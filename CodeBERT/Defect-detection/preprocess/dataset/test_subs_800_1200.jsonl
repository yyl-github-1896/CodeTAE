{"project": "FFmpeg", "commit_id": "08a747afb98c11da48b89339c2f1c5fdc56ced7e", "target": 0, "func": "static void count_frame_bits_fixed(AC3EncodeContext *s)\n\n{\n\n    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };\n\n    int blk;\n\n    int frame_bits;\n\n\n\n    /* assumptions:\n\n     *   no dynamic range codes\n\n     *   bit allocation parameters do not change between blocks\n\n     *   no delta bit allocation\n\n     *   no skipped data\n\n     *   no auxilliary data\n\n     *   no E-AC-3 metadata\n\n     */\n\n\n\n    /* header */\n\n    frame_bits = 16; /* sync info */\n\n    if (s->eac3) {\n\n        /* bitstream info header */\n\n        frame_bits += 35;\n\n        frame_bits += 1 + 1 + 1;\n\n        /* audio frame header */\n\n        frame_bits += 2;\n\n        frame_bits += 10;\n\n        /* exponent strategy */\n\n        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)\n\n            frame_bits += 2 * s->fbw_channels + s->lfe_on;\n\n        /* converter exponent strategy */\n\n        frame_bits += s->fbw_channels * 5;\n\n        /* snr offsets */\n\n        frame_bits += 10;\n\n        /* block start info */\n\n        frame_bits++;\n\n    } else {\n\n        frame_bits += 49;\n\n        frame_bits += frame_bits_inc[s->channel_mode];\n\n    }\n\n\n\n    /* audio blocks */\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        if (!s->eac3) {\n\n            /* block switch flags */\n\n            frame_bits += s->fbw_channels;\n\n\n\n            /* dither flags */\n\n            frame_bits += s->fbw_channels;\n\n        }\n\n\n\n        /* dynamic range */\n\n        frame_bits++;\n\n\n\n        /* spectral extension */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* exponent strategy */\n\n            frame_bits += 2 * s->fbw_channels;\n\n            if (s->lfe_on)\n\n                frame_bits++;\n\n\n\n            /* bit allocation params */\n\n            frame_bits++;\n\n            if (!blk)\n\n                frame_bits += 2 + 2 + 2 + 2 + 3;\n\n        }\n\n\n\n        /* converter snr offset */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* delta bit allocation */\n\n            frame_bits++;\n\n\n\n            /* skipped data */\n\n            frame_bits++;\n\n        }\n\n    }\n\n\n\n    /* auxiliary data */\n\n    frame_bits++;\n\n\n\n    /* CRC */\n\n    frame_bits += 1 + 16;\n\n\n\n    s->frame_bits_fixed = frame_bits;\n\n}\n", "idx": 8181, "substitutes": {"s": ["l", "session", "its", "is", "m", "t", "x", "gs", "v", "bis", "full", "ans", "ns", "hs", "spec", "self", "comm", "sg", "ds", "n", "si", "sites", "your", "sf", "b", "i", "c", "e", "sq", "us", "f", "sym", "sets", "es", "ic", "sup", "sis", "this", "u", "as", "comments", "fs", "su", "ps", "site", "ss", "g", "features", "stats", "small", "d", "data", "ls", "os", "same", "cs", "o", "sync", "south", "new", "sb", "sys", "side", "a", "ssl", "conf", "ts", "in", "the", "service", "p", "server", "qs", "xs", "rs", "js", "an", "S", "states", "services", "less", "h", "ses", "y"], "frame_bits_inc": ["frame_bit_ins", "frame_bits_enc", "frame_bit_rec", "frame_bits_dec", "frame_bit_enc", "frame_bits2in", "frame_bits_ins", "frame_bits2inc", "frame_bits_rec", "frame_bit_in", "frame_bits2dec", "frame_bit_inc", "frame_bits_in", "frame_bits2ins", "frame_bit_dec"], "blk": ["plks", "BLc", " blK", "BLq", "slq", "plkt", "clK", "BLK", "slc", "belk", " blmk", "blb", "blK", "Blk", "slkt", "plck", " blq", "blku", "flb", "belck", "slb", "flku", " blc", "blq", "BLck", "ylk", "clck", "plku", "plc", "plok", "blok", "clok", "plb", "Blks", "blck", "blks", " blck", " blok", "slok", "clk", "slks", "Blq", "BLok", "belku", "Blmk", " blks", "ylks", "BLk", "ylck", " blkt", "ylmk", "blkt", "blmk", "Blck", " blb", "belb", "slk", "flk", "blc", "plk", "flck", "plq"], "frame_bits": ["frame_pieces", "frame_bit", "fram67bits", " frame_planes", "frame64bits", "framexbits", " frame_mins", "sequence_bits", "fram_planes", "frame_parts", "frame_lines", "framexbugs", " frame_fits", "frame67pins", " frame_pins", "frame64bytes", " frame_pieces", "frame67pieces", "motion_hours", "frame_hours", " frame_locks", "frame_its", "motion_bits", "frame67locks", " frame_parts", " frame_dates", "frame67its", "image_bits", "frame_checks", " frame_overs", "frame_holes", "frame_fixes", " frame_bytes", "frame_overs", "frame33lins", " frame_ints", "fram_lins", "framexovers", "sequence_checks", " frame_hours", "fram_locks", "frame___bits", "frame_dates", "image_parts", "frame___bugs", "sequence_bugs", "frame_abs", "frame_flags", "frame_planes", "frame___pieces", "frame_bars", "frame33bits", "frame___planes", " frame_tops", "motion_planes", "motion_flags", "frame_tops", "fram67lins", "frame_ints", " frame_details", " frame_lines", "frame_details", "image_nos", "frame67tops", "frame67parts", " frame_nos", " frame_its", " frame_abs", "frame64mins", "frame_mins", "frame_fits", "frame_nos", "scene_bits", "scene_lins", "scene_effects", "frame_lins", " frame_holes", " frame_bars", "framexbytes", "frame_locks", "frame_effects", " frame_fixes", " frame_bugs", "frame67bits", "frame_bytes", "frame33effects", "frame64lines", " frame_bit", "frame_bugs", "frame67lins", "fram_bits", "fram67locks", "frame_pins"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 8197, "substitutes": {"pix": ["mip", " pixel", "cixel", "fix", "mrc", " pixels", "prc", "Pix", "pixel", "pip", "fixels", "fixel", "cix", "cixels", "pixels", " prc", "crc", "frc", "Pip", "mixels", "fip", "mixel", " pip", "Pixels", "mix", "Pixel"], "stride": ["erride", "strade", "errade", "strane", " strane", "drane", "brice", "drides", "Stride", "errider", " strided", " strade", "brided", "brpe", "Strided", " strider", " strpe", "strider", "bride", "striding", "Strpe", "strides", "erriding", "drided", " strice", " striding", "Strice", "strice", "brane", " strides", "drider", "strided", "brides", "driding", "drade", "strpe", "dride"], "bS": ["basDS", "abAs", " bSu", " bIS", " bSS", "baseEs", "lS", "bIS", "lEs", " bParts", "abC", " bSc", "fS", "BSC", "bSl", "fIS", "abDS", "bWS", "fSS", "aS", "BC", " bEs", " bC", "bDS", " bP", " bV", "fSc", "pWS", "baseD", "aV", " bAs", "abSC", "bD", " bCS", "lSu", " bSl", "lD", "fP", "BSl", "bC", "aP", " bDS", "pS", "bAs", "bSu", "basAs", "bSS", "BS", "bSc", "abS", "pP", "abCS", "bV", "bSC", "baseSu", "baseS", "basS", "basCS", "pParts", "fV", " bSC", "bParts", "bEs", "abSl", " bD", "bP", "bCS", " bWS"], "qp": ["qups", "qup", "calc", "sqc", "calp", "sqtp", "qt", "qlp", "qP", "caln", "qtp", "sqn", "qulp", "qps", "qpm", "eqt", "quP", "qn", "Qps", "quc", "qun", " Qpm", "eqp", "sqt", "Qp", "eqtp", "qutp", "sqlp", "eqc", " Qp", "qut", "QP", "Qpm", " QP", " Qps", "callp", "qc", "qupm", "sqp"], "h": ["l", "hi", "sh", "he", "ht", "html", "dh", "han", "g", "php", "ph", "hr", "hh", "w", "m", "conn", "http", "t", "b", "d", "history", "c", "s", "p", "hm", "e", "gh", "q", "eh", "hw", "f", "host", "zh", "ha", "v", "ih", "bh", "r", "ctx", "hess", "hp", "hs", "oh", "hub", "hd", "u", "H", "self", "hl", "api", "header", "ah", "ch", "rh", "uh"], "tc": ["uca", "asc", "term", "ui", "bb", "ta", "ul", "cases", "temp", "t", "tt", "toc", "tu", "c", "cum", "config", "pb", "cu", "ace", "gb", "Beta", "cb", "ec", "loc", "tmp", "bc", "ac", "cc", "binary", "cs", "ctrl", "tf", "cus", "index", "contract", "rc", "ic", "cas", "ctx", "tx", "gam", "margin", "TC", "tk", "dc", "pc", "xc", "tm", "type", "nc", "icc", "ca", "ci", " TC", "css", "lc", "cache", "beta", "mc", "uc", "sc", "acc", "fc"]}}
{"project": "FFmpeg", "commit_id": "ac66834c759b7130fb5be51f63cb6dff9b294cba", "target": 0, "func": "int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,\n\n                         int *frame_size_ptr,\n\n                         uint8_t *buf, int buf_size)\n\n{\n\n    int ret;\n\n\n\n    *frame_size_ptr= 0;\n\n    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){\n\n        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,\n\n                                buf, buf_size);\n\n        avctx->frame_number++;\n\n    }else\n\n        ret= 0;\n\n    return ret;\n\n}\n", "idx": 8199, "substitutes": {"avctx": ["afctx", " avcci", "AVcf", "avcmp", "avebc", "aphctx", "avbc", "avecmp", "avectx", "afcmp", "aphcf", "awcontext", "avcf", " avcmp", "AVloc", "AVcontext", "afcf", "aveconfig", " avgpu", " avsc", "afconfig", "afcci", "AVctx", "awbc", "avconfig", " avcontext", "afbc", "avsc", "afsc", "avcontext", "awctx", "avcci", "aphloc", "afloc", "avca", "afca", "avecci", "awca", "aphcontext", "avecontext", "aveca", "afgpu", "afcontext", "avgpu", " avconfig", "avegpu", "avesc", " avbc", "avloc"], "samples": ["sample", "nources", "ssample", "sesources", "sannels", "ssamps", "Samples", "sesamples", "Samps", " sources", "Sample", "sesannels", "sources", "Sources", " sannels", "ssources", "ssamples", "sesample", " sample", "nample", "namples", " samps", "nannels", "samps"], "frame_size_ptr": ["frame_size_ref", "frame_size_pointer", "frame_size_offset", "frame_size_inter", "frame_size_size", "frame_size_32", "frame_size_addr"], "buf": ["bag", "uf", "seq", "bb", "lim", "src", "fd", "b", "wb", "wav", "pool", "data", "fb", "batch", "config", "bd", "pb", "cb", "queue", "cf", "rb", "loc", "tmp", "bc", "f", "bf", "alloc", "cv", "ctx", "port", "blocks", "bytes", "vec", "buff", "buffer", "uc"], "buf_size": ["buflenadjust", "window_offset", "buflexsize", "buflexsized", "buf_capacity", "bufdnumber", "veclexsum", "buflensized", "veclexsize", "window_size", "bufdoffset", "buf64size", "bufamadjust", "buf_body", "buflensize", "bufdsize", "windowdsize", "bufrsize", "bufrnumber", "buflexsum", "border_size", "borderamcapacity", "buf_iz", "borderamiz", "vec_body", "window_number", "border_adjust", "bufamiz", "vec_sized", "buf_number", "bufroffset", "buf64capacity", "buflenbody", "veclexsized", "borderamadjust", "buf64adjust", "border_iz", "buf_offset", "bufamcapacity", "vec_sum", "vec_size", "buf64iz", "buf_sum", "bufleniz", "border_capacity", "borderamsize", "bufamsize", "buf_sized", "buflensum", "veclexbody", "buflencapacity", "buflexbody", "buf_adjust", "windowdnumber", "windowdoffset"], "ret": ["arr", "valid", "flag", "active", "ext", "len", "val", "alt", "def", "nt", "Ret", "num", " Ret", "data", "reply", "addr", "ref", "arg", "lit", "reg", "rets", "f", "code", "rt", "res", "bf", "det", "al", "rc", "fun", "att", "afe", "art", "sb", "offset", "bit", "fin", "cat", "re", "xt", "RET", "back", "result", "ft", "match", "rev", "resp", "mt", "success"], "frame_number": ["frameingno", "seqingindex", "seq_index", "frameingnumber", "frame_index", "seq_number", "frameingindex", "seq_no", "seqingnumber", "frame_no", "frame_Number", "seqingno", "seqingNumber", "frameingNumber", "seq_Number"]}}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n\n                    int mb_x, int mb_y, int layout)\n\n{\n\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n\n                                  mb - 1 /* left */,\n\n                                  0      /* top-left */ };\n\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n\n    int idx = CNT_ZERO;\n\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n\n    int8_t *sign_bias = s->sign_bias;\n\n    VP56mv near_mv[4];\n\n    uint8_t cnt[4] = { 0 };\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n\n        mb_edge[0] = mb + 2;\n\n        mb_edge[2] = mb + 1;\n\n    } else {\n\n        mb_edge[0] = mb - s->mb_width - 1;\n\n        mb_edge[2] = mb - s->mb_width - 2;\n\n    }\n\n\n\n    AV_ZERO32(&near_mv[0]);\n\n    AV_ZERO32(&near_mv[1]);\n\n    AV_ZERO32(&near_mv[2]);\n\n\n\n    /* Process MB on top, left and top-left */\n\n#define MV_EDGE_CHECK(n)                                                      \\\n\n    {                                                                         \\\n\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n\n        int edge_ref = edge->ref_frame;                                       \\\n\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n\n            if (mv) {                                                         \\\n\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n\n                    /* SWAR negate of the values in mv. */                    \\\n\n                    mv = ~mv;                                                 \\\n\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n\n                }                                                             \\\n\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n\n                cnt[idx] += 1 + (n != 2);                                     \\\n\n            } else                                                            \\\n\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n\n        }                                                                     \\\n\n    }\n\n\n\n    MV_EDGE_CHECK(0)\n\n    MV_EDGE_CHECK(1)\n\n    MV_EDGE_CHECK(2)\n\n\n\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n\n        mb->mode = VP8_MVMODE_MV;\n\n\n\n        /* If we have three distinct MVs, merge first and last if they're the same */\n\n        if (cnt[CNT_SPLITMV] &&\n\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n\n            cnt[CNT_NEAREST] += 1;\n\n\n\n        /* Swap near and nearest if necessary */\n\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n\n        }\n\n\n\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n", "idx": 8208, "substitutes": {"s": ["l", "session", "sg", "ds", "n", "si", "g", "is", "shell", "sf", "w", "m", "b", "t", "x", "sci", "d", "i", "gs", "service", "sa", "iss", "p", "server", "e", "se", "sq", "js", "f", "cs", "o", "size", "S", "v", "sync", "space", "south", "sie", "sl", "services", "state", "support", "ns", "sb", "spec", "h", "sim", "single", "side", "client", "ses", "fs", "a", "ss", "y", "settings", "ssl", "sc"], "mb": ["ym", "GB", "mac", "ib", "byte", "base", "bb", "mn", "em", "pg", "nb", "ph", "media", "m", "bp", "b", "mm", "wb", "MB", "big", "vm", "fb", "ref", "meta", "pb", "gb", "MP", "machine", "rb", "loc", "pm", "large", "bc", "nm", "mode", "db", "bf", "mp", "eb", "bound", "mx", "mi", "md", "lb", "mod", "mag", "sb", "ms", "mph", "emb", "cm", "meg", "ob", "url", "image", "mt", " MB", "mop", "um", "cmd", "mc", "om", "kb"], "mb_x": ["MB_index", "MB_width", "mb_index", "MB_y", "mb_width", "MB_x"], "mb_y": ["MB_z", "MB_y", "MB_x", "mb_z"], "layout": ["scroll", "l", "orient", "center", "scale", "Layout", "def", "id", "num", "z", "block", "config", "draw", "qa", "cb", "local", "np", "style", "loc", "sq", "f", "mode", "design", "shape", "nd", "sync", "cl", "dc", "position", "offset", "form", "layer", "nl", "nc", "h", "loop", "cell", "lc", "flat", "adj", "nn", "fc"], "mb_edge": ["mp_ide", "bb_close", "mp_edge", "MB_edge", "mb_ge", "mb_slice", "bb_ide", "bb_edge", "MB_connection", "bb_scale", "bb_gate", "MB_ide", "bb_slice", "mb_close", "mb_ide", "mp_line", "MB_ge", "mb_connection", "bb_connection", "mb_scale", "mb_pad", "mb_line", "bb_pad", "mp_slice", "mb_gate"], "sign_bias": ["sign_abare", "sign_biias", "sign_burius", "sign_cias", "sign_abias", "sign_abature", "sign_bature", "sign_blases", "sign_bary", "sign_abases", "sign_Base", "sign_abinding", "sign_burinding", "sign_bases", "sign_gare", "sign_biases", "sign_binding", "sign_gias", "sign_blinding", "sign_gases", "sign_Bare", "sign_biature", "sign_cases", "sign_cature", "sign_biary", "sign_abase", "sign_Bases", "sign_blias", "sign_blius", "sign_base", "sign_Bias", "sign_bius", "sign_abius", "sign_burases", "sign_gase", "sign_burias", "sign_bare", "sign_abary", "sign_cary"], "near_mv": ["near_vmvg", "near_mf", "near_mmx", "near_mb", "near_mver", "near_mj", "near_cmh", "near_bvg", "near_cmvs", "near_cmvm", "near_rh", "near_mx", "near_mmf", "near_tx", "near_Mf", "near_mq", "near_tv", "near_Mver", "near_Mv", "near_mmvs", "near_pv", "near_mmV", "near_vmV", "near_mmb", "near_mvs", "near_cmx", "near_mV", "near_vmj", "near_vmv", "near_mmv", "near_mmver", "near_cmv", "near_mh", "near_bV", "near_pf", "near_rq", "near_bv", "near_tvm", "near_pver", "near_cmq", "near_bj", "near_Mb", "near_rv", "near_tvs", "near_pb", "near_mmj", "near_mvm", "near_rx", "near_mmvm", "near_mmvg", "near_mvg"], "cnt": ["cnc", "lcnt", "bnc", "acct", "lcct", "bnt", "acrt", "acnt", "lcnc", "cct", "brt", "lcrt", "crt", "bct", "acnc"], "c": ["l", "arc", "channel", "C", "n", "g", "cil", "w", "conn", "m", "b", "t", "d", "con", "p", "e", "cu", "cf", "cn", "bc", "cc", "f", "cs", "cv", "connection", "r", "dc", "xc", "u", "nc", "h", "ca", "cm", "ci", "a", "ch", "lc", "jc", "cell", "mc", "uc", "cy", "sc", "chain"]}}
{"project": "qemu", "commit_id": "29851ee7c8bd3fb8542e21cd0270c73132590350", "target": 1, "func": "int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n", "idx": 8209, "substitutes": {"rd": ["ld", "rf", "dra", "rh", "cr", "ru", "RD", "std", "ds", "hr", "rw", "RF", "src", "mr", "rr", "fd", "rect", "rod", " dr", "ref", "rss", "rb", "rs", "lr", "dr", "xd", "nd", "rc", "erd", "RM", "r", "rid", "dd", "rn", "RT", "rx", "rg", "RR", "td", "rl", "rm"], "rt": ["rf", "ru", "td", "RD", "std", "tr", "test", "nt", "fr", "src", "rr", "rect", "vt", "ct", "ref", "attr", "dist", "ptr", "rb", "gt", "rs", "dr", "dat", "th", "rc", "r", "rid", "pr", "err", "art", "error", "rn", "vr", "rx", "rat", "ret", "ri", "rm", "RR", "rh", "rl", "RT"], "dsp": ["dp", "Dp", " dSp", "ldst", " dsc", "dst", "fdsp", "rSP", " dst", "fdsh", "Dsc", "fdst", "dsc", "rp", "rsp", "dsh", " dsh", "adSp", "Dsp", " dp", " dsl", "Dsl", "ndst", "dsl", " dSP", "ldsc", "ndsp", "ndSP", "ldSp", "adsp", "Dst", "adsh", "adsl", "ldsp", "adp", "ldp", "fdsc", "dSp", "adst", "dSP", "rst", "ndp", "adsc"], "result": ["parent", "round", "rf", "cr", "ru", "score", "Result", "tr", "test", "record", "rr", "rest", "rect", "ver", "var", "data", "rule", "rb", "array", "df", "db", "resource", "res", "order", "rc", "response", "feature", "r", "results", "err", "desc", "error", "rar", "root", "rx", "report", "der", "ret", "match", "sr", "replace", "ri", "rh", "success", "range", "runner"], "resultdsp": ["resultadsp", "matchDsp", "resultpdisp", "resultidsh", " resultDsc", "resultdsc", "resultadsc", "resultadst", "resultidsp", " resultdisp", "matchdsh", "matchdsr", "resultidpe", " resultfst", "resultDsc", "resultdisp", "resultDsp", "matchDsh", "resultpdsl", " resultdsl", "resultdsl", "resultDpe", "resultdst", "resultfsl", "resultadsl", "resultadisp", "resultpdsp", "resultDisp", "matchdsp", "resultfst", " resultDisp", "resultdpe", "resultidsr", "resultDsh", " resultDsl", "resultfsp", "resultDsr", " resultDsp", "resultdsh", "matchDpe", "resultpdsc", " resultfsl", "resultDsl", " resultdsc", "matchDsr", "matchdpe", " resultfsp", " resultdst", "resultdsr"]}}
{"project": "FFmpeg", "commit_id": "eb24fd64589b7eea91fa752861f0c6f07e5a48a8", "target": 0, "func": "int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n\n{\n\n    int count, x;\n\n    uint8_t *out;\n\n\n\n    out = outbuf;\n\n\n\n\n\n        for(x = 0; x < w; x += count) {\n\n            /* see if we can encode the next set of pixels with RLE */\n\n            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n\n                if(out + bpp + 1 > outbuf + out_size) return -1;\n\n                *out++ = (count ^ xor) + add;\n\n                memcpy(out, ptr, bpp);\n\n                out += bpp;\n\n            } else {\n\n                /* fall back on uncompressed */\n\n                count = count_pixels(ptr, w-x, bpp, 0);\n\n                *out++ = count - 1;\n\n\n\n                if(out + bpp*count > outbuf + out_size) return -1;\n\n                memcpy(out, ptr, bpp * count);\n\n                out += bpp * count;\n\n        }\n\n\n\n        ptr += count * bpp;\n\n    }\n\n\n\n    return out - outbuf;\n\n}\n", "idx": 8211, "substitutes": {"outbuf": ["tempqueue", "outputcb", "Outbuf", " outbuffer", "outcb", "upfac", "upbuffer", "inbuf", "againcb", " outbuff", "outerbuffer", "bitfac", "incb", "offbuffer", "outputbuf", "offuf", "offbuf", " outfac", "Outqueue", "againuf", "outfile", "tempbuf", "againbuf", "outuf", " outfile", " outqueue", "outbuffer", "tempuf", "tempbuffer", "Outbuffer", "bitcb", "outbuff", "infile", "outerfile", "upbuf", "bitbuffer", "Outuf", "outfac", " outcb", "outputbuff", " outuf", "outqueue", "againbuffer", "bitbuf", "offcb", "upcb", "outputbuffer", "inbuffer", "outerbuf", "inbuff", "outerbuff"], "out_size": ["out_address", "in_shape", "out__uri", "out64address", "out64shape", "in_size", "out__scale", "out_uri", "image_uri", "out__space", "outlogaddress", "in_address", "out_space", "out_shape", "image_size", "image_max", "out__size", "out__max", "out_length", "out_scale", "out_max", "image_length", "outlogshape", "image_space", "out__length", "out64size", "outlogsize", "image_scale"], "ptr": ["later", "Ptr", "sh", "up", "cmp", "ext", "tr", "str", "xp", "depth", "pad", "rw", "inter", "src", "temp", "mount", "pty", "tty", "pp", "buf", "pointer", "shift", "addr", "p", "ref", "attr", "fp", "pt", "plug", "loc", "tmp", "dr", "inst", "code", "slice", "alloc", "trace", "ctr", "ind", "rc", "r", "pr", "pre", "address", "err", "port", "ctx", "cur", "req", "patch", "pc", "offset", "pair", "pos", "length", "ch", "proc", "br", "buffer", "per"], "bpp": ["lpp", "lbpo", "lbcp", "bpped", "lbpar", "wbpp", " bsp", "barpp", "bact", "bapc", " bppa", "sbpp", " bcp", "abpp", "lbpp", "bpps", "hpp", "fpl", "bcp", "pppa", "cpp", "brppa", "wbpps", "brpp", "bpc", "lpper", "lep", "wbppa", "brpped", "bep", " bpc", "bpl", "npp", " bpar", "ppped", "sbact", " bpped", "brmp", "dbupp", "sbsp", "brpper", "lbpc", "hppa", "bppa", "rpp", "rep", "rppa", "bpo", "lupp", "bsp", "barupp", "dbpp", "hpl", "psp", "wbupp", "bpar", "pupp", "pep", "nsp", "abpped", "cep", "lmp", "rpl", "ppl", "pact", "bapo", "dbpl", "brep", "lpped", "bapped", "abcp", "bbep", " bpo", "cpped", "brupp", " bact", "sbppa", "bupp", "nppa", "ppp", "barppa", "fupp", "cupp", "bapp", "abpar", "bbpp", "barpps", "bbmp", " bpl", "fpo", "bmp", "bpper", " bpps", "lbpped", "fpp", " bupp", "bbpper", "dbpo", "npl", "hep"], "w": ["l", "wl", "wp", "n", "g", "wa", "win", "window", "m", "temp", "iw", "b", "sw", "z", "fw", "wb", "d", "wt", "t", "c", "s", "work", "p", "wd", "we", "max", "q", "wal", "hw", "f", "o", "v", "r", "wx", "aw", "kw", "wu", "u", "ww", "h", "ew", "a", "y", "W", "ow"], "add": ["diff", "arr", "ack", "plus", "start", "len", "pad", "mult", "added", "each", "d", "shift", "last", "ad", "sum", "c", "addr", "max", "app", "push", "ac", "call", "append", "inc", "ind", "end", "apply", "att", "mod", "address", "en", "load", "Add", "read", "init", "pos", "comp", "extra", "mix", "ADD"], "xor": ["yors", "Xnor", " xors", " xOR", "exr", "xOR", "ynor", "xr", "exors", " xnor", "exore", "XOR", "xtors", "xnor", "yor", " xr", "Xors", "xtore", "xtor", " xore", "xors", "Xor", "xtr", "yOR", "exor", "xore"], "count": ["l", "parent", "base", "find", "z", "sum", "max", "ref", "act", "cc", "ac", "code", "call", "found", "v", "process", "offset", "type", "depth", "ount", "scroll", "cond", "filter", "n", "val", "key", "all", "id", "missing", "b", "i", "con", "c", "ct", "e", "cd", "f", "index", "ind", "current", "list", "cast", "col", "Count", "ch", "len", "num", "d", "coll", "size", "part", "cat", "cache", "weight", "start", "time", "p", "number", "q", "child", "name", "check", "counter", "h", "length", "y", "match"], "x": ["xp", "plus", "n", "val", "wa", "in", "ax", "xx", "xi", "m", "id", "t", "sw", "z", "b", "d", "i", "c", "ct", "s", "X", "p", "ix", "el", "e", "pe", "xs", "f", "j", "code", "call", "index", "v", "min", "content", "fx", "ctx", "r", "tx", "en", "wx", "xc", "xes", "bit", "xt", "u", "ww", "pair", "h", "rx", "on", "px", "y", "dx", "ex"], "out": ["parent", "base", " in", "again", "word", "point", "t", "pool", "block", "sum", "max", "at", "ac", "code", "call", "v", "connection", "att", "err", "init", "image", "buffer", "up", "n", "prefix", "no", "Out", "b", "c", "work", "output", "tmp", "op", "index", "r", "error", "wx", "extra", "ext", "g", "temp", "conn", "page", "data", "o", "sync", "req", "new", "OUT", "part", "copy", "a", "cache", "result", "cmd", "diff", "byte", "co", "in", "update", "doc", "line", "p", "obj", "off", "child", "inc", "name", "user", "bit", "client", "bin", "ex"]}}
{"project": "FFmpeg", "commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "target": 1, "func": "static int vdpau_frames_init(AVHWFramesContext *ctx)\n\n{\n\n    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;\n\n    VDPAUFramesContext        *priv = ctx->internal->priv;\n\n\n\n    int i;\n\n\n\n    switch (ctx->sw_format) {\n\n    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;\n\n    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;\n\n    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported data layout: %s\\n\",\n\n               av_get_pix_fmt_name(ctx->sw_format));\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {\n\n        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {\n\n            priv->chroma_idx  = i;\n\n            priv->pix_fmts    = device_priv->pix_fmts[i];\n\n            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];\n\n            break;\n\n        }\n\n    }\n\n    if (!priv->pix_fmts) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported chroma type: %d\\n\", priv->chroma_type);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (!ctx->pool) {\n\n        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,\n\n                                                            vdpau_pool_alloc, NULL);\n\n        if (!ctx->internal->pool_internal)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    priv->get_data = device_priv->get_data;\n\n    priv->put_data = device_priv->put_data;\n\n\n\n    return 0;\n\n}\n", "idx": 8217, "substitutes": {"ctx": ["parent", "cdn", "mac", "conf", "co", "cam", "context", "cmp", "cci", "Context", "media", "cca", "conn", "tc", "cz", "auc", "sci", "c", "ct", "cp", "config", "cu", "qa", "cb", "cli", "cf", "cn", "wcs", "act", "loc", "coll", "hw", "cc", "bc", "cs", "ctrl", "cv", "ck", "ce", "sync", "cas", "voc", "conv", "ga", "tx", "acl", "pc", "xc", "kw", "cms", "concept", "nc", "gc", "cm", "ca", "ocr", "client", "ci", " context", "sys", "vc", "anc", "cmd", "crit", "pkg", "lc", "cus", "kb", "sc", "exec"], "device_priv": ["devicealpriv", " device_private", "deviceCpriv", " device_public", "device_private", "device_dat", "deviceingpriv", "deviceingpublic", "deviceJprivate", "device_size", "devicePpriv", " device_size", "device_pub", "deviceJpriv", " device_pub", "devicePpub", "deviceCpublic", "device_riv", "devicealpub", "deviceingpub", "device_public", "package_cert", " device_dat", "devicePprivate", "device_data", "deviceingriv", "deviceCprivate", " device_access", "deviceCaccess", "deviceJcert", "devicePdata", "package_private", "device_cert", "deviceJneg", "devicealsize", " device_riv", "package_priv", " device_data", "device_access", "device_neg", "devicealdat", "package_neg"], "priv": ["por", "tr", "access", "auth", "rw", "org", "pred", "vt", "config", "rib", "pb", "cb", "attr", "txt", "sk", "fam", "state", "err", "prep", "ca", "buff", "ocr", "ee", "rate", "prem", "gr", "pro", "or", "prop", "Priv", "voc", "ty", "storage", "impl", "aud", "ch", "anc", "fee", "exec", "prof", "conn", "usa", "temp", "consumer", "public", "cer", "stat", "cp", "data", "pri", "util", "gb", "mini", "ptr", "riv", "coll", "cs", "progress", "alloc", "rc", "sta", "req", "neg", "tx", "pi", "kw", "allow", "dev", "cache", "vc", "uc", "ki", "conf", "comment", "info", "auc", "p", "reader", "private", "sec", "pub", "cert", "inner", "raf", "cfg", "client", "soc", "ci", "api", "fac", "proc", "roc", "typ", "cy"], "i": ["count", "oi", "diff", "l", "hi", "ui", "di", "it", "start", "n", "si", "in", "zi", "adi", "id", "m", "xi", "info", "temp", "k", "t", "ini", "x", "b", "d", "c", "ji", "s", "block", "uri", "p", "e", "yi", "cli", "mu", "esi", "f", "ie", "j", "code", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "ind", "mi", "phi", "chi", "qi", "pi", "bi", "ii", "idi", "u", "type", "I", "li", "ip", "ci", "api", "io", "lc", "y", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}", "idx": 8221, "substitutes": {"state": ["parent", "l", "session", "State", "start", "si", "str", "class", "statement", "id", "m", "info", "instance", "i", "data", "c", "s", "config", "p", "rule", "e", "status", "ace", "request", "se", "STATE", "style", "er", "f", "j", "code", "resource", "call", "slice", "al", "parse", "scope", "name", "states", "address", "port", "part", "grade", "this", "type", "self", "use", "cache"]}}
{"project": "FFmpeg", "commit_id": "801c39e1e3058fc4ba822bfb5d8612d777111e32", "target": 0, "func": "static int dca_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    AVFrame *frame     = data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    int lfe_samples;\n\n    int num_core_channels = 0;\n\n    int i, ret;\n\n    float  **samples_flt;\n\n    DCAContext *s = avctx->priv_data;\n\n    int channels, full_channels;\n\n    int core_ss_end;\n\n\n\n\n\n    s->xch_present = 0;\n\n\n\n    s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer,\n\n                                                  DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE);\n\n    if (s->dca_buffer_size == AVERROR_INVALIDDATA) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Not a valid DCA frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8);\n\n    if ((ret = dca_parse_frame_header(s)) < 0) {\n\n        //seems like the frame is corrupt, try with the next one\n\n        return ret;\n\n    }\n\n    //set AVCodec values with parsed data\n\n    avctx->sample_rate = s->sample_rate;\n\n    avctx->bit_rate    = s->bit_rate;\n\n\n\n    s->profile = FF_PROFILE_DTS;\n\n\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        if ((ret = dca_decode_block(s, 0, i))) {\n\n            av_log(avctx, AV_LOG_ERROR, \"error decoding block\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* record number of core channels incase less than max channels are requested */\n\n    num_core_channels = s->prim_channels;\n\n\n\n    if (s->ext_coding)\n\n        s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr];\n\n    else\n\n        s->core_ext_mask = 0;\n\n\n\n    core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8;\n\n\n\n    /* only scan for extensions if ext_descr was unknown or indicated a\n\n     * supported XCh extension */\n\n    if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) {\n\n\n\n        /* if ext_descr was unknown, clear s->core_ext_mask so that the\n\n         * extensions scan can fill it up */\n\n        s->core_ext_mask = FFMAX(s->core_ext_mask, 0);\n\n\n\n        /* extensions start at 32-bit boundaries into bitstream */\n\n        skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n\n\n        while (core_ss_end - get_bits_count(&s->gb) >= 32) {\n\n            uint32_t bits = get_bits_long(&s->gb, 32);\n\n\n\n            switch (bits) {\n\n            case 0x5a5a5a5a: {\n\n                int ext_amode, xch_fsize;\n\n\n\n                s->xch_base_channel = s->prim_channels;\n\n\n\n                /* validate sync word using XCHFSIZE field */\n\n                xch_fsize = show_bits(&s->gb, 10);\n\n                if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) &&\n\n                    (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1))\n\n                    continue;\n\n\n\n                /* skip length-to-end-of-frame field for the moment */\n\n                skip_bits(&s->gb, 10);\n\n\n\n                s->core_ext_mask |= DCA_EXT_XCH;\n\n\n\n                /* extension amode(number of channels in extension) should be 1 */\n\n                /* AFAIK XCh is not used for more channels */\n\n                if ((ext_amode = get_bits(&s->gb, 4)) != 1) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"XCh extension amode %d not\"\n\n                           \" supported!\\n\", ext_amode);\n\n                    continue;\n\n                }\n\n\n\n                /* much like core primary audio coding header */\n\n                dca_parse_audio_coding_header(s, s->xch_base_channel);\n\n\n\n                for (i = 0; i < (s->sample_blocks / 8); i++)\n\n                    if ((ret = dca_decode_block(s, s->xch_base_channel, i))) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error decoding XCh extension\\n\");\n\n                        continue;\n\n                    }\n\n\n\n                s->xch_present = 1;\n\n                break;\n\n            }\n\n            case 0x47004a03:\n\n                /* XXCh: extended channels */\n\n                /* usually found either in core or HD part in DTS-HD HRA streams,\n\n                 * but not in DTS-ES which contains XCh extensions instead */\n\n                s->core_ext_mask |= DCA_EXT_XXCH;\n\n                break;\n\n\n\n            case 0x1d95f262: {\n\n                int fsize96 = show_bits(&s->gb, 12) + 1;\n\n                if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96)\n\n                    continue;\n\n\n\n                av_log(avctx, AV_LOG_DEBUG, \"X96 extension found at %d bits\\n\",\n\n                       get_bits_count(&s->gb));\n\n                skip_bits(&s->gb, 12);\n\n                av_log(avctx, AV_LOG_DEBUG, \"FSIZE96 = %d bytes\\n\", fsize96);\n\n                av_log(avctx, AV_LOG_DEBUG, \"REVNO = %d\\n\", get_bits(&s->gb, 4));\n\n\n\n                s->core_ext_mask |= DCA_EXT_X96;\n\n                break;\n\n            }\n\n            }\n\n\n\n            skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n        }\n\n    } else {\n\n        /* no supported extensions, skip the rest of the core substream */\n\n        skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb));\n\n    }\n\n\n\n    if (s->core_ext_mask & DCA_EXT_X96)\n\n        s->profile = FF_PROFILE_DTS_96_24;\n\n    else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH))\n\n        s->profile = FF_PROFILE_DTS_ES;\n\n\n\n    /* check for ExSS (HD part) */\n\n    if (s->dca_buffer_size - s->frame_size > 32 &&\n\n        get_bits_long(&s->gb, 32) == DCA_HD_MARKER)\n\n        dca_exss_parse_header(s);\n\n\n\n    avctx->profile = s->profile;\n\n\n\n    full_channels = channels = s->prim_channels + !!s->lfe;\n\n\n\n    if (s->amode < 16) {\n\n        avctx->channel_layout = dca_core_channel_layout[s->amode];\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            /*\n\n             * Neither the core's auxiliary data nor our default tables contain\n\n             * downmix coefficients for the additional channel coded in the XCh\n\n             * extension, so when we're doing a Stereo downmix, don't decode it.\n\n             */\n\n            s->xch_disable = 1;\n\n        }\n\n\n\n#if FF_API_REQUEST_CHANNELS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        if (s->xch_present && !s->xch_disable &&\n\n            (!avctx->request_channels ||\n\n             avctx->request_channels > num_core_channels + !!s->lfe)) {\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#else\n\n        if (s->xch_present && !s->xch_disable) {\n\n#endif\n\n            avctx->channel_layout |= AV_CH_BACK_CENTER;\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode];\n\n            } else {\n\n                s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode];\n\n            }\n\n        } else {\n\n            channels = num_core_channels + !!s->lfe;\n\n            s->xch_present = 0; /* disable further xch processing */\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe[s->amode];\n\n            } else\n\n                s->channel_order_tab = dca_channel_reorder_nolfe[s->amode];\n\n        }\n\n\n\n        if (channels > !!s->lfe &&\n\n            s->channel_order_tab[channels - 1 - !!s->lfe] < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            channels = 2;\n\n            s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO;\n\n            avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n            /* Stereo downmix coefficients\n\n             *\n\n             * The decoder can only downmix to 2-channel, so we need to ensure\n\n             * embedded downmix coefficients are actually targeting 2-channel.\n\n             */\n\n            if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO ||\n\n                                    s->core_downmix_amode == DCA_STEREO_TOTAL)) {\n\n                int sign, code;\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][0] & 0x0FF;\n\n                    s->downmix_coef[i][0] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                    sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][1] & 0x0FF;\n\n                    s->downmix_coef[i][1] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                }\n\n                s->output = s->core_downmix_amode;\n\n            } else {\n\n                int am = s->amode & DCA_CHANNEL_MASK;\n\n                if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"Invalid channel mode %d\\n\", am);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                if (s->prim_channels + !!s->lfe >\n\n                    FF_ARRAY_ELEMS(dca_default_coeffs[0])) {\n\n                    avpriv_request_sample(s->avctx, \"Downmixing %d channels\",\n\n                                          s->prim_channels + !!s->lfe);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    s->downmix_coef[i][0] = dca_default_coeffs[am][i][0];\n\n                    s->downmix_coef[i][1] = dca_default_coeffs[am][i][1];\n\n                }\n\n            }\n\n            av_dlog(s->avctx, \"Stereo downmix coeffs:\\n\");\n\n            for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                av_dlog(s->avctx, \"L, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][0]);\n\n                av_dlog(s->avctx, \"R, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][1]);\n\n            }\n\n            av_dlog(s->avctx, \"\\n\");\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Non standard configuration %d !\\n\", s->amode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = channels;\n\n\n\n    /* get output buffer */\n\n    frame->nb_samples = 256 * (s->sample_blocks / 8);\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples_flt = (float **)frame->extended_data;\n\n\n\n    /* allocate buffer for extra channels if downmixing */\n\n    if (avctx->channels < full_channels) {\n\n        ret = av_samples_get_buffer_size(NULL, full_channels - channels,\n\n                                         frame->nb_samples,\n\n                                         avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        av_fast_malloc(&s->extra_channels_buffer,\n\n                       &s->extra_channels_buffer_size, ret);\n\n        if (!s->extra_channels_buffer)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL,\n\n                                     s->extra_channels_buffer,\n\n                                     full_channels - channels,\n\n                                     frame->nb_samples, avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    /* filter to get final output */\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        int ch;\n\n\n\n        for (ch = 0; ch < channels; ch++)\n\n            s->samples_chanptr[ch] = samples_flt[ch] + i * 256;\n\n        for (; ch < full_channels; ch++)\n\n            s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256;\n\n\n\n        dca_filter_channels(s, i);\n\n\n\n        /* If this was marked as a DTS-ES stream we need to subtract back- */\n\n        /* channel from SL & SR to remove matrixed back-channel signal */\n\n        if ((s->source_pcm_res & 1) && s->xch_present) {\n\n            float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]];\n\n            float *lt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]];\n\n            float *rt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]];\n\n            s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256);\n\n            s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256);\n\n        }\n\n    }\n\n\n\n    /* update lfe history */\n\n    lfe_samples = 2 * s->lfe * (s->sample_blocks / 8);\n\n    for (i = 0; i < 2 * s->lfe * 4; i++)\n\n        s->lfe_data[i] = s->lfe_data[i + lfe_samples];\n\n\n\n    /* AVMatrixEncoding\n\n     *\n\n     * DCA_STEREO_TOTAL (Lt/Rt) is equivalent to Dolby Surround */\n\n    ret = ff_side_data_update_matrix_encoding(frame,\n\n                                              (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ?\n\n                                              AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_frame_ptr = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 8241, "substitutes": {"avctx": [" avxc", "afconn", "afctx", "ajcas", "aircontext", "avelc", "Avconn", "AVxc", "varctx", "afcas", "evconfig", "avcp", "avectx", "awcontext", "avecu", "evcontext", "avsci", "AVcp", "avsq", "AVcontext", "avcu", "varsci", "awctrl", "awcas", "afcu", "airctx", "aveconfig", "aflc", "avconn", "AVlc", "ajctx", "ajcontext", "avlc", "afconfig", "AVctx", "AVconn", "avconfig", " avcontext", "Avxc", "avcontext", "awctx", "avxc", " avconn", "evconn", "afsq", "Avctx", "avctrl", "evcu", "evctx", "afsci", "avecp", "varcontext", "airsq", "aveconn", "avecontext", "airsci", "varsq", "afcontext", "ajctrl", "afcp", "afctrl", "avcas", "Avcontext"], "data": ["parent", "sample", "base", "start", "media", "window", "record", "da", "pad", "open", "d", "ad", "block", "batch", "p", "reader", "queue", "feed", "memory", "array", "empty", "body", "DATA", "f", "next", "primary", "padding", "dat", "device", "o", "size", "input", "content", "raw", "object", "audio", "Data", "bytes", "as", "pos", "message", "header", "a", "video", "image", "cache", "length", "buff", "buffer", "database"], "got_frame_ptr": ["got_frame64addr", "got_frame_size", "got_frames_ptr", "got_frame64pointer", "got_frames2pointer", "got_frame_pointer", "got_frame2pointer", "got_frame2addr", "got_frames2addr", "got_frame32pointer", "got_frame32ptr", "got_frame32size", "got_frame64size", "got_frames2ptr", "got_frame64ptr", "got_frame32addr", "got_frame_addr", "got_frames_pointer", "got_frame2size", "got_frame2ptr", "got_frames_addr", "got_frames2size", "got_frames_size"], "avpkt": ["avcpKT", "avbKT", "avbpft", "afpacket", "afpka", "avfka", "afcpKT", "affka", "avpacket", "avfacket", "avspacket", "afcput", "affacket", " avpct", " avpke", " avcpct", " avpft", "avspke", " avcpkt", "avfkt", "avPct", "afcpkt", "avpft", "afcpct", "avPut", "avbpacket", "avPkt", "avpke", "avspkt", "afpke", "avbkt", "afput", "avcpkt", "avcpke", "avbct", "avpct", "avbpke", "avspka", "avcpct", "avbut", "afpkt", "afpct", "avpKT", "avcpft", "avput", "affkt", "avPft", " avcpke", " avcpft", "avbpka", "avcput", "avbpkt", "avfke", "afpKT", "avbpct", "avPKT", "avPke", "avpka", "affke"], "frame": ["setup", "session", "seq", "Frame", "frames", "window", "def", "m", "board", "fr", "b", "block", "fb", "config", "p", "e", "cf", "flow", "body", "f", "slice", "series", "iframe", "object", "row", "image", "buffer"], "buf": ["bag", "uf", "map", "seq", "img", "window", "pad", "src", "bm", "b", "fd", "pool", "block", "fb", "batch", "p", "ref", "pb", "cb", "fp", "queue", "rb", "array", "bc", "f", "alloc", "cv", "conv", "vec", "buff", "cmd", "br", "buffer", "uc"], "lfe_samples": [" exe_sannels", " exe_samples", " exe_namples", " exe_sones", " exe_gones", " exe_seamples", " exe_seannels", " exe_nample", " exe_nannels", " exe_seample", " exe_gample", " exe_gamples", " exe_sample", " exe_gannels", " exe_seones", " exe_nones"], "i": ["oi", "hi", "ui", "dim", "di", "base", "it", "start", "si", "n", "is", "zi", "info", "xi", "id", "k", "x", "ini", "z", "b", "t", "c", "p", "ix", "uri", "mu", "yi", "split", "mini", "eni", "f", "j", "ai", "multi", "index", "v", "gi", "ti", "mi", "phi", "chi", "abi", "qi", "pi", "bi", "part", "ii", "uni", "idi", "u", "I", "li", "ip", "ci", "ni", "io", "fi", "iu", "ki"], "ret": ["rf", "arr", "pass", "bad", "valid", "flag", "alt", "val", "len", "fail", "def", "nt", "info", "Ret", "mem", "red", "reply", "ref", "arg", "lit", "obj", "status", "reg", "value", "rets", "f", "rt", "res", "det", "fun", "att", "quiet", "bot", "en", "err", "r", "sb", "error", "bit", "cat", "re", "RET", "back", "let", "result", "rev", "match", "resp", "ft", "url", "success", "fab", "reset"], "samples_flt": ["samples_fmt", "samples_sfmt", "samples_sflt", "samples_Fls", "samples_rfmt", "samples_finite", "samples_rflt", "samples_Flt", "samples_rfinite", "samples_rfls", "samples_fls", "samples_sfinite", "samples_Finite", "samples_sfls", "samples_Fmt"], "s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "plugins", "v", "bis", "ns", "hs", "details", "spec", "self", "params", "settings", "sg", "ds", "si", "n", "sf", "b", "c", "e", "se", "args", "sq", "us", "f", "sym", "sets", "es", "r", "nas", "storage", "as", "this", "rates", "comments", "ps", "su", "site", "fs", "ss", "ks", "sv", "g", "features", "ops", "d", "stat", "sa", "ls", "os", "cs", "sync", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "vs", "conf", "ts", "info", "service", "p", "qs", "ins", "xs", "rs", "js", "aws", "S", "services", "ctx", "h", "ses", "uns", "css"], "channels": ["Chapters", "Channels", "shords", "shannels", "shapters", "ichords", "Chores", "shores", "chords", "Chords", "chapters", "ichores", "chores", "ichapters", "ichannels"], "full_channels": ["full_zannels", "full_Chategories", "full_Chars", "full_hars", "full_chars", "full_chunks", "full_hannels", "full_Chunks", "full_Channels", "full_chategories", "full_hategories", "full_zunks", "full_zars", "full_hunks", "full_zategories"], "core_ss_end": ["core_rss_pend", "core_ssmend", "core_ssmends", "core_ss_nd", "core_ssgpend", "core_ssmnd", "core_ss_ends", "core_ssgend", "core_ssgends", "core_rss_end", "core_ss_pend", "core_rss_nd", "core_rss_ends"]}}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    const unsigned long *features = cpu->model->features;\n\n    unsigned max_bit = 0;\n\n    S390Feat feat;\n\n\n\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n\n\n\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n\n        /* z/Architecture is always active if around */\n\n        words[0] = 1ull << (63 - 2);\n\n    }\n\n\n\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n\n         feat < S390_FEAT_MAX;\n\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n\n        const S390FeatDef *def = s390_feat_def(feat);\n\n        if (def->type == S390_FEAT_TYPE_STFL) {\n\n            unsigned bit = def->bit;\n\n            if (bit > max_bit) {\n\n                max_bit = bit;\n\n            }\n\n            assert(bit / 64 < MAX_STFL_WORDS);\n\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n\n        }\n\n    }\n\n\n\n    return max_bit / 64;\n\n}\n", "idx": 8247, "substitutes": {"env": ["conf", "qt", "context", "ext", "fen", "conn", "forest", "estate", "que", "net", "viron", "environment", "config", "e", "queue", "gui", "ec", "eni", "manager", "ev", "exc", "ea", "virt", "exe", "ctx", "loader", "en", "eng", "enc", "init", "esp", "engine", "cache", "anc", "eu", "proc", "core", "ex"], "words": ["windows", "tags", "vs", "mac", "devices", "maps", "wp", "frames", "workers", "rows", "images", "strings", "word", "w", "fields", "wh", "files", "games", "works", "doc", "weights", "lists", "terms", "prev", "pieces", "cats", "names", "wcs", "writer", "pages", "bits", "lines", " keywords", "aws", "items", "rules", "ints", "wei", "packs", "airs", "raw", "Words", "cards", "codes", "cycles", "blocks", "bytes", "kw", "ms", "WOR", "comments", "docs", "css", "W"], "cpu": ["mac", "cow", "cam", "roc", "processor", "conn", "gpu", "bench", "net", "mem", "pool", "cp", "vm", "config", "lu", "np", "uci", "performance", "hw", "linux", "mx", "clock", "fat", "ctx", "intel", "pu", "pc", "nic", "node", "CPU", "cat", "platform", "gc", "cache", "lc", "proc", "core", "fi", "fc"], "features": ["devices", "frames", "Features", "images", "workers", "stats", "cases", "fields", "boxes", "files", "ops", "games", "flows", "ports", "weights", "config", "facts", "ants", "pieces", "tests", "names", "cats", "issues", "reports", "bits", "wcs", "types", "pins", "plugins", "values", "items", "flags", "bugs", "format", "packs", "properties", "feature", "cas", "effects", "results", "classes", "eatures", "details", "blocks", "spec", "bytes", "faces", "fn", " Features", "fs", "attacks", "products", "nets", "settings", "fi", "events", "fc"], "feat": ["af", "eat", "word", "fd", "tag", "fw", "config", "feed", "act", "gt", "lat", "step", "ctr", "opt", "flags", "cas", "miss", "spec", "concept", "form", "type", "wit", "ann", "fi", "month", "fc", "hit", "category", "val", "cept", "apt", "ct", "fit", "prop", "f", "format", "mat", "circ", "art", "mot", "col", "ant", "lc", "seq", " feature", "test", "nt", "piece", "data", "fact", "rt", "feature", "part", "fn", "cat", "func", "vec", "crit", "man", "win", "info", "doc", "lit", "bug", "nat", "butt", "fat", "bit", "aug", "ft", "proc", "fe"], "def": ["diff", "conf", "gen", "cond", "dom", "val", "define", "af", "defined", "da", "decl", "ra", "de", "doc", "ref", "Def", "lit", "feed", "cf", "act", "df", "f", "DEF", "eval", "aux", "fam", "feature", "fun", "req", "raf", "desc", "cl", "dc", "part", "spec", "form", "ef", "dev", "ret", "vec", "definition", "fi"]}}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 8254, "substitutes": {"bs": ["vs", "ts", "ks", "bb", "ds", "is", "b", "gs", "iss", "sa", "ls", "pb", "cb", "gb", "ins", "rs", "BS", "os", "bc", "obs", "cs", "aws", "es", "bh", "state", "lb", "bi", "ns", "sb", "blocks", "ms", "as", "ses", "ps", "fs", "ss", "Bs", "bos"], "s": ["l", "conf", "session", "sg", "ts", "ks", "sv", "is", "n", "ds", "si", "g", "its", "sf", "stats", "m", "w", "http", "b", "t", "gs", "service", "c", "sa", "i", "p", "ls", "server", "e", "qs", "ins", "args", "js", "sq", "rs", "f", "os", "socket", "plugins", "xs", "cs", "sym", "o", "aws", "sets", "S", "es", "sync", "v", "states", "sl", "state", "services", "new", "sb", "ns", "storage", "spec", "sys", "params", "ses", "fs", "ps", "site", "ss", "settings", "ssl"], "sock": ["inocket", "setsocket", "wsock", "hsocket", "fink", "sesock", "focket", "sslocket", "myseth", "wsocket", "opensock", "opensocket", "scp", "sOCK", "fock", "insink", "SOCK", "hsink", "sockets", "inssocket", "pink", "opensocked", "sidocket", " sess", "pocket", "wscp", "sslink", "nsess", "insocket", "setsocked", "wsink", "nsink", "csocket", "nsocket", "sidix", "jsocks", "mysink", "sidocked", "Sink", "sesocks", "Socket", "insockets", "wsOCK", " socket", "dsockets", "setsock", "mysocket", "sink", "socks", "inink", "socket", "opensocks", "mysock", "hsock", "pock", "sesocket", "fess", "sess", "nsock", "jsocket", "seseth", "csocks", "bsink", "sslsocket", "insock", "jscp", "ssocket", "inock", "seth", "csock", "csocked", "dsocket", "Sock", "wsocks", "dsock", "pocked", "socked", "jsock", "bsock", "sslock", "six", "bsockets", "sidock", "dsink", "bsocket", "setsix", " socks", "hsocks", " sink", "sesink", "pocks"], "ret": ["flag", "str", "alt", "val", "len", "def", "nt", "conn", "Ret", "no", "sur", " Ret", "num", "mem", "ne", "reply", "ref", "arg", "obj", "status", "reg", "usr", "rb", "rets", "code", "rt", "res", "bf", "det", "opt", "rc", "ner", "fun", "att", "err", "en", "nr", "bit", "cat", "re", "RET", "back", "out", "result", "mt", "rev", "sr", "resp", "success"], "size": ["count", "iz", "timeout", "scale", "si", "len", "capacity", "speed", "password", "small", "SIZE", "send", "export", "data", "close", "server", "stream", "number", "args", "loc", "empty", "Size", "body", "mode", "large", "code", "sent", "shape", "sync", "name", "six", "sized", "izes", "address", "en", "sn", "storage", "grade", "offset", "bytes", "position", "message", "complete", "extra", "length", "use", "ize", "core", "security", "fee"], "blocksize": ["bitsized", "blocksiz", "bitsizes", "framesization", "locksization", "outsizer", "filesizes", " blocksizer", "bitsization", " blockssize", "bitsizer", "minsization", "locksized", "blocksizes", "blocksizer", "minsizer", " blocksiz", "filessize", "outsization", "bssize", "minsize", "quarterssize", "quartersize", "outsized", "bitsizing", "locksize", "quartersized", "blockize", "filesize", "bitssize", "locksizing", "blocksized", "quartersization", "blockssize", "bitsize", "blocksizing", "blockiz", "bsize", "bsiz", "outsize", "framessize", "lockssize", "framesize", "blockizer", "filesizing", "framesized", "minsized", "bsizer", "locksizes", "blocksization"]}}
{"project": "FFmpeg", "commit_id": "b52b398c30a729dda38c0dd5a0cdeef160c4ca54", "target": 0, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, please add a -strict -1 flag to use it\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 8271, "substitutes": {"avctx": ["afconn", "avcv", "avcmp", "akcmp", "avsync", "avalctx", "avalcontext", "akcli", "auctx", "AVcontext", "avconn", "AVconn", "evcca", "avcontext", "avepkg", "aptcontext", "avcms", "auconn", "avecli", "afcontext", "akcontext", "avalsync", "afcv", "navkb", "afwcs", "aucu", "aircontext", "aircms", "avbc", "afpkg", "avectx", "avalcli", "avalcms", "avnp", "AVkb", "afcu", "aflc", "avalcv", "aucmp", "avalconn", "svconn", "avekb", "evcu", "afloc", "aveloc", "aptctx", "aptcu", "avcli", "evloc", "avcca", "avloc", "navpkg", "svctx", "airpkg", "afctx", "airsync", "avelc", "AVcms", "AVpkg", "avcu", "aircv", "AVctx", "evconn", "evctx", "avalloc", "akbc", "airwcs", "afcms", "navcontext", "avkb", "AVcu", "aveconn", "avecontext", "aucontext", "AVbc", "akconn", "airlc", "afcca", "AVcli", "afsync", "navctx", "avalwcs", "svcontext", "aucca", "afcmp", "svbc", "avecu", "AVcmp", "evcontext", "afcli", "AVloc", "airctx", "aptcms", "avlc", "akctx", "avwcs", "avenp", "avpkg", "avalnp", "avecms", "AVnp"], "p": ["lp", "wp", "n", "m", "bp", "t", "pa", "pp", "cp", "c", "pb", "e", "np", "pe", "gp", "q", "P", "op", "pre", "pu", "hp", "tp", "jp", "pi", "pc", "u", "ap"], "b": ["l", "boot", "ib", "base", "bb", "nb", "bp", "bar", "ab", "c", "bd", "cb", "gb", "B", "rb", "f", "binary", "v", "lb", "a", "bin", "y", "br", "bs", "buffer"], "i": ["oi", "l", "ui", "dim", "di", "it", "start", "n", "is", "si", "in", "zi", "g", "m", "id", "xi", "info", "x", "k", "z", "ini", "t", "d", "fi", "c", "ji", "ix", "uri", "e", "yi", "mini", "eni", "f", "ie", "ai", "multi", "index", "v", "gi", "mi", "ti", "phi", "ind", "name", "chi", "abi", "qi", "inner", "pi", "bi", "part", "ii", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "depth", "iu", "ki"], "j": ["l", "it", "n", "len", "g", "note", "key", "m", "k", "z", "ji", "rel", "q", "js", "op", "uj", "v", "ind", "ij", "jp", "ii", "pos", "li", "J", "jl", "pop"], "level": ["parent", "count", "hi", "base", "delay", "scale", "str", "len", "val", "key", "stage", "temp", "where", "low", "tag", "path", "lvl", "block", "line", "limit", "time", "local", "rel", "pe", "role", "quality", "value", "loc", "q", "style", "mode", "height", "priority", "unit", "profile", "fl", "code", "index", "size", "version", "inc", "scope", "name", "order", "full", "cl", "levels", "position", "grade", "col", "type", "layer", "lock", "volume", "file", "length", "weight", "depth", "nn", "sc", "vel"], "o": ["oi", "l", "n", "O", "no", "m", "k", "ol", "oo", "c", "e", "op", "f", "os", "mode", "index", "oa", "oid", "ii", "offset", "io", "lo", "range"], "shift": ["scale", "ff", "ul", "src", "top", "cp", "off", "push", "P", "op", "size", "ctr", "rc", "bh", "sup", "jp", "sort", "cl", "ii", "offset", "col", "pos", "length", "ch", "br", "depth"], "fmt": [" fatt", " fMT", "lwt", "lmt", "frnt", "fformat", "fkt", "Fkt", " filt", "infmt", "ptm", "Flt", "fmn", "ptt", "pMT", " fformat", "fwt", "Fret", "hmt", "ctm", "lmn", "Fmt", "lformat", " fnt", "frmd", "formnt", " fmn", "formmt", "cmt", "frmt", "frt", "infatt", "frkt", "frMT", "Fmm", "infMT", "Fnm", " fkt", "fMT", "Ftm", "clt", "formt", "frmm", "forMT", "ftm", "flt", "frmn", " ftm", "pilt", "infret", "Fformat", "FMT", "filt", "frformat", "Fatt", "mMT", "fornm", "cMT", " frt", "pmt", "hilt", " ftt", " flt", "formkt", "frwt", "forprintf", "hrt", "fret", "mformat", "Fprintf", " fwt", "frprintf", "fnt", "htt", " fret", "pkt", "fatt", " fmm", " fmd", " fnm", "fmm", "prt", "mmt", "fnm", "ftt", "Fmd", "formprintf", "fmd", "forformat", "mprintf"], "s": ["l", "session", "is", "its", "strings", "m", "t", "gs", "parts", "v", "full", "groups", "details", "ns", "hs", "spec", "self", "params", "settings", "sg", "ds", "n", "si", "sites", "sf", "c", "e", "lines", "sq", "us", "f", "sym", "sets", "es", "sup", "r", "storage", "u", "comments", "fs", "ps", "su", "site", "ss", "ks", "sv", "g", "features", "stats", "ops", "d", "sa", "data", "ls", "os", "cs", "sync", "new", "sb", "sys", "secondary", "a", "ssl", "conf", "ts", "service", "server", "qs", "xs", "js", "rs", "S", "services", "ctx", "ses"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)\n\n{\n\n    int y;\n\n    uint8_t * fcode_tab= s->fcode_tab;\n\n\n\n    // RAL: 8 in MPEG-1, 16 in MPEG-4\n\n    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);\n\n\n\n    /* clip / convert to intra 16x16 type MVs */\n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= (y+1)* (s->mb_width+2)+1;\n\n        int i= y*s->mb_width;\n\n        for(x=0; x<s->mb_width; x++)\n\n            {\n\n            if (s->mb_type[i] & type)    // RAL: \"type\" test added...\n\n                {\n\n                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][0]>0) \n\n                        mv_table[xy][0]=  range-1;\n\n                    else\n\n                        mv_table[xy][0]= -range;\n\n                    }\n\n                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][1]>0) \n\n                        mv_table[xy][1]=  range-1;\n\n                    else                  \n\n                        mv_table[xy][1]= -range;\n\n            }\n\n            }\n\n            xy++;\n\n            i++;\n\n        }\n\n    }\n\n}\n", "idx": 8273, "substitutes": {"s": ["l", "conf", "sports", "session", "sg", "ts", "ks", "sv", "is", "n", "si", "g", "ds", "sf", "stats", "m", "w", "http", "b", "t", "sci", "d", "serv", "service", "c", "sa", "gs", "p", "ls", "server", "e", "qs", "se", "sq", "js", "f", "sy", "cs", "sym", "o", "sets", "S", "es", "sync", "v", "space", "south", "sie", "sl", "services", "r", "bis", "ns", "sb", "spec", "less", "u", "sys", "sim", "h", "self", "ses", "a", "su", "site", "ss", "ssl"], "mv_table": ["mw_table", "mv8buffer", "mv_header", "mv_list", "mf_list", "mvselement", "mb_stable", "mv__header", "mv_stable", "mvalllist", "mw_tab", "mv_session", "mvallkey", "mvpcode", "mb_group", "mf_buffer", "mv_cache", "mv2tab", "mv_key", "mv5file", "mvallfile", "mvvtable", "mvDstore", "mw_code", "mb_key", "mv8tab", "mvpcache", "mvvcode", "mb_table", "mw_cache", "mv__key", "mf_db", "mvDtable", "mv5session", "mf_machine", "mf_tab", "mv_body", "mvstable", "mvalltotal", "mv8total", "mf_total", "mb_tab", "mvpmachine", "mb_file", "mv_store", "mv_element", "mvpbuffer", "mv_code", "mvalltable", "mv8table", "mb_header", "mv_total", "mb_code", "mvalltab", "mv_group", "mvDtab", "mv_db", "mv__table", "mv8file", "mv2code", "mf_element", "mvvtab", "mv2cache", "mv25stable", "mf_body", "mvptab", "mv25cache", "mb_cache", "mv2table", "mvDelement", "mv5table", "mvsstore", "mv8list", "mv25tab", "mf_file", "mv5tab", "mv8machine", "mf_store", "mvptable", "mf_table", "mv_tab", "mvallheader", "mvvgroup", "mv_file", "mb_session", "mv__tab", "mvstab", "mv25table", "mv_machine", "mv_buffer"], "f_code": ["fianmode", "f__address", "fxorder", "x_code", "f_address", "f_mode", "f_entry", "x_case", "fsysbody", "f__case", "fiancase", "f_order", "x_entry", "f__code", "f_type", "fianentry", " f_type", " f_length", "c_code", "fxcode", "f_case", "fsyscodes", "f_call", "fpcall", "f_body", "fpcode", "fptype", "xiancode", "f__call", "c_body", "fsyscell", "fpaddress", "f_count", "fsyscode", "xiancase", "f_cell", "f_codes", "f__type", " f_order", " f_call", "f__mode", "c_cell", "f__entry", "xianmode", "f_length", "xianentry", " f_count", "x_mode", "c_codes", "fxlength", "fiancode", "fxcount", " f_address"], "type": ["count", "kind", "domain", "comment", "key", "class", "id", "method", "t", "Type", "block", "time", "p", "ref", "target", "role", "value", "style", "prop", "types", "f", "code", "unit", "version", "shape", "index", "slice", "format", "name", "error", "offset", "TYPE", "length", "ype", "match", "typ", "range"], "y": ["l", "ym", "ady", "yt", "oy", "ry", "ny", "m", "w", "t", "ey", "z", "vy", "b", "ye", "d", "c", "ys", "p", "e", "yi", "iy", "ay", "zy", "f", "sy", "yy", "j", "code", "height", "gy", "o", "py", "sky", "ky", "hy", "Y", "ty", "yr", "u", "dy", "h", "ya", "ch", "cy", "yo"], "fcode_tab": ["fcode__buff", "fcode_group", "fbr_db", "fcode__table", "fcodevaltable", "fcod_tab", "fbr_tab", "fcode_track", "fcode_session", "fcod_cat", "fcodevalsession", "fcode_cat", "fcode__tab", "fcodevalcontainer", "fcodeettab", "fcode_db", "fcodeftable", "fcod_buff", "fcodeOcat", "fcodes_table", "fcode_ab", "fcodeOtab", "fcod_cell", "fcodeetsession", "fcodeetcontainer", "fcodes_tab", "fcod_group", "fcode_cell", "fcodes_buff", "fcodeOgroup", "fbr_col", "fcode_buff", "fcodeOtable", "fcodeftab", "fcode_container", "fcod_container", "fcod_lab", "fcodeftrack", "fcod_session", "fcod_ab", "fcode__cell", "fbr_table", "fcode_table", "fcode_col", "fcodefbuff", "fcode_lab", "fcodevaltab", "fcod_table", "fcodes_track", "fcodeettable"], "x": ["l", "n", "g", "zi", "ax", "w", "m", "xx", "id", "t", "b", "z", "d", "c", "X", "p", "ix", "time", "e", "xxx", "f", "j", "code", "o", "index", "v", "yx", "tx", "ii", "u", "h", "on", "px", "image", "dx", "dy", "ex"], "xy": ["parent", "html", "xp", "json", "quad", "dj", "z", "vy", "bo", "txt", "loc", "lat", "ie", "code", "phi", "ii", "rx", "flat", "xf", "key", "note", "no", "id", "xi", "e", "iter", "f", "yy", "XY", "j", "gy", "pie", "py", "index", "try", "live", "ei", "wx", "xb", "yo", "hi", "zip", "axy", "di", "nb", "source", "temp", "my", "d", "data", "coord", "gb", "zy", "xxx", "zh", "oxy", "yx", "home", "px", "xxxx", "wy", "dx", "dy", "ui", "xxxxxxxx", "yt", "two", "byte", "fo", "xx", "info", "phy", "dt", "ji", "time", "qa", "mi", "ctx", "h", "io"], "i": ["l", "hi", "ui", "n", "si", "in", "zi", "key", "id", "xi", "m", "b", "my", "z", "d", "c", "ji", "p", "ix", "e", "yi", "f", "ie", "j", "code", "o", "index", "v", "gi", "ti", "r", "qi", "bi", "pi", "ii", "u", "h", "I", "li", "ip", "ci", "io", "ri", "iu"]}}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu;\n\n    Error *err = NULL;\n\n\n\n    cpu = cpu_s390x_create(cpu_model, &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 8291, "substitutes": {"cpu_model": ["gpu_id", "cpu_Model", "cpu_base", "core_Model", "gpu_models", "gpu_model", "gpu_Model", "core_model", "core_base", "cpu_id", "core_models", "cpu_models"], "core_id": ["core_type", " core_name", " core_ident", "corelicid", "core_name", " core_code", "core_path", "core_ident", " core_path", "coreliccode", "core_code", "corelictype", " core_type", "corelicname"], "errp": ["erp", " errP", "errorfp", "rr", "rp", "errorp", "errorP", "errP", "erP", " errfp", "erfp", " errr", "rP", "errr", "errfp", "errorr"], "cpu": ["lp", "parent", "uca", "mac", " cp", "cow", "kernel", "boot", "cmp", "processor", "conn", "gpu", "phy", "uno", "instance", "GPU", "cp", "python", "c", "config", "los", "vm", "obj", "data", "computer", "cli", "np", "uci", "cn", "fp", "gp", "frame", " CPU", "performance", "hw", "colo", "console", "foo", "linux", "lib", "ck", "process", "clock", "fps", "proxy", "ctx", "lb", "loader", "pu", "jp", "pc", "nic", "node", "cpp", "CPU", "fork", "nc", "gc", "platform", "null", "px", "ci", "fc", "css", "cache", "lc", "proc", "core", "roc", "runner"], "err": ["cr", "org", "mr", "ver", "ref", "cb", "ec", "aster", "er", "orig", "orr", "rx", "resp", "fi", "arr", "rage", "fr", "gr", "e", "iter", "msg", "ner", "ar", "r", "error", "rar", "orer", "lc", "fee", "runner", "acer", "ler", "arm", "str", "g", "fe", "bare", "oller", "ir", "rb", "dr", "progress", "exc", "order", "rc", "ise", "req", "norm", "tx", "sys", "cache", "result", "Er", "br", "core", "rh", "ok", "far", "erg", "raise", "phy", "rr", "erer", "oe", "doc", "Error", "bug", "rs", "lr", "rag", "lib", "inc", "cor", "rn", "cfg", "out", "rm"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n", "idx": 8296, "substitutes": {"deadline": [" deadlin", "hotline", "deadlined", "timeline", " deadLINE", "waitliner", "goldline", "deadLINE", "midline", "midlin", "Deadlin", "costlin", "midlined", "goldliner", "goldlin", "Deadbase", " deadbase", "deadlining", "timeLINE", "midliner", "waitzone", "deadlin", "deadbase", "timele", "hotle", "cmdliner", "DeadLINE", "deadzone", "costliner", "timelin", "waitle", "timebase", "timeliner", "goldlining", "timezone", "waitline", "hotzone", "Deadlining", "cmdlin", "Deadlined", "Deadline", "cmdline", "cmdlined", "deadliner", "costline", "deadle", "Deadliner", "hotliner", "costlining"], "bh": ["behavior", "hi", "ib", "sh", "ht", "bb", "timeout", "dh", "nb", "af", "ph", "abb", "bang", "hh", "conn", "bp", "src", "hab", "bm", "b", "adh", "fb", "batch", "work", "ref", "pb", "hm", "cb", "fp", "bo", "gh", "rb", "plug", "lr", "bc", "body", "bt", "zh", "bf", "ha", "bl", "bg", "sync", "HB", "aph", "ih", "ctx", "lb", "hp", "acl", "sb", "bi", "kh", "hub", "eth", "h", "hl", "hap", "ch", "ah", "br", "bs", "rh", "BT", "uh"]}}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)\n\n{\n\n    int n=0, x, y, i;\n\n\n\n    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));\n\n\n\n    /* Map to the ROQ quadtree order */\n\n    for (y=0; y<enc->height; y+=16)\n\n        for (x=0; x<enc->width; x+=16)\n\n            for(i=0; i<4; i++) {\n\n                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;\n\n                tempData->cel_evals[n++].sourceY = y + (i&2)*4;\n\n            }\n\n}\n", "idx": 8313, "substitutes": {"enc": ["Enc", "cdn", "ou", "oc", "context", "equ", "win", "conn", "temp", "nt", "ent", "iv", "ENC", "c", "ct", "environment", "nec", "config", "env", "cn", "ec", "cod", "coll", "ac", "code", "cs", "ctr", "nv", "inc", "rc", "input", "current", "ic", "voc", "cur", "ctx", "en", "eng", "pc", "dc", "orc", "xc", "init", "emb", "u", "nc", "self", "cel", "ant", "ci", "vc", "anc", "lc", "acc", "cy", "fc"], "tempData": ["TempModule", " tempModule", "fakeInfo", " tempInfo", "writerDat", "fakeDat", " tempdata", "fakedata", "TempInfo", "writerData", "TempDat", "celModule", "tempBu", "celdata", "tempdata", "stabledata", "stableData", "writerInfo", "privateDat", " tempDat", "tempDat", "privateData", "stableInfo", "tempInfo", "TempBu", "privatedata", "TempData", "celBu", " tempBu", "stableDat", "writerdata", "celData", "tempModule", "Tempdata", "fakeData"], "x": ["l", "hi", "n", "zi", "ax", "w", "m", "id", "xx", "xi", "t", "z", "k", "b", "d", "c", "data", "s", "X", "p", "ix", "time", "e", "yi", "xs", "q", "f", "j", "o", "index", "v", "yx", "fx", "tx", "u", "h", "xy", "rx", "px", "a", "ci", "ya", "wy", "dx", "ex"], "y": ["l", "ym", "yt", "oy", "n", "ry", "ny", "w", "id", "xx", "b", "ye", "z", "vy", "ey", "d", "t", "c", "ys", "cy", "p", "iy", "yi", "ish", "ay", "zy", "f", "yy", "sy", "j", "gy", "o", "py", "v", "yx", "ky", "yl", "Y", "ty", "ii", "yr", "u", "type", "h", "xy", "year", "a", "ya", "wy", "dy", "yo"], "i": ["oi", "l", "ali", "ui", "di", "it", "si", "n", "zi", "key", "m", "xi", "info", "id", "b", "ini", "z", "d", "c", "ji", "s", "p", "ix", "uri", "e", "yi", "cli", "mu", "eni", "f", "ie", "j", "ai", "multi", "index", "v", "gi", "ti", "mi", "phi", "chi", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "api", "ori", "ni", "io", "ri", "fi", "iu"]}}
{"project": "FFmpeg", "commit_id": "273e6af47b38391f2bcc157cca0423fe7fcbf55c", "target": 0, "func": "static int ea_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    EaDemuxContext *ea = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    int packet_read = 0;\n\n    unsigned int chunk_type, chunk_size;\n\n    int key = 0;\n\n    int av_uninit(num_samples);\n\n\n\n    while (!packet_read) {\n\n        chunk_type = avio_rl32(pb);\n\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n\n\n        switch (chunk_type) {\n\n        /* audio data */\n\n        case ISNh_TAG:\n\n            /* header chunk also contains data; skip over the header portion*/\n\n            avio_skip(pb, 32);\n\n            chunk_size -= 32;\n\n        case ISNd_TAG:\n\n        case SCDl_TAG:\n\n        case SNDC_TAG:\n\n        case SDEN_TAG:\n\n            if (!ea->audio_codec) {\n\n                avio_skip(pb, chunk_size);\n\n                break;\n\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n\n                       ea->audio_codec == CODEC_ID_MP3) {\n\n                num_samples = avio_rl32(pb);\n\n                avio_skip(pb, 8);\n\n                chunk_size -= 12;\n\n            }\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->audio_stream_index;\n\n\n\n            switch (ea->audio_codec) {\n\n            case CODEC_ID_ADPCM_EA:\n\n            case CODEC_ID_ADPCM_EA_R1:\n\n            case CODEC_ID_ADPCM_EA_R2:\n\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n                pkt->duration = AV_RL32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_EA_R3:\n\n                pkt->duration = AV_RB32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n                pkt->duration = ret * 2 / ea->num_channels;\n\n                break;\n\n            case CODEC_ID_PCM_S16LE_PLANAR:\n\n            case CODEC_ID_MP3:\n\n                pkt->duration = num_samples;\n\n                break;\n\n            default:\n\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n\n            }\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        /* ending tag */\n\n        case 0:\n\n        case ISNe_TAG:\n\n        case SCEl_TAG:\n\n        case SEND_TAG:\n\n        case SEEN_TAG:\n\n            ret = AVERROR(EIO);\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case MVIh_TAG:\n\n        case kVGT_TAG:\n\n        case pQGT_TAG:\n\n        case TGQs_TAG:\n\n        case MADk_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MVIf_TAG:\n\n        case fVGT_TAG:\n\n        case MADm_TAG:\n\n        case MADe_TAG:\n\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n\n            chunk_size += 8;\n\n            goto get_video_packet;\n\n\n\n        case mTCD_TAG:\n\n            avio_skip(pb, 8);  // skip ea dct header\n\n            chunk_size -= 8;\n\n            goto get_video_packet;\n\n\n\n        case MV0K_TAG:\n\n        case MPCh_TAG:\n\n        case pIQT_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MV0F_TAG:\n\nget_video_packet:\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->video_stream_index;\n\n            pkt->flags |= key;\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            avio_skip(pb, chunk_size);\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8340, "substitutes": {"s": ["sed", "sg", "ks", "sv", "ds", "si", "n", "g", "sf", "b", "t", "i", "sa", "c", "p", "e", "se", "sq", "os", "sk", "an", "f", "cs", "v", "es", "sync", "space", "sie", "sl", "services", "sb", "sis", "spec", "sd", "self", "scl", "ses", "a", "su", "ss", "ssl", "sc"], "pkt": ["cpkg", "cpacket", "copcht", "facket", "pKT", " pet", " packet", "spelt", "copct", "spkg", "fkt", "Pka", "payeth", "copkt", "copacket", " pkg", "Pk", "Pnt", "cpct", " pnt", "Pelt", "pka", "payct", " pka", "apacket", "cpet", "Pkt", "cpk", "Pet", "Peth", "PKT", "lpkt", "pk", "Pcht", "fet", "lpacket", "cpkt", "apkt", "Pkg", "lpka", "packet", "lpct", " pk", "spacket", "pnt", "Pct", "paykt", "Packet", "pcht", "pelt", "spkt", "apKT", " pct", " peth", "payacket", "fct", "apnt", "pct", " pcht", "pkg", "peth", " pKT", "pet", " pelt"], "ea": ["sea", "uca", "nea", "sem", "ee", "va", "area", "anza", "di", "ATA", "SEA", "ta", "lda", "wa", "na", "cca", "ba", "da", "usa", "iana", "ena", "pa", "ra", "oga", "sa", "oe", "gae", "data", "apa", "e", "qa", "ata", "ace", "au", "aea", "ica", "ec", "eni", "ette", "ia", "ECA", "eca", "fa", "ae", "ha", "eb", "oda", "oa", "esa", "ga", "ega", "eva", "aria", "aa", "ca", "coe", "ma", "enda", "aaaa", "EA", "a", "ape", "ni", "ema", "aka", "eu", "fee", "za", "eas"], "pb": ["lp", "dp", "uf", "ib", "wp", "ppa", "pg", "tab", "bb", "proc", "pit", "bp", "prot", "pl", "lab", "bm", "b", "ab", "wb", "pa", "pp", "job", "bs", "cp", "fb", "p", "ref", "pd", "cb", "fp", "gb", "np", "ub", "plug", "rb", "pm", "prop", "tmp", "bc", "pkg", "db", "bf", "mp", "eb", "amp", "bps", "bh", "phrase", "lb", "bot", "kt", "jp", "sb", "pc", "PB", "asm", "summary", "cpp", "hub", "plugin", "platform", "mb", "api", "fc", "ob", "xb", "rob", "typ", "vp"], "chunk_type": ["chword_length", "chword_level", "chunkertypes", "chunklentype", "chunkerlevel", "chet_type", "chunk_types", "chet_size", "chart_code", "chet_tag", "chunk_number", "chunkertag", "chunkworksize", "chword_type", "chunklentag", "chart_length", "chunkworktype", "chunk_code", "chunkerlength", "chunkworkcode", "chunkersize", "chunklennumber", "chunkworklength", "chword_types", "chunk_tag", "chart_size", "chunkertype", "chunklensize", "chet_number", "chunk_level", "chunk_length", "chart_type", "chunkernumber"], "chunk_size": ["chunk\u00b7load", "chgroup_load", "chunksfee", "chgroup_size", "chunknshape", "chunk2weight", "chunks_time", "chgroup_number", "chunkedsize", "chunk_name", "chunk2data", "chunksname", "chunk_sum", "chet_fee", "chunkncount", "chunkeddata", "chunk\u00b7type", "chait_name", "chump_eng", "chunk6count", "chump6shape", "chunkedchannel", "chgroup_data", "chunks_size", "chunk64number", "chet_size", "chait_sum", "chgroup_type", "chunk_eng", "chump_size", "chunk_channel", "chunk_count", "chunks_len", "chump_count", "chunkstype", "chunkneng", "chgroup64number", "chunklexnumber", "chunk6eng", "chunk6shape", "chait_no", "chunk_no", "chet_name", "chunk_SIZE", "chunk6size", "chunkedweight", "chunkssize", "chunk_data", "chunk64type", "chunk64size", "chetstype", "chetssize", "chunklextype", "chgroup_weight", "chgroup64type", "chgroup_channel", "chunklexload", "chunks_SIZE", "chunk_load", "chgroup64size", "chunk2channel", "chump6eng", "chunk_shape", "chetsname", "chunk_len", "chait_size", "chet_type", "chetsfee", "chunk_number", "chunk_weight", "chump6size", "chunk2size", "chunk_fee", "chunk\u00b7size", "chunk64load", "chunknsize", "chunk_time", "chunk\u00b7number", "chump_shape", "chunklexsize", "chgroup64load", "chump6count"]}}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n", "idx": 8357, "substitutes": {"ti": ["oi", "ui", "di", "ta", "si", "tif", "info", "ami", "ini", "iri", "sci", "i", "tu", "isi", "iti", "uri", "cli", "txt", "TI", "tti", "ai", "osi", "tta", "mi", "phi", "tis", "chi", "qi", "ty", "shi", "ita", "pi", "tk", "bi", "ii", "tm", "wi", "li", "ci", "ni", "ati", "ski", "fi", "ki", "tin", "te"], "parent": ["member", "level", "location", "reference", "holder", "context", "si", "comment", "source", "prefix", "class", "owner", "key", "info", "id", "method", "father", "path", "instance", "container", "pa", "i", "pointer", "pool", "fi", "p", "ref", "value", "memory", "parents", "child", "size", "shape", "scope", "name", "current", "content", "connection", "fat", "function", "address", "mother", "port", "new", "pi", "pc", "root", "type", "self", "pos", "null", "Parent", "gap", "cache", "family", "depth"], "new_iface": ["new_efacer", "new_ifaces", "new_switchace", "new_eface", "new_affce", "new_faces", "new_efce", "new_face", "new_effe", "new_efclass", "new_afface", "new_affacer", "new_invfe", "new_ifce", "new_switchce", "new_ifclass", "new_ifacer", "new_efaces", "new_fce", "new_eflace", "new_facer", "new_fclass", "new_invace", "new_afflace", "new_iflace", "new_switchacer", "new_invce", "new_switchlace", "new_invclass", "new_iffe", "new_ffe"], "iface_impl": ["iface__plug", "ifaceadinf", "ifac__impl", "iface__pp", "ifacepinfo", "ifce_impl", "ifaceadinfo", "ifac_pp", "iface_inf", "iflass_expl", "ifac_pl", "iface_pp", "ifaceppl", "iface__pl", "iface__repl", "ifac_impl", "iface_repl", "iflass_Impl", "iface_info", "ifac__pp", "ifac_expl", "iface__expl", "iface_expl", "ifac_cl", "ifacepinf", "ifac__plug", "ifce_pl", "ifaceadimpl", "ifac_repl", "iface_pl", "ifac_plug", "iface__impl", "ifce_info", "ifce_inf", "ifaceadpl", "iflass_kl", "iflass_impl", "ifacepimpl", "iface_cl", "iface_plug", "iface_Impl", "ifac__expl", "ifac__repl", "iface_kl", "ifac__pl"]}}
{"project": "FFmpeg", "commit_id": "c97f54020d5d55511e28622551f13233bd8ceb56", "target": 0, "func": "static int video_open(VideoState *is){\n\n    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    int w,h;\n\n\n\n    if(is_full_screen) flags |= SDL_FULLSCREEN;\n\n    else               flags |= SDL_RESIZABLE;\n\n\n\n    if (is_full_screen && fs_screen_width) {\n\n        w = fs_screen_width;\n\n        h = fs_screen_height;\n\n    } else if(!is_full_screen && screen_width){\n\n        w = screen_width;\n\n        h = screen_height;\n\n    }else if (is->video_st && is->video_st->codec->width){\n\n        w = is->video_st->codec->width;\n\n        h = is->video_st->codec->height;\n\n    } else {\n\n        w = 640;\n\n        h = 480;\n\n    }\n\n#ifndef SYS_DARWIN\n\n    screen = SDL_SetVideoMode(w, h, 0, flags);\n\n#else\n\n    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */\n\n    screen = SDL_SetVideoMode(w, h, 24, flags);\n\n#endif\n\n    if (!screen) {\n\n        fprintf(stderr, \"SDL: could not set video mode - exiting\\n\");\n\n        return -1;\n\n    }\n\n    SDL_WM_SetCaption(\"FFplay\", \"FFplay\");\n\n\n\n    is->width = screen->w;\n\n    is->height = screen->h;\n\n\n\n    return 0;\n\n}\n", "idx": 8370, "substitutes": {"is": ["isa", "mis", "was", "its", "show", "esi", "IS", "ie", "isc", "object", "pic", "bis", "ii", "has", "get", "init", "are", "ri", "lis", "si", "iso", "does", "id", "i", "serv", "iss", "s", "app", "isu", "or", "us", "index", "es", "ic", "ar", "sis", "as", "kit", "isl", "ps", "ss", "any", "plays", "iris", "like", "ops", "ls", "os", "cs", "oss", "ics", "las", "im", "can", "Is", "sys", "nis", "vs", "it", "info", "ais", "the", "isi", "ins", "ris", "address", "ms", "cms", "ip", "api", "ses", "css", "bs"], "w": ["wl", "l", "sh", "wp", "n", "wa", "win", "window", "rw", "m", "iw", "wh", "t", "x", "b", "sw", "fw", "d", "i", "wt", "z", "c", "wrap", "wb", "work", "p", "wd", "we", "max", "s", " W", "wal", "hw", "f", "q", "wo", "height", "o", "v", "wall", "r", "end", "wx", "wan", "aw", "u", "ww", "widget", "ew", "a", "y", "W", "weight", "ow"], "h": ["l", "hi", "sh", "ht", "dh", "n", "g", "ph", "hr", "wa", "hh", "m", "wh", "t", "x", "b", "z", "d", "c", "p", "hm", " H", "help", "gh", "q", "eh", "hw", "f", "height", "host", "zh", "o", "ha", "th", "v", "ih", "bh", "home", "r", "en", "hp", "enh", "oh", "hs", "kh", "hd", "u", "H", "hl", "length", "ah", "y", "ch", "rh", "uh"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n", "idx": 8380, "substitutes": {"opaque": [" opity", "phpaques", "OPaque", "opac", " opaco", "phpaque", " opifice", "opaco", "phpity", " opac", "OPaques", "ipopaque", " opaques", "phpifice", "ropac", "ipopifice", "ropaco", "OPac", "opaques", "ropaque", "OPaco", "opifice", "ipopaques", "opity", "ipopity", "ropaques"], "addr": [" p", "alias", "mac", "Address", "adr", "pad", "src", "point", " dst", "x", "d", "pointer", "adding", "ad", "data", " address", "p", "server", "ace", "ref", "attr", "ada", "amd", "ptr", "mode", "dr", "aque", "host", "code", "arity", "ar", " e", "address", "port", "nr", "pc", " pointer", "offset", " instr", "grad", "rx", "ip", "adder"], "size": [" bytes", "len", "n", "w", " offset", "x", "SIZE", "i", "data", "p", "e", "or", "Size", "large", " w", " length", "rc", " e", " len", "offset", "bytes", " rc", "length", " sizes", "ize"], "s": ["l", "session", "sg", "ds", "n", "g", "your", "rows", "si", "sf", "w", "m", "b", "t", "ops", "d", "gs", "sa", "c", "service", "i", "p", "ls", "e", "args", "sq", "js", "f", "sym", "o", "S", "v", "sync", "es", "scope", "states", "sl", "services", "sb", "ns", "spec", "u", "self", "comments", "ses", "su", "a", "fs", "core", "ss", "ps", "settings", "ssl"], "r": ["l", "cr", "rf", "str", "rd", "hr", "ror", "rw", "m", "fr", "mr", "rr", "b", "t", "d", "i", "var", "c", "p", "reader", "e", "or", "rb", "rs", "lr", "er", "dr", "rt", "res", "o", "v", "R", "rc", "ner", "ar", "pr", "err", "nr", "error", "rar", "vr", "h", "re", "rx", "rg", "result", "sr", "ri", "rh", "rl"], "rdy": ["radye", "ldY", "ddyd", "ordyn", "raidy", "ldy", "ldyn", "redy", "dddy", "rddy", "redd", "rty", "ridx", "riddy", "ndx", "rady", "ordx", "ddY", "rdye", "raidx", "ddx", "radi", "radd", "rtd", "ldw", "redye", "ndy", "rdx", "ordY", "rdd", "ddw", "ddy", "nddy", "rdY", "rdyd", "rtye", "redi", "ridY", "rdyn", "ddyn", "ldyd", "rdi", "ndY", "raidyd", "rdw", "ridy", "raidw", "ordy", "ldx", "rti"]}}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n", "idx": 8409, "substitutes": {"value": ["count", "score", "Value", "timeout", "rate", "scale", "start", "val", "window", "key", "media", "test", "id", "total", "num", "update", "create", "data", "max", "p", "limit", "set", "number", "flow", "unit", "values", "size", "index", "try", "v", "format", "current", "min", "name", "end", "age", "function", "grade", "property", "offset", "type", "change", "message", "complete", "image", "length", "weight", "VALUE", "fee"], "errp": ["erp", "err", " errlp", "errpc", "nerr", "erlp", " errpc", "nerp", "erpc", " errr", "errlp", "errr", "nerlp", "nerpc"], "s": ["l", "conf", "session", "sg", "ts", "ds", "si", "g", "your", "sf", "stats", "m", "ops", "i", "gs", "service", "c", "p", "ls", "qs", "status", "e", "args", "js", "rs", "f", "os", "cs", "sym", "o", "aws", "sets", "S", "es", "sync", "states", "sl", "services", "state", "new", "ns", "sb", "u", "sys", "self", "rates", "ips", "params", "ses", "fs", "su", "ps", "ss", "settings", "ssl"]}}
{"project": "qemu", "commit_id": "3d5d319e1221082974711af1d09d82f0755c1698", "target": 1, "func": "void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 8412, "substitutes": {"job": ["parent", "session", "library", "base", "up", "section", "worker", "model", "b", "project", "pool", "block", "slot", "run", "jo", "p", "work", "config", "cb", "exec", "jobs", "feed", "queue", "bug", "flow", "f", "manager", "j", "next", "db", "resource", "sub", "child", "lib", "py", "route", "pause", "Job", "name", "connection", "event", "account", "live", "sync", "object", "address", "function", "user", "part", "patch", "node", "hub", "plugin", "lock", "batch", "ip", "ob", "url", "image", "result", "runner"], "aio_context": ["aios_instance", "aio_instance", "aios_sc", "aioPcontext", "aiojcost", "aioPinstance", "aio2ctx", "aio_cost", "aios_connection", "aioPctx", "aio2context", "aio_config", "aios_ctx", "aiojresource", "aio__connection", "aio__ctx", "aios_resource", "aio_connection", "aio__context", "aios_cost", "aiojctx", "aiojcontext", "aio_sc", "aio__config", "aio2cost", "aioPsc", "aio_resource", "aios_context", "aio2resource", "aio_ctx", "aios_config"]}}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n\n                        const char *arg)\n\n{\n\n    /* new-style options contain an offset into optctx, old-style address of\n\n     * a global var*/\n\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n\n    int *dstcount;\n\n\n\n    if (po->flags & OPT_SPEC) {\n\n        SpecifierOpt **so = dst;\n\n        char *p = strchr(opt, ':');\n\n\n\n        dstcount = (int *)(so + 1);\n\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n\n        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : \"\");\n\n        dst = &(*so)[*dstcount - 1].u;\n\n    }\n\n\n\n    if (po->flags & OPT_STRING) {\n\n        char *str;\n\n        str = av_strdup(arg);\n\n        av_freep(dst);\n\n        *(char **)dst = str;\n\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n\n    } else if (po->flags & OPT_INT64) {\n\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n\n    } else if (po->flags & OPT_TIME) {\n\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n\n    } else if (po->flags & OPT_FLOAT) {\n\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n\n    } else if (po->flags & OPT_DOUBLE) {\n\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n\n    } else if (po->u.func_arg) {\n\n        int ret = po->u.func_arg(optctx, opt, arg);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR,\n\n                   \"Failed to set value '%s' for option '%s'\\n\", arg, opt);\n\n            return ret;\n\n        }\n\n    }\n\n    if (po->flags & OPT_EXIT)\n\n        exit_program(0);\n\n\n\n    return 0;\n\n}\n", "idx": 8425, "substitutes": {"optctx": [" optcf", " optcfg", "opctx", "optlib", " optcontext", "optionctx", "oplib", "optionbuf", "usrcfg", "optcontext", "opbuf", "optionlib", "optbuf", "optcfg", " optbuf", "usrctx", "usrcf", " optlib", "optcf", "usrcontext", "optioncf", "opcontext", "optioncfg", "optioncontext"], "po": ["va", "co", "ppa", "ta", "fo", "da", "O", "no", "aco", "bp", "to", "go", "ono", "oo", "pa", "pp", "poke", "oe", "post", "elo", "obj", "ote", "pd", "pro", "oto", "pb", "pe", "np", "bo", "cro", "gro", "cho", "op", "o", "Po", "mp", "oa", "py", "oda", "ppo", "zone", "ako", "plate", "pr", "vo", "PO", "pre", "jp", "tp", "pi", "pc", "ao", "mo", "apo", "obo", "pos", "flo", "lo", "ko", "yo"], "opt": ["sp", "Opt", "timeout", "fo", "ext", "alt", "ord", "prefix", "info", "go", "prot", "open", "pl", "tag", "path", "iv", "stat", "feat", "config", "obj", "optim", "dest", "attr", "lit", "usr", "off", "loc", "prop", "cho", "op", "dr", "o", "oss", "name", "aut", "sl", "pr", "neg", "err", "option", "sn", "cl", "spec", "orig", "init", "fn", "cat", "pos", "options", "ret", "text", "inf", "pot", "proc", "expr", "crit", "ok", "lo"], "arg": ["mac", "arc", "gen", "arr", "param", "argument", "flag", "g", "val", "ax", "all", "go", "tag", "path", "ang", "num", "doc", "ad", "other", "var", "config", "util", "target", "reg", "star", "ag", "or", "args", "loc", "op", "ac", "dr", "next", "none", "call", "parse", "inc", "ig", "name", "ar", "r", "neg", "err", "option", "enc", "as", "cat", "ret", "use", "image", "Arg", "par", "help", "inter", "any"], "dst": ["Dstd", "dstal", "ldst", "sdsc", "dsp", "adste", " ddr", "ldST", "dest", "Dsts", "ddr", "sdest", "dedste", "idste", "dST", "eddest", "edsc", "rdST", "DST", "dost", "adest", "nsc", "Dste", "dste", "nST", "dstd", "ldsc", " dST", "idstd", "ddest", "iddest", "insts", " dost", "idsc", "dedst", " ddest", " dsc", "sdrest", "iddr", "drest", " dsp", "inste", "rdst", "nsp", " dstd", "dedsts", " dsts", " dest", "fst", " dstal", "idst", "dsts", " dste", "rdsc", "ldsp", "adst", "dedsc", " drest", "instal", "idsts", "sdsts", "adST", "Dsc", "sdst", "dsc", "edst", "fST", "rdsts", "sdST", "sdost", "inst", "nst", "eddr", "adrest", "Dst", "adsts", "adost", "sdste", "Dstal", "fste", "fsc"], "dstcount": [" dstlimit", "dSTc", "dostCount", "dputCount", "dostid", "dftCount", "dputlast", " dstc", "dputlength", "dstid", "ndstCount", "dSTlength", "ndputlength", "ndputcount", " destlength", " destlast", " dSTsize", "destid", "destlast", " destid", "drestlimit", "dstweight", "dSTweight", "dstlength", "dstlast", "dSTcount", " dputCount", " destCount", "dostc", "dftcount", "destlimit", " dputc", "dstc", "dSTsize", " dputcount", "destCount", "dstsweight", "destcount", " dSTlast", "ndstcount", "dstlimit", "dstscount", "dostlimit", " dSTCount", "destlength", "drestcount", " destlimit", "drestlength", " dstid", "ndputCount", "drestid", "ndstlength", " destcount", "dstslast", "dstCount", " dstweight", "dostcount", " dstCount", "dstsCount", " dSTweight", "dostlength", " dstsize", "dftweight", " dSTcount", "dSTlast", "dstsize", " dstlength", " dstlast", "dSTCount", "dstslength", "dputcount", "dftsize", "dstssize", "dputc"], "so": ["ld", "osa", "zip", "sp", "sh", "co", "le", "pg", "fo", "si", "sf", "go", "to", "osp", "sw", "ly", "ne", "sa", "lo", "s", "obj", "se", "cli", "cu", "bo", "pe", "sq", "st", "os", "sk", "la", "SO", "ie", "cs", "o", "py", "osi", "ce", "asi", "sync", "sl", "sn", "sth", "tp", "ste", "shi", "sm", "oh", "pc", "mo", "li", "px", "ci", "So", "su", "flo", "ski", "sc", "te"], "p": ["lp", "l", "sp", "wp", "pg", "n", "g", "php", "m", "bp", "b", "t", "pa", "d", "i", "pp", "c", "cp", "s", "pb", "e", "fp", "np", "pe", "q", "P", "f", "op", "j", "o", "py", "v", "r", "pr", "pre", "hp", "tp", "jp", "pi", "pc", "u", "h", "api", "vp"], "str": ["cr", "sp", "arr", "tr", "hr", "strings", "Str", "fr", "sw", "kr", "strike", "doc", "data", "s", "STR", "iter", "wr", "style", "stri", "rs", "f", "dr", "bl", "v", "sl", "pr", "r", "err", "spec", "enc", "u", "type", "text", "br", "sr", "sc"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 8431, "substitutes": {"f": ["l", "rf", "conf", "lf", "fo", "g", "ff", "af", "m", "fr", "info", "fd", "b", "x", "k", "t", "fw", "d", "i", "c", "p", "ref", "obj", "e", "fp", "df", "j", "fa", "o", "tf", "fx", "fat", "h", "F", "file", "fs", "fi", "fe"], "pv": ["vpv", "pvt", " pb", "pf", "Pvs", "pV", "Pvt", "psf", " pf", "vpV", " pvs", "pb", "vpf", "Pb", "psb", "Pf", "PV", "psvt", "pvs", "psv", " pvt", " pV", "vpvs", "Pv"], "size": ["l", "len", "g", "val", "w", "small", "k", "x", "z", "SIZE", "iv", "d", "i", "data", "c", "e", "Size", "large", "shape", "fff", "h", "length", " sizes", "ize", "fe"], "v": ["vs", "l", "vi", "sv", "n", "g", "val", "lv", "w", "m", "b", "k", "t", "ve", "iv", "d", "i", "vt", "c", "data", "s", "p", "e", "tv", "value", "q", "j", "o", "uv", "V", "ii", "u", "h", "vv", "vp"]}}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 8435, "substitutes": {"cpu": ["boot", "cmp", "prefix", "processor", "conn", "gpu", "phy", "chip", "auc", "bench", "consumer", "net", "pid", "GPU", "login", "pool", "cp", "vm", "c", "config", "server", "component", "cli", "np", "uci", "cn", "gp", "eni", "socket", "pai", "console", "device", "linux", "process", "clock", "ctx", "loader", "hp", "pu", "pc", "nic", "node", "cpp", "CPU", "platform", "gc", "px", "CP", "cache", "lc", "proc", "core", "roc"], "ptex": [" ptel", "ct1", "portEx", "ptec", "iptEx", "ctex", "ktEX", "ctEx", "ktex", "etax", "ntex", "etex", "ptel", "cticket", "iptexec", "ptEX", "ptonex", "ctlex", " ptexec", "ptick", "ptlex", "pitec", "ntlex", "iptel", "etEx", "PTicket", "pticket", "eptext", "ctext", "PTex", "ntEX", "ctec", "portec", "ptext", "epticket", "ctEX", "etEX", "ktick", "PTEX", "ptonel", "ktlex", "ptonexec", "PText", "pt1", "portext", "pitEx", "PTEx", "pitex", "eptex", "ctick", "ptonEx", "portex", "pitext", "PTax", "ept1", "ptexec", "ntick", "ptax", "ptEx", "iptex", "PT1", "portax", "portEX", " ptEx"], "avpn": ["avn", "afp", "avc", "ampn", "akpn", "akpc", "avp", "ajn", "akn", "app", "afn", "akp", "vpn", "afpi", "ampc", "amn", "afpc", "vpc", "amp", "avpc", "ajpn", "ajpc", "apc", "akc", "appn", "appc", "apn", "ajpi", "afpn", "akpi", "vc", "avpi"], "flags": ["vs", "tags", "vals", "devices", "words", "flag", "xp", "vl", "ds", "ff", "lv", "sf", "features", "stats", "alls", "fd", "files", "ops", "ports", "lists", "s", "mask", "ls", "ants", "status", "versions", "bits", "args", "pages", "rs", "types", "lag", "f", "rets", "fl", "Flags", "linux", "values", "rules", "services", "native", "ats", "ns", "ips", "options", "fs", "settings", "fc"], "vp": ["vs", "lp", "sp", "wp", "sv", "vl", "xp", "lv", "vt", "ipes", "cp", "vm", "ov", "VS", "p", "username", "pb", "fp", "erv", "np", "attr", "GV", "qv", "nv", "cv", "VP", "RP", "uv", "vP", "tp", "VPN", "vr", "vg", "vv", "vc"], "rp": ["slp", "crb", "rv", " rpc", "rps", "slb", "rsp", "rvp", "rpc", "rsps", " rm", "rsvp", "slm", " rv", "rdv", "rdps", " rps", "crpc", "rdvp", "crp", "crm", "rsv", "slpc", "rm", " rvp", "rdp"], "env": ["fg", "conf", "session", "inet", "context", "fen", "equ", "worker", "conn", "estate", "que", "ini", "net", "viron", "export", "buf", "c", "environment", "vm", "config", "enable", "policy", "obj", "e", "cli", "stack", "queue", "np", "erv", "cb", "style", "ec", "eni", "args", "bc", "profile", "console", "ev", "skin", "db", "edge", "exc", "scope", "energy", "ea", "state", "ctx", "loader", "en", "eng", "Environment", "enc", "pect", "cfg", " environment", "cache", "agent", "engine", "eu", "proc", "core", "settings", "fi", "runner"], "token": ["setup", "tool", "channel", "cookie", "session", "byte", "pass", "context", "KEN", "start", "len", "val", "auth", "prefix", "key", "processor", "info", "id", "temp", "conn", "password", "tag", "t", "fd", "wt", "login", "fi", "vt", "service", "rule", "config", "uri", "username", "tick", "target", "fp", "secret", "request", "number", "stop", "socket", "code", "resource", "o", "module", "Token", "scope", "sync", "timer", "track", "response", "account", "loader", "callback", "function", "user", "ticket", "offset", "node", "fin", "fn", "not", "header", "api", "sid", "url", "oken", "text", "settings", "buffer", "ok", "reset"], "v": ["vs", "l", "vi", "va", "vert", "sv", "vl", "n", "g", "vu", "val", "lv", "vid", "w", "m", "b", "t", "x", "k", "iv", "ve", "ver", "i", "vt", "var", "c", "d", "s", "ov", "p", "vm", "e", "tv", "value", "q", "f", "j", "ev", "qv", "o", "version", "nv", "cv", "uv", "V", "u", "vr", "h", "vg", "av", "vv", "a", "vc"], "r": ["l", "rf", "ru", "hr", "rw", "m", "mr", "rr", "b", "c", "s", "p", "e", "rss", "rs", "lr", "f", "er", "rt", "R", "rc", "pr", "nr", "rar", "ur", "u", "rn", "h", "re", "vr", "rx", "rg", "sr", "ri", "br", "rh", "rl", "rm", "range"], "rb": ["rf", "ru", "erb", "bb", "rd", "rw", "src", "rr", "b", "kr", "RB", "pb", "gb", "rss", "rs", "tmp", "lr", "rt", "bf", "route", "rc", "reb", "lb", "ruby", "nr", "raf", "sb", "rar", "rn", "vr", "rx", "rg", "sr", "rob", "ri", "rh", "rl", "rm"]}}
{"project": "qemu", "commit_id": "33848ceed79679b5c9e558b768447af2614b8db2", "target": 1, "func": "int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size)\n\n{\n\n    PCIExpressDevice *exp;\n\n\n\n    pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER,\n\n                        offset, size);\n\n    exp = &dev->exp;\n\n    exp->aer_cap = offset;\n\n\n\n    /* log_max is property */\n\n    if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) {\n\n        dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT;\n\n    }\n\n    /* clip down the value to avoid unreasobale memory usage */\n\n    if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) {\n\n        return -EINVAL;\n\n    }\n\n    dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] *\n\n                                        dev->exp.aer_log.log_max);\n\n\n\n    pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SEVERITY_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS,\n\n                               PCI_ERR_COR_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_MASK_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_SUPPORTED);\n\n\n\n    /* capabilities and control. multiple header logging is supported */\n\n    if (dev->exp.aer_log.log_max > 0) {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC |\n\n                     PCI_ERR_CAP_MHRC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE |\n\n                     PCI_ERR_CAP_MHRE);\n\n    } else {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\n    }\n\n\n\n    switch (pcie_cap_get_type(dev)) {\n\n    case PCI_EXP_TYPE_ROOT_PORT:\n\n        /* this case will be set by pcie_aer_root_init() */\n\n        /* fallthrough */\n\n    case PCI_EXP_TYPE_DOWNSTREAM:\n\n    case PCI_EXP_TYPE_UPSTREAM:\n\n        pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL,\n\n                                   PCI_BRIDGE_CTL_SERR);\n\n        pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS,\n\n                                   PCI_SEC_STATUS_RCV_SYSTEM_ERROR);\n\n        break;\n\n    default:\n\n        /* nothing */\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8447, "substitutes": {"dev": ["diff", "conf", "gu", "dim", "gd", "di", "cam", "img", "valid", "debug", "dom", "comment", "g", "prof", "test", "Dev", "def", "conn", "info", "die", "prom", "w", "pack", "game", "dem", "ve", "adv", "d", "ver", "var", "data", "ad", "doc", "config", "server", "block", "app", "pro", "reg", "plug", "bug", "rad", "gh", "serial", "off", "priv", "sk", "ev", "device", "pub", "feature", "cur", "req", "end", "mod", "user", "loader", "dd", "error", "spec", "enc", "sd", "grad", "od", "client", "ch", "ow", "wd", "DEV"], "offset": ["count", "scroll", "alias", "location", "seq", "timeout", "base", "delay", "optional", "scale", "start", "len", "enabled", "alt", "prefix", "pad", "info", "annot", "origin", "shift", "pointer", "phase", "slot", "enable", "addr", "limit", "config", "server", "attr", "set", "queue", "ptr", "loc", "off", "style", "padding", "entry", "append", "index", "version", "offer", "exclusive", "amp", "order", "format", "align", "end", "item", "address", "port", "begin", "part", "art", "position", "hop", "error", "root", "type", "lock", "layer", "pos", "api", "attribute", "gap", "length", "url", "Offset", "range", "reset"], "size": ["ui", "sh", "timeout", "scale", "si", "len", "capacity", "small", "SIZE", "sum", "s", "max", "set", "loc", "empty", "Size", "sec", "large", "unit", "cs", "shape", "sized", "end", "address", "storage", "pos", "complete", "length", "ize", "fee"]}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 8457, "substitutes": {"cpu": ["kernel", "cmp", "gpu", "bench", "net", "python", "config", "thread", "computer", "np", "cn", "gp", "frame", " CPU", "gnu", "process", "lb", "cpp", "nc", "gc", "fc", "mac", "chip", "que", "instance", "vm", "component", "uci", "hw", "performance", "pai", "colo", "clock", "fps", "winner", "loader", "CPU", "lc", "cus", "uca", "boot", "conn", "uno", "consumer", "GPU", "cp", "cu", "cli", "fp", "cube", "eni", "linux", "home", "intel", "custom", "node", "gru", "px", "cache", "core", "mc", "cdn", "processor", "phy", "auc", "userc", "qa", "queue", "console", "name", "ctx", "pu", "pc", "nic", "platform", "null", "css", "proc", "roc"], "thread_name": [" thread_names", "condalname", "thread2names", "condalindex", "cond_size", "threadalsize", "connection_name", " thread_NAME", "thread_size", "connection_type", "threadalindex", "threadsname", "cond_number", "thread_number", "thread_len", "cond_name", "thread_names", "condalnumber", "threadslen", "threadssize", "threadalnumber", "thread_type", "thread_index", "connection_size", "thread2name", "threadstype", "connection_len", "thread_NAME", "cond_index", "threadalname", "thread2NAME", "condalsize"], "tcg_halt_cond": ["tcg_halt_reason", "tcg_halturecondition", "tcg_halt__code", "tcg_halt2code", "tcg_hort2cond", "tcg_halt_condition", "tcg_halt2reason", "tcg_hort_cond", "tcg_hait_cond", "tcg_haltingconnection", "tcg_halt_connection", "tcg_hort2reason", "tcg_hal_cond", "tcg_halt_Cond", "tcg_haltureCond", "tcg_halt2cond", "tcg_halt__reason", "tcg_halturecond", "tcg_halt2condition", "tcg_hait_condition", "tcg_haltingcondition", "tcg_hal_Cond", "tcg_hort_code", "tcg_hait_Cond", "tcg_haltingcond", "tcg_halturecmd", "tcg_hort2code", "tcg_halt__cond", "tcg_hort_condition", "tcg_halt_code", "tcg_hal_connection", "tcg_hort_reason", "tcg_halt_cmd", "tcg_halt__condition", "tcg_hait_cmd", "tcg_hal_condition", "tcg_haltingCond", "tcg_hort2condition"], "tcg_cpu_thread": ["tcg_cpu__process", "tcg_cpu__method", "tcg_cpu2cond", "tcg_cpu_process", "tcg_gpu_loop", "tcg_gpu_method", "tcg_cpu_worker", "tcg_gpu_connection", "tcg_cpu2method", "tcg_cpu2loop", "tcg_gpu_cond", "tcg_cpu_connection", "tcg_cpu2process", "tcg_gpu_thread", "tcg_cpu_loop", "tcg_gpu_process", "tcg_gpu_worker", "tcg_cpu__thread", "tcg_cpu2thread", "tcg_cpu__loop", "tcg_cpu_cond", "tcg_cpu_method", "tcg_cpu2connection"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n", "idx": 8466, "substitutes": {"vs": ["vals", "va", "ts", "uses", "ks", "sv", "ds", "lv", "stats", "alls", "http", "ils", "ops", "vers", "VS", "gs", "iss", "ys", "vm", "ov", "s", "ls", "server", "qs", "env", "xs", "args", "rs", "os", "sk", "obs", "cs", "v", "es", "sts", "fps", "state", "proxy", "services", "ns", "ms", "vr", "sys", "ses", "fs", "ps", "css", "vc", "ss", "bs", "vp"], "data": ["session", "timeout", "base", "keys", "start", "str", "len", "window", "key", "da", "def", "id", "info", "open", "missing", "d", "buf", "config", "batch", "addr", "ada", "args", "empty", "body", "DATA", "next", "none", "dat", "size", "input", "name", "response", "content", "raw", "done", "address", "results", "Data", "bytes", "message", "api", "a", "cache", "result", "buffer", "exec"], "datalen": ["dillingan", " davalun", "idotalen", "idotalan", "dallun", "dallan", "davalen", " dallsener", " davalenum", "daleden", "idotalsten", " dallsan", "davalan", "idotalens", "idatalens", "dallength", "datalenum", "dallsener", "daledenum", "idatalan", "daledun", "dallsan", " dallsen", "idatalsten", "dillingens", "daledan", "dallener", " datalength", "datalan", "dallsten", " datalan", "datalength", " dallsength", "datalens", " davalan", "idatalen", "dallsength", "dallsen", "davalenum", "davalener", " datalenum", "dillingen", "dotalsten", "dallenum", "datalener", "dallen", "dillingsten", "dotalan", "dotalen", "dotalens", "datalun", " datalun", "dallens", "datalsten", " davalen", "davalength", " datalener", "davalun"], "ret": ["valid", "flag", "str", "alt", "val", "len", "fail", "all", "_", "def", "nt", "Ret", "temp", " Ret", "mem", "job", "rec", "reply", "ref", "arg", "obj", "lit", "status", "reg", "rets", "f", "ut", "code", "rt", "res", "db", "det", "try", "rc", "fun", "att", "done", "r", "en", "err", "part", "get", "bit", "cat", "re", "RET", "back", "et", "result", "rev", "resp", "success", "pet"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static av_cold int decode_init(AVCodecContext * avctx)\n\n{\n\n    MPADecodeContext *s = avctx->priv_data;\n\n    static int init=0;\n\n    int i, j, k;\n\n\n\n    s->avctx = avctx;\n\n\n\n    ff_mpadsp_init(&s->mpadsp);\n\n\n\n    avctx->sample_fmt= OUT_FMT;\n\n    s->error_recognition= avctx->error_recognition;\n\n\n\n    if (!init && !avctx->parse_only) {\n\n        int offset;\n\n\n\n        /* scale factors table for layer 1/2 */\n\n        for(i=0;i<64;i++) {\n\n            int shift, mod;\n\n            /* 1.0 (i = 3) is normalized to 2 ^ FRAC_BITS */\n\n            shift = (i / 3);\n\n            mod = i % 3;\n\n            scale_factor_modshift[i] = mod | (shift << 2);\n\n        }\n\n\n\n        /* scale factor multiply for layer 1 */\n\n        for(i=0;i<15;i++) {\n\n            int n, norm;\n\n            n = i + 2;\n\n            norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1);\n\n            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRAC_BITS);\n\n            av_dlog(avctx, \"%d: norm=%x s=%x %x %x\\n\",\n\n                    i, norm,\n\n                    scale_factor_mult[i][0],\n\n                    scale_factor_mult[i][1],\n\n                    scale_factor_mult[i][2]);\n\n        }\n\n\n\n        RENAME(ff_mpa_synth_init)(RENAME(ff_mpa_synth_window));\n\n\n\n        /* huffman decode tables */\n\n        offset = 0;\n\n        for(i=1;i<16;i++) {\n\n            const HuffTable *h = &mpa_huff_tables[i];\n\n            int xsize, x, y;\n\n            uint8_t  tmp_bits [512];\n\n            uint16_t tmp_codes[512];\n\n\n\n            memset(tmp_bits , 0, sizeof(tmp_bits ));\n\n            memset(tmp_codes, 0, sizeof(tmp_codes));\n\n\n\n            xsize = h->xsize;\n\n\n\n            j = 0;\n\n            for(x=0;x<xsize;x++) {\n\n                for(y=0;y<xsize;y++){\n\n                    tmp_bits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j  ];\n\n                    tmp_codes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++];\n\n                }\n\n            }\n\n\n\n            /* XXX: fail test */\n\n            huff_vlc[i].table = huff_vlc_tables+offset;\n\n            huff_vlc[i].table_allocated = huff_vlc_tables_sizes[i];\n\n            init_vlc(&huff_vlc[i], 7, 512,\n\n                     tmp_bits, 1, 1, tmp_codes, 2, 2,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_vlc_tables));\n\n\n\n        offset = 0;\n\n        for(i=0;i<2;i++) {\n\n            huff_quad_vlc[i].table = huff_quad_vlc_tables+offset;\n\n            huff_quad_vlc[i].table_allocated = huff_quad_vlc_tables_sizes[i];\n\n            init_vlc(&huff_quad_vlc[i], i == 0 ? 7 : 4, 16,\n\n                     mpa_quad_bits[i], 1, 1, mpa_quad_codes[i], 1, 1,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_quad_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_quad_vlc_tables));\n\n\n\n        for(i=0;i<9;i++) {\n\n            k = 0;\n\n            for(j=0;j<22;j++) {\n\n                band_index_long[i][j] = k;\n\n                k += band_size_long[i][j];\n\n            }\n\n            band_index_long[i][22] = k;\n\n        }\n\n\n\n        /* compute n ^ (4/3) and store it in mantissa/exp format */\n\n\n\n        int_pow_init();\n\n        mpegaudio_tableinit();\n\n\n\n        for (i = 0; i < 4; i++)\n\n            if (ff_mpa_quant_bits[i] < 0)\n\n                for (j = 0; j < (1<<(-ff_mpa_quant_bits[i]+1)); j++) {\n\n                    int val1, val2, val3, steps;\n\n                    int val = j;\n\n                    steps  = ff_mpa_quant_steps[i];\n\n                    val1 = val % steps;\n\n                    val /= steps;\n\n                    val2 = val % steps;\n\n                    val3 = val / steps;\n\n                    division_tabs[i][j] = val1 + (val2 << 4) + (val3 << 8);\n\n                }\n\n\n\n\n\n        for(i=0;i<7;i++) {\n\n            float f;\n\n            INTFLOAT v;\n\n            if (i != 6) {\n\n                f = tan((double)i * M_PI / 12.0);\n\n                v = FIXR(f / (1.0 + f));\n\n            } else {\n\n                v = FIXR(1.0);\n\n            }\n\n            is_table[0][i] = v;\n\n            is_table[1][6 - i] = v;\n\n        }\n\n        /* invalid values */\n\n        for(i=7;i<16;i++)\n\n            is_table[0][i] = is_table[1][i] = 0.0;\n\n\n\n        for(i=0;i<16;i++) {\n\n            double f;\n\n            int e, k;\n\n\n\n            for(j=0;j<2;j++) {\n\n                e = -(j + 1) * ((i + 1) >> 1);\n\n                f = pow(2.0, e / 4.0);\n\n                k = i & 1;\n\n                is_table_lsf[j][k ^ 1][i] = FIXR(f);\n\n                is_table_lsf[j][k][i] = FIXR(1.0);\n\n                av_dlog(avctx, \"is_table_lsf %d %d: %x %x\\n\",\n\n                        i, j, is_table_lsf[j][0][i], is_table_lsf[j][1][i]);\n\n            }\n\n        }\n\n\n\n        for(i=0;i<8;i++) {\n\n            float ci, cs, ca;\n\n            ci = ci_table[i];\n\n            cs = 1.0 / sqrt(1.0 + ci * ci);\n\n            ca = cs * ci;\n\n            csa_table[i][0] = FIXHR(cs/4);\n\n            csa_table[i][1] = FIXHR(ca/4);\n\n            csa_table[i][2] = FIXHR(ca/4) + FIXHR(cs/4);\n\n            csa_table[i][3] = FIXHR(ca/4) - FIXHR(cs/4);\n\n            csa_table_float[i][0] = cs;\n\n            csa_table_float[i][1] = ca;\n\n            csa_table_float[i][2] = ca + cs;\n\n            csa_table_float[i][3] = ca - cs;\n\n        }\n\n\n\n        /* compute mdct windows */\n\n        for(i=0;i<36;i++) {\n\n            for(j=0; j<4; j++){\n\n                double d;\n\n\n\n                if(j==2 && i%3 != 1)\n\n                    continue;\n\n\n\n                d= sin(M_PI * (i + 0.5) / 36.0);\n\n                if(j==1){\n\n                    if     (i>=30) d= 0;\n\n                    else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0);\n\n                    else if(i>=18) d= 1;\n\n                }else if(j==3){\n\n                    if     (i<  6) d= 0;\n\n                    else if(i< 12) d= sin(M_PI * (i -  6 + 0.5) / 12.0);\n\n                    else if(i< 18) d= 1;\n\n                }\n\n                //merge last stage of imdct into the window coefficients\n\n                d*= 0.5 / cos(M_PI*(2*i + 19)/72);\n\n\n\n                if(j==2)\n\n                    mdct_win[j][i/3] = FIXHR((d / (1<<5)));\n\n                else\n\n                    mdct_win[j][i  ] = FIXHR((d / (1<<5)));\n\n            }\n\n        }\n\n\n\n        /* NOTE: we do frequency inversion adter the MDCT by changing\n\n           the sign of the right window coefs */\n\n        for(j=0;j<4;j++) {\n\n            for(i=0;i<36;i+=2) {\n\n                mdct_win[j + 4][i] = mdct_win[j][i];\n\n                mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1];\n\n            }\n\n        }\n\n\n\n        init = 1;\n\n    }\n\n\n\n    if (avctx->codec_id == CODEC_ID_MP3ADU)\n\n        s->adu_mode = 1;\n\n    return 0;\n\n}\n", "idx": 8482, "substitutes": {"avctx": ["AVcli", "afconn", "navcam", "mpconn", "afctx", "avcmp", "AVconfig", "navctx", " avcli", "aftx", "afconf", "akconsole", "afcmp", "avectx", "akcli", "akconf", "abconfig", "afctl", "abcontext", "navtx", "ajcli", " avtx", "AVcmp", "afcli", "aveconf", "AVcontext", "avcu", " avctl", "abctx", "afcu", "avectl", "ajctl", "avconn", "mpcontext", "ajtx", "navctrl", "ajctx", "ajcontext", "afconfig", "avcam", "AVctx", "ajcam", "AVconn", " avcontext", "avconfig", "avcontext", "abcu", " avconn", " avconsole", "akctl", "akctx", "avctrl", "mptx", "avconsole", "navcontext", "AVcu", "avecontext", "avtx", "AVcam", "navcli", "afcontext", "avctl", "akcontext", "mpcu", "mpcmp", "avcli", " avctrl", "ajctrl", "navctl", "afconsole", "avconf", "mpctx"], "s": ["session", "sg", "utils", "sv", "ds", "si", "sf", "m", "t", "b", "gs", "sa", "c", "data", "service", "p", "ls", "server", "qs", "se", "sq", "js", "sec", "sk", "rs", "o", "aws", "shared", "S", "sync", "space", "services", "ctx", "sb", "ns", "spec", "init", "sys", "ses", "su", "fs", "ss", "so", "ssl", "sc"], "i": ["l", "is", "m", "z", "iv", "uri", "ie", "isin", "phi", "abi", "ii", "init", "fi", "oi", "vi", "si", "id", "xi", "b", "c", "mu", "index", "slice", "sup", "ei", "bi", "u", "li", "ni", "site", "lc", "hi", "di", "g", "zi", "uli", "cli", "yi", "mini", "eni", "ai", "o", "gi", "chi", "pi", "I", "iu", "ui", "it", "in", "info", "ini", "line", "p", "ix", "isi", "q", "multi", "mi", "ti", "inner", "qi", "ip", "api", "io"], "j": ["l", "g", "m", "b", "t", "z", "ji", "c", "p", "obj", "kj", "q", "o", "r", "ij", "jp", "ii", "pos", "J", "jj"], "k": ["ks", "g", "key", "w", "m", "id", "b", "z", "num", "c", "max", "p", "q", "sk", "o", "ik", "r", "K", "mk"], "offset": ["parent", "alias", "timeout", "base", "start", "len", "iso", "pad", "info", "id", "origin", "data", "slot", "p", "split", "set", "ffff", "skip", "ptr", "off", "loc", "padding", "rot", "entry", "o", "index", "slice", "align", "port", "position", "error", "pos", "transform", "ip", "seed", "Offset", "reset"], "shift": ["diff", "vert", "sh", "fix", "delay", "scale", "pad", "id", "Shift", "pack", "data", "ress", "sum", "p", "ix", "set", "dist", "ptr", "push", "step", "slice", "version", "size", "hift", "sup", "load", "patch", "pull", "position", "init", " shifted", "form", "change", " shifts", "transform", "length", "seed", "mix", "depth", "pop", "range", "power"], "mod": ["diff", "mac", "dim", "rem", "Mod", "scale", "tr", "MOD", "mods", "m", "mult", "pack", "c", "max", "mu", "dist", "lex", "du", "step", "multipl", "mode", "sub", "modified", "module", "inc", "ind", "min", "sup", "roll", "pull", "sign", "form", "lock", "cm", "pos", "transform", "row", "comp", "length", "comb", "mix", "range"], "n": ["l", "mn", "nb", "len", "g", "m", "net", "b", "num", "z", "ne", "t", "c", "nor", "p", "eni", "dn", "body", "network", "pn", "o", "N", "spin", "ner", "r", "en", "sn", "ns", "ii", "init", "u", "nc", "nu", "ni", "adj", "nn"], "norm": ["diff", "chrom", "center", "term", "valid", "mn", "scale", "axis", "len", "normal", "ord", "complex", "m", "color", "low", "small", "num", "feat", "doc", "nor", "draw", "known", "global", "dist", "Norm", "cube", "rom", "loc", "coll", "orm", "unit", "version", "size", "mx", "index", "sync", "format", "raw", "fun", "nom", "function", "custom", "desc", "dc", "ii", " Norm", "fine", "front", "init", "orig", "rn", "nc", "uni", "cm", "form", "transform", "common", "carry", "orbit", "lc", "vec", "flat", "core", "sc", "range"], "h": ["ht", "g", "ph", "w", "m", "t", "path", "b", "c", "p", "hm", "help", "q", "host", "code", "ha", "r", "hash", "hs", "u", "H", "header", "cache", "ch", "rh"], "xsize": ["yscale", "xxscale", "xSize", "wSize", "xxbytes", "xxSize", "wscale", "ybytes", "xxsize", "xscale", "xbytes", "wbytes", "ySize", "ysize", "wsize"], "x": ["l", "key", "w", "m", "id", "t", "z", "num", "c", "data", "X", "p", "ix", "max", "height", "index", "bit", "u", "rx", "dx", "ex"], "y": ["l", "w", "m", "temp", "b", "t", "z", "vy", "c", "p", "height", "o", "Y", "col", "type", "pos", "ip", "ch", "dy"], "tmp_bits": ["tmp2bits", "mp_bit", "mp_batch", "tmp67bit", "tmp___windows", "prevWbits", "tmp2bytes", "prev_windows", "prev_bytes", "tmp2codes", "tmp___bytes", "mp_codes", "tmp___bits", "tmpWchanges", "tmp__bytes", "tmp_batch", "mp_bits", "tmp___changes", " tmp_blocks", "prev_bits", "tmp_bytes", "tmp_blocks", "prevWchanges", " tmp_bytes", "tmp__blocks", "tmp67bits", "prev_changes", "tmp__bits", "tmp_windows", "tmp2blocks", "tmp67batch", "prevWbytes", "tmp_changes", "tmpWwindows", "prevWwindows", "tmp__codes", "tmp_bit", "tmpWbytes", "tmp67codes", "tmpWbits"], "tmp_codes": ["tmp_maps", "nb86maps", "tmp86code", "tmp86bits", "nb86bits", "tmp86codes", "tmp_code", "nb86codes", "nb_codes", "nb_bits", "nb_code", "nb_maps", "tmp86maps", "nb86code"]}}
{"project": "FFmpeg", "commit_id": "480324e7ca0b87105fd7ee168292a0d5692af128", "target": 0, "func": "static int libgsm_decode_frame(AVCodecContext *avctx,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt) {\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);\n\n\n\n    if (*data_size < out_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (buf_size < avctx->block_align) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch(avctx->codec_id) {\n\n    case CODEC_ID_GSM:\n\n        if(gsm_decode(avctx->priv_data,buf,data)) return -1;\n\n        break;\n\n    case CODEC_ID_GSM_MS:\n\n        if(gsm_decode(avctx->priv_data,buf,data) ||\n\n           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;\n\n    }\n\n\n\n    *data_size = out_size;\n\n    return avctx->block_align;\n\n}\n", "idx": 8487, "substitutes": {"avctx": ["afconn", "afcup", "avsync", "avcmp", "auctx", " avcmp", "AVcontext", "avconn", " avcontext", "avcontext", " avconn", "avepkg", "aircup", "afcn", "navcmp", "AVcca", "AVcb", "auconn", "afcontext", "afkb", " avcu", "avcb", "avecup", "avconf", "aukb", "avecca", "aircontext", "evcmp", "ajcmp", "aircf", "afpkg", "avectx", "vercmp", "ausci", "afcu", "aflc", "afxc", "ajctx", "ajcontext", "ajpkg", " avcca", " avcf", "afsci", "avecn", "evconf", "avcn", "avcca", "vercf", " avxc", "afctx", "avelc", "ausync", " avkb", "avcf", "avecb", "avexc", "vercontext", "avcu", "verctx", "AVlc", "AVctx", "avxc", "evctx", " avsync", "navcontext", "avkb", "aveconn", "avecontext", "aucontext", "afcca", "afsync", "AVcf", "vercca", "navctx", "afconf", "afcmp", "navcca", "avecu", "AVcmp", "evcontext", "avsci", "avcup", "ajcn", "afcf", "airctx", "avlc", "ajconf", "avesci", "afcb", "avpkg", "avecf"], "data": ["parent", "count", "base", "media", "pad", "shift", "block", "config", "package", "memory", "frame", "body", "none", "content", "response", "bus", "offset", "image", "buffer", "val", "da", "id", "open", "ada", "bc", "DATA", "zero", "slice", "index", "input", "Data", "bytes", "header", "sample", "frames", "len", "array", "xxx", "dat", "alpha", "size", "raw", "done", "message", "a", "result", "cache", "uc", "ui", "valid", "start", "window", "batch", "p", "bu", "ata", "queue", "au", "empty", "la", "next", "address", "pos", "null", "api", "length"], "data_size": ["ata_body", "data_code", "data_scale", "ata_size", "buf_size", " data_code", "data___count", " data_slice", "dataqscale", "ata_form", "data___form", "data___size", "dataqslice", "data_num", "data___body", "data_form", "data_count", "dataqcode", "data_sized", "dataqsize", "data_body", "data_slice", "buf_num", "buf_unit", "buf_sized", "data_unit", "ata_count", " data_scale"], "avpkt": ["avnkg", "afpacket", "avPkg", "avpsth", "avpki", "abpct", "abpkt", "avlpki", "avnsth", "AVPkg", "avpacket", "avfacket", "avfpck", "affacket", "avvpacket", "afpkg", "avcpacket", "avfkt", "avPct", "AVpkg", "abpki", "AVPsth", "avPkt", "avfpkt", "avfct", "avfck", "abcpacket", "avvpkt", "abcpct", "avcpkt", "AVPct", "avpct", "avlpkt", "affck", "AVpsth", "avnkt", "avppsth", "avnct", "afpck", "avfpkg", "abpacket", "AVpct", "avfkg", "avpkg", "afpkt", "abcpki", "abcpkt", "avfki", "avcpct", "avvpck", "AVpkt", "affkt", "avlpacket", "avpck", "avppkg", "avppct", "avlpct", "affkg", "avfpacket", "avPsth", "avcpki", "avvpkg", "AVPkt", "avppkt"], "buf": ["bag", "uf", "map", "seq", "Buffer", "img", "len", "ff", "wa", "window", "pad", "src", "fd", "b", "ab", "num", "wb", "fb", "batch", "config", "bu", "cb", "fp", "queue", "feed", "cf", "rb", "array", "prop", "bc", "la", "code", "ha", "alloc", "cv", "cap", "ctx", "req", "cur", "port", "offset", "pos", "header", "length", "cache", "text", "buff", "vec", "func", "br", "buffer", "box", "uc"]}}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "func": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n", "idx": 8518, "substitutes": {"mr": ["km", "rf", "adr", "mk", "mn", "m", "rr", "bm", "kr", "gr", "wk", "hm", "MR", "gb", "rb", "rs", "lr", "er", "ml", "dr", "manager", "fm", "rt", "bf", "mc", "rc", "igr", "r", "md", "las", "nr", "ur", "yr", "tm", "vr", "dm", "cm", "rg", "mt", "Mr", "sr", "ocr", "rh", "rl", "rm"], "l": ["lp", "le", "base", "il", "n", "len", "g", "lv", "ul", "b", "ol", "x", "z", "d", "i", " L", "c", "ell", "s", "lo", "el", "ls", "p", "e", "loc", "er", "f", "ml", "lr", "dl", "la", "j", "o", "fl", "al", "ll", "v", "sl", "r", "L", "lb", "lt", "u", "nl", "li", "lin", "length", "lc", "rl", "ln", "ly", "kl"], "addr": ["mac", "adr", "Address", "arr", "base", "cmp", "len", "src", "x", "pointer", "ad", "data", "ref", "add", "ace", "ada", "amd", "ptr", "ange", "rs", "loc", "mode", "ac", "dr", "host", "rt", "size", "route", "oa", "nil", "name", "rc", "align", "ar", "r", "address", "dd", "nr", "part", "asm", "offset", "hop", "node", "orig", "layer", "rx", "a", "lan", "nn"]}}
{"project": "qemu", "commit_id": "d6b6abc51dda79a97f2c7bd6652c1940c068f1ec", "target": 1, "func": "void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,\n\n                              FWCfgCallback select_cb,\n\n                              FWCfgWriteCallback write_cb,\n\n                              void *callback_opaque,\n\n                              void *data, size_t len, bool read_only)\n\n{\n\n    int i, index, count;\n\n    size_t dsize;\n\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n\n    int order = 0;\n\n\n\n    if (!s->files) {\n\n        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);\n\n        s->files = g_malloc0(dsize);\n\n        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);\n\n    }\n\n\n\n    count = be32_to_cpu(s->files->count);\n\n    assert(count < fw_cfg_file_slots(s));\n\n\n\n    /* Find the insertion point. */\n\n    if (mc->legacy_fw_cfg_order) {\n\n        /*\n\n         * Sort by order. For files with the same order, we keep them\n\n         * in the sequence in which they were added.\n\n         */\n\n        order = get_fw_cfg_order(s, filename);\n\n        for (index = count;\n\n             index > 0 && order < s->entry_order[index - 1];\n\n             index--);\n\n    } else {\n\n        /* Sort by file name. */\n\n        for (index = count;\n\n             index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;\n\n             index--);\n\n    }\n\n\n\n    /*\n\n     * Move all the entries from the index point and after down one\n\n     * to create a slot for the new entry.  Because calculations are\n\n     * being done with the index, make it so that \"i\" is the current\n\n     * index and \"i - 1\" is the one being copied from, thus the\n\n     * unusual start and end in the for statement.\n\n     */\n\n    for (i = count + 1; i > index; i--) {\n\n        s->files->f[i] = s->files->f[i - 1];\n\n        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);\n\n        s->entries[0][FW_CFG_FILE_FIRST + i] =\n\n            s->entries[0][FW_CFG_FILE_FIRST + i - 1];\n\n        s->entry_order[i] = s->entry_order[i - 1];\n\n    }\n\n\n\n    memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n\n    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n\n\n\n    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n\n    for (i = 0; i <= count; i++) {\n\n        if (i != index &&\n\n            strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n\n            error_report(\"duplicate fw_cfg file name: %s\",\n\n                         s->files->f[index].name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,\n\n                              select_cb, write_cb,\n\n                              callback_opaque, data, len,\n\n                              read_only);\n\n\n\n    s->files->f[index].size   = cpu_to_be32(len);\n\n    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);\n\n    s->entry_order[index] = order;\n\n    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);\n\n\n\n    s->files->count = cpu_to_be32(count+1);\n\n}\n", "idx": 8522, "substitutes": {"s": ["l", "session", "is", "its", "strings", "m", "http", "t", "gs", "hm", "state", "groups", "ans", "ns", "hs", "spec", "self", "settings", "sg", "ds", "si", "n", "your", "sites", "sf", "w", "b", "c", "e", "se", "request", "args", "sq", "us", "f", "sym", "sets", "es", "r", "this", "u", "as", "comments", "fs", "ps", "site", "times", "ss", "uses", "ks", "sv", "g", "stats", "ops", "d", "ys", "ls", "os", "cs", "o", "sync", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "conf", "ts", "in", "service", "p", "server", "qs", "tests", "ins", "xs", "js", "rs", "aws", "S", "states", "services", "h", "ses", "uns", "y", "bs", "events"], "filename": ["fil", "original", "il", "prefix", "sf", "word", "unc", "password", "fd", "path", "files", "x", "tty", "rl", "config", "uri", "username", "fp", "txt", "Filename", "xxx", "f", "binary", "size", "slice", "nil", "name", "connection", "callback", "kn", "dll", "fn", "file", "fs", "url", "length", "gz", "directory", "which", "buffer", "kl"], "select_cb": ["select_rb", "select_pc", "select_cv", "connect_cv", "connect_rb", "connect_pc", "connect_cb"], "write_cb": [" write_func", "write_buff", "write_callback", " write_callback", "write_func", " write_buff"], "callback_opaque": ["callback_paque", "callback_ospacity", "callback__opid", "callback_opacity", "callback_pid", "callback_ospaque", "callback__opec", "callback__copaque", "callback_ospec", "callback_copaque", "callback_copacity", "callback__copec", "callback__copid", "callback__opaque", "callback__opacity", "callback_pacity", "callback_pec", "callback_opid", "callback_copid", "callback_copec", "callback_ospid", "callback_opec", "callback__copacity"], "data": ["session", "source", "media", "window", "record", "d", "buf", "block", "config", "batch", "memory", "body", "DATA", "binary", "dat", "call", "connection", "response", "callback", "Data", "bytes", "message", "image", "result", "bin", "write", "cache", "buffer"], "len": ["seq", "byte", "cmp", "str", "val", "all", "open", "mem", "block", "limit", "ls", "cb", "args", "loc", "code", "bl", "lib", "cap", "flags", "en", "type", "pos", "length", "bin", "Len"], "read_only": ["read_wait", "write_Only", "readvalonly", "write_all", "readvalwait", "read_all", "readvalall", "write_only", "readvalOnly", "write_wait", "read_Only"], "i": ["l", "ui", "di", "it", "is", "si", "n", "in", "id", "xi", "m", "my", "x", "ini", "b", "c", "p", "ix", "uri", "e", "yi", "mini", "eni", "f", "ie", "j", "code", "ai", "o", "multi", "size", "slice", "v", "ind", "name", "mi", "phi", "ti", "gi", "abi", "inner", "qi", "ei", "bi", "pi", "part", "ii", "list", "init", "u", "type", "I", "li", "ip", "ci", "a", "ni", "io", "y", "ri", "fi", "iu"], "index": ["parent", "connect", "find", "path", "x", "block", "config", "uri", "thread", "condition", "loc", "none", "ie", "call", "connection", "end", "sort", "full", "ii", "offset", "type", "image", "element", "si", "n", "val", "date", "key", "all", "id", "xi", "instance", "c", "expression", "e", "value", "f", "j", "zero", "slice", "ind", "input", "current", "position", "list", "insert", "member", "di", "initial", "page", "num", "action", "coll", "xxx", "alpha", "version", "size", "column", "sync", "order", "ih", "old", "cache", "weight", "success", "diff", "level", "ui", "original", "active", "start", "comment", "in", "info", "ini", "Index", "pointer", "other", "ix", "number", "search", "inc", "name", "address", "qi", "option", "pos", "loop", "ci", "length", "match"], "count": ["l", "cond", "base", "start", "n", "find", "class", "key", "id", "low", "b", "path", "num", "last", "con", "c", "sum", "pool", "time", "p", "max", "limit", "close", "number", "loc", "coll", "group", "f", "cc", "select", "large", "code", "found", "child", "call", "size", "catch", "process", "name", "connection", "ind", "order", "load", "counter", "first", "list", "cast", "col", "type", "file", "loop", "cycle", "length", "cache", "Count", "weight", "core", "force", "depth", "use", "ch"], "dsize": ["lsize", " dbytes", "msize", "dlsize", " diz", "dllen", "dname", "dscale", "fdiz", "Diz", "dcount", "sdlen", "sdsize", "Dscale", " dname", "dpack", "lbytes", "fdscale", "sdscale", "dlpack", " dscale", " dize", " dcount", "liz", "fdbytes", " dlen", " dpack", "Dize", "Dsize", "sdpack", "lscale", "mname", "dize", "lize", "dlscale", "fdsize", "dlen", "diz", "dbytes", "Dname", "mcount", "Dcount"], "mc": ["mac", "cow", "co", "mn", " MC", "m", "tc", "mr", "MC", "mm", "c", "vm", "mic", "bc", "cc", "ac", "ml", "mp", "cus", "mx", "mi", "md", "Mc", "dc", "pc", "mot", "ms", "cms", "gc", "nc", "cm", "ca", "ma", "rg", "cfg", "uc", "cy"]}}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n", "idx": 8526, "substitutes": {"f": ["l", "rf", "uf", "conf", "fu", "fo", "fen", "n", "ff", "ph", "af", "sf", "def", "w", "m", "fr", "info", "fd", "t", "x", "b", "k", "fw", "d", "c", "fb", "fal", "p", "e", "fp", "cf", "feed", "q", "df", "fa", "fm", "bf", "tf", "v", "fx", "r", "fun", "elf", "fn", "u", "form", "F", "file", "fs", "ft", "func", "inf", "fi", "fe", "fc"], "opaque": ["paque", "opacity", "opac", "opasso", "hoprique", "hopasso", " oprique", "operacity", "iopaque", "hopac", " opac", "oprique", " opaques", "paques", " opacity", "iopac", "hopaque", "pacity", " opasso", "operaque", "iopasso", "opaques", "ioprique", "operaques"], "s": ["l", "session", "is", "its", "strings", "m", "t", "gs", "sum", "er", "sy", "v", "err", "ns", "spec", "ser", "settings", "sg", "ds", "si", "n", "sites", "sf", "b", "c", "e", "se", "args", "sq", "us", "j", "sym", "sets", "es", "ar", "r", "en", "as", "u", "fs", "su", "site", "ps", "ss", "ess", "sc", "ks", "g", "ops", "d", "ys", "ls", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "ions", "a", "ssl", "conf", "ts", "rows", "in", "service", "p", "qs", "js", "an", "aws", "S", "states", "services", "ms", "h", "ses", "y"], "i": ["oi", "l", "vi", "hi", "ui", "di", "start", "si", "n", "adi", "zi", "m", "xi", "info", "id", "b", "x", "ini", "ami", "iv", "d", "c", "ji", "line", "limit", "p", "uri", "ix", "e", "mu", "yi", "eni", "ie", "dr", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "ti", "phi", "chi", "qi", "abi", "bi", "pi", "ii", "init", "u", "layer", "I", "li", "ip", "loop", "a", "ci", "io", "ni", "y", "ri", "fi", "iu", "ki"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static void exit_program(void)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        avfilter_graph_free(&filtergraphs[i]->graph);\n\n        for (j = 0; j < filtergraphs[i]->nb_inputs; j++) {\n\n            av_freep(&filtergraphs[i]->inputs[j]->name);\n\n            av_freep(&filtergraphs[i]->inputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->inputs);\n\n        for (j = 0; j < filtergraphs[i]->nb_outputs; j++) {\n\n            av_freep(&filtergraphs[i]->outputs[j]->name);\n\n            av_freep(&filtergraphs[i]->outputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->outputs);\n\n        av_freep(&filtergraphs[i]->graph_desc);\n\n        av_freep(&filtergraphs[i]);\n\n    }\n\n    av_freep(&filtergraphs);\n\n\n\n    /* close files */\n\n    for (i = 0; i < nb_output_files; i++) {\n\n        AVFormatContext *s = output_files[i]->ctx;\n\n        if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)\n\n            avio_close(s->pb);\n\n        avformat_free_context(s);\n\n        av_dict_free(&output_files[i]->opts);\n\n        av_freep(&output_files[i]);\n\n    }\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters;\n\n        while (bsfc) {\n\n            AVBitStreamFilterContext *next = bsfc->next;\n\n            av_bitstream_filter_close(bsfc);\n\n            bsfc = next;\n\n        }\n\n        output_streams[i]->bitstream_filters = NULL;\n\n        avcodec_free_frame(&output_streams[i]->filtered_frame);\n\n\n\n        av_freep(&output_streams[i]->forced_keyframes);\n\n        av_freep(&output_streams[i]->avfilter);\n\n        av_freep(&output_streams[i]->logfile_prefix);\n\n        av_freep(&output_streams[i]);\n\n    }\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        avformat_close_input(&input_files[i]->ctx);\n\n        av_freep(&input_files[i]);\n\n    }\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        av_frame_free(&input_streams[i]->decoded_frame);\n\n        av_frame_free(&input_streams[i]->filter_frame);\n\n        av_dict_free(&input_streams[i]->opts);\n\n        av_freep(&input_streams[i]->filters);\n\n        av_freep(&input_streams[i]);\n\n    }\n\n\n\n    if (vstats_file)\n\n        fclose(vstats_file);\n\n    av_free(vstats_filename);\n\n\n\n    av_freep(&input_streams);\n\n    av_freep(&input_files);\n\n    av_freep(&output_streams);\n\n    av_freep(&output_files);\n\n\n\n    uninit_opts();\n\n\n\n    avfilter_uninit();\n\n    avformat_network_deinit();\n\n\n\n    if (received_sigterm) {\n\n        av_log(NULL, AV_LOG_INFO, \"Received signal %d: terminating.\\n\",\n\n               (int) received_sigterm);\n\n        exit (255);\n\n    }\n\n}\n", "idx": 8534, "substitutes": {"i": ["oi", "l", "ui", "di", "it", "is", "si", "n", "start", "g", "zi", "in", "id", "xi", "info", "m", "b", "x", "ini", "my", "iv", "d", "iq", "p", "uri", "ix", "e", "yi", "cli", "isi", "eni", "f", "ie", "ai", "multi", "index", "module", "ind", "mi", "gi", "ih", "ik", "phi", "ic", "ti", "inner", "qi", "ij", "im", "ei", "pi", "bi", "ii", "init", "u", "I", "li", "ip", "ci", "api", "ori", "ni", "io", "y", "a", "ri", "interface", "fi", "iu", "ki"], "j": ["l", "ani", "ui", "je", "ju", "it", "adj", "n", "g", "key", "w", "m", "xi", "fr", "jet", "k", "b", "dj", "z", "x", "d", "jen", "ji", "other", "jo", "jam", "p", "e", "el", "ix", "kj", "gh", "eni", "js", "q", "f", "ie", "uj", "o", "v", "ih", "pr", "qi", "ij", "im", "jp", "ii", "ja", "u", "aj", "h", "oj", "li", "J", "y", "jc", "jl", "jj"], "s": ["session", "sg", "sv", "is", "ds", "g", "n", "si", "your", "sf", "m", "http", "t", "b", "d", "gs", "service", "c", "p", "ls", "e", "js", "sq", "us", "f", "os", "sym", "o", "S", "v", "sync", "es", "sl", "services", "r", "sup", "sb", "ns", "hs", "storage", "spec", "u", "sys", "secondary", "a", "ses", "comments", "ss", "ssl"], "bsfc": ["psfc", "bspc", "dsbc", "usfn", "wsfn", "bascf", "besfc", "sslc", "wsfp", "issci", "ksci", "ssfp", "wslc", "basfd", "pspc", "ksfc", "besfe", "dsfb", "csfb", "uscf", "BSfp", "outsfd", "osfd", "outsfc", "basfc", "vsfc", "vsfp", "isscf", "vscf", "osfn", "ksfp", "osfc", "outscf", "besfd", "usfd", "nsfn", "psbc", "nsfd", "bsfb", "bsfp", "outsfe", "bsfd", "dsfc", "kscf", "bsfe", "basfe", "bsbc", "csbc", "bescf", "BSfn", "issfp", "BSfc", "oscf", "bsci", "issfc", "bsfn", "ssfn", "bslc", "usfc", "dspc", "bscf", "nscf", "csfc", "cspc", "vsci", "ssfc", "BSlc", "wsfc", "psfb", "nsfc"], "next": ["later", "parent", "dot", "seq", "valid", "follow", "cmp", "key", "again", "second", "another", "open", "path", "page", "latest", "last", "iss", "other", "data", "head", "max", "prev", "close", "global", "ptr", "coll", "group", "sec", "network", " Next", "sequence", "primary", "code", "child", "alloc", "cv", "current", "future", "cur", "sen", "new", "first", "now", "root", "Next", "this", "self", "client", "secondary", "children", "proc"]}}
{"project": "qemu", "commit_id": "091b1108ca6d6e3bfaea5f095f219bf5ea8c316b", "target": 1, "func": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n", "idx": 8543, "substitutes": {"bs": ["vs", "boot", "base", "ks", "ds", "bid", "bas", "b", "ils", "ab", "gs", "iss", "fb", "ls", "pb", "cb", "ins", "ros", "bits", "rb", "outs", "us", "js", "BS", "bc", "obs", "cs", "bps", "ubs", "fps", "bis", "bi", "sb", "ns", "bus", "fs", "ses", "ps", "ob", "css", "bos"], "sector_num": [" sector_su", "sectorvalsu", "sectorvaloff", "sector_su", "sectorvalnum", "section_off", " sector_number", "section_number", "sector_off", "sectorvalsum", "sectorvalnumber", "sector_sum", " sector_name", "section_sum", "sectorvalname", "section_num", "sector_name", "sector_number"], "nb_sectors": ["nb_veores", "nb_psecs", "nb_speors", "nb_vectors", "nb_specs", "nb_secs", "nb_seors", "nb_tegments", "nb_tecs", "nb_seores", "nb_pectors", "nb_pegments", "nb_segments", "nb_vecs", "nb_psegments", "nb_psectors", "nb_peors", "nb_spectors", "nb_pecs", "nb_tectors", "nb_teores", "nb_vegments", "nb_pseores", "nb_veors", "nb_spegments"], "num_same": ["num\u00b7repeat", "num_two", "numemsame", "num_missing", "num_shared", " num_two", "numemtwo", "num_repeat", " num_missing", " num_share", " num_shared", "num\u00b7two", "numemshared", "num_share", "numemrepeat", " num_repeat", "num\u00b7same", "num\u00b7shared"], "bitmap": ["BITMAP", "bitMAP", "binwise", "binmaps", "binload", "hitwise", "BITmap", "bitwise", "BITMap", " bitwise", "bugblock", "byteMAP", "tagcache", "bitmask", " bitMap", "hitmap", "bitMap", "bytecache", "bitsaddress", "BITblock", "bitnumber", "byteaddress", "bootblock", " bitnumber", "byteMap", "binmap", " bitcache", "bitaddress", "binMAP", " bitmask", "bugmask", "bugMap", " bitmaps", "bitmaps", "bytenumber", "tagmaps", "bytemap", "bugmap", "hitmaps", "bitblock", "bitsMap", "binaddress", "bootmask", " bitblock", "bitload", " bitload", "byteblock", "bootmap", "binMap", "bytemaps", "bootMap", "bitsmaps", "bitsmap", "binblock", "tagmap", "tagnumber", "hitload", "bitcache"], "ret": [" updated", "repl", "valid", "flag", "active", "alt", "val", "len", "fail", "nt", "Ret", "num", "update", "pat", "data", "reply", "ref", "lit", "reg", "set", " result", "hard", "rb", "rets", "f", "rot", "code", "rt", "found", "res", "expected", "det", "bf", "replace", "rc", "r", "att", "end", "err", "ception", "new", " sent", "part", "art", "error", "rep", "bit", "cat", "change", "re", "RET", "back", " RET", "result", "mt", "br", "rl", "success", "reset"], "changed": ["diff", "initialized", " updated", "updated", "valid", " written", "g", "val", "anged", "temp", "changing", "changes", "added", "update", "edited", " unchanged", "data", "config", "locked", "ref", "used", "value", "loaded", "bug", "packed", "Changed", "written", "rot", "unit", "found", "expected", "handled", "broken", "current", " altered", "protected", "received", "aligned", "err", "new", "checked", "error", "stable", "change", "confirmed", "weight", "modified", "fe"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "substitutes": {"timer_list": ["tick_tree", "timer_record", "timerlisttest", "timer_count", "er_batch", "later_add", "meter_config", "timerlistget", "timer_stack", "timerappdef", "timerxList", "theme6stack", "timeridlist", "timerlistqueue", "timer2get", "timer_left", "timerlistlist", "theme_stack", "timerallconfig", "timer_table", "timerdrecord", "tick_List", " timer_diff", "timer_def", "meter_get", "timerkdiff", "timerxlist", "timer6LIST", "timerktable", "meterappdef", "timer0test", "theme0detail", "ticklisttree", "timer5stack", "theme_detail", "timer_type", "er_pair", "theme_LIST", "timer_queue", "theme_get", "timer_diff", "theme6list", "ticklistlist", "timerdlist", "timerAcount", "timerapplist", "meterappget", "timerlistList", "meter_def", "theme0get", "timer0detail", "theme_test", "timer6stack", "later_left", "ticklistList", "tick_queue", "timerlList", "timer0list", "timer5LIST", "tick_list", "timer6list", "timer_LIST", "timer6get", "timer_tree", "timerallget", "timerappget", "timerxpair", "timerklist", "ticklistqueue", "timeridleft", "timerAlist", "timerltree", "later_list", "timer_detail", "timer_config", "timer0get", "timeralldef", "er_list", "theme6get", "lateridbatch", "timerxrecord", "timer_lock", "timerappstack", "timer5get", "timerdList", "theme0list", "timerappLIST", "timer_batch", "timerlqueue", "timer_pair", "later_batch", "timerAtable", "theme0test", "er_type", "meterappconfig", "timer2config", "timer_List", "timer2list", "timer_add", " timer_count", "timer2def", "lateridlist", "timeralllist", "theme_list", "er_List", "timerllist", "timerlisttree", "timeridbatch", "timerappconfig", "timerlistdetail", "timerAdiff", "er_record", "er_lock", " timer_table", "lateridleft", "theme6LIST", "meter_list", "meterapplist", "timerkcount", "lateridadd", "timer_get", "timerdpair", "timer_test", "timeridadd", "timer5list"], "expire_time": ["expire___hour", "expirexmoney", "expireycount", "expireyhour", "expirexmode", "expire64money", "expire64hour", "expire___count", "expireytime", "expire64start", "expire_mode", "expire___time", "exake_start", "expiration_money", "expiration_timeout", "expire64timeout", "exire_money", "exire_count", "expireystart", "exire_Time", "expire__money", "expire___start", "expire_money", "exake___count", "exake___time", "expiration_time", "expire_Time", "expire_count", "expirextime", "expire_timeout", "expire64count", "expirefmoney", "expireftime", "expirefmode", "exire_time", "expire_hour", "exake_count", "exire_mode", "exake_hour", "expire__timeout", "exake___start", "expire64time", "expire__time", "expire_start", "exake_time", "exake___hour"]}}
{"project": "qemu", "commit_id": "e97fc193e1c65deb51643d5251e98affe07c59ca", "target": 0, "func": "static void check_refcounts(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n\n\n    size = bdrv_getlength(s->hd);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  0, s->cluster_size);\n\n\n\n    check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                           sn->l1_table_offset, sn->l1_size, 0);\n\n    }\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->refcount_table_offset,\n\n                  s->refcount_table_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        int64_t offset;\n\n        offset = s->refcount_table[i];\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, refcount_table, nb_clusters,\n\n                          offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2)\n\n            fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\",\n\n                   i, refcount1, refcount2);\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n}\n", "idx": 8568, "substitutes": {"bs": ["vs", "base", "bb", "ks", "ds", "is", "lbs", "stats", "org", "src", "b", "gs", "sa", "iss", "fb", "ls", "pb", "obj", "cb", "gb", "ros", "ins", "rss", "xs", "bits", "js", "rs", "BS", "os", "bc", "banks", "plugins", "obs", "cs", "us", "bl", "eb", "bps", "sync", "bh", "fps", "state", "las", "lb", "bis", "bi", "ns", "sb", "sys", "ses", "fs", "ob", "ps", "css", "ss", "bn", "bes", "bos"], "s": ["l", "session", "is", "its", "m", "t", "gs", "v", "state", "bis", "full", "ns", "spec", "self", "params", "settings", "sg", "ds", "n", "si", "sites", "w", "b", "c", "e", "args", "us", "f", "sym", "sets", "r", "sis", "fs", "su", "site", "ps", "ess", "ss", "ks", "g", "stats", "d", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "sb", "sys", "secondary", "a", "ssl", "vs", "ts", "service", "p", "qs", "ins", "xs", "js", "rs", "aws", "S", "states", "services", "ms", "ses", "css"], "size": ["count", "iz", "timeout", "scale", "si", "len", "g", "capacity", "n", "small", "SIZE", "c", "max", "sum", "ix", "time", "e", "loc", "empty", "Size", "sec", "large", "code", "unit", "ice", "shape", "name", "six", "sized", "address", "en", "storage", "type", "complete", "length", "ize", "weight", "core", "sc", "fee"], "nb_clusters": ["nb_custers", "nb_licusters", "nbOfsluster", "nb_slows", "nb_gluster", "nb_CLurs", "nb_cliques", "nb_labuster", "nb_CLuster", "nb_aclows", "nbJclunks", "nb_sclusters", "nb_slusters", "nb_shushes", "nb_labases", "nb_sclroups", "nb_labusters", "nb_clases", "nb_CLases", "nb_lliques", "nb_llards", "nb_acliffs", "nb_helluster", "nb_gallusters", "nb_cores", "nb_laburs", "nb_klambers", "nb_critusters", "nb_colores", "nb_glurs", "nbOfcluster", "nb_clocations", "nbOfslores", "nb_clushes", "nb_slroups", "nb_elust", "nbOfslusters", "nb_clores", "nb_slushes", "nb_plicas", "nb_splows", "nb_clayers", "nb_clust", "nb_sclayers", "nb_plocations", "nb_colusters", "nb_slores", "nb_klurs", "nb_laows", "nb_hellases", "nb_CLoses", "nb_liciffs", "nb_spliffs", "nb_aclroups", "nbJlabunks", "nb_licurs", "nb_splurs", "nb_gallosures", "nb_slocations", "nb_laayers", "nb_laboses", "nb_coluster", "nb_clows", "nb_galliques", "nb_closes", "nb_glusters", "nb_llusters", "nb_cliffs", "nb_helloses", "nb_elicas", "nbJclurs", "nb_sluster", "nb_CLores", "nb_plusters", "nb_klusters", "nb_blicas", "nb_hellusters", "nbJlabusters", "nb_shurs", "nb_clunks", "nb_critards", "nb_labunks", "nb_sclows", "nb_licambers", "nb_clards", "nb_CLusters", "nb_sliffs", "nb_critiques", "nb_splusters", "nb_blocations", "nb_elocations", "nb_glunks", "nb_slayers", "nbOfclores", "nb_CLunks", "nb_cocations", "nbJclusters", "nb_CLocations", "nb_clicas", "nb_kliffs", "nb_aclushes", "nbJlabuster", "nbOfclusters", "nb_aclusters", "nb_clroups", "nb_elusters", "nb_shroups", "nb_lausters", "nb_blust", "nb_cluster", "nb_shusters", "nbOfcliffs", "nb_clurs", "nb_clambers", "nb_plust", "nb_slurs", "nb_gallards", "nbJlaburs", "nbOfsliffs", "nb_CLiffs", "nb_aclurs", "nb_critosures", "nb_coliffs", "nb_blusters", "nb_laroups", "nb_llosures", "nb_slambers", "nb_custer", "nbJcluster", "nb_closures"], "refcount1": ["referencecount4", "refcount01", " refcounts", "refsum1", "refount4", "relount1", "refprocess01", "relountOne", " refcount4", "refprocess4", "refounts", "relcountOne", "refcheck9", "refCount1", " refcount9", "refsum4", "refCountOne", "referencecount1", " refCount4", "refcounts", " refcountOne", "referencecount2", "referenceount4", "refCount4", "relcount1", " refcount01", "relount4", "referenceount1", "refprocess1", "refprocesss", "refcount9", "refCount01", " refCount1", "refprocess9", "refsum2", "referencecountOne", "refount01", " refCountOne", "referenceount2", "refsumOne", " refCounts", "refount1", " refCount9", "refCount9", "refcheck1", "refountOne", "referenceountOne", "refprocessOne", "refcheckOne", "refcount4", "refount2", "refcheck4", "refCounts", "relcount4", " refCount01", "refcountOne"], "refcount2": ["refcount22", "referencecount4", "referencecount02", "refount4", "refcount02", "refload42", "relount1", "relountTwo", "refcode22", "refCount02", "refsum4", "refloadTwo", "refcache3", "referencecount1", "refountTwo", "referencecount2", "referenceount4", "refount02", "referencecountTwo", "refCount4", "relcount1", "relc2", "relcount3", "relount2", "refcountTwo", "referenceount1", "refc1", "refsum2", "refload1", "refcache2", "refcache1", "refload2", "relcount42", "refcode1", "relc42", "refCount2", "referenceount2", "referenceount02", "refcacheTwo", "relcount2", "refcodeTwo", "relcountTwo", "refcTwo", "refount1", "refcount42", "referenceountTwo", "referenceount22", "refc42", "referencecount22", "refount3", "relcTwo", "refcode2", "relount3", "relc1", "refcount3", "refcount4", "refount2", "refsum02", "refount22", "refc2"], "i": ["l", "m", "x", "z", "uri", "step", "ie", "v", "isin", "phi", "ii", "init", "ori", "ri", "fi", "oi", "vi", "si", "n", "key", "id", "xi", "ami", "b", "c", "e", "mu", "f", "j", "index", "slice", "r", "bi", "u", "li", "ni", "ski", "hi", "di", "g", "zi", "d", "data", "yi", "cli", "eni", "ai", "o", "gi", "chi", "pi", "part", "I", "iu", "ki", "ui", "it", "start", "in", "info", "ini", "ji", "p", "ix", "multi", "name", "ti", "mi", "ik", "inner", "qi", "uni", "ip", "ci", "io", "y"], "sn": ["vi", "SN", "sp", "sh", "sv", "span", "n", "si", "nb", "zi", "sf", "ny", "conn", "sw", "sa", "ssl", "sam", "ls", "cn", "nw", "sk", "syn", "sync", "ti", "sl", "chi", "sm", "Sn", "nr", "kn", "ki", "sb", "ns", "ii", "bi", "sd", "cl", "fn", "scl", "li", "nu", "ci", "su", "ni", "bn", "ski", "lc", "jc", "sr", "ss", "nn", "sc"], "refcount_table": ["refcount24resource", "reftimeOtree", "reftime_table", "refcountrmachine", "refnameedbuffer", "refprocess2tree", "refcountstab", "refcountNerror", "refcountedtable", "refqueueedsection", "refcountNtable", "refcount_TABLE", "refcountingtask", "refcount67batch", "refcount2session", "refcountrstable", "refcount67stable", "refcountingresource", "refcountPsection", "refcountOcache", "refount_table", "refqueue_error", "referrorJelement", "reftime_tab", "reftimeOtab", "refcode_cache", "refnameingresource", "refcheck_tab", "refcountJstable", "refcountxtable", "refcountstree", "refname_table", "refcheck_batch", "refcountingTable", "refcountOtree", "refcountNarray", "refcheck_stable", "refnameingtable", "refcountedarray", "refqueueedtable", "refcount2Table", "refcount67tab", "refsum_service", "refcode_state", "refcount2tree", "refcount_task", "refcountPerror", "refcountedsection", "refcount_stable", "refcountedTABLE", "refcountedTable", "referrorJtable", "refcount24task", "refcountedcenter", "refcountxmachine", "refcountscache", "refnameedtable", "refcount_cache", "reftime_cache", "refcount2table", "refsum_file", "refcountJstate", "referror_element", "refsum_Table", "refcountstable", "refqueueedarray", "reftimeOtable", "refcountJfile", "refcount_tab", "referrorJmachine", "refprocess2table", "refcount_section", "refcountJelement", "refqueue_table", "refcountOtab", "refprocess_session", "refcode_file", "refcountPtable", "refcountxresource", "reftime_tree", "refcount_machine", "refcountJtable", "refcount_total", "refnameedcenter", "refcount_center", "refcountOtable", "refcount_error", "refcount_database", "refname_machine", "refcountDtable", "refcountxtask", "refcount24machine", "refprocess_table", "refnameingtask", "reftimeOcache", "refcountederror", "refcountDbatch", "refsum_TABLE", "refcountingmachine", "refcount67table", "refcount_tree", "refcountDstable", "refcount_session", "refcheck_table", "refname_buffer", "refcountDtab", "refsum_table", "refcount_buffer", "refcount24table", "refount_Table", "refcountJmachine", "referror_stable", "refcount_file", "referror_machine", "refcode_table", "refname_center", "refcountrtable", "refcount_state", "refqueue_section", "refqueueederror", "refcountParray", "referror_table", "refcountJcache", "refnameedtotal", "refname_total", "refcount_service", "refcount_element", "refcountedservice", "refcount_batch", "refount_database", "refcountingtable", "refprocess2Table", "refcountedtotal", "referrorJstable", "refnameingmachine", "refcountrelement", "refname_resource", "refprocess_tree", "refcountNsection", "refcount_array", "refqueue_array", "refcountingdatabase", "refprocess_Table", "refname_task", "refprocess2session", "refcount_Table", "refcount_resource", "refcountedbuffer"], "offset": ["snap", "location", "timeout", "base", "optional", "start", "len", "alt", "key", "id", "num", "notation", "shift", "pointer", "slot", "addr", "ref", "p", "ace", "attr", "set", "skip", "number", "off", "loc", "next", "padding", "entry", "alpha", "o", "index", "slice", "align", "end", "object", "address", "aff", "new", "part", "position", "ii", "error", "type", "pos", "ip", "attribute", "activation", "api", "image", "ski", "Offset", "range", "reset"]}}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 8577, "substitutes": {"ip": ["ipe", "zip", "sp", "inet", "id", "ipp", "chip", "iv", "pp", "cp", "p", "ix", "fp", "ep", "machine", "gp", "IP", "arp", "op", "inst", "host", "device", "mp", "address", "im", "port", "jp", "ips", "api", "interface", "image", "io", "proc", "vp"], "s": ["sp", "sg", "sh", "sv", "is", "n", "g", "ds", "si", "stats", "m", "b", "ops", "d", "gs", "sa", "c", "service", "sam", "p", "e", "sq", "socket", "f", "cs", "o", "S", "v", "south", "sl", "state", "services", "ns", "storage", "sb", "spec", "sys", "ses", "ps", "ss", "y", "ssl", "sc"], "i": ["oi", "l", "hi", "ui", "di", "axis", "si", " ii", "n", "zi", "m", "id", "xi", "b", "x", "k", "z", "ini", "d", "c", "p", "ix", "uri", "e", "yi", "eni", "f", "ie", "j", "ai", "multi", "slice", "v", "ind", "gi", "mi", "ti", "phi", "r", "abi", "inner", "qi", "address", "bi", "pi", "ii", "u", "uni", "I", "li", "ci", "ni", "io", "y", "ri", "fi", "iu"], "ch": ["channel", "conf", "sh", "cand", "cmp", "arch", "ach", "ph", "conn", "ich", "chip", "k", "c", "cp", "config", "p", "el", "e", "cb", "chn", "cf", "CH", "q", "cho", "hw", "sk", "inst", "code", "cs", "zh", "child", "th", "cht", "cha", "chart", "che", "ce", "cher", "bh", "cham", "ctx", "chi", "sch", "cl", "patch", "cor", "ench", "enc", "col", "Ch", "h", "change", "ech", "form", "dev", "client", "ci", "her", "vc", "cache", "chan", "core", "kick", "cy", "sc", "exec"], "chr_name": ["chr_id", "chr_label", "chrb2name", "chrb2key", "char_key", "char_id", "char_name", "chr_number", "chdr_name", "chrb2number", "chrb_number", "chrb2type", "chrb_key", "chdr_label", "chr2key", "chr2number", "chr_Name", "chr2type", "chrb_type", "chr_key", "char_Name", "chr_type", "chr2name", "chdr_Name", "chrb_name"], "label": ["l", "alias", "channel", "byte", "base", "bad", "field", "str", "comment", "val", "prefix", "key", "pad", "hide", "info", "lab", "display", "model", "id", "path", "ab", "block", "line", "fb", "ell", "el", "ref", "layout", "config", "data", "frame", "loc", "title", "dl", "unit", "binary", "bl", "abel", "msg", "description", "route", "name", "ind", "eb", "align", "address", "desc", " Label", "error", "list", "summary", "unknown", "col", "bel", " labels", "message", "null", "url", "text", "Label", "br", "bean"], "index": ["count", "fix", "str", "start", "len", "section", "axis", "prefix", "key", "id", "point", "x", "ini", "num", "Index", "instance", "page", "pointer", "data", "block", "ix", "value", "condition", "loc", "array", "j", "alpha", "slice", "inc", "ind", "name", "connection", "end", "address", "new", "position", "error", "offset", "col", "type", "pos", "loop", "length", "weight"]}}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n", "idx": 8592, "substitutes": {"r1": ["r01", "ROne", "r5", "rangeOne", "rOne", "e1", "rs2", "e01", "sr5", "range1", "R2", "sr1", "eOne", "R5", "range2", "e2", "sr01", "R01", "R1", "r3", "R3", "range01", "range5", "rsOne", " rOne", "rs3", "rs1", " r3", " r01", "sr2"], "r2": ["rSecond", "rII", " rSecond", "rbtwo", "rc2", "rt182", "rt1", "r6", "rt2", "arSecond", "ar2", "rc1", "rtwo", "RII", "R2", "rb2", "artwo", "rrtwo", " rtwo", "R1", "rtII", "rb1", "rr2", "ar1", "rcII", "rr1", "rttwo", "rc182", "rtSecond", " r6", "rr6", "r182", "rb6", "R182"]}}
{"project": "FFmpeg", "commit_id": "7fffc879798bbbad647ad2b1b30f26855bf2abda", "target": 0, "func": "static int wc3_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    Wc3DemuxContext *wc3 = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    unsigned int fourcc_tag;\n\n    unsigned int size;\n\n    AVStream *st;\n\n    unsigned char preamble[WC3_PREAMBLE_SIZE];\n\n    int ret = 0;\n\n    int current_palette = 0;\n\n    int bytes_to_read;\n\n    int i;\n\n    unsigned char rotate;\n\n\n\n    /* default context members */\n\n    wc3->width = WC3_DEFAULT_WIDTH;\n\n    wc3->height = WC3_DEFAULT_HEIGHT;\n\n    wc3->palettes = NULL;\n\n    wc3->palette_count = 0;\n\n    wc3->pts = 0;\n\n    wc3->video_stream_index = wc3->audio_stream_index = 0;\n\n\n\n    /* skip the first 3 32-bit numbers */\n\n    url_fseek(pb, 12, SEEK_CUR);\n\n\n\n    /* traverse through the chunks and load the header information before\n\n     * the first BRCH tag */\n\n    if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n        WC3_PREAMBLE_SIZE)\n\n        return AVERROR(EIO);\n\n    fourcc_tag = AV_RL32(&preamble[0]);\n\n    size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    do {\n\n        switch (fourcc_tag) {\n\n\n\n        case SOND_TAG:\n\n        case INDX_TAG:\n\n            /* SOND unknown, INDX unnecessary; ignore both */\n\n            url_fseek(pb, size, SEEK_CUR);\n\n            break;\n\n\n\n        case _PC__TAG:\n\n            /* need the number of palettes */\n\n            url_fseek(pb, 8, SEEK_CUR);\n\n            if ((ret = get_buffer(pb, preamble, 4)) != 4)\n\n                return AVERROR(EIO);\n\n            wc3->palette_count = AV_RL32(&preamble[0]);\n\n            if((unsigned)wc3->palette_count >= UINT_MAX / PALETTE_SIZE){\n\n                wc3->palette_count= 0;\n\n                return -1;\n\n            }\n\n            wc3->palettes = av_malloc(wc3->palette_count * PALETTE_SIZE);\n\n            break;\n\n\n\n        case BNAM_TAG:\n\n            /* load up the name */\n\n            if ((unsigned)size < 512)\n\n                bytes_to_read = size;\n\n            else\n\n                bytes_to_read = 512;\n\n            if ((ret = get_buffer(pb, s->title, bytes_to_read)) != bytes_to_read)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case SIZE_TAG:\n\n            /* video resolution override */\n\n            if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n                WC3_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            wc3->width = AV_RL32(&preamble[0]);\n\n            wc3->height = AV_RL32(&preamble[4]);\n\n            break;\n\n\n\n        case PALT_TAG:\n\n            /* one of several palettes */\n\n            if ((unsigned)current_palette >= wc3->palette_count)\n\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = get_buffer(pb,\n\n                &wc3->palettes[current_palette * PALETTE_SIZE],\n\n                PALETTE_SIZE)) != PALETTE_SIZE)\n\n                return AVERROR(EIO);\n\n\n\n            /* transform the current palette in place */\n\n            for (i = current_palette * PALETTE_SIZE;\n\n                 i < (current_palette + 1) * PALETTE_SIZE; i++) {\n\n                /* rotate each palette component left by 2 and use the result\n\n                 * as an index into the color component table */\n\n                rotate = ((wc3->palettes[i] << 2) & 0xFF) |\n\n                         ((wc3->palettes[i] >> 6) & 0xFF);\n\n                wc3->palettes[i] = wc3_pal_lookup[rotate];\n\n            }\n\n            current_palette++;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\\n\",\n\n                preamble[0], preamble[1], preamble[2], preamble[3],\n\n                preamble[0], preamble[1], preamble[2], preamble[3]);\n\n            return AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n            WC3_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n        fourcc_tag = AV_RL32(&preamble[0]);\n\n        /* chunk sizes are 16-bit aligned */\n\n        size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    } while (fourcc_tag != BRCH_TAG);\n\n\n\n    /* initialize the decoder streams */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_XAN_WC3;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = wc3->width;\n\n    st->codec->height = wc3->height;\n\n\n\n    /* palette considerations */\n\n    st->codec->palctrl = &wc3->palette_control;\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->audio_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n    st->codec->codec_id = CODEC_ID_PCM_S16LE;\n\n    st->codec->codec_tag = 1;\n\n    st->codec->channels = WC3_AUDIO_CHANNELS;\n\n    st->codec->bits_per_sample = WC3_AUDIO_BITS;\n\n    st->codec->sample_rate = WC3_SAMPLE_RATE;\n\n    st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n        st->codec->bits_per_sample;\n\n    st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS;\n\n\n\n    return 0;\n\n}\n", "idx": 8617, "substitutes": {"s": ["sg", "ts", "sv", "its", "si", "n", "ds", "g", "sf", "m", "b", "t", "sci", "gs", "sa", "c", "service", "p", "ls", "e", "se", "sq", "f", "os", "an", "cs", "aws", "S", "v", "sl", "services", "sup", "support", "ns", "sb", "sis", "spec", "sys", "ses", "ps", "su", "fs", "ss", "ssl", "sc"], "ap": [" p", "sp", "wp", "aps", "bp", "pl", "ab", "pa", "pp", "cp", "p", "attr", "np", "au", "arp", "op", "ac", "mp", "al", "cap", "pac", "ar", "att", "am", "jp", "tp", "pi", "AP", "api"], "wc3": ["twlc15", "wsc13", "wec53", "wec1", "ewdc03", "wtc1", "welc03", "wrcthree", "wc23", "wca3", " wc03", "twc3", "wtc53", "wenc53", "wcthree", "wca4", "wfc4", "wincpthree", "wmc53", "wdc2003", "wcs15", "hwcthree", "wincthree", "wecdef", "wdc13", "wvc53", "wfc23", "twlc53", "wlc3", "welcdef", "wincgent", "wec23", "wslc03", "hwrc4", "Wc03", "wpc1", "wlcthree", "wencthree", "ewc5", "wfc2", "wc5", "wf03", "wlc6", "hwrc03", "wsc03", "wcathree", "twc03", "wfthree", "wec13", "ewc2003", "wcpgent", "twcgent", "wcp3", "ewfc03", "wdc1", "wac03", "wenc3", "Wc3", "wfc93", "ewc53", "Wac53", "wdc3", "wc93", "twlcgent", "wmc23", "wlc13", "wfc53", "wsc1", "wvcdef", "welc13", "winc3", "wedc6", "wc2003", "wdc5", "wdc2", "wdc53", "wincp3", "Wac03", "wc2", "wlcdef", "welc53", "ewdc5", "wec3", "ewc03", "winc03", "wcfgent", "wcf3", "hwc4", "wrc3", "wslc15", " wdc03", "wc03", "wec5", "wecry", "wlc03", "wcfthree", "wdcry", "twc15", "wenc03", "wvc5", "Wc53", "ewc3", "wfc3", "wmc03", "wpc3", "wc53", "wlc53", "wslc3", "wec6", "wfc03", " wdc3", "wcs3", "wc6", "wcgent", "wtc03", "wtcry", " wdc1", "wpc2", "wacthree", "wcf15", "wcp03", "wvcgent", "wca03", "wedc03", " wc1", "ewdc3", "wpc03", "Wacthree", "twlc3", "wlc15", "wcry", "wlcgent", "wdc23", "wfgent", "wf3", "wc1", "hwc3", "Wac3", "wcpthree", "ewfc53", "wsc15", "wsc53", "wedc23", "wlc1", "wrc4", " wdcry", "wfcthree", "wincp03", "hwrc3", "wsc3", "wslc1", "wec03", "welc3", "twlc03", "wcf03", "wac3", "wvc2003", "wrc03", "wtc93", "wvc03", "wdcdef", "wtc3", "wc13", "hwrcthree", "wpc15", "wmc3", "wdc03", "Wcthree", "wdc6", "wpc53", "wvc15", "wac53", "wedc3", "wcs03", "twc93", "ewfc3", "ewfc2", "wec2003", "wlc93", "wcdef", "wc15", "ewdc2003", "wedc53", "twlc93", "wvc3", "wc4", "wcs1", "wincpgent", "twc53", "ewc2", "hwc03", " wcry"], "pb": ["lp", "dp", "ib", "param", "bb", "ppa", "pg", "abc", "proc", "ba", "bp", "prot", "pl", "bm", "b", "ab", "wb", "pa", "cp", "fb", "p", "pd", "cb", "fp", "ub", "np", "gb", "pt", "pm", "rb", "prop", "bc", "dl", "pkg", "db", "bf", "eb", "py", "bps", "bh", "ctx", "lb", "tp", "jp", "sb", "pc", "PB", "asm", "summary", "cpp", "hub", "plugin", "platform", "api", "params", "fc", "ob", "xb", "rob", "buffer", "bos", "vp"], "fourcc_tag": ["fourCC_num", "fourCC_tag", "fourkk_type", "fourcc_option", "fourCC_bug", "fourcc_TAG", "fourCC_type", "fourkk_TAG", "fourCC_option", "fourcc_num", "fourkk_tag", "fourcc_type", "fourcc_bug"], "size": ["l", "iz", "timeout", "scale", "si", "len", "n", "capacity", "small", "page", "x", "SIZE", "big", "c", "data", "sum", "p", "max", "e", "mini", "style", "loc", "Size", "large", "sec", "code", "unit", "shape", "name", "six", "address", "en", "storage", "offset", "extra", "length", "use", "ize", "fee"], "st": ["ts", "std", "str", "src", "rest", "sa", "ct", "rss", "ut", "inst", "bl", "nd", "sts", "sta", "sl", "sth", "ste", "art", "storage", "ast", "St", " ss", "ST", "ft", "ss", "sc"], "preamble": ["pounette", "poonbler", "pramette", "prumbled", "pounle", "preamBLE", "praml", "preambles", "Preamble", "pipherle", "preaml", "Pramler", "PreamBLE", "Praml", " Prumble", "pirmle", "Preambled", "Preamette", "Preambler", "prumill", "Prambler", "pREAMl", "parenble", "Prambles", "Pramback", "pepill", "pramler", "pREAMler", "parenill", "prambles", "prambled", "pREAMbles", "pramll", " Prumle", " Preamle", "preamler", "pepble", "pepbled", "Pramette", "Preamll", "preamill", "pirmble", "Preamle", "Preamler", "pREAMble", " Preambled", "pramBLE", "pirmette", "prambler", "pipherback", "pramback", "poonble", "pipherll", "Pramble", "preamll", "Pramle", "pipherble", "preamle", "pounll", "pounble", "Preaml", "pramle", "pREAMBLE", "preambler", "poonback", "preamback", "preambled", "poonle", "PREAMble", " Preamill", "pREAMbled", "PREAMbled", "Preambles", "pirmler", " Preamble", "pREAMle", "preamette", "pepl", "PramBLE", "Preamback", "Pramll", "pipherette", "parenle", "peple", "PREAMle", "pramble", "parenbled", "pirmbles", "pirmBLE", " Prumill", "prumle", "pirml", "prumble", " Prumbled", "PREAMl", "pipherbler", "pREAMette"], "bytes_to_read": ["bytes_per_length", "bytes_to_load", "bytes_per_write", "bytes_to_length", "bytes_to_write", "bytes_per_read", "bytes_per_load"], "i": ["ui", "di", "it", "start", "n", "si", "len", "in", "id", "info", "x", "limit", "p", "iter", "f", "j", "ai", "index", "slice", "ti", "pi", "ii", "offset", "uni", "I", "ip", "io", "ni"], "rotate": ["Rotate", "rotant", "rotated", "orientated", "orientant", "otated", "Rotated", "Rotation", "Rotant", "rotation", "otate", "orientate", "otant", "otation", "orientation"], "current_palette": ["current_opaless", "current_alettes", "current_opalettes", "current_opalignment", "current_alette", "current_aless", "current_paless", "current_pixelettes", "current_alignment", "current_pixelette", "current_palettes", "current_pixelignment", "current_palignment", "current_opalette", "current_pixeless"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 8673, "substitutes": {"nptr": ["ntpointer", "netr", "nPtr", "endPtr", "NPtr", "endpt", "enptr", "startpt", "ntptr", "enpt", " npt", "endpointer", "neptr", " nPtr", "Npt", "ntPtr", "entr", "Ntr", " npointer", "startPtr", "startptr", "npt", "npointer", "Nptr", "enpointer", "nepointer", "nept", "startpointer", "ntpt", "ntr", "Npointer"], "end": ["vert", "ension", "start", "est", "and", "ended", "all", "id", "ent", "End", "open", "z", "update", "send", "post", "last", "ad", "close", "enable", "add", "max", "e", "obj", "ep", "set", "stop", "entry", "append", "index", "edge", "ind", "address", "en", "begin", "ending", "desc", "after", "offset", "enc", "pend", "change", "pos", "api", "use", "END"], "default_suffix": ["default_appendprefix", "default_appendfix", "default_protfix", "default_prefixix", "default_suffixed", "default_suffprefix", "default_prefixrix", "default_sfence", "default_suffrix", "default_prefixprefix", "default_appendix", "default_prefixixed", "default_prefixfix", "default_defixed", "default_defix", "default_protrix", "default_protprefix", "default_protix", "default_sfixed", "default_deffix", "default_sfix", "default_defence", "default_suffence", "default_appendrix", "default_sffix", "default_prefixence", "default_sufffix"], "unit": ["parent", "un", "element", "dim", "byte", "domain", "base", " units", "term", "category", "axis", "normal", "prefix", "class", "method", "temp", "data", "config", "component", "number", "version", "module", "format", "name", "option", "custom", "position", "dimension", "init", "uni", "Unit", "type", "u", "null", "attribute", "text", "currency", "crit", "lc", "units", "unct", "fc"], "retval": ["altsel", "returnval", "defv", "retsel", "RETVAL", "rtvalue", "pretval", "reteval", "Retval", "retVAL", "Retvalid", "retvals", "RETval", "alteval", "exitval", "returnVal", "altVAL", "rtcall", "RETeval", "returnVAL", "RETobj", "altval", " reteval", "exitobj", "returnvalue", "rteval", "exiteval", "exitvalid", "rtval", "RETvalue", " retcall", " retvalid", "rtvalid", "RETcall", " retsel", "defval", "exitVAL", " retVal", "Retvalue", " retvals", "retcall", "retvalid", "altvals", "retVal", "altvalue", "defeval", "retv", "returnvals", "pretsel", "rtVAL", "pretvalue", "returneval", " retvalue", "altvalid", "defvalid", "altVal", "retobj", "retvalue", "pretvalid", "Reteval", "rtv", "Retv", "exitvalue", "rtobj"], "endptr": ["endedpointer", "endedptr", "startpointers", "nPtr", "endPtr", "endaddr", "endedpoint", " endpointer", "idproc", "endpoint", "endpt", "ndpointer", "startpt", "estpointers", "ndPtr", "endedaddr", "idpt", "endpointer", "idpointer", "endproc", "endtr", " endproc", "endedfp", "starttr", "offsettr", "startaddr", "offsetaddr", "endfp", "endedPtr", "nfp", "estptr", " endpointers", "startptr", "idptr", " endpt", "npointer", "offsetpointer", "endedtr", "endpointers", "startproc", " endaddr", " endpoint", "startpointer", "ndptr", "offsetptr", "estpointer", "estproc", "ndfp", "endedproc", "startpoint"], "c": ["count", "l", "cr", "C", "cmp", "abc", "n", "m", "unc", "b", "t", "k", "x", "d", "i", "con", "ct", "p", "chain", "e", "cu", "cn", "cf", "ec", "f", "ac", "bc", "cc", "cs", "o", "v", "r", "ctx", "cur", "dc", "pc", "xc", " rc", "col", "u", "cat", "nc", "cm", "ci", "cache", "lc", "mc", "cy", "fc"], "val": ["l", "vals", "Val", "ee", "cond", "base", "valid", "il", "abc", "len", "bal", "ul", "sel", "def", "_", "m", "b", "x", "ol", "update", "ve", "d", "serv", "data", "VAL", "fb", "el", "p", "ref", "e", "ct", "rule", "exec", "rel", "value", "au", "pt", "f", "rot", "ac", "bc", "aval", "vol", "fl", "py", "eval", "al", "v", "bl", "bf", "min", "ind", "lib", "sl", "r", "pr", "cal", "pre", "err", "elt", "grad", "cel", "li", "flo", "fc", "fee", "vec", "vel"], "mul": ["imull", "tmull", "umull", "pult", "mull", "mil", "imall", "imuli", "muli", "pulus", "hmulator", "amUL", "Mul", " mull", "mmul", "mula", " mlu", "cmUL", "amlu", " mulo", "vul", "hmoul", "Mil", "Mal", "Mull", " mall", "mmult", "amil", "Mlu", "umule", "vull", "manulus", "MUL", "moul", "mmull", "umulator", "mult", " mUL", " mulator", "umul", "umoul", "mlu", " mult", "mall", " moul", "umula", "mmulus", "hmuli", "pul", "mUL", "cmul", "mulator", "mulus", "mule", "vula", "tmul", "imula", "amul", "hmul", "cmil", "mal", "tmal", "vule", "manul", "tmUL", "manall", "cmal", "cmulo", "mulo", "cmull", "manuli", "imul", "Mulo", " mulus", "amull", "pull", " muli", "imulus", "umuli", "imule"], "integral": ["incric", " integric", "infraction", "integrals", "Integrals", "infral", "extraction", "Integraction", "integraction", "infric", "integrier", "inferal", "Integrier", "extrals", "citral", "incral", "citraction", "citrier", " integraction", "integeral", "citrals", "extral", "Integral", "incraction", " integeral", "integric", "inceral", "extrier"], "fraction": ["rflux", "infraction", "infault", "rfract", "extault", "dault", " fract", "extraction", "Fraction", "fract", "Flux", "fractions", "extancy", "dletcher", "Fractions", "rfractions", "infancy", "infract", "flux", "fletcher", "extletcher", "draction", " fancy", "infractions", "dract", "extract", "fancy", "Fract", " fault", "rfraction", "fault", "influx", "infletcher"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 8707, "substitutes": {"bs": ["vs", "base", "bb", "ks", "ds", "lbs", "org", "bas", "http", "b", "gs", "iss", "fb", "ls", "pb", "ros", "gb", "ins", "rss", "bits", "outs", "ec", "rs", "js", "BS", "bc", "us", "os", "obs", "cs", "db", "bl", "bps", "ras", "ubs", "bh", "fps", "las", "lb", "bis", "als", "bi", "ns", "sb", "bytes", "ms", "sys", "fs", "ses", "css", "ss", "bing", "bes", "bos"], "res": ["vals", "conf", "des", "rem", "Res", "ry", "proc", "val", "resources", "RS", "def", "reset", "mr", "RES", "rest", "resolution", "gr", "ver", "ress", "obj", "ros", "reg", "rel", "Rs", "rss", "rs", "js", "ex", "resource", "pres", "ras", "rc", "response", "r", "req", "err", "results", "bis", "details", "rep", "spec", "ms", "re", "sys", "rates", "rx", "Resp", "rez", "result", "rev", "sr", "resp", "gen", "rh", "rus"], "refcount_table": ["refcountabletree", "refcount_db", "refcount__cache", "refcountingarray", "refprocessingaddress", "refcountingcache", "refcount_TABLE", "refcount__table", "refcountjtree", "refcountjarray", "refcountingservice", "refount_table", "refcountjTABLE", "refcache_array", "refcountingcount", "refcount__count", "refprocess_TABLE", "refcache_directory", "refcountableTABLE", "refcache_table", "refcountjdirectory", "refcountPdatabase", "refcountjdatabase", "refount_cache", "refcount_cache", "refcacheingdatabase", "refcount_directory", "refcountPservice", "refcountingsession", "refcountingaddress", "refcountingtree", "refcountingTABLE", "refcacheingarray", "refcountPtable", "refcountableaddress", "refcount__db", "refcountjtable", "refcountingdirectory", "refcache_database", "refcacheingdirectory", "refcount_database", "refprocess_table", "refcountabletable", "refprocessingtable", "refcount_address", "refcountjaddress", "refcount_tree", "refcount_session", "refcount_count", "refprocessingtree", "refprocess_address", "refount_count", "refprocessingTABLE", "refount_db", "refcount_service", "refcountingdb", "refcacheingtable", "refcountingtable", "refprocess_tree", "refcount_array", "refcountingdatabase", "refcountPsession"], "refcount_table_size": ["refcount_table_address", "refcount_database_name", "refcount_cache_SIZE", "ref\n", "refcount_table_offset", "refcount_database_size", "refcount_table_name", "refcount_table_SIZE", "refcount_cache_name", "refcount_cache_offset", "refcount_table_scale", "refcount_cache_sum", "refcount_database_scale", "refcount_database_address", " ref\n", "refcount_cache_scale", "refcount_cache_size", "reference\n", "refcount_table_sum", "rel\n"], "l1_table_offset": ["l1_table\u00b7size", "l1_file_start", "l1_table_adjust", "l1_file_adjust", "l1_table\u00b7slot", "l1_cache_slot", "l1_cache_size", "l1_table\u00b7sort", "l1_table_slot", "l1_table2size", "l1_table\u00b7offset", "l1_cache_address", "l1_cache_sort", "l1_file_size", "l1_table_size", "l1_cache_offset", "l1_table2sort", "l1_table_sort", "l1_table_start", "l1_file_offset", "l1_table2offset", "l1_cache_start", "l1_table_address", "l1_table2slot"], "l1_size": ["l1_set", "l1Fscale", "l0nmode", "l1_timeout", "l1noffset", "l4_capacity", "l0_mode", "l1Fsi", "l1Fcapacity", "l4_si", "l4_size", "l1_scale", "l1ntimeout", "l0nsize", "l0_offset", "l0_size", "l1_capacity", "l4_scale", "l1_offset", "l1nscale", "l1nsize", "l1_mode", "l4_offset", "l1_si", "l1nmode", "l0_set", "l0noffset", "l1Fsize", "l4_timeout", "l0_scale"], "flags": ["flag", "debug", "len", "features", "stats", "files", "ops", "mask", " fs", "util", "status", "reg", "bits", "args", "lag", "rets", " flag", "Flags", "rc", "fun", " bits", "rep", "bit", "file", "options", "fs"], "s": ["vs", "session", "ts", "ds", "its", "is", "si", "g", "stats", "http", "b", "gs", "sa", "c", "service", "p", "server", "ls", "qs", "status", "js", "rs", "os", "f", "cs", "sets", "S", "scope", "states", "state", "sl", "r", "services", "bis", "ns", "details", "spec", "sys", "self", "ses", "fs", "su", "ps", "ss", "settings", "ssl"], "l1_table": ["lfirst_body", "l4_table", "lfirst_comment", "l8_table", "l1Jtable", "l1_TABLE", "l1_template", "l8_file", "l1Jcache", "l1_comment", "l1___size", "l2_cache", "l1_length", "l4_length", "l3_TABLE", "l1___server", "l1Jbody", "lOne_tree", "l8_size", "l2_table", "lOne_table", "l1nbody", "l1_file", "l4_size", "l1___tree", "l1___header", "l1ncolumn", "l1_column", "l1_body", "lOne_template", "l3_cache", "l1___length", "l3_body", "l1_cache", "lfirst_column", "l1_offset", "l1___template", "l4_header", "l1___table", "lfirst_table", "l1ntable", "l1ncomment", "l1_tree", "l1_server", "l1_header", "l1JTABLE", "lOne_server", "l2_size", "l8_cache", "l3_table"], "l2_offset": ["l1_address", "l2Foffset", "l2xaddress", "l3_offset", "l2__offset", "l1_loc", "l2_point", "l2foffset", "l3_left", "l1_Offset", "l1_error", "l2soffset", "l2spoint", "l0__address", "l2__size", "l2__slot", "l0fsize", "l2_address", "l2_loc", "l2__address", "l2_shift", "l2xOffset", "l2fslot", "l0fslot", "l2_Offset", "l3_size", "l2xloc", "l2__point", "l0faddress", "l0__error", "l0_point", "l2_slot", "l2Fid", "l0_offset", "l0_size", "l0_error", "l2Fsize", "l1_offset", "l2serror", "l2faddress", "l2fsize", "l2_error", "l2__error", "l3_id", "l0foffset", "l3_origin", "l0_slot", "l2xshift", "l2xoffset", "l0__point", "l2_id", "l2_left", "l2xslot", "l2_size", "l2_origin", "l2saddress", "l2xsize", "l0_address", "l2Fleft", "l1_shift", "l0__offset", "l3_error"], "l1_size2": ["l1_scale1", "l1_count2", "l1Pvalue02", "l1_scale2", "l1_group5", "l1_scaleless", "l1_size1", "l1Psizeless", "l1_count132", "l1_capacity1", "l1_scale02", "l1Psize132", "l1_size132", "l1_size02", "l1Pvalue2", "l1_width2", "l1_value02", "l1_content5", "l1_value2", "l1Pvalueless", "l1_contentALL", "l1Psize2", "l1_sizeii", "l1_content2", "l1_size5", "l1_length4", "l1_length12", "l1_capacity2", "l1_contentii", "l1_groupALL", "l1_countless", "l1_valueless", "l1_sizeless", "l1_size12", "l1_length02", "l1_scale4", "l1_capacity02", "l1_sized5", "l1_scale132", "l1_count02", "l1Psize02", "l1_size4", "l1_sizedii", "l1_length1", "l1_value132", "l1_groupii", "l1_group2", "l1_sizeALL", "l1_length2", "l1_scale12", "l1_width1", "l1_sized2", "l1_sizedALL", "l1Pvalue132"], "i": ["l", "hi", "ui", "di", "si", "len", "n", "zi", "key", "info", "id", "xi", "m", "b", "x", "t", "ini", "z", "c", "p", "ix", "uri", "e", "mu", "yi", "split", "at", "mini", "eni", "f", "ie", "j", "code", "ai", "multi", "index", "slice", "ind", "ti", "mi", "gi", "phi", "r", "sup", "qi", "en", "pi", "bi", "ii", "u", "type", "h", "I", "li", "ip", "ci", "out", "result", "io", "ni", "ri", "y", "fi", "iu", "ki"], "ret": ["count", "pass", "valid", "flag", "ext", "alt", "val", "len", "fail", "def", "nt", "conn", "Ret", "sur", " Ret", "job", "red", "reply", "ref", "arg", "lit", "obj", "fit", "reg", "usr", "pt", "rb", "gt", "rets", "rot", "ut", "rt", "bf", "bl", "det", "opt", "fun", "att", "ben", "err", "resp", "en", "lt", "part", "rep", "art", "bit", "cat", "re", "RET", "back", "let", "result", "rev", "mt", "ft", "match", "feat", "bin", "success", "pet"], "check_errors": ["check_files", "get_files", "call_errors", "get_codes", "check_rors", "checkingfiles", "checkingerrors", "get_errors", "check_times", "getingfiles", "call_changes", "check_details", "getingcodes", "getingdetails", "call_rors", "checkingdetails", "call_times", "check_changes", "check_codes", "checkingcodes", "getingerrors", "get_details"], "corruptions": ["morritips", "morrupture", "corrogips", "corriture", "morrition", "corritions", "morruption", "corrotips", "morruptips", "morriture", "morruptions", "corritips", "corruptips", "corrogure", "corrogion", "corrupture", "corrition", "corrotions", "corrotion", "morritions", "corrogions", "corruption", "corroture"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8720, "substitutes": {"opaque": ["depque", "opacity", "opacle", "ipque", "spaque", "ipopque", "oaque", "popaque", "oacity", "pophole", "popacle", "depacity", "ipopacity", "ipopaque", "ipacity", "depaques", "oacle", "ipaque", "ohole", "sphole", "ipaques", "ophole", "spacle", "opque", "spacity", "popacity", "opaques", "ipopaques", "depaque"], "dcrn": ["Dcrl", "Drcns", "dcrnn", "dCRnt", " dcrnc", " dctrn", "DrcN", "dhrb", "dcrenn", "dcreN", "dhrnc", "drcl", "dcrb", "dCrns", "dctrb", "Dcrns", "dhrn", "dcrens", "dCRn", " dcrnn", "Dcrn", "drcns", "dctrn", "dCRnc", "Drcn", "dcrN", "dcrl", "dCrnn", " dcrN", " dctrb", "dcrns", " dcrnt", "dctrnc", "dcrel", "Drcl", "DcrN", " dcrns", "dctrnt", "drcn", "dCrl", "dhrnt", " dctrnt", "dCRb", "dcrnt", "dcren", "dCrn", " dctrnc", "dcrnc", " dcrb", "dCrN", "drcN"], "pob": ["cpub", "tob", "boy", "opab", "cpob", "tab", "Pob", "Pub", "poc", "Poy", "opob", "poby", "Pib", "apoby", " pab", "opobb", "cpoc", "pOB", "apob", "apoy", "tib", "bab", "Poby", " poc", " pobb", "pub", "pab", "pib", "bob", "Pobb", " pib", " pOB", "tOB", "poy", " pub", "POB", "boby", "opOB", "cpab", "pobb", "Poc", "apab", "Pab"], "ret": ["pass", "base", "valid", "flag", "ext", "alt", "val", "len", "key", "def", "nt", "info", "Ret", " Ret", "mem", "pat", "data", "reply", "ref", "arg", "lit", "status", "reg", "value", "hard", "gt", "rets", "ut", "code", "rt", "res", "bf", "det", "fun", "bit", "re", "cat", "RET", "back", " RET", "out", "result", "rev", "match", "ft", "feat", "force", "success", "pet"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_erase(OneNANDState *s, int sec, int num)\n\n{\n\n    uint8_t *blankbuf, *tmpbuf;\n\n    blankbuf = g_malloc(512);\n\n    if (!blankbuf) {\n\n        return 1;\n\n    }\n\n    tmpbuf = g_malloc(512);\n\n    if (!tmpbuf) {\n\n        g_free(blankbuf);\n\n        return 1;\n\n    }\n\n    memset(blankbuf, 0xff, 512);\n\n    for (; num > 0; num--, sec++) {\n\n        if (s->bdrv_cur) {\n\n            int erasesec = s->secs_cur + (sec >> 5);\n\n            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n\n            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            if (sec + 1 > s->secs_cur) {\n\n                goto fail;\n\n            }\n\n            memcpy(s->current + (sec << 9), blankbuf, 512);\n\n            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n\n                   blankbuf, 1 << 4);\n\n        }\n\n    }\n\n\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 1;\n\n}\n", "idx": 8755, "substitutes": {"s": ["l", "conf", "session", "sg", "ts", "is", "ds", "si", "your", "g", "sites", "its", "stats", "m", "http", "b", "t", "ops", "d", "gs", "sa", "c", "service", "p", "server", "ls", "e", "se", "qs", "private", "ins", "tests", "xs", "js", "sq", "us", "f", "rs", "os", "obs", "sym", "o", "sets", "S", "es", "sync", "south", "sie", "states", "sl", "services", "state", "r", "new", "full", "ns", "sb", "spec", "as", "sys", "self", "comments", "ses", "ps", "site", "fs", "y", "ss", "uns", "ssl"], "sec": ["scroll", "conf", "session", "seq", "ext", "section", "win", "second", "nt", "src", "rec", "con", "ct", "SEC", "c", "config", "lit", "se", "reg", "exec", "secret", "sector", "ec", "loc", "sq", "bc", "sy", "isec", "j", "code", "f", "sic", "sub", "next", "ctr", "lib", "inc", "sync", "size", "six", "cur", "req", "Sec", "sect", "desc", "offset", "spec", "enc", "col", "seconds", "secure", "sys", "year", "secondary", "esc", "comp", "length", "crit", "proc", "feat", "seed", "acc", "day", "sc", "security", "ex"], "num": ["un", "conf", "seq", "nb", "n", "len", "ord", "ul", "no", "nt", "b", "mem", "rec", "con", "sum", "lit", "reg", "number", "off", "loc", "bc", "nm", "f", "unit", "multi", "lib", "ctr", "umi", "inc", "Num", "nom", "mod", "en", "sn", "desc", "uni", "fn", "sim", "on", "nu", "common", "su", "ng", "um", "gen", "NUM"], "blankbuf": ["blogbuff", "spbytes", "spbuffer", "openbuf", "blankblock", " blankuf", "ankBuffer", "nullbuff", "spbuf", "blankba", " blankbytes", "blankfd", "blankbc", "frontbuf", "ankdb", " blankalloc", "emptyuf", "nullfd", " blankBuffer", "frontbuff", "kkbuf", "openbuff", "openblock", "kkbuff", "nulldb", "blankimg", "whitevec", " blankbuff", "validbuffer", " blankfd", "nullimg", " blankcf", "ankcf", "blankcur", "whiteblock", "blankoff", "blankcmd", "tmpimg", " blankimg", "openuf", "frontbuffer", "whitebuf", "blankbuff", "nullblock", "frontcur", "tmpbuff", "tmpcur", "ankbuff", "nullbc", "nullpath", "nullbuf", "openpath", "nullvec", "kkbuffer", "whitefd", "openbuffer", "blogbc", "validbuf", "emptybuffer", "whiteuf", " blankpath", "blankvec", " blankoff", "whitebuff", "validbytes", "whiteba", "tmpport", "tmpbuffer", "blankalloc", " blankblock", " blankbc", "blogbuf", "blogbuffer", "ankbuf", "nulloff", " blankba", "whitedb", "ankba", " blankcmd", "ankcmd", "ankvec", " blankport", "blankpath", "frontport", " blankcur", "frontcmd", "frontcf", "whitebuffer", "tmpoff", "blankuf", "blankBuffer", "blankcf", "nulluf", "nullbuffer", " blankbuffer", "emptybuf", "frontuf", "tmpbc", "blankport", "tmpuf", "spalloc", "blankbytes", "kkuf", "blankbuffer", "frontbc", "whiteBuffer", "blankdb", "validalloc", "emptybuff"], "tmpbuf": ["tempbuff", "frontbag", "tmpcb", " tmpcb", "blankuf", "fbuf", "mpcb", "tmpbuffer", "frontwb", "fbbuf", "blankbag", "tmpbag", "fakeuf", "fakebuf", "ownbuf", "frontbuffer", "fakebuffer", "tempbuf", " tmpbuffer", " tmpuf", "frontuf", "ownwb", "fbcb", "flatbuf", "blankbuff", "frontbuf", " tmpwb", "fakebuff", "tmpbuff", "tempuf", "tmpwb", "frontcb", "tempbuffer", "flatbuff", "tmpuf", "frontbuff", "ownuf", "ownbuff", " tmpbag", " tmpbuff", "mpbuf", "blankcb", "flatbuffer", "blankbuffer", "mpbuff", "fbbuff", "blankwb", "mpbuffer", "fbwb"]}}
{"project": "qemu", "commit_id": "ff74f33c310892c90c4439d963a6ce67f47ce18c", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, Error **errp)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (ret == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 8793, "substitutes": {"desc": ["asc", "des", "ext", "def", " description", "info", "src", "password", "path", "rec", "d", "DES", "doc", "data", "config", "ref", "meta", "dest", "attr", "dist", "priv", "sec", "code", "dir", "sub", "Description", "description", "rc", "name", "phrase", "Desc", "dc", "esc", "text", "lc", "dep", "sc", "uc"], "bs": ["vs", "base", "bb", "ds", "bas", "b", "ab", "gs", "fb", "ls", "pb", "cb", "ins", "gb", "rb", "rs", "us", "BS", "bc", "os", "js", "obs", "cs", "bl", "bps", "bh", "las", "lb", "bis", "bi", "ns", "sb", "fs", "ses", "ps", "css", "ss", "bes", "bos"], "desc_file_path": ["desc_file__pointer", "desc_file_url", "desc_file_patch", "desc_full_path", "desc_full_name", "desc_file___name", "desc_file_location", "desc_file_pointer", "desc_file__name", "desc_full_url", "desc_file__patch", "desc_file_name", "desc_full_pointer", "desc_file___url", "desc_full_location", "desc_file___location", "desc_file___path", "desc_full_patch", "desc_file__path"], "errp": ["orderpatch", "erp", "errorc", "reqg", "errpre", "errorfp", "erg", "orderfp", "errg", "rrc", "erpre", "reqc", "erc", " errpc", "errorp", "errorP", "reqp", "errorpc", " errc", "rrp", "erpatch", "strg", "errorg", "errP", " errpatch", "errpatch", "errpc", "rrg", "orderp", "erP", " errg", "errorpre", "err", "reqfp", "erpc", "strr", " errfp", "Erp", "Erpre", "erfp", "strp", "errc", "Erc", "orderr", "strc", "ErP", " errr", "errr", "rrfp", "errfp", "errorr"], "ret": ["count", "base", "fail", "t", "ref", "arg", "reg", "gt", "code", "al", "opt", "cur", "att", "orig", "re", " RET", "let", "url", "arr", "flag", "val", "Ret", "mem", "post", "fit", "res", "bf", "det", "try", "lt", "art", "back", "mt", "str", "ext", "alt", "len", "def", "nt", "num", " Ret", "pat", "data", "reply", "status", "usr", "rt", "rc", "fun", "part", "cat", "result", "success", "pass", "valid", "info", "sur", "lit", "obj", "final", "rets", "pub", "bot", "bit", "RET", "ft", "rev", "match", "feat"], "access": ["parent", "asc", "area", "reference", "pass", "connect", "source", "na", "key", "test", "id", "view", "src", "open", "password", "class", "public", "path", "sa", "config", "ref", "escape", "qa", "ace", "attr", "request", "condition", "ec", "array", "empty", "select", "ac", "mode", "Access", "alpha", "resource", "index", "shape", "accessible", "input", "name", "object", "att", "buffer", "ga", "option", "address", "acl", "error", "cast", "ast", "ACC", "secure", "esc", "a", "url", "image", "cache", "length", "use", "security", "auth", "expr", "acc", "sc", "uc"], "type": ["parent", "session", "field", "media", "path", "t", "block", "python", "ref", "attr", "code", "call", "full", "sort", "url", "ype", "alias", "key", "total", "post", "app", "pe", "value", "types", "op", "py", "index", "non", "format", "pre", "ty", "token", "position", "error", "root", "source", "class", "test", "temp", "Type", "status", "action", "style", "flow", "share", "label", "o", "version", "shape", "size", "order", "TYPE", "area", "level", "param", "domain", "comment", "info", "by", "time", "rel", "route", "name", "track", "address", "user", "option", "platform", "null", "api", "length", "y", "family", "typ", "security"], "fname": ["sfkey", "fName", "Fnames", "Fpath", " fnames", "fnames", " fprefix", "fcpath", "fkey", "fcname", "Fprefix", "sfnames", "Fkey", "fcprefix", "fprefix", "Fname", "cpath", "fcName", "cnames", "FName", " fkey", " fpath", "fpath", "cname", "sfname", " fName"], "p": ["lp", "l", "parent", "sp", "n", "g", "m", "bp", "point", "pl", "t", "path", "b", "pa", "d", "i", "pointer", "pp", "c", "data", "python", "cp", "pb", "e", "fp", "np", "pe", "q", "P", "f", "op", "o", "v", "r", "pr", "pre", "port", "tp", "jp", "pi", "part", "pc", "error", "h", "ip", "a", "ap", "vp"], "flat_offset": ["flat___offset", "plain___pos", "plain_length", "flat_width", "flat_left", "flat00Offset", "flat00position", "flat_pos", "flat_range", "plain___length", "flat_bit", "flat___size", " flat_range", " flat_start", "flat___pos", "plain_bit", "flat___length", "slice_left", "plain_pos", "fixed64position", "flat00width", "slice_offset", "plain___offset", "plain_offset", "fixed_position", "flat00offset", "flat64offset", "flat64alias", "fixed64Offset", "flat\u00b7range", "flat_alias", "flat_off", "flat64position", "flat_Offset", "fixed_width", "plain_size", " flat_port", "fixed_Offset", "flat_position", "flat___alias", "flat64width", "flat_start", "flat___bit", "flat\u00b7offset", "flat\u00b7start", "flat64size", "fixed64width", "flat64Offset", "slice_slot", "flat_length", "flat_size", "slice_off", "plain_position", "plain_alias", "fixed64offset", "plain___bit", "flat\u00b7port", "fixed_offset", "flat___position", "flat_port", "flat_slot"], "extent_path": ["extent_data", "extant_dir", "extant_path", "extension_file", "extant_file", "extant_case", "extent_name", "extent__path", "extent__file", "extent_method", "extant_name", "extent__method", "extant_data", "extension_dir", "extent_dir", "extension_path", "extension_method", "extent__dir", "extent_case"], "extent_file": ["extent_data", "extrent_files", "extents_file", "extent_files", "extant_path", "extrent_file", "extant_file", "extents_path", "extent_name", "extent2data", "extents_filename", "extant_files", "extent2file", "extant_data", "extents_name", "extent2files", "extrent_path", "extent_filename", "extent2path", "extrent_filename"], "s": ["sp", "session", "ts", "words", "is", "ds", "rows", "stats", "b", "x", "ims", "ops", "gs", "sa", "service", "server", "ls", "se", "xs", "js", "us", "safe", "os", "cs", "sym", "sets", "S", "es", "sync", "sl", "services", "state", "ches", "ies", "ns", "storage", "blocks", "ms", "sys", "comm", "ips", "ses", "fs", "su", "site", "ps", "ss", "y", "settings", "ssl"], "extent": ["extant", "EXTent", "Extend", "ExtENT", "extENT", "Extent", "content", "Extant", "contENT", "contend", "EXTENT", "extend", "contant", "EXTend", "EXTant"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 8794, "substitutes": {"arg": ["mac", "arc", "AR", "arr", "param", "argument", "arm", "abc", "g", "val", "ax", "ang", "var", "slot", "ref", "p", "ace", "local", "ag", "args", "loc", "ac", "entry", "call", "amp", "ig", "inc", "input", "rc", "aph", "ar", " argument", "load", "pc", "enc", "emb", "ann", "result", "Arg", "par", "inter", "exec"], "op": ["oc", "operator", "operation", "cmp", "val", "def", "info", "open", "ops", "p", "OP", "obj", "oop", "set", "or", "act", "loc", "prop", "ac", "mp", "o", "opt", "name", "Op", "option", "oid", "hop", "oper", "bit", "init", "node", "type", "cat", "lock", "ip", "plan", "comp", "use", "proc", "expr", "ok", "pop"], "mutex": ["putrex", "motex", "altact", " mutesc", "putec", " mutext", " mutus", "litact", " mutEX", "mutact", "utact", "utix", "rotexternal", "mutexternal", "putext", "utext", "altexternal", "putus", "motus", "rotex", "putesc", "Mutex", "litEX", "mutix", "mutus", "Mutact", "utEX", "putaux", " mutaux", "Mutaux", "utilex", "mutext", "putix", "putlex", "motEX", "MutEx", "altex", " mutexternal", "utaux", "mutesc", "mutrex", "putEx", "Mutix", "MutEX", "metex", " mutec", "mutec", "utus", "putact", " mutrex", "metEX", "rotext", " mutix", "utilec", " mutlex", "altext", "metesc", "mutlex", "rotact", "utex", " mutEx", "utilrex", "litex", "mutEx", "utEx", "mutaux", "motix", "mutEX", "litix", " mutact", "utilix", "metlex", "putex", "putEX"], "err": ["cr", "mr", "x", "ver", "nor", "ref", "ace", "cb", "attr", "loc", "aster", "er", "ac", "ie", "code", "call", "ctr", "end", "nr", "orig", "type", "resp", "arr", "n", "all", "i", "c", "e", "iter", "or", " result", "ev", "ind", "ner", "ar", "r", "error", "rar", " rc", "fee", "ler", "good", "arm", "str", "ext", "hr", "kr", "cer", "var", "usr", "ir", "rb", "dr", "order", "rc", "req", "dev", "result", "ah", "Er", "br", "sr", "rh", "ry", "rr", "oe", "Error", "bug", "lr", "rag", "nil", "pr", "inner", "cor", "yr", "rn", " error", "der", "icer", "fe"], "tmp": ["img", "cmp", "t", "tt", "tty", "vt", "fb", "config", "pb", "thread", "dest", "attr", "np", "txt", "bt", "fake", "v", "amp", "now", "cpp", "buff", "pkg", "own", "tc", "c", "vm", "db", "tf", "py", "current", "TB", "storage", "handler", "kk", "boot", "nb", "ff", "ph", "test", "temp", "nt", "src", "buf", "var", "cp", "fp", "ptr", "rb", "rt", "tp", "part", "sb", "property", "copy", "cache", "result", "Temp", "pointer", "p", "obj", "stuff", "private", "cro", "slave", "mp", "ctx", "null", "emp", "api", "tem", "pty"]}}
{"project": "FFmpeg", "commit_id": "aacc6615f8e3863cd930d3a1ab2cd28d9838f0f5", "target": 1, "func": "static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){\n\n    MotionEstContext * const c= &s->me;\n\n    Picture *p= s->current_picture_ptr;\n\n    int mb_xy= mb_x + mb_y*s->mb_stride;\n\n    int xy= 2*mb_x + 2*mb_y*s->b8_stride;\n\n    int mb_type= s->current_picture.mb_type[mb_xy];\n\n    int flags= c->flags;\n\n    int shift= (flags&FLAG_QPEL) + 1;\n\n    int mask= (1<<shift)-1;\n\n    int x, y, i;\n\n    int d=0;\n\n    me_cmp_func cmpf= s->dsp.sse[0];\n\n    me_cmp_func chroma_cmpf= s->dsp.sse[1];\n\n    \n\n    assert(p_type==0 || !USES_LIST(mb_type, 1));\n\n    assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1));\n\n    \n\n    if(IS_INTERLACED(mb_type)){\n\n        int xy2= xy  + s->b8_stride;\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n        c->stride<<=1;\n\n        c->uvstride<<=1;\n\n        init_interlaced_ref(s, 2);\n\n        \n\n        assert(s->flags & CODEC_FLAG_INTERLACED_ME);\n\n\n\n        if(USES_LIST(mb_type, 0)){\n\n            int field_select0= p->ref_index[0][xy ];\n\n            int field_select1= p->ref_index[0][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            if(p_type){\n\n                s->p_field_select_table[0][mb_xy]= field_select0;\n\n                s->p_field_select_table[1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->p_field_mv_table[0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->p_field_mv_table[1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER_I;\n\n            }else{\n\n                s->b_field_select_table[0][0][mb_xy]= field_select0;\n\n                s->b_field_select_table[0][1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->b_field_mv_table[0][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->b_field_mv_table[0][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_FORWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[0][xy ][0]; \n\n            y= p->motion_val[0][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[0][xy2][0]; \n\n            y= p->motion_val[0][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1, 1, cmpf, chroma_cmpf, flags);\n\n        }\n\n        if(USES_LIST(mb_type, 1)){\n\n            int field_select0= p->ref_index[1][xy ];\n\n            int field_select1= p->ref_index[1][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            s->b_field_select_table[1][0][mb_xy]= field_select0;\n\n            s->b_field_select_table[1][1][mb_xy]= field_select1;\n\n            *(uint32_t*)s->b_field_mv_table[1][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[1][xy ];\n\n            *(uint32_t*)s->b_field_mv_table[1][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[1][xy2];\n\n            if(USES_LIST(mb_type, 0)){\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BIDIR_I;\n\n            }else{\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BACKWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[1][xy ][0]; \n\n            y= p->motion_val[1][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0+2, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[1][xy2][0]; \n\n            y= p->motion_val[1][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1+2, 1, cmpf, chroma_cmpf, flags);\n\n            //FIXME bidir scores\n\n        }\n\n        c->stride>>=1;\n\n        c->uvstride>>=1;\n\n    }else if(IS_8X8(mb_type)){\n\n\n        cmpf= s->dsp.sse[1];\n\n        chroma_cmpf= s->dsp.sse[1];\n\n        init_mv4_ref(s);\n\n        for(i=0; i<4; i++){\n\n            xy= s->block_index[i];\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chroma_cmpf, flags);\n\n        }\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER4V;\n\n    }else{\n\n        if(USES_LIST(mb_type, 0)){\n\n            if(p_type){\n\n                *(uint32_t*)s->p_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER;\n\n            }else if(USES_LIST(mb_type, 1)){\n\n                *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR;\n\n            }else{\n\n                *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD;\n\n            }\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags);\n\n        }else if(USES_LIST(mb_type, 1)){\n\n            *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD;\n\n           \n\n            x= p->motion_val[1][xy][0]; \n\n            y= p->motion_val[1][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags);\n\n        }else\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n    }\n\n    return d;\n\n}", "idx": 8815, "substitutes": {"s": ["l", "session", "is", "strings", "m", "http", "t", "gs", "parts", "v", "bis", "ns", "details", "com", "spec", "self", "settings", "sg", "words", "ds", "si", "n", "your", "sf", "w", "b", "e", "se", "request", "lines", "sq", "f", "sym", "sets", "es", "r", "sup", "storage", "sis", "u", "sim", "comments", "ps", "su", "fs", "site", "ss", "sc", "ks", "sv", "g", "ops", "sa", "ls", "os", "cs", "o", "sync", "south", "sb", "sys", "a", "ssl", "conf", "sports", "ts", "service", "qs", "xs", "rs", "js", "S", "sie", "services", "support", "h", "client", "ses"], "mb_x": ["mbIdxy", "MB_lon", "MB_xy", "mp_x", "mbIdy", "MB_my", "mb_xy", "mp_type", "mp_pick", "mbIdx", "mb_lon", "mb_pick", "MB_y", "MB_x", "mb_my", "mbIdmy", "mb_type", "mp_y"], "mb_y": ["mp_year", "mb67x", "mbipy", "mbipx", "mbipyear", "mb6x", "mb00vy", "mb67type", "mb67y", "mbiplon", "mb6yan", "mb6y", "mb67vy", "mp_x", "MB_yan", "mb_year", "mb00x", "mb_lon", "mb_yan", "MB_type", "mb6vy", "MB_y", "MB_x", "mp_lon", "MB_vy", "mb00y", "mb00type", "mb_type", "mb_vy", "mp_y"], "p_type": ["p__types", "p__name", " p_types", "p_val", "p__type", "fp_val", "p__y", "p_name", "pkrole", "pkgrole", "pkval", "p_y", "p_ty", "fp_role", "pktypes", "m_name", " p_y", "pkgtype", " p_name", "pktype", "p_parent", "fp_types", "m_parent", "p_role", "m_ty", "pkgval", "fp_type", "p_types", "pkgtypes", "m_type"], "c": ["l", "cr", "conf", "co", "C", "n", "g", "m", "t", "b", "k", "con", "ct", "config", "cp", "cu", "e", "cf", "ec", "cc", "bc", "f", "ac", "cs", "cop", "v", "ce", "rc", "ic", "ctx", "cal", "pc", "dc", "enc", "u", "h", "ca", "cm", "ci", "lc", "ch", "mc", "cy", "sc"], "p": ["lp", "l", "sp", "wp", "n", "g", "media", "m", "bp", "http", "t", "b", "pa", "pp", "post", "cp", "pb", "e", "pro", "np", "pe", "po", "P", "f", "op", "j", "py", "cop", "v", "pre", "tp", "pi", "pc", "pal", "api", "ip", "ps", "a", "ap", "per", "vp"], "x": ["l", "n", "in", "w", "m", "id", "b", "z", "d", "X", "ix", "e", "pixel", "pe", "f", "o", "index", "v", "xy", "h", "pos", "px", "dx", "ex"], "y": ["l", "ym", "yt", "w", "m", "t", "b", "z", "vy", "ey", "d", "cy", "e", "f", "yy", "j", "o", "Y", "type", "xy", "h", "ya", "dy"], "i": ["n", "si", "w", "m", "k", "b", "z", "d", "e", "f", "j", "index", "v", "ti", "phi", "mi", "r", "pi", "ii", "u", "h", "I", "li", "ci"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "void ff_estimate_p_frame_motion(MpegEncContext * s,\n\n                                int mb_x, int mb_y)\n\n{\n\n    UINT8 *pix, *ppix;\n\n    int sum, varc, vard, mx, my, range, dmin, xx, yy;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    int mb_type=0;\n\n    uint8_t *ref_picture= s->last_picture[0];\n\n\n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[0];\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + 2         ][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + 2         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x = P[4][0];\n\n                pred_y = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x= P[1][0];\n\n                pred_y= P[1][1];\n\n            }\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_4MV){\n\n        int block;\n\n\n\n        mb_type|= MB_TYPE_INTER4V;\n\n\n\n        for(block=0; block<4; block++){\n\n            int mx4, my4;\n\n            int pred_x4, pred_y4;\n\n            int dmin4;\n\n            static const int off[4]= {2, 1, 1, -1};\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[block];\n\n            const int block_x= mb_x*2 + (block&1);\n\n            const int block_y= mb_y*2 + (block>>1);\n\n\n\n            const int rel_xmin4= xmin - block_x*8;\n\n            const int rel_xmax4= xmax - block_x*8 + 8;\n\n            const int rel_ymin4= ymin - block_y*8;\n\n            const int rel_ymax4= ymax - block_y*8 + 8;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + off[block]][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + off[block]][1];\n\n                if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift);\n\n                if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift);\n\n                if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift);\n\n                if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x4 = P[4][0];\n\n                pred_y4 = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x4= P[1][0];\n\n                pred_y4= P[1][1];\n\n            }\n\n            P[5][0]= mx - mb_x*16;\n\n            P[5][1]= my - mb_y*16;\n\n\n\n            dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture);\n\n\n\n            halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, \n\n                                   pred_x4, pred_y4, block_x, block_y, ref_picture);\n\n     \n\n            s->motion_val[ s->block_index[block] ][0]= mx4;\n\n            s->motion_val[ s->block_index[block] ][1]= my4;\n\n        }\n\n    }\n\n\n\n    /* intra / predictive decision */\n\n    xx = mb_x * 16;\n\n    yy = mb_y * 16;\n\n\n\n    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    sum = pix_sum(pix, s->linesize);\n\n#if 0\n\n    varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS;\n\n    vard = pix_abs16x16(pix, ppix, s->linesize);\n\n#else\n\n    sum= (sum+8)>>4;\n\n    varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8);\n\n    vard = (pix_norm(pix, ppix, s->linesize)+128)>>8;\n\n#endif\n\n\n\n    s->mb_var[s->mb_width * mb_y + mb_x] = varc;\n\n    s->avg_mb_var+= varc;\n\n    s->mc_mb_var += vard;\n\n\n\n    \n\n#if 0\n\n    printf(\"varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\\n\",\n\n\t   varc, s->avg_mb_var, sum, vard, mx - xx, my - yy);\n\n#endif\n\n    if(s->flags&CODEC_FLAG_HQ){\n\n        if (vard*2 + 200 > varc)\n\n            mb_type|= MB_TYPE_INTRA;\n\n        if (varc*2 + 200 > vard){\n\n            mb_type|= MB_TYPE_INTER;\n\n            halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n        }else{\n\n            mx = mx*2 - mb_x*32;\n\n            my = my*2 - mb_y*32;\n\n        }\n\n    }else{\n\n        if (vard <= 64 || vard < varc) {\n\n            mb_type|= MB_TYPE_INTER;\n\n            if (s->me_method != ME_ZERO) {\n\n                halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n            } else {\n\n                mx -= 16 * mb_x;\n\n                my -= 16 * mb_y;\n\n            }\n\n#if 0\n\n            if (vard < 10) {\n\n                skip++;\n\n                fprintf(stderr,\"\\nEarly skip: %d vard: %2d varc: %5d dmin: %d\", \n\n                                skip, vard, varc, dmin);\n\n            }\n\n#endif\n\n        }else{\n\n            mb_type|= MB_TYPE_INTRA;\n\n            mx = 0;//mx*2 - 32 * mb_x;\n\n            my = 0;//my*2 - 32 * mb_y;\n\n        }\n\n    }\n\n\n\n    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    set_p_mv_tables(s, mx, my);\n\n}\n", "idx": 8825, "substitutes": {"s": ["session", "is", "its", "strings", "m", "http", "t", "gs", "hm", "phys", "plugins", "series", "bis", "ns", "details", "spec", "settings", "sg", "ds", "si", "n", "your", "sites", "sf", "b", "i", "c", "e", "se", "lines", "sq", "us", "f", "sym", "sets", "es", "storage", "sis", "this", "u", "rates", "sim", "comments", "ps", "su", "fs", "site", "ss", "ks", "sv", "g", "features", "stats", "ops", "stat", "ls", "os", "cs", "sync", "south", "sb", "sys", "ions", "single", "secondary", "a", "ssl", "conf", "sports", "ts", "in", "service", "p", "server", "qs", "ins", "private", "xs", "js", "rs", "an", "S", "states", "services", "support", "ms", "client", "ses"], "mb_x": ["mb01xs", "mb68ey", "mb54x", "mb_ya", "mb24Y", "mb_xs", "mm_ey", "mb24xs", "MB_X", "mb54time", "mb54ey", "mb01Y", "mb68x", "mb_rx", "mb68y", "mm_y", "mb54y", "mb_X", "mb01x", "vm_x", "mm_time", "mb01ya", "mb68time", "vm_xs", "mm_x", "mb_time", "MB_x", "mb_Y", "mb_ey", "MB_rx", "mb24ya", "vm_ya", "MB_size", "mb_size", "vm_Y", "mb24x"], "mb_y": ["mb101yl", "mb_ym", "mb25oy", "mp_ady", "mb__y", "mb_ys", "mb101ym", "mb25x", "mm_ym", "mb_yl", "mb__ady", "mp_x", "mb25y", "mm_oy", "mb101y", "mm_y", "mb_yt", "mb00x", "mm_ys", "mm_x", "mb25ys", "mp_yt", "mb001y", "mb_ady", "mb101x", "mb00oy", "mm_yl", "mb00ys", "mb__x", "mb__yt", "mb001yl", "mb001ym", "mb00y", "mp_y", "mb_oy", "mb001x"], "pix": ["pox", " pik", "gpox", "ppik", "ppox", " pox", " pixels", "pixels", "gpixels", "gpix", "pik", "ppixels", "gpik"], "ppix": ["wpius", "wpIX", "dpixel", "ppius", "wpixel", "dpIX", "cpius", "dpix", "cpix", "cpIX", "ppIX", "dpius", "ppixel", "wpix", "cpixel"], "sum": ["count", "diff", "conf", "scale", "mass", "pack", "total", "Sum", "num", "mem", "stat", "doc", "loss", "vol", "quant", "norm", "miss", "cost", "summary", "mean", "sim", "pos", "dev", "bin", "um", "mix", "depth", "gram"], "varc": ["frec", "farc", "marc", "nvlc", "mrec", "vpc", "flc", "mlc", "nvpc", "nvarc", "mpc", "nvrec", "fpc", "vlc", "vrec"], "vard": ["img", "nb", "win", "lv", "src", "low", "num", "by", "ct", "cb", "gb", "pixel", "au", "sq", "cc", "nv", "ck", "sky", "cv", "rc", "voc", "cur", "cat", "nc", "dev", "vc", "rev", "ss", "ch", "feat"], "mx": ["km", "ym", "dim", "me", "mis", "mn", "xp", "mos", "mes", "m", "mr", "bm", "x", "mm", "mem", "MX", "mus", "vm", "max", "mu", "wm", "target", "mine", "xml", "memory", "pm", "nm", "fm", "mp", "py", "module", "yx", "min", "mi", "zx", "md", "mag", "nas", "hop", "wx", "ms", "dm", "xy", "cm", "rx", "px", "y", "wy", "mc", "rm"], "my": ["me", "mis", "mn", "mos", "your", "test", "m", "mr", "phy", "x", "mm", "mon", "mem", "i", "metadata", "cy", "max", "meta", "mine", "memory", "pm", "mic", "mode", "nm", "gy", "mid", "sym", "py", "yahoo", "min", "mi", "live", "MY", "md", "am", "gray", "bi", "ms", "dy", "self", "rx", "ma", "ng", "ya", "ram", "y", "mys", "mie", "mc", "My", "yo"], "range": ["broad", "sample", "channel", "area", "term", "domain", "base", "rate", "scale", "rage", "view", "spread", "m", "fr", "lim", "theme", "low", "Range", "origin", "resolution", "store", "angle", "line", "max", "ref", "run", "target", "role", "bug", "frame", "ange", "loc", "array", "f", "mode", "mid", "resource", "scan", "slice", "size", "edge", "route", "release", "query", "remote", "feature", "r", "end", "err", "repeat", "nr", "grade", "radius", "offset", "error", "year", "row", "ge", "gap", "use", "ram", "cache", "force", "random", "chain"], "dmin": [" dfree", "dmain", "dhmain", "pmain", "dminimum", "xdMIN", "dpMin", "dhMIN", "DMin", "xdfree", " dmiss", "dyMIN", "pmin", " dMIN", "dymain", "dpmin", "dmiss", "xdmin", "dinit", "sdMIN", "sdfree", "dMin", "dpMIN", "dMIN", "pMIN", "dpminimum", "Dminimum", " dminimum", "sdmiss", "dyinit", "ypos", " dpos", "DMIN", "dhmin", "dpos", "dymax", " dMin", "dmax", " dinit", "yinit", "dymin", "xdmiss", "dhMin", " dmain", "sdmin", "dfree", "Dmin", "pmax", "dypos", "Dmain", "Dmax"], "xx": ["fix", "na", "test", "mm", "pp", "dist", "act", "xs", "xxx", "foo", "code", "ck", "nd", "inc", "ns", "wx", "nc", "xy", "aa", "rx", "px", "pos", "ss", "nn"], "yy": ["ym", "oy", "delay", "hh", "bar", "mm", "cy", "fy", "nn", "zy", "xxx", "gy", "foo", "mid", "py", "zx", "YY", "dd", "ii", "xy", "aa", "year", "XX", "y", "dy"], "xmin": ["yMin", "Xstart", "xymax", " xstart", "x0", "XMin", "xymin", "dMin", "xMin", " x0", "exmin", "ymini", "Xsize", "xsize", "dsize", "exMin", "exmax", "y0", " xdiff", "xstart", "ystart", "xdiff", "exmini", "X0", "dmax", "Xmin", " xmini", "Xmax", "xymini", " xMin", "xydiff", "ydiff", "ysize", "xmini"], "ymin": [" ydiff", "xstat", "xmind", "xra", "symax", "mydiff", " ystart", " ymins", " ylen", "yymind", "eymin", "sylen", "xmins", "yMin", "Yna", "xna", "yna", "nymind", "symin", "nymax", "eymax", "Ymax", "ystat", "eyskip", "xlen", "ymon", "yra", "mystat", "xskip", "xMin", "yymon", "yymax", " yskip", "symins", "ymins", " yMin", "nymon", " ystat", "xstart", "ystart", "mymin", "yskip", "systart", "xdiff", "mymax", "ylen", "nymin", "ymind", "eystart", "xmon", "Ymin", "eyra", "yymin", "syra", "YMin", " yna", "ydiff"], "xmax": [" xaz", "wstart", "eyMax", "eymin", " xpress", "rxend", "zMax", "wmin", "eymax", "xMax", "Xdiff", "wmax", "eydiff", "zmin", "zend", "xaz", " xax", "dstart", "XMax", "zmax", "xax", "Xend", "dend", "mxax", "mxpress", " xdiff", "xpress", "xstart", "ystart", "wend", " xMax", "yax", "xdiff", "yMax", "ypress", "yaz", "Xmin", "dmax", "rxmin", "mxmin", " xend", "Xmax", "mxmax", "yend", "Xaz", "xend", "rxmax"], "ymax": ["pmake", "ymmag", "symax", "yanAX", "ymark", "ypake", "ymaze", "ymmake", "tmant", "tmark", "ypase", "yrask", "ymake", "tmake", "ymaj", "ypax", "tmag", "ypaze", "pmmax", "yraj", "maj", "ymmAX", "yrag", "ymmax", "yanax", "pmin", "ypark", "humax", "ymatch", "max", "ypatch", "symake", "yrase", "yrin", "ymmaze", "symant", "pmatch", "ymAX", "mmax", "nmask", "ymmase", "tmase", "ymmask", "min", "pmaj", "ymmatch", "nmase", "yrax", "ymase", "tmax", "symag", "yanaze", "ymag", "ypAX", "yrmax", "humark", "nmax", "ymmmax", "ymant", "yanatch", "pmax", "ymmant", "humase", "nmag", "humake", "ypmax", "ymask"], "rel_xmin": ["rel_exmax", "rel_ylim", "rel_yMin", "rel_tstart", "rel_exMin", "rel_tmid", "rel_xstart", "rel_xMin", "rel_glim", "rel_hmax", "rel_gmin", "rel_hmin", "rel_exmin", "rel_hmid", "rel_ymid", "rel_xmid", "rel_xlim", "rel_tmin", "rel_hstart", "rel_gmax", "rel_tmax", "rel_gMin", "rel_ystart", "rel_exlim"], "rel_ymin": ["rel_xmean", "rel_eymin", "rel_mmin", "rel_eymax", "rel_yrmin", "rel_yrfrom", "rel_xfrom", "rel_eyfrom", "rel_xna", "rel_mmid", "rel_yna", "rel_ymid", "rel_xmid", "rel_yfrom", "rel_mmean", "rel_yrna", "rel_ymean", "rel_yrmid", "rel_yrmean", "rel_yrmax", "rel_eyna", "rel_mmax"], "rel_xmax": ["rel_nmin", "rel_dxplus", "rel_ypad", "rel_yplus", "rel_yMax", "rel_dxMax", "rel_Xmax", "rel_xxmin", "rel_npad", "rel_xxmax", "rel_xxplus", "rel_Xpad", "rel_dxmin", "rel_Xmin", "rel_xxMax", "rel_xpad", "rel_xMax", "rel_dxmax", "rel_xplus", "rel_nmax"], "rel_ymax": ["rel_cmad", "rel_tmmax", "rel_yad", "rel_mmmax", "rel_mmmin", "rel_mmad", "rel_ymaz", "rel_tmmin", "rel_yaz", "rel_yax", "rel_tmaz", "rel_ymad", "rel_mmaz", "rel_cmax", "rel_tmax", "rel_cmmax", "rel_ymmax", "rel_ymmin", "rel_mmax"], "P": [" p", " N", "POS", "NP", "Py", "C", "PIN", "PUT", "E", "Point", "O", "PS", "X", "p", " E", "Position", " M", "B", " V", "IP", "PA", "Part", "T", "N", "G", "S", "R", "BP", "L", "V", "PO", "Y", "A", "K", "API", "PT", "PRE", "H", "I", "F", "AP", "Q", "U", "J", "W", "M", "D"], "ref_picture": ["refalvideo", "refaypic", "reference_picture", "refalpicture", "ref_database", "ref_profile", "reference_profile", "reference_video", "Ref_picture", "ref_pic", "refaypicture", "reference_database", "refaysummary", "ref_study", "ref_image", "reflexpic", "ref_summary", "reflexdetails", "ref_details", "refleximage", "Ref_details", " ref_video", "Ref_image", " ref_study", "refalstudy", "refalpic", " ref_pic", "ref_video", " ref_summary", "Ref_pic", "reflexpicture"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAAPIEncodePicture *pic, *next;\n\n\n\n    for (pic = ctx->pic_start; pic; pic = next) {\n\n        next = pic->next;\n\n        vaapi_encode_free(avctx, pic);\n\n    }\n\n\n\n    if (ctx->va_context != VA_INVALID_ID) {\n\n        vaDestroyContext(ctx->hwctx->display, ctx->va_context);\n\n        ctx->va_context = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->va_config != VA_INVALID_ID) {\n\n        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);\n\n        ctx->va_config = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->codec->close)\n\n        ctx->codec->close(avctx);\n\n\n\n    av_buffer_pool_uninit(&ctx->output_buffer_pool);\n\n\n\n    av_freep(&ctx->codec_sequence_params);\n\n    av_freep(&ctx->codec_picture_params);\n\n\n\n    av_buffer_unref(&ctx->recon_frames_ref);\n\n    av_buffer_unref(&ctx->input_frames_ref);\n\n    av_buffer_unref(&ctx->device_ref);\n\n\n\n    av_freep(&ctx->priv_data);\n\n\n\n    return 0;\n\n}\n", "idx": 8835, "substitutes": {"avctx": ["avcmp", "afctx", " avcn", "ovcu", "afcas", "AVcn", "ascmd", "afcmp", "ascontext", "avectx", "afcmd", "avcf", "avecu", "AVcmp", " avcmp", "vercas", "AVcontext", "ascmp", "asctx", "avcu", "afcu", "ovctx", "verctx", "afcf", "vercontext", "avcmd", "ovcontext", "AVcmd", "AVctx", " avcontext", "avcontext", "afcn", "avecas", "afcms", "avcms", "avecf", "avecms", "avecontext", "afcontext", "ovcms", "avcn", "avcas", "vercf"], "ctx": ["cmp", "sci", "config", "cb", "txt", "cn", "wcs", "loc", "cc", "connection", "cas", "concept", "nc", "gc", "ca", "ann", "pkg", "fc", "cam", "cca", "tc", "que", "instance", "c", "ct", "component", "cf", "sq", "hw", "bc", "pai", "voc", "conv", "wx", "col", "lc", "chan", "cus", "sc", "exec", "context", "conn", "src", "cp", "data", "cu", "cli", "fp", "coll", "cs", "ctrl", "ck", "sync", "tx", "xc", "kw", "vc", "cache", "cmd", "crit", "uc", "conf", "co", "cci", "obj", "qa", "la", "cv", "pc", "cms", "cfg", "cm", "coe", "client", "ci", "css", "kb"], "pic": ["lot", "pse", "seq", "key", "point", "pack", "chat", "piece", "page", "pid", "pa", "capt", "pointer", "c", "doc", "config", "p", "prev", "tick", "txt", "eni", "pins", "cha", "ig", "Picture", "ic", "fat", "feature", "photo", "kin", "pre", "jp", "study", "bi", "pen", "pc", "nic", "Pic", "fig", "col", "fin", "plugin", "cat", "lock", "li", "cycle", "file", "lic", "image", "cache", "lc", "pict", "pot", "cus", "picture", "pin", "fc"], "next": ["parent", "company", "seq", "follow", "start", "blog", "prefix", "nice", "key", "owner", "second", "conn", "info", "open", "pack", "piece", "page", "latest", "pid", "fi", "last", "pointer", "data", "more", "reply", "config", "prev", "p", "c", "line", "big", "head", "queue", "value", "frame", "eni", "ana", "sequence", "step", "sec", "code", "child", "inc", "current", "name", "space", "future", "doc", "new", "full", "first", "desc", "pc", "nic", "after", "enc", "init", "Next", "fin", "cycle", "soc", "complete", "image", "feat", "picture"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n", "idx": 8846, "substitutes": {"sockfd": [" socksfd", "socketfd", " socksFD", "sinkf", "sesockfp", "sinkflo", "sesockf", "sesinkfp", "sesockhandler", "sinkfp", "sinkFD", "sesockfd", " sockflo", "socksf", "sesinkhandler", "socksfp", "sockshandler", "sockethandler", " sockshandler", "socketFD", "socketsfp", "socketsf", "socksFD", "sockf", "socketflo", "socketshandler", "sockhandler", "socksflo", " sockFD", "sockFD", "socksfd", " socksflo", "socketsfd", " sockhandler", "sesinkf", "sinkhandler", "sockflo", "sinkfd", "sesinkfd", "sockfp"], "buff": ["bag", "count", "uf", "bb", "tab", "fo", "nb", "ff", "quit", "abb", "temp", "info", "b", "total", "num", "wb", "mem", "buf", "data", "cp", "fb", "bd", "batch", "pb", "cb", "gb", "txt", "feed", "local", "rb", "ptr", "cod", "tmp", "f", "body", "zero", "eb", "bound", "Buff", "nd", "ctx", "old", "sb", "back", "ob", "length", "ch", "text", "flat", "buffer"], "size": ["count", "iz", "area", "ee", "timeout", "scale", "si", "g", "len", "capacity", "class", "handle", "temp", "speed", "small", "total", "z", "SIZE", "send", "page", "data", "c", "sum", "close", "max", "e", "exec", "args", "loc", "empty", "Size", "body", "sec", "code", "zero", "shape", "sync", "name", "six", "fat", "done", "end", "address", "function", "err", "full", "storage", "error", "offset", "bytes", "clean", "complete", "extra", "length", "cache", "ize", "buffer", "success", "fee"], "retval": ["inteval", "RETVal", "RETVAL", "rtvalue", "reteval", "Retval", "retVAL", "memeval", "retvals", "RETval", "alteval", " retv", "ntval", "altv", "intval", "RetVAL", "altval", " reteval", "memvals", "rteval", "rtval", "intVal", "rtVal", "RETvalue", " retvalid", "rtvals", "finv", "refv", "Retvals", " retVal", "Retvalue", "RetVal", "intvals", " retvals", "ntvals", "nteval", "retvalid", "retVal", "altvalue", "retv", "ntvalue", "rtVAL", " retvalue", "memval", "altvalid", "retvalue", "altVal", "finvalid", "Reteval", "refval", "refeval", "rtv", "memVal", "finval", "fineval", "refvalue"]}}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n", "idx": 8855, "substitutes": {"blk": ["plks", "plkt", "clks", "Blk", "plck", "clck", "Blks", "blck", "blks", "Blkt", " blck", "clk", " blks", " blkt", "blkt", "clkt", "Blck", "plk"]}}
{"project": "qemu", "commit_id": "6f864e6ec8812d5a5525a7861ca599c6bcabdebe", "target": 0, "func": "static int vfio_load_rom(VFIODevice *vdev)\n\n{\n\n    uint64_t size = vdev->rom_size;\n\n    char name[32];\n\n    off_t off = 0, voff = vdev->rom_offset;\n\n    ssize_t bytes;\n\n    void *ptr;\n\n\n\n    /* If loading ROM from file, pci handles it */\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n\n        return 0;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n\n    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n\n    memset(ptr, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->fd, ptr + off, size, voff + off);\n\n        if (bytes == 0) {\n\n            break; /* expect that we could get back less than the ROM BAR */\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            memory_region_destroy(&vdev->pdev.rom);\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);\n\n    vdev->pdev.has_rom = true;\n\n    return 0;\n\n}\n", "idx": 8858, "substitutes": {"vdev": [" vde", "evdevice", "nvev", "udd", "hev", "wprof", "svdevice", "vsdev", "vang", " vd", "vdi", "vdevice", "udev", "vmcam", "everror", "hdev", "Vdev", "ovdd", "nvvar", "vde", "wdef", "lconn", "vdd", "ovdef", "ovev", " vdd", "svself", "pDEV", "evdev", "hDEV", " vdef", "nvdev", "pvar", "vconn", "vDEV", "vd", "kdi", "lang", "svprof", "vsdc", "ovgu", "gev", "ovdiv", " vconf", "ovvar", "pdi", "pde", "wdiv", "ld", "svdiv", "jconf", "fgu", "nvdd", "gdev", "Vconf", "cdd", "evgu", "kdev", "fdevice", "cdev", "evflow", " vdiv", " vgu", "pdev", "evd", "kev", "lcam", "jdi", "svdd", "pconf", "vDev", " vev", "evdc", "svconn", "VDev", "voltadv", "lgu", "vdom", "padv", "evev", "vgu", " vflow", "udiv", "vdiv", "lev", "vmgu", "evconf", "evdiv", " vcam", "wDev", "lconf", "Vdd", "vdc", "lflow", "svDev", " vvar", "voltdevice", "vself", "vcam", "pdc", "cdiv", "svdc", "evang", "Vev", "jdc", "pdd", "hdevice", "vprof", " vdevice", "vev", "voltself", "vvar", "Vdiv", "vadv", "jde", "wdom", "vsdevice", "evconn", "pdiv", "vdef", "gdd", "ldc", "svev", "svde", "kdc", "wev", "jdev", " vconn", "svconf", "verror", "jev", "Vprof", "vmdev", "uconn", "svang", " vself", "voltdev", "Vdevice", "Vvar", "ldev", "pev", "ovDEV", "vconf", "wdev", "ovdevice", "cconn", "ldef", "fev", " vdc", "svdev", "svadv", "ovdev", "pself", "ldevice", "Vdom", "vserror", "gde", "pdef", "vflow", "fdev", "pdevice", " verror", "svdom", "vmdevice"], "name": ["parent", "cpu", "alias", "NAME", "byte", "param", "base", "str", "n", "len", "val", "comment", "start", "prefix", "word", "key", "no", "id", "info", "path", "x", "num", "filename", "mem", "nam", "data", "block", "time", "ref", "addr", "max", "names", "number", "memory", "none", "host", "code", "device", "size", "version", "cap", "space", "connection", "function", "address", "new", "part", "list", "node", "type", "self", "pos", "null", "ame", "ip", "a", "url", "image", "cache", "Name", "buffer"], "bytes": ["cells", "ones", "nos", "flows", "ipes", "reads", "parts", "steps", "outs", "errors", "values", "charges", "ies", "cycles", "codes", "ns", "groups", "ips", "forces", "units", "settings", "all", "bits", "args", "pages", "lines", "odes", "rules", "es", "eps", "blocks", "annels", "allows", "ps", "videos", "fee", "loads", "zip", "boot", "abytes", "len", "ops", "data", "Bytes", "ls", "pieces", "os", "cs", "size", "items", "bps", "breaks", "seconds", "les", "vs", "byte", "rows", "icks", "files", "tes", "runs", "amples", "limits", "ms", "gets", "pos", "out", "io", "css", "days", "bs"], "ptr": ["Ptr", "sp", "tr", "start", "len", "ext", "pad", "nt", "src", "prot", "fd", "tty", "buf", "pointer", "shift", "data", "cp", "addr", "p", "pointers", "fp", "ep", "pt", "plug", "off", "loc", "tmp", "args", "push", "dr", "rt", "call", "slice", "size", "trace", "ctr", "alloc", "index", "py", "rc", "r", "ctx", "pre", "address", "tx", "port", "patch", "pc", "offset", "pos", "length", "cache", "br", "buffer", "exec"]}}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n", "idx": 8866, "substitutes": {"errp": ["erf", "erp", "errps", "gramps", "excps", "erps", "erb", "gramf", "excb", "errb", "excf", "errf", "gramb", "gramp", "excp"], "info": ["alias", "conf", "up", "it", "fo", "start", "si", "Info", "comment", "source", "in", "def", "id", "http", "bar", "update", "i", "data", "config", "a", "INFO", "obj", "before", "feed", "value", "txt", "bug", "q", "op", "f", "tf", "py", "index", "parse", "hand", "opt", "name", "order", "gi", "end", "inner", "check", "error", "now", "type", "back", "report", "ignore", "api", "extra", "options", "cache", "inf", "result", "image", "url", "ret", "help", "fi", "success"], "uuid": ["UUID", "ruID", "iqider", "buip", "uccuid", "uuide", "iqid", "cuid", "buID", "uid", "uuip", "UUid", "duq", "duide", "ruid", "buq", "ouid", "buuid", "buider", "ouids", "iqids", "iqID", "uip", "duid", "buids", "UUuid", "buide", "runame", "cuuid", "ouider", "guide", "uccid", "uuider", "guq", "UUname", "uuida", "cuip", "buid", "uuids", "guida", "uccID", "ruuid", "uuID", "guid", "uuname", "duida", "uuuid", "uccname", "uuq", "ouID", "buida"]}}
{"project": "FFmpeg", "commit_id": "d7eabd50425a61b31e90c763a0c3e4316a725404", "target": 0, "func": "static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n\n                             int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb;\n\n    int i, ch;\n\n    int mb = -1;\n\n    Band *bands = c->bands;\n\n    int off, ret, last_frame, skip;\n\n    int bits_used, bits_avail;\n\n\n\n    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n\n\n\n    buf_size = avpkt->size & ~3;\n\n    if (buf_size <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet size is too small (%i bytes)\\n\",\n\n               avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf_size != avpkt->size) {\n\n        av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n\n               \"extra bytes at the end will be skipped.\\n\");\n\n    }\n\n\n\n    skip       = buf[0];\n\n    last_frame = buf[1];\n\n    buf       += 4;\n\n    buf_size  -= 4;\n\n\n\n    /* get output buffer */\n\n    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;\n\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    av_fast_padded_malloc(&c->bits, &c->buf_size, buf_size);\n\n    if (!c->bits)\n\n        return AVERROR(ENOMEM);\n\n    c->dsp.bswap_buf((uint32_t *)c->bits, (const uint32_t *)buf, buf_size >> 2);\n\n    init_get_bits(&gb, c->bits, buf_size * 8);\n\n    skip_bits_long(&gb, skip);\n\n\n\n    /* read subband indexes */\n\n    for(i = 0; i <= c->maxbands; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            int t = 4;\n\n            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;\n\n            if(t == 4) bands[i].res[ch] = get_bits(&gb, 4);\n\n            else bands[i].res[ch] = bands[i-1].res[ch] + t;\n\n        }\n\n\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            mb = i;\n\n            if(c->MSS) bands[i].msf = get_bits1(&gb);\n\n        }\n\n    }\n\n    /* get scale indexes coding method */\n\n    for(i = 0; i <= mb; i++)\n\n        for(ch = 0; ch < 2; ch++)\n\n            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);\n\n    /* get scale indexes */\n\n    for(i = 0; i <= mb; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(bands[i].res[ch]){\n\n                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];\n\n                bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]);\n\n                switch(bands[i].scfi[ch]){\n\n                case 0:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 1:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n\n                    break;\n\n                case 2:\n\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 3:\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    break;\n\n                }\n\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n\n            }\n\n        }\n\n    }\n\n    /* get quantizers */\n\n    memset(c->Q, 0, sizeof(c->Q));\n\n    off = 0;\n\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n\n        for(ch = 0; ch < 2; ch++)\n\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n\n\n    bits_used = get_bits_count(&gb);\n\n    bits_avail = buf_size * 8;\n\n    if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n\n        return -1;\n\n    }\n\n    if(c->frames_to_skip){\n\n        c->frames_to_skip--;\n\n        *got_frame_ptr = 0;\n\n        return avpkt->size;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = c->frame;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 8878, "substitutes": {"avctx": ["afconn", "avcmp", "afctx", "afsync", "aphctl", "airsync", "avsync", "aircontext", "Avconn", "navsync", "navctx", "averctx", "aphctx", "afcas", "afcmp", "avectx", "afmac", "abcontext", "afctl", "avmac", "aphcu", "avcf", "AVcmp", " avcmp", "vercas", "AVcontext", "avcu", "abctx", "airctx", "afcu", "verctx", "avectl", "vercontext", "afcf", "avconn", " avmac", "afcci", "AVctx", "AVmac", " avcontext", "avercu", "avcontext", "abcu", " avconn", "abctl", "avcci", "Avctx", " avcf", "Avcmp", "airctl", " avcci", "navcontext", "avecf", "avecci", "aphcontext", "avecontext", "avctl", "afcontext", "avesync", "navctl", "vercu", "avercas", "avcas", "avercontext", "Avcontext"], "data": ["parent", "base", "window", "media", "da", "m", "board", "mem", "d", "block", "config", "batch", "p", "reader", "ata", "queue", "memory", "frame", "f", "DATA", "next", "body", "code", "dat", "device", "module", "v", "input", "connection", "content", "end", "Data", "bus", "bytes", "pos", "message", "api", "image", "cache", "bin", "buff", "result", "length", "buffer"], "got_frame_ptr": ["got_frames2buffer", "got_frame2pointers", "got_frames_ptr", "got_frames2pointer", "got_frame_pointer", "got_frame2pointer", "got_frame_pointers", "got_frame2buffer", "got_frames_buffer", "got_frames2ptr", "got_frame_buffer", "got_frames2pointers", "got_frames_pointer", "got_frame2ptr", "got_frames_pointers"], "avpkt": ["afpacket", "avpakg", "avcnn", "affacket", "avmkt", "avbcht", "avPkt", "avfct", "AVpacket", "avmkg", "AVppkt", "avbct", "avpct", "afpkt", "AVppKT", "avcfd", "affkt", "abpfd", "AVPacket", "avcacket", "avbpkh", "avprct", "AVPkh", "abckt", "avpact", "avvpKT", "abpkt", "avPkh", "afpkg", "avfkt", "avbkt", "avvpkt", "avprkt", "avebcht", "AVpkh", "avpafd", "avfkh", "avppkg", "avcct", "AVppkg", "avepkt", "abcacket", "avepct", "avpeter", "abcfd", "abcct", "avpkh", "avepnn", "abpct", "avfacket", "AVpKT", "avppkt", "avPct", "AVpkg", "avebkt", "avppKT", "avbpacket", "avpakt", "avpnn", "avepcht", "AVpct", "avpaeter", "avprcht", "AVpkt", "avppct", "avffd", "avprnn", "avbnn", "avebnn", "affkg", "avbpct", "avckt", "avmeter", "avfKT", "avpacket", "avpfd", "avpaacket", "affeter", "avvpct", "afpeter", "avebct", "AVPct", "AVppct", "avfeter", "abpacket", "avfkg", "avpkg", "avccht", "avpKT", "avPacket", "avbpkt", "avpcht", "avvpkg", "AVPkt", "avmacket"], "buf": ["bag", "grab", "uf", "map", "seq", "bb", "img", "context", "len", "ff", "proc", "lim", "src", "b", "que", "ab", "num", "wb", "mem", "block", "fb", "batch", "bu", "bd", "pb", "utf", "cb", "queue", "feed", "cf", "config", "rb", "loc", "array", "bc", "bf", "ref", "alloc", "cv", "v", "rc", "cas", "home", "cur", "raw", "fab", "port", "sb", "bus", "bytes", "av", "func", "vec", "buff", "br", "cmd", "feat", "buffer", "box", "uc"], "buf_size": ["buf2source", "bag_set", "bglexsize", "buf_count", "buf_capacity", "buf2ize", "buflensize", "bg_size", "block_capacity", "bg_loc", "block_size", "bglexscale", "buflenlen", "buf64shape", "bag_storage", " buf_Size", "buf__size", "buflexsized", "bg_count", " buf_scale", "buf_width", "buf_color", "bag_size", " buf_ize", "bag_sec", "buflenshape", " buf_shape", "buf_loc", " buf_len", "buf_set", "buf64len", "buf2scale", "bglexcolor", "buflexloc", "buflexcolor", "buf_scale", "buf__width", "buflexsize", " buf_width", "buf__sized", " buf_sec", "bglexloc", "buf__scale", "block_width", "buflexsec", "buf_start", "buf_sized", " buf_sized", "buflexstorage", "buflexwidth", "buflexset", "block_sized", "buf64size", "bg_scale", "buf_Size", "block_shape", "buf2size", "buf_storage", "buf_source", "block_scale", "buf_ize", "buflexscale", "buf_len", "bg_start", "buf_shape", " buf_source", "bg_color", "buf_sec"], "c": ["l", "co", "C", "context", "cmp", "n", "cca", "w", "m", "tc", "conn", "unc", "k", "b", "t", "d", "con", "ct", "s", "config", "p", "cp", "cu", "cd", "e", "cb", "exec", "cf", "cn", "ec", "coll", "sec", "cc", "bc", "f", "ac", "cs", "cv", "v", "ce", "rc", "ic", "ctx", "r", "cl", "pc", "dc", "xc", "enc", "this", "u", "cat", "nc", "icc", "cm", "ca", "self", "h", "ci", "a", "vc", "lc", "cmd", "cache", "core", "mc", "uc", "cy", "sc", "fc"], "gb": ["GB", "gram", "gu", "gd", "di", "bb", " GC", "g", "gio", " gcc", "gpu", "bm", " eg", "gm", " img", "kb", "gs", "tg", "gin", "cb", "gl", " gl", "cf", " ic", "gp", " pci", "nn", "rb", "cc", "bc", "gy", "cs", "db", "bf", "py", "lib", "bg", "mc", "gi", " cm", "gg", "sl", "ctx", " kb", "ga", "sb", "pc", "usb", "git", " rc", " co", "tm", " db", "cfg", "gc", "cm", "rg", "ci", "bin", " conf", "gam", "ki", " bi"], "i": ["count", "l", "ani", "ui", "di", "it", "is", "n", "si", "in", "zi", "m", "xi", "info", "id", "b", "k", "ini", "t", "x", "d", "p", "ix", "eni", "f", "ie", "j", "ai", "multi", "index", "v", "phi", "ind", "mi", "ih", "ik", "gi", "ti", "r", "chi", "sup", "qi", "im", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "ni", "io", "y", "fi", "ki"], "ch": ["count", "channel", "conf", "sh", "arch", "g", "ach", "ph", "tch", "conn", "ich", "chip", "k", "x", "z", "b", "ver", "cp", "qu", "batch", "cb", "gh", "q", "cho", "f", "sk", "j", "code", "zh", "th", "cht", "cha", "che", "bh", "cur", "chi", "sch", "cl", "cor", "mot", "col", "u", "h", "cm", "ci", "y", "chan", "cy", "sc"], "bands": ["tags", "devices", "tones", "ks", "boards", "frames", "cells", "ds", "features", "heads", "units", "boxes", "files", "rooms", "band", "ands", "fb", "pieces", "cats", "steps", "versions", "planes", "bits", "pages", "lines", "banks", "bass", "objects", "pins", "plugins", "limits", "bps", "cards", "classes", "locks", "codes", "groups", "audio", "levels", "blocks", "annels", "cycles", "bytes", "girls", "hops", "chains", "points", "rings", "buff", "nets", "tracks"], "off": [" num", "ff", "def", "info", " offset", "num", "ops", " af", "offs", " on", " def", "op", "mode", "o", "opt", " dev", "offset", "ef", "type", "pos", "Off", "ip", "on", "dev", "out", "loop"], "ret": ["arr", "valid", "bad", "active", "tr", "alt", "val", "len", "fail", "ext", "def", "info", "nt", "Ret", "mem", "reply", "ref", "arg", "lit", "obj", "status", "reg", "utf", "dist", "iter", "value", "rets", "bc", "f", "dr", "rt", "res", "progress", "det", "nil", "rc", "fun", "att", "ben", "miss", "bit", "fin", "re", "RET", "back", "result", "ft", "match", "feat", "success"], "last_frame": ["last_pixel", "last_fram", "last_line", "lastNewfram", "last__pixel", "next_frames", "first_element", "next_frame", "last__frame", "lastSubframe", "next_pixel", "last_element", "last__frames", " last_line", "last_frames", "lastSubpixel", "first_fram", "lastNewframe", "lastSubframes", "first_frame", " last_frames", "lastNewelement"], "skip": ["cpu", "count", "sp", "seq", "pass", "delay", "cmp", "len", "hide", "def", "no", "speed", "missing", "total", "num", "sleep", "mem", "send", "ops", "rec", "slot", "addr", "prev", "mask", "status", "vis", "feed", "strip", "Skip", "stop", "step", "op", "next", "sk", "loss", "progress", "scan", "slice", "opt", "wait", "min", "track", "jump", "miss", "error", "offset", "copy", "pos", "fast", "ip", "ips", "loop", "extra", "sid", "seed", "proc"], "bits_used": ["bits_available", "bits_needed", " bits_needed", "bits_sent", " bits_sent", " bits_available"], "bits_avail": ["bits_abanged", "bits_avanged", "bits_attail", "bits_capailed", "bits_capanged", "bits_capadded", "bits_availed", "bits_avadded", "bits_capail", "bits_abadded", "bits_attadded", "bits_abailed", "bits_attanged", "bits_attailed", "bits_abail"]}}
{"project": "FFmpeg", "commit_id": "35cb6854bb76b4a5b6f2aea2dce81e18d7ab61cd", "target": 1, "func": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n", "idx": 8900, "substitutes": {"src": ["setup", "seq", "repl", "img", "cmp", "start", "source", "sel", "pl", "pack", "low", "rec", "buf", "config", "rib", "ls", "cb", "ins", "target", "lit", "dist", "rss", "rb", "loc", "rs", "sq", "st", "ptr", "push", "sec", "inst", "la", "sub", "supp", "size", "bg", "master", "sync", "rc", "raw", "proxy", "ctx", "cur", "req", "sup", "ruby", "sl", "load", "r", "sort", "gb", "desc", "sb", "spec", "rx", "pos", "url", "comp", "length", "inf", "lc", "sr", "proc", "uc", "ssl", "sc", "fc"], "src_len": ["src_length", "source_len", "source_l", "source_length", "src_l", "rc_length", "source_line", "rc_len", "src_line", "rc_line", "rc_count"], "src_count": ["src_end", " src_end", "src__len", "src_length", "srcJcount", "srcMcount", "dest_size", "src__count", "src__end", "dest_count", " src_size", " src_length", "src__size", "srcMend", "srcJsize", "dest_c", "srcMlen", "src_size", "srcJlength", "srcJend", "src_c"], "dest": ["diff", "cdn", "des", "wp", "ds", "source", "id", "go", "rest", "cont", "path", "wb", "d", "delete", "de", "data", "cp", "destroy", "Dest", "rib", "target", "txt", "dist", "usr", "ptr", "loc", "priv", "tmp", "prop", "push", "dir", "slice", "route", "master", "sync", "name", "pipe", "home", "sup", "sort", "desc", "trans", "dc", " destination", "node", "pos", "gen", "wd", "dep", "ssl"], "dest_len": ["dest01len", " dest_line", "comb_line", "comb_len", "comb01length", "dest_count", "dest01length", " dest_length", "dest01count", "comb01count", "comb_count", "comb01line", "dest01line", "comb_length", "dest_length", "comb01len", " dest_limit", "dest_limit", "dest_line"], "ps": ["lp", "pse", "sp", "its", "cases", "pl", "pa", "gs", "parts", "ep", "po", " props", "ans", "hs", "ns", "Ps", "ips", "params", "ets", "par", "ds", "php", "aps", "pps", "s", "pe", "pm", "pages", "lines", "py", "rules", "es", "ars", "eps", "pre", "fs", "times", "ss", "pg", " pops", "ops", "pp", "posts", "cp", " posts", "ys", "ls", "local", "pins", "os", "cs", "bps", "ups", "als", "pi", "points", "vs", "pes", "amps", "pass", "ts", "ppa", "changes", "files", "itions", "PS", "ports", "powers", "p", "qs", "ins", "pt", "rs", "js", "pr", "ms", "pos", "css", "bs"], "ps_end": ["ds_END", "eps_end", "ps_enter", "ps_END", "ps_vert", "ps___dev", "ds_vert", "eps_END", "ds_dev", "ps___len", "ps_dev", "ps_len", "ps_add", "ps_ending", "ps_enable", "eps_start", "ds_end", "ds_enable", "ds_start", "ps___start", "ds_add", "eps_ending", "eps_ad", "ps___end", "eps_ends", "ps_ends", "ps_start", "ds_len", "ps_ad", "eps_enter"], "pd": ["dp", "ld", "lp", "pse", "wp", "ppa", "pg", "ds", "php", "ph", "lv", "da", "pl", "dt", "fd", "pid", "pa", "pp", "d", "pat", "cp", "ad", "bd", "p", "wd", "pb", "ls", "np", "pe", "po", "pt", "pm", "parser", "pn", "la", "dl", "py", "ln", "xd", "sync", "phi", "pr", "yd", "sth", "dd", "tp", "pu", "vd", "pi", "pc", "sd", "hd", "pod", "PD", "li", "od", "lc", "td", "dep", "pex"], "i": ["lp", "vi", "ui", "di", "it", "is", "n", "si", "zi", "m", "id", "xi", "b", "x", "ini", "t", "ami", "d", "uli", "c", "ji", "p", "uri", "ix", "e", "yi", "cli", "q", "f", "ie", "j", "ai", "dl", "o", "index", "v", "ind", "mi", "phi", "gi", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "api", "ni", "io", "y", "lc", "ri", "fi", "iu", "anti"], "l": ["lp", "wl", "le", "lf", "il", "n", "len", "ul", "lv", "m", "pl", "b", "ol", "t", "d", "c", "s", "p", "ls", "el", "e", "lit", "lu", "f", "la", "dl", "j", "o", "fl", "ll", "v", "sl", "r", "lb", "L", "u", "nl", "li", "length", "lc", "y", "ln", "lin", "kl"], "dest_end": ["dest__end", "pathamstart", "pathamended", "dest__ended", "destamended", "path_count", "dest_ended", "destnetfail", "path_start", "dest_count", "dest_start", "path_ended", "destnetend", "destnetstart", " dest_ended", " dest_fail", "destrictend", "dest__ends", "pathamend", "destnetcount", "dest__start", "dest_ends", "destamcount", "path_end", "destrictstart", "destamend", "pathamcount", "dest_fail", " dest_count", " dest_start", "destamstart", "destrictcount", "destrictfail", " dest_ends"]}}
{"project": "FFmpeg", "commit_id": "4f00519d9508e07aac58a00a9b514dae8ad95723", "target": 1, "func": "int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)\n\n{\n\n    av_log(avctx, AV_LOG_DEBUG, \"Header: %0X\\n\", show_bits(gb, 32));\n\n    v->profile = get_bits(gb, 2);\n\n    if (v->profile == PROFILE_COMPLEX)\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"WMV3 Complex Profile is not fully supported\\n\");\n\n    }\n\n\n\n    if (v->profile == PROFILE_ADVANCED)\n\n    {\n\n        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;\n\n        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;\n\n        return decode_sequence_header_adv(v, gb);\n\n    }\n\n    else\n\n    {\n\n        v->zz_8x4 = wmv2_scantableA;\n\n        v->zz_4x8 = wmv2_scantableB;\n\n        v->res_y411   = get_bits1(gb);\n\n        v->res_sprite = get_bits1(gb);\n\n        if (v->res_y411)\n\n        {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Old interlaced mode is not supported\\n\");\n\n            return -1;\n\n        }\n\n        if (v->res_sprite) {\n\n            av_log(avctx, AV_LOG_ERROR, \"WMVP is not fully supported\\n\");\n\n        }\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->s.loop_filter = get_bits1(gb); //common\n\n    if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"LOOPFILTER shall not be enabled in Simple Profile\\n\");\n\n    }\n\n    if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL)\n\n        v->s.loop_filter = 0;\n\n\n\n    v->res_x8 = get_bits1(gb); //reserved\n\n    v->multires = get_bits1(gb);\n\n    v->res_fasttx = get_bits1(gb);\n\n    if (!v->res_fasttx)\n\n    {\n\n        v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;\n\n        v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add;\n\n    }\n\n\n\n    v->fastuvmc =  get_bits1(gb); //common\n\n    if (!v->profile && !v->fastuvmc)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"FASTUVMC unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->extended_mv =  get_bits1(gb); //common\n\n    if (!v->profile && v->extended_mv)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Extended MVs unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->dquant =  get_bits(gb, 2); //common\n\n    v->vstransform =  get_bits1(gb); //common\n\n\n\n    v->res_transtab = get_bits1(gb);\n\n    if (v->res_transtab)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"1 for reserved RES_TRANSTAB is forbidden\\n\");\n\n        return -1;\n\n    }\n\n\n\n    v->overlap = get_bits1(gb); //common\n\n\n\n    v->s.resync_marker = get_bits1(gb);\n\n    v->rangered = get_bits1(gb);\n\n    if (v->rangered && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_INFO,\n\n               \"RANGERED should be set to 0 in Simple Profile\\n\");\n\n    }\n\n\n\n    v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); //common\n\n    v->quantizer_mode = get_bits(gb, 2); //common\n\n\n\n    v->finterpflag = get_bits1(gb); //common\n\n\n\n    if (v->res_sprite) {\n\n        v->s.avctx->width  = v->s.avctx->coded_width  = get_bits(gb, 11);\n\n        v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11);\n\n        skip_bits(gb, 5); //frame rate\n\n        v->res_x8 = get_bits1(gb);\n\n        if (get_bits1(gb)) { // something to do with DC VLC selection\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported sprite feature\\n\");\n\n            return -1;\n\n        }\n\n        skip_bits(gb, 3); //slice code\n\n        v->res_rtm_flag = 0;\n\n    } else {\n\n        v->res_rtm_flag = get_bits1(gb); //reserved\n\n    }\n\n    if (!v->res_rtm_flag)\n\n    {\n\n//            av_log(avctx, AV_LOG_ERROR,\n\n//                   \"0 for reserved RES_RTM_FLAG is forbidden\\n\");\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\");\n\n        //return -1;\n\n    }\n\n    //TODO: figure out what they mean (always 0x402F)\n\n    if(!v->res_fasttx) skip_bits(gb, 16);\n\n    av_log(avctx, AV_LOG_DEBUG,\n\n               \"Profile %i:\\nfrmrtq_postproc=%i, bitrtq_postproc=%i\\n\"\n\n               \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\"\n\n               \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\"\n\n               \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\",\n\n               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,\n\n               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,\n\n               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,\n\n               v->dquant, v->quantizer_mode, avctx->max_b_frames\n\n               );\n\n    return 0;\n\n}\n", "idx": 8901, "substitutes": {"avctx": ["navcb", "avcmp", "afctx", "avsync", "navsync", "AVconfig", "navctx", "abconn", "AVcn", "afpkg", "afcmp", "avectx", "abcmp", "vcontext", "AVsc", "abcontext", "vcmp", "afctl", "AVcmp", "AVpkg", " avcmp", "navconn", "AVcontext", "avcu", "verctx", "abctx", "vercontext", "verlc", "avconn", " avsc", "AVsync", "navcn", "AVlc", "avlc", "afconfig", "vctx", "cvctx", "AVctx", "avsc", "AVconn", " avcontext", "afsc", "verconn", "avconfig", "avcontext", "abcu", "vpkg", "cvctl", "avpkg", "navcontext", "navlc", "cvcontext", "AVctl", "AVcb", "avecn", "AVcu", "avecontext", "vercb", "afcontext", "avctl", " avcu", "cvconfig", "avcb", "avcn", "avesync", "ablc"], "v": ["vs", "l", "vi", "va", "gu", "vert", "sv", "n", "g", "val", "d", "lv", "view", "m", "nav", "b", "k", "t", "vim", "iv", "ve", "ver", "x", "vt", "var", "c", "vm", "s", "ov", "p", "i", "e", "tv", "value", "q", "f", "j", "ev", "qv", "vol", "inv", "version", "nv", "cv", "uv", "conv", "V", "vd", "z", "vin", "ii", "u", "vr", "h", "dev", "av", "vv", "vg", "video", "api", "vc", "rev", "volt", "vp"], "gb": ["GB", "ui", "gd", "bb", "nb", "g", "gom", "abb", "gpu", "phy", "bm", "b", "game", "gm", "gs", "gin", "bd", "hm", "cb", "ub", "bo", "ged", "cli", "gp", "rb", "gh", "gal", "bc", "gnu", "Gb", "gy", "db", "bf", "cgi", "eb", "bg", "gate", "agg", "lib", "gg", "lb", "ga", "sb", "storage", "usb", "pc", "git", "kw", "hub", "hd", "gru", "cfg", "xy", "mb", "rg", "ge", "bn", "ch", "gow", "gam", "kb", "ko", "gram"]}}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 8903, "substitutes": {"s390_dev": ["s180_def", "s380_priv", "s390_priv", "s170_device", "s390_conf", "solar_dev", "s390_def", "solar_de", "s180_device", "s380_device", "s380_dev", "s390_device", "s390_ev", "s380_ev", "s180_ev", "s170_ev", "solar_conf", "s170_def", "s390xconf", "s390xde", "s390_debug", "s390xdev", "s170_dev", "s180_dev", "s390_de", "s390xdebug", "solar_debug"], "dev": ["diff", "conf", "gu", "gd", "di", "td", "cam", "debug", "dom", "prov", "Dev", "def", "conn", "info", "temp", "dt", "dem", " priv", "development", "adv", "d", "ver", "de", "var", "ad", "data", "obj", "app", "driver", "bug", "rad", "priv", "hw", "ev", "device", "v", "md", "mod", "user", "dd", "dc", "error", "bus", "sd", "fin", "dm", "grad", "der", "client", "wd", "DEV"], "vdev": ["uvdb", "ldev", "ldb", "cdi", "tvbus", "tvver", " vver", "vrad", "wdev", "pDev", "cconn", "lrad", "vdb", "vdi", "cdev", "vdevice", "qdi", " vdiv", "ldef", "qdiv", "pdev", " vdevice", "cdevice", " vdi", "wrad", "qDev", "uvdev", "vDev", "tvdevice", "ldevice", " vDev", "vdef", "qdb", "pdef", " vdef", "vconn", "qconn", "wdevice", "vver", "tvdev", " vrad", " vbus", "qdef", "vdiv", "pdevice", "qdevice", "qrad", "uvrad", " vconn", "uvdiv", "cver", "qdev", "cbus", "vbus", " vdb", "wdiv"]}}
{"project": "qemu", "commit_id": "0fbfbb59a9766247be20023b17eb7872e7b29323", "target": 0, "func": "static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n", "idx": 8927, "substitutes": {"s": ["sg", "ts", "ks", "is", "ds", "g", "si", "sf", "m", "t", "d", "i", "gs", "service", "c", "p", "ls", "e", "qs", "parts", "args", "js", "sec", "f", "os", "cs", "sym", "o", "sets", "S", "es", "sync", "south", "states", "state", "services", "ns", "sb", "details", "spec", "sys", "params", "ses", "ps", "ss", "ssl"], "irrv": ["irerv", "irrrx", "irerq", "irprve", "irtrrb", "irtrv", " irrk", "irrck", "irrdva", "irrdve", "irrarva", "irrarvu", "irrve", " irerv", "rrrva", "mirrcv", "irrk", "irrp", "mirrv", "irrarf", " irerq", "irrrv", "rrx", "mirrcva", "irrq", "irrdx", "irtrrq", "irtrq", "irrcp", "rrrv", "irrx", "mirrvu", "irprb", "irrcx", "irrb", "irerf", "irtrrv", "irdrk", "irdrv", "irrcf", "irrrva", "irprv", "irrcvu", "mirrcvu", "irrcq", " irerf", "rrv", "irtrb", "irrdp", " irrq", "irerk", "mirrf", "irrdb", "irtrve", " irerk", "irrrb", "irrcv", "irrrq", "rrrx", "rrrp", "irtrrve", "irrva", "irrvu", "irrdv", "mirrva", "rrva", " irrf", "irrrve", "irrarv", "irrdq", "irprq", "irrcva", "rrp", "irrrf", "irrf", "irdrq", "mirrcf", "irrrvu", "irrrp", "irdrf"], "ppr": ["pphr", "ippr", "prnr", "mpnr", "ipppr", "uppp", "ppp", "ptri", "amprt", "yprt", "eprt", "mppr", "ipp", "prpr", "mphr", "upphr", "epr", "epri", "ipnr", "ypr", "uppr", "ptpr", "ippp", "ptp", "ptr", "ypri", "iphr", "prv", "amppr", "ipri", "ppv", "ipr", "pppr", "mpp", "ippri", "ppri", "ipv", "ampri", "ampr", "pprt", "eppr", "ppnr", "mpv", "mpr", "yppr", "prr", "upppr"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,\n\n\t\t CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)\n\n{\n\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n\n    int err = 0;\n\n    uint16_t magic;\n\n\n\n\t/* already locked in setup_frame() */\n\n    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);\n\n    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);\n\n    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);\n\n    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);\n\n    __put_user(env->regs[R_EDI], &sc->edi);\n\n    __put_user(env->regs[R_ESI], &sc->esi);\n\n    __put_user(env->regs[R_EBP], &sc->ebp);\n\n    __put_user(env->regs[R_ESP], &sc->esp);\n\n    __put_user(env->regs[R_EBX], &sc->ebx);\n\n    __put_user(env->regs[R_EDX], &sc->edx);\n\n    __put_user(env->regs[R_ECX], &sc->ecx);\n\n    __put_user(env->regs[R_EAX], &sc->eax);\n\n    __put_user(cs->exception_index, &sc->trapno);\n\n    __put_user(env->error_code, &sc->err);\n\n    __put_user(env->eip, &sc->eip);\n\n    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);\n\n    __put_user(env->eflags, &sc->eflags);\n\n    __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);\n\n\n\n        cpu_x86_fsave(env, fpstate_addr, 1);\n\n        fpstate->status = fpstate->sw;\n\n        magic = 0xffff;\n\n    __put_user(magic, &fpstate->magic);\n\n    __put_user(fpstate_addr, &sc->fpstate);\n\n\n\n\t/* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n    __put_user(env->cr[2], &sc->cr2);\n\n\treturn err;\n\n}\n", "idx": 8931, "substitutes": {"sc": ["cr", "sp", "asc", "SC", "context", "go", "src", "pl", "sw", "sci", "capt", "c", "de", "con", "config", "ka", "osc", "can", "Sc", "ec", "sq", "squ", "sec", "bc", "cc", "la", "hel", "isc", "scan", "cgi", "cus", "cv", "scope", "inc", "sync", "rc", "contract", "sche", "pac", "ctx", "cur", "ga", "sch", "cl", "desc", "pc", "dc", "com", "spec", "enc", "cle", "nc", "ca", "scl", "usc", "esc", "fc", "ci", "row", "lc", "sr", "crit", "mc", "acc", "uc", "exec"], "cs": ["vs", "pec", "ts", "ks", "ds", "its", "cases", "conn", "cer", "ops", "gs", "c", "cp", "s", "ls", "qs", "ins", "cf", "rss", "wcs", "args", "ec", "rs", "outs", "bc", "sk", "cc", "scope", "es", "sync", "rc", "ras", "CS", "checks", "cas", "ics", "ctx", "cal", "csv", "codes", "nas", "ns", "pc", "spec", "nc", "sys", "ips", "fs", "ps", "css", "ss", "cus", "Cs"], "magic": ["start", " success", "ALL", "work", " ERROR", "max", "Error", "alloc", "ctr", " done", "done", " len", " alloc", "oid", "error", "MAX", "result", "ERROR", "ok"]}}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n", "idx": 8946, "substitutes": {"acb": ["accb", " acsb", "ack", " acf", "dcsb", "achb", "ACw", "accbase", "dcbb", "dcb", "acbb", "ecu", " acbi", "acbase", "achbb", "aitb", "ocsb", "ocb", "accu", "ecf", "ecB", "acu", "ocbs", "macbb", "axf", "accv", "accbh", "acbh", "ancbb", "axu", "macbi", "acB", "acbi", "ucB", "ocB", "ecbs", "ecbi", " acbr", "agbs", "ACf", "ucf", " acB", "ecv", "acbr", "axv", " acw", "axb", "dcbase", "ocbb", "acbs", "ACb", "macb", "aitbase", "acsb", "ucbr", "accbb", "achbase", "acf", " ack", "ecw", "ACsb", "aitbb", "ecbb", "agb", "ACbase", "ancv", "agbb", " acbb", "ancb", "ecsb", "ucb", "accB", "eck", "ecb", "ACbb", "accf", "acv", "aitbh", "acw", "ancbr", " acv", "ocbase", "achbh", "agB", "accbr", "mack"], "s": ["l", "sg", "ts", "ks", "is", "n", "g", "si", "rows", "your", "ds", "in", "stats", "m", "info", "changes", "b", "t", "d", "gs", "sa", "c", "service", "data", "p", "ls", "e", "status", "args", "rs", "js", "f", "os", "an", "cs", "sym", "o", "aws", "sets", "S", "es", "sync", "scope", "south", "states", "sl", "services", "r", "state", "ns", "sb", "hs", "storage", "spec", "submit", "u", "sys", "params", "ses", "ps", "a", "su", "secondary", "ss", "fs", "comments", "ssl"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "substitutes": {"vtd_as": ["vdd_master", "vtd2AS", "vtd_session", "vdd2AS", "vtdokas", "vtdappasu", "vtdoksession", "vpd__as", "vdd2as", "vtd_AS", "vtdappras", "vpd_asu", "vTD__in", "vpd__ras", "vTD__is", "vtdokmaster", "vtd2as", "vTD_as", "vdd2session", "vtdappas", "vtd__master", "vtdokAS", "vtd_ras", "vtd2master", "vTD_ras", "vtdappis", "vdd_session", "vtd__as", "vpd_as", "vTD__as", "vdd_as", "vtd__AS", "vtd2session", "vTD__ras", "vdd2master", "vpd_ras", "vpd_is", "vpd__is", "vdd_AS", "vtd_master", "vtd__asu", "vtd__in", "vtd__ras", "vtd_asu", "vTD_in", "vtd_in", "vTD_is", "vpd__asu", "vtd__is", "vtd_is", "vtd__session"], "bus": ["boot", "base", "nt", "board", "http", "mount", "uss", "buf", "bridge", "service", "config", "uri", "used", "driver", "ux", "us", "BUS", "serial", "bc", "os", "host", "Bus", "sync", "name", "state", "address", "port", "usb", "plugin", "lock", "loop", "use", "cache", "proc", "drive"], "devfn": [" devln", "devname", " devfun", "diffdn", "diffkn", "diskfp", "diffn", "devicefp", "evfun", "bugn", "divfun", "devfun", "devkn", "divn", "divdn", "diskname", "evdn", "bugfun", "devln", "switchn", " devkn", "evfn", "domfp", "evname", "switchfp", "evn", "difffn", "diskfun", "switchln", "devicefn", "evkn", "diskfn", "evfp", "devdn", " devn", "devfp", " devfp", "devicename", "bugdn", " devdn", "domln", "devn", "divfn", "domn", "bugfn", "devicefun", "switchfn", "domfn"], "addr": ["mac", "adr", "area", "arr", "base", "ack", "len", "val", "id", "info", "conn", "rr", "b", "x", "bridge", "ad", "ref", "config", "uri", "ace", "server", "attr", "afi", "rss", "amd", "ag", "ptr", "act", "rs", "loc", "ac", "dr", "host", "rt", "ha", "route", "amp", "oa", "name", "sta", "rc", "md", "address", "kt", "dd", "nr", "part", "dc", "offset", "hop", "node", "asm", "eth", "vr", "layer", "pos", "rx", "ip", "url", "ann", "pkg", "wd", "adder"], "is_write": ["is__writing", "in_written", "in_write", "is_read", "in_writing", "in_read", "is2write", "is__read", "is2written", "is_writing", "is2read", "is__write", "is_written", "is2writing", "is__written"], "entry": ["ee", "session", "je", "Entry", "enter", "ry", "record", "ent", "service", "data", "server", "e", "ace", "ie", "rc", "ries", "event", "address", "ident", "spec", "row", "ge", "import", "ant", "insert", "cell"], "s": ["session", "sg", "ts", "ks", "is", "si", "g", "source", "stats", "m", "http", "b", "t", "ops", "i", "gs", "service", "c", "sa", "p", "server", "e", "parts", "ins", "request", "sq", "us", "js", "f", "os", "cs", "o", "S", "es", "sync", "space", "south", "state", "services", "sl", "r", "bis", "ns", "storage", "sb", "sis", "spec", "this", "sys", "self", "ses", "ps", "site", "a", "ss", "settings", "ssl", "sc"], "ce": ["le", "ve", "ance", "ace", "cc", "ie", " je", "code", " exce", "cur", "cal", "cle", "ca", "let", "gu", "ide", "ee", "c", "ct", "component", "se", "e", "ate", "cf", "pe", "ze", "ense", "ice", "che", " CE", " ent", "ke", "cast", "ced", "cel", "ant", "ge", "ine", "cell", "he", " ke", "CE", "cer", " ge", "cu", "ue", "dr", "cs", "ae", "catch", "edge", " ace", "ces", "cat", "use", "co", " pe", " ne", "ne", "oe", "SE", "ade", "see", " ie", "cue", "coe", "client", "ci", "force", "fe", "cy", "te"], "cc_entry": ["cc_rance", "cc_enter", "cn_enter", "ccappentry", "ccallentry", "cf_enter", "cc_element", "ccappenter", "cf_start", "rc_server", "CC_entry", "cc___inc", "ccappresult", "ccapparchive", "cf_entry", "cc_server", "cc_start", "CC_enter", "cn_event", "cc_event", "ccappelement", "ccallresult", "CC_import", "ctx_import", "CC_archive", "cnallenter", "cc_archive", "rc_path", "cc_import", " cc_inc", "cc_path", "cnallentry", "cnallevent", "cn_result", "cc_index", "ctx_reader", "cc_inc", "cf_element", "cc___path", "ctx_element", "cc___server", "ccallevent", "cnallresult", "ccallenter", " cc_index", "ccappevent", "ccappstart", " cc_rance", "cc___entry", "ccappimport", "cc_result", "cn_entry", "rc_inc", "cc_reader", "rc_entry", "ctx_entry"], "slpte": ["celptes", "celppn", "slppn", "slportd", " slntype", " slpta", "slntf", " slnta", "slptes", "slpointa", "slportey", "slupte", "celppes", "slpetes", "islpetec", "sliptec", "nlptec", "slnte", "celppe", "slpete", "nlptd", "slintes", "nlptey", "islptea", "sliptey", "slinte", "slppf", "slppes", "nlupte", "slptey", "slptf", "islpete", "slppe", "slntype", "slpetie", "celpppe", "slpointype", "slppec", " slnte", "slppea", "slporte", "slptn", "slftie", "nluptec", "nlpte", "slfte", "slptea", "celptpe", "slpetn", "slftea", "slintpe", "islpetea", "islpte", "sliptd", "slptec", "sluptd", "slpta", "islpetie", "slpetpe", "slppa", "slpetea", "celptn", "slptie", "slpppe", "sluptey", "slnta", "slptd", "slintn", "islptie", "slptype", "slppie", " slptf", "slppype", "slipte", " slntf", " slptype", "sluptec", "slpetec", "nluptd", "nluptey", "celpte", "slftec", "slportec", "slpointe", "slptpe", "islptec", "slpointf"], "page_mask": ["page_limit", "page___max", "page_flags", "page_ask", " page_length", " page_flags", " page_ask", "page___length", "page___mask", "page___limit", " page_limit", "page___flags", "page_max", "page_length", "page___ask", " page_max"], "level": ["parent", "zip", "pass", "base", "delay", "scale", "low", "lvl", "limit", "local", "loc", "mode", "priority", "code", "index", "scope", "inc", "levels", "lev", "bit", "type", "layer", "loop", "weight", "depth", "pattern", "vel"], "ret_fr": ["Ret_fr", "x", "ctr", "retregtr", "ret24br", "retregfr", "retregwrite", "ret_tr", " ret_pr", "Ret_br", "_", "retregdr", "ret24fr", "ret_pull", " ret_frac", "r", "Ret_write", "ret_dr", "this", "ret24pull", "Ret_pull", "g", " ret_dr", "d", "ret_write", "ret_frac", "ret_pr", "Ret_tr", "ret_cache", " ret_tr", "Ret_dr", " ret_cache", "write", "ret_br"], "access_flags": ["access___rights", "access_rules", "access_limits", " access_mask", "accessalflags", "accessslimits", "access___count", " access_bits", "access_parts", "access_mask", "access_flag", " access_rules", "accesssflags", "accessalmask", "access___flags", "access_rights", "access___bits", "accesssparts", " access_count", " access_flag", " access_parts", "accesssmask", "accessallimits", " access_limits", "access_bits", "accessalparts", " access_rights", "access_count"], "iotlb_entry": ["iotb_ry", "iotlb_post", "iotbl_post", "iotlb_try", "iotbl__entry", "iotzb_see", "iotla_enter", "iotzb_entry", "iotlb00ent", "iotbl_entry", "iotlbappcell", "iotlab_inc", "iotlb_enter", "iotbl_import", "iotlbapppost", "iotlb_ry", "iotb_way", "iotb_element", "iotlab_enter", "iotlab_ent", "iotml_entry", "iotlb_id", "iotla_server", "iotlb_index", "iotbl__import", "iotlb_view", "iotlb__entry", "iotlb_reader", "iotlb_element", "iotlb00view", "iotml_reader", "iotlb_server", "iotbl__post", "iotlb_way", "iotlb_exit", "iotlb_see", "iotlab_try", "iotlb__post", "iotb_entry", "iotla_index", "iotlab_exit", "iotbl_cell", "iotzb_id", "iotlab_entry", "iotla_entry", "iotlb00enter", "iotlb_inc", "iotlb__cell", "iotlb_cell", "iotml_exit", "iotlbappentry", "iotlb__import", "iotlb00entry", "iotlb_import", "iotlb_ent", "iotbl__cell", "iotlbappimport", "iotlab_view"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int load_multiboot(void *fw_cfg,\n\n                   FILE *f,\n\n                   const char *kernel_filename,\n\n                   const char *initrd_filename,\n\n                   const char *kernel_cmdline,\n\n                   int kernel_file_size,\n\n                   uint8_t *header)\n\n{\n\n    int i, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    MultibootState mbs;\n\n    uint8_t bootinfo[MBI_SIZE];\n\n    uint8_t *mb_bootinfo_data;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n\n    memset(bootinfo, 0, sizeof(bootinfo));\n\n    memset(&mbs, 0, sizeof(mbs));\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        uint64_t elf_low, elf_high;\n\n        int kernel_size;\n\n        fclose(f);\n\n\n\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_low, &elf_high, 0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = elf_low;\n\n        mb_kernel_size = elf_high - elf_low;\n\n        mh_entry_addr = elf_entry;\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                  mb_kernel_size, (size_t)mh_entry_addr);\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n        uint32_t mb_load_size = 0;\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n\n\n        if (mh_load_end_addr) {\n\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n\n        } else {\n\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n\n            mb_load_size = mb_kernel_size;\n\n        }\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                 mb_load_size, mh_load_addr);\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n\n            fprintf(stderr, \"fread() failed\\n\");\n\n            exit(1);\n\n        }\n\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n\n        fclose(f);\n\n    }\n\n\n\n    mbs.mb_buf_phys = mh_load_addr;\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n\n\n\n    /* Calculate space for cmdlines and mb_mods */\n\n    mbs.mb_buf_size += strlen(kernel_filename) + 1;\n\n    mbs.mb_buf_size += strlen(kernel_cmdline) + 1;\n\n    if (initrd_filename) {\n\n        const char *r = initrd_filename;\n\n        mbs.mb_buf_size += strlen(r) + 1;\n\n        mbs.mb_mods_avail = 1;\n\n        while (*(r = get_opt_value(NULL, 0, r))) {\n\n           mbs.mb_mods_avail++;\n\n           r++;\n\n        }\n\n        mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n\n    }\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n\n\n\n    /* enlarge mb_buf to hold cmdlines and mb-info structs */\n\n    mbs.mb_buf          = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n    mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n\n\n\n    if (initrd_filename) {\n\n        char *next_initrd, not_last;\n\n\n\n        mbs.offset_mods = mbs.mb_buf_size;\n\n\n\n        do {\n\n            char *next_space;\n\n            int mb_mod_length;\n\n            uint32_t offs = mbs.mb_buf_size;\n\n\n\n            next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename);\n\n            not_last = *next_initrd;\n\n            *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename);\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n            mb_debug(\"multiboot loading module: %s\\n\", initrd_filename);\n\n            mb_mod_length = get_image_size(initrd_filename);\n\n            if (mb_mod_length < 0) {\n\n                fprintf(stderr, \"Failed to open file '%s'\\n\", initrd_filename);\n\n                exit(1);\n\n            }\n\n\n\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n            load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs);\n\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n\n\n\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n\n                     (char *)mbs.mb_buf + offs,\n\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n\n            initrd_filename = next_initrd+1;\n\n        } while (not_last);\n\n    }\n\n\n\n    /* Commandline support */\n\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n\n             kernel_filename, kernel_cmdline);\n\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n\n\n\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n\n\n\n    /* the kernel is where we want it to be now */\n\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                                | MULTIBOOT_FLAGS_CMDLINE\n\n                                | MULTIBOOT_FLAGS_MODULES\n\n                                | MULTIBOOT_FLAGS_MMAP);\n\n    stl_p(bootinfo + MBI_MEM_LOWER,   640);\n\n    stl_p(bootinfo + MBI_MEM_UPPER,   (ram_size / 1024) - 1024);\n\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n\n\n\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n\n\n\n    /* save bootinfo off the stack */\n\n    mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n\n    memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n\n                     mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n\n                     sizeof(bootinfo));\n\n\n\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n\n    option_rom[nb_option_roms].bootindex = 0;\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 8955, "substitutes": {"fw_cfg": ["FW_fs", "FW_config", "fw_config", "FW_cfg", "fw_conf", "fw_fs", "FW_conf"], "f": ["l", "rf", "fu", "fo", "fen", "g", "sf", "w", "m", "fr", "fd", "b", "t", "fore", "fw", "d", "c", "fb", "s", "p", "e", "fp", "feed", "frame", "df", "tf", "v", "framework", "fin", "fn", "h", "F", "file", "fs", "proc", "fab"], "kernel_filename": ["elf_file", "elf_filename", "elf_fp", "linux_filename", "linux_name", "kernel_file", "kernel_directory", "kernel2directory", "kernel2file", "kernel2filename", "kernel2name", "kernel_fp", "kernel_name", "linux_file", "linux_directory"], "initrd_filename": ["cline_file", "cline_mode", "crd_fp", "crddfilename", "crd_mode", "cline_filename", "cline_fp", "crddfp", "crddfile", "crd_file", "crddmode", "crd_filename"], "kernel_cmdline": ["kernel_cmdload", "kernel_reqspace", "kernel_paramspace", "kernel_commandspace", "kernel_paramname", "kernel_paramload", "kernel_commandload", "kernel_commandname", "kernel_reqline", "kernel_paramline", "kernel_cmdspace", "kernel_reqload", "kernel_commandline", "kernel_reqname", "kernel_cmdname"], "kernel_file_size": ["kernel_data_SIZE", "kernel_data_count", "kernel_data_size", "kernel_file_count", "kernel_file_SIZE"], "header": ["later", "parent", "center", "cookie", "channel", "kernel", "comment", "prefix", "date", "prot", "consumer", "filename", "fw", "buf", "bridge", "metadata", "head", "data", "config", "mask", "meta", "server", "component", "target", "queue", "Header", "request", "driver", "writer", "frame", "table", "cover", "body", "padding", "dr", "host", "version", "index", "master", "flags", "name", "connection", "event", "content", "feature", "four", "document", "begin", "counter", "offset", "layer", "h", "message", "headers", "border", "carry", "directory", "definition", "buffer", "forward"], "i": ["count", "l", "hi", "ui", "di", "it", "start", "si", "n", "len", "zi", "iii", "m", "xi", "t", "x", "ini", "b", "z", "d", "c", "ji", "uri", "p", "ix", "cli", "mu", "mini", "eni", "ie", "j", "ai", "child", "multi", "index", "slice", "v", "gi", "ti", "mi", "phi", "abi", "qi", "counter", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "io", "ni", "y", "ri", "fi", "iu"], "mh_entry_addr": ["g", "all", "mh_load_ref", "_", "s", "addr", "linux", "ctr", "dll", "mh_entry_address", "mh_load_address", "mh_entry_ref", "this", "mh_entry_offset", "mh_load_offset", "buffer"], "mh_load_addr": ["mh_loader_size", "mh_loader_address", "mh_load_add", "mh_load_ref", "mh_loader_ref", "mh_load64addr", "mh_load64size", "mh_load___ref", "mh_load64add", "mh_loader_add", "mh_load___add", "mh_loader_addr", "mh_load___addr", "mh_load_address", "mh_load___address", "mh_load_size"], "mb_kernel_size": ["mb_linux_data", "mb_kernel_data", "mb_kernel32speed", "mb_kernel32size", "mb_kernel_speed", "mb_linux_scale", "mb_kernel___scale", "mb_linux_speed", "mb_file_scale", "mb_kernel_length", "mb_linux_size", "mb_kernel32scale", "mb_kernel_scale", "mb_kernel32data", "mb_kernel___size", "mb_file_length", "mb_file_size", "mb_kernel___length"], "mbs": ["amgs", "tmbc", "emps", "tmbs", "mibs", "tmps", "mbers", "mps", "mgs", "Mboxes", "mBS", "tmcs", "dmgs", "embc", "tmbles", "mbc", "mbles", "amcs", "dmbs", "pmbs", "tmgs", " mps", "ambles", "miBS", "mcs", "mibers", "mboxes", "pmBS", "dmbles", "pmbers", "emcs", "MBS", "dmcs", "miboxes", " mbc", "Mbers", "ambs", " mcs", "Mbs", "pmboxes", "embs"], "bootinfo": ["memid", "bytearchive", "loadstart", "bootstart", "lockid", "buildstart", "busInfo", "businfo", " bootarchive", "byteid", "bootInfo", " bootid", "lockinfo", "byteInfo", " bootstart", "buildinfo", "buildarchive", "lockInfo", " bootInfo", "buildInfo", "loadInfo", "loadinfo", "byteinfo", "bootid", "bootarchive", "memarchive", "busid", "meminfo", "loadarchive", "memInfo"], "mb_bootinfo_data": ["mb_bootinfo_info", "mb_bootinfo_bytes", "mb_bootinfo_buffer", "mb_bootINFO_info", "mb_bootINFO_buffer", "mb_bootINFO_bytes", "mb_bootINFO_data"], "elf_entry": ["ilo_entry", "ilo_image", "elf__image", "lf_inc", "elf_rc", "lf_entry", "elf_image", "elfsid", "elf_inc", "elf__entry", "elfslow", "lf_rc", "lf_low", "elfsimage", "ilo_low", "elf__low", "elf_id", "ilo_id", "elf__id", "elfsentry"], "elf_low": ["elf00size", "lf_la", "hl_low", "ELF_source", "lf_old", "lf_size", "hl_high", "elf_limit", "elfAold", "hlachigh", "hlacoffset", "elfJlimit", "elfJlow", "lf_low", "elfPbase", "elf_source", "elf_size", "ELF_low", "elfachigh", "hl_offset", "hl_limit", "elf00low", "ELF_base", "elf_offset", "elfaclow", "elf10high", "elf10source", "elf10low", "elfAlow", "elfPhigh", "elf00la", "egg_low", "elf00old", "elf_little", "elfAla", "elfPsource", "elfPlow", "elf_base", "elfAsize", "elf10base", "egg_little", "egg_old", "elf_la", "hlaclow", "elfacoffset", "elf_old", "ELF_high", "elfaclimit", "elfJoffset", "elfJhigh", "hlaclimit", "egg_high"], "elf_high": ["ELF_pop", "elf00low", "elf_large", "elf_hi", "elf_index", "el_last", "elf67last", "ELF_high", "elf67low", "el_low", "elf_last", "ELF_index", "el_hi", "ELF_large", "elf_pop", "el_high", "ELF_low", "elf00high", "ELF_hi", "elf67hi", "elf67high", "elf00index", "elf00large"], "kernel_size": ["kernel67rate", " kernel_weight", "kernel6number", "work64size", "work64rate", "kernel_number", "kernel64number", "kernel6size", "kernel64rate", "kernel6len", "kernel_sum", "kernel_pos", "kernel67number", "work_size", "kernel67len", " kernel_pos", "kernel6rate", "work_len", "work_number", "kernel64len", "kernel64size", " kernel_sum", "work_rate", "kernel_rate", "kernelacsize", "kernel_len", "work64len", "kernel67size", "work64number", "kernelacsource", "kernel_weight", " kernel_source", "kernel_source", "kernelacweight"]}}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,\n\n                                          int *beta, int *tc, uint8_t *no_p,\n\n                                          uint8_t *no_q)\n\n{\n\n    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),\n\n                                beta, tc, no_p, no_q);\n\n}\n", "idx": 8963, "substitutes": {"pix": [" pixel", " pik", "dpico", "dpix", "cpix", "pik", "Pico", "dpixel", " pixels", "Pix", "pixel", "pico", "pick", "dpixels", " pico", "pixels", "cpik", "cpixel", "apick", "cpick", "apixel", "apik", "Pixels", " pick", "apix", "Pixel"], "stride": ["strand", "spide", "sprided", "Stride", " strided", " strite", "sprider", "spride", "Strided", "sprite", " strider", "strider", "spand", "spided", "Strider", "stided", " strand", "stider", "stite", "stide", "strite", "strided", "Strand", "spider"], "beta": ["uca", "ui", "timeout", "ta", "scale", "si", "ba", "b", "\u03b2", "fb", "meta", "pb", "cb", "Beta", "lambda", "bc", "padding", "alpha", "mega", "phi", "abi", "buffer", "bis", "bot", "margin", "bi", "gradient", "offset", "lc", " alpha", "gam", "fee"], "tc": ["term", "ta", "temp", "t", "toc", "c", "cp", "pb", "cu", "cli", "loc", "tmp", "bc", "cc", "ac", "rc", "cas", "ctx", "TC", "pc", "dc", "xc", "icc", "cm", "ca", "ci", "cache", "lc", "mc", "acc", "sc", "uc", "fc"], "no_p": ["no_n", "no_c", " no_c", "no__n", " no_n", "no__p", "no__cp", "no_e", "no_cp", " no_cp", " no_e", "no__q"], "no_q": ["No_q", "no_c", "no_qs", "noParp", "no7c", "no7p", "noParq", "no7q", "no7qs", "No_c", "noLqs", "noLp", "no_eq", "noLq", "No_p", " no_eq", "noLeq", " no_qs", "noParqs", "No_qs", "noPareq"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n", "idx": 8970, "substitutes": {"s": ["session", "is", "its", "strings", "m", "http", "t", "x", "plugins", "ges", "v", "groups", "ns", "spec", "self", "settings", "sg", "ds", "n", "si", "sf", "w", "i", "opens", "e", "se", "sq", "us", "f", "sym", "sets", "es", "r", "u", "comments", "fs", "site", "times", "ows", "sc", "uses", "ks", "context", "g", "ops", "d", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "native", "sb", "sys", "ions", "ssl", "ts", "rows", "service", "p", "qs", "tests", "ins", "xs", "js", "rs", "sec", "S", "sie", "states", "services", "ctx", "ches", "ses"], "ext": ["xp", "str", "abc", " Ext", "test", "temp", "cont", "x", "ab", "t", "z", "sa", "data", "config", "p", "ace", "e", "app", "cb", "txt", "ex", "EXT", "f", "ut", "next", "external", "al", "aux", "current", "ctx", "att", "req", "cur", "tx", "desc", "cpp", "xt", "cfg", "self", "h", "Ext", "fc", "lc", "text", "proc", "sc", "fab", "exec"], "c": ["count", "cr", "arc", "C", "n", "g", "m", "unc", "t", "x", "z", "k", "d", "i", "p", "e", "cu", "cb", "or", "ec", "coll", "f", "ac", "cc", "code", "cs", "call", "o", "v", "ce", "name", "ic", "r", "dc", "enc", "col", "init", "u", "nc", "h", "ca", "ci", "vc", "lc", "ch", "y", "cache", "mc", "uc", "cy", "chain"], "a": ["va", "area", "n", "na", "ba", "w", "x", "ab", "t", "d", "i", "sa", "ad", "p", "ka", "e", "aaa", "at", "off", "f", "ac", "an", "ai", "alpha", "ae", "aux", "current", "ar", "am", "address", "A", "as", "u", "ast", "aa", "ca", "ma", "api", "y", "ap"], "b": ["ib", "base", "bb", "nb", "n", "g", "abb", "ba", "w", "bp", "bar", "k", "ab", "x", "wb", "d", "i", "fb", "p", "pb", "e", "split", "B", "rb", "f", "v", "r", "lb", "bis", "sb", "emb", "u", "null", "ob", "y", "bs", "mb"], "b_const": [" b_vert", "b_ctr", "b__const", " b_free", "b_vert", "b_Const", "B_vert", " b_int", " b__vert", "b__int", "B_ctr", " b_struct", " b__int", "B_const", "b_free", "bxint", " b_Const", "b_int", "b__vert", " b_con", "bxvert", "bxconst", " b__free", "b_con", "bxfree", " b__const", "b_cmp", "b_struct", "B_cmp", "b__free"], "l": ["lp", "le", "il", "n", "g", "w", "m", "pl", "t", "d", "i", "ell", "p", "ls", "el", "e", "lu", "loc", "lr", "f", "dl", "o", "fl", "al", "ll", "v", "sl", "r", "L", "lb", "u", "nl", "li", "lc", "rl", "ln", "lo", "kl"], "offset": ["alias", "uple", "location", "base", "operation", "start", "initial", "pad", "info", "unc", "missing", "shift", "pointer", "slot", "limit", "ref", "p", "adjust", "ace", "sum", "fp", "set", "skip", "value", "number", "ptr", "loc", "off", "array", "padding", "o", "append", "index", "alloc", "size", "slice", "exclusive", "column", "adjusted", "align", "end", "address", "function", "margin", "part", "position", "error", "pc", "aw", "output", "type", "online", "et", "pos", "layer", "attribute", "url", "length", "cache", "fee", "Offset", "reset"], "need_cmp": ["need_mp", "needJcmp", "needfulcont", "need_eq", "needfulmp", " need_cont", " need_comp", " need_mp", "needed_cmp", "needfulcmp", "needJcod", "need_conv", "need_cont", "needJeq", "need_cod", "need_coll", " need_conv", " need_eq", "needfulcomp", "needed_comp", "needed_mp", " need_cod", "needJcomp", "need_comp", "needed_coll"]}}
{"project": "qemu", "commit_id": "3736cc5be31f0399999e37d8b28ca9a3ed0b4ccb", "target": 0, "func": "static int nbd_negotiate_options(NBDClient *client, Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    trace_nbd_negotiate_options_flags();\n\n    be32_to_cpus(&flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        trace_nbd_negotiate_options_newstyle();\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        trace_nbd_negotiate_options_no_zeroes();\n\n        client->no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EIO;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n\n\n        trace_nbd_negotiate_options_check_option(option);\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                tioc = nbd_negotiate_handle_starttls(client, length, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_TLS_REQD,\n\n                                                 option, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                ret = nbd_negotiate_handle_list(client, length, errp);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8988, "substitutes": {"client": ["parent", "cdn", "man", "co", "connect", "product", "worker", "chrome", "conn", "open", "http", "public", "net", "project", "container", "con", "Client", "c", "service", "config", "server", "output", "app", "cli", "local", "queue", "request", "cod", "socket", "manager", "host", "resource", "call", "ce", "current", "connection", "remote", "response", "google", "input", "bird", "user", "port", "patch", "custom", "pc", "get", "plugin", "self", "command", "api", "ip", "clean", "image", "cache", "cell", "cmd", "cart", "pattern"], "errp": ["erp", "irP", "bugpa", " errP", "reqpe", "aerping", "eerpa", "ererproc", "eerpo", "interfp", "herepa", "herps", "arrf", "reqf", "reqp", "arrpe", "asterpa", "innerping", "ferp", "yrpost", " errapi", "herepe", "errf", "erpa", "erP", "bugpost", "errback", "eerfp", "herping", "erfp", "erpo", "herp", "ferpre", "derP", "ererfp", "ferf", "errpre", "drpre", "irfp", "errps", "serverp", "asterP", " errping", "interpre", "herpath", " errf", "errorpre", "herepost", "derf", "errpi", "derpc", "asterf", "ererp", "aerps", "irp", "eorback", "orderfp", "innerpath", "errpp", "drproc", "herep", "ErrorP", "interp", "erpi", "Errorf", "errorp", "errping", "rrpre", "errorapi", "errsp", "asterpo", "reqpp", "errP", "eorp", "errpc", "errproc", " errb", "orderp", "intersp", "bugp", "asterpc", "errpo", "aerpath", "yrpe", "irpi", "serverf", "errb", "ersp", "rrfp", "eerp", "errfp", "arrpp", "yrpa", "derp", "asterfp", "errorping", "drfp", "errorf", "errpe", " errpp", "ererpre", "erpre", "serverb", " errpc", "innerps", " errpe", "errapi", "errpost", "innerp", "rrp", "drp", "errorb", "orderpi", "erproc", " errpre", "errpa", "yrp", "serverapi", "ferping", "errpath", "arrp", "Errorp", "eorP", "bugpe", "aerp", "eorf", "Errorback", "rrsp", "orderP", "asterp", " errback"], "flags": ["vals", "styles", "utils", "flag", "ds", "includes", "strings", "members", "features", "heads", "stats", "links", "alls", "fields", "fd", "files", "requires", "ils", "filename", "ops", "ports", "lists", "mask", "config", "ants", "status", "reports", "xml", "versions", "lins", "bits", "args", "lag", "planes", "types", "errors", "f", "plugins", "tools", "FLAG", "Flags", "items", "values", "rules", "ints", "bugs", "caps", "properties", "fps", "states", "services", " Flags", "ags", "locks", "codes", "groups", "details", "bytes", "allows", "ips", "options", "fs", "comments", "feat", "settings", "atts", "ssl", "events", "fee"], "ret": ["count", " num", "flag", "ry", "val", " resp", " success", "nt", "Ret", " Ret", "num", " result", " count", " flag", "res", "al", "rc", " r", "rep", " rc", "RET", " RET", "result", " res", "success"], "option": ["element", "ion", "session", "Option", "term", "timeout", "optional", "operation", "section", "prefix", "key", "color", "open", "ban", "update", "block", "ption", "other", "config", "optim", "package", "global", "value", "number", "loc", "search", "cho", "array", "op", "large", "entry", "version", "index", "opt", "route", "name", "connection", "event", "feature", "example", "item", "object", "function", "put", "position", "error", "offset", "type", "lock", "pair", "single", "options", "image", "weight", "pin"], "length": ["count", "zip", "element", "level", "library", "character", "delay", "len", "section", "view", "id", "model", "tag", "mount", "total", "filename", "block", "data", "limit", "max", "config", "value", "number", "style", "loc", "Length", "serial", "sequence", "select", "padding", "label", "child", "slice", "size", "version", "duration", "function", "full", "patch", "pull", "available", "position", "error", "list", "type", "tail", "lock", "build", "options", "url", "text", "weight", "partial", "family", "range"], "magic": ["cookie", "base", "number", "dom", "iso", "prefix", "complex", "temp", "model", "http", "missing", "stat", "memory", "money", "big", "data", "config", "time", "meta", "ix", "generic", "status", "script", "secret", "action", "mic", "bug", "serial", "mini", "xxx", "agic", "padding", "style", "binary", "progress", "version", "size", "module", "inc", "format", "example", "bot", "token", "patch", "custom", "special", "unknown", "icon", "spec", "git", "init", "plugin", "lock", "type", "tech", "year", "Magic", "extra", "math", "cache", "agent", "currency", "image", "mag", "security", "power"]}}
{"project": "qemu", "commit_id": "f21126df5f81797486eb3bd628da8e2ad5fae12e", "target": 1, "func": "static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { /* write */\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n", "idx": 9025, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "state", "full", "ns", "hs", "spec", "self", "params", "settings", "sg", "ds", "si", "your", "sf", "b", "i", "serv", "c", "se", "e", "request", "args", "us", "f", "sym", "sets", "scope", "es", "r", "as", "u", "comments", "fs", "ps", "site", "su", "ss", "ks", "sv", "g", "stats", "ops", "d", "ls", "status", "os", "cs", "o", "sync", "south", "native", "new", "sb", "sys", "side", "ions", "a", "ssl", "conf", "ts", "the", "service", "p", "server", "qs", "tests", "ins", "xs", "js", "rs", "an", "aws", "S", "sie", "states", "services", "less", "h", "ses", "uns", "y", "bs"], "bits": ["vals", "boot", "BIT", "acts", "its", "nos", "features", "dates", "stats", "alls", "fields", "ops", "ports", " bugs", "mask", "pieces", "parts", "status", "ins", "ids", "steps", "runs", "bands", "outs", "planes", "pins", "plugins", "values", "limits", "ints", "flags", "bugs", "fps", "checks", "states", "notes", "locks", "codes", "hours", "cycles", "details", "blocks", "bytes", "bit", "lock", "gets", "ips", "options", "nets", "bs", "settings", "lins"], "value": ["json", "x", "store", "max", "xml", "none", "device", "values", "v", "content", "end", "object", "offset", "type", "image", "vi", "element", "val", "key", "w", "no", "id", "b", "total", "expression", "e", "unit", "index", "format", "position", "error", "fee", "temp", "num", "d", "data", "flow", "xxx", "entry", "resource", "o", "version", "size", "gi", "ava", "sn", "node", "message", "result", "VALUE", "ion", "byte", "Value", "valid", "scale", "wa", "server", "p", "number", "child", "name", "function", "address", "option", "null", "nu", "length", "write", "fe"], "n": ["l", "un", "nb", "len", "g", "span", "na", "ny", "m", "conn", "nt", "no", "t", "x", "k", "b", "num", "z", "d", "i", "ne", "net", "c", "inn", "p", "e", "don", "cn", "nw", "number", "dn", "f", "network", "nat", "j", "pn", "o", "N", "size", "non", "nit", "v", "name", "inner", "en", "sn", "ns", "node", "nan", "fn", "nc", "nl", "not", "nu", "ng", "ni", "length", "y", "adj", "nn"], "is_read": ["is_ok", " is_ok", " is_add", "is__ready", "is_Read", "is_write", "is_ready", "is__add", " is_Read", " is_write", "is__Read", "is__read", "is_current", "is__write", " is_current", " is_ready", "is_add"], "datacnt": [" datacant", " datacNT", " datcct", "datacourse", " Datacct", "DatACound", " datcnt", "Dataccent", " datACount", " Dataccnt", "datACnet", "dataccant", "daticount", "dataccound", "DatACnt", "Datacound", "dataccct", "daticnt", "datacnet", "datACnt", "Datacount", " datacnc", " datACnt", "datAcount", " datACourse", " datacount", "daticnc", "Datacct", "DatACount", "dataclnt", "DatACnc", "datAcNT", "dataccourse", " Dataccct", "datacount", " datacct", "dataclound", "datacant", " datACnet", "datancnet", " datacourse", "datACnc", " datACct", "datacct", "datacccent", "datACount", "DatACcent", " Datacount", "datcnt", "datAcnt", "datascourse", " datACNT", " Dataccnc", " datACant", "datcnc", "datacNT", "daticct", "DatACct", "datancnt", "datancNT", "datecnt", "dataccnc", "dataccent", "datcount", "datacnc", "datacound", "datACcent", "datACant", "datecnc", "datACct", "Datacnc", " datcnc", " Dataccount", " datcount", "datACourse", " Datacnt", "datascnt", "dataccnt", "datACound", "dataccount", "datascant", "datAcnet", "datACNT", "datcct", "dataccNT", "dataclct", "datecct", "datancount", "datascct", " datACnc", "datecount", "Datacnt", "datAcct", "dataclcent", " Datacnc", " datacnet", "datAcnc"]}}
{"project": "FFmpeg", "commit_id": "93c04e095dc37ebdab22174e88cfa91e24940866", "target": 0, "func": "static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)\n\n{\n\n    AMFDataType type;\n\n    AVStream *stream, *astream, *vstream;\n\n    AVIOContext *ioc;\n\n    int i;\n\n    // only needs to hold the string \"onMetaData\".\n\n    // Anything longer is something we don't want.\n\n    char buffer[11];\n\n\n\n    astream = NULL;\n\n    vstream = NULL;\n\n    ioc     = s->pb;\n\n\n\n    // first object needs to be \"onMetaData\" string\n\n    type = avio_r8(ioc);\n\n    if (type != AMF_DATA_TYPE_STRING ||\n\n        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)\n\n        return -1;\n\n\n\n    if (!strcmp(buffer, \"onTextData\"))\n\n        return 1;\n\n\n\n    if (strcmp(buffer, \"onMetaData\"))\n\n        return -1;\n\n\n\n    // find the streams now so that amf_parse_object doesn't need to do\n\n    // the lookup every time it is called.\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        stream = s->streams[i];\n\n        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n            astream = stream;\n\n        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            vstream = stream;\n\n    }\n\n\n\n    // parse the second object (we want a mixed array)\n\n    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)\n\n        return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 9036, "substitutes": {"s": ["l", "session", "sg", "ts", "sv", "ds", "n", "g", "si", "is", "sf", "stats", "m", "t", "b", "gs", "service", "c", "p", "ls", "server", "qs", "e", "xs", "sq", "rs", "parser", "f", "js", "os", "us", "cs", "sets", "S", "v", "sync", "es", "space", "sl", "services", "ctx", "bis", "ns", "sb", "storage", "spec", "cpp", "this", "u", "sys", "sim", "self", "comments", "ses", "fs", "ps", "su", "a", "ss", "settings", "ssl", "sc"], "next_pos": ["nextxposition", "nextpposition", "nextpPos", " next_Pos", "next2position", "next2pos", "next_position", "next_Pos", "nextxline", "nextnPos", " next_offset", "nextnpos", "next2offset", "nextppos", "next_line", "next2line", "nextxpos", "nextpoffset", "nextnoffset", "nextxoffset", " next_position", " next_line", "nextnposition", "next_offset"], "type": ["class", "record", "test", "info", "method", "key", "pl", "http", "model", "t", "id", "instance", "x", "Type", "data", "block", "p", "e", "bo", "pe", "rel", "value", "style", "types", "op", "code", "resource", "o", "call", "py", "version", "format", "current", "name", "state", "r", "pre", "ty", "port", "tp", "error", "TYPE", "link", "form", "y", "ype", "typ"], "stream": ["channel", "path", "iv", "pool", "thread", "dest", "feed", "object", "document", "port", "form", "row", "interface", "image", "filter", "hook", "upload", "view", "w", "stage", "speed", "cont", "instance", "steam", "draw", "slice", "input", "load", "cl", "file", "Stream", "impl", "context", "source", "model", "public", "stack", "coll", "entry", "host", "resource", "sub", "ream", "rog", "sync", "sl", "raw", "trans", "enc", "node", "engine", "through", "uc", "ssl", "valid", "sw", "rec", "time", "server", "reader", "wrapper", "child", "draft", "track", "user", "audio", "client", "transform", "video", "length"], "astream": ["ASTource", "asprom", "mastram", "adaptREAM", " astram", "maststream", "ASTREAM", "ASTchannel", "astrom", " aststream", "aspstream", "astsogg", "mastream", "astsource", "astraw", "paststream", "aspreen", " astrom", "astsstream", "aststream", "astogg", "astram", "astsREAM", "ASTraw", "astsream", "ASTram", "astsrom", "astource", "astchannel", "mastraw", "adaptstream", "ASTream", "adaptource", "pastream", "pastchannel", "astREAM", " astraw", "ASTogg", " astreen", "pastogg", "astreen", "aspream", "adaptream", "ASTstream", "astsreen", "astschannel"], "vstream": ["hview", "vvchannel", " vStream", "lvstream", "hstream", "vdraft", "svcloud", "svview", "svStream", "vream", "lvdraft", "vpsw", "svchannel", "vpcoll", "avStream", " vchannel", "VStream", " vcoll", "avstream", "avchannel", " vream", "svprogress", "vvprogress", "Vfile", " vfile", "Vstream", "vprogress", "vchannel", "vfile", "vpcloud", "svsw", "vcloud", "svcoll", "lvchannel", " vsw", "vStream", "svfile", "svream", "hprogress", "vpstream", "hchannel", "vcoll", "vvview", "Vream", "vvstream", "vsw", " vcloud", "svstream", "avdraft", "lvStream", "vview", " vdraft"], "ioc": ["iOC", "iniog", "tiog", "iniocl", "iic", "xioci", "tioc", "piOC", " iisc", "piic", "atiroc", "inog", " iOC", "inOC", "tiocl", "antioci", "iisc", "tioci", "piog", "pioc", "antioc", " iic", "xiroc", "ioci", "inoc", "antiocl", "uroc", "tiOC", "xioc", "atiog", "uoc", "xiocl", "iocl", " iog", "tiisc", "inic", "iniroc", "inioc", "atiocl", "iog", "antiroc", "tiroc", "uoci", "piisc", "atioc", "pioci", " ioci", "uocl", "iroc"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "si", "n", "zi", "adi", "key", "m", "xi", "info", "id", "b", "ini", "d", "uli", "c", "p", "ix", "uri", "e", "mu", "eni", "f", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "phi", "mi", "abi", "inner", "qi", "chi", "pi", "part", "ii", "u", "I", "li", "pos", "ip", "ci", "ni", "y", "ri", "fi", "iu"], "buffer": ["uf", "uffer", "channel", "byte", "Buffer", "reference", "bb", "base", "timeout", "comment", "source", "window", "prefix", "bar", "b", "paste", "buf", "data", "block", "fb", "batch", "server", "reader", "stack", "texture", "fp", "queue", "request", "feed", "iter", "memory", "seek", "frame", "table", "bc", "padding", "binary", "append", "slice", "shape", "pause", "FFER", "wave", "input", "raw", "phrase", "document", "address", "repeat", "audio", "position", "read", "bytes", "layer", "message", "loop", "header", "null", "url", "length", "bin", "buff", "cache", "text", "seed", "transfer"]}}
{"project": "qemu", "commit_id": "2e2aa31674444b61e79536a90d63a90572e695c8", "target": 0, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n\n        ret = msi_init(dev, 0, 1, true, false, &err);\n\n        /* Any error other than -ENOTSUP(board's MSI support is broken)\n\n         * is a programming error */\n\n        assert(!ret || ret == -ENOTSUP);\n\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n\n            /* Can't satisfy user's explicit msi=on request, fail */\n\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n\n                    \"msi=off with this machine type.\\n\");\n\n            error_propagate(errp, err);\n\n            s->msi_in_use = false;\n\n            return;\n\n        } else if (ret) {\n\n            /* With msi=auto, we fall back to MSI off silently */\n\n            error_free(err);\n\n            s->msi_in_use = false;\n\n        } else {\n\n            s->msi_in_use = true;\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 9038, "substitutes": {"dev": ["diff", "conf", "gu", "devices", "dim", "gd", "di", "cam", "valid", "DC", "debug", "ds", "img", "dom", "g", "comment", "prof", "Dev", "w", "info", "conn", "def", "die", "prom", "dem", "development", "ver", "de", "var", "data", "ad", "config", "p", "serv", "block", "pro", "driver", "reg", "bug", "rad", "serial", "hw", "f", "ev", "device", "vol", "v", "google", "home", "md", "req", "loader", "mod", "user", "ga", "dd", "dc", "error", "spec", "dm", "grad", "self", "od", "engine", "ch", "DEV"], "errp": ["erf", "erp", "rfp", "erb", " errP", "errorf", "rr", "rp", "errorp", "errorb", "errP", " errb", "errf", "erP", " errf", " errfp", "erfp", "errb", " errr", "rP", "errr", "errfp", "errorr"], "d": ["gd", "dh", "ds", "g", " dd", "w", "m", "dt", "t", "b", "i", "c", "ad", "data", "p", "cd", "e", "driver", "pd", "f", "db", "v", "dd", "dc", "sd", "dm", "Ds", "D"], "s": ["l", "sp", "session", "is", "m", "http", "t", "x", "gs", "parts", "sk", "device", "v", "ns", "details", "com", "spec", "self", "params", "settings", "sg", "ds", "si", "your", "sf", "b", "i", "serv", "c", "addr", "e", "app", "se", "args", "sq", "us", "f", "sym", "sets", "es", "r", "this", "comments", "ps", "su", "fs", "site", "ss", "secure", "sv", "g", "stats", "ls", "status", "os", "cs", "o", "sync", "south", "sl", "native", "sb", "sys", "side", "ssl", "conf", "ts", "service", "p", "server", "tests", "rs", "js", "an", "aws", "S", "services", "sd", "less", "options", "ses", "y"], "err": ["cr", "acer", "conf", "ler", "arr", " er", "str", "arm", "ry", "g", "die", "fr", "mr", "rr", "kr", "gr", "ver", "irm", "p", "ref", "Error", "e", "iter", "ir", "bug", "rs", "lr", "er", "dr", "res", "msg", "ind", "ner", "ar", "r", "req", "error", " error", "re", "sys", "der", "eor", "result", "rev", "Er", "sr", "resp", "br", "rh", "fi"], "ret": ["valid", "flag", "len", "val", "ry", "alt", "fail", "_", "nt", "Ret", "prot", "t", "x", " Ret", "num", "ver", "pat", "red", "reply", "ref", "lit", "reg", "rets", "f", "ut", "j", "code", "rt", "res", "al", "det", "rc", " arg", "sil", "att", "r", "ben", "en", "part", "art", "error", "re", "cat", "et", "RET", " RET", "result", "rev", "match", "ft", "mt", "success"]}}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    int i;\n\n    GICState *s = KVM_ARM_GIC(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n\n\n\n    kgc->parent_realize(dev, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    i = s->num_irq - GIC_INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n", "idx": 9039, "substitutes": {"dev": ["diff", "conf", "gu", "gd", "di", "cam", "debug", "ds", "tr", "dom", "test", "Dev", "w", "conn", "info", "def", "prom", "temp", "die", "development", "dem", "d", "ver", "de", "data", "ad", "p", "pro", "driver", "rad", "serial", "priv", "hw", "mode", "ev", "device", "md", "req", "mod", "bus", "spec", "dm", "grad", "self", "der", "ch"], "errp": ["erp", "corpc", "rrpc", "rrlp", "rrc", "erpi", "corP", " errpi", "erlp", "erc", " errc", "rrp", "errP", "errpc", "erP", "Erpi", "err", "erpc", "corlp", "errlp", "Erp", "errc", "errpi", "rrP", "Erc", "Erpc", "corp", "ErP", " errr", "Err", "errr"], "i": ["oi", "l", "hi", "ui", "di", "it", "start", "si", "n", "in", "zi", "adi", "m", "xi", "id", "info", "k", "t", "ini", "z", "x", "ami", "d", "b", "c", "p", "ix", "uri", "e", "yi", "mu", "mini", "eni", "f", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "mi", "phi", "udi", "abi", "qi", "pi", "bi", "ii", "init", "u", "I", "li", "ip", "ci", "a", "io", "ni", "lc", "y", "ri", "fi", "iu", "anti"], "s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "sk", "none", "v", "state", "ns", "spec", "self", "settings", "sg", "ds", "n", "si", "w", "b", "k", "c", "e", "args", "us", "f", "j", "sym", "es", "r", "as", "u", "this", "ps", "su", "site", "fs", "ss", "sh", "ks", "sv", "g", "d", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "a", "ssl", "ts", "service", "p", "server", "qs", "xs", "js", "rs", "S", "services", "sd", "less", "h", "ses", "y"], "sbd": ["wsBD", "csbd", " sbt", "psBD", " sdb", "csmd", " sbot", "wsbot", "sdb", "psdb", " sfd", "wsdb", "asbd", " sld", "sgd", "sld", " sgd", "wsbd", " sBD", "csBD", "Sbt", " smd", "psfd", "wsmd", "wsfd", "sfd", "Sbd", " sda", "wsld", "csfd", "sBD", "sda", "Sda", "asld", "asbot", "psbd", "smd", "asBD", "sbt", "sbot", "Sgd"], "kgc": [" gccl", "ggl", "pkgc", "kgl", " gccc", "dkc", "pkgb", " gcccc", "ggb", "kgd", "kgpc", "skl", "pkgd", "dkcc", " gccpc", "ggd", "kgb", "skd", "pkgpc", "pkgl", "dkpc", "kgcc", "dkl", "pkgcc", "ggc", "skb", "skc"]}}
{"project": "FFmpeg", "commit_id": "ebea370dc3909aa182bae4c728b83516a904beca", "target": 0, "func": "static int write_fragments(struct Tracks *tracks, int start_index,\n\n                           AVIOContext *in)\n\n{\n\n    char dirname[100], filename[500];\n\n    int i, j;\n\n\n\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n\n        struct Track *track = tracks->tracks[i];\n\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n\n        mkdir(dirname, 0777);\n\n        for (j = 0; j < track->chunks; j++) {\n\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n\n                     dirname, type, track->offsets[j].time);\n\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n\n            write_fragment(filename, in);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9047, "substitutes": {"tracks": ["tags", "setup", "styles", "tones", "music", "ks", "plays", "clips", "frames", "rows", "features", "roots", "cases", "links", "mods", "shows", "fields", "files", "path", "pps", "flows", "archives", "metadata", "history", "reads", "forms", "steps", "tests", "xml", "reports", "runs", "xs", "rs", " Tracks", "errors", "grades", "plugins", "cs", "checks", "notes", "acks", "services", "effects", "projects", "groups", "hops", "thumbnails", "tracking", "docs", "videos", "times", "settings", "events"], "start_index": ["work_Index", " start_initial", "start_initial", "start_Index", "start_address", "work_address", "start_offset", "work_index", " start_offset"], "in": ["str", "g", "n", "source", "In", "again", "conn", "m", "src", "b", "t", "inn", "ini", "login", "con", "c", "gin", "config", "reader", "stack", "ins", "socket", "f", "ac", "resource", "inc", "input", "connection", "min", "ic", "r", "ctx", "buffer", "read", "impl", "ci", "out", "image", "bin", "fc", "a", "url", "IN", "nin", "lin", "exec"], "dirname": ["fileName", "filenames", " directorysize", "foldernam", "folderpath", "dirsize", "pathsize", "directoryName", "dirdir", "directionsize", "dirnum", "pathstart", " dirsize", "directoryname", "dirName", "pathname", "directionname", "directorynam", "pathnum", "directoryfile", "filenam", "directorypath", " dirnames", " dirpath", "dirnames", "dirpath", "foldername", "directionsync", "folderName", "dirsync", "directionstart", "directorynames", "directorysize", "dirstart", "filepath", " dirsync", "dirfile", " dirdir", "directiondir", " directoryname", "directorystart", "pathsync", "directorynum", "directionnum", "dirnam", "pathdir", " dirfile", " directoryfile"], "filename": ["download", "il", "ename", "sheet", "prefix", "sf", "word", "json", "sql", "mpeg", "fd", "path", "wb", "lvl", "metadata", "rl", "output", "username", "lace", "uri", "fp", "txt", "final", "title", "Filename", "f", "nm", "binary", "bj", "database", "journal", "nil", "name", "folder", "phrase", "jpg", "document", "token", "dll", "summary", "fn", "fax", "file", "url", "length", "directory", "write", "jl", "buffer", "println", "kl"], "i": ["oi", "l", "ui", "di", "it", "is", "n", "si", "start", "zi", "adi", "id", "xi", "m", "b", "x", "k", "ami", "z", "ini", "d", "c", "ji", "p", "ix", "e", "yi", "eni", "f", "ie", "ai", "o", "index", "v", "name", "ind", "gi", "ti", "mi", "r", "qi", "bi", "pi", "ii", "u", "h", "I", "li", "ip", "ci", "ori", "ni", "io", "y", "ri", "fi", "iu", "ki"], "j": ["l", "ld", "je", "adj", "n", "g", "key", "m", "xi", "fr", "jet", "k", "b", "dj", "z", "t", "x", "jen", "job", "ji", "c", "p", "jo", "obj", "e", "el", "arg", "jam", "kj", "js", "f", "ie", "uj", "o", "v", "jit", "ind", "r", "jump", "req", "ij", "jp", "ii", "ja", "u", "aj", "h", "oj", "li", "ci", "J", "y", "rev", "jc", "jl", "jj", "br"], "track": ["round", "play", "rank", "sound", "field", "ack", "scale", "tr", "test", "record", "note", "trial", "date", "stage", "tag", "song", "task", "path", "project", "rec", "metadata", "rule", "time", "work", "skip", "seek", "gro", "coll", "group", "step", "mode", "call", "progress", "trace", "index", "name", "event", "order", "ride", "jump", "artist", "trip", "token", "Track", "sort", "audio", "check", "grade", "tm", "pair", "layer", "transform", "rack", "tracking", "gap", "complete", "match", "toggle"], "type": ["len", "source", "key", "date", "id", "info", "t", "path", "Type", "block", "rule", "time", "data", "p", "target", "attr", "rel", "value", "number", "style", "types", "label", "code", "dir", "version", "format", "name", "ty", "sort", "TYPE", "link", "single", "year", "file", "url", "length", "y", "ype", "typ"]}}
{"project": "qemu", "commit_id": "31783203c3b74c11015b20194d57dada559940cf", "target": 0, "func": "char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n", "idx": 9049, "substitutes": {"type": ["parent", "pretty", "base", "start", "ext", "class", "key", "info", "id", "like", "t", "path", "var", "Type", "block", "ct", "time", "p", "style", "off", "types", "code", "dir", "call", "size", "py", "format", "event", "pre", "port", "part", "TYPE", "link", "pos", "file", "url", "y", "ype", "typ"], "name": ["parent", "NAME", "base", "up", "start", "n", "ext", "str", "prefix", "key", "word", "nice", "info", "no", "id", "all", "missing", "path", "x", "filename", "num", "data", "other", "time", "names", "package", "none", "label", "code", "call", "dir", "named", "size", "non", "o", "version", "space", "connection", "home", "address", "old", "new", "part", "self", "file", "ame", "common", "null", "url", "image", "a", "Name", "one"], "len": ["count", "l", "lp", "seq", "ler", "base", "lf", "le", "str", "n", "val", "lim", "fd", "data", "line", " pos", "el", "ls", "lit", "loc", "ie", "la", "dl", "fl", " length", "size", "ll", "sl", "fun", "en", "err", "elt", "offset", "fin", "li", "pos", "lon", "url", "length", "Len", " lang", "lc", "vec", "ln", "dy"], "subdir": ["subDIR", "secdir", "secDIR", " subfolder", "subcoll", "ubcoll", "Suburi", "ubdirectory", " subcoll", "newdir", "Subdirectory", "regfolder", "Subcoll", "Subdirection", "secdirectory", "ubDir", "ubdir", " suburi", " subDir", " subDIR", "newdirection", "newDIR", "subdirection", " subdirectory", " subdirection", "SubDir", "ubdirection", "Subfolder", "subfolder", "uburi", "Subdir", "secdirection", "suburi", "regdirection", "newdirectory", "subdirectory", "regdirectory", "SubDIR", "subDir", "regdir"], "buf": ["bag", "uf", "seq", "Buffer", "base", "str", "ff", "val", "fd", "path", "b", "ab", "wb", "pool", "doc", "data", "block", "fb", "config", "ref", "addr", "bd", "cb", "fp", "queue", "feed", "cf", "rb", "loc", "ptr", "bc", "f", "la", "db", "alloc", "cv", "msg", "cap", "fam", "rc", "bg", "bh", "bed", "cas", "raw", "cur", "fun", "abi", "ctx", "r", "bytes", "null", "url", "result", "text", "buff", "func", "cmd", "vec", "br", "buffer", "bin", "box", "uc", "runner"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_flush(void)\n\n{\n\n}\n", "idx": 9055, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n", "idx": 9067, "substitutes": {"opaque": ["opacity", "opac", "Opaque", "ipsa", " opops", " opsa", "operacity", " opac", "appacity", "ipcs", "ipops", "opcs", " opaques", " opacity", "ipaque", " opcs", "opops", "opsa", "Opops", "appac", "Opsa", "operaque", "opaques", "operaques", "operac", "appaques", "appaque", "Opcs"], "addr": ["Address", "arr", "byte", "base", "arm", "len", "ord", "pad", "src", "x", "pointer", "ad", "data", "ace", "ada", "ptr", "args", "arity", "oa", "cap", "address", "nr", "part", "asm", "type", "pos"], "size": ["timeout", "len", "capacity", "class", "small", "SIZE", "data", "from", "or", "args", "empty", "Size", "large", "unit", " length", "shape", "name", "address", "desc", "bytes", "type", "length", " sizes", "ize", " Size"], "s": ["session", "ts", "ks", "is", "si", "g", "rows", "in", "m", "instance", "ops", "i", "service", "c", "gs", "p", "ls", "e", "qs", "request", "args", "sq", "rs", "socket", "slave", "outs", "cs", "S", "es", "sync", "ubs", "states", "services", "r", "als", "ans", "ns", "hs", "rates", "ips", "params", "ses", "ps", "ss", "ows", "ssl"]}}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9072, "substitutes": {"bs": ["vs", "ts", "bb", "ds", "src", "b", "gs", "iss", "ls", "pb", "qs", "cb", "gb", "ins", "bits", "rb", "outs", "rs", "js", "BS", "bc", "os", "cs", "bl", "es", "sync", "bh", "fps", "bis", "ns", "sb", "blocks", "ms", "ps", "fs", "ses", "css", "ss", "bos"], "res": ["vals", "des", "arr", "rem", "Res", "nos", "val", "RS", "def", "RES", "resolution", "gr", "ress", "obj", "ros", "reg", "pers", "Rs", "rss", "args", "rs", "js", "cs", "pres", "ras", "rc", "response", "r", "req", "err", "results", "details", "spec", "rus", "ms", "re", "sys", "ons", "params", "rez", "ps", "ret", "result", "rev", "ch", "resp", "rh", "ex"], "refcount_table": ["refcompPtype", "refcountttype", "refcomp_type", "refcountstab", "refcache2cache", "refcompPmap", "refcountslist", "refcountPtable", "refcomp_table", "refcache_table", "refcountscache", "refcount_list", "refcount2list", "refcount_cache", "refcompPtable", "refcount2table", "refcache_list", "refcompPcache", "refcountPcache", "refcounttcache", "refcount2tab", "refcomp_map", "refcache_tab", "refcountstable", "refcache2list", "refcountsmap", "refcomp_cache", "refcache2tab", "refcounttmap", "refcount_map", "refcount2cache", "refcountPmap", "refcountttable", "refcountPtype", "refcount_tab", "refcountstype", "refcount_type", "refcache_cache", "refcache2table"], "refcount_table_size": ["refcount_cache_scale", "refcount_cache_small", "refcount_table2small", "refcount_tab_num", "refcount_table2num", "refcount_cache_size", "refcount_tab_small", "refcount_table_small", "refcount_tab_size", "refcount_table2size", "refcount_table_num", "refcount_table_scale"], "offset": ["alias", "element", "location", "reference", "ui", "base", "optional", "initial", "prefix", "origin", "shift", "pointer", "i", "slot", "limit", "ref", "addr", "adjust", "p", "iterator", "set", "starting", "off", "loc", "activity", "padding", "next", "entry", "zero", "slice", "index", "edge", "align", "end", "address", "first", "part", "position", "error", "tail", "online", "pos", "gap", "length", "Offset", "transfer", "reset"], "size": ["count", "needed", "score", "timeout", "scale", "n", "len", "capacity", "small", "ey", "SIZE", "send", "shift", "c", "max", "e", "ish", "se", "set", "loc", "empty", "Size", "sec", "code", "cs", "unit", "sync", "name", "six", "sized", "end", "address", "storage", "form", "cm", "ci", "length", "cache", "use", "ize", "sc", "range", "fee"], "s": ["l", "ts", "ds", "is", "g", "si", "its", "stats", "http", "b", "t", "d", "gs", "sa", "c", "i", "p", "ls", "e", "qs", "se", "outs", "rs", "sq", "js", "os", "f", "args", "cs", "sym", "o", "sets", "S", "es", "sync", "south", "states", "sl", "state", "services", "r", "sb", "ns", "spec", "less", "sys", "ions", "ses", "ps", "site", "a", "ss", "settings", "ssl"], "start": ["count", "base", "scale", "started", "info", "id", "open", "shift", "ad", "from", "max", "work", "ace", "se", "ish", "set", "skip", "before", "starting", "off", "stop", "step", "st", "Start", "next", "ie", "index", "min", "ind", "state", "cur", "end", "address", "first", "part", "art", "check", "error", "get", "grade", "init", "type", "pos", "back", "range"], "last": ["parent", "count", "needed", "later", "base", "est", "Last", "low", "total", "latest", "from", "max", "prev", "close", "p", "se", "before", "final", "loc", "empty", "st", "next", "j", "scope", "nd", "end", "cur", "old", "full", "first", "ending", "after", "ast", "cycle", "use", "length", "so", "since", "range"], "cluster_offset": ["cluster__off", "clust_size", "clructure_size", "cluster67offset", "clandra_prefix", "cluster_entry", "clructure_offset", "clust_offset", "cluster_off", "cluster_prefix", "clance_address", "clance67offset", "clusterPoff", "clust_option", "clust_pos", "cluster67size", "cluster8offset", "clructure_index", "clructure_limit", "cluster_object", "clance_offset", "cluster67off", "cluster_position", "cluster8route", "cluster8address", "clance67limit", "cluster_option", "cluster67limit", "cluster_error", "cluster__offset", "clandra_offset", "clandra_size", "cluster_address", "cluster_start", "cluster_size", "clusterPaddress", "clance_route", "cluster8off", "clust_optional", "clance67off", "clandra_error", "clust_entry", "cluster_index", "cluster_optional", "clance_off", "clust_position", "clancePaddress", "clust_start", "cluster_route", "clusterPoffset", "clance_size", "clusterProute", "clance67size", "cluster_pos", "clancePoffset", "cluster_limit", "clanceProute", "cluster__route", "clancePoff", "clance_limit", "cluster__address", "clust_object"], "k": ["count", "ek", "ku", "ks", "n", "g", "key", "w", "id", "x", "b", "d", "i", "c", "max", "p", "work", "ka", "e", "number", "q", "kat", "f", "sk", "ak", "j", "o", "kid", "ck", "ky", "ik", "r", "end", "ki", "kn", "ask", "K", "uk", "ko", "unk", "ke", "kw", "u", "length", "y", "ch", "kick", "ok", "kk", "range"], "check_errors": ["update__results", "update__errors", "update_error", "check_error", "update__dates", "update__error", "check__dates", "check__results", "check__error", "check_results", "update_dates", "update_results", "check__errors", "update_errors", "check_dates"], "corruptions": ["disruptances", "corregients", "corrictients", "coremptes", "disruptes", "disrictients", "disrictances", "disruptions", "coremptients", "corrictances", "corruptances", "corregions", "correges", "corregances", "corrictes", "coremptances", "disrictes", "disruptients", "disrictions", "coremptions", "corrictions", "corruptes", "corruptients"]}}
{"project": "qemu", "commit_id": "f140e3000371e67ff4e00df3213e2d576d9c91be", "target": 1, "func": "static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n", "idx": 9087, "substitutes": {"bs": ["ib", "base", "bb", "ds", "is", "lbs", "cases", "bid", "bas", "b", "gs", "iss", "fb", "s", "ls", "pb", "gb", "ins", "rb", "rs", "js", "BS", "bc", "us", "os", "cs", "db", "ubs", "bh", "lb", "bis", "bi", "ns", "sb", "blocks", "cms", "ses", "fs", "ps", "css", "ob", "ss", "bes", "bos"], "request": ["parent", "enter", "access", "worker", "record", "http", "require", "claim", "config", "xml", "condition", "frame", "call", "response", "object", "get", "type", "form", "buffer", "reference", "rate", "save", "view", "instance", "demand", "create", "post", "input", "current", "callback", "load", "friend", "list", "read", "pair", "complete", "insert", "hello", "transfer", "ru", "Request", "initial", "method", "model", "head", "resource", "order", "subject", "query", "req", "ready", "command", "report", "message", "use", "press", "QUEST", "accept", "info", "server", "queue", "q", "push", "next", "quest", "child", "requ", "route", "name", "event", "apply", "user", "begin"], "qiov": ["Qiov", "qivo", "questiol", " qrolet", "quodi", "sqiev", "vilib", "quiov", "Q\u00ef", "qiol", "qiii", "qio", " qiii", "quio", "q\u00ef", "sqiov", "quiol", "quicho", " qicho", "sqilo", "quiii", " qiop", "sqicho", "quilib", "quilo", " qilo", "quivo", "questio", "questliv", " qliv", "Qrolet", "quiev", "viev", "qicho", "quliv", "questiov", " qio", "viov", "vicho", "qiev", "niov", "qliv", "qurolet", "qu\u00ef", "sqiop", "sqivo", "niii", "Qilo", "sqilib", " qiol", "nliv", "qilo", " q\u00ef", "sqodi", "quiop", "qilib", "qiop", "nrolet", "qrolet", " qivo", " qodi", "qodi"], "client": ["man", "session", "connect", "conn", "http", "public", "bridge", "Client", "service", "con", "config", "server", "uri", "cli", "q", "socket", "manager", "resource", "child", "connection", "google", "proxy", "bird", "circ", "pc", "admin", "web", "plugin", "handler", "cm", "sim", "api", "clean", "url", "cache", "cell"], "ret": ["count", "pass", "flag", "ext", "len", "val", "ry", "alt", "test", "fail", "_", "nt", "conn", "Ret", "num", "mem", "ver", "job", "reply", "ref", "arg", "obj", "lit", "run", "reg", "iter", "rb", "rets", "tmp", "f", "code", "rt", "res", "bf", "rc", "order", "fun", "req", "att", "r", "en", "err", "part", "art", "rep", "error", "read", "get", "cat", "re", "RET", "back", "complete", "result", "mt", "Len", "resp", "rev", "sr", "success", "pet"]}}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091, "substitutes": {"ctx": ["gd", "context", "cci", "cmp", "Context", "cca", "conn", "tc", "src", "que", "sci", "c", "cp", "config", "obj", "cu", "cli", "fp", "qa", "uci", "cf", "cb", "cn", "xs", "loc", "sq", "hw", "bc", "cs", "ctr", "cv", "scope", "sync", "rc", "connection", "cas", "voc", "req", "conv", "ga", "tx", "jp", "nas", "pc", "xc", "kw", "gru", "nc", "cfg", "ca", "cm", "rx", "ci", "vc", "anc", "cmd", "jc", "pkg", "lc", "cus", "kb", "exec"], "insn": ["rissn", "isinc", " insnl", "outsn", "insnt", "insN", "asp", "asn", "inne", "risn", " insns", "incb", "atsnl", "inn", "vinc", "outsnt", "risne", "isinnt", "linsner", "innt", "insc", "insns", "innl", "inp", "insne", "inc", "atsN", "insnl", "outsc", " insp", "incp", "inner", "linsne", "isinn", "outssn", "vinn", "insb", "inN", "asns", "atsp", "vinp", "linssn", " insN", "atsc", "incns", "asb", "incn", "inssn", "insp", "linsn", "atsn", "insner", "vinN", " insb", "isinsn", "risner"], "di": ["ani", "gu", "ui", "Di", "ds", "si", "adi", "zi", "da", "xi", "ini", "iri", "i", "DI", "uri", "cli", "uci", "du", "oci", "tti", "ai", "dat", "db", "gi", "ti", "mi", "ei", "vd", "bi", "pi", "dc", "andi", "ii", "idi", "cfg", "ci", "ni", "ri", "ki"], "tcg_r1": ["tcg_sr2", "tcg_rb", "tcg_m2", "tcg_srv", "tcg_lr2", "tcg_g0", "tcg_m1", "tcg_rv", "tcg_srb", "tcg_m0", "tcg_sr1", "tcg_R2", "tcg_r0", "tcg_lr0", "tcg_lr1", "tcg_R0", "tcg_lr11", "tcg_R1", "tcg_g2", "tcg_Rv", "tcg_g11", "tcg_Rb", "tcg_r11", "tcg_g1", "tcg_R11"], "tcg_r2": ["tcg_sr2", "tcg_rb", "tcg_rr2", "tcg_sr8", "tcg_hr2", "tcg_R82", "tcg_erb", "tcg_r82", "tcg_rr02", "tcg_sr82", "tcg_sr1", "tcg_R2", "tcg_hr8", "tcg_r02", "tcg_er1", "tcg_R1", "tcg_r8", "tcg_rr1", "tcg_hr82", "tcg_er2", "tcg_Rb", "tcg_R8", "tcg_R02", "tcg_hr1", "tcg_r4", "tcg_er4", "tcg_R4"], "ret": ["base", "tr", "alt", "val", "ry", "len", "def", "nt", "temp", "Ret", "ait", " Ret", "mem", "rec", "reply", "ref", "obj", "lit", "status", "reg", "rel", "final", "gt", "rets", "ut", "rt", "res", "bf", "det", "rc", "fun", "re", "gc", "sys", "RET", "cat", " RET", "result", "rev", "match", "ft", "resp", "mt", "fi", "success"]}}
{"project": "FFmpeg", "commit_id": "f27b22b4974c740f4c7b4140a793cac196179266", "target": 0, "func": "static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,\n\n                                            uint8_t *src_cb, uint8_t *src_cr,\n\n                                            int linesize, int uvlinesize,\n\n                                            int xchg, int chroma444,\n\n                                            int simple, int pixel_shift)\n\n{\n\n    int deblock_topleft;\n\n    int deblock_top;\n\n    int top_idx = 1;\n\n    uint8_t *top_border_m1;\n\n    uint8_t *top_border;\n\n\n\n    if (!simple && FRAME_MBAFF(h)) {\n\n        if (h->mb_y & 1) {\n\n            if (!MB_MBAFF(h))\n\n                return;\n\n        } else {\n\n            top_idx = MB_MBAFF(h) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    if (h->deblocking_filter == 2) {\n\n        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;\n\n        deblock_top     = h->top_type;\n\n    } else {\n\n        deblock_topleft = (h->mb_x > 0);\n\n        deblock_top     = (h->mb_y > !!MB_FIELD(h));\n\n    }\n\n\n\n    src_y  -= linesize   + 1 + pixel_shift;\n\n    src_cb -= uvlinesize + 1 + pixel_shift;\n\n    src_cr -= uvlinesize + 1 + pixel_shift;\n\n\n\n    top_border_m1 = h->top_borders[top_idx][h->mb_x - 1];\n\n    top_border    = h->top_borders[top_idx][h->mb_x];\n\n\n\n#define XCHG(a, b, xchg)                        \\\n\n    if (pixel_shift) {                          \\\n\n        if (xchg) {                             \\\n\n            AV_SWAP64(b + 0, a + 0);            \\\n\n            AV_SWAP64(b + 8, a + 8);            \\\n\n        } else {                                \\\n\n            AV_COPY128(b, a);                   \\\n\n        }                                       \\\n\n    } else if (xchg)                            \\\n\n        AV_SWAP64(b, a);                        \\\n\n    else                                        \\\n\n        AV_COPY64(b, a);\n\n\n\n    if (deblock_top) {\n\n        if (deblock_topleft) {\n\n            XCHG(top_border_m1 + (8 << pixel_shift),\n\n                 src_y - (7 << pixel_shift), 1);\n\n        }\n\n        XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);\n\n        XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);\n\n        if (h->mb_x + 1 < h->mb_width) {\n\n            XCHG(h->top_borders[top_idx][h->mb_x + 1],\n\n                 src_y + (17 << pixel_shift), 1);\n\n        }\n\n    }\n\n    if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n        if (chroma444) {\n\n            if (deblock_topleft) {\n\n                XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n            }\n\n            XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n\n            XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n\n            if (h->mb_x + 1 < h->mb_width) {\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n\n            }\n\n        } else {\n\n            if (deblock_top) {\n\n                if (deblock_topleft) {\n\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n                }\n\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9094, "substitutes": {"h": ["l", "hi", "sh", "he", "ht", "dh", "context", "n", "g", "ph", "hr", "hh", "w", "m", "http", "t", "b", "x", "z", "d", "history", "c", "adh", "s", "work", "p", "hm", "e", "help", "gh", "eh", "q", "hw", "f", "host", "o", "ha", "th", "v", "ih", "bh", "home", "r", "ctx", "hp", "him", "hash", "hs", "oh", "hd", "this", "u", "H", "hist", "hl", "header", "image", "ah", "ch", "rh", "uh"], "src_y": ["src_py", "src_dy", "srcPys", " src_vy", "src_vy", "src_m", " src_dy", "src_ys", " src_ys", " src_m", "srcPdy", "srcPy", " src_py", "srcPpy"], "src_cb": ["src\u00b7cb", "src_crop", " src_fb", "src67cb", " src_buf", "src\u00b7rb", "src_buf", "src_fb", "src67fb", "src_rb", "src\u00b7crop", "src67buf", " src_wb", " src_rb", "src\u00b7wb", " src_crop", "src67rb", "src_wb"], "src_cr": ["source_cr", "src_rb", "src_cat", "src_sr", "source_cp", "src_cp", "source_sr", " src_rb", " src_cat", "source_rb"], "linesize": ["linesization", "linsiz", " linesized", " linesizes", "linesiz", "ipsization", "linesizes", "lightssize", "pagesize", "linsize", "ipsize", "linesized", "linsization", "lightsization", "pagesiz", "ipsized", "linessize", "linsizes", " linesization", "lightsize", " linessize", "pagesizes", "pagesization", "ipssize", "lightsized", " linesiz"], "uvlinesize": ["nvblocksizing", "uvlinksized", "nvinsizing", "nvlinesizer", "uvlineIZE", "uvpagesization", "nvlinesizes", "uvpagesize", "uvlineizer", "nvblocksizes", "uvpagesized", "uvlinksizer", "uvlesizer", "ovlinksized", "uvlineize", "nvinsIZE", "ovlinesize", "uvlinkspace", "uvlinsized", "uvlinesizing", "uvblocksizing", "ovlinksizer", "nvlinesIZE", "uvlinesized", "ovlinesizer", "uvblocksize", "uvblocksization", "uvlinesizes", "ovlinespace", "uvlinesIZE", "ovlinkspace", "nvlinesize", "uvpagesizes", "uvlesize", "uvpagesizing", "uvlineization", "uvlinksize", "uvinsizer", "uvlinesizer", "ovlinesized", "uvpagesizer", "uvinsIZE", "nvlinesizing", "nvlinesization", "ovlinksize", "uvlineizes", "uvlinsize", "uvlinspace", "nvblocksization", "uvlesizing", "uvpagespace", "uvlinsizer", "nvinsizer", "uvinsize", "nvinsize", "nvblocksize", "uvlineizing", "uvlinesization", "uvlesIZE", "uvlinespace", "uvblocksizes", "uvinsizing"], "xchg": ["xarchrg", " xChga", " xchga", "xarchm", "xChga", "xchgc", "xachg", "xachgc", " xChg", "xachrg", "xchega", "xChgs", " xachm", "xcheg", "xarchgc", "xichgen", "xachm", "xChgen", " xChgs", "xichga", "xchga", "xchgen", " xchm", "xchgs", "xarchg", "xschg", "xschrg", "xchegs", " xachgc", " xchgs", "xichgs", " xchgc", "xichg", "xChg", "xschm", " xchgen", " xachg", "xchm", "xschgc", " xachrg", "xchegen", " xChgen", " xchrg", "xchrg"], "chroma444": ["chroma1", "aquea144", "aqua444", "aquca144", "aqua44", "aquea444", "chromea44", "aquca1", "aqua1", "aquca44", "aquaa1", "aquea1", "chromea1", "chroma44", "aquaa444", "chroma144", "chromea444", "aquaa44", "aquea44", "aquca444", "aquaa144", "aqua144", "chromea144"], "simple": ["channel", "active", "normal", "complex", "small", "plain", "material", "basic", "enable", "generic", "util", "local", "Simple", "style", "multiple", "packed", "binary", "label", "parse", "sync", "spin", "classic", "quiet", "little", "repeat", "unique", "custom", "details", "special", "spec", "summary", "less", "sim", "single", "file", "client", "complete", "partial", "broken", "linear"], "pixel_shift": [" pixel_scale", " pixel_offset", "pixel_switch", "pixel2size", "pixel_edge", "pixel2shift", " pixel_low", "pixel_offset", "pixel2scale", " pixel_sleep", "pixel_scale", "pixel2switch", "pixel_low", "pixel_Shift", " pixel_edge", " pixel_size", " pixel_change", "pixel_sleep", "pixel_size", "pixel_change", " pixel_switch", " pixel_Shift"], "deblock_topleft": ["deblock_toplept", "deblock_tollft", "deblock_Toulck", "deblock_Topleck", "deblock_Toplevel", "deblock_popleth", "deblock_stopleft", "deblock_toulft", "deblock_toulvel", "deblock_Toulft", "deblock_stroupt", "deblock_tollth", "deblock_strouft", "deblock_tpleck", "deblock_tollovel", "deblock_stoplept", "deblock_strouvel", "deblock_tplept", "deblock_stopleth", "deblock_tolloft", "deblock_tollock", "deblock_pplevel", "deblock_tOPLEvel", "deblock_stoplevel", "deblock_toplevel", "deblock_trouth", "deblock_tpleft", "deblock_ppleft", "deblock_tpleth", "deblock_popleft", "deblock_Topleft", "deblock_tOPLEft", "deblock_tplevel", "deblock_topleth", "deblock_Toulvel", "deblock_toulck", "deblock_pplept", "deblock_tOPLEpt", "deblock_trouvel", "deblock_strouth", "deblock_poplevel", "deblock_tOPLEth", "deblock_tollpt", "deblock_tolloth", "deblock_troupt", "deblock_tollvel", "deblock_topleck", "deblock_ppleth", "deblock_Topleth", "deblock_toulth", "deblock_trouft", "deblock_Toulth", "deblock_poplept"], "deblock_top": ["debblock_top", "deblock_bottom", "deblock__top", "deblocking_top", "deblock_TOP", "deblock__tops", "debblock_best", "deblock2tops", "deblock2bottom", "deblocking_high", "deblock__bot", "deblock__high", "deblocking_best", "deblock_best", "deblock0TOP", "debblock__top", "deblock2top", "debblock__tops", "deblock2best", "deblock_tops", "deblock0bottom", "deblock_bot", "deblock__TOP", "deblock__best", "deblocking_bot", "deblock_high", "deblocking__TOP", "deblocking_bottom", "deblocking__high", "deblocking__bottom", "debblock__bottom", "debblock__best", "debblock_bottom", "deblock__bottom", "debblock_tops", "deblocking_TOP", "deblock0top", "deblock0high", "deblocking__top"], "top_border_m1": ["top_border_mf", "top_border_t1", "top_border_t2", "top_border_c2", "top_border_M4", "top_border_M2", "top_border_v2", "top_border_M1", "top_border_c4", "top_border_v4", "top_border_cn", "top_border_m2", "top_border_ff", "top_border_v1", "top_border_f1", "top_border_vn", "top_border_f2", "top_border_Mf", "top_border_fn", "top_border_mn", "top_border_Mn", "top_border_m4", "top_border_tf", "top_border_c1", "top_border_tn"], "top_border": ["top_channel", "top_section", "top_extra", "top__conn", " top__extra", " top__section", "top__border", "top_buffer", " top_buffer", "top_margin", "top__extra", " top_conn", "top_conn", "top__section", " top_extra", "top__buffer", "top__channel", "top__margin", " top_margin", " top_channel", " top_section", " top__border", " top__conn"]}}
{"project": "FFmpeg", "commit_id": "c56e71309ec1a585ed4d4dc11ae0ba3ca7d19618", "target": 1, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint8_t *buf, int linesize)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len, height;\n\n    const uint8_t *ptr;\n\n    /* image block */\n\n\n\n    bytestream_put_byte(bytestream, 0x2c);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, avctx->width);\n\n    bytestream_put_le16(bytestream, avctx->height);\n\n    bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    /* no local clut */\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf;\n\n    for (height = avctx->height; height--;) {\n\n        len += ff_lzw_encode(s->lzw, ptr, avctx->width);\n\n        ptr += linesize;\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    bytestream_put_byte(bytestream, 0x3b);\n\n    return 0;\n\n}\n", "idx": 9095, "substitutes": {"avctx": ["afconn", "avcv", "avcmp", "afctx", "afsync", "avsync", "avcc", "ajcmp", "AVcc", "AVqa", "afcmp", "avecmp", "avectx", "afctl", "auctx", "auctl", "AVcmp", "AVcv", " avcmp", "AVcontext", "avconn", "AVsync", "avproc", "ajctx", "ajcontext", "AVctx", "AVconn", "aucmp", " avcontext", "avcontext", " avcv", " avconn", "AVproc", "afcc", "ajproc", " avsync", " avcc", "AVctl", "afqa", "aveconn", "avecontext", "aucontext", "avctl", "afcontext", "aveqa", "avqa", "afcv", "afproc"], "bytestream": [" bygestagram", "byinstbroad", "bytestingorage", "byteenREAM", "bylastream", "byconstreen", "bythisamera", "bycestream", "Byteststream", "BYpastream", "byestREAM", "byserverream", "byvestamera", "byeststream", "viaestream", "Bytestream", " bytestruction", "fortestream", "bygestream", "viainstagram", "BYtestamera", "liketestram", "andcodeair", "BYtestrum", "bytestrum", "byestchannel", "bylastagram", "byveyamera", "liketestruction", " bytestREAM", "viaestrum", "bycodeair", " bygestreen", " bytestamera", "byinstREAM", "bytestair", "bygestamera", "byserveramera", "byestream", " bygestalk", "byinstrum", "byaststream", "andcoderam", "byscriptagram", "fromestrum", "viatestamera", "bytestingruction", "bygestchannel", "byrestream", " bytestalk", "bythisream", "bytestingREAM", "byrestreen", "byvestream", "byinstagram", "BytestREAM", "bygestram", "byserverram", "byestrum", "byconstREAM", "byestorage", "bytrum", "byconstram", "bytestingered", "bytestalk", "bytestingram", "bytram", "viaestagram", "byconstear", "fortestorage", " bytestagram", "viatestallow", "byteenream", "bycoderum", "byestamera", "viatestream", "byestagram", "byteststream", "byestram", "byscriptram", "forestered", "byinstamera", "byestallow", "bytestered", "bytream", "fromtestrum", "Byestream", "bytestallow", " bygestear", "Byestamera", "bycestorage", "fortestrum", "bytruction", "bygestalk", "fromtestREAM", " bygestrom", "bycodeream", "bytestingair", "liketestair", "liketestingream", "bylastbroad", "byterrum", "byestruction", "byteenrom", "bypastream", "bygestair", "viainstream", "BYpastrum", "bygestrum", "bycoderam", "BYpastand", "bycestrum", "BYpastamera", "andtestrum", "bypertram", "Byestram", "viatestrum", "andtestram", "bytestagram", "byterair", "bytestreen", "bygestruction", "bypertair", "bythisallow", " bygestream", "bygestREAM", "bytestchannel", "byscriptalk", "fortestered", "viainstbroad", "bygeststream", "bythisrum", "byterream", "bytestingamera", "bypertream", "bypastrum", "viatestbroad", "byastREAM", "Bytestram", " bygestram", "bytestram", "andcoderum", "bytestand", "andtestream", "forestorage", "liketestingair", "bytestbroad", "viatestagram", "fromestREAM", "viaestallow", "bytestamera", "fromtestchannel", "byconstalk", "bytestREAM", "forestrum", "bygestrom", "bygestreen", " bygestruction", "bytallow", "byconstrom", "bylastamera", "viainstamera", "byvestREAM", "BYtestream", "fromestchannel", "andcodeream", " bygestamera", "ByestREAM", "Byestruction", "bycestered", "fromestream", "bytestrom", "byastream", "byestered", "bytagram", " bytestreen", " bytestear", "bypastamera", "byinstchannel", "byrestREAM", "BYtestand", "Bytestruction", "bytestruction", "byastram", "byteenamera", " bytestrom", "byvestruction", " bygestREAM", "bypastand", "fromtestream", "byterram", "byrestear", "bytamera", "bythisand", "byveyream", "byscriptream", "andtestair", "bygestagram", "Byeststream", "liketestingruction", "forestream", "bythisagram", "byveyagram", " bytestram", "bytestorage", "bytestingand", "liketestingram", "bygestear", "bypertruction", "bytestingream", "byveybroad", "byconstream", "byinstream", "byconstagram", "byserverruction", "bytestingrum", "Bytestamera", "liketestream", "bytestear", "byconstamera"], "end": ["start", "est", "ended", "id", "open", "End", "path", "z", "send", "last", "c", "line", "max", "limit", "e", "set", "env", "stop", "mid", "append", "index", "edge", "address", "en", "begin", "ending", "after", "offset", "enc", "h", "pos", "dev", "length", "use", "END", "range"], "buf": ["bag", "uf", "map", "background", "uu", "seq", "context", "src", "fd", "b", "wb", "mem", "pool", "fi", "data", "block", "fb", "config", "ref", "bu", "pb", "p", "cb", "fp", "queue", "cf", "rb", "loc", "tmp", "prop", "bc", "code", "alloc", "cv", "aux", "cap", "v", "rc", "home", "cas", "ctx", "conv", "raw", "address", "port", "offset", "border", "header", "length", "func", "vec", "buff", "br", "proc", "buffer", "box", "uc"], "linesize": ["linsiz", "codesizing", "linsIZE", "linesiz", "codesizer", "odesize", " linesIZE", "linsizer", "odesizing", "odesIZE", "linesizing", "linsize", "linesIZE", " linesizer", "codesize", " linesizing", "linesizer", "codesIZE", "codesiz", "odesiz", " linesiz"], "s": ["conf", "session", "sg", "ts", "ks", "sv", "ds", "n", "g", "is", "its", "w", "m", "stats", "b", "t", "ops", "d", "i", "gs", "c", "data", "service", "p", "ls", "e", "qs", "ins", "xs", "sq", "js", "rs", "f", "us", "args", "cs", "sym", "aws", "sets", "S", "v", "sync", "es", "services", "ctx", "r", "bis", "ns", "hs", "sb", "spec", "as", "sys", "ions", "ses", "a", "ps", "fs", "uns", "ss", "bs", "ssl"], "len": ["lp", "l", "count", "ld", "ler", "seq", "le", "lf", "span", "n", "val", "fen", "win", "lim", "z", "num", "data", "line", "limit", "el", "lit", "loc", "dl", "code", "fl", "size", "lib", "ll", "cap", "min", "name", "sl", "fun", "zen", "en", "pre", "lt", "elt", "fin", "lang", "den", "hl", "pos", "li", "lon", "url", "length", "bin", "Len", "lc", "lan", "rev", "ln", "dy", "lin"], "height": ["channel", "html", "img", "x", "container", "fw", "thin", "memory", "lat", "step", "duration", "port", "crop", "type", "volume", "row", "image", "definition", "buffer", "depth", "wid", "rank", "dim", "han", "view", "w", "id", "resolution", "density", "i", "layout", "padding", "gy", "ha", "slice", "input", "wall", "huge", "header", "gap", "ady", "hi", "context", "fen", "source", "room", "num", "d", "lvl", "wrap", "bottom", "head", "style", "flow", "hei", "host", "png", "Height", "alpha", "zh", "size", "shape", "kw", "hl", "sid", "weight", "dy", "diff", "level", "wide", "rows", "win", "window", "capacity", "qa", "quality", "dir", "name", "h", "length", "arrow", "y", "direction"], "ptr": ["Ptr", "uf", "sp", "dim", "sh", "lf", "context", "tr", "ext", "start", "str", "pad", "coord", "src", "inter", "fd", "mount", "pointer", "shift", "fi", "addr", "p", "ref", "pb", "dest", "pointers", "fp", "attr", "cb", "pt", "plug", "loc", "rb", "tmp", "push", "slave", "rot", "dr", "inst", "code", "slice", "alloc", "ctr", "trace", "index", "rc", "obj", "cur", "req", "address", "err", "port", "pe", " pointer", "offset", "pend", "pair", "pos", "length", "buff", "proc", "buffer", "fe"]}}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"stbl\");\n\n    mov_write_stsd_tag(pb, track);\n\n    mov_write_stts_tag(pb, track);\n\n    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&\n\n        track->has_keyframes && track->has_keyframes < track->entry)\n\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        track->flags & MOV_TRACK_CTTS && track->entry)\n\n        mov_write_ctts_tag(pb, track);\n\n    mov_write_stsc_tag(pb, track);\n\n    mov_write_stsz_tag(pb, track);\n\n    mov_write_stco_tag(pb, track);\n\n    return update_size(pb, pos);\n\n}\n", "idx": 9101, "substitutes": {"pb": ["lp", "dp", "uf", "ib", "wp", "ppa", "pg", "bb", "nb", "proc", "prof", "bp", "prot", "pl", "lab", "bm", "b", "ab", "wb", "pa", "pp", "pool", "cp", "fb", "p", "pd", "pro", "fp", "np", "txt", "gb", "pt", "cb", "pm", "rb", "tmp", "bc", "vp", "db", "bf", "mp", "fm", "eb", "py", "bps", "bh", "ctx", "lb", "hp", "sth", "tp", "jp", "sb", "pc", "PB", "summary", "cpp", "plugin", "platform", "api", "ob", "mt", "lc", "buff", "xb", "pkg", "um", "uc", "bos", "fc"], "track": ["round", "play", "session", "ack", "tr", "cmp", "record", "word", "tag", "task", "tt", "config", "thread", "skip", "step", "train", "call", "cur", "port", "sort", "patch", "hop", "type", "form", "row", "rank", "sound", "note", "view", "stage", "trial", "post", "work", "seek", "module", "token", "rack", "complete", "lc", "toggle", "tab", "test", "model", "project", "metadata", "tick", "add", "gro", "coll", "mode", "progress", "sync", "order", "roll", "node", "tm", "allow", "report", "press", "follow", "comment", "rr", "run", "trace", "route", "gg", "event", "Track", "audio", "check", "tracking", "transform", "match", "tracks", "rm"]}}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    if (nb_needed > nb_available) {\n\n        nb_needed = nb_available;\n\n    }\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 9106, "substitutes": {"bs": ["vs", "utils", "ts", "ks", "ds", "its", "b", "gs", "sa", "iss", "fb", "ls", "pb", "gb", "ins", "bits", "outs", "js", "rs", "BS", "bc", "os", "banks", "us", "obs", "cs", "db", "plugins", "aws", "bl", "bps", "es", "bh", "lb", "bis", "ns", "sb", "ses", "fs", "ps", "css", "ss", "bes", "bos"], "offset": ["alias", "location", "seq", "timeout", "base", "initial", "start", "len", "alt", "af", "prefix", "conn", "id", "origin", "shift", "pointer", "i", "slot", "limit", "addr", "fp", "set", "number", "off", "loc", "padding", "entry", "alpha", "o", "index", "alloc", "size", "slice", "adjusted", "align", "aware", "aligned", "address", "option", "part", "position", "error", "node", "bit", "type", "online", "pos", "attribute", "url", "length", "fee", "seed", "buffer", "Offset", "range", "reset"], "num": ["count", "dim", "valid", "n", "len", "numbered", "m", "unc", "mult", "lim", "mon", "con", "sum", "batch", "coord", "number", "loc", "nm", "multi", "umi", "inc", "Num", "nom", "norm", "begin", "node", "init", "uni", "fn", "pos", "loop", "nu", "common", "bin", "um", "gen", "om", "nn", "NUM"], "s": ["conf", "session", "ts", "words", "ks", "ds", "is", "si", "g", "n", "your", "its", "stats", "b", "t", "ims", "gs", "sa", "service", "p", "ls", "server", "e", "qs", "ins", "xs", "js", "rs", "sq", "f", "us", "os", "obs", "cs", "sym", "aws", "sets", "S", "es", "sync", "v", "space", "south", "states", "state", "sl", "services", "bis", "sb", "ns", "details", "spec", "sys", "self", "sim", "rates", "ses", "ps", "site", "su", "fs", "ss", "settings", "ssl"], "l1_index": ["l1_lock", "l1xlock", "l61_index", "l51Ftype", "l1xlength", "l11__size", "l1Fnum", "l51Findex", "l1_num", "l1_length", "l51Foffset", "l4_length", "l1xoffset", "l1_ind", "l11_offset", "l1Foffset", "l1_prefix", "l11__bits", "l11_index", "l51Fnum", "l11__offset", "l1__bits", "l1xindex", "l11_bits", "l1__offset", "l4_prefix", "l1Findex", "l1__size", "l51_index", "l61_lock", "l51_num", "l61_ind", "l11_size", "l51_type", "l1_type", "l1Ftype", "l1_offset", "l4_index", "l1_sync", "l1_size", "l61_sync", "l4_offset", "l1__index", "l1xsync", "l1xind", "l51_offset", "l1xprefix", "l11__index"], "l2_index": ["l2amthread", "l2acindex", "l21amindex", "l2__bin", "l21_index", "l21amelement", "l82_loc", "lii_index", "l2foffset", "l10_weight", "l2ampointer", "l10_index", "l2__index", "l82_slot", "l82findex", "l2__size", "l2Dindex", "l2_output", "l21_pointer", "l2Mindex", "l2_loc", "l2acthread", "l6_size", "l2Xelement", "l2_len", "l82floc", "l2fslot", "l2_bin", "l82_offset", "l82foffset", "l2amindex", "l21_element", "l2_pointer", "l82_index", "l2Mweight", "l2Dtable", "l2Doffset", "l2_weight", "l2Xindex", "l2__position", "l2acelement", "l2_slot", "l2Moption", "l82fslot", "l2amelement", "l2floc", "lii_offset", "l2Xpointer", "l10_len", "l6_position", "l2Xthread", "l21_thread", "l6_bin", "l2Mlen", "l21ampointer", "l6_index", "lii_output", "l2_thread", "l2acpointer", "l21amthread", "l2findex", "l2Doutput", "l2_position", "l2_size", "l10_option", "l2_element", "l2_option", "lii_table"], "l2_offset": ["l2Ptable", "ltwo_skip", "l2ferror", "l1_source", "l2acoffset", "l2foffset", "ltwofoffset", "l1_position", "ltwofreset", "ltwofskip", "l2acskip", "l2_tile", "ltwo_error", "ltwo_offset", "l2freset", "l2_skip", "ltwo_reset", "l2Psource", "l2_slot", "l2Poffset", "l2_addr", "l1_location", "l2acreset", "l1_addr", "l1_table", "ltwoferror", "l1_offset", "l2_source", "l2_error", "l1_size", "l2_location", "l2Pindex", "l1_tile", "l2acerror", "l2_reset", "l2_position", "l2_size", "l1_slot", "l2fskip"], "l2_table": ["l2thedatabase", "loneMrequired", "l53Xdatabase", "l53_table", "l2_machine", "l2Dpage", "l1_source", "loneMtable", "lII_union", "l2_page", "l53Xstore", "l6_module", "lIIthebody", "l2_module", "l2alltable", "lIItheunion", "l2xroot", "l2_cache", "l2_root", "lone_table", "l53_database", "l2_body", "l2Mrequired", "l2thebody", "l2Mbody", "l2Xdatabase", "l2xservice", "l02_root", "lIIthetable", "l2Fstore", "l02_service", "lone_body", "l2Xtable", "lII_table", "l2Mcache", "l2Xmachine", "lII_store", "l2rdatabase", "l02_table", "lIIthestore", "l2thestore", "l2Dtable", "l02_page", "l2allmachine", "l6_table", "l2rtable", "l2relement", "l2rmodule", "l2theunion", "l53Xtable", "lII_body", "l53Xmachine", "l6_element", "l2alldatabase", "l2_union", "l1_table", "l2Fdatabase", "l1_cache", "l2theelement", "l1_offset", "l2allstore", "l2thetable", "l2_source", "l2Mtable", "l2xtable", "l2Xstore", "l6_database", "l2xstore", "lone_required", "l2Ftable", "loneMcache", "lone_cache", "l2_required", "l2xbody", "l53_machine", "l2Droot", "l2xpage", "l2xunion", "l2Fmachine", "l2_service", "l2_store", "l2_element", "l53_store", "l2themodule", "l2_database", "loneMbody", "l2Dservice"], "cluster_offset": ["clust_size", "cluster_cache", "clusteracoffset", "cluster2cache", "cluster2offset", "clust_index", "clust_offset", "cluster_off", "closen_slot", "clayeracshift", "clusteracshift", "cluster0slot", "closen2offset", "cluster1optional", "cluster1shift", "clayeracaddress", "clayer_info", "cluster2slot", "cluster_info", "cluster_position", "cluster0offset", "cluster7address", "closen2cache", "clayer_position", "cluster7optional", "cluster2off", "closen_cache", "cluster__offset", "cluster_address", "clayer_off", "cluster_start", "cluster_size", "cluster_shift", "cluster2part", "cluster_part", "cluster__start", "clusteracoptional", "cluster7shift", "closen2part", "cluster_index", "cluster2position", "cluster_optional", "cluster__index", "clust_start", "cluster__size", "cluster__slot", "clayer_shift", "clayeracoffset", "closen_offset", "cluster__cache", "clusteracaddress", "cluster__part", "cluster1offset", "closen_part", "clayer_address", "closen2slot", "clayeracoptional", "cluster2info", "cluster1address", "clayer_optional", "cluster7offset", "cluster0cache", "cluster0part", "cluster_slot", "clayer_offset"], "l1_bits": ["l1lexmins", "l51_codes", "l51_bits", "l1lexbands", "l2_codes", "l2_blocks", "l1_its", "l1_codes", "l1_locks", "l1_length", "lub_mins", "l1vbit", "lub_locks", "l1lexlength", "l1lexabs", "l51_length", "l1__bits", "l1__bit", "l1_abs", "lub_bands", "l1lexcodes", "l1__its", "l1_bit", "l2_bit", "l2_pieces", "l2_its", "l1lexbits", "l1_pieces", "l1vblocks", "lub_bits", "l2_bytes", "l1_bytes", "l1_bands", "l1_mins", "l1vbytes", "l1vbits", "l51_abs", "l2_bits", "l1_blocks", "l1__pieces", "l1lexlocks"], "c": ["count", "l", "C", "abc", "n", "g", "w", "m", "unc", "t", "k", "b", "x", "z", "total", "d", "i", "max", "p", "limit", "e", "cb", "cf", "ec", "f", "bc", "ac", "cc", "code", "cs", "call", "o", "v", "ce", "r", "cl", "dc", "col", "u", "h", "ci", "cache", "y", "cy"], "index_in_cluster": ["index_in_scure", "index_in_clusters", "index_in_sloser", "index_in_chusters", "index_in_licust", "index_in_chust", "index_in_licusters", "index_in_Clust", "index_in_closer", "index_in_scusters", "index_in_slorer", "index_in_Clure", "index_in_clust", "index_in_loser", "index_in_chure", "index_in_scuster", "index_in_Clusters", "index_in_clure", "index_in_Clone", "index_in_clue", "index_in_scluster", "index_in_Closer", "index_in_Clorer", "index_in_luster", "index_in_lusters", "index_in_chue", "index_in_slusters", "index_in_licuster", "index_in_scust", "index_in_sclone", "index_in_clorer", "index_in_licue", "index_in_sclorer", "index_in_Cluster", "index_in_slust", "index_in_lust", "index_in_slone", "index_in_sluster", "index_in_clone", "index_in_sclusters", "index_in_chuster", "index_in_Clue"], "nb_available": ["ni67available", "nb67available", "nob_available", "pb_external", "nb64available", "cb_used", "nb_required", "nb67expected", "nblexavailability", "nb_opened", "nb64allowed", "nb___availability", "nob_availability", "nbPprovided", "ni_required", "pb_available", "pb_needed", "nblexavailable", "nb__available", "nb_used", "nbPavailability", "nb___opened", "nb64announced", "ni67availability", "nb_availability", "nob_provided", "cb_needed", "cb_required", "nb__required", "nob_allowed", "ni_availability", "nbPopened", "nb_expected", "nob_needed", "nb___provided", "pblexexternal", "ni_allowed", "nblexneeded", "nb__availability", "nb_allowed", "pb_availability", "ni_announced", "pblexneeded", "nb_external", "nb_provided", "nb67availability", "ni67required", "pblexavailable", "nblexexternal", "nb64availability", "nb67required", "nb___available", "nb__expected", "nbPavailable", "ni67expected", "nob_opened", "cb_available", "ni_expected", "nb_announced", "ni_available", "pblexavailability"], "nb_needed": ["nn_needed", "nb__needed", "nb_need", "nb___needed", "nb_required", "nbMcontained", "nb67used", "nb67needed", "nb_contained", "nbMbalanced", "sync67needed", "nb___needs", "nb_used", "nb___found", "nb67balanced", "fee_found", "nb__needs", "sync_balanced", "len67needed", "nb__contained", "len67needs", "nb67needs", "nn_initialized", "fee_necessary", "nn_used", "nb67contained", "fee___needs", "len_needed", "nb_initialized", "fee___necessary", "len_used", "sync67needs", "nn_required", "sync_needed", "nbMneeds", "fee___needed", "sync_contained", "sync_needs", "fee_needs", "sync67contained", "fee___found", "nn_available", "len_needs", "nbMneeded", "nb_found", "nb_necessary", "nb__balanced", "sync67balanced", "len67need", "fee_needed", "nb___necessary", "len_need", "nn_necessary", "nb_balanced", "nb67need", "len67used", "nb_needs"], "nb_clusters": ["nb__luster", "nb2collusters", "nb00clancers", "nb_flunks", "nb_plodes", "nb_cleores", "nb_clitions", "nb_clients", "nb_sclusters", "nb00sclusters", "nb_slusters", "nb_clists", "nb_scusters", "nb_collodes", "nb__litions", "nb_Clusters", "nb00sclists", "nb00clists", "nb_flancers", "nb2collodes", "nb_Clicas", "nb_plores", "nb_clores", "nb2colluts", "nb_slodes", "nb_slores", "nb_kluster", "nb2clodes", "nb_licas", "nb__clitions", "nb_sclists", "nb_Clitions", "nb_klicas", "nb_clancers", "nb00sclunks", "nb2clusters", "nb_cleuts", "nb_clodes", "nb_plients", "nb__clicas", "nb_blients", "nb_Cluster", "nb2clores", "nb_litions", "nb_cleodes", "nb__licas", "nb_plusters", "nb_klusters", "nb_blodes", "nb_clunks", "nb_scodes", "nb_scores", "nb_lusters", "nb_sclunks", "nb_scuts", "nb_flusters", "nb2collores", "nb_cleusters", "nb_luster", "nb_blores", "nb__lusters", "nb__cluster", "nb__clusters", "nb_scists", "nb00sclancers", "nb_flists", "nb2cluts", "nb_clicas", "nb_colluts", "nb_scunks", "nb_klitions", "nb_cluster", "nb_cluts", "nb_slients", "nb00clusters", "nb00clunks", "nb_blusters", "nb_scancers", "nb_collores", "nb_sclancers", "nb_collusters"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;\n\n\n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n//printf(\"%X %X %X %X %X %X %X %X %X %X\\n\", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],\n\n//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\tb5Dither= dither8[y&1];\n\n\tg6Dither= dither4[y&1];\n\n\tg5Dither= dither8[y&1];\n\n\tr5Dither= dither8[(y+1)&1];\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\n/* no speed diference on my p3@500 with prefetch,\n\n * if it is faster for anyone with -benchmark then tell me\n\n\t\t\tPREFETCH\" 64(%0) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%1) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%2) \\n\\t\"\n\n*/\n\nYUV2RGB\n\n\n\n#ifdef DITHER1XBPP\n\n\t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\"\n\n\t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\"\n\n\t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\"\n\n#endif\n\n\t\t     /* mask unneeded bits off */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm0;\" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_grnmask)\", %%mm2;\" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm1;\" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */\n\n\n\n\t\t     \"psrlw $3,%%mm0;\" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */\n\n\t\t     \"pxor %%mm4, %%mm4;\" /* zero mm4 */\n\n\n\n\t\t     \"movq %%mm0, %%mm5;\" /* Copy B7-B0 */\n\n\t\t     \"movq %%mm2, %%mm7;\" /* Copy G7-G0 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpcklbw %%mm4, %%mm2;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpcklbw %%mm1, %%mm0;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm2;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"por %%mm2, %%mm0;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\n\n\t\t     \"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t     MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpckhbw %%mm4, %%mm7;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm7;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t     \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\t\t     \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\n\n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */\n\n\n\n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n\n\n    return srcSliceH;\n\n}\n", "idx": 9109, "substitutes": {"c": ["l", "conf", "oc", "cam", "C", "n", "g", "w", "m", "tc", "conn", "t", "b", "k", "d", "con", "cp", "s", "ct", "p", "e", "cu", "cn", "ec", "f", "ac", "cc", "cs", "ctrl", "cv", "ce", "rc", "ctx", "cur", "cal", "pc", "dc", "xc", "enc", "u", "nc", "h", "cm", "ca", "ci", "comp", "vc", "lc", "ch", "mc"], "src": ["seq", "proc", "source", "sel", "scene", "http", "b", "sur", "bs", "rect", "iv", "config", "dest", "gl", "attr", "usr", "rss", "rb", "loc", "sq", "st", "sec", "inst", "sub", "lib", "cv", "rc", "sl", "ctx", "conv", "sup", "support", "sb", "scenes", "spec", "secure", "scl", "url", "text", "rob", "ources", "sr", "uc", "ssl", "sc"], "srcStride": ["srcShride", "srcScide", "srcSlope", "stStride", "srcDride", "srcShide", "srcSTri", "srcSTrue", "rcShri", "rcStroy", "rcEstri", "srcSlrite", "stClride", "srcScrue", "srcStause", "srcStandcase", "srcClride", "srcStide", "srcShri", "srcClrite", "srcStcase", "supportSTope", "srcEstope", "supportStuse", "srcSlroy", "srcClause", "srcEstuse", " srcSterve", "supportStope", "supportSTuse", "srcSlerve", "srcSlroute", "rcStri", "srcEstrue", "supportStide", "rcStride", "rcEstrue", "srcSTope", "srcSlri", "srcConstroy", "rcShroy", "srcStroy", "srcScrite", "srcStandide", "srcShrite", "srcShcase", "srcDause", " srcStrite", "srcDrite", "supportSTide", "srcEstride", "stStructure", "supportSTride", "rcEstide", "stStause", "rcStroute", "rcShride", "srcStuse", "srcStope", "srcScructure", "srcShroute", "srcSlride", "srcScri", "srcStandrite", "srcSTuse", " srcStcase", "srcSlide", "rcStrue", "srcScride", "srcConstride", "srcStrite", "stStrite", "stClructure", "stClrite", "srcStri", "rcShroute", "supportStride", "srcStrue", " srcStide", "srcStructure", "srcEstri", "srcConstroute", "stClause", "rcStide", "srcSTide", "srcConstri", "srcEstide", "srcSTride", "rcEstride", "srcSluse", "srcScause", "srcClructure", "srcStandride", "srcStroute", "srcDructure", "srcEstrite", "srcEsterve", "srcSterve", "srcShroy"], "srcSliceY": ["srcSlideW", "srcSlideH", "srcSlaceW", "srcFliceW", "srcSliceM", "srcFliceH", "srcSlaseW", "srcSlaceH", "srcSlaseY", "srcFlICEY", "srcSlaceY", "srcSlICEX", "srcSlICEW", "srcFlICEM", "srcSliceX", "srcSlideX", "srcSlaseH", "srcFliceX", "srcFlaseH", "srcSlaceM", "srcFlICEW", "srcFliceY", "srcFlaseW", "srcSlideM", "srcFliceM", "srcSlaceX", "srcSlICEM", "srcSlICEY", "srcSliceW", "srcSlaseX", "srcFlaseX", "srcSlideY", "srcFlICEX", "srcFlaseY"], "srcSliceH": ["srcSlideW", "srcSlideH", "srcSlaceW", "srcFliceH", "srcFliceW", "srcSlsliceHT", "srcSlaceH", "srcFlICEH", "srcSlsliceH", "srcFlICEY", "srcSlaceY", "srcSlICEX", "srcSlICEW", "srcSlICEHT", "srcSlaceF", "srcSliceX", "srcFlICEHT", "srcSlaceHT", "srcSlICEH", "srcFliceHT", "srcFliceX", "srcSlsliceX", "srcSlideF", "srcFliceF", "srcFlICEW", "srcSlICEF", "srcSliceF", "srcFliceY", "srcSliceHT", "srcSlaceX", "srcSlsliceY", "srcSlICEY", "srcSliceW", "srcFlICEF", "srcSlideY", "srcFlICEX"], "dst": ["nste", " drc", "dsrc", "gst", "grc", "nsts", "drc", "Dste", "Dsts", "Dsrc", "dste", "nsrc", " dsrc", "gsts", " dsts", "nst", "Dst", "dsts", " dste", "gsrc", "Drc"], "dstStride": ["dstStide", "dscTrip", "dstTride", "dscStrip", "dstStrend", "dstStro", "dscTri", "dsrcStride", "dststrip", "dstCrip", "dscStri", "dstStrip", "dstStrri", "dstScrite", "dstScube", "dststri", "dstaStride", "dstTide", "dstCrite", "dstStrrite", "dstStrite", "dsrcstube", "dscTrite", "dsrcstrite", "dstStrro", "dstCro", "dstaStrro", "dstTend", "dstTrip", "dstStube", "dscStrite", "dstStrube", "dstaStend", "dsrcStube", "dstTrite", "dststride", "dstaStrride", "dstTri", "dstaStro", "dstaStide", "dstScri", "dscTride", "dstStrride", "dscStride", "dstCride", "dststrite", "dstScride", "dstaStrend", "dsrcStri", "dsrcStrite", "dstStend", "dsrcstride", "dsrcstri", "dstCri", "dstCend", "dstTro", "dstCide", "dststube", "dstStri"], "y": ["count", "isy", "ym", "ady", "my", "yt", "oy", "say", "n", "ry", "ny", "m", "w", "t", "x", "ey", "z", "vy", " Y", "d", "i", "b", "ye", "uy", "ys", "cy", "p", "iy", "yi", "yang", "ay", "zy", "yy", "sy", "j", "gy", "py", "sky", "ky", "yl", "yd", "hy", " x", "Y", "ty", "yr", "yu", "type", "h", "yan", "year", "ya", "dy", "yo"], "h_size": ["h__len", "hxloc", "H_size", "H__len", " hxsize", "h_len", "h1length", "hxize", " h_scale", " h_sum", "H__loc", " h_address", "h2scale", "h__Size", "h2size", "h_Size", " h_width", "H_scale", "h1loc", "h__length", "hxsize", "h_width", " h_SIZE", "h_address", "h_scale", "H__scale", "h_ize", "H__Size", "H_length", "H_Size", " hxize", "h__scale", "H_loc", "H__length", "H_len", " hxscale", "H__size", "h_SIZE", "h1len", "hxscale", "h__loc", "h2loc", " hxloc", "h_length", "h1size", "h2ize", "h__size", "h__sum", " h_ize", "H__sum", "h_loc", " h_loc", "h_sum", "H_sum"], "_image": ["_original", "timg", "_img", "toriginal", "timage", "tpng", "_png"], "_py": [" _dim", "_xy", "wpic", "wdim", "hpic", "hpy", "_dim", "hxy", " _pic", "_pic", "hdim", "wpy", " _xy", "wxy"], "_pu": ["_gpu", "_ui", "__lu", "__ui", "_lu", "__gpu", "__pu"], "_pv": ["_ppf", "_pf", "_Pf", "_gv", "_Pu", "_pvi", "_ppu", "_gu", "_Pvi", "_ppvi", "_gf", "_ppv", "_gvi", "_Pv"]}}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 9122, "substitutes": {"mr": ["km", "rh", "rf", "adr", "ru", "mn", "tr", "hr", "mor", "m", "fr", "theme", "rr", "bm", "kr", "mm", "gr", "wire", "bridge", "wk", "eer", "hm", "MR", "drm", "wm", "usr", "gb", "wr", "pm", "rb", "rs", "gro", "lr", "er", "ml", "dr", "manager", "nm", "fm", "rt", "mer", "mid", "mx", "module", "bh", "r", "req", "bro", "err", "mmm", "nr", "shr", "rpm", "rar", "yr", "tm", "plugin", "vr", "dm", "cm", "rx", "rg", "eri", "mt", "Mr", "lc", "sr", "br", "eu", "mc", "rl", "rm", "github"], "addr": ["alias", "mac", "area", "adr", "location", "base", "start", "len", "ord", "owner", "prefix", "pad", "conn", "id", "src", "rr", "pointer", "bridge", "ad", "ref", "config", "work", "ace", "uri", "attr", "np", "dist", "amd", "act", "ptr", "frame", "loc", "eni", "mode", "dr", "inst", "host", "rt", "arity", "osi", "amp", "oa", "route", "index", "name", "rc", "align", "state", "proxy", "ctx", "address", "nr", "dc", "hop", "offset", "node", "rn", "layer", "ino", "ip", "extra", "length", "range"], "size": ["count", "l", "channel", "is", "z", "SIZE", "max", "grow", "loc", "code", "cap", "end", "izes", "offset", "cycle", "settings", "iz", "timeout", "si", "speed", "c", "large", "unit", "es", "sized", "en", "nick", "storage", "izer", "year", " Size", "range", "fee", "len", "second", "small", "send", "export", "mini", "activity", "mode", "shape", "sync", "ise", "ize", "weight", "core", "area", "scale", "capacity", "number", "Size", "empty", "sec", "name", "mi", "six", "address", "pos", "length", "ity"], "match_data": ["Match_val", "match64data", "match_Data", "matchingData", "matcheddata", "matchedvalue", "match2val", "matchingdata", "match_all", "match___value", "match___keys", "Match2val", "match64pos", "match64all", "Match_data", "Match2data", "match2Data", "match2data", "match_value", "matched_data", "matchningdata", "matchabledata", "matchingval", "match_pos", "Match_Data", "match___data", "matched_style", "matched_value", "matchedkeys", "match_style", "Match2Data", " match_all", "matchedstyle", "match_keys", "matchableData", "matchningpos", "match___style", " match_pos", "match_val", "matchningall", "matchableval", "matched_keys"], "data": ["devices", "ui", "di", "timeout", "delay", "source", "window", "media", "da", "pad", "id", "def", "open", "d", "buf", "ad", "batch", "reader", "ata", "value", "action", "memory", "writer", "array", "empty", "body", "DATA", "next", "dat", "alpha", "device", "append", "progress", "ea", "format", "input", "connection", "oder", "response", "content", "state", "done", "address", "results", "function", "load", "callback", "Data", "error", "bus", "bytes", "read", "handler", "aa", "api", "message", "image", "cache", "result", "length", "partial", "bin", "buffer"], "e": ["l", "ee", "element", "eur", "n", "E", "fe", "m", "t", "ey", "b", "d", "de", "oe", "ne", "c", "s", "p", "se", "esi", "ec", "ue", "er", "f", "ie", "none", "ev", "o", "ae", "edge", "energy", "ea", "es", "ce", "ede", "end", "entity", "r", "en", "error", "u", "engine", "eu", "eve", "ed"], "i": ["oi", "l", "ui", "di", "it", "is", "si", "n", "in", "zi", "id", "m", "xi", "info", "b", "x", "ini", "z", "iv", "d", "c", "p", "ix", "uri", "yi", "mu", "cli", "eni", "f", "ie", "j", "ai", "o", "index", "v", "gi", "mi", "ti", "phi", "r", "address", "qi", "ij", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "a", "api", "length", "ni", "y", "ri", "fi", "iu"], "ioeventfd_nb": ["ioeventfn_nb", "ioeventfdPloop", "ioeventf_cb", "ioeventfdPnb", "ioeventfn_base", "ioeventfdPbase", "ioeventFD_nb", "ioeventfd2num", "ioeventfdPnum", "ioeventfn_num", "ioeventfd2loop", "ioeventFD_cb", "ioeventfd2base", "ioeventFD_nr", "ioeventfd_note", "ioeventf_nb", "ioeventf_note", "ioeventfd2nb", "ioeventfd_rb", "ioeventfd_b", "ioeventf_b", "ioeventfd_base", "ioeventfn_loop", "ioeventFD_bm", "ioeventfd_num", "ioeventfd_loop", "ioeventFD_rb", "ioeventfd_nr", "ioeventfd_bm", "ioeventfd_cb"]}}
{"project": "FFmpeg", "commit_id": "c3778df2d4c05e76d28d77a2d740e435393046c9", "target": 0, "func": "enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)\n\n{\n\n    if (codec && codec->pix_fmts) {\n\n        const enum AVPixelFormat *p = codec->pix_fmts;\n\n        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;\n\n        enum AVPixelFormat best= AV_PIX_FMT_NONE;\n\n        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,\n\n                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };\n\n            }\n\n        }\n\n        for (; *p != AV_PIX_FMT_NONE; p++) {\n\n            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);\n\n            if (*p == target)\n\n                break;\n\n        }\n\n        if (*p == AV_PIX_FMT_NONE) {\n\n            if (target != AV_PIX_FMT_NONE)\n\n                av_log(NULL, AV_LOG_WARNING,\n\n                       \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\",\n\n                       av_get_pix_fmt_name(target),\n\n                       codec->name,\n\n                       av_get_pix_fmt_name(best));\n\n            return best;\n\n        }\n\n    }\n\n    return target;\n\n}\n", "idx": 9134, "substitutes": {"st": ["std", "str", "start", "est", "ust", "stage", "nt", "fr", "src", "rest", "t", "steam", "stream", "stack", "se", "osc", "ost", "stop", "dr", "spect", "inst", "ut", "nd", "sts", "sta", "sl", "end", "kt", "sth", "sn", "ist", "ste", "cl", "sb", "stim", "ast", "St", "ST", "client", "ft", "ess", "td", "sc"], "codec": ["coderec", "cedef", "cedec", "codeco", "codeesc", "cedeca", "codeenc", "peddc", "labec", "codeEC", "code", "pedec", "compesc", "compenc", "codeca", "codeec", " code", "codep", "codeack", "Codef", "labef", "coderer", "compEC", "pedenc", "ode", "Codenc", "odec", "codesc", "compeca", "aquec", "coddc", "labenc", "compec", "codack", "odenc", " codEC", " codrec", "codenc", " codenc", "aquEC", " coddc", "pedef", "codeoc", "Codeca", "cedep", "codac", "labdc", "codoc", "Codec", "odesc", " codeca", "aquack", "cheec", " codef", "codeect", " codack", "odeca", "Codac", "cheenc", " coderer", "codrec", "compeco", "Codeco", "compoc", "aquect", "codef", " codep", "Codep", "odoc", "compe", "Coderer", "codEC", "codeerer", "odEC", "codect", "Codrec", "cheac", " codect", "cheeco", "compac", "CodEC"], "target": ["parent", "compatible", "valid", "goal", "source", "window", "class", "method", "nt", "src", "t", "path", "Target", "instance", "top", "last", "config", "output", "arg", "obj", "component", "dest", "global", "value", "array", "best", "large", "next", "blank", "host", "external", "opt", "master", "format", "input", "current", "end", "object", "new", "support", "largest", "arget", "root", "this", "type", "platform", "self", "null", "transform", "options", "client", "peer", "gap", "result", "match", "localhost", "pattern", "any"], "p": ["lp", "l", "dp", "parent", "sp", "param", "wp", "pg", "n", "g", "w", "m", "bp", "point", "b", "t", "k", "x", "pa", "d", "i", "pp", "post", "c", "cp", "s", "data", "pb", "e", "np", "fp", "pe", "po", "ep", "at", "pm", "q", "P", "best", "f", "op", "pn", "j", "prop", "code", "progress", "o", "v", "pre", "hp", "tp", "jp", "port", "pi", "pc", "after", "pect", "u", "h", "back", "a", "ps", "y", "per"]}}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "static void gic_set_irq(void *opaque, int irq, int level)\n\n{\n\n    /* Meaning of the 'irq' parameter:\n\n     *  [0..N-1] : external interrupts\n\n     *  [N..N+31] : PPI (internal) interrupts for CPU 0\n\n     *  [N+32..N+63] : PPI (internal interrupts for CPU 1\n\n     *  ...\n\n     */\n\n    GICState *s = (GICState *)opaque;\n\n    int cm, target;\n\n    if (irq < (s->num_irq - GIC_INTERNAL)) {\n\n        /* The first external input line is internal interrupt 32.  */\n\n        cm = ALL_CPU_MASK;\n\n        irq += GIC_INTERNAL;\n\n        target = GIC_TARGET(irq);\n\n    } else {\n\n        int cpu;\n\n        irq -= (s->num_irq - GIC_INTERNAL);\n\n        cpu = irq / GIC_INTERNAL;\n\n        irq %= GIC_INTERNAL;\n\n        cm = 1 << cpu;\n\n        target = cm;\n\n    }\n\n\n\n    assert(irq >= GIC_NR_SGIS);\n\n\n\n    if (level == GIC_TEST_LEVEL(irq, cm)) {\n\n        return;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        gic_set_irq_11mpcore(s, irq, level, cm, target);\n\n    } else {\n\n        gic_set_irq_generic(s, irq, level, cm, target);\n\n    }\n\n\n\n\n    gic_update(s);\n\n}", "idx": 9150, "substitutes": {"opaque": ["opacity", "opedaco", "opedaque", "opac", " opaco", "opedusher", "iopusher", "opaco", "operacity", "iopaque", " opac", "opusher", " opaques", " opusher", " opacity", "opedac", "iopac", "iopaco", "openaques", "operaque", "opaques", "openaque", "operaques", "openacity"], "irq": ["ironqu", "pirqs", "irqq", "riquery", "mirq", "riqq", "ierQ", "Irquest", "iraqu", "irQ", "yrque", "Irg", "ireqq", "IRqi", "irquery", "mirQ", "pirqu", "ironQ", "yrquest", "riqual", "iraquest", "riq", "iraque", "IRQ", "irtqq", "iriq", "ierquest", "iraqual", "lrq", "lrqu", "iraqq", "iriqu", " irg", "irqual", "pirq", "riQ", "irtquest", "irireq", "IRquest", "irque", "pirQ", "irtreq", "irtque", "irech", "yrq", "ierqa", "ironqs", "ireq", "irch", "ireqa", "ierque", "IRqa", "rique", "irqs", "riqs", "yrqu", "ierq", "rich", " irqu", "IRq", "mirque", " irquest", "irreq", "ierreq", "irqi", "irtquery", "iriquest", "mirquest", "irqu", "irtq", "IRque", "ironq", "ireQ", "irtqu", "iraquery", "riqu", "irqa", "iraq", "yrQ", "lrque", "lrQ", "Irq", "ierqi", "irtch", "irtqi", "irequ", "ierqu", "irquest", "riquest", "Irqu", "ierg", "irg", "irtQ", "irtqual", "IRqu", "iraQ"], "level": ["wl", "parent", "l", "hi", "co", "scale", "len", "ul", "key", "stage", "m", "model", "path", "lvl", "con", "c", "line", "rule", "limit", "el", "pri", "local", "pe", "loc", "coll", "high", "sequence", "ec", "mode", "code", "fl", "size", "index", "module", "scope", "inc", "Level", "content", "cl", "levels", "cle", "enc", "col", "type", "layer", "url", "length", "lc", "depth", "sc", "vel"], "s": ["l", "conf", "session", "sg", "ts", "ks", "is", "n", "g", "si", "ds", "sf", "m", "http", "t", "b", "d", "i", "gs", "service", "c", "p", "server", "e", "status", "private", "xs", "sq", "js", "rs", "f", "sk", "us", "os", "sym", "cs", "o", "sets", "S", "es", "sync", "south", "sie", "states", "sl", "state", "r", "services", "sup", "sb", "ns", "storage", "sis", "spec", "this", "u", "sys", "self", "secondary", "ses", "su", "site", "a", "y", "ss", "ssl"], "cm": ["cr", "km", "uca", "ym", "center", "dim", "param", "dom", "m", "mr", "cut", "bm", "chip", "course", "mm", "gm", "c", "vm", "cp", "CM", "config", "component", "wm", "fp", "cn", "cf", "pm", "cc", "nm", "mode", "fm", "ctrl", "module", "mx", "ctx", "im", "cl", "pc", "dc", "com", "dm", "comm", "ca", "ci", "url", "cache", "lc", "cmd", "crit", "um", "core", "mc", "rm", "cy", "chain"], "target": ["parent", "center", "member", "session", "term", "location", "timeout", "compatible", "goal", "source", "conn", "cut", "path", "task", "Target", "net", "t", "top", "pointer", "config", "output", "limit", "component", "value", "cn", "gt", "large", "manager", "unit", "resource", "trace", "module", "scope", "master", "format", "content", "remote", "ctx", "object", "address", "token", "offset", "arget", "platform", "tail", "client", "transform", "secondary", "null", "site", "match", "core", "force", "forward", "range"], "cpu": ["uca", "boot", "cmp", "processor", "conn", "gpu", "chip", "bench", "prem", "net", "instance", "num", "GPU", "pool", "appa", "cp", "vm", "component", "thread", "computer", "np", "pixel", "cn", "fp", "gp", "pm", " CPU", "performance", "hw", "unit", "process", "master", "rc", "fps", "program", "lb", "pu", "pc", "nic", "node", "CPU", "nc", "platform", "gc", "CP", "cache", "lc", "proc", "core", "roc", "PC"]}}
{"project": "FFmpeg", "commit_id": "366ac22ea5a8bab63c7f46cdad2ddb2ff22cdbed", "target": 1, "func": "static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n                          IVITile *tile, AVCodecContext *avctx)\n{\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n                mv_scale, blks_per_mb;\n    IVIMbInfo   *mb, *ref_mb;\n    int         row_offset = band->mb_size * band->pitch;\n    mb     = tile->mbs;\n    ref_mb = tile->ref_mbs;\n    offs   = tile->ypos * band->pitch + tile->xpos;\n    /* scale factor for motion vectors */\n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n    mv_x = mv_y = 0;\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n        mb_offset = offs;\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n            mb->xpos     = x;\n            mb->ypos     = y;\n            mb->buf_offs = mb_offset;\n            if (get_bits1(&ctx->gb)) {\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n                    return -1;\n                }\n                mb->type = 1; /* empty macroblocks are always INTER */\n                mb->cbp  = 0; /* all blocks are empty */\n                mb->q_delta = 0;\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                           IVI_VLC_BITS, 1);\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                }\n                mb->mv_x = mb->mv_y = 0; /* no motion vector coded */\n                if (band->inherit_mv){\n                    /* motion vector inheritance */\n                    if (mv_scale) {\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                    } else {\n                        mb->mv_x = ref_mb->mv_x;\n                        mb->mv_y = ref_mb->mv_y;\n                    }\n                }\n            } else {\n                if (band->inherit_mv) {\n                    mb->type = ref_mb->type; /* copy mb_type from corresponding reference mb */\n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    mb->type = 0; /* mb_type is always INTRA for intra-frames */\n                } else {\n                    mb->type = get_bits1(&ctx->gb);\n                }\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n                mb->q_delta = 0;\n                if (band->qdelta_present) {\n                    if (band->inherit_qdelta) {\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n                                           (ctx->frame_flags & 8))) {\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                               IVI_VLC_BITS, 1);\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                    }\n                }\n                if (!mb->type) {\n                    mb->mv_x = mb->mv_y = 0; /* there is no motion vector in intra-macroblocks */\n                } else {\n                    if (band->inherit_mv){\n                        /* motion vector inheritance */\n                        if (mv_scale) {\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                        } else {\n                            mb->mv_x = ref_mb->mv_x;\n                            mb->mv_y = ref_mb->mv_y;\n                        }\n                    } else {\n                        /* decode motion vector deltas */\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_y += IVI_TOSIGNED(mv_delta);\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_x += IVI_TOSIGNED(mv_delta);\n                        mb->mv_x = mv_x;\n                        mb->mv_y = mv_y;\n                    }\n                }\n            }\n            mb++;\n            if (ref_mb)\n                ref_mb++;\n            mb_offset += band->mb_size;\n        }\n        offs += row_offset;\n    }\n    align_get_bits(&ctx->gb);\n    return 0;\n}", "idx": 9162, "substitutes": {"ctx": ["conf", "utils", "cam", "context", "cmp", "Context", "cca", "conn", "sci", "fw", "c", "ct", "cp", "config", "qq", "qa", "cli", "cb", "cf", "cn", "wcs", "loc", "coll", "hw", "cc", "bc", "la", "cs", "ctrl", "cv", "ck", "scope", "sync", "rc", "connection", "voc", "cas", "conv", "cal", "tx", "kt", "cl", "wx", "xc", "hub", "cms", "nc", "gc", "cm", "ca", "cfg", "client", "ci", " context", "vc", "anc", "cmd", "lc", "pkg", "kb", "sc"], "band": ["play", "channel", "word", "board", "tag", "bridge", "bd", "bo", "frame", "brand", "device", "zone", "connection", "kt", "port", "usb", "bus", "unk", "link", "image", "broad", "lf", "bb", "flag", "key", "stage", "song", "rule", "car", "prop", "group", "dB", "db", "unit", "slice", "bound", "nd", "cast", "plugin", "layer", "back", "cell", "ground", "range", "station", "tool", "boot", "product", "plane", "brid", "card", "piece", "gb", "style", "flow", "mode", "wave", "feature", "part", "cmd", "core", "co", "leg", "phase", "service", "line", "batch", "bands", "bit", "Band", "bin", "match", "direction"], "tile": ["mage", "kernel", "img", "ite", "theme", "tag", "ele", "bridge", "uri", "ace", "target", "pixel", "txt", "loc", "ie", "lite", "sk", "device", "uv", "kt", "port", "hop", "link", "pod", "flo", "interface", "image", "flat", "ht", "tif", "sheet", "chip", "bm", "rule", "component", "fit", "cf", "tf", "slice", "det", "module", "sky", "live", "plate", "col", "plugin", "layer", "li", "file", "header", "ge", "gap", "mt", "site", "ski", "nn", "tool", "zip", "boot", "grid", "tab", "nb", "ile", "conn", "plane", "game", "Tile", "project", "tu", "metadata", "cli", "cube", "coll", "mode", "dr", "entry", "feature", "node", "core", "byte", "co", "fo", "scale", "phy", "dt", "service", "oe", "line", "mask", "texture", "table", "ti", "ilo", "uni", "bin", "so"], "avctx": ["AVconfig", "AVcm", "devctrl", "avectx", "devcontext", "Avctrl", "AVctrl", "AVcontext", "avcm", "avecm", "AVctx", "avconfig", " avcontext", "avcontext", "devconfig", "Avctx", "avctrl", "Avconfig", " avcm", "avecontext", "devctx", "Avcontext", " avctrl", "avectrl"], "x": ["ady", "hi", "xp", "n", "php", "wa", "win", "ph", "ax", "w", "m", "xi", "id", "xx", "t", "b", "z", "num", "sw", "d", "i", "my", "by", "c", "X", "p", "ix", "time", "e", "el", "off", "xxx", "f", "gy", "code", "index", "v", "yx", "name", "zx", "fx", "tx", "en", "wx", "xc", "xy", "h", "pos", "rx", "on", "px", "ya", "image", "dx", "ex"], "y": ["ym", "ady", "yt", "oy", "n", "ry", "asy", "ny", "w", "m", "id", "t", "ey", "z", "vy", "b", "ye", "i", "d", "ys", "cy", "p", "iy", "yi", "ish", "ay", "zy", "f", "sy", "yy", "height", "gy", "o", "py", "sky", "yx", "ky", "yl", "yd", "hy", "Y", "ty", "yr", "type", "xy", "h", "year", "lon", "a", "ya", "wy", "dy", "yo"], "mv_x": ["mv_d", "mvIdrx", "mf_d", "mv8xx", "mf_xx", "mv_h", "mw_x", "mw_z", "mb_ex", "mv8y", "mf_scale", "mf_e", "mw_y", "mf_z", "mv_xy", "mvIdx", "mv8x", "mb_x", "mv_ex", "mv_e", "mf_x", "mvIde", "mv_xx", "mw_xy", "mb_y", "mvIdy", "mvIdd", "mv_rx", "mv8scale", "mf_y", "mvIdz", "mv_z", "mf_rx", "mb_h"], "mv_y": ["mv_ny", "mv2y", "mf_z", "mh_p", "mm2ny", "mh_x", "mm2cy", "mv_p", "mm_ny", "mf_py", "mh_i", "mv2ty", "mv_cy", "mv2cy", "mv2ny", "mm_y", "mm_cy", "mv_i", "mv_py", "mv_ty", "mm_ty", "mm2ty", "mf_y", "mv_z", "mf_x", "mm2y", "mh_y"], "mv_delta": ["mv_pbase", "mv__ddbase", "mv__delta", "mv_ddelta", "mv_delt", "mv_Delt", "mv__dbase", "mv__ddiff", "mv_dbase", "mv_Diff", "mv_pelta", "mv__ddelt", "mv__diff", "mv__ddelta", "mv_diff", "mv_ddelt", "mv_Dbase", "mv_ddbase", "mv_pelt", "mv_piff", "mv_Delta", "mv_ddiff", "mv__delt"], "offs": ["windows", "utils", "ks", "ds", "frames", "ones", "nos", "rows", " off", "aps", "heads", "ff", "tips", "ops", "flows", "ands", "powers", "s", " offsets", "pieces", "bands", "xff", "outs", "off", "lines", "bits", "errors", "args", "sets", "oa", "aux", "ups", "eps", "ans", "ns", "blocks", "offset", "bytes", "ms", "OFF", "pos", "points", "ons", "options", "times", "ows", "Offset"], "mb_offset": ["mb67adjust", "mx_offset", "mc67offset", "mb67off", "mb_delay", "mb_count", "mc_Offset", "mb_slot", "mc67position", "lim67location", "lim67off", "mbPdelay", "mx_count", "lim67delay", "mb_Offset", "mb_adjust", "lim_delay", "mb_off", "lim67offset", "mbPoffset", "mx_slot", "mbPoff", "mbPlocation", "mc67adjust", "mb67position", "mb_location", "mb67delay", "mb67location", "lim_off", "mc_offset", "mc_adjust", "mc67Offset", "mb_position", "mc_position", "mx_off", "mb67offset", "lim_offset", "mb67Offset", "lim_location"], "mv_scale": ["mv_slice", "mv__grade", "mw_scale", "mv\u00b7scale", "mf_cale", "mv_size", "mv\u00b7slice", "mv_gap", "mb_gap", "mv__size", "mv__center", "mf_scale", "mv_cale", "mb_size", "mf_size", "mf_slice", "mv\u00b7init", "mb_rate", "mv\u00b7margin", "mf_center", "mw_margin", "mf_grade", "mv_center", "mv_grade", "mb_scale", "mw_slice", "mv__scale", "mw_init", "mv_rate", "mv_init", "mv_margin"], "blks_per_mb": ["blks_Per_mm", "blks_per_mm", "blks_per_kb", "blks_Per_MB", "blks_per_MB", "blks_Per_mb", "blks_Per_kb"], "mb": ["GB", "ym", "library", "ib", "byte", "base", "bb", "mn", "em", "pg", "nb", "ph", "mor", "m", "bp", "lim", "BM", "org", "bm", "b", "mm", "mem", "job", "MB", "vm", "fb", "bd", "ref", "pb", "app", "gb", "rb", "bc", "nm", "orb", "db", "bf", "mp", "fm", "eb", "bl", "mx", "amp", "bg", "fam", "mc", "gg", "md", "lb", "mod", "sm", "sb", "amb", "ms", "emb", "cm", "ma", "meg", "ob", "mt", "bin", " MB", "cmd", "xb", "mag", "om", "kb"], "ref_mb": ["ref__kb", "ref_gb", "refvalmb", "ref__mp", "ref_kb", "ref_mp", "ref__mb", "rel_gb", "ref__gb", "reference_ym", "ref_bb", " ref_MB", " ref_bb", "refvalym", "ref__mm", "reference_kb", "rel_mb", "rel_mp", "ref_MB", "reference_mb", "rel_emb", "ref__ym", "reference_mm", "ref_emb", "ref_mm", " ref_mm", "refvalmm", "ref_ym", "ref__emb", "refvalkb"]}}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 9172, "substitutes": {"vty_lookup": ["vty_findup", "vty_signup", "vty_findUp", "vty_lookUp", "vty_finddown", "vty_lookdown", "vty_signdown", "vty_signUp"], "sPAPRMachineState": ["sPAPREMachineService", "sPAPRMachineService", "sPAPRMousestate", "sPAPRMobileService", "sPAPRMounterstate", "sPAPRMobilestate", "sPAPRMobileConfig", "sPAPRMounterState", "sPAPRMouseService", "sPAPRMouseState", "sPAPREMachineState", "sPAPREMachinestate", "sPAPREMachineConfig", "sPAPREMobileConfig", "sPAPRMouseConfig", "sPAPREMobileService", "sPAPREMobileState", "sPAPRMobileState", "sPAPRMounterConfig", "sPAPRMachinestate", "sPAPRMounterService", "sPAPREMobilestate", "sPAPRMachineConfig"], "spapr": ["spappr", " spapsrar", "spaprc", "scapar", "scaprb", "spapsrs", "spaprs", "sparprar", "sprapr", "spamprs", " spapsrc", "spapsr", "papsar", "spraprator", "spapra", "papsrator", "spopr", "spaprar", " spaprc", "spopar", "sprapar", " spapsr", "spamprator", "papsrs", "spampar", "spappar", "sparpr", "spaprb", "spapar", "spapprar", " spapsra", "spapsrar", "scapra", "sparpra", "spopra", "spapprb", "spaprator", "sparprc", "scappra", "scappar", "spoprb", "spapprc", "spappra", " spaprar", "spapsar", "spapsrator", "scappr", "paprs", "spraprb", "scapr", "spraprs", "papsr", "spapsra", "sprapra", "papar", "spampr", "scapprb", "spapsrc", "papr", " spapra", "paprator"], "target_ulong": ["target_uint32", "target_uint_", "target_u32", "target_us_", "target_uslong", "target_uintlong", "target_us32", "target_ul32", "target_ul_", "target_u_", "target_ullong", "target_uintong", "target_usong", "target_uong"], "reg": [" Reg", "REG", "arc", "rem", "arch", "g", "region", "org", "tag", "rest", "net", "num", "mem", "rec", "stat", "gr", "data", "addr", "config", "dist", "ag", "memory", "loc", "serial", "sec", "res", "scan", "eg", "bl", "ig", "rc", "name", "min", "mod", "Reg", "port", "im", "eng", "dis", "spec", "col", "re", "dev", "rg", "ann", "match", "feat"], "sdev": ["SDev", " sdevice", "dsdevice", "gdev", " spred", "dsev", "wsdev", "wsDev", "wsvar", "csdevice", "sev", "smod", "dsDev", "sesev", "gerror", " serror", "Sev", "Sdevice", "cserror", "sportsdev", "sdevice", "wsdiv", "sportsvar", "sesdevice", "sDev", " smod", "dsdev", "sdiv", "sespred", "sportsDev", "Sdev", "spred", "serror", "sportsdiv", " sev", "gdevice", "sesdev", "svar", "csdev", "gmod", "Spred", "csmod", " sDev"]}}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n", "idx": 9174, "substitutes": {"job": ["parent", "session", "base", "section", "worker", "bar", "task", "pool", "block", "config", "cb", "er", "code", "process", "connection", "object", "lb", "self", "url", "image", "up", "id", "b", "work", "jo", "output", "f", "j", "db", "py", "module", "Job", "live", "fire", "error", "hub", "plugin", "lock", "layer", "handler", "build", "ob", "exec", "member", "blog", "model", "page", "project", "status", "flow", "sub", "pause", "sync", "order", "poll", "home", "fun", "part", "node", "message", "result", "ah", "cmd", "hide", "line", "run", "server", "jobs", "queue", "bug", "manager", "child", "lib", "route", "name", "event", "function", "bot", "user", "api", "loop", "match"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}", "idx": 9176, "substitutes": {"bs": ["vs", "base", "ks", "ds", "lbs", "bid", "bas", "src", "boxes", "b", "gs", "iss", "fb", "s", "ls", "pb", "obj", "cb", "ins", "bits", "rb", "rs", "banks", "BS", "bc", "os", "obs", "cs", "bl", "bps", "ras", "ubs", "fps", "las", "lb", "bis", "ns", "sb", "blocks", "bytes", "as", "ses", "ps", "fs", "css", "ss", "bes", "bos"], "offset": ["count", "area", "location", "boot", "timeout", "reference", "seq", "base", "inet", "initial", "start", "prefix", "origin", "pointer", "data", "slot", "addr", "config", "ref", "attr", "fp", "set", "off", "loc", "ptr", "padding", "o", "bound", "index", "size", "order", "align", "loader", "address", "port", "part", "position", "type", "layer", "online", "et", "pos", "url", "length", "image", "absolute", "buffer", "Offset", "reset"], "buf1": ["buff2", " bufp", "uf3", "bag2", " bufone", "bufone", " buf4", "buf2", "buf4", " buf2", "bagone", "uf1", "uf2", "buffer3", " buf0", "buff0", "bufferone", " buf3", "buffer2", "buffer1", "buff1", "buf3", "bufferp", "buffer4", "bag1", "bag4", "uf0", "bufp", "buffp", "buffer0", "buf0"], "count1": ["call2", "lenone", "len1", " countOne", "lenOne", "partOne", "cond1", " count8", "len2", "partone", "count2", "count8", "part8", "sum1", " countone", "condOne", "cond2", "callone", "sumone", "part1", "call1", "countOne", "sumOne", "call8", "condone", "countone", " count2", "part2", "sum2"], "drv": ["drvs", " drver", "irf", "drV", "Drf", " drf", " drvs", "irv", "Drb", "drb", "drf", "DRf", " drb", "irver", "hrf", "rdf", "drvr", "DRvs", "DRV", "rdvr", "driver", "adrvc", "DRp", "driv", "adrf", "hrb", "drp", "adrver", "drvc", "hrv", "hrV", "irvc", "adrv", "rdvs", " drV", " drvc", "rdv", "drib", "DRv", "Drv", "DrV", "drif", "drver", "Drp", " drp", "Drver", "DRvr", " drvr"]}}
{"project": "FFmpeg", "commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "target": 1, "func": "int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n\n                             int max_size)\n\n{\n\n    uint32_t mrk;\n\n    int i, tmp;\n\n    const uint16_t *ssrc = (const uint16_t *) src;\n\n    uint16_t *sdst = (uint16_t *) dst;\n\n    PutBitContext pb;\n\n\n\n    if ((unsigned) src_size > (unsigned) max_size)\n\n        src_size = max_size;\n\n\n\n    mrk = AV_RB32(src);\n\n    switch (mrk) {\n\n    case DCA_SYNCWORD_CORE_BE:\n\n        memcpy(dst, src, src_size);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_LE:\n\n        for (i = 0; i < (src_size + 1) >> 1; i++)\n\n            *sdst++ = av_bswap16(*ssrc++);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_14B_BE:\n\n    case DCA_SYNCWORD_CORE_14B_LE:\n\n        init_put_bits(&pb, dst, max_size);\n\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n\n            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n\n            put_bits(&pb, 14, tmp);\n\n        }\n\n        flush_put_bits(&pb);\n\n        return (put_bits_count(&pb) + 7) >> 3;\n\n    default:\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n}\n", "idx": 9178, "substitutes": {"src": ["chrom", "seq", "img", "cmp", "start", "source", "sel", "proc", "low", "rest", "RC", "sur", "iv", "b", "lower", "buf", "s", "config", "uri", "rib", "dest", "cb", "attr", "split", "rel", "dist", "gb", "rb", "loc", "sq", "st", "ource", "sec", "obl", "inst", "code", "sub", "supp", "slice", "ctr", "sync", "rc", "sl", "cur", "sup", "req", "sn", "desc", "sb", "spec", "secure", "scl", "sit", "url", "length", "comp", "rob", "sr", "uc", "ssl", "sc"], "src_size": ["src_length", "src_ize", "secure_size", "rc_address", "rc_time", " src_ize", "rss_sized", "srcsize", "srcqscale", "srcslength", "src_sized", "rc_name", "srcqSIZE", "secure_sum", "src_capacity", " src_count", "src_sum", "secure_small", "src_name", "rc_ize", " src_length", "src_small", "src_count", " src_scale", "src_engine", "rc_engine", "rc_SIZE", "rss_size", "rc_size", "src_loc", "src_time", "secure_SIZE", "src_SIZE", "srcqengine", "rc_capacity", "src_scale", " src_loc", "rc_scale", "src_address", "srcsloc", "rss_scale", "srcqsize", "srcssize"], "dst": ["dedst", "dedrc", " drc", " dsc", "dbl", "dsrc", "sdsc", "dssts", "sdsts", "drc", "dedbl", "dedest", "Dsc", "dsc", "Dest", "dest", "Dsts", "Dsrc", "sdrc", " dsrc", " dsl", "Dsl", "dsl", "dedsts", "sdest", " dsts", " dest", "dssc", "pdsl", "Dst", " dbl", "dsbl", "dsts", "pdst", "dsst", "pdsrc", "dedsc", "pdsc"], "max_size": ["maxlexlen", "maxLoffset", "max_time", "maxLsize", " max_len", " max64capacity", " max_depth", "max_count", "maxLdepth", "maxlexoffset", "max24time", " max64size", "maxacsize", "maxactime", " max_time", "max64capacity", "maxlexsize", " max_offset", "max_len", " max64name", "maxfullcapacity", "max33depth", "max64size", "max24count", "maxfullname", "maxfullstorage", " max_name", "max_name", " max_storage", "max24size", "max_depth", "max_storage", " max_capacity", " max64storage", "max24cap", "max_offset", "max_capacity", "maxaccap", "max64name", "max33size", "max64storage", "max33offset", " max_count", "maxlexcapacity", "maxfullsize", "max_cap", " max_cap", "maxaccount"], "mrk": ["vrks", "MRkg", "vrkk", "rrke", " hrkg", "Mrks", "mrkg", "MRkk", "rrks", "drk", " hrk", "mrK", "MRks", "krks", "rrK", "lrk", "MRke", "mrkk", "drks", " hrK", "mrks", "MRok", "krkk", "lrke", "MRk", "Mrke", "mrok", " hrke", "Mrok", "vrK", "mrke", "drok", "rrk", "lrks", "Mrk", "MRK", "krK", "krk", "lrkg", "drke", "vrk", "lrK"], "i": ["oi", "hi", "ui", "di", "it", "start", "si", "in", "source", "zi", "id", "xi", "info", "k", "x", "ini", "z", "c", "ji", "p", "ix", "pri", "uri", "mu", "mini", "f", "ie", "j", "ai", "multi", "index", "v", "rc", "ti", "mi", "gi", "phi", "ind", "r", "end", "chi", "qi", "im", "pi", "bi", "ii", "init", "uni", "type", "u", "I", "pos", "li", "ip", "ci", "ni", "io", "image", "ri", "fi", "iu"], "tmp": ["diff", "sp", "bb", "img", "cmp", "nb", "ff", "source", "abb", "temp", "tc", "bp", "wb", "Temp", "pp", "buf", "vt", "cp", "data", "fb", "meta", "stuff", "cb", "fp", "np", "txt", "obj", "ptr", "rb", "yy", "db", "bf", "mp", "tf", "amp", "rc", "uv", "phi", "cur", "jp", "TB", "part", "sb", "cpp", "result", "buff", "proc", "kk"], "ssrc": ["SSsrc", "dsrc", "sslc", "vsrc", "dsrs", "SSRC", "ssri", "sRC", "vsri", "vssrc", "vslc", "ssRC", "sssrc", "SSrc", "dslc", "dsri", "SSrs", "dsRC", "ysri", "ysrc", "dssrc", "yslc", "yssrc", "srs", "ssrs"], "sdst": ["hdnd", "hdst", "hdsc", "sdsc", "dost", " sdost", "SDft", "SDsp", "SDsc", "dsc", "sdft", " sdsc", "sdost", "tdft", "ddft", " sdnd", "ddsp", "tdst", "sdnd", "ddsc", "hdost", "dnd", "tdsc", "tdsp", "SDst", "ddst", "sdsp"], "pb": ["lp", " PB", "dp", "ib", "wp", "bb", "pg", "nb", "sf", "bp", "tc", "pl", "lab", "bm", "b", "wb", "pa", "pp", " eb", "cp", "vm", "fb", "p", "pd", "cb", "fp", "gb", "ub", "rb", "pm", "bc", "bt", "db", "bf", "mp", "bj", "eb", "bps", "bh", "lb", "bot", "jp", "tp", "sb", "pc", "PB", "hub", "mb", "api", "fc", "ob", "bsp", "obb", "xb", "rob", "vp"]}}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189, "substitutes": {"xhci": [" xhsci", " xphdc", "sexhlci", " xwsci", "xhcci", "xbhcit", "workhscu", "xbhcu", "Xhcci", "sexhcit", "xhlcin", "xehdc", "xhrcci", " xhcm", "xihcm", "xrhcit", "Xehcin", "xehsci", "xrhci", " xhco", "xrhcu", "xrhii", "xhlci", "xwsci", " xphcm", "xhscu", "xbhii", " xwci", "xhsri", " xhcci", "workhca", "xhii", " xphco", "Xehri", "xhcu", "xphco", "xehci", "xwri", "workhci", "Xhci", "xhlcit", "xhdc", "xehri", "xhtri", "xehcm", "xphdc", "xhrco", "xhtca", "xhtcu", "xwci", "xphcm", "Xehcci", "xhlii", "sexhci", "xihco", "xhtci", "xhcit", "xwcci", "xhsci", "xhco", "xhlri", "xwcu", "xhhcci", "Xehci", "xhhcin", "xbhci", "xhhci", "xhsca", "Xhri", "xehcci", "xihci", "sexhlcit", "xhri", "xhrsci", " xphci", "sexhlii", "xhrci", " xhdc", "workhsca", "workhcu", "sexhlcu", " xwco", "xhlcci", "xphci", "xehco", "xhca", "sexhcu", "sexhii", "xwca", "workhri", "xhcin", "xehcin", "Xhcin", "xwco", "workhsci", "xihdc", "xhlcu", "xhhri", "xhcm", " xwcci", "workhsri"], "slotid": ["slotname", " slotinfo", " slotno", "lotide", "slotinfo", "spotno", " slotId", "lotid", "spotid", " slotname", "socketname", "lotId", "socketno", "lotno", "spotname", "lotinfo", "spotId", "slotide", "spotinfo", "spotide", "socketid", "slotno", "lotname", "socketide", "slotId"], "epid": ["apId", "ekids", "apin", "epin", "oppath", "ppId", "ypID", "opid", "epnum", "evit", "ekId", "epsId", "espip", " epnum", " ep1", " epID", " epkid", "epx", "ekkid", "taskkid", "ypids", "amppid", " epin", "opx", "ep1", "ppit", "ppID", "eppid", "eppath", "lipid", "ypi", "epsID", "apid", "epi", "lip1", "epsi", "epID", "taskid", "epaid", "yppid", "ipit", "epkid", "ipkid", "eknum", "lipip", "ekx", "ipid", "ampid", "epId", "apkid", "epsid", "ampaid", "ipip", "ewId", " epId", "ampip", "yppath", " epit", "espit", "ekpath", "ekid", "epsit", "ewkid", "ipnum", "ppi", "ypid", " epip", " epaid", "opids", "ppid", "ypip", "ypit", "evId", "epspid", "ip1", "ipID", "espid", "ewin", "ppaid", "epids", "ypaid", "epip", "evid", "tasknum", "taskId", "ewid", "evi", "ypx", "epsip", "espID", " epi", "lipnum", "epsaid", "ipId", "epit"], "slot": ["lot", "channel", "shot", "session", "ion", "boot", "spot", "timeout", "tab", "kernel", "blog", "section", "shell", "Slot", "trial", "pit", "game", "tz", "job", "pool", "serv", "service", "server", "layout", "target", "role", "loc", "table", "socket", "slave", "rot", "entry", "profile", "slice", "lib", "module", "zone", "rol", "connection", "account", "sl", "option", "margin", "offset", "plugin", "cat", "lock", "hole", "li", "loop", "sit", "bin", "lc", "cell", "pot", "pty", "pin"], "epctx": ["eccf", "mpconn", "mploc", "mpcb", "ppconn", "ypcontext", "eccontext", "eccb", "ypcf", "EPtx", "mpcor", "ypconn", "ppctx", "ppcor", "EPcontext", "Epcmp", "ewcm", "EPctx", "ekctrl", "pctx", "ypctx", "ekcmd", "mpcontext", "ypcm", "yploc", "epctrl", "eptx", "EPcmp", "epcmp", "ipctx", "yptx", "pcontext", "iploc", "epcf", "ppcf", "mpcm", "ekconn", "ekctx", "mpctrl", "epcm", "Epcmd", "ekcmp", "ypcb", "ppcontext", "ewloc", "ptx", "eploc", "mptx", "ekcontext", "ecctx", "ipcmd", "ewctx", "pptx", "ecconn", "ekloc", " epctrl", "ipcmp", " epcontext", "Eploc", "mpcmp", "Epctx", "epcb", "ypcor", "ewcontext", " epconn", "epcor", "epconn", "pcmp", "epcmd", "epcontext", "mpctx"], "i": ["l", "it", "is", "n", "in", "id", "b", "k", "d", "c", "p", " I", "e", "or", "f", "j", "ai", "o", "ic", "r", "pi", "h", "I", "ip", "a", "io", "ri"]}}
{"project": "qemu", "commit_id": "bc3e6a0d6c8ab6cd7cd4b576ed567756f1dcabd2", "target": 1, "func": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n", "idx": 9193, "substitutes": {"bus": ["session", "boot", "pass", "base", "board", "http", "tag", "mount", "bridge", "config", "driver", "plug", "bug", "us", "serial", "BUS", "brand", "os", "Bus", "scope", "sync", "connection", "las", "address", "port", "stick", "usb", "hub", "plugin", "controller", "io", "cache", "use", "bank", "book"]}}
{"project": "qemu", "commit_id": "679aa175e84f5f80b32b307fce5a6b92729e0e61", "target": 0, "func": "static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            /* Interrupt Controller Type Register */\n\n            return ((s->num_irq / 32) - 1)\n\n                    | ((NUM_CPU(s) - 1) << 5)\n\n                    | (s->security_extn << 10);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            /* Interrupt Group Registers: these RAZ/WI if this is an NS\n\n             * access to a GIC with the security extensions, or if the GIC\n\n             * doesn't have groups at all.\n\n             */\n\n            res = 0;\n\n            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {\n\n                /* Every byte offset holds 8 group status bits */\n\n                irq = (offset - 0x080) * 8 + GIC_BASE_IRQ;\n\n                if (irq >= s->num_irq) {\n\n                    goto bad_reg;\n\n                }\n\n                for (i = 0; i < 8; i++) {\n\n                    if (GIC_TEST_GROUP(irq + i, cm)) {\n\n                        res |= (1 << i);\n\n                    }\n\n                }\n\n            }\n\n            return res;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Set/Clear Enable.  */\n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Set/Clear Pending.  */\n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (gic_test_pending(s, irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target.  */\n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            /* For uniprocessor GICs these RAZ/WI */\n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_EDGE_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xf10) {\n\n        goto bad_reg;\n\n    } else if (offset < 0xf30) {\n\n        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n            goto bad_reg;\n\n        }\n\n\n\n        if (offset < 0xf20) {\n\n            /* GICD_CPENDSGIRn */\n\n            irq = (offset - 0xf10);\n\n        } else {\n\n            irq = (offset - 0xf20);\n\n            /* GICD_SPENDSGIRn */\n\n        }\n\n\n\n        res = s->sgi_pending[irq][cpu];\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    qemu_log_mask(LOG_GUEST_ERROR,\n\n                  \"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9210, "substitutes": {"opaque": ["opacity", "OPaque", "ipque", "opac", "Opaque", "OPquire", "operbuffer", "OPque", "operacity", "Opac", " opacity", "ipaque", "ipac", "opquire", "Opque", "opbuffer", "ipquire", " opbuffer", "OPac", "operaque", "opque", "OPacity", "Opquire", "OPbuffer"], "offset": ["utils", "base", "optional", "tile", "path", "shift", "ref", "set", "esi", "skip", "starting", "loc", "align", "end", "port", "type", "online", "url", "image", "alias", "reference", "timeout", "delay", "iso", "prefix", "id", "missing", "addr", "limit", "sequence", "padding", "index", "slice", "energy", "clock", "position", "error", "bytes", "range", "fee", "location", "operation", "initial", "len", "data", "slot", "fp", "ptr", "style", "entry", "o", "size", "sync", "part", "esp", "et", "attribute", "activation", "frequency", "Offset", "reset", "inet", "ui", "start", "info", "pointer", "phase", "line", "p", "server", "queue", "off", "onto", "address", "option", "pos", "ip", "api", "length"], "attrs": ["ttrs", "attrributes", "attps", "addributes", " attributes", "attributes", " attls", "addrs", "ttributes", "attrrs", "attros", "attls", "addps", "Attros", "addros", "Attributes", "ttps", "Attls", "attrps", "attrls", "ttros", "Attps", "Attrs", " attps"], "s": ["l", "session", "is", "m", "http", "t", "gs", "sk", "state", "ns", "hs", "spec", "self", "settings", " settings", "sg", "ds", "n", "si", "sites", "sf", "w", "b", "c", "e", "se", "sq", "f", "sym", "sets", "es", "r", "storage", " services", " requests", "u", "ps", "site", "times", "ss", "g", "stats", "ops", "d", "sa", "ls", "local", "os", "cs", "o", "sync", "south", "sl", "sb", "sys", "secondary", "a", "ssl", " os", "conf", "ts", "service", "p", "server", "xs", "js", "S", "sie", "states", "services", "results", "less", "ses"], "res": ["vals", "utils", "arr", "rem", "cmp", "Res", "rows", "val", "features", "mr", "fields", "RES", "rest", "resolution", "gr", "clear", "powers", "ress", "max", "ros", "reg", "Rs", "runs", "rys", "args", "rss", "js", "rs", "bits", "os", "ris", "cs", "pres", "scope", "ras", "rc", "ries", "response", "resh", "cons", "r", "pre", "results", "err", "details", "blocks", "bytes", "ms", "rus", "re", "ores", "row", "out", "result", "ret", "cache", "resp", "match", "rh", "reset"], "irq": ["irkg", "irqt", "arc", "irekg", "irqq", "ircharge", "ironcharge", "iracharge", "rilq", "arque", "arQ", "earcharge", "incque", "ironqq", "ierqt", " irche", "irQ", "rinq", "IRqs", "urcharge", "rilqa", "urQ", "rinqu", "ireqq", "rilqt", "rinQ", "ironqt", "irece", "irquery", "irec", "urquery", "arche", "ireqs", "ireque", "ironqual", "iraquest", " irz", "irf", "riq", "iraque", "iref", "rilqual", "IRQ", "urq", "ierquest", "earqq", "ierqual", "earce", "urqa", " irQ", "iercharge", "irequest", "urqs", " irque", "pirque", "irqual", "pirq", "virche", "riQ", "earq", "irtquest", "urquest", "riqa", " irkg", "earquest", "irque", "pirQ", "virque", "irtque", "ironquest", "irche", "irct", "ierqa", "ireq", " irce", "ireqa", "ironqa", "ierque", "IRqa", "incct", "irqs", "rique", "iract", "virflow", "ierq", "pirz", "irecharge", "pirce", "IRq", "virct", "arf", "irflow", "incflow", "earQ", "irce", "virq", "arq", "irqu", "ironq", "irtq", " irqa", "ireQ", "ironque", "iraquery", "irz", "riqu", "irqa", "earque", "iraq", "virQ", " irc", "pirqa", " irf", "rinquest", "earqu", "arkg", "irquest", "iraflow", "ierquery", "riquest", "ironce", "urque", "irc", "irtQ", "ironz", "incq"], "i": ["oi", "l", "vi", "ani", "hi", "ui", "di", "it", "is", "si", "start", "n", "in", "zi", "id", "xi", "info", "my", "x", "ini", "z", "ami", "t", "d", "ji", "c", "p", "uri", "ix", "e", "mu", "yi", "cli", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "ti", "phi", "end", "chi", "qi", "ei", "pi", "bi", "ii", "init", "u", "I", "li", "ip", "ci", "ori", "io", "ni", "image", "y", "ri", "fi", "iu", "ki"], "cpu": ["rem", "cmp", "len", "prefix", "conn", "gpu", "chip", "net", "num", "sci", "mem", "pool", "cp", "c", "vm", "p", "component", "cli", "np", "pixel", "gp", "pm", " CPU", "linux", "process", "current", "clock", "fps", "pu", "cl", "pc", "nic", "CPU", "nc", "gc", "ips", "ci", "image", "cache", "lc", "proc", "core", "roc", "nn"], "cm": ["cr", "km", "sem", "ym", "dim", "rem", "om", "m", "cut", "chip", "bm", "mult", "mr", "dem", "num", "mm", "gm", "c", "vm", "cp", "CM", "hm", "cum", "qa", "cli", "wm", "drm", "cf", "cn", "pm", "q", "cc", "nm", "fm", "mx", "umi", "module", "req", "im", "cl", "iam", "dm", "comm", "form", "ci", "cache", "lc", "core", "mc", "rm"], "mask": ["windows", "kernel", "rem", "rows", "conn", "net", "gr", "ress", "ace", "qa", "bits", "cc", "sk", "flags", "rc", "resh", "ask", "cost", "blocks", "ms", "bit", "ips", "row", "cache", "ch", "result", "weight"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                      target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret;\n\n    target_ulong sr, pgidx;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n\n\n    sr = env->sr[eaddr >> 28];\n\n    ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n    ds = sr & 0x80000000 ? 1 : 0;\n\n    ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n    vsid = sr & 0x00FFFFFF;\n\n    target_page_bits = TARGET_PAGE_BITS;\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx\n\n            \" nip=\" TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n            \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n    hash = vsid ^ pgidx;\n\n    ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            qemu_log_mask(CPU_LOG_MMU, \"htab_base \" TARGET_FMT_plx\n\n                    \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            /* Software TLB search */\n\n            ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_loglevel_mask(CPU_LOG_MMU)) {\n\n                CPUState *cs = ENV_GET_CPU(env);\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", env->htab_base, env->htab_mask + 0x80);\n\n                for (curaddr = env->htab_base;\n\n                     curaddr < (env->htab_base + env->htab_mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(cs->as, curaddr);\n\n                    a1 = ldl_phys(cs->as, curaddr + 4);\n\n                    a2 = ldl_phys(cs->as, curaddr + 8);\n\n                    a3 = ldl_phys(cs->as, curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            qemu_log_mask(CPU_LOG_MMU, \"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        qemu_log_mask(CPU_LOG_MMU, \"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log_mask(CPU_LOG_MMU, \"ERROR: instruction should not need \"\n\n                          \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 9215, "substitutes": {"env": ["fg", "cdn", "conf", "utils", "qt", "context", "dict", "conn", "dt", "que", "ini", "net", "viron", "ne", "environment", "config", "server", "obj", "e", "cli", "qa", "np", "txt", "esi", "cf", "gui", "ec", "eni", "bc", "manager", "inst", "console", "ev", "inv", "db", "exc", "cv", "ea", "scope", "req", "cal", "en", "end", "eng", "Environment", "enc", "init", "uni", "cfg", "nc", "et", "client", "dev", "her", "site", "engine", "eu", "settings", "exec"], "ctx": ["conf", "utils", "qt", "wp", "context", "cmp", "prefix", "conn", "sci", "fw", "kb", "c", "cp", "config", "qq", "anon", "obj", "qa", "cli", "fp", "cb", "local", "cf", "act", "cn", "loc", "sq", "wcs", "hw", "cc", "bc", "pkg", "ctrl", "console", "cv", "exc", "ck", "sync", "rc", "scope", "event", "connection", "cas", "conv", "tx", "jp", "cl", "acl", "xc", "git", "fn", "cfg", "sys", "cm", "scl", "ca", "client", "ci", "general", "grad", "nc", "vc", "lc", "cmd", "chan", "ssl", "sc", "exec"], "eaddr": ["ecdr", "eeddr", "awdr", "eadhr", "ecder", "oadhr", "edddu", "effdu", "effhr", "eaddu", "effmot", "execdr", "designmot", "eadbr", "eadcur", "eadDr", "designdr", "effcur", "efdr", "egDR", "effdr", "abdr", "avdr", "abstr", "eddrr", "awhr", "eddhr", "eddder", "effder", "efDr", "efder", "abder", "ecrr", "awDr", "egder", "eldu", "awder", "execder", "efhr", "elhr", "elDR", "eadder", "eadmot", "eedhr", "awstr", "edddr", "elder", "execmot", "avbr", "ecstr", "eadrr", "eedder", "execcur", "designder", "eedbr", "oadder", "egdr", "oadstr", "efDR", "egDr", "avstr", "eddstr", "eedstr", "eldr", "egstr", "avder", "eadstr", "abbr", "egrr", "awDR", "eadDR", "oaddr", "designcur"], "rw": ["wl", "wn", "rh", "rf", "ru", "wp", "w", "src", "rr", "wh", "sw", "wb", "wk", "usr", "rss", "wr", "nw", "rb", "rs", "hw", "rt", "rc", "nr", "wx", "ww", "vr", "rx", "rg", "rack", "RW", "resp", "wd", "nn", "tw"], "type": ["parent", "kind", "str", "class", "test", "key", "method", "id", " typ", "like", "t", "var", "Type", "other", "rule", "time", "ref", "p", "block", "attr", "rel", "role", "pt", "style", "action", "types", "op", "none", "code", "unit", " ty", "py", "shape", "size", "format", "name", "state", "pre", "user", "port", "token", "tp", "ty", "ping", "error", "col", "TYPE", "year", "null", "y", "ype", "typ"], "hash": ["map", "session", "sh", "base", "str", "tr", "handle", "Hash", "auth", "key", "hh", "id", "chip", "tag", "total", "num", "sha", "block", "sum", "addr", "ref", "mask", "attr", "number", "memory", "search", "array", "height", "db", "ha", "version", "index", "msg", "format", "name", "user", "kh", "copy", "h", "ash", "dev", "header", "cache", "rev", "bin", "br", "match", "alg", "rh", "depth"], "vsid": [" vsend", "bsd", "lsname", "dsids", "lsid", "fskid", "dsip", "VSId", "lsids", "lskid", "vshide", "vsids", "dsid", "bsmid", "vsId", "csend", "pskid", "dskid", "vsd", "lshide", "psmid", "rsid", "psid", "cskid", "csid", "vsend", "dsinfo", "fsids", " vsids", " vskid", "fsid", "wsinfo", "vsip", "rskid", "wsid", "bskid", "bsid", "vskid", "wsids", "lsip", "lsinfo", " vsId", "csids", "VShide", "rsmid", "psd", "vsname", "vsinfo", "lsId", "VSkid", "wsname", "lsend", "fsip", " vshide", "vsmid", "VSid", "dsname", "rsd"], "ds": ["vs", "dp", "cr", "vals", "des", "dim", "di", "std", "dh", "pg", "sv", "str", "ks", "auth", "dds", "da", "conn", "sql", "dt", "ops", "d", "gs", "data", "ys", "s", "ls", "xs", "rs", "os", "sk", "dr", "dl", "db", "sync", "sts", "eps", "virt", "tx", "dd", "DS", "ns", "dc", "hs", "sd", "Ds", "sys", "der", "dev", "ps", "sid", "ss", "bs", "dy"], "pr": ["cr", "pol", "sp", "por", "pg", "sv", "tr", "PR", "hr", "fr", "pl", "rr", "mr", "kr", "pid", "pa", "p", "pro", "attr", "rel", "rss", "pt", "wr", "pm", "po", "ptr", "rs", "lr", "dr", "pir", "spr", "sl", "Pr", "r", "pre", "sn", "jp", "nr", "pi", "vr", "rx", "pos", "ps", "rev", "br", "per"], "target_page_bits": ["target_page_flags", "target_Page_bits", "target_pg_bytes", "target_page64mins", "target_page64bytes", "target_pageallpoints", "target_page_locks", "target_page64flags", "target_pageallparts", "target_Page_flags", "target_page_points", "target_page_mins", "target_page64bits", "target_page_details", "target_pg_locks", "target_page_bytes", "target_Page_mins", "target_pg_details", "target_pg_points", "target_pg_parts", "target_pageallbits", "target_page_parts", "target_Page_bytes", "target_pg_bits", "target_pagealllocks"], "ret": ["seq", "arr", "len", "val", "alt", "all", "nt", "Ret", "total", " Ret", "num", "last", "feat", "data", "ref", "arg", "lit", "reg", "gt", "rets", "res", "det", "fun", "ben", "get", "bit", "fin", "cat", "RET", " RET", "result", "rev", "match", "ft", "resp", "mt"], "sr": ["cr", "rf", "ru", "SR", "rin", "sv", "tr", "rd", "hr", "sf", "fr", "src", "rr", "sw", "sur", "kr", "gr", "ra", "serv", "usr", "rss", "ir", "rs", "rb", "lr", "er", "dr", "rt", "mir", "ctr", "spr", "cv", "sl", "r", "nr", "sb", "radius", "rar", "yr", "vr", "rx", "rg", "ser", "br", "RR", "rh", "rl", "ssl"], "pgidx": ["pgIdz", "pgaidv", "pgIdx", "pgridex", "gIdc", " pgidX", "pgIdxes", "pgIdX", "pgidct", " pgidz", "pgIdb", "pgidsxes", "pgpidx", "pgnamect", "pgaidz", "pgpidX", " pgpidb", "pgnameX", "pgidsX", " pgpidv", "pgnameex", "pgpidb", "gidX", " pgidxes", "gidx", "pgidz", "pgridx", "gIdct", "pgIdv", "pgidc", "gidex", "gIdex", "pgIdct", "pgidv", " pgIdx", " pgpidX", "pgaidX", "gidct", " pgIdX", "pgidsz", "gIdx", "pgIdc", "pgaidb", "gIdX", " pgIdxes", "gIdz", "pgridct", "pgidsx", "pgidex", "pgaidc", "pgnamex", "pgpidv", " pgidb", "pgIdex", " pgIdz", " pgpidx", "pgaidx", " pgidv", "gidc", "gidz", "pgidb", "pgridX", "pgidxes", "pgidX"]}}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void slirp_socket_save(QEMUFile *f, struct socket *so)\n\n{\n\n    qemu_put_be32(f, so->so_urgc);\n\n    qemu_put_be16(f, so->so_ffamily);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_faddr.s_addr);\n\n        qemu_put_be16(f, so->so_fport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_faddr and so_fport\\n\");\n\n    }\n\n    qemu_put_be16(f, so->so_lfamily);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_laddr.s_addr);\n\n        qemu_put_be16(f, so->so_lport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_laddr and so_lport\\n\");\n\n    }\n\n    qemu_put_byte(f, so->so_iptos);\n\n    qemu_put_byte(f, so->so_emu);\n\n    qemu_put_byte(f, so->so_type);\n\n    qemu_put_be32(f, so->so_state);\n\n    slirp_sbuf_save(f, &so->so_rcv);\n\n    slirp_sbuf_save(f, &so->so_snd);\n\n    slirp_tcp_save(f, so->so_tcpcb);\n\n}\n", "idx": 9225, "substitutes": {"f": ["l", "rf", "uf", "conf", "xf", "lf", "fo", "fen", "g", "ff", "af", "sf", "def", "w", "m", "fr", "info", "fd", "t", "b", "k", "fed", "fore", "fw", "d", "i", "c", "fb", "s", "p", "e", "fp", "cf", "feed", "q", "df", "of", "j", "fm", "bf", "tf", "fa", "o", "v", "fx", "fun", "full", "fn", "u", "form", "self", "F", "file", "fs", "func", "inf", "fac", "fi", "fe", "fc"], "so": ["osa", "sp", "ou", "ku", "sh", "co", "le", "fo", "oso", "si", "plus", "iso", "sf", "no", "go", "to", "kee", "ve", "za", "tw", "tto", "ne", "oe", "sa", "from", "de", "i", "isi", "p", "se", "e", "pro", "oto", "bo", "cli", "po", "olo", "os", "sk", "ie", "SO", "la", "o", "osi", "oa", "sync", "ce", "zo", "oco", "sl", "vo", "sm", "shi", "ao", "ko", "mo", "ico", "this", "u", "ho", "coe", "thro", "flo", "So", "su", "ge", "ski", "ri", "ki", "lo", "te"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n", "idx": 9231, "substitutes": {"obj": ["arr", "prefix", "class", "id", "otype", "data", "ref", "Obj", "attr", "cb", "rel", "po", "objects", "js", "inst", "code", "o", "opt", "module", "ctx", "object", "mod", "node", "type", "ob", "func"], "name": ["parent", "alias", "NAME", "n", "comment", "prefix", "key", "def", "class", "id", "no", "path", "block", "ref", "names", "rel", "value", "child", "named", "end", "old", "part", "fn", "type", "self", "on", "func", "Name"], "val": ["vals", "Val", "Value", "base", "valid", "sel", "key", "def", "var", "VAL", "doc", "data", "ref", "el", "Obj", "rel", "value", "prop", "eval", "v", "live", "old", " value", "ret", "func", "exec"], "errp": ["erp", "rrp", "err", "rrr", " errP", "errP", "rrP", "erP", " errr", "errr"]}}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n", "idx": 9238, "substitutes": {"ctx": ["conf", "cam", "context", "cmp", "Context", "cca", "conn", "tc", "src", "c", "cp", "config", "component", "fp", "cn", "cf", "loc", "bc", "cc", "cs", "ctrl", "cv", "ck", "ce", "rc", "cas", "conv", "tx", "pc", "cpp", "cms", "cm", "ca", "ci", "anc", "lc", "text", "mc", "kb", "sc", "exec"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "n", "si", "zi", "m", "id", "xi", "info", "b", "x", "k", "t", "ini", "d", "c", "ji", "p", "uri", "e", "mu", "yi", "f", "ie", "j", "ai", "code", "o", "multi", "index", "slice", "v", "gi", "ti", "qi", "pi", "bi", "ii", "u", "type", "h", "I", "li", "ci", "a", "io", "length", "ni", "y", "iu"], "output": ["region", "word", "block", "config", "target", "memory", "code", "external", "response", "content", "object", "document", "full", "put", "sort", "grade", "image", "eff", "reference", "filter", "generated", "application", "control", "draw", "value", "hidden", "unit", "module", "input", "current", "four", "position", "layer", "complete", "operation", "source", "model", "page", "data", "written", "flow", "resource", "version", "size", "software", "after", "oper", "fn", "result", "core", "Output", "byte", "display", "update", "queue", "number", "average", "console", "event", "address", "function", "option", "summary", "null", "out", "video", "write", "forward"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n", "idx": 9246, "substitutes": {"dstU": ["dSTV", "dostU", "drcUV", "DSTP", "destP", "DestU", "DSTV", "destV", "dSTUV", "dscP", "dSTU", "DestV", "dstP", "dostP", "dostUV", "drcV", "dscV", "destUV", "destU", "DestP", "dstUV", "DestUV", "DSTU", "DstP", "drcP", "dSTP", "DstV", "drcU", "DSTUV", "dscUV", "DstU", "DstUV", "dostV", "dscU"], "dstV": ["dSTV", "drdV", "adSTU", "adSTV", "ddrUV", "DSTV", "dsrcV", "dSTUV", "ddrV", "DstI", "dSTU", "drdUV", "dsrcU", "adSTUV", "drdI", "dstUV", "adSTW", "DSTU", "dconstUV", "dconstU", "dconstV", "ddrW", "adstUV", "dsrcI", "DstV", "adstW", "DSTUV", "DstU", "DSTI", "dSTI", "DstUV", "dstW", "dSTW", "ddrU", "dstI", "dsrcUV", "drdU", "adstU", "dconstW", "adstV"], "src1": ["reflect2", "src0", "rc2", " src01", " src7", "rc7", "src01", "rc1", " src0", "src7", "rib0", "reflect7", "rib1", "rc0", "rib01", "reflect1", "reflect0", "rib2", "rc01"], "src2": ["rc4", " src3", "src4", "dest3", "rc1", "dest4", "dest2", "rc2", "rc3", " src4", "dest1", "src3"], "unused": ["unwritten", "uncprotected", "unprotected", "unsprotected", "uninitialized", "uncwritten", "unalwritten", "uncused", "unalprotected", "uncinitialized", "unalinitialized", "unswritten", "unsinitialized", "unsused", "unalused"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lan9118_readl(void *opaque, target_phys_addr_t offset,\n\n                              unsigned size)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n\n\n    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);\n\n    if (offset < 0x20) {\n\n        /* RX FIFO */\n\n        return rx_fifo_pop(s);\n\n    }\n\n    switch (offset) {\n\n    case 0x40:\n\n        return rx_status_fifo_pop(s);\n\n    case 0x44:\n\n        return s->rx_status_fifo[s->tx_status_fifo_head];\n\n    case 0x48:\n\n        return tx_status_fifo_pop(s);\n\n    case 0x4c:\n\n        return s->tx_status_fifo[s->tx_status_fifo_head];\n\n    case CSR_ID_REV:\n\n        return 0x01180001;\n\n    case CSR_IRQ_CFG:\n\n        return s->irq_cfg;\n\n    case CSR_INT_STS:\n\n        return s->int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9255, "substitutes": {"opaque": ["obaque", "opacity", "opatile", "ipatile", "opac", " opsa", "opersa", "operacity", " opac", " opaques", "ipacity", "operatile", " opacity", "ipaque", "ipaques", "obacity", "obsa", "opsa", "operaque", " opatile", "obac", "opaques", "operaques", "operac"], "offset": ["parent", "seq", "location", "timeout", "base", "delay", "initial", "start", "axis", "operation", "len", "pad", "origin", "shift", "pointer", "buf", "data", "slot", "i", "addr", "p", "phase", "fp", "set", "sector", "afi", "skip", "number", "off", "args", "empty", "padding", "o", "alloc", "index", "slice", "format", "align", "aligned", "address", "position", "bytes", "bit", "type", "pos", "null", "ip", "length", "seed", "buffer", "Offset", "range", "reset"], "size": [" bytes", "len", " data", "SIZE", "ops", "data", " padding", " address", " offsets", "e", "Size", " unused", "padding", "o", " length", "flags", "bytes", " error", " flags", "a", "length", " sizes", "ize"], "s": ["l", "session", "its", "is", "m", "t", "gs", "sum", "parts", "set", "outs", "er", "plugins", "ies", "ns", "hs", "spec", "self", "ips", "settings", "ed", "erences", "ings", "sg", "ds", "si", "your", "sites", "sf", "ments", "b", "ists", "i", "c", "e", "request", "or", "sq", "f", "sym", "sets", "scope", "es", "r", "storage", "this", "u", "complete", "fs", "ps", "site", "comments", "ss", "ows", "ks", "g", "stats", "temp", "src", "small", "d", "ls", "local", "status", "socket", "os", "cs", "o", "sync", "south", "sl", "new", "als", "sb", "seconds", "sys", "ions", "side", "secondary", "a", "ssl", "conf", "ing", "ts", "rows", "in", "ools", "ims", "service", "ports", "p", "server", "qs", "tests", "ins", "xs", "rs", "js", "an", "aws", "S", "states", "services", "ctx", "ches", "address", "results", "ers", "ses"]}}
{"project": "FFmpeg", "commit_id": "c94d551ea7b39c4e467e146cd347c407e8eb38ee", "target": 0, "func": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride)\n\n{\n\n    PixletContext *ctx = avctx->priv_data;\n\n    GetBitContext *b = &ctx->gbit;\n\n    unsigned cnt1, nbits, k, j = 0, i = 0;\n\n    int64_t value, state = 3;\n\n    int rlen, escape, flag = 0;\n\n\n\n    while (i < size) {\n\n        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);\n\n\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 < 8) {\n\n            value = show_bits(b, nbits);\n\n            if (value <= 1) {\n\n                skip_bits(b, nbits - 1);\n\n                escape = ((1 << nbits) - 1) * cnt1;\n\n            } else {\n\n                skip_bits(b, nbits);\n\n                escape = value + ((1 << nbits) - 1) * cnt1 - 1;\n\n            }\n\n        } else {\n\n            escape = get_bits(b, 16);\n\n        }\n\n\n\n        value = -((escape + flag) & 1) | 1;\n\n        dst[j++] = value * ((escape + flag + 1) >> 1);\n\n        i++;\n\n        if (j == width) {\n\n            j = 0;\n\n            dst += stride;\n\n        }\n\n        state = 120 * (escape + flag) + state - (120 * state >> 8);\n\n        flag = 0;\n\n\n\n        if (state * 4 > 0xFF || i >= size)\n\n            continue;\n\n\n\n        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;\n\n        escape = av_mod_uintp2(16383, nbits);\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 > 7) {\n\n            rlen = get_bits(b, 16);\n\n        } else {\n\n            value = show_bits(b, nbits);\n\n            if (value > 1) {\n\n                skip_bits(b, nbits);\n\n                rlen = value + escape * cnt1 - 1;\n\n            } else {\n\n                skip_bits(b, nbits - 1);\n\n                rlen = escape * cnt1;\n\n            }\n\n        }\n\n\n\n        if (i + rlen > size)\n\n            return AVERROR_INVALIDDATA;\n\n        i += rlen;\n\n\n\n        for (k = 0; k < rlen; k++) {\n\n            dst[j++] = 0;\n\n            if (j == width) {\n\n                j = 0;\n\n                dst += stride;\n\n            }\n\n        }\n\n\n\n        state = 0;\n\n        flag = rlen < 0xFFFF ? 1 : 0;\n\n    }\n\n\n\n    align_get_bits(b);\n\n    return get_bits_count(b) >> 3;\n\n}\n", "idx": 9258, "substitutes": {"avctx": [" avxc", "Avcca", "AVcoll", "AVxc", "avbc", "avcoll", "AVcontext", "Avcoll", "ajctx", "ajcontext", "AVctx", " avcontext", "Avxc", "avcontext", "avxc", "Avbc", " avcca", "Avctx", "ajcoll", "AVcca", "AVbc", "ajbc", "avcca", "Avcontext"], "dst": ["dedst", "Dbl", "DST", "dbl", "dptr", "dput", "dedstream", "sST", " dput", "dnstream", "sput", "Dsts", "ndsts", "ndst", "defst", "dedsts", " dsts", "dnst", " dST", "dnsts", "Dst", " dbl", "adstream", "dnptr", "dsts", "defsts", "adsts", "ndbl", "ndST", "ssts", "dST", "dstream", "adptr", "sst", "adst", "defST", "dedptr", "defput"], "size": ["scale", "si", "len", "g", "small", "z", "SIZE", "s", "ffff", "loc", "Size", "sec", "code", "shape", "name", "six", "sized", "address", "en", "ci", "length", "ize", "core"], "stride": ["strange", "STRine", "stides", "drIDE", "STRid", "drides", "hride", "strid", "hrIDE", "brange", "strine", "bride", "strides", "hrides", "STRide", "strIDE", " strid", "STRides", "brIDE", "stid", " strides", "drange", "stide", "hrange", " strine", "stine", "brides", "dride"], "ctx": ["conf", "utils", "cam", "context", "cmp", "cca", "conn", "pa", "c", "cp", "ct", "p", "ref", "obj", "cb", "cf", "loc", "hw", "cc", "bc", "ctrl", "cv", "rc", "cas", "tx", "cl", "pc", "dc", "xc", "ca", "cm", " context", "ci", "lc", "anc", "buff", "pkg", "kb", "sc"], "b": ["l", "ib", "boot", "base", "bb", "nb", "g", "abb", "ba", "w", "m", "fr", "bar", "http", "ab", "wb", "d", "c", "fb", "bd", "p", "pb", "e", "obj", "gb", "cb", "B", "machine", "rb", "f", "body", "orb", "be", "bt", "db", "bf", "o", "bc", "eb", "lib", "bl", "v", "bh", "lb", "bis", "bi", "sb", "usb", "emb", "a", "ob", "comp", "bin", "ch", "func", "br", "bs", "xb", "buffer"], "cnt1": ["pcntOne", "Crt1", "CntOne", "cannot1", "cctOnce", "CNT1", "count2", "cnt31", "cot1", "CNT5", "CNTOnce", "CNTN", "CntFirst", "pcct1", "cntN", "acntOne", "pcntn", "CrtOne", "CNTFirst", "count3", "cont1", "acrtOne", "counter2", "crt1", "cNTX", "Cnt2", "cotFirst", "CntX", " cnt3", "count11", " cct2", "cNT1", "centX", "_", "crtOne", "cnt5", "crtOnce", "s", "Crt2", "cNT2", "counter1", "Cnt1", "cnt3", "cntX", "cctN", "r", "cNT5", "contn", "cntFirst", "cct5", " cnt2", "cct1", "CntOnce", "cct3", "acrt1", "cannot2", "pcnt1", "centN", " cct1", "acrtOnce", "cctX", "cont2", "contOnce", "cent2", "CNT2", "g", "Crt31", "pcctOne", " cnt11", "counter3", "cct31", "count1", "cnt2", "centOnce", "cannotOnce", "cntOnce", "crtFirst", "contOne", "CNTX", "countOne", "cent1", "cont31", "Cnt31", "crt31", "cNTFirst", "Cnt5", "cct11", " cct3", "CntN", "cnt11", "cent5", "cNTOne", "counter11", " cct11", "cNTOnce", "cNTN", "cctn", "acnt1", "acntn", "acrtn", "cNTn", "crt2", "CNTOne", "pcctn", "countn", "centOne", "cct2", "cntOne", "cannot5", "cctOne", "cotOne", "crtn", "cntn", "acntOnce"], "nbits": ["Nints", "Nlocks", "ynbits", "onhours", "nints", "nbytes", "nparts", "unblocks", "onbits", "numbytes", "ynbands", "jits", "netlines", "netits", "unlines", "netblocks", "nits", "numparts", " nints", "cbytes", "nbit", "Nparts", "npieces", " nbugs", "nboot", "Nplanes", "units", "Nhours", "numlines", " nits", "ynkeys", "inbits", "unbits", "infeatures", "Nits", "onlocks", "nbugs", "numplanes", "jfeatures", "ynpoints", "onplanes", " nfeatures", "unboot", "unnbits", "numits", "nplanes", "mnkeys", "unkeys", "numbits", "inpieces", "numbands", "Nfits", "jbits", "Nlines", " nlines", "jlines", "Nbits", "nfeatures", "Nbit", "cbit", "mnbits", "unnparts", "unnfits", " nbit", "numints", "ynints", " nblocks", "nlocks", " nbands", "cbits", "jbytes", "unpoints", "nlines", " nparts", "ynparts", "unnits", "nblocks", "nframes", "inparts", "numframes", " nhours", "Nfeatures", "mnboot", "Npieces", "jints", "mnpoints", " nframes", "nbands", "jbit", "netbits", " nbytes", "numbugs", "nfits", " nplanes", "numbit", "nhours", "ynboot", "Nbytes", "jframes", " nlocks", "nkeys", "jlocks", " nfits", "npoints", "ynfeatures", "ynbytes", "unbugs", " npieces"], "k": ["it", "n", "g", "key", "w", "id", "z", "d", "mask", "p", "e", "qa", "q", "f", "ie", "loss", "code", "o", "v", "r", "end", "K", "cost", "kw", "row", "y", "ki"], "value": ["parent", "media", "iv", "shift", "block", "python", "max", "reg", "values", "v", "content", "state", "end", "now", "offset", "kill", "type", "volume", "image", "buffer", "random", "element", "delay", "val", "ract", "view", "ba", "key", "w", "open", "total", "expression", "large", "unit", "ha", "index", "format", "current", "variable", "always", "complete", "gap", "partial", "one", "range", "fee", "map", "num", "buf", "data", "style", "array", "flow", "entry", "version", "wave", "gi", "ava", "native", "message", "dev", "attribute", "VALUE", "va", "area", "Value", "valid", "character", "scale", "start", "comment", "wa", "update", "job", "p", "we", "number", "serial", "slave", "child", "name", "event", "function", "cost", "null", "ault", "length"], "rlen": ["krlen", "arln", "irlen", " rbl", "rrli", " rrel", "dlength", "drel", "rLen", "rrlen", "rdl", "rden", "hden", "rrel", "dLen", "nrlen", "irLen", "hlin", "nrli", "drdl", "arlin", "irln", "drlen", " rlength", "flin", "krrel", "fln", "arlen", "rlength", "drLen", "hln", "nrLen", " rln", "arden", "krlength", "rrbl", "drln", " rli", "rrLen", " rdl", "rln", "flen", "rli", "dlen", "rbl", "irdl", " rLen", "nrbl", "fden", "hlen", "rlin", "krLen"], "escape": ["archive", "access", "shell", "shift", "ace", "script", "attr", "strip", "ec", "code", "race", "wait", "ce", "ride", "offset", "CAP", "expr", "buffer", "alias", "ee", "reason", "element", "delay", "rage", "view", "speed", "open", "control", "expression", "rule", "close", "layout", "adjust", "e", "sq", "slice", "eval", "variable", "cape", "error", "charge", "complete", "safe", "secure", "exec", "effect", "wrap", "quote", "style", "entry", "alpha", "shape", "command", "attribute", "cookie", "character", "scale", "comment", "update", "qa", "scape", "slave", "la", "child", "ea", "parse", "event", "guard", "address", "esc", "length", "match", "write"], "i": ["l", "ui", "di", "it", "n", "si", "m", "xi", "info", "id", "ini", "z", "x", "d", "c", "ji", "p", "ix", "uri", "e", "mini", "f", "j", "ai", "o", "index", "slice", "v", "gi", "mi", "ti", "phi", "ind", "qi", "pi", "bi", "ii", "I", "li", "ci", "ni", "io", "y", "ri", "fi", "iu", "ki"]}}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(s, &request);\n\n    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {\n\n        reply.error = errno;\n\n    } else {\n\n        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);\n\n    }\n\n    nbd_coroutine_end(s, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 9260, "substitutes": {"bs": ["vs", "base", "ds", "lbs", "bid", "bas", "b", "ab", "iss", "sa", "fb", "ls", "pb", "gb", "ins", "bits", "js", "BS", "os", "bc", "cs", "db", "bl", "bh", "las", "bis", "nas", "bi", "ns", "sb", "blocks", "ses", "fs", "ob", "ss", "bes", "bos"], "sector_num": ["sector2name", " sector_number", " sector_no", "sector2number", "section_number", "sector6number", "sector_count", "sector6num", "section_no", "sector6no", "sector2num", " sector_name", "sector2no", "sector_no", "sector6count", "section_num", "section_count", "sector_name", "sector_number"], "nb_sectors": ["nb_secctors", "nb_vectors", "nb_gections", "nb_seccs", "nb_secs", "nb_gectors", "nb_kegments", "nb_vections", "nb_segments", "nb_kectors", "nb_kellers", "nb_sections", "nb_vecs", "nb_sellers", "nb_kections", "nb_secctor", "nb_vector", "nb_gellers", "nb_vegments", "nb_secgments", "nb_gegments", "nb_sector", "nb_vellers"], "qiov": ["Qiov", "quodi", "quiov", "Qliv", "sqiov", "zliv", "quilib", "sqliv", "ziov", " qiev", " qliv", "ziev", "Qoyer", "qiev", " qoyer", "quliv", "qliv", "sqilib", "sqodi", "qilib", "Qiev", " qodi", "qoyer", "qodi", " qilib", "zoyer"], "offset": ["location", "reference", "timeout", "inet", "optional", "start", "len", "prefix", "i", "pointer", "phase", "shift", "slot", "from", "addr", "ref", "server", "fp", "set", "number", "off", "seek", "array", "padding", "o", "index", "size", "align", "address", "position", "error", "type", "online", "pos", "null", "length", "Offset", "range", "reset"], "s": ["session", "spot", "is", "ds", "g", "si", "n", "stats", "src", "http", "b", "t", "stat", "d", "i", "gs", "service", "c", "ops", "p", "e", "status", "private", "sq", "js", "socket", "os", "f", "an", "us", "sym", "o", "S", "sync", "south", "sie", "states", "sl", "state", "sup", "bis", "sb", "storage", "ns", "spec", "u", "sys", "h", "secondary", "ses", "su", "ss", "ssl"], "request": ["parent", "rf", "QUEST", "session", "reference", "base", "Request", "ry", "worker", "record", "id", "demand", "create", "post", "send", "config", "server", "work", "queue", "xml", "frame", "q", "push", "er", "next", "quest", "resource", "call", "child", "route", "input", "order", "query", "response", "name", "event", "req", "object", "address", "user", "repeat", "friend", "error", "read", "get", "type", "re", "pair", "allow", "command", "message", "report", "complete", "client", "rx", "use", "insert", "result", "have", "hello", "buffer", "transfer"], "reply": ["reason", "repl", "related", "base", "answer", "relation", "ry", "comment", " response", "prefix", "rr", "Reply", "send", "post", "notice", "service", "server", "queue", "lex", "respond", "repair", "entry", "echo", "route", "parse", "sync", "order", "flash", "response", "query", "proxy", "apply", "sup", "address", "resp", "maybe", "callback", "bot", "ping", "read", "link", "re", "sys", "report", "back", "ignore", "ret", "write", "match", "replace", "buffer", "transfer"]}}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int request_frame(AVFilterLink *link)\n\n{\n\n    AVFilterContext *ctx = link->src;\n\n    IDETContext *idet = ctx->priv;\n\n\n\n    do {\n\n        int ret;\n\n\n\n        if (idet->eof)\n\n            return AVERROR_EOF;\n\n\n\n        ret = ff_request_frame(link->src->inputs[0]);\n\n\n\n        if (ret == AVERROR_EOF && idet->cur) {\n\n            AVFrame *next = av_frame_clone(idet->next);\n\n\n\n            if (!next)\n\n                return AVERROR(ENOMEM);\n\n\n\n            filter_frame(link->src->inputs[0], next);\n\n            idet->eof = 1;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (!idet->cur);\n\n\n\n    return 0;\n\n}\n", "idx": 9282, "substitutes": {"link": ["ld", "l", "linked", "co", "base", "lf", "ack", "cmp", "comment", "sel", "conn", "info", "links", "http", "tag", "path", "pack", "post", "service", "block", "line", "ref", "ace", "hip", "local", "lex", "feed", "bug", "loc", "frame", "style", "ink", "call", "slice", "ck", "parse", "sync", "Link", "load", "friend", "pull", "plugin", "lock", "lang", "li", "ci", "url", "lc", "cell", "join", "kick", "light"], "ctx": ["conf", "context", "cca", "conn", "tc", "src", "instance", "container", "c", "cp", "ct", "config", "ref", "cb", "exec", "cf", "cn", "loc", "hw", "bc", "cc", "cs", "ctrl", "cv", "ck", "rc", "cas", "tx", "pc", "self", "ca", "cm", "ci", "vc", "cache", "lc", "cmd", "pkg", "mc", "sc", "fc"], "idet": [" ideting", "Idety", "idsen", "hdart", "hd\u00e9t", "idetic", "aidot", "indet", " idel", "dset", "ipeting", "Idet", " idety", " idest", "iden", "Id\u00e9t", "sdart", "Idel", "aidest", "idpt", "id\u00e9t", "sdet", "idest", "ipot", "intetic", " idot", "idart", " iden", "indety", "aidset", "Idoint", "hdet", "idspt", "idset", "idety", "idel", "idET", "aidet", " idetic", "Idest", "indel", " idpt", "hdoint", "intot", "det", "Idart", "dET", "Idetic", "Idot", " idset", " idET", "intpt", "ipen", "sd\u00e9t", "idseting", "idsot", "aidpt", "aidET", "idot", "indot", "dpt", "sdoint", "idoint", "intet", "ideting", "idsetic", "aidetic", "ipet"], "ret": ["bad", "flag", "active", "str", "alt", "val", "len", "ext", "fail", "def", "nt", "id", "Ret", "num", " Ret", "pat", "feat", "reply", "data", "ref", "arg", "lit", "reg", "value", "gt", "rets", "code", "rt", "res", "pub", "det", "rc", "fun", "att", "part", "art", "error", "bit", "cat", "re", "RET", " RET", "result", "ft", "match", "resp", "rev", "mt", "sr", "success", "pet"], "next": ["later", "parent", "dot", "seq", "follow", "start", "own", "again", "second", "conn", "nt", "open", "low", "missing", "page", "latest", "shift", "last", "more", "data", "head", "reply", "job", "prev", "fb", "obj", "other", "big", "target", "frame", "ec", "flow", "tmp", "sec", " Next", "code", "primary", "child", "foo", "name", "current", "future", "cur", "end", "new", "first", "desc", "now", "front", "Next", "self", "this", "business", "li", "ng", "result", "rev", "forward", "success", "chain"]}}
{"project": "FFmpeg", "commit_id": "a2085a7e9d83d99aca58bfb385f6db1afa5673dd", "target": 1, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n                             void *data, int *data_size,\n                             uint8_t *buf, int buf_size)\n{\n    DPCMContext *s = avctx->priv_data;\n    int in, out = 0;\n    int predictor[2];\n    int channel_number = 0;\n    short *output_samples = data;\n    int shift[2];\n    unsigned char byte;\n    short diff;\n    if (!buf_size)\n        return 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ROQ_DPCM:\n        if (s->channels == 1)\n            predictor[0] = AV_RL16(&buf[6]);\n        else {\n            predictor[0] = buf[7] << 8;\n            predictor[1] = buf[6] << 8;\n        }\n        SE_16BIT(predictor[0]);\n        SE_16BIT(predictor[1]);\n        /* decode the samples */\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n            predictor[channel_number] += s->roq_square_array[buf[in]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_INTERPLAY_DPCM:\n        in = 6;  /* skip over the stream mask and stream length */\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0])\n        output_samples[out++] = predictor[0];\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1])\n            output_samples[out++] = predictor[1];\n        }\n        while (in < buf_size) {\n            predictor[channel_number] += interplay_delta_table[buf[in++]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_XAN_DPCM:\n        in = 0;\n        shift[0] = shift[1] = 4;\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0]);\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1]);\n        }\n        while (in < buf_size) {\n            byte = buf[in++];\n            diff = (byte & 0xFC) << 8;\n            if ((byte & 0x03) == 3)\n                shift[channel_number]++;\n            else\n                shift[channel_number] -= (2 * (byte & 3));\n            /* saturate the shifter to a lower limit of 0 */\n            if (shift[channel_number] < 0)\n                shift[channel_number] = 0;\n            diff >>= shift[channel_number];\n            predictor[channel_number] += diff;\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_SOL_DPCM:\n        in = 0;\n        if (avctx->codec_tag != 3) {\n            if(*data_size/4 < buf_size)\n            while (in < buf_size) {\n                int n1, n2;\n                n1 = (buf[in] >> 4) & 0xF;\n                n2 = buf[in++] & 0xF;\n                s->sample[0] += s->sol_table[n1];\n                 if (s->sample[0] < 0) s->sample[0] = 0;\n                if (s->sample[0] > 255) s->sample[0] = 255;\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n                s->sample[s->channels - 1] += s->sol_table[n2];\n                if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0;\n                if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255;\n                output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8;\n            }\n        } else {\n            while (in < buf_size) {\n                int n;\n                n = buf[in++];\n                if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F];\n                else s->sample[channel_number] += s->sol_table[n & 0x7F];\n                s->sample[channel_number] = av_clip_int16(s->sample[channel_number]);\n                output_samples[out++] = s->sample[channel_number];\n                /* toggle channel */\n                channel_number ^= s->channels - 1;\n            }\n        }\n        break;\n    }\n    *data_size = out * sizeof(short);\n    return buf_size;\n}", "idx": 9283, "substitutes": {"avctx": ["afconn", "afctx", "avalcontext", "avalctx", "avcmp", "aircontext", "afcas", "afcmp", "avectx", "afcoll", "AVcup", "AVcmp", "evcontext", "avcoll", "avcup", "AVcontext", "aircmp", "airctx", "avconn", "AVconn", "AVctx", " avcontext", " avcoll", "avalconn", "avcontext", "evconn", " avconn", "avalcup", "evctx", "aveconn", "avecontext", "afcontext", "aircas", "avecup", "AVcas", "avcas", "evcoll"], "data": ["map", "sample", "base", "start", "len", "media", "window", "da", "pad", "b", "d", "block", "config", "p", "reader", "batch", "memory", "array", "tmp", "body", "DATA", "next", "dat", "device", "multi", "size", "input", "raw", "Data", "offset", "a", "image", "result", "cache", "buff", "bin", "buffer", "database"], "data_size": ["queue_size", "data_capacity", "data_source", "queue_strength", "data_strength", "queue_source", "queue_capacity"], "buf": ["img", "pool", "block", "fb", "config", "bd", "ref", "pb", "cb", "ux", "frame", "cap", "fam", "uv", "cas", "cur", "port", "text", "buff", "buffer", "box", "mac", "bb", "ba", "b", "que", "ab", "mem", "cf", "bc", "db", "msg", "input", "conv", "header", "comb", "bag", "grab", "map", "seq", "tab", "context", "src", "num", "wb", "band", "coord", "rb", "array", "flow", "alloc", "Buff", "aux", "wave", "bh", "home", "border", "func", "vec", "cmd", "br", "uc", "uf", "area", "Buffer", "window", "wav", "batch", "bu", "queue", "cv", "ctx", "bin", "feat"], "buf_size": ["buf_pos", "uf_pos", "buffer_size", "buffer_address", "buflexpos", "uf_depth", "buf_length", "uf_Size", "buf_depth", "uf_length", "uf_number", "buf_address", "bufallsize", "buf_number", "buf_loc", "bufalllength", "buflexSize", "buflexnumber", "buff_empty", "buff_loc", "buf_scale", "buflexsize", "bufalldepth", "uf_sized", "uf_size", "buffer_number", "buf_sized", "buf_Size", "bufallsized", "buff_size", "buffer_scale", "buff_length", "buf_empty"], "s": ["l", "session", "sg", "ts", "ks", "is", "g", "si", "m", "t", "b", "d", "i", "gs", "sa", "c", "service", "p", "ls", "e", "qs", "args", "sq", "js", "xs", "f", "os", "j", "cs", "sym", "o", "sets", "S", "v", "es", "space", "services", "r", "ns", "sb", "spec", "u", "sys", "self", "ses", "a", "ps", "su", "y", "ss", "site", "bs", "ssl", "sc"], "in": ["l", "channel", "again", "m", "x", "net", "pid", "config", "call", "isin", "connection", "err", "vin", "init", "url", "image", "lin", "rin", "In", "all", "key", "id", "inn", "i", "con", "c", "f", "index", "try", "input", "min", "ind", "en", "token", "read", "IN", "str", "len", "source", "like", "d", "login", "resource", "version", "size", "query", "old", "new", "part", "copy", "a", "nin", "pin", "pass", "it", "start", "win", "ini", "update", "rec", "line", "gin", "qa", "ins", "off", "inc", "name", "din", "inner", "pull", "inside", "pos", "bin", "tin", "ex"], "predictor": ["perjector", "predictore", "predictors", "pcriptour", "pcorrection", "predicton", "positour", "preredictor", "pcriptor", "ppectior", "predictable", "peredictar", "ppection", "priptrator", "predictior", "ptestor", " predictori", "pvarors", "ppredore", "pitnessOR", "ptestrator", "pictore", "precorrector", "ppectory", " predictator", "propributator", "prentler", "predicter", " predictible", "Ppectorer", "ppectier", "Predictor", "pcessori", "ppectler", "ptesttor", "predictier", "ppectar", "pcesslor", "perjectrator", "prepectore", "ppredible", "preredictar", "pripto", "ppredider", "pcorrectors", "perjectlor", "propributor", "ppredler", "plredictol", "Predictori", "ppredion", "pepredar", "psributee", "ppredator", " pcessior", "pacherore", " predictors", "predicto", "predictener", "pvictlor", "pconstructor", "plector", "plectlor", "peredictori", "pripttor", "ppectlor", "pjectlor", "previctier", "pributator", "predictory", "ppectors", "preacherOR", " pcessor", "pvaror", " ppredor", "ppectore", "predictour", "Predicto", "plloring", "pepredori", "plredictlor", "perredicttor", "predictar", "preredictider", "epredictour", "ppredee", "perredictor", "preredictutor", "preacherori", "ppredor", "propributour", " ppecter", "ppecter", "predicttor", "pjectrator", "pvarutor", " ppectar", "pveyore", "priptori", " predicter", "predictoring", "pributor", "pictrator", "predictorer", "picttor", "priptor", "pjectori", " ppredors", "ppredlor", "predictlor", "eposittor", "previctor", "previctori", "peredictlor", " pcessori", "pllor", "preredictors", "predictee", "pcessator", " pcessore", "pctors", "pcessior", "predictator", "prentible", "Ppector", "pvictator", " predictore", "pllectol", "precorrectori", "preredictori", "pcorrectori", "pvictour", "pcorrectlor", "pepredlor", "epredicttor", "pacherOR", "pitnessori", "epositor", "pcessore", "predictible", "prepectider", "pcessable", "propredictor", "pctour", "ppector", "padaptor", "pcesson", "pcorrectior", "psributor", "prepector", "priptlor", "preacherore", "padapter", "pepredor", "pvictors", " ppectoring", " prediction", "pcorrecter", "pcessoder", "pjecttor", "predictider", "predictrator", "perredictlor", "pributee", "previcter", " ppredion", "positener", "Ppectori", "Ppecto", "pcessor", "priptorer", "pconstructtor", "ppredar", "pcorrectrator", "pacherori", "perjecttor", "padaptoring", "ppredior", "psredictore", " pcessoder", "pcripttor", "propredictator", "prepectori", "ppectee", "predictoder", "psredictory", " predictable", "precorrectutor", "pributors", "prentori", "ppectider", "pvictor", "pllar", "pictori", "pconstructer", " ppector", "pitnessore", "pveyor", " predictoder", "ppecto", "pconstructener", "pvictori", "ppectator", "pjectable", "pvicter", "pctor", " predicttor", "ppectoring", "ppecton", "padaptar", "pllectore", "predictOR", "pictable", "pcriptener", "pvarori", " ppectori", "preredictore", "pacherar", "ptestore", " pcessable", " ppredior", "Predictorer", "plredictore", "precorrectors", "preredicter", "preredictOR", "ppectol", "epositour", "pictor", "ppectible", " predictrator", "pveyOR", " ppectler", "prepectar", "pributore", "peredictor", "prentor", "epredictor", "predictutor", " pcession", "pvictier", "prediction", "pvictol", "psributory", "epredictener", "pconstructour", "pconstructori", "pcession", "propredictors", "ppredory", "pctator", "predictol", "pcorrector", " pcesser", "predictori", "pictoder", "preacheror", "predictler", "pller", "preredicton", "ppectori", "ppredorer", "psredictee", "pjector", "pcessar", " predictler", "pcorrectutor", "pcorrectore", "ppectorer", "pributory", "pcorrecttor", "pitnessor", "pjectoder", "pllector", "plredictor", " pcessator", "posittor", "positor", "prepecton", "pveyori", " predictar", "pacheror", "psributore", "plectol", "ppredon", "pllectlor", "pconstructier", "pacherider", "ppredo", " ppectible", "ppredors", "propributors", "pributour", "ppredori", "pcesser", "plectore", "pvictore", " predictoring", "preredictier", "perredictrator", " predictior", "epositener", "propredictour", "ppectutor", "psredictor"], "output_samples": ["output_tamples", "output_sigs", "output_sores", "output_setsonents", "output_sributes", "output_timesamples", "output_bages", "output_timesigs", "output_setsamps", "output_tigs", "output_setsributes", "output_tonents", "output_samps", "output_setsamples", "output_specamps", "output_sages", "output_framesigs", "output_timesams", "output_pannels", "output_seriesages", "output_pamps", "output_tannels", "output_bributes", "output_seriesamps", "output_tams", "output_damples", "output_damps", "output_seriesamples", "output_sams", "output_framesamps", "output_bamps", "output_bamples", "output_pamples", "output_dores", "output_sannels", "output_tamps", "output_digs", "output_framesores", "output_specamples", "output_specams", "output_timesamps", "output_Sores", "output_Samples", "output_Sigs", "output_seriesributes", "output_setsannels", "output_setsages", "output_sonents", "output_Samps", "output_framesamples", "output_ponents", "output_specigs"], "shift": ["count", "scale", "workers", "worker", "pad", "pack", "chip", "total", "mask", "batch", "config", "max", "push", "padding", "slice", "shape", "master", "align", "raw", "pull", "offset", "pos", " shifts", "extra", "image", "seed", "transfer"], "byte": ["channel", "bb", "val", "word", "piece", "b", "letter", "pointer", "block", "binary", "unit", "slice", "Byte", "bytes", "bit", "null", "ip", "image", "bin", "buffer"], "diff": [" dup", "channel", " label", "len", "id", " difference", " split", " remaining", " padding", " gain", " beta", " align", " distance", " bias", " boundary", " extra", " unused", " unknown", " mismatch", " temp", " len", " stride", " delta", " error", " rank", " change"], "out": ["parent", "channel", "timeout", "In", "win", "again", "key", "all", "no", "conn", "outer", "Out", "to", "id", "net", "x", "num", "post", "i", "pool", "con", "c", "max", "output", "p", "server", "arg", "at", "outs", "off", "ac", "call", "o", "index", "version", "inc", "sync", "name", "input", "connection", "query", "min", "req", "inner", "user", "err", "new", "part", "OUT", "error", "bit", "init", "pos", "client", "not", "null", "image", "bin", "io", "extra", "cmd", "IN", "ex"], "channel_number": ["channel\u00a0\n", "channelOnum", "channelingnb", "channel_maximum", "channel_major", "channelingmaximum", " channel_document", "gapernumber", "channelpsize", " channel_num", "gap_name", "channelJexpression", "channelPnumber", "channelxmaximum", "channel_no", "channelJnb", "channelOno", "channel_group", "variable_function", "channelPfunction", "channelxname", "channelpnumber", "channelingno", "channelerexpression", "channelIdnumber", "channelpnumbered", "channelername", "variable_number", "message_state", "channelxnumber", "channel_class", "channelalgroup", "channelalcollection", " channel_class", "channel_token", " channel_numbered", "chan_numbered", "channelernb", "channelIdclass", " channel_collection", "variable_class", "channel_duration", "channelingfunction", "channelernumber", "gapernb", "message_maximum", "variableingclass", "channelingnumber", "channelOduration", "channelIdfunction", "channelPclass", "channel_state", " channel_no", "channelingmajor", "channel_num", "channel_collection", "chan_size", "chan_number", "message_name", "channel_expression", "channel_numbered", "channelingname", "gapername", "channelIdmajor", "channel_name", "variableingnumber", "channelOnumber", "message_number", "channelingdocument", " channel_size", "channelPmajor", "channelptoken", "gaperexpression", "channel_\n", "gap_expression", "variableingmajor", "messagexmaximum", "channelJnumber", " channel_duration", "variableingfunction", "channel_document", "channelingstate", "channelalnumbered", "messagexstate", " channel_group", "channelJname", "channelalnumber", "channel_size", " channel_\n", "gap_number", "messagexname", " channel_nb", "channel_nb", "gap_nb", "channelingclass", "channelxstate", "channel_function", "chan_token", "messagexnumber", "variable_major"]}}
{"project": "FFmpeg", "commit_id": "03abf55f252945c70f4a79eaf4d609cee4d98710", "target": 1, "func": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n\n                              AVStream *st, RMStream *rst,\n\n                              unsigned int codec_data_size, const uint8_t *mime)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    if (codec_data_size > INT_MAX)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n\n\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n\n        int number_of_streams = avio_rb16(pb);\n\n        int number_of_mdpr;\n\n        int i;\n\n        for (i = 0; i<number_of_streams; i++)\n\n            avio_rb16(pb);\n\n        number_of_mdpr = avio_rb16(pb);\n\n        if (number_of_mdpr != 1) {\n\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n\n        }\n\n        avio_rb32(pb);\n\n        v = avio_rb32(pb);\n\n    }\n\n\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n\n        int stream_count, rule_count, property_count, i;\n\n        ff_free_stream(s, st);\n\n        if (avio_rb16(pb) != 0) {\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n\n            goto skip;\n\n        }\n\n        stream_count = avio_rb16(pb);\n\n        avio_skip(pb, 6*stream_count);\n\n        rule_count = avio_rb16(pb);\n\n        avio_skip(pb, 2*rule_count);\n\n        property_count = avio_rb16(pb);\n\n        for(i=0; i<property_count; i++){\n\n            uint8_t name[128], val[128];\n\n            avio_rb32(pb);\n\n            if (avio_rb16(pb) != 0) {\n\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n\n                goto skip; //FIXME skip just this one\n\n            }\n\n            get_str8(pb, name, sizeof(name));\n\n            switch(avio_rb32(pb)) {\n\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n\n                av_dict_set(&s->metadata, name, val, 0);\n\n                break;\n\n            default: avio_skip(pb, avio_rb16(pb));\n\n            }\n\n        }\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        if (fps > 0) {\n\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n\n                      0x10000, fps, (1 << 30) - 1);\n\n#if FF_API_R_FRAME_RATE\n\n            st->r_frame_rate = st->avg_frame_rate;\n\n#endif\n\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 9301, "substitutes": {"s": ["sp", "utils", "sg", "sv", "ds", "si", "g", "sf", "src", "b", "t", "sci", "ops", "gs", "sa", "c", "service", "p", "ls", "sq", "types", "f", "os", "plugins", "cs", "es", "sts", "sie", "sl", "services", "r", "bis", "sb", "storage", "ns", "spec", "sys", "scl", "client", "ses", "fs", "ps", "bs", "settings", "ssl", "sc"], "pb": ["lp", "dp", "uf", "wp", "bb", "pg", "bp", "prot", "pl", "lab", "bm", "b", "ab", "wb", "pa", "bs", "pp", "fb", "p", "pd", "cb", "fp", "gb", "txt", "pro", "pt", "rb", "pm", "parser", "bc", "dl", "bt", "db", "bf", "eb", "py", "bps", "bh", "phrase", "ctx", "lb", "tp", "jp", "sb", "pc", "PB", "asm", "cpp", "hub", "plugin", "platform", "api", "fc", "ob", "xb", "pkg", "rob", "typ", "bos", "vp"], "st": ["ld", "l", "sp", "ts", "std", "sv", "ds", "str", "start", "est", "ust", "sf", "stage", "nt", "fr", "src", "rest", "t", "sw", "d", "post", "sa", "ct", "ad", "p", "stream", "obj", "stack", "stab", "set", "ost", "pt", "stop", "f", "ut", "inst", "bt", "nd", "sts", "sta", "sl", "state", "end", "ist", "sth", "kt", "sn", "ste", "put", "elt", "sb", "pc", "art", "sd", "ast", "St", "et", "ST", "ft", "mt", "ss", "td", "sc"], "rst": ["rstream", " rstream", "Rstream", "rgST", "rgsc", "ersc", " rsts", "erst", "srstream", "Rst", "Rsts", "srsc", "erST", "rtd", "srsts", "srst", "ertd", " rtd", "rgtd", " rsc", "rST", "rsts", "Rsc", "rsc", " rST", "rgst"], "codec_data_size": ["codec_window_length", "codec_dat_size", "codec_data_format", "codec_window_size", "codec_data_width", "codec_data_length", "codec_data_scale", "codec_dat_format", "codec_dat_capacity", "codec_window_scale", "codec_data_capacity"], "mime": [" mimes", "tmile", "Mimes", " mapped", "Mapped", "Mime", "amimes", "MIME", "mame", " mame", "amime", "mile", "tmIME", "amame", "tmimes", "mimes", "Mame", "amapped", " mile", "mapped", "tmime", " mIME", "amIME", "Mile", "mIME"], "v": ["vs", "l", "vi", "vert", "sv", "n", "g", "lv", "vid", "m", "t", "k", "b", "x", "iv", "ve", "d", "vt", "ver", "c", "ov", "limit", "p", "e", "tv", "value", "q", "f", "j", "ev", "vol", "nv", "cv", "format", "uv", "r", "conv", "V", "en", "u", "vr", "h", "vv", "ant", "rev", "volt", "vp"], "size": ["l", "n", "len", "si", "small", "x", "SIZE", "c", "p", "e", "loc", "Size", "f", "code", "unit", "sent", "en", "desc", "enc", "pos", "ize"], "codec_pos": ["codec_position", "codef_loc", "codecspos", "codef_pos", "codoc_position", "codef_position", "codec_start", "codec_len", "codecsposition", "codecslen", "codoc_pos", "codec_loc", "codoc_len", "codef_start"], "ret": ["bad", "flag", "alt", "len", "fail", "def", "id", "nt", "Ret", "mem", "red", "reply", "data", "ref", "arg", "lit", "status", "reg", "rets", "code", "rt", "res", "lib", "det", "rc", "fun", "att", "rep", "error", "re", "cat", "RET", "back", "out", "result", "rev", "mt", "match", "resp", "success", "pet"], "number_of_mdpr": ["number_of_mondPr", "number_of_mondrx", "number_of_mdPr", "number_of_MDrs", "number_of_MDPR", "number_of_mdrx", "number_of_ndPr", "number_of_amdpr", "number_of_amdPr", "number_of_ndrx", "number_of_mmrx", "number_of_ddpr", "number_of_ddrs", "number_of_MDPr", "number_of_ndPR", "number_of_mmPR", "number_of_mmPr", "number_of_mmrs", "number_of_MDpr", "number_of_ndrs", "number_of_mdr", "number_of_mondpr", "number_of_amdPR", "number_of_mondr", "number_of_ndpr", "number_of_mmpr", "number_of_amdrs", "number_of_mmr", "number_of_ndr", "number_of_ddPr", "number_of_mdPR", "number_of_ddPR", "number_of_mdrs"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "n", "si", "in", "m", "xi", "b", "x", "ini", "d", "uli", "c", "ji", "p", "ix", "e", "mu", "eni", "q", "f", "ie", "j", "ai", "multi", "index", "gi", "ti", "phi", "mi", "chi", "abi", "qi", "inner", "pi", "ii", "I", "li", "pos", "ip", "ci", "ni", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "abda1f37eed86f3501db2e5439c1a7b97171ea22", "target": 1, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status &= ~COM_CRC_ERROR;\n\n        return 0;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n    if (sd->card_status & ILLEGAL_COMMAND)\n\n        rsplen = 0;\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 9330, "substitutes": {"sd": ["sp", "dk", "gd", "fd", "ad", "bd", "config", "esi", "dist", "dn", "sk", "sy", "dl", "vd", "dis", "hd", "dm", "od", "ed", "ld", "sg", "ds", "si", "sf", "fr", "sam", "s", "cd", "se", "nd", "ind", "ic", "md", "sth", "SD", "sim", "li", "su", "site", "lc", "sc", "sem", "des", "sh", "di", "std", "sv", "conn", "model", "d", "sa", "gb", "cod", "df", "os", "dat", "sync", "sta", "south", "sl", "sn", "sb", "dev", "report", "vc", "td", "sed", "ui", "dt", "service", "pd", "lib", "sie", "dd", "cm", "api", "ci", "ses", "wd"], "req": ["rf", "sem", "dq", " request", "conf", "ru", "seq", "Request", "proc", "def", "org", "src", "fr", "http", "rr", "require", "gr", "rec", "ra", "serv", "config", "ref", "reader", "uri", "cb", "reg", "request", "dist", "rb", "ir", "sq", "q", "f", "quest", "rt", "res", "resource", "requ", "progress", "release", "ctr", "query", "r", "ctx", "err", "desc", "spec", "required", "ro", "rx", "report", "client", "rg", "result", "cmd", "sr", "resp", "ri", "rh", "exec"], "response": ["sp", "des", "session", "answer", " resp", "json", "def", "application", "view", "model", "onse", "sw", "serv", "service", "respons", "reply", "data", "server", "output", "uri", "e", "status", "request", "esi", "respond", "df", "f", "given", "res", "resource", "v", "description", "es", "connection", "subject", "state", "example", "r", "object", "document", "err", "en", "Response", "error", "report", "Resp", "message", "api", "su", "ret", "result", "image", "site", "cache", "resp", "success"], "rtype": ["rrtype", "srvar", "cTYPE", "cclass", " rref", "rType", "rname", "rarid", "cty", "ptype", "pval", "rcname", "rrref", "rval", "ctype", "rTYPE", "rty", "rartype", "rrid", "rctype", "rcstat", "srby", "srname", "rarType", "arclass", "rcTYPE", "rrby", "rcty", "rcval", "rrType", "pstat", "artype", "rcclass", "arty", " rType", "rid", "rarref", "srtype", "pname", "rref", "rstat", "rrvar", "rclass", "srid", "srstat", " rid", "rvar", " rby", "rby", "arTYPE", " rvar", "srval"], "rsplen": ["raspaloen", "rsfen", "rsbllen", "arsplen", "rsblien", "rsslens", "rsprfen", "rspalenc", "rssleng", "rsphen", "rsplens", "raspeen", "rsfilens", "rsphun", "rspaleng", "rsseleng", "lsplens", "rsPLon", "rspacen", "rsfilen", "rspeened", "rsslun", "lspleng", "rsprenn", "arsplien", "rasplfen", "rssellen", "raspleng", "rsseln", "raspalenn", "rsfilreen", "rspacened", "rasplatten", "rspheng", "rasslon", "rssplenn", "rslens", "rsoploen", "rsplreen", "raspeonen", "rasplun", "rsproen", "arssleng", "rsppens", "rspllen", "rsselreen", "rsblen", "rspeatten", "rsfonen", "arssllen", "rssplen", "rsplonen", "lslens", "rsoplen", "rasplened", " rsseln", "rsphened", "rspaconen", " rsselon", "rsselen", "rspln", "rsPLen", " rsselenn", "lslenc", "arspleng", "rsfatten", "rspaloen", " rsplon", "rspleng", "raspalfen", "rsppeng", "rspalenn", " rspln", "rsplun", "rasplon", "raspalen", "rspren", "rsPLn", "rasploen", "lsleng", "rasslun", "rsblon", "rassllen", "rasslen", "rasplonen", "rsspln", "rsplened", "rspacatten", "rspeen", "rspeonen", "rsploen", "rasslens", "rsfened", "rsplien", "rsselens", "rspalens", "rsspleng", "rasplreen", " rsplenn", "rasslreen", "rsselened", "rsbleng", " rsselen", "rsppenc", "rsspllen", "rsslreen", "rasplens", "rsplfen", "rsoplenn", "lsplen", "lsplenc", "rsslon", "arsslen", "raspeatten", "rsplenc", "lslen", "rslenc", "rsslen", "rsPLenn", "raspllen", "rsleng", "rasslened", "rslen", "rspalen", "rsplon", "rsllen", "arsslien", "rspalfen", "rsselun", "rslien", "rassleng", "rssplon", "rasplenn", "arspllen", "rsfillen", "rssllen", "rasplen", "rsslien", "rsoplfen", "rsplatten", "rsppen", "rsplenn", "rsselon", "rsselenn", "rsslened", "raspeened"]}}
{"project": "FFmpeg", "commit_id": "76db17dc7d4f19f9a03bdd6de79c2ea37b76888f", "target": 0, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DPCMContext *s = avctx->priv_data;\n\n    int in, out = 0;\n\n    int predictor[2];\n\n    int ch = 0;\n\n    int stereo = s->channels - 1;\n\n    short *output_samples = data;\n\n    int shift[2];\n\n    unsigned char byte;\n\n    short diff;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    // almost every DPCM variant expands one byte of data into two\n\n    if(*data_size/2 < buf_size)\n\n        return -1;\n\n\n\n    switch(avctx->codec->id) {\n\n\n\n    case CODEC_ID_ROQ_DPCM:\n\n        if (stereo) {\n\n            predictor[0] = buf[7] << 8;\n\n            predictor[1] = buf[6] << 8;\n\n        } else {\n\n            predictor[0] = AV_RL16(&buf[6]);\n\n        }\n\n        SE_16BIT(predictor[0]);\n\n        SE_16BIT(predictor[1]);\n\n\n\n        /* decode the samples */\n\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n\n            predictor[ch] += s->roq_square_array[buf[in]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n\n\n    case CODEC_ID_INTERPLAY_DPCM:\n\n        in = 6;  /* skip over the stream mask and stream length */\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0])\n\n        output_samples[out++] = predictor[0];\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1])\n\n            output_samples[out++] = predictor[1];\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            predictor[ch] += interplay_delta_table[buf[in++]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n\n\n        break;\n\n\n\n    case CODEC_ID_XAN_DPCM:\n\n        in = 0;\n\n        shift[0] = shift[1] = 4;\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0]);\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1]);\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            byte = buf[in++];\n\n            diff = (byte & 0xFC) << 8;\n\n            if ((byte & 0x03) == 3)\n\n                shift[ch]++;\n\n            else\n\n                shift[ch] -= (2 * (byte & 3));\n\n            /* saturate the shifter to a lower limit of 0 */\n\n            if (shift[ch] < 0)\n\n                shift[ch] = 0;\n\n\n\n            diff >>= shift[ch];\n\n            predictor[ch] += diff;\n\n\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n    case CODEC_ID_SOL_DPCM:\n\n        in = 0;\n\n        if (avctx->codec_tag != 3) {\n\n            if(*data_size/4 < buf_size)\n\n                return -1;\n\n            while (in < buf_size) {\n\n                int n1, n2;\n\n                n1 = (buf[in] >> 4) & 0xF;\n\n                n2 = buf[in++] & 0xF;\n\n                s->sample[0] += s->sol_table[n1];\n\n                if (s->sample[0] < 0)   s->sample[0] = 0;\n\n                if (s->sample[0] > 255) s->sample[0] = 255;\n\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n\n                s->sample[stereo] += s->sol_table[n2];\n\n                if (s->sample[stereo] < 0)   s->sample[stereo] = 0;\n\n                if (s->sample[stereo] > 255) s->sample[stereo] = 255;\n\n                output_samples[out++] = (s->sample[stereo] - 128) << 8;\n\n            }\n\n        } else {\n\n            while (in < buf_size) {\n\n                int n;\n\n                n = buf[in++];\n\n                if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F];\n\n                else s->sample[ch] += s->sol_table[n & 0x7F];\n\n                s->sample[ch] = av_clip_int16(s->sample[ch]);\n\n                output_samples[out++] = s->sample[ch];\n\n                /* toggle channel */\n\n                ch ^= stereo;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    *data_size = out * sizeof(short);\n\n    return buf_size;\n\n}\n", "idx": 9343, "substitutes": {"avctx": ["afconn", "afctx", "afcup", "avcmp", "avehw", " avhw", "afcmp", "avectx", "AVcmp", "avsci", "avcup", "AVcontext", "avconn", "ajctx", "ajcontext", "AVconn", "ajqa", "apctx", " avcontext", "AVctx", "avcontext", "afsci", "avesci", "avhw", "afhw", "afqa", " avcup", "avecontext", "aveqa", "afcontext", "apconn", "avqa", "avecup", "ajsci", "apcmp", "apcontext"], "data": ["sample", "channel", "base", "start", "frames", "len", "val", "window", "media", "pad", "da", "d", "block", "batch", "p", "reader", "config", "output", "queue", "value", "memory", "frame", "array", "tmp", "empty", "body", "DATA", "next", "dat", "multi", "size", "slice", "input", "connection", "content", "raw", "address", "audio", "Data", "pos", "client", "message", "a", "video", "image", "cache", "result", "buff", "length", "buffer", "database"], "data_size": ["data\u00b7size", "data\u00b7depth", "data\u00b7capacity", "data_scale", "window_size", "data_capacity", "data_width", "window_scale", "buffer_size", "data_form", "window_capacity", "buffer_scale", "data_depth", "data\u00b7scale", "window_depth", "buffer_form", "buffer_width"], "avpkt": ["avcpk", "afpacket", "afpk", "avPkg", "afpka", "avfka", "avpacket", "avcpacket", "afPk", "afpkg", "avfacket", "affacket", "afPkt", "avfkt", "afcpkt", "avPct", "avtkt", "avPk", "afcpct", "avcpkg", "avcpka", "avtct", "avPkt", "avfct", "avpka", "afPacket", "avfunch", "avcpkt", "avppk", "avpct", "affunch", "avppacket", "avcpct", "afpkt", "avpkg", "avtunch", "afpct", "avtacket", "afPkg", "affct", "avPacket", "affkt", "avppkg", "avppct", "afcpka", "afpunch", "avPunch", "avppka", "afcpacket", "avpk", "avpunch", "avppkt"], "buf": ["bag", "grab", "uf", "seq", "arr", "bb", "img", "context", "uber", "tab", "window", "abb", "pad", "src", "auc", "b", "que", "ab", "brace", "wav", "pool", "feat", "block", "fb", "batch", "config", "bu", "c", "coord", "cb", "bd", "queue", "np", "cf", "gb", "usr", "loc", "array", "bc", "alloc", "cv", "v", "cap", "aux", "fam", "uv", "Buff", "home", "cur", "conv", "ctx", "fab", "port", "bytes", "band", "av", "border", "result", "vec", "buff", "br", "proc", "cmd", "text", "buffer", "bin", "box", "uc"], "s": ["conf", "sg", "ks", "context", "sv", "is", "si", "g", "m", "t", "b", "ops", "d", "i", "gs", "sa", "c", "p", "e", "sq", "rs", "f", "os", "cs", "sym", "o", "S", "v", "sync", "space", "south", "sl", "services", "ctx", "sup", "r", "bis", "sb", "ns", "storage", "spec", "u", "sys", "comm", "client", "soc", "ses", "ps", "a", "su", "ss", "ssl", "sc"], "in": ["count", "l", "again", "ax", "record", "x", "ac", "call", "v", "isin", "connection", "vin", "init", "lin", "image", "rin", "In", "key", "all", "id", "trial", "b", "k", "inn", "i", "con", "c", "before", "f", "index", "try", "ind", "input", "min", "r", "en", "token", "margin", "cl", "IN", "str", "len", "source", "like", "num", "d", "login", "head", "resource", "version", "size", "old", "part", "a", "nin", "pin", "pass", "it", "start", "win", "ini", "update", "rec", "line", "gin", "p", "ins", "inc", "name", "din", "inner", "pull", "inside", "pos", "bin", "gen", "tin"], "predictor": ["pictedier", "fredictore", "promjector", "promredictter", " practor", "predictore", "ppreduser", "predictors", "pvictitor", "practori", "promredictlor", "pvictors", "predictitor", " prediction", "fpredator", "ppredractor", "priptractor", "pconstructio", "pruptore", "predictar", "fredictor", "Predictation", "ppreder", "prepectlor", "posteror", "appictedcer", "preredictor", "pjectuser", "fredictors", "pcriptor", "pictedor", "ppectior", "pacherior", "ppredor", "fredictorb", "ppection", "pcripter", "predictior", "Pvictor", "ppecter", "fpredorb", "pensler", "tpripttor", "pritor", "penser", "tpriptoder", "priptors", "predicttor", "tpredictor", "pritior", " predictori", "paitnesscer", "fredictori", "pcorrectcer", "tpredicttor", "pritore", " pruptorn", "pcriptore", " predictorn", "fpredor", "pripter", "ppredore", "pcessor", "priptier", "promredictior", "presentor", "predictutor", " practori", "fpectore", "promributior", "priptori", " practitor", " pcession", " predicter", "promjectuser", "prediction", "promjectter", "pcriptler", "pruptcer", "pributor", "precorrector", " predictator", "pensore", "ppredar", "pcession", "pacherlor", " ppectior", "preredictlor", "Predictors", "pruptorn", "predicter", "priptor", "pacherori", "predictorn", "ppredlor", "practore", "predictlor", "Predictor", "pceptori", "predictractor", "priptore", "paitnessor", "ppredior", " predictitor", "pruptor", "pributlor", "predictcer", " ppectore", "previctor", "ppectler", "pcorrector", "pcessori", "paredictor", "promjectore", " practore", "Pvictation", " pcesser", "predictori", "pvictar", "ppectar", "previctori", "predictier", " pcessori", "pruptior", "pcessors", " pruptore", "priptation", " penser", "prepectori", "presentuser", "presentore", "predictler", "predictuser", "tprediction", "predictoder", "appredictor", "priptio", "ppectori", "prepectore", "pjector", "paitnessio", " predictler", "paitnesslor", "pceptitor", "posteroder", "Pvictors", "promredictor", "promributlor", "predictation", "pcorrectore", "pcessator", "preredictar", "priptorb", "pictedractor", "practor", " pensore", "previctore", "pcorrectors", "pceptor", "pcisionor", "pconstructlor", "pcessior", "Pvicter", "fpredors", "predictator", "pcisionore", "preredictcer", "ppredoder", "appictedor", "postertor", " pruptior", "predictorb", "pitnessor", " predictore", "precorrectore", "ppectorb", "pjectter", "ppectorn", "precorrectori", "pvictor", "priptoder", "pription", "preredictori", "ppredion", "paredictlor", "pvictation", "ppredator", "previctar", "ppredcer", "pcorrectori", "pacherore", "pitnesscer", "fpectori", " predictors", " ppector", "pictedcer", "precorrectcer", "promredictore", "tpription", "pvictori", " pensler", "pjectore", "pributior", " ppectator", "paredictcer", "presentter", "ppectator", "ppredorb", "pruptori", "appredictcer", "appredictier", "pitnessio", "pconstructor", "pitnesslor", "priptcer", " ppectors", "pacheror", "pvicter", "pcessore", "pceptore", "fpectutor", "paredictio", "pripttor", "ppectlor", "priptator", "fredictator", "ppredors", "fpector", "appredictractor", "promributuser", "promributor", "pconstructcer", "predictter", "pritorn", "appictedractor", "pributuser", "ppredtor", "ppector", "posterion", "pcisionori", " ppectori", "pcorrectior", "preredictore", "tpredictoder", "pensor", "ppredori", "pacheruser", "practitor", "pcesser", "pcisionutor", "predictio", "tpriptor", "pvictore", "promredictuser", "ppectors", "prepector", "priptlor", " pensor", "ppredier", " pcessor", " pruptor", " predictior", "appictedier", "fredictutor", "ppectutor", "Predicter", "ppectore"], "output_samples": ["output_tamples", "output_tords", "output_sributes", "output_typesributes", "output_insannels", "output_dides", "output_bolutions", "output_dipes", "output_insamples", "output_Sords", "output_typesolutions", "output_sords", "output_typesamples", "output_linesamps", "output_sipes", "output_tipes", "output_linesamples", "output_insords", "output_sides", "output_salls", "output_samps", "output_typesamps", "output_bributes", "output_linesributes", "output_palls", "output_pannels", "output_talls", "output_solutions", "output_tannels", "output_polutions", "output_pamps", "output_seriesamps", "output_damples", "output_seriesamples", "output_bamps", "output_bannels", "output_bamples", "output_pamples", "output_pipes", "output_pides", "output_sannels", "output_tamps", "output_Sannels", "output_Samples", "output_seriesannels", "output_tides", "output_linesolutions", "output_Samps", "output_seriesolutions", "output_dalls", "output_insamps"], "shift": ["sh", "img", "scale", "pad", "cut", "pack", "chip", "mask", "config", "batch", "set", "push", "slice", "ctr", "shape", "hift", "cap", "align", " chunk", "err", "pull", "offset", "form", "extra", "seed", "transfer", "range"], "byte": ["channel", "bb", "val", "word", "piece", "letter", "block", "binary", "unit", "slice", " channel", " chunk", "Byte", "bytes", "bit", "copy", "null", "ip", "image", "bin", "buffer"], "diff": [" gap", " dup", "channel", " label", " contrast", " difference", " ecc", " digest", " dist", " align", " distance", " bias", " boundary", " differences", " unused", " mask", " mismatch", " shape", " temp", "err", " dev", " phase", " error", " exponent", " disp"], "out": ["parent", "channel", "timeout", "pass", "again", "all", "w", "no", "conn", "id", "Out", "version", "key", "b", "net", "x", "post", "i", "c", "line", "output", "p", "server", "arg", "at", "off", "outs", "q", "j", "call", "o", "size", "index", "v", "inc", "sync", "ind", "name", "input", "connection", "min", "req", "inner", "user", "err", "new", "OUT", "part", "error", "bit", "init", "pos", "client", "on", "not", "io", "bin", "cmd", "null", "IN", "pin", "ex"], "ch": ["count", "channel", "conf", "chrom", "sh", "ach", "ph", "conn", "fr", "ich", "chip", "ver", "i", "c", "qu", "cp", "batch", "och", "chu", "p", "app", "chn", "gh", "CH", "q", "cho", "f", "sk", "j", "code", "zh", "cs", "inst", "th", "cht", "cha", "che", "ky", "cher", "bh", "cur", "chi", "err", "sch", "cl", "cor", "col", "Ch", "h", "change", "client", "ci", "y", "cell", "chan", "kick", "cy"]}}
{"project": "FFmpeg", "commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 9347, "substitutes": {"s": ["vs", "setup", "l", "sg", "ts", "ks", "sv", "frames", "is", "your", "g", "ds", "si", "m", "t", "ops", "gs", "service", "c", "i", "p", "ls", "qs", "cli", "gb", "ins", "se", "parts", "e", "js", "sq", "rs", "f", "os", "share", "cs", "sym", "sets", "S", "es", "sync", "scope", "space", "series", "v", "sche", "services", "bis", "ns", "spec", "cpp", "u", "sys", "comm", "sim", "self", "ses", "ps", "fs", "site", "ss", "settings", "ssl"], "frame": ["setup", "pse", "element", "Frame", "scale", "frames", "window", "scene", "m", "figure", "game", "rame", "panel", "data", "line", "fram", "p", "draw", "e", "motion", "cf", "coll", "flow", "sequence", "f", "fl", "o", "slice", "process", "series", "state", "feature", "iframe", "object", "document", "flower", "file", "image", "fi", "fe", "dy"], "value": ["parent", "Value", "scale", "rate", "val", "media", "depth", "record", "view", "method", "m", "model", "w", "b", "update", "z", "shift", "data", "rule", "mask", "limit", "p", "action", "memory", "number", "array", "flow", "values", "version", "size", "v", "format", "wave", "current", "content", "feature", "function", "cost", "position", "offset", "bit", "u", "change", "message", "charge", "image", "result", "write", "weight", "one", "buffer", "VALUE"], "run": ["round", "man", "un", "pass", "rate", "len", "g", "win", "trial", "id", "running", "plot", "k", "num", "con", "block", "c", "head", "config", "max", "thread", "runs", "q", "flow", "step", "f", "unit", "index", "race", "version", "sync", "ride", "spin", "min", "r", "fun", "orig", "bit", "lock", "Run", "cycle", "loop", "row", "use", "image", "write", "weight", "force", "day", "nn"], "x": ["l", "axis", "n", "ax", "key", "w", "m", "xx", "t", "z", "b", "page", "i", "data", "c", "line", "X", "p", "ix", "e", "pixel", "q", "f", "index", "size", "v", "bit", "u", "h", "xy", "layer", "pos", "px", "a", "image", "dx", "dy", "ex"], "y": ["l", "oy", "n", "g", "w", "m", "ny", "xi", "t", "k", "z", "b", "vy", "i", "ey", "ye", "c", "cy", "p", "e", "iy", "ish", "ay", "zy", "f", "yy", "sy", "gy", "o", "py", "v", "sky", "ky", "Y", "ty", "pi", "col", "u", "type", "h", "xy", "ya", "yn", "dy", "yo"], "plane": ["orient", "lane", "level", "scale", "axis", "rate", "g", "key", "m", "board", "plot", "xi", "k", "page", "direction", "z", "c", "line", "limit", "mask", "p", "e", "se", "pe", "planes", "drop", "q", "flow", "group", "f", "mode", "rot", "unit", "fl", "o", "slice", "size", "module", "zone", "order", "age", "port", "pen", "position", "u", "fly", "charge", "ane", "row", "image", "core", "flat", "plan", "weight", "force", "day", "pin"], "bits_per_plane": ["bits_per_ane", "bits_permmplane", "bits_per_lane", "bits_permmane", "bits_perPageplane", "bits_permmline", "bits_per_flight", "bits_perPagelayer", "bits_per_plan", "bits_per_day", "bits_per_planes", "bits_permmlane", "bits_per_layer", "bits_perPagelane", "bits_per_line", "bits_perPageline"], "d": ["dp", "diff", "l", "dim", "di", "dh", "ds", "n", "g", "dict", "w", "m", "dt", "fd", "b", "t", "z", "k", "i", "data", "c", "ad", "p", "e", "q", "dn", "f", "df", "dl", "dat", "o", "v", "ind", "md", "dd", "dc", "sd", "u", "dy", "h", "dx", "D"], "j": ["l", "dim", "adj", "n", "section", "start", "g", "m", "xi", "fr", "jet", "k", "dj", "z", "b", "i", "job", "ne", "ji", "el", "p", "jo", "e", "obj", "js", "f", "ie", "uj", "child", "o", "py", "v", "jit", "ind", "ij", "jp", "part", "ja", " i", "u", "aj", "lock", "h", "xy", "li", "J", "io", "ni", "jl", "jj", "dy"]}}
{"project": "FFmpeg", "commit_id": "aaf78e4d14b4875e4cff30e979421a1087337b9f", "target": 1, "func": "mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){\n\n    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));\n\n  mp_image_t* mpi=NULL;\n\n  int w2;\n\n  int number = mp_imgtype >> 16;\n\n\n\n  av_assert0(vf->next == NULL); // all existing filters call this just on next\n\n\n\n  //vf_dint needs these as it calls vf_get_image() before configuring the output\n\n  if(vf->w==0 && w>0) vf->w=w;\n\n  if(vf->h==0 && h>0) vf->h=h;\n\n\n\n  av_assert0(w == -1 || w >= vf->w);\n\n  av_assert0(h == -1 || h >= vf->h);\n\n  av_assert0(vf->w > 0);\n\n  av_assert0(vf->h > 0);\n\n\n\n  av_log(m->avfctx, AV_LOG_DEBUG, \"get_image: %d:%d, vf: %d:%d\\n\", w,h,vf->w,vf->h);\n\n\n\n  if (w == -1) w = vf->w;\n\n  if (h == -1) h = vf->h;\n\n\n\n  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;\n\n\n\n  // Note: we should call libvo first to check if it supports direct rendering\n\n  // and if not, then fallback to software buffers:\n\n  switch(mp_imgtype & 0xff){\n\n  case MP_IMGTYPE_EXPORT:\n\n    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.export_images[0];\n\n    break;\n\n  case MP_IMGTYPE_STATIC:\n\n    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[0];\n\n    break;\n\n  case MP_IMGTYPE_TEMP:\n\n    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.temp_images[0];\n\n    break;\n\n  case MP_IMGTYPE_IPB:\n\n    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:\n\n      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n      mpi=vf->imgctx.temp_images[0];\n\n      break;\n\n    }\n\n  case MP_IMGTYPE_IP:\n\n    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];\n\n    vf->imgctx.static_idx^=1;\n\n    break;\n\n  case MP_IMGTYPE_NUMBERED:\n\n    if (number == -1) {\n\n      int i;\n\n      for (i = 0; i < NUM_NUMBERED_MPI; i++)\n\n        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)\n\n          break;\n\n      number = i;\n\n    }\n\n    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;\n\n    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h);\n\n    mpi = vf->imgctx.numbered_images[number];\n\n    mpi->number = number;\n\n    break;\n\n  }\n\n  if(mpi){\n\n    mpi->type=mp_imgtype;\n\n    mpi->w=vf->w; mpi->h=vf->h;\n\n    // keep buffer allocation status & color flags only:\n\n//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);\n\n    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;\n\n    // accept restrictions, draw_slice and palette flags only:\n\n    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);\n\n    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;\n\n    if(mpi->width!=w2 || mpi->height!=h){\n\n//      printf(\"vf.c: MPI parameters changed!  %dx%d -> %dx%d   \\n\", mpi->width,mpi->height,w2,h);\n\n        if(mpi->flags&MP_IMGFLAG_ALLOCATED){\n\n            if(mpi->width<w2 || mpi->height<h){\n\n                // need to re-allocate buffer memory:\n\n                av_free(mpi->planes[0]);\n\n                mpi->flags&=~MP_IMGFLAG_ALLOCATED;\n\n                mp_msg(MSGT_VFILTER,MSGL_V,\"vf.c: have to REALLOCATE buffer memory :(\\n\");\n\n            }\n\n//      } else {\n\n        } {\n\n            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;\n\n        }\n\n    }\n\n    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);\n\n    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){\n\n\n\n        av_assert0(!vf->get_image);\n\n        // check libvo first!\n\n        if(vf->get_image) vf->get_image(vf,mpi);\n\n\n\n        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){\n\n          // non-direct and not yet allocated image. allocate it!\n\n          if (!mpi->bpp) { // no way we can allocate this\n\n              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,\n\n                     \"vf_get_image: Tried to allocate a format that can not be allocated!\\n\");\n\n              return NULL;\n\n          }\n\n\n\n          // check if codec prefer aligned stride:\n\n          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){\n\n              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&\n\n                         mpi->flags&MP_IMGFLAG_YUV) ?\n\n                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME\n\n              w2=((w+align)&(~align));\n\n              if(mpi->width!=w2){\n\n#if 0\n\n                  // we have to change width... check if we CAN co it:\n\n                  int flags=vf->query_format(vf,outfmt); // should not fail\n\n                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,\"??? vf_get_image{vf->query_format(outfmt)} failed!\\n\");\n\n//                printf(\"query -> 0x%X    \\n\",flags);\n\n                  if(flags&VFCAP_ACCEPT_STRIDE){\n\n#endif\n\n                      mpi->width=w2;\n\n                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n//                  }\n\n              }\n\n          }\n\n\n\n          mp_image_alloc_planes(mpi);\n\n//        printf(\"clearing img!\\n\");\n\n          vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);\n\n        }\n\n    }\n\n    av_assert0(!vf->start_slice);\n\n    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)\n\n        if(vf->start_slice) vf->start_slice(vf,mpi);\n\n    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){\n\n            mp_msg(MSGT_DECVIDEO,MSGL_V,\"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\\n\",\n\n                  \"NULL\"/*vf->info->name*/,\n\n                  (mpi->type==MP_IMGTYPE_EXPORT)?\"Exporting\":\n\n                  ((mpi->flags&MP_IMGFLAG_DIRECT)?\"Direct Rendering\":\"Allocating\"),\n\n                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?\" (slices)\":\"\",\n\n                  mpi->width,mpi->height,mpi->bpp,\n\n                  (mpi->flags&MP_IMGFLAG_YUV)?\"YUV\":((mpi->flags&MP_IMGFLAG_SWAPPED)?\"BGR\":\"RGB\"),\n\n                  (mpi->flags&MP_IMGFLAG_PLANAR)?\"planar\":\"packed\",\n\n                  mpi->bpp*mpi->width*mpi->height/8);\n\n            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\",\n\n                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],\n\n                mpi->stride[0], mpi->stride[1], mpi->stride[2],\n\n                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);\n\n            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;\n\n    }\n\n\n\n  mpi->qscale = NULL;\n\n  }\n\n  mpi->usage_count++;\n\n//    printf(\"\\rVF_MPI: %p %p %p %d %d %d    \\n\",\n\n//      mpi->planes[0],mpi->planes[1],mpi->planes[2],\n\n//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);\n\n  return mpi;\n\n}\n", "idx": 9349, "substitutes": {"vf": ["svf", "svrf", "svfe", "verfo", "vfen", "svfc", "ffs", "avf", "evcf", "evb", "vcf", " vrf", "svfo", "wcf", "ffb", "ervfen", "nvrf", "fb", "udfile", "wrf", "evf", " vfi", "nvcf", "vfile", "udf", "vfa", "evfen", "Vf", "ivfen", "avfen", "avfs", "vvfer", " vconf", "avfile", "vvcf", " vc", "verrf", "ovcf", "vp", "antfi", " vfer", "ovfen", "antcf", "avc", "vorf", "vfb", "convfs", "convcf", "vfer", "ivfs", "vorfer", "vfor", "volrf", "fcf", "evfc", "antf", "nvf", "Vfs", "svfa", "vfi", "vfo", " vfe", "wfs", "vrfs", "svfs", "vercf", "vorrf", "ovconf", "vb", "svfen", "ivcf", "svfor", "nvfile", " vfen", "ff", "avp", "volfor", "avcf", "wb", "ovfa", "udcf", "navfa", "wf", "volfs", "ivf", "evfs", " vfb", " vfile", "vrf", "vfs", "navf", "verfs", "vfc", "vvrf", "svfile", "ovrf", "svconf", "antfs", "vc", "ervf", "svc", " vb", "evrf", " vfor", "verf", "convfo", " vp", "vvf", "vfe", "Vcf", "vconf", "ervcf", "ovf", "svcf", "vrcf", "vrfe", "wfb", "volf", "udp", "convf", "avrf", "svfer", "vorcf", "navcf", " vcf", "Vc", " vfc", "svfi", "ervrf", "avfer", "navfen", " vfs", "svb"], "outfmt": ["outdefMT", " outfnc", "outFns", "outFnc", " outFns", "outfunmt", "outFMT", " outfns", " outFnc", " outfMT", "outfunns", "outdefns", "outdefmt", "outfMT", "outfns", "outfunnc", " outFMT", " outFmt", "outfnc", "outfunMT", "outdefnc", "outFmt"], "mp_imgtype": ["mp__imagtype", "mp_imstyle", "mp_bgtype", "mp_bgstyle", "mp__imginfo", "mp_ngType", "mp_imagecount", "mp_imgype", "mp_extType", "mp_imagestyle", "mp_iminfo", "mp_imginfo", "mp_imgType", "mp_imagstyle", "mp_ngtype", "mp_ngstyle", "mp_imgcount", "mp_exttype", "mp_bgype", "mp_imType", "mp_extstyle", "mp_imagetype", "mp_imtype", "mp_imgstyle", "mp_imageType", "mp_imagtype", "mp_imagcount", "mp__imgcount", "mp_ngype", "mp__imaginfo", "mp_bgType", "mp__imgtype", "mp__imagstyle", "mp_imageinfo", "mp_imageype", "mp_imaginfo", "mp_imcount", "mp__imagcount", "mp_extype", "mp_imype", "mp__imgstyle"], "mp_imgflag": ["mp_alignstyle", "mp_bgtype", "mp_imageflags", "mp_imgflags", "mp_ngtype", "mp_bgbit", "mp_imagstyle", "mp_imagebit", "mp_bgflags", "mp_imgstring", "mp_exttype", "mp_imagflag", "mp_imgbit", "mp_alignstring", "mp_ngbit", "mp_aligntype", "mp_extstyle", "mp_imagetype", "mp_imagstring", "mp_imgstyle", "mp_ngflag", "mp_extflag", "mp_extstring", "mp_imagtype", "mp_bgflag", "mp_alignflag", "mp_imageflag", "mp_ngflags"], "w": ["wl", "l", "wn", "wid", "sh", "wp", "n", "g", "wa", "win", "window", "rw", "word", "wh", "b", "x", "sw", "z", "fw", "d", "wt", "wb", "t", "c", "work", "p", "we", "wed", "nw", "wal", "wo", "hw", "f", "q", "wy", "way", "v", "wave", "wall", "wx", "wan", "kw", "aw", "u", "ww", "wi", "ew", "y", "W", "weight", "ow", "wd", "tw"], "h": ["l", "hi", "sh", "hat", "ht", "he", "n", "g", "hr", "ph", "wa", "hh", "ul", "hz", "wh", "b", "x", "t", "z", "k", "his", "d", "history", "c", "s", "work", "p", "hm", "e", "gh", "q", "hw", "f", "height", "host", "j", "o", "ha", "th", "v", "bh", "ih", "home", "r", "how", "hs", "oh", "kh", "hd", "u", "H", "hl", "length", "ah", "y", "ch", "rh", "uh"], "m": ["l", "man", "mac", "mn", "n", "g", "bm", "b", "t", "mm", "gm", "d", "c", "vm", "p", "e", "machine", "f", "manager", "j", "mp", "o", "module", "v", "mi", "r", "md", "mod", "mut", "sm", "ms", "tm", "u", "dm", "cm", "mt", "M"], "mpi": [" mpiu", "MPit", "mpI", "MPI", "mmI", "mmi", "mbi", "mpci", "epi", "mpit", "mpid", "epf", "epc", "mpiu", " mpii", "MPi", " mpid", "MPid", "MPf", "epiu", "mpc", "mbiu", "mpf", "MPci", "mbii", "epI", "mmci", " mpit", "mmid", " mpc", "mpii", "epii", " mpci", " mpf", "epit", "mbc", " mpI"], "w2": ["ws2", "ww2", " w1", "w0", "sw2", "w6", "wa6", "wa4", "wa2", "wb1", "w1", "wa1", "ws4", "wbTwo", "W2", "ww6", "w3", "sw1", "wa3", "wb0", "ww1", " w6", "h3", "h0", "hTwo", "waTwo", "w4", " wTwo", "W4", "ws1", "W1", "h2", "h1", "swTwo", "sw3", " w0", "wb2", "wTwo"]}}
{"project": "FFmpeg", "commit_id": "e630ca5111077fa8adc972fe8a3d7e2b3e8dc91f", "target": 1, "func": "static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)\n\n{\n\n    Mp4Descr *descr = d->active_descr;\n\n    int predefined;\n\n    if (!descr)\n\n        return -1;\n\n\n\n    predefined = avio_r8(&d->pb);\n\n    if (!predefined) {\n\n        int lengths;\n\n        int flags = avio_r8(&d->pb);\n\n        descr->sl.use_au_start       = !!(flags & 0x80);\n\n        descr->sl.use_au_end         = !!(flags & 0x40);\n\n        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);\n\n        descr->sl.use_padding        = !!(flags & 0x08);\n\n        descr->sl.use_timestamps     = !!(flags & 0x04);\n\n        descr->sl.use_idle           = !!(flags & 0x02);\n\n        descr->sl.timestamp_res      = avio_rb32(&d->pb);\n\n                                       avio_rb32(&d->pb);\n\n        descr->sl.timestamp_len      = avio_r8(&d->pb);\n\n\n\n\n\n\n        descr->sl.ocr_len            = avio_r8(&d->pb);\n\n        descr->sl.au_len             = avio_r8(&d->pb);\n\n        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);\n\n        lengths                      = avio_rb16(&d->pb);\n\n        descr->sl.degr_prior_len     = lengths >> 12;\n\n        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;\n\n        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;\n\n    } else {\n\n        avpriv_report_missing_feature(d->s, \"Predefined SLConfigDescriptor\");\n\n\n    return 0;\n", "idx": 9351, "substitutes": {"d": ["ld", "l", "gd", "di", "mad", "dh", "ds", "n", "dom", "did", "g", "in", "dict", "da", "w", "m", "id", "dt", "fd", "dos", "t", "b", "z", "k", "i", "c", "ad", "s", "bd", "p", "data", "e", "pd", "cd", "du", "dn", "f", "dr", "dl", "ded", "db", "dat", "o", "j", "xd", "nd", "ind", "md", "r", "mod", "dd", "vd", "dc", "sd", "u", "dm", "h", "dy", "grad", "od", "del", "dad", "td", "D"], "off": [" family", " cap", " output", " clen", "ff", " mode", " offset", " Off", "ops", " pos", " offsets", "offs", " on", " unused", " def", " op", " ins", " feat", " bits", "offset", " fo", "Off", " coff", " lo", " OFF", " buff"], "len": ["seq", "n", "alt", " clen", "val", "all", "def", "mem", "el", " Len", " length", "size", "min", "name", "fun", "en", "spec", "fn", "pos", "length", "Len", "vec", "gen", "ln"], "descr": ["descorr", "desro", "diffr", " descsr", "distrs", "criptsr", "deser", "constrs", " descer", "decr", "escrf", "desre", "descrs", "descrc", "hyprs", "scra", " descrs", "declrf", "hyprator", "accr", "descrr", "descnr", "hypr", "catr", "suprator", "escn", "decor", "escrs", "escrc", "reqrs", " descar", "wardre", "accra", " descor", "catrs", " descrator", "scrs", "Descr", "diffn", "escsr", "descru", "cator", "Descrn", "declr", "declar", "descrator", "reqro", "escru", "distrb", " descrr", " descro", "Descrb", "docrs", "desr", "constre", "descn", "Descsr", "distr", "descor", " descrn", "descsr", " descorr", "scsr", "structnr", "scr", "escorr", " descrf", "decpr", "declnr", "catpr", "Descre", "distrn", "Descrs", "decrs", "reqsr", "criptre", " descrc", "descre", "escr", "structrs", "declorr", "constrc", " descra", "cripter", "hypsr", "descrf", "descpr", "constru", " descn", "reqr", "escro", "descar", "diffrator", "wardsr", "structrr", "descrn", "accsr", "escnr", "escer", "diffro", "diffre", "descrb", "desru", "supr", "escrb", "criptr", "docre", "constr", "declrs", "declro", "desrs", " descnr", "descra", " descru", "desrb", "structr", "accrs", "supre", "desar", " descpr", "decler", "descer", "dessr", "descro", "suprs", "docrator", "wardr", "wardru", "escrator", " descre", "docr", "diffrs", "escrr", "constrator", "Descer", " descrb"], "predefined": ["pedetermined", " predef", "Predicated", " predetermined", "pedefined", "Prediscovered", "predicated", "predef", "condefined", "condef", "condicated", "redicated", "rediscovered", "Predetermined", " preddefined", "reddefined", "peddefined", "condetermined", "prediscovered", "predetermined", "pedicated", " prediscovered", "Predef", "redefined", "redef", "redetermined", "Predefined", "preddefined", " predicated"], "lengths": ["thes", "ravelstyles", "feedls", "lengthits", " lengthes", "controlches", "Lengthches", "feedp", "lengthches", "engthes", "ohl", "engthi", "lengthi", "feedes", "Lengthits", "controlstyles", "ravels", " lengthports", "feeds", "engths", "lengthes", "lengthports", "engthen", "controlits", "Lengthports", "widths", "lengthl", "ohs", "controls", " lengthls", "ohes", "lengthen", "Lengthstyles", "lengthstyles", " lengthi", "ravelits", "widthes", "Lengths", "Lengthen", "widthl", "lengthp", "thports", "Lengthi", " lengthp", "feedl", "ths", "lengthls", "widthls", "widthp", "ravelches", " lengthen", "Lengthes"]}}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 9352, "substitutes": {"env": ["conf", "qt", "eur", "ext", "dict", "shell", "conn", "viron", "environment", "config", "server", "obj", "e", "target", "erv", "txt", "esi", "ep", "gui", "priv", "eni", "global", "np", "manager", "db", "console", "profile", "exc", "v", "state", "loader", "err", "en", "enh", "eng", "Environment", "here", "enc", "emb", "et", "dev", "her", "ah", "eu"], "r1": ["r01", "R4", "b3", "ar2", "t1", "b1", "ar3", "R2", "r4", "t3", "R1", "ar4", " r4", "r3", "R3", "result01", "ar1", "t01", "result1", "b01", " r3", "result3"], "r2": ["rSecond", "l2", "R4", " r0", "l0", "l1", "R0", "r0", "array2", "arraytwo", "l4", "rtwo", " rii", "R2", "arrayii", "arraySecond", "r4", "rii", "R1", " rtwo", " r4", "Rii", "RSecond", " rSecond", "Rtwo"]}}
{"project": "FFmpeg", "commit_id": "ec79b1fc88b2cc6a9ab6cd953efcdbaebedde233", "target": 1, "func": "static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr)\n\n{\n\n    WtvContext *wtv = s->priv_data;\n\n    AVIOContext *pb = wtv->pb;\n\n    while (!url_feof(pb)) {\n\n        ff_asf_guid g;\n\n        int len, sid, consumed;\n\n\n\n        ff_get_guid(pb, &g);\n\n        len = avio_rl32(pb);\n\n        if (len < 32)\n\n            break;\n\n        sid = avio_rl32(pb) & 0x7FFF;\n\n        avio_skip(pb, 8);\n\n        consumed = 32;\n\n\n\n        if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) {\n\n            if (ff_find_stream_index(s, sid) < 0) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 28);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, 0, sid, mediatype, subtype, formattype, size);\n\n                consumed += 92 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_stream2_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size);\n\n                consumed += 76 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t buf[258];\n\n                const uint8_t *pbuf = buf;\n\n                int buf_size;\n\n\n\n                avio_skip(pb, 8);\n\n                consumed += 8;\n\n                if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                    !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) {\n\n                    avio_skip(pb, 6);\n\n                    consumed += 6;\n\n                }\n\n\n\n                buf_size = FFMIN(len - consumed, sizeof(buf));\n\n                avio_read(pb, buf, buf_size);\n\n                consumed += buf_size;\n\n                ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL);\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                int audio_type;\n\n                avio_skip(pb, 8);\n\n                audio_type = avio_r8(pb);\n\n                if (audio_type == 2)\n\n                    st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n\n                else if (audio_type == 3)\n\n                    st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                consumed += 9;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 12);\n\n                if (avio_rl32(pb))\n\n                    av_log(s, AV_LOG_WARNING, \"DVB scrambled stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n                consumed += 16;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t language[4];\n\n                avio_skip(pb, 12);\n\n                avio_read(pb, language, 3);\n\n                if (language[0]) {\n\n                    language[3] = 0;\n\n                    av_dict_set(&st->metadata, \"language\", language, 0);\n\n                    if (!strcmp(language, \"nar\") || !strcmp(language, \"NAR\"))\n\n                        st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                }\n\n                consumed += 15;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_timestamp_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 8);\n\n                wtv->pts = avio_rl64(pb);\n\n                consumed += 16;\n\n                if (wtv->pts == -1)\n\n                    wtv->pts = AV_NOPTS_VALUE;\n\n                else {\n\n                    wtv->last_valid_pts = wtv->pts;\n\n                    if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch)\n\n                        wtv->epoch = wtv->pts;\n\n                if (mode == SEEK_TO_PTS && wtv->pts >= seekts) {\n\n                    avio_skip(pb, WTV_PAD8(len) - consumed);\n\n                    return 0;\n\n                }\n\n                }\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_data_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (mode == SEEK_TO_DATA && stream_index >= 0 && len > 32 && s->streams[stream_index]->priv_data) {\n\n                WtvStream *wst = s->streams[stream_index]->priv_data;\n\n                wst->seen_data = 1;\n\n                if (len_ptr) {\n\n                    *len_ptr = len;\n\n                }\n\n                return stream_index;\n\n            }\n\n        } else if (!ff_guidcmp(g, /* DSATTRIB_WMDRMProtectionInfo */ (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0)\n\n                av_log(s, AV_LOG_WARNING, \"encrypted stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n        } else if (\n\n            !ff_guidcmp(g, /* DSATTRIB_CAPTURE_STREAMTIME */ (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PBDATAG_ATTRIBUTE */ (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PicSampleSeq */ (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_TRANSPORT_PROPERTIES */ ff_DSATTRIB_TRANSPORT_PROPERTIES) ||\n\n            !ff_guidcmp(g, /* dvr_ms_vid_frame_rep_data */ (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelChangeSpanningEvent */ (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelInfoSpanningEvent */ (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelTypeSpanningEvent */ (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) ||\n\n            !ff_guidcmp(g, /* EVENTID_PIDListSpanningEvent */ (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) ||\n\n            !ff_guidcmp(g, /* EVENTID_SignalAndServiceStatusSpanningEvent */ (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) ||\n\n            !ff_guidcmp(g, /* EVENTID_StreamTypeSpanningEvent */ (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) ||\n\n            !ff_guidcmp(g, ff_index_guid) ||\n\n            !ff_guidcmp(g, ff_sync_guid) ||\n\n            !ff_guidcmp(g, ff_stream1_guid) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) {\n\n            //ignore known guids\n\n        } else\n\n            av_log(s, AV_LOG_WARNING, \"unsupported chunk:\"FF_PRI_GUID\"\\n\", FF_ARG_GUID(g));\n\n\n\n        avio_skip(pb, WTV_PAD8(len) - consumed);\n\n    }\n\n    return AVERROR_EOF;\n\n}\n", "idx": 9366, "substitutes": {"s": ["l", "sp", "session", "is", "m", "t", "sci", "gs", "parser", "plugins", "v", "bis", "ns", "spec", "self", "sg", "ds", "si", "n", "sites", "sf", "b", "c", "e", "sq", "types", "us", "f", "sym", "sets", "es", "r", "sup", "u", "sim", "comments", "fs", "su", "ps", "ss", "sc", "ks", "sv", "ops", "d", "sa", "data", "ls", "os", "cs", "sync", "sl", "sn", "sb", "sys", "secondary", "a", "ssl", "fts", "setup", "ts", "in", "service", "p", "server", "qs", "ins", "xs", "rs", "S", "services", "ctx", "support", "client", "ses", "bs"], "mode": [" p", "Mode", "dim", "scale", "perm", " mem", " modes", "m", " m", "mem", "c", "mask", " perm", "MODE", "format", "name", "r", "mod", " bits", " flags", " prog", "gen", " type"], "seekts": [" exta", " extes", "acttd", "actte", " exte", "acttes", "wpte", "actta", "wptes", "wpta", " extd", "wptd"], "len_ptr": ["len2pointer", " len_pointer", " len_tr", " len64ptr", "len64pointer", "len64ptr", "len_tr", " len_pt", "len_pointer", " len64pt", "len2tr", "len2pt", " len64pointer", "len64tr", "len_pt", "len2ptr", "len64pt", " len64tr"], "wtv": [" wsv", " wv", "swtv", "swdev", "wv", "wcv", "wdev", " wvt", "wwvt", "wwdev", "iwtv", "wvt", "iwdev", " wcv", "iwvt", "Wdev", "Wcv", "iwsv", "wwsv", "swv", "Wv", "swcv", "Wtv", "wsv", " wdev", "wwtv"], "pb": ["lp", "dp", "uf", "ib", "wp", "ppa", "pg", "bb", "proc", "abb", "fe", "bp", "prot", "pl", "lab", "bm", "b", "ab", "wb", "pa", "pp", "bs", "cp", "fb", "p", "pd", "cb", "fp", "gb", "ub", "pm", "rb", "parser", "bc", "vp", "dl", "fm", "bf", "mp", "db", "eb", "bps", "bh", "phrase", "ctx", "lb", "jp", "tp", "sb", "pc", "PB", "asm", "summary", "cpp", "hub", "plugin", "platform", "mb", "api", "ob", "xb", "pkg", "rob", "typ", "kb", "bos", "fc"], "g": [" msg", "gn", "gu", "sg", "gd", "gat", "m", "go", "conn", "t", "game", "gm", " eg", "tg", "gs", "c", "gin", " generator", "p", "gain", "generation", "gl", "reg", " mg", "gener", " G", "gb", "gp", "yg", "group", "f", "G", "eg", "bg", "msg", "ig", "og", "gi", "gg", " pg", "ic", "r", " group", "ga", "groups", "alg", "lang", "gc", "cfg", "h", " prog", "vg", "rg", "gz", "gen", " gen", "gram"], "len": ["count", "l", "seq", "lf", "n", "val", "lif", "id", "lim", "fd", "num", "data", "el", "ls", "lit", "gl", "split", "loc", "la", "dl", "code", "fl", "bl", "ll", "syn", "sl", "sil", "en", "fin", "fn", "hl", "li", "pos", "lon", "length", "bin", "Len", "lc", "lan", "ann", "ln", "lin"], "sid": ["channel", "session", "vid", "x", "pid", "uri", "feed", "sk", "syn", "end", "offset", "spec", "ity", "seed", "buffer", "dim", "ds", "si", "_", "id", "oin", "c", "sam", "addr", "sym", "scope", "msg", "token", "desc", "uin", "su", "gap", "sample", "seq", "source", "conn", "src", "uid", "sa", "data", "cod", "socket", "mid", "oa", "sl", "sn", "sb", "side", "chrom", "start", "pack", "skin", "kid", "name", "sil", "ident", "sd", "uni", "pos", "sit", "typ"], "consumed": ["consipped", " consipped", " unconsessed", "persumed", "continumed", " consended", "nsume", "unsipped", "persipped", "continumption", "presumption", "consumes", "cosipped", "continume", "consume", " unconsuming", "unsessed", "presuming", "persessed", "nsumed", "presume", "cosumed", "consessed", " unconsended", "nsumption", "consuming", "unsuming", "nsuming", "cosended", "persuming", "consumption", " consumes", "consended", " unconsumed", "presumed", "cosumes", " unconsipped", "continuming", " unconsumes", "unsumed"], "mediatype": ["mediantype", "medialype", "mediatingotype", "metasype", "mediaattype", "medietypes", "medietyp", "metatopic", "mediaratypes", "servatyp", "mediantopic", "mediaettype", "medietid", "metasopic", "datadid", "mediantypes", "mediatyp", "mediasopic", "mediaatype", "mediarattype", "metatpe", "datadype", "mediaetyp", "mediasiotype", "mediasiyp", "mediatid", "medialopic", "metaspe", "medietype", "servatingotype", "mediadype", "metasime", "datadtype", "mediasiopic", "mediaype", "datadypes", "servatotype", "mediaetype", "mediasime", "mediaatypes", "medialyp", "servatingyp", "mediaantype", "mediartyp", "mediastype", "mediatypes", "mediape", "datatid", "mediaid", "mediaatyp", "mediaatopic", "mediantime", "mediayp", "mediatopic", "mediatpe", "mediadtype", "mediaanttype", "servatype", "servatingopic", "mediantpe", "medianttype", "datatype", "servatopic", "mediaypes", "mediaatid", "mediasype", "mediaetid", "mediarttype", "mediasiype", "mediaopic", "metatype", "servatingype", "mediaantypes", "mediatotype", "datattype", "datatypes", "mediettype", "mediadypes", "mediatime", "mediartid", "mediadid", "mediatingyp", "medialotype", "mediaratid", "metatime", "mediaime", "mediaspe", "mediaantopic", "mediaratype", "mediattype", "mediatingopic", "mediatingype", "mediasypes", "mediartype"], "subtype": ["ubid", "ubtypes", " subname", "subtypes", "extype", "parttypes", "subid", "Subname", "singname", "formatid", "shorttype", "formblock", "singid", "shortname", "formatname", " subparent", "partype", "textname", "subname", "subblock", "exttype", "extid", "singtypes", "formatparent", "textparent", "formatype", "broadtypes", " subid", "subype", "ubtype", "subparent", " subtypes", "formtype", "formype", "Subtype", "ubname", "shortype", "textype", "Subype", "texttype", "broadype", "formatblock", "Subid", "parttype", " subype", "formattypes", "shortid", "singtype", "formid", "broadtype", "extblock"], "formattype": ["cattype", "titletype", " formatid", "versiontype", "typeblock", "typefamily", "partstyle", "subformat", "formatstyle", "subid", "formatid", "formatfamily", "titleblock", "catformat", "formatname", "formatType", "partype", "subname", "unittype", "typetype", "versionType", "titlename", "formname", "titlefamily", "formatype", "typeid", "subype", " formatblock", "formype", "formtype", " formatType", "substyle", "unitype", " formatfamily", "formatblock", "parttype", " formatname", " formatype", "subType", "versionype", "typeype", "typename", "unitname", "unitid", "formType", "formid", "partformat", "catype", "versionname", "formatformat", "catstyle"], "size": ["count", "iz", "gn", "member", "area", "ui", "timeout", "scale", "capacity", "shell", "class", "hh", "id", "speed", "small", "SIZE", "send", "data", "sum", "time", "value", "mini", "style", "loc", "Size", "sec", "body", "large", "empty", "code", "unit", "external", "shape", "sync", "name", "content", "align", "sized", "address", "storage", "grade", "offset", "bytes", "type", "message", "esc", "white", "extra", "length", " sizes", "ize", "weight", "engine", "fee"]}}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "func": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n", "idx": 9399, "substitutes": {"klass": ["skcl", "sklass", "kazz", "skclass", "kclass", " kazz", "Klass", "skazz", "sklasses", " kcl", "Klasses", "Kclass", "klasses", " kclass", "kcl", "Kazz", "Kcl", " klasses"], "data": ["parent", "di", "ds", "def", "da", "info", "d", "i", "config", "reader", "cb", "ata", "array", "DATA", "dat", "device", "input", "loader", "dd", "Data", "after", "api", "options", "params", "cache", "result"], "dc": ["cr", "cdn", "di", "DC", "cci", "ds", "enter", "abc", "cca", "da", "conn", "tc", "dt", "d", "c", "ct", "cd", "cu", " DC", "cb", "cf", "ec", "cc", "df", "bc", "ac", "db", "dat", "design", "ga", "pc", "disc", "nc", "gc", "cm", "ca", "director", "vc", "lc", "mc", "sc", "fc"], "vdc": ["pcd", " vmc", "Vmc", "nvcd", "pcc", "pdc", "gmc", "Vcf", "ffc", "vdi", "vcf", "nvdc", "Vdc", "vsDC", "gfc", "Vdi", "vcc", "gnc", " vdi", "vcd", "nvcc", "gdi", "pmc", "fdc", "lvcf", " vcc", "lvmc", "gcf", "fdi", "vnc", "VDC", "lvdc", "vfc", "ddk", "Vnc", "Vcd", "Vc", " vfc", "gdc", "vscd", "dcd", "vDC", "lvdi", " vcd", "dDC", "vmc", "gc", "Vdk", "nvmc", "vsdk", "vdk", "vsdc", "ddc", "vc", " vnc", " vc", "fc"]}}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "substitutes": {"smp_cpus": ["smp_gpus", "smp_puses", "smp_mpu", "smp_pul", "smp_cpu", "smp_gpis", "smp_mpis", "smp_gpul", "smp_gpuses", "smp_ipu", "smp_cpul", "smp_cpuses", "smp_ipis", "smp_mpul", "smp_cpis", "smp_mpuses", "smp_gpu", "smp_pus", "smp_ipus", "smp_mpus", "smp_pis", "smp_ipuses"], "s": ["l", "session", "is", "m", "http", "t", "x", "gs", "set", "sk", "v", "state", "bis", "groups", "ns", "spec", "self", "settings", "sg", "ds", "si", "n", "your", "sf", "w", "b", "k", "c", "se", "e", "args", "sq", "us", "f", "j", "sym", "sets", "scope", "es", "current", "sup", "r", "storage", "as", "ps", "su", "site", "fs", "ss", "secure", "g", "stat", "d", "sa", "ls", "status", "socket", "os", "cs", "o", "sync", "south", "sl", "native", "new", "sb", "sys", "secondary", "ssl", "conf", "ts", "in", "service", "p", "server", "qs", "tests", "xs", "js", "rs", "sec", "aws", "S", "states", "services", "h", "client", "ses", "y"], "ret": ["true", "af", "fail", "red", "ref", "arg", "cb", "reg", "gt", "code", "al", "opt", "end", "att", "err", "hash", "re", " RET", "let", "url", "resp", "arr", "flag", "val", "key", "id", "no", "Ret", "mem", "post", "fit", "ut", "j", "db", "res", "bf", "det", "lt", "art", "error", "back", "not", "sat", "mt", "rl", "bad", "str", "nb", "len", "alt", "def", "nt", "conn", "num", " Ret", "pat", "reply", "status", "rb", "rt", "rc", "fun", "req", "part", "cat", "result", "success", "pass", "valid", "info", "sur", "job", "lit", "pt", "rets", "bot", "bit", "RET", "ft", "rev", "match", "feat", "pet"], "i": ["oi", "l", "sp", "ui", "dim", "di", "base", "it", "si", "n", "zi", "key", "m", "xi", "id", "b", "x", "t", "ini", "k", "d", "uli", "c", "p", "ix", "uri", "e", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "gi", "mi", "ind", "ti", "phi", "abi", "qi", "err", "pi", "bi", "part", "ii", "init", "u", "uni", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "ki"]}}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "substitutes": {"client": ["session", "context", "prefix", "chrome", "worker", "conn", "open", "http", "consumer", "public", "container", "project", "con", "Client", "c", "service", "config", "server", "reader", "util", "cli", "package", "request", "local", "private", "wrapper", "queue", "gui", "app", "cod", "socket", "manager", "entry", "host", "call", "child", "https", "ce", "current", "connection", "remote", "event", "google", "ctx", "user", "custom", "storage", "get", "plugin", "command", "handler", "single", "api", "image", "cache", "cell", "ssl"], "filename": ["fil", "il", "source", "prefix", "password", "fd", "path", "files", "tty", "buf", "username", "utf", "fp", "txt", "title", "Filename", "f", "binary", "bf", "database", "slice", "folder", "name", "content", "connection", "phrase", "loader", "buffer", "dll", "acl", "fn", "url", "directory", "which", "rl", "kl"], "flags": ["flag", "features", "stats", "files", "ops", "s", "mask", "util", "status", "bits", "args", "lag", "errors", "mode", " flag", "FLAG", "Flags", "format", "fun", " bits", " Flags", "rep", "bytes", "bit", "ips", "options", "fs", "gen"], "errp": ["erp", "armfp", "rarpa", "rrr", " errP", "rarpo", "ferlp", "lerfp", "finderpc", "errr", " errlp", "acerp", "arrsp", "acerpr", "armpr", "ferp", "erP", "err", "erpc", "lerlp", "ferpc", "erfp", "erpo", "rarsp", "errpr", "argpa", "finderping", "asterlp", "errpre", "asterpr", "erpr", "armpo", "argp", "arrpr", "errlp", "errpi", "errorpa", "armsp", " errr", "armp", "ferpi", "finderfp", "errorfp", "arrpo", "ferfp", "errorp", "errping", "arrfp", "rrpre", "errsp", "errP", "errpc", "argb", "errpo", "ferpr", "yrpe", "acerpi", "errb", "errfp", "yrpa", "rarp", "errorping", "errorpe", "errpe", "erping", "erpre", "argpe", " errpc", "acerlp", "errorpc", "rrp", "armpa", "finderp", " errpre", "errpa", "arrpa", "yrb", "asterpi", "yrp", "arrp", "lerpc", " errfp", "lerp", "rrP", "asterp", "errorb"], "i": ["l", "is", "m", "t", "x", "z", "iv", "ie", "v", "phi", "abi", "err", "ii", "init", "type", "ori", "ri", "fi", "oi", "gu", "si", "n", "id", "xi", "b", "c", "e", "mu", "f", "j", "index", "slice", "jit", "r", "bi", "u", "li", "ni", "lc", "hi", "di", "g", "source", "adi", "d", "status", "cli", "yi", "eni", "dr", "ai", "o", "gi", "chi", "pi", "I", "ret", "result", "iu", "ui", "start", "in", "info", "ini", "ji", "line", "p", "ix", "isi", "multi", "ti", "mi", "inner", "qi", "idi", "ip", "ci", "io", "y"], "st": ["ld", "l", "std", "str", "est", "nt", "no", "istic", "x", " sc", "ct", "stream", "obj", "ost", "f", "code", "v", "r", "ist", "sth", "et", "ST", "func", "fi", "fe", "sc"], "uri": ["ui", "archive", "location", "term", "di", " URI", "si", "source", "adi", "processor", "http", "path", "iri", "ini", "service", "metadata", "config", "server", "username", "reader", "cli", "package", "component", "ir", "gui", "eni", "parser", "manager", "binary", "unit", "resource", "multi", "slice", "umi", "route", "gi", "connection", "query", "folder", "doi", "mi", "address", "qi", "document", "pi", "storage", "git", "plugin", "uni", "handler", "api", "ci", "url", "io", "ori", "attribute", "directory", "ri", "URI", "transfer", "database"], "qp": ["idp", "ppP", "qP", "sqn", "sqP", "qn", "sqnp", "qop", "qq", "qpart", "reqop", "reqp", "questv", "sqf", "queste", "sqi", "idpc", "QP", "questpoint", "pgb", "qz", "sqpoint", "requpre", " qtp", "sqe", "qpre", "qupart", "requh", "qpc", "sqv", "sqpre", "sqtp", "qtp", "ql", "Qr", "que", "requp", "quc", "requl", "sqb", " qf", "sqm", "pgpr", "sqpart", "quq", "questf", " qr", "Qp", "qutp", "qunp", "qupc", "qufp", "sqop", "sqfp", "qc", "questh", "sqr", "reql", "idv", "sqz", "sqc", "questz", " qfp", "sqpr", "sql", "Qps", "qh", " qs", "Qi", "questp", "qpoint", " qm", "qul", "ppi", "sqh", "sqps", "qupre", "qfp", " qc", "quf", "qupoint", "sqp", "qnp", "qup", "ppp", "questpart", "Qs", "qps", "qupr", "qr", "qum", " qn", "Qc", "pgp", "sqq", "qs", "qun", "qf", "quz", "sqs", " qb", "ppps", "quop", "qv", "questl", "sqpc", "qub", "qe", "qpr", "pgh", "qi", "qm", "reqnp", "quh", "quv", "questq", "qb", "idh"], "file": ["parent", "base", "il", "flag", "comment", "ile", "source", "info", "http", "files", "path", "data", "line", "rule", "local", "queue", "feed", "f", "unit", "dir", "resource", "format", "folder", "name", "live", "pipe", "fat", "current", "pic", "full", "part", "offset", "get", "root", "File", "ignore", "image", "cache", "io", "buffer"], "strp": ["drpc", "irP", "drpe", "irp", "strpi", "nerpa", "drlp", "strpe", "Strpr", "strpatch", "strib", "strfp", "rrpatch", "nerp", "rrpr", "yrlp", "nerP", "Strb", "Strn", "strpr", "trn", "stripc", "strP", "arrpc", " strpe", "Strpc", "yrpc", "Strfp", "strb", "strip", "Strpe", "strpc", "arrpe", " strpatch", "StrP", "strpa", "rrp", "drp", "strifp", "Strp", "Strpi", " strn", "yrp", "trP", "arrp", " strpr", "trpe", " strpc", "Strpa", "strlp", "trp", " strb", "yrpe", "arrlp", "rrP", "irpi", "Strpatch", " strP", "nerpi", "irpa", "strn", " strfp"]}}
{"project": "FFmpeg", "commit_id": "6f7f2396049575fcf2054b4dafa19ca01381638e", "target": 1, "func": "static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {\n\n    NUTContext * priv = avf->priv_data;\n\n    AVIOContext * bc = avf->pb;\n\n    nut_demuxer_opts_tt dopts = {\n\n        .input = {\n\n            .priv = bc,\n\n            .seek = av_seek,\n\n            .read = av_read,\n\n            .eof = NULL,\n\n            .file_pos = 0,\n\n        },\n\n        .alloc = { av_malloc, av_realloc, av_free },\n\n        .read_index = 1,\n\n        .cache_syncpoints = 1,\n\n    };\n\n    nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts);\n\n    nut_stream_header_tt * s;\n\n    int ret, i;\n\n\n\n    if ((ret = nut_read_headers(nut, &s, NULL))) {\n\n        av_log(avf, AV_LOG_ERROR, \" NUT error: %s\\n\", nut_error(ret));\n\n\n        return -1;\n\n\n\n\n    priv->s = s;\n\n\n\n    for (i = 0; s[i].type != -1 && i < 2; i++) {\n\n        AVStream * st = avformat_new_stream(avf, NULL);\n\n        int j;\n\n\n\n        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);\n\n\n\n        st->codec->has_b_frames = s[i].decode_delay;\n\n\n\n        st->codec->extradata_size = s[i].codec_specific_len;\n\n        if (st->codec->extradata_size) {\n\n            st->codec->extradata = av_mallocz(st->codec->extradata_size);\n\n\n\n\n\n            memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);\n\n\n\n\n        avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den);\n\n        st->start_time = 0;\n\n        st->duration = s[i].max_pts;\n\n\n\n        st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag);\n\n\n\n        switch(s[i].type) {\n\n        case NUT_AUDIO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag);\n\n\n\n            st->codec->channels = s[i].channel_count;\n\n            st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom;\n\n            break;\n\n        case NUT_VIDEO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);\n\n\n\n            st->codec->width = s[i].width;\n\n            st->codec->height = s[i].height;\n\n            st->sample_aspect_ratio.num = s[i].sample_width;\n\n            st->sample_aspect_ratio.den = s[i].sample_height;\n\n            break;\n\n\n        if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n\n\n\n    return 0;\n", "idx": 9435, "substitutes": {"avf": ["affs", "aplf", "AVsf", " avF", "avm", "AVcf", "avc", "avF", "awf", "avsf", "AVfs", "awfe", "umf", "evlf", "affp", "ajf", "affac", "auc", "avcf", "afc", "abcf", "ajfs", "umfp", "afcf", " avfs", " avc", "avfac", " avfac", "avfp", "aucf", "aum", "abfs", "evfs", "afd", "afm", "apF", "evf", "avd", "AVf", "evF", "auF", "afj", "ajlf", "avfe", "apf", "avj", "affe", "umcf", "aufp", "apfs", "abf", "avlf", "awm", "afF", "umF", "absf", "ajF", " avj", "awd", "aud", "avfs", "evfac", "afsf", "auj", "auf", "aufe", "aff"], "ap": ["map", "mac", "sp", "arr", "oc", "wp", "ams", "aps", "ab", "apt", "ad", "cp", "attr", "np", "au", "arp", "array", "prop", "op", "ac", "cap", "ar", "att", "am", "tp", "AP", "api", "av"], "priv": ["ib", "cmp", "tr", "roc", "access", "auth", "conn", "org", "temp", "info", "pid", "iv", "store", "vt", "tu", "cp", "data", "sa", "config", "p", "rib", "pri", "pb", "pro", "gb", "private", "cb", "np", "txt", "fp", "ptr", "riv", "Priv", "sec", "trust", "tmp", "pub", "sub", "oca", "aux", "obj", "rc", "cert", "ctx", "tx", "ty", "raf", "pi", "sb", "pc", "storage", "cfg", "prep", "dev", "soc", "ci", "cache", "anc", "proc", "ocr", "mc", "uc"], "bc": ["ib", "context", "BC", "tc", "BBC", "c", "ct", "cp", "cb", "fp", "cf", "CBC", "ec", "cc", "ac", "bf", "isc", "mc", "rc", "ctx", "cl", "dc", "pc", "cms", "nc", "ca", "cm", "soc", "ci", "lc", "cus", "uc", "sc", "fc"], "nut": ["cot", "tun", "cit", "ou", "boot", "timeout", "orn", "n", "conn", "nt", "annot", "dt", "cut", "nuts", "ct", "config", "bd", "obj", "cb", "stab", "np", "cf", "cro", "tmp", "rot", "nat", "ut", "tube", "rt", "orb", "nit", "ctr", "aft", "fat", "utt", "art", "cue", "ott", "fn", "ot", "pot", "cart", "ocr"], "s": ["l", "sp", "is", "its", "strings", "t", "gs", "parts", "v", "series", "groups", "ns", "details", "spec", "settings", "sg", "ds", "n", "si", "sites", "sf", "b", "c", "e", "args", "lines", "sq", "f", "sets", "es", "storage", "rates", "comments", "ps", "su", "times", "fs", "ss", "apps", "ks", "sv", "g", "source", "stats", "d", "sa", "ls", "status", "socket", "os", "cs", "student", "o", "sync", "sl", "sn", "native", "sb", "sys", "secondary", "a", "ssl", "setup", "ts", "service", "p", "server", "qs", "tests", "xs", "js", "S", "sts", "sie", "states", "services", "summary", "ms", "h", "ses", "events"], "ret": ["sp", "repl", "valid", "bad", "flag", "str", "tr", "len", "val", "alt", "fail", "def", "nt", "id", "Ret", "temp", "num", "mem", "red", "reply", "ref", "obj", "lit", "reg", "iter", "rets", "sec", "rt", "res", "det", "rc", "fat", "cur", "att", "fun", "r", "err", "rep", "art", "xt", "cat", "re", "RET", "back", " RET", "out", "result", "mt", "ft", "isf", "resp", "pet"], "i": ["l", "m", "x", "iv", "uri", "ie", "v", "phi", "ii", "init", "type", "ori", "interface", "ri", "fi", "oi", "si", "n", "id", "xi", "b", "c", "e", "f", "index", "module", "jit", "sup", "bi", "u", "li", "ni", "lc", "cell", "hi", "ib", "di", "g", "source", "zi", "d", "yi", "cli", "mini", "eni", "ai", "gi", "chi", "pi", "part", "I", "iu", "ui", "it", "info", "ini", "ji", "p", "ix", "isi", "ish", "mi", "ti", "ik", "inner", "qi", "ij", "h", "ip", "ci", "api", "io", "y"], "st": ["ld", "sp", "sh", "ts", "std", "str", "start", "est", "rd", "ust", "stage", "nt", "fr", "src", "dt", "t", "rest", "d", "post", "sa", "ct", "p", "stream", "se", "set", "ost", "pt", "stop", "tmp", "ut", "inst", "spect", "rt", "bl", "nd", "lt", "sta", "sts", "sl", "r", "end", "kt", "sn", "sth", "ist", "ste", "put", "trans", "sb", "art", "elt", "sd", "ast", "St", "ST", "ft", "mt", "ss", "sr", "td", "sc"], "j": ["l", "ib", "je", "it", "adj", "n", "g", "note", "json", "key", "fr", "jet", "k", "jen", "dj", "z", "b", "x", "job", "d", "ji", "other", "jo", "p", "obj", "e", "kj", "js", "q", "f", "ie", "uj", "child", "bj", "o", "size", "v", "syn", "jit", "ind", "name", "pr", "im", "ij", "jp", "ii", "ja", "aj", "h", "oj", "li", "J", "ni", "y", "length", "jc", "jl", "jj", "br", "dy"]}}
{"project": "qemu", "commit_id": "41264b385c2b324fea026204e5de9bef980733b1", "target": 1, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n    Error *local_err = NULL;\n#if !defined(CONFIG_USER_ONLY)\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n#endif\n#if !defined(CONFIG_USER_ONLY)\n    if (smp_threads > max_smt) {\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n    if (!is_power_of_2(smp_threads)) {\n        error_setg(errp, \"Cannot support %d threads on PPC with %s, \"\n                   \"threads count must be a power of 2.\",\n                   smp_threads, kvm_enabled() ? \"KVM\" : \"TCG\");\n#endif\n    cpu_exec_init(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n#if !defined(CONFIG_USER_ONLY)\n    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt\n        + (cs->cpu_index % smp_threads);\n#endif\n    if (tcg_enabled()) {\n        if (ppc_fixup_cpu(cpu) != 0) {\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n#if defined(TARGET_PPCEMB)\n    if (!ppc_cpu_is_valid(pcc)) {\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n                   \"or choose another CPU model.\");\n#endif\n    create_ppc_opcodes(cpu, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    init_ppc_proc(cpu);\n    if (pcc->insns_flags & PPC_FLOAT) {\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n                                 33, \"power-fpu.xml\", 0);\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n                                 34, \"power-altivec.xml\", 0);\n    if (pcc->insns_flags & PPC_SPE) {\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n                                 34, \"power-spe.xml\", 0);\n    if (pcc->insns_flags2 & PPC2_VSX) {\n        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,\n                                 32, \"power-vsx.xml\", 0);\n    qemu_init_vcpu(cs);\n    pcc->parent_realize(dev, errp);\n#if defined(PPC_DUMP_CPU)\n    {\n        CPUPPCState *env = &cpu->env;\n        const char *mmu_model, *excp_model, *bus_model;\n        switch (env->mmu_model) {\n        case POWERPC_MMU_32B:\n            mmu_model = \"PowerPC 32\";\n            break;\n        case POWERPC_MMU_SOFT_6xx:\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_74xx:\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx:\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx_Z:\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n                \"and zones protections\";\n            break;\n        case POWERPC_MMU_REAL:\n            mmu_model = \"PowerPC real mode only\";\n            break;\n        case POWERPC_MMU_MPC8xx:\n            mmu_model = \"PowerPC MPC8xx\";\n            break;\n        case POWERPC_MMU_BOOKE:\n            mmu_model = \"PowerPC BookE\";\n            break;\n        case POWERPC_MMU_BOOKE206:\n            mmu_model = \"PowerPC BookE 2.06\";\n            break;\n        case POWERPC_MMU_601:\n            mmu_model = \"PowerPC 601\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_MMU_64B:\n            mmu_model = \"PowerPC 64\";\n            break;\n#endif\n        default:\n            mmu_model = \"Unknown or invalid\";\n            break;\n        switch (env->excp_model) {\n        case POWERPC_EXCP_STD:\n            excp_model = \"PowerPC\";\n            break;\n        case POWERPC_EXCP_40x:\n            excp_model = \"PowerPC 40x\";\n            break;\n        case POWERPC_EXCP_601:\n            excp_model = \"PowerPC 601\";\n            break;\n        case POWERPC_EXCP_602:\n            excp_model = \"PowerPC 602\";\n            break;\n        case POWERPC_EXCP_603:\n            excp_model = \"PowerPC 603\";\n            break;\n        case POWERPC_EXCP_603E:\n            excp_model = \"PowerPC 603e\";\n            break;\n        case POWERPC_EXCP_604:\n            excp_model = \"PowerPC 604\";\n            break;\n        case POWERPC_EXCP_7x0:\n            excp_model = \"PowerPC 740/750\";\n            break;\n        case POWERPC_EXCP_7x5:\n            excp_model = \"PowerPC 745/755\";\n            break;\n        case POWERPC_EXCP_74xx:\n            excp_model = \"PowerPC 74xx\";\n            break;\n        case POWERPC_EXCP_BOOKE:\n            excp_model = \"PowerPC BookE\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_EXCP_970:\n            excp_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            excp_model = \"Unknown or invalid\";\n            break;\n        switch (env->bus_model) {\n        case PPC_FLAGS_INPUT_6xx:\n            bus_model = \"PowerPC 6xx\";\n            break;\n        case PPC_FLAGS_INPUT_BookE:\n            bus_model = \"PowerPC BookE\";\n            break;\n        case PPC_FLAGS_INPUT_405:\n            bus_model = \"PowerPC 405\";\n            break;\n        case PPC_FLAGS_INPUT_401:\n            bus_model = \"PowerPC 401/403\";\n            break;\n        case PPC_FLAGS_INPUT_RCPU:\n            bus_model = \"RCPU / MPC8xx\";\n            break;\n#if defined (TARGET_PPC64)\n        case PPC_FLAGS_INPUT_970:\n            bus_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            bus_model = \"Unknown or invalid\";\n            break;\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n               \"    MMU model        : %s\\n\",\n               object_class_get_name(OBJECT_CLASS(pcc)),\n               pcc->pvr, pcc->msr_mask, mmu_model);\n#if !defined(CONFIG_USER_ONLY)\n        if (env->tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif", "idx": 9437, "substitutes": {"dev": ["mac", "devices", "conf", "cow", "cam", "debug", "tr", "dom", "prov", "prof", "test", "Dev", "def", "conn", "pack", "dem", "ver", "d", "de", "data", "pro", "priv", "serial", "rad", "hw", "ev", "device", "pub", "req", "loader", "mod", "user", "pu", "bus", "spec", "sd", "node", "grad", "comp", "cache", "ch", "proc"], "errp": ["erf", "erp", " errP", " erping", "derp", "errpre", "derr", "errorfp", "callf", "errorf", "rrb", "rrc", " errsp", "errpe", "erping", "erpre", "derc", "rrf", " errt", " errping", "arrf", "erc", "errort", "errorp", "errorP", "errr", "errt", "errping", " errpe", "arrpe", " errc", "arrc", " ert", "rrp", "callc", "errsp", " erb", " errpre", "errP", " errb", "derP", "errf", "erP", " errf", "errorpre", " erf", "err", "arrp", " errfp", "callp", "callsp", "erfp", "Erp", "errc", "rrP", " err", "Erc", "errb", "ErP", "rrsp", "rrpe", " errr", "Err", " erp", "errorb", "rrfp", "errfp"], "cs": ["vs", "utils", "ks", "ds", "cells", "cing", "conn", "gs", "c", "cp", "s", "ls", "qs", "tests", "ins", "cf", "cn", "wcs", "args", "rs", "cc", "sk", "os", "acs", "ck", "sync", "rc", "ras", "CS", "cons", "checks", "cas", "ctx", "ns", "pc", "spec", "cms", "sys", "nc", "ca", "ps", "fs", "css", "cache", "lc", "bs", "core", "cus", "sc"], "cpu": ["mac", "cow", "utils", "kernel", "uu", "boot", "cam", "cmp", "processor", "conn", "gpu", "uno", "chip", "cp", "vm", "cum", "c", "config", "p", "cu", "cli", "computer", "np", "uci", "cn", "hw", "bc", "os", "device", "console", "linux", "process", "sync", "rc", "clock", "fps", "ctx", "pu", "PU", "pc", "nic", "dc", "node", "spec", "cpp", "CPU", "nc", "gc", "cm", "cfg", "px", "sys", "ci", "css", "cache", "lc", "hu", "lan", "proc", "core", "fc"], "pcc": ["Pcc", " pcf", "percci", "ppac", "percc", "Pci", "cpac", "Pcf", "pci", "pCC", "pck", "cpcc", "ppci", " pci", "ppCC", " pCC", "ppck", "pac", "perck", " pcci", " pac", "percf", "ppcc", "cpci", "PCC", "Pck", "pcci", " pck", "pcf", "Pcci", "cpCC"], "local_err": ["Local_doc", "internal_err", "local_norm", " local_bug", "local_ok", "Local_gr", "localallerr", "localofrr", "localIPerr", "localallcore", "internal_orr", "localoforr", "localoferr", "local_bug", "localIPcore", " local_msg", "local67er", "local67err", "Local_rr", " local_ok", "local_res", "local67doc", " local_core", "Local_res", "Local_err", "locallyerror", "locallymsg", "localallok", "local_doc", "locallyerr", " local_error", "internal_rr", "local_error", "locallybug", "local_gr", "localIPok", "localIPerror", "local_orr", "local67gr", "internal_norm", "local_core", "localofnorm", "local_msg", "local_rr", "localallerror", "Local_er", "local_er"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 9443, "substitutes": {"addr": ["mac", "Address", "adr", "arm", "n", "pad", "m", "src", " dst", "b", "x", "i", "pointer", "ad", "data", " address", "add", "p", "e", "attr", "target", "afi", "amd", "ptr", "ange", "array", "f", "dr", "host", "rt", "device", "v", "md", "r", "address", "dd", "part", "offset", "node", "nc", "pos", "rx", "ip", "localhost", "a", "inter"], "RAM_size": ["ram_size", "RAMLogSIZE", "RAM_bytes", "RAM_Size", "ram_capacity", "RAM_capacity", "ram_bytes", "RAMLogcapacity", "RAMLogbytes", "ram_Size", "RAMLogsize", "RAM_SIZE", "ram_SIZE"], "dev": ["conf", "gd", "di", "sh", "debug", "ds", "n", "g", "Dev", "w", "def", "m", "temp", "ve", "adv", "ver", "data", "ad", "p", "e", "pro", "driver", "app", "rad", "priv", "serial", "er", "f", "ev", "device", "db", "o", "v", "raw", "r", "md", "mod", "err", "dd", "dc", "error", " Dev", "sd", "u", "dm", "grad", "od", "der", "ch", "DEV"], "s": ["l", "sg", "sh", "sv", "ds", "n", "g", "si", "w", "m", "src", "t", "b", "k", "i", "gs", "sa", "c", "ad", "p", "se", "e", "sq", "js", "rs", "f", "os", "cs", "device", "o", "S", "v", "sync", "south", "sl", "services", "r", "ns", "sb", "sd", "spec", "u", "h", "self", "ps", "a", "ss", "ssl"], "d": ["l", "gd", "di", "dh", "ds", "n", "g", " dd", "da", "w", "m", "dt", "fd", "b", "t", "k", "z", "i", "data", "c", "ad", "p", "e", "cd", "driver", "f", "dr", "db", "device", "dat", "o", "v", "md", "r", "dd", "dc", "sd", "u", "D", "dy"]}}
{"project": "qemu", "commit_id": "49aa4058ac6dd0081aaa45776f07c98df397ca5e", "target": 1, "func": "QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n\n{\n\n    char host[65], port[33], width[8], height[8];\n\n    int pos;\n\n    const char *p;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n\n\n    opts = qemu_opts_create(qemu_find_opts(\"chardev\"), label, 1, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        return NULL;\n\n    }\n\n\n\n    if (strstart(filename, \"mon:\", &p)) {\n\n        filename = p;\n\n        qemu_opt_set(opts, \"mux\", \"on\");\n\n        if (strcmp(filename, \"stdio\") == 0) {\n\n            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n\n             * but pass it to the guest.  Handle this only for compat syntax,\n\n             * for -chardev syntax we have special option for this.\n\n             * This is what -nographic did, redirecting+muxing serial+monitor\n\n             * to stdio causing Ctrl+C to be passed to guest. */\n\n            qemu_opt_set(opts, \"signal\", \"off\");\n\n        }\n\n    }\n\n\n\n    if (strcmp(filename, \"null\")    == 0 ||\n\n        strcmp(filename, \"pty\")     == 0 ||\n\n        strcmp(filename, \"msmouse\") == 0 ||\n\n        strcmp(filename, \"braille\") == 0 ||\n\n        strcmp(filename, \"stdio\")   == 0) {\n\n        qemu_opt_set(opts, \"backend\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"vc\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"vc\");\n\n        if (*p == ':') {\n\n            if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) {\n\n                /* pixels */\n\n                qemu_opt_set(opts, \"width\", width);\n\n                qemu_opt_set(opts, \"height\", height);\n\n            } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) {\n\n                /* chars */\n\n                qemu_opt_set(opts, \"cols\", width);\n\n                qemu_opt_set(opts, \"rows\", height);\n\n            } else {\n\n                goto fail;\n\n            }\n\n        }\n\n        return opts;\n\n    }\n\n    if (strcmp(filename, \"con:\") == 0) {\n\n        qemu_opt_set(opts, \"backend\", \"console\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"COM\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"serial\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"file:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"file\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"pipe:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"pipe\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"tcp:\", &p) ||\n\n        strstart(filename, \"telnet:\", &p)) {\n\n        if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1)\n\n                goto fail;\n\n        }\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == ',') {\n\n            if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n\n                goto fail;\n\n        }\n\n        if (strstart(filename, \"telnet:\", &p))\n\n            qemu_opt_set(opts, \"telnet\", \"on\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 9445, "substitutes": {"label": ["alias", "channel", "seq", "base", "prefix", "key", "lab", "display", "tag", "path", "block", "line", "config", "el", "layout", "local", "pixel", "value", "loc", "title", "code", "bl", "route", "abel", "description", "format", "name", "align", "address", "desc", "position", "error", "file", "message", "url", "image", "length", "cell", "text", "Label"], "filename": ["download", "il", "json", "path", "python", "uri", "package", "attr", "txt", "duration", "description", "content", "document", "params", "url", "image", "text", "buffer", "println", "sound", "sheet", "prefix", "sf", "application", "license", "output", "lace", "title", "large", "f", "binary", "jpg", "loader", "position", "fax", "file", "directory", "location", "initial", "source", "src", "password", "appy", "buf", "microsoft", "metadata", "fp", "Filename", "maximum", "nuclear", "phrase", "kn", "dll", "tp", "fn", "single", "message", "ssl", "kl", "gender", "fil", "ppa", "mpeg", "files", "other", "username", "final", "nil", "name", "folder", "doi", "video", "length", "lua", "database"], "host": ["map", "param", "base", "prefix", "class", "def", "path", "Host", " ip", "data", "addr", "server", "config", " address", "loc", "master", "name", "address", " addr", "link", "pair", "h", "file", "ip", "url", "bind"], "port": ["channel", "timeout", "prefix", "key", "path", "post", "ports", "service", "cp", "data", "server", "uri", "ref", "output", "table", "slice", "index", "route", "address", "user", "phone", "offset", "type", "file", "ip", "url", "interface"], "height": ["rank", "level", "dim", "pass", "up", "img", "images", "rows", "window", "view", "w", "id", "missing", "total", "resolution", "density", "angle", "bottom", "layout", "upper", "driver", "thin", "style", "grow", "high", "gravity", "padding", "lat", "Height", "alpha", "dir", "th", "size", "shape", "hold", "duration", "stroke", "deep", "buffer", "definition", "pull", "holes", "above", "huge", "crop", "h", "volume", "ip", "build", "gap", "length", "image", "y", "arrow", "inches", "times", "depth", "direction"], "pos": ["POS", "start", "len", "val", " loc", " offset", "src", " index", " position", "i", " start", "line", " location", "pixel", "loc", "os", "padding", "unit", "size", "opt", "name", "Pos", "position", "offset", "col", "type", " disp"], "p": ["lp", "l", "dp", "sp", "param", "n", "g", "w", "m", "bp", "point", "path", "b", "t", "x", "pa", "d", "i", "pp", "c", "cp", "s", "python", "pb", "e", "fp", "np", "pixel", "pe", "pt", "q", "P", "parser", "f", "pn", "op", "j", "o", "ap", "v", "format", "pipe", "r", "pr", "pre", "tp", "jp", "pi", "pc", "u", "type", "h", "pair", "file", "ip", "params", "ps", "a", "y", "pkg", "per", "vp"], "opts": ["optps", "Opt", "operuts", "OPments", "ottips", "optips", " optes", " opouts", "ipments", "OPps", " opstr", "optes", " optps", "optters", "ipls", "ots", "OPrets", "OPstr", "opt", "OPcs", "optms", "optments", "optt", "Opters", "otcs", "otters", "opert", "optouts", " optments", "opttes", "otts", " opls", "optls", "Opts", "opps", "Oprets", "OPouts", "popt", "opercs", "optts", "itt", " opttt", " oputs", "opttips", " opments", " opms", " optcs", "Opments", "poptt", "popters", "opertes", " optt", "Optes", "ops", "operouts", "Opouts", "popts", " optrets", "operters", "opstr", "OPt", "oputs", " opt", "optcs", "itcs", "ipts", "OPters", "opments", "itts", " opttips", "OPuts", "oprets", "ot", "oters", " optstr", "OPts", " optms", " opps", " opters", "itouts", "opls", "opouts", "operts", "ipcs", "opcs", " optters", " opcs", "opms", "opters", "OPtes", " optts", "Opcs"], "local_err": ["checklyer", "localpyuser", "baseamver", "base_errors", "localpyerr", "check_attr", "local_finder", "base_ver", "localamer", "local7attr", "checklyerr", "locallyfinder", "local_ver", "checklyfinder", "locallyattr", "local__err", "global_rr", "baseamerr", "global_user", "base_err", "localpyerror", "local7finder", "baseamer", "locallyerr", " local_error", "local__errors", "base_er", " local_rr", "localamver", "local_error", "check_finder", "baseamerrors", "local_attr", "check_err", "localamerr", "global_error", "checklyattr", "global_err", "local__er", "check_er", "local__ver", "local_user", " local_er", "locallyer", "local_rr", "local7er", "local_errors", "local_er", "localamerrors", "localpyrr", "local7err"]}}
{"project": "qemu", "commit_id": "c73860803f8f8f56ee01b6e796507bfb4ea073ec", "target": 1, "func": "POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER8\";\n\n    dc->desc = \"POWER8\";\n\n    pcc->pvr = CPU_POWERPC_POWER8_BASE;\n\n    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;\n\n    pcc->init_proc = init_proc_POWER7;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;\n\n    pcc->msr_mask = 0x800000000284FF36ULL;\n\n    pcc->mmu_model = POWERPC_MMU_2_06;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER7;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n}", "idx": 9457, "substitutes": {"oc": ["mac", "co", "DC", "roc", "cca", "org", "unc", "toc", "doc", "c", "config", "OC", "exec", "cf", "ec", "loc", "oci", "bc", "ac", "cc", "isc", "o", "alloc", "oca", "rc", "oco", "voc", "pc", "oid", "ucc", "oper", "nc", "soc", "anc", "ocr", "mc", "uc", "ok", "fc"], "data": ["parent", "di", "ds", "da", "def", "d", "block", "config", "output", "bc", "DATA", "ac", "dat", "device", "input", "raw", "load", "dd", "new", "Data", "bus", "dev", "ci", "cache", "fee"], "dc": ["cdn", "mac", "di", "DC", "ds", "cca", "da", "conn", "tc", "dt", "d", "doc", "c", "cd", "cf", "VC", "ec", "bc", "df", "cc", "ac", "dat", "design", "rc", "ga", "desc", "disc", "nc", "cm", "ca", "director", "vc", "lc", "jc", "mc", "acc", "sc", "uc", "fc"], "pcc": [" pC", " pdd", "lpCC", "Pcf", "cpcca", "cpct", "pcs", "prdd", "cpcf", "frc", " pck", "pe\n", "Pcca", "pC", "cpCC", "lpcf", " pcca", "tcs", "prc", "Pacc", "fcf", "tcc", "cpcc", "ppCC", "p\n", " pcci", "prck", " prc", "P\n", "PCC", "Pck", "lpcca", " pct", "ppacc", "prCC", "Pcc", "pdd", "ppcca", "tCC", " pacc", "pck", "cpacc", " pCC", "lpcci", "prcc", "cpcci", " pcs", "Prc", "fcc", "pcci", "Pcci", "pct", "PC", " p\n", " pcf", "Pdd", "peC", "pCC", "pcca", "lpcc", "tcf", "fcca", "ppck", "ppcc", "Pct", "cpck", "pcf", "pacc", "fCC", "Pcs"]}}
{"project": "FFmpeg", "commit_id": "842e98b4d83d8cf297e2bc2761f1f47eb89e49e4", "target": 0, "func": "static int parse_object_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n    PGSSubObject *object;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n    int id;\n\n\n\n    if (buf_size <= 4)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 4;\n\n\n\n    id = bytestream_get_be16(&buf);\n\n    object = find_object(id, &ctx->objects);\n\n    if (!object) {\n\n        if (ctx->objects.count >= MAX_EPOCH_OBJECTS) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Too many objects in epoch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        object = &ctx->objects.object[ctx->objects.count++];\n\n        object->id = id;\n\n    }\n\n\n\n    /* skip object version number */\n\n    buf += 1;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > object->rle_remaining_len)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        memcpy(object->rle + object->rle_data_len, buf, buf_size);\n\n        object->rle_data_len += buf_size;\n\n        object->rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    if (buf_size > rle_bitmap_len) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Buffer dimension %d larger than the expected RLE data %d\\n\",\n\n               buf_size, rle_bitmap_len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height || !width || !height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions (%dx%d) invalid.\\n\", width, height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    object->w = width;\n\n    object->h = height;\n\n\n\n    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!object->rle)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(object->rle, buf, buf_size);\n\n    object->rle_data_len = buf_size;\n\n    object->rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "idx": 9482, "substitutes": {"avctx": ["aflib", "ajcu", "avsync", "AVcf", "afctx", "aircontext", "navctx", "navcu", "verkb", "avectx", "awcontext", "abconfig", "awcmd", "abcontext", "avcf", "avecu", "abcf", "evcontext", "avlib", "AVcontext", "avcu", "airctx", "awcas", "verctx", "vercontext", "AVkb", "abctx", "afcf", "avconn", "avcmd", "avconv", "AVsync", "aveconfig", "ajctx", "ajcontext", "AVcmd", "afconfig", "AVctx", "aircmd", "aveconv", "AVconn", "verconn", "avconfig", "avelib", "avcontext", "awctx", "verloc", "evconn", "afcu", "avloc", "avekb", "evctx", "AVconv", "avkb", "avecf", "aveloc", "AVcu", "evsync", "avecontext", "navconfig", "aircas", "afcontext", "navlib", "AVloc", "AVcas", "ajconv", "versync", "avcas", "vercf"], "buf": ["bag", "count", "uf", "grab", "seq", "byte", "img", "context", "uber", "len", "ff", "proc", "window", "pad", "src", "fd", "b", "mount", "filename", "wb", "num", "block", "fb", "batch", "comb", "config", "pb", "obj", "cb", "fp", "queue", "coord", "cf", "rb", "off", "flow", "bc", "alloc", "cv", "ctr", "fam", "rc", "home", "cur", "conv", "loader", "callback", "port", "begin", "bus", "root", "cat", "pos", "loop", "header", "row", "length", "func", "vec", "buff", "cmd", "br", "feat", "buffer", "box", "uc", "runner"], "buf_size": ["buffer_len", "raw_size", "buf_count", "buf___capacity", "bufnsize", "buf_capacity", "buf_send", "buffterm", "bufflexstrength", "cb_size", "cb_side", "buffer_size", "buff_sized", "buf64term", "cb64content", "buff_scale", "fb_form", "raw_SIZE", "raw_capacity", "buflexterm", "cb_count", " buf_capacity", "buffsized", "buflexsized", "buf64side", "buf_form", " buf_small", "buf_width", "buffstrength", "buf_address", "bag_size", " buf_ize", "bufnscale", "buf_clean", "buff_speed", "buf128size", " buf_len", "buf128content", "cb_content", "buf_strength", "bag_sized", "bufflexsize", "uf_scale", "buf_content", "fb_global", "buf_scale", "bufflexterm", "bag_speed", "buf_global", "buflexstrength", "buflexsize", "buff_strength", "uf_capacity", "buf64count", "cb64side", "buff_term", "bufnglobal", "raw_send", "uf_sized", "buf64content", "bufnform", "uf_size", "buf_small", "fb_scale", "fb_size", "buf64strength", "bufflexsized", "buf_sized", "buf_rate", "buff_width", "buf___size", "buf_SIZE", "buf_speed", "buf67count", "buf128count", "buf_term", "buf___clean", " buf_clean", "buf64size", "buf_Size", "buffer_ize", "bag_Size", "buf_side", "buf64sized", " buf_rate", "cb64count", "buf_ize", "buf67content", "buff_size", "buffer_scale", "cb64size", " buf_address", "buf_len", "buf67size", "buf128side", "buf67side", "buffsize"], "ctx": ["cdn", "conf", "cam", "wp", "context", "cci", "abc", "prefix", "cca", "conn", "que", "instance", "sci", "c", "cp", "config", "obj", "cu", "cb", "qa", "cf", "cn", "act", "wcs", "loc", "coll", "hw", "cc", "bc", "ctrl", "alloc", "cv", "ck", "aux", "sync", "rc", "cas", "tx", "acl", "xc", "git", "kw", "cms", "concept", "gc", "nc", "cm", "ca", "client", "cycle", "ci", "fc", "vc", "anc", "cmd", "lc", "pkg", "cus", "kb", "exec"], "object": ["parent", "tree", "block", "python", "package", "target", "po", "act", "body", "orb", "external", "connection", "end", "document", "full", "oid", "offset", "type", "interface", "image", "element", "n", "key", "no", "open", "instance", "post", "output", "value", "op", "unit", "ject", "zero", "index", "en", "position", "error", "lock", "not", "ant", "ob", "source", "class", "model", "public", "article", "project", "style", "coll", "entry", "host", "o", "subject", "entity", "actor", "part", "node", "et", "attribute", "cache", "core", "active", "Object", "comment", "service", "obj", "private", "objects", "number", "empty", "an", "lib", "name", "event", "item", "inner", "function", "address", "bot", "bit", "pos", "null"], "sequence_desc": ["sequence_description", " sequence_str", " sequence_des", "sequenceEdesc", "seq_description", "sequencePdes", "sequence_sec", "seq_desc", "sequence__str", "sequenceElength", "sequenceEdescription", "sequencePstr", "sequence_Desc", "sequencePdesc", "seq_sec", "sequence__desc", "sequence_length", "sequenceEDesc", "sequence__description", "seq_des", "sequence_str", "sequencePdescription", "seq_length", "sequence__des", "sequence_des", " sequence_description", "seq_Desc"], "rle_bitmap_len": ["rle_bitmap2length", "rle_bitmap_length", "rle_bitmap2val", "rle_bitmap_val", "rle_bitcap_len", "rle_bitmap64l", "rle_bitcap_length", "rle_bitmap_l", "rle_bitmap64val", "rle_bitmask_lic", "rle_bitmask_name", "rle_bitmap2len", "rle_bitcap_Len", "rle_bitmask_len", "rle_bitmask_val", "rle_bitmap_name", "rle_bitcap_val", "rle_bitcap_l", "rle_bitmap64len", "rle_bitmap2l", "rle_bitmap_Len", "rle_bitmap64length", "rle_bitmap_lic"], "height": ["diff", "rank", "dim", "he", "ht", "img", "han", "rows", "thirds", "images", "window", "w", " heights", "third", "missing", "x", "east", "resolution", "container", "fw", "density", "data", "bottom", "work", "layout", "dist", "thin", "gh", "gravity", "high", "flow", "padding", "Height", "alpha", "png", "size", "shape", "index", "duration", "th", "stroke", "hold", "wall", "ty", "pull", "above", "hang", "huge", "crop", "h", "volume", "build", "border", "row", "gap", "length", "image", "y", "inches", "weight", "family", "ows", "depth", "direction"], "id": ["parent", "count", "alias", "ide", "base", "start", "source", "vid", "pad", "key", "board", "bid", "no", "info", "fd", "x", "uid", "num", "pid", "tag", "d", "i", "path", "class", "data", " fid", "head", "mask", "p", "ref", "obj", "uri", "ids", "ad", "ID", "value", "number", "f", "code", "kid", "version", "index", "name", "event", "end", "edit", "address", " ID", "ident", "oid", "error", "offset", "node", "bit", "type", "aid", "Id", "file", "ip", "url", "length", "image", "sid", "gen"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,\n\n        RDMALocalBlock *block, uintptr_t host_addr,\n\n        uint32_t *lkey, uint32_t *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9508, "substitutes": {"rdma": ["pdda", "rtca", "rdca", "rgmas", "pdm", "rtmas", "ldmas", "rtma", "djca", "rcma", "djma", "ldm", "rcmas", "rdda", "xdmas", "rdfa", "rtm", "rdmas", "xdma", "djm", "rgMA", "pdca", "rbma", "erdmas", "rbmas", "erdm", "rgfa", "rdMA", "djda", "ldda", "rdango", "erdca", "xdda", "ldma", "erdma", "rcMA", "ldango", "rcango", "rbMA", "rcda", "pdma", "rbfa", "rdm", "ldca", "rgma", "rcfa", "xdango"], "block": ["channel", "session", "base", "ack", "section", "record", "point", "ban", "tag", "panel", "config", "ref", "condition", "frame", "none", "call", "bl", "contract", "object", "full", "link", "type", "row", "image", "random", "box", "chain", "Block", "view", "rule", "work", "group", "unit", "inv", "commit", "module", "clock", "wall", "blocks", "error", "position", "list", "plugin", "lock", "build", "header", "join", "exec", "map", "def", "num", "coll", "flow", "BL", "sync", "part", "node", "cache", "un", "byte", "comment", "info", "pack", "update", "line", "batch", "run", "number", "off", "name", "event", "address", "user", "check", "pos"], "host_addr": ["host_no", "server_addr", "server_address", "host_start", "server_name", "server_start", "host_address", "server_no", "host_name"], "lkey": ["lbmatch", "olise", " lchar", " lmatch", " lise", "elkey", "pkey", "lkeys", "lrow", "slfix", "uowner", "llrow", " lrow", "lmac", "ylcheck", "lcheck", "uchar", "slrow", "urow", "Lvalue", " llock", "ukey", " lKey", "ylfix", "rlKey", "llchar", "lvalue", " lfix", "rise", "lbvalue", "lmatch", "slmac", "rvalue", "lbfix", "LKey", "lchar", "slkeys", "pask", "pkeys", "lowner", "ylask", "pcheck", "olrow", "elvalue", "lbkey", "Llock", "rrow", "rlvalue", " lkeys", "llkey", "llock", "rlkey", "lKey", "rkeys", "lbkeys", "olkey", "llowner", "slvalue", "lbmac", " lvalue", " lmac", "Lkey", "lask", " lcheck", "rllock", "lblock", "elkeys", "ylkey", "olchar", "rchar", " lask", "pmatch", "pfix", "lfix", "slkey", "plock", "elrow", " lowner", "lise"], "rkey": ["nrrow", "hmatch", "rmatch", "rchange", "rarg", " rarg", " rKey", "pruse", "rarcall", "Rrow", "hrkey", "crchange", "pkey", "lrow", "prkey", "nlock", "trget", "hrrow", "rcheck", "puse", "srkey", "usum", "rno", "arno", "ukey", "rKey", "nrKey", "trkey", "lcall", "srget", "arkey", "nrget", "lmatch", "trmatch", "armatch", "RKey", " rmatch", " rload", "pKey", "rrule", "trlock", "srchange", "crcheck", "rararg", "ruse", "rfix", "rrow", "hcall", "Rkey", "luse", "llock", "crkey", "crget", "prmatch", "uno", "prget", "nrcheck", "larg", "rload", "mlock", "lKey", " rrule", "Rload", "umatch", "rarrule", "srsum", "prlock", "lrule", "hKey", "arsum", "hrlock", "rsum", "nkey", "rarkey", "nrkey", "mget", " rcall", "nrload", "prKey", "rcall", "nrchange", "mkey", "rget", "nfix", " rrow", "pmatch", "hkey", "nrow", "lfix", "hrfix", "mmatch", "srcheck", "srno", "rlock", "srmatch"], "chunk": ["hck", " chdu", "unchanne", "cyanch", "hunk", "cheork", "schunker", "chdu", "enchanch", "chunks", "cheaken", "querunk", "ichunks", "ahunk", "shunks", "chault", "cheunker", "shanch", "shunk", "ichunk", " chard", "chuk", " chunks", "shuk", "querunker", "ahunker", " chault", "enchuk", "unchaken", "unchunk", "chak", "ichunker", "ahk", "shank", "achard", " chack", "enchunk", "archanne", "chork", "ichck", "ichault", "chank", "hunker", "chaunk", "querault", "cheanne", "achunks", "archunk", "achack", "archaken", "enchank", " chunker", "chaken", "cheunk", "ichork", "cyuk", "cyunk", "chunker", "schork", "chard", "shard", " chk", "chk", " chork", "chack", "chadu", "channe", "cyank", "schunk", "ahdu", "achunk", "shack", "hork", "querunks", " chck", "chaunker", "chck", "chanch"], "chunk_start": ["chanch_end", "chork_end", "chunk_name", "chrow_data", "chrow_end", "chunk64index", "chow_begin", "chunk_stop", "chunk0end", "chork_part", "chanch_index", "chrow_offset", "chow_stop", "chunk64end", "chunk_pos", "chrow_start", "chunk_data", "chork_start", "chork_name", "chunk_begin", "chanch_old", "chunk_offset", "chunk_part", "chunk64old", "chork0name", "chunk_from", "chunk0name", "chow_end", "chunk_old", "chork0start", "chork0end", "chunk0start", "chunk_index", "chork0part", "chunk0part", "chunk64start", "chow_start", "chanch_start"], "chunk_end": ["chunk_id", "chunks_ends", "chunk_size", "chunk1start", "chunks_start", "chunks_end", "chunk_ends", "chunk1end", "chunk_nd", "chunks_nd", "chunk1size", "chunks_id"], "total_registrations": ["total_registicrations", "total_regdistors", "total_registicries", "total_regustors", "total_rdistries", "total_registentulations", "total_regdistrators", "total_regustrations", "total_regdistries", "total_ristrations", "total_regustries", "total_gdistrations", "total_gdistrators", "total_registicrators", "total_registrators", "total_gistrators", "total_regdistrations", "total_gdistors", "total_regiftries", "total_regiftors", "total_rdistulations", "total_gdistries", "total_registors", "total_ristulations", "total_gistors", "total_gistries", "total_rdistrators", "total_rdistrations", "total_registries", "total_registentrations", "total_regustrators", "total_registiculations", "total_ristries", "total_ristrators", "total_registentries", "total_gistrations", "total_registentrators", "total_regiftrations", "total_regdistulations", "total_registulations", "total_regiftrators"]}}
{"project": "qemu", "commit_id": "e3697092228770c3b23d0bf524e18b508b109932", "target": 1, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n        if (depth == 16 || depth == 32) {\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds->surface);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 9509, "substitutes": {"s": ["session", "is", "its", "m", "http", "t", "gs", "parts", "plugins", "ges", "series", "state", "bis", "ns", "spec", "self", "params", "settings", "sg", "ds", "si", "your", "sites", "sf", "b", "i", "c", "e", "request", "or", "sq", "us", "f", "sym", "sets", "es", "r", "sis", "this", "ps", "su", "site", "fs", "ss", "ks", "g", "features", "stats", "ops", "ls", "status", "os", "same", "grades", "cs", "o", "south", "sl", "new", "sb", "sys", "ions", "secondary", "a", "ssl", "conf", "sports", "ts", "in", "service", "p", "server", "qs", "ins", "xs", "js", "rs", "S", "sie", "states", "services", "ses"], "full_update": [" full_width", " full_init", "fullworkwrite", "fullworkload", "fullurereport", "full_\n", " full_save", "full_write", "fullOupdate", "complete_load", "half_event", "full_event", "halferupdate", "fullOwrite", "fullOsave", "fullerevent", "half_Update", "fullCwrite", "full_version", "fullurerelease", "fulleget", "fullerUpdate", "fullerupdate", "complete_write", "fullCupdate", "complete_range", " full_view", "fulllexupdate", "fulllexsave", "full_apply", "fulllexwidth", "fullerapply", "fullworkget", "halferevent", "fullurewrite", "full_end", "full_get", " full_report", "fullOwidth", "fullureupdate", "full_save", "fullCrange", "full_init", "half_update", " full_end", "fullOversion", "fullOinit", "fulleload", "fullworkupdate", "fulleupdate", "full_range", " full_version", "half_apply", "halferUpdate", "full_report", "full_view", "fulllexinit", "fullOview", "fullewrite", "full_width", "full_load", "complete_update", " full_release", "full_release", " full_\n", "halferapply", " full_write", "full_Update", "complete_get"], "y1": ["ya01", "Y1", "Y01", "y01", "ya1", " y01"], "y": ["n", "g", "w", "m", "b", "x", "ey", "z", "vy", "t", "i", "c", "cy", "p", "e", "q", "f", "yy", "o", "Y", "h", "xy", "pos", "ip", "yn", "image", "dy"], "update": ["updated", "delay", "scale", "date", "m", "id", "num", "enable", "draw", "layout", "e", "status", "q", "o", "version", "index", "sync", "current", "wait", "edit", "check", "position", "node", "u", "image", "write"], "page_min": ["pagexlimit", "page_limit", "pagexsize", "pagexmax", "pagexmin", "page_size", " page_limit", " page_size"], "page_max": [" page_start", "page_start", " page_range", "page_range"], "linesize": ["pagesizer", "imagesizing", "linesizer", "pagesiz", "linsizer", "imagesize", "imagesizer", "linsiz", "pagesize", "linesizing", "linesiz", "linsize", "linsizing", "pagesizing", "imagesiz"], "y_start": ["y_range", "line_start", "line_min", "line_end", "y_min", "y_end", "y2range", "y2start", "y2min", "y2end", "line_range"], "double_scan": ["full_scan", "double_copy", "double\u00b7search", "Double_scan", "double_search", "double_control", "doublelyplan", "double_query", "double_read", "double_skip", "double\u00b7query", "double_plan", "doublelysc", "doublelycopy", "double_sc", "double\u30dfread", "multi_query", "multi_search", "double_rate", "doublelyscan", "full_batch", "multi_plan", "multi_skip", "double_batch", "double\u30dfrun", "doublelyerror", "double_run", "double\u00b7scan", "multi_error", "multi_copy", "multi_rate", "Double_control", "double_fill", "double_match", "doublelyfill", "doublelymatch", "double\u30dfscan", "doublelysearch", "Double_run", "full_match", "Double_search", "double_error", "doublelybatch", "multi_read", "multi_sc", "double\u00b7run", "multi_control", "doublelyrun", "multi_fill", "double\u30dfskip"], "mask": ["count", "delay", "flag", "scale", "window", "pad", "clear", "batch", "qa", "skip", "sk", "dr", "mode", "flags", "quiet", "ask", "counter", "cost", "details", "dark", "black", "bit", "lock", "image", "cache", "weight", "random"], "depth": ["count", "level", "dim", "delay", "rate", "scale", "debug", "len", "features", "pad", "id", "max", "dist", "mode", "padding", "dr", "progress", "dir", "slice", "deep", "repeat", "dc", "grade", "grad", "length", "weight", "seed", "direction"], "height": ["rank", "dim", "rows", "window", "w", "id", "x", "resolution", "density", "wrap", "bottom", "max", "layout", "quality", "style", "thin", "padding", "Height", "size", "shape", "slice", "input", "h", "row", "gap", "length", "image", "inches", "direction"], "shift_control": ["shiftaclimit", "shiftallcontroller", "force_controller", "shift_align", "carry_limit", "transfer_scale", "force_control", "shiftlexcontrol", "shiftxcontrolled", "shift\u00b7length", "shiftpignore", "shiftingcontrol", "shiftalladdress", "secondaryxcontrol", "shiftpcontrol", "push_scan", "shift_ignore", "push_update", "shift\u00b7control", "shiftacalign", "shift_run", "shiftingforward", "secondary_controlled", "shiftlexscale", " shift_correct", " shift_controlled", "shift_update", "shiftaccorrect", "shiftxrun", "shiftaccontrolled", "push_length", "shift_forward", "shiftingcontrolled", "shift_width", "carry_controlled", "shiftlexcontroller", "shiftxcontroller", "shift_scan", "shiftallcontrol", " shift_forward", "shiftaccontroller", "shiftaccontrol", "shiftpedit", "transfer_address", " shift_run", "shift\u00b7update", "push_control", "push_width", "shift_scale", "shiftxcorrect", "shift_edit", "carry_control", "shift_length", "secondaryxcontroller", "shift_release", "secondary_correct", "carry_align", "shiftlexaddress", "shift_correct", "shiftingrun", " shift_edit", "transfer_controller", "push_controlled", "force_release", "shift_controller", "shift_limit", "shiftacrun", "transfer_control", " shift_ignore", " shift_controller", "secondary_controller", "shift_address", "shift_controlled", "shiftxcontrol", "secondaryxcontrolled", "secondaryxcorrect", "shiftallscale", "secondary_control", "shift\u00b7scan", "force_correct", "shiftpcontrolled"], "line_offset": ["line2offset", "line2slot", "line_index", "line2index", "inline_start", "inline_index", "line_start", "line___slot", "line___offset", "line___index", "inline_slot", "line___start", "line2start", "line_slot", "inline_offset"], "page0": ["page4", "row4", "row2", "row50", "line4", " page2", "line0", " page50", "line50", "page2", "row0", " page4", "page50", "line2"], "page1": ["line01", " page01", "line1", "limit1", "page2", "limit2", "limit01", "page01", " page2", "line2"], "bwidth": ["bweight", "nwidth", " bvalue", "dweight", "dwidth", " bWidth", "nWidth", " bweight", "bWidth", "dvalue", "bvalue", "nvalue", "dWidth", "nweight"], "bits": ["vals", "BIT", "its", "frames", "rows", "features", "dates", "ports", "fixes", "batch", "pieces", "parts", "steps", "ins", "cats", "bands", "planes", "lines", "bles", "pins", "plugins", "limits", "items", "ints", "flags", "bugs", "bps", "fps", "checks", "notes", "bis", "locks", "cycles", "breaks", "levels", "blocks", "details", "bytes", "bit", "gets", "points", "ips", "bin", "bs", "units", "issues", "lins"], "disp_width": ["dispatch_size", "disc_size", "disp_length", "disp_left", "disp_line", "disc_line", "disping64width", "disp_speed", "dispatch_speed", "disc_width", "disping_size", "disp64width", "disp64value", "disp_weight", "disp_value", "disping_level", "disp64size", "disping_width", "disping64value", "dispatch_width", "dispatch_left", "disc_weight", "disping64level", "disp_level", "disp64level", "disp_size", "dispatch_length", "disping64size", "disping_value"], "multi_scan": ["multiFscan", "multi_move", "multi_keep", "multilexscan", "multijkeep", "multiFkeep", "double_walk", "double_run", "multiackeep", "single_apply", "multijrun", "multi_watch", "single_run", "multilexkeep", "multiacskip", "multiacscan", "double_move", "multi_cat", "multijapply", "multi_apply", "double_keep", "multi67run", "multiacrun", "multiFrun", "double_skip", "multiFapply", "multijscan", "multi_walk", "multi_skip", "multilexskip", "multi67scan", "multilexrun", "multi67cat", "double_cat", "multi67watch", "single_scan", "single_keep", "double_watch"], "multi_run": ["multiPupdate", "multiPloop", "multi___loop", "multi_update", "multiPrun", "single_run", "multiPscan", "multi_loop", "multi_min", "multi___update", "multi___run", "single_min", "single_update", "multi___min", "single_scan", "single_loop"], "d": ["dp", "diff", "l", "dim", "dh", "ds", "n", "w", "m", "dt", "b", "x", "i", "c", "data", "ad", "p", "e", "dist", "f", "dl", "dir", "xd", "dc", "dx", "D", "direction"], "v": ["vs", "l", "vi", "vals", "va", "vert", "sv", "n", "g", "val", "view", "w", "m", "k", "x", "b", "z", "iv", "t", "i", "ver", "ve", "c", "ov", "var", "p", "e", "value", "q", "f", "j", "code", "ev", "qv", "o", "vol", "version", "fl", "cv", "values", "uv", "r", "conv", "V", "end", "vo", "ii", "u", "h", "pos", "av", "vv", "rev", "volt", "vp"], "addr1": [" addr01", "addr01", "ptr0", "dist1", "ptr1", "addr0", "ptr01", "dist01", "dist0", " addr0"], "addr": ["dp", "mac", "arr", "delay", "xp", "len", "da", "pad", "iii", "src", "add", "dist", "amd", "ptr", "mode", "dr", "nd", "align", "md", "address", "layer", "grad", "nc", "aa", "pos", "ip", "nn", "direction"], "vga_draw_line": ["vga_draw_inline", "vga_draw_point", "vga_draw_lines", "vga_draw2point", "vga_draw2inline", "vga_create_line", "vga_draw2lines", "vga_create_point", "vga_create_inline", "vga_draw2line", "vga_create_lines"]}}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n", "idx": 9510, "substitutes": {"mask": ["count", "diff", "map", "alias", "conf", "Mask", "arr", "filter", "fix", "delay", "flag", "scale", "comment", "auth", "depth", "key", "pad", "id", "pack", "mount", "mm", "block", "data", "sum", "config", "addr", "reg", "secret", "bits", "sk", "mode", "code", "mark", "shape", "size", "trace", "flags", "wait", "address", "mod", "ask", "user", "patch", "check", "offset", "bit", "lock", "allow", "type", "dev", "header", "image", "result", "cache", "buff", "weight", "buffer"], "attr": ["alias", "adr", "arr", "cmp", "si", "alt", "access", "class", "perm", "method", "conn", "rr", "stat", "config", "addr", "ref", "app", "cb", "rel", "ptr", "rad", "prop", "atts", "rs", "f", "ac", "rb", "ai", "rt", "ctrl", "py", "opt", "sync", "ind", "attach", "r", "att", "address", "err", "mut", "ii", "offset", "spec", "error", "type", "layer", "api", "attribute", "func", "cache", "match", "fac", "ann", "fi", "typ", "acc"], "tid": ["Tname", "untids", " tone", "pids", "pid", "tids", " tids", "untid", "nids", "pip", "toid", "nid", "nname", "pone", "tip", "untname", " tip", "Toid", "fids", "fid", "noid", "fip", "fone", "Tids", "tname", "untoid", "tone", "Tid"], "info": ["diff", "alias", "hi", "conf", "ui", "fo", "start", "si", "Info", "handle", "source", "comment", "is", "def", "ext", "id", "conn", "http", "inter", "ami", "update", "fw", "i", "data", "config", "INFO", "obj", "afi", "txt", "thin", "args", "bug", "f", "op", "py", "trace", "index", "hand", "name", "gi", "order", "att", "inner", "raf", "part", "error", "ii", "offset", "now", "init", "link", "type", "self", "lock", "handler", "api", "options", "fs", "ignore", "image", "result", "inf", "cache", "ret", "extra", "help", "fi", "buff"], "fds": [" fns", "tfds", "ifords", "ifds", " fDS", "fdds", "rfd", "ofords", "afDS", "sfds", "fDS", " fdes", "fdes", "pdds", "fd", "dfdds", "fmails", "ofns", "fords", "sfdds", " fords", " fdd", "sfdes", " fd", "pDS", "fdd", "afds", " fmails", "ifns", "fns", "dfds", "dfmails", "rfds", "afdds", "tfdds", "sfdd", "ofds", "rfdds", "tfdes", "rfmails", "tfdd", " fdds", "afns", "ifdds", "pns", "dfd", "pds", "ofdds"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n", "idx": 9516, "substitutes": {"vs": ["vals", "va", "uses", "ks", "sv", "ds", "stats", "alls", "src", "http", "ils", "pps", "vers", "VS", "iss", "gs", "vt", "ports", "cp", "ls", "ov", "qs", "ins", "env", "outs", "xs", "rs", "os", "sk", "vas", "obs", "cs", "v", "es", "otes", "sts", "fps", "eps", "state", "services", "las", "ns", "hs", "ms", "vr", "fs", "ps", "ses", "ss", "bs", "vp"], "data": ["map", "sample", "seq", "base", "valid", "start", "window", "media", "da", "pad", "id", "open", "d", "buf", "i", "ad", "batch", "p", "reader", "ada", "feed", "empty", "body", "DATA", "dat", "values", "size", "v", "input", "response", "end", "Data", "offset", "bytes", "pos", "client", "api", "result", "cache", "text", "buffer", "events"], "len": ["count", "l", "seq", "base", "lf", "start", "str", "val", "all", "block", "limit", "el", "ls", "db", " length", "size", "lib", "min", "en", "type", "pos", "length", "Len", "rev"]}}
{"project": "FFmpeg", "commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "target": 1, "func": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n", "idx": 9528, "substitutes": {"h": ["l", "hi", "sh", "ht", "context", "n", "g", "ph", "hr", "hh", "w", "m", "http", "t", "x", "z", "d", "i", "c", "s", "p", "hm", "e", "eh", "q", "f", "host", "o", "ha", "v", "ih", "r", "hp", "oh", "hs", "beh", "u", "H", "self", "hl", "ah", "y", "rh", "uh"], "pmv_fw": ["pmm_hw", "pmf_wu", "pmc_wd", "pmc_kw", "pmv_feat", "pmv_w", "pmm__fw", "pmc_fw", "pmov_fw", "pmv_wd", "pmov__wd", "pmv__hw", "pmov_wcs", "pmv_wu", "pmm__w", "pmv__wcs", "pmc_hw", "pmov_wd", "pmf_feat", "pmov__nw", "pmov_nw", "pmv_nw", "pmv__nw", "pmf_hw", "pmm__wk", "pmv__wk", "pmf_fo", "pmv_wk", "pmv_hw", "pmv_wcs", "pmv_fo", "pmv_kw", "pmm_fw", "pmv__w", "pmf_fw", "pmf_w", "pmc_w", "pmv__wd", "pmov__fw", "pmf_wy", "pmm_w", "pmf_nw", "pmv_wy", "pmm_wk", "pmv__fw", "pmov__wcs", "pmm__hw", "pmc_nw"], "col_mv": ["col_vv", "col_mmk", "col_cmov", "col_nver", "col_dmb", "col_Mov", "col_dmm", "col2mf", "col_cmver", "col_mb", "col_vf", "col_Mv", "col_mc", "col2mc", "col_Mver", "col_Mm", "col_emb", "col_Mx", "col_cmb", "col_mk", "col2Mb", "col_mver", "col_vver", "col_mf", "col2Mc", "col_mov", "col_mx", "col_nv", "col_cmf", "col_emf", "col_nx", "col_cmm", "col_cmv", "col_mmf", "col_ymov", "col_mmv", "col_Mf", "col2mv", "col_nc", "col_emv", "col_ymf", "col_nb", "col_ymv", "col_dmf", "col_Mk", "col_cmx", "col_mmb", "col_ymb", "col_cmk", "col_nf", "col_dmv", "col2Mf", "col_vb", "col_mm", "col_Mb", "col2mb", "col_Mc", "col2Mv", "col_cmc", "col_emver"], "pmv_bw": ["pmv_eway", "pmv_ubwd", "pmv5bwk", "pmv_adw", "pmv_dwk", "pmv_ubaw", "pmv_barwk", "pmv_lbwa", "pmv_bway", "pmv_ewal", "pmv_vwk", "pmv__bwt", "pmv_bbway", "pmv_bwt", "pmv_vtw", "pmv_ubw", "pmv_bbwa", "pmv5lbwa", "pmv_bwer", "pmv8ubwd", "pmv8ubw", "pmv_adwal", "pmv_fwal", "pmv_fws", "pmv8bwer", "pmv_bewal", "pmv_pw", "pmv_drw", "pmv_brw", "pmv_bws", "pmv_bwk", "pmv5lbwk", "pmv_adway", "pmv_btW", "pmv_bbtw", "pmv_dwer", "pmv_fsw", "pmv_lwt", "pmv_bbw", "pmv_lw", "pmv_bwa", "pmv5bwa", "pmv_vw", "pmv_dw", "pmv5lbw", "pmv_fwd", "pmv_faw", "pmv__bw", "pmv_btwt", "pmv_fwer", "pmv_bbwal", "pmv_rbw", "pmv_psw", "pmv_barwd", "pmv_bew", "pmv8bwd", "pmv_fwt", "pmv8ubwer", "pmv_besw", "pmv_pwt", "pmv_pW", "pmv_lws", "pmv_daw", "pmv_adwa", "pmv_barrw", "pmv_lbtw", "pmv8baw", "pmv_bsw", "pmv_lbw", "pmv_ew", "pmv_bews", "pmv_bW", "pmv_ubwer", "pmv_vwa", "pmv5lbtw", "pmv_lbwk", "pmv8bw", "pmv_dwd", "pmv_baw", "pmv5bw", "pmv_btw", "pmv_btwal", "pmv_bbwk", "pmv_rbwk", "pmv_rbrw", "pmv8ubaw", "pmv_bwal", "pmv__bW", "pmv_barw", "pmv_pwal", "pmv_ewa", "pmv_pws", "pmv__bwal", "pmv_rbwd", "pmv_bwd", "pmv_lsw", "pmv5btw"]}}
{"project": "FFmpeg", "commit_id": "22fa38f0c85fb31cddbb0bc22a2df5953c702b95", "target": 0, "func": "static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n", "idx": 9533, "substitutes": {"p0": [" p2", "q7", "q1", "p2", "q0", "c7", "c0", "cp1", "q2", "p1", " p1", "p7", "c2", "c1", "cp0", " p7", "cp2"], "temp": ["area", "eff", "base", "valid", "test", "cases", "tc", "cash", "t", "total", "mix", "Temp", "pool", "wrap", "c", "comb", "p", "output", "a", "fit", "iter", "pt", "mini", "average", "tmp", "empty", "none", "unit", "zero", "multi", "non", "fake", "amp", "wave", "current", "input", "wait", "order", "pre", "one", "new", "adapt", "now", "tim", "copy", "out", "crop", "cel", "single", "common", "clean", "tem", "null", "cache", "api", "emp", "flat", "partial", "warm", "mag", "buffer"], "uncliped": ["unapeable", "unclipsable", " unclipeded", "unclipED", "unclipsmented", "uninpaed", "unincliped", " uncapable", "uncapled", "unclipned", "uninpad", " uncapled", "uncapable", "unclipeded", " unclipsed", "unclipmented", "unpaeds", "unpad", "unclipsled", " unclipened", "unclipeds", "uncutd", "unclipseds", "uncutmented", "unpamented", "unscripted", " unclipled", "unapeed", "unclipsed", "unclipable", "uncuteds", "uncuted", "uninclipd", " unclipable", "unclipsened", " unclipED", "unclipseded", "unapeED", "uncutned", "uncuteded", "unscriptened", "unscripteded", " unclipned", " unclipsned", "unscriptned", "uncutened", "uninclipmented", "unclipsED", "unclipened", " unclipsened", "unapeled", " unclipseded", "uncaped", " uncaped", "uninclipeds", "uninpamented", "unclipled", "unclipsned", "unclipsd", "unpaed", "uninpaeds", "uncapED", "unclipd", " uncapED"], "ones": ["vals", "sample", "tones", "original", "amps", "ks", "keys", "plus", "frames", "cells", "rows", "aps", "na", "cases", "ops", "s", "ls", "names", "ins", "steps", "oned", "bits", "outs", "lines", "offs", "clone", "os", "none", "parents", "alpha", "values", "zero", "size", "packs", "cycles", "ans", "custom", "blocks", "ms", "ays", "less", "faces", " clones", "eros", "les", "pos", "null", "ips", "common", "ps", "points", "one", "ases"], "max": ["count", "diff", "parent", "conf", "ox", "co", "mad", "std", "scale", "plus", "n", "est", "ax", "pad", "w", "id", "x", "z", "last", "wrap", "ad", "sum", "from", "final", "act", "step", "none", "height", "only", "alpha", "size", "Max", "end", "az", "mod", "old", "full", "first", "frac", "now", "init", "crop", "self", "ca", "cycle", "cache", "anc", "range"], "min": ["Min", "area", "seq", "is", "n", "len", "span", "in", "prefix", "na", "ax", "start", "m", "small", "x", "sum", "s", "p", "limit", "mine", "skip", "po", "mini", "act", "mins", "none", "only", "index", "size", "non", "version", "minus", "pre", "mod", "part", "ms", "sign", "init", "mean", "pos", "null", "ps", "ng", "partial"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,\n\n                                target_ulong pc2, TCGv r_cond)\n\n{\n\n    int l1;\n\n\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);\n\n\n\n    gen_goto_tb(dc, 0, pc2, pc1);\n\n\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);\n\n}\n", "idx": 9546, "substitutes": {"dc": ["dp", "cdn", "CC", "oc", "DC", "context", "abc", "da", "cca", "tc", "dt", "d", "toc", "c", "config", " DC", "cd", "cf", "ec", "bc", "ac", "cc", "db", "design", "rc", "input", "ctx", "circ", "desc", "pc", "disc", "dm", "nc", "ca", "director", "vc", "lc", "jc", "mc", "uc", "sc", "fc"], "pc1": ["fcone", "mc2", "arcb", "PC2", "PCone", "arc1", "fc2", "fc1", "arc2", "PCb", "lcone", "pcone", "fc3", "pc3", "lc1", "lc3", "pcb", "mcb", "lc2", "mc1", "PC1", "PC3"], "pc2": ["rc4", "rc02", "fc8", "rc2", "rc8", "fc4", "c8", "pc02", "PC2", "pc0", "arc1", "rc1", "fc2", "c0", "PC8", "arc3", "lc4", "fc1", "PC02", "pc8", "arc2", "PC0", "pc3", "c2", "lc1", "PC4", "rc0", "lc8", "c1", "lc2", "arc02", "pc4", "rc3", "PC1", "PC3"], "r_cond": ["R_pre", " r2sec", "rbCond", "r2sec", "racCond", " r_condition", "R_condition", "raccond", " r_sec", "rxCond", " r_Cond", "racsec", " r2condition", "r2condition", "rxcond", "r_sec", "r2cond", "rxpre", "raccondition", "r_Cond", "rbcondition", "rbcond", "R_Cond", "rxcondition", "rbsec", "r_pre", "r_condition", " r2Cond", "R_cond", " r2cond", "r2Cond"], "l1": ["l3", " l0", " l8", "l2", " l31", "pl31", " l9", "v9", "L9", " l2", "pl2", "l0", "v0", " ln", "Ln", "pln", "l31", "L3", "r1", "r2", "L1", "lc31", "pl1", "lc1", "r3", "lc3", "L8", "lcn", "lc2", "v2", "r8", " l3", "L0", "L2", "v1", "ln", "l9", "l8"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "substitutes": {"bs": ["vs", "base", "bb", "ks", "ds", "bas", "bm", "b", "iss", "sa", "ls", "pb", "cb", "gb", "bits", "us", "rs", "BS", "os", "bc", "js", "obs", "cs", "bl", "bps", "es", "bh", "lb", "bi", "ns", "sb", "ms", "fs", "ses", "ps", "ob", "css", "ss", "bos"], "offset": ["count", "location", "seq", "timeout", "base", "initial", "start", "nb", "len", "prefix", "conn", "id", "shift", "slot", "ron", "config", "ref", "addr", "meta", "fp", "set", "off", "loc", "o", "index", "alloc", "size", "slice", "end", "address", "acl", "part", "position", "error", "type", "pos", "url", "fee", "Offset", "reset"], "n_start": [" n_base", "nunlast", "n_last", "nFlast", " n_last", "nFbase", "nFend", "nFstart", "n_base", "nunbase", "nunend", "nunstart"], "n_end": ["n_info", "n__start", " n2info", "n__all", " n2start", " n_all", " n2all", "nunstop", " n_stop", "nunrange", "n2end", "n2info", " n2end", "n_range", " n_range", "n_all", "n__end", "n__info", "n2all", "n_stop", "n2start", "nunend", "nunstart", " n_info"], "num": ["count", "seq", "dim", "len", "alt", "id", "mult", "mem", "con", "batch", "max", "split", "number", "off", "f", "mid", "multi", "index", "ctr", "Num", "node", "orig", "init", "uni", "fn", "um", "NUM"], "m": ["man", "n", "g", "mr", "bm", "b", "t", "mm", "gm", "mem", "d", "i", "metadata", "c", "p", "meta", "e", "machine", "pm", "f", "manager", "fm", "o", "mp", "v", "mi", "r", "md", "sm", "ms", "tm", "dm", "h", "cm", "mt", "M", "mc", "rm"], "s": ["vs", "sg", "ts", "ks", "sv", "ds", "is", "si", "g", "its", "sites", "stats", "b", "t", "stat", "ops", "gs", "sa", "c", "p", "ls", "se", "e", "ins", "qs", "xs", "rs", "sq", "js", "os", "f", "cs", "sym", "sets", "S", "v", "sync", "states", "sl", "state", "services", "sn", "ns", "storage", "sb", "spec", "ms", "sys", "sim", "ses", "fs", "su", "ps", "y", "ss", "settings"], "l2_index": ["l2acindex", "l96_lock", "l2_region", "l2_dimension", "l2Mdimension", "lao_index", "l2hthread", "l2_slice", "l52Jthread", "l96Jdimension", "l2_length", "lappingJlength", "l2dslice", "l2xinfo", "l4_info", "l2Cposition", "l2Hindex", "l96Jwidth", "l96_width", "laoamcount", "l2_header", "l2kindex", "l2_ini", "l2_module", "l52_module", "l2vkey", "l2vregion", "l2Jlock", "l2amcount", "l2dini", "laoammodule", "l96_dimension", "lapping_index", "l1_length", "l2_shape", "l2_key", "l2_value", "l2dindex", "l4_region", "l2kheader", "l2hmodule", "l2klabel", "l2Mindex", "l96_index", "l2Jlabel", "l2Jthread", "l1_index", "lapping_length", "l2xslice", "l2Mwidth", "l52_thread", "l2vindex", "lappingJindex", "l22dslice", "l2amindex", "l2ammodule", "l22dindex", "l2Celement", "l22dini", "l4_slice", "l4_size", "l52Jindex", "l22_ini", "l22_slice", "l22_element", "l2_Index", "l1_slice", "l2amshape", "ltwo_value", "l2Hwidth", "l2acelement", "l2Jdimension", "l4_Index", "l2_label", "ltwo_index", "l52Jmodule", "l2fheader", "l2hindex", "l2Hdimension", "l2xindex", "l2klength", "l52_index", "lao_count", "l2Jheader", "l4_key", "lappingJlabel", "ltwo_element", "laoamshape", "l2Hlock", "l96Jlock", "lapping_header", "l2Jmodule", "l2acvalue", "l4_index", "lao_module", "l22delement", "lapping_label", "lao_shape", "l2_lock", "l1_size", "ltwo_position", "l52Jpath", "lappingJheader", "l2Mlock", "l2_width", "l2Cvalue", "laoamindex", "l2_thread", "l22_index", "l2acposition", "l2delement", "l2hpath", "l2_path", "l52_path", "l2_count", "l2Jindex", "l2xlength", "l2Cindex", "l2Jlength", "l2findex", "l2_info", "l2flabel", "l2_position", "l2_size", "l2Jwidth", "l96Jindex", "l2_element", "l2xsize", "l2vIndex", "l2Jpath", "l2flength"], "ret": ["count", "arr", "rem", "ext", "len", "val", "alt", "g", "info", "nt", "Ret", "conn", "b", "i", "ref", "obj", "status", "reg", "iter", "rets", "f", "j", "rt", "res", "bf", "det", "al", "opt", "mi", "r", "att", "fun", "en", "hash", "ur", "re", "RET", "back", "result", "rev", "match", "ber", "fi", "success"], "l2_offset": ["l2_type", "l4_offset", "l2xstart", "l4_type", "l2xoffset", "l2xOffset", "l1_Offset", "l1_offset", "l1_start", "l2_size", "l2_Offset", "l4_index", "l2_start", "l4_size", "l2xsize", "l1_size"], "l2_table": ["l2xstable", "l2Ptable", "l02scontainer", "l2jblock", "l2Ptab", "l2Pconfig", "l2stype", "l2scontainer", "l2dtree", "l02_stable", "ltwosfeature", "l2ttable", "l2_page", "l6_module", "lserverstable", "l2Jfeature", "l2_module", "l2_cache", "l2_tab", "l2soffset", "ltwo_view", "lserverscache", "l2_package", "l2_body", "l6_stable", "ltwo_table", "l2_container", "l2Jtable", "l2jmodule", "l2tstable", "l6_body", "l2thestable", "ltwo_body", "lserversoffset", "l2jpackage", "l2_file", "l2Jview", "l2tbody", "l02_table", "l3_size", "l02_page", "l2Jbody", "l6_table", "l2xpackage", "l02sstable", "l3_tree", "l6_tree", "l2xblock", "l2_type", "lserver_table", "l6_time", "lserver_offset", "lserver_type", "ltwo_feature", "l02spage", "l2sfeature", "l6_block", "l2xmodule", "l2thecontainer", "l2sstable", "l3_cache", "l6_file", "l2dtime", "l2tcache", "l2sview", "l2_block", "l2spage", "l2thetable", "ltwosbody", "l6_tab", "l02_container", "l2xtable", "l2jtable", "l2xcontainer", "l2scache", "l6_cache", "l6_index", "l2thepage", "l2Pindex", "ltwostable", "l2_config", "l2_tree", "l6_config", "lserver_cache", "l2_feature", "l6_package", "l02stable", "l2sbody", "l2xpage", "l2_stable", "l2_view", "ltwosview", "l2_size", "l2_time", "l2stable", "l2dfile", "lserverstype", "l2dtable", "l3_table"], "cluster_offset": ["cluster67offset", "clusteracoffset", "clusterLend", "cluster_attribute", "clusterPend", "cluster_entry", "cluster_off", "clusterLoffset", "clusterPpadding", "clinical_Offset", "clard_entry", "cluster67format", "clusterFattribute", "clancPleft", "clrome_url", "clrome67offset", "clusterLpadding", "clusterFpadding", "clrome67shift", "clusterPOffset", "clider_ref", "clrome_position", "clause_off", "clution_padding", "clution_attribute", "cluster_position", "clause_offset", "cluster_ref", "clutionFpadding", "clanc_format", "cluster_option", "cluster67left", "cluster_format", "clutionFattribute", "cluster_count", "clard_start", "cluster_addr", "clinical_limit", "clusterPentry", "clutionFend", "cluster_Offset", "cluster_padding", "clause_addr", "clusterPleft", "clanc_Offset", "clutionFoffset", "clause_Offset", "clancPformat", "cluster_start", "cluster_left", "cluster_size", "clider_offset", "cluster_shift", "clusterFend", "clause_set", "cluster67url", "clusterPstart", "cluster67Offset", "cluster67position", "cluster_area", "clution_end", "clusteracOffset", "clrome67position", "cluster_end", "clanc_offset", "clanc_left", "cluster_set", "clution_offset", "clusterLattribute", "clusteraclimit", "clusterPoffset", "cluster67shift", "clrome67url", "clrome_offset", "cluster_url", "clancPOffset", "clinical_offset", "clause_area", "cluster_limit", "clard_offset", "clider_count", "clinical_option", "clusterFoffset", "clusterPattribute", "clancPoffset", "clusteracoption", "clause_end", "clusterPformat", "clider_size", "clrome_shift"], "nb_clusters": ["nb_declunks", "nb_contusters", "nb00flappers", "nb_pluster", "nb_sclocations", "nb_custers", "nb00sclocations", "nb67decunks", "nb_blancers", "nb_licusters", "nb_combicas", "nb_blroups", "nb_clonents", "nb_chuster", "nb67clayers", "nb00clappers", "nb_slorders", "nb_sclashes", "nb00flroups", "nb_compashes", "nb_combonents", "nb_sclusters", "nb_clients", "nb_zusters", "nb00sclusters", "nb_slusters", "nb_combroups", "nb_lconents", "nb67clorders", "nb_decients", "nb_ciders", "nb_clists", "nb00explists", "nb_declappers", "nb_compusters", "nb_decunks", "nb_flroups", "nb_blitors", "nb_chitors", "nb_bluster", "nb00flusters", "nb__clords", "nb_collodes", "nb_collicas", "nb00sclorders", "nb2chitors", "nb_filunks", "nb_decayers", "nb_plashes", "nb_clurations", "nb00clists", "nb_explusters", "nb00explusters", "nb_plonents", "nb_llorders", "nb2chores", "nb_clorders", "nb_clocations", "nb2chusters", "nb67decorders", "nb_sclores", "nb00clubes", "nb_plores", "nb_clores", "nb_plicas", "nb_chusters", "nb00clroups", "nb_conticas", "nb_clust", "nb_clayers", "nb_condusters", "nb_decusters", "nb_cancers", "nb_clitors", "nb_explubes", "nb_splust", "nb_deciders", "nb_lcust", "nb_condores", "nb_chicas", "nb_clancers", "nb_glorders", "nb_decancers", "nb_chances", "nb_tust", "nb2clusters", "nb67clunks", "nb_turations", "nb_lcroups", "nb_clodes", "nb_explunks", "nb_clords", "nb_chients", "nb__clicas", "nb_blients", "nb_lcappers", "nb_filubes", "nb00clust", "nb_zappers", "nb2clores", "nb_condients", "nb_zust", "nb_glusters", "nb_llusters", "nb_declorders", "nb_clances", "nb_plusters", "nb_bliders", "nb_clunks", "nb_clashes", "nb__clodes", "nb67clusters", "nb_slunks", "nb_licances", "nb_contodes", "nb00clodes", "nb_flusters", "nb67decayers", "nb_plroups", "nb2clients", "nb_explists", "nb2chients", "nb_filusters", "nb_filists", "nb2clitors", "nb_collords", "nb_declroups", "nb_combusters", "nb__chodes", "nb_flust", "nb_cliders", "nb_splusters", "nb_clubes", "nb00explunks", "nb_blances", "nb_scluster", "nb_conditors", "nb_chroups", "nb__chords", "nb_slayers", "nb_llocations", "nb_blores", "nb_tappers", "nb__clusters", "nb_splurations", "nb_lcusters", "nb_lcicas", "nb_sclorders", "nb_declusters", "nb_declayers", "nb_zurations", "nb_glodes", "nb_clicas", "nb_declust", "nb_sclodes", "nb00explubes", "nb_chodes", "nb_tusters", "nb_chords", "nb_clroups", "nb_licuster", "nb_compores", "nb_glocations", "nb00clorders", "nb_licroups", "nb_cluster", "nb__chicas", "nb_splists", "nb_cients", "nb_chores", "nb_compuster", "nb00sclodes", "nb_splubes", "nb_clappers", "nb__chusters", "nb_llodes", "nb_splunks", "nb00clusters", "nb_blusters", "nb00clunks", "nb_decorders", "nb67decusters", "nb_splappers", "nb_contords", "nb00clocations", "nb_flappers", "nb00flust", "nb_collusters"], "old_alloc": ["old__stat", " old_meta", " old_stat", "old_meta", "old2aux", "old2stat", "old__meta", "old2meta", "old2alloc", "old__alloc", "old_aux", "old_stat", " old_aux", "old__aux"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static int tx_consume(Rocker *r, DescInfo *info)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    char *buf = desc_get_buf(info, true);\n\n    RockerTlv *tlv_frag;\n\n    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\n\n    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\n\n    uint32_t pport;\n\n    uint32_t port;\n\n    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;\n\n    uint16_t tx_l3_csum_off = 0;\n\n    uint16_t tx_tso_mss = 0;\n\n    uint16_t tx_tso_hdr_len = 0;\n\n    int iovcnt = 0;\n\n    int err = ROCKER_OK;\n\n    int rem;\n\n    int i;\n\n\n\n    if (!buf) {\n\n        return -ROCKER_ENXIO;\n\n    }\n\n\n\n    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\n\n\n\n    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\n\n    if (!fp_port_from_pport(pport, &port)) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {\n\n        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);\n\n    }\n\n\n\n    switch (tx_offload) {\n\n    case ROCKER_TX_OFFLOAD_L3_CSUM:\n\n        if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    case ROCKER_TX_OFFLOAD_TSO:\n\n        if (!tlvs[ROCKER_TLV_TX_TSO_MSS] ||\n\n            !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n        tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_MSS]) {\n\n        tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n        tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]);\n\n    }\n\n\n\n    rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) {\n\n        hwaddr frag_addr;\n\n        uint16_t frag_len;\n\n\n\n        if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        if (iov[i].iov_base) {\n\n            g_free(iov[i].iov_base);\n\n        }\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 9574, "substitutes": {"r": ["rf", "ru", "g", "rw", "w", "m", "mr", "rr", "b", "t", "kr", "d", "ra", "c", "s", "p", "reader", "e", "rss", "rb", "rs", "er", "f", "lr", "dr", "rt", "o", "v", "R", "rc", "rar", "ro", "self", "re", "rx", "rg", "br", "rob", "sr", "rh", "rl"], "info": ["diff", "rf", "conf", "fo", "si", "Info", "iso", "source", "prof", "auth", "def", "id", "fw", "d", "data", "information", "config", "p", "INFO", "afi", "txt", "thin", "off", "f", "manager", "entry", "rt", "linux", "description", "rc", "about", "req", "inner", "user", "bis", "end", "ctx", "error", "now", "init", "type", "api", "options", "fs", "extra", "io", "inf", "buff", "text", "fi"], "dev": ["conf", "di", "debug", "tr", "prof", "Dev", "def", "w", "conn", "pack", "ver", "rec", "ra", "data", "pro", "reg", "ev", "device", "res", "lib", "rc", "end", "dd", "raf", "fin", "ro", "proc"], "buf": ["bag", "uf", "seq", "Buffer", "context", "src", "pack", "fd", "b", "path", "fw", "fi", "doc", "data", "block", "fb", "config", "pb", "obj", "cb", "fp", "queue", "feed", "cf", "prop", "bc", "f", "alloc", "cv", "v", "msg", "aux", "rc", "cas", "ctx", "conv", "callback", "desc", "bytes", "header", "result", "vec", "buff", "text", "proc", "func", "br", "buffer", "bin", "box", "uc"], "tlv_frag": ["tlv_flag", "tlv_frags", "tlvsbrags", "tlv_branch", "tlvsfrags", "tlv_bragged", "tlvsbragged", "tlv_brags", "tlv_flags", "tlvsfrag", "tlvsbranch", "tlv_franch", "tlv_brag", "tlvsfragged", "tlv_fragged", "tlv_flanch", "tlv_flagged", "tlvsbrag", "tlvsfranch"], "tlvs": ["tlvstates", "itlvn", "itllabs", "tlle", "tlevd", "tdeps", "attdepn", "tlvb", "attlvids", "attlvs", "tlevns", "tLVs", "tllu", "tllabs", "untrelld", "tcpabs", "glvi", "glve", "tlvS", "attdepids", "Tlevns", "taggu", "intjectu", "tcpn", "intlvs", "tllns", "tlfns", "twld", "tlevi", "Tlvu", "tcfs", "tlvns", "Tlvd", "tlvabs", "untrellstates", "Tlevu", "attdeps", "attlvS", "tcps", "tlvd", "tlls", "glegi", "tllS", "tlfd", "Tlvns", "tleve", "tlege", "glvs", "tLVS", "tagge", "Tlevb", "tjectu", "Tlvs", "tservs", "tlln", "tLVids", "tcfabs", "untlvs", "tlevu", "tLVn", "taggs", "twlu", "tlvi", "tlfe", "tlevb", "tllb", "tlfb", "intlve", "tservd", "untrells", "tlfs", "Tlvb", "tjects", "tdepn", "tlve", "untlvd", "glege", "intjecte", "tells", "tlld", "tlfi", "itlvabs", "tcfn", "intjects", "trelld", "tlvids", "Tlevs", "glegs", "tjecte", "tlvu", "intlvu", "twls", "tlevstates", "itlls", "itlln", "tlegs", "tservu", "trellstates", "trells", "attdepS", "tllids", "attlvn", "Tlevd", "tdepS", "tlvn", "tlegi", "telld", "tellstates", "tlevs", "untlvstates", "tdepids", "itlvs"], "ROCKER_TLV_TX_MAX": ["ROCKER_TLV_TXIDMax", "ROCKER_TLV_TXIDSIZE", "ROCKER_TLV_TXPSIZE", "ROCKER_TLV_TX_SIZE", "ROCKER_TLV_TX_Max", "ROCKER_TLV_TEXT_Max", "ROCKER_TLV_TEXT_MAX", "ROCKER_TLV_TXIDMAX", "ROCKER_TLV_TEXT_SIZE", "ROCKER_TLV_TXPMax", "ROCKER_TLV_TXPMAX"], "iov": ["uments", "seq", "redits", "uda", "ibl", "vl", "net", "mem", "ov", "obj", "argo", "nv", "ctr", "urses", "ounter", "sn", "nr", "umers", "nc", "ores", "ounters", "NT", "io", "ret", "vec", "rowd", "ources", "fi", "nn"], "pport": ["voice", "PORT", "vision", "fund", "val", " sport", "lv", "quart", "pit", "prot", "mitt", "rest", "pid", "pp", "fi", "serv", "service", "ct", "claim", "iss", "config", "upp", "regon", "lex", "pt", "pe", "loc", "prop", "itness", "la", "nat", "iff", "supp", "fl", "shape", "opt", "cv", "ort", "rog", "nil", "voc", "ctx", "cas", "imet", "mut", "support", "pull", "mot", "plugin", "choice", "pair", "ault", "sex", "ann", "vc", "aim", "feat", "Support", "typ", "pet", "fc"], "port": ["PORT", "pass", "val", "porter", "path", "ports", "claim", "orts", "protect", "config", "p", "service", "component", "cp", "target", "reg", "Port", "pt", "ptr", "loc", "prop", "rot", "pn", "priority", "host", "pir", "version", "ort", "pr", "address", "position", "hop", "type", "pos", "ip", "header", "import", "length", "match", "per", "ORT"], "rem": [" ii", "m", "num", "mem", "rec", "rib", "rom", "ptr", "res", "ort", " pri", "rc", "REM", "err", "Rem", "error", " err", "rx", "ip", "out", " res", "resp", "ok"], "i": ["l", "it", "is", "n", "start", "id", "m", "x", "z", "d", "c", "p", "lit", "e", "iter", "eni", "f", "j", "index", "pi", "ii", "init", "h", "I", "li", "ip"], "iovcnt": ["iovscpy", "iovscnt", "iovuncpy", "iocsec", "iovlcnc", "iovcsec", "iocnt", "iocnc", "iovlcpy", "iolcnc", "iovcpy", "iovscnc", "iovscsec", "iovlcsec", "iovuncsec", "iolcsec", "iolcpy", "iovlcnt", "iovcnc", "iovuncnt", "iovuncnc", "iocpy", "iolcnt"]}}
{"project": "FFmpeg", "commit_id": "bd8ae4885b905415f0e86d4e348c4b72be81e6e6", "target": 0, "func": "AVFilterFormats *avfilter_all_colorspaces(void)\n\n{\n\n    return avfilter_make_format_list(35,\n\n                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,\n\n                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,\n\n                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,\n\n                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,\n\n                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,\n\n                PIX_FMT_RGB32,    PIX_FMT_BGR32,\n\n                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,\n\n                PIX_FMT_RGB24,    PIX_FMT_BGR24,\n\n                PIX_FMT_RGB565,   PIX_FMT_BGR565,\n\n                PIX_FMT_RGB555,   PIX_FMT_BGR555,\n\n                PIX_FMT_RGB8,     PIX_FMT_BGR8,\n\n                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,\n\n                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,\n\n                PIX_FMT_GRAY8,    PIX_FMT_PAL8,\n\n                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK\n\n                PIX_FMT_NV12,     PIX_FMT_NV21);\n\n}\n", "idx": 9576, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n", "idx": 9584, "substitutes": {"base": ["l", "area", "seq", "boot", "byte", "scale", "prefix", "pad", "info", "id", "bas", "ached", "http", "b", "k", "i", "data", "Base", "block", "addr", "cp", "ix", "server", "p", "local", "gb", "ada", "set", "ase", "f", "slave", "db", "bf", "unit", "sync", "rc", "name", "other", "full", "bi", "root", "null", "ip", "weak", "out", "use", "cache", "io", "build", "br", "bin", "extra", "force", "buffer", "core", "c", "range", "reset"], "irqA": ["ariqueA", "ariqArch", "irpB", "irqsRA", "irchArch", "irchA", "irqsN", "irchB", "irchN", " irqBA", "ircingBA", "irqueN", "irqsArch", "ariqueN", "irqN", "ariqRA", "ariqN", "irpA", "ariqA", "irqueA", "irqsA", "irpP", "irqBA", "ariqueArch", "irqP", "irchRA", "irchP", "irqArch", "irqueRA", "ircingP", "irchBA", " ircingBA", " ircingA", "ircingB", "irqRA", " ircingP", " irqP", " ircingB", "irqueArch", "ircingA", "irpBA", "ariqueRA"], "irqB": ["virqGB", "virqB", "irpB", "virquGB", "irceB", "irfD", "irceI", "irqueI", "virqD", "irchB", "irquGB", "IRqB", "irqD", "irceA", "irqBs", "irfB", "virquD", "irchGB", "irfBI", "virquB", "irqueBs", "irpA", "virquBI", "irqGB", "irqueA", "IRqI", "irpBs", "irquBI", "irquD", "IRpBs", "irqI", "IRpA", "virqBI", "IRqA", "irqueB", "irchD", "IRpI", "irfGB", "irqBI", "irceBs", "IRpB", "IRqBs", "irpI", "irchBI", "irquB"], "chrA": ["CharAR", "charmG", "chrcAPI", "chrfAPI", "CharG", " chrC", "ChrB", "chrG", "charmB", "chdrA", "chrcB", " chrfA", "charmA", "CharA", "chrC", "ChrG", "chdrB", "chrfA", "ChrA", "chrfB", " chrfB", "charmAR", "charB", "charC", "ChrAR", "charA", "chdrAR", "CharB", "chrcA", "charAR", "charAPI", "chrfC", " chrfC", "chrAPI", " chrfAPI", "charG", "chrAR", "chrcC", "chdrG", " chrAPI"], "chrB": ["chrtBB", "charUB", "chlW", "chlC", "chrtUB", "charBB", "chrfBB", "CharC", "ChrB", "ChrC", "ChrUB", "chrfDB", "chrC", "CharA", "chrW", "ChrDB", "chrtDB", "ChrA", "chrtB", "chrBB", "chrfB", "CharUB", "chrfUB", "chrtC", "CharBB", "charB", "charC", "CharW", "ChrBB", "chlB", "ChrW", "charA", "chrUB", "chlA", "CharB", "chrtW", "chrtA", "charDB", "chrDB", "CharDB", "charW"], "clock": ["seq", "axis", "si", "watch", "hour", "Clock", "sleep", "chron", "shift", "block", "c", "time", "server", "config", "tick", "set", "sq", "serial", "sec", "rot", "ac", "ctl", "sync", "timer", "align", "poll", " clocks", "counter", "offset", "spec", "root", "lock", "sys", "year", "loop", "lc", "seed"], "it_shift": ["it_scale", "ip_shift", "ip_count", "ip_size", "ip_push", "lit_offset", "lit_scale", "it_push", "lit_size", "it_count", "lit_shift", "it_offset", "it_size"], "dev": ["gd", "dom", "t", "ve", "ver", "de", "ad", "block", "driver", "device", "v", "mod", "spec", "grad", "self", "od", "gu", "cam", "debug", "n", "w", "c", "e", "cd", "app", "pro", "prop", "f", "ev", "db", "r", "md", "dc", "error", "ch", "ow", "sh", "di", "g", "test", "Dev", "def", "conn", "temp", "adv", "var", "data", "dat", "req", "enc", "dy", "diff", "conf", "valid", "die", "info", "dt", "p", "bug", "rad", "priv", "off", "serial", "pub", "user", "der", "api", "wd", "DEV"], "s": ["l", "sp", "session", "sg", "sh", "ds", "n", "g", "is", "si", "w", "m", "stats", "http", "b", "t", "i", "gs", "c", "p", "server", "e", "se", "js", "f", "os", "sk", "cs", "o", "S", "v", "sync", "south", "sl", "services", "r", "state", "new", "ns", "sb", "spec", "u", "sys", "self", "h", "ps", "fs", "su", "a", "ss", "ssl"], "d": ["l", "ld", "gd", "di", "std", "dh", "ds", "n", "g", "did", " dd", "w", "m", "dt", "fd", "b", "t", "z", "i", "c", "ad", "data", "p", "bd", "e", "pd", "driver", "cd", "f", "j", "dl", "db", "dat", "o", "v", "nd", "ind", "state", "md", "r", "dd", "dc", "sd", "u", "dy", "od", "dad", "dx", "D"]}}
{"project": "FFmpeg", "commit_id": "a744064c4155bde063b9e8a47699542be3b8e5eb", "target": 1, "func": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}", "idx": 9598, "substitutes": {"s": ["conf", "styles", "sg", "ds", "si", "your", "sf", "features", "stats", "t", "ops", "d", "gs", "c", "p", "ls", "qs", "parts", "request", "xs", "rs", "sq", "js", "f", "args", "cs", "sym", "o", "sets", "shared", "S", "es", "sync", "sts", "cons", "services", "sup", "ans", "sb", "ns", "hs", "self", "sys", "params", "ses", "a", "options", "comments", "css", "ss", "fs", "settings", "ssl"], "i": ["count", "l", "oi", "hi", "ui", "di", "start", "si", "in", "zi", "key", "m", "id", "xi", "info", "b", "x", "ini", "d", "uli", "c", "ji", "p", "uri", "ix", "e", "yi", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "phi", "r", "abi", "qi", "jp", "pi", "bi", "part", "ii", "init", "u", "I", "li", "ci", "a", "length", "io", "lc", "ri", "fi", "iu"]}}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "func": "void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n", "idx": 9607, "substitutes": {"block": ["parent", "Block", "element", "byte", "filter", "base", "record", "view", "point", "k", "data", "line", "time", "batch", "tick", "condition", "frame", "table", "coll", "group", "flow", "none", "off", "call", "unit", "bl", "index", "name", "end", "object", "inner", "address", "tx", "pre", "new", "check", "cl", "blocks", "col", "type", "lock", "clean", "ip", "row", "out", "cell", "buffer", "box", "chain"], "i": ["oi", "l", "vi", "hi", "ui", "di", "it", "is", "si", "zi", "key", "id", "info", "xi", "m", "b", "x", "ini", "z", "k", "d", "c", "line", "p", "uri", "ix", "e", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "phi", "ti", "r", "abi", "qi", "bi", "pi", "ii", "init", "u", "I", "li", "ip", "ci", "a", "io", "ni", "y", "lc", "ri", "length", "fi", "iu"], "temp": ["zip", "level", "base", "context", "test", "template", "b", "Temp", "store", "var", "data", "c", "config", "output", "app", "iter", "args", "table", "tmp", "flow", "unit", "inv", "size", "index", "fake", "v", "input", "order", "pre", "tx", "blocks", "offset", "col", "type", "lock", "null", "emp", "params", "tem", "out", "row", "cache", "cell", "partial", "buffer", "exec"]}}
{"project": "qemu", "commit_id": "603987488c61ca02ee99890d07cdaecdb118a659", "target": 1, "func": "PCIBus *pci_pmac_init(qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    UNINState *d;\n\n\n\n    /* Use values found on a real PowerMac */\n\n    /* Uninorth main bus */\n\n    dev = qdev_create(NULL, \"Uni-north main\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(UNINState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_unin_set_irq, pci_unin_map_irq,\n\n                                         pic, 11 << 3, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 11 << 3, \"Uni-north main\");\n\n\n\n    sysbus_mmio_map(s, 0, 0xf2800000);\n\n    sysbus_mmio_map(s, 1, 0xf2c00000);\n\n\n\n    /* DEC 21154 bridge */\n\n#if 0\n\n    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */\n\n    pci_create_simple(d->host_state.bus, 12 << 3, \"DEC 21154\");\n\n#endif\n\n\n\n    /* Uninorth AGP bus */\n\n    pci_create_simple(d->host_state.bus, 13 << 3, \"Uni-north AGP\");\n\n\n\n    /* Uninorth internal bus */\n\n#if 0\n\n    /* XXX: not needed for now */\n\n    pci_create_simple(d->host_state.bus, 14 << 3, \"Uni-north internal\");\n\n#endif\n\n\n\n    return d->host_state.bus;\n\n}\n", "idx": 9616, "substitutes": {"pic": ["mac", "oc", "pass", "cci", "xi", "pid", "pa", "i", "c", "config", "p", "fp", "pins", "bc", "ac", "pick", "lib", "pres", "ig", "sync", "ic", "jp", "pi", "pc", "Pic", "nic", "bus", "sys", "file", "ip", "fs", "lc", "proc", "cus", "fi", "pin", "fc"], "dev": ["diff", "conf", "gd", "di", "sh", "ds", "n", "g", "dom", "Dev", "w", "info", "def", "conn", "m", "da", "b", "dem", "ve", "adv", "ver", "de", "data", "ad", "c", "p", "e", "cd", "driver", "bug", "rad", "serial", "dn", "priv", "f", "ev", "device", "v", "r", "err", "dd", "dc", "bus", "sd", "spec", "dm", "der", "ch", "DEV", "dy"], "s": ["l", "session", "ts", "sh", "sv", "ds", "n", "g", "si", "is", "w", "m", "src", "b", "t", "k", "sw", "i", "gs", "c", "p", "e", "se", "sq", "rs", "js", "f", "os", "us", "cs", "o", "S", "v", "scope", "sync", "south", "sl", "state", "r", "services", "sup", "sn", "ns", "sb", "sd", "spec", "sys", "self", "h", "secure", "ps", "ses", "su", "fs", "a", "ss", "settings", "ssl", "sc"], "d": ["l", "ld", "gd", "di", "mad", "td", "dh", "ds", "n", "g", "dom", "rd", "did", "dict", "da", "w", "m", "id", "dt", "fd", "b", "t", "ud", "z", "i", "de", "c", "data", "ad", "p", "bd", "e", "cd", "driver", "pd", "dn", "f", "ded", "dl", "j", "db", "device", "dat", "o", "dr", "xd", "v", "nd", "ind", "md", "r", "done", "dd", "vd", "dc", "sd", "hd", "u", "D", "self", "wd", "dx", "dy", "ed"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 9619, "substitutes": {"lexer": ["Lexeder", "Lexe", "licers", "ntaxera", "cloder", "Lexer", "loge", "visioner", "lexeder", "licer", "visione", "visionator", "clator", "Lexoder", " lexers", "ntaxer", "cler", "Lexker", "lexe", "ntaxe", "ntaxker", "Lexator", "Lexers", "logker", "lexers", " lexeder", "logera", "cle", "visionoder", "lexker", "Lexera", "lexoder", " lexe", "liceder", "loger", "lexera", "lexator", "lice"], "input": ["element", "session", "Input", "argument", "context", "field", "source", "view", "temp", "model", "instance", "data", "expression", "config", "output", "reader", "qa", "xml", "request", "array", "op", "select", "resource", "inc", "format", "current", "query", "magic", "state", "raw", "ctx", "inner", "document", "token", "storage", "list", "form", "import", "image", "text", "inf", "expr", "buffer"], "type": ["parent", "kind", "level", "field", "str", "class", "key", "info", "method", "id", "like", "t", "by", "i", "post", "Type", "data", "python", "time", "p", "block", "set", "pe", "value", "action", "style", "number", "types", "op", "code", "call", "o", "version", "shape", "py", "size", "format", "name", "state", "pre", "ty", "token", "sort", "part", "ping", "error", "spec", "TYPE", "handler", "year", "length", "ype", "typ", "direction"], "x": ["l", "n", "in", "key", "w", "xx", "m", "id", "t", "b", "z", "d", "i", "c", "data", "X", "p", "ix", "e", "number", "xs", "xxx", "f", "code", "size", "index", "v", "name", "xt", "h", "on", "length", "ex"], "y": ["ym", "ady", "oy", "n", "ry", "key", "ny", "w", "id", "xx", "t", "ey", "z", "vy", "ye", "i", "ys", "cy", "p", "iy", "yi", "ay", "zy", "xxx", "yy", "sy", "j", "gy", "o", "py", "sky", "ery", "Y", "sys", "year", "ya", "length", "dy", "yo"], "parser": ["parent", "lp", "operator", "enter", "worker", "json", "tree", "http", "pool", "block", "python", "config", "script", "xml", "txt", "lex", "er", "code", "document", "spec", "init", "self", "seed", "buffer", "author", "php", "missing", "arser", "instance", "post", "player", "rule", "s", "jack", "before", "value", "args", "slice", "ars", "magic", "winner", "loader", "token", "storage", "above", "list", "root", "plugin", "this", "layer", "handler", "general", "file", "join", "holder", "wp", "g", "test", "builder", "data", "local", "writer", "entry", "master", "ger", "part", "super", "node", "copy", "sys", "command", "message", "Parser", "man", "pass", "argument", "comment", "ring", "processor", "pack", "lower", "p", "reader", "server", "upper", "private", "star", "manager", "parse", "paragraph", "gg", "pillar", "inner", "der", "book"], "dict": ["diff", "map", "dot", "conf", "session", "arr", "di", "fix", "str", "comment", "auth", "dog", "record", "json", "tree", "info", "model", "def", "d", "doc", "data", "sum", "config", "reader", "obj", "package", "bug", "table", "coll", "df", "array", "dr", "code", "db", "dir", "slice", "module", "parse", "response", "pillar", "state", "document", "dd", "patch", "hash", "list", "copy", "init", "pair", "cat", "der", "clean", "file", "cache", "ict", "result", "pkg", "database"], "brace_count": ["brace_part", "brace\u00b7left", "option_amount", "plate_left", "plate\u00b7part", "line_size", "braceacoffset", "brace_cell", "brace\u00b7cast", "plate_count", "line_length", "brace_size", "brace_length", "line_catch", "brace_index", "line_const", "brace_min", "braceaccount", "brace_len", "brace\u00b7part", "option_offset", "brace\u00b7depth", "brace\u00b7count", "brace_left", "option_length", "braceanceleft", "braceancecast", "brace_cast", "braceancepart", "braceancecount", "brace\u00b7size", "line_index", "braceacsize", "line_min", "plate\u00b7left", "line_cell", "brace_catch", "plate\u00b7count", "plate\u00b7cast", "brace_depth", "plate_cast", "braceacamount", "braceacmin", "line_len", "brace_const", "brace\u00b7min", "line_count", "plate_part", "line_depth", "braceacdepth", "option_count", "brace_amount", "brace_offset", "braceaclength"], "bracket_count": ["bracket_code", "bracket_age", "bracket9weight", "bracket_length", "brace_code", "bracket9order", "brace_size", "brace_length", "bracket9count", "bracketercount", "brace_age", "brace_len", "bracketersize", "brace_order", "bracketerdepth", "brace_weight", "bracket_size", "bracket_weight", "bracket_depth", "bracket_order", "brace_depth", "bracket9length", "bracket_len"]}}
{"project": "qemu", "commit_id": "041d95f42e39ed1d3a029332cab9966889f0aeb3", "target": 0, "func": "static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n", "idx": 9629, "substitutes": {"env": ["vs", "cdn", "conf", "pec", "qt", "context", "pg", "ext", "fen", "n", "dict", "conn", "org", "dt", "net", "que", "viron", "iss", "c", "environment", "doc", "config", "server", "el", "e", "osc", "erv", "ep", "np", "txt", "args", "ec", "eni", "cf", "er", "act", "gui", "inst", "code", "ev", "db", "dat", "console", "exc", "cv", "ea", "ce", "v", "ctx", "req", "cur", "en", "err", "enh", "eng", "Environment", "here", "enc", "init", "ef", "nc", "et", "her", "site", "cache", "ah", "anc", "eu", "icer", "core", "eve", "exec"], "eaddr": ["ellder", "evdr", "efdr", "ellrs", "evrr", "addr", "evrs", "efder", "eadrs", "adrs", "evder", "adder", "ellrr", "eadder", "elldr", "evDR", "efrr", "eadrr", "efDR", "ellDR", "adrr", "eadDR"], "pid": ["cpu", "pg", "vid", "id", "pl", "uid", "path", "pa", "pp", "pointer", "phase", "p", "pb", "pd", "pri", "np", "ep", "po", "pt", "pm", "prop", "pins", "priority", "mid", "py", "mi", "pipe", "pu", "port", "pi", "ping", "pc", "pod", "ino", "od", "pos", "ip", "proc", "pty", "pin"], "cs": ["vs", "co", "ks", "ds", "c", "ls", "qs", "ins", "cn", "cf", "wcs", "ec", "rs", "cc", "sk", "bc", "acs", "sync", "CS", "ics", "cas", "settings", "ns", "pc", "ces", "spec", "cms", "nc", "sys", "ca", "ci", "fs", "ps", "css", "lc", "ch", "ss", "core", "cus", "cks", "sc", "Cs"], "tlb": ["templb", "ptlu", "untlb", " tacl", "tb", "Tbl", "plab", "llb", "etlab", " tdl", "rtlp", "untla", "tlu", "Tl", " tb", "tempdl", "trl", "ntbf", "bbl", "ktbf", "Tlb", "pbl", "ttb", "tld", "ntlb", "ttlb", "tilo", " tl", "tbl", "tla", " tlu", "flab", "tflb", "etlp", "tlp", "ktlu", "Tb", "bbf", "blb", "fbl", " tlr", "lrl", "ntbl", " tlab", "tlr", "etbl", "ktbl", "rtlb", "ttla", "tlab", "tbf", "lbl", "rtlab", "tfilo", "tfacl", " tilo", "tdl", "untlr", "tflu", "Tld", "fdl", "flp", "rtbl", "templab", "ttbl", " tla", " trl", "ptacl", "ntlu", "plp", " tlp", "blu", "Trl", "ktlb", "tl", "etlb", "flb", "tacl", "ptilo", "plb", " tbl", "ll", " tld", "ttlr", "ttld", "ptlb", "untbl", "templp"], "raddr": ["wdr", "rbdr", "rwdb", "rdb", "waddr", " rptr", "ipdb", " rdr", "rbptr", " raddress", "rptr", "waddress", "ipaddress", "rbaddress", "rwaddr", "ipaddr", "rdr", "rbaddr", "wptr", "raddress", "wdb", "rwaddress"], "page": ["count", "area", "byte", "pg", "start", "n", "ph", "key", "id", "pl", "pack", "total", "num", "pp", "pointer", "ver", "block", "line", "limit", "p", "server", "e", "pe", "number", "pages", "stop", "step", "next", "entry", "size", "edge", "inc", "wait", "order", "name", "current", "age", "address", "port", "eng", "pc", "Page", "offset", "aa", "ew", "ip", "row", "gap", "image", "site", "result", "proc", "buffer", "month", "per"], "end": ["start", "n", "ended", "w", "id", "ent", "End", "x", "z", "send", "post", "d", "c", "line", "limit", "p", "ad", "max", "e", "head", "ep", "set", "stop", "f", "append", "index", "edge", "size", "inc", "nd", "name", "address", "en", "ending", "offset", "after", "enc", "u", "type", "tail", "pend", "pos", "ip", "END"], "i": ["oi", "l", "ui", "di", "it", "start", "si", "n", "zi", "id", "xi", "info", "m", "b", "x", "k", "ini", "ami", "d", "t", "uli", "c", "limit", "p", "uri", "e", "mu", "yi", "eni", "f", "j", "ai", "multi", "index", "v", "gi", "ti", "mi", "phi", "r", "abi", "qi", "pi", "ii", "u", "I", "li", "ip", "ci", "a", "api", "ni", "io", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "9cd1e97a7ae2856ec00b5682db0dea17f42fc734", "target": 0, "func": "void pci_bridge_initfn(PCIDevice *dev, const char *typename)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = PCI_BRIDGE(dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_word_test_and_set_mask(dev->config + PCI_STATUS,\n\n                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * TODO: We implement VGA Enable in the Bridge Control Register\n\n     * therefore per the PCI to PCI bridge spec we must also implement\n\n     * VGA Palette Snooping.  When done, set this bit writable:\n\n     *\n\n     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,\n\n     *                            PCI_COMMAND_VGA_PALETTE);\n\n     */\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, OBJECT(br), \"pci_bridge_pci\", UINT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, OBJECT(br), \"pci_bridge_io\", 65536);\n\n    br->windows = pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n}\n", "idx": 9630, "substitutes": {"dev": ["diff", "conf", "gu", "valid", "img", "debug", "dom", "comment", "test", "Dev", "def", "conn", "info", "fr", "dt", "die", "w", "nt", "development", "dem", "adv", "d", "ver", "de", "var", "data", "block", "config", "p", "app", "pro", "driver", "private", "dist", "bug", "rad", "priv", "ev", "device", "child", "pub", "vol", "v", "google", "feature", "end", "req", "mod", "user", "err", "dd", "dc", "bus", "error", "node", "enc", "root", "dm", "self", "grad", "der", "client", "DEV"], "typename": ["Tylenname", "tyrenename", "typpenname", "typerame", "Typenename", "tylenname", "tylenAME", "typlename", "typenAME", "typenename", "typerature", "typenname", "Typename", "typarenname", "typarenename", "typpenAME", "tylenename", "typerename", "typpename", "typarenature", "tylenature", "typarename", "typenature", "typerAME", "tylename", "tyrenname", "Typenname", "typername", "tyrename", "typpenename", "Tylename", "Tylenature", "tyrenAME", "typlenAME", "typlenename", "Tylenename", "Typenature", "typlenname"], "parent": ["gu", "str", "g", "comment", "test", "def", "conn", "instance", "by", "pool", "bridge", "block", "c", "data", "var", "ref", "p", "prev", "component", "reg", "dist", "pt", "op", "host", "unit", "child", "device", "opt", "current", "name", "fat", "ctx", "r", "port", "new", "node", "root", "self", "Parent", "cache", "ram", "par"], "br": ["BR", "cr", "bolt", "base", "img", "tr", "mr", "pl", "bar", "tag", "ver", "bridge", "block", "config", "bd", "nor", "ref", "global", "loc", "bl", "ctr", "bed", "err", "bus", "Br", "av", "broad", "arr", "n", "fr", "bm", "b", "gr", "browser", "pro", "or", "bc", "be", "j", "ev", "bf", "res", "r", "pre", "bro", "root", "ch", "ru", "ler", "boot", "str", "hr", "brid", "kr", "buf", "var", "ov", "wr", "rb", "coll", "dr", "bg", "bh", "shr", "ger", "vr", "ber", "adr", "bal", "bas", "p", "el", "obj", "rel", "plug", "off", "lr", "pr", "bs"], "sec_bus": ["security_machine", "cy_usb", "sec_car", " sec_block", "securebridge", "Sec_car", "cy_boot", "securedriver", "secJdriver", "cy_bus", "securebus", "secJbus", "secure_BUS", " sec_mount", "sec_port", "secjBUS", "sec_usb", "sec_def", "sec_service", "secpbridge", " sec_boot", "security_driver", "secjdef", "Sec_port", "secJBUS", "secure_bridge", "esc_boot", "esc_usb", "sec_boot", "Sec_driver", "secJdev", "secure_bus", "sec_dev", "secpbus", "sec_us", "Sec_bridge", "secjport", "Sec_BUS", "secpBUS", "security_bridge", "secjbus", "Sec_def", "esc_us", "esc_bus", "sec_BUS", "security_bus", " sec_us", " sec_def", "sec_driver", "sec_machine", "Sec_dev", "secpcar", "secure_boot", "sec_mount", "sec_block", "Sec_bus", "cy_service", " sec_usb", "sec_bridge", "securemachine"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n", "idx": 9639, "substitutes": {"linebuf": ["linbuffer", "linqueue", "linequeue", "lockbuffer", " lineuf", " linebuffer", "linebc", "lockbuf", "linkbuffer", "linvec", "linkuf", "linevec", "linkbuf", "linkbc", "lockvec", "linkqueue", "linbuf", "linkvec", " linebc", "lockqueue", "linebuffer", "linuf", "lineuf", "linbc"], "fb": ["rf", "fg", "bb", "img", "abc", "src", "fd", "b", "ab", "fw", "buf", "facebook", "FB", "pb", "cb", "fp", "cf", "rb", "tmp", "f", "fa", "bf", "eb", "bg", "fx", "lb", "abl", "sb", "eddy", "border", "ob", "buff", "xb", "fi", "fe", "fab", "fc"], "y": ["l", "area", "yt", "start", "n", "ny", "m", "w", "b", "x", "t", "z", "vy", " Y", "d", "i", "c", "ys", "p", "e", "yi", "f", "sy", "padding", "gy", "height", "yy", "py", "Y", "ii", "col", "kit", "dy", "type", "xy", "px", "ya", "io", "cy"]}}
{"project": "qemu", "commit_id": "30b8b68eb574fd68060eebcc4da790fdfe18d668", "target": 0, "func": "static inline abi_long target_to_host_cmsg(struct msghdr *msgh,\n\n                                           struct target_msghdr *target_msgh)\n\n{\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);\n\n    abi_long msg_controllen;\n\n    abi_ulong target_cmsg_addr;\n\n    struct target_cmsghdr *target_cmsg;\n\n    socklen_t space = 0;\n\n    \n\n    msg_controllen = tswapal(target_msgh->msg_controllen);\n\n    if (msg_controllen < sizeof (struct target_cmsghdr)) \n\n        goto the_end;\n\n    target_cmsg_addr = tswapal(target_msgh->msg_control);\n\n    target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);\n\n    if (!target_cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = tswapal(target_cmsg->cmsg_len)\n\n                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));\n\n\n\n        space += CMSG_SPACE(len);\n\n        if (space > msgh->msg_controllen) {\n\n            space -= CMSG_SPACE(len);\n\n            gemu_log(\"Host cmsg overflow\\n\");\n\n            break;\n\n        }\n\n\n\n        if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) {\n\n            cmsg->cmsg_level = SOL_SOCKET;\n\n        } else {\n\n            cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level);\n\n        }\n\n        cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type);\n\n        cmsg->cmsg_len = CMSG_LEN(len);\n\n\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(data, target_data, len);\n\n        } else {\n\n            int *fd = (int *)data;\n\n            int *target_fd = (int *)target_data;\n\n            int i, numfds = len / sizeof(int);\n\n\n\n            for (i = 0; i < numfds; i++)\n\n                fd[i] = tswap32(target_fd[i]);\n\n        }\n\n\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, 0);\n\n the_end:\n\n    msgh->msg_controllen = space;\n\n    return 0;\n\n}\n", "idx": 9643, "substitutes": {"msgh": ["tsgh", "mesgor", "msht", "mosht", "cmsgh", "masgor", "MSky", "masht", "mesgg", "msky", "tsGH", "mosgg", "msgg", "msGH", " msky", "msche", "cmsche", "mesgh", "vsgy", " msGH", " mswh", "vsgg", "cmsgy", "mesht", "msgor", "mosgh", "masgg", "mesche", "cmsgg", "MSgh", "msgy", "mesgy", "MSGH", "mswh", "masgh", "tswh", "mosgor", "MSwh", "tsky", "vsgh", "vsche"], "target_msgh": ["target_mrht", "target_lsht", "target_msoug", "target_msyg", "target_kesyg", "target_meszh", "target_szh", "target_kesgg", "target_mesgg", "target_qsgg", "target_mrgh", "target_msht", "target_sht", "target_kesoug", "target_qsgh", "target_kesgh", "target_lsgs", "target_mesgh", "target_lsgg", "target_mesoug", "target_qsoug", "target_mszh", "target_mrzh", "target_mesgs", "target_sgh", "target_msgg", "target_sgs", "target_sgg", "target_msgs", "target_qsyg", "target_mesyg", "target_lsgh", "target_mrgg", "target_mesht"], "cmsg": ["dcmd", "rcmsg", "conmessage", "acmsg", "rcmessage", "dmsg", "ucload", "conmn", "qdoc", "ncmsg", "fcmap", "bcmsg", "accmd", "rmsg", "qmsg", "cdoc", "acdoc", "xcwd", "cmn", "cwd", "fccmd", "acmessage", " cwd", "fcdoc", "bccmd", "comsg", "fcmessage", " ccmd", "bcarg", "rcdoc", "pcmsg", "fcmsg", "conmsg", "cgen", "ucdoc", "pccmd", "conwd", " cmessage", "arcmessage", "ccmd", " cset", "dmessage", "Cmodule", "cset", "bcmodule", "arcdoc", "fmessage", "vcmn", "acset", "qcmd", "xcmn", "dgen", "rmessage", "codoc", "vcmsg", "vcmessage", " cgen", "cmap", "Cdoc", "fmsg", "ucmodule", "rdoc", "vcdoc", "fdoc", "ucmessage", "pcload", "rmap", "ncmap", "cload", "coset", "xcmsg", " cdoc", "acmn", "arcmsg", "cget", "uccmd", "acgen", "ucmsg", "arcmn", "cmessage", "comessage", "cmodule", "bcmessage", "qmessage", "bcget", "farg", "carg", "ncdoc", "rcmn", "Cmsg", " cmn", "ucget", "bcdoc", "ncmessage", "Cget", "fcmn", "ncarg", "xcmessage", "pcmessage", "bcload"], "msg_controllen": ["msg_restroller", "msg_contcolllen", "msg_contallens", "msg_contentcollen", "msg_controlledener", "msg_controlon", "msg_restrollingon", "msg_contiller", "msg_contentrolllen", "msg_constrollener", "msg_controllening", "msg_restrollingens", "msg_contcollon", "msg_contentrolle", "msg_constrollening", "msg_contillen", "msg_controllingen", "msg_contillening", "msg_controlener", "msg_constrolening", "msg_controllinger", "msg_contracten", "msg_contcolle", "msg_controllener", "msg_contcollener", "msg_controllingener", "msg_constroller", "msg_controlledens", "msg_contentcoller", "msg_contentallener", "msg_constroler", "msg_contcollen", "msg_controlle", "msg_contracton", "msg_contentrollon", "msg_contentrollen", "msg_controller", "msg_contentcolllen", "msg_controlleder", "msg_contentcolle", "msg_contractens", "msg_controllingon", "msg_contentallens", "msg_constrollen", "msg_controllingens", "msg_controllens", "msg_contentrollens", "msg_contracter", "msg_constrolener", "msg_controllinglen", "msg_restrollon", "msg_restrollens", "msg_contallon", "msg_constrolen", "msg_controlledon", "msg_contentallon", "msg_controllinge", "msg_controllede", "msg_restrollinger", "msg_contentroller", "msg_contentallen", "msg_controlens", "msg_controlen", "msg_controlledlen", "msg_contallener", "msg_controler", "msg_controle", "msg_contcollens", "msg_controllon", "msg_controlleden", "msg_contentrollener", "msg_contcoller", "msg_contallen", "msg_restrollen", "msg_controlledening", "msg_controlllen", "msg_contillener", "msg_controlening", "msg_restrollingen"], "target_cmsg_addr": ["target_cmessage_adr", "target_cmsg_pos", "target_cmsg__address", "target_cmsg__adr", "target_cmessage_address", "target_cmsg_host", "target_cmsg_nr", "target_cmsg_address", "target_cmsg__nr", "target_cmessage_ord", "target_cmsg_ord", "target_cmsg__addr", "target_cmessage_host", "target_cmessage_nr", "target_cmsg_adr", "target_cmessage_addr", "target_cmessage_pos"], "target_cmsg": ["target_cdr", "target_acmp", "target_ucdr", "target_yml", "target_yerg", "target_lccmd", "target_bdoc", "target_lcog", "target_lcmessage", "target_cfsend", "target_cipher", "target_fog", "target_cudr", "target_acog", "target_rcglobal", "target_lcg", "target_rcmp", "target_rcgen", "target_rcmg", "target_iccmd", "target_ccmn", "target_lcdoc", "target_pcmp", "target_lcdr", "target_bmg", "target_verg", "target_pcmg", "target_bipher", "target_pcmessage", "target_bog", "target_ccmp", "target_csdef", "target_cfmp", "target_rcmsg", "target_acmg", "target_acmsg", "target_cfgen", "target_cumg", "target_mgen", "target_pcgen", "target_vgen", "target_cog", "target_mmsg", "target_ccmsg", "target_vmsg", "target_cmessage", "target_ygen", "target_cfframe", "target_icmessage", "target_cumsg", "target_cglobal", "target_acg", "target_cml", "target_csend", "target_cfmsg", "target_acdoc", "target_pcmsg", "target_rcdr", "target_cerg", "target_icmsg", "target_ucmessage", "target_lcglobal", "target_cdef", "target_fmessage", "target_ccmd", "target_merg", "target_fdr", "target_pcframe", "target_lcmsg", "target_ucmsg", "target_ymsg", "target_cg", "target_csmsg", "target_acmessage", "target_lcmn", "target_pcg", "target_cmn", "target_cgen", "target_rcmessage", "target_icmg", "target_cfipher", "target_fmsg", "target_rcframe", "target_lcmg", "target_cssend", "target_rccmd", "target_cfdef", "target_cmg", "target_ucog", "target_csipher", "target_cmp", "target_cdoc", "target_lcmp", "target_acmn", "target_bsend", "target_bmsg", "target_vml", "target_mml", "target_bdef", "target_cframe", "target_cuglobal"], "data": ["parent", "channel", "session", "di", "base", "source", "media", "window", "key", "pad", "doc", "batch", "reader", "meta", "body", "next", "DATA", "entry", "resource", "dat", "size", "space", "response", "part", "Data", "message", "result", "text"], "target_data": ["target__conn", "target__data", "target_addr", "target__addr", "target_conn", " target_addr", " target_conn"]}}
{"project": "qemu", "commit_id": "9d6f1b73f83a02fb28438fa9a487f5c7d245e4af", "target": 0, "func": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n", "idx": 9647, "substitutes": {"pidfile": ["payfile", "piddir", "pidf", "payfd", "pdir", "pinfiles", "pcstr", "cpdir", "cpFile", "payf", "pf", "pingfile", "pidFile", "cpfile", "pFile", "pingfp", "payfiles", "pindir", "pcfp", "pidfp", "podfile", "pingfd", "pinfd", "pcfd", "pidfiles", "pinf", "pcfile", "pingstr", "pinfile", "cpf", "podstr", "podfd", "pfd", "pinFile", "podfp", "pfiles", "pfile"], "pidfd": ["pidstream", "pidf", "pinflo", "plugindf", "pinstream", "pitfx", "pidcond", "pidfc", "pinfp", "phandler", "pindir", "pingfx", "podFD", "pluginFD", "fddc", "podcond", "mpfd", "piddf", "cpfx", "cpFD", "pidfi", "pinf", "idfin", "pcfi", "pinfin", "pindf", "pidfn", "cpfd", "pfp", "idfx", "fdfd", "pidfp", "pitfd", "idfd", "pcfd", "poddir", "podf", "pfile", "pitfp", "pinfi", "panf", "pidFD", "fdfile", "pf", "panfd", "mpfp", "pidd", "fdfx", "fdfn", "pinFD", "pingfd", "podfile", "pidfx", " pidFD", "pand", "pcdir", "panfi", "piddc", " pidf", "pincond", "pinfd", "podfn", "podstream", "pitFD", "pidflo", "pingf", "pfd", "podfp", "codfp", "pcstream", "pingflo", "pingdc", "idf", "fdfc", "iddc", "pcd", "idfc", "piddir", "codfd", "pidhandler", "pinfn", "pingfc", " pidfp", "pFD", "idflo", "fdFD", "pinhandler", "pingfin", "coddf", "podhandler", "mpf", "podfx", "mpFD", "codFD", "pcond", "cpfp", "podfd", "pinfile", "pcf", "pind", "pluginfp", "pidfin", "pluginfd"], "pidstr": ["prfile", "idstr", "idbr", "piddata", "pinst", "pitbr", "pidStr", " piddata", "pingdr", "pingbytes", "pinbr", "pingletter", "pstri", "pingfile", "idstring", "pitbytes", " pidstring", "pingst", "pingbr", "pingstri", "prstr", "pStr", "pinbytes", "pindr", "pingstring", "pidletter", " pidbr", " pidStr", "prdr", "pidstring", " pidletter", "iddata", "pidst", "pingStr", "pidbytes", "pinstring", "pidbr", "pstr", "pindata", "pitstring", "piddr", "pinstr", "pingstr", "pinfile", "pidstri", " pidst", "pinletter", "prstring", " pidstri", "pitstr"]}}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "static void handle_pending_signal(CPUArchState *cpu_env, int sig)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_ulong handler;\n\n    sigset_t set, old_set;\n\n    target_sigset_t target_old_set;\n\n    struct target_sigaction *sa;\n\n    struct sigqueue *q;\n\n    TaskState *ts = cpu->opaque;\n\n    struct emulated_sigtable *k = &ts->sigtab[sig - 1];\n\n\n\n    trace_user_handle_signal(cpu_env, sig);\n\n    /* dequeue signal */\n\n    q = k->first;\n\n    k->first = q->next;\n\n    if (!k->first)\n\n        k->pending = 0;\n\n\n\n    sig = gdb_handlesig(cpu, sig);\n\n    if (!sig) {\n\n        sa = NULL;\n\n        handler = TARGET_SIG_IGN;\n\n    } else {\n\n        sa = &sigact_table[sig - 1];\n\n        handler = sa->_sa_handler;\n\n    }\n\n\n\n    if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) {\n\n        /* Guest has blocked SIGSEGV but we got one anyway. Assume this\n\n         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info\n\n         * because it got a real MMU fault), and treat as if default handler.\n\n         */\n\n        handler = TARGET_SIG_DFL;\n\n    }\n\n\n\n    if (handler == TARGET_SIG_DFL) {\n\n        /* default handler : ignore some signal. The other are job control or fatal */\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n        } else if (sig != TARGET_SIGCHLD &&\n\n                   sig != TARGET_SIGURG &&\n\n                   sig != TARGET_SIGWINCH &&\n\n                   sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        }\n\n    } else if (handler == TARGET_SIG_IGN) {\n\n        /* ignore sig */\n\n    } else if (handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* block signals in the handler using Linux */\n\n        do_sigprocmask(SIG_BLOCK, &set, &old_set);\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &old_set);\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n    if (q != &k->info)\n\n        free_sigqueue(cpu_env, q);\n\n}\n", "idx": 9650, "substitutes": {"cpu_env": ["pu_env", "gpu_environment", "cpu6en", "cpu__state", "cpu6env", "proc__en", "cpu_en", "gpu_eni", "pu_eye", "gpu_dir", "cpu_dir", "pu_environment", "proc_en", "cpu_eye", "cpu_eni", "cpu__en", "proc_state", "cpu6environment", "proc__state", "gpu_env", "proc__env", "cpu6eye", "cpu_environment", "cpu_state", "pu_en", "proc_env", "cpu__env"], "sig": ["essature", "symig", "ligma", "osiger", "tig", "tag", " sag", "swig", "asig", "tIG", "pig", "sigi", "sIG", "argsature", "dIG", "argsig", "sib", "lig", "pigma", "giger", "physig", "asiger", "sigs", " siger", " sigs", "gigma", "symige", "dig", "lature", "sian", "wigs", "Sigi", "essIG", "sigma", "figma", "symigs", "psIG", "sige", "psib", "ssigs", "essiger", " sigi", "asIG", "psigma", "wigma", "pature", "osig", "liger", " sigma", "ssIG", "ssigma", " sian", "digma", "wsian", "nsiger", "wiger", " srig", "Sib", " sature", "tiger", "osIG", "tigma", "gig", "nsig", "wig", "sature", "asib", "piger", "osature", "ssig", "argsag", "Sag", "wsiger", "SIG", "psiger", "asature", "dib", "physag", "wsigma", "srig", "gIG", " sib", "ssige", "wsig", "argsige", "diger", "physige", "siger", "ssib", "sag", "asigma", "Srig", "fwig", "symigma", "Siger", "tigs", "nsIG", " swig", "gature", "nsigs", "psig", "essig", "Sig", "physature", " sIG", "wsIG", " sige", "tigi", "fig", "Sigs", "Sigma", "figer"], "cpu": ["cr", "uca", "mac", "processor", "conn", "gpu", "chip", "t", "que", "pty", "pid", "cp", "vm", "c", "config", "p", "cu", "cli", "queue", "cn", "pt", "gp", "hw", "cs", "device", "linux", "process", "clock", "ctx", "pu", "tp", "jp", "pc", "nic", "node", "CPU", "fork", "cat", "sys", "cfg", "cm", "nc", "client", "px", "ci", "gc", "css", "cache", "lc", "proc", "core", "mc", "fi", "uc"], "handler": ["parent", "channel", "worker", "driver", "lambda", "parser", "code", "al", "connection", "response", "cher", "end", "err", "controller", "type", "widget", "definition", "application", "no", "stage", "ssh", "player", "ha", "slice", "hand", "format", "magic", "sche", "callback", "error", "exec", "hi", "location", "handle", "ph", "password", "data", "slot", "Handler", "action", "writer", "host", "catch", "handled", "master", "new", "command", "message", "func", "man", "library", "byte", "processor", "pointer", "service", "time", "server", "reader", "wrapper", "off", "slave", "manager", "child", "lib", "route", "parse", "nil", "name", "event", "guard", "ctx", "function", "client", "loop", "api", "ignore", "match"], "set": ["setup", "session", "base", "connect", "start", "save", "open", "cut", "net", "update", "clear", "send", "store", "shift", "export", "create", "server", "run", "add", "util", "push", "ex", "nat", "Set", "SET", "ha", "dat", "sets", "parse", "nil", "sync", "end", "mod", "mut", "new", "sort", "check", "get", "sign", "cast", "init", "change", "et", "client", "use", "write", "match", "settings", "sc", "reset"], "old_set": [" old_sync", "old_sc", "old_reset", " old_reset", " old_sc", "old_sync"], "target_old_set": ["target_new_lock", "target_new_set", "target_new_sync", "target_old_lock", "target_old_sync"], "sa": ["osa", "sea", "sp", "va", "pse", "sg", "sh", "ama", "ta", "si", "wa", "na", "da", "ba", "pa", "sha", "sam", "asu", "s", "ka", "se", "au", "action", "ia", "SA", "sk", "la", "ai", "asi", "sta", "sie", "sche", "sl", "ga", "sm", "sn", "sb", "pc", "storage", "sd", "as", "aa", "asa", "ca", "ma", "api", "a", "Sa", "su", "so", "za", "sc", "security"], "q": ["l", "dq", "conf", "qt", "context", "pg", "n", "g", "w", "conn", "m", "t", "que", "z", "d", "iq", "c", "qu", "s", "p", "qq", "qs", "qa", "queue", "sq", "f", "sk", "v", "query", "state", "ctx", "req", "r", "qi", "cl", "u", "h", "self", "client", "Q", "ch"], "ts": ["ks", "ta", "ds", "tr", "test", "tl", "stats", "tc", "temp", "t", "tt", "tz", "ops", "gs", "tu", "s", "ls", "qs", "pt", "uts", "rs", "us", "cs", "tf", "acs", "ics", "states", "cons", "Ts", "tx", "tp", "ats", "tk", "ns", "pc", "tm", "sys", "TS", "fs", "ps", "ss", "bs", "td", "te"], "k": ["dk", "ku", "ks", "n", "g", "t", "z", "b", "kr", "d", "c", "s", "work", "p", "ka", "ak", "f", "sk", "j", "cs", "o", "ck", "kick", "v", "ky", "ik", "kin", "K", "tk", "uk", "kw", "ke", "unk", "u", "fork", "self", "y", "ch", "mk", "ok", "kk", "ko"]}}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n", "idx": 9651, "substitutes": {"d": ["ld", "gd", "dh", "ds", "did", "dom", "g", "da", "m", "id", "dt", "fd", "b", "t", "x", "dos", "i", "c", "ad", "ct", "bd", "p", "e", "cd", "f", "ded", "dl", "db", "dat", "xd", "v", "nd", "ind", "md", "r", "done", "dd", "dc", "sd", "grad", "od", "a", "dad", "dx", "D"], "address": ["channel", "Address", "element", "base", "start", "enter", "est", "ord", "date", "m", "id", "b", "pointer", "c", "ad", "enable", "addr", "uri", "config", "e", "ace", "target", "add", "value", "entry", "host", "device", "index", "shape", "size", "ind", "name", "order", "event", "end", "r", "object", "en", "grade", "offset", "node", "pair", "message", "ip", "attribute", "interface", "length", "image", "adder"], "val": ["count", "ld", "vals", "Val", "element", "ee", "seq", "arr", "byte", "valid", "base", "sel", "alt", "b", "x", "var", "VAL", "slot", "line", "addr", "el", "ref", "rel", "value", "db", "aval", "vol", "fl", "bl", "eval", "al", "v", "index", "lib", "sl", "end", "item", "part", "grad", "pos", "li", "length"], "len": ["count", "l", "ld", "seq", "le", "lf", "valid", "base", "str", "n", "fen", "id", "num", "z", "data", "line", "el", "ls", "lit", "f", "fl", " length", "size", "lib", "cap", "name", "ind", "end", "fun", "en", "err", "part", "enc", "fin", "fn", "type", "pos", "li", "lon", "length", "ann", "Len", "bin", "lc", "lan", "rev", "ln", "lin"]}}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 9670, "substitutes": {"size": ["count", "timeout", "base", "scale", "start", "si", "len", "section", "capacity", "small", "SIZE", "send", "shift", "last", "data", "from", "limit", "max", "adjust", "se", "e", "sum", "skip", "set", "p", "args", "loc", "array", "Size", "empty", "body", "large", "next", "code", "sec", "alloc", "shape", "sync", "content", "six", "sized", "address", "new", "position", "offset", "bytes", "after", "pos", "ip", "length", "cache", "ize", "fee"], "block": ["channel", "Block", "byte", "initial", "start", "section", "point", "pack", "page", "container", "job", "line", "batch", "work", "prev", "ref", "before", "number", "off", "frame", "loc", "group", "flow", "network", "next", "none", "label", "unit", "bl", "slice", "sync", "name", "clock", "object", "pre", "address", "new", "blocks", "error", "node", "plugin", "link", "type", "lock", "layer", "ip", "row", "image", "down", "buffer", "box", "range", "chain"], "next_block": [" next_row", "next_point", "next__point", "next_box", "next__block", "front_box", " next_lock", "next_layer", "next_page", " next_blocks", "next_lock", "front_group", "next_group", "next_line", " next_point", " next_line", " next_page", "next_unit", "front_block", "next_row", " next_layer", "next__row", "next_blocks", "front_unit", "next__page"], "end": ["eff", "start", "ext", "len", "est", "enter", "ended", "ff", "id", "open", "End", "ent", "ad", "update", "each", "send", "post", "z", "last", "line", "enable", "max", "limit", "close", "e", "prev", "set", "se", "add", "off", "ed", "stop", "next", "an", "mid", "append", " next", "index", "edge", "nd", "event", "inner", "address", "en", "begin", "new", "ending", "offset", "after", "enc", "pend", "until", "length", "use", "ize", "day", "END", "range"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n", "idx": 9683, "substitutes": {"chr": ["ichri", "phre", " chrr", "Chrar", "chri", "echrr", "CHr", "ichre", "phr", "ichrb", " chrar", "Chrc", "phrc", " chR", "Chr", "chre", " chrc", "CHrr", "echlr", "phri", "echR", " chlr", "echr", "chrr", "ichrc", " chre", "Chrb", " chri", "CHR", "chR", " chrb", "chlr", "chrar", "chrc", "CHlr", "ichr", "ichrar", "chrb"]}}
{"project": "qemu", "commit_id": "fdaef06917100d97782df550c1807a1da054e27e", "target": 0, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int buflen = 0;\n\n    int ret;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        if (!bdrv_is_inserted(s->bs))\n\n            goto not_ready;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        if (req->cmd.xfer < 4)\n\n            goto illegal_request;\n\n        buflen = scsi_device_get_sense(&s->qdev, outbuf, req->cmd.xfer,\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case START_STOP:\n\n        if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) {\n\n            /* load/eject medium */\n\n            bdrv_eject(s->bs, !(req->cmd.buf[4] & 1));\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        bdrv_set_locked(s->bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->bs, &nb_sectors);\n\n        if (!nb_sectors)\n\n            goto not_ready;\n\n        nb_sectors /= s->cluster_size;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX)\n\n            nb_sectors = UINT32_MAX;\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->cluster_size * 2;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case SYNCHRONIZE_CACHE:\n\n        ret = bdrv_flush(s->bs);\n\n        if (ret < 0) {\n\n            if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        memset(outbuf, 0, 8);\n\n        /* ??? This should probably return much more information.  For now\n\n           just return the basic header indicating the CD-ROM profile.  */\n\n        outbuf[7] = 8; // CD-ROM\n\n        buflen = 8;\n\n        break;\n\n    case SERVICE_ACTION_IN:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == 0x10) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->bs, &nb_sectors);\n\n            if (!nb_sectors)\n\n                goto not_ready;\n\n            nb_sectors /= s->cluster_size;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->cluster_size * 2;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case REPORT_LUNS:\n\n        if (req->cmd.xfer < 16)\n\n            goto illegal_request;\n\n        memset(outbuf, 0, 16);\n\n        outbuf[3] = 8;\n\n        buflen = 16;\n\n        break;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    return buflen;\n\n\n\nnot_ready:\n\n    if (!bdrv_is_inserted(s->bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n    } else {\n\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n    }\n\n    return -1;\n\n\n\nillegal_request:\n\n    scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    return -1;\n\n}\n", "idx": 9706, "substitutes": {"r": ["cr", "rf", "ru", "n", "hr", "w", "m", "fr", "mr", "rr", "b", "x", "d", "i", "c", "p", "e", "request", "rss", "rb", "rs", "q", "er", "j", "res", "v", "R", "rc", "ar", "rar", "ur", "re", "rg", "rev", "sr", "rh"], "outbuf": ["Outbuf", " outbuffer", "outcb", "inbuf", "OUTcb", " outbuff", "incb", "OUTcv", " outcv", "newcv", "Outcb", "newbuffer", "opuf", "outuf", "OUTbuffer", "OUTbuff", "newbuf", "outbuffer", "opbuf", "Outbuffer", "outbuff", "OUTuf", "opbuff", "Outuf", " outcb", " outuf", "opbuffer", "inuf", "OUTbuf", "inbuffer", "newuf", "Outbuff", "outcv", "inbuff"], "req": ["tr", "org", "http", "require", "z", "ver", "ra", "config", "ref", "tar", "qq", "cb", "reg", "er", "call", "ctr", "state", "cur", "err", "spec", "get", "form", "grad", "row", "pkg", "resp", "w", "fr", "low", "gr", "serv", "c", "e", "pro", "app", "request", "sq", "f", "j", "res", "input", "md", "load", "desc", "required", "this", "ch", "exec", "sem", "dq", "rf", "ru", "seq", "str", "g", "def", "conn", "src", "d", "data", "ir", "rt", "resource", "query", "ro", "dev", "comp", "cache", "cmd", "crit", "sr", "rh", "conf", "qt", "wa", "rr", "rec", "p", "queue", "rs", "q", "sec", "requ", "ctx", "pull", "h", "proc"], "s": ["conf", "session", "sg", "ts", "ds", "is", "g", "w", "http", "b", "ray", "t", "ops", "d", "gs", "service", "c", "serv", "p", "ls", "js", "rs", "sec", "sq", "f", "q", "j", "os", "cs", "sym", "res", "S", "v", "sync", "states", "services", "sup", "ns", "hs", "sis", "spec", "sys", "fs", "su", "ses", "ps", "y", "ss", "uns", "ssl"], "nb_sectors": ["nb_gecs", "nb_vectors", "nb_secs", "nb_pefs", "nb_sefs", "nb_gectors", "nb_pectors", "nb_pegments", "nb_segments", "nb_gefs", "nb_vecs", "nb_vefs", "nb_pecs", "nb_vegments", "nb_gegments"], "ret": ["alt", "val", " resp", "def", " success", "no", "Ret", " Ret", "mem", "red", "reg", "rets", "res", "rc", "Num", "fun", "re", "RET", "back", " RET", "result", "match", "resp", "success"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "static void flush_queued_work(CPUState *cpu)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (cpu->queued_work_first == NULL) {\n\n        return;\n\n    }\n\n\n\n    while ((wi = cpu->queued_work_first)) {\n\n        cpu->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n        if (wi->free) {\n\n            g_free(wi);\n\n        }\n\n    }\n\n    cpu->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9707, "substitutes": {"cpu": ["uca", "cow", "kernel", "boot", "processor", "conn", "gpu", "bench", "auc", "prem", "consumer", "instance", "GPU", "fi", "cp", "c", "vm", "chu", "cu", "cli", "lu", "np", "uci", "cn", "cf", "eni", "hw", "pai", "bc", "colo", "cs", "unit", "linux", "process", "clock", "winner", "ctx", "loader", "lb", "pu", "custom", "pc", "nic", "CPU", "fork", "gc", "nc", "cfg", "ci", "css", "cache", "core", "lc", "proc", "ocr", "cus", "roc", "fc"], "wi": ["wid", "Wi", "wl", "hi", "wiki", "ee", "ani", "ui", "di", "wp", "WI", "si", "wa", "worker", "w", "xi", "iw", "iri", "ini", "wine", "fw", "sci", "i", "data", "wk", "cu", "yi", "mu", "wm", "gui", "wal", "eni", "wo", "hei", "wic", "wei", "gi", "mi", "ti", "wife", "chi", "qi", "ei", "bi", "ii", "wan", "wu", "wit", "ci", "ni", "ski", "fi", "ki", "fee"]}}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n", "idx": 9709, "substitutes": {"guest_base": ["guester_area", "guess_based", "guess_base", "guest67size", "guester_bas", "guest_based", "guest67based", "guest_start", "guest67area", "guess_start", "guess_size", "guest_bas", "guest_bare", "guester_bare", "guest67base", "guester_base", "guester_size", "guest_area", "guess_area"], "guest_size": ["guest_offset", "guest64base", "guested64sec", "guested64size", "guested_sec", "guested64address", "guested_address", "guested_base", "guest_address", "guest64sec", "guest_sec", "guested_size", "guested64base", "guest64address", "guester_base", "guester_size", "guester_offset", "guest64size"], "real_start": ["re_address", "realamcost", "real_shift", "realacstart", " real_cost", "real64set", "realpend", " real_set", "complex_art", "re_start", "re_end", "realacsearch", "real67end", "realacaddr", "realpart", "real_address", " real_size", "real_end", "realamstart", "realpoffset", "real67shift", "real64end", "real_offset", "real_search", "complex_offset", " real_search", "real64cost", "real67start", "realamset", "re_shift", "real_set", "complex_end", "real_cost", "real_pad", "complex_start", " real_end", " real_addr", " real_stack", "realacsize", "real67address", "realamend", "realpstart", " real_pad", "real_art", "real_addr", "real_stack", "real64start", "real_size"], "test_page_addr": ["test_page_adr", "test_pageacsize", "test_site_adr", "test_server_offset", "test_page_ord", "test_server_addr", "test_page_ext", "test_site_ad", "test_site_size", "test_pageacord", "test_site_dist", "test_page64offset", "test_page_ad", "test_site_ord", "test_server_ext", "test_server_size", "test_pagexaddr", "test_pagexsize", "test_pageacaddr", "test_page_dist", "test_page64addr", "test_pagexext", "test_page_address", "test_site_addr", "test_site_address", "test_page_offset", "test_page64size", "test_page_size", "test_pageacaddress", "test_pagexaddress", "test_server_address", "test_page64address", "test_site_offset"]}}
{"project": "qemu", "commit_id": "f5f601afcec6c1081128fe5a0f831788ca9f56ed", "target": 1, "func": "long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 9721, "substitutes": {"env": ["chal", "conf", "qt", "context", "equ", "dict", "conn", "que", "net", "iv", "viron", "ne", "iss", "environment", "vm", "config", "el", "obj", "e", "stack", "osc", "ep", "np", "txt", "ec", "priv", "eni", "manager", "code", "ev", "db", "console", "dir", "edge", "ea", "exc", "scope", "ce", "v", "event", "ctx", "loader", "en", "eng", "Environment", "enc", "ef", "cfg", "nc", "et", "dev", " environment", "her", "site", "engine", "agent", "eu", "core"], "frame": ["cpu", "setup", "element", "boot", "vert", "Frame", "base", "up", "config", "frames", "window", "date", "def", "processor", "scene", "fr", "point", "chip", "game", "que", "ne", "block", "line", "fb", "environment", "fram", "tick", "component", "thread", "e", "target", "ace", "role", "cf", "face", "ze", "flow", "sequence", "f", "host", "code", "profile", "slice", "version", "ea", "module", "scope", "parse", "ind", "connection", "event", "feature", "state", "iframe", "object", " Frame", "jp", "framework", "position", "node", "cfg", "message", "file", "flo", "interface", "image", "feat", "fi", "fe"], "frame_addr": ["frame_slice", " frame_slice", "frame_nz", "frame_oa", "frameIPaddr", "sample_addr", "frame64address", "frame64adr", "frame_offset", " frame_ord", "frame_adr", "sample_oa", " frame_offset", " frame_address", "frameIPaddress", "frame64addr", "frame_ord", "frame_ptr", "sample_adr", " frame_ptr", "frame_address", "frame64oa", "frameIPoffset", "sample_address", "frameIPnz", " frame_nz"], "target_set": ["useracsystem", "target_system", "targetWsystem", "arget_type", "target_spec", "targetacspec", "arget_sc", "useracset", "target_sc", "target_export", " target_sign", "target_type", "targetacset", " target_cut", "targetWexport", " target_system", "target_cut", "targetFsystem", "user_system", "useracexport", "targetFset", "targetFcut", "target_store", "useracspec", "target_sign", "user_spec", "user_export", "targetFsign", "user_set", "targetWset", "targetWspec", " target_store", "arget_set", "targetacsystem", " target_sc", "targetacexport"], "set": ["setup", "seq", "base", "scale", "start", "section", "key", "cut", "pack", "open", "net", "update", "clear", "send", "store", "create", "ne", "sa", "ct", "se", "target", "exec", "st", "code", "Set", "SET", "call", "parse", "scope", "nil", "sync", "ind", "mut", "en", "setting", "get", "sign", "cast", "init", "read", "change", "et", "client", "site", "match", "write", "gen", "sc", "reset"], "i": ["oi", "diff", "l", "ui", "di", "start", "si", "n", "in", "zi", "key", "m", "xi", "id", "t", "x", "b", "ini", "k", "d", "page", "c", "s", "p", "uri", "ix", "e", "cli", "mu", "split", "yi", "f", "j", "ai", "code", "o", "multi", "slice", "index", "v", "gi", "ti", "phi", "name", "abi", "qi", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "ni", "io", "lc", "ski", "ri", "y", "fi", "iu"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n", "idx": 9722, "substitutes": {"priv": ["pad", "conn", "info", "prom", "pl", "pack", "temp", "pred", "pid", "tty", "cp", "p", "pri", "pb", "pro", "attr", "private", "ptr", "prop", "Priv", "tmp", "sk", "ev", "pub", "device", "rc", "port", "raf", "pi", "pc", "eth", "impl", "deb", "api", "proc"], "id": ["parent", "channel", "ide", "is", "start", "in", "pad", "info", "uid", "fd", "path", "pid", "d", "i", "ad", "ref", "p", "ids", "cd", "ida", "e", "ID", "ep", "ptr", "entry", "code", "mid", "kid", "name", "rc", "event", "end", "ider", "address", "ident", "oid", "error", "init", "type", "aid", "Id", "od", "ip", "sid", "one"], "interrupt_packet": ["interrupt_paramET", "interrupt_signacket", "interrupt_packette", "interrupt_processeting", "interrupt_requestet", "interrupt_exeting", "interrupt_sexets", "interrupt_sexacket", "interrupt_signet", "interrupt_paramets", "interrupt_packail", "interrupt_sexet", "interrupt_viewET", "interrupt_packET", "interrupt_sexception", "interrupt_parametting", "interrupt_streamail", "interrupt_compant", "interrupt_packetting", "interrupt_exet", "interrupt_viewet", "interrupt_encette", "interrupt_sexant", "interrupt_packeting", "interrupt_promets", "interrupt_requestET", "interrupt_paramail", "interrupt_packageets", "interrupt_viewette", "interrupt_sexET", "interrupt_parameting", "interrupt_packageET", "interrupt_packant", "interrupt_paramet", "interrupt_sexetting", "interrupt_processet", "interrupt_promacket", "interrupt_pacET", "interrupt_packception", "interrupt_compets", "interrupt_signception", "interrupt_encets", "interrupt_pacets", "interrupt_packageacket", "interrupt_packacket", "interrupt_processacket", "interrupt_paramette", "interrupt_signET", "interrupt_packets", "interrupt_paramacket", "interrupt_requestacket", "interrupt_pacet", "interrupt_streamet", "interrupt_viewets", "interrupt_exET", "interrupt_paramant", "interrupt_streameting", "interrupt_encET", "interrupt_exacket", "interrupt_requestetting", "interrupt_sexeting", "interrupt_processail", "interrupt_packageet", "interrupt_promet", "interrupt_streamacket", "interrupt_paramception", "interrupt_pacacket", "interrupt_compacket", "interrupt_promET", "interrupt_encet", "interrupt_compet"], "data": ["parent", "up", "valid", "delay", "str", "len", "window", "record", "pad", "def", "da", "info", "pack", "missing", "d", "rec", "last", "p", "reader", "package", "ada", "feed", "memory", "empty", "DATA", "next", "entry", "dat", "progress", "device", "size", "input", "response", "event", "raw", "done", "address", "new", "Data", "error", "bytes", "type", "message", "complete", "ip", "api", "image", "result", "video", "a", "cache", "buffer"], "data_len": ["datasln", "bytesLen", "datasLen", "byteslimit", "Data_length", " data_length", "data_length", "Data_l", "Data_len", "dataslimit", "byteslen", "data_ln", "byte_limit", "byte_len", "bytesln", "byte_ln", "Data_Len", "data_limit", "byte_Len", "dataslen", "data_l", "data_Len", "data64Len", "data64ln", " data_pos", "data64len", "data_pos", " data_Len", "data64limit"], "dev": ["diff", "conf", "gu", "di", "cam", "valid", "debug", "dom", "comment", "prof", "test", "def", "w", "conn", "info", "Dev", "prom", "die", "temp", "game", "dem", "adv", "d", "ver", "de", "var", "ad", "block", "ow", "p", "app", "pro", "reg", "ep", "private", "bug", "rad", "serial", "hw", "df", "sk", "prop", "ev", "device", "pub", "v", "home", "end", "req", "loader", "mod", "user", "dd", "dc", "error", "link", "dm", "grad", "self", "h", "mem", "ip", "deb", "engine", "ch", "proc", "dep", "DEV"], "aurb": ["vrab", "ergb", "aurk", "rrB", "aurab", "ergc", "igrb", "aurp", "orgib", "turp", "earB", "ergbis", "orgob", "igrab", "rarb", "urB", "eara", "aubis", "url", "ergr", "vrk", "orgb", "lrab", "aub", "turb", "rara", "ura", "aurf", "igrob", "vra", "earb", "rumab", "earp", "turk", "birdl", "vrib", "aurB", "rra", "urp", "vrp", "aul", "aurib", "aua", "lrB", "birdb", "urc", "tura", "vrb", "birdib", "urf", "rumf", "aurr", "urbis", "rumb", "igrib", "lrb", "auib", "aurob", "urib", "auab", "rarp", "rumB", "rrb", "urr", "urk", "auc", "lrf", "aurbis", "orgab", "urb", "aup", "birdc", "vrob", "urab", "rrp", "aur", "aurl", "rarab", "aura", "aurc"]}}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "void mpeg1_encode_mb(MpegEncContext *s,\n\n                     DCTELEM block[6][64],\n\n                     int motion_x, int motion_y)\n\n{\n\n    int i, cbp;\n\n    const int mb_x = s->mb_x;\n\n    const int mb_y = s->mb_y;\n\n    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;\n\n\n\n    /* compute cbp */\n\n    cbp = 0;\n\n    for(i=0;i<6;i++) {\n\n        if (s->block_last_index[i] >= 0)\n\n            cbp |= 1 << (5 - i);\n\n    }\n\n    \n\n    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && \n\n        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||\n\n        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |\n\n        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {\n\n        s->mb_skip_run++;\n\n        s->qscale -= s->dquant;\n\n        s->skip_count++;\n\n        s->misc_bits++;\n\n        s->last_bits++;\n\n        if(s->pict_type == P_TYPE){\n\n            s->last_mv[0][1][0]= s->last_mv[0][0][0]= \n\n            s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0;\n\n        }\n\n    } else {\n\n        if(first_mb){\n\n            assert(s->mb_skip_run == 0);\n\n            encode_mb_skip_run(s, s->mb_x);\n\n        }else{\n\n            encode_mb_skip_run(s, s->mb_skip_run);\n\n        }\n\n        \n\n        if (s->pict_type == I_TYPE) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n        } else if (s->mb_intra) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 6, 0x01, 0, 0);\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 5, 0x03, 0, 0);\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n            memset(s->last_mv, 0, sizeof(s->last_mv));\n\n        } else if (s->pict_type == P_TYPE) { \n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp != 0) {\n\n                    if ((motion_x|motion_y) == 0) {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern & quant */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                    } else {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                        mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                        mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                        s->mv_bits+= get_bits_diff(s);\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->misc_bits+= get_bits_diff(s);\n\n                    mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                    mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                    s->qscale -= s->dquant;\n\n                    s->mv_bits+= get_bits_diff(s);\n\n                }\n\n                s->last_mv[0][1][0]= s->last_mv[0][0][0]= motion_x;\n\n                s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y;\n\n            }else{\n\n                assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD);\n\n\n\n                if (cbp) {\n\n                    if(s->dquant){\n\n                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    }else{\n\n                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits+= get_bits_diff(s);\n\n                for(i=0; i<2; i++){\n\n                    put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                    s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                    s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                }\n\n                s->mv_bits+= get_bits_diff(s);\n\n            }\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n            s->f_count++;\n\n        } else{  \n\n            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi\n\n\n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 0);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); \n\n                    mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); \n\n                    s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0];\n\n                    s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1];\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); \n\n                    mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); \n\n                    s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0];\n\n                    s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1];\n\n                    s->b_count++;\n\n                }\n\n            }else{\n\n                assert(s->mv_type == MV_TYPE_FIELD);\n\n                assert(!s->frame_pred_frame_dct);\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 1);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                        s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                    }\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[1][i]);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);\n\n                        s->last_mv[1][i][0]=   s->mv[1][i][0];\n\n                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];\n\n                    }\n\n                    s->b_count++;\n\n                }\n\n            }\n\n            s->mv_bits += get_bits_diff(s);\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n        }\n\n        for(i=0;i<6;i++) {\n\n            if (cbp & (1 << (5 - i))) {\n\n                mpeg1_encode_block(s, block[i], i);\n\n            }\n\n        }\n\n        s->mb_skip_run = 0;\n\n        if(s->mb_intra)\n\n            s->i_tex_bits+= get_bits_diff(s);\n\n        else\n\n            s->p_tex_bits+= get_bits_diff(s);\n\n    }\n\n}\n", "idx": 9727, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "sum", "v", "series", "bis", "full", "ans", "ns", "details", "spec", "self", "settings", "sg", "ds", "si", "n", "w", "b", "c", "e", "se", "sq", "us", "f", "sym", "sets", "es", "sup", "r", "en", "this", "comments", "fs", "su", "site", "ps", "ss", "ks", "sv", "g", "features", "stats", "ops", "d", "ys", "ls", "os", "cs", "sync", "sl", "new", "sb", "sys", "a", "ssl", "conf", "sports", "ts", "in", "service", "p", "qs", "ins", "xs", "js", "rs", "an", "aws", "S", "states", "services", "less", "client", "ses", "css", "y", "bs"], "block": ["Block", "byte", "window", "record", "w", "info", "stat", "data", "config", "output", "e", "script", "bc", "mode", "device", "size", " blocks", "input", "ctx", "object", "audio", "blocks", "enc", "type", "video", "image", "cache", "buffer"], "motion_x": ["motionIdname", "motion_index", "move_name", "motion_name", "motion___y", "rup_y", "motion___index", "motion___dx", "motion_cross", "motionIdy", "motion___x", "rup_index", "rup_x", "move_cross", "motionIdcross", "motionIdx", "rup_dx", "motion_dx", "move_x", "move_y"], "motion_y": ["eye_ya", "motion_height", "motion_ya", "move_py", "eye_y", "motion11y", "eye_x", "move_height", "motion11height", "eye_height", "motion11x", "motion_py", "motion11py", "move_x", "move_y"], "i": ["oi", "l", "hi", "ui", "di", "n", "si", "in", "zi", "key", "m", "xi", "info", "b", "x", "k", "ini", "ami", "d", "c", "ji", "p", "ix", "uri", "e", "yi", "mu", "eni", "f", "j", "ai", "index", "v", "ind", "gi", "mi", "ti", "phi", "r", "chi", "abi", "qi", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "api", "ori", "io", "ni", "lc", "y", "ri", "fi", "iu", "ki"], "cbp": ["CBpc", "bbP", "cbc", "rbpc", "abbp", "CBp", "cbpi", "rbps", "cfpc", "bbps", "bbpi", "rbpi", "CBP", "bcpc", "bbp", "cbpc", "cfP", "cbps", "ggps", "ggpi", "ggp", "cfps", "rbc", "abbc", "CBps", "abbP", "bcp", "CBc", "rbp", "bcps", "abbps", "bcP", "bbpc", "abbpc", "cfp", "ggP", "rbP", "cbP"], "mb_skip_run": ["mb_skip_bit", "mb_skip_count", "mb_num_unit", "mb_num_bit", "mb_num_run", "mb_num_count", "mb_skip_unit"], "skip_count": ["miss_file", "skipalcount", "skipalcounter", "skipalfile", "miss_code", "skip_file", "skip_code", "miss_counter", "skipalcode", "miss_count", "skip_counter"], "misc_bits": ["every_bands", "skipumbits", "everyveldates", "skipumdates", "everyvelbands", "every_runs", "skipumbands", "skipvelbands", "skipvelbits", "skip_bits", "everyvelruns", "everyvelbits", "skip_runs", "skipumruns", "skip_dates", "skipvelruns", "skip_bands", "every_bits", "skipveldates", "every_dates"], "last_bits": ["last128cycles", "lastallcycles", "last128locks", "last_bit", "max_bits", "max_bit", "lastallbit", "lastalllocks", "last128bit", "lastallbits", "last_locks", "max_locks", "last_cycles", "max_cycles", "last128bits"]}}
{"project": "qemu", "commit_id": "fb846a094fdee7bb6a88b48aeed0d97a8080a20d", "target": 0, "func": "static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)\n\n{\n\n    unsigned int cssid = 0;\n\n    unsigned int ssid = 0;\n\n    unsigned int schid;\n\n    unsigned int devno;\n\n    bool have_devno = false;\n\n    bool found = false;\n\n    SubchDev *sch;\n\n    int num;\n\n    DeviceState *parent = DEVICE(dev);\n\n    Error *err = NULL;\n\n    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);\n\n    VirtIODevice *vdev;\n\n\n\n    sch = g_malloc0(sizeof(SubchDev));\n\n\n\n    sch->driver_data = dev;\n\n    dev->sch = sch;\n\n\n\n    dev->indicators = NULL;\n\n\n\n    /* Initialize subchannel structure. */\n\n    sch->channel_prog = 0x0;\n\n    sch->last_cmd_valid = false;\n\n    sch->thinint_active = false;\n\n    /*\n\n     * Use a device number if provided. Otherwise, fall back to subchannel\n\n     * number.\n\n     */\n\n    if (dev->bus_id) {\n\n        num = sscanf(dev->bus_id, \"%x.%x.%04x\", &cssid, &ssid, &devno);\n\n        if (num == 3) {\n\n            if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) {\n\n                error_setg(errp, \"Invalid cssid or ssid: cssid %x, ssid %x\",\n\n                           cssid, ssid);\n\n                goto out_err;\n\n            }\n\n            /* Enforce use of virtual cssid. */\n\n            if (cssid != VIRTUAL_CSSID) {\n\n                error_setg(errp, \"cssid %x not valid for virtio devices\",\n\n                           cssid);\n\n                goto out_err;\n\n            }\n\n            if (css_devno_used(cssid, ssid, devno)) {\n\n                error_setg(errp, \"Device %x.%x.%04x already exists\",\n\n                           cssid, ssid, devno);\n\n                goto out_err;\n\n            }\n\n            sch->cssid = cssid;\n\n            sch->ssid = ssid;\n\n            sch->devno = devno;\n\n            have_devno = true;\n\n        } else {\n\n            error_setg(errp, \"Malformed devno parameter '%s'\", dev->bus_id);\n\n            goto out_err;\n\n        }\n\n    }\n\n\n\n    /* Find the next free id. */\n\n    if (have_devno) {\n\n        for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n            if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                sch->schid = schid;\n\n                css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"No free subchannel found for %x.%x.%04x\",\n\n                       cssid, ssid, devno);\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"user-configured\");\n\n    } else {\n\n        cssid = VIRTUAL_CSSID;\n\n        for (ssid = 0; ssid <= MAX_SSID; ssid++) {\n\n            for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n                if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                    sch->cssid = cssid;\n\n                    sch->ssid = ssid;\n\n                    sch->schid = schid;\n\n                    devno = schid;\n\n                    /*\n\n                     * If the devno is already taken, look further in this\n\n                     * subchannel set.\n\n                     */\n\n                    while (css_devno_used(cssid, ssid, devno)) {\n\n                        if (devno == MAX_SCHID) {\n\n                            devno = 0;\n\n                        } else if (devno == schid - 1) {\n\n                            error_setg(errp, \"No free devno found\");\n\n                            goto out_err;\n\n                        } else {\n\n                            devno++;\n\n                        }\n\n                    }\n\n                    sch->devno = devno;\n\n                    css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"Virtual channel subsystem is full!\");\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"auto-configured\");\n\n    }\n\n\n\n    /* Build initial schib. */\n\n    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\n\n\n\n    sch->ccw_cb = virtio_ccw_cb;\n\n\n\n    /* Build senseid data. */\n\n    memset(&sch->id, 0, sizeof(SenseId));\n\n    sch->id.reserved = 0xff;\n\n    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;\n\n\n\n    if (k->realize) {\n\n        k->realize(dev, &err);\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n\n        goto out_err;\n\n    }\n\n\n\n    /* device_id is only set after vdev has been realized */\n\n    vdev = virtio_ccw_get_vdev(sch);\n\n    sch->id.cu_model = vdev->device_id;\n\n\n\n    /* Only the first 32 feature bits are used. */\n\n    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                         dev->host_features[0]);\n\n\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    dev->sch = NULL;\n\n    g_free(sch);\n\n}\n", "idx": 9744, "substitutes": {"dev": ["diff", "conf", "gu", "dim", "sh", "di", "cam", "img", "valid", "cand", "debug", "dom", "comment", "test", "Dev", "w", "conn", "def", "info", "die", "pack", "dem", "adv", "d", "ver", "de", "doc", "data", "ad", "block", "var", "mem", "config", "app", "driver", "dist", "plug", "rad", "priv", "nov", "serial", "df", "sk", "ev", "device", "db", "pub", "v", "md", "req", "mod", "user", "dd", "dc", "bus", "sd", "root", "this", "dm", "grad", "self", "der", "api", "cache", "ch", "ow", "wd", "DEV"], "errp": ["reqg", "iterP", " errP", "lerps", "bugpr", "mrpr", "iterg", "nerpr", "nerp", "lerP", "errg", "nerP", "errcp", "errpe", "errps", "finderP", "bugP", "finderpc", " errpc", "eorb", "errorp", "errorP", "errorpc", "eorps", "strpc", "reqp", "itern", "reqcp", "errn", "itercp", "rrn", "strps", "reqn", "rrp", "mrP", "finderp", "rrcp", "lerb", "errP", " errb", "errpc", "eorp", "rrg", "mrpe", "bugp", "eorP", "mrp", "lerp", "nerpe", "bugpe", "strp", "iterps", "errpr", "iterp", " errps", "errb", "errorps", "iterpc", "finderps"], "schid": ["scheId", "scname", "chids", "sckid", "schaid", "scheid", "scids", "schID", "cssname", "chid", "skip", "cssids", "skit", " schno", "schkid", "csshide", "servID", "schit", "schite", "khid", "sshide", "cssid", "chip", "skno", "khip", "slId", "chkid", " schit", "schids", "slname", "ch\n", "skID", "skkid", "scit", "ssids", "chno", "scheids", "scheno", "skite", "khite", "slid", "khname", "slkid", "chname", "skaid", "schId", "skname", "scID", "skid", " schID", "skids", "schip", "schno", "ssname", "chaid", "servname", "sskid", "schhide", "schname", "servaid", "ssId", "scid", "chID", "scno", "servid", "skId", "chId", "schehide", "schename", "chite", "sk\n"], "devno": ["advnone", "debugyes", "divNo", "varno", "evyes", "privnos", "privNo", "divdo", " devNo", "devnone", "privno", " devnumber", " devyes", "devnumber", "divno", "evnos", "devyes", "advNo", "veryes", "evlo", "errn", "verno", "vardo", "varyes", "divnos", "advn", " devdo", "debugn", "evno", "varnumber", "divyes", "devdo", "evn", "errNo", "debugno", "evNo", "varnos", "devlo", " devn", "errno", "devnos", "errnone", " devlo", "vernumber", "appyes", " devnone", "appn", "varNo", "devn", " devnos", "debugNo", "appNo", "advno", "appno", "privn", "divlo", "devNo"], "sch": ["cr", "sp", "channel", "osh", "arch", "ach", "ich", "http", "loc", "sk", "ctr", "ky", "cher", "usb", "spec", "chain", "si", "chip", "school", "ssh", "gr", "serv", "s", "se", "app", "chn", "cho", "th", "scope", "shop", "sche", "sm", "ch", "ss", "sc", "sh", "g", "ph", "conn", "src", "kr", "cer", "cp", "gb", "zh", "cs", "inch", "bh", "sl", "chi", "sn", "sb", "enc", "sys", "Sch", "sr", "mc", "rh", "ssl", "conf", "sw", "service", "gh", "plug", "inst", "cht", "chy", "ctx", "git", "sd", "kh", "cfg", "cm", "soc", "ci", "css"], "num": ["count", "un", "nob", "nb", "n", "len", "span", "ul", "no", "id", "nam", "con", "sum", "max", "coord", "number", "du", "loc", "code", "unit", "index", "umi", "inc", "name", "Num", "nom", "nr", "miss", "offset", "node", "orig", "col", "uni", "fn", "nc", "loop", "nu", "su", "result", "um", "gen", "om", "NUM"], "parent": ["conf", "channel", "cow", "cmp", "arch", "class", "def", "conn", "src", "instance", "i", "c", "data", "CH", "f", "inst", "child", "scope", "state", "cur", "ctx", "root", "self", "cfg", "Parent", "cache", "mc"], "err": ["acer", "conf", "arr", "proc", "mr", "rr", "gr", "cb", "ec", "er", "dr", "ev", "res", "exc", "msg", "phi", "ise", "req", "error", "sys", "cfg", "der", "ah", "Er", "resp", "rh", "fi"], "k": ["dk", "kind", "conf", "kernel", " sk", "mk", "ks", "n", "m", "conn", "kr", "c", "wk", "sk", "kid", "ck", "v", "ky", "ik", "ctx", "K", "tk", "uk", "kw", "spec", "mc", "ki", "kk"], "vdev": ["vdiv", "fdiv", "Vdev", "Vdevice", "fdev", "vddev", "vddevice", "vddiv", "Vdiv", "fdevice", "vdevice"], "ssid": ["pside", "ssin", "dsids", "dsid", "hessids", "schID", "cssname", "psin", "nskid", "psid", "cssids", "wslike", "wside", "lessid", "nsaid", "dside", "rssid", "cssID", "csit", "csids", "csslike", "schit", "csslit", "csID", "ssit", "hessid", "cssaid", "hesslit", "cssid", "nsid", "hessi", "hesside", "dsin", "grossname", "grossid", "dskid", "cslike", "csid", "lesskid", "nslike", "schids", "dsit", "wsid", "skID", "wsids", "ssaid", "ssids", "lessname", "hesslike", "csname", "cssi", "csside", "grossi", "rsskid", "ssi", "hessaid", "pskid", "nsids", "cside", "sslike", "cskid", "skname", "skid", "rssids", "nsID", "sslit", "skide", "rsside", "rsslike", "ssname", "sside", "grosslit", "sskid", "rssID", "rssname", "dsID", "hesskid", "ssID", "csskid", "rssin", "lessID", "schlike", "schide", "hessname"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 9754, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tunsigned i;\n\n#ifdef HAVE_MMX\n\n\tlong mmx_size= 23 - src_size;\n\n\tasm volatile (\n\n\t\t\"test %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\"jns 2f\t\t\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 32(%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq  2(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // R BGR BGR B\n\n\t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR\n\n\t\t\"pand %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq  6(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\tMOVNTQ\" %%mm1,   (%2, %%\"REG_a\")\\n\\t\" // RGB RGB RG\n\n\t\t\"movq  8(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // R BGR BGR B\n\n\t\t\"movq 10(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // GR BGR BGR\n\n\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq 14(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // R BGR BGR B\n\n\t\tMOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n", "idx": 9761, "substitutes": {"src": ["seq", "img", "reflect", "tif", "proc", "source", "sel", "b", "sur", "RC", "rest", "send", "rect", "sci", "s", "config", "stream", "dest", "cb", "gb", "usr", "dist", "rb", "loc", "rs", "sq", "st", "sec", "share", "inst", "sub", "slice", "cv", "sync", "rc", "input", "sl", "r", "cur", "sup", "ctx", "ruby", "sort", "support", "desc", "sb", "spec", "reverse", "secure", "sys", "grad", "transform", "url", "gz", "comp", "rob", "sr", "uc", "ssl", "sc"], "dst": ["nrc", "ldr", "dsp", "lsrc", "lsts", "ldest", " ddr", "Dsts", "ssp", "ddr", "sdest", "lst", "adconst", "asm", "dST", " drc", "DST", "Ddest", " dconst", "all", "_", "nbl", "addr", " dST", "ddest", " dbl", "r", "sddest", "bytes", "ssts", "sst", " ddest", " dsc", "dbl", "Ddr", "g", " dsp", "nconst", "drc", "lsc", "num", "lST", "dconst", " dsts", "adrc", "Dconst", "dsts", "adst", "adsc", "dsrc", "sdconst", "sdsts", "pack", "sdst", "dsc", " dsrc", "lsp", "nst", "Dst", "adsrc", "adbl"], "src_size": ["src96size", "src_length", "src96value", "src__size", "src_sized", "rc_name", "sb96scale", "sb_cycle", " src_start", "src_name", " src_length", "src__strength", "source_speed", "src_strength", " src_scale", "src_start", "src_fee", "sb96size", "src96start", "source_scale", "sb_size", "rc_size", "src_center", "source_size", "sb96value", "src_cycle", "src_scale", "source_fee", "rc_strength", "sb_scale", "rc_scale", " src_sized", "src96address", "src_address", "sb96cycle", "src_value", "src96scale", "src__scale", "src96cycle", "source_center", "sb_value", " src_address", "src_speed"], "i": ["oi", "l", "ui", "di", "it", "start", "n", "g", "si", "in", "zi", "key", "source", "m", "id", "xi", "info", "b", "t", "z", "ini", "my", "d", "ami", "page", "c", "ji", "s", "p", "ix", "uri", "e", "mu", "cli", "eni", "f", "j", "ai", "multi", "index", "slice", "v", "gi", "mi", "phi", "name", "r", "inner", "qi", "pi", "bi", "ii", "bit", "init", "u", "type", "h", "I", "li", "api", "ci", "a", "ni", "io", "y", "ri", "fi", "iu", "anti"], "memory": ["mac", "session", "reference", "reflect", "media", "record", "m", "application", "gpu", "Memory", "mm", "mem", "vm", "texture", "reg", "array", "binary", "resource", "master", "program", "r", "address", "function", "storage", "asm", "java", "message", "medium", "math", "cache", "ram", "image", "M", "buffer"], "x": ["xf", "xp", "val", "xx", " xx", "m", "xi", "w", "id", "b", "z", "d", "c", "s", "X", "p", "ix", "e", "ux", "xs", "f", "v", "ic", "tx", "xc", "xt", "u", "h", "xe", "rx", "px", "y", "xb", "dx", "ex"]}}
{"project": "FFmpeg", "commit_id": "ffd7fd79441f97f1edb25181af0603ff6ea9b342", "target": 1, "func": "static int vda_h264_end_frame(AVCodecContext *avctx)\n{\n    H264Context *h                      = avctx->priv_data;\n    struct vda_context *vda_ctx         = avctx->hwaccel_context;\n    AVFrame *frame                      = &h->cur_pic_ptr->f;\n    struct vda_buffer *context;\n    AVBufferRef *buffer;\n    int status;\n    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)\n    status = vda_sync_decode(vda_ctx);\n    frame->data[3] = (void*)vda_ctx->cv_buffer;\n    if (status)\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);", "idx": 9772, "substitutes": {"avctx": [" avcas", "afctx", "AVcf", "avcs", "svcontext", "avectx", "ajcb", "avcf", "svcas", "AVcontext", "AVkb", "avconn", "ajctx", "ajcontext", "ajkb", " avcs", "AVconn", "AVctx", " avcontext", "avcontext", "svcs", " avconn", "ajcf", "svconn", "avekb", "avctrl", "ajconn", "avkb", "avecf", "AVcb", "avecontext", "afcontext", " avctrl", "avcb", "AVcas", "afctrl", "afcs", "svctrl", "avcas", " avcb", "svctx"], "h": ["sh", "he", "ht", "n", "g", "hr", "ph", "auth", "w", "m", "http", "t", "d", "c", "data", "p", "hm", "e", "cf", "gh", "ec", "q", "hw", "f", "host", "o", "ha", "v", "ih", "ctx", "hp", "hd", "H", "self", "handler", "header", "ah", "ch", "rh"], "vda_ctx": ["vdc_sync", "vdc_context", "vda__ctx", "vDa_ctx", "vla_tx", "vda_ca", "vDA_coll", "vda_lc", "vda__cmp", "vDa_context", "vdc_conn", "vda2ci", "vda_tx", "vda_sync", "vda2context", "vDa_cu", "vla_cmp", "vda2coll", "vda_cu", "vda__lc", "vda_cmp", "vda__conn", "vda_ci", "vda_coll", "vDA_context", "vDa_rt", "vda2ctx", "vdc_ctx", "vDA_ctx", "vla_context", "vda__context", "vda_conn", "vda_rt", "vla_ctx", "vDA_ci", "vda_context", "vdc_ca", "vda__tx", "vdc_lc"], "frame": ["channel", "element", "Frame", "base", "frames", "source", "window", "view", "board", "game", "data", "block", "line", "c", "fram", "p", "stack", "thread", "draw", "request", "cf", "flow", "f", "call", "trace", "event", "ctx", "iframe", "object", "document", "file", "message", "header", "row", "video", "image"], "context": ["parent", "channel", "center", "base", "source", "board", "instance", "container", "buf", "data", "config", "stream", "component", "stack", "thread", "cf", "flow", "shape", "scope", "event", "content", "ctx", "document", "header", "image", "definition"], "buffer": ["channel", "reference", "source", "window", "record", "view", "board", "container", "buf", "data", "block", "batch", "stack", "writer", "flow", "event", "iframe", "document", "message", "header", "image", "cache", "buff", "result", "transfer"], "status": ["Status", "reason", "session", "level", "score", "uses", "rate", "str", "debug", "comment", "source", "fail", "prefix", "stats", "stage", "speed", "missing", "update", "stat", "service", "line", "s", "used", "e", "skip", "style", "args", "errors", "code", "progress", "size", "index", "msg", "flags", "sync", "wait", "content", "fps", "name", "state", "magic", "received", "err", "full", " Status", "details", "error", "grade", "spec", "gc", "message", "null", "complete", "standard", "result", "settings", "ity", "success", "security"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data,\n\n                        int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    Picture *out;\n\n    int i, out_idx;\n\n    int ret;\n\n\n\n    h->flags  = avctx->flags;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\n    if (buf_size == 0) {\n\n out:\n\n\n\n        h->cur_pic_ptr = NULL;\n\n        h->first_field = 0;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f.key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            out->reference &= ~DELAYED_PIC_REF;\n\n            ret = output_frame(h, pict, &out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n\n        int cnt= buf[5]&0x1f;\n\n        const uint8_t *p= buf+6;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n        cnt = *(p++);\n\n        if(!cnt)\n\n            goto not_extra;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n\n    }\n\nnot_extra:\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n\n    if (buf_index < 0)\n\n        return -1;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        av_assert0(buf_index <= buf_size);\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n\n            return buf_size;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        field_end(h, 0);\n\n\n\n        /* Wait for second field. */\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n            if (CONFIG_MPEGVIDEO) {\n\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n\n                                    &h->low_delay,\n\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(pict->data[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 9781, "substitutes": {"avctx": [" avcas", "afctx", " avpkg", "aircontext", "afcas", "afpkg", "awloc", "awcontext", "abcontext", "avci", "avcu", "airctx", "abctx", "afcu", "avcam", "afci", " avcontext", "avcontext", "awctx", "abcu", "afloc", "avpkg", " avcam", "afcam", " avloc", " avci", "abci", "afcontext", "aircas", " avcu", "avcas", "awcam", "avloc", "airpkg"], "data": ["parent", "sample", "channel", "start", "val", "proc", "media", "window", "da", "capt", "config", "reader", "batch", "package", "feed", "value", "memory", "frame", "empty", "body", "DATA", "next", "f", "code", "dat", "device", "size", "module", "input", "connection", "response", "content", "picture", "Data", "pos", "message", "header", "client", "video", "image", "result", "cache", "buff", "length", "a", "buffer", "database"], "got_frame": ["got__frame", " got_trace", "gotallframes", "got_point", "got__frames", "gone_point", " got_frames", "gotqiframe", "gotqvalue", "gone_iframe", "goneaciframe", "got___iframe", "got___point", "got__trace", " got_line", "gotacpoint", "got_line", "gotallframe", "goneacframe", "goneacpoint", "got_iframe", "gotaciframe", "got___value", "gotqframe", "got__line", "got___frame", "got_frames", "got_trace", "gotallline", "goneacvalue", "gotqpoint", "gone_frame", "got_value", "gotalltrace", "gotacframe", "gotacvalue", "gone_value"], "avpkt": [" avspkt", "avfkk", "evfck", "avpacket", "avfacket", "avprki", " avpct", "awprki", "avPnt", "avfkt", "avPct", "awpki", "avpaacket", "avpft", "avspct", "avspnt", " avspct", "avpkk", "awpft", " avspnt", "avPkt", "avppnt", "avPck", "avPki", "avspkt", "avfck", "avpnt", " avpnt", " avpcht", "avpakt", "avprft", "awprft", "avpct", "avlpkt", "avprkt", "evpck", "avPcht", "evpkt", "avpack", "avpect", "avPkk", "awpkt", "avpki", "evfacket", "avpakk", "avPect", " avspcht", "avlpect", "avppcht", "evpkk", "evpacket", "avPacket", "avprect", "avpck", "awprkt", "avPft", "avppct", "awprect", "avspcht", "avlpft", "avpcht", "evfkk", "awpect", "avlpki", "evfkt", "avppkt"], "buf": ["img", "path", "shift", "block", "fb", "config", "pb", "cb", "frame", "loc", "bt", "v", "uv", "cas", "cur", "port", "bus", "offset", "orig", "text", "buff", "buffer", "fi", "box", "b", "ab", "mem", "capt", "c", "cf", "xff", "bc", "f", "msg", "r", "conv", "header", "comb", "grab", "bag", "seq", "context", "ff", "bp", "src", "brace", "num", "wb", "cp", "usr", "ffff", "rb", "alloc", "Buff", "aux", "rc", "home", "cache", "vec", "cmd", "br", "uc", "uf", "batch", "bu", "queue", "off", "cv", "ctx", "font", "begin", "bin", "proc", "feat"], "h": ["l", "hi", "sh", "he", "ht", "it", "dh", "context", "han", "g", "ph", "hr", "hh", "w", "m", "ich", "http", "b", "t", "d", "c", "adh", "hm", "e", "help", "gh", "eh", "q", "hw", "f", "host", "zh", "o", "ha", "th", "v", "bh", "ih", "home", "ctx", "r", "hy", "hp", "oh", "hs", "kh", "hd", "u", "H", "self", "hl", "handler", "header", "ah", "ch", "cache", "um", "rh", "uh"], "pict": ["dq", "seq", "cam", "img", "conn", "nt", "pl", "path", " pic", "pty", "pid", "stat", " img", "capt", "doc", "ct", "config", "obj", "txt", "gui", "tmp", "xxx", "fat", "photo", "ctx", "pic", "picture", "mat", "mot", "wx", "fig", "init", "fin", "cat", "image", "ch", "buff", "proc", "feat", "fi"], "out": ["parent", "img", "again", "m", "t", "block", "config", "ref", "at", "opt", "v", "err", "init", "image", "flat", "picture", "timeout", "n", "prefix", "w", "trial", "no", "outer", "Out", "b", "plain", "c", "output", "hard", "f", "op", "hidden", "input", "conv", "error", "u", "ext", "g", "conn", "temp", "o", "sync", "new", "part", "OUT", "copy", "cat", "result", "cache", "cmd", "reset", "diff", "dot", "yout", "comment", "in", "doc", "line", "obj", "qa", "off", "next", "lib", "inc", "inner", "user", "option", "bit", "null", "client", "io", "bin", "proc"], "i": ["oi", "l", "hi", "ui", "di", "it", "is", "si", "n", "g", "in", "zi", "m", "xi", "id", "info", "b", "x", "ini", "iv", "t", "d", "my", "c", "ji", "ix", "uri", "e", "yi", "cli", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "module", "v", "gi", "mi", "phi", "ti", "chi", "abi", "qi", "inner", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "api", "ni", "io", "y", "a", "ri", "ori", "lc", "fi", "iu", "ki"], "out_idx": ["out__idxb", "out__midxc", "out_ridx", "out_Idc", "out_idX", "out__midX", "out_indis", "out_ridc", "out_idxb", "out_Idxe", "out_ridz", "out_indz", "out_idv", "out_idxe", "out_indxs", "out_inxs", "out__idx", "out__midx", "out_IDis", "out_idc", "out_inc", "out_idxs", "out_midz", "out_indv", "out_idis", "out_idsxc", "out_midxs", "out_dxs", "out_IDz", "out_ridxs", "out_idxc", "out_idsxb", "out_midX", "out_dx", "out__midxb", "out_indx", "out_inz", "out_midxb", "out_Idxs", "out__idX", "out_Idv", "out_Idx", "out_midxc", "out_IDx", "out_dv", "out__idxc", "out_midis", "out_dxe", "out_Idz", "out_idsX", "out_indxe", "out_idsx", "out_IDxs", "out_idz", "out_inx", "out_midx"], "ret": ["pass", "flag", "ext", "alt", "val", "len", "proc", "def", "nt", "no", "Ret", "id", "num", "mem", "feat", "reply", "ref", "arg", "lit", "obj", "status", "reg", "usr", "gt", "rets", "code", "rt", "res", "det", "opt", "rc", "fun", "att", "bot", "pret", "bit", "xt", "fin", "re", "nz", "RET", "back", "cat", "result", "ft", "match", "rev", "resp", "sr", "mt", "success", "pet"], "p": ["lp", "l", "dp", "sp", "wp", "xp", "n", "g", "proc", "m", "bp", "t", "b", "pid", "pa", "d", "pp", "c", "s", "cp", "pb", "e", "fp", "np", "pe", "at", "po", "q", "P", "f", "padding", "j", "o", "py", "v", "r", "pre", "tp", "jp", "patch", "pi", "part", "pc", "u", "pair", "api", "a", "ps", "ap", "per", "vp"], "cnt": ["count", "ecNT", "cno", "bNT", "lc\n", "ecno", "c\n", " c0", "Cnt", "ecount", "c0", "Cno", "bnn", "Cnn", "ecnt", " count", "C0", "bnt", " c\n", "CNT", " cNT", " cnn", " cno", "lc0", "Count", "cNT", "cnn", "bount", "C\n"]}}
{"project": "qemu", "commit_id": "e853ea1cc68716c3d9c22d04578020c6dd743306", "target": 1, "func": "GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n", "idx": 9787, "substitutes": {"c": ["cr", "l", "channel", "C", "n", "g", "w", "m", "tc", "t", "k", "b", "d", "ct", "s", "p", "cu", "cd", "e", "ec", "f", "ac", "cc", "cs", "ctrl", "ctx", "r", "cl", "dc", "xc", "enc", "u", "self", "h", "ca", "ci", "a", "vc", "ch", "lc", "mc"], "buf": ["bag", "uf", "seq", "Buffer", "len", "ff", "tc", "src", "fd", "b", "que", "num", "pool", "shift", "cp", "block", "fb", "batch", "p", "pb", "cb", "gb", "queue", "cf", "feed", "fp", "rb", "loc", "bc", "f", "alloc", "cv", "cap", "rc", "bh", "cas", "ctx", "cur", "offset", "col", "vec", "buff", "br", "buffer", "uc"], "size": ["timeout", "scale", "start", "si", "g", "len", "capacity", "source", "handle", "n", "speed", "small", "z", "SIZE", "num", "export", "shift", "sum", "max", "limit", "e", "status", "args", "loc", "empty", "Size", "large", "sec", "code", "shape", "sync", "name", "content", "address", "offset", "bytes", "cm", "complete", "esc", "length", "use", "cache", "ize", "success", "fee"], "count": ["parent", "cond", "base", "flag", "start", "len", "val", "all", "id", "temp", "low", "b", "small", "num", "i", "last", "sum", "limit", "max", "feed", "loc", "empty", "f", "code", "call", "child", "found", "index", "name", "current", "content", "new", "check", "offset", "col", "cat", "allow", "type", "length", "Count", "cache", "weight", "depth"]}}
{"project": "FFmpeg", "commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "target": 1, "func": "static int channelmap_query_formats(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n\n\n    ff_set_common_formats(ctx, ff_planar_sample_fmts());\n\n    ff_set_common_samplerates(ctx, ff_all_samplerates());\n\n    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);\n\n    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);\n\n\n\n    return 0;\n\n}\n", "idx": 9789, "substitutes": {"ctx": ["mac", "cam", "std", "context", "cmp", "Context", "cca", "conn", "tc", "k", "sci", "fw", "c", "cp", "ct", "config", "p", "cu", "cb", "cli", "qs", "qa", "cf", "cn", "wcs", "kk", "sq", "loc", "hw", "bc", "cc", "sk", "cs", "ctrl", "cus", "acs", "cv", "ck", "rc", "cas", "conv", "tx", "kt", "jp", "cl", "pc", "kw", "cpp", "cms", "nc", "gc", "cm", "ca", "grad", "client", "ci", "vc", "anc", "lc", "cmd", "pkg", "mc", "kb", "sc", "fc"], "s": ["utils", "sg", "ks", "sv", "ds", "n", "si", "w", "b", "ops", "i", "gs", "sa", "c", "service", "p", "ls", "qs", "e", "args", "js", "sq", "f", "os", "cs", "o", "acs", "sets", "S", "es", "sync", "sl", "services", "ans", "sb", "storage", "params", "ses", "fs", "ps", "ss", "settings", "ssl", "sc"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9805, "substitutes": {"env": ["vs", "ani", "conf", "qt", "context", "dict", "stage", "conn", "que", "ini", "net", "viron", "export", "ne", "environment", "wk", "config", "server", "output", "enable", "e", "vm", "erv", "queue", "global", "esi", "style", "ec", "args", "ass", "eni", "network", "next", "manager", "code", "ev", "db", "dat", "console", "exc", "ea", "zone", "cv", "state", "en", "eng", "ench", "Environment", "enc", "eva", "init", "nc", "wordpress", "dev", "her", "cache", "eu", "icer", "core", "exec"], "wi": ["wid", "Wi", "wl", "wiki", "hi", "ee", "ui", "di", "wp", "WI", "si", "wa", "worker", "rw", "w", "bp", "iw", "wig", "ye", "iri", "ini", "wb", "wt", "wine", "fw", "sci", "data", "wk", "yi", "mu", "wm", "cli", "nw", "wal", "eni", "wo", "hei", "iki", "wic", "wei", "gi", "mi", "ti", "wife", "qi", "ei", "bi", "ii", "wx", "wan", "kw", "wu", "widget", "wit", "ci", "ni", "ski", "fi", "ki", "fee"]}}
{"project": "qemu", "commit_id": "477830727821e4bc337f4ac1fd222ffe0b900e1a", "target": 0, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret < 0) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    socket_set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, s);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n", "idx": 9817, "substitutes": {"s": ["l", "session", "is", "m", "http", "t", "sci", "gs", "state", "full", "ns", "details", "spec", "self", "settings", "sg", "ds", "si", "your", "n", "b", "i", "c", "e", "se", "sq", "us", "f", "sym", "sets", "scope", "es", "r", "storage", "sis", "this", "sim", "fs", "su", "ps", "ss", "g", "stats", "d", "sa", "ls", "socket", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "secondary", "ssl", "conf", "sports", "ts", "service", "server", "p", "qs", "xs", "js", "aws", "S", "sie", "states", "services", "submit", "ses", "uns"], "aio_req": ["aio_desc", "aietMtar", "aietMrequ", "aio2req", "ao_grab", "aioMrequ", "ao_ref", "aio_call", "aios_crit", "aiet_tar", "aiet_req", "aio_request", "ao_req", "aios_ref", "aio_comp", "aioMreq", "aios_rx", "ao_request", "aio0request", "aio0ref", "aio0rx", "aio2err", "aios_def", "aios_request", "aiofrequest", "aioMcall", "aio_requ", "aiofcrit", "aios_rec", "aios_comp", "aietMreq", "aiet_requ", "aio_ref", "aiofreq", "aios_req", "aio_tar", "aiofdesc", "aio2rs", "aio_def", "aios_ver", "aio_rs", "aio_rec", "aietMcall", "aio_err", "aio_crit", "aio_rx", "aios_desc", "aio0req", "aiet_call", "aio2request", "aio_ver", "aio_grab", "aioMtar"], "iov": ["ou", "uu", "iii", "unc", "uno", "iop", "iv", "ir", "oci", " ov", "mx", "ih", "cons", "ilo", "ii", "icon", "uo", "ico", "rio", "io", "eu", "rob", "ocr", "um", "roc", "om", "uh", "igi"], "niov": ["ciove", "niovo", " niot", " niove", "ciov", " niovo", "ciovo", "eiove", "eiovo", "niot", "ciot", "eiot", "eiov", "niove"], "create": ["construct", "Create", "initial", "save", "raise", "open", "update", "clear", "delete", "enable", "destroy", "add", "drop", "clone", "make", "none", "primary", "code", "execute", "wait", "name", "creator", "future", "native", "new", "unique", "check", "when", "copy", "init", "type", "change", "created", "creation", "message", "build", "complete", "present", "insert", "use", "write", "replace", "fee"], "aiocb_type": ["aiocsb_type", "aiocsb_code", "aiocb_state", "aiocsb_Type", "aiocb__style", "aiocb_name", "aiocb__Type", "aiocb_style", "aiocb_code", "aiocb__type", "aiocb__state", "aiocb__code", "aiocsb_name", "aiocb_Type", "aiocb__name", "aiocsb_style", "aiocsb_state"], "hdr": ["htr", " hr", "hrec", "HDR", "hsr", "hahr", "hdi", "phstr", "hastr", "pharr", "harr", "ohDR", " Hrr", " hrc", "thrid", "shdr", " hDR", " harr", "phDR", "ghhr", "hrid", "thld", "rhDR", "shstr", " hrec", "chhr", "ehdr", "thdr", "Hrec", "thhr", "ehdi", "herid", "thver", "ehDr", "hDR", "phsr", "rhsr", "rhrec", "phdr", "phr", "shld", "shver", "herr", "hstr", "ghtr", "handdr", " hrr", "shrc", "khvar", "hrr", "bhrc", " hrid", "ghdr", "hivar", "hDr", "histdr", "shrr", " Hdr", "shsr", "ahdr", " htr", "hrc", "hver", "hlver", "hr", "hidr", " hDr", "histDr", "hirc", "rhtr", "hvar", "hedr", "hlDR", "ehrid", "phrc", "hatr", "chrid", "ahtr", "ghstr", "Hrs", "chdr", "hlld", "Htr", " hhr", "rhrc", "hadr", "hirid", "histrid", "hld", "shDR", " hrs", " hdi", "ahstr", "rhr", "bhdr", "rhhr", "ghrec", "phdi", " hstr", " hvar", "eharr", "khrid", "rhrs", "bhstr", "rhdr", " hsr", "ohrec", "shtr", "khdr", " Htr", "hldr", "hhr", "hrs", "ahhr", "handrid", "bhDR", "khrc", "Hdr", "thDR", "handrr", "ohdr"], "wlen": ["winlon", "wwLen", "wordlength", "ewlim", "wlim", "walength", "wwln", "ewlon", "kwen", "wln", "wlf", "wdl", "xlen", " wlength", "xlim", "ewoln", "wen", "rwln", "worddl", "wadl", "ewdl", "rwLen", "kwlength", "Wlength", "wwlen", "winlim", "ewlength", " wlf", "ewlf", "winlen", "wwlength", "ewen", "ewlen", "wLen", "kwlf", "walen", "waoln", "winlength", "Wln", "xlength", "wlon", "wordoln", "woln", "rwlen", "wordlen", "xlon", "rwlength", "Wlen", "WLen", "kwlen", " wen", "wlength"], "ret": ["rows", "val", " clen", "def", " success", "nt", "all", "Ret", "fields", "ops", "used", " result", "bits", "off", "rets", " unused", "Flags", "fun", " bits", " Flags", "bit", "RET", "options", "result", "success"]}}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_write_packet(AVFormatContext *s, int stream_index,\n\n                            UINT8 *buf, int size)\n\n{\n\n    VideoData *img = s->priv_data;\n\n    AVStream *st = s->streams[stream_index];\n\n    ByteIOContext pb1, *pb;\n\n    AVPicture picture;\n\n    int width, height, ret, size1;\n\n    char filename[1024];\n\n\n\n    width = st->codec.width;\n\n    height = st->codec.height;\n\n\n\n    switch(st->codec.pix_fmt) {\n\n    case PIX_FMT_YUV420P:\n\n        size1 = (width * height * 3) / 2;\n\n        if (size != size1)\n\n            return -EIO;\n\n        \n\n        picture.data[0] = buf;\n\n        picture.data[1] = picture.data[0] + width * height;\n\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n\n        picture.linesize[0] = width;\n\n        picture.linesize[1] = width >> 1; \n\n        picture.linesize[2] = width >> 1;\n\n        break;\n\n    case PIX_FMT_RGB24:\n\n        size1 = (width * height * 3);\n\n        if (size != size1)\n\n            return -EIO;\n\n        picture.data[0] = buf;\n\n        picture.linesize[0] = width * 3;\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (get_frame_filename(filename, sizeof(filename), \n\n                           img->path, img->img_number) < 0)\n\n        return -EIO;\n\n\n\n    if (!img->is_pipe) {\n\n        pb = &pb1;\n\n        if (url_fopen(pb, filename, URL_WRONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        pb = &s->pb;\n\n    }\n\n    switch(img->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_save(&picture, width, height, pb, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_save(&picture, width, height, pb, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_save(&picture, width, height, filename);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_save(&picture, width, height, pb);\n\n        break;\n\n    }\n\n    if (!img->is_pipe) {\n\n        url_fclose(pb);\n\n    }\n\n\n\n    img->img_number++;\n\n    return 0;\n\n}\n", "idx": 9842, "substitutes": {"s": ["session", "sg", "ts", "sv", "ds", "si", "g", "sf", "m", "src", "http", "t", "b", "sci", "gs", "service", "c", "serv", "sam", "p", "ls", "sa", "se", "xs", "sq", "f", "op", "cs", "sym", "v", "S", "space", "sie", "sl", "services", "r", "ns", "sb", "storage", "spec", "summary", "self", "api", "ses", "fs", "su", "ps", "a", "ss", "sr", "ssl", "sc"], "stream_index": ["stream_design", "feed_pointer", "streamsindex", "stream_pointer", "stream_Index", " stream_design", "stream_num", "feed_index", "streamernum", "streamsdesign", "streamsIndex", "stream__Index", "feed_Index", "feed_num", "streamerIndex", "streamerpointer", "stream__index", "streamerindex", "stream__pointer", " stream_Index", "stream__num"], "buf": ["uf", "seq", "Buffer", "prefix", "pad", "src", "fd", "b", "wb", "mem", "data", "fb", "batch", "config", "dest", "cb", "fp", "queue", "rb", "loc", "tmp", "bc", "padding", "foo", "pkg", "alloc", "cv", "msg", "rc", "home", "ctx", "desc", "border", "func", "vec", "buff", "cmd", "text", "feat", "bin", "buffer", "box", "uc"], "size": ["count", "area", "scale", "si", "len", "g", "capacity", "source", "speed", "small", "z", "SIZE", "data", "style", "loc", "Size", "sec", "large", "body", "code", "unit", "shape", "cap", "name", "rc", "content", "align", "sn", "desc", "storage", "offset", "enc", "crop", "video", "length", " sizes", "image", "ize", "weight", "buffer"], "img": ["ani", "imag", "movie", "gd", "html", "gif", "ext", "upload", "dom", "media", "info", "src", "iv", "fi", "i", "data", "big", "fb", "config", "p", "obj", "cb", "gb", "plug", "tmp", "f", "ie", "inst", "bl", "bg", "amp", "og", "embed", "input", "rc", "iframe", "jpg", "pic", "im", "audio", "eng", "fig", "icon", "enc", "emb", "cm", "aug", "ng", "url", "image", "pict", "br", "imp"], "st": ["stan", "sp", "sh", "gd", "std", "ds", "str", "si", "stage", "nt", "fr", "src", "rest", "stat", "d", "steam", "sa", "ct", "sam", "obj", "se", "ost", "pt", "ut", "inst", "rt", "cv", "nd", "sts", "sta", "sl", "sm", "sn", "sth", "ste", "sb", "sty", "storage", "sd", "ast", "St", "sim", "ST", "ft", "ss", "td", "fe", "sc"], "pb1": ["refone", "ref4", "p2", "bufone", "PB1", "buf2", "buf4", "db4", "PB4", "buf1", "ref1", "PB3", "db2", "db1", "db3", "ref2", "p1", "PBone", "p3", "pb2", "pbone", "pb3", "PB2", "p4", "pb4"], "pb": ["lp", "dp", "uf", "ib", "bb", "ppa", "pg", "nb", "wp", "bp", "lab", "pl", "prot", "bm", "b", "ab", "bs", "pa", "pp", "wb", "bridge", "cp", "python", "fb", "p", "obj", "cb", "fp", "np", "gb", "pt", "pm", "rb", "cod", "tmp", "bc", "dl", "profile", "bf", "mp", "db", "eb", "bl", "cv", "bps", "bh", "phrase", "pr", "ctx", "lb", "bot", "jp", "sb", "pc", "PB", "avi", "summary", "plugin", "platform", "api", "fc", "ob", "rob", "pkg", "typ", "vp"], "picture": ["media", "imgur", "history", "fb", "config", "uri", "cb", "package", "pixel", "profile", "pic", "study", "widget", "import", "image", "definition", "buffer", "fi", "phot", "wikipedia", "ami", "gui", "large", "slice", "bi", "avi", "storage", "error", "fine", "plugin", "li", "file", "lc", "pict", "bank", "family", "statement", "password", "game", "piece", "photos", "gallery", "data", "cli", "fp", "brush", "mini", "style", "ana", "entry", "query", "feature", "jp", "movie", "imi", "kl", "man", "library", "character", "detail", "gif", "comment", "info", "money", "service", "username", "obj", "manager", "guide", "Picture", "photo", "fat", "ctx", "audio", "summary", "api", "video", "io", "feat", "database"], "height": ["center", "pad", "gpu", "history", "max", "dist", "grow", "lat", "high", "device", "stroke", "duration", "crop", "volume", "image", "three", "definition", "buffer", "depth", "windows", "rank", "dim", "upload", "view", "w", "id", "total", "resolution", "paste", "density", "layout", "padding", "slice", "input", "wall", "ty", "margin", "above", "huge", "gap", "location", "std", "bottom", "data", "gain", "head", "style", "flow", "Height", "png", "shape", "shr", "dark", "kw", "tight", "command", "weight", "through", "level", "rows", "window", "third", "time", "gold", "quality", "gh", "square", "hold", "deep", "ctx", "pull", "h", "length", "arrow", "y", "feat", "direction"], "ret": ["count", "pass", "std", "flag", "str", "ext", "len", "val", "alt", "def", "temp", "nt", "id", "Ret", "mem", "reply", "rl", "ref", "arg", "lit", "output", "status", "split", "final", "gt", "rets", "ut", "rt", "res", "det", "rc", "content", "att", "full", "part", "bit", "re", "cat", "RET", "back", "url", "result", "bin", "ft", "flat", "feat", "match", "let", "pet"], "size1": [" sizeOne", "shapeOne", " size3", "width4", "size3", "size01", "size2", " sizeone", "width1", "Size2", "SIZE4", "widthone", "sizeOne", "Size1", "size4", "iz1", "Sizeone", "shape2", "SIZEone", " size0", " size2", "size0", "any3", "any1", "widthPre", "shape0", "sizeone", " size4", "SIZE1", "ize0", "Size0", "ize1", "iz2", "izPre", " sizePre", "shape3", "width2", "sizePre", "shapeone", "shape1", " size01", "anyOne", "width01", "iz01"], "filename": ["l", "fil", "seq", "byte", "original", "location", "wp", "il", "n", "tif", "prefix", "word", "src", "fd", "files", "b", "path", "login", "data", "fb", "config", "uri", "username", "p", "utf", "fp", "txt", "loc", "Filename", "title", "f", "nm", "binary", "png", "slice", "shape", "nil", "name", "content", "phrase", "jpg", "document", "dll", "bytes", "root", "fn", "file", "out", "image", "length", "url", "directory", "family", "buffer", "ssl", "kl"], "img_number": ["img_header", "imgnumindex", "imgblocknum", "img_index", "image_num", "imgblockheader", "image_index", "img_num", "imgnumnum", "imgblocknumber", "image_header", "imgblockindex", "imgnumheader", "image_number", "imgnumnumber"]}}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n", "idx": 9845, "substitutes": {"mon": ["mont", "man", "channel", "emon", "Monitor", "mos", "meter", "own", "MON", "mor", "my", "mm", "pid", "chron", "con", "monitor", "don", "mu", "amon", "mic", "mand", "mid", "sym", "mons", "module", "mc", "master", "Mon", "min", "atom", "kin", "mut", "mot", "mun", "mo", " monitor", "ann", "bin", "mag", "pin"], "qdict": ["eqdot", "qdot", "eqdef", "Qdict", " qdef", " qdot", "Qdot", "Qdef", "eqdict", "qdef"], "dinfo": ["bdInfo", " dfo", "rdinfo", "Dinfo", "bdinfo", "bdinf", "Dfo", "DInfo", "rdfo", " dentry", " dInfo", " dinf", "dinf", "bdentry", "dfo", "Dinf", "Dentry", "rdinf", "dentry", "dInfo"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {\n\n  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;\n\n  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );\n\n  uint8_t *ysrc = src[0];\n\n  uint8_t *usrc = src[1];\n\n  uint8_t *vsrc = src[2];\n\n  const int width = c->srcW;\n\n  const int height = srcSliceH;\n\n  const int lumStride = srcStride[0];\n\n  const int chromStride = srcStride[1];\n\n  const int dstStride = dstStride_a[0];\n\n  const vector unsigned char yperm = vec_lvsl(0, ysrc);\n\n  const int vertLumPerChroma = 2;\n\n  register unsigned int y;\n\n\n\n  if(width&15){\n\n    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);\n\n    return srcSliceH;\n\n  }\n\n\n\n  /* this code assume:\n\n\n\n  1) dst is 16 bytes-aligned\n\n  2) dstStride is a multiple of 16\n\n  3) width is a multiple of 16\n\n  4) lum&chrom stride are multiple of 8\n\n  */\n\n\n\n  for(y=0; y<height; y++)\n\n    {\n\n      int i;\n\n      for (i = 0; i < width - 31; i+= 32) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_yA = vec_ld(i, ysrc);\n\n\tvector unsigned char v_yB = vec_ld(i + 16, ysrc);\n\n\tvector unsigned char v_yC = vec_ld(i + 32, ysrc);\n\n\tvector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);\n\n\tvector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);\n\n\tvector unsigned char v_uA = vec_ld(j, usrc);\n\n\tvector unsigned char v_uB = vec_ld(j + 16, usrc);\n\n\tvector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));\n\n\tvector unsigned char v_vA = vec_ld(j, vsrc);\n\n\tvector unsigned char v_vB = vec_ld(j + 16, vsrc);\n\n\tvector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_uv_b = vec_mergel(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);\n\n\tvector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n\tvec_st(v_yuy2_2, (i << 1) + 32, dst);\n\n\tvec_st(v_yuy2_3, (i << 1) + 48, dst);\n\n      }\n\n      if (i < width) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_y1 = vec_ld(i, ysrc);\n\n\tvector unsigned char v_u = vec_ld(j, usrc);\n\n\tvector unsigned char v_v = vec_ld(j, vsrc);\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n      }\n\n      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t{\n\n\t  usrc += chromStride;\n\n\t  vsrc += chromStride;\n\n\t}\n\n      ysrc += lumStride;\n\n      dst += dstStride;\n\n    }\n\n\n\n  return srcSliceH;\n\n}\n", "idx": 9846, "substitutes": {"c": ["cit", "cr", "l", "oc", "C", "n", "g", "w", "m", "conn", "b", "t", "k", "d", "con", "cp", "ct", "s", "p", "e", "cd", "cu", "cf", "cn", "f", "cc", "ac", "cs", "ctrl", "ce", "ctx", "dc", "xc", "nc", "cm", "ca", "ci", "vc", "lc", "ch", "mc", "cy", "sc"], "src": ["chrom", "source", "sel", "scene", "http", "sur", "filename", "iv", "rect", "buf", "config", "rib", "dest", "attr", "split", "stab", "rss", "rb", "loc", "sq", "st", "inst", "sub", "cv", "rc", "input", "sl", "sup", "req", "ctx", "cur", "conv", "sn", "support", "sb", "scl", "usc", "impl", "url", "sit", "rob", "sr", "sc", "uc", "ssl", "secure"], "srcStride": ["srcRestro", "srcstri", "sourceStrip", "sourceRestride", "srcCurride", "srcShride", " srcStOverride", "srcstride", "srcStrid", "sourceStide", "srcShrip", "srcRestride", "sourceRestide", "srcStOverride", "srcStri", "srcRestOverride", "srcRestri", "srcShOverride", "srcRestrid", "sourceStride", "srcStyride", " srcStide", "sourceRestrip", " srcRestide", "sourceStrid", " srcstri", "srcStyrip", "srcCurrip", "srcRestrip", "srcShide", "srcScrip", " srcRestrip", "srcRestide", "srcScri", "srcStrip", "srcStyOverride", " srcStri", "srcstro", "sourceRestrid", "srcScro", " srcstro", "srcCuride", " srcStro", " srcStrip", "srcStro", " srcRestride", " srcstrip", " srcRestOverride", " srcstride", "srcScride", "srcStyide", "srcstrip", "srcCurrid", "srcStide"], "srcSliceY": ["srcPliceW", "srcSlaceW", "srcPliceX", "srcPlaceH", "srcSlaceH", "srcSlICEB", "srcPlICEY", "srcSlaceY", "srcSlICEX", "srcPlICEW", "srcSlICEW", "srcSliceB", "srcSlueB", "srcSliceX", "srcSlueY", "srcSlICEH", "srcPlaceW", "srcSlineY", "srcSlineH", "srcSlueW", "srcPlICEH", "srcSlineW", "srcSlaceB", "srcPlICEB", "srcSlueH", "srcSlaceX", "srcSlineX", "srcPlaceX", "srcSlICEY", "srcSliceW", "srcPlaceY", "srcPliceB", "srcPliceH", "srcPliceY"], "srcSliceH": ["srcSlaceh", "srcPliceW", "srcSlaceW", "srcPlaceh", "srcPliceX", "srcSliceN", "srcPlaceH", "srcSlaceH", "srcSlaseW", "srcSlaseY", "srcSlaseN", "srcSlaceY", "srcSlICEX", "srcPlICEW", "srcSlICEW", "srcSliceX", "srcSlaceN", "srcSlenseH", "srcPlaceW", "srcSlICEH", "srcSlaseH", "srcSlineY", "srcSliceh", "srcPlICEh", "srcSlineH", "srcSlueW", "srcPlICEH", "srcSlineW", "srcSlueN", "srcSlICEN", "srcSlueH", "srcSlenseW", "srcSlaceX", "srcSlineX", "srcPlaceX", "srcSlICEY", "srcPlICEN", "srcSliceW", "srcPlaceY", "srcPliceh", "srcPliceH", "srcPliceY", "srcSlueh", "srcSlenseh", "srcSlICEh", "srcPliceN", "srcSlenseY"], "dstParam": ["dscPar", "dscParam", "dscMode", "destPar", "DstPar", "dstMode", "DstParam", "dscParameter", "dstPar", "dspParam", "dspParameter", "inblParameter", "destParam", "inblMode", "dblMode", "DscPar", "dspPar", "instMode", "DscParam", "DstParameter", "instParam", "instPar", "destParameter", "dblParameter", "DstMode", "DscParameter", "destMode", "dblParam", "DscMode", "dspMode", "dblPar", "dstParameter", "inblPar", "inblParam", "instParameter"], "dstStride_a": ["dstStri_e", "dstStri_a", "dstStride4p", "dstStrite2A", "dstStride2a", "dstStri_m", "dstStrite_c", "dstStriteJp", "dstStride_p", "dstStrite_o", "dstStride_e", "dstStriteJc", "dstStride4o", "dstStride_A", "dstStrideJa", "dstStriteJe", "dstStrideJp", "dstStriteJa", "dstStrite_a", "dstStride2p", "dstStrite2p", "dstStride2o", "dstStride2A", "dstStrideJe", "dstStrite2o", "dstStrite_p", "dstStride_m", "dstStrite_A", "dstStrite_e", "dstStrideJc", "dstStride_c", "dstStride4a", "dstStrite2a", "dstStride_o", "dstStride4A"], "dst": ["DST", "dsrc", " dsc", "lsrc", "adST", "lsc", "Dsc", "dsc", " dcr", "Dsrc", " dsrc", " dST", "Dst", "dcr", "lcr", "lst", "dST", "adcr", "adsrc", "adst", "adsc"], "ysrc": ["syssrc", "sysrc", "rysrc", "dsroc", "ryssrc", "dsrc", "ynource", "gesource", "ynsrc", "source", "lsrc", "lsource", "iessrc", "pspc", "ieslc", "sRC", "lssrc", "ysrec", "geslc", "rsroc", "iesconfig", "sysroc", "ysroc", "dsrec", "sysconfig", "sysRC", "rsrc", "yspc", "gesrc", "ryslc", "dslc", "ynconfig", "rssrc", "anssrc", "iesrc", "lsRC", "iesource", "gessrc", "ysRC", "iesusc", "dsRC", "ysusc", "ansrc", "dssrc", "dsusc", "yslc", "ssrc", "rysusc", "ynrc", "yssrc", "ysource", "ysconfig", "anspc", "ansrec", "dsource", "dspc", "sysource", "psrc", "psrec", "pssrc", "rsRC"], "usrc": ["ussrc", "usrb", "unsrb", "mssrc", "srt", " ussrc", "slc", "asource", "sfc", "source", "srb", "ssdc", "msloc", "unslc", "sRC", "asrc", "ssr", "unsrc", "assrc", "ssRC", "rusrc", "uslc", "usr", " usr", "usource", "sssrc", "msrc", "USrc", " usdc", "USrb", "sloc", "USrt", "ssource", "ssrc", "usrt", "rusr", " usloc", "unsrt", "USlc", "msfc", "asRC", "russrc", "usfc", "rusdc", " usfc", "usloc", "usdc", "usRC"], "vsrc": [" vconst", "dsrc", "vrc", "svsrc", "svsource", "lsrc", "hconst", "ldest", "drc", "lconst", "lloc", "svrc", "vconst", "hloc", " vdest", "sdest", "vloc", "hsrc", "ddest", "hdest", "ssource", "ssrc", "svdest", "vdest", " vloc", "dsource", "vsource"], "y": ["ym", "ady", "yt", "oy", "n", "ry", "asy", "ny", "w", "m", "t", "x", "ey", "vy", "ye", "z", " Y", "b", "p", "iy", "yi", "ay", "zy", "yy", "sy", "gy", "j", "o", "py", "sky", "ky", "yd", "hy", "Y", "ty", " cy", "ies", "yr", "type", "dy", "h", "year", "ya", "cy", "yo"], "i": ["ani", "vi", "l", "ui", "di", "it", "start", "si", "n", "in", "zi", "m", "xi", "id", "iw", "k", "x", "b", "ini", "z", "ami", "uli", "ji", "p", "ix", "uri", "e", "yi", "mini", "ia", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "phi", "ti", "ik", "qi", "bi", "pi", "ii", "init", "u", "h", "I", "li", "ip", "ci", "ni", "io", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "338c858c946017cd3ec8c2be06d817e001d94bc3", "target": 0, "func": "void cpu_loop(CPUAlphaState *env)\n\n{\n\n    CPUState *cs = CPU(alpha_env_get_cpu(env));\n\n    int trapnr;\n\n    target_siginfo_t info;\n\n    abi_long sysret;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_alpha_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        /* All of the traps imply a transition through PALcode, which\n\n           implies an REI instruction has been executed.  Which means\n\n           that the intr_flag should be cleared.  */\n\n        env->intr_flag = 0;\n\n\n\n        switch (trapnr) {\n\n        case EXCP_RESET:\n\n            fprintf(stderr, \"Reset requested. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MCHK:\n\n            fprintf(stderr, \"Machine check exception. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_SMP_INTERRUPT:\n\n        case EXCP_CLK_INTERRUPT:\n\n        case EXCP_DEV_INTERRUPT:\n\n            fprintf(stderr, \"External interrupt. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MMFAULT:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID\n\n                            ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR);\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_UNALIGN:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGBUS;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_BUS_ADRALN;\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_OPCDEC:\n\n        do_sigill:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_ILLOPC;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_ARITH:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGFPE;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_FPE_FLTINV;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_FEN:\n\n            /* No-op.  Linux simply re-enables the FPU.  */\n\n            break;\n\n        case EXCP_CALL_PAL:\n\n            env->lock_addr = -1;\n\n            switch (env->error_code) {\n\n            case 0x80:\n\n                /* BPT */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x81:\n\n                /* BUGCHK */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x83:\n\n                /* CALLSYS */\n\n                trapnr = env->ir[IR_V0];\n\n                sysret = do_syscall(env, trapnr,\n\n                                    env->ir[IR_A0], env->ir[IR_A1],\n\n                                    env->ir[IR_A2], env->ir[IR_A3],\n\n                                    env->ir[IR_A4], env->ir[IR_A5],\n\n                                    0, 0);\n\n                if (trapnr == TARGET_NR_sigreturn\n\n                    || trapnr == TARGET_NR_rt_sigreturn) {\n\n                    break;\n\n                }\n\n                /* Syscall writes 0 to V0 to bypass error check, similar\n\n                   to how this is handled internal to Linux kernel.\n\n                   (Ab)use trapnr temporarily as boolean indicating error.  */\n\n                trapnr = (env->ir[IR_V0] != 0 && sysret < 0);\n\n                env->ir[IR_V0] = (trapnr ? -sysret : sysret);\n\n                env->ir[IR_A3] = trapnr;\n\n                break;\n\n            case 0x86:\n\n                /* IMB */\n\n                /* ??? We can probably elide the code using page_unprotect\n\n                   that is checking for self-modifying code.  Instead we\n\n                   could simply call tb_flush here.  Until we work out the\n\n                   changes required to turn off the extra write protection,\n\n                   this can be a no-op.  */\n\n                break;\n\n            case 0x9E:\n\n                /* RDUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0x9F:\n\n                /* WRUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0xAA:\n\n                /* GENTRAP */\n\n                info.si_signo = TARGET_SIGFPE;\n\n                switch (env->ir[IR_A0]) {\n\n                case TARGET_GEN_INTOVF:\n\n                    info.si_code = TARGET_FPE_INTOVF;\n\n                    break;\n\n                case TARGET_GEN_INTDIV:\n\n                    info.si_code = TARGET_FPE_INTDIV;\n\n                    break;\n\n                case TARGET_GEN_FLTOVF:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case TARGET_GEN_FLTUND:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case TARGET_GEN_FLTINV:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case TARGET_GEN_FLTINE:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case TARGET_GEN_ROPRAND:\n\n                    info.si_code = 0;\n\n                    break;\n\n                default:\n\n                    info.si_signo = TARGET_SIGTRAP;\n\n                    info.si_code = 0;\n\n                    break;\n\n                }\n\n                info.si_errno = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            default:\n\n                goto do_sigill;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (info.si_signo) {\n\n                env->lock_addr = -1;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_STL_C:\n\n        case EXCP_STQ_C:\n\n            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 9864, "substitutes": {"env": ["img", "org", "net", "environment", "config", "ace", "cb", "np", "esi", "ec", "v", "ce", "end", "init", "nc", "her", "settings", "que", "iss", "output", "e", "cf", "args", "gui", "db", "ev", "inv", "forge", "py", "energy", "exe", "loader", "en", "eng", "extra", "site", "fg", "context", "ext", "fen", "conn", "viron", "eni", "entry", "keeper", "dat", "exc", "oa", "here", "icon", "enc", "et", "cache", "engine", "eu", "core", "eve", "vs", "conf", "cookie", "inet", "qt", "dict", "ini", "server", "obj", "erv", "manager", "console", "ea", "cv", "event", "cfg", "api", "inf"], "cs": ["vs", "ks", "ds", "conn", "gs", "c", "cp", "ys", "ls", "qs", "ins", "cf", "cn", "args", "ec", "rs", "js", "cc", "bc", "sk", "ac", "acs", "ck", "ras", "rc", "sync", "CS", "cas", "ctx", "ns", "pc", "dc", "ces", "spec", "nc", "sys", "ced", "ci", "fs", "css", "lc", "bs", "core", "cus", "cks", "sc", "Cs"], "trapnr": [" traprf", " trapnw", "trapnos", "trapNR", " trapradius", "impnl", " trapNR", "traprf", "tapNR", "rapNR", "rrnl", "trapradius", "tapradius", "rrnw", " trapnl", "tripNR", "trapnw", " trapnos", "triprf", "impnr", "rapnw", "rapnr", "tapnos", "tapnr", "taprf", "impNR", "tripnos", "rapnl", "rrnr", "rrNR", "trapnl", "impradius", "tapnl", "tripnr"], "info": ["utils", "is", "show", "where", "http", "fw", "notice", "config", "txt", "afi", "thin", "frame", "opt", "state", "end", "how", "ii", "now", "init", "link", "type", "image", "help", "fi", "alias", "si", "Info", "iso", "id", "ami", "i", "information", "app", "args", "f", "op", "tf", "index", "py", "hand", "error", "fs", "extra", "join", "hi", "source", "def", "conn", "data", "util", "entry", "gi", "home", "new", "result", "success", "ok", "diff", "conf", "ui", "follow", "fo", "start", "comment", "die", "update", "service", "INFO", "obj", "off", "bug", "manager", "event", "inner", "check", "api", "ignore", "inf"], "sysret": ["systemRet", "_result", "Sysresult", "_Ret", "sysresult", "sysRet", "systemresult", "_ret", "systemexit", "Sysexit", "Sysret", "sysexit", "_exit", "SysRet", "systemret"]}}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (!target) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(pbdev->target, target)) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 9870, "substitutes": {"target": ["parent", "boot", "timeout", "compatible", "domain", "base", "goal", "it", "source", "prefix", "owner", "window", "nt", "method", "to", "id", "tag", "path", "t", "Target", "template", "project", "component", "value", "brand", "blank", "host", "unit", "resource", "expected", "device", "version", "route", "module", "scope", "format", "name", "current", "remote", "content", "object", "address", "token", "port", "support", "patch", "offset", "arget", "required", "root", "type", "platform", "tail", "client", "transform", "ip", "peer", "match", "weight", "flat", "core", "direction", "range"], "i": ["oi", "l", "hi", "ui", "di", "si", "n", "in", "zi", "key", "id", "m", "info", "xi", "t", "x", "k", "ini", "z", "b", "d", "c", "p", "ix", "uri", "e", "mu", "yi", "eni", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "phi", "inner", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "ori", "ni", "io", "lc", "y", "ri", "iu"], "pbdev": ["pbconf", "bpadv", "bbev", "lpDev", "wbdata", "bbadv", "wbdevice", "wbdev", "pbDev", "bbDev", "bhdevice", "bpapp", "ppdiv", "bpconf", "bpdevice", "pbdevice", "bdiv", "mpapp", "lpdev", "pcdef", "bdev", "pcdevice", "pbdi", "cbver", "lpev", "lpadv", "lpdiv", "mpdevice", "pdev", "pconf", "bhdiff", "bpdiff", "lpdi", "bver", "pcdev", "pbdef", "pbadv", "bhpriv", "bpver", "rbdef", "rbdevice", "lbdata", "bbdev", "pbver", "bpdef", "bpdev", "rbdev", "cbapp", "pcconf", "lpdiff", "pbapp", "bdi", "bpDev", "lbdev", "cbdevice", "lppriv", "bpev", "ppver", "cbdev", "pbev", "pbdiv", "pbdata", "lpdevice", "rbdata", "bppriv", "pbpriv", "pdef", "lbdef", "wbdef", "pdevice", "bhdev", "ppdev", "mpver", "lpver", "pbdiff", "ppdi", "mpdev", "lbdevice"], "s": ["is", "si", "g", "ds", "w", "stats", "m", "b", "t", "d", "gs", "sa", "c", "p", "ls", "e", "ins", "rs", "sq", "f", "o", "S", "v", "south", "states", "sl", "services", "ns", "sis", "spec", "u", "sys", "ps", "ses", "a", "ss", "ssl"]}}
{"project": "FFmpeg", "commit_id": "c95fefa0420be9cc0f09a95041acf11114aaacd0", "target": 0, "func": "static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n\n{\n\n    uint16_t cmd;\n\n    int i, sz, offset, code;\n\n    unsigned char *dst_end = dst + dst_size;\n\n    const unsigned char *src_end = src + src_size;\n\n\n\n    while (src < src_end && dst < dst_end) {\n\n        code = *src++;\n\n        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {\n\n            if (code & (1 << i)) {\n\n                *dst++ = *src++;\n\n            } else {\n\n                cmd = AV_RL16(src); src += 2;\n\n                offset = cmd >> 4;\n\n                sz = (cmd & 0xF) + 2;\n\n                /* don't use memcpy/memmove here as the decoding routine (ab)uses */\n\n                /* buffer overlappings to repeat bytes in the destination */\n\n                sz = FFMIN(sz, dst_end - dst);\n\n                while (sz--) {\n\n                    *dst = *(dst - offset - 1);\n\n                    ++dst;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9896, "substitutes": {"src": ["setup", "chrom", "seq", "img", "cmp", "start", "mode", "proc", "source", "sel", "rest", "sur", "filename", "iv", "send", "stat", "buf", "config", "uri", "rib", "dest", "cb", "gb", "attr", "dist", "rb", "loc", "rs", "sq", "st", "prop", "cod", "tmp", "inst", "bc", "ource", "sub", "supp", "slice", "ctr", "sec", "sync", "rc", "sl", "ctx", "sup", "cur", "address", "ruby", "req", "conv", "desc", "sb", "spec", "sys", "ser", "url", "length", "comp", "inf", "ch", "rob", "sr", "seed", "uc", "lc", "ssl", "sc"], "src_size": ["src_ize", "src_scale", " src_start", "rc_ize", "rc_size", "rc_scale", "rc_end", " src_scale", "src_start"], "dst": ["dedst", " drc", " dsc", "DST", "madest", "dost", "drest", "dssts", "idsts", "pdest", "drc", "dedest", "Dsc", "dsc", "adest", "edst", "ndrc", "idest", "Dest", "fST", "dest", "Dsts", "fsts", "madsts", "fsc", "ndst", "dedsts", " dsts", " dest", " dST", "adrc", "fst", "madst", "ddest", "Drest", "madrest", "Dst", "dssc", "edST", "idst", "pdrc", "dsts", "ndest", "adost", "pdst", "dsest", "Dost", "edost", "ndsc", "dST", "ddsc", "idost", " dost", "edsc", "adst", "pdsc", "dsst", "dedsc", " drest", "ddrc", "idsc", "ddst", "adsc", "Drc"], "dst_size": ["dsc_size", "dsts_size", "dst_start", "dsts_end", "dsc_end", "dst_min", "dst_scale", "dsc_start", "dsts_start", "dsc_scale", "dsts_min"], "cmd": ["count", "mac", "cookie", "seq", "oc", "cmp", "ack", "dom", "dict", "id", "buf", "ct", "c", "head", "config", "cp", "cd", "cb", "cod", "cc", "mode", "op", "ctrl", "ctl", "child", "ctr", "ck", "msg", "opt", "ind", "md", "req", "ctx", "cur", "Cmd", "acl", "dc", "node", "init", "cat", "cfg", "command", "cm", "grad", "comp", "gz", "func", "gen", "uc", "acc"], "i": ["count", "l", "oi", "ui", "di", "start", "si", "n", "in", "zi", "adi", "info", "m", "xi", "b", "x", "ini", "z", "k", "t", "d", "c", "ji", "s", "p", "e", "at", "eni", "f", "ie", "j", "ai", "o", "index", "v", "ind", "gi", "udi", "ti", "r", "end", "qi", "ei", "bi", "pi", "ii", "u", "h", "I", "pos", "li", "ip", "ci", "a", "ori", "ri", "iu"], "sz": ["szen", "Szen", "Sx", " szip", "sx", "dsze", "asz", "aszip", "Sce", "aszen", "dsq", "szip", "Szn", " szn", "Szi", "asce", "szi", "Sq", "Sze", "gszen", "asze", "wszn", "psz", " sce", "sq", "Sz", "wsze", "sze", "gsx", "Szip", "aszn", "pszip", "wsz", " szi", "wszen", " sx", "dsx", " szen", "szn", "aszi", "dsz", "sce", "gszip", "gsz", "pszen", "psx", " sze", " sq"], "offset": ["count", "alias", "seq", "field", "start", "ext", "len", "alt", "pad", "nt", "origin", "shift", "c", "slot", "addr", "line", "limit", "ref", "off", "loc", "mode", "padding", "entry", "o", "index", "slice", "size", "order", "align", "end", "port", "part", "position", "error", "pos", "length", "Offset", "range"], "code": ["count", "zip", "seq", "co", "Code", "cmp", "ack", "comment", "rage", "id", "conn", "control", "c", "rule", "config", "addr", "cd", "cb", "cf", "loc", "cod", "ec", "sec", "cc", "mode", "ac", "call", "acc", "ck", "sync", "content", "coded", "codes", "check", "error", "cat", "nc", "charge", "ci", "comp", "length", "func", "gen", "fi", "range"], "dst_end": ["dsts_line", "dstMEnd", "dst0end", "dst_ends", "dST_start", "dst_ended", "dst0line", "dst_start", "dST_END", "dst0start", "dst_line", "dsc_ended", "dstMEND", "dsts_end", "dsc_end", "dST_end", "dst_id", "dsc_start", "dsts_ends", "dST_End", "dst0ends", "dstMstart", "dstMend", "dst_END", "dsc_id", "dst_End", "dsts_start"], "src_end": [" src_stop", "src00end", " src_start", "src0size", "src_stop", "src00edge", "rc_size", "src_ends", "src0ends", " src_End", "rc_end", "rc_ends", "src0start", "src_edge", "src00stop", "rc_start", " src_edge", "src00start", "src_start", "src_End", "src0end"]}}
{"project": "FFmpeg", "commit_id": "84f0aba18dc8815c5cd408238909e4dc8b60684f", "target": 1, "func": "ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,\n\n                  void *priv_data, RTPDynamicProtocolHandler *handler)\n\n{\n\n    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->ic = ic;\n\n    s->streams = &ic->streams[first_stream_of_set_idx];\n\n    do {\n\n        s->n_streams++;\n\n    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&\n\n             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);\n\n    s->prev_set_id    = -1;\n\n    s->prev_stream_id = -1;\n\n    s->prev_timestamp = -1;\n\n    s->parse_packet = handler->parse_packet;\n\n    s->dynamic_protocol_context = priv_data;\n\n\n\n    return s;\n\n}\n", "idx": 9913, "substitutes": {"s": ["l", "session", "is", "its", "http", "t", "x", "gs", "er", "sk", "full", "ies", "ns", "hs", "spec", "self", "settings", "erences", "sg", "ds", "si", "n", "w", "b", "i", "c", "e", "sq", "us", "f", "sym", "sets", "es", "ic", "r", "u", "comments", "fs", "su", "ps", "ess", "ss", "sc", "ks", "g", "ops", "d", "ls", "os", "cs", "o", "sync", "ics", "sl", "sn", "new", "sb", "sys", "ssl", "conf", "sports", "ts", "rows", "in", "service", "p", "qs", "ins", "xs", "js", "rs", "an", "aws", "S", "ctx", "ms", "ses", "ures", "css", "y", "bs", "events"], "n_streams": ["n_feedflows", "n_threadviews", "n_structviews", "n__streaming", "n_swflows", "n_lengthflows", "n_lengthd", "n__threadd", "n__streamed", "n_streamls", "n_feedls", "n_structing", "n_hosts", "n_feedd", "n_structs", "n__streamings", "n_hostings", "n_lengthviews", "n_streamd", "n__streamviews", "n_threadings", "n_swd", "n__streams", "n_hostd", "n_streamflows", "n_lengths", "n_threaded", "n_streamed", "n_threading", "n__threadviews", "n__threaded", "n_streamviews", "n_lengthing", "n__threads", "n_lengthings", "n_streaming", "n_lengthed", "n__threading", "n_feeds", "n_lengthls", "n_hosted", "n_swls", "n_threadd", "n_sws", "n_structd", "n_streamings", "n__streamd", "n__threadings", "n_threads"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    QCowL2Meta l2meta;\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    l2meta.nb_clusters = 0;\n\n    qemu_co_queue_init(&l2meta.dependent_requests);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        cluster_offset = l2meta.cluster_offset;\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buffer(&hd_qiov, cluster_data);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_link_l2(bs, &l2meta);\n\n\n\n        run_dependent_requests(s, &l2meta);\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 9922, "substitutes": {"bs": ["vs", "base", "ks", "bb", "ds", "its", "is", "lbs", "bas", "b", "ab", "iss", "sa", "fb", "ls", "pb", "qs", "gb", "ins", "outs", "js", "us", "BS", "bc", "os", "banks", "obs", "cs", "bl", "bh", "lb", "bis", "bi", "sb", "ns", "fs", "ses", "ps", "ss", "bes", "bos"], "sector_num": ["section_offset", "sectoralnumber", " sector_number", "section_number", "sector_count", "sector_number", "sectoralnum", "sectoralname", "sectoralcount", "sector_dest", " sector_begin", "sector_offset", " sector_dest", "section_count", "section_num", "sector_begin", "section_name", "sector_name"], "remaining_sectors": ["remaining_seges", "remaining_segment", "remaining_Sewards", "remaining_SEctions", "remaining_Seimeters", "remaining_SElements", "remaining_kegments", "remaining_tegments", "remaining_kewards", "remaining_kectors", "remaining_secctions", "remaining_gegments", "remaining_sewards", "remaining_secimeters", "remaining_tectors", "remaining_sesctors", "remaining_gections", "remaining_secctors", "remaining_sesges", "remaining_segments", "remaining_seclements", "remaining_seimeters", "remaining_secges", "remaining_tegment", "remaining_keimeters", "remaining_selements", "remaining_teges", "remaining_gelements", "remaining_SEctors", "remaining_secwards", "remaining_Segments", "remaining_sesgments", "remaining_sesgment", "remaining_secgment", "remaining_secgments", "remaining_gectors", "remaining_SEgments", "remaining_sections", "remaining_Sectors"], "qiov": [" qoren", "viewios", "quios", "quiov", "quoren", "qiol", "qios", "qoren", "sqnox", "qimoto", "viewiov", "quuno", " qios", "sqiov", " qdyl", "sqdyl", "quiol", "qudyl", " qiop", "viewiop", "qdyl", "qtoren", "qtuno", "sqimoto", "qunox", "viewiol", "qnox", "quno", " qnox", "qtimoto", " qimoto", " quno", " qiol", "quimoto", "quiop", "qiop", "qtiov"], "s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "plugins", "state", "bis", "full", "ns", "spec", "comm", "params", "settings", "sg", "words", "ds", "si", "sites", "b", "c", "e", "args", "lines", "f", "sym", "sets", "es", "r", "storage", "sis", "rates", "comments", "ps", "su", "site", "fs", "ss", "g", "features", "stats", "stat", "d", "sa", "ls", "os", "cs", "o", "sync", "sl", "sb", "admin", "sys", "side", "secondary", "ssl", "conf", "ts", "in", "uploads", "service", "p", "qs", "tests", "js", "aws", "multi", "S", "modules", "sie", "states", "services", "results", "submit", "less", "ses"], "index_in_cluster": ["index_in_cluration", "index_in_pliton", "index_in_sclure", "index_in_clusters", "index_in_chusters", "index_in_Clust", "index_in_plust", "index_in_acluster", "index_in_acluration", "index_in_laborum", "index_in_sclorum", "index_in_Clure", "index_in_clust", "index_in_aclusters", "index_in_labure", "index_in_Clusters", "index_in_clure", "index_in_clue", "index_in_cliton", "index_in_Cliton", "index_in_pluster", "index_in_queorum", "index_in_scluster", "index_in_chue", "index_in_sclust", "index_in_Clorum", "index_in_clorum", "index_in_queue", "index_in_chorum", "index_in_acliton", "index_in_pluration", "index_in_queuster", "index_in_Cluration", "index_in_labuster", "index_in_labusters", "index_in_Cluster", "index_in_scluration", "index_in_queusters", "index_in_plusters", "index_in_sclusters", "index_in_chuster", "index_in_Clue"], "n_end": ["namEND", " n_begin", " n_tail", "nappbegin", "sn00END", "n_after", "n2end", "n2ends", "nPends", "in_after", "N_run", "N_end", "n_END", "nappend", "nappEND", "sn2end", "sn_end", "n00END", "n2enter", "ntheended", "sn_post", " n_END", "n_enter", "ntheEND", "sn_max", "n_post", "n00max", "nPenter", "n00end", "n_max", "sn_ends", "n_ended", "N_END", "n_offset", "n_ends", "in_offset", "ntherun", "ntheend", "namend", "nambegin", "sn2ends", "sn_enter", "nPend", "N_ended", "nacafter", "sn00end", "napptail", "sn00post", "nacoffset", "n_run", "n__run", "n__END", "n_begin", "n_tail", "sn00max", "sn2enter", "n__ended", "namtail", "n00post", "n__end", "in_end", "nacend", "sn_END"], "ret": ["count", "seq", "pass", "valid", "flag", "ext", "alt", "val", "len", "nt", "conn", "Ret", "prot", "num", "ref", "arg", "lit", "fit", "reg", "hard", "gt", "rets", "j", "code", "rt", "res", "det", "opt", "rc", "fun", "att", "bot", "hash", "bit", "fin", "re", "RET", "back", "let", "result", "rev", "ft", "match", "mer", "success"], "cur_nr_sectors": ["cur_nr_vections", "cur_nr_pegments", "cur_nr_pecs", "cur_nr_secgments", "cur_nr_teonents", "cur_nr_peonents", "cur_nr_seccs", "cur_nr_secctions", "cur_nr_pectors", "cur_nr_tegments", "cur_nr_sections", "cur_nr_pections", "cur_nr_vectors", "cur_nr_tecs", "cur_nr_vecs", "cur_nr_veonents", "cur_nr_vegments", "cur_nr_seonents", "cur_nr_segments", "cur_nr_secs", "cur_nr_secctors", "cur_nr_tectors"], "l2meta": ["d2mini", "l3la", "l1metadata", "l3eta", "l7eta", " l3data", "l_meta", "l3Meta", "L1meta", "l6Meta", "lc2meta", "lc4meta", "L2meta", "l6mo", "l6meta", "l1data", "l3mini", " l3Meta", "l1la", "l2la", "l_eta", "lc2metadata", "el2metadata", "l4meta", "d2meta", "l4mo", "l4Meta", " l2Meta", "l7meta", "l2mo", "L2la", "l1mini", "d2Meta", " l3meta", "L1eta", "L1la", "l_Meta", "l7metadata", "lc4eta", "l7mo", "el4meta", "l6metadata", "L1Meta", "l1eta", "l2Meta", "L2Meta", "l4data", "el2Meta", "d1meta", "lc2mo", "lc2eta", " l3metadata", "l3data", "l2mini", "d1mini", "d1metadata", "d1Meta", " l2metadata", "el2meta", "l2metadata", "d2metadata", "el4mo", "lc4metadata", "lc4mo", "l4metadata", "L2eta", " l2data", "l4eta", "el4Meta", "l2data", "l1Meta", "l2eta", "l3metadata", "l3mo", "el2mo", "l3meta", "l1meta", "l_la", "l1mo", "el4metadata"], "cluster_offset": ["cluster\u00b7data", "cluster_prefix", "cluster__position", "clard__position", "clard__offset", "clusterFdata", "clard_position", "clusterFalt", "cluster_position", "cluster__prefix", "clayer_loc", "clayer_location", "cluster__offset", "clusterFnum", "clard_prefix", "clard_alt", "cluster__data", "cluster_loc", "cluster_location", "cluster\u00b7position", "clorer_length", "clusterEdata", "clusterElocation", "clard__prefix", "cluster\u00b7prefix", "clusterEloc", "clard_data", "cluster_alt", "clusterEoffset", "cluster_length", "clayer_data", "clorer_data", "clard_offset", "clusterFoffset", "cluster\u00b7offset", "clard__data", "clayer_offset", "cluster_num", "clard_num", "clorer_offset"], "hd_qiov": ["hd_sqimoto", "hd_questilo", "hd_quin", "hd_qnox", "hd_sqliv", "hd_viewiris", "hd_quiov", "hd_qveh", "hd_sqouri", "hd_sqilo", "hd_questnox", "hd_qqiris", "hd_questirin", "hd_sqveh", "hd_qimoto", "hd_qaimoto", "hd_qq\u00ef", "hd_viewiov", "hd_uiris", "hd_pushveh", "hd_qiris", "hd_questiov", "hd_uiov", "hd_quiris", "hd_Quin", "hd_sqiris", "hd_qouri", "hd_questveh", "hd_squin", "hd_viewilo", "hd_uirin", "hd_qqiov", "hd_qauin", "hd_questiris", "hd_qqirin", "hd_qliv", "hd_sqirin", "hd_pushirin", "hd_Qliv", "hd_u\u00ef", "hd_qaliv", "hd_Qimoto", "hd_questouri", "hd_qilo", "hd_pushiov", "hd_quirin", "hd_q\u00ef", "hd_qaiov", "hd_sqiov", "hd_viewouri", "hd_qirin", "hd_sqnox", "hd_Qiov", "hd_qu\u00ef", "hd_pushnox"], "cluster_data": ["clancer_data", "clusters_name", "clancer_DATA", "clust_size", "cluster___results", "clusteraclength", "clusterfDATA", "cluster_DATA", "cluster2name", "clusterfoffset", "clusteracoffset", "cluster_length", "cluster_size", "clusteracDATA", "clusters_results", "cluster2results", "cluster_name", "clusteracdata", "cluster___DATA", "clust_results", "clusters_data", "cluster_results", "cluster___data", "cluster2data", "cluster___name", "cluster_sum", "cluster2DATA", "clusterfdata", "clusterflength", "clusteringsize", "clust_sum", "clancer_length", "clusteringresults", "clusteringsum", "clusters_DATA", "clusteringdata", "clust_data", "clancer_offset"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n\n                   VhostBackendType backend_type, bool force)\n\n{\n\n    uint64_t features;\n\n    int i, r;\n\n\n\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -1;\n\n    }\n\n\n\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -errno;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->migration_blocker = NULL;\n\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n\n        error_setg(&hdev->migration_blocker,\n\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n\n        migrate_add_blocker(hdev->migration_blocker);\n\n    }\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    hdev->memory_changed = false;\n\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n\n    hdev->force = force;\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n\n    }\n\nfail:\n\n    r = -errno;\n\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n\n    return r;\n\n}\n", "idx": 9929, "substitutes": {"hdev": [" hdef", "ohcomment", "rhhost", "ohhost", "workdriver", "hev", "rhdev", "hserial", " hserial", "ohdebug", "ghdiv", "hdi", "shev", "hdom", "vdi", "vdevice", "hmod", "vde", "hdd", "vhost", "zhpad", " hdevelopment", "hwdev", "workdi", "ohdevelopment", "vpad", " hdiv", "hdie", "shdev", "hde", "hrev", "hdevelopment", "rhapp", "vconn", " hconn", "hhdevice", "uhdev", "shdom", "hrhost", "ghdevelopment", "zhde", "hdata", "hwrad", "rhdevice", "shod", "hlrad", "ohdie", "ihdev", "rhdie", "hconn", "hdef", "rhdef", "hrdiv", "hhdiv", " hdom", "hwdata", "uhhost", "fdevice", "cdev", " hdriver", "shdd", " hev", "hmhost", "pdev", "hlod", "cdevice", " hhost", "uhdevice", "cdef", "khdev", "khdc", "hldev", "hrad", "hcomment", "rhserial", "khhost", "happ", " hod", "vdev", "vdc", "hmdev", "hdebug", "hod", "lapp", " hdebug", " hde", "ghapp", "rhdi", "khdi", "ihdiv", "hdevice", "hrdevice", "vdie", "hdc", "ohdef", "hdiv", " hdevice", "vev", " happ", "ohdevice", "fdef", " hdata", "ihdevelopment", " hdc", "vserial", "rhdc", " hga", "rhdiv", "hhdev", "shconn", " hdd", "hhost", " hcomment", "hrga", "ghdev", "shdc", " hpad", " hrad", "rhdriver", "capp", "ldev", "workdev", " hdi", "fga", "vdevelopment", "uhdebug", "fapp", "ldef", "zhdevice", "fev", "vod", "hpad", "rhdevelopment", "hldata", "ihapp", "pcomment", "hhhost", "ldevice", "ohdev", "rhdd", "pdef", "hwod", "fdev", "pdevice", "zhdev", "hdriver", "hga", "hrdev", "rhev", "rhdom", "workdiv"], "opaque": ["opacity", "Opatinum", "opacle", "operacle", " opaco", "ospaque", "ompacity", "Opaque", "Opacity", "ompaque", " opatinum", "opaco", " opacle", "operacity", "oponymous", "ospaques", "osponymous", "ospbuffer", "iponymous", "ipacity", " opacity", "ospaco", "operaco", "operatinum", "ipaque", " opec", "ompaco", "catacity", "ospacity", "ipbuffer", "opbuffer", " opbuffer", "opec", "catacle", "operaque", "operec", "opaques", "cataque", "catec", "operaques", " oponymous", "opatinum", "Opaco", "ompaques"], "backend_type": ["backend_size", "backend_class", "backend_name", "backender_class", "backender_types", "backender_type", "backender_name", "backender_size", "backend_types"], "force": [" allow", " erase", " mode", "forced", "ops", "enable", "p", "util", "driver", "slave", "mode", "op", " forced", "Force", "flags", "ce", "native", "allow", "gc", " ignore", "use", "cache", "write", " alpha", "depth", " implicit", "secure"], "features": ["tags", "requires", "config", "afi", "errors", "ac", "plugins", "flags", "details", "rx", "ips", "params", "nets", "issues", "settings", "fi", "fc", "mac", "devices", "Features", "n", "resources", "includes", "license", "c", "s", "facts", "reports", "bits", "args", "types", "performance", "rules", "format", "bugs", "properties", "effects", "eatures", "products", "models", "g", "stats", "ops", "fixes", "forms", "ants", "versions", "ffff", " f", "protection", "os", "rt", "items", "feature", "ATURES", "classes", "new", "fn", "result", "rows", "fields", "files", "ports", "tests", "rs", "lib", "ints", "modules", "services", "results", "faces", "options", "feat", "events"], "i": ["l", "ui", "di", "it", "start", "n", "si", "zi", "id", "m", "xi", "b", "x", "t", "k", "ini", "z", "d", "iq", "c", "p", "uri", "ix", "e", "yi", "eni", "f", "ie", "j", "ai", "o", "index", "v", "gi", "ti", "mi", "phi", "qi", "err", "im", "pi", "bi", "ii", "u", "type", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu"], "r": ["cr", "rf", "l", "ru", "arr", "n", "g", "rd", "hr", "m", "fr", "mr", "rr", "b", "t", "kr", "k", "d", "rec", "c", "nor", "p", "run", "e", "or", "rb", "ir", "rs", "q", "er", "f", "lr", "dr", "rt", "o", "v", "R", "rc", "ner", "ar", "pr", "function", "err", "nr", "rar", "ur", "u", "re", "h", "rg", "result", "sr", "br", "rh", "rl"]}}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        int r, g, b;\n\n\n\n        switch (pix_fmt) {\n\n        case AV_PIX_FMT_RGB8:\n\n            r = (i>>5    )*36;\n\n            g = ((i>>2)&7)*36;\n\n            b = (i&3     )*85;\n\n            break;\n\n        case AV_PIX_FMT_BGR8:\n\n            b = (i>>6    )*85;\n\n            g = ((i>>3)&7)*36;\n\n            r = (i&7     )*36;\n\n            break;\n\n        case AV_PIX_FMT_RGB4_BYTE:\n\n            r = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            b = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_BGR4_BYTE:\n\n            b = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            r = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_GRAY8:\n\n            r = b = g = i;\n\n            break;\n\n        default:\n\n            return AVERROR(EINVAL);\n\n        }\n\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9934, "substitutes": {"pal": ["conf", "area", "ee", "base", "scale", "span", "val", "in", "ph", "all", "pad", "phil", "pl", "panel", "pp", "data", "sum", "mask", "el", "ace", "cb", "pro", "pixel", "app", "style", "ette", "group", "pel", "py", "al", "align", "font", "cal", "Pal", "pod", "cel", "li", "bin", "cell", "ch", "ap", "face", "pin"], "pix_fmt": ["pix_Fmt", "pix_formformat", "pix_formmt", "pix_fMT", "pix_FMT", "pix_frMT", "pix_Fnt", "pix_fformat", "pix_frformat", "pix_formMT", "pix_formlt", "pix_Flt", "pix_lMT", "pix_frlt", "pix_llt", "pix_fnt", "pix_flt", "pix_Fformat", "pix_lmt", "pix_frmt", "pix_formnt", "pix_lnt"], "i": ["l", "is", "m", "t", "x", "z", "uri", "esi", "ie", "v", "phi", "abi", "ii", "ori", "ri", "fi", "oi", "si", "n", "id", "xi", "ami", "k", "c", "s", "e", "mu", "f", "j", "index", "slice", "ic", "bi", "u", "li", "ni", "anti", "hi", "di", "zi", "adi", "my", "yi", "cli", "mini", "eni", "ai", "o", "gi", "chi", "pi", "I", "iu", "ui", "it", "in", "info", "ini", "p", "isi", "ix", "multi", "mi", "ti", "ik", "qi", "idi", "ip", "ci", "api", "io", "y"], "r": ["l", "cr", "ru", "n", "hr", "w", "m", "fr", "bar", "rr", "k", "x", "gr", "d", "ra", "c", "s", "p", "e", "gb", "reg", "or", "rb", "rad", "rs", "q", "er", "f", "lr", "j", "o", "v", "R", "rc", "ar", "err", "nr", "ur", "u", "ro", "h", "re", "rg", "a", "y", "sr", "ri", "br", "rh", "rl", "range"], "g": ["l", "gu", "sg", "gd", "pg", "n", "w", "m", "go", "k", "x", "ang", "gm", "gr", "d", "mg", "gs", "c", "z", "s", "p", "e", "gb", "reg", "gp", "gh", "q", "group", "f", "gy", "G", "bg", "v", "ig", "og", "gi", "gg", "ga", "err", "u", "h", "rg", "vg", "ng", "ge", "y", "gen"], "b": ["l", "ib", "base", "bb", "n", "abb", "w", "m", "bp", "ba", "bar", "t", "k", "ab", "x", "z", "d", "wb", "c", "ad", "s", "fb", "p", "bd", "e", "cb", "gb", "B", "rb", "f", "bc", "be", "j", "o", "eb", "bl", "v", "bh", "reb", "lb", "ga", "bi", "sb", "ur", "u", "ob", "a", "bin", "y", "xb", "bs", "br", "mb"]}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "void qmp_transaction(TransactionActionList *dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n", "idx": 9943, "substitutes": {"dev_list": ["ev_list", " dev_cont", "ev_entry", "dev__list", "dev__cont", "dev_code", "devayentry", "devaylist", "dev__entry", "devaycode", "dev_cont", "ev_code", "ev_cont", "dev__info", "devaycont"], "errp": ["erp", "rrpy", "errorlp", "rrlp", "errorpe", "errpe", "errpy", "errps", "errorpy", "errtp", "ierpe", "errorp", "rrp", " errtp", "ierpy", "ierp", "err", "errlp", "errortp", "erps", " errps", "ierlp", "rrpe", "errorps", " errr", "ertp", "errr", "errorr"], "dev_entry": ["demFentry", "demFalias", " dev_element", "demFevent", " dev_ry", "der_entry", "dev_ry", "dem_event", "dev_event", "dev5entry", "devamentry", "devFevent", "devamEntry", "dev_parse", " dev_enter", "dev_iterator", "dev_element", "dev5list", "demFlist", " dev_parse", "devFlist", "dev_alias", "der_element", "deramelement", "deramentry", "der_Entry", "devamelement", "dev_Entry", "dev5event", "dev5alias", "devFentry", "dev_enter", "deramEntry", "devFalias", "dem_entry", " dev_iterator", "dem_list", "dem_alias"], "state": ["parent", "session", "m", "point", "tag", "config", "set", "feed", "step", "er", "ie", "st", "code", "none", "call", "body", "al", "connection", "cur", "err", "port", "patch", "now", "grade", "form", "self", "type", "seed", "key", "view", "all", "id", "go", "k", "instance", "post", "rule", "s", "se", "e", "or", "op", "j", "slice", "scope", "module", "ner", "r", "load", "error", "root", "this", "back", "down", "State", "str", "g", "test", "class", "statement", "conn", "game", "public", "stat", "data", "head", "local", "action", "STATE", "style", "os", "entry", "resource", "o", "size", "sync", "order", "trans", "part", "oper", "node", "message", "use", "cache", "core", "start", "ry", "comment", "info", "update", "p", "run", "obj", "private", "manager", "child", "parse", "name", "event", "states", "inner", "user", "address", "out", "print"], "next": ["parent", "vious", "seq", "start", "owner", "again", "key", "second", "open", "path", "post", "last", "other", "data", "head", "prev", "iterator", "close", "set", "action", "off", "step", "sequence", "sec", "entry", "code", "child", "name", "response", "current", "ner", "future", "end", "done", "new", "first", "now", "after", "error", "front", "Next", "link", "self", "cycle", "loop", "back", "proc", "gen", "forward", "success", "chain"], "local_err": ["remote_error", "foreign___err", " local_req", "local_iter", "foreign_order", "remote_err", "local_cry", "foreign___notice", " local_cry", " local_error", "local_error", "local_req", "local___er", " local_iter", "foreign___order", "local_notice", "local___order", "local_order", "local___err", "foreign_err", "foreign_er", "local___notice", "foreign___er", "local_er", "remote_er", "foreign_notice"], "dev_info": ["ev_entry", "ev_Info", " dev_inf", "ev_family", "devjid", "devjinfo", " dev_next", "devlicinfo", "dev_id", "devenspec", "dev__id", "dev_inf", "devacinfo", "deveninfo", "devacinf", "devenid", "devlicentry", "devjnext", "ev_check", "devsinfo", "devacdata", "devliccheck", "dev_Info", "dev__entry", "devjentry", "dev__next", "dev_alias", "devacfamily", "dev_family", "devsalias", "dev_next", "dev__info", " dev_spec", "dev_data", " dev_alias", "dev_check", "devlicInfo", "devacalias", "dev_spec", " dev_id", "ev_data", "devsinf", "ev_info"], "ops": ["utils", "oc", "operator", "its", "opus", "steps", "afi", "outs", "uts", "step", "acs", "cop", "opt", "flags", "checks", "groups", "ns", "hop", "ips", "oops", "forces", "settings", "aps", "ils", "pps", "works", "opens", "app", "op", "opp", "eps", "locks", "acl", "lock", "ps", "times", "ss", " operations", "apps", "maps", "uses", "operation", "orders", "owner", "stats", "alls", "OPS", "arts", "effect", "posts", "ands", "OP", "pieces", "oop", "pins", "os", "cs", "o", "oa", "aux", "sync", "ups", "asts", "tx", "Ops", "als", "trans", "oper", "opers", "co", "ts", "active", "info", "actions", "changes", "ims", "oe", "obj", "ins", "xs", "rs", "obs", "states", "ms", "ip", "options", "loop", "io"]}}
{"project": "qemu", "commit_id": "d15fda639ba356148fc7161bba863866fd2797ef", "target": 0, "func": "static int intel_hda_init(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n    uint8_t *conf = d->pci.config;\n\n\n\n    d->name = d->pci.qdev.info->name;\n\n\n\n    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(conf, 0x2668);\n\n    pci_config_set_revision(conf, 1);\n\n    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);\n\n    pci_config_set_interrupt_pin(conf, 1);\n\n\n\n    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */\n\n    conf[0x40] = 0x01;\n\n\n\n    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,\n\n                                          intel_hda_mmio_write, d,\n\n                                          DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);\n\n    if (d->msi) {\n\n        msi_init(&d->pci, 0x50, 1, true, false);\n\n    }\n\n\n\n    hda_codec_bus_init(&d->pci.qdev, &d->codecs,\n\n                       intel_hda_response, intel_hda_xfer);\n\n\n\n    return 0;\n\n}\n", "idx": 9956, "substitutes": {"pci": ["jpci", "hcod", "Pmi", " pcgi", "cii", "cdi", "bca", "bii", "cci", "mmi", "jpki", "Pdi", "hdi", "qki", "cca", "mcm", "pcod", "hct", "pcm", "qdi", "mii", "Pki", "Pci", "cki", "pki", "mki", "pca", "hii", "hcgi", "ccm", "pcgi", "bki", " pdi", "qii", " pii", "Pcm", "mci", "jpii", "mdi", "jpdi", " pcod", "hki", "Pii", " pcm", "pii", "hci", "Pct", "mcgi", "qci", "Pcod", " pct", " pmi", "pct", "pmi", "cmi", "pdi", "hca", " pki", "bci"], "d": ["l", "ld", "diff", "gd", "di", "dh", "ds", "n", "g", "dom", "did", "rd", "dict", "da", "w", "m", "id", "die", "dt", "defined", "fd", "b", "t", "z", "i", "con", "c", "ad", "s", "config", "p", "data", "bd", "e", "cd", "pd", "wd", "dn", "f", "dr", "dl", "ded", "db", "dat", "j", "nd", "v", "ind", "state", "md", "r", "done", "dd", "vd", "dc", "sd", "dm", "h", "dy", "od", "dev", "client", "cmd", "td", "D"], "conf": ["cr", "img", "abc", "dom", "comment", "dict", "def", "conn", "info", "fr", "b", "ini", "con", "c", "config", "p", "ref", "cd", "cb", "app", "exec", "cf", "cn", "rb", "bug", "sec", "f", "Conf", "v", "rc", "ctx", "conv", "cal", "req", "cl", "dc", "com", "spec", "uc", "init", "cfg", "h", "ca", "cm", "dev", "client", "confirmed", "deb", "cache", "ch", "cmd", "lc", "comb", "core", "fi", "inf", "fab", "aff"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n\n        raw_aio_remove(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 9961, "substitutes": {"bs": ["vs", "base", "bb", "ba", "bid", "bas", "b", "fb", "s", "ls", "pb", "qs", "obj", "gb", "bits", "rb", "BS", "bc", "os", "obs", "db", "cs", "eb", "las", "lb", "bis", "bi", "sb", "ns", "bytes", "as", "fs", "ps", "ob", "bes", "bos"], "sector_num": ["sector_sn", "sector2name", "sector_index", " sector_number", "section_number", "sector2number", "sector_number", " sector_sn", "sector2index", "section_index", "sector2num", " sector_name", "section_num", "section_name", "sector_name"], "qiov": ["Qiov", " qrolet", "qiu", "quiu", "sqio", "questieri", "quiov", "qio", "quoyer", "quio", "questiu", "sqieri", "sqiov", "Qnox", "sqiu", "questio", "qunox", "Qoyer", "Qrolet", "qnox", " qoyer", "questiov", "qieri", "qurolet", "quieri", " qnox", "qrolet", "qoyer"], "nb_sectors": ["nb_vectors", "nb_peivers", "nb_secs", "nb_parseivers", "nb_serkers", "nb_serctors", "nb_pectors", "nb_sivers", "nb_segments", "nb_vekers", "nb_sergments", "nb_sctors", "nb_scs", "nb_parsekers", "nb_seivers", "nb_parsegments", "nb_sections", "nb_pections", "nb_serivers", "nb_pecs", "nb_sercs", "nb_sctions", "nb_sekers", "nb_vegments", "nb_parsectors", "nb_serctions", "nb_veivers"], "cb": ["bb", "abc", "unc", "b", "c", "fb", "pb", "fp", "gb", "cf", "rb", "bc", "cc", "orb", "db", "bf", "ctrl", "eb", "cv", "CB", "ctx", "lb", "callback", "function", "sb", "pc", "dc", "fn", "ob", "func", "lc", "fee", "buff", "fc"], "opaque": ["opacity", " opaco", "oclque", "opaco", "operacity", " opque", "operque", "octacity", "oclaque", " opacity", "operaco", " opec", "octque", "opec", "oclacity", "opque", "operaque", "oclaco", "octaque", "octec", "operec"], "acb": ["ocbb", " acba", "ocb", "ACb", "ocsb", "accb", "ACbd", " acsb", "ack", "akk", " acf", "ecf", "accsb", "acu", "aku", "akb", " acbb", " acl", "accB", "aca", "eck", "ACa", "ecb", "ACbb", "ACl", "accf", "accl", "acsb", "accba", "acB", " aca", "ocB", "oca", "ainb", "acca", " acbd", "accbb", "aink", "ainf", "ACf", "acf", "ainu", "acl", "accbd", " acB", "acbb", "ecu", "ACba", "acba", "acbd", "akf", "ACsb"]}}
{"project": "FFmpeg", "commit_id": "3622988f2162e502727da476a70f5e4f48cd19c5", "target": 0, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n    \n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 &&\n\n                ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n    \n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n    \n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*h->b8_stride] == 0){\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        /* FIXME assumes that L1ref0 used the same ref lists as current frame */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1mv0[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n    \n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n    \n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9977, "substitutes": {"h": ["l", "hi", "sh", "he", "ht", "dh", "n", "g", "ph", "hr", "hh", "w", "m", "http", "b", "path", "x", "k", "t", "z", "d", "c", "hm", "p", " H", "e", "gh", "q", "eh", "hw", "f", "host", "o", "ha", "th", "v", "bh", "ih", "r", "hp", "hs", "oh", "u", "H", "hl", "image", "ah", "ch", "y", "rh"], "mb_type": ["mp_typ", "pg_typ", "mb_TYPE", "MB_name", "bg_split", "mb__TYPE", "mb__type", "MB_size", "mp_id", "mbaltype", "pg_TYPE", "MB_type", "mp_name", "pg_type", "mb_name", "mb_size", "mbftype", "pg_col", "mb_typ", "mb_length", "mb__split", "mb_split", "mballength", "mbaltypes", "mbaltyp", "mp_length", "mb_format", "mbflength", "MB_types", "mb_types", "mbftyp", "mb__format", "bg_type", "mp_types", "bg_format", "mb_col", "mbftypes", "mb_id", "bg_TYPE", "mp_type"], "s": ["l", "conf", "session", "location", "sh", "ts", "ds", "n", "g", "si", "in", "is", "w", "m", "b", "ages", "t", "x", "k", "d", "i", "gs", "c", "p", "ls", "server", "qs", "e", "rs", "us", "sq", "f", "os", "an", "js", "j", "sym", "o", "S", "es", "v", "sl", "services", "r", "settings", "support", "ns", "storage", "sb", "hs", "spec", "u", "ions", "client", "ps", "fs", "ses", "a", "y", "ss", "rh"], "l1mv0": ["l1mv1", "l1mmv1", "l1mf0", "l1mc6", "l1mh0", "l1mh1", "l1mf1", "l1mmv0", "l1mmf6", "l1mmf0", "l1mf2", "l1mf6", "l1mh6", "l1mc2", "l1mc1", "l1mmv6", "l1mh2", "l1mmv2", "l1mv2", "l1mc0", "l1mmf2", "l1mmf1", "l1mv6"], "l1ref0": ["l_ref0", "l1mem50", "l_f50", "l1r50", "l1r0", "l_f0", "l1r1", "l1ref50", "l_f1", "l1mem0", "l_ref1", "l1f50", "l1f0", "l_ref50", "l1mem1", "l1f1", "l1ref1"], "sub_mb_type": ["sub_mbjkey", "sub_mb_id", "sub_ym_type", "sub_MB_type", "sub_ym_num", "sub_bb_type", "sub_mp_key", "sub_mb_state", "sub_ym_ver", "sub_mp_Type", "sub_mb_num", "sub_mb_ver", "sub_mb_key", "sub_mbjType", "sub_bb_typ", "sub_mb_tag", "sub_mb_comp", "sub_mb_Type", "sub_mb_typ", "sub_mp_type", "sub_MB_types", "sub_bb_id", "sub_mp_comp", "sub_MB_tag", "sub_mbjtype", "sub_mbjcomp", "sub_ym_state", "sub_mb_types"], "i8": ["p6", "i64", "ui8", " i88", "p8", "i6", "ui88", " i64", " i6", "p88", "ui64", "i88", "ui6", "p64"], "i4": [" i3", "i2", "p8", "p4", "pi8", "pi3", "i3", " i2", "pi2", "p3", "p2", "pi4"]}}
{"project": "qemu", "commit_id": "e3af7c788b73a6495eb9d94992ef11f6ad6f3c56", "target": 0, "func": "static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)\n\n{\n\n    uint32_t ret;\n\n\n\n    switch (ot) {\n\n    case MO_8:\n\n        ret = cpu_ldub_code(env, s->pc);\n\n        s->pc++;\n\n        break;\n\n    case MO_16:\n\n        ret = cpu_lduw_code(env, s->pc);\n\n        s->pc += 2;\n\n        break;\n\n    case MO_32:\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n#endif\n\n        ret = cpu_ldl_code(env, s->pc);\n\n        s->pc += 4;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n    return ret;\n\n}\n", "idx": 10000, "substitutes": {"env": ["vs", "fg", "ou", "inet", "dh", "fen", "shell", "conn", "que", "net", "iv", "viron", "d", "ne", "iss", "c", "environment", "config", "vm", "e", "osc", "np", "txt", "esi", "ec", "eni", "er", "f", "ev", "console", "enos", "energy", "v", "es", "ea", "state", "sl", "ctx", "en", "err", "enh", "eng", "ench", "enc", "esp", "nc", "esm", "her", "engine", "ah", "eu", "proc", "eve", "ens"], "s": ["vs", "conf", "session", "sg", "ts", "sv", "is", "n", "si", "ds", "sites", "its", "t", "b", "ops", "gs", "ssl", "c", "iss", "p", "ls", "server", "e", "qs", "ins", "args", "js", "sq", "sec", "os", "rs", "f", "us", "cs", "sym", "o", "sets", "S", "es", "states", "sl", "services", "ctx", "en", "ns", "sb", "spec", "enc", "sys", "h", "ses", "fs", "site", "ps", "su", "ss", "ess", "a", "settings", "ens"], "ot": ["cot", "lot", " os", "boot", "oc", " t", "nt", "t", "ol", " bot", "c", "p", "osc", "oto", "ocol", "or", "pt", "gt", " pot", " quot", "op", " ov", "rot", "ut", "ots", "rt", "os", " rot", "o", " opt", "ort", "OT", "ic", "r", " OT", " tot", " dot", "mot", "ott", "root", " o", "sys", " robot", "et", "ocl", "ant", "ch", "pot", "ocr", "iot"], "ret": ["repl", "flag", "str", "alt", "val", "len", "ext", "def", "nt", "id", "Ret", "mem", "data", "reply", "red", "addr", "ref", "arg", "obj", "lit", "fit", "reg", "final", "gt", "rets", "f", "ut", "code", "rt", "res", "bf", "det", "al", "v", "eval", "rc", "fun", "resp", "part", "art", "bit", "xt", "re", "RET", "back", "out", "result", "mt", "url", "rev", "match", "success"], "pc": ["cpu", "lp", "arc", "asc", "roc", "auc", "post", "pointer", "con", "c", "ct", "pb", "sc", "pt", "mic", "pm", "ec", "cc", "ac", "bc", "cs", "isc", "pub", "inc", "sync", "rc", "clock", "pac", "cur", "pu", "tp", "can", "xc", "enc", "cms", "pod", "nc", "sys", "gc", "loop", "lic", "ci", "cache", "anc", "cent", "lc", "proc", "vc", "mc", "uc", "micro", "PC", "fc"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n", "idx": 10026, "substitutes": {"opaque": ["compaque", "opacity", "OPaque", "compacity", "ipque", "opac", "compque", "compaques", "OPque", " opac", "OPaques", "copacity", " opaques", "ipacity", " opacity", "ipaque", "ipaques", "copaque", "copac", "OPac", "opque", "copaques", "opaques", "OPacity"], "bs": ["vs", "ks", "bb", "abc", "ds", "ba", "bas", "b", "ab", "ops", "gs", "iss", "fb", "ls", "pb", "ros", "ins", "cb", "bits", "ums", "rs", "BS", "bc", "os", "obs", "cs", "bec", "bl", "bps", "ras", "bh", "fps", "las", "lb", "als", "ns", "sb", "bytes", "ps", "fs", "ss", "bes", "bos"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,\n\n                      int rw, int type, int target_page_bits)\n\n{\n\n    hwaddr pteg_off;\n\n    target_ulong pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);\n\n    for (i = 0; i < 8; i++) {\n\n        if (env->external_htab) {\n\n            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));\n\n            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);\n\n        } else {\n\n            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));\n\n            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);\n\n        }\n\n        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);\n\n        LOG_MMU(\"Load pte from %08\" HWADDR_PRIx \" => \" TARGET_FMT_lx \" \"\n\n                TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n", "idx": 10049, "substitutes": {"env": ["cot", "chal", "conf", "ou", "qt", "context", "ext", "equ", "dict", "conn", "org", "dt", "que", "ini", "net", "viron", "ne", "environment", "vm", "config", "qa", "cli", "osc", "np", "txt", "cf", "e", "esi", "ec", "eni", "eh", "act", "bc", "ev", "db", "console", "qv", "inv", "exc", "cv", "ea", "oa", "energy", "event", "cal", "en", "loader", "jp", "eng", "Environment", "enc", "cfg", "nc", "site", "cache", "ah", "engine", "eu", "ocr", "fi", "exec"], "ctx": ["utils", "qt", "context", "cmp", "Context", "na", "conn", "src", "dt", "que", "sci", "fw", "service", "c", "ct", "cp", "config", "qq", "obj", "qa", "cli", "cu", "fp", "component", "cn", "cf", "wcs", "loc", "sq", "hw", "bc", "cc", "console", "ctrl", "rt", "cv", "exc", "ck", "sync", "rc", "connection", "cas", "conv", "cal", "tx", "kt", "acl", "git", "xc", "nc", "cm", "ca", "client", "grad", "ci", "vc", "lc", "cmd", "anc", "pkg", "ocr", "settings", "cgi", "kb", "sc", "exec"], "h": ["l", "hi", "sh", "ht", "dh", "n", "g", "ph", "hh", "w", "m", "id", "b", "t", "x", "c", "p", "hm", "gh", "q", "hw", "f", "host", "ha", "v", "bh", "ih", "end", "en", "hp", "hash", "oh", "hs", "hd", "u", "H", "hl", "header", "ch", "rh", "uh"], "rw": ["wl", "wn", "rf", "ru", "wp", "w", "iw", "wh", "sw", "fw", "wb", "wt", "wk", "wd", "rew", "usr", "rss", "wr", "nw", "rb", "writer", "rs", "wo", "lr", "hw", " w", "rc", "ih", "raw", "nr", "wx", "kw", "wu", "rn", "ww", "rx", "rg", "rack", "RW", "rh", "rl", "tw"], "type": ["kind", "id", "method", "info", "temp", "t", "path", "rec", "Type", "rule", "time", "ref", "p", "pb", "attr", "pe", "thin", "style", "ptr", "prop", "types", "tmp", "op", "unit", "o", "py", "shape", "format", "name", "rc", "cur", "ty", "ping", "error", "TYPE", "sys", "re", "y", "ype", "weight", "resp", "typ"], "target_page_bits": ["target_width_bytes", "target_page64bit", "target_page64config", "target_page64bytes", "target_pagenumbits", "target_pagenumbit", "target_width64bytes", "target_width_config", "target_width_bit", "target_page64bits", "target_width64bit", "target_page_bytes", "target_width_bits", "target_width64bits", "target_pagenumconfig", "target_page_config", "target_width64config", "target_page_bit", "target_pagenumbytes"], "pteg_off": ["pteg55fail", "ptig_Off", "pteg00off", "ptpeg_ON", "pteg67open", "ptpeglenon", "pteg_open", "ptreg_set", "pteg67num", "ptig_num", "ptpeg_offset", "ptrig55Off", "ptpeg_off", "ptpeg_on", "pteg_set", "pteglenoff", "ptrig_not", "pteg_ref", "pteglenON", "pteglenon", "ptrig_off", "pteg0open", "pteg55orig", "pteg_offset", "pteg00on", "pteg_orig", "pteg_fail", "pteg67ref", "pteg55not", "pteg_num", "ptigh00on", "ptpeglenoffset", "pteg_alt", "pteg0off", "ptigh00alt", "ptrig55off", "pteg_on", "ptpeglenoff", "pteg_not", "pteg55on", "pteg67orig", "pteg0ref", "ptreg_off", "pteg67not", "pteg55off", "ptigh_fail", "pteg_Off", "ptig_ref", "pteg00alt", "ptpeglenON", "ptrig55not", "pteg_opp", "ptreg_opp", "pteg55Off", "ptreg_offs", "ptigh00fail", "ptigh_off", "ptigh_on", "ptig_open", "ptreg_on", "ptrig_Off", "pteg_ON", "ptrig55orig", "pteg67Off", "pteg67off", "pteglenoffset", "pteg00fail", "ptreg_OFF", "pteg_offs", "pteg55alt", "ptigh00off", "pteg_OFF", "ptrig_orig", "ptigh_alt", "ptig_off"], "pte0": ["pte050", "ctee150", "cte18", "ctee0", "cte0", "cte192", "ptae180", "pti0", "ptee192", "ptte100", "ptea0", "PTE2", " pts8", "ptee100", "upti0", "pte8", "ctee18", "pte100", "PTE029", "ptae18", "ptte1", "ptse00", "cte00", "pts8", "ptse1", "pte5", "ptE5", "ptee8", "upti050", "ptE029", "ptoe050", "pteio", "ptse0", " pteio", "pte180", "pte18", "ptE4", "ptE25", "ptte0", "PTe0", " pts0", "ptae050", "ptee5", "ptae00", "ptnio", "PTe5", "PTE0", "pte00", "ptse18", "ptedge029", "ptea192", "ptee1", "ptoe192", "ptoe1", "ptte25", "ptee18", "ptae4", "pte029", "ptedge2", " ptsio", "ptae1", "pte2", "ptea1", "upti4", " pte8", "upte4", "ptee25", "ctee1", "upte180", "ptee0", "PTE5", "ptoe0", "pts0", "cte4", "ctee4", "ptee4", "ptoe180", "cte25", "ptee00", "pteeio", "upte050", "cte100", "PTe2", "ptn0", "ptsio", "pti4", "ctee00", "ptoe150", "ptse100", "ptse25", "ptE2", "ptee029", "pti180", "ptee2", "ptE1", "ctee25", "cte1", "ptedge5", "ptea150", "pte150", "PTe029", "upte0", "ptoe25", "ptE0", "pte192", "pti050", "pte4", "pte25", "ctee100", "cte150", "ptedge0", "ptee150", "ptae0", "ctee192", "upti180", "ptn8", "ptoe4"], "pte1": ["cteOne", "cteeone", "postoe81", "cte5", "ctee0", "cteen", "cte0", "pteeone", "ctee11", "ptoe9", "ptea0", "ptlOne", "ptfe0", "ptee3", "pte8", "ptoe5", "pteone", "ctee2", "pte9", "cteeOne", "pted1", "cte3", "poste0", "pteen", "ptee81", "cte11", "ptoeOne", "ptse1", "pte5", "ptee8", "ptfe3", "ctee3", "ptoe81", "ptei5", "ptse0", "ptl0", "ptedone", "ptea11", "ptfeOne", "postoeOne", "ptee5", "poste81", "poste1", "cteone", "ptseone", "posteOne", "ptee1", "ptoe1", "ptfe1", "pte11", "postoe0", "cte2", "cten", "ptoen", "ptae1", "pte2", "cte8", "ptea1", "ptoeone", "ctee8", "ptei1", "pte81", "ctee1", "ptee0", "ptoe0", "ptle9", "pten", "ptea3", "ptoe11", "ptle1", "pted2", "ptl81", "cte9", "ptei3", "ptee11", "ptei2", "pteione", "ptaen", "ptee2", "ptoe8", "ptl1", "cte1", "ptle0", "pteiOne", "ptei0", "pte3", "pteOne", "postoe1", "ctee9", "pted5", "ptse8", "ptle5", "ptae0", "ptee9", "ptae3", "pteeOne", "ctee5", "ptoe3"], "i": ["oi", "l", "hi", "ui", "di", "is", "si", "n", "in", "zi", "adi", "info", "xi", "id", "b", "x", "ini", "my", "t", "d", "c", "ji", "p", "ix", "uri", "e", "cli", "mu", "yi", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "mi", "phi", "ti", "ind", "chi", "abi", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu"], "ret": ["good", "pass", "valid", "bad", "flag", "debug", "len", "val", "fail", "def", " success", "nt", "id", "Ret", "rr", "like", "num", "mem", "last", "big", "data", "ref", "arg", "lit", "fit", "reg", " result", "bug", "gt", "rets", "best", "f", "rt", "res", "db", "ig", "rc", "ind", "req", "fun", "done", "err", "get", "bit", "fin", "re", "stable", "cat", "rx", "RET", " good", "back", "result", "resp", "fi", "success"], "r": ["rf", "ru", "g", "ry", "hr", "m", "mr", "rr", "b", "t", "kr", "d", "c", "s", "p", "e", "ir", "rb", "rs", "er", "f", "lr", "dr", "rt", "res", "v", "R", "rc", "ar", "end", "err", "nr", "error", "ur", "re", "rg", "result", "sr", "ri", "br", "rh", "rl"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    xcrs.nr_xcrs = 1;\n\n    xcrs.flags = 0;\n\n    xcrs.xcrs[0].xcr = 0;\n\n    xcrs.xcrs[0].value = env->xcr0;\n\n    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 10055, "substitutes": {"env": ["chal", "conf", "ou", "context", "enter", "dict", "conn", "que", "net", "iv", "viron", "iss", "c", "environment", "vm", "config", "el", "server", "obj", "e", "ep", "np", "machine", "args", "ec", "eni", "f", "network", "manager", "entry", "code", "ev", "db", "exc", "ea", "cv", "scope", "v", "ctx", "end", "loader", "en", "eng", "enc", "ef", "eye", "et", "client", "esc", "chev", "cache", "ah", "eu", "fi"], "xcrs": ["xfras", "etcars", "xar", "ucars", "xdcs", "xdrics", "xdr", "xfrs", "lcrd", "xaRS", "xfri", "xbri", "ucrs", "xcrics", "xfrors", "xccs", "xcr", "xfcs", "ucps", "ctxars", "xcdr", "xdars", "xdrors", "xfars", "xdps", "lcrs", "xdri", "xcras", "ctxdr", "xers", "xarics", "xaras", "xfdr", "lcars", "lcras", "etcrors", "xars", "xfr", "xeras", "xfps", "xacs", "lcrics", "xfRS", "xdRS", "ctxps", "etcrs", "xddr", "lcps", "ucrys", "xdrs", "xdras", "xbrs", "xcrors", "lcr", "lcrys", "xfrd", "xeRS", "xcri", "xcps", "ctxrs", "xbRS", "xer", "xbras", "xcrd", "xdrd", "xcRS", "xcrys", "lcRS", "xdrys", "etcRS", "xcars"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n", "idx": 10064, "substitutes": {"ctx": ["cpu", "cdn", "cam", "wp", "context", "Context", "cca", "conn", "tc", "sci", "c", "cp", "config", "qq", "cu", "cli", "cb", "np", "txt", "cf", "cn", "wcs", "fp", "loc", "hw", "bc", "cc", "cs", "ctrl", "cus", "cv", "ck", "parse", "sync", "rc", "connection", "cas", "conv", "tx", "qa", "pc", "wx", "xc", "git", "cpp", "cms", "nc", "cfg", "cm", "ca", "client", "grad", "ci", "fc", "wordpress", "vc", "anc", "cmd", "lc", "pkg", "mc", "kb", "sc", "exec"], "cond": ["diff", "conf", "reason", "proc", "fail", "def", "temp", "Cond", "red", "c", "comb", "config", "cp", "obj", "cb", "reg", "cf", "condition", "loc", "cod", "prop", "sec", "df", "bc", "code", "unit", "pkg", " Cond", "cas", "conv", "pre", "desc", "cl", "xc", "com", "lock", "prep", "pos", "fc", "comp", "func", "lc", "cmd", "crit", "resp", "cell", "exec"], "cmp": ["cpu", "diff", "conf", "seq", "Compare", "gen", "co", "proc", "cp", "c", "config", "component", "cb", "upp", "fp", "cup", "np", "pro", "loc", "prop", "coll", "tmp", "op", "bc", "cho", "pkg", "omp", "ctrl", "mp", "cop", "agg", "cas", "conv", "jp", "desc", "rep", "cor", "com", "cpp", "Comp", "prep", "comm", "pos", "clip", "comp", "mom", "lc", "cmd", "crit", "resp", "imp"], "disp": ["demp", "discp", "DISp", "disps", " dispp", " Disps", "dislp", "DISP", "dempp", "despp", "dembp", "desp", "Disps", " disbp", "desbp", "DISps", "disP", "deslp", "dispp", "DisP", " Disp", "demlp", " dislp", " DisP", "Discp", " Discp", "DIScp", "disbp", "Disp"]}}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)\n\n{\n\n    uint32_t val = pci_default_read_config(d, address, len);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 10081, "substitutes": {"d": ["ld", "gd", "dh", "ds", "da", "id", "m", "dt", "dos", "fd", "t", "x", "b", "i", "data", "ad", "c", "bd", "p", "e", "pd", "cd", "f", "ded", "dl", "db", "dat", "v", "ind", "md", "dd", "dc", "sd", "dm", "od", "a", "dad", "D"], "address": ["channel", "Address", "dim", "inet", "argument", "m", "instance", "pointer", "ad", "data", "addr", "config", "p", "e", "ace", "driver", "target", "number", "array", "ai", " Address", "device", "index", "shape", "object", "port", "dd", "offset", "type", "pair", "message", "ip", "attribute", "interface", "image", "length"], "len": ["count", "l", "seq", "base", "lf", "valid", "n", "val", "in", "lim", "fd", "z", "num", "data", "block", "line", "limit", "el", "split", "loc", "f", "fl", "size", "en", "part", "offset", "enc", "pos", "length", "bin", "Len", "lc", "ln"]}}
{"project": "qemu", "commit_id": "bbade20633a6b4ed7333e03a76038eda98950946", "target": 1, "func": "static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n", "idx": 10104, "substitutes": {"cpu": ["mac", "boot", "cmp", "prof", "worker", "processor", "conn", "gpu", "mem", "cp", "vm", "thread", "cli", "gp", "linux", "mx", "process", "clock", "loader", "pu", "pc", "CPU", "px", "cache", "proc", "core", "mc", "roc"], "spapr": ["SPapr", "spaper", "spappnr", " spaprs", "spepnr", "spappr", "spaprc", "SPaprc", "spaprs", "speprs", " spapR", "spAPR", " spappnr", " spapprs", "SPapR", "spAPr", "spepR", " spapnr", "SPaperc", "spapR", "spaprb", "SPaper", "spapnr", "spAPnr", " spappR", "spepr", " spappr", "spapprs", "spapprb", "spappR", "spaperc", "spapprc", "spapeR", "SPaperb", "spaperb", "SPapeR", "spAPrs", "spAPrc", "SPaprb", "spAPrb"], "token": ["cookie", "des", "timeout", "len", "conn", "Ret", "total", "wt", "mem", "ern", "reply", "rule", "cb", "nat", "acs", "ea", "flags", "fun", "urn", "ctx", "cost", "tn", "RET", "su", "result", "match", "resp"], "nargs": ["ntarg", "larg", "ntseq", "carg", "cseq", "cargs", "lrets", "narg", "crets", "ntrets", "lseq", "nseq", "nrets", "ntargs", "largs"], "args": ["uments", "vals", "ts", "arr", "len", "ait", "alls", "data", "reply", "addr", "arg", "aus", "ai", "cs", "call", "ae", "parse", "ints", "flags", "ns", "ms", "Args", "params", "ret", "func", "resp"], "nret": ["dreturn", "nreturn", "dret", " nRET", "cret", " nRet", "dRET", "ncret", "ncreturn", "nrets", "natret", "creturn", "nRET", " nmatch", "nmatch", "crets", " nreturn", "nRet", "ncrets", "natRET", "ncRet", "natmatch", " nrets", "cRet", "natreturn", "dmatch"], "rets": ["uments", "utils", "strings", "store", "vers", "nuts", "reads", "outs", "uts", "errors", "acs", "flags", "books", "checks", "groups", "details", "ns", "ips", "ails", "uries", "nets", "ets", "buffer", "ves", "vals", "ds", "uds", "opens", "bits", "lines", "res", "fits", "acks", "nas", "ards", "bytes", "fs", "urs", "des", "alt", "verts", "features", "def", "ops", "archives", "reply", "ls", "aux", "tta", "ats", "sys", "ret", "fts", "ts", "ults", "rows", "fields", "files", " secrets", "ents", "qs", "tests", "secret", "runs", "nir", "rs", "ints", "results", "RET", "ures", "proc", "tracks", "events"], "tm": ["imm", " tmp", "tr", "m", "mr", " m", "t", "tt", "gm", "hm", "txt", "nm", " tre", "timer", "htm", " tc", "tri", "dm", "text", "tw", "TM", "dim", "ku", "em", "tc", "template", "mem", "tmp", "sym", "tom", "tf", "md", "sm", "tk", " ret", "sim", "mt", "gam", "ym", "term", " mem", "temp", " ts", "mm", "project", "tu", "metadata", "cu", "cli", "wm", "mode", " te", "fm", "tre", "nom", "norm", "anim", "tim", "imi", "td", "om", "mc", "ui", "ts", " t", "ta", "lim", "utm", "dt", "server", "multi", " template", "ti", "mi", "ten", "acqu", "him", "tn", "cm", "tem", " TM", "um", "typ", "te"]}}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n", "idx": 10128, "substitutes": {"device": ["parent", "mac", "devices", "mobile", "product", "conn", "gpu", "phy", "model", "path", "mount", "task", "project", "block", "data", "Device", "component", "target", "driver", "machine", "serial", "slave", "mode", "network", "unit", "scope", "name", "connection", "feature", "address", "port", "node", "type", "dev", "ip", "disk", "attribute", "image", "engine", "android", "buffer", "direction"], "speed": ["scroll", "rank", "level", "score", "pass", "rate", "scale", "si", "start", "source", "path", "send", "disable", "gain", "strength", "status", "set", "performance", "step", "mode", "unit", "size", "sync", "Speed", "state", "peed", "port", "screen", "cost", "error", "grade", "spec", "image", "length", "fee", "ss", "weight", "seed", "settings", "slow", "power"], "errp": ["erf", "erp", " errP", "ryP", "acerf", "errps", "corP", "erlp", "corr", " errpc", "acerp", "rypc", " errlp", "ryp", "acerps", "errP", "errpc", "errf", " errf", "erP", "erpc", "err", "corlp", "errlp", "erps", "ryps", " errps", "corp", " errr", "errr", "acerP"], "job": ["parent", "member", "session", "up", "worker", "b", "block", "run", "config", "work", "jo", "status", "output", "queue", "jobs", "cb", "server", "pm", "bug", "flow", "f", "manager", "j", "db", "child", "sub", "py", "lib", "module", "process", "route", "Job", "name", "sync", "home", "fun", "object", "lb", "address", "jp", "full", "error", "node", "hub", "plugin", "lock", "layer", "api", "build", "ob", "image", "result", "runner"]}}
{"project": "FFmpeg", "commit_id": "e8c4db0d4d07738fed716b1d2f20c85aac944641", "target": 0, "func": "static int create_stream(AVFormatContext *s)\n\n{\n\n    XCBGrabContext *c = s->priv_data;\n\n    AVStream *st      = avformat_new_stream(s, NULL);\n\n    xcb_get_geometry_cookie_t gc;\n\n    xcb_get_geometry_reply_t *geo;\n\n    int ret;\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = av_parse_video_size(&c->width, &c->height, c->video_size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000);\n\n\n\n    gc  = xcb_get_geometry(c->conn, c->screen->root);\n\n    geo = xcb_get_geometry_reply(c->conn, gc, NULL);\n\n\n\n    c->width      = FFMIN(geo->width, c->width);\n\n    c->height     = FFMIN(geo->height, c->height);\n\n    c->time_base  = (AVRational){ st->avg_frame_rate.den,\n\n                                  st->avg_frame_rate.num };\n\n    c->time_frame = av_gettime();\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width      = c->width;\n\n    st->codec->height     = c->height;\n\n    st->codec->time_base  = c->time_base;\n\n\n\n    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);\n\n\n\n    free(geo);\n\n\n\n    return ret;\n\n}\n", "idx": 10161, "substitutes": {"s": ["session", "sg", "ks", "sv", "is", "si", "ds", "g", "sf", "w", "m", "b", "t", "ops", "d", "i", "gs", "service", "sa", "p", "e", "xs", "sq", "js", "f", "os", "cs", "o", "sets", "v", "es", "S", "sync", "sl", "services", "r", "sn", "ns", "sb", "spec", "as", "sys", "ses", "su", "fs", "ss", "ssl", "sc"], "c": ["l", "cr", "co", "oc", "C", "n", "g", "w", "m", "conn", "tc", "k", "b", "t", "z", "x", "d", "i", "con", "cp", "config", "p", "ct", "chain", "e", "cb", "cu", "cd", "cf", "ec", "q", "coll", "f", "cc", "ac", "bc", "sec", "cs", "ctrl", "o", "cus", "v", "ce", "ic", "ctx", "cur", "r", "cl", "pc", "dc", "com", "enc", "col", "this", "u", "nc", "h", "cm", "ca", "ci", "vc", "lc", "cache", "anc", "jc", "ch", "mc", "uc", "cy", "sc", "fc"], "st": ["cr", "l", "sp", "t", "tt", "ad", "ace", "set", "cc", "sk", "ce", "cur", "put", "ST", "ld", "est", "ust", "stage", "post", "ct", "se", "e", "osc", "tmp", "bc", "f", "spect", "ut", "nd", "sth", "cl", "art", "dc", "storage", "mt", "lc", "ess", "ss", "sc", "sh", "std", "str", "nt", "src", "stat", "sa", "stop", "sle", "rt", "cs", "sync", "sta", "sl", "sn", "sb", "ast", "et", "sr", "td", "uc", "ts", "start", "rd", "irst", "dt", "rest", "obj", "ost", "pt", "inst", "sts", "ist", "ste", "sty", "sd", "St", "ft", "fe"], "gc": ["cr", "cdn", " da", "gu", " bc", " acc", "gd", "sg", "bb", "pg", " g", "g", " cc", "cca", "conn", "GC", "gm", "wd", "gb", "reg", "ag", "gp", " func", "gt", "cc", "ac", "bc", "gas", "ha", "bg", " ac", "ig", "sync", "rc", " cm", "gg", "ic", "ctx", "ga", "sb", "dc", "pc", " mc", "kw", " ss", "nc", "grad", "vg", " sn", "rg", " proc", "gz", "cm", "cache", "lc", " ec", "jc", "mc"], "geo": [" geonet", " geoa", "nebo", "ceonet", "sei", "seos", " Geol", "Gei", "gebo", "ceo", "geonet", "Geoa", "genometry", "cheometry", " gei", "geos", " geot", "neo", "gateod", " geos", "Gebo", "neu", "ceos", "genos", "geometry", " gebo", " geol", "cheos", "Geot", "geology", "gateos", "geoa", "demos", "gateot", "geol", "nei", " Geos", " Geot", "geod", "seu", " Geo", "geu", "genology", " geology", "Geos", "geno", "ceod", "neos", "Geol", " geod", "demi", "cheo", "gateo", "gateonet", "geot", "gei", "seo", "demu", "gateoa", "demo", "cheology", " geometry", "Geo"], "ret": ["over", "base", "true", "af", "fail", "t", "x", "net", "ref", "arg", "reg", "gt", "code", "al", "end", "att", "err", "re", "url", "let", "arr", "flag", "val", "id", "Ret", "hard", "f", "ut", "res", "bf", "det", "ner", "lt", "en", "art", "error", "back", "mt", "rf", "bad", "ext", "len", "alt", "test", "def", "nt", "pat", "data", "status", "rt", "rc", "fun", "fin", "cat", "et", "result", "success", "reset", "pass", "active", "info", "run", "lit", "off", "rets", "nat", "RET", "ft", "rev", "feat", "pet"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc)\n\n{\n\n    unsigned cb;\n\n    uint8_t  *tmp_vlc_bits;\n\n    uint32_t *tmp_vlc_codes;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t *codebook_multiplicands;\n\n    int ret = 0;\n\n\n\n    vc->codebook_count = get_bits(gb, 8) + 1;\n\n\n\n    av_dlog(NULL, \" Codebooks: %d \\n\", vc->codebook_count);\n\n\n\n    vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks));\n\n    tmp_vlc_bits  = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits));\n\n    tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes));\n\n    codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands));\n\n\n\n    for (cb = 0; cb < vc->codebook_count; ++cb) {\n\n        vorbis_codebook *codebook_setup = &vc->codebooks[cb];\n\n        unsigned ordered, t, entries, used_entries = 0;\n\n\n\n        av_dlog(NULL, \" %u. Codebook\\n\", cb);\n\n\n\n        if (get_bits(gb, 24) != 0x564342) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook setup data corrupt.\\n\", cb);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        codebook_setup->dimensions=get_bits(gb, 16);\n\n        if (codebook_setup->dimensions > 16 || codebook_setup->dimensions == 0) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook's dimension is invalid (%d).\\n\",\n\n                   cb, codebook_setup->dimensions);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        entries = get_bits(gb, 24);\n\n        if (entries > V_MAX_VLCS) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook has too many entries (%u).\\n\",\n\n                   cb, entries);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        ordered = get_bits1(gb);\n\n\n\n        av_dlog(NULL, \" codebook_dimensions %d, codebook_entries %u\\n\",\n\n                codebook_setup->dimensions, entries);\n\n\n\n        if (!ordered) {\n\n            unsigned ce, flag;\n\n            unsigned sparse = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" not ordered \\n\");\n\n\n\n            if (sparse) {\n\n                av_dlog(NULL, \" sparse \\n\");\n\n\n\n                used_entries = 0;\n\n                for (ce = 0; ce < entries; ++ce) {\n\n                    flag = get_bits1(gb);\n\n                    if (flag) {\n\n                        tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n                        ++used_entries;\n\n                    } else\n\n                        tmp_vlc_bits[ce] = 0;\n\n                }\n\n            } else {\n\n                av_dlog(NULL, \" not sparse \\n\");\n\n\n\n                used_entries = entries;\n\n                for (ce = 0; ce < entries; ++ce)\n\n                    tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n            }\n\n        } else {\n\n            unsigned current_entry  = 0;\n\n            unsigned current_length = get_bits(gb, 5) + 1;\n\n\n\n            av_dlog(NULL, \" ordered, current length: %u\\n\", current_length);  //FIXME\n\n\n\n            used_entries = entries;\n\n            for (; current_entry < used_entries && current_length <= 32; ++current_length) {\n\n                unsigned i, number;\n\n\n\n                av_dlog(NULL, \" number bits: %u \", ilog(entries - current_entry));\n\n\n\n                number = get_bits(gb, ilog(entries - current_entry));\n\n\n\n                av_dlog(NULL, \" number: %u\\n\", number);\n\n\n\n                for (i = current_entry; i < number+current_entry; ++i)\n\n                    if (i < used_entries)\n\n                        tmp_vlc_bits[i] = current_length;\n\n\n\n                current_entry+=number;\n\n            }\n\n            if (current_entry>used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \" More codelengths than codes in codebook. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n        }\n\n\n\n        codebook_setup->lookup_type = get_bits(gb, 4);\n\n\n\n        av_dlog(NULL, \" lookup type: %d : %s \\n\", codebook_setup->lookup_type,\n\n                codebook_setup->lookup_type ? \"vq\" : \"no lookup\");\n\n\n\n// If the codebook is used for (inverse) VQ, calculate codevectors.\n\n\n\n        if (codebook_setup->lookup_type == 1) {\n\n            unsigned i, j, k;\n\n            unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions);\n\n\n\n            float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32));\n\n            float codebook_delta_value   = vorbisfloat2float(get_bits_long(gb, 32));\n\n            unsigned codebook_value_bits = get_bits(gb, 4) + 1;\n\n            unsigned codebook_sequence_p = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" We expect %d numbers for building the codevectors. \\n\",\n\n                    codebook_lookup_values);\n\n            av_dlog(NULL, \"  delta %f minmum %f \\n\",\n\n                    codebook_delta_value, codebook_minimum_value);\n\n\n\n            for (i = 0; i < codebook_lookup_values; ++i) {\n\n                codebook_multiplicands[i] = get_bits(gb, codebook_value_bits);\n\n\n\n                av_dlog(NULL, \" multiplicands*delta+minmum : %e \\n\",\n\n                        (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value);\n\n                av_dlog(NULL, \" multiplicand %u\\n\", codebook_multiplicands[i]);\n\n            }\n\n\n\n// Weed out unused vlcs and build codevector vector\n\n            codebook_setup->codevectors = used_entries ? av_mallocz(used_entries *\n\n                                                                    codebook_setup->dimensions *\n\n                                                                    sizeof(*codebook_setup->codevectors))\n\n                                                       : NULL;\n\n            for (j = 0, i = 0; i < entries; ++i) {\n\n                unsigned dim = codebook_setup->dimensions;\n\n\n\n                if (tmp_vlc_bits[i]) {\n\n                    float last = 0.0;\n\n                    unsigned lookup_offset = i;\n\n\n\n                    av_dlog(vc->avctx, \"Lookup offset %u ,\", i);\n\n\n\n                    for (k = 0; k < dim; ++k) {\n\n                        unsigned multiplicand_offset = lookup_offset % codebook_lookup_values;\n\n                        codebook_setup->codevectors[j * dim + k] = codebook_multiplicands[multiplicand_offset] * codebook_delta_value + codebook_minimum_value + last;\n\n                        if (codebook_sequence_p)\n\n                            last = codebook_setup->codevectors[j * dim + k];\n\n                        lookup_offset/=codebook_lookup_values;\n\n                    }\n\n                    tmp_vlc_bits[j] = tmp_vlc_bits[i];\n\n\n\n                    av_dlog(vc->avctx, \"real lookup offset %u, vector: \", j);\n\n                    for (k = 0; k < dim; ++k)\n\n                        av_dlog(vc->avctx, \" %f \",\n\n                                codebook_setup->codevectors[j * dim + k]);\n\n                    av_dlog(vc->avctx, \"\\n\");\n\n\n\n                    ++j;\n\n                }\n\n            }\n\n            if (j != used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \"Bug in codevector vector building code. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n            entries = used_entries;\n\n        } else if (codebook_setup->lookup_type >= 2) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \"Codebook lookup type not supported. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n// Initialize VLC table\n\n        if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Invalid code lengths while generating vlcs. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        codebook_setup->maxdepth = 0;\n\n        for (t = 0; t < entries; ++t)\n\n            if (tmp_vlc_bits[t] >= codebook_setup->maxdepth)\n\n                codebook_setup->maxdepth = tmp_vlc_bits[t];\n\n\n\n        if (codebook_setup->maxdepth > 3 * V_NB_BITS)\n\n            codebook_setup->nb_bits = V_NB_BITS2;\n\n        else\n\n            codebook_setup->nb_bits = V_NB_BITS;\n\n\n\n        codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits;\n\n\n\n        if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits,\n\n                            entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits),\n\n                            sizeof(*tmp_vlc_bits), tmp_vlc_codes,\n\n                            sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes),\n\n                            INIT_VLC_LE))) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Error generating vlc tables. \\n\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return 0;\n\n\n\n// Error:\n\nerror:\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return ret;\n\n}\n", "idx": 10175, "substitutes": {"vc": ["wl", "cdn", "dk", "qt", "ht", "bb", "sv", "cci", "lv", "nt", "iv", "fw", "vt", "service", "c", "vm", "serv", "data", "cu", "cli", "util", "cf", "VC", "wcs", "hw", "bc", "cc", "vp", "cs", "ctrl", "db", "rt", "nv", "cv", "ll", "v", "rc", "uv", "input", "gg", "ic", "voc", "ctx", "vd", "dc", "wx", "xc", "plugin", "vr", "nc", "sys", "cat", "vg", "client", "vv", "ci", "ant", "api", "lc", "cache", "cmd", "wd", "cy", "fc"], "cb": [" bc", "seq", "bb", "cmp", "abc", "nb", "ff", "abb", "hh", "CV", "tc", "dt", "b", "wb", "buf", "c", "cp", "fb", "batch", "config", "pb", "cd", "cf", "cn", "rb", "loc", "cod", "bc", "code", "db", "ctrl", "bf", "eb", "ctr", "cv", "lib", "CB", "sync", "rc", "uv", "gg", "cur", "abi", "lb", "callback", "sb", "dc", "cor", "tell", "kw", "node", " rc", "hub", "nc", "gc", "cm", "confirmed", "client", "ob", "url", "func", "lc", " callback", "obb", "cmd", "buff", "cell", "cgi", "kb", "kk", "uc"], "tmp_vlc_bits": ["tmp_vlc__bits", "tmp_vllc_pieces", "tmp_vllc__locks", "tmp_vlci_pieces", "tmp_vlc_pieces", "tmp_vllc__pieces", "tmp_vllc__bits", "tmp_vlc2pieces", "tmp_vlc2locks", "tmp_vlc__locks", "tmp_vlc_locks", "tmp_vllc_bits", "tmp_vllc_locks", "tmp_vllc__codes", "tmp_vlc2codes", "tmp_vlc__pieces", "tmp_vlc2bits", "tmp_vlc__codes", "tmp_vlci_codes", "tmp_vllc_codes", "tmp_vlci_bits", "tmp_vlci_locks"], "tmp_vlc_codes": ["tmp_vlc_flags", "tmp_vllc_code", "tmp_vlc2odes", "tmp_vlc__odes", "tmp_vlci_code", "tmp_vlc__code", "tmp_vlc_lines", "tmp_vllc_bits", "tmp_vllc_odes", "tmp_vlc2codes", "tmp_vlc_code", "tmp_vlci_lines", "tmp_vlci_odes", "tmp_vlc2bits", "tmp_vlc__codes", "tmp_vlci_flags", "tmp_vlc_odes", "tmp_vlci_codes", "tmp_vllc_codes", "tmp_vlci_bits", "tmp_vlc2flags", "tmp_vlc__flags", "tmp_vlc2code"], "gb": ["GB", "gram", "gu", "ui", "gd", "sg", "bb", "nb", "abb", "gpu", "bm", "gm", "wb", "gs", "gin", "pb", "gold", "gp", "rb", "gt", "yg", "hw", "bc", "gnu", "Gb", "gy", "db", "bf", "cgi", "eb", "bg", "cv", "agg", "lib", "py", "uv", "gg", "ctx", "lb", "ga", "sb", "pc", "storage", "usb", "hub", "hd", "cfg", "gc", "cm", "vg", "rg", "ci", "fc", "bn", "gz", "buff", "gam", "kb", "mb"], "codebook_multiplicands": ["codebook_multiplacanders", "codebook_multicAND", "codebook_multicityand", "codebook_multicands", "codebook_multiplificanders", "codebook_multicityands", "codebook_multicanders", "codebook_multiplacand", "codebook_multipliccides", "codebook_multiplacands", "codebook_multicityants", "codebook_multicants", "codebook_multicads", "codebook_multiplicityand", "codebook_multiplocand", "codebook_multacanders", "codebook_multiplificands", "codebook_multacand", "codebook_multiplicads", "codebook_multiplacAND", "codebook_multipliccands", "codebook_multiplocanders", "codebook_multicityAND", "codebook_multipliscands", "codebook_multicand", "codebook_multiplocands", "codebook_multipliccand", "codebook_multiplicanders", "codebook_multacads", "codebook_multipliscAND", "codebook_multiplicityides", "codebook_multiplicityants", "codebook_multiplificand", "codebook_multacands", "codebook_multiplicand", "codebook_multiplicants", "codebook_multiplificads", "codebook_multiplicityands", "codebook_multiplicAND", "codebook_multipliscand", "codebook_multiplicityAND", "codebook_multipliccAND", "codebook_multiplacants", "codebook_multiplocads", "codebook_multiplacides", "codebook_multiplicides", "codebook_multiplacads", "codebook_multipliscants"], "codebook_setup": ["codeblock_boot", "codebooks_setup", "codebooks_set", "codebooks_Setup", "codebookPsetup", "codebook_sett", "codebook___setup", "codebookPselect", "codebook___Setup", "codebookPconstruct", "codebookPset", "codebook_Setup", "codebook_reset", "codebookallset", "codebookFSetup", "codebooks_reset", "codebooks_sett", "codebook___sett", "codeblock_set", "codebookallselect", "codebook_ctx", "codeblock_init", "codebook_construct", "codebook_select", "codebook_boot", "codebook_init", "codebook_config", "codebookFsetup", "codebooks_construct", "codebookFctx", "codebookallsetup", "codebooks_select", "codeblock_setup", "codebook_set", "codebooks_config", "codebookallconstruct"], "ordered": [" bc", " acc", "seq", "bb", "g", "val", " resp", " row", "id", " arr", " ref", " tid", "rb", "bc", "bf", "py", "bg", "cv", " rg", "CB", "rc", "gg", " dc", " rc", "cat", " rows", "row", " callback", " rec"], "t": ["ts", "ext", "n", "g", "len", "trial", "m", "dt", "total", "tt", "b", "wt", "c", "s", "p", "e", "f", "T", "v", "ti", "r", "att", "port", "tn", " ret", "type", "back"], "entries": ["detresses", " entresses", "countried", "entried", "countries", "Entresses", "ntrations", "ntensions", "ntrys", "detrys", "Entures", "antensions", "Entrys", "rentries", "rentures", " entrys", "countrys", "Entensions", "rentensions", "detensions", " entensions", "detries", "entures", "gestrations", "ntries", "gestrys", "entrations", "antried", "intensions", "anties", "counties", "gestensions", "Enties", "entresses", "enties", "Entried", "entensions", "entrys", "renties", "antrations", "intures", "gestries", "inties", "antrys", "antries", "intries", "Entries"], "used_entries": ["used_renties", "used_gestries", "used_tions", "used_rentrows", "used_rentries", "used_rentions", "used_gestrows", "used_ties", "used_tries", "used_entrows", "used_gestions", "used_gesties", "used_entions", "used_trows", "used_enties"]}}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "substitutes": {"f": ["l", "uf", "rf", "conf", "xf", "fo", "fen", "g", "ff", "af", "sf", "w", "m", "fr", "fd", "t", "b", "files", "fw", "d", "i", "c", "fb", "s", "p", "e", "fp", "exec", "feed", "cf", "df", "fm", "bf", "tf", "v", "r", "framework", "elf", "this", "fn", "form", "F", "file", "fs", "func", "fi", "fe", "fc"], "spapr": ["sphapri", "Spaperb", "scaprb", "spapener", "spakr", "yparpner", "chapr", "scapsra", "sppplr", "spaperr", "scapprn", "ypapner", "sparpner", "spavner", "sessionaprs", "sppprc", "spopril", "spaprb", "paprb", "spaperrb", "spakrb", "spafR", "spapar", "spaptrar", "slarprc", "chapar", "spacrar", "sparpra", "spappR", "slapri", "spashrn", "spaplr", "spapersr", "asphapri", "spappner", "spappri", "sppprs", "slapr", "spashrar", "scaprc", "spippr", "spakrn", "spAPrc", "scapprg", "sessionapru", "spapran", "spapsrc", "spajrar", "yparpra", "spaperR", "spajra", "papR", "spacrc", "Spapr", "spashra", "asphapru", "chaprar", "spappr", "sphapr", "spAPsr", "sessionppr", "spoprar", "spacar", "sparprar", "chopril", "pAPrb", "pAPr", "spaptri", "yparpr", "spppru", "spAPr", "Spaperc", "spapsrin", "spaprin", "pAPR", "spafra", "spaptr", "papsr", "sessionpprs", "spapsra", "spapsri", "spapprn", "scaprn", "ypapr", "sessionaplr", "spashr", "spacra", "scapprb", "papr", "aspapri", "sparpru", "sessionpplr", "spaptar", "aspapr", "slarpri", "spaper", "sparprg", "ypapra", "spafrc", "scaprg", "spaprc", "slaprc", "spapplr", "spappsr", "spaprs", "spacner", "spavr", "spavrc", "speprs", "speplr", "spepru", "ypaprar", "sessionppru", "spappru", "slarpr", "sparpri", "spajrn", "spampran", "spapru", "sphaprs", "scapsR", "spipprin", "spacril", "Spapran", "spapprs", "spapsran", "spapprc", "spappra", "aspapru", "spppr", "spippran", "scappr", "Spapsrin", "asphaprs", "scapprc", "spapner", "Spaper", "Spapsran", "spacr", "scapru", "Spapner", "chopr", "pAPsr", "yparprc", "sppprg", "scapsrc", "spapri", "choprar", "spapprg", "spajr", "spapril", "ypaprc", "spAPrn", "scapR", "chapril", "spapsr", "aspaprs", "asphapr", "spAPR", "sessionapr", "spapra", "spopr", "spaprar", "scapsr", "spopar", "ypaprn", "yparprar", "spapsR", "sparpr", "spaprn", "Spaprb", "sphapru", "spapR", "spAPra", "spepr", "scapra", "spakrc", "spapprb", "yparprn", "sparprc", "spaperc", "spamprin", "spavrb", "sparprn", "spaperb", "scappru", "spafr", "scapr", "spaprg", "Spaprin", "spaptril", "Spapsr", "spaptru", "Spapener", "spaptrs", "spampr", "Spaprc", "spAPrb", "chopar"], "max_ns": ["max_nas", "max_bs", "max__ls", " max_mins", "max_ls", "maxFbs", " max_nas", " max_ls", "maxFls", " max_rss", "max__rss", "max__ns", "maxFnas", "max_mins", "max__mins", " max_bs", "max_rss", "maxFns"], "chunkstart": [" chorkstop", " chorkstart", "Chunksstart", " ChunkStart", "chiffstyle", "chiffstarting", "Chunkstart", "shankend", "chanstop", " Chunkend", "chaultstarting", "chacketsize", " chunkinit", " chaultstyle", "chashstop", "chankst", "chacketinit", "chunkstop", " chunkstarting", "chanstart", "ChunksStart", "chacketStart", " Chanstart", "chacketstop", " ChanStart", "chaultstyle", " chunkpad", "chipstart", "hacketset", "Chunksize", "hunkend", "chaultstop", "chacksize", "Chunkend", "Chunksset", "shankst", "chacketpad", " chaultstart", "Chunksend", "chanStart", "chackst", "chackStart", " Chunkstop", "chunkpad", "chunksstop", "chunkend", "chackend", "hunkset", "chunksset", " Chunkstart", "chunkset", "chackset", "chunksstart", " chaultstop", "shankStart", "chunkstarting", "chorkpad", "chunkssize", " chorkpad", "chunksend", "chackstart", " Chanstop", "chashstart", "shunkst", "chankstart", " Chanend", "chipStart", "chorkstart", "chorkstyle", "chipend", "chorkstarting", "chorkstop", "chashpad", "chanend", "chankStart", "hunkStart", "chiffstop", " chunkstyle", "chankset", "chaultstart", "hunkstart", "chunksStart", "hacketend", " chaultstarting", "chunkst", " chunkstop", "chacketend", "chunkStart", "shunkstart", "chankend", "Chunkssize", "chacketstart", "chunksize", "chunkstyle", "hacketstart", "chorkinit", " chorkinit", "ChunkStart", "chiffstart", "shankstart", "chipset", "hacketStart", "shunkStart", "chunkinit", "Chunkset", "chacketset", "chashinit", "shunkend"], "invalidstart": ["inbrokenoffset", "Incompleteend", "Incompletestar", "invalidstop", "invalidindex", "nvalstop", "INcompatiblestarted", "Invalidend", "insecurestart", "nvalidend", "incompletestop", "inasticend", "invalidend", "nvalstart", "incompatibleindex", "nvalidstop", "inlegalStart", "infreshstart", "invalidoffset", "INvalidoffset", "INcompatibleoffset", "inlegalindex", "invalend", "inbrokenstarted", " inbrokenStart", " invalidset", "INvalidstart", " invalidindex", "incompatiblestarted", "nvalidstart", "infreshstarted", "incompleteset", "insecureset", "infreshindex", "invalidset", "INcompatibleindex", "inbadset", "insecureend", "insecurestar", "inasticoffset", "incompleteoffset", "Invalidstar", "incompleteend", "inbrokenset", "Incompleteset", "INvalidstarted", "INvalidindex", "incompletestart", "inbrokenstart", "nvalend", "Invalidstart", "inbadindex", "inasticstart", "inregularset", "INcompatiblestart", "nvaloffset", "inbrokenindex", "invaloffset", "inregularstar", "invalidStart", "inbadStart", "invalstart", "inasticstop", "inregularend", "Invalidset", "nvalidoffset", "incompatibleoffset", "incompletestar", "inlegalset", "inregularstart", "inbrokenStart", "inbadstart", "invalidstar", "infreshoffset", " inbrokenindex", " inbrokenset", "inlegalstart", "invalidstarted", " inbrokenstart", "Incompletestart", " invalidStart", "invalstop", "incompatiblestart"], "index": ["count", "updated", "connect", "section", "find", "point", "connected", "path", "x", "de", "block", "config", "thread", "set", "condition", "loc", "body", "found", "connection", "end", "document", "offset", "form", "type", "online", "localhost", "element", "dim", "si", "n", "date", "key", "view", "id", "open", "total", "i", "expression", "output", "request", "value", "unit", "slice", "ind", "input", "current", "example", "position", "list", "error", "ticket", "root", "insert", "fix", "opened", "context", "initial", "len", "temp", "second", "page", "num", "add", "action", "socket", "alpha", "version", "column", "sync", "old", "part", "available", "cache", "engine", "weight", "diff", "original", "active", "start", "axis", "ini", "Index", "update", "run", "ix", "search", "route", "inc", "name", "address", "option", "pos", "length", "match", "pattern"], "examined": ["exAMine", "exambining", "xambined", "exAMinated", "examritten", "examine", "exummented", "xamided", "exambinated", "exasmritten", "examinated", " exummented", "exAMining", " exambined", " examinated", " examine", "ExAMined", " exambritten", "exAMored", "xambine", " exambinated", "exAMmented", "exAMined", "examinining", "exambored", "exameinated", "exambmented", "examining", "ExAMored", " exumined", "examinined", "exambined", "Examined", "exasmmented", "Examine", "Examining", "examinored", "xamine", "examored", "exameine", " exammented", " exumine", " examritten", "xaminated", "exameided", "exAMritten", " exuminated", "exameined", "examinine", "exambided", "xamined", "exAMided", "exasminated", " exambmented", "exumine", "xambided", "exambine", "xambinated", "ExAMine", "exasmined", "exuminated", "ExAMining", "examided", "exammented", "Examored", "exambritten", "exumined"]}}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 10190, "substitutes": {"domain": ["parent", "count", "channel", "conf", "base", "Domain", "flag", "category", "country", "dom", "prefix", "class", "key", "id", "model", "origin", "net", "rule", "uri", "server", "component", "target", "role", "cn", "table", "dn", "title", "brand", "mode", "host", "db", "dir", "code", "unit", "mid", "version", "module", "format", "name", "magic", "feature", "example", "address", "bot", "root", "plugin", "controller", "command", "handler", "file", "site", "cmd", "ype", "cart", "core", "force", "range"], "type": ["parent", "kind", "base", "field", "class", "key", "test", "id", "method", "info", "like", "t", "Type", "rule", "p", "server", "ref", "target", "role", "pe", "value", "style", "table", "types", "op", "none", "host", "unit", "o", "py", "version", "module", "format", "name", "state", "address", "port", "ty", "part", "ping", "TYPE", "plugin", "link", "platform", "file", "null", "api", "client", "url", "site", "y", "ype", "typ"], "protocol": [" proturl", "staturl", "proturl", "inetotype", "statotype", "Protose", "topicle", "topocol", "ocolocol", " protose", "platformicle", "lifect", "ocolurl", "typeect", "platformocol", "lifocol", "protect", "ocolotype", "proticle", "lifose", " protport", "protport", "pathocol", "statocol", "Proticle", "pathotype", "platformport", "inetect", "Protocol", "Protport", " prototype", "inetocol", "protose", " protect", "lifport", "typeocol", "pathect", "prototype", "topport", "typeotype", "Protect"], "ret": ["sp", "base", "net", "ref", "arg", "reg", "gt", "code", "al", "opt", "att", "err", "pret", "re", "url", "resp", "fi", "fab", "flag", "val", "Ret", "mem", "addr", "fit", "value", "f", "db", "res", "bf", "py", "det", "format", "en", "art", "rep", "fire", "back", "mt", "std", "str", "ext", "alt", "len", "def", "nt", "bare", "pat", "data", "reply", "status", "rt", "rc", "fun", "part", "sb", "cat", "sys", "result", "sr", "success", "repl", "pass", "valid", "active", "info", "sur", "job", "run", "obj", "lit", "rets", "nat", "bit", "RET", "ft", "rev", "match", "pet"]}}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n", "idx": 10192, "substitutes": {"env": ["runner", "conf", "visor", "context", "ext", "dict", "conn", "que", "viron", "serv", "environment", "config", "server", "obj", "ace", "cli", "e", "np", "args", "ec", "priv", "eni", "ev", "exc", "ea", "virt", "exe", "req", "loader", "en", "err", "eng", "enc", "init", "esp", "cfg", "fs", "cache", "anc", "eu", "proc", "core", "eve", "exec"], "buf": ["bag", "uf", "mac", "seq", "Buffer", "base", "len", "ff", "fd", "b", "que", "mem", "pool", "fi", "data", "cp", "fb", "batch", "bd", "ref", "pb", "config", "cb", "queue", "feed", "cf", "rb", "array", "bc", "alloc", "cv", "Buff", "msg", "rc", "cas", "raw", "ctx", "blocks", "func", "vec", "buff", "cmd", "br", "buffer", "uc"], "buf_len": ["bufspos", "buf_pos", "buf_size", " buf_val", " buf_size", " buf_length", "bufsval", "buflenpos", "bufsdl", "buflendl", "buf_dl", "bufslen", "buflenlen", " buf_pos", "buf_val", " buf_dl", "bufssize", "buflenlength", "buf_length", "bufslength"], "cpu": [" cp", "cow", "cca", "processor", "conn", "gpu", "bench", "instance", "pid", "cp", "vm", "c", "cu", "computer", "np", "uci", "cn", "cf", "hw", "bc", "pai", "linux", "mc", "rc", "ctx", "pu", "pc", "cpp", "CPU", "nc", "px", "css", "cache", "lc", "proc", "core", "cus"], "cs": ["vs", "utils", "co", "ks", "ds", "conn", "gs", "c", "cp", "ls", "qs", "cf", "cn", "ec", "bc", "cc", "os", "sk", "cus", "acs", "ck", "sync", "CS", "cons", "ics", "ctx", "ns", "pc", "spec", "cms", "sys", "nc", "ca", "ci", "ps", "fs", "css", "vc", "lc", "bs", "mc", "sc", "Cs"], "hc": [" hv", "hcf", "hpc", "khc", "hardpc", "hardc", "hrc", "hhpc", "ohcf", "Hc", "Hv", "hhc", " hf", " hec", "hardcf", "whec", "hcu", "ohpc", "ohv", " hcu", "rhf", "rhc", "ohc", "hardcu", "Hcall", "Hcs", " hrc", "qf", " hpc", "qcu", "khec", " hcs", "khf", "rhcu", "whf", "whc", "ohlc", " hcf", "ohcu", "khcu", "qrc", "hlc", " hlc", "rhrc", "hv", "Hlc", "whcu", "qc", "hhcs", "hec", "hf", " hcall", "hhcall", "hcs", "Hpc", "hcall"], "pvinfo": ["pdenfam", "pevinbo", " pininfo", "pevinco", "pevinfam", "pcinbo", " pevininfo", " pevinco", "pwinfi", " pwinfi", "pinbo", "pvinfam", " pinfo", "pinfo", " pwinf", "pdenfo", "pevinfi", "pwinfo", "pvinco", " pvininfo", "pcininfo", " pevinf", "pdenf", "pvinfi", "pwinco", " pwinfam", " pvinbo", " pvinf", "pvinf", " pwinfo", "pevininfo", "pwinfam", "pcinfo", "pwininfo", "pvininfo", "pininfo", " pvinfi", " pvinco", " pinbo", "pinf", "pevinf", " pvinfam", " pevinfo", "pvinbo", "pwinf", "pcinf", "pevinfo", "pcinco", "pdenfi", " pinf"]}}
{"project": "qemu", "commit_id": "1bcef683bf840a928d633755031ac572d5fdb851", "target": 0, "func": "void process_incoming_migration(QEMUFile *f)\n\n{\n\n    if (qemu_loadvm_state(f) < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        exit(0);\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    incoming_expected = false;\n\n\n\n    if (autostart) {\n\n        vm_start();\n\n    } else {\n\n        runstate_set(RSTATE_PRE_LAUNCH);\n\n    }\n\n}\n", "idx": 10194, "substitutes": {"f": ["l", "rf", "fo", "fen", "g", "ff", "af", "sf", "m", "fr", "info", "fd", "files", "t", "b", "fw", "i", "c", "fb", "p", "ref", "e", "fp", "exec", "feed", "df", "fa", "fm", "tf", "v", "fn", "F", "file", "fs", "inf", "proc", "fi", "fc"]}}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv40_decode_mb_info(RV34DecContext *r)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int q, i;\n\n    int prev_type = 0;\n\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n\n    int blocks[RV34_MB_TYPES] = {0};\n\n    int count = 0;\n\n\n\n    if(!r->s.mb_skip_run)\n\n        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;\n\n\n\n    if(--r->s.mb_skip_run)\n\n         return RV34_MB_SKIP;\n\n\n\n    if(r->avail_cache[6-1])\n\n        blocks[r->mb_type[mb_pos - 1]]++;\n\n    if(r->avail_cache[6-4]){\n\n        blocks[r->mb_type[mb_pos - s->mb_stride]]++;\n\n        if(r->avail_cache[6-2])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;\n\n        if(r->avail_cache[6-5])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;\n\n    }\n\n\n\n    for(i = 0; i < RV34_MB_TYPES; i++){\n\n        if(blocks[i] > count){\n\n            count = blocks[i];\n\n            prev_type = i;\n\n        }\n\n    }\n\n    if(s->pict_type == AV_PICTURE_TYPE_P){\n\n        prev_type = block_num_to_ptype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for P-frame\\n\");\n\n    }else{\n\n        prev_type = block_num_to_btype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for B-frame\\n\");\n\n    }\n\n    return 0;\n\n}\n", "idx": 10213, "substitutes": {"r": ["cr", "rf", "l", "ru", "str", "tr", "rd", "g", "hr", "w", "m", "fr", "mr", "rr", "b", "t", "kr", "gr", "d", "ra", "c", "nor", "p", "e", "usr", "rss", "wr", "or", "ir", "rb", "rs", "er", "f", "lr", "dr", "rt", "res", "o", "v", "R", "rc", "ar", "pr", "err", "nr", "rar", "ur", "re", "h", "self", "rg", "result", "sr", "br", "rh", "per"], "s": ["l", "session", "is", "m", "http", "t", "z", "gs", "er", "sy", "v", "port", "ns", "spec", "self", "params", "settings", "ed", "sg", "ds", "n", "si", "sf", "w", "b", "c", "e", "se", "args", "sq", "us", "f", "sym", "res", "es", "sup", "en", "storage", "u", "rates", "fs", "su", "site", "ps", "ss", "down", "sc", "ks", "g", "stats", "ops", "d", "ls", "os", "share", "cs", "o", "sync", "south", "sl", "sb", "sys", "side", "secondary", "a", "sr", "ssl", "conf", "ts", "rows", "service", "p", "server", "rs", "js", "sec", "an", "S", "services", "sing", "support", "submit", "less", "h", "ses", "y", "inf"], "gb": ["GB", "gram", "sg", "gd", "ui", "bb", "pg", "nb", "g", "abb", "bp", "gpu", "bm", "gm", "gs", "bridge", "vm", "gin", "hm", "pb", "cb", "ub", "gl", "gp", "rb", "bc", "binary", "gy", "db", "bf", "eb", "bg", "cv", "rc", "gg", "ctx", "ga", "gam", "sb", "pc", "storage", "usb", "git", "hub", "tm", "gru", "gc", "cfg", "cm", "rg", "vg", "ge", "mc", "buffer", "kb", "sc", "mb"], "q": [" p", "l", "count", "dq", "qt", "n", "g", "comment", "w", "id", "b", "t", "k", "z", "que", "d", "iq", "c", "qu", "max", "p", "qq", "ct", "qs", "e", "qa", "queue", "config", "quality", "value", "bug", "ue", "sq", "f", "eq", "code", "o", " query", "quant", "v", "ce", "query", "cur", "req", "qi", "cl", "offset", "ime", "bit", "u", "type", "h", "Q", "ch", "y", "question"], "i": ["count", "l", "oi", "diff", "hi", "ui", "di", "it", "start", "n", "g", "si", "zi", "info", "m", "id", "xi", "b", "k", "ini", "t", "x", "d", "c", "p", "ix", "e", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "ti", "phi", "chi", "qi", "bi", "pi", "part", "ii", "init", "u", "type", "I", "li", "ip", "ci", "ni", "io", "y", "fi", "iu"], "blocks": ["loads", "stars", "maps", "stores", "words", "guards", "frames", "images", "rows", "nos", "lbs", "builders", "heads", "stats", "shows", "boxes", "files", "ocks", "flows", "works", "rooms", "block", "bags", "bars", "views", "jobs", "cb", "ins", "runs", "bands", "bits", "objects", "pages", "outs", "types", "lines", "errors", "plugins", "sections", "breakers", "limits", "items", "BL", "rules", "balls", "Blocks", "values", "books", "checks", "results", "locks", "cycles", "groups", "holes", "waves", "bytes", "girls", "ions", "times", "bs", "units"], "mb_skip_run": ["mb_skipayruns", "mb_run_num", "mb_skip_min", "mb_run_unit", "mb_run_min", "mb_skipprun", "mb_skip_num", "mb_skipppos", "mb_run_start", "mb_skipacttype", "mb_run_runner", "mb_skipaymin", "mb_skippnum", "mb_skippruns", "mb_skipactrun", "mb_run_run", "mb_skipayrun", "mb_skip_type", "mb_skip_runner", "mb_run_pos", "mb_skipaystart", "mb_run_runs", "mb_skip_start", "mb_skip_runs", "mb_skipactrunner", "mb_skipactunit", "mb_run_type", "mb_skip_unit", "mb_skip_pos"], "mb_type": ["ym_model", "phrase_shape", "mbppnumber", "mbppstyle", "ym_position", "mp_shape", "ambjtype", "mbjtypes", "mbuchposition", "ambjfamily", "mbuchmodel", "mbpshape", "mbjfamily", "phrasepltotal", "mb_position", "mb_number", "mb_family", "mbppcache", "ym_pos", "mbjnumber", "mp_style", "mbpltype", "ambjnumber", "mbppshape", "mp_cache", "mbpnumber", "amb_family", "mb_shape", "phrase_number", "phraseplshape", "mbplnumber", "ambjtypes", "mbpptype", "mbptotal", "mb_cache", "mb_style", "phrase_type", "mbpptotal", "phrasepltype", "mb_types", "mbpltotal", "mbuchpos", "phraseplnumber", "mbjtype", "mb_model", "amb_number", "mbuchtype", "amb_type", "mbptype", "amb_types", "ym_type", "mbplshape", "phrase_total", "mb_total", "mp_type"], "mb_pos": ["bb_val", "mbjloc", "mb_unit", "bgJlen", "mb_val", "mbJlen", "MB_neg", "mb_position", "MB_position", "bgJpos", "mbjval", "mb_neg", "mb2loc", "mb_po", "mbJpos", "bb_position", "mb_offset", "mb_size", "mbJpart", "mb2offset", "bb_loc", "bg_len", "mb2val", "mbjoffset", "bgJsin", "mb_sin", "bb_unit", "bb_len", "bgJpart", "mb2pos", "mbjpos", "mbJpad", "mbJsin", "mb_loc", "bb_offset", "bg_sin", "MB_loc", "bb_po", "bg_pos", "mb_pad", "mbJunit", "bb_pad", "bb_size", "MB_pos", "bb_pos", "bg_part", "mb_len", "mb_part"], "mb_stride": ["mb_bride", "mb_strision", "mb_splride", "mb_brride", "mb_trision", "mb_tride", "mb_trIDE", "mb_splage", "mb_blided", "mb_strider", "mb_trides", "mb_shrision", "mb_slide", "mb_splide", "mb_trid", "mb_slider", "mb_strase", "mb_brides", "mb_strage", "mb_distade", "mb_blide", "mb_trided", "mb_strid", "mb_brision", "mb_strade", "mb_slride", "mb_striided", "mb_strIDE", "mb_blIDE", "mb_distided", "mb_brid", "mb_striade", "mb_shrid", "mb_strride", "mb_brIDE", "mb_shrided", "mb_distide", "mb_striide", "mb_brase", "mb_brade", "mb_striase", "mb_blides", "mb_splider", "mb_brider", "mb_strides", "mb_strided", "mb_shride", "mb_brage", "mb_distase", "mb_slage", "mb_brided"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,\n\n                                        uint8_t *dst,\n\n                                        long width, long height,\n\n                                        long srcStride1, long srcStride2,\n\n                                        long srcStride3, long dstStride)\n\n{\n\n    x86_reg x;\n\n    long y,w,h;\n\n    w=width/2; h=height;\n\n    for (y=0;y<h;y++) {\n\n        const uint8_t* yp=src1+srcStride1*y;\n\n        const uint8_t* up=src2+srcStride2*(y>>2);\n\n        const uint8_t* vp=src3+srcStride3*(y>>2);\n\n        uint8_t* d=dst+dstStride*y;\n\n        x=0;\n\n#if COMPILE_TEMPLATE_MMX\n\n        for (;x<w-7;x+=8) {\n\n            __asm__ volatile(\n\n                PREFETCH\"   32(%1, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%2, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%3, %0)          \\n\\t\"\n\n                \"movq      (%1, %0, 4), %%mm0   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq         (%2, %0), %%mm1   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq         (%3, %0), %%mm2   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"movq            %%mm0, %%mm3   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq            %%mm1, %%mm4   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq            %%mm2, %%mm5   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"punpcklbw       %%mm1, %%mm1   \\n\\t\" /* U0U0 U1U1 U2U2 U3U3 */\n\n                \"punpcklbw       %%mm2, %%mm2   \\n\\t\" /* V0V0 V1V1 V2V2 V3V3 */\n\n                \"punpckhbw       %%mm4, %%mm4   \\n\\t\" /* U4U4 U5U5 U6U6 U7U7 */\n\n                \"punpckhbw       %%mm5, %%mm5   \\n\\t\" /* V4V4 V5V5 V6V6 V7V7 */\n\n\n\n                \"movq            %%mm1, %%mm6   \\n\\t\"\n\n                \"punpcklbw       %%mm2, %%mm1   \\n\\t\" /* U0V0 U0V0 U1V1 U1V1*/\n\n                \"punpcklbw       %%mm1, %%mm0   \\n\\t\" /* Y0U0 Y1V0 Y2U0 Y3V0*/\n\n                \"punpckhbw       %%mm1, %%mm3   \\n\\t\" /* Y4U1 Y5V1 Y6U1 Y7V1*/\n\n                MOVNTQ\"          %%mm0,  (%4, %0, 8)    \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 8(%4, %0, 8)    \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm2, %%mm6   \\n\\t\" /* U2V2 U2V2 U3V3 U3V3*/\n\n                \"movq     8(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U2 Y V2 Y U2 Y V2*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U3 Y V3 Y U3 Y V3*/\n\n                MOVNTQ\"          %%mm0, 16(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 24(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"movq            %%mm4, %%mm6   \\n\\t\"\n\n                \"movq    16(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm5, %%mm4   \\n\\t\"\n\n                \"punpcklbw       %%mm4, %%mm0   \\n\\t\" /* Y U4 Y V4 Y U4 Y V4*/\n\n                \"punpckhbw       %%mm4, %%mm3   \\n\\t\" /* Y U5 Y V5 Y U5 Y V5*/\n\n                MOVNTQ\"          %%mm0, 32(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 40(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm5, %%mm6   \\n\\t\"\n\n                \"movq    24(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/\n\n                MOVNTQ\"          %%mm0, 48(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 56(%4, %0, 8)   \\n\\t\"\n\n\n\n                : \"+r\" (x)\n\n                : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d)\n\n                :\"memory\");\n\n        }\n\n#endif\n\n        for (; x<w; x++) {\n\n            const long x2 = x<<2;\n\n            d[8*x+0] = yp[x2];\n\n            d[8*x+1] = up[x];\n\n            d[8*x+2] = yp[x2+1];\n\n            d[8*x+3] = vp[x];\n\n            d[8*x+4] = yp[x2+2];\n\n            d[8*x+5] = up[x];\n\n            d[8*x+6] = yp[x2+3];\n\n            d[8*x+7] = vp[x];\n\n        }\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n#endif\n\n}\n", "idx": 10233, "substitutes": {"src1": ["rc2", "st1", " src01", "src01", "rc1", "source1", "source01", "source3", "loc3", " srcA", "st3", "sourceA", "loc1", "srcA", "stA", "rc3", "loc2", "st01"], "src2": ["const02", "src0", "rc02", "srcTwo", "rc2", "const2", "sort02", "src02", " srcTwo", "source02", " src0", "sort0", "sort2", "source2", "sourceTwo", "constTwo", " src02", "rc0"], "src3": ["rc2", "source5", "rc1", "source1", "rc53", "source2", "source3", "source53", "rc5", "src5", "src53", " src5", " src53", "rc3"], "dst": [" dsc", "dost", " dconst", "rdst", "Dsc", "dsc", "rdsts", "Dsts", "dconst", "pdost", " dsts", " dST", "pdST", "Dst", "Dconst", "dsts", "pdst", "rdconst", "dST", "rdsc", " dost", "pdsc"], "height": ["rank", "dim", "sh", "img", "window", "z", "resolution", "fw", "density", "work", "max", "layout", "thin", "style", "gravity", "padding", "Height", "th", "size", "shape", "hold", "stroke", "v", "input", "ty", "hd", "crop", "length", "image", "inches", "depth", "dy", "direction"], "srcStride1": ["srcScrite3", "srcShride1", "srcScrite1", "srcStriteOne", "srcStide1", "srcStrue1", "srcStri1", "srcStrueOne", "srcStrip2", "srcShrue1", "srcStide2", "srcScride3", "srcStrite2", "srcScride2", "srcScrite2", "srcShrideOne", "srcStrip1", "srcStri2", "srcShrueOne", "srcStide3", "srcShride2", "srcShride3", "srcStideOne", "srcStrite1", "srcStrue2", "srcShrue2", "srcStri3", "srcStrite3", "srcStrue3", "srcScride1", "srcStrip3", "srcStrideOne", "srcShrue3"], "srcStride2": ["srcStide8", "srcStrate1", "srcScrite1", "srcStrip52", "srcScride52", "srcStide1", "srcStrid4", "srcStrid2", "srcStrid1", "srcStrip2", "srcStriteTwo", "srcScrite4", "srcScride4", "srcSTrateTwo", "srcStide2", "srcStrite2", "srcScride2", "srcScrite2", "srcScrite52", "srcStrite52", "srcStrip4", "srcStride52", "srcSTride1", "srcSTride8", "srcSTrate2", "srcStideTwo", "srcStrateTwo", "srcSTrideTwo", "srcSTrate1", "srcStrite1", "srcSTride2", "srcStrideTwo", "srcStrate8", "srcStride8", "srcScride1", "srcStrite4", "srcStride4", "srcSTrate8", "srcStrid52", "srcStrate2", "srcStrip1", "srcStrite8"], "srcStride3": ["srcScrite7", "srcStrideN", "srcstrideThree", "srcStrlN", "srcStrideThree", "srcStide1", "srcStride7", "srcScride7", "srcsterve1", "srcStriteN", "srcStriteThree", "srcStrl3", "srcsterveThree", "srcStrl7", "srcsterve2", "srcStide2", "srcScride3", "srcStrite2", "srcStideThree", "srcScrite2", "srcScride2", "srcstride2", "srcStrl2", "srcStri2", "srcstride1", "srcSterve3", "srcStriN", "srcStide3", "srcSterveThree", "srcStrite7", "srcScriteN", "srcStrite1", "srcstride3", "srcStri3", "srcsterve3", "srcScrideN", "srcStrite3", "srcSterve2", "srcSterve1", "srcStri7", "srcScrite3"], "dstStride": ["dstShrate", "dstStide", "dstSTrb", "dstShrite", "dstRestride", "dstStrate", "dstShride", "drdStride", "dststrib", "dstRestrate", "drdStide", "drdSTide", "dstStrib", "dstStrite", "dstSTide", "drdStrate", "dstStrb", "dstSTrite", "dststrb", "drdSTrate", "dstSTride", "dndstride", "dstSTrib", "dndStride", "dstRestrb", "dststride", "drdSTrb", "dndstrate", "dstShrib", "dststrate", "dstRestide", "dststide", "dndstrib", "dststrite", "dstSTrate", "dndStrite", "dndStrib", "dndstrite", "dndStrate", "drdStrb", "drdSTride"], "x": ["l", "ady", "xp", "n", "g", "ax", "key", "xx", "id", "xi", "m", "t", "z", "b", "my", "i", "k", "con", "c", "s", "X", "p", "ix", "time", "e", "status", "ct", "python", "work", "cross", "xs", "q", "step", "xxx", "f", "j", "code", "index", "v", "yx", "sync", "zx", "fx", "ctx", "tx", "wx", "xc", "u", "ww", "xy", "rx", "px", "on", "sex", "image", "dx", "ex"], "y": ["ym", "ady", "yt", "oy", "n", "g", "ry", "ny", "yer", "t", "ey", "z", "vy", "b", "i", "ye", "c", "ys", "cy", "p", "e", "yi", "iy", "yang", "ay", "lat", "zy", "f", "yy", "sy", "j", "gy", "py", "iny", "sky", "ky", "yl", "yd", "hy", "Y", "ty", "ies", "yr", "yu", "yan", "year", "yah", "ya", "yn", "wy", "ity", "dy", "yo"], "w": ["wid", "l", "wn", "wl", "wp", "n", "g", "wa", "win", "m", "wh", "sw", "t", "z", "wt", "wb", "fw", "b", "c", "s", "p", "we", "e", "q", "hw", "v", "r", "wx", "kw", "aw", "u", "ww", "ew", "W", "weight", "wd"], "h": ["l", "hi", "sh", "ht", "n", "g", "ph", "wa", "hh", "m", "t", "b", "z", "i", "c", "s", "p", "hm", "e", "q", "hw", "f", "v", "r", "hs", "u", "H", "ch", "W", "rh", "uh"], "yp": ["lp", "dp", "ym", "sp", "yt", "wp", "pg", "xp", "iw", "wb", "pp", "cp", "ys", "pb", "fp", "ep", "np", "pe", "pt", "pm", "op", "yy", "dr", "omp", "mp", "py", "eps", "pr", "yd", "jp", "tp", "xt", "yu", "px", "ip", "ps", "yn", "dep", "typ", "cy"], "up": ["cr", "uf", "sp", "ui", "uph", "wp", "img", "xp", "in", "ul", "pp", "cp", "upp", "pt", "op", "upt", "mp", "ups", "uv", "sup", "aw", "u", "ps", "out", "url", "ch", "down", "um", "uc"], "vp": ["lp", "dp", "vs", "dq", "sp", "wp", "vl", "xp", "sv", "lv", "pp", "vt", "pb", "pd", "fp", "np", "gp", "pm", "pn", "mp", "uv", "eps", "pu", "tp", "jp", "vr", "vg", "vv", "vc"], "d": ["dp", "ld", "dim", "di", "dh", "ds", "n", "g", "m", "dt", "b", "t", "z", "c", "data", "bd", "p", "pd", "e", "cd", "dist", "dn", "f", "dl", "db", "dat", "v", "md", "yd", "dd", "dc", "sd", "dm", "dy", "dx", "D"]}}
{"project": "FFmpeg", "commit_id": "381e195b46d080aee1d9b05ef2b6b140e9463519", "target": 0, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n, i;\n\n    uint8_t *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    int32_t *dst_int32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n\n        /* we process 40-bit blocks per channel for LXF */\n\n        sample_size = 5;\n\n\n\n    if (sample_size == 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid sample_size\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        if (buf_size < n) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n            return -1;\n\n        }else\n\n            buf_size -= buf_size % n;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] +\n\n                           (av_reverse[v & 0xff] << 8));\n\n          samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++) {\n\n                AV_WN16A(samples, bytestream_get_le16(&src2[c]));\n\n                samples += 2;\n\n            }\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            *samples++ = *src++ + 128;\n\n        }\n\n        break;\n\n#if HAVE_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(64, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(64, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* HAVE_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples += n * sample_size;\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            AV_WN16A(samples, x << 8);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            AV_WN16A(samples, s->table[*src++]);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n        }\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    case CODEC_ID_PCM_LXF:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        //unpack and de-planerize\n\n        for (i = 0; i < n; i++) {\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract low 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n\n            }\n\n\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract high 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n\n            }\n\n        }\n\n        src += n * avctx->channels * 5;\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 10244, "substitutes": {"avctx": ["afconn", "avcv", "avalcontext", "avcmp", "avalctx", "evcf", "aveci", "avmac", "abcontext", "auctx", "AVcontext", "avcm", "avconn", "evctl", "rafctl", "AVconn", " avcontext", "avcontext", " avconn", "vermac", "AVci", "avctl", "afcontext", "avectrl", "afcv", "apcmp", "aucu", "avc", "attctx", "evcmp", "avectx", "atttx", "afc", "afcu", " avc", "aflc", "attcontext", "afci", " avcf", "evcu", "rafctx", "afloc", "aveloc", "evloc", "avallc", "vercf", "avloc", "afctx", "avelc", "AVtx", "abconn", "AVc", "afcm", "avalexc", "abcmp", "avcf", "avci", "avexc", "vercontext", "avcu", "verctx", "abctx", "AVexc", "AVlc", "afconfig", "AVctx", "abctrl", " avcv", "evconn", "evctx", "evcv", "avctrl", "navcontext", "aveconn", "avecontext", "aveconnection", "aucontext", "abcm", "afctrl", "ablc", "AVcf", "AVconfig", "navctx", "aftx", "afcmp", "rafcf", "afctl", "attconfig", "avecu", "evcontext", "afcf", "afconnection", "avecm", "avlc", "navmac", "apctx", "AVmac", "avconfig", "navcf", "afexc", "avecf", "avtx", "avconnection", "apconn", "rafcontext", "apcontext", "auconnection"], "data": ["parent", "map", "sample", "channel", "seq", "start", "frames", "len", "val", "source", "window", "media", "da", "b", "d", "block", "config", "p", "reader", "stream", "batch", "queue", "frame", "array", "tmp", "xxx", "body", "DATA", "f", "next", "dat", "multi", "size", "slice", "input", "response", "content", "r", "load", "Data", "bytes", "pos", "message", "a", "video", "image", "result", "cache", "bin", "length", "buff", "buffer"], "data_size": ["data\u00b7size", "data\u00b7shape", "data_scale", "doc_size", "doc_count", "data_shape", "data\u00b7address", " data_address", " data_shape", "data_fee", "data_count", "doc_fee", "doc_shape", "data\u00b7scale", " data_scale", "data_address"], "avpkt": ["affud", "afpacket", "avnpud", "avnpkt", " avcct", "avwpacket", "avpacket", "avfacket", " avckt", " avpct", "affacket", "avfcf", "avckg", "AVcpkg", "avfkt", "avcnt", " avpck", "avpcf", "AVpkg", "avcpkg", "avnpcf", "avnpnt", "avvpct", "afpud", "avvpkt", "avpud", "avpnt", " avpnt", "avcpkt", "AVcpkt", "avfud", "avwpkt", "AVcpct", "avpct", "affcf", "avvpnt", " avcck", "avcpct", "AVpet", "afpkt", "avpkg", "AVpct", "avcet", "avvpck", "avpet", "avnpacket", "avwpud", "AVpkt", "avcck", "affkt", "avpck", " avcnt", "avppkg", "avppct", "AVcpet", "avnpct", "avcct", "avwpcf", "avnpck", "avppet", "avcpet", "afpcf", "avckt", "avppkt"], "buf": ["bag", "uf", "seq", "img", "len", "pad", "b", "wb", "block", "fb", "config", "batch", "bd", "pb", "ref", "cb", "fp", "queue", "dest", "cf", "rb", "loc", "array", "tmp", "bc", "f", "alloc", "cv", "cap", "cas", "port", "offset", "vec", "buff", "buffer", "box", "uc"], "s": ["session", "sv", "g", "stats", "m", "w", "b", "d", "sa", "p", "e", "sq", "rs", "f", "o", "S", "v", "sync", "r", "sb", "ns", "sys", "a", "ses", "ss", "ssl", "sc"], "sample_size": [" sample_address", "ample8code", "mean_mini", "mean67mini", "sample_handle", "sample___start", "sample_rate", "scale_scale", "scale_rate", "sample_name", "sample___code", "site_size", "sample64size", " sample_name", "sample67size", "sample64scale", "sample_start", "sample___limit", "sample_address", "ample_size", "sample8start", "sample64sized", "scale_sized", " sample_sum", "ample8start", "ample_range", "sample_code", "mean_handle", "sample_type", "ample_code", "sample_strength", "ample_scale", " sample_scale", "sample_shape", "sample_limit", "sample67handle", "sample___size", "sample8size", "sample_scale", "ample8size", "mean67shape", "ample_limit", "mean67size", "sample_mini", "sample_range", "ample_sum", "sample64rate", "sample67shape", "ample8limit", "scale_size", "mean_shape", "mean67handle", " sample_sized", "sample8code", "sample_sum", "site_strength", "sample_sized", "ample_start", "sample8limit", "site_type", "mean_size", "site_name", "sample67mini"], "c": ["count", "l", "C", "g", "w", "m", "k", "b", "x", "z", "d", "con", "ct", "p", "e", "cn", "f", "cc", "cs", "v", "r", "en", "dc", "u", "h", "nc", "cm", "ci"], "n": ["l", "un", "co", "nb", "len", "g", "na", "all", "w", "m", "conn", "nt", "b", "x", "k", "num", "z", "net", "d", "ne", "nor", "p", "e", "don", "cn", "nw", "number", "dn", "f", "network", "pn", "j", "o", "N", "size", "Ns", "v", "r", "norm", "en", "sn", "ns", "node", "u", "rn", "nc", "h", "t", "pos", "y", "ln", "nn"], "i": ["l", "di", "si", "m", "b", "k", "ini", "x", "d", "p", "e", "f", "j", "o", "index", "v", "ind", "ti", "pi", "ii", "u", "I", "li", "ip", "ci", "ni", "y"], "samples": ["sample", "namesamples", "unsample", "sizes", "unsamples", "Sannels", "insample", "insources", "Sizes", "sannels", "Samples", "Samps", "namesources", " sources", "insamples", "namesizes", "unsources", "unsamps", "sources", "Sources", " sannels", "ssannels", "ssamples", " sample", " samps", "insamps", "ssamps", "samps", "insizes"], "src": ["seq", "img", "source", "sel", "SOURCE", "b", "sur", "RC", "config", "stream", "dest", "cb", "ins", "split", "gb", "ptr", "rb", "loc", "tmp", "rs", "sq", "bc", "inst", "sub", "fl", "slice", "lib", "cv", "sync", "rc", "input", "sl", "sup", "ctx", "sn", "sb", "params", "url", "gz", "bin", "proc", "uc", "ssl", "sc", "fc"], "src8": ["rc4", "src4", "source16", "source4", "rc8", "rc6", "src6", " src4", " src16", " src6", "source8", "source6", "src16", "rc16"], "src2": ["rc4", " src3", "src4", "source3", "src1", "rc1", "source1", "source4", "rc2", "rc3", " src4", " src1", "source2", "src3"], "MAX_CHANNELS": ["MAX_CHANES", "MAX_CHANNEL", "MAX_CHANERS", "MAX_CHANDS", "MAX_CLANDS", "MAX_CHANGERS", "MAX_CHANETS", "MAX_CHANELS", "MAX_CLANETS", "MAX_CLANNES", "MAX_CHANNDS", "MAX_CHINETS", "MAX_CHOUNES", "MAX_CLANNETS", "MAX_CHOUNETS", "MAX_CHOANGEL", "MAX_CHOANGETS", "MAX_CHANNETS", "MAX_CHOUNDS", "MAX_CLANELS", "MAX_CHOANNEL", "MAX_CHANGELS", "MAX_CHINERS", "MAX_CHINELS", "MAX_CHOANNERS", "MAX_CLANNELS", "MAX_CHANNES", "MAX_CHOANNELS", "MAX_CLANNDS", "MAX_CHOANGERS", "MAX_CHANEL", "MAX_CHANGDS", "MAX_CHANGETS", "MAX_CHOANNETS", "MAX_CHANNERS", "MAX_CHOANGELS", "MAX_CHANGES", "MAX_CHINEL", "MAX_CHANGEL", "MAX_CLANES", "MAX_CHOUNELS"], "dst_int32_t": ["dst_int16_t", "dst_int32_int", "dst_int16_T", "dst_int16_type", "dst_int16_int", "dst_int32_type", "dst_int32_T"]}}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static int parse_presentation_segment(AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size,\n\n                                      int64_t pts)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    int x, y, ret;\n\n\n\n    int w = bytestream_get_be16(&buf);\n\n    int h = bytestream_get_be16(&buf);\n\n\n\n    ctx->presentation.pts = pts;\n\n\n\n    av_dlog(avctx, \"Video Dimensions %dx%d\\n\",\n\n            w, h);\n\n    ret = ff_set_dimensions(avctx, w, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Skip 1 bytes of unknown, frame rate? */\n\n    buf++;\n\n\n\n    ctx->presentation.id_number = bytestream_get_be16(&buf);\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     state\n\n     *     palette_update_flag (0x80),\n\n     *     palette_id_to_use,\n\n     */\n\n    buf += 3;\n\n\n\n    ctx->presentation.object_number = bytestream_get_byte(&buf);\n\n    ctx->presentation.composition_flag = 0;\n\n    if (!ctx->presentation.object_number)\n\n        return 0;\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     object_id_ref (2 bytes),\n\n     *     window_id_ref,\n\n     */\n\n    buf += 3;\n\n    ctx->presentation.composition_flag = bytestream_get_byte(&buf);\n\n\n\n    x = bytestream_get_be16(&buf);\n\n    y = bytestream_get_be16(&buf);\n\n\n\n    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/\n\n\n\n    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);\n\n\n\n    if (x > avctx->width || y > avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",\n\n               x, y, avctx->width, avctx->height);\n\n        x = 0; y = 0;\n\n    }\n\n\n\n    /* Fill in dimensions */\n\n    ctx->presentation.x = x;\n\n    ctx->presentation.y = y;\n\n\n\n    return 0;\n\n}\n", "idx": 10253, "substitutes": {"avctx": ["afconn", "avcmp", "afctx", "AVcf", "AVconfig", "avelc", "ajcmp", "aucas", "afcas", "vercmd", "aucca", "afpkg", "afcmp", "avectx", "avecmp", "alcontext", "evcf", "afcmd", "auctx", "AVctrl", "avcf", "avecu", "AVcmp", "evcontext", "AVpkg", "AVcontext", "alconv", "avcu", "alctx", "afcu", "verctx", "vercontext", "afcf", "aveconfig", "avconn", "avcmd", "avconv", "aflc", "AVlc", "ajctx", "ajcontext", "AVcmd", "afconfig", "AVctx", "aveconv", "avconfig", "AVconn", "avlc", "avcontext", "afconv", "alcca", "avepkg", "evconn", "avcas", "avctrl", "evctx", "ajcmd", "avpkg", "alcas", "alpkg", "avecf", "AVcu", "aveconn", "avecontext", "aucontext", "afcontext", "ajctrl", "afctrl", "avcca", "afcca", "verconfig"], "buf": ["bag", "uf", "seq", "uu", "img", "context", "proc", "ph", "af", "wa", "src", "fd", "b", "brace", "mount", "auc", "wb", "fw", "ab", "pool", "data", "fb", "batch", "ref", "config", "pb", "bu", "cb", "fp", "queue", "gb", "cf", "rb", "bc", "pkg", "ha", "bound", "alloc", "cv", "aux", "exc", "fam", "rc", "uh", "Buff", "bh", "cas", "home", "conv", "cur", "font", "req", "port", "begin", "uint", "h", "loop", "row", "func", "vec", "buff", "cmd", "br", "feat", "text", "buffer", "box", "uc", "runner"], "buf_size": [" buffer_length", "buf2size", " buffer_SIZE", "buf2name", "buf_name", " buffer_name", "buf2SIZE", "buf2length", "buf_length", " buffer_size", "buf_SIZE"], "pts": ["ntg", "prs", "prd", "pxc", "ptg", "ctns", "portgs", "pxns", " ptsps", " ptsts", "ptc", " ptd", "ntts", "aptd", " ptss", "ports", "cts", "ptd", "portd", " ptsd", "ntgs", "ptps", " ptps", "ptgs", "pxs", "ctc", "aptc", "ptns", "prgs", "aptns", "nts", "ntd", "ntps", "apts", "ctd", "pxd", "ptts", " ptts", "prg", "portg"], "ctx": ["conf", "co", "cam", "context", "cmp", "cca", "conn", "tc", "sci", "fw", "c", "cp", "data", "config", "p", "cu", "cb", "cli", "qa", "cf", "cn", "wcs", "loc", "coll", "hw", "cc", "bc", "cs", "ctrl", "cus", "cv", "ck", "aux", "ce", "cas", "conv", "tx", "pc", "xc", "cpp", "cms", "nc", "cfg", "cm", "ca", "gc", "client", "ci", "fc", "comp", "css", "vc", "lc", "cmd", "pkg", "mc", "kb", "sc", "exec"], "x": ["l", "xp", "ax", "m", "pl", "t", "path", "z", "code", "v", "port", "rx", "image", "n", "val", "key", "view", "w", "id", "xi", "b", "k", "i", "c", "X", "work", "e", "pe", "value", "f", "index", "r", "en", "position", "wx", "u", "ww", "sex", "hi", "location", "d", "data", "coord", "xxx", "host", "o", "shape", "fx", "tx", "xc", "xy", "xe", "px", "a", "dx", "in", "wa", "xx", "time", "p", "ix", "xs", "q", "height", "name", "address", "h", "length", "ex"], "y": ["l", "ym", "ady", "hi", "isy", "area", "yt", "oy", "n", "ry", "wa", "w", "id", "m", "ny", "bar", "t", "b", "z", "vy", "ey", "d", "i", "ye", "s", "cy", "p", "ys", "iy", "yi", "ish", "value", "pt", "ay", "q", "zy", "f", "yy", "sy", "j", "height", "gy", "o", "py", "index", "v", "name", "ky", "yl", "ery", "hy", "acy", "Y", "ty", "ies", "ii", "type", "h", "yan", "xy", "lon", "yn", "ya", "image", "length", "wy", "dy", "yo"], "ret": ["rf", "flag", "str", "alt", "val", "ry", "len", "def", "id", "nt", "Ret", "num", "last", "feat", "red", "reply", "ref", "run", "lit", "obj", "reg", "pt", "rb", "rets", "f", "code", "rt", "res", "bf", "det", "wait", "rc", "md", "r", "att", "fun", "err", "en", "ben", "end", "art", "read", "re", "RET", "rx", "back", "mt", "result", "rev", "ft", "resp", "match", "fi", "success"]}}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "void qemu_coroutine_delete(Coroutine *co_)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);\n\n\n\n    if (s->pool_size < POOL_MAX_SIZE) {\n\n        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);\n\n        co->base.caller = NULL;\n\n        s->pool_size++;\n\n        return;\n\n    }\n\n\n\n    g_free(co->stack);\n\n    g_free(co);\n\n}\n", "idx": 10266, "substitutes": {"co_": ["ci_", "ci__", "co__", "Co__", " co__", "CO_", "mo_", "aco_", "Co_"], "s": ["l", "conf", "sg", "ts", "ks", "is", "si", "ds", "sf", "stats", "m", "http", "b", "stat", "gs", "c", "p", "ls", "e", "se", "status", "ins", "local", "xs", "sq", "js", "rs", "os", "f", "cs", "o", "S", "es", "sync", "sl", "state", "r", "services", "sup", "sb", "ns", "hs", "u", "sys", "ps", "ses", "su", "fs", "ss", "bs", "ssl"], "co": ["parent", "CC", "company", "oc", "fo", "CO", "aco", "go", "x", "oo", "isco", "que", "con", "c", "oe", "cu", "coord", "cf", "Co", "po", "cross", "loc", "coll", "cc", "op", "bc", "code", "call", "o", "ck", "che", "ctx", "can", "cost", "pc", "com", "oper", "ico", "mo", "col", "ca", "coe", "ci", "flo", "cache", "lc", "core", "mc", "so", "ko", "fc"], "pool_size": ["poolallsize", "pool_length", "queue_size", "pool__weight", "poolallweight", "pool_count", "queue_count", "pool__length", "thread_size", "thread_weight", "queue_max", "poolallcapacity", "pool_capacity", "thread_capacity", "poolalllength", "pool__capacity", "pool__size", "pool_weight", "thread_length", "pool_max"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 10268, "substitutes": {"a": ["l", "area", "va", "n", "af", "da", "ba", "m", "b", "x", "ab", "pa", "d", "i", "sa", "c", "ad", "s", "p", "e", "at", "au", "ia", "f", "ac", "an", "la", "ai", "fa", "alpha", "o", "ae", "ea", "aux", "ar", "am", "ga", "A", "art", "as", "ast", "aj", "u", "aa", "ca", "self", "ma", "y", "ap"], "STATUS_PARAM": ["STATUS_PA", "STATUS_ARA", "STATUS_PARam", "STATUS_ARAME", "STATUS_ARAM", "STATUS_PARA", "STATUS_PAME", "STATUS_PAM", "STATUS_Pam", "STATUS_ARam", "STATUS_PARAME"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10269, "substitutes": {"tpm_fd": ["tpm__d", "tpm_FD", "tcm_handler", "tdem_dir", "tpm__handler", "tpm__fd", "tpm_dir", "tpm_flo", "tPM_d", "tPM_FD", "tdem_flo", "tpm_writer", "tpm67handler", "tpm__writer", "tpm67flo", "tcm_fd", "tpm_handler", "tdem_handler", "tpm67dir", "tpm_d", "tPM_fd", "tPM_context", "tcm_d", "tcm_writer", "tdem_fd", "tpm67fd", "tpm_context"], "in": ["diff", "rin", "win", "In", "again", "all", "m", "id", "source", "x", "ini", "inn", "update", "login", "con", "data", "c", "s", "work", "ins", "ac", "index", "inc", "input", "min", "din", "isin", "r", "inner", "new", "read", "init", "image", "bin", "IN", "nin", "into", "pin", "ex"], "in_len": ["out_lan", "in00en", "in_size", "in_Len", "out_lf", "inxsize", "inxlength", "inxlen", "out_en", "in_lf", " in_Len", "in00len", " in_length", "in_l", "in00length", "in_lan", "in_en", "out_l", "out_length", " in_size", "in_length", "in00lan", "inxLen"], "out": ["timeout", "ext", "n", "comment", "prefix", "again", "window", "w", "conn", "temp", "Out", "b", "net", "update", "doc", "data", "c", "reply", "work", "output", "line", "obj", "server", "block", "target", "exec", "at", "outs", "off", "call", "o", "size", "inc", "name", "input", "response", "connection", "req", "err", "new", "full", "OUT", "part", "wx", "after", "bit", "init", "file", "client", "io", "cache", "result", "write", "cmd", "image", "buffer", "ex"], "out_len": ["out_line", "again_ln", "out_lin", "out_lf", "in_pos", "outvlen", " out_lin", "in_limit", "out_pos", "out0len", "out_lon", "out0pos", "outalllf", " out_lf", "outalllen", "again_len", "out_limit", "outvsize", "out_size", " out_lon", "out0limit", "outvln", "out_length", "again_size", "again_line", "outalllon", "out0length", "outalllin", "in_length", "out_ln", "outvline"], "ret": ["sp", "arr", "std", "flag", "str", "alt", "val", "len", "ext", "def", "nt", "id", "Ret", "dt", "num", "mem", "pat", "data", "reply", "ref", "arg", "lit", "fit", "status", "reg", "obj", "final", "gt", "rets", "j", "code", "rt", "res", "bf", "db", "det", "al", "opt", "rc", "fun", "att", "en", "lt", "part", "rep", "art", "pret", "desc", "bit", "fin", "cat", "re", "RET", "back", "let", "result", "ft", "match", "mt", "resp", "feat", "rev", "rl", "sr", "success"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10278, "substitutes": {"env": ["qt", "ext", "que", "viron", "vt", "environment", "config", "e", "np", "txt", "esi", "erv", "ec", "eni", "priv", "ev", "inv", "forge", "energy", "exc", "ea", "oa", "exe", "zen", "en", "eng", "Environment", "enc", "emb", "ef", "et", "impl", "her", "eu", "fi", "ens", "runner"], "addr": ["lp", "stall", "ack", "pad", "fd", "x", "bridge", "ad", "ref", "ace", "afi", "memory", "loc", "dl", "device", "align", "lb", "nr", "asm", "offset", "hop", "url", "pkg", "ld", "alias", "ord", "id", "mem", "work", "e", "r", "en", "layer", "lc", "cpu", "seq", "alt", "conn", "src", "data", "add", "ls", "coord", "ptr", "eni", "socket", "dr", "host", "size", "alloc", "edge", "oa", "rc", "order", "sl", "node", "aa", "hl", "lan", "adr", "start", "pointer", "ell", "el", "p", "rs", "lr", "la", "ea", "route", "address", "pos", "ip"], "buf": ["bag", "uf", "seq", "ff", "src", "fd", "b", "que", "path", "wb", "mem", "pool", "fi", "data", "fb", "batch", "config", "pb", "cb", "fp", "queue", "feed", "rb", "array", "bc", "alloc", "cv", "rc", "cas", "home", "ctx", "lb", "port", "offset", "url", "result", "vec", "buff", "cmd", "proc", "br", "buffer", "uc", "runner"], "len": ["lp", " el", "seq", "ler", "le", "lf", "base", "il", "n", "val", "in", "lv", "nt", "lim", "low", "pl", "i", "ell", "line", "limit", "el", "ls", "lit", "loc", "la", "dl", "fl", "bl", "non", "ll", "min", "sl", "L", "en", "lb", "fin", "lock", "lang", "den", "hl", "li", "pos", "lon", "url", "length", "Len", "lc", "lan", "ln", "lin"], "is_write": [" is_writ", "has_sync", "is_call", "is_flow", "isaycall", "isaywrite", "islandcreate", "has_written", "is_writ", "isaywrit", "isplandread", "islandwrite", "islandwriter", "has_flow", "isp_writer", "has_write", "islandread", "is_read", " is_call", "is_sync", "isp_create", "is_create", "isp_write", "isplandwriter", "is_written", "is_writer", "isp_read", "isplandcreate", "isplandwrite"], "l": ["lp", "ld", "le", "lf", "il", "n", "ul", "pl", "b", "ol", "z", "d", "i", " L", "ell", "line", "el", "p", "ls", "e", "limit", "lu", "lit", "loc", "la", "dl", "fl", "o", "bl", "ll", "v", "sl", "r", "L", "lb", "en", "u", "lang", "nl", "hl", "li", "url", "length", "lc", "y", "jl", "rl", "ln", "lin", "kl"], "phys_addr": ["phys__pointer", "phys__address", "physical_addr", "phys_dr", "phys___pointer", " phys_rt", "las_az", "phys2addr", "physical_adr", "cpu_address", "phys_ref", "phys_align", "phy_addr", "phys_address", "physical_pointer", "physkaddr", "phys___addr", "phys_rt", "phys___address", " phys_ord", "phy_oa", "phys__adr", "physkaddress", "las_dr", "phys_adr", "phys_ord", "las_align", "physical_address", "phys__addr", "phys_adder", "cpu_ord", "phys_ace", "phys_oa", "phy_adder", "phys_pointer", "physkdr", "cpu_ref", " phys_ace", "phys2ord", "phys2ace", "phys2rt", "las_address", "phy_address", "physkalign", "phys_az", "cpu_addr", "phys___adr", "las_addr"], "page": ["count", "lp", "area", "byte", "pg", "n", "id", "fr", "pl", "net", "num", "x", "pid", "ver", "pp", "pointer", "c", "line", "data", "p", "ref", "server", "e", "limit", "el", "pe", "memory", "number", "pages", "array", "loc", "stop", "padding", "next", "size", "inc", "name", "sl", "end", "age", "address", "en", "pc", "Page", "offset", "hop", "node", "aa", "pos", "ip", "row", "url", "site", "cache", "buffer"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq dma, omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 10282, "substitutes": {"system_memory": ["system_reference", "system_media", "System_reference", " system_metadata", " system_media", "System_memory", "System_region", "system_mem", "system_metadata", " system_mem", "system_region", "System_mem"], "base": ["l", "mac", "area", "ui", "is", "id", "info", "m", "bas", "b", "x", "i", "block", "Base", "cp", "addr", "p", "ix", "c", "ase", "ace", "gb", "e", "server", "frame", "ia", "f", "la", "os", "bf", "resource", "v", "name", "r", "address", "bi", "storage", "as", "u", "ca", "mb", "ma", "ip", "a", "use", "buffer", "aga", "ases"], "irq": ["irdq", "irew", "srqs", "irqu", "irtque", "irtq", " irw", "irech", " irqi", "irtqu", " irch", "ireq", "srch", "irch", "IRdq", " irdq", "nirq", "nirqi", "irtch", "irtqi", "IRw", "irw", "irqs", "irtqs", "irequ", "nirque", "ird", " ird", "iredq", "nird", " irque", "IRq", "srqu", "srq", "irtd", "ireqs", "irque", "IRch", "irqi"], "dma": ["sMA", "dmas", "sga", "vdMA", "duma", "smas", " dMA", " dca", "dga", " dga", "dMA", "zma", "dca", "sma", "zga", "duca", "duMA", "vdca", "zmas", "vdma", "zMA", " dmas", "vdga", "duga"], "clk": ["blwork", "slwork", "blke", "plwork", "plb", "clke", "slb", "plke", "clwork", "slk", "blb", "clb", "plk", "slke", "blk"], "s": ["l", "session", "is", "its", "m", "t", "gs", "v", "izes", "ns", " shares", "self", "ips", "settings", "erences", "ings", "sg", "ds", "si", "n", "w", "b", "i", "opens", "c", "e", "args", "us", "f", "sets", "scope", "es", "r", "u", "fs", "ps", "ss", "ows", "g", "ops", "d", "sa", "ls", "os", "cs", "o", "south", "new", "als", "sb", "sys", "ions", "secondary", "a", "ssl", "ts", "rows", " scales", "p", "js", "rs", "an", "aws", "S", "states", "services", "ches", "ses", "ures"]}}
{"project": "qemu", "commit_id": "66668d197fa40747e835e15617eda2f1bc80982f", "target": 0, "func": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    VncPalette *palette = &color_count_palette;\n\n    uint32_t bg = 0, fg = 0;\n\n    int colors;\n\n    int ret = 0;\n\n#ifdef CONFIG_VNC_JPEG\n\n    bool force_jpeg = false;\n\n    bool allow_jpeg = true;\n\n#endif\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n\n\n    vnc_tight_start(vs);\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vnc_tight_stop(vs);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n\n\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n\n            allow_jpeg = false;\n\n        }\n\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n\n            force_jpeg = true;\n\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n\n        }\n\n    }\n\n#endif\n\n\n\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n\n                                 force_jpeg);\n\n    } else {\n\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n    }\n\n#else\n\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 10291, "substitutes": {"vs": ["vals", "va", "styles", "ts", "ks", "wp", "sv", "pg", "ds", "verts", "lbs", "stats", "alls", "nav", "http", "ils", "pps", "ops", "vers", "ver", "VS", "ov", "gs", "ys", "s", "iss", "ls", "serv", "qs", "ports", "ins", "versions", "views", "env", "xs", "lines", "rs", "pages", "args", "ums", "sk", "vas", "plugins", "obs", "cs", "js", "assets", "cv", "v", "es", "Vs", "otes", "sts", "posts", "eps", "state", "ns", "ms", "as", "vr", "px", "params", "fs", "ps", "css", "ss", "bs", "settings", "ves", "vp"], "x": ["l", "up", "n", "val", "ph", "win", "wa", "m", "id", "xx", "b", "t", "z", "k", "my", "d", "i", "c", "X", "p", "ix", "work", "e", "pe", "xs", "q", "f", "o", "index", "v", "min", "name", "fx", "ic", "en", "tx", "wx", "xt", "u", "xy", "pos", "rx", "px", "on", "a", "image", "wy", "dx", "ex"], "y": ["l", "ym", "yt", "yp", "n", "ry", "m", "ny", "id", "t", "ye", "vy", "z", "b", "d", "i", "ey", "c", "ys", "s", "p", "cy", "yi", "ish", "yes", "q", "f", "yy", "sy", "j", "gy", "py", "v", "yl", "Y", "ty", "ies", "col", "yr", "xy", "yan", "on", "yn", "ya", "ch", "wy", "dy", "yo"], "w": ["wl", "l", "wn", "hi", "sh", "wp", "n", "g", "wa", "win", "rw", "m", "temp", "iw", "wh", "b", "t", "z", "fw", "wt", "d", "sw", "wb", "c", "p", "we", "nw", "q", "wal", "hw", "f", "wy", "height", "way", "v", "wx", "wan", "kw", "aw", "wu", "ww", "ew", "k", "ya", "W", "ow", "wd", "tw"], "h": ["l", "hi", "sh", "he", "ht", "dh", "n", "g", "wa", "ph", "hz", "hh", "m", "temp", "ul", "id", "wh", "t", "b", "z", "k", "d", "c", "p", "hm", "gh", "q", "eh", "hw", "body", "f", "height", "zh", "ha", "th", "v", "bh", "ih", "home", "en", "cl", "hs", "oh", "kh", "hd", "u", "H", "hl", "ah", "ch", "um", "rh", "uh"], "palette": ["pallette", "alte", "gamote", "alet", "colette", "Palte", "palade", "Palettes", "callete", "Pallete", "callette", " pallette", "gamette", " palettes", "alettes", "calette", "Palote", "pallete", "calote", "collete", "colade", "palettes", "alette", "palote", "calade", "colettes", "colet", "Pallette", "collette", " palet", "palet", "palte", "allette", "Palet", "Palette", "gamlette", "Palade", "gamlete", " palte"], "colors": ["icollections", "coloror", "colores", "palters", "COLores", "palor", "colorour", "collections", "colorters", "colorors", "color", "pallections", "palals", "icolals", "colorores", "valors", "icolons", "colorons", "palors", "Colors", "valores", "COLors", "colorlections", "Colores", "palour", " colters", "colour", "icolor", "icolters", "COLor", "Color", " color", "palores", " collections", "icolores", "icolors", "colters", " colals", "vallections", "colons", " colons", "valour", "colals"]}}
{"project": "qemu", "commit_id": "5238c88657d751e3acf3e953a9b11f5f24262f75", "target": 0, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    uint32_t palcode;\n\n    int32_t disp21, disp16;\n\n#ifndef CONFIG_USER_ONLY\n\n    int32_t disp12;\n\n#endif\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit;\n\n    uint8_t lit;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = insn >> 26;\n\n    ra = (insn >> 21) & 0x1F;\n\n    rb = (insn >> 16) & 0x1F;\n\n    rc = insn & 0x1F;\n\n    real_islit = islit = (insn >> 12) & 1;\n\n    if (rb == 31 && !islit) {\n\n        islit = 1;\n\n        lit = 0;\n\n    } else\n\n        lit = (insn >> 13) & 0xFF;\n\n    palcode = insn & 0x03FFFFFF;\n\n    disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11;\n\n    disp16 = (int16_t)(insn & 0x0000FFFF);\n\n#ifndef CONFIG_USER_ONLY\n\n    disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20;\n\n#endif\n\n    fn11 = (insn >> 5) & 0x000007FF;\n\n    fpfn = fn11 & 0x3F;\n\n    fn7 = (insn >> 5) & 0x0000007F;\n\n    LOG_DISAS(\"opc %02x ra %2d rb %2d rc %2d disp16 %6d\\n\",\n\n              opc, ra, rb, rc, disp16);\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, palcode);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n    case 0x08:\n\n        /* LDA */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x09:\n\n        /* LDAH */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x0A:\n\n        /* LDBU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0D:\n\n        /* STW */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x10:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_cmpbge(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                       tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_addlv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_sublv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_addqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_subqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x11:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            if (likely(rc != 31)) {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask);\n\n                } else {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask);\n\n                }\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            if (rc != 31) {\n\n                tcg_gen_movi_i64(cpu_ir[rc], ctx->implver);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x12:\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            gen_zap(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            gen_zapnot(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x13:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            {\n\n                TCGv low;\n\n                if (unlikely(rc == 31)){\n\n                    break;\n\n                }\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                    break;\n\n                }\n\n                low = tcg_temp_new();\n\n                if (islit) {\n\n                    tcg_gen_movi_tl(low, lit);\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low);\n\n                } else {\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n                tcg_temp_free(low);\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_mullv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_mulqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x14:\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_s(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtf(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrts(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_f(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtg(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtt(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_faddf(ra, rb, rc);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_fsubf(ra, rb, rc);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_fmulf(ra, rb, rc);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_fdivf(ra, rb, rc);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG */\n\n#if 0 // TODO\n\n            gen_fcvtdg(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_faddg(ra, rb, rc);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_fsubg(ra, rb, rc);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_fmulg(ra, rb, rc);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_fdivg(ra, rb, rc);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_fcmpgeq(ra, rb, rc);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_fcmpglt(ra, rb, rc);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_fcmpgle(ra, rb, rc);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            gen_fcvtgf(rb, rc);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD */\n\n#if 0 // TODO\n\n            gen_fcvtgd(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            gen_fcvtgq(rb, rc);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            gen_fcvtqf(rb, rc);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            gen_fcvtqg(rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_fadds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_fsubs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_fmuls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_fdivs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_faddt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_fsubt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_fmult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_fdivt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_fcmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_fcmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_fcmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_fcmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_fcvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_fcvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            gen_fcvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            gen_fcvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            gen_fcvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            gen_fcvtlq(rb, rc);\n\n            break;\n\n        case 0x020:\n\n            if (likely(rc != 31)) {\n\n                if (ra == rb) {\n\n                    /* FMOV */\n\n                    if (ra == 31) {\n\n                        tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]);\n\n                    }\n\n                } else {\n\n                    /* CPYS */\n\n                    gen_fcpys(ra, rb, rc);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            gen_fcpysn(ra, rb, rc);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            gen_fcpyse(ra, rb, rc);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_store_fpcr(cpu_env, cpu_fir[ra]);\n\n            } else {\n\n                TCGv tmp = tcg_const_i64(0);\n\n                gen_helper_store_fpcr(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_load_fpcr(cpu_fir[ra], cpu_env);\n\n            }\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            gen_fcvtql(rb, rc);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            gen_fcvtql_v(ctx, rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            if (ra != 31) {\n\n                if (use_icount) {\n\n                    gen_io_start();\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                    gen_io_end();\n\n                    ret = EXIT_PC_STALE;\n\n                } else {\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                }\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mfpr(ra, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        if (rb != 31) {\n\n            tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3);\n\n        } else {\n\n            tcg_gen_movi_i64(cpu_pc, 0);\n\n        }\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr;\n\n\n\n            if (ra == 31) {\n\n                break;\n\n            }\n\n\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1C:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit));\n\n                } else {\n\n                    tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit));\n\n                    } else {\n\n                        tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit));\n\n                    } else {\n\n                        gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x31:\n\n            /* PERR */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_perr(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], clz64(lit));\n\n                    } else {\n\n                        gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit));\n\n                    } else {\n\n                        gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbw(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbl(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x36:\n\n            /* PKWB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pkwb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x37:\n\n            /* PKLB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pklb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x70:\n\n            /* FTOIT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x78:\n\n            /* FTOIS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (rc != 31) {\n\n                TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                if (ra != 31) {\n\n                    gen_helper_s_to_memory(tmp1, cpu_fir[ra]);\n\n                } else {\n\n                    TCGv tmp2 = tcg_const_i64(0);\n\n                    gen_helper_s_to_memory(tmp1, tmp2);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1);\n\n                tcg_temp_free_i32(tmp1);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mtpr(ctx, rb, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            if (rb == 31) {\n\n                /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n                   address from EXC_ADDR.  This turns out to be useful for our\n\n                   emulation PALcode, so continue to accept it.  */\n\n                TCGv tmp = tcg_temp_new();\n\n                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n                gen_helper_hw_ret(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            } else {\n\n                gen_helper_hw_ret(cpu_env, cpu_ir[rb]);\n\n            }\n\n            ret = EXIT_PC_UPDATED;\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr, val;\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            if (ra != 31) {\n\n                val = cpu_ir[ra];\n\n            } else {\n\n                val = tcg_temp_new();\n\n                tcg_gen_movi_i64(val, 0);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            if (ra == 31) {\n\n                tcg_temp_free(val);\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10295, "substitutes": {"ctx": [" cx", " c", "utils", "qt", "context", "cca", "conn", "tc", "sci", "buf", "cp", "c", "config", "obj", "cb", "txt", "cf", "lex", "xs", "loc", "hw", "cc", "bc", "ctrl", "cv", "cas", "conv", "tx", "jp", "xc", "gc", "grad", "cm", "scl", "irc", "ca", " context", "ci", "anc", "lc", "proc", "cgi", "kb", "sc", "exec"], "insn": ["INSsn", "itsg", "INSc", " insm", "insm", "issn", "allsnn", " insna", " insconn", "alsyn", "insd", "itsc", "incyn", "intsv", "rsyn", "minsg", "gesg", "inp", "insne", "rsn", "inpn", "tsn", "lsnan", " insp", " insdn", "inN", "outsna", "itsn", "inna", "itsnan", "outsd", "tsne", " inssn", "lsg", "outsn", "minsnan", " insns", "intsN", "inn", "opensnor", "insnan", "insyn", " inszn", "tssn", "inns", "insnn", " insne", "allsne", "gessn", "outsdn", "ind", "outsc", "insnor", " insd", "incg", "incp", "outsnn", " insN", "openssn", "incns", "allsn", "incn", "incnan", "rulesyn", "insp", "intsn", " insc", "itsconn", " insyn", "dsm", "minsyn", "lssn", "insN", "dsyn", "INSn", "INSdn", "itsne", "outsne", "lsn", "incN", "alsv", "tsyn", "insc", "gesne", "lsconn", "insconn", "insns", "gesna", "gesnan", "intsyn", "rsm", "opensd", "dsn", "alsN", "allsc", "INSnor", "outszn", "incsn", "insg", "inssn", "rulesne", "risc", "issd", "opensna", "risner", "INSzn", "risn", "kinsna", "kinsc", "issp", "itsnn", "gesn", "minsn", "rulesn", "isspn", "inszn", "inc", "incv", "incpn", "itssn", "kinsn", "inner", "kinsner", "rulessn", "INSna", "opensn", "outssn", "gesyn", "alsn", "insv", "dsd", "lsne", "insna", "risna", "inspn", "incd", "insdn", "insner", "gesnor", "rsd"], "palcode": ["peldesc", "pelcodes", "opcodes", "plcod", "pelcod", " palcodes", "calmode", "opaldesc", "calcodes", "palcod", "opalcode", "plCode", "opalcodes", "calCode", "plcodes", "caldesc", "palstr", "binCode", "opstr", "opCode", "plcode", "bincod", "calstr", "palcodes", " palstr", "opalmode", "bincodes", "pelmode", " palCode", "opcode", "palmode", "pelcode", "bincode", "palCode", "paldesc", "pelCode", "calcode"], "disp21": ["dispc22", " disop21", " disop14", "disP61", " dispatch211", "disop22", "dispr14", " disp26", "dispr26", " disop26", "disop14", "disp26", " dispatch21", "dispc26", " dispatch61", "disop26", "dispp21", "disp211", " disp61", "dispatch211", "dispr22", "disp61", "disp22", "dispp61", "dispc14", " disp22", " disp14", "dispr21", "disop21", "disP21", "disp14", "dispp211", "dispc21", " disp211", "dispatch61", "disP211", "dispatch21", " disop22"], "disp16": ["disvp22", "interpp8", "dispr16", "interpp16", "interpp21", "dispp22", "disnp22", "rispr6", "rispr60", "risp06", "disjp21", "rispr06", "unp22", "disp06", "disfp21", "disp6", "disfp6", "dispp31", "disvp18", "dispr60", "disnp31", "rispr16", "interp8", "disfp8", "disjp16", "dispp18", "risp6", "unp18", "dispp21", "interp21", "disp60", "unp31", "disnp06", "disp8", "dispp6", "disnp6", "risp60", "dispp8", "disp22", "dispp06", "dispp60", "unpp22", "dispr6", "unpp31", "interp6", "disvp16", "disnp18", "unp16", "disvp31", "disnp16", "interp16", "interpp6", "dispp16", "dispr06", "disjp6", "disfp16", "unpp18", "disp18", "unpp16", "risp16", "disnp60", "disjp8", "disp31"], "disp12": ["rep12", "Discp12", "disps12", "rep14", "disp40", "dispend02", "discp02", "dispend12", "disf32", "ref12", "Discp16", "disps16", "rep16", "disq14", "dispend16", "Discp02", "ref16", "ref32", "Disp40", "discp12", "discp16", "discp32", "Disp12", "Disp02", "Disp16", "disps40", "discp40", "disp02", "disq16", "rep32", "disf12", "ref14", "disp14", "disf16", "disq12", "discp14", "disf14", "Discp40", "dispend40", "disp32", "disq32", "disps02"], "fn11": ["ln1", " fn12", "FN1", " fn14", "fc12", "fd14", "fd12", "fc7", "fc11", "FN13", "fp7", "fc1", "fp1", " fn1", "ln14", "fn14", "fp13", "ln11", "fp12", "fn13", "fd1", "fn1", "FN12", "FN11", "fn12", " fn13", "fd11", "ln12", "fp11"], "opc": ["iopct", "operc", " opci", " opcn", "ropcn", "ropcs", "opci", "iopf", "optn", "Oplc", "ropci", "optc", " oplc", "ioppc", "yppc", "ropc", "operci", "opC", "opcs", "roplc", "Opcn", "ropC", " opcd", "opcn", " opn", "opct", " opcs", "ropcd", "optcs", "ypc", " opct", "opercs", "opcd", "iopc", " opC", "Opc", "opn", "oplc", "oppc", "opern", "Opci", "ypf", "opf", " opf", "OpC", " oppc", "Opcd", "optci", "ypct", "Opcs"], "ra": ["cr", "dra", "area", "ru", "va", "ta", "rd", "wa", "na", "da", "ba", "src", "Ra", "ara", "rr", "RC", "sha", "sa", "tra", "ref", "role", "rad", "loc", "rs", "la", "rt", "alpha", "ha", "ras", "ria", "min", "ar", "r", "rar", "aria", "as", "ran", "RA", "ro", "ca", "asa", "rg", "ma", "a", "ri", "sr", "range", "era"], "rb": ["cr", "rf", "adr", "ru", "erb", "bb", "rab", "nb", "rd", "abc", "src", "rr", "b", "ab", "RB", "wb", "fb", "ref", "pb", "cb", "gb", "usr", "lr", "rt", "db", "RR", "bf", "r", "reb", "lb", "rid", "ruby", "nr", "raf", "sb", "rar", "arb", "rn", "vr", "rg", "ri", "sr", "rob", "rh", "rl", "xb"], "rc": ["cr", "rf", "ru", "rin", "rw", "src", "rr", "RC", "rec", "c", "rl", "config", "ref", "gb", "loc", "rs", "ac", "rt", "ras", "r", "reb", "cur", "ruby", "pc", "rar", "rn", "vr", "rx", "irc", "rg", "sr", "ri", "rh", "roc", "sc", "uc", "fc"], "fpfn": ["fpfat", "tffn", "lpfile", "rffile", "fwfile", "lpfn", "lpfp", "lpfunc", "fwfp", "tffile", "fnfp", "fwfn", "rffn", "tffat", "vpfn", "vpfile", "fpfp", "vpfilename", "fwfunc", "fnfunc", "fpfunc", "vpfat", "rffilename", "rffat", "fnfile", "tffilename", "fnfn", "fpfile", "fpfilename"], "fn7": ["rn8", "rn701", " fn77", "rn7", " fn9", "fp9", "fn9", "fn77", "fp7", "hn8", "hn9", " fn8", " fn701", "rn9", "fp701", "fn701", "fp77", "hn7", "hn77", "fp8", "fn8"], "islit": ["islits", "unicit", "oblited", "ielit", "islite", "chalitable", "ilitor", "ilits", "ilitting", "nlite", "isalitted", "islitted", "unicitable", "nlitor", "ielited", "implit", "chalat", "ilitable", "unicat", "chalitting", "oblit", "islitt", "isalit", "nlit", "oplitable", "islitting", "islitable", "islat", "unicitting", "idelit", "llitt", "llitting", "chalit", "implitting", "isalite", "ilite", "oplat", "ilitted", "ielitting", "ielitt", "oblitt", "islitor", "islited", "oplit", "nlitted", "idelitable", "implits", "llit", "idelits", "idelitting", "llited", "oplitting", "oblitting", "ilit", "implitable", "isalitor"], "real_islit": ["real_ilit", "real_ielitting", "real_sli", "real_islitic", "real_bli", "real_ilite", "real_ielite", "real_islite", "real_islitting", "real_splitic", "real_slitted", "real_ielit", "real_slite", "real_blit", "real_ielitic", "real_blitted", "real_islitted", "real_splite", "real_ilitting", "real_ili", "real_splitting", "real_ilitted", "real_slit", "real_ilitic", "real_isli", "real_split", "real_blite"], "lit": ["l", "it", "il", "lif", "alt", "sel", "def", "pit", "info", "lim", "pl", "nt", "ab", "num", "stat", "mit", "slot", "fit", "util", "split", "rel", "iter", "or", "loc", "rets", "sec", "op", "rot", "lite", "la", "ie", "rt", "lib", "eval", "opt", "al", "wat", "fat", "sl", "sil", " lib", "abi", "lt", "ident", "bit", "lang", "cat", "let", "lc", "text", "proc", "expr", "typ", "lin"], "ret": ["repl", "pass", "alt", "class", "def", "Ret", "mem", "job", "reply", "rl", "ref", "arg", "obj", "status", "reg", "util", "rel", "final", "gt", "rets", "ut", "rt", "res", "lib", "det", "eval", "fun", "rep", "re", "sys", "type", "RET", "cat", "back", " RET", "let", "result", "rev", "match", "resp", "feat", "fi", "success"]}}
{"project": "FFmpeg", "commit_id": "53e5462040f6f7273fb6b0d7592eea1f5d26829f", "target": 0, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, int flags, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   int srcFormat, uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n    int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos;\n\n    int16_t av_unused *mmx2Filter    = c->chrMmx2Filter;\n\n    int     av_unused canMMX2BeUsed  = c->canMMX2BeUsed;\n\n    void    av_unused *mmx2FilterCode= c->chrMmx2FilterCode;\n\n\n\n    if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE)\n\n        return;\n\n\n\n    if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) {\n\n        src1 += ALT32_CORR;\n\n        src2 += ALT32_CORR;\n\n    }\n\n\n\n    if (srcFormat==PIX_FMT_RGB48LE) {\n\n        src1++;\n\n        src2++;\n\n    }\n\n\n\n    if (c->hcscale_internal) {\n\n        c->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n#if COMPILE_TEMPLATE_MMX\n\n    // Use the new MMX scaler if the MMX2 one can't be used (it is faster than the x86 ASM one).\n\n    if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed))\n\n#else\n\n    if (!(flags&SWS_FAST_BILINEAR))\n\n#endif\n\n    {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n#if ARCH_X86 && CONFIG_GPL\n\n#if COMPILE_TEMPLATE_MMX2\n\n        int i;\n\n#if defined(PIC)\n\n        DECLARE_ALIGNED(8, uint64_t, ebxsave);\n\n#endif\n\n        if (canMMX2BeUsed) {\n\n            __asm__ volatile(\n\n#if defined(PIC)\n\n                \"mov          %%\"REG_b\", %6         \\n\\t\"\n\n#endif\n\n                \"pxor             %%mm7, %%mm7      \\n\\t\"\n\n                \"mov                 %0, %%\"REG_c\"  \\n\\t\"\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\"\n\n                \"mov                 %2, %%\"REG_d\"  \\n\\t\"\n\n                \"mov                 %3, %%\"REG_b\"  \\n\\t\"\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                \"mov                 %5, %%\"REG_c\"  \\n\\t\" // src\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\" // buf1\n\n                \"add              $\"AV_STRINGIFY(VOF)\", %%\"REG_D\"  \\n\\t\"\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n\n\n#if defined(PIC)\n\n                \"mov %6, %%\"REG_b\"    \\n\\t\"\n\n#endif\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (mmx2Filter), \"m\" (mmx2FilterPos),\n\n                \"m\" (mmx2FilterCode), \"m\" (src2)\n\n#if defined(PIC)\n\n                ,\"m\" (ebxsave)\n\n#endif\n\n                : \"%\"REG_a, \"%\"REG_c, \"%\"REG_d, \"%\"REG_S, \"%\"REG_D\n\n#if !defined(PIC)\n\n                ,\"%\"REG_b\n\n#endif\n\n            );\n\n            for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) {\n\n                //printf(\"%d %d %d\\n\", dstWidth, i, srcW);\n\n                dst[i] = src1[srcW-1]*128;\n\n                dst[i+VOFW] = src2[srcW-1]*128;\n\n            }\n\n        } else {\n\n#endif /* COMPILE_TEMPLATE_MMX2 */\n\n            x86_reg xInc_shr16 = (x86_reg) (xInc >> 16);\n\n            uint16_t xInc_mask = xInc & 0xffff;\n\n            __asm__ volatile(\n\n                \"xor %%\"REG_a\", %%\"REG_a\"               \\n\\t\" // i\n\n                \"xor %%\"REG_d\", %%\"REG_d\"               \\n\\t\" // xx\n\n                \"xorl    %%ecx, %%ecx                   \\n\\t\" // xalpha\n\n                ASMALIGN(4)\n\n                \"1:                                     \\n\\t\"\n\n                \"mov        %0, %%\"REG_S\"               \\n\\t\"\n\n                \"movzbl  (%%\"REG_S\", %%\"REG_d\"), %%edi  \\n\\t\" //src[xx]\n\n                \"movzbl 1(%%\"REG_S\", %%\"REG_d\"), %%esi  \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, (%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"movzbl    (%5, %%\"REG_d\"), %%edi       \\n\\t\" //src[xx]\n\n                \"movzbl   1(%5, %%\"REG_d\"), %%esi       \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, \"AV_STRINGIFY(VOF)\"(%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"addw       %4, %%cx                    \\n\\t\" //xalpha += xInc&0xFFFF\n\n                \"adc        %3, %%\"REG_d\"               \\n\\t\" //xx+= xInc>>16 + carry\n\n                \"add        $1, %%\"REG_a\"               \\n\\t\"\n\n                \"cmp        %2, %%\"REG_a\"               \\n\\t\"\n\n                \" jb        1b                          \\n\\t\"\n\n\n\n/* GCC 3.3 makes MPlayer crash on IA-32 machines when using \"g\" operand here,\n\n   which is needed to support GCC 4.0. */\n\n#if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n\n                :: \"m\" (src1), \"m\" (dst), \"g\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#else\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#endif\n\n                \"r\" (src2)\n\n                : \"%\"REG_a, \"%\"REG_d, \"%ecx\", \"%\"REG_D, \"%esi\"\n\n            );\n\n#if COMPILE_TEMPLATE_MMX2\n\n        } //if MMX2 can't be used\n\n#endif\n\n#else\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n#endif /* ARCH_X86 */\n\n    }\n\n    if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) {\n\n        int i;\n\n        //FIXME all pal and rgb srcFormats could do this convertion as well\n\n        //FIXME all scalers more complex than bilinear could do half of this transform\n\n        if(c->srcRange) {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (dst[i     ]*1799 + 4081085)>>11; //1469\n\n                dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; //1469\n\n            }\n\n        } else {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n                dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10308, "substitutes": {"c": ["l", "center", "conf", "co", "C", "cmp", "n", "g", "conn", "m", "b", "t", "cont", "k", "d", "con", "ct", "s", "config", "p", "cp", "e", "cu", "cn", "cf", "ec", "coll", "f", "cc", "ac", "cs", "ctrl", "cv", "ce", "rc", "cur", "cal", "dc", "xc", "enc", "this", "u", "h", "nc", "ca", "cm", "client", "ci", "vc", "lc", "ch", "mc", "uc", "cy", "sc"], "dst": [" ddest", "sdsrc", "DST", "dsrc", "Ddest", "wdsrc", "sdsts", "sdst", "wdst", "wdST", "dest", "Dsts", "Dest", "Dsrc", " dsrc", "wdsts", "pdsts", " dsts", "sdest", " dest", " dST", "pdST", "ddest", "Dst", "dsts", "pdst", "pddest", "dST"], "dstWidth": ["destWeight", "dstWeight", "dSTWeight", "ddestwidth", "ddestWidth", " dSTWidth", "dSTMaximum", "drcwidth", "ddestCut", "dStWeight", "drcCut", "dstsWidth", "ddestHeight", "dstCut", "dStWidth", "drestMaximum", "destWidth", "dSTHeight", "drcHeight", "dStwidth", "dstsMaximum", "dstwidth", " dstwidth", "dSTwidth", "dstsHeight", " dstsMaximum", "dstHeight", " dstWeight", "dSTWidth", "dstMaximum", "dSTCut", "dstswidth", " dstswidth", " dSTWeight", " dSTCut", "drestwidth", " dstHeight", "drestHeight", "destwidth", "drestWidth", " dstCut", " dstMaximum", " dSTHeight", "drcWidth", "dStHeight", " dSTwidth", " dstsWidth", "destHeight", " dstsHeight"], "src1": ["rc4", "src4", "uint2", "rcone", "inst81", " srcone", "rc2", "rc8", "supp8", "suppOne", " src01", "config1", "config01", "src01", "rc1", "source1", "uintW", "config2", " srcOne", "source4", "uint1", "source01", "inst1", "source2", "instOne", "uintOne", "src81", "sourceone", "rcW", "supp1", " src8", "inst01", "rcOne", " src81", "instone", "configone", "srcone", "rc81", "srcOne", "sourceOne", " src4", "rc01", "inst2", "src8"], "src2": ["instTwo", "rc4", "src4", "imgTwo", "img4", "rc02", "srcTwo", "src0", "img02", "rc2", "dest0", "configTwo", "rcB", "src02", "config1", "img2", "instB", "config2", "srcB", " srcTwo", "rc1", "sc02", " src0", "dest2", "source4", "destB", "rcTwo", "source2", "destTwo", "sourceTwo", "config4", "scTwo", " src02", "rc0", " srcB", "sc2", " src4", "inst02", "inst2"], "srcW": [" srcWidth", "configW", "srcL", "srcN", " srcN", "configL", "destN", "srcV", " srcL", "destV", "sourceWidth", "destW", "srcw", "configw", "destWidth", "rcw", "rcV", "sourceW", "rcWidth", "sourceN", "destw", "rcW", "rcL", " srcV", "srcWidth", "sourcew", " srcw", "rcN", "configN"], "xInc": [" xSec", "Xinc", "XInc", "xIncre", " xIncre", "dxinc", "timeInc", "xinc", "xSec", "xEnc", "rxInc", "dxSec", "XMin", "timeInv", "rxinc", "xMin", "ixEnc", "ixInc", "XSec", "rxIncre", "timeinc", "XIncre", "dxInc", "XEnc", " xinc", "timeIncre", "xInv", " xEnc", "dxIncre", " xMin", "ixIncre", "rxInv", "ixMin", "XInv"], "flags": ["vals", "styles", "tones", "flag", "frames", "sf", "features", "stats", "alls", "files", "Flag", "requires", "ops", "lists", "ports", "orts", "s", "mask", "lights", "ISS", "ants", "powers", "opens", "reports", "versions", "bits", "planes", "pages", "lag", "types", "atts", "f", "args", "plugins", "FLAG", "Flags", "fl", "rules", "ints", "fires", "fps", "states", "ags", " Flags", "ats", "details", "allows", "faces", "ips", "options", "fs", "forces", "settings", "lins"], "hChrFilter": ["hchrF", "hchrFactor", "hcharF", "hChlFactor", "hChcrMask", "hChcLayer", "hCharFilter", "hChrF", "g", "hChrConfig", "all", "_", "color", "hchrLayer", "hChcrFactor", "hCharFactor", "hcharConfig", "hChlLayer", "hChcFactor", "hChcF", "hCharF", "hCharConfig", "hChrMask", "hChcrConfig", "G", "hchrMask", "hchrFilter", "hchrConfig", "hcharMask", "hCharLayer", "hChcFilter", "hChlConfig", "bytes", "hChlF", "hChlFilter", "hChrFactor", "hChcrFilter", "hCharMask", "hcharFilter", "hChrLayer", "hChlMask", "hcharLayer", "hcharFactor"], "hChrFilterPos": ["hChrFeatureDef", "hChrFilterDef", "hChrRulePos", "hChrFileSize", "hChrRuleBase", "hChrFilterEx", "hChrFactorPos", "hChlFileType", "hChlFileSize", "hChrListenerPos", "hChrFilterNum", "hChrHelperSize", "hChrFeatureEx", "hChrFactorEx", "hChlFilterType", "hChlFilterNum", "hChrListenerType", "hChrFileNum", "hChrFilePos", "hChrFileType", "hChrListenerSize", "hChrtFilterEx", "hChrListenerNum", "hChrtFactorEx", "hChrRuleEx", "hChrFactorBase", "hChrtFactorBase", "hChrHelperPos", "hChlFilePos", "hChrtFilterDef", "hChrtFactorDef", "hChrtFactorPos", "hChrHelperNum", "hChrFactorDef", "hChrtFilterPos", "hChrtFilterBase", "hChrRuleDef", "hChlFilterPos", "hChlFilterSize", "hChrFeaturePos", "hChrFilterBase", "hChlFileNum", "hChrFeatureBase", "hChrHelperType", "hChrFilterType"], "hChrFilterSize": ["hChrRulePos", "hChrFlPos", "hChnFilterLength", "hChrcFlLength", "hChrFLength", "hChrFactorPos", "hChrBufferSize", "hChnFactorPos", "hChrcFilterPos", "hChrFlSize", "hChrcFlSize", "hChrRuleSize", "hChnFilterSize", "hChrFOffset", "hChrRuleOffset", "hChrFilterOffset", "hChrcFlOffset", "hChrFlLength", "hChnFilterCode", "hChrBufferCode", "hChrcFilterSize", "hChrRuleLength", "hChrFCode", "hChrFactorLength", "hChrFactorCode", "hChnFactorSize", "hChrFilterCode", "hChnFactorLength", "hChrFSize", "hChrFPos", "hChrcFilterLength", "hChrcFilterOffset", "hChrcFlPos", "hChnFilterPos", "hChrFlOffset", "hChnFactorCode", "hChrBufferLength", "hChrFilterLength", "hChrFactorSize", "hChrBufferPos"], "srcFormat": [" srcWidth", "urlMT", "sourceformat", "sourceForm", "rcPattern", "srcForm", "rcFile", "instPattern", "rcSize", "rcUnit", "sourceWidth", "distType", " srcFile", "instFormat", " srcUnit", "srcPattern", "sourceUnit", " srcOffset", "srcUnit", "distFormat", "instUnit", "urlFile", "srcType", "srcMT", "srcformat", "sourcePattern", "srcSize", "sourceSize", " srcSize", " srcFunction", "sourceFormat", "rcWidth", "sourceFunction", "rcType", "rcFunction", "rcMT", "distformat", "sourceType", "instType", "srcFile", "srcWidth", "rcOffset", "srcFunction", "distForm", " srcType", "sourceOffset", "rcFormat", "rcformat", "urlFormat", "srcOffset", " srcMT", "urlUnit", "rcForm"], "formatConvBuffer": ["formatConVFile", "formatConfFilter", "formatConcReader", "formatConvFilter", "formatConventionBuff", "formatAnfFile", "formatAnvPtr", "formatEnvFilter", "formatConventionBuffer", "formatConfPtr", "formatEnfFile", "formatConveLine", "formatConvrArray", "formatConfLine", "formatConvtFile", "formatConvrBuffer", "formatEnfReader", "formatEnvBuffer", "formatConfContainer", "formatEnfContainer", "formatConcBuff", "formatEnvBuff", "formatConveBuffer", "formatAnvBuff", "formatConchFile", "formatConvPtr", "formatConchReader", "formatEnvReader", "formatEnfFilter", "formatConfBuffer", "formatConvReader", "formatConventionFilter", "formatConvrFile", "formatAnfPtr", "formatEnvFile", "formatConchBuff", "formatConventionContainer", "formatEnfPtr", "formatAnfBuffer", "formatConvtBuffer", "formatConcArray", "formatAnvBuffer", "formatConchBuffer", "formatConcBuffer", "formatConvvContainer", "formatConvvBuff", "formatConvrBuff", "formatConvvBuffer", "formatConvtBuff", "formatConcFile", "formatConveBuff", "formatConvFile", "formatEnfBuffer", "formatConvContainer", "formatConvePtr", "formatConfArray", "formatConvvFilter", "formatEnfLine", "formatEnvContainer", "formatConvtLine", "formatEnfBuff", "formatConvtPtr", "formatEnfArray", "formatEnvPtr", "formatEnvLine", "formatAnvFile", "formatConVBuffer", "formatConfFile", "formatConvLine", "formatAnfBuff", "formatConVBuff", "formatConfReader", "formatConVPtr", "formatConfBuff", "formatConvArray", "formatConvBuff", "formatEnvArray"], "pal": ["vals", "conf", "scale", "real", "ale", "val", "color", "pl", "pack", "isal", "panel", "AL", "mask", "el", "p", "local", "cb", "pixel", "rel", "ass", "what", "alpha", "al", "v", "align", "ar", "abi", "cal", "pi", "as", "cale", "nl", "bin", "fac"], "mmx2FilterPos": ["mmx1FilterPosition", "mmx1FilterPos", "mmx1FPos", "mmx2FilterBase", "mmx2FeaturePos", "mmx2FInfo", "mmx2FeatureBase", "mmx1FilterBase", "mmx2FeaturePosition", "mmx1FPosition", "mmx2HeaderBase", "mmx2FeatureInfo", "mmx2FPos", "mmx2FPosition", "mmx1FilterInfo", "mmx2FilterInfo", "mmx2HeaderInfo", "mmx2FilterPosition", "mmx2FBase", "mmx2HeaderPosition", "mmx1FInfo", "mmx2HeaderPos", "mmx1FBase"], "mmx2Filter": ["mmx42Profile", "mmx1Header", "mmX2Header", "mmx2Header", "mmx1Filter", "mmx1Profile", "mmxTwoFactor", "mmxTwoFilter", "mmxTwoHeader", "mmX1Factor", "mmX1Profile", "mmx42Factor", "mmX2Profile", "mmX1Filter", "mmx2Factor", "mmX2Factor", "mmxTwoProfile", "mmx1Factor", "mmx2Profile", "mmx42Filter", "mmx42Header", "mmX1Header", "mmX2Filter"], "mmx2FilterCode": ["mmx2FilterNumber", "mmx2FilterCount", "mmx1FSize", "mmx2filterCode", "mmx2FNumber", "mmx2filterNumber", "mmx2FCode", "mmx2LayerNumber", "mmx1FCode", "mmx2FCount", "mmx1FNumber", "mmx1FilterNumber", "mmx1FilterCode", "mmx1FCount", "mmx2FilterSize", "mmx2LayerSize", "mmx2FSize", "mmx1FilterCount", "mmx2LayerCount", "mmx2filterSize", "mmx2filterCount", "mmx1FilterSize", "mmx2LayerCode"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n", "idx": 10316, "substitutes": {"a": ["va", "area", "abc", "n", "window", "ba", "m", "b", "x", "ab", "pa", "d", "i", "sa", "data", "c", "addr", "p", "e", "ata", "at", "au", "value", "f", "ac", "an", "la", "alpha", "ae", "ea", "aux", "ga", "A", "offset", "as", "u", "h", "aa"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n", "idx": 10322, "substitutes": {"thread1": ["taskOne", "threadOne", " threadb", "Thread1", "threadb", "methodb", "Thread2", "task2", "Threadb", "thread0", " threadone", "threadone", "task0", "task1", "thread3", "process1", " thread3", "method1", "Thread3", "process2", "method3", "processOne", "process0", "methodone", "ThreadOne", "Thread0", "Threadone"], "thread2": [" threadb", "threadb", "methodb", "threadtwo", "threadsecond", " threadsecond", "membersecond", "process1", "member2", "method2", "processsecond", "methodtwo", "member1", "method1", "process2", "processtwo", "elementb", "element2", "element1", " threadtwo", "membertwo", "elementtwo"]}}
{"project": "qemu", "commit_id": "1b27d7a1e8609b2eeb6238f2c629eb82217523f6", "target": 0, "func": "static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,\n\n                                                            uint32_t val)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint64_t write_one = 1;\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if ((dest < 0) || (dest > s->max_peer)) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {\n\n                IVSHMEM_DPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\",\n\n                                                    write_one, dest, vector);\n\n                if (write(s->peers[dest].eventfds[vector],\n\n                                                    &(write_one), 8) != 8) {\n\n                    IVSHMEM_DPRINTF(\"error writing to eventfd\\n\");\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n", "idx": 10327, "substitutes": {"opaque": ["operc", "opacity", " opaca", " opc", "ospaque", "ipc", " opifice", "ipopaca", "operacity", "ospifice", "ospaques", "ospaca", "opaca", "ipopaque", " opaques", "ipacity", " opacity", "ipaque", "ipopifice", "opc", "operaque", "opaques", "opifice", "ipopaques"], "addr": ["alias", "mac", "channel", "adr", "seq", "base", "cmp", "len", "ord", "prefix", "pad", "src", "point", "prot", "x", "pointer", "ad", "data", "ref", "config", "p", "coord", "ace", "attr", "dest", "driver", "amd", "ptr", "loc", "mode", "dr", "host", "code", "db", "alpha", "index", "amp", "v", "route", "sta", "align", "r", "address", "port", "part", "sb", "hop", "offset", "asm", "node", "layer", "pos", "ip", "sid", "mt", "interface", "cmd"], "val": ["vals", "arr", "base", "valid", "len", "sel", "test", "all", "b", "x", "iv", "mem", "stat", "fi", "serv", "buf", "data", "VAL", "slot", "el", "arg", "ref", "lit", "p", "config", "value", "pt", "loc", "xxx", "rot", "db", "unit", "vol", "aval", "py", "al", "eval", "v", "bl", "index", "sl", "ctx", "pre", "elt", "pal", "pos", "ival", "ret", "vec", "buffer"], "s": ["l", "conf", "session", "ts", "ks", "sv", "is", "n", "g", "sites", "ds", "sf", "w", "m", "b", "t", "ops", "d", "gs", "service", "c", "p", "ls", "e", "qs", "private", "rb", "rs", "sq", "us", "f", "os", "an", "js", "sym", "o", "aws", "slice", "S", "v", "es", "sync", "south", "sie", "states", "sl", "state", "r", "ctx", "services", "sb", "hs", "ns", "spec", "this", "sys", "self", "ses", "a", "fs", "site", "ps", "ss", "settings", "ssl"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n", "idx": 10333, "substitutes": {"s": ["sp", "session", "sg", "ts", "ks", "sv", "ds", "n", "g", "is", "its", "w", "src", "b", "t", "ops", "d", "i", "gs", "sa", "c", "p", "e", "qs", "set", "js", "sq", "us", "os", "sk", "an", "ots", "cs", "o", "sets", "scope", "es", "sl", "r", "ns", "sb", "spec", "init", "u", "sys", "self", "ses", "a", "ps", "ss", "ssl", "sc"], "ot": ["oi", "cot", " os", "ox", "dot", "ou", "oc", "it", "O", "nt", "t", "ol", "bs", "c", "ct", "p", "obj", "e", "set", "or", "pt", "gt", "oci", " quot", "op", "rot", "ut", "ac", "ots", "rt", "os", "o", "oti", "j", "cop", "otes", "og", "OT", "ic", "bot", "sn", "mot", "oid", "ott", "sys", "et", "ant", "y", "pot", "ow", "ocr", "so", "iot"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "void test_fcmp(double a, double b)\n\n{\n\n    long eflags, fpus;\n\n\n\n    fpu_clear_exceptions();\n\n    asm(\"fcom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fcom(%f %f)=%04lx \\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    fpu_clear_exceptions();\n\n    asm(\"fucom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fucom(%f %f)=%04lx\\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    if (TEST_FCOMI) {\n\n        /* test f(u)comi instruction */\n\n        fpu_clear_exceptions();\n\n        asm(\"fcomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n        fpu_clear_exceptions();\n\n        asm(\"fucomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n    }\n\n    fpu_clear_exceptions();\n\n    asm volatile(\"fxam\\n\"\n\n                 \"fstsw %%ax\\n\"\n\n                 : \"=a\" (fpus)\n\n                 : \"t\" (a));\n\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n\n    fpu_clear_exceptions();\n\n}\n", "idx": 10338, "substitutes": {"a": ["l", "va", "area", "ama", "n", "af", "access", "na", "da", "ba", "m", "w", "x", "ab", "pa", "d", "sa", "c", "ad", "s", "p", "e", "app", "aaa", "ata", "at", "au", "ia", "ana", "er", "f", "ac", "an", "la", "ai", "fa", "ak", "o", "ae", "j", "alpha", "ea", "oa", "name", "sta", "home", "ar", "r", "am", "ga", "A", "part", "aw", "as", "u", "ast", "self", "aa", "ca", "asa", "ma", "api", "y"], "b": ["l", "ib", "base", "bb", "bad", "abc", "n", "g", "nb", "abb", "ba", "m", "w", "bp", "bar", "k", "ab", "z", "wb", "t", "d", "i", "big", "c", "ad", "fb", "bd", "p", "pb", "e", "cb", "obj", "B", "bo", "f", "bc", "be", "j", "bt", "bf", "o", "eb", "lib", "v", "bh", "home", "r", "lb", "bot", "bis", "bi", "sb", "part", "hub", "emb", "u", "h", "aa", "ob", "bin", "y", "xb", "bs", "mb"], "eflags": ["fflugs", "eflsaga", "eflpags", "suppdlagg", "evlaga", "eflcags", "efLugs", "efLags", "eflcaga", "eflagging", "supplagged", "efragged", "fflagged", "efrlags", "evlushes", " deflpags", "eflcagging", "efbagged", " deflpaps", "efdlushes", "efdlags", "evlugs", "eflages", "eflaga", " deflpaga", "eflars", "eflag", "suppdlags", "eflcages", "efklag", "efragging", "eflsaps", "eflcugs", "efrugs", "evlcaga", "evlcags", "efbasses", "efrag", " deflaps", "efdlars", "ffLagged", "eflugs", "efLages", "efklugs", "efbags", "efdlagged", "fflages", "ffLugs", "efdlaps", "efrlaga", "eflaps", " deflars", "suppdlasses", "efdlasses", "efbagg", "eflsars", "efdlaga", "eflpaga", "efrags", "ffLags", "evlcugs", "supplasses", "evlag", "efklags", "eflsags", " deflpars", "evlagging", "efLagged", "eflushes", "eflpaps", "eflpars", "efdlagg", "evlcushes", "efdlugs", "evlcag", "suppdlagged", "evlags", "eflasses", "eflcag", "evlcagging", "eflcushes", "efrages", " deflags", "efrlushes", "supplagg", "eflcagg", "eflcagged", "fflags", "efrlugs", "ffLages", "eflcasses", "supplags", " deflaga", "eflagg", "efklagging", "eflagged"], "fpus": ["fpos", "vpush", "gpu", "fnus", "fpuse", "printfUS", "phpaus", "fpuss", "cpio", "tpuses", "fpusal", "hpuse", "fpcus", "tpaus", "lpus", "vpcus", "sfos", "tpush", "FPcus", "gpush", "sfUS", "lpuses", "gpcus", "fpums", "lpis", "tpu", "gpis", "hpusal", "FPis", "lpcus", "ulpuse", "FPio", "fpio", "gpio", "lpu", "FPuss", "bpusal", "FPush", "vpu", "FPums", "printfus", "fncus", "FPos", "gpuses", "FPaus", "ulpusal", "FPus", "bpus", "mpuses", "tpsec", "cpcus", "phpums", "mpu", "fnis", "fpuses", "printfu", "mpus", "FPUS", "phpuss", "bpu", "npu", "fnush", "bpuse", "printfsec", "vpis", "npUS", "vpus", "ulpus", "fpUS", "fpaus", "hpu", "ulpu", "gpus", "fnu", "FPsec", "fnUS", "npus", "vpuses", "npuses", "fpush", "lpos", "tpUS", "FPuses", "lpUS", "tpums", "sfuses", "fpsec", "mpUS", "tpuss", "FPu", "cpus", "fpis", "phpus", "tpus", "sfus", "cpuses", "fpu", "hpus"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n\n                             int mmu_idx, target_ulong size)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    hwaddr iotlb, xlat, sz;\n\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n\n\n    assert_cpu_is_self(cpu);\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n\n\n    sz = size;\n\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n\n    assert(sz >= TARGET_PAGE_SIZE);\n\n\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n              \" prot=%x idx=%d\\n\",\n\n              vaddr, paddr, prot, mmu_idx);\n\n\n\n    address = vaddr;\n\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n\n        /* IO memory case */\n\n        address |= TLB_MMIO;\n\n        addend = 0;\n\n    } else {\n\n        /* TLB_MMIO for rom/romd handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 10351, "substitutes": {"cpu": ["boot", "cmp", "proc", "capacity", "processor", "conn", "gpu", "bench", "chip", "net", "pid", "fi", "cp", "vm", "c", "config", "environment", "p", "component", "cli", "fp", "np", "uci", "cn", "gp", "frame", " CPU", "eni", "hw", "pai", "linux", "cv", "process", "ea", "clock", "ctx", "intel", "lb", "program", "loader", "pu", "hp", "pc", "node", "cpp", "CPU", "gru", "platform", "sys", "cache", "lc", "eu", "pkg", "core", "roc", "fc"], "vaddr": ["uendor", " vendor", "vvnode", "vvaddr", "avendor", "faddr", "vnode", "haddress", "vptr", "waddr", "hconfig", " vconfig", " vhost", "cvaddr", " vrf", "vconfig", "vadr", "cvaddress", "vpaddress", "avaddr", "whost", "vhost", "avaddress", "vdr", " vpart", "wpart", "vvadr", "cvendor", "uaddress", " vaddress", "uaddr", "faddress", "phost", "waddress", "vrf", "ppart", "fadr", "cvdr", " vdr", "avptr", "pptr", "fdr", "vendor", "fhost", "hhost", "fendor", "uptr", "pconfig", "vaddress", "frf", "prf", "vpaddr", "vpadr", "vpnode", "fnode", "vpart", "pendor", "vvaddress", "paddress", "haddr"], "paddr": ["laddr", " paddress", "jpaddr", "pad", "waddr", "qaddress", "pnm", "padr", "vpaddress", " pnm", "wadd", "vad", "qptr", "jpadr", "jpad", " padd", "vpad", "waddress", " pad", "qnm", "jpaddress", "vadd", "ladd", "pptr", " padr", " pptr", "jpnm", "vpadr", "vpaddr", "vaddress", "laddress", "jpptr", "wad", "qaddr", "paddress", "padd"], "attrs": ["ttrs", "addls", " attributes", "Attars", "attributes", "ttars", "attrr", "Attr", "attars", "addr", "attr", " attls", "addrs", "ttributes", "attrrs", "attros", "attls", "ttr", "attrros", "addros", "Attributes", "attrls", " attars", "Attrs", " attros", " attr"], "prot": ["rf", "channel", "dim", "seq", "rin", "inet", "ext", "fen", "len", "prefix", "conn", "src", "phy", " protocol", "path", "model", "dt", "plain", "chip", "stat", "pool", "pointer", "data", "config", "uri", "crypt", "lit", "addr", "pro", "cli", "txt", "ocol", "prop", "eni", "rot", "format", "sil", "port", " proto", "col", "type", "platform", "pos", "prototype", "header", "io", "Prot", "ret", "pattern", "lo", "reset"], "mmu_idx": ["mmu__idb", "mmu__idX", "mmu2idx", "mmu_idsn", "mmu_iden", "mmu_itb", "mmu_itX", "mmu_midw", "mmu_lasti", "mmu_vidw", "mmu_midx", "mmu_pidw", "mmu_vidc", "mmu_vidi", "mmu2idb", "mmu_idez", "mmu2idX", "mmu_idsx", "all", "_", "mmu__iden", "mmu_lastx", "mmu__idx", "mmu2idw", "mmu_idew", "mmu_idw", "r", "mmu__idz", "mmu_midX", "mmu_lastw", "mmu_idz", "mmu_midb", "g", "mmu_pidb", "mmu_idec", "mmu_IdX", "mmu_Idx", "mmu__itb", "mmu_idi", "mmu_Idst", "mmu_itst", "mmu_Idb", "mmu_idsz", "mmu__itX", "mmu__itst", "mmu_idst", "mmu__idex", "mmu__idn", "mmu_pidx", "mmu__idez", "mmu_idn", "mmu__ideb", "mmu_idb", "mmu_idc", "mmu_idX", "mmu__itx", "mmu__idst", "mmu_idsb", "mmu_ideb", "mmu_idex", "mmu_lastc", "mmu_idei", "mmu_pidX", "pos", "mmu_itx", "mmu_vidx"], "size": ["iz", "member", "scale", "si", "len", "capacity", "g", "password", "small", "SIZE", "last", "sum", "max", "style", "loc", "Size", "sec", "large", "mode", "empty", "code", "unit", "external", "zero", "shape", "name", "six", "sized", "en", "sn", "full", "eng", "desc", "storage", "offset", "bytes", "esc", "complete", "gz", "length", "engine", "cache", "ize", "core", "sc", "security", "fee"], "env": ["cdn", "conf", "ee", "session", "inet", "kernel", "context", "ext", "fen", "equ", "worker", "conn", "org", "que", "ini", "net", "viron", "export", "ne", "environment", "python", "config", "server", "el", "enable", "e", "np", "gui", "ec", "ass", "eni", "ev", "console", "profile", "assets", "eval", "exc", "ea", "v", "zone", "oa", "energy", "scope", "edge", "loader", "en", "err", "kn", "enh", "eng", "Environment", "enc", "init", "nc", "et", " environment", "her", "cache", "anc", "engine", "eu", "core", "exec"], "section": ["area", "ion", "session", "context", "vision", "ext", "comment", "abc", "region", "ssh", "container", "shadow", "service", "environment", "config", "server", "component", "se", "package", "set", "sector", "ect", "loc", "sq", "array", "protection", "sec", "entry", "sections", "sub", "version", "connection", "ctx", "function", "option", "sect", "ception", "port", "part", "storage", "offset", "setting", "division", "plugin", "Section", "esc", "length", "site", "lc", "cell", "definition", "core", "settings", "security"], "index": ["count", " Index", "element", "ion", "level", "fix", "axis", "len", "val", "access", "prefix", "key", "small", "x", "Index", "update", "include", "pointer", "bridge", "i", "config", "ix", "ace", "value", "action", "loc", "inst", "unit", "append", " length", "slice", "shape", "version", "inc", "column", "ind", "input", "align", "sect", " indexes", "position", "offset", "error", "ticket", "type", "pos", "length", "image", "xxxx", "match", "weight", "fee"], "address": ["alias", "Address", "area", "location", "reference", "byte", "element", "balance", "answer", "enter", "capacity", "region", "prefix", "point", "password", "bridge", "block", "ress", "addr", "output", "ace", "package", "target", "value", "number", "array", "network", "code", "host", "resource", "alpha", "route", "shape", "trace", "order", "name", "account", "align", "contact", "end", "port", "position", "grade", "offset", "node", "type", "pair", "message", "ip", "attribute", "interface", "image", "length", "match"], "code_address": ["code_addr", "code__account", "code2addr", "code__addr", "code2index", " code2address", " code_account", " code_index", "code2address", "code__location", "code__address", "code_index", " code2addr", " code2number", "code_location", " code_addr", " code_location", "code_account", "code2number", "code_number", " code_number", " code2index"], "addend": ["Addstart", "attend", "Adden", " adden", "extset", "Addend", " addest", "extend", "Addended", "pushstart", "addends", " addset", "calluse", "callend", " adduse", "attest", "adduse", " addended", "pushended", " addEND", "callset", "extuse", "attends", "atten", "adden", "Addends", "pushend", "Addest", "addEND", "pushEND", "AddEND", "addended", " addends", "addest", "addstart", "addset", " addstart"], "te": ["Te", "ee", "ts", "je", "le", "ta", "scale", "tile", "ite", "t", "ele", "ve", "ne", "oe", "de", "e", "se", "tes", "pe", "ptr", "ze", "ue", "st", "ie", "be", "code", "ice", "ae", "edge", "tta", "ce", "ti", "tre", "lt", "ten", "ste", "ffe", "elt", "ke", "tm", "ge", "let", "TE", "fe", "tw"], "iotlb": ["otlas", "otlab", "ietlr", "otlr", "etlb", "ioll", "iotl", "iotlr", "etlr", "otlt", "iotlt", "iollt", "otlb", "ietlas", "iollab", "ietlab", "ietl", "etlas", "etl", "ietlt", "otl", "iotlas", "iotlab", "iollb", "ietlb"], "xlat": [" xdat", "wxlit", "wxlat", "ylat", "wxsat", "xxlat", "xlag", "xxlag", "ixhi", "Xdat", "ixflat", "xxdat", "ycat", "xLat", "yla", " xlit", " xla", "xxlit", "xcat", "XLat", "ixla", " xflat", "xhi", "yhi", "xla", "xsat", " xlag", "ixlag", " xsat", "xlit", "xxflat", "xdat", "Xlat", "xxsat", "xxLat", " xcat", " xLat", "xflat", "xxcat", "ixlat", " xhi", "ixcat"], "sz": ["szen", "pszn", "lszn", "tszi", "psZ", "wszi", "pszi", "lsz", "blockszl", "Szi", "sesze", "seszen", "sesz", "szi", "lsze", "blocksz", "Sze", "psze", "szl", "psz", "tszn", " sZ", "Sz", "wsze", "sze", "blockszi", "wsz", " szi", "sZ", "tsze", "Szl", "seszi", " szen", "szn", " szl", "wsZ", "pszen", " sze", "tsz", "blocksze", "lszi"], "vtlb_index": ["vtlb_position", "vtrl_address", "vtrl_position", "vtlb_address", "vtrl_ind", "vtrl_index", "vtlb_ind"]}}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}", "idx": 10355, "substitutes": {"cipher": ["scryption", "chrypt", "encryption", "encrypt", " crypt", "Cursor", "scrypt", "acoder", "acipher", "crypt", "acursor", "chipher", "scortex", "coder", " cortex", "encortex", "acortex", "encairo", "encipher", "cortex", "acairo", "scursor", "acrypt", "encursor", "cairo", "chursor", "scairo", "encoder", "scoder", "Coder", "chairo", "Cairo", "Crypt", "Cipher", "cryption", "scipher", " cryption", "cursor"], "key": ["ee", "base", "KEY", "source", "id", "temp", "open", "k", "net", "ey", "x", "iv", "block", "data", "rule", "close", "server", "secret", "value", "Key", "code", "pub", "size", "version", "index", "name", "connection", "order", "min", "phrase", "cert", "state", "hash", "read", "sign", "copy", "init", "type", "change", "lock", "pair", "message", "ip", "row", "client", "length", "text", "write", "seed", "weight", "transfer", "fee"], "nkey": ["networkbase", "lkey", "nmKey", "lnkey", "Nblock", "pce", "dKey", " nvalue", " nce", "networkorder", "NKey", "dnip", "lnblock", "lvalue", "dnsecret", " nblock", "nKey", " nlarge", "snkey", "pip", "dnorder", "pbase", "nblock", "dnbase", "nsec", "norder", "nmsec", "Nkey", "snvalue", "pkey", "nsecret", " nsec", "pblock", "llarge", " nkeys", "networkip", "porder", "nmkey", "dce", "nbase", "nkeys", "lnkeys", "dnblock", "nce", "networkkey", "nmblock", "pKey", " nKey", "Nsec", "nip", "dkey", " nsecret", "nlarge", "dnkey", "lnsecret", "dnkeys", "snlarge", "dblock", "nvalue"], "errp": ["erp", "errap", "derp", "errorf", "errcp", " errbp", " errvp", "dervp", "errorp", "errorbp", "erap", "armcp", "errf", " errf", " errap", " errfp", "erfp", "ervp", "armf", " errcp", "errbp", "armbp", "derfp", "derap", "armp", "errorcp", "errvp", "errfp"], "ctxt": ["octext", "ctfi", "CTirt", "ectert", "ptkt", "qtXT", "nttxt", "actkt", "antrt", "octtxt", "CTert", "ntext", "cxt", "ptxt", "cext", "ecttxt", "antext", "ptfi", "ctrust", "qtkt", "CTXT", "CTlect", "CTxt", "acttxt", "ctirt", "cirt", "octert", "actext", "ectext", "pttxt", "actrust", "CTfi", "CTtxt", "ctXT", "ctext", "CTkt", "actirt", "antlect", "CTrt", "actXT", "ptext", "ctlect", "ectlect", "octxt", "antxt", "cttxt", "ptrust", "qtxt", "ctrt", "ectrt", "ctkt", "actxt", "ctert", "ntert", "CText", "cXT", "qtext", "ntxt", "CTrust", "ptert", "ectfi", "ectxt", "ectkt"]}}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,\n\n                                    bool is_legacy)\n\n{\n\n    int ret;\n\n    VqInfoBlock info;\n\n    VqInfoBlockLegacy linfo;\n\n    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);\n\n\n\n    if (check_len) {\n\n        if (ccw.count != info_len) {\n\n            return -EINVAL;\n\n        }\n\n    } else if (ccw.count < info_len) {\n\n        /* Can't execute command. */\n\n        return -EINVAL;\n\n    }\n\n    if (!ccw.cda) {\n\n        return -EFAULT;\n\n    }\n\n    if (is_legacy) {\n\n        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        linfo.align = address_space_ldl_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(linfo.queue),\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n        linfo.index = address_space_lduw_be(&address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n", "idx": 10364, "substitutes": {"sch": ["sac", "conf", "sp", "channel", "sh", "src", "ich", "chip", "sw", "ssh", "chid", "chn", "CH", "gh", "squ", "sk", "cs", "isc", "wic", "cht", "sky", "chy", "shop", "inch", "sche", "sl", "chi", "sb", "igh", "usb", "sd", "kh", "spec", "ech", "soc", "ses", "ch", "Sch", "sr", "ocr", "ssl", "sc"], "ccw": ["CChw", "ccwan", "ecy", "ucwa", "ecwal", "accfw", " ccW", "ghw", "rcl", "uccwall", "ghwork", "CCwa", "rcw", "rcwa", "rcW", "ccfw", "CCf", "cwd", "ccy", "CCw", "ccl", "acW", "ucw", "ccn", "ucwall", "ucfw", "uchw", "ccwork", "CCow", "ncw", " cchw", " ccwan", "ghws", "accw", "ccwall", "CCws", "acws", " ccy", "llwan", "ncW", "CCwe", "accW", "ecwd", "ghwall", " ccwd", " ccl", "cff", "ccwal", "ucwork", "ccwe", "cfws", "rcwan", "CCW", "cfW", "cw", "ccwd", " ccwa", "uccw", "cfow", " ccn", " ccws", "cfw", "ccow", "ccf", "cchw", " ccwal", "ncwe", "ecw", "ccW", "CCn", "ucW", "cwal", "ccws", "ucws", "ncws", "llwa", "uccwork", "accwa", "accf", "acw", "rcws", "accow", "cfwa", "cfn", "ccwa", "acwe", "uccws", "CCfw", "llw", "lll", "cy"], "check_len": ["check_count", "checkingcount", " checkercount", "check32length", "check64num", "checkercount", "checkerlen", "check_num", " checkerlen", "check64count", "checkingnum", " check_length", "check64len", "checkablelength", "block_num", "blockingcount", "blockinglength", "check_length", "check32count", "checkinglen", "block_count", " checkerlength", "checkerlength", "checkablelen", "block_length", "blockingnum", "check32len", "block_len", " check_count", "check64length", "blockinglen", "checkablecount", "checkinglength"], "is_legacy": ["is_legace", "is_legimental", "is_Legastic", "is_ledastic", "is_regacy", "is_Legace", "is_legantic", "is_Legantic", "is_regazy", "is_levacy", "is_lowimental", "is_regastic", "is_Legacy", "is_legazy", "is_regACY", "is_levimental", "is_lowACY", "is_ledazy", "is_levace", "is_regace", "is_legastic", "is_ledacy", "is_regimental", "is_lowace", "is_regantic", "is_ledace", "is_legACY", "is_Legazy", "is_levantic", "is_levACY", "is_lowacy"], "ret": ["arr", "valid", "alt", "val", "def", "nt", "Ret", " Ret", "data", "reply", "red", "ref", "arg", "lit", "reg", "rets", "ut", "res", "det", "opt", "aux", "rc", "fun", "att", "hash", "get", "bit", "eth", "fin", "cat", "re", "gc", "RET", " RET", "result", "rev", "mt", "match", "resp", "success"], "info": ["archive", "base", "json", "where", "http", "fw", "block", "config", "cb", "txt", "afi", "thin", "frame", "loc", "opt", "about", "end", "ii", "offset", "now", "orig", "init", "type", "image", "buff", "help", "fi", "alias", "si", "Info", "iso", "id", "i", "information", "work", "app", "f", "op", "index", "py", "hand", "error", "wx", "extra", "zip", "hi", "di", "ext", "def", "data", "util", "part", "cache", "result", "success", "diff", "conf", "ui", "fo", "start", "comment", "update", "job", "service", "INFO", "obj", "off", "bug", "name", "inner", "check", "api", "ignore", "inf"], "linfo": ["lanph", "lineno", "linece", "lenco", "Lincf", "lango", "lanfi", "leneno", "Linfo", "elinfi", "lnjo", "lanfo", "lanf", "lenbo", " Linjo", " Linf", "elinfo", "ilfo", "linetto", "ilph", "lenf", " linzo", "alincf", "synfo", "vinjo", " lingo", "linph", " Linfo", "lintto", "lubo", "lenph", "linjo", "synce", "vinfo", "linso", " linato", "Linjo", "vinf", "synso", "lanato", "elinjo", "elinbo", "lnfi", "lnzo", "Lintto", "synzo", "synf", "linfi", "lufo", "linefo", " linjo", "lingo", "lance", "elinzo", "Linma", "lnph", "luzo", "lenfo", "luso", "vinzo", "linbo", "lancf", "Lingo", "lanco", "vinco", "linego", "vinbo", " Linbo", " linf", "linema", "laneno", "lnfo", " linbo", "lincf", "linato", "alinbo", "elinf", "linco", " linma", "elinco", "Linf", "synato", "linzo", "alingo", "lineph", "Linbo", "linef", "linma", "synco", "Linph", "lanzo", "lneno", " linco", " lintto", " linso", " lineno", "ilbo", "lanbo", "lnbo", "linf", "ilco", "synph", "lenzo", "ilf", "lnf", "synbo", "alinfo", "ilzo", "lince", "vinph", "syneno", "lnco"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 10370, "substitutes": {"client": ["parent", "session", "connect", "http", "container", "config", "ace", "code", "call", "contract", "ce", "connection", "content", "remote", "end", "port", "get", "help", "gu", "prefix", "open", "i", "con", "c", "close", "app", "request", "gui", "current", "callback", "friend", "plugin", "sim", "build", "common", "cell", "secure", "conn", "public", "game", "my", "project", "Client", "data", "util", "cli", "local", "cod", "host", "resource", "new", "custom", "cat", "command", "use", "cache", "core", "co", "start", "comment", "win", "update", "service", "server", "private", "manager", "child", "name", "user", "address", "pc", "cm", "api", "clean", "ci"], "err": ["cr", "acer", "conf", "ler", "arr", "str", "n", "rage", "conn", "fr", "mr", "rr", "erer", "kr", "cer", "gr", "ver", "i", "var", "fy", "Error", "e", "cb", "ace", "ir", "aster", "bug", "rs", "er", "lr", "dr", "found", "res", "finder", "msg", "ind", "order", "ar", "r", "req", "ise", "cor", "error", "here", "rar", "sys", "cfg", "orer", "der", "rx", "dev", "result", "fee", "Er", "sr", "resp", "rh", "fi", "runner"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n", "idx": 10374, "substitutes": {"s": ["session", "ds", "sf", "w", "m", "k", "ssh", "t", "b", "ops", "d", "i", "c", "p", "e", "status", "js", "f", "sym", "o", "sets", "scope", "es", "south", "states", "state", "services", "sb", "spec", "u", "self", "sys", "side", "ips", "secondary", "ses", "fs", "a", "ss", "ssl"], "fd": ["ld", "diff", "xf", "lf", "std", "ds", "rd", "sf", "id", "pid", "d", " fid", "fb", "bd", "pd", "cd", "fp", "cf", " f", "dn", "flow", "df", "f", "dl", "fa", "dir", "fl", "xd", "nd", "nil", "ind", "fx", "md", "dd", "FD", " FD", "dc", "sd", "ecd", "fin", "fn", "handler", "fee", "fc"], "virq": ["virk", "riverke", "riverQ", "virke", "virQ", "riverq", "irq", " virk", "virtQ", " virce", "irQ", "riverk", "varike", "virce", "virtce", " virke", " virQ", "variq", "virtance", "variQ", "virance", "irce", "varik", "irance", " virance", "virtq"]}}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n", "idx": 10385, "substitutes": {"chan": ["sac", "cot", "channel", "cow", "proc", "conn", "Chan", "path", "rec", "buf", "serv", "con", "c", "cp", "comb", "close", "block", "cn", "cho", "bc", "an", "scan", "alloc", "opt", "cap", "rc", "cas", "home", "ctx", "conv", "cur", "can", "circ", "cor", "cat", "sys", "ca", "dev", "ann", "ch", "Channel", "cmd", "gen"], "cond": ["parent", " parent", " condition", " whence", "Cond", " comp", " conditional", "d", " cis", "c", " cas", " pos", " exec", " signal", " latch", "condition", "bc", "ac", "code", " flag", " interrupt", "cl", " code", " co", " error", " err", "comp", "proc"], "opaque": ["obaque", "opacity", "OPacs", "OPaque", "opsesc", "opane", "operacs", " opacs", "iopace", "opsacity", "iopacity", "opacs", "operacity", "iopaque", "ipesc", " opace", "OPaques", " opaques", "ipacity", "opsaque", " opacity", "ipaque", "iopec", " opec", "obacity", "obane", "obesc", "ipane", "opace", "opsane", "opec", "operaque", "opesc", "opaques", "OPacity", "operaques", "obec", "obace"], "chr": [" chro", " chrr", "ichrr", "Chrl", "chrb", "CHr", " chrs", "CHro", " chrl", "ichre", "chro", "chrs", "CHrb", "cherlr", " chdr", "Chrs", "chnr", "Chm", "chcr", "Chr", " chcr", "chre", "shdr", " chlr", "chrr", "cherrr", "shnr", "chm", " chre", "Chro", "chrl", "Chrb", "CHm", "cherre", "Chcr", "chdr", "achre", "shr", " chrb", "CHcr", "CHrl", " chnr", "achnr", "chlr", " chm", "ichlr", "achdr", "shre", "ichr", "achr", "cherr", "CHrs"], "s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "full", "ns", "spec", "self", "settings", "sg", "ds", "si", "n", "your", "sf", "w", "b", "i", "c", "se", "e", "args", "sq", "us", "f", "sym", "sets", "es", "r", "as", "u", "comments", "ps", "su", "fs", "site", "ss", "ks", "g", "ops", "d", "sa", "ls", "os", "cs", "o", "sync", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "conf", "ts", "rows", "service", "p", "server", "qs", "ins", "xs", "js", "rs", "aws", "S", "services", "results", "ms", "h", "ses", "uns"], "status": ["parent", "Status", "sp", "session", "score", "uses", "flag", "active", "str", "si", "g", "comment", "plus", "source", "class", "stats", "stage", "temp", "id", "sw", "update", "stat", "i", "ssl", "server", "e", "xml", "wrapper", "style", "step", "f", "code", "progress", "msg", "flags", "sync", "wait", "response", "magic", "name", "sl", "state", "pre", "err", " Status", "error", "spec", "this", "complete", "result", "cache", "ss", "ess", "STAT", "settings", "success", "security", "ex"], "bufptr": ["ufctr", "bufferPtr", " bufpointer", " bufaddr", "ufaddr", "buffpointer", "buffptr", "ufpointer", "cbaddr", "cbpointer", "buffctr", "buffdr", "bufPtr", "cbdr", "ufdr", "buffaddr", "bufferctr", "cbptr", "bufaddr", "bufferptr", "bufdr", "bufferpointer", "buffPtr", "ufPtr", "ufptr", " bufPtr", "bufctr", " bufdr", "bufpointer"]}}
{"project": "qemu", "commit_id": "a01d8cadadf4c0dad8fc5157ee56aea8ec323982", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406, "substitutes": {"pic": ["oc", "cci", "xi", "pid", "i", "c", "config", "p", "cli", "fp", "ec", "pins", "bc", "ac", "cus", "lib", "ig", "ics", "ic", "jp", "pc", "Pic", "nic", "file", "soc", "lic", "lc", "pict", "jc", "anc", "pot", "mc", "fi", "vec", "pin", "sc", "fc"], "s": ["l", "session", "is", "m", "t", "z", "gs", "v", "state", "groups", "ns", "spec", "self", "settings", "ds", "n", "si", "sites", "your", "sf", "w", "b", "i", "c", "e", "request", "lines", "sq", "f", "j", "sym", "es", "r", "storage", "u", "ps", "su", "fs", "site", "ss", "sv", "g", "features", "sa", "ls", "status", "socket", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "ts", "service", "p", "server", "qs", "js", "rs", "S", "states", "services", "sd", "less", "null", "ses", "y"], "d": ["l", "ld", "diff", "session", "dim", "di", "dh", "ds", "n", "g", "did", "dom", "and", "dict", "da", "w", "m", "id", "dt", "dos", "b", "t", "k", "z", "i", "de", "c", "data", "config", "p", "ad", "ct", "e", "pd", "cd", "q", "dn", "f", "ded", "dl", "j", "db", "device", "dat", "o", "dr", "nd", "sync", "md", "dd", "dc", "sd", "D", "dm", "dy"], "PPC_io_memory": ["PPC_io_mem", "PPC_iogmem", "PPC_ioammemory", "PPC_iogaddress", "PPC_auto_buffer", "PPC_io_address", "PPC_IO_memory", "PPC_iogmemory", "PPC_io_buffer", "PPC_auto_device", "PPC_IO_address", "PPC_auto_memory", "PPC_ioambuffer", "PPC_auto_mem", "PPC_io_Memory", "PPC_ioammem", "PPC_IO_Memory", "PPC_iogMemory", "PPC_ioamdevice", "PPC_io_device", "PPC_IO_mem"]}}
{"project": "FFmpeg", "commit_id": "6d24231e504f71a76a8fabe87c8d7cfa826da75a", "target": 0, "func": "static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n", "idx": 10410, "substitutes": {"avctx": ["aucu", "aveobj", "appcontext", "avcmp", "afctx", "akcmp", "avobj", "avalctx", "avalcontext", "avelc", "appcu", "appqa", "AVqa", "ajconfig", "afcmp", "akca", "avectx", "avcp", "auctx", "avcf", "avecu", "AVcmp", "AVca", "avalcf", "AVcontext", "avcu", "afcf", "avedc", "afcu", "avdc", "aveconfig", "aflc", "AVlc", "ajctx", "aucp", "afconfig", "ajcontext", "AVctx", "avlc", "avconfig", "avcontext", "appctx", "ajcf", "akctx", "avctrl", "avecp", "avca", "ajdc", "afca", "avecf", "afqa", "afdc", "avalobj", "avecontext", "aucontext", "aveqa", "afcontext", "akcontext", "avqa", "ajctrl", "afcp", "avectrl", "afctrl", "afobj"]}}
{"project": "FFmpeg", "commit_id": "14f3f3a1ad9aca7599bdaa399cdb8680c52dc696", "target": 1, "func": "static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb)\n\n{\n\n    v->res_rtm_flag = 1;\n\n    v->level = get_bits(gb, 3);\n\n    if(v->level >= 5)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Reserved LEVEL %i\\n\",v->level);\n\n    }\n\n    v->chromaformat = get_bits(gb, 2);\n\n    if (v->chromaformat != 1)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR,\n\n               \"Only 4:2:0 chroma format supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->postprocflag = get_bits(gb, 1); //common\n\n\n\n    v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1;\n\n    v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1;\n\n    v->broadcast = get_bits1(gb);\n\n    v->interlace = get_bits1(gb);\n\n    if(v->interlace){\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced mode not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    v->tfcntrflag = get_bits1(gb);\n\n    v->finterpflag = get_bits1(gb);\n\n    get_bits1(gb); // reserved\n\n    v->psf = get_bits1(gb);\n\n    if(v->psf) { //PsF, 6.1.13\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Progressive Segmented Frame mode: not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    if(get_bits1(gb)) { //Display Info - decoding is not affected by it\n\n        int w, h, ar = 0;\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display extended info:\\n\");\n\n        w = get_bits(gb, 14);\n\n        h = get_bits(gb, 14);\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display dimensions: %ix%i\\n\", w, h);\n\n        //TODO: store aspect ratio in AVCodecContext\n\n        if(get_bits1(gb))\n\n            ar = get_bits(gb, 4);\n\n        if(ar == 15) {\n\n            w = get_bits(gb, 8);\n\n            h = get_bits(gb, 8);\n\n        }\n\n\n\n        if(get_bits1(gb)){ //framerate stuff\n\n            if(get_bits1(gb)) {\n\n                get_bits(gb, 16);\n\n            } else {\n\n                get_bits(gb, 8);\n\n                get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        if(get_bits1(gb)){\n\n            v->color_prim = get_bits(gb, 8);\n\n            v->transfer_char = get_bits(gb, 8);\n\n            v->matrix_coef = get_bits(gb, 8);\n\n        }\n\n    }\n\n\n\n    v->hrd_param_flag = get_bits1(gb);\n\n    if(v->hrd_param_flag) {\n\n        int i;\n\n        v->hrd_num_leaky_buckets = get_bits(gb, 5);\n\n        get_bits(gb, 4); //bitrate exponent\n\n        get_bits(gb, 4); //buffer size exponent\n\n        for(i = 0; i < v->hrd_num_leaky_buckets; i++) {\n\n            get_bits(gb, 16); //hrd_rate[n]\n\n            get_bits(gb, 16); //hrd_buffer[n]\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 10414, "substitutes": {"v": ["vs", "l", "vi", "va", "sv", "n", "g", "val", "x", "lv", "m", "temp", "k", "b", "t", "vim", "ve", "iv", "ver", "vt", "var", "c", "vm", "s", "ov", "p", "d", "e", "tv", "value", "q", "hw", "f", "j", "ev", "qv", "vol", "o", "version", "nv", "cv", "inv", "vic", "uv", "conv", "V", "vd", "ii", "u", "vr", "dev", "av", "vv", "api", "video", "vg", "vc", "rev", "ch", "vp"], "gb": ["gh", "GB", "gram", "gu", "sg", "gd", "ui", "boot", "bb", "g", "gom", "gio", "go", "phy", "bm", "b", "game", "gm", "gs", "gin", "gl", "ged", "cli", "gold", "gp", "rb", "du", "yg", "cod", "gui", "bc", "gnu", "gal", "gy", "binary", "db", "bf", "cgi", "Gb", "lib", "bg", "eb", "gi", "gg", "google", "gem", "lb", "ga", "sb", "usb", "storage", "git", "kw", "range", "hub", "gru", "gc", "rg", "fc", "ge", "gz", "lc", "gow", "buff", "gam", "kb", "ko", "mb"], "w": ["wl", "l", "wn", "wp", "n", "g", "wa", "win", "m", "wh", "b", "x", "t", "sw", "fw", "d", "wt", "wig", "wb", "z", "s", "work", "max", "we", "p", "c", "wal", "wo", "q", "f", "r", "wx", "wan", "aw", "kw", "u", "ww", "ew", "a", "k", "y", "W", "weight", "ow", "wd"], "h": ["l", "hi", "sh", "he", "ht", "n", "g", "hr", "ph", "hh", "m", "t", "x", "b", "z", "k", "d", "c", "p", "hm", "e", "gh", "q", "f", "o", "ha", "th", "r", "end", "en", "oh", "hs", "kh", "hd", "u", "H", "hl", "ah", "y", "rh", "uh"]}}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 10416, "substitutes": {"address": ["alias", "Address", "adr", "location", "reference", "holder", "start", "enter", "prefix", "pad", "point", "pointer", "data", "config", "add", "server", "uri", "target", "set", "component", "ace", "number", "memory", "array", "socket", "network", "padding", "host", "code", "resource", "index", "shape", "route", "name", "order", "end", "object", "en", "port", "position", "dc", "offset", "node", "type", "pair", "ip", "localhost", "image", "length"], "pc": ["cpu", "arc", "pg", "ota", "tc", "point", "pl", "pid", "pointer", "con", "c", "ref", "pb", "gb", "ocol", "pt", "po", "pm", "ptr", "bc", "cc", "ac", "pn", "code", "py", "amp", "inc", "rc", "port", "ping", "dc", "xc", "type", "nc", "pos", "client", "lic", "lc", "mc", "uc", "PC", "fc"], "puc": ["pucc", "Pcc", "pcc", "pbc", " pucc", "tbc", "Pbc", " pream", "lpream", "ppuc", "tcc", " pUC", "lpucc", "lpuc", "lpcc", " pcc", " pbc", "tuc", "PUC", "pream", "tUC", "ppream", "ppcc", "Puc", "pUC", "ppucc"], "prot": [" protocols", " pref", "seq", "inet", "pg", "len", " clen", "ext", " Protocol", "prefix", " protocol", "cli", "stat", "rect", "pointer", "pool", "bc", "server", "utf", "pro", "fp", "status", "txt", "ocol", "pt", "bits", "ptr", "prop", "lead", " Prot", "rot", "padding", "nat", "code", "primary", "dat", "fl", "ref", "size", "opt", "rog", "flags", "sil", "att", "pre", " len", " PROT", "port", "en", "rep", " proto", "offset", " Proto", "col", "eth", "platform", "pos", "header", "gap", "io", "Prot", "ret", "typ", "lo", "reset"], "p": ["lp", "l", "dp", "parent", "sp", "wp", "pg", "n", "proc", "w", "m", "bp", "point", "t", "b", "page", "pa", "pp", "i", "post", "d", "c", "cp", "s", "pb", "e", "fp", "ep", "np", "pe", "po", "gp", "P", "f", "op", "j", "pkg", "progress", "o", "py", "v", "pr", "pre", "hp", "jp", "tp", "patch", "pi", "part", "u", "api", "ps", "ap", "per", "vp"], "host_start": ["hostlexend", "hostlexstart", "node_end", "server_stop", "host_id", "server_end", "server_pos", "node_id", "host_pad", "host_size", "host_starting", "host_se", "host_stop", "server_starting", "node_pad", " host_size", " host_id", "hostlexpos", "node_start", "host_set", "server_set", "host_pos", "hostlexstarting", "server_start", "server_se"], "host_end": ["server_line", "hostlexend", "host_ends", "hostlexstart", "host_max", "host_line", "host_ended", " host_ends", "hostsend", "hostsEND", " host_send", "hostsstart", "server_max", "server_start", "hostsmax", "host_END", "server_END", "server_end", "hostlexends", "host_send", "server_ended", "hostlexsend"], "addr": ["Address", "ack", "xp", "enter", "arch", "pad", "x", "ad", "ref", "ace", "attr", "amd", "act", "loc", "ac", "code", "amp", "align", "nr", "hop", "offset", "grad", "od", "url", "alias", "mac", "arr", "ord", "id", "work", "index", "md", "r", "en", "position", "error", "eth", "layer", "adj", "nn", "ady", "seq", "ext", "len", "conn", "src", "add", "coord", "ptr", "dr", "host", "rt", "size", "oa", "order", "sta", "rc", "fx", "part", "ast", "vr", "cmd", "adder", "adr", "start", "rr", "origin", "pointer", "obj", "inst", "route", "name", "dd", "pos", "ip", "wd"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);\n\n}\n", "idx": 10429, "substitutes": {"dst": ["cdsrc", "sdsrc", " drc", "dsrc", "dnstr", "drrc", "dnrc", "drc", "sdst", " dstr", "dstr", "cdst", "sdST", "sdrc", " dsrc", "dnst", "dnST", "drST", " dST", "drst", "cdrc", "dST", "drstr", "cdST"], "src": ["img", "rate", "source", "sel", "low", "b", "sur", "iv", "d", "buf", "i", "s", "config", "dest", "cb", "gb", "dist", "ffff", "rb", "loc", "rs", "st", "sec", "bc", "inst", "slice", "bg", "rc", "sl", "sup", "bis", "sb", "grad", "url", "use", "sr", "rob", "rl", "sc"], "stride": ["drone", "STRine", "strade", "ptider", " strip", "shrider", "ptone", "yrided", "ptide", " strided", " strade", "strine", " strider", "strone", "strider", "arride", "arrend", "arrided", "strip", "strend", " strone", "shrine", "drided", "yrend", "STRide", "arrade", "drend", "STRider", "ptided", "drider", "strided", " strend", " strine", "yride", "yrider", "shrip", "drade", "dride", "STRip", "shride"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int film_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 4)\n\n        return 0;\n\n\n\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 10449, "substitutes": {"p": ["lp", "l", "sp", "n", "proc", "m", "bp", "t", "b", "k", "pa", "pp", "i", "pointer", "d", "data", "c", "pb", "e", "fp", "np", "gp", "P", "f", "op", "j", "o", "v", "pre", "jp", "tp", "pc", "u", "api", "ip", "ps", "a", "ap"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,\n\n                       unsigned int size, int mem_index)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv taddr = tcg_temp_local_new();\n\n    TCGv tval = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    dc->postinc = 0;\n\n    cris_evaluate_flags(dc);\n\n\n\n    tcg_gen_mov_tl(taddr, addr);\n\n    tcg_gen_mov_tl(tval, val);\n\n\n\n    /* Store only if F flag isn't set */\n\n    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n    if (size == 1) {\n\n        tcg_gen_qemu_st8(tval, taddr, mem_index);\n\n    } else if (size == 2) {\n\n        tcg_gen_qemu_st16(tval, taddr, mem_index);\n\n    } else {\n\n        tcg_gen_qemu_st32(tval, taddr, mem_index);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */\n\n    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(tval);\n\n    tcg_temp_free(taddr);\n\n}\n", "idx": 10478, "substitutes": {"dc": ["cot", "cr", "cdn", "cow", "oc", "di", "DC", "context", "cca", "da", "conn", "tc", "dt", "fd", "d", "doc", "c", "ct", " DC", "cd", "cb", "cu", "cf", "gui", "ec", "bc", "ac", "df", "cc", "db", "ctrl", "rc", "ctx", "ga", "pc", "xc", "dm", "nc", "cfg", "vc", "anc", "jc", "mc", "uc", "sc", "fc"], "addr": ["adr", "cmp", "ext", "ord", "tch", "iii", "orde", "conn", "src", "tz", "ne", "add", "obj", "ace", "cb", "attr", "au", "amd", "ptr", "loc", "hw", "host", "rt", "ha", "oa", "amp", "rc", "sta", "align", "home", "md", "ctx", "address", "az", "kt", "nr", "endor", "offset", "node", "ast", "rn", "layer", "rx", "ip", "func", "nn", "kk"], "val": ["vals", "Val", "seq", "byte", "base", "valid", "alt", "len", "sel", "def", "all", "b", "stat", "mem", "VAL", "data", "slot", "ref", "arg", "el", "local", "value", "pt", "loc", "la", "db", "vol", "bl", "alloc", "eval", "v", "name", "live", "sl", "tx", "pc", "grad", "pos", "dev", "fee", "lan", "buffer", "fe", "exec"], "size": ["needed", "ui", "sh", "scale", "si", "len", "g", "capacity", "ny", "small", "z", "SIZE", "send", "shift", "c", "sum", "value", "loc", "ec", "Size", "sec", "empty", "eni", "sy", "code", "unit", "v", "sync", "rc", "six", "sized", "ctx", "address", "en", "function", "sn", "here", "enc", "uni", "general", "li", "ci", "length", "ize", "sc", "security", "fee"], "mem_index": ["mem_width", "mem_level", "memenloc", "memory_index", "memory_length", "meminglevel", "memingloc", "memblockindex", "mem_length", "mem_address", " mem_loc", "memory_loc", "memplaceindex", "mem_size", "mem_loc", "memory_level", " mem_address", "memplacewidth", "memblockwidth", "memplaceaddress", "memblockaddress", "memenindex", "memory_size", "memingaddress", "memenaddress", " mem_width", "memingindex"]}}
{"project": "qemu", "commit_id": "947858b0ba97f4ec097de667e45eff99212867c3", "target": 0, "func": "static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n", "idx": 10480, "substitutes": {"opaque": ["obaque", "OPairo", "compaque", "opacity", "Opaques", "OPaque", "compacity", "Opca", "opac", "iopairo", "Opaque", "Opacity", "OPca", "OPque", "iopque", "compca", "iopaque", " opque", " opaques", "ipacity", " opca", " opairo", " opacity", "ipaque", "iopca", "ipac", "obca", "obacity", "ipaques", "compac", "opque", "obac", "opaques", "ipca", "opca", "opairo"], "iocb": ["iocalbi", "iecob", "iocbe", " iocabi", "aioadbe", "iocibc", "icocpb", "iocdb", "iocaba", "iocub", "ueck", "iock", "iocadb", " iocab", "iocombo", "tocbb", "iocob", "uocb", "tocob", "iocationgb", "ioca", " iocub", " iocadb", "iocbb", "iOCb", "iocolob", "uock", "iorga", "toclbr", "iopob", "iocm", "uiecob", "ioadbe", "aiocbe", "iecf", " iomb", "iocombb", "uocm", "iocaldb", "iocationdb", "iocomb", " iomab", "iocolf", "iogbb", "iocomob", "iopf", "iocationb", "iomb", "uiocbb", "uiocob", "uecm", "ioclm", "uocbb", " iocba", "iocibb", "iorgm", " iomub", " ioca", "ioadbc", "iocibe", "iopb", "ioclob", " iocdb", "ioggb", "iocationpb", "iocationbb", "iorgab", "iocationbi", "iOCub", "icocbb", "uiecbb", "icogbb", "iocbi", "uiocf", "aiocbo", "ioadb", "iocpb", "iorgk", "uiecf", "iecbb", "icogb", "iocabi", "ioclbr", "icocgb", "aioadbc", "aiocbc", "aioadbo", "iecpb", "uiecb", "uecb", "iecb", "ioadbo", "iocombc", "icocb", "iogb", "iocombr", "ieck", " ioma", "iocib", "iomab", "ioclk", "iocab", "iocolbb", "iorgbb", "iecgb", "aioadb", "iocbr", " iocaba", "uecbb", "iopbb", "iocgb", "toclbb", "iocf", "iocalba", "iorgb", "iOCab", "iocibo", "iocbc", "iOCa", "iecm", "ioclb", "iorgub", "iocbo", "ioclbb", "iocibr", "iocationba", "icogpb", "tocb", "toclob", "toclb", "aiocb", "iogpb", "iocombe", "iomub", "iocolb", "iocalb", "icoggb", "iociob", "uiocb", "ioma", " iocbi", "tocbr", "iocba"]}}
{"project": "qemu", "commit_id": "ad11ad77748bdd8016370db210751683dc038dd6", "target": 0, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n\n                            abi_long cmd, abi_long arg)\n\n{\n\n    void *argptr;\n\n    struct dm_ioctl *host_dm;\n\n    abi_long guest_data;\n\n    uint32_t guest_data_size;\n\n    int target_size;\n\n    const argtype *arg_type = ie->arg_type;\n\n    abi_long ret;\n\n    void *big_buf = NULL;\n\n    char *host_data;\n\n\n\n    arg_type++;\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        ret = -TARGET_EFAULT;\n\n        goto out;\n\n    }\n\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n\n    unlock_user(argptr, arg, 0);\n\n\n\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n\n    memcpy(big_buf, buf_temp, target_size);\n\n    buf_temp = big_buf;\n\n    host_dm = big_buf;\n\n\n\n    guest_data = arg + host_dm->data_start;\n\n    if ((guest_data - arg) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n\n    host_data = (char*)host_dm + host_dm->data_start;\n\n\n\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n\n    switch (ie->host_cmd) {\n\n    case DM_REMOVE_ALL:\n\n    case DM_LIST_DEVICES:\n\n    case DM_DEV_CREATE:\n\n    case DM_DEV_REMOVE:\n\n    case DM_DEV_SUSPEND:\n\n    case DM_DEV_STATUS:\n\n    case DM_DEV_WAIT:\n\n    case DM_TABLE_STATUS:\n\n    case DM_TABLE_CLEAR:\n\n    case DM_TABLE_DEPS:\n\n    case DM_LIST_VERSIONS:\n\n        /* no input data */\n\n        break;\n\n    case DM_DEV_RENAME:\n\n    case DM_DEV_SET_GEOMETRY:\n\n        /* data contains only strings */\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        break;\n\n    case DM_TARGET_MSG:\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n\n        break;\n\n    case DM_TABLE_LOAD:\n\n    {\n\n        void *gspec = argptr;\n\n        void *cur_data = host_data;\n\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n        int spec_size = thunk_type_size(arg_type, 0);\n\n        int i;\n\n\n\n        for (i = 0; i < host_dm->target_count; i++) {\n\n            struct dm_target_spec *spec = cur_data;\n\n            uint32_t next;\n\n            int slen;\n\n\n\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n\n            slen = strlen((char*)gspec + spec_size) + 1;\n\n            next = spec->next;\n\n            spec->next = sizeof(*spec) + slen;\n\n            strcpy((char*)&spec[1], gspec + spec_size);\n\n            gspec += next;\n\n            cur_data += spec->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        ret = -TARGET_EINVAL;\n\n        goto out;\n\n    }\n\n    unlock_user(argptr, guest_data, 0);\n\n\n\n    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (!is_error(ret)) {\n\n        guest_data = arg + host_dm->data_start;\n\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n\n        switch (ie->host_cmd) {\n\n        case DM_REMOVE_ALL:\n\n        case DM_DEV_CREATE:\n\n        case DM_DEV_REMOVE:\n\n        case DM_DEV_RENAME:\n\n        case DM_DEV_SUSPEND:\n\n        case DM_DEV_STATUS:\n\n        case DM_TABLE_LOAD:\n\n        case DM_TABLE_CLEAR:\n\n        case DM_TARGET_MSG:\n\n        case DM_DEV_SET_GEOMETRY:\n\n            /* no return data */\n\n            break;\n\n        case DM_LIST_DEVICES:\n\n        {\n\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n\n\n\n            while (1) {\n\n                uint32_t next = nl->next;\n\n                if (next) {\n\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n\n                }\n\n                if (remaining_data < nl->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + nl_size, nl->name);\n\n                cur_data += nl->next;\n\n                remaining_data -= nl->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                nl = (void*)nl + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_DEV_WAIT:\n\n        case DM_TABLE_STATUS:\n\n        {\n\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n            int spec_size = thunk_type_size(arg_type, 0);\n\n            int i;\n\n\n\n            for (i = 0; i < host_dm->target_count; i++) {\n\n                uint32_t next = spec->next;\n\n                int slen = strlen((char*)&spec[1]) + 1;\n\n                spec->next = (cur_data - argptr) + spec_size + slen;\n\n                if (guest_data_size < spec->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n\n                cur_data = argptr + spec->next;\n\n                spec = (void*)host_dm + host_dm->data_start + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_TABLE_DEPS:\n\n        {\n\n            void *hdata = (void*)host_dm + host_dm->data_start;\n\n            int count = *(uint32_t*)hdata;\n\n            uint64_t *hdev = hdata + 8;\n\n            uint64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10485, "substitutes": {"ie": ["ani", "zip", "ee", "ide", "qt", "je", "le", "img", "ext", "ife", "nice", "die", "ite", "ini", "job", "ne", "oe", "IE", "isi", "lit", "e", "cli", "ace", "fit", "lex", "plug", "ze", "ec", "eni", "oci", "nat", "pie", "ice", "eg", "eb", "edge", "ig", "ce", "lie", "sie", "exe", "intel", "ei", "ii", "ime", "li", "irc", "ip", "ci", "ge", "ni", "ine", "tie", "iu"], "buf_temp": ["buf_test", " buf_test", "uf_tem", "uf_num", "buf_tmp", " buf_cache", "buf_cache", "uf_temp", "buflextest", "buf_base", "buff_orig", "uf_buffer", " buf_current", "bufjorig", "buf1num", " buf_tem", "buff_temp", "buf_orig", "buf_num", " buf_tmp", "bufjtemp", "bufjporary", "buf_buffer", "buflexcurrent", "buff_tem", "buf1temp", "buff_porary", "buf_porary", "buflextemp", "buff_base", "buf1tem", "buflextem", "buff_cache", "bufjtem", "buf1buffer", "buf_current", "buf_tem"], "fd": ["std", "ds", "win", "def", "d", " fid", " fs", "ffff", " f", " def", "f", "df", "iff", "rc", " dc", "fff", "FD", "dc", " FD", "enc", "fin", "nc", "file", "Arg", "fi", "fe", "fc"], "cmd": ["mac", "seq", "gen", "gd", "cmp", "window", "def", "conn", "method", "buf", "config", "cb", "cli", "mode", "ctl", "ctr", "opt", "msg", "md", "Cmd", "desc", "dc", "cat", "cfg", "command", "client", "header", "alg", "bind"], "arg": ["mac", "arc", "arr", "param", "byte", "argument", "flag", "ext", "str", "g", "val", "len", "win", "pad", "nt", "ang", "num", "mem", "var", "ad", "doc", "slot", "addr", "ref", "ace", "target", "reg", "star", "amd", "ag", "args", "loc", "prop", "sec", "gt", "dr", "entry", "call", "index", "amp", "msg", "parse", "ig", "input", "inc", "ar", "end", "load", "nick", "enc", "bit", "init", "cat", "use", "result", "Arg", "gen", "inter", "exec"], "argptr": ["argumentptr", "argspad", " argbf", "arrot", "argpt", "argpointers", "paramPtr", "docpt", "arpt", "inptr", " argrot", "argbf", "arPtr", "argumentpointer", " argpointers", "parptr", "docptr", "parPtr", "argumentPtr", "docPtr", "ackptr", "ackpointer", "ackPtr", "parpointer", "paramptr", "Argpad", "inpointers", "argspointer", "ArgPtr", "parambf", " argpad", "Argrot", " argPtr", "arpointer", "arptr", "argfp", "Argpointer", "argPtr", "argrot", "argumentbf", "ackrot", "argsPtr", "argpointer", "parpointers", "Argptr", "paramfp", " argfp", "argumentfp", "docpointer", "argpad", "inpointer", "inPtr", " argpt", " argpointer", "argumentrot", "argsptr"], "host_dm": [" host_nm", "hostPooldom", "hostalldt", "host_dt", "host_cm", "host_module", "hostalldm", "hard_fm", "host__dt", "server_dt", " host_dom", " host_bm", "host_dc", "port_md", "hostallfm", "hostPoolbm", "client_dn", "Host_dm", " host_db", "host_dim", "host_metadata", "hostacdn", "host__module", "Host_cm", "hostingdl", "hard_dm", "server_data", "host_bm", "host_dl", "server_dm", "server_fm", " host_dt", "client_dl", "host__dim", "client_metadata", "hostacdl", "host_nm", "hostPooldm", "host_db", "hard_module", "hostalldata", "client_dm", "Host_dt", " host_fm", "port_dm", "port_dim", "hostingdm", "hostingmetadata", "hard_dim", "host_fm", "host_dom", "host__dm", "port_dc", "Host_fm", "host__data", "host_dn", "host_md", "hostacmetadata", "hostacdm", "host__fm", "hostingdn", "hostPooldb"], "guest_data": ["guestingbuf", "guestingData", "guest_di", "guest_size", "guestingdat", "guest_buf", "guesting_dat", "guesta_alpha", "guestingiondat", "guestingdata", "guest__data", "guestfulldi", "guest__Data", "guestiondef", "guest_alpha", "guestfulldata", "guester_buf", "guestiondata", "guesta_data", "guester_size", "guestinglength", "guest2Data", "guesting_def", "guestiondi", "guestiondat", "guester_Data", "guest__size", "guest_length", "guesting_di", "guesta_dat", "guester_data", "guester_dat", "guest_dat", "guest__dat", "guest_Data", "guestfulldef", "guestingiondef", "guesting_data", "guestingiondi", "guest2data", "guest2buf", "guestingalpha", "guest_def", "guesta_length", "guest2dat", "guestingiondata", "guestfulldat"], "guest_data_size": ["guest_action_capacity", "guest_data_capacity", "guest_Data_length", "guest_Data_size", "guest_data_form", "guest_data_length", "guest_data_pos", "guest_action_form", "guest_data_start", "guest_action_pos", "guest_Data_start", "guest_data_address", "guest_Data_address", "guest_action_size", "guest_Data_scale", "guest_data_scale"], "target_size": ["arget_len", "arget_size", " target_start", "target64len", "target64size", "target64capacity", "targetedsize", "arget_name", "arget_capacity", " target_name", "arget_sized", "targetedstart", " target_sn", "target_len", "targetedname", "arget_start", "target64sized", "target_start", "target_name", "target_SIZE", "target_capacity", "target_sized", "target_sn", " target_SIZE"], "arg_type": ["arg_typ", " arg_num", "argvtype", "arg_order", "err_type", "int_type", "arglexrole", "int_role", "arg_spec", "arg_width", "cat_spec", "arg_num", "cat_name", "argxtype", "arglextype", "argfname", "argfformat", " arg_size", "argvname", "argxname", "errlentyp", "int_types", "arglentype", "arg_size", "argrtype", "argargorder", "argvwidth", "argxnum", "argrname", "err_name", "arg_format", "arglentyp", "argrsize", " arg_format", "arglextypes", "arg_role", "arglenname", "errlenname", "arg_name", "arg_types", "arglexorder", "int_order", "err_typ", "argxsize", "argargtypes", "argargrole", "cat_width", "argargtype", "argrnum", "errlentype", "argftype", " arg_name", "cat_type", "argvspec"], "ret": ["seq", "flag", "debug", "alt", "val", "len", "def", "nt", "Ret", "num", "mem", "job", "pat", "reply", "output", "ref", "lit", "reg", "usr", "gt", "rets", "sec", "ut", "rt", "res", "eval", "det", "opt", "rc", "fun", "att", "hash", "bit", "cat", "gc", "re", "RET", "back", "let", "result", "rev", "ft", "resp", "feat", "mt", "buffer", "match", "success"], "big_buf": ["real_buffer", "real_buf", "big54bu", " big_buff", "big_bu", "big___batch", "real_buff", "big54buff", "real___buf", "big_tmp", "real___buffer", "big___bu", "bigxbuff", "real_batch", "home_buf", "big__buf", " big_vec", "big__buff", "big54vec", "bigxuf", "home54buffer", "home54tmp", " big_tmp", "bigxbuf", "big_uf", " big_buffer", " big_uf", "big___buffer", "big_vec", "home_buffer", "bigxtmp", "big_batch", "big54buf", "big_buffer", "big_buff", "home54uf", " big_bu", "home_tmp", "home54buf", "big54buffer", "big__uf", "big___buf", "big__buffer", "home_uf", "big54uf", "big___buff", "real___buff", "big54tmp", "big___vec", "real___batch"], "host_data": [" host_slice", " host_dat", "hostsdat", "master_addr", "hostsdata", "host_dat", "host_size", "hostssize", "hostacslice", "master_data", "hostacdata", "host_addr", "master_size", "hostacdat", "hostacdm", "host_slice", "master_dat", "hostsaddr"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)\n\n{\n\n    InputStream        *ist = s->opaque;\n\n    DXVA2Context       *ctx = ist->hwaccel_ctx;\n\n    int                ret;\n\n\n\n    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_frame_copy_props(ctx->tmp_frame, frame);\n\n    if (ret < 0) {\n\n        av_frame_unref(ctx->tmp_frame);\n\n        return ret;\n\n    }\n\n\n\n    av_frame_unref(frame);\n\n    av_frame_move_ref(frame, ctx->tmp_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 10498, "substitutes": {"s": ["sed", "sg", "ks", "sv", "ds", "is", "si", "source", "sf", "src", "gs", "iss", "c", "sa", "service", "ls", "lex", "sq", "sec", "os", "f", "st", "cs", "es", "sts", "sl", "support", "ns", "sb", "storage", "sd", "spec", "as", "sys", "self", "ses", "ps", "fs", "ss", "so", "ssl", "sc"], "frame": ["cpu", "setup", "pse", "Frame", "base", "frames", "source", "view", "scene", "info", "fr", "point", "rame", "phy", "data", "fb", "config", "fram", "thread", "e", "ace", "cf", "fact", "ze", "flow", "f", "none", "dr", "code", "host", "slice", "fake", "ce", "fx", "feature", "iframe", " Frame", "document", "kt", "object", "framework", "part", "cfg", "coe", "file", "video", "image", "interface", "feat", "fi", "fe", "za", "fc"], "ist": ["ld", "ide", "adr", "wp", "asp", "est", "irst", "nt", "IST", "alist", "ais", "isd", "ists", "iss", "ad", "isi", "ost", "iste", "dist", "pt", "ir", "aci", "st", "inst", "rt", "isc", "osi", "ind", "sta", "ird", "kt", "sd", "pect", "esp", "ast", "ista", "et", "ict", "ess", "ism", "imet"], "ctx": ["cr", "mac", "qt", "cam", "wp", "context", "cmp", "Context", "cca", "conn", "que", "sci", "fw", "c", "cp", "ct", "config", "cu", "cli", "cf", "cn", "wcs", "ec", "sq", "coll", "loc", "cc", "cs", "ctrl", "cv", "ck", "sync", "ce", "cas", "tx", "kt", "pc", "cor", "xc", "wx", "cfg", "nc", "cm", "ca", "cycle", " context", "ci", "comp", "css", "vc", "anc", "cmd", "lc", "pkg", "cus", "cy", "sc", "fc"], "ret": ["rf", "base", "bad", "flag", "ext", "alt", "val", "len", "ry", "def", "nt", "id", "Ret", "t", "mem", "pat", "data", "run", "arg", "ref", "obj", "reg", "usr", "pt", "or", "rb", "gt", "rets", "j", "code", "rt", "res", "bf", "det", "opt", "rc", "fun", "att", "req", "r", "en", "end", "art", "bit", "fin", "re", "cat", "RET", "back", "result", "mt", "ft", "rev", "success", "pet", "fab"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,\n\n                    uint8_t *segment, uint8_t *ref, int layout)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (s->segmentation.update_map)\n\n        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);\n\n    else if (s->segmentation.enabled)\n\n        *segment = ref ? *ref : *segment;\n\n    mb->segment = *segment;\n\n\n\n    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;\n\n\n\n    if (s->keyframe) {\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,\n\n                                    vp8_pred16x16_prob_intra);\n\n\n\n        if (mb->mode == MODE_I4x4) {\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);\n\n        } else {\n\n            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;\n\n            if (s->mb_layout == 1)\n\n                AV_WN32A(mb->intra4x4_pred_mode_top, modes);\n\n            else\n\n                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);\n\n            AV_WN32A(s->intra4x4_pred_mode_left, modes);\n\n        }\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                vp8_pred8x8c_prob_intra);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {\n\n        // inter MB, 16.2\n\n        if (vp56_rac_get_prob_branchy(c, s->prob->last))\n\n            mb->ref_frame =\n\n                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */\n\n                                                      : VP56_FRAME_GOLDEN;\n\n        else\n\n            mb->ref_frame = VP56_FRAME_PREVIOUS;\n\n        s->ref_count[mb->ref_frame - 1]++;\n\n\n\n        // motion vectors, 16.3\n\n        decode_mvs(s, mb, mb_x, mb_y, layout);\n\n    } else {\n\n        // intra MB, 16.1\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);\n\n\n\n        if (mb->mode == MODE_I4x4)\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                s->prob->pred8x8c);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n        mb->partitioning     = VP8_SPLITMVMODE_NONE;\n\n        AV_ZERO32(&mb->bmv[0]);\n\n    }\n\n}\n", "idx": 10502, "substitutes": {"s": ["l", "conf", "session", "sg", "ts", "ks", "sv", "ds", "n", "si", "g", "is", "sf", "w", "m", "b", "t", "d", "gs", "service", "p", "ls", "e", "se", "qs", "cli", "sq", "js", "rs", "f", "os", "us", "sec", "j", "cs", "o", "aws", "sym", "sets", "S", "es", "sync", "v", "sl", "services", "r", "ns", "sb", "storage", "sis", "spec", "com", "sys", "sim", "self", "h", "ses", "su", "ps", "fs", "ch", "ss", "bs", "ssl", "sc"], "mb": ["ym", "mac", "ib", "byte", "base", "bb", "em", "mn", "pg", "nb", "ph", "mor", "m", "bp", "bm", "b", "k", "ab", "mm", "mem", "job", "gs", "MB", "vm", "fb", "bd", "pb", "e", "p", "gb", "rb", "bc", "mode", "db", "fm", "mp", "bf", "eb", "bg", "bl", "v", "gg", "md", "lb", "mod", "sm", "sb", "amb", "usb", "ms", "emb", "cp", "cfg", "cm", "ob", "mt", "xb", "bs", "mc", "kb"], "mb_x": ["MB_xy", "mp_x", "MB_name", "mb_xy", "bb_x", "mp_i", "bb_y", "mb_ex", "bb_ex", "MB_y", "mb_width", "MB_x", "mb_name", "mb_type", "mb_i", "mp_y", "bb_type", "mp_width"], "mb_y": ["mb1x", "MB_i", "mb1Y", "mb1y", "MB_Y", "mb1i", "MB_y", "MB_x", "mb_Y", "mb_i"], "segment": [" segments", " semission", "seignment", "psegment", "gegments", "SEgments", "algment", "SEgment", "gegement", "alignment", "SEgement", "SEignment", "pegments", "psegement", "persegments", "asegement", "gegment", "persement", "gement", "asement", "psegments", "pemission", "asegment", "segement", "aseignment", " segement", "psement", "megment", "megement", "sement", "pegement", "semission", "mement", " sement", "pegment", "segments", "alment", "persegment", "persemission", "algement", "SEment", "asegments", "megments", "pement"], "ref": ["parent", "diff", "rf", "count", "conf", "location", "reference", "seq", "base", "alt", "af", "prefix", "def", "id", " reference", "fr", "info", "ab", "num", "include", "block", "config", "local", "rel", "relative", "Ref", "loc", "f", "mode", "primary", "bf", "href", "index", "route", "remote", "raw", "pre", "part", "offset", "type", "re", "pos", "url", "image", "comp", "absolute", "range", "REF"], "layout": ["parent", "diff", "scroll", "location", "delay", "Layout", "shell", "view", "def", "id", "board", "model", "lim", "mount", "num", "slot", "config", "qa", "xml", "loc", "flow", "mode", "la", "unit", "bf", "shape", "route", "repeat", "lay", "cl", "position", "offset", "lang", "layer", "loop", "cell", "lc", "fc"], "c": ["l", "center", "channel", "arc", "oc", "C", "n", "g", "w", "m", "conn", "b", "t", "k", "d", "con", "ct", "config", "p", "e", "cu", "cf", "ec", "cc", "f", "bc", "ac", "code", "cs", "o", "cus", "v", "ce", "rc", "ctx", "r", "cur", "cl", "dc", "pc", "xc", "com", "cms", "u", "nc", "h", "ca", "cm", "ci", "vc", "ch", "lc", "cmd", "jc", "cache", "mc", "uc", "cy", "sc"], "ref_frame": ["reference_model", "reference_thread", "refbframe", "refbmodel", "reference_mode", "ref_thread", "refbthread", "refpremodel", "refpreframe", "refpremode", "refprethread", "reference_frame", "ref_model", "ref_mode", "refbmode"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    /* make sure instructions are on a halfword boundary */\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    /* Enforce properly-sized instructions in a delay slot */\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            /* GP */\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            /* MOVEP */\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n", "idx": 10504, "substitutes": {"env": ["cot", "fg", "chal", "cdn", "conf", "qt", "pec", "context", "equ", "conn", "org", "info", "que", "iv", "viron", "environment", "e", "cb", "qa", "erv", "txt", "np", "priv", "ec", "manager", "inst", "ev", "db", "cv", "ea", "oa", "scope", "exc", "cal", "en", "err", "Environment", "enc", "esp", "cfg", "dev", "her", "eu", "pkg", "fi"], "ctx": ["utils", "cmp", "Context", "na", "sci", "fw", "gs", "config", "qq", "cb", "np", "txt", "cn", "wcs", "loc", "cc", "cas", "kt", "cpp", "concept", "gc", "nc", "ca", "grad", "rx", "pkg", "settings", "fc", "ku", "prefix", "cca", "c", "ct", "cf", "sq", "hw", "bc", "conv", "wx", "anc", "lc", "sc", "exec", "std", "context", "conn", "src", "cp", "util", "cli", "cs", "ctrl", "progress", "linux", "ck", "sync", "rc", "ga", "tx", "jp", "xc", "kw", "fn", "comp", "vc", "cmd", "qa", "console", "lib", "cv", "support", "pc", "git", "cm", "client", "ci", "kb"], "is_branch": ["is_bracket", "is_braged", "is_backet", "is_baluster", "is_refanch", "is_balanch", "is_banch", "is_baged", "is_buster", "is_refaged", "is_bruster", "is_refacket", "is_balaged", "is_refuster", "is_balacket"], "op": ["tool", "pol", "sp", "vert", "oc", "it", "operator", "operation", "ext", " Op", "proc", "prefix", "opus", "ops", " ip", "top", "ver", "rop", "addr", "p", "prev", "OP", "oop", "ep", "off", "bug", "prop", "mode", "dr", "omp", "cop", "opt", "msg", "name", "opp", "Op", "mod", "option", "ipop", "hop", "oper", "bit", "type", "cat", "lock", "ip", "ant", "lic", "cmd", "ap", "expr", "pop"]}}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)\n\n{\n\n    int i;\n\n    int vlc    = get_bits1(&q->gb);\n\n    int start  = cplband[p->js_subband_start];\n\n    int end    = cplband[p->subbands - 1];\n\n    int length = end - start + 1;\n\n\n\n    if (start > end)\n\n        return;\n\n\n\n    if (vlc)\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);\n\n}\n", "idx": 10513, "substitutes": {"q": ["dq", "qt", "sh", "context", "pg", "g", "view", "w", "m", "id", "k", "que", "t", "z", "d", "iq", "c", "qu", "ct", "config", "qq", "qs", "qa", "e", "xml", "queue", "local", "app", "cf", "sq", "f", "quest", "j", "v", "rc", "query", "cur", "req", "ctx", "qi", "cl", "mail", "u", "h", "Q", "charge", "comp", "cache", "ch", "core", "question"], "p": ["lp", "l", "sp", "param", "wp", "n", "w", "m", "bp", "t", "b", "k", "pa", "d", "pp", "post", "c", "cp", "s", "pb", "e", "np", "po", "pm", "P", "parser", "op", "f", "j", "pkg", "o", "py", "cop", "parse", "v", "pr", "pre", "tp", "pi", "part", "pc", "plugin", "u", "api", "ip", "ps", "params", "press", "ap", "per", "vp"], "decouple_tab": ["decouple__table", "decouple__tag", "decouplethebag", "decouple__bag", "decouple_tag", "decouple__lab", "decouple2ab", "decouplethetab", "decourage_window", "decourage_tab", "decouple_bag", "decouple_ab", "decouple2tag", "decouple_window", "decouple2window", "decouple__tab", "decouple__ab", "decourage_table", "decourage_lab", "decourage_ab", "decouple2tab", "decouplethetable", "decourage_tmp", "decouple_table", "decourage_tag", "decouplethetmp", "decouple_tmp", "decourage_bag", "decouple_lab", "decouple__window"], "i": ["oi", "l", "ui", "di", "it", "start", "si", "n", "g", "in", "zi", "adi", "id", "xi", "m", "info", "b", "k", "t", "z", "x", "ini", "d", "c", "ji", "ix", "uri", "e", "yi", "eni", "f", "ie", "j", "ai", "o", "multi", "v", "ind", "ti", "gi", "phi", "end", "abi", "qi", "ei", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "a", "length", "ni", "io", "lc", "ri", "fi", "iu"]}}
{"project": "FFmpeg", "commit_id": "d1f3e475f9807b445ba37ff2fd23f71c4645de79", "target": 1, "func": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n", "idx": 10520, "substitutes": {"pkt": ["hkt", "cpacket", "cpkg", " pet", " packet", "het", "bkt", "backet", "ppkt", " pkg", "mkg", "Pnt", "cpct", " pnt", "cpeth", "cpet", "Pkt", "cpnt", "Pet", "bnt", "hacket", "Pcht", "cpkt", "mkt", "packet", "bet", "ppacket", "ppcht", "pnt", "Pct", "Packet", "macket", "pcht", "hnt", " pct", "meth", " peth", "pct", "ppct", " pcht", "pkg", "peth", "pet"], "pkt_data": ["packet_data", "pkt_buffer", "packet_buffer", "packet_memory", "packet_parts", "packet_cache", "pkt_memory", "pkt_parts", "pkt_cache"], "pts": [" ptstats", "ntds", "ptments", "ntts", " ptss", "portds", "ptsets", " ptsstats", "cts", "ports", "portts", "ptd", "oints", "periodd", "ctts", "ctments", "periodts", "ntments", "ptds", "pullts", "ointstats", "ointss", "nts", "ntd", "ptss", " ptsets", " ptssets", "ptstats", "periods", "ctds", "pulld", "ptts", " ptsss", "pulls", "ointsets", "portments"], "ret": ["base", "valid", "flag", "ext", "len", "val", "alt", "def", "nt", "Ret", "t", "num", "reply", "lit", "obj", "status", "rets", "f", "code", "rt", "res", "bf", "det", "al", "fun", "att", "en", "part", "art", "eth", "fin", "cat", "re", "et", "RET", "back", "out", "result", "mt", "ft", "match", "rev", "flat", "fi", "success", "pet"], "data": ["parent", "map", "arr", "di", "base", "valid", "start", "media", "window", "pad", "da", "record", "missing", "d", "buf", "ad", "config", "p", "reader", "batch", "parts", "package", "ata", "ada", "addr", "memory", "array", "body", "DATA", "code", "dat", "resource", "zero", "size", "alpha", "slice", "input", "connection", "content", "current", "raw", "done", "address", "results", "dd", "new", "load", "Data", "part", "bus", "bytes", "message", "api", "a", "image", "cache", "result", "bin", "partial", "buffer"]}}
{"project": "FFmpeg", "commit_id": "54b2d317ed99622efa07b10aca217e1a083105d9", "target": 0, "func": "static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){\n\n    int i,j,k,m;\n\n    double l2tab[256];\n\n\n\n    for(i=1; i<256; i++)\n\n        l2tab[i]= log2(i/256.0);\n\n\n\n    for(i=0; i<256; i++){\n\n        double best_len[256];\n\n        double p= i/256.0;\n\n\n\n        for(j=0; j<256; j++)\n\n            best_len[j]= 1<<30;\n\n\n\n        for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){\n\n            double occ[256]={0};\n\n            double len=0;\n\n            occ[j]=1.0;\n\n            for(k=0; k<256; k++){\n\n                double newocc[256]={0};\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        len -=occ[m]*(     p *l2tab[    m]\n\n                                      + (1-p)*l2tab[256-m]);\n\n                    }\n\n                }\n\n                if(len < best_len[k]){\n\n                    best_len[k]= len;\n\n                    best_state[i][k]= j;\n\n                }\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        newocc[    one_state[    m]] += occ[m]*   p ;\n\n                        newocc[256-one_state[256-m]] += occ[m]*(1-p);\n\n                    }\n\n                }\n\n                memcpy(occ, newocc, sizeof(occ));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10539, "substitutes": {"best_state": ["best_config", "one_cell", "oneegercell", "onesstate", "bestalorder", "best_reg", " best_loc", "oneegerstring", "onesstring", "oneegerstate", "oneegerconfig", "best_cell", "onescell", "onesconfig", "best_order", "one_string", "one_config", "best_string", " best_reg", "bestalloc", "bestalstate", "bestalreg", "best_loc", " best_order"], "one_state": ["one_slice", "one_scale", "one_type", " one_type", "one_area", "one_states", "one_string", "one_part", "one_system", " one_string"], "i": ["oi", "l", "ui", "di", "it", "is", "si", "n", "in", "zi", "xi", "id", "x", "ini", "z", "my", "b", "ami", "ji", "c", "p", "ix", "uri", "e", "yi", "mini", "eni", "q", "f", "ie", "ai", "o", "multi", "v", "gi", "mi", "ik", "qi", "im", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "api", "io", "ni", "y", "ri", "fi", "iu", "ki"], "j": ["l", "dj", "ui", "je", "it", "start", "n", "g", "key", "w", "jet", "x", "b", "z", "t", "d", "job", "jen", "ji", "c", "s", "p", "jo", "e", "kj", "q", "js", "f", "ie", "uj", "o", "v", "r", "qi", "ij", "jp", "ii", "ja", "u", "aj", "h", "oj", "li", "J", "ni", "y", "ch", "jc", "jl", "jj"], "k": ["l", "km", "ek", "ks", "n", "g", "ph", "key", "w", "b", "x", "z", "mm", "d", "c", "wk", "s", "p", "e", "ok", "kk", "q", "ak", "f", "sk", "o", "ck", "v", "ky", "ik", "r", "kin", "kn", "K", "uk", "kw", "ke", "u", "h", "y", "ch", "ki", "ko"], "m": ["l", "km", "ym", "man", "em", "mn", "n", "g", "w", "mr", "bm", "b", "z", "mm", "d", "x", "gm", "c", "s", "p", "hm", "e", "mu", "pm", "q", "f", "an", "fm", "o", "module", "v", "mi", "r", "md", "am", "im", "sm", "u", "dm", "h", "cm", "t", "ma", "a", "y", "um", "M", "mc", "om"], "l2tab": ["r3lab", "l3loc", "l2buff", "l_ab", " l2Tab", "l5loc", " l1loc", "r2loc", " l4loc", "l1loc", "r3tab", " l2ab", "l1tab", " l2mem", " l2loc", "l_mem", "l3ab", "l2mem", "l_lab", "r2lab", "r2tab", "l2ab", "l2loc", " l2buff", "r2ab", "l3lab", "l5Tab", "l1lab", " l2lab", "l4loc", "l5tab", "l3mem", "l4tab", "l2Tab", "l4lab", " l1buff", " l1lab", " l4Tab", "l1buff", "l5lab", "r3ab", "l62tab", " l1tab", "l4mem", " l4tab", "l1Tab", "r3loc", "l4ab", "l3tab", "l2lab", "l3buff", "l62buff", "l_loc", "l1ab", "l62lab", "l4Tab", "l_tab", " l4mem", " l4ab", "l62loc", " l4lab"], "best_len": ["better_len", "best2lon", " best_pos", "better_val", "best_lit", "best___len", "best_sum", "bestParpos", "bestParlen", "best_val", "best2val", " best_sum", "best_lon", "best___lon", " best_lon", " best_norm", "bestenlabel", "bestensum", "better_lin", "best2norm", " best_Len", "best_lin", "best___val", "best___norm", "best_norm", "bestenlen", "best_label", " best_val", " best_label", " best_id", "best_pos", "bestenpos", "bestParsum", " best_lit", "best_id", "best_Len", "best2len", "better_pos", "bestParlabel"], "occ": ["seq", "eff", "oc", "arr", "cci", "abc", "events", "roc", "org", "pl", "mult", "auc", "cont", "z", "rec", "toc", "comb", "config", "app", "mu", "coord", "cf", "pha", "feed", "ec", "loc", "oci", "cc", "ac", "coll", "bc", "bec", "dat", "ae", "index", "bl", "exc", "inc", "ind", "cons", "cur", " circ", "err", "resp", "charges", "ffe", "address", "circ", "cl", "frac", "com", "enc", "oper", "form", "nc", "aug", "charge", "result", "inf", "ah", "anc", "Occ", "feat", "rh", "acc", "fe", " rec", "uc", "fc"], "newocc": ["NewOcc", "Newocc", " newacc", "Newacc", "NEWloc", " newexc", "Newexc", "nextacc", " newloc", "newloc", "NEWacc", "newcirc", "NEWocc", " newOcc", "updateOcc", "newOcc", "updateocc", "newacc", "newexc", "nexteff", " neweff", "nextOcc", "Neweff", "neweff", "Newloc", "NEWOcc", "updateexc", " newcirc", "updateacc", "nextocc", "Newcirc"]}}
{"project": "FFmpeg", "commit_id": "ff486c0f7f6b2ace3f0238660bc06cc35b389676", "target": 0, "func": "static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n", "idx": 10547, "substitutes": {"s": ["session", "sg", "ts", "sv", "context", "ds", "n", "si", "g", "is", "sf", "w", "m", "http", "t", "b", "i", "gs", "service", "c", "p", "ls", "e", "se", "qs", "xs", "sq", "js", "f", "cs", "sym", "o", "aws", "sets", "S", "es", "sky", "sync", "space", "services", "ns", "sb", "storage", "spec", "u", "self", "sys", "sim", "side", "ses", "ps", "su", "site", "ss", "fs", "settings", "ssl"], "x": ["l", "n", "ax", "xx", "w", "xi", "m", "id", "t", "b", "z", "d", "i", "c", "X", "p", "ix", "max", "e", "pe", "xs", "f", "height", "index", "size", "v", "fx", "tx", "u", "h", "xy", "rx", "px", "image", "dx", "ex"], "y": ["ym", "ady", "yt", "oy", "ry", "ny", "w", "b", "ey", "vy", "z", "t", "i", "ys", "p", "cy", "iy", "yi", "ay", "zy", "sy", "yy", "j", "height", "py", "sky", "ery", "Y", "ty", "ies", "yr", "u", "yn", "ya", "dy", "yo"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int h264_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    int ret;\n\n    const uint8_t *new_extradata;\n\n    int new_extradata_size;\n\n\n\n    h->flags = avctx->flags;\n\n    h->setup_finished = 0;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\nout:\n\n    if (buf_size == 0) {\n\n        H264Picture *out;\n\n        int i, out_idx;\n\n\n\n        h->cur_pic_ptr = NULL;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f->key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            ret = output_frame(h, pict, out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n\n\n    new_extradata_size = 0;\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata_size > 0 && new_extradata) {\n\n        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,\n\n                                       &h->ps, &h->is_avc, &h->nal_length_size,\n\n                                       avctx->err_recognition, avctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size);\n\n    if (buf_index < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        buf_size = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            return 0;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        ff_h264_field_end(h, &h->slice_ctx[0], 0);\n\n\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||\n\n                                   h->next_output_pic->recovered)) {\n\n            if (!h->next_output_pic->recovered)\n\n                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;\n\n\n\n            ret = output_frame(h, pict, h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    }\n\n\n\n    assert(pict->buf[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 10554, "substitutes": {"avctx": ["afconn", "afctx", "AVcn", "afcfg", "evcf", "avectx", "awcontext", "afctl", "avcf", "evcontext", "avsci", " avctl", "avcu", "AVcontext", "afcf", "afcu", "avectl", "avconn", "AVctx", " avcontext", "avcontext", "awctx", "evconn", " avconn", "avcfg", "afsci", "AVcfg", "avesci", " avcf", "evctx", "afloc", "afcn", "awcu", "awcfg", " avsci", "awcn", " avloc", "aveloc", "avecf", "AVcu", "avecontext", "avctl", "afcontext", "avcn", "avloc"], "data": ["parent", "channel", "img", "context", "val", "in", "media", "window", "da", "capt", "block", "head", "config", "p", "reader", "batch", "qa", "feed", "memory", "frame", "empty", "tmp", "body", "f", "DATA", "next", "code", "dat", "size", "slice", "input", "connection", "response", "content", "fat", "picture", "load", "new", "Data", "message", "api", "client", "header", "video", "image", "result", "cache", "buff", "a", "proc", "buffer"], "got_frame": ["got__frame", "gotqsample", "getting__frames", "gotoffframes", "got__frames", "got__sample", "getting_frames", "gotqframes", "get_frame", "getting_iframe", "get_sample", "get_value", "gotqiframe", "got__iframe", "getting__iframe", "got_sample", "getting_sample", "got_iframe", "got___value", "gotqframe", "gotoffvalue", "got___frame", "gotoffframe", "getting_frame", "got_frames", "getting__sample", "get_frames", "got_value", "getting__frame", "got___sample", "gotoffsample", "got___frames"], "avpkt": ["avwpacket", "avcpcht", "abfacket", "afckt", "avpkn", " avpet", "avspct", "abpsth", "avcpkt", "avpct", "avpek", "navpcht", "afpdt", "avwpkn", " avfput", "afpkt", "avfpet", "avjpkt", "afcelt", "avpekt", "avcacket", "navpacket", "avnpdt", "avwpsth", "avpeacket", "abpkt", "avcpacket", "avjpkn", "avfkt", "navpkt", " avpait", "avnpelt", "avnput", "avfpkt", "avspkt", "afpelt", "avfput", "avtpkt", "avcdt", "abfsth", "abfkt", "afpct", "abpkn", "avtpet", "avpdt", "avnpct", "avcct", "navpeacket", "avjpsth", "avtpait", "avfsth", "abfkn", "avnpkt", "avfacket", "avpelt", "navpekt", "afcdt", "avwpkt", "avpet", "navpk", "avcelt", "avtput", "avckt", " avput", "avcpk", "avpsth", "avpacket", "avnpait", " avfpkt", "avjpacket", " avfpet", "avck", "avfpait", "navpecht", "avnpet", "avpait", "avpecht", "abpacket", "avccht", " avfpait", "avspdt", "avput", "avfkn", "avspelt", "navpek", "avpcht", "afcct", "avpk"], "buf": ["uf", "seq", "Buffer", "img", "ph", "path", "pool", "block", "fb", "batch", "config", "cb", "fp", "queue", "cf", "rb", "tmp", "alloc", "cv", "cas", "conv", "cat", "buff", "cmd", "proc", "buffer", "box", "uc"], "h": ["l", "hi", "sh", "he", "ht", "dh", "n", "g", "han", "ph", "hr", "auth", "hh", "w", "m", "ich", "http", "t", "b", "d", "c", "adh", "work", "hm", "p", "help", "gh", "eh", "q", "hw", "f", "hal", "j", "host", "zh", "ha", "th", "v", "bh", "ih", "home", "ctx", "hy", "en", "hp", "him", "hash", "hs", "oh", "kh", "hub", "hd", "this", "u", "H", "handler", "hl", "self", "beh", "header", "image", "ah", "ch", "y", "um", "hu", "rh", "uh"], "pict": ["dq", "img", "def", "conn", "path", " pic", "pty", "pid", "stat", "fw", "capt", "doc", "ct", "config", "p", "obj", "qa", "cli", "fp", "txt", "gui", "tmp", "pai", "fa", "fat", "photo", "ctx", "pic", "picture", "mat", "avi", "mot", "fig", "init", "fin", "cat", "image", "ch", "buff", "proc", "feat", "fi"], "ret": ["count", "base", "fail", "red", "ref", "arg", "reg", "gt", "code", "att", "pret", "re", " RET", "url", "let", "resp", "flag", "val", "no", "id", "Ret", "mem", "post", "last", "value", "db", "res", "bf", "det", "msg", "en", "error", "back", "mt", "rl", "rf", "std", "nb", "alt", "len", "class", "def", "nt", "num", "reply", "usr", "rb", "rt", "rc", "fun", "part", "fin", "cat", "result", "sr", "success", "pass", "active", "run", "lit", "obj", "rets", "bit", "RET", "ft", "bin", "rev", "match", "feat", "pet"], "new_extradata": ["new_externalradta", "new_externaladade", "new_extradada", "new_extracada", "new_externalpartata", "new_extrafade", "new_extrataton", "new_extradta", "new_extpartATA", "new_externalradada", "new_extadata", "new_extrafaton", "new_extrastaton", "new_extvardaton", "new_extadATA", "new_extarcada", "new_extvardada", "new_extadta", "new_extracata", "new_extadada", "new_extradica", "new_extpartoint", "new_externalpartATA", "new_externalradATA", "new_externalradica", "new_externalradaton", "new_externaladta", "new_externalradoint", "new_extarcoint", "new_extrafta", "new_extrafata", "new_extrastata", "new_extracica", "new_extvardica", "new_externaladata", "new_extrastada", "new_extratata", "new_extratade", "new_extpartada", "new_extadade", "new_externalpartada", "new_extarcATA", "new_extradaton", "new_extracaton", "new_externalradade", "new_extadoint", "new_externaladica", "new_extradATA", "new_externaladaton", "new_externaladada", "new_extadaton", "new_externalradata", "new_extrastta", "new_extarcata", "new_externalpartoint", "new_extadica", "new_extrafada", "new_extvardata", "new_extpartata", "new_extradoint", "new_extradade", "new_extratada"], "new_extradata_size": ["new_extradada_Size", "new_extradata_Size", "new_extradata_small", "new_extradada_capacity", "new_extradata_name", "new_extradata_address", "new_extradata_capacity", "new_extradada_size", "new_extradada_address", "new_extradata_number", "new_extradada_scale", "new_extradata_scale", "new_extradada_name", "new_extradada_number", "new_extradada_small"], "out": ["parent", "img", " in", "again", "m", "point", "path", "x", "net", "config", "at", "step", "call", "opt", "v", "connection", "err", "init", "image", "flat", "picture", "timeout", "n", "prefix", "w", "outer", "Out", "b", "plain", "c", "output", "hard", "tmp", "f", "format", "input", "conv", "error", "wx", "u", "ext", "str", "g", "test", "conn", "o", "sync", "raw", "home", "new", "OUT", "part", "after", "copy", "cat", "a", "cache", "cmd", "dot", "yout", "in", "update", "batch", "p", "obj", "qa", "off", "lib", "inc", "name", "inner", "user", "option", "client", "loop", "io", "write", "proc", "cgi"], "i": ["oi", "l", "hi", "ui", "di", "it", "si", "g", "in", "zi", "info", "xi", "id", "x", "ini", "my", "d", "c", "ji", "p", "uri", "ix", "e", "yi", "cli", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "gi", "mi", "phi", "ti", "name", "chi", "abi", "qi", "inner", "pi", "bi", "ii", "init", "u", "idi", "I", "li", "ip", "ci", "a", "io", "ni", "y", "api", "ri", "ori", "lc", "fi", "iu", "ki"], "out_idx": ["out_ider", "out_indb", "out_ideX", "out_ridx", "out_idex", "out_idb", "out_idX", "out__inc", "out_ridc", "outxidp", "out__idc", "out_index", "out_indp", "out_indw", "outxidb", "out__idv", "out_idp", "out_ridxe", "out_idy", "out_idv", "out_idxe", "out__inx", "outxidx", "out__idx", "out_idc", "out_inc", "out_ridy", "out_inxc", "out_inb", "out_indv", "out_idw", "out_ridex", "out__idex", "out_endx", "out_endxe", "out_inv", "out_indc", "out_idxc", "out_idew", "outxindp", "out_indxc", "out_indr", "out_indx", "out__inex", "outxidxc", "out__inv", "out_endy", "out_idr", "outxindx", "outxindb", "out_ridX", "out_inex", "out_inp", "out_endX", "out_indX", "out_ridv", "outxindxc", "out_inx"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)\n\n{\n\n    if (bin < 7) {\n\n        if ((b0 + 256) == b1)\n\n            a = 384;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else if (bin < 20) {\n\n        if ((b0 + 256) == b1)\n\n            a = 320;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else {\n\n        a = FFMAX(0, a - 128);\n\n    }\n\n\n\n    return a;\n\n}\n", "idx": 10556, "substitutes": {"a": ["l", "mac", "area", "va", "ama", "valid", "active", "wa", "af", "na", "access", "ba", "da", "missing", "b", "x", "ab", "z", "acha", "pa", "d", "i", "sa", "data", "c", "ad", "sha", "p", "e", "qa", "aaa", "ata", "ada", "au", "ia", "array", "f", "ac", "an", "la", "xa", "ai", "alpha", "fa", "ae", "index", "ha", "ea", "aux", "tta", "sta", "ar", "sup", "am", "address", "ga", "A", "audio", "aw", "as", "u", "aj", "aa", "ca", "asa", "ma", "api", "y"], "b0": ["f93", "f80", "f1", "base0", "base1", "bc1", "p2", "B6", "b80", "body2", "body1", "v93", " bale", "p6", "v0", "fdb", "bcale", " b2", "bodydb", "base2", "bdb", "body0", "sb00", " b6", " b90", "f2", "sb0", "p0", "fale", "bale", "bc0", "p80", "p1", "bc90", "sb1", "f90", " b00", "base80", "b6", "b00", "b93", "p00", "f00", "B2", "B00", "b90", "B0", "v1", "sb93", "f0", "v00", "pdb", "b2"], "b1": ["f11", "l2", "bb", "a1", " b7", " b11", "a7", "f1", "f100", " b8", "l0", "body1", "l1", "ab", "b11", "l11", " b2", "a0", " bb", " b6", "f2", "a8", "a2", "a100", "b7", "b6", "f6", "b8", "body7", "f8", "body100", "b100", "a6", "f0", " b100", "bodyb", "b2", "l8"], "bin": ["count", "bool", "byte", "base", "abc", "len", "g", "in", "win", "bar", "ban", "bas", "b", "num", "i", "big", "data", "block", "c", "batch", "ix", "nn", "bits", "off", "bc", "ac", "binary", "scan", "lib", "version", "index", "spin", "magic", "abi", "bot", "bis", "ben", "bi", "ping", "pc", "part", "bit", "nan", "border", "bn", "gap", "gen", "depth", "pin"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n                                      long width, long height,\n\n                                      long lumStride, long chromStride, long srcStride)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y+=2) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \"pcmpeqw                 %%mm7, %%mm7       \\n\\t\"\n\n            \"psrlw                      $8, %%mm7       \\n\\t\" // FF,00,FF,00...\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(4)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // U0V0 U0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // UVUV UVUV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(0)\n\n\n\n            MOVNTQ\"                  %%mm2, (%1, %%\"REG_a\", 2)  \\n\\t\"\n\n\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(12)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq                    %%mm2, %%mm4       \\n\\t\" // YUYV YUYV(12)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(8)\n\n            \"psrlw                      $8, %%mm2       \\n\\t\" // U0V0 U0V0(12)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm4       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm2, %%mm1       \\n\\t\" // UVUV UVUV(8)\n\n            \"packuswb                %%mm4, %%mm3       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm3, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // UVUV UVUV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // UVUV UVUV(8)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // V0V0 V0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // V0V0 V0V0(8)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // U0U0 U0U0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // U0U0 U0U0(8)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // VVVV VVVV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // UUUU UUUU(0)\n\n\n\n            MOVNTQ\"                  %%mm0, (%3, %%\"REG_a\")     \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, (%2, %%\"REG_a\")     \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm3       \\n\\t\" // YUYV YUYV(12)\n\n            \"pand                    %%mm7, %%mm0       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm1       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // YYYY YYYY(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm0,  (%1, %%\"REG_a\", 2) \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n#else\n\n        long i;\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            udst[i]     = src[4*i+1];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n            vdst[i]     = src[4*i+3];\n\n        }\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n        }\n\n#endif\n\n        udst += chromStride;\n\n        vdst += chromStride;\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(EMMS\"       \\n\\t\"\n\n                     SFENCE\"     \\n\\t\"\n\n                     :::\"memory\");\n\n#endif\n\n}\n", "idx": 10564, "substitutes": {"src": ["cdn", "chrom", "sound", "img", "source", "sel", "sur", "sci", "iv", "filename", "stat", "rect", "config", "rib", "stream", "dest", "gl", "gb", "dist", "rb", "loc", "sq", "rs", "gal", "sec", "obl", "inst", "tmp", "href", "lib", "sync", "rc", "sl", "sil", "jpg", "cur", "ctx", "ruby", "lore", "sb", "wx", "sys", "scl", "url", "gz", "rob", "sr", "rl", "ssl", "sc"], "ydst": ["isdst", "dyirst", "hdst", "isdSt", "dyste", "dycr", "dxirst", "ydstr", "isdST", "ydste", "iddST", "ydSt", "dxost", "dyost", "iddstr", "dxast", "dxst", "iddSt", "ydST", "ydenst", "isdste", "ydast", "hdcr", "dyest", "dyast", "isdstr", "hdste", "ydost", "hdast", "dyst", "hdest", "ydenSt", "ydirst", "iddst", "hdost", "ydcr", "ydenST", "isdest", "ydenstr", "isdcr", "hdirst", "ydest"], "udst": ["vdost", "ddost", "udost", "ddST", "ddstr", "vdend", "UDst", "udend", "uddst", "vdstr", "uddST", "ddest", "vdST", "UDend", "uddstr", "UDest", "UDST", "udST", "vdest", "udstr", "ddend", "uddost", "udest", "ddst"], "vdst": ["vdost", "hdst", "hdstr", "udost", "fdost", "fdst", "fdest", "vdstr", "vdST", "xdst", "xdest", "hdest", "fdstr", "hdost", "udST", "vdest", "udstr", "xdost", "hdST", "xdST", "udest"], "height": ["level", "dim", "window", "def", "w", "x", "resolution", "fw", "d", "density", "top", "bottom", "max", "layout", "quality", "thin", "padding", "Height", "png", "alpha", "th", "shape", "deep", "ty", "pull", "above", "hang", "crop", "h", "build", "gap", "length", "depth", "dy"], "lumStride": ["lUMStro", "lumConstrict", "lumStrue", "lUMStread", "lumbStube", "lumRestro", "lUMConstrict", "lumScide", "lumbStride", "lumSTube", "lumbScride", "lUMConstread", "lumstride", "lumStube", "lumStide", "lumConstread", "lumRestread", "lumStro", "lUMStrict", "lumStoreide", "lumSTride", "lumRestrict", "lumstrict", "lUMStride", "lumScube", "lUMConstro", "lumstro", "lumStrict", "lumbScrue", "lumStorerue", "lumStoreride", "lumScride", "lumSTrue", "lumConstro", "lUMConstride", "lumbStrue", "lumStread", "lumStoreube", "lumScrue", "lumbStide", "lumstread", "lumbScube", "lumRestride", "lumbScide", "lumConstride", "lumSTide"], "chromStride": ["romRestride", "chromRestride", "romResterve", "chromStrue", "chromEstrub", "romSterve", "chromRestrue", "chromResterve", "chromEstride", "chromStrub", "chromDistrue", "chromRestrub", "romStrue", "chromDisterve", "romRestrue", "chromEsterve", "chromSterve", "chromEstrue", "chromDistrub", "chromDistride", "romRestrub", "romStrub", "romStride"], "srcStride": ["srcStrride", "usrStri", "srcStackipe", "sourceStipe", "srcEstlock", "srcStrrite", "srcStipe", "srcEstride", "srcDesclock", "srcStlock", "srcDescsync", "srcDescride", "srcStsync", "srcStri", "sourceStride", "srcStackride", "srcEstsync", "srcEstri", "sourceStrite", "srcStackrite", "srcStackerve", "srcSTlock", "usrStlock", "srcStrerve", "srcDescri", "usrEstri", "srcSTri", "usrStsync", "sourceSterve", "srcSTride", "srcSTsync", "usrEstsync", "srcStripe", "usrEstride", "usrEstlock", "usrStride", "srcSterve", "srcStrite"], "y": ["ym", "ady", "yt", "oy", "n", "ry", "ny", "w", "t", "ey", "ye", "vy", "x", "z", "d", "c", "ys", "p", "yi", "ay", "zy", "yy", "sy", "j", "py", "ky", "yl", "yd", "hy", "Y", "ty", "yr", "col", "dy", "xy", "h", "year", "lon", "ya", "yn", "wy", "cy", "yo"]}}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 10583, "substitutes": {"node": ["parent", "cdn", "NAME", "n", "comment", "source", "prefix", "word", "id", "no", "src", "path", "instance", "num", "block", "config", "uri", "package", "local", "nn", "loc", "empty", "network", "none", "odes", "host", "primary", "child", "route", "master", "nil", "content", "remote", "ctx", "object", "address", "callback", "document", "native", "new", "root", "ast", "fn", "od", "message", "ip", "null", "file", "image", "android", "cache", "anc", "core", "one", "Node"], "name": ["parent", "alias", "NAME", "base", "n", "comment", "prefix", "key", "word", "na", "no", "missing", "path", "x", "filename", "create", "nam", "block", "python", "s", "time", "names", "package", "number", "title", "none", "nm", "code", "label", "call", "child", "named", "size", "address", "sn", "new", "part", "unknown", "root", "fn", "type", "self", "file", "on", "client", "common", "image", "ni", "text", "Name", "one"], "pbs": ["Pbes", "cbc", "cds", " pgb", "pbc", "Pps", "pbes", " pbl", "pasts", "Pbc", "Pbs", "mbl", "pps", "bbes", "mds", " pBS", "pBS", "mbs", " pbc", "bps", "cbs", " pasts", "pbl", " pbes", "pcs", "masts", "pgb", " pcs", "cbl", "bbs", "bgb", "cBS", " pds", "Pcs", "casts", "Pgb", "PBS", "pds", " pps", "ccs"], "paio": ["inos", "maxwell", "smart", "qua", "arin", "dogs", "doctor", "amba", "ardo", "cone", "ppa", "iott", "dog", "cca", "aco", "uno", "enforcement", "aic", "aho", "oga", "apple", "olulu", "abba", "aaa", "oji", "cro", "vale", "tmp", "abo", "pai", "ocobo", "police", "tti", "colo", "ampa", " Arpaio", "opa", "ppo", "rog", "tta", "apache", "iov", "lli", "pic", "ione", "orc", "arf", "ello", "ori", "ski", "jj", "acc"], "errp": ["iterfp", "rf", "erp", "erf", "erb", " errP", "rrr", "nerp", "rrb", "errg", "rrpr", "rr", "iterr", "erpr", "rp", "armb", "nerg", "rb", "Erb", "nerb", "rrp", "nerf", " erb", " errb", "errP", "errf", "erP", " errf", " errg", "err", " errfp", " erpr", "Erp", "erfp", "errpr", "iterp", " err", "armf", "armg", "iterb", "errb", "ErP", "armp", " errr", "Err", " erp", "errr", "errfp"], "bs": ["vs", "base", "bb", "its", "ds", "ba", "cases", "src", "bas", "bid", "boxes", "b", "gs", "iss", "fb", "s", "ls", "pb", "obj", "cb", "gb", "ins", "ros", "rss", "bits", "outs", "rs", "banks", "BS", "bc", "os", "obs", "cs", "eb", "bps", "ubs", "ctx", "las", "lb", "bis", "nas", "als", "sb", "ns", "blocks", "bytes", "null", "ps", "ses", "fs", "css", "ss", "bing", "bes", "bos"], "bitmap": ["BITMAP", "bitMAP", "Bitmaps", "binmaps", "BITmap", "taskmap", "bincache", "BITMap", " bitMap", "bitmask", "bitMap", "Bitmap", " bitMAP", "bootcache", "bytecache", "BITmaps", "taskmask", " bitcache", "binmap", " bitmask", "byteMap", "taskmaps", "BitMap", "bitmaps", "bytemap", "bootmask", "BitMAP", "bootmap", "binMap", "bootmaps", "bytemaps", "taskcache", " bitmaps", "bitcache"], "aio_context": ["aios_instance", "aio2context", "aio_queue", "aio2instance", "aio_ctx", "aios_config", "aio_instance", "aio2graph", "aio_graph", "aios_scope", "aio_client", "aios_connection", "aio_config", "aios_ctx", "aio_support", "aio2support", "aios_client", "aio_connection", "aio_scope", "aios_support", "aios_context", "aios_graph"]}}
{"project": "qemu", "commit_id": "446f16a6906e9d05aa9ce0dde727d4f731a89298", "target": 1, "func": "void ppce500_init(MachineState *machine, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t loadaddr;\n\n    hwaddr kernel_base = -1LL;\n\n    int kernel_size = 0;\n\n    hwaddr dt_base = 0;\n\n    hwaddr initrd_base = 0;\n\n    int initrd_size = 0;\n\n    hwaddr cur_base = 0;\n\n    char *filename;\n\n    hwaddr bios_entry = 0;\n\n    target_long bios_size;\n\n    struct boot_info *boot_info;\n\n    int dt_size;\n\n    int i;\n\n    /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and\n\n     * 4 respectively */\n\n    unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i;\n\n        env->mpic_iack = params->ccsrbar_base +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    machine->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, params->ccsrbar_base,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_prop_set_uint32(dev, \"first_pin_irq\", pci_irq_nrs[0]);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", params->spin_base, NULL);\n\n\n\n    if (cur_base < (32 * 1024 * 1024)) {\n\n        /* u-boot occupies memory up to 32MB, so load blobs above */\n\n        cur_base = (32 * 1024 * 1024);\n\n    }\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        qemu_irq poweroff_irq;\n\n\n\n        dev = qdev_create(NULL, \"mpc8xxx_gpio\");\n\n        s = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]);\n\n        memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n\n\n        /* Power Off GPIO at Pin 0 */\n\n        poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0);\n\n        qdev_connect_gpio_out(dev, 0, poweroff_irq);\n\n    }\n\n\n\n    /* Platform Bus Device */\n\n    if (params->has_platform_bus) {\n\n        dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE);\n\n        dev->id = TYPE_PLATFORM_BUS_DEVICE;\n\n        qdev_prop_set_uint32(dev, \"num_irqs\", params->platform_bus_num_irqs);\n\n        qdev_prop_set_uint32(dev, \"mmio_size\", params->platform_bus_size);\n\n        qdev_init_nofail(dev);\n\n        s = SYS_BUS_DEVICE(dev);\n\n\n\n        for (i = 0; i < params->platform_bus_num_irqs; i++) {\n\n            int irqn = params->platform_bus_first_irq + i;\n\n            sysbus_connect_irq(s, i, mpic[irqn]);\n\n        }\n\n\n\n        memory_region_add_subregion(address_space_mem,\n\n                                    params->platform_bus_base,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (machine->kernel_filename) {\n\n        kernel_base = cur_base;\n\n        kernel_size = load_image_targphys(machine->kernel_filename,\n\n                                          cur_base,\n\n                                          ram_size - cur_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    machine->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base += kernel_size;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (machine->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    machine->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /*\n\n     * Smart firmware defaults ahead!\n\n     *\n\n     * We follow the following table to select which payload we execute.\n\n     *\n\n     *  -kernel | -bios | payload\n\n     * ---------+-------+---------\n\n     *     N    |   Y   | u-boot\n\n     *     N    |   N   | u-boot\n\n     *     Y    |   Y   | u-boot\n\n     *     Y    |   N   | kernel\n\n     *\n\n     * This ensures backwards compatibility with how we used to expose\n\n     * -kernel to users but allows them to run through u-boot as well.\n\n     */\n\n    if (bios_name == NULL) {\n\n        if (machine->kernel_filename) {\n\n            bios_name = machine->kernel_filename;\n\n        } else {\n\n            bios_name = \"u-boot.e500\";\n\n        }\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL,\n\n                         1, ELF_MACHINE, 0);\n\n    if (bios_size < 0) {\n\n        /*\n\n         * Hrm. No ELF image? Try a uImage, maybe someone is giving us an\n\n         * ePAPR compliant kernel\n\n         */\n\n        kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n\n                                  NULL, NULL);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Reserve space for dtb */\n\n    dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n\n\n    dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n\n                                       initrd_base, initrd_size,\n\n                                       kernel_base, kernel_size);\n\n    if (dt_size < 0) {\n\n        fprintf(stderr, \"couldn't load device tree\\n\");\n\n        exit(1);\n\n    }\n\n    assert(dt_size < DTB_MAX_SIZE);\n\n\n\n    boot_info = env->load_info;\n\n    boot_info->entry = bios_entry;\n\n    boot_info->dt_base = dt_base;\n\n    boot_info->dt_size = dt_size;\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 10594, "substitutes": {"machine": ["mac", "session", "boot", "base", "shell", "processor", "m", "model", "template", "mount", "game", "instance", "container", "mem", "service", "vm", "config", "server", "p", "motion", "computer", "memory", "Machine", "mode", "manager", "host", "device", "mp", "module", "process", "connection", "state", "object", "loader", "user", "part", "node", "controller", "plugin", "message", "image", "cache", "engine", "core", "proc", "M", "mc", "database"], "params": ["mac", "conf", "param", "cam", "Par", "ams", "processor", "conn", "mm", "vm", "config", "server", "phys", "pro", "attr", "global", "args", "manager", "lib", "master", "loader", "pi", "options", "image", "proc", "par", "pty"], "address_space_mem": ["address_sp_mem", "address_sp_memory", "address_sp_space", "address_space_memory", "address_space_space"], "ram": ["cow", "sh", "img", "rw", "w", "path", "net", "instance", "mm", "mem", "max", "RAM", "reg", "gb", "network", "mode", "Ram", "am", "AM", "cal", "im", "iam", "ro", "rg", "disk", "image", "gam", "sc", "gram"], "pci_bus": ["pci_def", "pdi_boot", "pdi_def", "pci_boot", "pci_BUS", "pdi_BUS", "pdi_bus"], "env": ["vs", "conf", "session", "qt", "context", "ext", "si", "equ", "dict", "conn", "password", "path", "net", "que", "iv", "viron", "export", "iss", "environment", "vm", "config", "NV", "e", "attr", "np", "global", "cf", "act", "args", "ec", "eni", "gui", "network", "code", "profile", "db", "dir", "ev", "skin", "energy", "scope", "ea", "opt", "exc", "v", "oa", "exe", "ctx", "loader", "err", "en", "eng", "Environment", "enc", "pect", "node", "ef", "nc", "cfg", "et", " environment", "cache", "anc", "agent", "eu", "ah", "core", "engine", "vel"], "loadaddr": ["rolladdr", "readattr", "loadattr", " loadmem", "readmem", "rollAddress", "rollattr", "loadAddress", "loadmem", "rollmem", " loadAddress", "readAddress", " loadattr", "readaddr"], "filename": ["seq", "tif", "prefix", "word", "src", "fd", "path", "files", "tty", "buf", "fp", "amd", "f", "mode", "binary", "linux", "nil", "name", "dll", "unknown", "enc", "fn", "file", "length", "buffer"], "bios_size": ["bios_count", "bio_number", "bio_count", "bios_number", "bio_size", "bios__number", "bios__count", "bios_ize", "bios__ize", "bios__size", "bio_ize"], "boot_info": ["bootleninfo", "bootlogfamily", "bootnetgroup", "bootnetcount", "boot_limit", "bootnetid", "kernel_info", "kernel_system", " boot_count", "bootlensystem", "bootvalinfo", "kernellogfamily", "kernellogsystem", "kernelloginfo", "kernelloglimit", "boot_family", "bootlenlimit", "boot_id", "bootnetinfo", "kernel_limit", "bootloglimit", "bootloginfo", "bootvallimit", "bootvalsystem", "kernel_family", " boot_group", "boot_count", "boot_group", " boot_id", "boot_system", "bootvalfamily", "bootlogsystem", "bootlenfamily"], "dt_size": ["boot_size", "dt_len", "boot_sum", "dt_length", "boot_length", "dt_sum", "dtlenlen", "dtlensum", "dtlenlength", "boot_len", "dtlensize"], "i": ["oi", "l", "vi", "count", "gu", "ui", "di", "it", "is", "n", "si", "start", "in", "zi", "adi", "info", "id", "xi", "gpu", "b", "x", "ini", "z", "ami", "t", "d", "uli", "c", "p", "ix", "uri", "e", "yi", "mu", "mini", "eni", "f", "ie", "j", "ai", "multi", "index", "size", "v", "gi", "mi", "ti", "phi", "r", "chi", "qi", "ij", "ei", "pi", "bi", "ii", "u", "type", "I", "li", "ip", "ci", "a", "ni", "ski", "y", "ri", "fi", "iu", "ki"], "pci_irq_nrs": ["pci_irq_crs", "pci_irq_cumbers", "pci_irq_ynrc", "pci_irq_nodes", "pci_irq_codes", "pci_irq_ynumbers", "pci_irq_ynrs", "pci_irq_crc", "pci_irq_numbers", "pci_irq_nrc", "pci_irq_ynodes"], "irqs": ["irprints", "ircles", "mirqi", "ironces", "irdq", "irqu", "irques", " irprints", "irsces", " irces", " irqa", "errqs", "mirq", "ironches", "rinprints", "ironqs", "ireq", "irqa", "irces", "Irquest", "errqu", "mirqs", "IRprints", "rincles", "Irq", "irq", " irdq", "Irqs", "irsqs", "errqi", "IRches", "Irques", "Ircles", " irq", "rinq", "IRcles", "IRques", "irequ", "irquest", "IRqs", "mirqu", "iperches", "iperq", "mirques", "Irqa", "rinques", "IRq", "Irches", "mirqa", "irsdq", "iperquest", "irches", "mircles", " irques", "errq", " ircles", "ireqs", "IRquest", "ireqi", "irondq", "iperqs", " irches", "rinqs", "irsches", "irqi"], "mpic": ["MPics", "mpia", "ipics", "ppics", "ppic", "MPac", "ipac", "mpics", "mpac", "ppia", "MPic", "ppac", "MPia", "ipia", "ipic"], "dev": ["conf", "gu", "Dev", "w", "conn", "def", "net", "iv", "ver", "de", "data", "ov", "app", "global", "hw", "inst", "ev", "device", "pu", "dd", "enc", "node", "disk", "ip", "cache", "ch"], "firstenv": ["firstenvironment", "firstexc", "lastenv", "firstev", " firstexc", "lastenc", " firstconfig", "secondenvironment", "Firstenv", " firstev", "secondenc", "firstconfig", "lastenvironment", "secondexc", " firstenc", "firstenc", "seconddir", "secondev", "Firstconfig", " firstenvironment", "Firstexc", "lastexc", "secondconfig", "firstdir", "Firstdir", " firstdir", "lastev", "secondenv"], "ccsr_addr_space": ["ccsr_addr_sp", "ccsr_addrnsp", "ccsr_addrnblock", "ccsr_address_space", "ccsr_addrnrange", "ccsr_address_sp", "ccsr_address_range", "ccsr_addr_block", "ccsr_addr_range", "ccsr_addrnspace", "ccsr_address_block"], "s": ["session", "sh", "n", "w", "m", "ssh", "ops", "d", "sa", "c", "p", "server", "e", "sym", "o", "S", "v", "sync", "scope", "services", "port", "spec", "fs", "a", "ses", "ssl", "sc"], "ccsr": ["cctr", "scsi", "cfvr", "ccsi", " ccvr", " ccsi", " cctr", "scsr", "ccvr", "cfsr", "scvr", "cftr", "cfsi", "sctr"], "cpu": ["cow", "uu", "kernel", "cmp", "processor", "conn", "gpu", "uno", "chip", "bench", "auc", "que", "instance", "net", "mem", "pp", "GPU", "cp", "vm", "chu", "c", "cu", "computer", "cli", "np", "uci", "cn", "eni", " CPU", "hw", "pai", "performance", "linux", "process", "fps", "ctx", "loader", "hp", "pu", "jp", "ilo", "pc", "nic", "node", "CPU", "gc", "nc", "px", "ci", "hu", "lc", "proc", "core", "mc", "cgi", "runner"], "cs": ["vs", "utils", "ts", "co", "ks", "ds", "conn", "c", "cp", "ls", "ix", "ins", "cf", "wcs", "ec", "js", "rs", "cc", "sk", "bc", "os", "acs", "ck", "ras", "rc", "CS", "cons", "ics", "ctx", "ns", "pc", "spec", "nc", "ca", "ps", "fs", "css", "cache", "core", "sc"], "input": ["conf", "session", "Input", "img", "ack", "str", "active", "in", "conn", "temp", "instance", "c", "data", "block", "config", "output", "ix", "sum", "qa", "cli", "request", "act", "q", "flow", "cc", "unit", "call", "child", "device", "version", "inc", "rc", "current", " inputs", "cl", "pull", "dc", "enc", "ip", "image", "bin", "text", "cache", "exec"]}}
{"project": "FFmpeg", "commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n", "idx": 10609, "substitutes": {"s": ["session", "sg", "ts", "ds", "si", "g", "is", "sf", "m", "b", "t", "ops", "d", "gs", "service", "c", "serv", "p", "ls", "e", "qs", "sq", "js", "f", "os", "cs", "sym", "o", "S", "es", "sync", "scope", "sl", "services", "ctx", "ns", "sb", "spec", "u", "sys", "self", "ses", "a", "fs", "su", "site", "ss", "ssl"], "rc_rice_param": ["rc_rice_mode", "rc_rice_ram", "rc_rice2cm", "rc_square_mode", "rc_single_cm", "rc_rice_type", "rc_square_rm", "rc_square_num", "rc_cost_num", "rc_riceingprogram", "rc_single_params", "rc_ruby_param", "rc_square_cm", "rc_riceingmode", "rc_cost_cm", "rc_ruby_name", "rc_ricefullcm", "rc_single_ram", "rc_cost_par", "rc_single_param", "rc_square_param", "rc_rice_program", "rc_riceingnum", "rc_rice_cm", "rc_riceacnum", "rc_rice_params", "rc_rice2ram", "rc_ruby_type", "rc_rice_par", "rc_riceaccm", "rc_rice_name", "rc_ricefulltype", "rc_rice_rm", "rc_riceingparam", "rc_rice2params", "rc_rice2param", "rc_riceacpar", "rc_ruby_cm", "rc_square_program", "rc_ricefullparam", "rc_riceacparam", "rc_rice_num", "rc_cost_param", "rc_ricefullname"], "last_coeff_abs_level_remaining": ["last_coeff_abs_level_main", "last_coeff_abs_level_remained", "last_coeff_abs_level_mained", "last_coeff_abs_level_rapping", "last_coeff_abs_level_resain", "last_coeff_abs_level_mapping", "last_coeff_abs_level_rained", "last_coeff_abs_level_reained", "last_coeff_abs_level_regained", "last_coeff_abs_level_resaining", "last_coeff_abs_level_Remain", "last_coeff_abs_level_regain", "last_coeff_abs_level_regaining", "last_coeff_abs_level_remain", "last_coeff_abs_level_reain", "last_coeff_abs_level_Remapping", "last_coeff_abs_level_rain", "last_coeff_abs_level_regapping", "last_coeff_abs_level_reaining", "last_coeff_abs_level_maining", "last_coeff_abs_level_resapping", "last_coeff_abs_level_resained", "last_coeff_abs_level_raining", "last_coeff_abs_level_Remained", "last_coeff_abs_level_remapping", "last_coeff_abs_level_reapping", "last_coeff_abs_level_Remaining"], "i": ["oi", "ui", "di", "base", "it", "si", "zi", "pad", "adi", "id", "xi", "info", "b", "x", "t", "ini", "c", "ji", "p", "uri", "ix", "e", "mu", "fp", "mini", "eni", "f", "ie", "padding", "j", "ai", "multi", "index", "v", "gi", "ti", "phi", "abi", "pre", "qi", "inner", "jp", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "io", "ni", "image", "ri", "fi", "iu"], "prefix": ["diff", "fix", "base", "pass", "delay", "scale", "start", "wp", "len", "pad", "temp", "bp", "password", "path", "num", "post", "pointer", "phase", "adding", "batch", "p", "ix", "prev", "status", "fp", "queue", "skip", "wrapper", "number", "sequence", "xxx", "padding", "mode", "next", "priority", "append", "zero", "index", "module", "master", "order", "name", "magic", "phrase", "pre", "address", "token", "patch", "hop", "offset", "radius", "root", "init", "gap", "length", "cache", "ski", "partial", "mix", "frequency", "reset"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n", "idx": 10620, "substitutes": {"s": ["conf", "session", "sg", "ts", "sv", "si", "g", "n", "sf", "stats", "m", "src", "b", "t", "gs", "sa", "c", "service", "serv", "p", "server", "ls", "e", "qs", "se", "xs", "js", "sq", "rs", "f", "args", "us", "o", "aws", "v", "es", "sync", "scope", "south", "sie", "sl", "services", "ns", "sb", "storage", "spec", "u", "self", "comm", "h", "sys", "client", "soc", "a", "su", "site", "ses", "ss", "sr", "core", "ssl", "sc"], "last": ["count", "later", "parent", "l", "timeout", "start", "show", "second", "Last", "info", "total", "latest", "reply", "max", "prev", "se", "cli", "final", "style", "loc", "lag", "sec", "next", "code", "size", "eval", "event", "state", "end", "old", "full", "first", "error", "after", "li", "length", "result", "use", "lo"], "seg": [" sek", "SEc", "kep", "eleig", "kel", "beg", "teig", "serge", "elega", "tegen", "sug", "ceg", "segm", "schega", "sege", "kege", "SEgo", "keG", "segs", "zego", "kegn", "neG", "gec", "negen", "zek", "serg", "SEp", "lec", "gee", "gego", "schege", "geg", "adeg", "kegg", "neig", "adeleg", "kec", "serig", "SEb", " segm", "sugment", "zega", "keg", "begg", "gega", "speb", "tege", "peg", "tega", " sega", "pseg", "bep", "schegn", "zeg", "selk", "persego", "schegg", "begm", "inego", "tegm", "segment", "sergen", "segn", "cege", "legen", "begs", "seig", " sego", "nego", "sep", "sega", " segen", "selgg", "pegen", "nep", "SEg", "SEge", "zep", "adegg", "tegn", "spegen", "pec", "speg", "scheg", "seleg", "persegen", "sel", "kego", "suga", "gep", "geig", "seeg", "pep", "schego", "parsegn", "tego", " see", "selge", "SEga", " segn", "seb", "keig", "selgn", "bega", "cega", "schegment", "kegen", "sek", "eleg", "neg", "parseg", "pega", "segen", "SEgen", "gege", "inega", "sego", "keleg", "ineg", "tee", "adep", "pege", "psegn", "psep", "spego", "segg", "nega", "seegs", "selga", "elege", "leg", " sege", "lel", "gegn", "perseg", "psegen", "gegm", "inege", "begen", "zege", "seep", "peig", "gegment", "selg", "sec", "sugn", "parsegen", "seegm", "beleg", "cegen", "gegen", " sep", " sec", "teg", "see", "SEig", "SEgn", "gegs", "perseb", "gel", "parsep", "psega", "kega", "seG", "geG"], "i": ["oi", "l", "ui", "di", "base", "it", "start", "n", "si", "in", "zi", "info", "xi", "id", "b", "ini", "z", "c", "line", "limit", "p", "ix", "uri", "e", "iter", "eni", "f", "ie", "j", "ai", "multi", "index", "slice", "ind", "mi", "ti", "gi", "phi", "name", "r", "abi", "qi", "bi", "pi", "ii", "type", "I", "li", "ip", "ci", "ni", "ski", "ri", "fi", "iu"], "buf": ["bag", "uf", " b", "seq", "Buffer", "img", "ff", "pad", "ba", "src", "fd", "b", "wb", " arr", "mem", " bu", "pool", "block", "data", "fb", "bd", "config", "fi", "pb", "cb", "fp", "queue", "rb", "loc", "tmp", "bc", "f", "alloc", "cv", "msg", "exc", "rc", "bh", "bed", "raw", "home", "ctx", "callback", "bytes", "h", "null", "ret", " buffer", "func", "buff", "br", "cmd", "result", "vec", "buffer", " buff", "text", "box", "uc"]}}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640, "substitutes": {"a": ["parent", "l", "va", "area", "ama", "na", "da", "ba", "x", "ab", "pa", "i", "sa", "c", "ad", "p", "e", "aaa", "ada", "au", "ia", "f", "ac", "an", "la", "fa", "alpha", "ae", "ha", "ea", "name", "am", "ga", "A", "as", "aa", "ca", "ma"], "b": ["l", "ib", "base", "bb", "nb", "abc", "abb", "ba", "m", "bar", "k", "ab", "x", "wb", "i", "c", "fb", "bd", "pb", "e", "cb", "B", "rb", "f", "be", "db", "bf", "v", "lb", "bis", "sb", "emb", "ob", "y", "xb", "bs", "zb"]}}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n", "idx": 10648, "substitutes": {"expected": [" observed", "element", "me", " event", "updated", "valid", " expecting", "generated", "str", "announced", "est", "started", "test", "view", "id", " expects", " unexpected", "anticipated", "forced", "allowed", "supported", "asured", "data", "config", "e", "claimed", " actual", " expect", "nexpected", "sequence", "ordered", "actual", " expectation", "code", "found", "ev", "fake", "handled", "name", "event", "received", "seen", "failed", "err", "served", "old", "new", "pect", "required", "handler", "created", "confirmed", "pected", "result", "force", "pattern", "managed"], "measured": ["seasured", "peasured", "seasure", "peasure", "feasure", "Measure", " measuring", "Meessed", "feessed", "feasuring", "Measures", "omeasure", "easures", "mesasure", "feasured", "mesasuring", "meessed", "omeessed", "easured", "mesessed", " measure", "measure", "seessed", "omeasuring", "Measuring", "omeasured", "peasures", "Measured", "peessed", "peasuring", "easuring", "seasuring", "measuring", "easure", " meessed", "mesasured", "measures"], "cmd": ["gn", "mac", "cookie", "seq", "cmp", "id", "method", "conn", "control", "buf", "c", "cp", "data", "ct", "config", "cd", "cli", "cb", "cf", "cn", "args", "cod", "cc", "mode", "code", "ctrl", "ctr", "ck", "msg", "module", "pipe", "md", "ctx", "req", "Cmd", "init", "cat", "cfg", "command", "comm", "grad", "client", "clean", "gz", "func", "pkg", "core", "help", "bind"]}}
{"project": "FFmpeg", "commit_id": "b4886795108e319a5b3a88370e90207d9c15a01e", "target": 1, "func": "static int decode_frame_byterun1(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height ; y++) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { //PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM\n\n        for(y = 0; y < avctx->height ; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(row, avctx->width, buf, buf_end);\n\n        }\n\n    } else { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n        for (y = 0; y < avctx->height ; y++) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);\n\n            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 10665, "substitutes": {"avctx": ["afconn", "avalcontext", "avcmp", "avalctx", "avehw", "abcontext", "navtx", "ajcomponent", "AVcontext", "aktx", "alctx", "avcm", "aveconfig", "avconn", "afnc", "avsc", " avcontext", "afcor", "avcontext", "Avtx", " avconn", "Avctx", "afcomponent", "avcms", " avloc", "alhw", "afhw", "airsci", " avnc", "afcontext", "afkb", "akcf", " avcu", "akcontext", "avesc", "aircontext", "avcor", "afpkg", "avectx", "alcontext", "aksc", "avvoc", "avcomponent", "navconn", "afcu", "aflc", "avcmd", "verkit", "ajnc", "ajctx", "ajcontext", "afxc", "verconn", "avalconn", "afsc", "avekb", "afsci", "afloc", " avsci", "aveca", "afvoc", "avkit", "Avcontext", "avloc", "airpkg", "avca", "afctx", " avpkg", "avelc", "navcms", "afcm", "avecomponent", "avcf", "avalconfig", "avecmd", "avalcmd", "avcu", "abctx", "verctx", "vercontext", "ajtx", "afconfig", "AVctx", "avxc", "avalkit", "avalloc", "avhw", " avcm", "ajcor", "afcms", "navcontext", "avkb", "aveconn", "avecontext", "ajsys", "ablc", "avnc", "ajxc", "AVconfig", "navctx", "aftx", "afkit", "avecmp", "afcmp", "afcmd", "Avsci", "avecu", "AVcmp", "akcms", "avsci", "navxc", "airctx", "navsys", "afcf", "avecm", "afsys", "avlc", "avconfig", "ajcf", "akctx", "navcf", "abkb", "alca", "avpkg", "afca", " avcor", "avecf", " avvoc", "avtx", "avevoc", "ajsci", "avsys"], "data": ["parent", "base", "media", "pad", "m", "x", "shift", "block", "split", "memory", "frame", "body", "code", "series", "content", "align", "end", "first", "offset", "image", "buff", "buffer", "devices", "delay", "da", "w", "id", "open", "last", "output", "draw", "layout", "value", "bits", "DATA", "zero", "index", "slice", "module", "format", "input", "load", "Data", "blocks", "read", "bytes", "header", "one", "map", "sample", "len", "source", "d", "head", "action", "dat", "alpha", "size", "done", "message", "a", "cache", "result", "ui", "scale", "start", "window", "batch", "p", "ata", "table", "empty", "next", "name", "address", "length", "bin", "write"], "data_size": ["data_scale", "flow6end", "data6len", "flow_end", "flow_scale", "flow6size", "flow6len", "data_end", "data_len", "flow_size", "flow6scale", "data6scale", "data6end", "flow_len", "data6size"], "avpkt": ["afpacket", "avputo", "avfka", "affk", "abfacket", "affyth", "affacket", "affkn", "avpkn", "afpyth", "avfct", "avfpk", "avpnt", "avcpkt", "avpct", "avcpct", "afpkt", " avipkt", "avcke", "avcqt", "affkt", "avpercht", "avpekt", "avkqt", "avpsacket", "afpqt", "avcacket", "avbpkh", "abpcht", "afpnt", "avfelt", "avpeacket", "abpkt", "avcpacket", "avtpelt", "avpqt", "avpekh", " avpct", "avfkt", "abfct", "avnpcht", "avfpkt", "avtpacket", "avtpyth", "afpke", "afpelt", "avvpkt", "avpputo", "abfcht", "avfk", "affuto", "avtpkt", "avipft", "avperkn", "avppacket", "affnt", "abfkt", "avnpacket", "affelt", "afpcht", "avfkh", "avcct", "avppka", " avpacket", "avfyth", "avpka", "avperacket", "affke", "avfke", "afpka", "afpk", "avkke", "avnpkt", "avpkh", "abpct", "avfacket", "avfft", "avvpacket", "avfuto", "avipct", "avpft", "affqt", "avbpacket", "avpelt", "avpke", "avfqt", "avfnt", "avpakt", " avipacket", "avnpkn", "avkacket", "avpskt", "avpselt", "affka", "avckt", "avpaka", "avpyth", "avipkt", "avvpcht", "avpacket", "avbpcht", " avpft", " avipft", "avpauto", "afpkn", "avperkt", "avpaacket", " avipct", "avnpnt", "avvpct", "avipacket", "avkkt", "afpkh", "avpsyth", "avpecht", "abpacket", "afputo", "avccht", "avcpft", "avfkn", "affkh", "avfpnt", "avnpk", "avbpkt", "avfpacket", "avpcht", "affcht", "avpk", "avfcht", "avppkt"], "s": ["l", "conf", "session", "sg", "ts", "ks", "sv", "is", "n", "g", "si", "its", "ds", "stats", "m", "http", "t", "b", "ops", "d", "i", "gs", "service", "c", "p", "ls", "e", "qs", "args", "js", "sq", "rs", "f", "sk", "os", "xs", "cs", "sym", "o", "aws", "sets", "S", "v", "sync", "es", "settings", "services", "r", "sup", "ns", "sb", "spec", "as", "sys", "ses", "a", "su", "fs", "ps", "ss", "bs", "css", "ssl", "sc"], "buf": ["bag", "uf", "map", "seq", "Buffer", "base", "len", "ff", "val", "window", "lim", "ab", "wb", "mem", "cp", "block", "limit", "batch", "cb", "queue", "cf", "rb", "loc", "empty", "bc", "zero", "alloc", "cv", "cap", "rc", "cas", "home", "cur", "col", "fin", "pos", "header", "length", "cache", "vec", "buff", "cmd", "br", "text", "buffer", "box", "uc"], "buf_end": ["queue_size", "queue_stop", "buf_size", "queue_start", "buf_stop", "queue_end", "buf_start"], "y": ["ym", "ady", "area", "oy", "n", "key", "ny", "w", "m", "t", "x", "ye", "ey", "z", "vy", "i", "c", "p", "iy", "yi", "ay", "zy", "sy", "yy", "j", "gy", "height", "py", "ky", "yl", "hy", "Y", "hop", "ii", "yr", "col", "kit", "dy", "xy", "type", "idy", "h", "year", "ip", "yn", "ya", "lon", "ch", "wy", "cy", "yo"], "plane": ["sea", "lane", "level", "pass", "scale", "axis", "n", "span", "key", "class", "w", "board", "pl", "jet", "page", "z", "direction", "con", "cp", "line", "limit", "p", "pose", "pe", "planes", "drop", "cube", "flow", "fle", "f", "mode", "rot", "unit", "fl", "slice", "gate", "zone", "period", "cap", "plate", "age", "port", "pen", "mo", "col", "cat", "den", "pos", "fly", "file", "ge", "flo", "ane", "charge", "weight", "plan", "core"], "res": ["cr", "rh", "vals", "conf", "des", "gen", "arr", "rem", "Res", "ry", "val", "nos", "id", "RES", "resolution", "gr", "rec", "ver", "bs", "ress", "obj", "ros", "reg", "rss", "args", "rs", "js", "os", "errors", "ris", "rap", "rex", "pres", "msg", "ras", "min", "rc", "response", "resh", "content", "cons", "r", "req", "err", "results", "breaks", "details", "error", "rus", "ms", "root", "re", "rates", "rx", "ps", "sol", "result", "ret", "rev", "cache", "resp", "press", "ber", "css", "success", "range", "reset"], "row": ["pass", "ack", "scale", "tr", "rows", "key", "view", "board", "low", "post", "block", "line", "batch", "feed", "value", "bug", "array", "flow", "entry", "fl", "Row", "index", "slice", "column", "per", "item", "r", "user", "port", "col", "pos", "image", "cell", "month", "box", "range"]}}
{"project": "FFmpeg", "commit_id": "29d2dc59f973f9495c703b4cab17ded5c24ab3e8", "target": 1, "func": "int alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n\n    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11\n\n    const int mb_array_size= s->mb_stride*s->mb_height;\n\n    const int b8_array_size= s->b8_stride*s->mb_height*2;\n\n    const int b4_array_size= s->b4_stride*s->mb_height*4;\n\n    int i;\n\n\n\n    if(shared){\n\n        assert(pic->data[0]);\n\n        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);\n\n        pic->type= FF_BUFFER_TYPE_SHARED;\n\n    }else{\n\n        int r;\n\n\n\n        assert(!pic->data[0]);\n\n\n\n        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);\n\n\n\n        if(r<0 || !pic->age || !pic->type || !pic->data[0]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]);\n\n            return -1;\n\n        }\n\n\n\n        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (stride changed)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if(pic->linesize[1] != pic->linesize[2]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (uv stride mismatch)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        s->linesize  = pic->linesize[0];\n\n        s->uvlinesize= pic->linesize[1];\n\n    }\n\n\n\n    if(pic->qscale_table==NULL){\n\n        if (s->encoding) {\n\n            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))\n\n        }\n\n\n\n        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check\n\n        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))\n\n        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))\n\n        pic->mb_type= pic->mb_type_base + s->mb_stride+1;\n\n        if(s->out_format == FMT_H264){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 2;\n\n        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 3;\n\n        }\n\n        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)\n\n        }\n\n        pic->qstride= s->mb_stride;\n\n        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))\n\n    }\n\n\n\n    /* It might be nicer if the application would keep track of these\n\n     * but it would require an API change. */\n\n    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);\n\n    s->prev_pict_types[0]= s->pict_type;\n\n    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)\n\n        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.\n\n\n\n    return 0;\n\nfail: //for the CHECKED_ALLOCZ macro\n\n    return -1;\n\n}\n", "idx": 10670, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "phys", "syn", "ubs", "bis", "full", "hs", "ns", "spec", "self", "settings", "sg", "ds", "si", "your", "sites", "w", "b", "c", "e", "sq", "us", "f", "sym", "sets", "es", "current", "space", "sup", "storage", "sis", "as", "fs", "ps", "site", "lc", "ss", "ks", "g", "features", "stats", "ops", "sa", "ls", "share", "os", "cs", "sync", "sb", "sys", "side", "a", "ssl", "conf", "sports", "ts", "service", "p", "qs", "ins", "xs", "js", "rs", "sec", "aws", "parse", "S", "sie", "services", "ctx", "ms", "ses", "sit", "bin", "y"], "pic": ["pse", "sci", "iv", "pa", "fb", "config", "txt", "frame", "ac", "cop", "pres", "syn", "study", "spec", "image", "fi", "picture", "phot", "fc", "mac", "si", "xi", "chat", "capt", "c", "jack", "bc", "pick", "py", "module", "cha", "ig", "ic", "bi", "avi", "Pic", "plugin", "file", "lc", "pict", "cus", "str", "model", "piece", "sa", "data", "tick", "fp", "mini", "style", "eni", "pins", "sync", "ics", "feature", "sn", "jp", "icon", "fn", "sys", "vc", "cache", "pot", "jc", "mc", "pin", "comment", "doc", "p", "mic", "sec", "lib", "parse", "Picture", "sie", "photo", "kin", "pc", "nic", "sit", "bin", "icer", "feat", "typ", "cy"], "shared": ["parent", "sh", "compatible", "public", "bare", "acked", "balanced", "locked", "used", "local", "managed", "private", "global", "stack", "loaded", "packed", "sq", "owned", "sec", "share", "same", "sharp", "sharing", "aws", "lib", "shape", "parse", "exclusive", "sync", "aware", "raw", "held", "load", "part", "storage", "read", "ared", "encrypted", "broken", "par", "buffer", "sc"], "i": ["l", "it", "si", "n", "in", "m", "b", "x", "c", "p", "e", "mini", "f", "j", "ai", "index", "v", "ti", "pi", "counter", "ii", "I", "li", "ip", "ci", "a", "io", "image"], "r": ["l", "cr", "rh", "rf", "ru", "rate", "n", "rd", "hr", "m", "fr", "mr", "rr", "b", "kr", "d", "ra", "c", "p", "e", "attr", "rb", "ir", "rs", "er", "lr", "f", "dr", "rt", "res", "v", "R", "rc", "ar", "pr", "err", "nr", "rar", "vr", "re", "h", "rg", "result", "sr", "br", "rl", "range"]}}
{"project": "FFmpeg", "commit_id": "fa5dacce143f3fbe8eac14d5a99e926b2787e9e6", "target": 1, "func": "static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\n    if (get_bits(&ctx->gb, 5) != 0x1F) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\n        return -1;\n    ctx->prev_frame_type = ctx->frame_type;\n    ctx->frame_type      = get_bits(&ctx->gb, 3);\n    if (ctx->frame_type >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\n        return -1;\n    ctx->frame_num = get_bits(&ctx->gb, 8);\n    if (ctx->frame_type == FRAMETYPE_INTRA) {\n        ctx->gop_invalid = 1;\n        if (decode_gop_header(ctx, avctx))\n            return -1;\n        ctx->gop_invalid = 0;\n    if (ctx->frame_type != FRAMETYPE_NULL) {\n        ctx->frame_flags = get_bits(&ctx->gb, 8);\n        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\n        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n        /* skip unknown extension if any */\n        if (ctx->frame_flags & 0x20)\n            skip_hdr_extension(&ctx->gb); /* XXX: untested */\n        /* decode macroblock huffman codebook */\n        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\n            return -1;\n        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n    align_get_bits(&ctx->gb);\n    return 0;", "idx": 10671, "substitutes": {"ctx": ["utils", "cmp", "Context", "na", "sci", "fw", "config", "cb", "np", "cn", "wcs", "loc", "cc", "ctr", "ce", "connection", "cas", "concept", "nc", "gc", "ca", "pkg", "fc", "cam", "cca", "tc", "c", "component", "cf", "hw", "bc", "scope", "msg", "conv", "cl", "dc", "lc", "anc", "cus", "sc", "exec", "context", "conn", "cp", "cu", "cli", "fp", "coll", "cs", "ctrl", "ck", "exc", "sync", "req", "ga", "tx", "xc", "kw", "gru", "sys", "comp", "vc", "cmd", "crit", "mc", "conf", "co", "obj", "qa", "la", "console", "lib", "cv", "support", "pc", "git", "cms", "cfg", "cm", "client", "ci", "css", "kb"], "avctx": ["ivcam", "avcmp", "afctx", "abwcs", "navwcs", "AVconfig", "aircontext", "navctx", "averctx", "antcontext", "avercmp", "afcmp", "avchan", "abcmp", "Avcam", "abcontext", "antcmp", "AVcmp", "aircmp", "AVcontext", "airctx", "abctx", "ivctx", "averconsole", "afconfig", "avcam", "AVctx", "avconfig", "AVconsole", "avcontext", "ivchan", "Avctx", "avwcs", "avconsole", "navcmp", "navcontext", "airconfig", "abcam", "AVcam", "afcontext", "antctx", "ivcontext", "Avchan", "Avcontext", "AVchan", "afconsole", "antcam", "avercontext", "AVwcs"]}}
{"project": "FFmpeg", "commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "target": 1, "func": "static int mpegts_write_header(AVFormatContext *s)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    MpegTSWriteStream *ts_st;\n\n    MpegTSService *service;\n\n    AVStream *st, *pcr_st = NULL;\n\n    AVDictionaryEntry *title, *provider;\n\n    int i, j;\n\n    const char *service_name;\n\n    const char *provider_name;\n\n    int *pids;\n\n    int ret;\n\n\n\n    if (s->max_delay < 0) /* Not set by the caller */\n\n        s->max_delay = 0;\n\n\n\n    // round up to a whole number of TS packets\n\n    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;\n\n\n\n    ts->tsid = ts->transport_stream_id;\n\n    ts->onid = ts->original_network_id;\n\n    /* allocate a single DVB service */\n\n    title = av_dict_get(s->metadata, \"service_name\", NULL, 0);\n\n    if (!title)\n\n        title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;\n\n    provider      = av_dict_get(s->metadata, \"service_provider\", NULL, 0);\n\n    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;\n\n    service       = mpegts_add_service(ts, ts->service_id,\n\n                                       provider_name, service_name);\n\n\n\n    if (!service)\n\n        return AVERROR(ENOMEM);\n\n\n\n    service->pmt.write_packet = section_write_packet;\n\n    service->pmt.opaque       = s;\n\n    service->pmt.cc           = 15;\n\n\n\n    ts->pat.pid          = PAT_PID;\n\n    /* Initialize at 15 so that it wraps and is equal to 0 for the\n\n     * first packet we write. */\n\n    ts->pat.cc           = 15;\n\n    ts->pat.write_packet = section_write_packet;\n\n    ts->pat.opaque       = s;\n\n\n\n    ts->sdt.pid          = SDT_PID;\n\n    ts->sdt.cc           = 15;\n\n    ts->sdt.write_packet = section_write_packet;\n\n    ts->sdt.opaque       = s;\n\n\n\n    pids = av_malloc_array(s->nb_streams, sizeof(*pids));\n\n    if (!pids) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* assign pids to each stream */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n\n\n        ts_st = av_mallocz(sizeof(MpegTSWriteStream));\n\n        if (!ts_st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        st->priv_data = ts_st;\n\n\n\n        ts_st->user_tb = st->time_base;\n\n        avpriv_set_pts_info(st, 33, 1, 90000);\n\n\n\n        ts_st->payload = av_mallocz(ts->pes_payload_size);\n\n        if (!ts_st->payload) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        ts_st->service = service;\n\n        /* MPEG pid values < 16 are reserved. Applications which set st->id in\n\n         * this range are assigned a calculated pid. */\n\n        if (st->id < 16) {\n\n            ts_st->pid = ts->start_pid + i;\n\n        } else if (st->id < 0x1FFF) {\n\n            ts_st->pid = st->id;\n\n        } else {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Invalid stream id %d, must be less than 8191\\n\", st->id);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        if (ts_st->pid == service->pmt.pid) {\n\n            av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        for (j = 0; j < i; j++) {\n\n            if (pids[j] == ts_st->pid) {\n\n                av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        pids[i]                = ts_st->pid;\n\n        ts_st->payload_pts     = AV_NOPTS_VALUE;\n\n        ts_st->payload_dts     = AV_NOPTS_VALUE;\n\n        ts_st->first_pts_check = 1;\n\n        ts_st->cc              = 15;\n\n        /* update PCR pid by using the first video stream */\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            service->pcr_pid == 0x1fff) {\n\n            service->pcr_pid = ts_st->pid;\n\n            pcr_st           = st;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_AAC &&\n\n            st->codec->extradata_size > 0) {\n\n            AVStream *ast;\n\n            ts_st->amux = avformat_alloc_context();\n\n            if (!ts_st->amux) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ts_st->amux->oformat =\n\n                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? \"latm\" : \"adts\",\n\n                                NULL, NULL);\n\n            if (!ts_st->amux->oformat) {\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ret = avcodec_copy_context(ast->codec, st->codec);\n\n            if (ret != 0)\n\n                goto fail;\n\n            ast->time_base = st->time_base;\n\n            ret = avformat_write_header(ts_st->amux, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {\n\n            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;\n\n        }\n\n    }\n\n\n\n    av_freep(&pids);\n\n\n\n    /* if no video stream, use the first stream as PCR */\n\n    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {\n\n        pcr_st           = s->streams[0];\n\n        ts_st            = pcr_st->priv_data;\n\n        service->pcr_pid = ts_st->pid;\n\n    } else\n\n        ts_st = pcr_st->priv_data;\n\n\n\n    if (ts->mux_rate > 1) {\n\n        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n\n\n        if (ts->copyts < 1)\n\n            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);\n\n    } else {\n\n        /* Arbitrary values, PAT/PMT will also be written on video key frames */\n\n        ts->sdt_packet_period = 200;\n\n        ts->pat_packet_period = 40;\n\n        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (!pcr_st->codec->frame_size) {\n\n                av_log(s, AV_LOG_WARNING, \"frame size not set\\n\");\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * 512);\n\n            } else {\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);\n\n            }\n\n        } else {\n\n            // max delta PCR 0.1s\n\n            // TODO: should be avg_frame_rate\n\n            service->pcr_packet_period =\n\n                ts_st->user_tb.den / (10 * ts_st->user_tb.num);\n\n        }\n\n        if (!service->pcr_packet_period)\n\n            service->pcr_packet_period = 1;\n\n    }\n\n\n\n    ts->last_pat_ts = AV_NOPTS_VALUE;\n\n    ts->last_sdt_ts = AV_NOPTS_VALUE;\n\n    // The user specified a period, use only it\n\n    if (ts->pat_period < INT_MAX/2) {\n\n        ts->pat_packet_period = INT_MAX;\n\n    }\n\n    if (ts->sdt_period < INT_MAX/2) {\n\n        ts->sdt_packet_period = INT_MAX;\n\n    }\n\n\n\n    // output a PCR as soon as possible\n\n    service->pcr_packet_count = service->pcr_packet_period;\n\n    ts->pat_packet_count      = ts->pat_packet_period - 1;\n\n    ts->sdt_packet_count      = ts->sdt_packet_period - 1;\n\n\n\n    if (ts->mux_rate == 1)\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate VBR, \");\n\n    else\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate %d, \", ts->mux_rate);\n\n    av_log(s, AV_LOG_VERBOSE,\n\n           \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\",\n\n           service->pcr_packet_period,\n\n           ts->sdt_packet_period, ts->pat_packet_period);\n\n\n\n    if (ts->m2ts_mode == -1) {\n\n        if (av_match_ext(s->filename, \"m2ts\")) {\n\n            ts->m2ts_mode = 1;\n\n        } else {\n\n            ts->m2ts_mode = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&pids);\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st    = s->streams[i];\n\n        ts_st = st->priv_data;\n\n        if (ts_st) {\n\n            av_freep(&ts_st->payload);\n\n            if (ts_st->amux) {\n\n                avformat_free_context(ts_st->amux);\n\n                ts_st->amux = NULL;\n\n            }\n\n        }\n\n        av_freep(&st->priv_data);\n\n    }\n\n\n\n    for (i = 0; i < ts->nb_services; i++) {\n\n        service = ts->services[i];\n\n        av_freep(&service->provider_name);\n\n        av_freep(&service->name);\n\n        av_freep(&service);\n\n    }\n\n    av_freep(&ts->services);\n\n    return ret;\n\n}\n", "idx": 10672, "substitutes": {"s": ["l", "session", "its", "is", "m", "http", "t", "z", "gs", "parts", "set", "none", "v", "ns", "details", "hs", "spec", "settings", "sg", "ds", "si", "n", "sites", "sf", "b", "c", "e", "args", "sq", "us", "f", "sym", "sets", "es", "space", "r", "as", "u", "comments", "fs", "su", "ps", "site", "ss", "ks", "sv", "g", "stats", "ops", "d", "sa", "ls", "local", "status", "cs", "o", "sync", "south", "sb", "sys", "ions", "single", "secondary", "a", "sr", "ssl", "conf", "p", "qs", "tests", "ins", "tes", "xs", "js", "rs", "aws", "S", "services", "ches", "submit", "less", "h", "client", "ses", "y"], "ts": ["tags", "utils", "tr", "its", "t", "tt", "wt", "gs", "parts", "outs", "uts", "acs", "te", "ns", "details", "ets", "settings", "ds", "ments", "tc", "types", "tf", "es", "tis", " services", "ps", "fs", "times", "ss", "ks", "test", "stats", "mods", "tips", "alls", "ops", "ls", "os", "cs", "ics", "Ts", "tx", "tp", "ats", "als", "trans", "tim", "tm", "points", "TS", "ters", "td", "vs", "ta", "files", "ims", "ports", "qs", "tests", "ins", "tes", "xs", "rs", "js", "rets", "lets", "sts", "cons", "services", "ms", "options", "bs", "tin", "events"], "ts_st": ["ats_St", "ts_sth", "ats_sth", "ats_ST", "ats_st", "ts_St", "ts_ST"], "service": ["sp", "company", "session", "it", "sv", "ds", "si", "section", "is", "source", "start", "Service", "info", "id", "license", "http", "t", "tt", "project", "serv", "server", "component", "se", "ie", "sk", "entry", "cs", "resource", "ice", "device", "py", "module", "v", "scope", "sync", "series", "space", "event", "connection", "sl", "services", "proxy", "object", "port", "support", "ns", "storage", "git", "spec", " services", "plugin", "sys", "command", "image", "vc", "use", "match", "site", "text", "ss", "skill", "y", "cy", "security"], "st": ["sp", "std", "sv", "str", "test", "stage", "src", "t", "rest", "tt", "sa", "ct", "pt", "inst", "sts", "sta", "sl", "sn", "sth", "sb", "ST", "sid", "td", "typ", "sc"], "pcr_st": ["pcr2st", "pcrsst", "pct_ST", "pcrsrest", "pcr_rest", "pcr_ST", "pcrsST", "pcr2rest", "pcr2ST", "pct_rest", "pcr_str", "pct_str", "pcrsstr", "pct_st", "pcr2str"], "title": ["alias", "company", "term", "yt", "html", "Title", "detail", "author", "comment", "prefix", "key", "shell", "note", "id", "test", "theme", "license", " titles", "tag", "template", "article", "application", "filename", "project", "doc", "metadata", "data", "head", "meta", "username", "role", "itles", "itle", "body", "label", "profile", "resource", "unit", "primary", "alpha", "journal", "scope", "description", "format", "name", "tip", "subject", "doi", "phrase", "media", "phone", "part", "details", "summary", "front", "type", "ame", "message", "header", "text"], "provider": ["authoricator", "authorator", "produator", "divider", "configiders", "generison", "providers", "provison", "authorider", "configce", "PROVide", "authoride", "provide", "divison", "promider", "prider", "produider", "PROVoker", "proker", "generide", "generator", "PROVider", "provoker", "divoker", "provoser", "generoser", "produoker", "provator", "produicator", "provce", "PROVison", "generoker", "produce", "proser", "produiders", "produide", "promiders", "divide", "configider", "generider", "pride", "produoser", "promce", "provicator", "genericator"], "i": ["l", "ui", "di", "start", "n", "si", "zi", "id", "xi", "b", "x", "ini", "d", "fi", "ji", "c", "p", "ix", "e", "eni", "f", "ie", "ai", "index", "v", "gi", "ti", "mi", "phi", "end", "chi", "qi", "jp", "pi", "bi", "ii", "u", "type", "I", "li", "ip", "ci", "ri", "depth", "iu", "ki"], "j": ["l", "je", "it", "vision", "note", "jet", "k", "z", "job", "ji", "slot", "p", "obj", "sec", "op", "ie", "v", "sync", "r", "att", "ij", "jp", "aj", "pos", "J", "rev", "jc", "ok"], "service_name": ["server_nam", "servicealname", "server_title", "plugin_name", "servicefullname", "serviceftype", "serviceOname", "service_anc", "service_size", "service_nam", " service_desc", " service_title", "server_name", "service_title", "serviceftitle", "service_secret", "serviceFsize", "service_type", "plugin_size", "servicealtitle", "service_desc", "servicefulldesc", "servicefnam", "plugin_secret", "serviceOsecret", "server_type", "servicefname", "plugin_anc", "serviceOanc", "serviceFsecret", "servicealtype", "servicealnam", "serviceOsize", "serviceFname", "servicefulltitle", "serviceFanc"], "provider_name": ["provider1description", "provifier_number", "provifieracnumber", "proviser1description", "provider_named", "provideracname", "provideracbase", "provider_names", "provideracnumber", "providers_named", "providersid", "provider1name", "provider_number", "providersname", "proviser_names", "providerUnumber", "provider_description", "provider_code", "providerUcode", "provider_base", "proviser_description", "provider1names", "providerUname", "provifieracbase", "providers_code", "proviser1names", "provifieraccode", "provifier_name", "provider_id", "proviser_name", "provideraccode", "providerscode", "provifieracname", "proviser1name", "providers_name", "providerUbase", "providersnamed", "provifier_base", "provifier_code", "providers_id"], "pids": ["Pid", "bicks", "ppods", "cpips", "bids", "cpods", "pases", "cpid", "pips", " pid", "bid", " pips", "pid", "pods", "Pids", "cpids", "Picks", " pipes", "ppids", " pods", "ppases", "pipes", "bips", "ppipes", "Pips", "Pipes", "picks", "ppid", " pases", "Pods", " picks", "Pases", "ppips"], "ret": ["seq", "arr", "str", "alt", "val", "len", "Ret", " Ret", "mem", "vt", "reply", "lit", "util", "status", "secret", "gt", "rets", "sec", "ut", "rt", "res", "det", "fun", "att", "r", "get", "cat", "re", "RET", "back", " RET", "url", "result", "ft", "match", "success", "pet"]}}
{"project": "FFmpeg", "commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "target": 1, "func": "void dct32(INTFLOAT *out, const INTFLOAT *tab)\n\n{\n\n    INTFLOAT tmp0, tmp1;\n\n\n\n    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\n\n             val8 , val9 , val10, val11, val12, val13, val14, val15,\n\n             val16, val17, val18, val19, val20, val21, val22, val23,\n\n             val24, val25, val26, val27, val28, val29, val30, val31;\n\n\n\n    /* pass 1 */\n\n    BF0( 0, 31, COS0_0 , 1);\n\n    BF0(15, 16, COS0_15, 5);\n\n    /* pass 2 */\n\n    BF( 0, 15, COS1_0 , 1);\n\n    BF(16, 31,-COS1_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 7, 24, COS0_7 , 1);\n\n    BF0( 8, 23, COS0_8 , 1);\n\n    /* pass 2 */\n\n    BF( 7,  8, COS1_7 , 4);\n\n    BF(23, 24,-COS1_7 , 4);\n\n    /* pass 3 */\n\n    BF( 0,  7, COS2_0 , 1);\n\n    BF( 8, 15,-COS2_0 , 1);\n\n    BF(16, 23, COS2_0 , 1);\n\n    BF(24, 31,-COS2_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 3, 28, COS0_3 , 1);\n\n    BF0(12, 19, COS0_12, 2);\n\n    /* pass 2 */\n\n    BF( 3, 12, COS1_3 , 1);\n\n    BF(19, 28,-COS1_3 , 1);\n\n    /* pass 1 */\n\n    BF0( 4, 27, COS0_4 , 1);\n\n    BF0(11, 20, COS0_11, 2);\n\n    /* pass 2 */\n\n    BF( 4, 11, COS1_4 , 1);\n\n    BF(20, 27,-COS1_4 , 1);\n\n    /* pass 3 */\n\n    BF( 3,  4, COS2_3 , 3);\n\n    BF(11, 12,-COS2_3 , 3);\n\n    BF(19, 20, COS2_3 , 3);\n\n    BF(27, 28,-COS2_3 , 3);\n\n    /* pass 4 */\n\n    BF( 0,  3, COS3_0 , 1);\n\n    BF( 4,  7,-COS3_0 , 1);\n\n    BF( 8, 11, COS3_0 , 1);\n\n    BF(12, 15,-COS3_0 , 1);\n\n    BF(16, 19, COS3_0 , 1);\n\n    BF(20, 23,-COS3_0 , 1);\n\n    BF(24, 27, COS3_0 , 1);\n\n    BF(28, 31,-COS3_0 , 1);\n\n\n\n\n\n\n\n    /* pass 1 */\n\n    BF0( 1, 30, COS0_1 , 1);\n\n    BF0(14, 17, COS0_14, 3);\n\n    /* pass 2 */\n\n    BF( 1, 14, COS1_1 , 1);\n\n    BF(17, 30,-COS1_1 , 1);\n\n    /* pass 1 */\n\n    BF0( 6, 25, COS0_6 , 1);\n\n    BF0( 9, 22, COS0_9 , 1);\n\n    /* pass 2 */\n\n    BF( 6,  9, COS1_6 , 2);\n\n    BF(22, 25,-COS1_6 , 2);\n\n    /* pass 3 */\n\n    BF( 1,  6, COS2_1 , 1);\n\n    BF( 9, 14,-COS2_1 , 1);\n\n    BF(17, 22, COS2_1 , 1);\n\n    BF(25, 30,-COS2_1 , 1);\n\n\n\n    /* pass 1 */\n\n    BF0( 2, 29, COS0_2 , 1);\n\n    BF0(13, 18, COS0_13, 3);\n\n    /* pass 2 */\n\n    BF( 2, 13, COS1_2 , 1);\n\n    BF(18, 29,-COS1_2 , 1);\n\n    /* pass 1 */\n\n    BF0( 5, 26, COS0_5 , 1);\n\n    BF0(10, 21, COS0_10, 1);\n\n    /* pass 2 */\n\n    BF( 5, 10, COS1_5 , 2);\n\n    BF(21, 26,-COS1_5 , 2);\n\n    /* pass 3 */\n\n    BF( 2,  5, COS2_2 , 1);\n\n    BF(10, 13,-COS2_2 , 1);\n\n    BF(18, 21, COS2_2 , 1);\n\n    BF(26, 29,-COS2_2 , 1);\n\n    /* pass 4 */\n\n    BF( 1,  2, COS3_1 , 2);\n\n    BF( 5,  6,-COS3_1 , 2);\n\n    BF( 9, 10, COS3_1 , 2);\n\n    BF(13, 14,-COS3_1 , 2);\n\n    BF(17, 18, COS3_1 , 2);\n\n    BF(21, 22,-COS3_1 , 2);\n\n    BF(25, 26, COS3_1 , 2);\n\n    BF(29, 30,-COS3_1 , 2);\n\n\n\n    /* pass 5 */\n\n    BF1( 0,  1,  2,  3);\n\n    BF2( 4,  5,  6,  7);\n\n    BF1( 8,  9, 10, 11);\n\n    BF2(12, 13, 14, 15);\n\n    BF1(16, 17, 18, 19);\n\n    BF2(20, 21, 22, 23);\n\n    BF1(24, 25, 26, 27);\n\n    BF2(28, 29, 30, 31);\n\n\n\n    /* pass 6 */\n\n\n\n    ADD( 8, 12);\n\n    ADD(12, 10);\n\n    ADD(10, 14);\n\n    ADD(14,  9);\n\n    ADD( 9, 13);\n\n    ADD(13, 11);\n\n    ADD(11, 15);\n\n\n\n    out[ 0] = val0;\n\n    out[16] = val1;\n\n    out[ 8] = val2;\n\n    out[24] = val3;\n\n    out[ 4] = val4;\n\n    out[20] = val5;\n\n    out[12] = val6;\n\n    out[28] = val7;\n\n    out[ 2] = val8;\n\n    out[18] = val9;\n\n    out[10] = val10;\n\n    out[26] = val11;\n\n    out[ 6] = val12;\n\n    out[22] = val13;\n\n    out[14] = val14;\n\n    out[30] = val15;\n\n\n\n    ADD(24, 28);\n\n    ADD(28, 26);\n\n    ADD(26, 30);\n\n    ADD(30, 25);\n\n    ADD(25, 29);\n\n    ADD(29, 27);\n\n    ADD(27, 31);\n\n\n\n    out[ 1] = val16 + val24;\n\n    out[17] = val17 + val25;\n\n    out[ 9] = val18 + val26;\n\n    out[25] = val19 + val27;\n\n    out[ 5] = val20 + val28;\n\n    out[21] = val21 + val29;\n\n    out[13] = val22 + val30;\n\n    out[29] = val23 + val31;\n\n    out[ 3] = val24 + val20;\n\n    out[19] = val25 + val21;\n\n    out[11] = val26 + val22;\n\n    out[27] = val27 + val23;\n\n    out[ 7] = val28 + val18;\n\n    out[23] = val29 + val19;\n\n    out[15] = val30 + val17;\n\n    out[31] = val31;\n\n}\n", "idx": 10699, "substitutes": {"out": ["up", " in", "in", "In", "temp", "trial", "Out", "doc", "data", "output", "obj", "outs", "table", "opt", "input", "raw", "user", "err", "new", "OUT", "copy", "orig", "file", "image", "io", "ch", "cmd", "ex"], "tab": ["term", "bb", "window", "test", "trial", "lab", "temp", "bar", "ray", "ab", "mem", "buf", "doc", "pb", "cb", "reg", "table", "ac", "db", "ctr", "track", "tx", "sb", "col", "bin", "cell", "buff", "acc"], "tmp0": [" tmp6", "tmp6", " buf6", " buf1", " buf5", " buf0", " proc6", " proc1", " proc0", " proc5", " tmp5", "tmp5"], "tmp1": ["temp3", "tmp01", "j7", "cv01", "cv7", "j3", "temp7", "j01", "temp01", "temp1", "j1", "tmp3", "cv3", "cv1", "tmp7"], "val0": ["f00", "value00", " val00", "value2", "f0", "val00", "f2", "value0"], "val1": ["Val1", "Val5", "eval11", "al1", "al11", "eval01", "al5", "Val11", "Val01", "val01", "eval5", "al01", "eval1"], "val2": ["doc4", "el22", "el5", "eval4", "eval2", "el2", "doc5", "el4", "eval5", "eval22", "doc2", "doc22"], "val3": ["value3", "eval33", " val03", "value33", "eval4", "value03", "val03", "val33", "eval3", " val33", "value4", "eval03"], "val4": ["Val4", "Val5", "eval4", "eval6", "eval5", "Val6", "eval8", "Val8"], "val5": [" val55", "value5", "value55", "eval55", "eval4", "eval5", "eval8", "val55", "value8", "value4"], "val6": ["value5", "al6", "al16", "eval16", "al8", "value6", "al5", "eval6", "eval5", "value16", "eval8", "value8"], "val7": ["vals5", "el8", "el5", "vals8", "el17", "vals17", "eval17", "eval5", "eval7", "eval8", "el7", "vals7"], "val8": ["value5", "eval11", "value6", "eval6", "value11", "eval5", "eval8", "value8"], "val9": ["eval11", "eval9", "eval10", "Val11", "eval8", "Val10", "Val8", "Val9"], "val10": ["Val12", "al8", "eval11", "eval12", "al12", "al11", "al10", "eval10", "Val11", "eval8", "Val10", "Val8"], "val11": ["aval13", "eval11", "eval20", "eval13", "el14", "aval11", "el20", "eval14", "el13", "aval14", "el11", "aval20"], "val12": ["eval18", "eval11", "eval12", "el12", "eval4", "el18", "el4", "el11"], "val13": ["valid16", "eval16", "eval13", "valid10", "eval10", "eval27", "valid27", "valid13"], "val14": ["el10", "eval16", "eval11", "value14", "el11", "el16", "el14", "eval14", "eval10", "value11", "value16", "value10"], "val15": ["el14", "eval15", " val03", "el17", "eval17", "el15", "val03", "eval14", "eval03", "el03"], "val16": ["eval16", "eval33", "value33", "value17", "eval17", "val33", "eval8", "value16", " val33", "value8"], "val17": ["al16", "al10", "value17", "al19", "value16", "value19", "value10", "al17"], "val18": ["eval19", "vals11", "vals15", "eval11", "eval18", "vals19", "vals18", "eval15"], "val19": ["eval19", "valid25", "valid19", "eval25", "eval26", "eval17", "valid17", "valid26"], "val20": ["vals15", "value14", "value13", "eval20", "eval13", "eval14", "vals13", "vals14", "value15", "value20", "vals20", "eval15"], "val21": ["eval21", "eval23", "el14", "el23", "eval14", "el27", "eval27", "el21"], "val22": ["el22", "el14", "eval14", "eval24", "valid22", "valid32", "eval32", "el32", "val32", "el24", "valid14", "eval22", "valid24"], "val23": ["eval21", "value23", "eval23", "eval24", "el25", "value21", "eval25", "el23", "value24", "el24", "el21", "value25"], "val24": ["al16", "eval16", "al27", "vals27", "al24", "eval25", "eval24", "vals16", "al25", "vals24", "eval27", "vals25"], "val25": ["el26", "eval24", "el25", "eval25", "eval26", "el15", "el24", "eval15"], "val26": ["eval18", "el26", "eval13", "eval26", "el18", "el27", "el13", "eval27"], "val27": ["value26", "arg28", "eval26", "arg27", "arg22", "value28", "arg26", "eval28", "value22", "eval27", "eval22", "value27"], "val28": ["vals27", "vals23", "eval23", "eval25", "eval28", "vals28", "eval27", "vals25"], "val29": ["al29", "eval29", "eval24", "al14", "al24", "al22", "eval14", "eval22"], "val30": ["aval15", "aval30", "eval29", "eval30", "aval29", "aval27", "eval27", "eval15"], "val31": ["eval21", "Val31", " val32", "eval33", "Val21", " val33", "Val33", "val33", "eval32", "val32", "eval31", "Val32"]}}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n\n{\n\n    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);\n\n    tcg_gen_st32_tl(cpu_T[0], cpu_env, \n\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n\n    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);\n\n    tcg_gen_st_tl(cpu_T[0], cpu_env, \n\n                  offsetof(CPUX86State,segs[seg_reg].base));\n\n}\n", "idx": 10721, "substitutes": {"seg_reg": ["seG_rec", "seg2tag", "seg_tag", "seG_tag", "seg_Reg", "seg2num", "seg_rec", "seG_Reg", "seg2rec", "seg_num", "seg_region", "segm_reg", "seg_stat", "seg1num", "segm_tag", "segm_stat", "seg2REG", "seg2Reg", "seG_num", "seg2reg", "seg1reg", "seG_reg", "seg1rec", "seG_REG", "segm_region", "seg1tag", "seg_REG"]}}
{"project": "FFmpeg", "commit_id": "5a446bc88e49cc6400d0c646ca1eb540a727c9de", "target": 1, "func": "static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n", "idx": 10723, "substitutes": {"src": ["img", "cmp", "ack", "scene", "http", "iv", "shift", "config", "dest", "gl", "cb", "split", "target", "dist", "loc", "st", "cc", "ctr", "uv", "cur", "sort", "spec", "grad", "scl", "url", "text", "seed", "fc", "upload", "go", "low", "rss", "sq", "bc", "slice", "input", "sup", "conv", "load", "scenes", "u", "rob", "secure", "sc", "source", "sel", "send", "stat", "buf", "data", "stream", "stack", "gb", "usr", "rb", "share", "obl", "host", "sub", "size", "sync", "rc", "sl", "req", "sn", "sb", "comp", "sr", "core", "uc", "ssl", "start", "sur", "sec", "inst", "supp", "lib", "cv", "ctx", "support", "front", "reverse", "gz", "bs"], "stride": [" strode", "hrision", "spide", "strange", "dividen", "divider", "intided", "striider", "intide", "instision", "pridable", "strision", "hride", "Stride", "striide", "stridable", "prided", " strided", "brided", "intider", " strside", "Strided", "instider", " strider", "briding", "strider", "arrider", "arride", "arrided", "bride", "frides", "prider", "instide", "Strange", "striding", "frider", "strides", "hriding", "instode", "spided", "trside", "striden", "Strider", "trider", "divided", "strside", " striding", "frside", " strange", "intiding", " strision", " strides", "arrange", "Striding", "Strision", "strided", "strode", "instiding", "tride", "fride", "divide", "brider", "spidable", "spider", "hrided", "pride", "striision", "Stridable", "instided", "trides", "briden", " striden", "striode"], "i": ["oi", "l", "ui", "di", "it", "is", "n", "si", "zi", "m", "id", "xi", "info", "x", "k", "ami", "ini", "p", "e", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "mi", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "ori", "ni", "io", "y", "ri", "iu"], "a": ["l", "n", "af", "da", "ba", "w", "m", "x", "ab", "pa", "sa", "ad", "p", "e", "aaa", "au", "at", "ia", "ak", "f", "ac", "an", "ai", "fa", "alpha", "ae", "ar", "r", "am", "ga", "A", "art", "aw", "as", "ast", "aj", "u", "aa", "ca", "asa", "ma", "y"], "b": ["l", "base", "bb", "n", "g", "ba", "w", "bas", "x", "ab", "k", "wb", "ad", "s", "bd", "p", "e", "cb", "B", "rb", "f", "bc", "be", "bt", "db", "o", "eb", "v", "r", "lb", "bi", "sb", "u", "h", "aa", "ca", "y", "bs"], "c": ["l", "C", "n", "g", "w", "m", "x", "k", "z", "ab", "ad", "s", "p", "ct", "e", "cd", "cu", "cf", "cn", "f", "ac", "cc", "cs", "o", "v", "ce", "rc", "r", "dc", "u", "h", "ca", "ci", "lc", "y", "ch", "cy"], "d": ["l", "ld", "di", "ds", "n", "g", "da", "w", "m", "dt", "t", "z", "x", "k", "ad", "s", "bd", "p", "e", "cd", "du", "dn", "f", "db", "o", "v", "r", "md", "dd", "dc", "u", "dy", "h", "ca", "y", "dad", "dx", "D"], "d1": ["D3", "sdOne", "cone", "D2", "f1", "D81", " d3", "b3", "f5", "t1", "d5", "fOne", "b1", "t81", "f2", "d81", "c3", "bone", "t3", " done", "sd2", "D1", "done", "c2", "c1", "f3", "bOne", "sd3", " d5", "sd1", "b5", "dOne", "d3", "t2", "b2", " d81", "c5"], "d2": [" d02", "D02", "b0", "b12", "l2", " d10", " d12", "Db", "d0", "d02", "D2", "f1", "ndtwo", "d12", "nd02", "l0", "p2", " dtwo", "f10", "dtwo", "l4", "dd2", "c4", "cb", "p10", "f2", "dd8", " d0", "nd2", "d8", "db", "p0", "p1", "d4", "nd8", "c2", "b4", "c02", "D4", " d4", " db", "l12", "f0", "d10", "b2", "dd02", "ddtwo", " d8"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727, "substitutes": {"d": ["ld", "l", "gd", "di", "mad", "dh", "ds", "n", "g", "dom", "in", "dict", "da", "id", "m", "dt", "dos", "fd", "b", "t", "z", "dj", "k", "ud", "de", "i", "c", "data", "ad", "bd", "p", "wd", "s", "e", "cd", "pd", "du", "q", "dn", "df", "f", "dr", "dl", "j", "db", "dat", "xd", "nd", "md", "done", "mod", "dd", "old", "vd", "dc", "sd", "ct", "plugin", "dm", "h", "od", "der", "dad", "td", "D"], "alloc": ["mac", "arc", "oc", "ack", "abc", "val", "access", "win", "nt", "org", "src", "pl", "pack", "rec", "buf", "doc", "block", "slot", "c", "config", "util", "exec", "ptr", "ec", "loc", "oci", "hw", "sec", "ac", "vol", "oca", "aux", "gate", "ea", "rc", "ctx", "loader", "offset", "init", "use", "anc", "roc", "sc", "acc", "rac"], "entry": ["count", "element", "byte", "Entry", "start", "enter", "ry", "section", "prefix", "record", "pad", "id", "nt", "info", "version", "card", "letter", "data", "config", "uri", "reader", "server", "e", "zero", "add", "driver", "feed", "value", "number", "or", "array", "sec", "ie", "dr", "code", "ctrl", "slice", "index", "size", "route", "module", "parse", "rc", "inc", "event", "input", "r", "end", "address", "option", "port", "ident", "error", "offset", "pair", "command", "row", "attribute", "import", "image", "insert", "cell", "length", "seed"], "vector": ["Vector", "element", "ion", "timeout", "character", "point", "password", "shadow", "letter", "buf", "block", "config", "server", "reader", "uri", "output", "driver", "collection", "value", "number", "writer", "array", "serial", "sequence", "manager", "device", "zero", "version", "index", "v", "connection", "object", "address", "document", "uration", "port", "token", "variable", "counter", "position", "controller", "command", "volume", "ault", "header", "io", "length", "vec", "buffer", "volt", "direction"], "control": ["ion", "timeout", "holder", "character", "ack", "handle", "comment", "info", "board", "card", "controlled", "update", "data", "block", "rule", "config", "Control", "output", "reader", "add", "driver", "feed", "bug", "sequence", "trl", "ctrl", "sub", "lib", "rol", "ride", "per", "event", "current", "contact", "guard", "protected", "edit", "object", "address", "state", "port", "roll", "variable", "support", "pull", "error", "oper", "controller", "form", "command", "io", "cell", "safe", "forward", "sc"], "addr": ["alias", "adr", "Address", "oc", "ack", "arm", "enter", "alt", "val", "ord", "pad", "nt", "org", "src", "rr", "x", "pointer", "ad", "work", "add", "ace", "coord", "attr", "usr", "env", "amd", "act", "ptr", "loc", "eni", "dr", "host", "rt", "pkg", "call", "index", "size", "oa", "edge", "route", "ort", "module", "order", "align", "ar", "md", "end", "address", "kt", "dd", "nr", "part", "art", "dc", "hop", "offset", "hash", "node", "eth", "vr", "nc", "layer", "grad", "od", "pair", "ip", "udder", "url", "ard", "adder", "nn", "direction"]}}
{"project": "qemu", "commit_id": "d279279e2b5cd40dbcc863fb66a695990f304077", "target": 1, "func": "static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        /* XXX: Some CPUs implement this in hardware.\n\n           Not supported yet. */\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 10730, "substitutes": {"ctx": ["cam", "context", "cmp", "cci", "Context", "cca", "conn", "tc", "src", "sci", "history", "c", "ct", "cp", "config", "qq", "obj", "cu", "qa", "cli", "txt", "cf", "cn", "wcs", "xs", "loc", "sq", "coll", "hw", "bc", "cc", "la", "cs", "ctrl", "progress", "linux", "cv", "ck", "sync", "rc", "connection", "cas", "conv", "ga", "tx", "kt", "jp", "xc", "cfg", "nc", "ca", "cm", " context", "ci", "vc", "anc", "lc", "crit", "pkg", "ch", "cmd", "kb", "sc", "exec"], "rt": ["round", "rf", "irt", "adr", "ru", "boot", "yt", "RD", "vert", "it", "ry", "nt", "dt", "rr", "tt", "rect", "vt", "ct", "fit", "pt", "rb", "gt", "ptr", "rot", "dr", "ut", "ort", "format", "rc", "ird", "r", "rid", "art", "root", "xt", "rn", "vr", "cat", "RT", "rx", "rat", "mt", "ft", "vc", "ann", "flat", "br", "rh", "rm"], "rd": ["ld", "rh", "dra", "ru", "dim", "RD", "ds", "hr", "ord", "RS", "rw", "RF", "rr", "fd", "d", "rod", "red", "addr", " RD", "cd", "attr", "rb", "respond", "rs", "dr", "xd", "nd", "sync", "rc", "RM", "ird", "rid", "dd", "dc", "rn", "rx", "rg", "ri", "RR", "td", "rl", "rm"], "t0": ["tt0", "at62", "t53", "p2", " t8", "f200", "t1", "at1", "t255", "kt255", "T00", "ktNG", "kt1", "at050", "t25", "p255", "te2", "x1", "x255", "t62", "at25", "t6", "T6", "T1", "ty0", "TNG", "ty1", "pt250", "pt1", "p00", "kt0", "te1", "kt100", "p8", "ten8", " t00", "p050", "t93", "te0", "ot00", "p100", "ot0", "at53", "ot1", "ten0", " t5", "att5", "t192", " tNG", "th1", "p25", "t250", "dt8", "th0", "T5", "f00", "temp0", "ptNG", "p200", "f250", "t8", "ot200", "pt2", "dt1", "f1", " t62", "T2", "ty93", "x0", "at00", "T0", "p93", "t100", "te00", "p0", "temp8", "t5", "p1", "tt6", " t250", "t050", "dt0", "kt53", "f0", "pt0", " t2", " t25", "t200", " t100", "temp192", "ot5", "at200", "pt00", "f5", "att0", "dt93", "ty8", "th00", " t200", "pNG", " t1", "kt050", "tt1", "p53", "tt00", "att1", "th250", "xNG", "ten192", "attNG", " t192", "tNG", "t2", "at0", "temp250", "t00", "ten250", "ot6", " t255", "p62"]}}
{"project": "qemu", "commit_id": "af01492755b82ccaf0d15014477b34ba3ea643fc", "target": 1, "func": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n", "idx": 10735, "substitutes": {"dev": ["diff", "conf", "gu", "kind", "gd", "di", "cam", "debug", "dom", "Dev", "def", "conn", "w", "prom", "die", "info", "dem", "development", "ve", "adv", "d", "ver", "de", "ad", "data", "p", "Device", "obj", "app", "pro", "driver", "plug", "bug", "rad", "serial", "prop", "nov", "priv", "sk", "inst", "ev", "device", "pub", "v", "raw", "md", "req", "cur", "mod", "dd", "new", "desc", "dc", "unknown", "error", "spec", "sd", " Dev", "init", "DE", "bus", "self", "grad", "od", "DEV"], "errp": ["erp", "err", "rp", "errP", " errP", "errpc", "rpc", "erP", " errpc", "erpc", " errr", "rP", "errr", "rr"], "s": ["conf", "session", "sg", "ts", "sh", "sv", "is", "ds", "g", "sf", "m", "src", "ops", "gs", "service", "c", "i", "p", "ls", "e", "args", "js", "sq", "rs", "f", "os", "us", "cs", "sym", "o", "aws", "S", "sync", "sl", "services", "new", "ns", "sb", "spec", "u", "sys", "side", "ses", "su", "fs", "uns", "ps", "ss", "ssl"]}}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "static int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n\n{\n\n    RangeCoder *c = &fs->c;\n\n    uint8_t state[CONTEXT_SIZE];\n\n    unsigned ps, i, context_count;\n\n    memset(state, 128, sizeof(state));\n\n\n\n    if (fs->ac > 1) {\n\n        for (i = 1; i < 256; i++) {\n\n            fs->c.one_state[i]        = f->state_transition[i];\n\n            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];\n\n        }\n\n    }\n\n\n\n    fs->slice_x      = get_symbol(c, state, 0) * f->width;\n\n    fs->slice_y      = get_symbol(c, state, 0) * f->height;\n\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;\n\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n\n\n    fs->slice_x     /= f->num_h_slices;\n\n    fs->slice_y     /= f->num_v_slices;\n\n    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;\n\n    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n\n    if ((unsigned)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < f->plane_count; i++) {\n\n        PlaneContext *const p = &fs->plane[i];\n\n        int idx               = get_symbol(c, state, 0);\n\n        if (idx > (unsigned)f->quant_table_count) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        p->quant_table_index = idx;\n\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n\n        context_count = f->context_count[idx];\n\n\n\n        if (p->context_count < context_count) {\n\n            av_freep(&p->state);\n\n            av_freep(&p->vlc_state);\n\n        }\n\n        p->context_count = context_count;\n\n    }\n\n\n\n    ps = get_symbol(c, state, 0);\n\n    if (ps == 1) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 1;\n\n    } else if (ps == 2) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 0;\n\n    } else if (ps == 3) {\n\n        f->cur->interlaced_frame = 0;\n\n    }\n\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n\n\n\n    if (av_image_check_sar(f->width, f->height,\n\n                           f->cur->sample_aspect_ratio) < 0) {\n\n        av_log(f->avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n\n               f->cur->sample_aspect_ratio.num,\n\n               f->cur->sample_aspect_ratio.den);\n\n        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10738, "substitutes": {"f": ["count", "l", "af", "m", "http", "fd", "t", "x", "fw", "fb", "config", "ref", "feed", "of", "fl", "v", "flags", "full", "now", "form", "self", "flat", "fi", "fab", "fc", "xf", "lf", "sf", "_", "id", "fr", "b", "s", "e", "cf", "bf", "tf", "r", "this", "u", "file", "rf", "fen", "g", "ff", "ul", "fed", "d", "fp", "flow", "df", "fa", "fm", "fx", "feature", "new", "fn", "F", "func", "aff", "uf", "conf", "fo", "function", "raf", "h", "pos", "fac", "y", "inf", "fe"], "fs": ["utils", "af", "http", "fd", "x", "fw", "flows", "gs", "fb", "feed", "wcs", "of", "fl", "v", "flags", "full", "ns", "fi", "ves", "fc", "vals", "xf", "FS", "lf", "ds", "sf", "fr", "ils", "s", "e", "cf", "bc", "bf", "tf", "res", "es", "fps", "fits", "ss", "ows", "Fs", "fee", "rf", "uses", "ks", "frames", "ff", "features", "ops", "ls", "fp", "df", "os", "cs", "fm", "linux", "aux", "fx", "fn", "sys", "cache", "func", "fts", "vs", "uf", "ts", "fo", "rows", "fields", "files", "qs", "rs", "obs", "states", "raf", "ms", "faces", "h", "options", "css", "bs", "fe"], "c": ["l", "cr", "arc", "center", "conf", "co", "C", "abc", "n", "g", "m", "conn", "b", "t", "k", "z", "x", "d", "con", "cp", "ct", "config", "s", "chain", "e", "cd", "cu", "cf", "cn", "ec", "coll", "q", "bc", "cc", "ac", "code", "cs", "cus", "cv", "v", "ce", "ic", "ctx", "r", "can", "cl", "pc", "dc", "xc", "com", "col", "controller", "u", "this", "nc", "h", "cm", "ca", "cycle", "ci", "vc", "lc", "cache", "jc", "y", "ch", "mc", "uc", "cy", "sc", "fc"], "state": ["parent", "count", "session", "m", "t", "config", "memory", "loc", "st", "body", "code", "v", "object", "port", "type", "form", "seed", "buffer", "key", "id", "instance", "s", "rule", "component", "e", "j", "slice", "input", "current", "r", "this", "u", "State", "context", "str", "source", "conn", "public", "stat", "data", "local", "STATE", "style", "resource", "size", "version", "sync", "use", "cache", "core", "area", "start", "pointer", "private", "name", "states", "address", "h", "null", "options", "length", "y"], "ps": [" base", " parent", " bc", "State", " val", " cache", " output", " cc", " frame", " pos", " function", " _", " config", " func", " mask", " q", " block", " self", " col", " props", " bits", " code", " flags", " out", " res", " source", " callback"], "i": ["oi", "l", "diff", "ani", "hi", "ui", "di", "it", "is", "si", "n", "axis", "in", "zi", "key", "id", "info", "xi", "m", "b", "ini", "z", "ami", "x", "ji", "uri", "ix", "e", "mu", "yi", "esi", "mini", "eni", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "jit", "ind", "mi", "ti", "gi", "phi", "isin", "min", "abi", "inner", "qi", "ij", "ei", "bi", "pi", "ii", "u", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "range"], "context_count": ["path2counter", "path_name", "context_counter", "path_count", "context2count", "context1count", "path2name", "context2counter", "context_name", "context1counter", "context_len", "path_len", "path2count", "path2len", "context1name", "context1len", "context2name", "path_counter", "context2len"], "p": ["l", "g", "m", "b", "z", "pp", "cp", "e", "np", "pe", "pt", "q", "P", "op", "j", "o", "py", "v", "r", "port", "pi", "pc", "u", "a", "vp"]}}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10741, "substitutes": {"cs": ["ks", "ds", "cing", "conn", "c", "cp", "ct", "ls", "qs", "cf", "cn", "wcs", "ec", "cc", "bc", "sk", "acs", "ck", "mc", "ce", "rc", "sync", "CS", "ics", "ctx", "ns", "pc", "sb", "ms", "cms", "sys", "nc", "ca", "cm", "ci", "ps", "fs", "css", "lc", "anc", "bs", "cus", "cks", "cy", "sc"], "bp": ["lp", "sp", "bb", "pg", "nb", "ba", "conn", "b", "pa", "pp", "kb", "bridge", "cp", "fb", "bd", "p", "config", "pb", "pd", "fp", "np", "gb", "gp", "arp", "bc", "bf", "mp", "eb", "bg", "bps", "bh", "ctx", "lb", "GP", "hp", "tp", "jp", "sb", "pc", "PB", "usb", "cpp", "esp", "bsp", "br", "adj", "BP", "vp"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n", "idx": 10744, "substitutes": {"rdma_ram_block": ["rdma_ram_lock", "rdma_ramxlock", "rdma_ram_type", "rdma_ramxdevice", "rdma_mem_block", "rdma_ramxblock", "rdma_mem_Block", "rdma_ram_Block", "rdma_mem_device", "rdma_mem_type", "rdma_ram_device", "rdma_ramxBlock", "rdma_mem_lock"], "i": ["l", "ui", "is", "si", "g", "m", "b", "x", "d", "data", "c", "p", "uri", "ix", "e", "memory", "mini", "f", "j", "ai", "multi", "slice", "index", "v", "gi", "ti", "phi", "r", "buffer", "qi", "pi", "bi", "ii", "h", "I", "ip", "ci", "a", "io", "fi", "iu"]}}
{"project": "FFmpeg", "commit_id": "a1e093a6fb324612266d40e3168a14f58adab265", "target": 0, "func": "static int decode_element(AVCodecContext *avctx, void *data, int ch_index,\n\n                          int channels)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;\n\n    uint32_t output_samples;\n\n    int i, ch;\n\n\n\n    skip_bits(&alac->gb, 4);  /* element instance tag */\n\n    skip_bits(&alac->gb, 12); /* unused header bits */\n\n\n\n    /* the number of output samples is stored in the frame */\n\n    has_size = get_bits1(&alac->gb);\n\n\n\n    alac->extra_bits = get_bits(&alac->gb, 2) << 3;\n\n    bps = alac->sample_size - alac->extra_bits + channels - 1;\n\n    if (bps > 32) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* whether the frame is compressed */\n\n    is_compressed = !get_bits1(&alac->gb);\n\n\n\n    if (has_size)\n\n        output_samples = get_bits_long(&alac->gb, 32);\n\n    else\n\n        output_samples = alac->max_samples_per_frame;\n\n    if (!output_samples || output_samples > alac->max_samples_per_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\",\n\n               output_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!alac->nb_samples) {\n\n        /* get output buffer */\n\n        alac->frame.nb_samples = output_samples;\n\n        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n    } else if (output_samples != alac->nb_samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\",\n\n               output_samples, alac->nb_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    alac->nb_samples = output_samples;\n\n    if (alac->direct_output) {\n\n        for (ch = 0; ch < channels; ch++)\n\n            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];\n\n    }\n\n\n\n    if (is_compressed) {\n\n        int16_t lpc_coefs[2][32];\n\n        int lpc_order[2];\n\n        int prediction_type[2];\n\n        int lpc_quant[2];\n\n        int rice_history_mult[2];\n\n\n\n        decorr_shift       = get_bits(&alac->gb, 8);\n\n        decorr_left_weight = get_bits(&alac->gb, 8);\n\n\n\n        for (ch = 0; ch < channels; ch++) {\n\n            prediction_type[ch]   = get_bits(&alac->gb, 4);\n\n            lpc_quant[ch]         = get_bits(&alac->gb, 4);\n\n            rice_history_mult[ch] = get_bits(&alac->gb, 3);\n\n            lpc_order[ch]         = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = lpc_order[ch] - 1; i >= 0; i--)\n\n                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);\n\n        }\n\n\n\n        if (alac->extra_bits) {\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                if(get_bits_left(&alac->gb) <= 0)\n\n                    return -1;\n\n                for (ch = 0; ch < channels; ch++)\n\n                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);\n\n            }\n\n        }\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],\n\n                            alac->nb_samples, bps,\n\n                            rice_history_mult[ch] * alac->rice_history_mult / 4);\n\n            if(ret<0)\n\n                return ret;\n\n\n\n            /* adaptive FIR filter */\n\n            if (prediction_type[ch] == 15) {\n\n                /* Prediction type 15 runs the adaptive FIR twice.\n\n                 * The first pass uses the special-case coef_num = 31, while\n\n                 * the second pass uses the coefs from the bitstream.\n\n                 *\n\n                 * However, this prediction type is not currently used by the\n\n                 * reference encoder.\n\n                 */\n\n                lpc_prediction(alac->predict_error_buffer[ch],\n\n                               alac->predict_error_buffer[ch],\n\n                               alac->nb_samples, bps, NULL, 31, 0);\n\n            } else if (prediction_type[ch] > 0) {\n\n                av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\",\n\n                       prediction_type[ch]);\n\n            }\n\n            lpc_prediction(alac->predict_error_buffer[ch],\n\n                           alac->output_samples_buffer[ch], alac->nb_samples,\n\n                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        for (i = 0; i < alac->nb_samples; i++) {\n\n            if(get_bits_left(&alac->gb) <= 0)\n\n                return -1;\n\n            for (ch = 0; ch < channels; ch++) {\n\n                alac->output_samples_buffer[ch][i] =\n\n                         get_sbits_long(&alac->gb, alac->sample_size);\n\n            }\n\n        }\n\n        alac->extra_bits   = 0;\n\n        decorr_shift       = 0;\n\n        decorr_left_weight = 0;\n\n    }\n\n\n\n    if (channels == 2 && decorr_left_weight) {\n\n        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,\n\n                           decorr_shift, decorr_left_weight);\n\n    }\n\n\n\n    if (alac->extra_bits) {\n\n        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,\n\n                          alac->extra_bits, channels, alac->nb_samples);\n\n    }\n\n\n\n    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {\n\n    switch(alac->sample_size) {\n\n    case 16: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10750, "substitutes": {"avctx": ["afconn", "avalbc", "afctx", "afcup", "AVcf", "avalctx", "avalcontext", "navctx", "avebc", " avdc", "alconn", "Avctl", "avbc", "alctl", "afpkg", "avectx", " avca", "alcontext", "afmac", "avmac", "avemac", "afctl", "verpkg", "avcf", "navconn", "AVcontext", "avdc", "avedc", "avcup", "alctx", "verctx", "vercontext", "afcf", "verlc", "avconn", "aflc", "Avcf", " avmac", "AVlc", "avlc", "AVctx", "AVconn", "afbc", " avcontext", "verconn", "avalconn", "avcontext", "Avctx", " avcf", "navcf", "avpkg", "avca", "navcontext", "afca", "AVctl", "afdc", "alpkg", "avecf", "aveconn", "avecontext", "aveca", "avctl", "afcontext", "navcup", "verctl", "avecup", "navctl", "Avcontext"], "data": ["parent", "base", "context", "source", "media", "window", "da", "d", "config", "batch", "reader", "ata", "memory", "frame", "array", "body", "DATA", "dat", "input", "connection", "audio", "Data", "api", "image", "cache", "result", "buffer", "database"], "ch_index": ["ach_Index", "ch_Index", "chkslice", "chkIndex", "ach_level", "chslevel", "ch_level", "ach_slice", "chklevel", "chsindex", "ach_index", "ch_slice", "chsIndex", "chkindex", "chsslice"], "channels": [" chunks", "cars", "cords", "shannels", "channel", "chords", "Chords", "Chunks", "cannels", "shords", "Chanes", "chunks", "Chars", "shanes", "CHapters", "compunks", "compords", "shars", "companes", " chapters", "CHannel", "chanes", "tchannels", "tchunks", "cunks", " channel", "shunks", "Channels", "chars", "tchapters", "compannels", "CHannels", "chapters", "CHunks", "tchannel"], "alac": ["almac", "alec", "realacs", "alacl", "palacs", "pelacc", "pelax", "malac", "plax", "alsac", "realac", "elmac", "llax", "ilacc", "elact", "ellas", " aljac", "isalacer", "challac", " alacs", "alacc", "allac", "realanc", " alax", "calas", "balacc", "eliac", "palanc", " aloc", "aliacc", "alianc", "alacer", "alas", "llac", "plac", "balas", "ALac", "chalanc", "unalacc", "balact", "llanc", "aloc", "chalacl", "allas", "malacc", "isalAC", "alax", "ellmac", "alsec", "ralanc", "challacc", "alsacc", "aljac", "realacc", "aliiac", "calacs", "calec", " alas", "elacc", "pelac", "isalacl", " alec", " alanc", "alsoc", "ALacs", "llact", "ALAC", "ilas", "belacs", "alanc", "unalac", "belacc", "chalas", "chalacs", "elanc", "ellac", "eloc", "unalmac", "maliac", " alact", "calax", " alacc", "alsiac", "aliacl", "ralact", "llas", "plAC", "alioc", " alacl", "ALacc", "calmac", "ellacc", "calanc", "alsacs", "isaljac", "planc", "baloc", "elas", "challax", "aliacs", "belac", " alacer", "isalacc", "ralacc", "unalax", "palacc", "balanc", "isalanc", "isalac", "chalac", "aliac", "balmac", "alsmac", "calac", "isaloc", "elac", "challas", "alact", "balac", "llacc", "elacs", " alAC", "ilac", "placc", "palac", "caliac", "calacer", "placs", "calacc", "eljac", "ralac", "alacs", "malmac", "elAC", " almac", "belacl", "allanc", "ilanc", "alAC", "calAC", "alsacl", "chalacc", "pelAC", "allacc"], "has_size": ["hasRcount", "has_time", "is_count", "has_sized", "has_width", "hasRwidth", " has_time", "has67sized", "is_sized", "has_count", "hasRsized", "has_speed", "has67speed", "hasRsize", "full_speed", "full_sized", "has67size", "is_width", " has_group", "is_size", "full_size", "has_group"], "bps": ["lp", "vs", "apps", "bb", "abytes", "nb", "strings", "prefix", "lbs", "aps", "stats", "cases", "bp", "prot", "tips", "pps", "ops", "posts", "ipes", "ls", "pb", "parts", "pieces", "fp", "steps", "jobs", "bands", "bits", "rb", "planes", "offs", "pins", "objects", "lines", "bys", "plugins", "limits", "items", "fps", "eps", "bis", "codes", "hops", "details", "sb", "blocks", "bytes", "allows", "rates", "points", "ips", "params", "ps", "nets", "bs"], "is_compressed": ["is_cress", "is_Compressed", "is_suppression", "is_cressed", "is_Compression", "is_ompress", "is_composed", "is_compress", "is_Composed", "is_ompression", "is_suppressed", "is_compression", "is_Compress", "is_cured", "is_cression", "is_compured", "is_ompressed", "is_supposed", "is_suppured", "is_omposed", "is_Compured", "is_suppress"], "decorr_shift": ["decorr_offset", "decoris_left", "decorr\u00b7left", "decorr\u00b7shift", "decorr_left", "decorr\u00b7power", "decorr\u00b7offset", "decoris_power", "decoris_offset", "decorr_power", "decoris_shift"], "decorr_left_weight": ["decorr_left2count", "decorr_shift_weights", "decorr_shift_count", "decorr_left2weight", "decorr_left2shift", "decorr_shift_shift", "decorr_shift_weight", "decorr_left_count", "decorr_left_weights", "decorr_left2weights", "decorr_left_shift"], "ret": ["arr", "valid", "ext", "len", "val", "alt", "def", "nt", "ait", "temp", "Ret", "mem", "reply", "ref", "lit", "fit", "cb", "reg", "obj", "txt", "value", "utf", "rb", "rets", "bc", "rt", "res", "det", "format", "rc", "fun", "att", "req", "mat", "bis", "cur", "ben", "rep", "get", "bit", "fin", "re", "RET", "back", "out", "result", "rev", "ft", "match", "resp", "buffer", "success", "pet"], "output_samples": ["output_asamps", "output_setsamp", "output_sacks", "output_tales", "output_nonents", "output_suffipes", "output_lacks", "output_requamples", "output_sipes", "output\u00b7servicesamples", "output_sones", "output_outsamps", "output_outsiles", "output_setsamples", "output_esamp", "output_vamples", "output_pores", "output_nones", "output_damples", "output_namps", "output_sales", "output_tamps", "output_assips", "output_sips", "output_requones", "output_tamples", "output_siles", "output_nizes", "output_sances", "output_suamples", "output_Sonents", "output_lones", "output_linesills", "output_setsamps", "output_linesamples", "output\u00b7servicesases", "output_samp", "output_sesamp", "output_lannels", "output_seamples", "output_samps", "output_suffannels", "output_asamples", "output\u00b7samp", "output_vips", "output_outspects", "output_suffums", "output_sportsamps", "output_nannels", "output_asales", "output_assamples", "output\u00b7sonents", "output_sannels", "output_esamples", "output_requacks", "output_dannels", "output_dums", "output_sesances", "output_lums", "output\u00b7sases", "output_requamps", "output_dipes", "output_servicesamples", "output\u00b7linesonents", "output_Sills", "output_vamps", "output_lamps", "output\u00b7linesamples", "output_sample", "output\u00b7linesills", "output_pamps", "output_sases", "output_npects", "output\u00b7servicesamp", "output_nales", "output_sills", "output_namples", "output_esases", "output_lamples", "output_suores", "output_pamples", "output_assamps", "output_linesonents", "output_Sessions", "output\u00b7samples", "output_servicesamp", "output\u00b7servicesamps", "output_Samples", "output_outsamples", "output_seores", "output_sessions", "output_sesamps", "output_Samps", "output_servicesessions", "output_suample", "output_sportspects", "output_sores", "output_nips", "output_seample", "output_suffamples", "output\u00b7sills", "output_servicesamps", "output_nacks", "output_sportsiles", "output_sums", "output_lipes", "output_nills", "output_spects", "output_pample", "output_vizes", "output_servicesases", "output_tannels", "output_sizes", "output_niles", "output_namp", "output_setsances", "output_seamps", "output\u00b7samps", "output_nances", "output_suamps", "output_nases", "output_asannels", "output_sportsamples", "output_sesamples", "output_esamps", "output_sonents", "output_assizes"], "i": ["count", "l", "channel", "base", "it", "n", "b", "x", "k", "z", "num", "d", "c", "p", "e", "f", "j", "ai", "v", "chi", "pi", "bi", "ii", "I", "ip", "ci", "io"], "ch": ["count", "l", "channel", "chrom", "conf", "sh", "oy", "cmp", "arch", "ach", "ph", "conn", "ich", "chip", "b", "ver", "c", "cp", "qu", "batch", "och", "p", "app", "cb", "cf", "gh", "CH", "loc", "q", "cho", "f", "sk", "j", "code", "zh", "child", "th", "cht", "cha", "anch", "che", "ind", "cher", "bh", "ctx", "chi", "sch", "cl", "mot", "cor", "col", "Ch", "change", "h", "ech", "dev", "ci", "comp", "length", "cmd", "chan"]}}
{"project": "FFmpeg", "commit_id": "57cc1ad35fd488c7a879661498f6f3508038d5a9", "target": 0, "func": "static av_always_inline float quantize_and_encode_band_cost_template(\n\n                                struct AACEncContext *s,\n\n                                PutBitContext *pb, const float *in,\n\n                                const float *scaled, int size, int scale_idx,\n\n                                int cb, const float lambda, const float uplim,\n\n                                int *bits, int BT_ZERO, int BT_UNSIGNED,\n\n                                int BT_PAIR, int BT_ESC)\n\n{\n\n    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float CLIPPED_ESCAPE = 165140.0f*IQ;\n\n    int i, j, k;\n\n    float cost = 0;\n\n    const int dim = BT_PAIR ? 2 : 4;\n\n    int resbits = 0;\n\n    const float  Q34 = sqrtf(Q * sqrtf(Q));\n\n    const int range  = aac_cb_range[cb];\n\n    const int maxval = aac_cb_maxval[cb];\n\n    int off;\n\n\n\n    if (BT_ZERO) {\n\n        for (i = 0; i < size; i++)\n\n            cost += in[i]*in[i];\n\n        if (bits)\n\n            *bits = 0;\n\n        return cost * lambda;\n\n    }\n\n    if (!scaled) {\n\n        abs_pow34_v(s->scoefs, in, size);\n\n        scaled = s->scoefs;\n\n    }\n\n    quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval);\n\n    if (BT_UNSIGNED) {\n\n        off = 0;\n\n    } else {\n\n        off = maxval;\n\n    }\n\n    for (i = 0; i < size; i += dim) {\n\n        const float *vec;\n\n        int *quants = s->qcoefs + i;\n\n        int curidx = 0;\n\n        int curbits;\n\n        float rd = 0.0f;\n\n        for (j = 0; j < dim; j++) {\n\n            curidx *= range;\n\n            curidx += quants[j] + off;\n\n        }\n\n        curbits =  ff_aac_spectral_bits[cb-1][curidx];\n\n        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];\n\n        if (BT_UNSIGNED) {\n\n            for (k = 0; k < dim; k++) {\n\n                float t = fabsf(in[i+k]);\n\n                float di;\n\n                if (BT_ESC && vec[k] == 64.0f) { //FIXME: slow\n\n                    if (t >= CLIPPED_ESCAPE) {\n\n                        di = t - CLIPPED_ESCAPE;\n\n                        curbits += 21;\n\n                    } else {\n\n                        int c = av_clip(quant(t, Q), 0, 8191);\n\n                        di = t - c*cbrtf(c)*IQ;\n\n                        curbits += av_log2(c)*2 - 4 + 1;\n\n                    }\n\n                } else {\n\n                    di = t - vec[k]*IQ;\n\n                }\n\n                if (vec[k] != 0.0f)\n\n                    curbits++;\n\n                rd += di*di;\n\n            }\n\n        } else {\n\n            for (k = 0; k < dim; k++) {\n\n                float di = in[i+k] - vec[k]*IQ;\n\n                rd += di*di;\n\n            }\n\n        }\n\n        cost    += rd * lambda + curbits;\n\n        resbits += curbits;\n\n        if (cost >= uplim)\n\n            return uplim;\n\n        if (pb) {\n\n            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);\n\n            if (BT_UNSIGNED)\n\n                for (j = 0; j < dim; j++)\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)\n\n                        put_bits(pb, 1, in[i+j] < 0.0f);\n\n            if (BT_ESC) {\n\n                for (j = 0; j < 2; j++) {\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {\n\n                        int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191);\n\n                        int len = av_log2(coef);\n\n\n\n                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);\n\n                        put_bits(pb, len, coef & ((1 << len) - 1));\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (bits)\n\n        *bits = resbits;\n\n    return cost;\n\n}\n", "idx": 10765, "substitutes": {"s": ["conf", "session", "utils", "ts", "sv", "g", "sites", "strings", "t", "sci", "ops", "gs", "service", "c", "sa", "p", "ls", "qs", "e", "ins", "parts", "outs", "js", "rs", "xs", "os", "f", "cs", "sym", "sets", "S", "sync", "south", "states", "sl", "services", "bis", "ns", "sb", "storage", "sis", "spec", "hs", "sys", "self", "rates", "comments", "ses", "ps", "a", "uns", "ss", "settings", "ssl", "sc"], "pb": ["lp", "ib", "wp", "abc", "bp", "prot", "pl", "bm", "ab", "pp", "cp", "fb", "p", "pd", "gb", "fp", "ub", "rb", "pm", "bc", "mp", "bps", "lb", "sb", "pc", "PB", "cpp", "proc", "vp"], "in": ["arr", "rin", "pass", "str", "is", "source", "In", "win", "again", "m", "id", "quad", "x", "ini", "inn", "login", "include", "rec", "con", "data", "c", "config", "gin", "e", "ins", "q", "f", "binary", "slice", "index", "ints", "inc", "v", "input", "min", "isin", "din", "ic", "query", "inner", "err", "margin", "circ", "orig", "init", "a", "out", "image", "bin", "inf", "IN", "nin", "pin", "lin"], "scaled": ["decaled", " scalled", "oscaling", "Scased", "SCalled", "decaling", "scale", "Scaped", "oscased", "scided", "oscalled", "escalled", "Scaling", "Scaled", "escaled", "secaling", "scased", "SCided", "Scalled", "secalled", "Scale", "SCale", "escale", "oscaped", "scaped", " scaling", "scalled", "SCaled", "oscaled", "decalled", "decided", "escaling", "secased", "secaled", "scaling", "SCaling", " scided", "secaped"], "size": ["iz", "dim", "sh", "scale", "si", "len", "small", "z", "SIZE", "shift", "c", "sum", "max", "time", "global", "mini", "loc", "sq", "Size", "sec", "mode", "empty", "code", "unit", "shape", "sync", "six", "sized", "inner", "grade", "pos", "engine", "ize", "core", "sc", "range"], "scale_idx": ["scale_sidX", "scale_indi", "scale_idsw", "scale_nameci", "scale_ridn", "scale6idxes", "scale_midz", "scale_idz", "scale_idsx", "scale_idn", "scale_ridx", "scale_idsp", "scale_ridi", "scale_ridw", "scale_idp", "scale_ridxes", "scale6idi", "scale_idci", "scale_IDn", "scale_midx", "scale_sidx", "scale_ridp", "scale_indx", "scale_ridci", "scale_IDp", "scale_idi", "scale6namei", "scale_idw", "scale_idX", "scale_sidz", "scale_idc", "scale_IDw", "scale_idsn", "scale_indxes", "scale6idci", "scale_namex", "scale_sidc", "scale_namexes", "scale6idx", "scale_idxes", "scale_midc", "scale6namexes", "scale_indci", "scale_namei", "scale6nameci", "scale6namex", "scale_midX", "scale_IDx"], "cb": ["count", "conf", "seq", "co", "bb", "cmp", "nb", "len", "ff", "abb", "conn", "src", "phy", "b", "c", "cp", "fb", "batch", "cd", "coord", "gb", "cf", "cn", "rb", "loc", "bc", "binary", "code", "db", "bf", "ctrl", "ctr", "cv", "CB", "sync", "uv", "ctx", "callback", "nr", "cor", "dc", "nc", "cfg", "confirmed", "ob", "func", "cmd", "buff", "core", "cgi", "kb", "kk", "aff"], "lambda": ["LA", "seq", "std", "bb", "abc", "wa", "da", "lim", "quad", "z", " gamma", "appa", "data", " beta", "qa", "mu", "sq", "dB", "lam", "la", "alpha", "slice", "aux", "wave", "phi", "fun", "abi", "function", "cl", "acl", "boost", "fn", "xy", "igma", "func", "partial", "beta", "kl"], "uplim": ["uiplime", "uiplims", "uPLength", "uPlims", "uPlength", " uPLength", "uPlim", "uPLim", " uPLim", " uplims", " uPLime", "uPLims", " uPLims", "uplims", "uPLime", "uiplim", "uplime", " uplime", "uiplength", "uPlime", " uplength", "uplength"], "bits": ["utils", "its", "frames", "rows", "lbs", "features", "ops", "works", "flows", "weights", "reads", "pieces", "ids", "jobs", "ins", "parts", "steps", "bands", "planes", "pins", "plugins", "limits", "items", "ints", "flags", "bugs", "fps", "checks", "cycles", "groups", "holes", "hours", "blocks", "bytes", "bit", "ips", "forces", "bs", "lins"], "BT_ZERO": ["BT_READAME", "BT_ZEAME", "BT_READIVE", "BT_ZOK", "BT_READERO", "BT_CCONE", "BT_ZIVE", "BT_READONE", "BT_ZEERO", "BT_AZONE", "BT_AZOK", "BT_ZONE", "BT_ZOW", "BT_ZEONE", "BT_AZERO", "BT_ZAME", "BT_CCOW", "BT_ZEIVE", "BT_AZOW", "BT_CCOK", "BT_CCERO"], "BT_UNSIGNED": ["BT_OUTCCRED", "BT_UNCEPTRED", "BT_UNFEED", "BT_UNSignED", "BT_UNCEPTED", "BT_UNSignING", "BT_UNFINed", "BT_UNFORMLED", "BT_UNSIGNAL", "BT_UNFINED", "BT_OUTSIGNMED", "BT_OUTCCLED", "BT_UNCCLED", "BT_UNCEPTLED", "BT_UNSigned", "BT_UNCCED", "BT_UNSIGNIFIED", "BT_UNFEed", "BT_UNSIGNRED", "BT_UNCCMED", "BT_UNFORMRED", "BT_OUTSIGNLED", "BT_UNCEPTMED", "BT_OUTCCMED", "BT_UNFEAL", "BT_UNFORMED", "BT_UNCCRED", "BT_OUTSIGNRED", "BT_UNFINIFIED", "BT_UNSignIFIED", "BT_UNFEITED", "BT_UNSignITED", "BT_OUTSIGNED", "BT_UNFORMMED", "BT_UNSIGNMED", "BT_UNSIGNed", "BT_UNSIGNLED", "BT_UNSIGNITED", "BT_UNSignAL", "BT_UNSIGNING", "BT_UNFINING", "BT_OUTCCED"], "BT_PAIR": ["BT_WAVEL", "BTTIMEWAVEL", "BT_FAAR", "BT_PAIX", "BT_MAIR", "BT_BAIR", "BT_WAULL", "BT_WAUSE", "BT_WAIR", "BT_PAR", "BTTIMEPAVEL", "BT_FAIX", "BTTIMEPAUSE", "BT_PAUSE", "BT_PAAR", "BT_PIX", "BTTIMEWAIR", "BT_MAAR", "BT_PAVEL", "BT_CAVEL", "BT_BAVEL", "BT_PAULL", "BT_FAIR", "BT_MAIX", "BT_CAULL", "BTTIMEPAIR", "BT_BAULL", "BTTIMEWAUSE", "BT_CAIR", "BTTIMEPAULL", "BT_CAUSE", "BT_FAULL", "BT_PIR", "BT_MAULL", "BT_PULL", "BTTIMEWAULL", "BT_BAUSE"], "BT_ESC": ["BT_USC", "BT_DESCI", "BT_DESCC", "BT_ESCENT", "BT_EXCI", "BT_ESCI", "BT_DESCENT", "BT_EXCC", "BT_EXC", "BT_USCC", "BT_EXCENT", "BT_USCI", "BT_USCENT", "BT_DESC", "BT_ESCC"], "i": ["oi", "l", "ani", "ui", "dim", "it", "n", "si", "zi", "m", "xi", "info", "id", "x", "ini", "z", "my", "b", "d", "uli", "c", "ji", "p", "ix", "uri", "e", "yi", "eni", "q", "f", "ie", "ai", "o", "multi", "index", "slice", "v", "gi", "mi", "phi", "ik", "ti", "ind", "chi", "inner", "qi", "im", "pi", "bi", "ii", "u", "h", "I", "li", "pos", "ip", "ci", "ori", "ni", "io", "y", "ri", "fi", "iu", "ki"], "j": ["l", "ld", "ani", "je", "rem", "adj", "n", "g", "key", "m", "fr", "jet", "b", "dj", "z", "num", "d", "x", "ji", "other", "p", "jo", "obj", "e", "rel", "kj", "pt", "q", "js", "uj", "o", "v", "syn", "jit", "ind", "r", "qi", "ij", "err", "old", "jp", "part", "ii", "ja", "aj", "h", "li", "pos", "J", "y", "ch", "jc", "jl", "jj", "br"], "k": ["km", "n", "g", "key", "w", "m", "x", "b", "z", "max", "p", "e", "ok", "kk", "q", "f", "sk", "o", "v", "ik", "r", "K", "ke", "u", "y", "ki"], "off": ["over", "eff", "alt", "ff", "ord", "and", "def", "no", "info", "id", "low", "shift", "block", "ov", "ref", "offs", "flow", "op", "mode", "none", "loss", "of", "o", "offer", "opt", "order", "raw", "fun", "end", "function", "err", "load", "cost", "error", "offset", "now", "orig", "bit", "OFF", "online", "pos", "Off", "dev", "on", "loop", "out", "cmd", "down"], "vec": ["seq", "arr", "xp", "len", "window", "def", "buf", "var", "factor", "cube", "vp", "opt", "cv", "expr", "spec", "init", "vector", "xy", "rx", "cycle", "vv", "func", "vc", "flat", "feat", "fi", "vel"], "quants": ["quands", " quats", "aquant", "aquants", " quANT", "aquands", "quANT", "QUANT", "acquants", "quant", "aquANT", "acquands", "acquant", " quands", "QUants", "quats", "QUands", " quant", "acquats", "QUant", "aquats"], "curbits": ["curbites", "cubit", " curbals", "culpit", "curits", "scurbits", " curbites", "culpits", "curites", " curites", "sculpit", "curbals", "sculpits", "cubals", "scurbals", "cuspit", "sculpals", "culpites", "sculpites", "scurbites", " curits", " curit", "curbit", "culpals", " curbit", "curals", "cuspites", "curit", "cuspits", "scurbit", "cuspals", "cubits", " curals", "cubites"]}}
{"project": "FFmpeg", "commit_id": "ba571f6b4d15a998d6fde387509cd84177fccd96", "target": 0, "func": "static void event_loop(VideoState *cur_stream)\n\n{\n\n    SDL_Event event;\n\n    double incr, pos, frac;\n\n\n\n    for(;;) {\n\n        double x;\n\n        SDL_WaitEvent(&event);\n\n        switch(event.type) {\n\n        case SDL_KEYDOWN:\n\n            if (exit_on_keydown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n            switch(event.key.keysym.sym) {\n\n            case SDLK_ESCAPE:\n\n            case SDLK_q:\n\n                do_exit(cur_stream);\n\n                break;\n\n            case SDLK_f:\n\n                toggle_full_screen(cur_stream);\n\n                break;\n\n            case SDLK_p:\n\n            case SDLK_SPACE:\n\n                if (cur_stream)\n\n                    toggle_pause(cur_stream);\n\n                break;\n\n            case SDLK_s: //S: Step to next frame\n\n                if (cur_stream)\n\n                    step_to_next_frame(cur_stream);\n\n                break;\n\n            case SDLK_a:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);\n\n                break;\n\n            case SDLK_v:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);\n\n                break;\n\n            case SDLK_t:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);\n\n                break;\n\n            case SDLK_w:\n\n                if (cur_stream)\n\n                    toggle_audio_display(cur_stream);\n\n                break;\n\n            case SDLK_LEFT:\n\n                incr = -10.0;\n\n                goto do_seek;\n\n            case SDLK_RIGHT:\n\n                incr = 10.0;\n\n                goto do_seek;\n\n            case SDLK_UP:\n\n                incr = 60.0;\n\n                goto do_seek;\n\n            case SDLK_DOWN:\n\n                incr = -60.0;\n\n            do_seek:\n\n                if (cur_stream) {\n\n                    if (seek_by_bytes) {\n\n                        if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){\n\n                            pos= cur_stream->video_current_pos;\n\n                        }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){\n\n                            pos= cur_stream->audio_pkt.pos;\n\n                        }else\n\n                            pos = avio_tell(cur_stream->ic->pb);\n\n                        if (cur_stream->ic->bit_rate)\n\n                            incr *= cur_stream->ic->bit_rate / 8.0;\n\n                        else\n\n                            incr *= 180000.0;\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, pos, incr, 1);\n\n                    } else {\n\n                        pos = get_master_clock(cur_stream);\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            break;\n\n        case SDL_MOUSEBUTTONDOWN:\n\n            if (exit_on_mousedown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n        case SDL_MOUSEMOTION:\n\n            if(event.type ==SDL_MOUSEBUTTONDOWN){\n\n                x= event.button.x;\n\n            }else{\n\n                if(event.motion.state != SDL_PRESSED)\n\n                    break;\n\n                x= event.motion.x;\n\n            }\n\n            if (cur_stream) {\n\n                if(seek_by_bytes || cur_stream->ic->duration<=0){\n\n                    uint64_t size=  avio_size(cur_stream->ic->pb);\n\n                    stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);\n\n                }else{\n\n                    int64_t ts;\n\n                    int ns, hh, mm, ss;\n\n                    int tns, thh, tmm, tss;\n\n                    tns = cur_stream->ic->duration/1000000LL;\n\n                    thh = tns/3600;\n\n                    tmm = (tns%3600)/60;\n\n                    tss = (tns%60);\n\n                    frac = x/cur_stream->width;\n\n                    ns = frac*tns;\n\n                    hh = ns/3600;\n\n                    mm = (ns%3600)/60;\n\n                    ss = (ns%60);\n\n                    fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \\n\", frac*100,\n\n                            hh, mm, ss, thh, tmm, tss);\n\n                    ts = frac*cur_stream->ic->duration;\n\n                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)\n\n                        ts += cur_stream->ic->start_time;\n\n                    stream_seek(cur_stream, ts, 0, 0);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_VIDEORESIZE:\n\n            if (cur_stream) {\n\n                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,\n\n                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);\n\n                screen_width = cur_stream->width = event.resize.w;\n\n                screen_height= cur_stream->height= event.resize.h;\n\n            }\n\n            break;\n\n        case SDL_QUIT:\n\n        case FF_QUIT_EVENT:\n\n            do_exit(cur_stream);\n\n            break;\n\n        case FF_ALLOC_EVENT:\n\n            video_open(event.user.data1);\n\n            alloc_picture(event.user.data1);\n\n            break;\n\n        case FF_REFRESH_EVENT:\n\n            video_refresh(event.user.data1);\n\n            cur_stream->refresh=0;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 10767, "substitutes": {"cur_stream": ["curplesource", "ser_thread", "curacsystem", "curksystem", "ser_system", " cur_source", "cour_client", "curplesteam", "cur__steam", "curksurface", "public_steam", "curxform", "ur_form", "curacsteam", "curksteam", "cur_steam", "prev_object", "tur_stream", "curtheform", "curssource", "cur_speed", "rah_row", "rah_form", "cur_engine", "curplesound", "curfsteam", "cur1stream", "curfsurface", "publictheenc", "currsample", "pr_surface", "cur_form", "pull_stream", "cur_sound", "curappform", "cur_cloud", "curvalstream", "cur_model", "ur_sw", "curkstream", "curtheenc", "pull_system", "Cur_stream", "curUsystem", "pullUsystem", "cour_host", "curalstream", "Cur_clean", "curappstream", "curgsurface", "curappclean", "cur_surface", "cur_sw", "curgstream", "curxstem", "cur_source", "prvalsteam", "cour_thread", "cur_object", "cur1thread", "pull_sound", "cur__form", "cour_cloud", "cur_track", "ser_speed", " cur_steam", "Cur_form", "pull_sw", "curvalslice", " cur_stem", "curxtrack", "cur_sample", "cour_design", "curappcloud", "curacsurface", "Cur_cloud", "courUsurface", "cour_system", "cour_engine", "publictheform", "curvalsteam", "pr_slice", "curUsteam", "courUstream", "curthestream", "curplestream", "prvalstream", "cur1sound", "cursstream", " cur_track", "cur_row", "ur_stream", "curgstick", "pull_thread", "cur1source", "public_enc", "curthesteam", "prvalsurface", "prev_track", "curkspeed", "pr_steam", "curalthread", "cur_enc", "cur__stream", "pr_stream", "courUengine", "curUstick", "cur_clean", "cur_slice", " cur_clean", "cour_form", "cur_system", "cour_stick", "tur1sound", "tur_source", "cur_transform", "pull_source", "pullUsteam", "cursthread", "pull_surface", "curactransform", "Cur_transform", " cur_form", "curgengine", "curUsurface", "rah_stream", "cur_host", "cur_client", " cur_thread", "prev_thread", "Cur_model", "curalhost", "publicthestream", "public_stream", "prev_stream", "ur_sample", "cur__speed", "curacstream", "curfstream", "tur1source", "curaldesign", "cur_stick", "curacmodel", "curvalsurface", "curssteam", "curxstream", "publicthesteam", "cur_thread", "courUstick", "currsw", "tur_sound", "cour_surface", "prvalslice", "cur_stem", "pullUstream", " cur_speed", "pull_steam", "rah_sample", "ser_stream", "currform", "tur1stream", "cur1form", "cursform", "curfslice", "cur_design", "cour_stream", "currstream", "pullUsurface", "public_form", "curUengine", "curkthread", "curacform", "cour_source", "curUstream"], "event": ["ee", "element", "g", "val", "in", "comment", "test", "view", "key", "ent", "t", "instance", "update", "vent", "data", "c", "e", "Event", "xml", "pe", "bug", "ec", "condition", "empty", "style", "f", " Event", "an", "entry", "ev", "call", "exc", "ce", "name", "input", "feature", "end", "object", "entity", "address", "ception", "load", "error", "advert", "node", "type", "self", "change", "form", "handler", "message", "command", "esc", "ge", "image", "result", "press", "text", "events", "exec"], "incr": ["indrs", "integr", "incre", "integrs", "encpr", "Incerr", "intr", "discrl", " incre", "incrs", "discra", "imprs", " incrb", "infr", "infpr", "integre", "incpr", "intre", "encrl", "accl", "encerr", "Incre", "infra", "incra", "imperr", " incp", "accp", "accr", "encp", " incrum", "Incrb", "incrum", "infrl", "incrl", " incerr", "incp", "impr", "intrs", "integerr", "incl", "encrb", "inderr", "indr", "discpr", " incra", "incerr", " incrs", " incl", "encre", "incrb", "imprum", "encl", "discr", "encr", "indrum", "interr", "encra", "Incr", "accra"], "pos": ["POS", "diff", "sp", "conf", "area", "cond", "location", "pass", "start", "str", "len", "val", "axis", "def", "all", "pl", "pid", "pointer", "block", "slot", "sum", "p", "ref", "limit", "config", "rel", "po", "pt", "style", "loc", "prop", "push", "os", "rot", "next", "unit", "vol", "index", "slice", "pres", "ind", "space", "Pos", "fat", "pr", "end", "port", "patch", "part", "pc", "position", "offset", "spec", "col", "fin", "type", "cache", "resp", "feat"], "frac": ["count", "abc", "window", "win", " fraction", "cut", "angle", "ref", "qa", "sec", "ac", "unit", "alpha", "exc", "fre", "cap", "format", "rc", "fun", " circ", "repeat", "callback", "circ", "bit", " delta", "feat", "fc"], "x": [" cx", "xf", " X", "xp", "xx", "w", "m", "b", "z", "d", "c", "ct", "X", " dx", "f", "xa", "index", " tx", "wx", "xc", "xy", "xe", "rx", "y", "ex"]}}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int sox_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    int ret, size;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n\n\n    size = SOX_SAMPLES*s->streams[0]->codec->block_align;\n\n    ret = av_get_packet(s->pb, pkt, size);\n\n    if (ret < 0)\n\n        return AVERROR(EIO);\n\n\n    pkt->stream_index = 0;\n\n    pkt->size = ret;\n\n\n\n    return 0;\n\n}", "idx": 10772, "substitutes": {"s": ["ts", "ks", "sv", "ds", "is", "g", "si", "sf", "stats", "m", "http", "t", "b", "ops", "gs", "service", "c", "p", "ls", "e", "qs", "xs", "sq", "js", "us", "os", "f", "cs", "sym", "o", "aws", "sets", "S", "v", "sync", "es", "south", "sl", "services", "ns", "sb", "spec", "less", "self", "sys", "ses", "a", "ss", "settings", "ssl", "sc"], "pkt": ["spet", " pet", " packet", "spct", "ppkt", "Pnt", " pnt", "Pkt", "Pet", "Peth", "packet", "ppacket", "spacket", "Pct", "pnt", "ppnt", "Packet", "spkt", "ppeth", " pct", " peth", "pct", "ppct", "peth", "pet"], "ret": ["count", " reply", "flag", "ext", "len", "val", "alt", "g", "def", "_", "nt", "id", "Ret", "t", "sur", "num", "mem", "data", "reply", "el", "lit", "obj", "status", "reg", "value", " result", "number", "rets", "f", "code", "rt", "res", "bf", "format", "rc", "fat", "ner", "r", "fun", " len", "en", "sb", "offset", "get", "read", "bit", "fin", "xt", "re", "nl", "RET", "result", "mt", "ft", "sr", "length", "success"], "size": ["count", "iz", "channel", "scale", "ext", "si", "len", "val", "capacity", "handle", "small", "x", "num", "SIZE", "send", "big", "data", "sum", "max", "el", "fit", "e", "style", "empty", "sec", "f", "loc", "Size", "args", "code", "unit", "body", "large", "sent", "shape", "version", "name", "content", "fat", "address", "en", "sn", "full", "offset", "bytes", "enc", "file", "esc", "length", "ize", "weight", "write", "fee"]}}
{"project": "FFmpeg", "commit_id": "d094052c8e8a036666ac02bfc52bf221ad39e4c8", "target": 1, "func": "static av_cold int svq1_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVQ1Context * const s = avctx->priv_data;\n\n\n\n    dsputil_init(&s->dsp, avctx);\n\n    avctx->coded_frame= (AVFrame*)&s->picture;\n\n\n\n    s->frame_width = avctx->width;\n\n    s->frame_height = avctx->height;\n\n\n\n    s->y_block_width = (s->frame_width + 15) / 16;\n\n    s->y_block_height = (s->frame_height + 15) / 16;\n\n\n\n    s->c_block_width = (s->frame_width / 4 + 15) / 16;\n\n    s->c_block_height = (s->frame_height / 4 + 15) / 16;\n\n\n\n    s->avctx= avctx;\n\n    s->m.avctx= avctx;\n\n\n    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));\n\n    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));\n\n    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));\n\n    h263_encode_init(&s->m); //mv_penalty\n\n\n\n    return 0;\n\n}", "idx": 10773, "substitutes": {"avctx": ["avcv", "avcmp", "ajcu", "avalctx", "avalcontext", "ajcp", "afcas", "afcfg", "auctx", "AVctrl", " avcmp", "AVcontext", "aucb", "avectl", "avcontext", "avepkg", "averctrl", "avcfg", "avecas", "avalctrl", "avctl", "afcontext", " avcu", "avcb", "avecv", "avecfg", "ajcfg", "ajcmp", "afpkg", "avcp", "avectx", "afcu", "avcmd", "ajctx", "ajcontext", "aucmp", "avercv", "ajpkg", " avcf", "auqa", "afqa", "avqa", "afcp", "svcu", "avallc", "avcas", "avercontext", "svctx", "afctx", "avercmp", "avercmd", "aucmd", "avcf", "avalqa", "avecmd", "avcu", "AVlc", "AVctx", "averlc", "avctrl", "avecp", "AVctl", "AVcu", "avalcb", "avecontext", "aucontext", "ajcas", "AVcf", "averctx", "svcontext", "avecmp", "afcmp", "avecu", "AVcmp", "afcf", "avlc", "svctl", "ajcf", "afcb", "avpkg", "avecf", "aucv"], "s": ["l", "session", "is", "its", "strings", "m", "t", "gs", "sum", "parts", "v", "ans", "ns", "hs", "details", "com", "spec", "self", "comm", "settings", "erences", "sg", "ds", "si", "n", "sites", "your", "w", "b", "i", "c", "e", "args", "lines", "us", "f", "sym", "sets", "es", "r", "storage", "as", "u", "ps", "fs", "su", "site", "ss", "uses", "ks", "g", "features", "ops", "d", "sa", "ls", "os", "cs", "o", "sync", "ats", "sys", "ions", "side", "a", "ssl", "vs", "conf", "ts", "rows", "changes", "service", "p", "qs", "ins", "xs", "js", "rs", "an", "aws", "S", "states", "services", "ms", "h", "ses", "uns", "y", "bs"]}}
{"project": "qemu", "commit_id": "d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801, "substitutes": {"ad": ["ld", "ady", "mad", "bb", "pad", "id", "http", "quad", "ads", "ud", "ab", "ang", "d", "post", "adh", "bd", "p", "add", "addr", "ace", "wd", "ada", "exec", "at", "ag", "ade", "ay", "rad", "jad", "ass", "ac", "an", "db", "dat", "al", "edd", "md", "att", "end", "dd", "AD", "art", "dc", "pc", "admin", "pod", "od", "client", "dev", "api", "a", "aud", "ap", "aed", "ed", "Ad"], "sglist": ["sgnIST", "sgnst", "sGLister", " sglIST", "sgnister", "sglIST", "sGLst", " sGLIST", "sgelister", " sGLst", " sGList", "sgelIST", " sglister", "sgelst", "sGList", "sgnist", "sgelist", "sGLIST", " sGLister", "sglst", " sglst", "sglister"], "offset": ["location", "timeout", "delay", "start", "si", "len", "prefix", "pad", "origin", "num", "data", "slot", "sum", "limit", "addr", "config", "ref", "p", "skip", "set", "number", "off", "loc", "f", "padding", "entry", "alpha", "o", "index", "size", "align", "r", "end", "address", "part", "position", "amount", "type", "pos", "attribute", "length", "Offset", "range", "reset"], "cmd": ["mac", "ht", "cmp", "def", "pad", "conn", "MD", "d", "c", "head", "config", "cp", "addr", "cd", "cb", "rad", "cod", "op", "dr", "code", "pkg", "ctrl", "ctl", "md", "ctx", "req", "mod", "Cmd", "cl", "dc", "node", "cat", "cfg", "comm", "command", "grad", "client", "od", "dad", "proc"], "prdt": ["Prt", "brtd", "frtd", "Prdt", "prDT", "PRdt", " prta", "Prta", "prds", "brds", "prot", "protd", "Prqt", " prt", " prqt", "prtd", "brdt", "prta", " prDT", "frqt", "PrDT", "PRqt", "PRtd", "frta", "prt", " prds", "Prtd", "prodt", "prqt", "brqt", " prtd", "proDT", "frdt", "PRds"], "i": ["oi", "l", "hi", "ui", "di", "it", "n", "len", "si", "m", "xi", "info", "k", "x", "ini", "z", "ami", "t", "b", "d", "c", "p", "ix", "uri", "e", "mu", "yi", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "phi", "ti", "ind", "r", "chi", "abi", "qi", "bi", "pi", "ii", "u", "I", "pos", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "ki"], "tbl_entry_size": ["tbl_row_len", "tbl_entry_pos", "tbl_row_pos", "tbl_entry_sum", "tbl_offset_size", "tbl_Entry_size", "tbl_Entry_len", "tbl_entry_count", "tbl_offset_len", "tbl_entry_len", "tbl_row_size", "tbl_Entry_sum", "tbl_offset_count"], "bus": [" buses", "boot", "pass", "base", "class", "board", "brid", "b", "bridge", "c", "block", "service", "config", "p", "used", "ux", "feed", "plug", "bug", "us", "BUS", "serial", "bc", "Bus", "route", "connection", "state", "proxy", "las", "pu", "port", "usb", "hub", "cat", "type", "pos", "dev", "io", "cache", "vc", "proc"], "qbus": ["qboot", "sqboot", "QBus", "dqbus", "dqboot", "Qdi", "qBus", "sqbus", "Qbus", "dqdi", "sqBus", "dqBus", "Qboot", "sqdi", "qdi"], "tbl": ["itill", "bill", "tpl", "tuple", " tcol", "fbl", "Tbl", "tBL", "fBL", "itcol", "fuple", " tBL", "itBL", "tcol", "ruple", "Tuple", "rpl", "till", "fpl", "bbl", "TBL", "bcol", " till", "itbl", "bBL", "Tpl", "rBL", "rbl"]}}
{"project": "FFmpeg", "commit_id": "9b6aafba6c06ef62783dd5e9c5ed668f3a095128", "target": 1, "func": "static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n\n                                                uint8_t *dest_y,\n\n                                                uint8_t *dest_cb,\n\n                                                uint8_t *dest_cr,\n\n                                                int field_based,\n\n                                                int bottom_field,\n\n                                                int field_select,\n\n                                                uint8_t **ref_picture,\n\n                                                h264_chroma_mc_func *pix_op,\n\n                                                int motion_x, int motion_y,\n\n                                                int h, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,\n\n        uvsx, uvsy;\n\n    const int lowres     = s->avctx->lowres;\n\n    const int op_index   = FFMIN(lowres, 2);\n\n    const int block_s    = 8>>lowres;\n\n    const int s_mask     = (2 << lowres) - 1;\n\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n\n    if (s->quarter_sample) {\n\n        motion_x /= 2;\n\n        motion_y /= 2;\n\n    }\n\n\n\n    if (field_based) {\n\n        motion_y += (bottom_field - field_select) * (1 << lowres - 1);\n\n    }\n\n\n\n    sx = motion_x & s_mask;\n\n    sy = motion_y & s_mask;\n\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n\n        uvsrc_x = src_x >> 1;\n\n        uvsrc_y = src_y >> 1;\n\n    } else if (s->out_format == FMT_H261) {\n\n        // even chroma mv's are full pel in H261\n\n        mx      = motion_x / 4;\n\n        my      = motion_y / 4;\n\n        uvsx    = (2 * mx) & s_mask;\n\n        uvsy    = (2 * my) & s_mask;\n\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n\n    } else {\n\n        mx      = motion_x / 2;\n\n        my      = motion_y / 2;\n\n        uvsx    = mx & s_mask;\n\n        uvsy    = my & s_mask;\n\n        uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n\n        uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if ((unsigned) src_x >  h_edge_pos - (!!sx) - 2 * block_s ||\n\n        (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) {\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n\n                                s->linesize, 17, 17 + field_based,\n\n                                src_x, src_y << field_based, h_edge_pos,\n\n                                v_edge_pos);\n\n        ptr_y = s->edge_emu_buffer;\n\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n\n            s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            ptr_cb = uvbuf;\n\n            ptr_cr = uvbuf + 16;\n\n        }\n\n    }\n\n\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data\n\n    if (bottom_field) {\n\n        dest_y  += s->linesize;\n\n        dest_cb += s->uvlinesize;\n\n        dest_cr += s->uvlinesize;\n\n    }\n\n\n\n    if (field_select) {\n\n        ptr_y   += s->linesize;\n\n        ptr_cb  += s->uvlinesize;\n\n        ptr_cr  += s->uvlinesize;\n\n    }\n\n\n\n    sx = (sx << 2) >> lowres;\n\n    sy = (sy << 2) >> lowres;\n\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n        uvsx = (uvsx << 2) >> lowres;\n\n        uvsy = (uvsy << 2) >> lowres;\n\n        pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n        pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n    }\n\n    // FIXME h261 lowres loop filter\n\n}\n", "idx": 10836, "substitutes": {"s": ["session", "is", "strings", "m", "t", "gs", "v", "bis", "ns", "spec", "self", "params", "settings", "sg", "ds", "si", "n", "sf", "b", "i", "opens", "c", "e", "se", "sq", "f", "sym", "sets", "es", "space", "storage", "sis", "u", "rates", "sim", "comments", "ps", "su", "site", "ess", "ss", "ks", "sv", "g", "source", "stats", "ops", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "sb", "sys", "ions", "secondary", "ssl", "conf", "sports", "ts", "service", "p", "qs", "xs", "js", "rs", "aws", "S", "services", "ms", "ses"], "dest_y": ["dest_vy", "Dest_x", "dest_py", "dest__y", "dest__vy", "dest__py", "dest_x", "Dest_y", "dest__x", "Dest_vy", "Dest_py"], "dest_cb": ["dest_bb", "Dest_rb", "Dest_bb", "dest_hub", "Dest_cb", "dest_rb", "Dest_hub"], "dest_cr": ["Dest_cr", "Dest_rb", "dest__cr", "dest__CR", "Dest_cb", "dest__cb", "dest_rb", "dest__rb", "dest_CR", "Dest_CR"], "field_based": ["fieldPtotal", "fieldPbased", " field_related", "fielderbased", " field_fixed", "field6count", " field_ed", "field_set", "field___based", "fieldacbased", "field6based", "field67like", "field_base", "field_received", "fieldPvalid", "field67base", "field___received", "field_valid", "fielderset", "field_bound", " field_total", " field_base", "fieldacfixed", "fieldPbound", "field6Based", "field6base", "fieldacreceived", "field_ed", " field_bound", " field_count", "field_related", " field_valid", " field_received", " field_Based", "field67ed", "field___fixed", "field_like", "fieldacbound", "field_count", "field67based", " field_like", "field_fixed", "field___bound", "fielderrelated", "field_total", "field_Based", " field_set"], "bottom_field": ["bottom24size", "bottom24field", "bottom4fields", "bottom4size", " bottom_FIELD", " bottom_slice", "bottom54fields", "bottom54FIELD", "bottom_sample", "bottom4sample", "bottom_slice", "bottom54slice", "bottom_FIELD", "bottom_fields", "bottom24sample", "bottom__FIELD", "last_size", "bottom4field", "last_field", "bottom__fields", "last_fields", "last_sample", "bottom54field", "bottom24fields", "bottom__field", "bottom__slice", "bottom_size", " bottom_fields"], "field_select": ["field___count", "field_sel", " field_selected", "fieldalelect", "field8elect", " field_patch", " field_sel", "field8select", " field_reverse", "field8patch", " field_elect", "field_count", " field_count", "field___selected", "field___sel", "fieldalreverse", "field_elect", "field___select", "field_patch", "field_reverse", "field_selected", "fieldalselect", "field8reverse", "fieldalpatch"], "ref_picture": ["reference_img", "ref_img", "reference_picture", "reference_profile", "ref_profile", "refsprofile", "refspicture", "ref_image", "refsimage", "referencesimage", "reference_image", "referencesprofile", "referencespicture", "referencesimg", "refsimg"], "pix_op": ["pixalloffset", "pixalloper", "png_offset", "png_oper", "pixallimage", "pix2image", "png_image", "png_op", "pix2offset", "pix_offset", "pix2op", "pix_image", "pix2oper", "pixallop", "pix_oper"], "motion_x": ["motion67ix", "motion_width", "error44ey", "camera67ya", "motion44x", "error_ys", " motion_no", "motion44ys", "motion_xs", "error_xs", "motionaly", "motion44xs", "camera_x", "camera_ix", "motion_no", " motion_width", "motion33y", "motion_ya", "motionalx", "motion_xy", "motion33x", "error_x", "motion___x", "motion_ix", "motion67ya", "motion44ey", "motion67name", "motionPya", " motion_name", "motion_ys", "motion67y", "camera_xy", "motion33xy", "motionPx", "motionPix", "camera67x", "motion67xy", "motion___ys", "motion33no", "motionalxy", " motion_xy", "motion___xs", "camera_ya", "motion_ey", "motion67x", "error44ys", "motion_name", "error_ey", "motionalwidth", "camera67ix", "motionPxy", "error44xs", "camera67xy", "motion___ey", "error44x"], "motion_y": ["moving_ny", "location_y", "motionLogY", "camera_yah", " motion_ya", " motion_vy", "motionJny", "motionLogy", "moving67y", "motionFilesy", "motionLogyd", "locationLogx", "motionFiley", "motion64ny", "motionJyt", "motionFilew", "motion_sy", "motion_Y", "moving67ny", "location_x", "moving_Y", "motion2ys", "motionLogw", "motionLogsy", "motion64vy", "motionJvy", "moving67Y", "motion67ady", "motion_ya", "cameraLogY", "motion_yt", "motionFilex", "moving_y", "motion64y", "motion2x", "camera_y", "motionJys", "motion_ys", "motion_ny", "motion_yah", " motion_yt", "moving67ady", "motion67y", "motion67ny", "motion2y", " motion_ny", " motion_dy", "motionLogyah", "motion67Y", "cameraLogy", "motion_dy", "locationLogy", "locationLogsy", "moving_ady", "motion_ady", "motion_vy", "camera_Y", "cameraLogyah", "camera_yd", "motion_yd", "motion64ys", "location_w", " motion_ys", "motionJy", "motion_w", "motionJx", "motion2dy", "cameraLogyd", "motionJya", "locationLogw", "location_sy", "motionLogx"], "h": ["l", "n", "g", "ph", "w", "m", "b", "x", "k", "z", "d", "i", "c", "p", "e", "q", "f", "o", "v", "bh", "r", "hs", "u", "H", "image", "y", "ch"], "mb_y": ["mbjsize", "machine_yl", "mb_yl", "mbjcy", "mp_x", "mb_cy", "mb_x", "machine_y", "machine_ery", "machine_vy", "mb_ery", "mp_size", "mbjx", "mp_cy", "mb_vy", "mb_size", "mp_y", "mbjy"], "ptr_y": ["ptr_yd", "ptr__vy", "ptr__ya", "ptr_ya", "ptr__yd", "src_vy", "src_ya", "ptr_vy", "src_yd", "ptr__y"], "ptr_cb": ["dest_hub", "ptr__b", "ptr_b", "ptr__cb", "ptr_rb", "dest_rb", "ptr_hub", "dest_b", "ptr__hub", "ptr__rb"], "ptr_cr": ["src_cr", "src_cb", "src_rb", "src_sr", "ptr_rb", "ptr_sr"], "mx": ["area", "base", "mn", "xp", "mr", " m", "mm", "mem", "cp", "max", "vis", "loc", "sq", "large", "mode", "host", "shape", "mc", "wave", "mi", "tx", "ns", "hop", "wx", " mc", "ms", "nz", "rx", "mag"], "my": ["mis", "mn", "asy", "ny", "ey", "mon", "by", "sam", "fy", "pm", "yy", "gy", "mid", "sym", "py", "sky", "ky", "mi", "MY", "ery", "sup", "md", "custom", "ms", "ram", "mys", "My"], "src_x": ["loc_w", "loc_y", "src_xy", "loc_xy", "source_y", "src_w", "loc_x", "src_X", "src_z", "source_id", "source_w", "source_x", "source_X", "src_id", "source_z"], "src_y": ["src2ys", "src_dy", "src2y", "src__x", " src_z", "src_ya", "src2x", " src_dy", "src_ys", "src__y", " src_ys", "src__dy", "src_z", "src2dy", "src__ys", " src_ya"], "uvsrc_x": ["uvsrcsy", "uvsrc_z", "uvsrc_xx", "uvsrcsxx", "uvsrc_w", "uvsrcsx", "uvsrc2y", "uvsrcsz", "uvsrc2z", "uvsrc2xx", "uvsrc2x"], "uvsrc_y": ["uvsource_i", "uvsrc_ya", "uvsource_ya", "uvsource_y", "uvsource_x", "uvsrc_i"], "uvlinesize": ["ujlesizes", "vlinesizer", "ujlesrate", "ujlesize", "ujlinesizes", "uvinesizer", "uvlsizes", "uvlinization", "ujlesization", "uvlsize", "uvinesizes", "uvcodesizes", "uvlinesrate", "uvlinesiz", "uvlinesizes", "uvlinrate", "vlinesizes", "ujlinesrate", "uvcodesization", "uvlesization", "uvlesize", "uvcodesrate", "uvlinize", "uvlesrate", "ujlinesize", "vlinesize", "uvlinizes", "uvlinesizer", "uvinesiz", "uvlesizes", "uvlsiz", "uvcodesize", "ujlinesization", "uvlinesization", "uvinesize", "uvlsizer", "vlinesiz"], "linesize": ["stringsizing", "linssize", "linesization", "linsiz", "codessize", "ballsization", "linesiz", "relationsize", "codesizes", " linesizes", "onesize", "ballssize", "ballsize", "linesizes", "relationsization", "onesizer", "linesizing", "linsize", "onesization", "facessize", "inesizer", "codesization", "stringsize", "linsization", "ballsizer", "facesization", "facesize", " linesizer", "codesize", "linessize", " linesizing", "onessize", "linesizer", "stringsiz", "relationssize", "inesiz", " linesization", " linessize", "inesizing", "facesizes", "relationsiz", " linesiz", "inesize", "stringsizer"], "sx": [" sxc", "Sx", "Sxx", " sxx", "nsx", "nsX", "ssX", "sxc", "nsy", " sX", "ssx", "ssy", "py", "Sxc", "sxx", "sX", "pxx", "pX", "ssxx", "px", "Sy", "SX", "nsxc"], "sy": ["ym", "ady", "ony", "area", "si", "ry", "asy", "ny", "phy", "ey", "sa", "ship", "ys", "fy", "dist", "ay", "loc", "sq", "zy", "ie", "yy", "sym", "gy", "sub", "size", "py", "syn", "sky", "sync", "ky", "south", "hy", "ty", "SY", "dy", "sys", "idy", "sid", "y", "wy", "cy", "ly"], "uvsx": ["ucsh", "ubsx", "UcsX", "uvesxx", "uvesx", " uvsxx", "UvsX", "ubsy", "Uvsy", "uvsX", "uVSy", "ucsx", "uVSx", "uversx", " ubsx", "ucsy", "ubsxx", "uVSX", " ubsxx", "ubsh", "uversy", "uvsxx", " ubsh", "uvsh", " uvsh", "Ucsy", "ucsX", "uvesh", "ucsxx", "Uvsx", "Ucsx", " ubsy", "uvesy", "uversX"], "uvsy": ["usbsync", "usbny", "cvsy", "uzny", "nvdy", "uvsync", "uvfy", "vpfy", "nvdist", "cvdy", "nvsy", "usbpy", "uvny", "vpsy", "cvny", "usbsy", "vpdy", "uzpy", "nvfy", "vpdist", "uvdist", "cvsync", "uzsync", "cvfy", "uzsy", "uvpy", "cvdist", "cvpy", "uvdy"]}}
{"project": "FFmpeg", "commit_id": "1178868683d25c0f358b0364eb55f69b563b24f3", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf      = avpkt->data;\n\n    unsigned int   buf_size = avpkt->size;\n\n    const uint8_t *buf_end  = buf + buf_size;\n\n\n\n    const AVPixFmtDescriptor *desc;\n\n    EXRContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr;\n\n\n\n    int i, x, y, stride, magic_number, version, flags, ret;\n\n    int w = 0;\n\n    int h = 0;\n\n    unsigned int xmin   = ~0;\n\n    unsigned int xmax   = ~0;\n\n    unsigned int ymin   = ~0;\n\n    unsigned int ymax   = ~0;\n\n    unsigned int xdelta = ~0;\n\n\n\n    int out_line_size;\n\n    int bxmin, axmax;\n\n    int scan_lines_per_block;\n\n    unsigned long scan_line_size;\n\n    unsigned long uncompressed_size;\n\n\n\n    unsigned int current_channel_offset = 0;\n\n\n\n    s->channel_offsets[0] = -1;\n\n    s->channel_offsets[1] = -1;\n\n    s->channel_offsets[2] = -1;\n\n    s->channel_offsets[3] = -1;\n\n    s->bits_per_color_id = -1;\n\n    s->compr = -1;\n\n\n\n    if (buf_size < 10) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_number = bytestream_get_le32(&buf);\n\n    if (magic_number != 20000630) { // As per documentation of OpenEXR it's supposed to be int 20000630 little-endian\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    version = bytestream_get_byte(&buf);\n\n    if (version != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version %d\\n\", version);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    flags = bytestream_get_le24(&buf);\n\n    if (flags & 0x2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    // Parse the header\n\n    while (buf < buf_end && buf[0]) {\n\n        unsigned int variable_buffer_data_size;\n\n        // Process the channel list\n\n        if (check_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) >= 0) {\n\n            const uint8_t *channel_list_end;\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            channel_list_end = buf + variable_buffer_data_size;\n\n            while (channel_list_end - buf >= 19) {\n\n                int current_bits_per_color_id = -1;\n\n                int channel_index = -1;\n\n\n\n                if (!strcmp(buf, \"R\"))\n\n                    channel_index = 0;\n\n                else if (!strcmp(buf, \"G\"))\n\n                    channel_index = 1;\n\n                else if (!strcmp(buf, \"B\"))\n\n                    channel_index = 2;\n\n                else if (!strcmp(buf, \"A\"))\n\n                    channel_index = 3;\n\n                else\n\n                    av_log(avctx, AV_LOG_WARNING, \"Unsupported channel %.256s\\n\", buf);\n\n\n\n                while (bytestream_get_byte(&buf) && buf < channel_list_end)\n\n                    continue; /* skip */\n\n\n\n                if (channel_list_end - * &buf < 4) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                current_bits_per_color_id = bytestream_get_le32(&buf);\n\n                if (current_bits_per_color_id > 2) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (channel_index >= 0) {\n\n                    if (s->bits_per_color_id != -1 && s->bits_per_color_id != current_bits_per_color_id) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    s->bits_per_color_id  = current_bits_per_color_id;\n\n                    s->channel_offsets[channel_index] = current_channel_offset;\n\n                }\n\n\n\n                current_channel_offset += 1 << current_bits_per_color_id;\n\n                buf += 12;\n\n            }\n\n\n\n            /* Check if all channels are set with an offset or if the channels\n\n             * are causing an overflow  */\n\n\n\n            if (FFMIN3(s->channel_offsets[0],\n\n                       s->channel_offsets[1],\n\n                       s->channel_offsets[2]) < 0) {\n\n                if (s->channel_offsets[0] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing red channel\\n\");\n\n                if (s->channel_offsets[1] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing green channel\\n\");\n\n                if (s->channel_offsets[2] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing blue channel\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            buf = channel_list_end;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            xmin = AV_RL32(buf);\n\n            ymin = AV_RL32(buf + 4);\n\n            xmax = AV_RL32(buf + 8);\n\n            ymax = AV_RL32(buf + 12);\n\n            xdelta = (xmax-xmin) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            w = AV_RL32(buf + 8) + 1;\n\n            h = AV_RL32(buf + 12) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (*buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"pixelAspectRatio\", \"float\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255);\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (s->compr == -1)\n\n                s->compr = *buf;\n\n            else\n\n                av_log(avctx, AV_LOG_WARNING, \"Found more than one compression attribute\\n\");\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        }\n\n\n\n        // Check if there is enough bytes for a header\n\n        if (buf_end - buf <= 9) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        // Process unknown variables\n\n        for (i = 0; i < 2; i++) {\n\n            // Skip variable name/type\n\n            while (++buf < buf_end)\n\n                if (buf[0] == 0x0)\n\n                    break;\n\n        }\n\n        buf++;\n\n        // Skip variable length\n\n        if (buf_end - buf >= 5) {\n\n            variable_buffer_data_size = get_header_variable_length(&buf, buf_end);\n\n            if (!variable_buffer_data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            buf += variable_buffer_data_size;\n\n        }\n\n    }\n\n\n\n    if (s->compr == -1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing compression attribute\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (buf >= buf_end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    buf++;\n\n\n\n    switch (s->bits_per_color_id) {\n\n    case 2: // 32-bit\n\n    case 1: // 16-bit\n\n        if (s->channel_offsets[3] >= 0)\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB48;\n\n        break;\n\n    // 8-bit\n\n    case 0:\n\n        av_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);\n\n        return AVERROR_PATCHWELCOME;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (s->compr) {\n\n    case EXR_RAW:\n\n    case EXR_RLE:\n\n    case EXR_ZIP1:\n\n        scan_lines_per_block = 1;\n\n        break;\n\n    case EXR_ZIP16:\n\n        scan_lines_per_block = 16;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Compression type %d is not supported\\n\", s->compr);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        ff_thread_release_buffer(avctx, &s->picture);\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // Verify the xmin, xmax, ymin, ymax and xdelta before setting the actual image size\n\n    if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (w != avctx->width || h != avctx->height) {\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    }\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    bxmin = xmin * 2 * desc->nb_components;\n\n    axmax = (avctx->width - (xmax + 1)) * 2 * desc->nb_components;\n\n    out_line_size = avctx->width * 2 * desc->nb_components;\n\n    scan_line_size = xdelta * current_channel_offset;\n\n    uncompressed_size = scan_line_size * scan_lines_per_block;\n\n\n\n    if (s->compr != EXR_RAW) {\n\n        av_fast_padded_malloc(&s->uncompressed_data, &s->uncompressed_size, uncompressed_size);\n\n        av_fast_padded_malloc(&s->tmp, &s->tmp_size, uncompressed_size);\n\n        if (!s->uncompressed_data || !s->tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if ((ret = ff_thread_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    // Zero out the start if ymin is not 0\n\n    for (y = 0; y < ymin; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    // Process the actual scan line blocks\n\n    for (y = ymin; y <= ymax; y += scan_lines_per_block) {\n\n        uint16_t *ptr_x = (uint16_t *)ptr;\n\n        if (buf_end - buf > 8) {\n\n            /* Read the lineoffset from the line offset table and add 8 bytes\n\n               to skip the coordinates and data size fields */\n\n            const uint64_t line_offset = bytestream_get_le64(&buf) + 8;\n\n            int32_t data_size;\n\n\n\n            // Check if the buffer has the required bytes needed from the offset\n\n            if ((line_offset > buf_size) ||\n\n                (s->compr == EXR_RAW && line_offset > avpkt->size - xdelta * current_channel_offset) ||\n\n                (s->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32(avpkt->data + line_offset - 4)))) {\n\n                // Line offset is probably wrong and not inside the buffer\n\n                av_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    ptr_x = (uint16_t *)ptr;\n\n                    memset(ptr_x, 0, out_line_size);\n\n                }\n\n            } else {\n\n                const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0;\n\n\n\n                if (scan_lines_per_block > 1)\n\n                    uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1);\n\n                if ((s->compr == EXR_ZIP1 || s->compr == EXR_ZIP16) && data_size < uncompressed_size) {\n\n                    unsigned long dest_len = uncompressed_size;\n\n\n\n                    if (uncompress(s->tmp, &dest_len, avpkt->data + line_offset, data_size) != Z_OK ||\n\n                        dest_len != uncompressed_size) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during zlib decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                } else if (s->compr == EXR_RLE && data_size < uncompressed_size) {\n\n                    if (rle_uncompress(avpkt->data + line_offset, data_size, s->tmp, uncompressed_size)) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during rle decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                }\n\n\n\n                if (s->compr != EXR_RAW && data_size < uncompressed_size) {\n\n                    predictor(s->tmp, uncompressed_size);\n\n                    reorder_pixels(s->tmp, s->uncompressed_data, uncompressed_size);\n\n\n\n                    red_channel_buffer   = s->uncompressed_data + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = s->uncompressed_data + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[3];\n\n                } else {\n\n                    red_channel_buffer   = avpkt->data + line_offset + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = avpkt->data + line_offset + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[3];\n\n                }\n\n\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    const uint8_t *r, *g, *b, *a;\n\n\n\n                    r = red_channel_buffer;\n\n                    g = green_channel_buffer;\n\n                    b = blue_channel_buffer;\n\n                    if (alpha_channel_buffer)\n\n                        a = alpha_channel_buffer;\n\n\n\n                    ptr_x = (uint16_t *)ptr;\n\n\n\n                    // Zero out the start if xmin is not 0\n\n                    memset(ptr_x, 0, bxmin);\n\n                    ptr_x += xmin * desc->nb_components;\n\n                    if (s->bits_per_color_id == 2) {\n\n                        // 32-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n\n                        }\n\n                    } else {\n\n                        // 16-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n\n                        }\n\n                    }\n\n\n\n                    // Zero out the end if xmax+1 is not w\n\n                    memset(ptr_x, 0, axmax);\n\n\n\n                    red_channel_buffer   += scan_line_size;\n\n                    green_channel_buffer += scan_line_size;\n\n                    blue_channel_buffer  += scan_line_size;\n\n                    if (alpha_channel_buffer)\n\n                        alpha_channel_buffer += scan_line_size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    // Zero out the end if ymax+1 is not h\n\n    for (y = ymax + 1; y < avctx->height; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 10842, "substitutes": {"avctx": [" avxc", "afconn", "avnas", "afctx", "avcmp", "avalctx", "aphctl", "avalcontext", "navctx", "avcv", "avalnas", "aphctx", "afpkg", "avecmp", "afcmp", "avectx", "afctl", "avci", "AVcmp", "AVcv", "avexc", "avenas", "avalpkg", " avctl", "AVcontext", "apxc", "avconn", "avalcv", "afxc", "afsrc", "AVctx", "apctx", "afci", " avcontext", "AVconn", "navsrc", "avalconn", "avcontext", "avxc", "avepkg", "Avctx", "Avcmp", "avpkg", "navcmp", "navcontext", "AVci", "aphxc", "aphcontext", "AVsrc", "avecontext", "avctl", "afcontext", "Avcontext", "afcv", "Avci", "afnas", "apcmp", "avsrc", "apcontext"], "data": ["parent", "sample", "channel", "base", "start", "media", "window", "record", "da", "pad", "open", "d", "doc", "block", "c", "config", "reader", "meta", "stream", "package", "queue", "memory", "frame", "body", "DATA", "next", "padding", "mode", "f", "dat", "device", "o", "size", "input", "connection", "content", "align", "address", "Data", "read", "bytes", "command", "pos", "message", "video", "image", "result", "length", "cache", "text", "buffer", "database"], "got_frame": ["buf_scale", "buf_frame", "bufipscale", "orig_scale", "buflogtrace", "buflogframe", "buflogposition", "bufipframe", "orig_position", "bufiptrace", "bufipposition", "buflogscale", "buf_trace", "orig_frame", "buf_position", "orig_trace"], "avpkt": ["avcpKT", "afpacket", "avpsth", "avfka", "abpkt", "abpka", "avpacket", "avfacket", "abfacket", "avcpacket", " avcpnt", "abfki", "avbpki", " avcpkt", "avcnt", "avfkt", "afcpkt", "avpft", "avcpsth", "abpki", "afcpct", "avppft", "avppKT", "abfka", "avbpacket", " avcpsth", "avppnt", "avfct", " avcpKT", "avpnt", " avpnt", "avcsth", "avcpkt", "afpft", "avpct", "avppsth", "avpki", "afcpft", "abpacket", "avfki", "avppacket", "avppki", "afpkt", "avcpct", "abfkt", "afpct", "avpKT", " avpsth", "avcpft", "afcpacket", "avbpka", "avppct", " avpKT", "avbpkt", "avcpnt", "avppka", "avcKT", "avpka", "avckt", "avfft", "avppkt"], "buf": ["bag", "uf", "map", "seq", "img", "context", "len", "ff", "window", "pad", "src", "fd", "brace", "ab", "num", "wb", "pool", "block", "fb", "config", "cp", "batch", "comb", "cb", "fp", "queue", "cf", "gb", "rb", "bc", "pub", "alloc", "cv", "aux", "cap", "Buff", "rc", "exc", "home", "cas", "cur", "ctx", "port", "usb", "bus", "loop", "header", "cache", "vec", "buff", "cmd", "br", "text", "buffer", "box", "uc", "runner"], "buf_end": ["buf2end", "buf__ended", "buf_ended", "buf2ended", "queue_start", "buf__len", "queue_ended", "buf__start", "buf_len", "queue_end", "queue_len", "buf_start", "buf2len", "buf2start", "buf__end"], "desc": ["asc", "des", "ext", "def", " description", "path", "rec", "doc", "meta", " def", "sec", "dir", "sub", "description", "name", "Desc", " d", "dc", "summary", "enc", "esc", "text", "proc", "feat", "acc", "sc"], "s": ["l", "conf", "session", "sg", "ts", "ds", "si", "is", "n", "its", "stats", "m", "http", "t", "ops", "d", "gs", "sa", "c", "service", "server", "ls", "e", "parts", "rs", "sq", "sec", "f", "os", "an", "js", "cs", "sym", "o", "sets", "S", "es", "v", "sync", "sl", "services", "ns", "sb", "details", "spec", "ms", "as", "sys", "h", "client", "ps", "fs", "su", "ses", "ss", "settings", "ssl"], "picture": ["library", "base", "img", "detail", "media", "info", "piece", "filename", "photos", "fi", "feat", "slot", "config", "meta", "package", "frame", "share", "profile", "conference", "guide", "description", "Picture", "photo", "feature", "ctx", "pic", "details", "icon", "summary", "fine", "plugin", "file", "video", "image", "pict", "definition", "family"], "p": ["l", "pg", "n", "m", "t", "d", "c", "pb", "pd", "e", "fp", "P", "f", "op", "mp", "py", "v", "tp", "jp", "pi", "pc", "ps", "ap", "vp"], "ptr": ["sh", "img", "src", "pl", "fd", "pointer", "fi", "obj", "pb", "fp", "attr", "np", "pt", "prop", "tmp", "dr", "inst", "alloc", "ctr", "jpg", "pic", "pos", "vec", "br", "proc", "buffer"], "i": ["it", "start", "n", "id", "xi", "m", "info", "t", "z", "d", "c", "e", "f", "j", "index", "v", "pi", "bi", "ii", "u", "I", "ip", "ci", "io"], "x": ["xx", "w", "m", "id", "t", "z", "d", "pointer", "c", "X", "pixel", "xs", "f", "index", "shape", "fx", "tx", "h", "xy", "rx", "image", "dx", "ex"], "y": ["l", "ym", "sp", "n", "w", "m", "id", "t", "z", "vy", "d", "c", "e", "f", "yy", "j", "height", "o", "py", "Y", "type", "h", "xy", "cy"], "stride": ["strope", "strite", "frope", "fride", "brider", "strider", "bride", "shrider", "frite", "brite", "shrope", "frider", "shrite", "brope", "shride"], "magic_number": [" magic_text", "magic_note", "magic_value", "magic_notation", " magic_value", " magic_note", "magic_total", " magic_digit", "magic_digit", "magicureno", "magic_no", " magic_no", "magicuretotal", " magic_total", " magic_notation", "magicurenumber", "magic_text", " magic_counter", "magicurenotation", "magic_counter"], "version": ["parent", "diff", "Version", "major", "channel", "level", "vert", "scale", "vision", "section", "product", "date", "stage", "tag", "update", "num", "latest", "ver", "vers", "python", "generation", "package", "target", "versions", "secret", "value", "driver", "number", "bug", "brand", "mode", "size", "software", "release", "description", "format", "name", "v", "feature", "option", "patch", "position", "VERSION", "type", "platform", "flower", "until", "build", "length", "beta", "depth", "pin", "direction"], "flags": ["vals", "styles", "utils", "flag", "frames", "len", "members", "features", "dates", "stats", "mods", "alls", "actions", "fields", "files", "ages", "ils", "filename", "ports", "lists", "mask", "ants", "parts", "status", "reports", "versions", "quality", "bits", "args", "planes", "types", "plugins", "FLAG", "Flags", "rules", "ints", "format", "missions", "properties", "magic", "fps", "states", "caps", "ags", " bits", "locks", "hours", "groups", "details", "bytes", "options", "feat", "settings", "atts"], "ret": ["seq", "flag", "ext", "alt", "val", "len", "def", "info", "mem", "reply", "status", "rets", "res", "rc", "fun", "quiet", "orig", "RET", "back", "complete", "result", "rev", "resp", "success"], "out_line_size": ["out_lines_speed", "out_line_speed", "out_lines_size", "out_lines_sum", "out_lines_count", "out_line_count", "out_line_sum"], "bxmin": ["bxpos", "bxxstart", " bxstart", "bxxmax", "btxmax", "bxstart", "bxxpos", "btxmin", "btxstart", " bxmax", "bxmax", "btxpos", "bxxmin", " bxpos"], "axmax": ["xmax", "exrange", "exmax", "oxrange", "oxmax", "xrange", "xmin", "oxmin", "axrange", "exmin", "axmin"], "scan_lines_per_block": ["scan_lines_per_byte", "scan_lines_per_row", "scan_lines_per_channel"], "scan_line_size": ["scan_line_scale", "scan_lines_scale", "scan_lines_count", "scan_line_sum", "scan_lines_size", "scan_lines_sum", "scan_line_count"], "uncompressed_size": ["uncomplied_ize", "uncompressedlensize", "uncomplied_num", "uncompressedlicize", "uncompressedlicspeed", "uncompressedlicnum", "uncompressed_num", "uncompressedlenspeed", "uncompressedlenize", "uncompressedlicsize", "uncompressedlennum", "uncompressed_speed", "uncompressed_ize", "uncomplied_size", "uncomplied_speed"]}}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n", "idx": 10847, "substitutes": {"s": ["l", "conf", "session", "sg", "ts", "ds", "is", "n", "si", "g", "features", "stats", "m", "http", "t", "b", "send", "d", "i", "gs", "service", "c", "ops", "server", "p", "ls", "e", "status", "request", "args", "rs", "js", "sq", "os", "f", "an", "plugins", "cs", "sym", "o", "sets", "S", "es", "sync", "states", "services", "r", "ns", "sb", "sys", "ps", "ses", "fs", "core", "ss", "settings", "ssl"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 10849, "substitutes": {"src": ["img", "start", "source", "sel", "http", "sur", "rest", "rect", "buf", "config", "stack", "dest", "cb", "gb", "gl", "dist", "rb", "loc", "sq", "rs", "st", "inst", "sub", "slice", "sync", "rc", "input", "sl", "cur", "req", "sup", "sth", "sb", "url", "comp", "rob", "ssl", "sc"], "dst": [" ddest", "dsrc", "dbl", "Ddest", "psts", "dost", "dssts", "pdest", "lsts", "drc", "post", "Dsts", "pst", "lrc", " dsts", "ddest", "Dst", "dsbl", "sbl", "dsts", "lst", "lbl", "Dost", "ssts", "sst", " dost", "dsst"], "src_size": ["srcblocksize", "src_range", "source_scale", "source_range", "src_scale", "srcblockscale", "src_address", "source_size", " src_scale", "srcblockrange", " src_shape", " src_address", "src_shape"], "i": ["oi", "l", "ani", "ui", "di", "it", "is", "si", "n", "zi", "adi", "m", "xi", "info", "ami", "k", "ini", "d", "c", "ji", "p", "ix", "uri", "e", "mu", "mini", "eni", "f", "ie", "j", "ai", "multi", "index", "v", "gi", "mi", "phi", "ti", "abi", "qi", "bi", "pi", "ii", "init", "u", "I", "li", "ip", "ci", "ori", "ni", "io", "ri", "iu"], "b": ["l", "ib", "base", "bb", "n", "abb", "w", "m", "x", "k", "ab", "wb", "t", "d", "c", "s", "p", "e", "gb", "B", "rb", "f", "db", "bf", "o", "bg", "v", "bi", "sb", "u", "a", "y", "br"], "g": ["l", "gn", "sg", "pg", "n", "w", "m", "k", "x", "gm", "gr", "d", "mg", "big", "c", "s", "p", "e", "gb", "gp", "gh", "q", "group", "f", "G", "o", "bg", "v", "gi", "gg", "ga", "u", "h", "rg", "vg", "ge", "a", "y"], "r": ["l", "n", "w", "m", "rr", "k", "t", "x", "gr", "d", "ra", "c", "s", "p", "e", "wr", "rb", "rs", "q", "er", "f", "j", "G", "o", "v", "R", "rc", "sl", "ar", "pr", "nr", "u", "ro", "re", "h", "rg", "a", "sr", "br", "rl", "range"], "rgb": [" rba", "cbb", "cgg", "cgray", "brbb", "urbo", "drbg", "rgbb", "lgb", "rggg", "rbgg", "brgg", "rgray", "rbbo", "rgg", " rgray", "lbg", "cgb", "Rbg", "lgg", "Rgb", "rba", "arg", "urgb", "rggb", "argg", "brbo", "Rgg", " rg", "rbg", "rgbg", "lbb", "argd", " rbg", "rbba", "urgg", "Rba", "rbbb", "argb", "brgb", "drgg", "rbbg", "rbo", "rbgb", "rbb", "rg", " rbb", " rgd", "rgd", "rbgd", "urbb", "lgray", "drgb", "drbb", " rgg"]}}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n", "idx": 10857, "substitutes": {"netdev": ["networkpad", "netdevice", "matdev", "netdef", " netconf", "netdriver", " netpad", "natpad", " netdef", "netdiv", "etdev", "networkdef", "networkdiv", "etdevice", "etdef", "natdevice", "netpad", " netdevice", "netconn", "etdriver", "networkconf", "matdriver", " netdriver", "netconf", "etconn", "natconf", "matdevice", "etdiv", " netdiv", "networkdevice", " netconn", "natdev", "matconn", "networkdev"], "name": ["parent", "alias", "sea", "NAME", "base", "up", "n", "prefix", "key", "word", "info", "id", "path", "x", "filename", "nam", "data", "addr", "username", "names", "network", "host", "label", "size", "version", "cap", "connection", "space", "am", "user", "address", "old", "part", "type", "ame", "ip", "client", "image", "ni", "anc", "Name", "hello", "family"], "peer": ["parent", "cot", "channel", "worker", "owner", "conn", "instance", "pool", "block", "addr", "server", "pro", "attr", "request", "pe", "ptr", "socket", "er", "next", "slave", "host", "device", "scope", "connection", "remote", "cert", "cur", "actor", "req", "address", "inner", "node", "enc", "client", "ip", "seed", "proc", "buffer", "ssl", "chain"], "errp": ["iterfp", "erp", "dersp", "rrr", "rrpc", "derp", "derr", " errsp", "rrc", "iterr", "errps", "errper", "erc", " errpc", "erper", " errc", " errper", "rrper", "errsp", "rrp", "errpc", "err", "erpc", " errfp", "erfp", "erps", "errc", "iterps", "derpc", "iterp", " errps", "ersp", " errr", "errr", "errfp"], "queues": ["Queue", "queries", "Queends", "quesges", "quums", "queends", "queueries", "quges", "qations", "queueues", " queances", "clends", "Queances", "Queures", "quesences", "que", "quients", "queences", "qasks", "fluences", "quue", "clasks", "quesations", "clues", "requues", "Queients", "queueums", "queue", "quures", "quues", "Queries", "qends", "fluues", "qacks", "queueacks", "queacks", "queums", "requures", "quries", "queances", "clries", " queures", "queueue", "queasks", "quences", "quesues", "quesures", "fluges", "quesacks", " queue", "fluures", "Queasks", "ques", "qries", "queations", "queges", "queueances", "Queums", "requients", "queueations", "queueures", "queients", "queures", "Queues", "quesue", "requums"], "vhost_user_opts": ["vhost_user_OPcs", "vhost_user_operts", "vhost_user_preps", "vhost_user_opente", "vhost_user_openps", "vhost_user_opens", "vhost_user_opents", "vhost_user_proters", "vhost_user_kt", "vhost_user_opps", "vhost_user_operps", "vhost_user_prote", "vhost_user_props", "vhost_user_kts", "vhost_user_proter", "vhost_user_optts", "vhost_user_opcs", "vhost_user_verts", "vhost_user_OPters", "vhost_user_prets", "vhost_user_ops", "vhost_user_OPt", "vhost_user_kter", "vhost_user_prots", "vhost_user_procs", "vhost_user_optt", "vhost_user_adps", "vhost_user_opters", "vhost_user_opms", "vhost_user_operms", "vhost_user_optps", "vhost_user_opt", "vhost_user_verps", "vhost_user_optcs", "vhost_user_OPms", "vhost_user_kters", "vhost_user_prot", "vhost_user_OPter", "vhost_user_vert", "vhost_user_OPts", "vhost_user_OPps", "vhost_user_adms", "vhost_user_opter", "vhost_user_pros", "vhost_user_pret", "vhost_user_opert", "vhost_user_prety", "vhost_user_OPty", "vhost_user_optte", "vhost_user_adts", "vhost_user_adt", "vhost_user_opty", "vhost_user_opte", "vhost_user_verty"], "chr": [" chro", "chri", "ichrg", " chrg", "CHr", "cherrg", "cherrc", "shrg", "qr", "schri", "schsr", "ichrs", "schro", " chsr", "chro", "ichsr", "echrg", "Chrc", "chrs", "qsr", "chsr", "Chrs", "qri", "chcr", "Chr", " chcr", " chrc", "Chsr", "echr", "qro", "chrg", "echrs", "CHrc", "shrb", "shrc", "Chrb", " chri", "Chcr", "schr", "shr", "CHcr", "CHrg", "chrc", "echsr", "Chrg", "ichr", "cherrb", "cherr", "chrb"]}}
{"project": "FFmpeg", "commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "target": 1, "func": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10868, "substitutes": {"gb": ["GB", "ui", "gd", "boot", "bb", "nb", "g", "gio", "abb", "gpu", "bm", "game", "b", "gm", "gs", "gin", "cb", "gp", "gui", "rb", "bc", "gnu", "gy", "db", "bf", "eb", "slice", "py", "ig", "gi", "gg", "ctx", "abi", "ga", "vd", "usb", "storage", "sb", "pc", "hub", "gc", "cfg", "xy", "vg", "rg", "ge", "bin", "gam", "kb"], "value": ["parent", "member", "reference", "Value", "valid", "sv", "scale", "comment", "key", "view", "model", "ve", "iv", "store", "service", "data", "time", "server", "component", "memory", "number", "code", "unit", "db", "values", "child", "version", "size", "index", "v", "format", "description", "name", "response", "query", "process", "feature", "end", "object", "function", "variable", "get", "type", "volume", "message", "video", "image", "result", "write", "weight", "buffer", "VALUE", "range"], "series": ["vals", "eries", "channel", "stores", "scale", "frames", "si", "IES", "axis", "source", "ds", "store", "service", "data", "config", "parts", "sector", " Series", "frame", "serial", "pins", "sequence", "array", "slice", "ints", "Series", "groups", "details", "bytes", "seconds", "options", "params", "seed", "proc", "events", "chain"], "i": ["oi", "l", "ui", "di", "it", "is", "n", "si", "in", "id", "xi", "info", "b", "x", "ini", "k", "z", "p", "ix", "uri", "e", "f", "ie", "j", "ai", "o", "multi", "index", "v", "jit", "ind", "ti", "gi", "qi", "pi", "bi", "part", "ii", "bit", "col", "u", "I", "li", "pos", "ip", "ci", "ori", "io", "bin", "ni", "ri", "fi"], "val": ["count", "l", "vals", "Val", " v", "seq", "base", "valid", "pass", "dim", "cond", "len", " eval", "sel", "bal", "b", "x", "update", "block", "VAL", "data", "sum", "p", "el", "ref", "rel", "pt", " slot", "f", "la", "bc", "unit", "vol", "bl", "eval", "al", "v", "sl", "abi", " bit", "pre", "part", " ret", "bit", "col", "pos", "ret", "bin", "vec", "fe"], "bits": ["count", "vals", "boot", "words", "base", "its", "frames", "rows", "ids", "features", "dates", "cuts", "alls", "changes", "b", "files", "ops", "places", "works", "ports", "s", "reads", " bugs", "jobs", "pieces", "parts", "cats", "ins", "steps", "runs", "bands", "planes", "bug", "versions", "pins", "lines", "cs", "limits", "items", "ints", "flags", "bugs", "ubs", "fps", "bis", "cycles", "ats", "hours", "details", "blocks", "part", "codes", "bytes", "ns", "bit", "gets", "rots", "pos", "points", "ips", "ps", "bin", "forces", "bs", "units", "settings", "lins"]}}
{"project": "FFmpeg", "commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "target": 1, "func": "static void check_add_res(HEVCDSPContext h, int bit_depth)\n\n{\n\n    int i;\n\n    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);\n\n    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);\n\n\n\n    for (i = 2; i <= 5; i++) {\n\n        int block_size = 1 << i;\n\n        int size = block_size * block_size;\n\n        ptrdiff_t stride = block_size << (bit_depth > 8);\n\n        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);\n\n\n\n        randomize_buffers(res0, size);\n\n        randomize_buffers2(dst0, size);\n\n        memcpy(res1, res0, sizeof(*res0) * size);\n\n        memcpy(dst1, dst0, size);\n\n\n\n        if (check_func(h.add_residual[i - 2], \"add_res_%dx%d_%d\", block_size, block_size, bit_depth)) {\n\n            call_ref(dst0, res0, stride);\n\n            call_new(dst1, res1, stride);\n\n            if (memcmp(dst0, dst1, size))\n\n                fail();\n\n            bench_new(dst1, res1, stride);\n\n        }\n\n    }\n\n}\n", "idx": 10869, "substitutes": {"h": ["l", "rh", "sh", "he", "ht", "dh", "g", "hr", "hh", "w", "m", "http", "t", "b", "c", "work", "hm", "p", "e", "eh", "hw", "f", "host", "FH", "ha", "v", "bh", "ih", "r", "hp", "him", "oh", "hs", "hub", "hd", "cpp", "H", "handler", "hl", "self", "hist", "header", "cache", "ch", "help"], "bit_depth": ["bit_deep", " bit_size", "bit32depth", " bit_deep", "bit2depth", "bit64strength", "bit64rate", "bit_size", " bit_strength", "bitftype", "bitfsize", " bit_rate", "bit32size", "bitfdepth", "bit2strength", "bit_height", "bit64deep", "block_size", "bitfheight", "bit_Depth", "block_height", "bit32height", "bit32type", " bit_Depth", "bit64depth", "bit_strength", "bit2deep", "bit2rate", "block_depth", "bit_type", "block_type", "bit_rate"], "i": ["count", "l", "ui", "di", "it", "si", "n", "zi", "depth", "m", "xi", "b", "x", "k", "z", "t", "ini", "d", "c", "p", "ix", "uri", "e", "mini", "eni", "f", "ie", "j", "ai", "multi", "index", "size", "v", "gi", "ti", "mi", "phi", "abi", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n", "idx": 10875, "substitutes": {"data": ["parent", "base", "valid", "media", "test", "record", "da", "temp", "m", "t", "d", "buf", "i", "c", "config", "p", "reader", "iterator", "style", "array", "empty", "parser", "f", "DATA", "xxx", "dat", "call", "fake", "format", "input", "done", "Data", "init", "this", "u", "self", "api", "video", "result", "buffer", "database"], "unused": ["untuse", "untus", "unus", " unuse", "Unus", "Unuse", "Unused", "Unchecked", "unuse", "unchecked", " unchecked", "untused", "untchecked", " unus"], "tmp": ["uf", "cmp", "verb", "lv", "test", "temp", "tc", "b", "t", "Temp", "wb", "buf", "vt", "var", "vm", "c", "config", "p", "metadata", "pb", "obj", "dest", "fp", "tv", "txt", "np", "rb", "array", "f", "j", "mp", "tf", "py", "amp", "fake", "uv", "conv", "tp", "sb", "front", "copy", "cpp", "self", "api", "vv", "video", "kk", "vp"], "errp": ["erf", "erp", "aerpy", "rarp", "iterpy", "errpe", " erpe", "errpy", "rarpr", "erpr", "Erf", "erlp", "herf", "lerpy", "rarpe", "herP", "lerpr", "rarP", "errP", "herlp", "errpc", "aerpr", "errf", "erP", "iterpr", "errlp", "lerpc", "lerp", " erpr", "Erp", "erpe", " erP", "herp", "aerp", "errpr", "iterp", "aerpc", "Erlp", "ErP", "iterpc", " erp"], "v": ["vs", "l", "vi", "sv", "n", "g", "val", "lv", "test", "w", "temp", "m", "k", "t", "z", "iv", "d", "i", "vt", "c", "vm", "s", "p", "obj", "e", "tv", "value", "q", "f", "j", "o", "nv", "cv", "uv", "V", "vd", "u", "h", "api", "vv", "vp"]}}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n", "idx": 10877, "substitutes": {"env": ["vs", "fg", "chal", "conf", "inet", "erb", "context", "ext", "enter", "dict", "stage", "conn", "net", "que", "viron", "export", "ne", "environment", "enable", "config", "el", "server", "obj", "e", "global", "txt", "ep", "np", "args", "ec", "ass", "esi", "er", "style", "manager", "inst", "code", "ev", "db", "console", "dat", "py", "profile", "exc", "cv", "energy", "scope", "ea", "v", "event", "state", "end", "ctx", "loader", "en", "err", "tern", "eng", "Environment", "here", "enc", "ef", "nc", "dev", "her", "extra", "engine", "cache", "eu", "exec"], "new_cr4": ["new_CR2", "new_CR8", "new_cmfour", "new_rc1", "new_Cr40", "new_cm4", "new_rcfour", "new_cm2", "new_corefour", "new_cm04", "new_Cr1", "new_cr1", "new_Crfour", "new_Cr04", "new_cm1", "new_cr40", "new_cr2", "new_cr8", "new_crfour", "new_cm8", "new_rc8", "new_CR4", "new_cr04", "new_CR1", "new_CRfour", "new_Cr8", "new_Cr4", "new_rc40", "new_core1", "new_Cr2", "new_core4", "new_core2", "new_rc4", "new_CR04", "new_CR40", "new_rc2"]}}
{"project": "qemu", "commit_id": "ffad4116b96e29e0fbe892806f97c0a6c903d30d", "target": 0, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 10899, "substitutes": {"arg": ["mac", "arc", "gen", "arr", "param", "oc", "argument", "flag", "pg", "g", "val", "mor", "tag", "ang", "doc", "ad", "slot", "ref", "ace", "reg", "ag", "args", "op", "ac", "call", "parse", "amp", "ig", "inc", "input", "ar", "pc", "enc", "rg", "match", "Arg", "par", "exec"], "snapshot": ["preshot", "preview", "preprint", "snapview", "picshot", "imagevision", "imageprint", "snapvision", "picview", "picprint", "picvision", "prevision", "snapprint", "imageshot", "imageview"], "opaque": ["paque", "operc", "opacity", "opcam", " opc", "opac", "ospaque", "ospcam", "iopacity", "operacity", "iopaque", " opac", " opacity", "iopac", "pac", "opc", "ospac", "opercam", "pacity", "pc", "ospacity", "iopcam", "operaque", "operac"], "buf": ["bag", "grab", "uf", "ru", "seq", "arr", "holder", "img", "context", "pad", "src", "fd", "path", "b", "filename", "num", "wb", "fw", "pool", "doc", "block", "bridge", "fb", "config", "ref", "cb", "queue", "usr", "cf", "rb", "loc", "array", "args", "bc", "nat", "code", "bt", "ctr", "cv", "msg", "cap", "exc", "rc", "input", "cas", "ctx", "cur", "loader", "port", "begin", "desc", "bus", "uint", "header", "text", "buff", "vec", "proc", "br", "cmd", "buffer", "result", "func", "box", "uc", "runner"], "file": ["cpu", "channel", "byte", "base", "comment", "source", "class", "id", "model", "files", "path", "filename", "block", "line", "data", "uri", "stream", "queue", "array", "body", "f", "binary", "unit", "db", "resource", "profile", "name", "input", "object", "port", "part", "bus", "File", "image", "buffer", "book"], "devname": ["busno", "defno", " devpath", "defnames", " devnames", "modsize", "devnames", "busName", "divno", " devName", "modName", "devicesize", "divsize", "devicenames", "evname", "evno", "divName", " devno", "buspath", "modname", "devsize", "divname", "devicepath", "modnames", "evpath", "deviceName", "busname", "devicename", "devName", "devpath", "defname", "modno", "devno", "defName", "deviceno"], "serial": ["parent", "pass", "cmp", "comment", "prefix", "model", "pack", "tag", "mount", "toc", "mask", "uri", "util", "status", "loc", "mode", "device", "version", "series", "master", "desc", " bus", "spec", "controller", "lang", "dev", "proc"], "mediastr": ["generustrs", "mediestry", "mediustrb", "generustr", "mediastrs", "generastrb", "mediastry", "mediustrs", "generastr", "generastry", "mediastrb", "mediestrs", "generustrb", "mediastsr", "mediustr", "mediastsrs", "mediestrb", "mediastsrb", "generustry", "generastrs", "mediastsry", "mediestr", "mediustry"], "type": ["parent", "base", "comment", "source", "class", "key", "view", "info", "method", "id", "model", "like", "tag", "t", "instance", "by", "Type", "block", "rule", "config", "p", "data", "pb", "time", "rel", "pe", "role", "style", "types", "code", "unit", "label", "o", "resource", " TYPE", "format", "name", "state", "user", "ty", "full", "part", "position", "error", "TYPE", "link", "command", "image", "y", "ype", "family", "typ"], "media": ["library", "music", "Media", "source", "record", "m", "model", "i", "data", "vm", "package", "script", "memory", "style", "language", "mode", "manager", "resource", "device", "shared", "format", "medi", "connection", "document", "port", "audio", "pi", "storage", "java", "command", "ma", "volume", "medium", "interface", "image", "ype"], "bus_id": ["bus__num", "BUS_info", " bus_num", "bus_num", "us__ids", " bus_name", "us_id", "bus__name", "busuuid", "busuuname", "bus_Id", "bus_name", "BUS_ids", "busuuhead", "bus_ids", "unit_ids", "busuunum", "busPname", "BUS_id", "busPhead", "bus_kid", "BUS_kid", "bus__id", " bus_head", "us_name", "bus_head", "bus__ids", "us__num", "us_num", "busPid", "us__name", "bus_info", "us__id", "us_ids", "busPnum", "unit_Id", "unit_name"], "unit_id": [" unit_name", "unit_sid", "unit__ident", "bus_ident", "unit_ident", "unit__id", "bus_name", "unit_num", " unit_sid", "block_kid", "block_id", " unit_num", "block_name", "unit_name", "unit_kid", "unit__name"], "cyls": ["cheles", "tyils", "gyls", "gyll", "cryils", "coples", "gyles", "gyvs", "coplf", "tylf", "cyll", "cryls", " cyvs", "cryles", " cyles", "cyles", "chevs", "copils", "chell", "cyvs", "cyils", " cyll", "tyls", "tyles", "crylf", "chels", "copls", "cylf"], "heads": ["loads", "stars", "devices", "frames", "workers", "rows", "links", "files", "head", "reads", "views", "jobs", "tests", "ids", "drivers", "offs", "pages", "lines", "types", "plugins", "tails", "obs", "sections", "flags", "modules", "checks", "locks", "pull", "scenes", "blocks", "headers", "shots", "docs", "HEAD", "times", "comments", "issues"], "secs": [" seclocks", "sectS", "ECS", "seclocks", "sects", " secls", "isecls", "secls", "iseclocks", "SECls", "SEClocks", "isecs", "sectds", "secr", " secS", "SECs", "isecds", "SECS", "secds", "secS", "sectr", "isecS", "ECds", "ECr", "isecr", "ECs"], "translation": ["Translation", "alias", "conf", "utils", "base", "comment", "source", "prefix", "val", "info", " translations", "layout", "late", "qa", "language", "loc", "padding", "rot", "la", "version", "description", "master", "name", "port", "trans", "ping", "position", "offset", "lang", "seconds", "pos", "message", "border", "options", "comments", "length", "text", "activation", "settings"], "bdrv": ["Bdrw", "Bdrp", "BDrp", "Bdrf", "BDrw", "BDrf", "bdrp", "bDrf", "bdrf", "BDrv", "bdrw", "bDrv", "bDrw", "bDrp", "bdriw", "Bdrv", "bdrif", "bdriv", "bdrip"], "drv": [" drb", "DrV", "srp", "drp", "srV", "drV", "Drp", "srb", " drp", "srv", " drV", "Drb", "drb", "Drv"], "machine": ["mac", "boot", "m", "info", "model", "mob", "mount", "template", "instance", "bridge", "vm", "service", "config", "meta", "computer", "driver", "target", "memory", "Machine", "slave", "mode", "manager", "unit", "device", "process", "connection", "storage", "bus", "node", "controller", "ma", "interface", "image", "engine", "proc", "mc", "buffer"], "max_devs": ["max_evs", "max_devns", "max_evS", "max_devicen", "max_devps", "max_devges", "max_devi", "max_pubi", "max_deps", "max_deviceS", "max_evges", "max_pubs", "max_depi", "max_deviceps", "max_depn", "max_devicei", "max_devS", "max_devicep", "max_devn", "max_evi", "max_devices", "max_libges", "max_pubps", "max_pubS", "max_evn", "max_evps", "max_evns", "max_depp", "max_libi", "max_devicens", "max_libs", "max_devp", "max_deviceges", "max_evp", "max_libns"], "index": ["parent", "diff", "level", "axis", "prefix", "key", "view", "info", "speed", "id", "x", "page", "Index", "num", "toc", "pointer", "head", "config", "action", "condition", "loc", "priority", "unit", "scan", "version", "slice", "inc", "input", "connection", "ind", "proxy", "miss", "position", "error", "offset", "ticket", "pos", "loop", "image", "length", "weight", "depth"], "cache": ["count", "parent", "conf", "session", "timeout", "base", "delay", "cmp", "comment", "prefix", "capacity", "temp", "pack", "tag", "pool", "toc", "c", "Cache", "pointer", "batch", "config", "ref", "slot", "block", "global", "ac", "child", "scan", "race", "master", "sync", "rc", "pre", "miss", "frac", "acl", "pc", "read", "lock", "cat", "ache", "loop", "result", "lc", "buffer"], "bdrv_flags": ["bdrv_bits", "bdrv_ops", "bdrf_flags", "bdrf_ops", "bdrv_flag", "bdrf_flag", "bdrf_bits"], "onerror": ["error", "override", "erride", "onerrors", "rerride", "onerception", "rerception", "rerror", "rerrors", "overrors", "onerride", "overror", "overception", "erception", "errors"], "drives_table_idx": ["drives_table_sidxs", "drives_table_dx", "drives_table_sidx", "drives_table_sidv", "drives_table_dxs", "drives_table_dxc", "drives_table_idxc", "drives_table_dv", "drives_table_idxs", "drives_table_idv", "drives_table_sidxc"], "str": ["cr", "sp", "seq", "arr", "pass", "tr", "proc", "strings", "dict", "fr", "Str", "String", "doc", "c", "config", "obj", "lit", "STR", "iter", "cf", "strip", "rs", "empty", "st", "bc", "dr", "inst", "cs", "ctr", "msg", "format", "sync", "name", "sl", "r", "req", "err", "expr", "part", "spec", "enc", "cat", "ocr", "url", "text", "lc", "br", "vec", "par", "exec"], "params": ["vs", " param", "vals", "mac", "conf", "Parameters", "arr", "param", "ams", "info", " args", "data", "block", "config", "p", "obj", "names", "attr", "afi", "args", "rb", "rs", "prop", "types", "array", "description", "ctx", "req", "r", "acl", "details", "desc", "spec", " parameters", "pos", "options", "url", "ps", "css", "proc", "par", "settings"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n", "idx": 10914, "substitutes": {"fd": ["cond", "td", "timeout", "ds", "handle", "ff", "sf", "conn", "fed", "pid", "fw", "d", "buf", "pointer", "tty", "ad", " fid", "fb", "addr", "bd", "cd", "pd", "fp", "exec", "ffff", "socket", "f", "df", "dl", "fa", "dir", "nd", "draft", "ind", "fx", "pipe", "fat", "md", "dd", "FD", " FD", "dc", "sd", "hd", "fn", "handler", "file", "flo", "io", "fee", "cmd", "fi", "fe", "fc"], "err": ["later", "cr", "acer", "ror", "fr", "rr", "cer", "gr", "server", "reader", "p", "e", "status", "ace", "iter", "ir", "rb", "rs", "er", "ie", "dr", "ev", "res", "finder", "exc", "ar", "r", "req", "ise", "error", "sys", "der", "eor", "ser", "result", "y", "Er", "sr", "fi"], "opaque": ["paque", "opacity", "opatile", "OPaque", "ipque", "boacity", "Opaque", "Opacity", "pque", "OPque", " opque", "boque", "Opatile", "ipacity", "paques", "boaques", " opacity", "ipaque", "ipaques", "boaque", "pacity", "Opque", "opque", " opatile", "opaques", "OPatile", "OPacity"], "s": ["conf", "session", "sg", "ts", "is", "si", "g", "ds", "sf", "stats", "m", "http", "t", "b", "stat", "gs", "service", "c", "i", "p", "ls", "server", "status", "request", "sq", "js", "rs", "f", "us", "an", "sym", "o", "S", "es", "sync", "south", "sl", "services", "r", "sb", "ns", "hs", "spec", "sys", "h", "ses", "su", "a", "ps", "y", "ss", "settings", "ssl"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *pict, int *got_packet)\n\n{\n\n    LJpegEncContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    const int width  = avctx->width;\n\n    const int height = avctx->height;\n\n    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];\n\n    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];\n\n    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;\n\n    int ret, header_bits;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        max_pkt_size += width * height * 3 * 3;\n\n    else {\n\n        max_pkt_size += mb_width * mb_height * 3 * 4\n\n                        * s->hsample[0] * s->vsample[0];\n\n    }\n\n    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", max_pkt_size);\n\n        return ret;\n\n    }\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n\n\n    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,\n\n                                   s->matrix);\n\n\n\n    header_bits = put_bits_count(&pb);\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        ret = ljpeg_encode_bgr(avctx, &pb, pict);\n\n    else\n\n        ret = ljpeg_encode_yuv(avctx, &pb, pict);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(&pb, header_bits);\n\n\n\n    flush_put_bits(&pb);\n\n    pkt->size   = put_bits_ptr(&pb) - pb.buf;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10950, "substitutes": {"avctx": ["afconn", "avcv", "avcmp", " avcci", "avsync", "afcas", "navtx", "macctx", "AVcontext", "avconn", "AVsci", "raftvoc", " avcontext", "avcontext", " avconn", "navcmp", "evkb", "afcontext", "afkb", "avcb", "afcv", "navkb", "aircontext", "evcmp", "ajcmp", "avectx", "avvoc", "macconn", "navconn", "AVkb", "ajctx", "ajcontext", "afxc", "ajvoc", "avekb", "afsci", "avetx", "afvoc", "avcas", "afctx", "navsync", "aircci", " avkb", "avecb", "raftcas", "avexc", "apkb", "aircv", "AVctx", "avxc", " avcv", "avcci", "evctx", "raftcontext", "navcontext", "avkb", "aveconn", "avecontext", " avcas", "afsync", "navctx", "airconn", "aftx", "afcmp", "avecmp", "AVcmp", "evcontext", "avsci", "navxc", "airctx", "aircb", "AVsync", "afcci", "apctx", "ajconn", "afcb", "macvoc", "maccontext", " avvoc", "raftctx", "avtx", "apconn", "ajsci", "apcontext"], "pkt": ["cpkg", "cpacket", "facket", "hkt", "mcp", " pet", "opkt", " packet", " pcp", "fkt", "tkt", "hkg", " pkg", "fwk", "cpct", "pck", "Pqt", "tck", "opacket", "Pkt", "tct", "pqt", "Pet", "tacket", "mct", "hacket", "hwk", "opct", "cpkt", "Pkg", "mkt", "fkg", "packet", " pqt", "Pcp", "cpqt", " pwk", "Pct", "Packet", "Pck", "macket", " pct", " pck", "opet", "pwk", "pct", "pkg", "pcp", "pet"], "pict": ["cot", "imag", "mac", "cam", "img", " picture", "conn", "chat", " pic", "sci", "plain", "stat", " img", "pty", "capt", "photos", "config", "qq", "cli", "private", "gui", "sq", "sec", "pai", "xxx", "png", "quant", "fat", "photo", "jpg", "pic", "picture", "bis", "mut", "mot", "Pic", "Pict", "fig", "cat", "client", "pas", "image", "ch", "pot", "proc", "feat", "fi", "phot"], "got_packet": ["got_sexant", "got_paramets", "got_paramant", "got_packacket", "got_packx", "got_capet", "got_packed_", "got_paramet", "got_packs\n", "got_Pack_", "got_packsx", "got_Pack\n", "got_packant", "got_packedx", "got_pack\n", "got_packets", "got_capant", "got_sexet", "got_Packx", "got_sexacket", "got_pack_", "got_packed\n", "got_paramacket", "got_capets", "got_packs_", "got_sexets", "got_capacket"], "s": ["l", "session", "is", "m", "t", "sci", "gs", "v", "bis", "ns", "spec", "self", "params", "settings", "sg", "ds", "si", "n", "sf", "w", "b", "i", "c", "e", "args", "sq", "us", "f", "sym", "sets", "es", "sup", "r", "storage", "u", "fs", "su", "site", "ps", "ss", "sc", "sv", "g", "ops", "d", "sa", "data", "ls", "os", "cs", "o", "sync", "sl", "sn", "sb", "sys", "side", "a", "ssl", "conf", "in", "service", "p", "qs", "rs", "js", "aws", "S", "services", "h", "ses", "y"], "pb": ["lp", "dp", "uf", "bb", " ssh", "pg", "nb", "bp", "prot", "pl", "lab", "bm", "b", " pc", "wb", "pa", "buf", " eb", "sa", "cp", "fb", "p", " fs", "pd", "cb", "fp", " gp", "gb", "ub", "gp", "rb", "pm", "kB", "tmp", "bc", "vp", "dl", "db", "bf", "fm", "eb", " sd", "bps", " subp", "bh", " SCP", "ctx", "lb", "bot", "tx", "jp", "tp", "sb", "pc", "PB", " rc", "cpp", "plugin", " db", "hub", "platform", "api", " ns", "ss", "xb", "pkg", "rob", " conf", "typ", "kb", "sc", "fc"], "ret": ["pass", "base", "valid", "flag", "active", "ext", "str", "alt", "val", "len", "fail", "def", "nt", "id", "Ret", "sur", "num", "pat", "reply", "ref", "arg", "lit", "fit", "status", "reg", "obj", "run", "value", "gt", "rets", "f", "rot", "ut", "code", "rt", "res", "bf", "det", "opt", "fun", "att", "cur", "bot", "ben", "en", "lt", "rep", "art", "fin", "re", "RET", "back", "aud", "result", "ft", "match", "let", "resp", "feat", "success"], "header_bits": [" header_count", "head_bits", "header_bytes", "header_length", "header_pieces", "header96parts", "head_pieces", " header_bytes", "head_parts", "header_parts", "header96count", "header96bits", "header_count", " header_parts", "head_length", "header96bytes"]}}
{"project": "FFmpeg", "commit_id": "27bcf55f459e038e81f09c17e72e6d44898b9015", "target": 1, "func": "int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterLink *outlink = buffer_filter->outputs[0];\n\n    int ret;\n\n\n\n    if (c->picref) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n\n        AVFilterContext *scale = buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n        char scale_param[1024];\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO,\n\n               \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,\n\n               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);\n\n\n\n        if (!scale || strcmp(scale->filter->name, \"scale\")) {\n\n            AVFilter *f = avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n\n                return ret;\n\n\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n\n            scale->filter->init(scale, scale_param, NULL);\n\n        }\n\n\n\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n\n\n\n        link = scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    c->picref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n\n                                          picref->video->w, picref->video->h);\n\n    av_image_copy(c->picref->data, c->picref->linesize,\n\n                  picref->data, picref->linesize,\n\n                  picref->format, picref->video->w, picref->video->h);\n\n    avfilter_copy_buffer_ref_props(c->picref, picref);\n\n\n\n    return 0;\n\n}\n", "idx": 10962, "substitutes": {"buffer_filter": ["buffer_fill", "input_filter", "bufferingfilter", "bufferacsort", "bufferacmodel", "bufferablefilter", "bufferqflush", " buffer_flush", "buffer_part", "bufferkfil", "request64fill", "buffer64model", "bufferappinfo", "bufferacfilter", "bufferingfl", "inputingfilter", "media_fil", "filter_filter", "reference_info", "bufferappfl", "filteracfil", "bufferwfil", "buffer64sort", "bufferqlayer", "bufferwfilter", " buffer_search", "bufferacfil", "buffer_model", "bufferappfil", "buffer_flush", "bufferingfat", "media_filter", "bufferablecontrol", "texture_handle", "buffer_manager", "texture_part", "layer_model", "bufferwmanager", "buffer64control", "request_control", "bufferwheader", "inputinginfo", "buffer64fill", "bufferingfil", "buffer_handle", "bufferablefill", "reference_context", "reference_filter", "request64filter", "bufferinginfo", "bufferappcontrol", "buffer_search", "buffer_header", "input_fl", "buffer64flush", "media_fill", "bufferappfilter", "layer_sort", "inputingfl", "request_filter", "bufferappfat", "buffer_fl", "request_flush", " buffer_layer", "bufferkhandle", "bufferkpart", "request64control", "layer_search", "bufferkfilter", "bufferacsearch", "buffer_fat", "bufferacmanager", "buffer64filter", "media_control", "request_fill", "buffer64search", "buffer_info", "filteracfilter", "buffer_fil", "filter_header", "filteracmanager", "buffer_control", "filter_fil", "bufferingpart", "layer_filter", "buffer_layer", "request64flush", "bufferableflush", "bufferqsearch", "buffer_context", "bufferacheader", "bufferappfill", "texture_fil", "buffer64layer", "bufferinghandle", "reference_sort", "inputingfat", "bufferqfilter", "buffer_sort", "input_fat", "input_info", "filter_manager", "texture_filter", "filteracheader"], "picref": ["nickreference", "pictreference", "nicreference", " picrel", "pictRef", " picRef", "Picinfo", "chataff", "sysref", "nicRef", "picreference", "macref", "pcdef", "mcRef", "sysRef", "pinRef", "pic1", "nick1", "fcref", "Picconf", "mcinfo", "picinfo", "nicconf", "chatreference", "pindef", " pic1", "fcid", "picaff", "payreference", "Picreference", "picnum", "mcref", "mcreference", "pinreference", "pininfo", "payinf", "Picref", "nickref", "sysrel", "synaff", "pcreference", "fatRef", "nickrel", "Picnum", "fatref", "macid", "pictref", "picinf", "sysconf", "pinid", "fatreference", "nicref", "Picinf", "sys1", "macRef", "fatinf", "pcinfo", "pictnum", "synRef", "chatref", "sysreference", "picRef", "fcreference", "pinref", "picconf", "Picaff", "synreference", "PicRef", "picid", "macreference", "picdef", "macnum", "payRef", " picreference", "chatRef", "picrel", " picinfo", "Picdef", "pcref", "fcRef", "synref", "payref"], "c": ["parent", "l", "cr", "center", "arc", "channel", "oc", "co", "C", "context", "n", "g", "in", "w", "m", "tc", "conn", "course", "t", "b", "k", "z", "d", "i", "rec", "con", "cp", "s", "config", "p", "cu", "e", "cf", "cn", "ec", "coll", "cc", "bc", "ac", "cs", "ctrl", "o", "call", "v", "chart", "ce", "ctx", "r", "cl", "dc", "pc", "xc", "com", "this", "u", "h", "cm", "ca", "client", "ci", "a", "cache", "lc", "y", "vc", "mc", "uc", "sc", "chain"], "outlink": ["outloader", "newloader", "imageloader", "outlinks", "inloader", "inlink", "newlink", "imagelink", "inlinks", "imagelinks", "newLink", "outLink", "imageLink", "newlinks", "inLink"], "ret": ["count", "base", "fail", "ref", "arg", "reg", "gt", "code", "att", "err", "get", "re", " RET", "let", "url", "resp", "flag", "debug", "val", "id", "Ret", "mem", "fit", "value", "prop", "bc", "res", "bf", "det", "rep", "error", "back", "replace", "bad", "str", "alt", "len", "def", "nt", "num", "pat", "data", "reply", "status", "usr", "rb", "rt", "fun", "part", "cat", "result", "success", "pass", "valid", "info", "job", "run", "lit", "obj", "final", "bug", "rets", "bot", "bit", "RET", "ft", "match"], "scale": ["channel", "center", "base", "complex", "config", "pixel", "set", "gp", "code", "call", "fake", "zone", "series", "ce", "rating", "cal", "sort", "grade", "ii", "spec", "crop", "form", "url", "image", "seed", "settings", "alias", "filter", "cam", "rate", "si", "save", "stage", "w", "total", "rule", "draw", "e", "late", "se", "cf", "large", "unit", "scan", "slice", "scope", "Scale", "margin", "error", "root", "cale", "ge", "replace", "gam", "sc", "range", "fee", "score", "g", "source", "data", "coll", "flow", "mode", "label", "alpha", "size", "shape", "order", "sl", " scaling", "ga", "cache", "lan", "setup", "area", "co", "ale", "info", "update", "service", "mask", "server", "p", "network", "parse", "user", "transform", "video", "te"], "link": ["channel", "location", "links", "plane", "model", "path", "service", "bridge", "line", "pixel", "feed", "loc", "ink", "call", "slice", "parse", "sync", "Link", "proxy", "load", "copy", "layer", "li", "file", "url", "image", "lan"], "scale_param": ["data_return", "scale_term", "scaleFconn", "pixel_num", "dataerterm", "data_num", "scaleerconn", "data_param", "scale2size", "scale_num", "scaleingconn", "scaleFreturn", "data_term", "scale_name", "filter_name", "scale_conn", "scaleingparam", "scale___param", "data_conn", "data_size", "pixel_nm", "scaleFterm", "scale_block", "scaleFparam", "scale_params", "pixel_par", "scaleacblock", "scale___par", "scale2num", "scale2params", "scale_return", "scaleerparam", "filter_par", "scale___num", "dataerparam", "scaleacpar", "scale2param", "scale_nm", "filteracname", "scaleacname", "filter_param", "scale___nm", "pixel_param", "filteracpar", "dataerreturn", "scaleerreturn", "scaleerterm", "scale_size", "filteracblock", "data_params", "scaleingreturn", "filteracparam", "scaleacparam", "filter_block", "dataerconn", "scaleingterm", "scale_par"], "f": ["l", "fg", "filter", "g", "sf", "w", "m", "info", "fr", "b", "t", "d", "i", "s", "fb", "p", "e", "fit", "fp", "cf", "flow", "j", "fa", "fm", "fl", "tf", "o", "v", "fx", "r", "u", "h", "cale", "F", "file", "fs", "fi", "fe", "fc"]}}
{"project": "FFmpeg", "commit_id": "9568b2e425f127031ddc91dd78cb9b9f2cae206d", "target": 1, "func": "int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n                                         H264ParamSets *ps, int bit_length)\n{\n    AVBufferRef *pps_buf;\n    const SPS *sps;\n    unsigned int pps_id = get_ue_golomb(gb);\n    PPS *pps;\n    int qp_bd_offset;\n    int bits_left;\n    int ret;\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    pps_buf = av_buffer_allocz(sizeof(*pps));\n    if (!pps_buf)\n        return AVERROR(ENOMEM);\n    pps = (PPS*)pps_buf->data;\n    pps->data_size = gb->buffer_end - gb->buffer;\n    if (pps->data_size > sizeof(pps->data)) {\n        av_log(avctx, AV_LOG_WARNING, \"Truncating likely oversized PPS \"\n               \"(%\"SIZE_SPECIFIER\" > %\"SIZE_SPECIFIER\")\\n\",\n               pps->data_size, sizeof(pps->data));\n        pps->data_size = sizeof(pps->data);\n    memcpy(pps->data, gb->buffer, pps->data_size);\n    pps->sps_id = get_ue_golomb_31(gb);\n    if ((unsigned)pps->sps_id >= MAX_SPS_COUNT ||\n        !ps->sps_list[pps->sps_id]) {\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id);\n    sps = (const SPS*)ps->sps_list[pps->sps_id]->data;\n    if (sps->bit_depth_luma > 14) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Invalid luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n    } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unimplemented luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n        ret = AVERROR_PATCHWELCOME;\n    pps->cabac             = get_bits1(gb);\n    pps->pic_order_present = get_bits1(gb);\n    pps->slice_group_count = get_ue_golomb(gb) + 1;\n    if (pps->slice_group_count > 1) {\n        pps->mb_slice_group_map_type = get_ue_golomb(gb);\n        av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch (pps->mb_slice_group_map_type) {\n        case 0:\n#if 0\n    |       for (i = 0; i <= num_slice_groups_minus1; i++)  |   |      |\n    |           run_length[i]                               |1  |ue(v) |\n#endif\n            break;\n        case 2:\n#if 0\n    |       for (i = 0; i < num_slice_groups_minus1; i++) { |   |      |\n    |           top_left_mb[i]                              |1  |ue(v) |\n    |           bottom_right_mb[i]                          |1  |ue(v) |\n    |       }                                               |   |      |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n    |       slice_group_change_direction_flag               |1  |u(1)  |\n    |       slice_group_change_rate_minus1                  |1  |ue(v) |\n#endif\n            break;\n        case 6:\n#if 0\n    |       slice_group_id_cnt_minus1                       |1  |ue(v) |\n    |       for (i = 0; i <= slice_group_id_cnt_minus1; i++)|   |      |\n    |           slice_group_id[i]                           |1  |u(v)  |\n#endif\n            break;\n    pps->ref_count[0] = get_ue_golomb(gb) + 1;\n    pps->ref_count[1] = get_ue_golomb(gb) + 1;\n    if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) {\n        av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n    qp_bd_offset = 6 * (sps->bit_depth_luma - 8);\n    pps->weighted_pred                        = get_bits1(gb);\n    pps->weighted_bipred_idc                  = get_bits(gb, 2);\n    pps->init_qp                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->init_qs                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->chroma_qp_index_offset[0]            = get_se_golomb(gb);\n    pps->deblocking_filter_parameters_present = get_bits1(gb);\n    pps->constrained_intra_pred               = get_bits1(gb);\n    pps->redundant_pic_cnt_present            = get_bits1(gb);\n    pps->transform_8x8_mode = 0;\n    memcpy(pps->scaling_matrix4, sps->scaling_matrix4,\n           sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, sps->scaling_matrix8,\n           sizeof(pps->scaling_matrix8));\n    bits_left = bit_length - get_bits_count(gb);\n    if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) {\n        pps->transform_8x8_mode = get_bits1(gb);\n        decode_scaling_matrices(gb, sps, pps, 0,\n                                pps->scaling_matrix4, pps->scaling_matrix8);\n        // second_chroma_qp_index_offset\n        pps->chroma_qp_index_offset[1] = get_se_golomb(gb);\n        if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) {\n    } else {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n    init_dequant_tables(pps, sps);\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n    return 0;\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;", "idx": 10971, "substitutes": {"gb": ["GB", "sg", "gd", "bb", "pg", "nb", "g", "gom", "abb", "bp", "bm", "gm", "wb", "tg", "gs", "vm", "gin", "bd", "hm", "pb", "cb", "gp", "rb", "gh", "gt", "bc", "gy", "db", "bf", "eb", "bg", "py", "bps", "gg", "ctx", "lb", "ga", "sb", "pc", "usb", "hub", "tm", "gc", "cfg", "rg", "bn", "buff", "gam", "kb", "mb"], "avctx": ["avcmp", "afctx", "ivctx", "avalctx", "avalcontext", "navctx", "avecmp", "afcmp", "avectx", "ivconn", " avkb", "Avkb", "AVvoc", "avci", "AVcmp", "avvoc", "avsci", "avalsci", "navconn", "AVcontext", "AVloc", "verctx", "vercontext", "AVkb", "avalcmp", "avconn", "AVsci", "AVctx", "AVconn", " avcontext", "verconn", "avcontext", "navvoc", "Avctx", "avekb", "afsci", "afloc", "navcontext", "AVci", "avkb", "aveloc", " avci", "avecontext", "ivcontext", "afcontext", "afkb", "ivvoc", "Avci", "vervoc", "Avcontext", "avloc"], "ps": ["ypes", "pse", "sp", "pes", "amps", "ks", "ppa", "pg", "acts", "ds", "icks", "ams", "aps", "alls", "pl", "changes", "PS", "pa", "pp", "ops", "gs", "ports", "posts", "ys", "s", "p", "ls", "pers", "pe", "pt", "po", "xs", "rs", "cs", "mp", "bps", "ups", "eps", "fps", "pr", "details", "hs", "Ps", "ms", "points", "ips", "params", "px", "ss", "ples"], "bit_length": ["imagelenangle", "bitplen", "bit_size", "imagelenlen", "image_angle", "bitlensize", "imagelenlength", "image_size", "bit_angle", "imagelensize", "bitpangle", "bitlenlength", "bitplength", "image_length", "bit_len", "image_len", "bitlenangle", "bitpsize", "bitlenlen"], "pps_buf": ["pps_uf", "pps_bag", "ppa_bag", "ppa_uf", "pps_buffer", "pps_buff", "ppa_buff", "ppa_buf", "pps2uf", "ppa_buffer", "ppa_vec", "pps2buff", "ppa_fd", "pps_vec", "pps_fd", "pps2buf", "pps2bag", "pps2buffer"], "sps": ["Spped", "sPS", "sports", "cips", "osps", "sups", " spp", "spps", "insps", "jspped", "syspped", "cpps", "pips", "yourpped", "ppp", "ospps", "cples", "sysports", "yourips", "pper", "Spps", " spped", "spp", "sper", " spes", " spps", "jsports", " sports", "jsPS", "spe", "ppe", "yourps", " sups", " sips", "ppps", "gpe", "osples", "gips", "Sbs", "gPS", " sPS", "gps", "Sips", "cps", "pples", "insups", "spes", "inspes", "sysPS", "Spe", "sysps", " sbs", " sper", "osips", "sbs", "jsps", "spped", "sples", " spe", "Sps", "sips", "yourPS", "inspps", "SPS"], "pps": ["vs", "lp", "ypes", "apps", "drops", "pes", "amps", "opers", "ks", "ppa", "pg", "clips", "ds", "php", "acts", "icks", "includes", "dds", "hh", "alls", "pl", "shows", "changes", " pp", "PS", "ils", "ops", "pp", "posts", "ipes", "works", "ls", "pieces", "upp", "ppers", "xs", "ppe", "pages", "pins", "lines", "types", "plugins", "sels", "mp", "bps", "ppo", "packs", "ups", "eps", "phones", "opp", "asts", "fps", "services", "hp", "dd", "rpm", "hops", "details", "pull", "hs", "oper", "cpp", "mph", "ips", "params", "docs", "px", "forces", "pkg", "tracks", "ppy", "kk"], "qp_bd_offset": [" qp_bd_index", " qp_bdwoffset", " qp_bd_off", " qp_bdwindex", " qp_bd2index", " qp_bdwaddress", " qp_data_offset", " qp_bd2address", " qp_bd2offset", " qp_bdwoff", " qp_data_off", " qp_bd2off", " qp_data_address", " qp_data_index", " qp_bd_address"], "bits_left": ["bits_needed", "its_right", "its_left", "bits_right", "its_needed"], "ret": ["arr", "pass", "rem", "alt", "proc", " resp", "def", " success", "Ret", " result", "rs", "res", "rc", "fun", "results", "rep", "error", "eth", "RET", "back", " RET", "result", "resp", "success"]}}
{"project": "qemu", "commit_id": "a52b2cbf218d52f9e357961acb271a98a2bdff71", "target": 1, "func": "static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)\n\n{\n\n    trace_qxl_spice_monitors_config(qxl->id);\n\n    if (replay) {\n\n        /*\n\n         * don't use QXL_COOKIE_TYPE_IO:\n\n         *  - we are not running yet (post_load), we will assert\n\n         *    in send_events\n\n         *  - this is not a guest io, but a reply, so async_io isn't set.\n\n         */\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->guest_monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(\n\n                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,\n\n                    0));\n\n    } else {\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n        if (qxl->max_outputs) {\n\n            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,\n\n                                                qxl->max_outputs);\n\n        }\n\n#endif\n\n        qxl->guest_monitors_config = qxl->ram->monitors_config;\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->ram->monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n\n                                          QXL_IO_MONITORS_CONFIG_ASYNC));\n\n    }\n\n}\n", "idx": 10974, "substitutes": {"qxl": ["qqfxls", "qxesls", "qqfxl", "qwxle", "pxlc", "quxls", "qtxll", "qxlb", "iqexsl", "qxly", "pxxl", "uxl", "questionxll", " qexlin", " qxla", "iqxs", "iqxls", "qtlin", "qqli", "qoxl", "qurxll", "qtxlp", "quxly", "qXlc", "qexli", " qxli", "quxs", "qxxlp", "sqxcl", "qexll", " qrxli", " qexla", "quxpl", "qqfxsl", "queryxlb", "qxfsl", "qaxn", "pxxlc", "questionexpll", "qexpll", "qxls", "qexpl", "pxli", "qexL", "qurxly", "sqxel", "qtxla", "iqexls", " qrxle", "sqxlc", "uxxl", "qrxlb", "Qtxl", "qqfxli", "quxl", "queryrxl", "qxlin", " qexlc", "qxxl", " qrxlc", "qfxls", "qxpla", "Qxlc", " qrxl", "iqexlc", "iqxp", "qxesl", "qtlc", "queryrxlb", "qxxli", "qxmlly", "qxpl", "iqxsl", "qqxsl", "qyli", "qxplp", "uxlc", " qxel", "sqxL", "qrxel", "uxxli", "Qtxlc", " qxlc", "qfxli", "qfxsl", "qxlc", "uxle", "iqexp", "qqxls", "questionexpl", "qxmlll", "qyl", "qxxsl", "queryxle", "qoxla", "qtxl", "qexp", "qrxly", "qxlp", "qxxle", " qrxlp", "qtxlc", "qxclc", "iqexs", "queryxll", "qxesp", "pxl", "qexl", "qxxlc", "qoxlc", "qrxls", "questionxl", "questionxlc", "questionxsl", "questionexpsl", "pxxli", "qxmll", "qylc", "qrxli", " qrxel", "qxplc", "qxmlls", "qurxl", "qtla", "quxla", "qxessl", "qexel", "qXl", "qxfll", "qexn", "iqxli", "quxli", "qxll", "qxtp", "qxtsl", "qwxls", "qqxl", "qrxle", "qrxll", "queryrxle", "Qxn", "qrxl", "qtxn", "qxel", "qtxsl", "qexlin", "quxplc", "qwxel", " qxlin", "qexls", " qxle", "qaxli", "quxpla", "qxtl", "qql", "qwxl", "uxxle", "sqxl", "qqsl", "iqxl", "pxxsl", "queryrxll", "quxll", "qqxli", "qoxlin", "qxsle", "qxn", "qxxs", "qxsl", "qurxls", "qfxl", "qexly", "qtl", "sqxcL", "qxcL", "qaxls", "quxlc", "qrxlc", "Qxli", "qxxla", "qxflc", "qexle", "qXel", "qxli", "qxcel", "qaxsl", "qexsl", "qexplc", "questionexplc", "qaxle", "uxxlc", "qaxlc", "qrxlp", "iqexli", "qxfl", "qexla", "qexs", "qxla", "qxs", "qtxli", "quxplp", "qylp", "queryxl", "qxp", "qXL", "qxL", "sqxcel", "qxle", "qxtls", "qxslb", " qxlp", " qxls", "Qxl", "qexpsl", "qqlc", "iqxlc", "quxlp", "pxsl", "Qtxn", "qxcl", "qxsll", "qexlc", " qrxls", "iqexl", "uxli", "Qtxli", " qexl", "sqxclc", "qaxl"], "replay": ["REresh", "REplaying", "REpeat", "relplays", "preload", "ereplay", "ereplays", "relpeat", "preplay", "REload", "erepeat", "REplays", "reresh", "preplaying", "preplays", "reload", "replaying", "repeat", "relplay", "REplay", "ereresh", "relresh", " reload", " replaying", "replays", " replays"]}}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n", "idx": 10982, "substitutes": {"n": ["l", "gn", "un", "mn", "nb", "g", "hn", "na", "w", "conn", "m", "nt", "t", "net", "b", "num", "z", "k", "d", "i", "ne", "c", "s", "nor", "p", "anon", "e", "np", "cn", "dn", "nov", "network", "nm", "pn", "f", "an", "j", "o", "N", "nit", "v", "syn", "ic", "en", "sn", "new", "ns", "nic", "node", "enc", "fn", "u", "self", "nl", "rn", "not", "nu", "on", "yn", "adj", "ln", "nn"], "status": ["Status", "uses", "std", "active", "str", "stats", "conn", "stat", "data", "s", "config", "server", "cli", "np", "rss", "network", "nat", "code", "progress", "version", "size", "nil", "sync", "name", "current", "remote", "state", "details", "spec", "node", "sys", "out", "result", "ss", "resp", "ok", "sc"], "vdev": ["svdiv", "ldev", "htr", "svver", "svdevice", " vver", "svtr", "Vev", "wdev", "vserv", "vswitch", " vswitch", "vdevice", "hdevice", " vdiv", "lswitch", "hdev", "Vdev", "hdiv", "pdev", " vdevice", "vev", "svdev", "Vdiv", "vDev", "ldevice", "pserv", " vev", " vDev", "ltr", "pdiv", "VDev", "wdevice", "vver", " vserv", "vdiv", "wev", "pdevice", "vtr", "svswitch", "wDev", "Vserv", "lver", "Vdevice"], "nc": ["cdn", "gn", "qt", "mn", "conn", "nt", "net", "ne", "c", "ct", "nec", "cb", "np", "cn", "nw", "ec", "dn", "bc", "nm", "cc", "cs", "NC", "nv", "cv", "ck", "rc", "ctx", "sn", "nr", "ns", "pc", "dc", "nic", "enc", "rn", "ci", "ng", "bn", "ni", "lc", "jc", "mc", "roc", "nn", "fc"], "r": ["cr", "rh", "l", "rf", "ru", "arr", "str", "g", "rd", "hr", "rw", "w", "m", "mr", "rr", "b", "k", "t", "z", "kr", "d", "i", "ra", "c", "p", "e", "attr", "or", "rb", "rs", "lr", "f", "er", "o", "v", "R", "rc", "ar", "pr", "err", "nr", "error", "rar", "u", "re", "rx", "rg", "row", "a", "result", "sr", "br", "rl"]}}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n", "idx": 10984, "substitutes": {"obj": ["parent", "n", "Object", "conn", "org", "src", "instance", "server", "Obj", "gb", "po", "objects", "args", "rb", "os", "orb", "j", "code", "host", "o", "alloc", "ctx", "object", "bot", "oid", "node", "self", "api", "ob", "cache", "so"], "core": ["cpu", "cr", "runner", "arc", "base", "conn", "org", "cer", "con", "c", "cp", "Core", "ace", "cf", "ec", "bc", "ac", "cs", "ck", "ce", "rc", "cur", "object", "can", "custom", "pc", "enc", "rn", "ro", "sys", "gc", "ca", "ocr", "clean", "ob", "anc", "lc", "roc", "cy", "ore", "fc"], "name": ["alias", "NAME", "span", "n", "ext", "str", "comment", "prefix", "key", "word", "class", "id", "info", "no", "path", "instance", "num", "nam", "var", "data", "c", "s", "names", "known", "search", "loc", "none", "ac", "label", "code", "call", "o", "named", "size", "sn", "new", "part", "desc", "type", "ame", "null", "url", "anc", "Name"], "oc": ["ou", "co", "roc", "class", "org", "unc", "aco", "auc", "instance", "c", "OC", "ec", "loc", "oci", "cc", "ac", "os", "bc", "isc", "o", "alloc", "oca", "rc", "oco", "ic", "voc", "object", "pc", "oid", "dc", "hop", "enc", "soc", "ob", "anc", "mc", "uc", "fc"]}}
{"project": "FFmpeg", "commit_id": "892fc83e88a20f9543c6c5be3626712be7a2e6f2", "target": 0, "func": "static void init_block_mapping(Vp3DecodeContext *s) \n\n{\n\n    int i, j;\n\n    signed int hilbert_walk_y[16];\n\n    signed int hilbert_walk_c[16];\n\n    signed int hilbert_walk_mb[4];\n\n\n\n    int current_fragment = 0;\n\n    int current_width = 0;\n\n    int current_height = 0;\n\n    int right_edge = 0;\n\n    int bottom_edge = 0;\n\n    int superblock_row_inc = 0;\n\n    int *hilbert = NULL;\n\n    int mapping_index = 0;\n\n\n\n    int current_macroblock;\n\n    int c_fragment;\n\n\n\n    signed char travel_width[16] = {\n\n         1,  1,  0, -1, \n\n         0,  0,  1,  0,\n\n         1,  0,  1,  0,\n\n         0, -1,  0,  1\n\n    };\n\n\n\n    signed char travel_height[16] = {\n\n         0,  0,  1,  0,\n\n         1,  1,  0, -1,\n\n         0,  1,  0, -1,\n\n        -1,  0, -1,  0\n\n    };\n\n\n\n    signed char travel_width_mb[4] = {\n\n         1,  0,  1,  0\n\n    };\n\n\n\n    signed char travel_height_mb[4] = {\n\n         0,  1,  0, -1\n\n    };\n\n\n\n    debug_vp3(\"  vp3: initialize block mapping tables\\n\");\n\n\n\n    /* figure out hilbert pattern per these frame dimensions */\n\n    hilbert_walk_y[0]  = 1;\n\n    hilbert_walk_y[1]  = 1;\n\n    hilbert_walk_y[2]  = s->fragment_width;\n\n    hilbert_walk_y[3]  = -1;\n\n    hilbert_walk_y[4]  = s->fragment_width;\n\n    hilbert_walk_y[5]  = s->fragment_width;\n\n    hilbert_walk_y[6]  = 1;\n\n    hilbert_walk_y[7]  = -s->fragment_width;\n\n    hilbert_walk_y[8]  = 1;\n\n    hilbert_walk_y[9]  = s->fragment_width;\n\n    hilbert_walk_y[10]  = 1;\n\n    hilbert_walk_y[11] = -s->fragment_width;\n\n    hilbert_walk_y[12] = -s->fragment_width;\n\n    hilbert_walk_y[13] = -1;\n\n    hilbert_walk_y[14] = -s->fragment_width;\n\n    hilbert_walk_y[15] = 1;\n\n\n\n    hilbert_walk_c[0]  = 1;\n\n    hilbert_walk_c[1]  = 1;\n\n    hilbert_walk_c[2]  = s->fragment_width / 2;\n\n    hilbert_walk_c[3]  = -1;\n\n    hilbert_walk_c[4]  = s->fragment_width / 2;\n\n    hilbert_walk_c[5]  = s->fragment_width / 2;\n\n    hilbert_walk_c[6]  = 1;\n\n    hilbert_walk_c[7]  = -s->fragment_width / 2;\n\n    hilbert_walk_c[8]  = 1;\n\n    hilbert_walk_c[9]  = s->fragment_width / 2;\n\n    hilbert_walk_c[10]  = 1;\n\n    hilbert_walk_c[11] = -s->fragment_width / 2;\n\n    hilbert_walk_c[12] = -s->fragment_width / 2;\n\n    hilbert_walk_c[13] = -1;\n\n    hilbert_walk_c[14] = -s->fragment_width / 2;\n\n    hilbert_walk_c[15] = 1;\n\n\n\n    hilbert_walk_mb[0] = 1;\n\n    hilbert_walk_mb[1] = s->macroblock_width;\n\n    hilbert_walk_mb[2] = 1;\n\n    hilbert_walk_mb[3] = -s->macroblock_width;\n\n\n\n    /* iterate through each superblock (all planes) and map the fragments */\n\n    for (i = 0; i < s->superblock_count; i++) {\n\n        debug_init(\"    superblock %d (u starts @ %d, v starts @ %d)\\n\",\n\n            i, s->u_superblock_start, s->v_superblock_start);\n\n\n\n        /* time to re-assign the limits? */\n\n        if (i == 0) {\n\n\n\n            /* start of Y superblocks */\n\n            right_edge = s->fragment_width;\n\n            bottom_edge = s->fragment_height;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * s->fragment_width;\n\n            hilbert = hilbert_walk_y;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = -1;\n\n\n\n        } else if (i == s->u_superblock_start) {\n\n\n\n            /* start of U superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->u_fragment_start - 1;\n\n\n\n        } else if (i == s->v_superblock_start) {\n\n\n\n            /* start of V superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->v_fragment_start - 1;\n\n\n\n        }\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 4;\n\n\n\n            /* fragment is now at the start of a new superblock row */\n\n            current_fragment += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through all 16 fragments in a superblock */\n\n        for (j = 0; j < 16; j++) {\n\n            current_fragment += hilbert[j];\n\n            current_height += travel_height[j];\n\n\n\n            /* check if the fragment is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_fragments[mapping_index] = current_fragment;\n\n                debug_init(\"    mapping fragment %d to superblock %d, position %d\\n\", \n\n                    s->superblock_fragments[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_fragments[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no fragment\\n\", \n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the superblock <-> macroblock mapping; iterate through\n\n     * all of the Y plane superblocks to build this mapping */\n\n    right_edge = s->macroblock_width;\n\n    bottom_edge = s->macroblock_height;\n\n    current_width = 0;\n\n    current_height = 0;\n\n    superblock_row_inc = s->macroblock_width;\n\n    hilbert = hilbert_walk_mb;\n\n    mapping_index = 0;\n\n    current_macroblock = -1;\n\n    for (i = 0; i < s->u_superblock_start; i++) {\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 2;\n\n\n\n            /* macroblock is now at the start of a new superblock row */\n\n            current_macroblock += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through each potential macroblock in the superblock */\n\n        for (j = 0; j < 4; j++) {\n\n            current_macroblock += hilbert_walk_mb[j];\n\n            current_height += travel_height_mb[j];\n\n\n\n            /* check if the macroblock is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_macroblocks[mapping_index] = current_macroblock;\n\n                debug_init(\"    mapping macroblock %d to superblock %d, position %d\\n\",\n\n                    s->superblock_macroblocks[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_macroblocks[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no macroblock\\n\",\n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width_mb[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the macroblock <-> fragment mapping */\n\n    current_fragment = 0;\n\n    current_macroblock = 0;\n\n    mapping_index = 0;\n\n    for (i = 0; i < s->fragment_height; i += 2) {\n\n\n\n        for (j = 0; j < s->fragment_width; j += 2) {\n\n\n\n            debug_init(\"    macroblock %d contains fragments: \", current_macroblock);\n\n            s->all_fragments[current_fragment].macroblock = current_macroblock;\n\n            s->macroblock_fragments[mapping_index++] = current_fragment;\n\n            debug_init(\"%d \", current_fragment);\n\n\n\n            if (j + 1 < s->fragment_width) {\n\n                s->all_fragments[current_fragment + 1].macroblock = current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = current_fragment + 1;\n\n                debug_init(\"%d \", current_fragment + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if (i + 1 < s->fragment_height) {\n\n                s->all_fragments[current_fragment + s->fragment_width].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {\n\n                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width + 1;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            /* C planes */\n\n            c_fragment = s->u_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            c_fragment = s->v_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            debug_init(\"\\n\");\n\n\n\n            if (j + 2 <= s->fragment_width)\n\n                current_fragment += 2;\n\n            else \n\n                current_fragment++;\n\n            current_macroblock++;\n\n        }\n\n\n\n        current_fragment += s->fragment_width;\n\n    }\n\n}\n", "idx": 10992, "substitutes": {"s": ["l", "conf", "session", "sg", "ts", "sv", "is", "si", "g", "n", "ds", "m", "t", "b", "small", "ops", "gs", "service", "c", "p", "ls", "e", "qs", "se", "js", "rs", "sec", "f", "sq", "us", "os", "sy", "cs", "sym", "an", "sets", "S", "v", "es", "space", "south", "services", "r", "sup", "bis", "en", "full", "ns", "sb", "spec", "u", "sys", "self", "h", "ses", "fs", "ps", "su", "site", "ss", "y", "a", "secondary", "inf", "ssl", "sc"], "i": ["l", "ui", "it", "n", "in", "m", "b", "x", "k", "d", "c", "p", "e", "f", "index", "v", "ind", "mi", "r", "ii", "u", "I", "li", "ci", "a", "y"], "j": ["l", "je", "n", "key", "m", "k", "b", "z", "job", "ji", "jo", "p", "obj", "js", "ak", "o", "r", "ij", "jp", "ii", "offset", "java", "aj", "pos", "J", "jc", "jj"], "hilbert_walk_y": ["hilbert_walk_x", "hilbert_walkureoy", "hilbert_walkPiy", "hilbert_indexureoy", "hilbert_move_Y", "hilbert_step_ye", "hilbert_index_oy", "hilbert_move_ya", "hilbert_hop_vy", "hilbert_path_y", "hilbert_walk_cy", "hilbert_walkFy", "hilbert_hop_ey", "hilbert_view_x", "hilbert_walk_Y", "hilbert_index_y", "hilbert_walk_ym", "hilbert_walkPy", "hilbert_move_xy", "hilbert_indexureya", "hilbert_indexurex", "hilbert_step_y", "hilbert_indexurey", "hilbert_walk_vy", "hilbert_view_ya", "hilbert_walk_ry", "hilbert_hop_y", "hilbert_walk_yn", "hilbert_move_x", "hilbert_path_ey", "hilbert_walkureya", "hilbert_step_ya", "hilbert_walk_oy", "hilbert_walk_ny", "hilbert_walk___ya", "hilbert_walkFya", "hilbert_step_yt", "hilbert_index_ya", "hilbert_walkurey", "hilbert_path_cy", "hilbert_move_cy", "hilbert_walkFyn", "hilbert_move_y", "hilbert_walkurex", "hilbert_walkPY", "hilbert_wait_ya", "hilbert_walk_xy", "hilbert_move_ry", "hilbert_wait_ye", "hilbert_view_yn", "hilbert_walkPyt", "hilbert_walk___x", "hilbert_walkFx", "hilbert_walk___y", "hilbert_walk_ya", "hilbert_path_x", "hilbert_walk_ye", "hilbert_walk_iy", "hilbert_hop_ya", "hilbert_walk___type", "hilbert_walk_type", "hilbert_index_x", "hilbert_wait_ym", "hilbert_move_iy", "hilbert_wait_y", "hilbert_view_y", "hilbert_move_yt", "hilbert_walk_ey", "hilbert_move_type", "hilbert_hop_x", "hilbert_walk_yt"], "hilbert_walk_c": ["hilbert_walk_ci", "hilbert_walker_ci", "hilbert_walker_c", "hilbert_walk_cy", "hilbert_walker_cy", "hilbert_walker_y"], "hilbert_walk_mb": ["hilbert_walk_b", "hilbert_walk_mm", "hilbert_walker_mm", "hilbert_walker_xb", "hilbert_walker_mb", "hilbert_walk_xb", "hilbert_walker_b"], "hilbert": ["halbolt", "Hailbl", "halcox", "hillcox", "Hilbolt", "Hailbert", "hillbert", "hilbl", "Hilcox", "hailbert", "hilbolt", "halbl", "hillbolt", "hillbl", "hailbolt", "Hilbl", "Hilbert", "halbert", "hailbl", "Hailbolt", "hilcox", "hailcox", "Hailcox"], "current_macroblock": ["current_macroncondition", "current_maclassblock", "current_mac_row", "current_mic_row", "current_maclassrow", "current_mic_condition", "current_mic_block", "current_microcondition", "current_maclassblocks", "current_macroblocks", "current_mac_condition", "current_mic_blocks", "current_maclasscondition", "current_microblock", "current_macronblock", "current_microrow", "current_mac_block", "current_mac_blocks", "current_macrocondition", "current_macrorow", "current_microblocks", "current_macronblocks", "current_macronrow"], "c_fragment": ["current_frangment", "current_fragments", "current_frangement", "current_fagme", "current_fagement", "current_frasureme", "current_fragme", "current_frragme", "current_frangme", "current_frragments", "current_fagment", "current_fagments", "current_frragment", "current_frragement", "current_frasurements", "current_frangments", "current_frasurement", "current_fragement", "current_frasureement"], "travel_width": ["travel___shape", "travel___layout", " travel_layout", "travel___weight", " travel_shape", "travel_weight", "travelableweight", "travelablewidth", "travelablelayout", "travel_layout", "travel___width", "travelableshape", " travel_weight", "travel_shape"], "travel_height": ["travelacheight", " travel_padding", "travelacdistance", "travel_padding", "travel_distance", "travelacpadding", "travelacwidth", " travel_distance"], "travel_width_mb": ["travel_width_bb", "travel_weight_mm", "travel_weight_mb", "travel_weight_bb", "travel_width_mp", "travel_weight_mp", "travel_width_mm"], "travel_height_mb": ["travel_data_mm", "travel_data_mp", "travel_height_bb", "travel_data_bb", "travel_height_mm", "travel_data_mb", "travel_height_mp"], "mapping_index": ["mapped_id", "mapped_index", "mapping_depth", "mapped_ind", "mapping_ind", "mapped_depth", "mapping_id"], "current_fragment": ["current_frigement", "current_drigments", "current_fraggment", "current_fraggement", "current_drigment", "current_frangmented", "current_frangment", "current_fraggments", "current_fragments", "current_frangement", "current_drigement", "current_dragmented", "current_dragments", "current_dragment", "current_frigments", "current_fragmented", "current_frangments", "current_frigmented", "current_frigment", "current_dragement", "current_fragement", "current_fraggmented", "current_drigmented"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; m68k_cpu_defs[i].name; i++) {\n\n        (*cpu_fprintf)(f, \"%s\\n\", m68k_cpu_defs[i].name);\n\n    }\n\n}\n", "idx": 10999, "substitutes": {"f": ["l", "rf", "xf", "n", "g", "fen", "sf", "w", "m", "fr", "fd", "b", "t", "x", "d", "c", "s", "p", "ref", "e", "fp", "exec", "cf", "feed", "df", "j", "fa", "o", "tf", "v", "name", "r", "fff", "fn", "form", "h", "F", "file", "fs", "fac", "proc", "fi", "fc"], "cpu_fprintf": ["cpu_forwrite", "cpu_Fprintf", "cpu_Fprint", "cpu_cfcmp", "cpu_Fformat", "cpu_cfformat", "cpu_fflush", "cpu_Fwrite", "cpu_Fmt", "cpu_fmt", "cpu_forprint", "cpu_fformat", "cpu_formt", "cpu_fdflush", "cpu_fprint", "cpu_cfflush", "cpu_fwrite", "cpu_Fcmp", "cpu_forprintf", "cpu_cfprintf", "cpu_fcmp", "cpu_fdformat", "cpu_Fflush", "cpu_fdprintf", "cpu_fdcmp"], "i": ["oi", "l", "hi", "ui", "di", "it", "start", "si", "zi", "m", "id", "xi", "info", "t", "x", "b", "z", "ini", "k", "d", "c", "ji", "block", "p", "ix", "uri", "e", "mu", "attr", "ie", "j", "code", "ai", "o", "multi", "index", "slice", "v", "gi", "name", "phi", "abi", "qi", "bi", "pi", "ii", "init", "u", "I", "li", "ci", "io", "ni", "lc", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11016, "substitutes": {"s": ["session", "sg", "ks", "sv", "ds", "is", "g", "si", "m", "info", "http", "b", "t", "ops", "d", "i", "gs", "service", "c", "server", "p", "e", "js", "sq", "us", "os", "f", "an", "rs", "sym", "cs", "o", "S", "es", "sync", "south", "states", "services", "sl", "r", "ns", "sb", "spec", "u", "self", "sys", "ions", "ses", "fs", "ps", "su", "a", "ss", "ssl"], "dev": ["diff", "debug", "comment", "Dev", " device", "info", "def", "w", "prom", "die", "game", "dem", "development", "adv", "d", "ver", "de", "data", "ad", "block", "app", "driver", "bug", "rad", "priv", "serial", "ev", "device", "v", "md", "end", "dd", "dc", "bus", "sd", "grad", "od", "der", "engine", "cmd", "wd"], "state": ["parent", "un", "session", "State", "start", "handle", "key", "statement", "tag", "t", "instance", "stat", "d", "shadow", "head", "config", "p", "rule", "e", "status", "driver", "se", "set", "role", "ace", "STATE", "style", "st", "mode", " self", "resource", "scope", "sync", "name", "states", "sl", "cur", "see", "err", "port", "part", "spec", "type", "self", "lock", " states", " State", "ignore", "use", "ss", "seed", "settings"]}}
{"project": "FFmpeg", "commit_id": "af8aa846fa5b9f2c7dcde451c872426528b8b561", "target": 0, "func": "static void frame_start(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n\n\n    MPV_frame_start(s, s->avctx);\n\n    ff_er_frame_start(s);\n\n\n\n    assert(s->linesize && s->uvlinesize);\n\n\n\n    for(i=0; i<16; i++){\n\n        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n    for(i=0; i<4; i++){\n\n        h->block_offset[16+i]=\n\n        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+16+i]=\n\n        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n\n\n    /* can't be in alloc_tables because linesize isn't known there.\n\n     * FIXME: redo bipred weight to not require extra buffer? */\n\n    if(!s->obmc_scratchpad)\n\n        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);\n\n\n\n//    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;\n\n}\n", "idx": 11026, "substitutes": {"h": ["l", "hi", "sh", "he", "ht", "n", "g", "ph", "hr", "hh", "w", "m", "http", "t", "x", "b", "history", "c", "p", "hm", "e", "gh", "eh", "q", "hw", "f", "host", "o", "th", "ha", "v", "ih", "bh", "home", "ctx", "hp", "hash", "hs", "oh", "hd", "this", "hhh", "H", "self", "hl", "header", "image", "ah", "y", "ch", "rh", "uh"], "s": ["l", "session", "is", "strings", "m", "http", "t", "gs", "hm", "v", "hes", "full", "hs", "ns", "spec", "self", "params", "settings", "sg", "ds", "si", "n", "sites", "sf", "w", "b", "ssh", "c", "e", "se", "request", "args", "sq", "f", "sym", "sets", "es", "r", "this", "u", "comments", "ps", "fs", "ss", "sc", "sh", "ks", "g", "stats", "ops", "d", "ys", "ls", "cs", "o", "sync", "sl", "ats", "sb", "sys", "ions", "side", "a", "ssl", "setup", "conf", "sports", "ts", "sw", "p", "server", "qs", "xs", "js", "rs", "sec", "aws", "S", "services", "ctx", "support", "ses", "y"], "i": ["l", "is", "m", "t", "x", "iv", "uri", "esi", "ie", "v", "phi", "abi", "ii", "ori", "ri", "fi", "oi", "vi", "si", "n", "id", "xi", "b", "ami", "c", "e", "mu", "f", "j", "index", "slice", "ic", "ei", "bi", "u", "li", "ni", "anti", "hi", "di", "zi", "d", "yi", "cli", "ia", "eni", "ai", "o", "gi", "chi", "im", "pi", "I", "a", "iu", "ki", "ui", "it", "start", "in", "info", "ini", "ji", "p", "ix", "isi", "ish", "multi", "ti", "mi", "ik", "qi", "ip", "ci", "api", "io", "y"]}}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}", "idx": 11046, "substitutes": {"dev": ["diff", "conf", "gu", "cam", "valid", "debug", "dom", "test", "Dev", "def", "conn", "info", "prom", "die", "w", "da", "pad", "dem", "development", "ve", "adv", "ver", "d", "de", "var", "data", "block", "ad", "app", "pro", "cd", "driver", "dist", "bug", "rad", "priv", "serial", "hw", "db", "device", "ev", "home", "end", "mod", "dd", "dc", "error", "bus", "sd", "grad", "od", "der", "ch", "dep", "DEV"], "bmdma_bar": ["bmdda_browser", "bmdma_home", "bmdma_car", "bmdma_browser", "bmdma__bar", "bmdda_var", "bmdda_app", "bmdda_home", "bmdda_bar", "bmdma_var", "bmdma__home", "bmdma_app", "bmdma__var", "bmdma__car", "bmdda_car"], "ide_bar": ["ideboardhome", "ine_show", "ine_bar", "idexbars", "ideboardbar", "idepgroup", "ide_home", "idejloader", "side_bar", "ine_bars", "ide_buffer", "side_bars", "IDE_var", "IDExbuffer", "idejhome", "IDExbars", "ide_var", "IDExvar", "ideboardtab", "IDExbar", "ide_car", "idejbars", "ide_show", "ideboardgroup", "ide_bars", "idexvar", "ideptab", "side_tab", "side_loader", "IDE_bar", "idejbar", "idephome", "IDE_buffer", "idepbar", "ide_tab", "IDE_bars", "side_group", "ide_group", "ide_loader", "idexbuffer", "side_home", "idexbar", "ine_car"]}}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}", "idx": 11070, "substitutes": {"handle": ["alias", "ipe", "fail", "conn", "Handle", "open", "phy", "fd", "pointer", "pool", "data", "wrap", "addr", "draw", "close", "wrapper", "ptr", "share", "host", "device", "call", "child", "resource", "hand", "handled", "process", "connection", "end", "object", "ctx", "hash", "h", "handler", "ignore", "use", "write", "proc", "help", "bind"], "errp": [" errpo", "erp", "erbp", "rrr", " errP", "armP", "errorpo", " errbp", "ern", "rrpo", "errn", "errorp", "rrn", " ern", " erpo", "rrp", "errP", "erP", "err", "erpo", "armr", "errpo", " err", "errbp", "armbp", " errn", "errorn", " errr", "armp", " erp", "errr", "errorr"], "gfh": ["gcfrh", " gfw", "gfssh", " gfxh", " gfxp", "gfsh", "Gfsh", "glfsh", "gfxh", "gfboh", " gfxch", "gfw", "glfch", "glfw", "gfoh", "gfbsh", " gfoh", "gfrh", "gsfh", "Gcfh", "glfh", "glfp", "Gcfsh", "gsfoh", " gfsh", "gcfsh", " gfhs", " gfch", " gsfh", "gfhs", "Gfbh", "glfrh", "gfsbh", "gsfsh", "gsfhs", "Gfh", " gsfsh", " gsfhs", " gsfoh", "gufw", " gfxw", "gfbh", "gfp", "Gcfrh", "Gcfbh", "gfxw", "gfbhs", "gufh", "gfxch", "gfsrh", "gufch", "gcfh", "gcfbh", "gufp", "glfbh", "gfch", "gfxp", " gfp", "Gfrh"], "fh": ["dp", "hbh", "ghs", "afp", "dh", "fbh", "fdp", " fhs", "ph", "fsh", "ffc", "hh", "afh", " fsh", "dbh", "Fbh", "pp", "fdz", "fdh", "hph", "fp", " fH", " fph", "gh", " fz", "fhs", " fp", "afsh", "ffh", "ffsh", "Fz", "gsh", "dph", " fc", "hp", "Fp", "ffhs", " fbh", "fH", "Fh", "fph", "gc", "fc", "afH", "pH", "fdbh", "psh", "fz"], "ret": ["arr", "std", "flag", "len", "val", "alt", "nt", "Ret", "num", "mem", "pat", "data", "reply", "ct", "ref", "arg", "lit", "reg", "rb", "rets", "code", "rt", "res", "det", "rc", "fat", "fun", "att", "err", "fin", "lock", "re", "xt", "RET", "result", "mt", "ft", "match", "resp", "sr", "rl", "success", "pet"]}}
{"project": "FFmpeg", "commit_id": "c9aab8a123c0bcf6adeab390db1ec783326456ca", "target": 0, "func": "static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture * const ref1 = &h->ref_list[1][0];\n\n    int j, old_ref, rfield;\n\n    int start= mbafi ? 16                      : 0;\n\n    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];\n\n    int interl= mbafi || s->picture_structure != PICT_FRAME;\n\n\n\n    /* bogus; fills in for missing frames */\n\n    memset(map[list], 0, sizeof(map[list]));\n\n\n\n    for(rfield=0; rfield<2; rfield++){\n\n        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){\n\n            int poc = ref1->ref_poc[colfield][list][old_ref];\n\n\n\n            if     (!interl)\n\n                poc |= 3;\n\n            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed\n\n                poc= (poc&~3) + rfield + 1;\n\n\n\n            for(j=start; j<end; j++){\n\n                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {\n\n                    int cur_ref= mbafi ? (j-16)^field : j;\n\n                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;\n\n                    if(rfield == field || !interl)\n\n                        map[list][old_ref] = cur_ref;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11080, "substitutes": {"h": ["l", "sh", "he", "ht", "html", "n", "g", "hr", "ph", "hh", "w", "m", "http", "t", "b", "z", "d", "i", "c", "p", "hm", "e", "ref", "gh", "eh", "q", "hw", "f", "host", "o", "ha", "v", "ih", "bh", "hp", "oh", "hs", "hd", "u", "H", "self", "hl", "header", "image", "ah", "ch", "rh", "uh"], "map": ["parent", "conf", "maps", "arr", "up", "cmp", "scale", "dict", "m", "model", "open", "pack", "mem", "create", "pool", "block", "data", "config", "max", "meta", "app", "set", "table", "group", "array", "share", "code", "db", "bl", "shape", "module", "scope", "cap", "master", "msg", "min", "Map", "pre", "address", "en", "hash", "copy", "lock", "change", "pair", "file", "ge", "use", "MAP", "cache", "match", "down", "ap", "image", "buffer", "per"], "list": ["parent", "count", "l", "base", "record", "m", "path", "x", "pool", "block", "config", "max", "set", "act", "st", "none", "code", "err", "full", "com", "type", "self", "flat", "chain", "arr", "val", "key", "all", "view", "low", "cont", "c", "List", "pre", "load", "cl", "wx", "listed", "header", "lc", "range", "str", "g", "len", "source", "test", "lists", "data", "head", "cli", "local", "coll", "old", "can", "cache", "diff", "batch", "p", "server", "queue", "table", "name", "LIST", "ist", "null", "out", "write", "feat"], "field": ["count", "play", "cmp", "record", "x", "shift", "ref", "v", "end", "offset", "type", "change", "ld", "key", "fr", "low", "i", "c", "rule", "component", "value", "group", "f", "input", "Field", "load", "layer", "lc", "range", "fix", "len", "g", "source", "ff", "d", "size", "query", "old", "message", "diff", "level", "co", "start", "fields", "FIELD", "line", "p", "ix", "number", "off", "length", "match", "force", "fe"], "colfield": ["catindex", "textindex", "colrule", "collref", "textfix", "reflabel", "reforder", "rolrule", "collfield", "collrow", "colindex", " colfix", "actloader", " collabel", "colfix", "catgroup", "actfield", "rolref", "colorder", "catfield", "rolfield", "actrow", "colrow", "colgroup", "rolorder", "rollabel", " colrule", "catfix", "reffield", "refrule", "textgroup", "collloader", " colindex", "actref", " colorder", "rolloader", "textfield", "colloader", "rolrow", "colref", "collabel", " colgroup"], "mbafi": ["MBafi", "mdifa", "embafi", "kbaf", "kbafa", "mciera", "MBfi", "mpaf", "mbfi", "macabi", "embfi", " MBafi", "nobaf", "mbifa", "mnafi", " MBabi", "nobfi", "mpifa", "embaf", "MBifi", " MBiana", "mdafi", "ombafa", "nobafa", "ombafi", "mpabi", "maciera", "MBafa", "mbifi", "mnabi", "ombabi", "maciana", "embafa", "mdabi", "mnaf", "mdafa", "mbabi", "ombifa", "mcaf", "mcafa", " MBfi", "mbiana", "mnafa", "mcabi", "mpifi", "mbafa", "mcafi", "macafi", "mpafi", " MBifi", "mpafa", "mpfi", "mciana", "nobafi", "mbiera", "mbaf", " MBiera", "kbfi", "kbafi", " MBafa"], "s": ["l", "session", "sg", "sh", "is", "n", "g", "si", "w", "m", "b", "ages", "t", "ops", "i", "gs", "c", "p", "ls", "server", "e", "rs", "os", "f", "cs", "o", "S", "es", "v", "scope", "sync", "sl", "services", "r", "als", "ns", "sb", "spec", "u", "sys", "ions", "ances", "params", "ps", "ures", "fs", "ses", "y", "ss", "a", "settings", "ssl", "sc"], "ref1": [" ref2", "ref01", " Ref2", "rangeOne", "col2", "resp01", "reference1", "ref0", "refOne", "reference01", "range1", "Ref0", " Ref0", "ref2", "range2", "respOne", "reference2", " refOne", "resp1", "Ref1", "referenceOne", "colOne", "range01", "resp2", "col0", "Ref2", " Ref1", "col1"], "j": ["l", "jan", "je", "it", "str", "n", "g", "start", "adj", "key", "all", "note", "m", "fr", "section", "x", "jet", "b", "jen", "dj", "z", "num", "k", "d", "i", "job", "c", "ji", "ref", "p", "obj", "jo", "jam", "reg", "e", "el", "js", "f", "ie", "code", "uj", "child", "bj", "o", "index", "bl", "v", "syn", "jit", "ind", "r", "ij", "jp", "part", "ja", "offset", "col", "u", "aj", "oj", "li", "pos", "J", "length", "y", "ch", "jc", "jl", "jj", "br"], "old_ref": ["old_diff", "old_rec", "old5ref", "oldlexfe", "old5cmp", "old_cmp", "old67Ref", "oldlexval", "old_remote", "old_pointer", "oldJpointer", "oldJreference", " old_pointer", "old5rec", "old67diff", "oldlexref", "olderlexref", " old_remote", "old67ref", " old_Ref", "oldlexreference", "old67ext", "olderlexfe", "olderlexval", " old_vis", "old67fe", " old_reference", "oldJref", "old_vis", "olderlexreference", "old67pre", "older_cmp", "old_val", "old_Ref", "old67remote", "old5reference", " old_pre", " old_diff", "older_val", "older_fe", "old_ext", "older_rec", "old_fe", " old_fe", "oldJRef", "old67reference", "old_reference", "old67vis", " old_ext", "oldJdiff", "old_pre", "older_ref", "older_reference"], "rfield": ["rtkey", "rdkey", "rkey", "rtref", "reldiff", "relkey", "rtfun", "relslice", "drslice", "rddiff", "rarfield", "jf", "roslice", "rdref", "nrfields", "nrslice", " rfc", " rdiff", "jref", "drcomp", "rolabel", "rlabel", "relref", "lkey", "rofc", " rlabel", " rslice", " rfields", "rslice", "lfc", "jfield", "nrforce", "bfield", "Rslice", "rofield", "nrfield", "rcomp", "lslice", "srforce", "rarref", "rref", "rdfield", " rf", "rfix", "nrchar", "nrFIELD", "rf", "relchar", "relfix", " rforce", "rfields", "rfc", "bslice", "lfield", "rfun", "rdfix", " rFIELD", "rokey", " rfix", " rfun", "rarkey", "nrkey", "srfield", " rkey", " rref", "rdslice", "srFIELD", "rof", "jlabel", "Rcomp", "rforce", "srfields", "roref", "rchar", "rtfield", "rdiff", "Rfield", "drfield", "rdchar", "relfield", "rarfun", "bcomp", "rFIELD"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 11084, "substitutes": {"pnum": ["ennumb", "rnui", "pronenum", "snumb", "rnuma", "snumer", "pronumb", "pronumber", "hnum", "snam", "PNumer", "atanenum", "rnummer", "gnuma", "ynum", "gnum", "hnuma", "atanum", "pnumb", "ennume", "pnuma", "hnumm", "pnumm", "PNam", "rnumber", "PNuma", "pnumber", "rnumer", "nnumer", "pnummer", "rnenum", "rnum", "nnum", "pnui", "atanuma", "pnenum", "atanummer", "nnumb", "nnenum", "ynumb", "pronum", "ennumber", "hnumb", "PNumm", "pnam", "PNum", "ennum", "nnumm", "rnam", "ynumer", "bnumber", "bnui", "ennui", "ennummer", "PNumb", "nnumber", "bnume", "rnumb", "snum", "pnumer", "rnume", "bnum", "gnumb", "pnume", "ennenum", "ynumm", "snumm", "ennuma", "gnumm"], "pden": ["Ponder", " pne", "pDen", "cdan", "pronder", "czen", "priden", " pDen", "nDen", "spden", "piden", "nden", "nzen", "prdon", "przen", " pzen", "ndan", "ciden", "prden", "Pne", "Pden", "cden", " ponder", " pdon", "pdon", "prlen", "pne", "plen", "Pdan", " piden", "clen", "pzen", "cDen", "splen", "pdan", "spne", "Plen", " plen", "prdan", "spdan", "Pzen", "ponder", "cdon", " pdan"], "s": ["ts", "is", "g", "w", "m", "t", "ops", "c", "p", "qs", "e", "us", "sq", "parser", "cs", "v", "sync", "r", "spec", "ms", "as", "sys", "ps", "ses", "fs", "ss", "ssl"], "st": ["ld", "ts", "std", "str", "start", "est", "ust", "stage", "nt", "fr", "src", "t", "rest", "sa", "c", "ct", "stress", "ost", "pt", "sec", "ut", "inst", "cs", "th", "nd", "sts", "sta", "sl", "r", "cur", "ist", "sth", "sn", "ste", "sb", "sty", "sd", "ast", "St", "ST", "ft", "mt", "ss", "td", "sc"], "pc": ["lp", "arc", "asc", "td", "co", "pg", "cca", "tc", "cz", "pl", "pa", "pp", "pat", "c", "ct", "cp", "con", "p", "pb", "pd", "sc", "pt", "pm", "ec", "bc", "pn", "ac", "cc", "cs", "mp", "amp", "inc", "rc", "pac", "ctx", "pr", "cl", "spec", "enc", "nc", "icc", "px", "ps", "vc", "lc", "anc", "func", "proc", "mc", "uc", "PC", "fc"], "pkt": [" packet", "ppkg", "ppkt", " pkg", "Pkt", " ptk", "Pett", "Ptk", "lpkt", "lpacket", "ppett", "Pkg", " pett", "pett", "packet", "lptk", "lpct", "ppacket", "ptk", "Pct", "Packet", " pct", "pct", "pkg"], "frame_size": ["frame_loc", "file_description", "frame_len", " frame_count", "fram_count", "file_loc", "frame_sized", " frame_sized", "frame_count", "frame___description", " frame_len", "fram_size", "frame_name", "frame_description", "fram_sized", "frame___rate", "frame_rate", " frame_name", "file_rate", "fram_rate", "file_size", "frame___size", "frame___loc"]}}
{"project": "qemu", "commit_id": "ecbddbb106114f90008024b4e6c3ba1c38d7ca0e", "target": 1, "func": "static int os_host_main_loop_wait(int64_t timeout)\n{\n    GMainContext *context = g_main_context_default();\n    GPollFD poll_fds[1024 * 2]; /* this is probably overkill */\n    int select_ret = 0;\n    int g_poll_ret, ret, i, n_poll_fds;\n    PollingEntry *pe;\n    WaitObjects *w = &wait_objects;\n    gint poll_timeout;\n    int64_t poll_timeout_ns;\n    static struct timeval tv0;\n    fd_set rfds, wfds, xfds;\n    int nfds;\n    /* XXX: need to suppress polling by better using win32 events */\n    ret = 0;\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n        ret |= pe->func(pe->opaque);\n    }\n    if (ret != 0) {\n        return ret;\n    }\n    FD_ZERO(&rfds);\n    FD_ZERO(&wfds);\n    FD_ZERO(&xfds);\n    nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds);\n    if (nfds >= 0) {\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n        if (select_ret != 0) {\n            timeout = 0;\n        }\n        if (select_ret > 0) {\n            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);\n        }\n    }\n    g_main_context_prepare(context, &max_priority);\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n    for (i = 0; i < w->num; i++) {\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n    }\n    if (poll_timeout < 0) {\n        poll_timeout_ns = -1;\n    } else {\n        poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS;\n    }\n    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);\n    qemu_mutex_unlock_iothread();\n    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);\n    qemu_mutex_lock_iothread();\n    if (g_poll_ret > 0) {\n        for (i = 0; i < w->num; i++) {\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n        }\n        for (i = 0; i < w->num; i++) {\n            if (w->revents[i] && w->func[i]) {\n                w->func[i](w->opaque[i]);\n            }\n        }\n    }\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n        g_main_context_dispatch(context);\n    }\n    return select_ret || g_poll_ret;\n}", "idx": 11113, "substitutes": {"timeout": ["count", "cookie", "delay", "start", "alt", "window", "no", "conn", "trial", "nt", "temp", "t", "sleep", "pool", "ssl", "time", "limit", "max", "server", "number", "outs", "stop", "sec", "unit", "size", "version", "opt", "duration", "v", "connection", "response", "event", "option", "offset", "ime", "rain", "seconds", "options", "Timeout", "out", "io", "cache", "url", "random", "exec"], "context": ["parent", "channel", "Context", "window", "temp", "tc", "instance", "service", "c", "config", "work", "server", "component", "thread", "local", "driver", "xml", "request", "wrapper", "queue", "stack", "package", "cf", "network", "none", "bc", "host", "resource", "graph", "ce", "current", "connection", "input", "event", "cas", "proxy", "ctx", "document", "tx", "support", "java", "concept", "handler", "null", "cache", "buffer", "sc"], "poll_fds": ["poll_rfcks", "poll_fslers", "poll_fdes", "poll_fcds", "poll_fundds", "poll_funcs", "pollingfds", "poll_sfdds", "poll_Fld", "poll_rfdat", "poll_fd", "pollingfld", "poll_fdat", "poll_funds", "pollingrfd", "poll_rfdes", "poll_rfts", "poll_tfdes", "poll_funts", "poll_rfds", "pollingrfdes", "poll_fDS", "poll_rfld", "poll_sfds", "poll_fsds", "poll_xdds", "poll_ddes", "poll_fcdds", "poll_xds", "pollingfdes", "poll_rfDS", "poll_funks", "poll_funcks", "poll_dfds", "poll_rflers", "pollingrfds", "pollingrfld", "poll_fys", "poll_dds", "poll_tfsts", "poll_fcys", "poll_funlers", "poll_Fd", "poll_fsks", "poll_Fds", "pollingfd", "poll_fccks", "poll_xys", "poll_fcks", "poll_tfds", "poll_tfdds", "poll_dfdes", "poll_sfDS", "poll_sfcs", "poll_fsdds", "poll_rfdds", "poll_rfcs", "poll_rfys", "poll_xdat", "poll_funns", "poll_fld", "poll_Fdes", "poll_fsts", "poll_fcs", "poll_fts", "poll_rfsts", "poll_fcns", "poll_rfns", "poll_rfks", "poll_fdds", "poll_flers", "poll_fks", "poll_dfd", "poll_funDS", "poll_dsts", "poll_fcdat", "poll_fcts", "poll_ddds", "poll_dfld", "poll_rfd", "poll_fns"], "g_poll_ret": ["g_poll_return", "g_poll_result", "g_exec_rets", "g_exec_return", "g_poll_rets", "g_exec_ret", "g_exec_result"], "ret": ["seq", "valid", "delay", "flag", "active", "alt", "val", "len", "ry", "trial", "temp", "nt", "Ret", "no", "info", "num", "job", "reply", "ref", "server", "obj", "run", "status", "iter", "value", "rets", "rt", "res", "det", "opt", "wait", "live", "sync", "fun", "req", "att", "r", "err", "part", "sb", "offset", "get", "bit", "re", "RET", "back", "complete", "url", "result", "ft", "resp", "feat", "fi", "success", "pet", "reset"], "i": ["ani", "l", "gu", "ui", "di", "it", "start", "si", "n", "info", "id", "xi", "m", "ami", "x", "ini", "my", "d", "c", "p", "uri", "ix", "e", "mu", "yi", "iter", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "inc", "gi", "ti", "mi", "phi", "ind", "chi", "qi", "pi", "bi", "part", "ii", "u", "I", "li", "ip", "ci", "ni", "io", "image", "y", "fi", "iu", "ki"], "n_poll_fds": ["n_poll67fcs", "n_poll_cfks", "n_poll67nys", "n_poll_ofls", "n_poll67fds", "n_polledinfcons", "n_poll_Fns", "n_poll_ofsts", "n_poll_funds", "n_polledinfds", "n_poll_fss", "n_poll_fls", "n_poll_forcs", "n_poll_Fls", "n_poll_fsts", "n_poll_fdr", "n_poll_frd", "n_poll_tdr", "n_poll_fys", "n_pollsfdds", "n_poll_fieldds", "n_poll_rfd", "n_poll_nys", "n_poll_cfdds", "n_poll_rfks", "n_poll_fordr", "n_poll_infns", "n_poll_forys", "n_poll_rfcons", "n_poll_rfcs", "n_poll_funks", "n_poll_fd", "n_poll_fcons", "n_polledfds", "n_poll_fords", "n_poll_ndr", "n_poll_cfcs", "n_poll67fdr", "n_poll_funrd", "n_poll_rfss", "n_pollsfcs", "n_poll_fund", "n_poll_rfds", "n_poll_Fsts", "n_poll67ndr", "n_poll_ncs", "n_poll_rfdds", "n_pollscfks", "n_polledfns", "n_poll_funcs", "n_poll_rfls", "n_pollsfks", "n_poll_fns", "n_polledinfss", "n_poll_cfds", "n_poll_Fds", "n_poll_infds", "n_pollscfds", "n_poll_fieldss", "n_poll_infcons", "n_poll_rfns", "n_poll_nds", "n_poll_tcs", "n_poll_fks", "n_poll_fundds", "n_polledinfns", "n_poll_tys", "n_polledfss", "n_poll_infss", "n_pollscfdds", "n_poll_rfrd", "n_pollscfcs", "n_poll_ofns", "n_poll_fcs", "n_poll_fieldns", "n_poll_tds", "n_poll_rfsts", "n_poll_ofds", "n_polledfcons", "n_poll_fdds", "n_poll67ncs", "n_poll_fieldcons", "n_pollsfds", "n_poll67nds", "n_poll67fys"], "pe": ["pse", "ee", "pes", "je", "he", "me", "le", "enter", "ale", "ph", "wa", "fe", "ite", "pl", "que", "ve", "pa", "pp", "poke", "de", "oe", "p", "spe", "se", "e", "ase", "ep", "pri", "ope", "po", "ze", "qa", "ue", "pei", "ae", "PE", "py", "Pe", "peak", "ce", "ffe", "ste", "cl", "pc", "ple", "pen", "ke", "xe", "coe", "ge", "ape", "peer", "ps", "one", "pex", "per", "te"], "w": ["wl", "wp", "n", "g", "wa", "win", "rw", "iw", "sw", "fw", "d", "wb", "wt", "c", "wk", "work", "p", "we", "e", "wal", "q", "hw", " W", "v", "wait", "wave", "wall", "r", "wx", "wan", "kw", "aw", "web", "wu", "ww", "h", "widget", "ew", "W", "ow", "wd"], "poll_timeout": ["poll67timeout", "vote_timeout", "poll__limit", "run_timeout", "pollltimeout", "poll_delay", "poll_token", " poll_delay", "vote_slot", "run__timeout", "poll67limit", "run__frequency", "polllslot", "pollltoken", "run_delay", "run_limit", "poll__delay", "poll__timeout", "vote_token", "poll_slot", "poll_limit", "poll__frequency", "poll67frequency", " poll_time", "run__limit", "poll67delay", "run__delay", "run_frequency", "poll_frequency", "poll_time"], "poll_timeout_ns": ["poll_delay_ns", "poll_time_ds", "poll_timeout_ls", "poll_timeout_sec", "poll_time_ls", "poll_delay_sec", "poll_timeout_NS", "poll_timeout_ds", "poll_timeout_ms", "poll_delay_ls", "poll_time_NS", "poll_time_ns", "poll_delay_ms"], "tv0": ["TV0", "vi00", " tv6", "tv00", " tvng", "vt2", "tv6", "tv2", "TV2", "timeoutng", "tvng", "timeout0", "TV00", "timeout2", "vi0", "cvng", " tv2", "vt0", "cv2", "vi2", "cv6", "vt00", "cv0", "timeout6"], "rfds": ["rfns", "fbdd", "RFdd", "sfDS", "rfd", "RFda", "rbdds", "RFys", "sfds", "fDS", "fd", "fdes", "fbDS", "lfDS", "xfcs", "sfda", "fbdds", "sfDs", "sfns", "sfcs", "sfdds", "sfys", "sfdes", "rbns", "xfda", "fdd", "rfcs", "sfd", "lfys", "fbcs", "RFDS", "RFDs", "RFdes", "fbda", "rfda", "fDs", "fbd", "rfDs", "RFds", "rfdds", "RFd", "rfys", "rfdes", "fbds", "lfds", "rfdd", "rbda", "xfdds", "lfda", "rfDS", "xfns", "rbds", "fds"], "wfds": ["wcfda", "Wfsds", "wcfys", "swcfths", "Wfsld", "swcfds", "Wfys", "Wfdb", "wcfdds", "wfsnas", " wfys", "wfxths", "swfks", " wvds", "wfacys", "wfscs", "wfsts", "wfys", "walfrd", "wcfcs", "wvds", "wafrd", "wrfds", "wcfths", "wfsdb", "kwfuds", "wfsuds", "Wfld", "swfths", "wfssts", "kwrfuds", "winfld", "wfxds", "wlfrd", "wfuds", "wfxdds", "wfsda", "wlfys", "wfda", " wvda", "wfcs", "wcfds", "wlfds", "wfdb", "wfsds", "wfsdds", "wfsld", "wrfuds", "walfnas", "wxfuds", "wvys", "wfths", "wfxks", "wvda", "swfdds", "kwfdds", "wfacrd", "wcfks", "wfnas", "Wfsys", "wrfdds", "winfds", "wfld", "wffds", "swcfdds", "wlfnas", "winfdb", "wxfds", "swcfks", "wfks", " wvcs", "kwrfsts", "wafys", "wffld", "kwfsts", "wffdb", "wvcs", "Wfsdb", " wfda", "wfsths", "winfys", "wrfsts", "wfsrd", "wfacnas", "walfds", " wvys", " wfcs", "wfacds", "swfds", "wxfdds", "walfys", "kwrfds", "kwrfdds", "wafds", "wfsys", "wxfsts", "kwfds", "wfdds", "wfrd", "wafnas", "Wfds", "wffys", "wfsks"], "xfds": ["rfdb", "fxrd", "tfds", "cfd", "rfd", "cfdb", "cfdds", "sfds", "xfdd", "rfrd", "tfd", "sfda", "cfrd", "xfd", "fxd", "fcds", "xfda", "lfns", "xfths", "sfd", "sfths", "fxdd", "fifths", "fcd", "fcdd", "fxns", "xfdb", "fifda", "tfdb", "fcdds", "rfda", "cfdd", "cfds", "fifds", "fxths", "rfdds", "xfrd", "rfdd", "lfds", "cfda", "xfdds", "lfd", "xfns", "lfths", "cfns", "cfths", "fxda", "fxds", "tfda", "fifd"], "nfds": [" nrfds", "nfld", "naffdes", "naffdy", "nfmds", "nfmrs", " nfdes", " ncfrs", "ncfds", " nrfda", "nfd", "nFds", "ncfrs", " nfdy", "ncfda", " nfda", " nrfd", " nrfdds", " ncfd", "ncfdds", " ncfdds", "nfDS", "nrfd", " nfdds", "nrfda", " nrfDS", "nfbdes", "ntfds", " ncfds", "nfbds", "nfrs", " nfrs", "ncfDS", "nfdes", "ntfdes", " ncfld", "nfmld", "nFd", "ncfd", "nfbdds", "nfmdds", " ncfda", "nfbdy", "nrfDS", "nrfdes", "nfbda", "naffds", "nFdds", "ncfdy", "nFDS", "ncfdes", " nfDS", " ncfdes", "nfdy", "nrfrs", " nfd", " ncfdy", "nfdds", "naffdds", "ncfld", "nrfld", "nrfdy", "nfda", "nrfds", "nrfdds", "ntfd", " nrfdy", "ntfda", " nfld"]}}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n", "idx": 11117, "substitutes": {"bs": ["vs", "base", "bb", "ds", "abc", "blog", "lbs", "ba", "bid", "bas", "b", "ab", "gs", "iss", "fb", "bu", "ls", "pb", "qs", "cb", "ub", "bits", "rb", "rs", "banks", "BS", "bc", "os", "us", "js", "obs", "cs", "bl", "bps", "ubs", "bh", "ctx", "las", "lb", "abi", "bis", "bot", "bi", "sb", "ns", "blocks", "bytes", "ses", "fs", "css", "ss", "bing", "bes", "bos"], "snapshot_id": ["snapshot_path", "snapshot_name", "snapshot_Id", "snapshot_type", "snapaction_path", "snapaction_name", "snapaction_type", "snapshot_ids", "snapaction_id"], "drv": ["rtb", " drc", "hrp", " drsv", " drf", "Drf", "hrc", "parv", "srf", "srw", "drc", "Drb", "drb", "drf", "DRf", "DRb", " drb", " drw", "hrf", "srsv", "parw", "parf", "Drw", "srv", "hrw", "DRp", "parsv", "hrb", "drp", "rtc", "hrv", "DRv", "Drv", "drsv", "drw", "Drp", "rtv", "rtf", " drp"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint32_t val;\n\n\n\n    val = bswap32(cpu_inl(addr & IOPORTS_MASK));\n\n    return val;\n\n}\n", "idx": 11126, "substitutes": {"opaque": ["opec", " opad", "opacity", "opad", "operaque", " opacity", "optec", "optaque", "operacity", " opec", "optacity", "operad", "optad", "operec"], "addr": ["mac", "Address", "adr", "ord", "prefix", "pad", "point", "fd", "x", "pointer", "data", "ad", "slot", "config", "p", "obj", "ace", "ref", "arg", "cb", "amd", "ptr", "args", "dr", "host", "code", "device", "rt", "oa", "amp", "rc", "address", "kt", "dd", "dc", "pc", "offset", "node", "layer", "grad", "pos", "proc", "adder"], "val": ["vals", "Val", "ee", "cond", "base", "valid", "pass", "il", "len", "sel", "alt", "key", "all", "x", "fi", "VAL", "data", "slot", "el", "p", "arg", "ref", "obj", "lit", "value", "pt", "f", "la", "bc", "j", "rt", "fl", "py", "eval", "al", "v", "bl", "ind", "sl", "pre", "elt", "pc", "ret", "ann", "rl"]}}
{"project": "qemu", "commit_id": "5dafc53f1fb091d242f2179ffcb43bb28af36d1e", "target": 0, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n", "idx": 11127, "substitutes": {"f": ["l", "uf", "conf", "lf", "fo", "fen", "ff", "af", "sf", "def", "m", "fr", "info", "fd", "t", "x", "b", "k", "d", "i", "c", "data", "fb", "p", "ref", "e", "fp", "cf", "feed", "flow", "df", "of", "fa", "bf", "tf", "o", "fl", "v", "fx", "fun", "function", "old", "new", "full", "elf", "this", "fn", "form", "u", "h", "F", "file", "fs", "inf", "fi", "fe", "fc"], "len": ["count", "l", "lp", "base", "le", "z", "body", "ie", "dl", "fl", " length", "end", "err", "lang", "lon", "led", "url", "ld", "lf", "span", "n", "val", "id", "low", "limit", "index", "non", "min", "lt", "en", "list", "li", "Len", "lc", "ler", "seq", "str", "conn", "num", "buf", "data", "ls", "style", "size", "sl", "fun", "part", "fin", "hl", " lang", "lan", "dy", "lim", "doc", "line", "el", "lit", "js", "la", "ll", "name", "fat", "pos", "del", "length", "rev", "gen", "ln", "lin"]}}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n", "idx": 11128, "substitutes": {"hub": ["library", "ib", "grid", "bb", "blog", "conn", "lab", "src", "http", "mob", "builder", "trap", "project", "job", "pool", "config", "server", "pb", "cb", "ub", "gb", "driver", "feed", "plug", "bug", "Hub", "club", "tube", "host", "db", "pub", "sub", "lib", "route", "connection", "home", "proxy", "bot", "mod", "pc", "hop", "bus", "git", "node", "plugin", "hole", "client", "ob", "image", "interface", "url", "month", "box"], "port": ["parent", "PORT", "adr", "bb", "tr", "point", "porter", "http", "project", "pid", "iv", "pool", "ports", "serv", "bridge", "cp", "service", "p", "server", "pb", "target", "Port", "pt", "gp", "pm", "manager", "host", "pub", "device", "ort", "state", "proxy", "end", "address", "patch", "pc", "hop", "oper", "plugin", "type", "pod", "pair", "pos", "client", "ip", "proc", "pin", "transfer"], "peer": ["parent", "channel", "prov", "source", "owner", "worker", "info", "conn", "point", "http", "origin", "instance", "ker", "cer", "pp", "pool", "player", "bridge", "addr", "server", "p", "reader", "pb", "pro", "target", "driver", "rel", "pe", "ref", "socket", "er", "slave", "manager", "host", "device", "pub", "edge", "scope", "master", "connection", "remote", "state", "proxy", "entity", "address", "tp", "pc", "hop", "node", "enc", "root", "plugin", "type", "pod", "vr", "client", "ip", "dev", "iper", "interface", "transfer", "buffer", "ssl", "per", "chain"]}}
{"project": "FFmpeg", "commit_id": "c4e554701ec27b31b1b6396130b8bb2aaa0d4ad0", "target": 0, "func": "DVDemuxContext* dv_init_demux(AVFormatContext *s)\n\n{\n\n    DVDemuxContext *c;\n\n\n\n    c = av_mallocz(sizeof(DVDemuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->vst = av_new_stream(s, 0);\n\n    c->ast[0] = av_new_stream(s, 0);\n\n    if (!c->vst || !c->ast[0])\n\n        goto fail;\n\n    av_set_pts_info(c->vst, 64, 1, 30000);\n\n    av_set_pts_info(c->ast[0], 64, 1, 30000);\n\n\n\n    c->fctx = s;\n\n    c->ast[1] = NULL;\n\n    c->ach = 0;\n\n    c->frames = 0;\n\n    c->abytes = 0;\n\n    c->audio_pkt[0].size = 0;\n\n    c->audio_pkt[1].size = 0;\n\n    \n\n    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;\n\n    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;\n\n    c->vst->codec.bit_rate = 25000000;\n\n    \n\n    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;\n\n    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;\n\n   \n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; \n\n    \n\n    return c;\n\n    \n\nfail:\n\n    if (c->vst)\n\n        av_free(c->vst);\n\n    if (c->ast[0])\n\n        av_free(c->ast[0]);\n\n    av_free(c);\n\n    return NULL;\n\n}\n", "idx": 11140, "substitutes": {"s": ["l", "conf", "ts", "ks", "ds", "n", "g", "si", "in", "is", "w", "m", "src", "t", "b", "x", "d", "i", "gs", "service", "p", "server", "ls", "e", "se", "xs", "sq", "rs", "sec", "f", "os", "cs", "o", "sets", "v", "es", "S", "input", "south", "sl", "services", "ctx", "r", "ns", "sb", "storage", "spec", "u", "sys", "self", "options", "ses", "a", "ps", "fs", "css", "ss", "params", "settings", "sc"], "c": ["l", "cr", "arc", "oc", "cmp", "t", "x", "config", "cb", "cn", "ec", "cc", "ac", "code", "call", "v", "ce", "cur", "com", "nc", "ca", "fc", "n", "w", "tc", "b", "k", "i", "con", "ct", "e", "cd", "cf", "f", "bc", "current", "ic", "cl", "dc", "col", "this", "u", "lc", "ch", "anc", "sc", "g", "conn", "CV", "unc", "d", "cp", "cu", "coll", "cs", "rc", "xc", "enc", "cat", "vc", "cache", "mc", "uc", "co", "C", "rec", "p", "q", "cv", "ctx", "pc", "h", "cm", "ci", "cy"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int bytes, BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {0};\n\n    int ret = 0;\n\n    bool need_flush = false;\n\n    int head = 0;\n\n    int tail = 0;\n\n\n\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n\n                        bs->bl.request_alignment);\n\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                    MAX_WRITE_ZEROES_BOUNCE_BUFFER);\n\n\n\n    assert(alignment % bs->bl.request_alignment == 0);\n\n    head = offset % alignment;\n\n    tail = (offset + bytes) % alignment;\n\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n\n\n\n    while (bytes > 0 && !ret) {\n\n        int num = bytes;\n\n\n\n        /* Align request.  Block drivers can expect the \"bulk\" of the request\n\n         * to be aligned, and that unaligned requests do not cross cluster\n\n         * boundaries.\n\n         */\n\n        if (head) {\n\n            /* Make a small request up to the first aligned sector. For\n\n             * convenience, limit this request to max_transfer even if\n\n             * we don't need to fall back to writes.  */\n\n            num = MIN(MIN(bytes, max_transfer), alignment - head);\n\n            head = (head + num) % alignment;\n\n            assert(num < max_write_zeroes);\n\n        } else if (tail && num > alignment) {\n\n            /* Shorten the request to the last aligned sector.  */\n\n            num -= tail;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_write_zeroes) {\n\n            num = max_write_zeroes;\n\n        }\n\n\n\n        ret = -ENOTSUP;\n\n        /* First try the efficient write zeroes operation */\n\n        if (drv->bdrv_co_pwrite_zeroes) {\n\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                /* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end */\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            /* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             */\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        bytes -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n", "idx": 11141, "substitutes": {"bs": ["vs", "vals", "utils", "ib", "base", "bb", "ks", "ubis", "ds", "its", "is", "lbs", "bid", "bas", "http", "b", "ab", "gs", "iss", "fb", "ls", "pb", "obj", "ros", "gb", "ins", "cb", "bits", "outs", "rs", "banks", "BS", "bc", "js", "us", "plugins", "obs", "bt", "db", "cs", "bl", "eb", "bps", "ras", "sync", "ubs", "bh", "cons", "fps", "asts", "abi", "lb", "bot", "bis", "las", "bi", "ns", "sb", "blocks", "bel", "pos", "fs", "ses", "ps", "css", "ob", "ss", "bing", "bes", "bos"], "offset": ["parent", "alias", "location", "boot", "seq", "base", "inet", "timeout", "start", "len", "prefix", "info", "origin", "num", "shift", "i", "data", "slot", "config", "ref", "limit", "head", "from", "fp", "set", "off", "loc", "offs", "padding", "unit", "o", "abyte", "size", "alloc", "index", "slice", "order", "name", "align", "end", "address", "part", "position", "error", "oid", "root", "type", "tail", "online", "pos", "header", "url", "length", "Offset", "range", "reset"], "bytes": ["count", "zip", "devices", "seq", "byte", "boot", "words", "cells", "len", "ones", "rows", "files", "total", "ops", "data", "Bytes", "reads", "ls", "pieces", "parts", "steps", "used", "tes", "bits", "outs", "lines", "rets", "args", "pages", "body", "errors", "limits", "size", "bps", "es", "locks", "ns", "blocks", "seconds", "pos", "ips", "length", "nets", "units", "fee"], "flags": ["vals", "utils", "ts", "flag", "strings", "features", "sf", "stats", "mods", "alls", "fields", "fd", "files", "ils", "ops", "weights", "s", "mask", "ants", "util", "utf", "versions", "bits", "args", "lag", "rets", "types", "planes", "f", "plugins", "FLAG", "Flags", "fl", "rules", "fps", "fun", " Flags", "ags", "locks", "details", "bit", "ips", "options", "fs", "comments", "ret", "feat", "settings", "atts", "fts", "fee"], "drv": ["rdver", "drV", "Drf", " drf", "srf", "derp", "rdb", "srb", "Drb", "drb", "drf", "DRf", "DRb", " drb", "derv", "srV", "drav", "DRV", "hrver", "srv", "hrb", "drp", "hrv", "yrav", "yrb", "rdav", " drvin", " drV", "rdv", "DRv", "Drv", "dervin", "DrV", "hrav", "drvin", "derf", "drver", "rtv", "rtf", "yrver", " drp", "rtvin", "rtp", "yrv"], "qiov": [" qliv", " quno", " Qliv", " Qovi", " qovi", "qtliv", " Qiov", "qliv", " Quno", "quno", "qtiov", "qtuno", "qtovi", "qovi"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n", "idx": 11142, "substitutes": {"f": ["l", "rf", "lf", "fo", "fen", "g", "ff", "n", "af", "sf", "w", "m", "fr", "info", "fd", "b", "t", "k", "x", "fw", "d", "c", "fb", "p", "ref", "e", "fp", "cf", "feed", "df", "j", "bf", "tf", "o", "fx", "r", "elf", "u", "form", "self", "F", "file", "fs", "buff", "fe", "fc"], "q": ["l", "dq", "conf", "qt", "plus", "g", "view", "w", "info", "id", "k", "que", "x", "quick", "d", "iq", "c", "qu", "s", "work", "p", "qq", "qs", "qa", "e", "queue", "cf", "sq", "flow", "quest", "j", "v", "sync", "query", "r", "req", "check", "cl", "u", "Q", "question"], "i": ["l", "hi", "ui", "di", "start", "si", "n", "zi", "key", "info", "xi", "id", "t", "x", "b", "ini", "k", "d", "c", "ji", "p", "ix", "uri", "e", "yi", "mu", "mini", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "phi", "qi", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "io", "ni", "ri", "jj", "fi", "iu"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)\n\n{\n\n    uint32_t entry;\n\n    EHCIQueue *q;\n\n    int reload;\n\n\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    q = ehci_find_queue_by_qh(ehci, entry);\n\n    if (NULL == q) {\n\n        q = ehci_alloc_queue(ehci, async);\n\n    }\n\n    q->qhaddr = entry;\n\n    q->seen++;\n\n\n\n    if (q->seen > 1) {\n\n        /* we are going in circles -- stop processing */\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        q = NULL;\n\n        goto out;\n\n    }\n\n\n\n    get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);\n\n\n\n    if (q->async == EHCI_ASYNC_INFLIGHT) {\n\n        /* I/O still in progress -- skip queue */\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n        goto out;\n\n    }\n\n    if (q->async == EHCI_ASYNC_FINISHED) {\n\n        /* I/O finished -- continue processing queue */\n\n        trace_usb_ehci_queue_action(q, \"resume\");\n\n        ehci_set_state(ehci, async, EST_EXECUTING);\n\n        goto out;\n\n    }\n\n\n\n    if (async && (q->qh.epchar & QH_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n", "idx": 11143, "substitutes": {"ehci": ["ekci", "ahCI", "helmcit", "hessci", "ehsci", "ehcin", "phercit", "ahcit", "enguci", "hessCI", "khco", "ahuci", "ohcu", "khci", "hlci", "hldi", "evcit", "hesscci", "ehCI", "ethersci", "ghcu", "etherii", "ethdi", "ethco", "engdi", "phercci", "hanci", "ehdi", "ghci", "ethercit", "hesscu", "ohcit", "pherii", "ghcci", "hesski", "ahcci", "pherci", "ohki", "hlsci", "ahco", "ahki", "ekii", "hlii", "hlCI", "ahii", "hessdi", "khdi", "ghdi", "hesssci", "ohsci", "ehii", "ehcu", "ohdi", "ehcci", "ehco", "hlcci", "helmci", "ohii", "evii", "hlcu", "ehcit", "khcu", "ekuci", "ohci", "hansci", "hancit", "khki", "hanii", "evci", "khcin", "ekdi", "ahsci", "ohcin", "helmdi", "ethcin", "ahci", "ahcu", "ahcin", "khii", "ahdi", "engci", "ohcci", "ethci", "helmcin", "hlki", "etherci", "ehki", "ehuci", "engii", "evcci"], "async": ["ASsync", "asynchron", "asnc", "rasynchron", " ascel", "assync", "againync", "assynchron", "rasynchronous", "asyn", " asynchron", "acsync", "inasyn", "rassync", " assync", "againynchronous", "ASyn", "ascel", "Asynchron", "assnc", "Asynchronous", "Asyn", "rasync", "acyn", "assynchronous", "ASync", "Assync", "rasnc", " asynchronous", "ASnc", "inasynchronous", "inasync", "acync", "asssync", "againcel", " asyn", "Async", "inascel", "rasyn", "asynchronous", "againyn", "assyn", "ASynchronous", " asnc", "ASynchron", "acynchronous"], "entry": ["l", "channel", "element", "Entry", "enter", "ry", "source", "key", "record", "id", "nt", "ent", "card", "d", "service", "data", "qu", "server", "reader", "qa", "e", "ace", "queue", "se", "feed", "ue", "f", "ie", "next", "la", "index", "route", "parse", "inc", "rc", "input", "query", "event", "connection", "cur", "address", "ga", "ident", "offset", "Q", "row", "ge", "her", "image", "insert", "lc", "cache", "cell", "match"], "q": ["l", "dq", "qt", "sh", "pg", "ack", "g", "comment", "quit", "view", "w", "id", "k", "que", "t", "z", "quick", "update", "d", "i", "iq", "post", "c", "qu", "config", "qq", "p", "qa", "qs", "e", "queue", "request", "pe", "cf", "cli", "bug", "sq", "ue", "f", "eq", "quest", "qv", "requ", "ck", "v", "parse", "ce", "sync", "input", "query", "event", "cur", "req", "qi", "check", "cl", "get", "u", "h", "command", "client", "Q", "charge", "cache", "ch", "cmd", "question"], "reload": ["REloads", "REresh", "reloads", "Reloaded", "reloaded", "REload", " reloads", "Reresh", "Reloads", "Reload", " reresh", "REloaded", "reresh", " reloaded"], "seen": ["sem", "finished", "session", "registered", "opened", "visible", "ended", "started", "view", "second", "selected", "matched", "killed", "saw", "known", "kept", "written", "ordered", "hidden", "given", "expected", "changed", "sent", "shared", "heard", "received", "done", "served", "see", "failed", "confirmed", "eye", "sex", "since", "shown"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n", "idx": 11167, "substitutes": {"s": ["l", "conf", "sg", "ts", "ks", "ds", "is", "si", "n", "g", "its", "features", "stats", "m", "info", "changes", "t", "b", "ims", "ops", "d", "i", "gs", "service", "c", "p", "ls", "server", "qs", "e", "tests", "request", "se", "xs", "sq", "js", "rs", "f", "os", "cs", "sym", "o", "sets", "S", "es", "sync", "sie", "states", "services", "r", "ches", "sb", "ns", "hs", "details", "ms", "u", "sys", "rates", "comments", "ses", "ps", "fs", "su", "a", "ss", "settings", "ssl"], "tm": ["ym", "ui", "ts", " t", "em", "ta", "tr", "om", " mem", "m", "tc", "temp", "mr", "dt", "t", " m", "tt", "mm", "tz", "mem", "irm", "gm", "nam", "metadata", "time", "hm", "tick", "tmp", "ac", "rt", "tom", "fm", "trace", "mi", "timer", "track", "tis", "ti", "md", "mod", "htm", "sm", "tx", "tp", "tk", "tri", "tim", "dm", "sim", "tem", "mt", "ram", "math", "text", "M", "rm", "TM", "te"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void tosa_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    PXA2xxState *mpu;\n\n    TC6393xbState *tmio;\n\n    DeviceState *scp0, *scp1;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa255\";\n\n\n\n    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);\n\n\n\n    memory_region_init_ram(rom, NULL, \"tosa.rom\", TOSA_ROM, &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n    tmio = tc6393xb_init(address_space_mem, 0x10000000,\n\n            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));\n\n\n\n    scp0 = sysbus_create_simple(\"scoop\", 0x08800000, NULL);\n\n    scp1 = sysbus_create_simple(\"scoop\", 0x14800040, NULL);\n\n\n\n    tosa_gpio_setup(mpu, scp0, scp1, tmio);\n\n\n\n    tosa_microdrive_attach(mpu);\n\n\n\n    tosa_tg_init(mpu);\n\n\n\n    tosa_binfo.kernel_filename = kernel_filename;\n\n    tosa_binfo.kernel_cmdline = kernel_cmdline;\n\n    tosa_binfo.initrd_filename = initrd_filename;\n\n    tosa_binfo.board_id = 0x208;\n\n    arm_load_kernel(mpu->cpu, &tosa_binfo);\n\n    sl_bootparam_write(SL_PXA_PARAM_BASE);\n\n}\n", "idx": 11193, "substitutes": {"machine": ["mac", "boot", "base", "arm", "comment", "normal", "m", "info", "model", "template", "instance", "project", "service", "data", "config", "server", "motion", "app", "computer", "bug", "hard", "Machine", "slave", "mode", "manager", "host", "linux", "module", "process", "connection", "space", "state", "object", "loader", "inner", "user", "address", "part", "node", "controller", "link", "self", "sim", "message", "image", "cache", "mom", "M", "mc", "database"], "cpu_model": ["memory_model", "gpu_machine", "gpu_module", "memory0parent", "cpubookmode", "cpu_source", "cpufsource", "cpu0memory", "cpufmemory", "gpu_mode", "memory0memory", "memory_parent", "gpu_manager", "cpubookprocessor", "cpu_scale", "gpu_model", "cpufmodel", "cpu_device", "gpu_processor", "cpubookmodel", "memory_memory", "cpu_manager", "cpu_module", "memory_source", "cpufparent", "cpu0model", "cpubookscale", "cpubookmodule", "cpu_parent", "cpu_processor", "gpu_device", "cpu0source", "gpu_scale", "cpubookmachine", "cpu0parent", "cpu_machine", "memory0source", "cpu_memory", "memory0model", "cpu_mode"], "kernel_filename": ["processoringfilename", "kernelingmaximum", "kernelacfile", "processor_document", "kernelingfilename", "kernel_document", "kernel___source", "kernel___file", "processoringname", "kernelacfilename", "processoringmaximum", "processor_filename", "kernelingdocument", "linux_file", "processor_maximum", "kernel___metadata", "system_filename", "kernelacmetadata", "kernel_maximum", "kernel_location", "kernel_directory", "kernelingname", "network_location", "system_file", "system_metadata", "kernel_name", "kernelacsource", "kernel_source", "system_source", "network_sheet", "network_directory", "kernel_sheet", "processoringdocument", "kernel___filename", "kernel_fn", "kernel_metadata", "processor_name", "linux_filename", "kernel_file", "network_filename", "linux_fn", "linux_directory"], "kernel_cmdline": ["kernel_mden", "kernel_pathline", "kernel_cmdside", "kernel_maclin", "kernel_commandside", "kernel_commandLine", "kernel_mdlin", "kernel_configfile", "kernel_callfile", "kernel_callment", "kernel_cmdfile", "kernel_deadline", "kernel_commandl", "kernel_macen", "kernel_callLine", "kernel_pathfile", "kernel_commandfile", "kernel_mdline", "kernel_commandline", "kernel_commanden", "kernel_mdLine", "kernel_deadLine", "kernel_configside", "kernel_cmdlin", "kernel_commandlin", "kernel_deadment", "kernel_configline", "kernel_cmdLine", "kernel_commandment", "kernel_mdl", "kernel_deadfile", "kernel_cmdment", "kernel_callline", "kernel_cmdl", "kernel_cmden", "kernel_macline", "kernel_macl", "kernel_pathside"], "initrd_filename": ["initrt_package", "initrd___file", "initrdjfilename", "initrd_file", "initattrjusername", "initrd_package", "initrd_username", "initrd_sequence", "initrd2filename", "initrd___package", "initrt_memory", "initrd_memory", "initrd___filename", "initrd2memory", "initattr_name", "initrd2file", "initrd___location", "initrdjusername", "initrd2name", "initrt_filename", "initattrjfilename", "initrd_name", "initrt_files", "initrdjplatform", "initattrjplatform", "initattr_filename", "initrt_file", "initrdjname", "initrd_location", "initattr_platform", "initattrjname", "initrd_platform", "initattr_username", "initrt_name", "initrt_location", "initrt_sequence", "initrd_files"], "address_space_mem": ["address_space_mm", "address_space33name", "address_network67sum", "address_spacemmname", "address_space67sum", "address_network67memory", "address_space_view", "address_pace_name", "address_network_memory", "address_network_mem", "address_service_mm", "address_space_ram", "address_spacemmview", "address_space2mm", "address_space_memory", "address_space_sum", "address_space_Mem", "address_network_sum", "address_space67memory", "address_network67mem", "address_space2memory", "address_space_min", "address_space67mem", "address_pace_view", "address_space2mem", "address_space2ram", "address_pace_mem", "address_service_ram", "address_space_name", "address_service_mem", "address_space2min", "address_service_Mem", "address_space2Mem", "address_space33mem", "address_spacemmmem", "address_space33view"], "rom": ["cpu", "cr", "gra", "chrom", "param", "rem", "arm", "region", "mor", "prom", "ray", "aram", "dem", "container", "mem", "serv", "vm", "sam", "ROM", "crypt", "ros", "drm", "pro", "reg", "memory", "coll", "mode", "rome", "resource", "graph", "REM", "roy", "r", "norm", "rim", "com", "rar", "roma", "ran", "ro", "sim", "cm", "rx", "rg", "rum", "ram", "cmd", "rob", "core", "roc", "rm", "gram"], "mpu": ["cpu", "ipus", "ipcu", "ppc", "capU", "capus", "mpui", "copus", "copu", "copcu", "capo", "mmi", " mpl", "mpU", "mmo", "MPcu", "ippus", " mpi", "MPo", "ipo", "cpcu", "mpo", "mmou", "mmu", " mpo", "ippu", " mpus", "mpi", "ippui", "mpc", "MPus", "capu", "cpo", "mpl", "mpou", "ppui", "ppl", "ppo", "cpui", "ppi", "copo", "MPU", "ppu", "ppcu", "ppU", "cpus", "mmcu", " mpc", " mpou", "mpcu", "mmc", "mmus", "ppus", "MPu", "ipu", "ippo", "mpus", "mml", "ppou"], "tmio": ["mmIO", "txIO", "gpios", "tgiol", "txios", "smri", "tgio", "tmrio", "txio", "mmiol", "mpios", "tgri", "smiol", "memro", "gpro", "tmIO", "smio", "gpiol", "termio", "tmius", "tmiol", "txiol", "mpiol", "memio", "gpio", "gpius", "tgrio", "mmio", "termro", "mpIO", "gpri", "memios", "termius", "gprio", "termios", "mpio", "tmios", "tmro", "tmri", "memius", "mmios", "smrio"], "scp0": ["scpp2", " scp13", "scpc2", "ScP1", "ScP0", "scp50", " scpor", " scP50", "scpp1", " scp10", "scp2", " scPor", "scapor", "scmp0", " scp2", "scmp10", "scP0", "ScP3", "scpp13", " scP0", "scpp50", "Scp0", "scap2", "scpor", "scpp0", "scpp10", "scpc1", "scap50", "scppor", " scp50", "scP3", "scpc3", "scpc0", "scP50", "Scp3", "Scp1", "ScP2", "scP1", "scmp1", "scap0", "scp13", "Scp2", "scPor", " scP2", "scP2", "scmp13", "scp10", "scp3"], "scp1": [" scm0", "scp61", " scv1", "scp2", "scv4", "scm1", "scp4", "scp7", "sccp7", " scp2", "scap7", "scm0", "scP7", " scm1", "scv1", "scP0", "scm61", "scb1", "scb4", " scv2", "scm2", " scp61", " scp7", "scv61", "scap2", " scap7", " scm61", "scb0", " scap0", "sct61", " scv0", " scap1", "scb2", "sccp0", "sct0", "sct2", " scm2", "scv0", "sccp1", " scp4", "sct1", "scP1", "sccp2", "scP4", "scap0", "scP2", "scv2", " scv4", " scap2", "scap1"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n", "idx": 11202, "substitutes": {"ibs": ["obg", "iws", "iwS", "bbss", "obS", "ribg", " ibS", " ibis", " ibss", "hwS", "ipS", "hws", "ibS", "iwis", "iwsys", "obs", "ibg", "gifs", "ribs", "iwss", "ribS", "bbS", "ibsys", "ibis", "gifS", "bbs", "gifsys", "ipg", "ips", "hwsys", "ibss", "bbis"], "cmd": ["count", "mac", "gn", "seq", "kg", "dom", "dict", "id", "conn", "path", "buf", "c", "cp", "head", "config", "cd", "cb", "cod", "cc", "mode", "op", "code", "ctrl", "call", "ck", "msg", "nd", "chan", "ind", "input", "module", "route", "pipe", "md", "ctx", "req", "mod", "Cmd", "check", "cl", "dc", "cat", "grad", "comm", "command", "cfg", "client", "crit", "pkg", "gen", "force", "bind"], "cmd_len": [" cmd_val", "cmd_length", "cmd_Len", "cmdslen", " cmd_length", "cmd_val", " cmd_Len", " cmdsLen", "cmdsLen", "cmdslength", " cmdslen", " cmdsval", "cmdsval", " cmdslength"], "rsp": ["Rp", "Rserv", " resp", " rp", "rp", "rdsp", "Rsc", "rrp", "rserv", "rdSp", "rrserv", "rrsc", "rdesp", " rSp", "rresp", "rdsc", " rserv", " rsc", "rSp", "rrsp", "rrSp", "resp", "Rsp", "rsc"], "rsp_len": ["rsc_length", "rsc_limit", "rsp2Len", "rsp_Len", "rsc_Len", "rsc_len", "rsp2limit", "rsp_limit", "rsp2len", "rsp_length", "rsp2length"], "max_rsp_len": ["max_rsp_l", "max_rsc_length", "max_rsp_length", "max_rsc_len", "max_rsp_val", "max_rsc_l", "max_rsc_val"], "sens": [" sened", "gractor", "gENS", "pENS", "fensor", " sets", "censing", "sened", "cents", "practor", "gents", "pens", "gens", "fensing", " sensing", "dens", "dENS", "statensor", "censes", "Sens", "statents", "sents", "fenses", "densor", "Sractor", "fens", "statENS", "fENS", "sets", "Sensor", "fents", "Sents", "sensing", "statens", "Sened", "dents", "sensor", " sensor", "pensor", "sENS", "gensor", " sENS", "gets", "gened", "sractor", "Sets", " senses", " sents", "senses", "SENS", "cens"]}}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n", "idx": 11235, "substitutes": {"base": ["count", "area", "scale", "start", "normal", "source", "prefix", "pad", "info", "id", "model", "bas", "b", "x", "bare", "pa", "i", "basic", "data", "Base", "c", "addr", "server", "p", "ase", "local", "hard", "f", "mode", "padding", "db", "unit", "size", "index", "fake", "name", "space", "proxy", "pre", "address", "offset", "root", "kit", "type", "file", "ip", "ma", "out", "site", "cache", "api", "core", "force", "buffer"], "irq": ["rqi", "riq", "riqi", "rqs", "irqu", "irquire", "dirq", "ironq", "irtq", "arique", "irtqu", " irqi", "ironk", "rik", "ironqs", "irtk", "rq", "dirqu", "arqu", "iriq", "ironqi", "ariqu", "rk", "arinqu", "arq", "ariqs", "ierqual", "irtqi", "irqs", "rinq", "rinque", "ierquire", "ark", "ierqu", " irk", "irk", "riqs", "rinqu", "ierq", "iriquire", " irqu", "dirqs", "iriqu", "irqual", "dirque", "arqi", "arinq", "arinqual", "ariq", "iriqual", "arinquire", "irque", "rinqs", "irqi"], "fclk": ["fflq", "Fclks", "fCLf", "faclk", "Fclok", "fslq", "fflk", "FclK", "Fclk", "fslp", "cclf", "fCLq", "fplks", "fCLk", "cplp", "flicks", "ffln", "Fclf", "fClq", "flicf", "fClks", "FplK", "cclk", "cclq", "Fclq", "fCLks", "fplf", "fclok", "fplk", "cplf", "fflf", "fplq", "Fplk", "fcln", "Fpln", "fplK", "fflp", "fCLK", "fslk", "fpln", "facln", "faclK", "fflok", "flicq", "faclok", "fplok", "Fcln", "fclf", "fflK", "flick", "fclks", "fclp", "cplq", "cplk", "cclp", "fclK", "Fplks", "fClk", "fplp", "Fplq", "fslf", "Fplok", "fclq", "fClK"], "iclk": ["iscelp", "icelp", "icdlk", "iscelk", "icilk", "isclk", "icelk", "iscelq", "icdlka", "iclp", "icdlq", "icilq", "iclka", "icilka", "iclq", "icilp", "isclka", "isclq", "icdlp", "iscelka", "icelka", "icelq", "isclp"], "txdma": ["rxfma", "txnma", "txdlmas", "txfmas", "txdca", "txfca", "rxfmas", "txdlma", "rxdca", "txfma", "txdlca", "rxdla", "rxfla", "txdmas", "txnla", "rxdmas", "rxfca", "txfla", "txdlla", "txnmas", "txnca", "txdla"], "rxdma": ["rxema", "nrxdca", "rxdna", "rxfma", "rxcca", "rxeda", "rxfda", "rxcda", "rxfna", "nrxdma", "rxdca", "rxeca", "nrxeda", "rxfca", "rxdda", "nrxena", "nrxeca", "nrxdda", "rxcma", "rxcna", "nrxdna", "rxena", "nrxema"], "label": ["l", "alias", "reason", "nob", "field", "scale", "comment", "prefix", "hide", "key", "lab", "ab", "block", "data", "el", "target", "loc", "dl", "unit", "bl", "eval", "abel", "msg", "description", "route", "name", "input", "align", "address", "err", "desc", "unknown", "error", "col", "uni", "message", "charge", "cell", "text", "Label"], "chr": ["ichri", "CHrt", "chri", "CHr", " chrs", "ichR", "Chrc", "chrs", " chrt", "Chrs", " chR", "Chr", " chrc", "echr", "CHri", "echrs", "ichrt", "Chrb", "chrt", " chri", "CHR", "echrc", "chR", " chrb", "echrb", "chrc", "ichr", "chrb"], "s": ["l", "ings", "session", "sg", "ts", "is", "si", "g", "ds", "n", "its", "rows", "w", "m", "b", "t", "ops", "d", "i", "gs", "sa", "c", "p", "ls", "e", "lines", "sq", "js", "socket", "f", "os", "rs", "cs", "sym", "o", "sets", "S", "v", "es", "sync", "sl", "services", "ches", "als", "ns", "sb", "spec", " shares", "u", "sys", "single", "ips", "ses", "a", "su", "fs", "ures", "ss", "ows", "settings", "ssl", "ves"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)\n\n{\n\n    VHDDynDiskHeader *dyndisk_header =\n\n        (VHDDynDiskHeader *) buf;\n\n    size_t block_size, num_bat_entries;\n\n    int i;\n\n    int ret = -EIO;\n\n\n\n    // Write the footer (twice: at the beginning and at the end)\n\n    block_size = 0x200000;\n\n    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);\n\n\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    // Write the initial BAT\n\n    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    memset(buf, 0xFF, 512);\n\n    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n\n        if (write(fd, buf, 512) != 512) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    // Prepare the Dynamic Disk Header\n\n    memset(buf, 0, 1024);\n\n\n\n    memcpy(dyndisk_header->magic, \"cxsparse\", 8);\n\n\n\n    /*\n\n     * Note: The spec is actually wrong here for data_offset, it says\n\n     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.\n\n     */\n\n    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);\n\n    dyndisk_header->table_offset = be64_to_cpu(3 * 512);\n\n    dyndisk_header->version = be32_to_cpu(0x00010000);\n\n    dyndisk_header->block_size = be32_to_cpu(block_size);\n\n    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);\n\n\n\n    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));\n\n\n\n    // Write the header\n\n    if (lseek(fd, 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (write(fd, buf, 1024) != 1024) {\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 11268, "substitutes": {"fd": ["uf", "dra", "cdn", "cond", "gd", "lf", "af", "sf", "die", "fed", "wb", "fw", "d", " fid", "fb", "bd", "reader", "cb", "fp", "driver", "feed", " f", "rb", "writer", "df", "f", "dl", "deck", "db", "dir", "bf", "FH", "fl", "fm", "draft", "fx", "fat", "buffer", "dd", "raf", "FD", "dc", "fn", "grad", "handler", "file", "flo", "fs", "ft", "func", "buff", "wd", "fi", "fc"], "buf": ["true", "pad", "fw", "fb", "bd", "config", "pb", "cb", "feed", "loc", "bt", "cas", "usb", "bus", "buff", "pkg", "fi", "buffer", "fab", "fc", "b", "c", "cf", "xff", "tmp", "bc", "f", "db", "bf", "dc", "handler", "bag", "ru", "seq", "tab", "ff", "src", "wb", "cp", "data", "fp", "ptr", "rb", "fa", "alloc", "exc", "Buff", "rc", "bh", "fx", "raw", "done", "sb", "fin", "fn", "vec", "cmd", "br", "uc", "uf", "Buffer", "filename", "wav", "batch", "reader", "queue", "cv", "ctx", "raf", "null", "proc", "feat"], "total_sectors": ["total_pserets", "total_serctors", "total_sections", "total_gectors", "total_selements", "total_bections", "total_psections", "total_pections", "total_psegment", "total_serrets", "total_psectors", "total_segments", "total_serets", "total_pelements", "total_sergment", "total_sergments", "total_bectors", "total_gegment", "total_segment", "total_pectors", "total_pegments", "total_psegments", "total_begments", "total_belements", "total_gegments", "total_pselements", "total_gerets"], "dyndisk_header": ["dyndisc_layer", "dyndraw_player", "dyndisc_server", "dyndisksxlayer", "dyndrawtheerror", "dyndise_dr", "dyndisk_layer", "dyndisks_back", "dyndink_metadata", "dyndiskxback", "dyndink_size", "dyndiskfmetadata", "dyndrawtheversion", "dyndisk_buffer", "dyndisksxback", "dyndisk_player", "dyndiskxmetadata", "dyndise_handler", "dyndisks_layer", "dyndisk_back", "dyndisk__dr", "dyndisk_writer", "dyndisk_dr", "dyndiskdheaders", "dyndisksxmetadata", "dyndiskfback", "dyndiskfoffset", "dyndink_header", "dyndiskflayer", "dyndink_writer", "dyndisc_offset", "dyndraw_error", "dyndink_layer", "dyndiskdheader", "dyndink_buffer", "dyndise_writer", "dyndise_reference", "dyndisks_metadata", "dyndisk_message", "dyndrawtheheader", "dyndisk_error", "dyndiskxlayer", "dyndiskOheaders", "dyndisk__layer", "dyndisk_server", "dyndisc_header", "dyndise_message", "dyndise_layer", "dyndisk_size", "dyndiskdlayer", "dyndisks_header", "dyndisksxheader", "dyndiskfserver", "dyndiskOheader", "dyndisk_headers", "dyndiskxheader", "dyndraw_header", "dyndisktheversion", "dyndisk__header", "dyndisk_handler", "dyndiskOreference", "dyndisk_version", "dyndisk_metadata", "dyndiskdmetadata", "dyndiskOwriter", "dyndisktheerror", "dyndisktheplayer", "dyndiskfheader", "dyndraw_version", "dyndisk_offset", "dyndise_server", "dyndise_header", "dyndisktheheader", "dyndrawtheplayer", "dyndink_headers", "dyndisk_reference", "dyndise_headers", "dyndisk__writer"], "block_size": ["block_content", "block64weight", "server_storage", "blockalweight", "device_size", "block_length", "device_length", "block64speed", "block_type", "block64sized", "group_fee", "block___offset", "device_type", "server_size", "block_speed", "cache_scale", "group_length", "block_offset", " block_sized", "device_scale", "block_storage", "serveralsize", "block64time", "block_strength", "block_limit", "server_speed", "server_weight", "block64size", "block_time", "cache_strength", "block___content", " block_offset", "blockalstorage", "block___size", "serveralspeed", "block_fee", "block_mini", "group_size", "block_weight", "block_sized", "group_group", "serveralweight", "blockalsize", " block_content", "block64storage", "block_scale", "blockalspeed", "block64limit", "block_group", "cache_mini", " block_time", "cache_size", " block_limit", "serveralstorage"], "num_bat_entries": ["num_bat_ntrs", "num_bat_ctry", "num_bat_Entries", "num_bat_ntrys", "num_bat_entues", "num_bat_contrying", "num_bat_entrying", "num_bat_ntries", "num_bat_contrys", "num_bat_ntances", "num_bat_entry", "num_bat_Entrys", "num_bat_centrys", "num_bat_centrs", "num_bat_ntories", "num_bat_incries", "num_bat_addories", "num_bat_addances", "num_bat_centories", "num_bat_ctries", "num_bat_centries", "num_bat_contry", "num_bat_centues", "num_bat_addry", "num_bat_entrs", "num_bat_incrows", "num_bat_incrs", "num_bat_centances", "num_bat_entrys", "num_bat_incry", "num_bat_incues", "num_bat_addries", "num_bat_centry", "num_bat_entrows", "num_bat_ntrying", "num_bat_entances", "num_bat_ctrys", "num_bat_centrows", "num_bat_entories", "num_bat_contries", "num_bat_Entry", "num_bat_ctrs", "num_bat_ntues", "num_bat_ntry", "num_bat_Entrying", "num_bat_ntrows"], "i": ["count", "l", "oi", "hi", "ui", "di", "base", "it", "start", "n", "si", "g", "in", "zi", "id", "info", "xi", "m", "b", "ami", "ini", "d", "c", "ji", "p", "uri", "e", "yi", "mu", "split", "mini", "eni", "j", "ai", "o", "multi", "index", "gi", "ti", "mi", "phi", "chi", "inner", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "ni", "y", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 11303, "substitutes": {"bs": ["vs", "ts", "bb", "ds", "bp", "b", "gs", "iss", "fb", "ls", "pb", "qs", "gb", "ins", "outs", "rs", "us", "BS", "os", "bc", "js", "obs", "cs", "aws", "bl", "bh", "state", "lb", "ns", "sb", "ps", "ses", "fs", "ss", "bos"], "psn_tab": ["psn2ab", "psn2tab", "psrn_loop", "psrn_tab", "pssn_ab", "psn_ab", "pssn_buf", "pssn_tmp", "psrn_Tab", "psn_Tab", "psn2loop", "pssn_tab", "psn2Tab", "psrn_ab", "psn_tmp", "psn_buf", "psn_loop"], "s": ["conf", "session", "is", "ds", "g", "m", "b", "ops", "sa", "c", "service", "p", "ls", "e", "js", "os", "f", "cs", "sym", "o", "aws", "S", "south", "states", "sl", "state", "services", "sup", "bis", "sn", "ns", "sb", "storage", "spec", "sys", "ses", "ps", "ss", "settings", "ssl"], "sn_info": ["sn_INFO", "nsJfo", "snpinfo", "snapappInfo", "snappinfo", "snJfo", "nsJinfo", "wn_info", "sw_part", "snametab", "wn_error", "snacinfo", "snpfo", "snacdata", "snninfo", "snap_Info", "snameinf", "sl_private", "sn_data", "nn_data", "snapJinit", "snactab", "snJinf", "sn_error", "snacinf", "snJinit", "snalldata", "snappstart", "sn__tab", "snapappinfo", "sn_init", "snap_inf", "sn_Info", "wn_field", "ns_inner", "sn_field", "nn_hand", "sw_info", "snapJinfo", "sn__manager", "snapJinf", "sw_start", "snperror", "snapacinfo", "sn_start", "ns_error", "nn_info", "snJinner", "ns_open", "snapJdata", "snamedata", "snap_data", "ns_comment", "sn_part", "snapacdata", "nsJerror", "sn_open", "snapappname", "sn__info", "snerinfo", "snapperror", "snncomment", "snnmanager", "snPinfo", " sn_manager", "snpinner", "sn_private", "swPpart", "sn_hand", "snappid", "ns_manager", "sl_error", "snallhand", "wn_id", "swPstart", "snap_init", "sn_manager", "snJinfo", "snerprivate", "snerINFO", "snJdata", "swPinfo", "snappfield", "sn_comment", "ns_info", "snapappstart", "snap_info", "snameinfo", "sn_fo", "sn_id", "sn__inf", "snappInfo", "sn_inf", "snPpart", "snererror", "swPid", "snnopen", "snallinfo", "snappname", "snapactab", "sn_inner", " sn_inf", "nsJinner", "ns_fo", "snap_tab", "snPid", "snapacinf", "snJerror", "snPstart", "sn_name", "sl_INFO", "snap_start", "sl_info", "sw_id"], "sn_tab": ["snPab", "sn__account", "sn_count", "snnapp", "nn_account", "sn_loc", "sn_app", "nn_app", "snPaccount", "sn__tab", "nn_count", "swPaccount", "nn_tab", "sw_info", "sw_account", "snncount", "pn_tab", "pn_space", "sn__info", "sw_ab", "sn_space", "snPinfo", "sw_loc", "swPab", "snntab", "sn_lab", "pn_info", "swPinfo", "sw_tab", "snPtab", "sn__ab", "sn_ab", "swPtab", "sn_account", "snnaccount", "pn_lab"], "i": ["oi", "l", "hi", "gu", "ui", "di", "it", "start", "n", "si", "zi", "m", "id", "info", "xi", "iw", "k", "x", "b", "z", "ami", "ini", "d", "pointer", "c", "ji", "p", "ix", "uri", "e", "yi", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "name", "ti", "phi", "gi", "mi", "isin", "r", "abi", "qi", "ij", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu"], "snap_count": ["snap_check", "gap_size", "record_count", "snapfcount", " snap_weight", "spot_count", "sn_number", "snapfaddress", "capt_check", "sn_count", " snap_check", "snap_force", "gap_check", "snapfsize", "snap67index", "snap_depth", "recordfcount", "snapPloop", "snapPhandle", "spotxtotal", "snap_limit", "snap_number", "snap_index", "gap_force", "snap_address", "snapPcheck", "snapPlimit", "recordfindex", "snap_total", "snapNloop", "snapNcheck", "recordfsize", "capt_handle", "spot_time", "spot_total", "spotxtime", "snapFtotal", "record_size", "snapNhandle", "snap67address", "snapencast", "snapPcount", " snap_number", "snapFcount", "gap_count", "snapPweight", "snap_handle", " snap_size", "snapJcount", " snap_len", "snap_weight", "snap64check", "snap64size", "snapencount", " snap_depth", "spotxcount", " snap_cast", "snap67size", "snap64force", "snap_loop", "snapJcast", "snapFtime", "snap_size", "snap64count", "capt_count", "recordfaddress", "snapencheck", "snapxcount", "snap_time", "snap_cast", "snapNcount", "snapxtotal", "capt_loop", "snapxtime", "sn_cast", " snap_limit", "snapJcheck", "snap_len", "snap67count", "record_index", "record_address", "snapfindex"], "snaps": ["knats", "knapps", "snap", "slips", "snops", "snps", "synaps", "knaps", "spps", "clips", "synapses", "swabs", "knapes", "snats", "swapses", "snapes", "naps", "slap", "knapses", "nips", "snabs", "knops", " snops", "swap", "knabs", "swapes", "snapps", " snabs", "slapses", "nap", "snasts", " snips", "snapping", "sliffs", "snips", "sniffs", "swips", "swiffs", "slasts", " snapping", "spapps", "swops", "cliffs", "nps", "spaps", "spasts", "slapping", "clabs", "slabs", "slapps", "swats", " snats", "slops", "slapes", "synps", "synapes", "swps", "swaps", "knapping", "nasts", "snapses", "slps", "slaps", "napps", "napes", " snapps", "claps", "knips"], "snap_name": ["switch_source", "snapJsize", "pgfalias", "snapfcount", "snappcount", "gap_ni", "gap_key", "snap64key", "switch_size", "snapJanc", "snapJcount", "snappalias", "pgfstr", "snap_key", "snapJstr", "snap_source", "snappstr", "pg_name", "switch_anc", "snapfstr", "snappname", "snapfalias", "snap_anc", "snap_alias", "snap_ni", "switch_name", "snap___name", "snapJalias", "snap64id", "gap_name", "pg_alias", "gap_id", "snap_id", "pgfcount", "snapfname", "snap___source", "pg_count", "snap64name", "snapJname", "pg_str", "snapJsource", "pgfname", "snap___anc", "snap_str", "snap64ni", "snap___size", "snap_size"]}}
{"project": "qemu", "commit_id": "62c58ee0b24eafb44c06402fe059fbd7972eb409", "target": 0, "func": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,\n\n                                 MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                                 hwaddr *phys_ptr, int *prot, uint32_t *fsr)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    bool is_user = regime_is_user(env, mmu_idx);\n\n    int n;\n\n    int matchregion = -1;\n\n    bool hit = false;\n\n\n\n    *phys_ptr = address;\n\n    *prot = 0;\n\n\n\n    /* Unlike the ARM ARM pseudocode, we don't need to check whether this\n\n     * was an exception vector read from the vector table (which is always\n\n     * done using the default system address map), because those accesses\n\n     * are done in arm_v7m_load_vector(), which always does a direct\n\n     * read using address_space_ldl(), rather than going via this function.\n\n     */\n\n    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */\n\n        hit = true;\n\n    } else if (m_is_ppb_region(env, address)) {\n\n        hit = true;\n\n    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {\n\n        hit = true;\n\n    } else {\n\n        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {\n\n            /* region search */\n\n            /* Note that the base address is bits [31:5] from the register\n\n             * with bits [4:0] all zeroes, but the limit address is bits\n\n             * [31:5] from the register with bits [4:0] all ones.\n\n             */\n\n            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;\n\n            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;\n\n\n\n            if (!(env->pmsav8.rlar[n] & 0x1)) {\n\n                /* Region disabled */\n\n                continue;\n\n            }\n\n\n\n            if (address < base || address > limit) {\n\n                continue;\n\n            }\n\n\n\n            if (hit) {\n\n                /* Multiple regions match -- always a failure (unlike\n\n                 * PMSAv7 where highest-numbered-region wins)\n\n                 */\n\n                *fsr = 0x00d; /* permission fault */\n\n                return true;\n\n            }\n\n\n\n            matchregion = n;\n\n            hit = true;\n\n\n\n            if (base & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region base\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, base, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n            if ((limit + 1) & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region limit\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, limit, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!hit) {\n\n        /* background fault */\n\n        *fsr = 0;\n\n        return true;\n\n    }\n\n\n\n    if (matchregion == -1) {\n\n        /* hit using the background region */\n\n        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);\n\n    } else {\n\n        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);\n\n        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);\n\n\n\n        if (m_is_system_region(env, address)) {\n\n            /* System space is always execute never */\n\n            xn = 1;\n\n        }\n\n\n\n        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);\n\n        if (*prot && !xn) {\n\n            *prot |= PAGE_EXEC;\n\n        }\n\n        /* We don't need to look the attribute up in the MAIR0/MAIR1\n\n         * registers because that only tells us about cacheability.\n\n         */\n\n    }\n\n\n\n    *fsr = 0x00d; /* Permission fault */\n\n    return !(*prot & (1 << access_type));\n\n}\n", "idx": 11316, "substitutes": {"env": ["conf", "inet", "qt", "visor", "context", "ext", "fen", "stage", "conn", "dt", "estate", "net", "que", "viron", "ne", "environment", "config", "output", "obj", "e", "cli", "osc", "np", "txt", "chn", "queue", "po", "ec", "eni", "args", "er", "ut", "ev", "db", "skin", "console", "profile", "exc", "ea", "energy", "oa", "state", "virt", "exe", "req", "loader", "en", "err", "kn", "example", "him", "ctx", "eng", "Environment", "enc", "init", "esp", "ef", "online", "esm", "site", "engine", "her", "eu", "core", "eve", "exec"], "address": ["alias", "channel", "Address", "area", "location", "reference", "center", "base", "context", "balance", "enter", "source", "prefix", "class", "region", "capacity", "conn", "date", "point", "password", "email", "path", "instance", "pointer", "service", "enable", "addr", "config", "output", "ace", "uri", "target", "server", "limit", "number", "eni", "network", "padding", "host", "code", "device", "resource", "size", "index", "route", "shape", "name", "order", "account", "state", "abi", "en", "port", "repeat", "position", "grade", "offset", "type", "message", "ip", "attribute", "localhost", "interface", "length", "image", "api", "url", "site", "core", "settings", "buffer", "range"], "access_type": ["access2name", "access_info", " access2id", "access_name", " access2type", " access2info", " access_id", "access2type", " access2name", " access_name", "access_id", "access2id", "access2info", " access_info"], "mmu_idx": ["mmu_idxe", "mmu_adc", "mmu_midx", "mmu_Idxc", "mmu_IDx", "mmu_inv", "mmu_IDc", "mmu_midn", "mmu_idg", "mmu_IDX", "mmu_idsx", "mmu_IDn", "mmu_inn", "mmu_idexc", "mmu_Idxe", "mmu_adn", "mmu_midxe", "mmu_idv", "mmu_midX", "mmu_idsc", "mmu_midxc", "mmu_midb", "mmu_IdX", "mmu_Idx", "mmu_IDg", "mmu_inc", "mmu_midg", "mmu_idxc", "mmu_Idb", "mmu_Idg", "mmu_idsv", "mmu_Idn", "mmu_IDv", "mmu_idexe", "mmu_adv", "mmu_idn", "mmu_idb", "mmu_idc", "mmu_inx", "mmu_idX", "mmu_ideb", "mmu_idex", "mmu_adx", "mmu_idsX"], "phys_ptr": [" phys_tr", "phys_port", "phy_addr", "phy_ref", " phys_addr", "phys_addr", "phy_ptr", " phys_port", "phys_pointer", "phys_ref", "phy_pointer", "phys_tr"], "prot": ["channel", "seq", "dim", "rin", "ext", "prefix", "conn", "lit", "src", "model", "chron", "pat", "slot", "addr", "p", "uri", "server", "phys", "status", "target", "np", "afi", "config", "ocol", "pro", "cli", "prop", "protection", "rot", "nat", "format", "sil", "abi", "att", "port", "offset", "type", "platform", "pos", "io", "Prot", "transfer", "reset"], "fsr": ["ssrf", "fsrr", "atsrs", "FSR", "psrs", "ssr", "FSrb", "ssR", "fsR", "psR", "fxR", "fsrf", "fxp", " fsrb", "fsrb", "atsrr", " fsrs", "ssp", "fsp", " fsp", "fxrf", "FSrr", "FSrs", "fxr", "atsR", "atsr", "psr", " fsrf", "fsrs", "psrb", " fsrr", " fsR", "FSr"], "cpu": ["cow", "kernel", "boot", "cmp", "processor", "conn", "gpu", "bench", "chip", "prem", "net", "mem", "pool", "cp", "vm", "c", "p", "cli", "computer", "np", "uci", "machine", "cn", "gp", "hw", "os", "vidia", "device", "linux", "mx", "ctx", "lb", "pu", "hp", "jp", "pc", "nic", "node", "CPU", "platform", "gc", "cm", "px", "cache", "lc", "proc", "core", "roc"], "n": ["count", "l", "un", "base", "mn", "nb", "g", "span", "len", "in", "na", "w", "nt", "m", "conn", "no", "b", "k", "t", "num", "net", "z", "d", "i", "ne", "x", "c", "s", "limit", "p", "e", "np", "cn", "nw", "number", "dn", "f", "pn", "nat", "j", "nm", "network", "o", "N", "index", "nit", "syn", "v", "name", "r", "en", "sn", "nr", "ns", "node", "fn", "u", "nl", "nc", "nu", "ng", "ni", "y", "nin", "nn"]}}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 11328, "substitutes": {"s": ["session", "State", "is", "n", "si", "m", "t", "b", "instance", "serv", "service", "c", "p", "server", "e", "status", "se", "sq", "f", "os", "S", "scope", "south", "states", "state", "services", "r", "sl", "sb", "storage", "sys", "self", "fs", "su", "ses", "ss", "ssl"], "pdu": ["ppda", " pda", " puda", "pud", " pou", "spdu", "spcu", "Pdu", " pud", "pda", "psu", "wpuu", "puda", "ppuda", "wptu", "spuda", "wpdu", " ptu", "Ptu", "ptu", "Pda", "ppdu", "puu", "ppcu", " puu", "pcu", "Pud", "pptu", "ppsu", "Puu", "pou", " pcu", "wpou", "Pou", "ppud", "spsu", " psu"], "fidp": ["cidr", "poidf", "pidf", "fidc", "caidp", "fidr", "fadp", " fiddp", "fixP", "fidee", "fpidp", "pidg", "fadf", "fixr", "caidr", "fiddl", "fidf", "fadP", " fidc", "fixp", " fiddc", "faidf", "fide", "fipf", "caidP", " fidper", "foidg", "cidP", "faidr", "pidp", "faidp", "fiddp", "fidef", "fpidl", "fidl", " fiddper", "foide", "fixf", "fpidper", "faidper", "cidf", "cidp", "fideg", "foidf", "faidc", "fpidc", "fipp", "faidP", "fipg", "fipe", "pide", "fadr", "fidep", "foidp", "fiddper", "faidl", " fidl", "fidper", " fiddl", "caidf", "poidp", "poide", "fidg", "poidg", "fiddc", "fidP"], "off": ["over", "up", "alt", "ff", "len", "own", "pad", "ord", "info", "def", "low", "open", "num", "shift", "buf", "block", "data", "addr", "ref", "set", "offs", "flow", "mode", "none", "o", "non", "opt", "offer", "raw", "end", "load", "new", "art", "now", "offset", "less", "OFF", "pos", "Off", "ip", "on", "out", "length", "buff", "down", "reset"], "max_count": ["max_weight", "maxersize", " max_weight", "max_size", "maxxlen", " max_child", "maxerlen", "maxityweight", "maxitylength", "maxxcount", "max_handle", " max_len", "max67count", " max_length", "max_length", "max67handle", "maxerchild", " max_size", "max67weight", "max_child", " max_handle", "max67length", "maxitycount", "max_len", "maxxsize", "maxityhandle", "maxercount", "maxxchild"], "err": ["count", "cr", "org", "mr", "ver", "shift", "nor", "ref", "cb", "attr", "act", "aster", "loc", "er", "body", "errors", "code", "ctr", "nr", "offset", "orig", "init", "type", " Err", "resp", "ee", "arr", "rage", "fr", "go", "gr", "addr", "e", "iter", "or", "try", "msg", "min", "ind", "magic", "ner", "ar", "r", "load", "error", "rar", "idy", "fer", "header", "range", "later", "map", "fg", "seq", "ler", "good", "arm", "str", "len", "var", "data", "ir", "style", "dr", "master", "order", "rc", "req", "dev", "cache", "result", "Er", "br", "sr", "ah", "rh", "dy", "rr", "more", "reader", "Error", "bug", "lr", "rag", "trace", "yr", "rn", " error", "der", "out", "ln"], "read_count": ["read_counter", " read_limit", "read_limit", "read\u00b732", "read_group", "reader_num", "readertotal", "reader_count", "reader_width", "readeralcount", "readablelen", "readerlrange", "readedcount", "readlrange", " read_max", "read6total", "readalnum", "read___size", "readerablecount", "reader_len", "read\u00b7len", "read_max", " read_length", "read6count", "readalcount", "reader_range", "readabletotal", "readerlen", "readeralrange", "readerabletotal", "read___count", "readlcount", "read_num", "readeralcounter", "read_32", "readed32", "read_total", "readacsize", "readerwidth", "read_path", "read_length", " read_group", " read_cost", "read64group", "readablecount", "readablewidth", " read_number", "readlnum", "readacrange", "read_width", "reader_total", "readalcounter", "read_cost", "readlsize", "readerablewidth", "readacnumber", "read_range", "readaccount", "readedlen", "reader_counter", "read6width", "read64count", "readerablelen", "read\u00b7count", "write_count", " read_size", "reader_size", "readercount", "readacnum", "read_size", "readalrange", "readaccounter", "read_number", "readeralnum", "read6len", "write_32", "read64limit", "read___cost", "readerlsize", "readlcounter", "read_len", "write_len", " read_path", "readerlcount"], "xattr_len": ["xattr2val", "xattribute_len", "xatt_len", "xattr__length", "xattr__Len", "xattr_Len", "xrr__len", "xattr2count", "xrr_num", "xattr2Len", "xattr_val", "xattr_count", "xrr__Len", "xrr_Len", "xrr_len", "xattr__len", "xrr_length", "xattr__num", "xattr_length", "xattribute_val", "xattr_num", "xatt_val", "xatt_count", "xrr__num", "xattribute_Len", "xattr2len", "xrr__length", "xatt_Len"], "v": ["vs", "l", "vert", "sv", "n", "g", "lv", "w", "m", "k", "t", "b", "ve", "d", "i", "vt", "service", "c", "vm", "p", "e", "env", "f", "j", "o", "version", "uv", "state", "V", "vd", "u", "fs", "volt", "vp"], "elem": ["easer", "element", "pelements", "pelement", " elements", "beaser", "eeler", "elee", " element", " eler", "meject", "eelem", " elev", "belem", "eler", "melem", "eelements", "peler", "eelev", "belev", "eelement", "melement", "seject", "elements", "selee", "eleject", "pelem", "eeaser", "elelee", "melee", " easer", "selement", "selem", "elelement", "elev", "belement", "elelem", "eject"]}}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "substitutes": {"bs": ["vs", "base", "ds", "lbs", "ba", "bid", "bas", "b", "iss", "sa", "fb", "ls", "pb", "gb", "js", "us", "BS", "bc", "os", "obs", "cs", "bl", "es", "ubs", "bh", "las", "lb", "bis", "bi", "ns", "sb", "blocks", "as", "fs", "ses", "css", "ps", "ss", "bes", "bos"], "sector_num": ["sectorIdnum", "sectoridnumber", " sector_number", "sectorIdnumber", "sector_count", "sector_number", "sector_nom", "sectoridcount", "sectorIdfn", "sectorIdcount", " sector_nom", " sector_count", " sector_name", "sector_fn", "sectoridfn", "sector_name", "sectoridnum", " sector_fn"], "buf": ["bag", "uf", "seq", "Buffer", "ff", "src", "fd", "b", "num", "pool", "fi", "data", "block", "fb", "batch", "ref", "pb", "cb", "fp", "queue", "rb", "loc", "array", "bc", "bf", "alloc", "cv", "v", "ctx", "port", "bytes", "result", "vec", "buff", "buffer"], "nb_sectors": ["nb_spegments", "nb_secctors", "nb_vectors", "nb_sucs", "nb_surars", "nb_specs", "nb_secs", "nb_sears", "nb_surctors", "nb_secvers", "nb_suars", "nb_seitors", "nb_pectors", "nb_severs", "nb_suvers", "nb_survers", "nb_segments", "nb_pegments", "nb_surcs", "nb_vecs", "nb_spectors", "nb_pecs", "nb_speitors", "nb_vegments", "nb_secars", "nb_seccs", "nb_peitors", "nb_suctors", "nb_veitors"], "ret": ["pass", "base", "flag", "len", "val", "alt", "nt", "id", "Ret", "info", "x", "num", " Ret", "pat", "data", "reply", "ref", "arg", "obj", "reg", "final", "rets", "tmp", "f", "j", "code", "rt", "res", "bf", "py", "det", "fun", "att", "ben", "en", "art", "bit", "fin", "cat", "re", "RET", "back", "result", "rev", "match", "ft", "fi"], "s": ["l", "conf", "session", "ts", "is", "ds", "g", "si", "n", "w", "b", "t", "d", "gs", "sa", "c", "service", "iss", "p", "server", "e", "args", "js", "rs", "sq", "f", "j", "cs", "sym", "o", "opt", "S", "sync", "sl", "r", "ns", "sys", "h", "side", "ses", "ps", "fs", "site", "ss", "settings", "ssl"]}}
{"project": "qemu", "commit_id": "968fc24d843c9e9b24231ca1960b47ef2fc724ea", "target": 1, "func": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n\n                         uint8_t *dst, int dlen)\n\n{\n\n    uint32_t zrun_len = 0, nzrun_len = 0;\n\n    int d = 0, i = 0;\n\n    long res, xor;\n\n    uint8_t *nzrun_start = NULL;\n\n\n\n    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %\n\n               sizeof(long)));\n\n\n\n    while (i < slen) {\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] == new_buf[i]) {\n\n            zrun_len++;\n\n            i++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed */\n\n        if (!res) {\n\n            while (i < slen &&\n\n                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {\n\n                i += sizeof(long);\n\n                zrun_len += sizeof(long);\n\n            }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n", "idx": 11359, "substitutes": {"old_buf": ["new_uc", "oldfbox", "old_buffer", "old8buffer", "old67uf", "old67queue", "old_queue", "oldfbuff", "new_uf", "old_uf", "old__buff", "old_box", "_", "id", "b", "old__queue", "s", "old__buffer", "new_box", "r", "oldqbuf", "old__buf", "oldqband", "new_buffer", "old8uc", "oldqbuffer", "new_buff", "g", "add", "oldqbuff", "new_socket", "old8buf", "new_queue", "new_fab", "new_band", "old_band", "old67socket", "old_fab", "old_buff", "old_uc", "oldfbuffer", "old67buf", "oldfbuf", "old8buff", "old_socket"], "new_buf": ["new5font", "newJbuff", "new_fd", "old_buffer", "old_bus", "old_queue", "new_fat", "new_uf", "old_uf", "newalhead", "new__fd", "new_cv", "newAllfb", "old_fb", "new5buf", "new_head", "old_cb", "new_fb", "newJbus", "new__buf", "new_font", "new_buffer", "new_bus", "new__buffer", "new__queue", "new_buff", "new5buff", "old_cv", "new5buffer", "newalcv", "new_queue", "newJbuf", "old_font", "newJbuffer", "old_head", "old_buff", "new__buff", "newAllqueue", "newalbuff", "new__uf", "newalbuf", "newAllbuf", "newAllbuff", "new_cb", "old_fat", "old_fd"], "slen": [" slatten", "dllen", " slenn", "slien", "blen", " slened", "slatten", " slens", "slon", "plun", "llenn", "plah", " slan", "clen", "clah", "slenc", "islun", "slan", "dlien", "plenn", "sslang", " slah", "slens", "glens", " slien", "slang", "bleng", "islens", "sllen", "plang", "islenn", "selig", "llenc", " sleni", "plien", "plen", "islon", "gloren", "selun", "sellen", "selen", "llang", " sllen", "blenn", " slenum", "llien", "hlien", "plend", "sslatten", "glenc", " slig", "clun", "selens", " slend", "islig", "islenum", "islen", "llen", "pleng", "slah", "slense", "plenum", "dlun", "sleng", "sslenn", " slense", " slon", "llatten", "islend", "blien", "slenn", "hlen", "plan", "shen", " sloren", "lleng", "plon", "selien", "sloren", "hleni", "sslien", "clan", "slun", "sslen", "slenum", "hlened", "llens", "sslun", "slened", "lloren", "llun", "sleni", " slenc", "sheni", "shien", "islense", " slun", "shened", "slig", "sslense", "glen", "selenn", "slend"], "dst": ["dstal", " drc", "dsrc", "dbl", "sdsc", "nstal", "drc", "sdst", "dsc", "nsc", "fST", "idbl", "fstal", "sdST", "idsrc", " dsrc", "nST", "inst", "nst", "fst", " dbl", "inbl", "idst", "idrc", "insrc", "dST", "sdstal", "inrc", "fsc"], "dlen": [" dlog", "xlin", " dlength", "qlimit", "idlimit", "dlog", "dlength", "dylon", " dlimit", "xlen", "dysl", "dLen", "udLen", "udlin", "dlin", "qlen", "qLen", "idLen", "qlog", "udlen", "dsl", " dsl", " dlin", "dylen", "xlength", "dval", " dlon", " dLen", "rdval", "idlog", "dlon", "dlimit", "rdlen", "xLen", "dyval", " dval", "rdsl", "idlen", "udlength", "rdlon"], "res": ["Res", "nos", "mr", "x", "red", "reg", "script", "errors", "pres", "response", "err", "details", "re", "params", "resp", "vals", "rem", "reed", "id", "RES", "resolution", "gr", " Res", "ids", "rss", "rys", "bits", "args", "j", "min", "r", "pre", "rep", "error", "rar", "ons", "ps", "rus", "des", "def", "data", "ress", "ros", "os", "cs", "ras", "rc", "resh", "req", "rez", "sol", "ret", "result", "press", "func", "rh", "reset", "rows", "rest", "rec", "runs", "final", "rs", "js", "rets", "ris", "cons", "results", "ms", "css", "rev", "ares"], "xor": ["yors", "rxOR", " xors", " xOR", "factnor", "exOR", "factop", "xOR", "yori", "Xore", " xop", "exod", " xnor", "exore", " xod", "rxore", "factor", "XOR", "xori", "factors", "xnor", "yor", " xori", "txor", "Xors", "rxop", " xore", "txOR", "xors", "Xor", "txod", "yOR", "exor", "xod", "rxnor", "rxors", "Xori", "txore", "xop", "xore", "rxor"], "nzrun_start": ["nzrun__start", "nzrun1start", "nzrun_type", "nzrun__len", "nzrun_offset", "nzrun__offset", "nzRun_offset", "nzrun_max", "nzRun_start", "nzRun_type", "nzRun_len", "nzrun1len", "nzRun_space", "nzrunMspace", "nzrun__type", "nzrun1max", "nzrunMlen", "nzrunMstart", "nzrun_space", "nzRun_max", "nzrunMmax", "nzrun1space"], "i": ["oi", "l", "vi", "hi", "ui", "di", "it", "is", "n", "si", "g", "in", "zi", "source", "start", "id", "xi", "m", "info", "b", "x", "ini", "z", "t", "iv", "d", "c", "block", "s", "p", "ix", "isi", "e", "yi", "uri", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "mi", "phi", "ind", "name", "qi", "err", "ei", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "api", "ori", "ni", "io", "y", "ri", "fi", "iu", "anti"], "zrun_len": ["zrunner_l", "zrun_el", "zrun__num", "zcall6fin", "zun_lon", "zrun_fin", "zrun__el", "zrun7num", "zrun_Len", "zrunner_len", "zrun__line", "zun_el", "zrun_num", "zrun_line", "zupdate7line", "zRun_val", "zupdate7num", "zcall_len", "zupdate7len", "zrunslen", "zcall_fail", "zrun2el", "zupdate_limit", "zRun_num", "zrun_val", "zrunspos", "zrun2len", "zrun__val", "zcall6len", "zrun__fail", "zrun6len", "zrun2Len", "zcall_fin", "zrunner_Len", "zrunsel", "zunsel", "zrunning_l", "zrun__limit", "zrun__len", "zrun_limit", "zrun7line", "zRun_pos", "zupdate_num", "zcall_pos", "zrun_lon", "zcall6fail", "zRun_len", "zunslon", "zunslen", "zrun__lon", "zrun6pos", "zrun__fin", "zrun2l", "zrunning_el", "zcall6pos", "zrun7limit", "zrun_fail", "zupdate7limit", "zun_pos", "zun_len", "zrun_l", "zrun_pos", "zrun6fail", "zunspos", "zupdate_len", "zrun6fin", "zrun7len", "zrunner_val", "zrunning_Len", "zrunning_len", "zrunslon", "zupdate_line", "zrun__pos"], "nzrun_len": ["zrun2lf", "zrunning2l", "nzru_start", "zrun_l", "nzrun_fin", "zrun_pos", "nzru_fin", "zrun__lf", "zrun2len", "zrunning2len", "zrunning_lf", "zrunning2pos", "zrun_lf", "zrun2pos", "zrun2l", "zrunning2lf", "zrunning_pos", "zrunning_len", "nzru_Len", "zrunning_l", "nzru_len", "zrun__pos", "zrun__len", "nzrun_Len", "zrun__l"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static av_cold void init_atrac3_transforms(ATRAC3Context *q) {\n\n    float enc_window[256];\n\n    int i;\n\n\n\n    /* Generate the mdct window, for details see\n\n     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */\n\n    for (i=0 ; i<256; i++)\n\n        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;\n\n\n\n    if (!mdct_window[0])\n\n        for (i=0 ; i<256; i++) {\n\n            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);\n\n            mdct_window[511-i] = mdct_window[i];\n\n        }\n\n\n\n    /* Initialize the MDCT transform. */\n\n    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);\n\n}\n", "idx": 11361, "substitutes": {"q": ["dq", "qt", "context", "g", "w", "quad", "k", "iq", "c", "qu", "qq", "p", "qs", "qa", "cb", "queue", "e", "sq", "f", "py", "lib", "query", "req", "qi", "Q", "text", "question"], "enc_window": ["enc67flow", "enc2window", "enc_flow", "Enc_frame", "Enc_win", "enc_frame", "dec_window", "Enc_windows", "enc2win", "enc2box", "Enc_stream", "Enc_window", "enc67windows", "enc_windows", "enc_win", "dec_box", "enc_box", "dec_win", "enc_container", "Enc_container", "enc_stream", "enc67win", "enc2windows", "enc67window", "dec_flow", "dec_windows"], "i": ["oi", "l", "ui", "di", "it", "si", "n", "g", "anti", "zi", "adi", "w", "m", "xi", "id", "info", "k", "x", "b", "ini", "t", "d", "z", "c", "ji", "s", "p", "ix", "uri", "e", "yi", "cli", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "mi", "phi", "abi", "qi", "ei", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "api", "io", "ni", "y", "a", "ri", "fi", "iu", "ki"]}}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "substitutes": {"dcl": ["ddcl", "dsCL", "dCL", "ddCl", " dCl", " dfl", "dscl", "dsfl", "dsCl", "ddCL", "dfl", "ddfl", " dCL", "dCl"], "ds": ["vs", "ld", "sem", "cdn", "des", "session", "gd", "ts", "ks", "dh", "did", "uds", "dom", "dds", "da", "die", "dt", "dos", "dal", "ads", "d", "gs", "data", "ys", "ls", "pd", "parts", "dist", "du", "xs", "js", "rs", "df", "os", "ded", "dl", "dr", "db", "cs", "dat", "sync", "sts", "md", "dd", "DS", "vd", "ans", "ns", "dc", "nas", "sd", "ms", "Ds", "dm", "sys", "od", "der", "ses", "fs", "ps", "del", "ss", "bs", "settings", "dx"], "s": ["l", "session", "is", "its", "m", "t", "gs", "parts", "state", "ns", "hs", "spec", "self", "params", "sg", "si", "n", "your", "b", "i", "iss", "c", "e", "args", "sq", "us", "f", "sym", "sets", "es", "r", "sis", "as", "u", "fs", "ps", "site", "ss", "ks", "sv", "g", "stats", "ops", "d", "sa", "ls", "os", "cs", "o", "sync", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "vs", "conf", "ts", "service", "p", "qs", "ins", "xs", "js", "rs", "aws", "S", "sts", "states", "services", "h", "ses", "y", "bs"], "kind": ["parent", "ld", "rank", "gen", " kinds", "good", "kg", "std", "context", "str", "start", "Kind", "class", "def", "vid", "id", "method", "key", "nt", "die", "path", "k", "instance", "data", "head", "info", "draw", "lit", "args", "style", "xxx", "brand", "mode", "ie", "code", "mid", "child", "stroke", "actory", "kid", "shape", "nd", "ck", "name", "ind", "inner", "kt", "desc", "part", "cost", "spec", "ke", "need", "init", "concept", "type", "lang", "mean", "dev", "impl", "sid", "engine", "text", "feat", "depth", "ko"], "stride": ["striider", "striide", "Stride", " strided", "brided", "Strided", " strider", "briding", "strider", "bride", "striding", "striiding", "drided", "Strider", "trider", " striding", "Striding", "drider", "strided", "tride", "trided", "brider", "driding", "triding", "dride", "striided"], "req": ["sp", "cmp", "war", "rw", "org", "require", "ver", "ra", "ref", "qq", "tar", "reg", "dist", " reg", "ctr", "cur", "err", "spec", "get", "grad", "rx", "resp", " requirements", "fr", "iw", "gr", "serv", "e", "app", "request", "sq", "f", "j", "res", "r", "wx", "ur", "compl", "exec", "rf", "dq", "sem", "ru", " requisite", "seq", "str", "g", "conn", "util", "progress", "query", "tx", "jp", "a", "ret", "cache", "crit", "conf", "urg", "qt", "ry", "wa", "rr", "rec", "p", "js", "q", "sec", "requ", "lib", "Requ", "ctx", "pr", "pull", "client", "proc", " requ"], "sx": ["ssph", "Sx", "sfx", " smy", "spxe", "ppx", "sw", "ssfx", "ssw", "spy", " sph", " sX", "ssxe", "dw", "ssx", "ssy", "sxe", "py", " sxe", "sph", "dfx", "sX", "pX", "sct", "smy", " spx", "ssmy", " sct", " sfx", "px", "Spx", "spph", "spx", "Sy", "SX", "dx", "dy", "ssct"], "sy": ["ady", "hi", "si", "ry", "len", "asy", "ny", "phy", "ey", "sa", "ys", "fy", "thin", "ay", "sq", "zy", "lat", "yy", "gy", "sym", "py", "size", "syn", "sky", "ky", "south", "fun", "hy", "ty", "SY", "dy", "idy", "sys", "rx", "lon", "sat", "yn", "y", "ch", "Sy", "wy", "ity", "cy", "Ty"]}}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}", "idx": 11381, "substitutes": {"d": ["l", "ld", "gd", "dh", "ds", "g", "da", "m", "dt", "fd", "t", "b", "dj", "z", "i", "c", "ad", "data", "p", "e", "pd", "cd", "f", "dl", "j", "dat", "o", "state", "md", "r", "dd", "dc", "sd", "u", "dm", "self", "D"], "jtx": ["jobta", " jcf", "ojtx", "ojctx", "Jx", "qtx", "jobtxt", " jhea", "dtxt", "jptest", "jtest", " jctx", "jpx", "jobctx", "jptx", "jpctx", " jx", " jta", "dta", "jctx", "jpta", "ojcf", "ujx", "jptm", "qta", "jhea", " jtest", "dtm", "Jta", "jtxt", "djtx", "ujtx", "djta", "jpcf", "jta", "jx", "Jtest", "Jhea", "ujtest", "jobtx", " jtxt", "qtm", "jptxt", "jcf", "ujta", "jtm", "jphea", "qtxt", "dtx", "djtxt", "djctx", "Jtx", "ojx"], "s": ["l", "session", "ts", "sh", "ks", "sv", "is", "si", "ds", "g", "sf", "stats", "m", "sw", "b", "ops", "i", "gs", "sa", "service", "c", "p", "ls", "se", "e", "parts", "xs", "js", "sq", "rs", "f", "cs", "sym", "o", "sets", "S", "es", "sync", "south", "states", "sl", "services", "state", "r", "sb", "ns", "hs", "spec", "sys", "self", "ses", "su", "ps", "fs", "ss", "settings", "ssl"]}}
{"project": "FFmpeg", "commit_id": "3df2be9fa7365646f22a93cfde1e4097467f498e", "target": 1, "func": "static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n\n                                    AVPacket *pkt, uint64_t display_duration)\n\n{\n\n    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',')\n\n        layer = ++ptr;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',') {\n\n        int64_t end_pts = pkt->pts + display_duration;\n\n        int sc = matroska->time_scale * pkt->pts / 10000000;\n\n        int ec = matroska->time_scale * end_pts  / 10000000;\n\n        int sh, sm, ss, eh, em, es, len;\n\n        sh = sc/360000;  sc -= 360000*sh;\n\n        sm = sc/  6000;  sc -=   6000*sm;\n\n        ss = sc/   100;  sc -=    100*ss;\n\n        eh = ec/360000;  ec -= 360000*eh;\n\n        em = ec/  6000;  ec -=   6000*em;\n\n        es = ec/   100;  ec -=    100*es;\n\n        *ptr++ = '\\0';\n\n        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;\n\n        if (!(line = av_malloc(len)))\n\n            return;\n\n        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\",\n\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n\n        av_free(pkt->data);\n\n        pkt->data = line;\n\n        pkt->size = strlen(line);\n\n    }\n\n}\n", "idx": 11383, "substitutes": {"matroska": ["matroski", "mriska", "Matrosla", "matronsla", "macroski", "matriski", "matrola", "matrska", "matronsku", "macrola", "mrosla", "matroku", "mroska", "matriska", "matrsku", "matronski", "matrisku", "macroka", "matroneskee", "matroskee", "matriskee", "mrosku", "mrisla", "Matriska", "matrosku", "Matrisla", "Matriski", "Matroskee", "macrosla", "matrokee", "macroska", "Matriskee", "Matroska", "matrski", "matroki", "matroneski", "mroski", "macroku", "matronska", "macrosku", "matrisla", "matrosla", "matroneska", "mrisku", "matronesla", "matrsla", "Matroski", "macroki", "matroka", "mriski"], "pkt": ["facket", " pet", "opkt", " packet", "npet", "opeter", "tpacket", "npqt", "fkt", "peter", " pkg", " punt", "mkg", "Pnt", "melt", "pait", "fnt", " pnt", "punt", "apkg", "tpqt", "Pelt", "Pqt", "opnt", "feter", " pait", "apacket", "opacket", "Pkt", "pqt", "Pet", "jpkt", "jpacket", "fet", "apkt", "Pkg", "mkt", "fkg", "packet", " pqt", "npacket", "Pait", "Pct", "apunt", "Punt", "Packet", "pnt", "opkg", "macket", "tpkt", "jpnt", "pelt", "opelt", "jpait", " pct", "apnt", "pct", "pkg", "apeter", "tpct", "npkt", "pet"], "display_duration": ["display_version", "display_component", "display_length", "report_duration", "time_component", "displayationDuration", "displayationcomponent", "report_cost", "displayartpolicy", "time_length", "timeationDuration", "displayartversion", "report_policy", "timeationcomponent", "timeationlength", "displayartcost", "timeationduration", "display_policy", "displayationduration", "time_Duration", "display_cost", "report_version", "time_duration", "displayationlength", "display_Duration", "displayartduration"], "line": ["lp", "l", "zip", "level", "byte", "pass", "base", "lf", "le", "val", "source", "record", "word", "point", "page", "Line", "data", "block", "limit", "el", "e", "liner", "pe", "number", "lines", "frame", "loc", "entry", "code", "db", "unit", "slice", "parse", "name", "LINE", "item", "part", "error", "offset", "link", "nl", "li", "file", "pos", "row", "header", "url", "length", "out", "lc", "cell", "ine", "lined", "buffer", "pin", "lin"], "layer": ["lp", "wl", "l", "parent", "channel", "level", "Layer", "byte", "base", "lf", "lv", "depth", "src", "lvl", "phase", "data", "wk", "addr", "stack", "queue", "pe", "loc", "coll", "lr", "bc", "la", "device", "fl", "slice", "ll", "sl", "ctx", "address", "lay", "patch", "cl", "position", "offset", "pair", "hl", "file", "header", "url", "length", "lc", "seed", "buffer", "nn", "kl"], "ptr": ["tr", "enter", "pad", "pl", "fd", "shift", "ref", "attr", "ep", "dist", "loc", "step", "pert", "code", "ctr", "tip", "cur", "err", "port", "patch", "offset", "url", "buffer", "depth", "Ptr", "dim", "stage", "id", "addr", "pe", "iter", "ect", "slice", "sth", "desc", "pair", "file", "header", "transfer", "seq", "ext", "str", "src", "prot", "data", "eger", "coord", "fp", "dr", "entry", "req", "part", "pend", "vr", "br", "diff", "start", "rd", "mount", "leg", "pointer", "p", "time", "pt", "push", "lr", "inst", "trace", "pr", "address", "pull", "pos", "peer", "length", "ft", "proc", "fe"], "end": ["start", "n", "est", "enter", "in", "ended", "pad", "all", "id", "ent", "End", "x", "z", "send", "post", "last", "ad", "head", "max", "add", "p", "e", "set", "ep", "stop", "push", "sec", "mid", "append", "size", "edge", "index", "nd", "ind", "event", "en", "begin", "ending", "after", "enc", "pend", "tail", "pos", "use", "length", "END"], "sh": ["l", "SH", "sea", "osh", " ssh", " size", "ush", "ph", "ff", " square", "src", "wh", "sw", "ssh", "small", " sc", "ship", "cp", "qu", "se", "ish", "Sh", "loc", "sq", "hw", "sk", "zh", "cs", "hel", "size", "ksh", "ih", "sl", "ctx", "esh", "en", "sch", "cl", "how", "h", "hl", " sl", "ch", "ize", "ity", "sc"], "sm": ["sem", "ym", "sea", "sp", "me", "sv", "si", "ph", "m", "wh", "sw", "mm", "sci", "mem", "cp", "sum", "sam", "s", "hm", "spe", "se", "loc", "sq", "sk", "sy", "cs", "size", "sl", "md", "en", "sn", "sch", "cl", "spec", "ms", "h", "sim", "scl", "su", "css", "ch", "sr", "ess", "hem", "sc", "ism"], "ss": ["vs", "sem", "sp", "seq", "me", "ks", "sv", "ds", "si", "ush", "ph", "ems", "sw", "ese", "ssh", "uss", "iss", "ssl", "SS", "s", "ys", "e", "se", "rss", "pe", "ec", "sq", "us", "rs", "cs", "sl", "en", "sn", "sch", "ans", "ns", "spec", "ms", "h", "ps", "su", "css", "ah", "ses", "ess", "sr", "settings", "ens", "sc"], "eh": ["sem", "ek", "eah", "eff", "me", "he", "arch", "est", "ach", "ph", "ems", "mes", "ear", "oe", "el", "e", "se", "ep", "esi", "pe", "env", "ect", "ec", "ex", "er", "ev", "eb", "hed", "exc", "ih", "ctx", "esh", "en", "tx", "kn", "sch", "eng", "oh", "enc", "kh", "eth", "ef", "h", "hl", "emp", "esc", "ah", "ch", "ess", "ens", "eas"], "em": ["sem", "ek", "ee", "eff", "me", "est", "emer", "ach", "mes", "ems", "ph", "m", "sw", "x", "mm", "mem", "ell", "time", "el", "e", "pm", "ec", "er", "lem", "ev", "emi", "eg", "eb", "ae", "Em", "sl", "ees", "im", "en", "eng", "eme", "emin", "cm", "cel", "emp", "ema", "ess", "eu", "hem", "om", "ex"], "es": ["vs", "ek", "ee", "pes", "ES", "est", "mes", "lems", "ems", "ese", "x", "oe", "ys", "s", "el", "ls", "e", "qs", "se", "ep", "esi", "ec", "lines", "eks", "cs", "ae", "eps", "ees", "Es", "en", "hes", "els", "eng", "ces", "xes", "esp", "ef", "esc", "ses", "ps", " ec", "ess", "ets", "ices", "ens", "ed", "ex"], "len": ["lp", "l", "ld", "count", "sp", "ler", "seq", "le", "lf", "base", "start", "fen", "val", "n", "zi", "lim", "data", "ell", "el", "ix", "limit", "loc", "la", "dl", "fl", "size", "bl", "ll", "lib", "min", "sl", "en", "lt", "elt", "part", "offset", "fin", "den", "cel", "pos", "li", "lon", "length", "lc", "lan", "Len", "ln", "dy", "lin"]}}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n", "idx": 11400, "substitutes": {"type": ["count", "parent", "kind", "channel", "level", "base", "comment", "source", "prefix", "class", "key", "test", "id", "info", "method", "t", "total", "Type", "data", "block", "config", "p", "time", "e", "status", "pe", "action", "value", "style", "types", "mode", "code", "unit", "size", "version", "shape", "index", "format", "name", "connection", "state", "address", "ty", "port", "part", "ping", "position", "error", "copy", "TYPE", "lock", "year", "message", "header", "client", "length", "ype", "family", "typ", "month"], "reader_id": ["reader__ids", "reader__name", " reader_type", "reader_size", "readeruserid", "writer_name", "readeracsize", "readerusertype", "writer_id", "readeracid", "reader_ids", "reader__id", "readeruserroot", "reader_root", "reader_name", "readerusername", " reader_root", "readeracname", "reader_type", "readeracids", "writer_size", "writer_type", "reader__size", "writer_ids", " reader_name"], "msg": ["seq", "mess", "len", "g", "word", "id", "m", "game", "send", "buf", "gs", "doc", "data", "addr", "obj", "queue", "args", "frame", "body", "op", "Msg", "pub", "sent", "size", "name", "md", "req", "mail", "enc", "ms", "lang", "command", "comm", "message", "length", "result", "cmd", "pkg", "gen", "gram"], "mhHeader": [" mhConn", "mhrReader", " mghBuffer", "MhHeader", "meshPart", "mphHeader", "meshWriter", "mbhHeader", "mahHeader", "mhrHeader", " mchHeader", " mchWriter", "meshLast", " mphReader", "mvHeader", "mghheader", " mvPart", " mphHead", "meshBuffer", " mhheader", " mchBuffer", "mhlheader", " mghHeader", "mhClient", "mhlLast", "mbhConn", "MwHeader", "mghServer", " mhrWriter", "mghConn", "mvPart", "mhHead", "MwHead", "mghBuffer", "mhWriter", "mbhheader", " mhrHeader", "methBuffer", "methHeader", " mhReader", "mghHead", "mvWriter", " mghheader", "mphReader", "methHead", "mghHeader", "mhrHead", "mrhClient", "mghClient", "mhBuffer", "mchWriter", " mhrheader", "mchHeader", " mhPart", "mhPart", " mvHeader", "mhrConn", "mbhWriter", " mhBuffer", " mhrConn", "mhlBuffer", " mhHead", "mhrheader", " mchHead", "meshheader", "mhrWriter", "mwBuffer", "MwServer", "mrhHeader", " mhWriter", "mhReader", "mphClient", "mchHead", "meshHead", "methWriter", "mghWriter", " mghLast", "mhrClient", "mrhHead", "mchBuffer", "mhlHeader", "mahServer", "mhheader", "mwClient", "MwClient", "mhConn", "mwWriter", "MhClient", "mwHead", "mrhReader", " mhLast", "MhServer", "mbhPart", "mwHeader", "mphHead", "mbhHead", "mahClient", "meshHeader", " mvHead", " mphHeader", "mhLast", "MhHead", " mhClient", "mhServer", "mwServer", "mghLast", "mvHead", " mphClient", "mahHead", " mvWriter"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){\n\n    int i, j;\n\n    int dc = (((dctcoef*)block)[0] + 32) >> 6;\n\n    pixel *dst = (pixel*)_dst;\n\n    stride >>= sizeof(pixel)-1;\n\n    for( j = 0; j < 4; j++ )\n\n    {\n\n        for( i = 0; i < 4; i++ )\n\n            dst[i] = av_clip_pixel( dst[i] + dc );\n\n        dst += stride;\n\n    }\n\n}\n", "idx": 11423, "substitutes": {"_dst": ["_Dsts", "_adst", "_idput", "_fconst", "_Dost", " _adset", "_dconst", "_lst", " _dST", "_dsts", " _dsts", "_idst", " _adST", " _Dost", " _Dsts", "_adset", " _dset", " _Dconst", "_dost", "_fost", "_lST", "_fst", "_lset", " _adput", "_adST", "_dset", "_dST", " _dput", "_fsts", "_adput", "_Dst", "_lput", " _Dst", " _adst", " _dost", "_Dconst", "_idset", "_idST", " _dconst", "_dput"], "block": ["channel", "Block", "comment", "record", "word", "page", "num", "line", "batch", "mask", "pixel", "frame", "none", "padding", "label", "device", "unit", "bl", "sync", "name", "clock", "end", "cl", "blocks", "enc", "bit", "type", "layer", "lock", "clean", "ip", "row", "disk", "header", "image", "bin", "buffer", "chain"], "stride": ["decision", "incider", "brone", "strade", " strip", "decider", "strision", " strided", " strade", "slide", "brided", "trive", "decide", "slided", " strider", "strone", "strider", "bride", "strip", "slone", " strone", "brade", "trider", "stip", "stider", "strive", "incision", " strision", "strride", "trip", " strive", "stide", "strided", " strride", "stive", "incride", "slade", "tride", "decride", "incide"], "i": ["oi", "l", "ui", "di", "it", "si", "n", "zi", "m", "xi", "info", "b", "x", "k", "ini", "z", "d", "uli", "c", "ji", "p", "uri", "ix", "e", "mu", "f", "ai", "o", "v", "gi", "mi", "phi", "ti", "r", "qi", "jp", "pi", "bi", "ii", "init", "u", "h", "I", "li", "ip", "ci", "a", "disk", "ni", "io", "ri", "fi", "iu"], "j": ["l", "ui", "it", "is", "n", "si", "g", "w", "m", "xi", "b", "k", "z", "x", "dj", "d", "ji", "c", "p", "jo", "obj", "e", "q", "js", "f", "ie", "uj", "o", "v", "jit", "r", "qi", "ij", "jp", "ii", "ja", "init", "u", "aj", "I", "li", "ci", "J", "y", "jc", "jl", "jj"], "dst": ["dedst", "vdsp", " dsc", "dbl", "dsp", " dstream", " dconst", " dsp", "idsts", "dedbl", "dedstream", "dsc", " dstr", "dstr", "Dste", "Dest", "dest", "Dsts", "dste", "dconst", "ndsts", "ndste", "ndst", "dedsts", "vdstr", " dsts", " dest", "adsp", "adstr", " dbl", "adstream", "idst", "idste", "dedste", "Dst", "adsts", "dsts", "ndest", " dste", "adconst", "dstream", "vdst", "adst", "vdconst", "adbl", "dedsc", "idsc"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt,\n\n                             const AVFrame *pict, int *got_packet)\n\n{\n\n    const AVFrame *const p = pict;\n\n    const int near         = avctx->prediction_method;\n\n    PutBitContext pb, pb2;\n\n    GetBitContext gb;\n\n    uint8_t *buf2 = NULL;\n\n    uint8_t *zero = NULL;\n\n    uint8_t *cur  = NULL;\n\n    uint8_t *last = NULL;\n\n    JLSState *state;\n\n    int i, size, ret;\n\n    int comps;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n        avctx->pix_fmt == AV_PIX_FMT_GRAY16)\n\n        comps = 1;\n\n    else\n\n        comps = 3;\n\n\n\n    if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 +\n\n                               AV_INPUT_BUFFER_MIN_SIZE)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    buf2 = av_malloc(pkt->size);\n\n    if (!buf2)\n\n        goto memfail;\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n    init_put_bits(&pb2, buf2, pkt->size);\n\n\n\n    /* write our own JPEG header, can't use mjpeg_picture_header */\n\n    put_marker(&pb, SOI);\n\n    put_marker(&pb, SOF48);\n\n    put_bits(&pb, 16, 8 + comps * 3); // header size depends on components\n\n    put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8);  // bpp\n\n    put_bits(&pb, 16, avctx->height);\n\n    put_bits(&pb, 16, avctx->width);\n\n    put_bits(&pb, 8, comps);          // components\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);     // component ID\n\n        put_bits(&pb, 8, 0x11);  // subsampling: none\n\n        put_bits(&pb, 8, 0);     // Tiq, used by JPEG-LS ext\n\n    }\n\n\n\n    put_marker(&pb, SOS);\n\n    put_bits(&pb, 16, 6 + comps * 2);\n\n    put_bits(&pb, 8, comps);\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);   // component ID\n\n        put_bits(&pb, 8, 0);   // mapping index: none\n\n    }\n\n    put_bits(&pb, 8, near);\n\n    put_bits(&pb, 8, (comps > 1) ? 1 : 0);  // interleaving: 0 - plane, 1 - line\n\n    put_bits(&pb, 8, 0);  // point transform: none\n\n\n\n    state = av_mallocz(sizeof(JLSState));\n\n    if (!state)\n\n        goto memfail;\n\n\n\n    /* initialize JPEG-LS state from JPEG parameters */\n\n    state->near = near;\n\n    state->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;\n\n    ff_jpegls_reset_coding_parameters(state, 0);\n\n    ff_jpegls_init_state(state);\n\n\n\n    ls_store_lse(state, &pb);\n\n\n\n    zero = last = av_mallocz(p->linesize[0]);\n\n    if (!zero)\n\n        goto memfail;\n\n\n\n    cur  = p->data[0];\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 8);\n\n            t    = last[0];\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 16);\n\n            t    = *((uint16_t *)last);\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 0; j < 3; j++) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 2; j >= 0; j--) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    }\n\n\n\n    av_freep(&zero);\n\n    av_freep(&state);\n\n\n\n    /* the specification says that after doing 0xff escaping unused bits in\n\n     * the last byte must be set to 0, so just append 7 \"optional\" zero-bits\n\n     * to avoid special-casing. */\n\n    put_bits(&pb2, 7, 0);\n\n    size = put_bits_count(&pb2);\n\n    flush_put_bits(&pb2);\n\n    /* do escape coding */\n\n    init_get_bits(&gb, buf2, size);\n\n    size -= 7;\n\n    while (get_bits_count(&gb) < size) {\n\n        int v;\n\n        v = get_bits(&gb, 8);\n\n        put_bits(&pb, 8, v);\n\n        if (v == 0xFF) {\n\n            v = get_bits(&gb, 7);\n\n            put_bits(&pb, 8, v);\n\n        }\n\n    }\n\n    avpriv_align_put_bits(&pb);\n\n    av_freep(&buf2);\n\n\n\n    /* End of image */\n\n    put_marker(&pb, EOI);\n\n    flush_put_bits(&pb);\n\n\n\n    emms_c();\n\n\n\n    pkt->size   = put_bits_count(&pb) >> 3;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n\n\nmemfail:\n\n    av_packet_unref(pkt);\n\n    av_freep(&buf2);\n\n    av_freep(&state);\n\n    av_freep(&zero);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 11427, "substitutes": {"avctx": ["afconn", "avcv", "afctx", "avecca", "AVconfig", "navctx", "avcc", "abconn", "afconf", "AVcc", "afcas", "evcf", "afpkg", "afkw", "avectx", "abcontext", "abconfig", "avcf", "avecu", "AVpkg", "evcontext", "avkw", "navconn", "AVcontext", "avcu", "abctx", "AVcit", "afcf", "afcu", "navcas", "AVkw", "avconn", "navconf", "ajctx", "ajcontext", "afconfig", "avcit", "AVctx", "AVconn", "afcit", "ajconf", " avcontext", "avconfig", "avcontext", " avconn", "afcc", "avekb", "evcu", "evctx", "abkb", "avcas", " avcc", "avpkg", "navcontext", "avkb", "ajcv", "avecf", "AVcca", "aveconn", "navconfig", "avecontext", " avcit", "navkw", "afcontext", "afkb", "AVcas", "afcv", "navcv", "avcca", "afcca", "avconf", "navpkg"], "pkt": ["facket", "cpacket", "bwk", " pet", " packet", "bkt", "backet", "fkt", "mctx", "Pwk", "fwk", " pkg", "mkg", "Pnt", "pctx", "cpct", " pnt", "Pqt", "cpet", "Pkt", "cpnt", "pqt", "Pet", " pctx", "bnt", "mkit", "cpkt", "Pkg", "mkt", "fkg", " pqt", "packet", "pkit", "cpqt", " pwk", "Pct", "pnt", "Packet", "macket", "Pkit", " pct", "fctx", "mwk", " pkit", "pwk", "fct", "pct", "pkg", "pet"], "pict": ["cit", "cot", "cam", "img", "gif", "pit", "piece", "sci", "pty", "stat", "paste", "fi", "capt", "apt", "buf", "config", "lit", "qa", "obj", "sec", "pai", "png", "quant", "Picture", "photo", "fat", "ctx", "pic", "bis", "jp", "mot", "Pic", "Pict", "fig", "init", "shit", "pas", "sit", "image", "buff", "proc", "feat", "picture", "phot"], "got_packet": ["got_rawpoint", "got_pluget", "got_packacket", "got2packacket", "got_rawet", "got_comppoint", "got_packpoint", "got2compacket", "got_plugpoint", "got2packset", "got_rawset", "got_compset", "got_plugset", "got2compset", "got_plugacket", "got_packset", "got2packpoint", "got2comppoint", "got2compet", "got2packet", "got_compet", "got_compacket", "got_rawacket"], "p": ["l", "n", "g", "m", "pl", "b", "t", "d", "c", "cp", "pd", "e", "fp", "np", "pt", "q", "P", "prop", "f", "pn", "o", "py", "port", "jp", "pi", "pc", "a", "pkg"], "pb": ["lp", " PB", "dp", "ld", "repl", "bb", "pg", "nb", "abc", "proc", "bp", "lab", "pl", "bm", "b", "bs", "wb", "SB", "buf", "pa", " eb", "kb", "fb", "ref", "cb", "fp", "np", "attr", "ub", "rb", "loc", "prop", "pm", "bc", "la", "dl", "db", "bf", "bj", "py", "eb", "cv", "bps", "bh", "ctx", "las", "lb", "bot", "jp", "TB", "sb", "pc", "PB", " proto", "PF", "summary", "hub", "plugin", " buf", "platform", "api", "fc", " pu", "ob", "lc", "xb", "pkg", "rob", "BP", "bos", "vp"], "pb2": ["pb5", "cb5", "PB1", "bp2", "pb0", "bufall", "pb6", "fb0", "cb2", "PB5", "fb6", "pball", "bptwo", "bp1", "cb1", "cbtwo", "bp0", "bp6", "PBtwo", "fball", "pbtwo", "bpall", "PB2", "pb1", "bp5", "buf6", "fb2", "buf0"], "gb": ["CC", " parent", " bc", " acc", " cc", " client", "CV", " gcc", " ch", " comp", " sc", " ic", " sim", "bc", "cc", " call", "rc", " cm", " lib", " support", "TC", "pc", " mc", " rc", " co", " prog", " conv", " ec", " con", " conf"], "buf2": ["buffer8", "uf8", "buff2", "uf3", "uf4", " buf4", "buf4", "cb4", "buf1", "buff4", "uf1", "uf2", "cb2", "buff8", " buf0", "cb1", " buf3", "buffer2", "buffer1", "buff3", "buff1", "buf3", " buf1", "buffer4", "cb0", "buf8", "uf0", "buf0"], "zero": ["byte", "scale", "initial", "comment", "prefix", "negative", "missing", "total", "num", "mask", "used", "final", "bug", "serial", "empty", "none", "entry", "version", "nil", "extra", "one", "sc", "fee"], "cur": ["count", "seq", "uu", "cmp", "info", "num", "sum", "prev", "pri", "cb", "final", "loc", "mid", "code", "child", "ctr", "rc", "ind", "current", "req", "pre", "ci", "result", "rev", "inf", "random"], "last": ["worst", "seq", "str", "Last", "low", "total", "latest", "max", "prev", "used", "final", "style", "empty", "st", "next", "code", "th", "nd", "sync", "end", "first", "desc", "cost", "self", "cycle", "cache", "rev", "pop"], "state": ["session", "State", "param", "start", "val", "media", "statement", "conn", "tag", "instance", "data", "config", "status", "STATE", "style", "code", "resource", "progress", "scope", "master", "sync", "states", "port", "spec", "type", "cache", "result"], "i": ["oi", "l", "ani", "hi", "ui", "di", "it", "start", "si", "g", "n", "in", "zi", "id", "xi", "info", "b", "k", "ini", "z", "ami", "d", "uli", "c", "ji", "e", "cli", "mu", "eni", "f", "code", "ai", "multi", "index", "ind", "ti", "mi", "gi", "phi", "udi", "r", "chi", "abi", "qi", "inner", "pi", "bi", "ii", "idi", "type", "I", "li", "ip", "ci", "io", "ni", "ski", "y", "ri", "fi", "iu", "ki"], "size": ["count", "sp", "channel", "dim", "sh", "scale", "si", "len", "g", "capacity", "speed", "small", "z", "SIZE", "send", "data", "sum", "c", "loc", "Size", "sec", "empty", "body", "height", "code", "unit", "sent", "shape", "cap", "name", "content", "fat", "sized", "address", "sn", "full", "storage", "offset", "bytes", "uni", "form", "cm", "pos", "general", "sex", "gz", "length", "extra", "ize", "sc"], "ret": ["repl", "bad", "flag", "ext", "alt", "val", "len", "fail", "tr", "def", "nt", "Ret", " Ret", "mem", "reply", "ref", "lit", "fit", "status", "reg", "utf", "usr", "value", "rets", "rt", "res", "bl", "det", "rc", "fun", "r", "att", "err", "rep", "error", "ure", "fin", "re", "RET", "result", "mt", "match", "resp", "feat", "success"], "comps": ["compps", "calips", "perups", "comups", "Comops", " compes", "confpes", "quups", "combpos", "expos", " comases", "ocomple", "compips", "exps", "compases", "compples", "combops", "qups", "comppes", "comples", "confips", "Compes", "COMips", "perops", "perms", "comppps", "calpes", "comips", " combs", "comops", "calples", "compups", "COMpps", "confps", "compbs", "compms", "limases", "confples", "compPS", "combps", "limbs", "qums", "quops", "compple", "limps", "comases", "Comples", "compops", "expes", "exples", "commbs", "commPS", "comppos", "Comps", " comples", "ocomips", "combples", "Compos", " comPS", "compos", "COMps", "comple", "commps", "compes", "COMple", "perps", " compos", "ocompps", "limops", "ocomps", "comPS", "combs", " comops", "calps", "comms", "commpos"]}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "void ff_vc1_decode_blocks(VC1Context *v)\n\n{\n\n\n\n    v->s.esc3_level_length = 0;\n\n    if (v->x8_type) {\n\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);\n\n\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n    } else {\n\n        v->cur_blk_idx     =  0;\n\n        v->left_blk_idx    = -1;\n\n        v->topleft_blk_idx =  1;\n\n        v->top_blk_idx     =  2;\n\n        switch (v->s.pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            if (v->profile == PROFILE_ADVANCED)\n\n                vc1_decode_i_blocks_adv(v);\n\n            else\n\n                vc1_decode_i_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            if (v->p_frame_skipped)\n\n                vc1_decode_skip_blocks(v);\n\n            else\n\n                vc1_decode_p_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            if (v->bi_type) {\n\n                if (v->profile == PROFILE_ADVANCED)\n\n                    vc1_decode_i_blocks_adv(v);\n\n                else\n\n                    vc1_decode_i_blocks(v);\n\n            } else\n\n                vc1_decode_b_blocks(v);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 11428, "substitutes": {"v": ["vs", "l", "vi", "va", "gu", "vert", "sv", "n", "g", "vu", "lv", "view", "w", "m", "model", "k", "b", "x", "t", "iv", "ve", "ver", "i", "vt", "d", "c", "ov", "s", "vm", "p", "var", "qu", "e", "vim", "server", "tv", "value", "or", "q", "cover", "f", "j", "ev", "vol", "o", "version", "nv", "cv", "uv", "vic", "conv", "V", "vd", "z", "vin", "ii", "vers", "u", "vr", "serv", "dev", "api", "vv", "video", "vc", "rev", "volt", "vp"]}}
{"project": "FFmpeg", "commit_id": "8ce803db51a28eb662b6271b2b223e0312bdb3d2", "target": 1, "func": "paint_mouse_pointer(XImage *image, struct x11_grab *s)\n\n{\n\n    int x_off = s->x_off;\n\n    int y_off = s->y_off;\n\n    int width = s->width;\n\n    int height = s->height;\n\n    Display *dpy = s->dpy;\n\n    XFixesCursorImage *xcim;\n\n    int x, y;\n\n    int line, column;\n\n    int to_line, to_column;\n\n    int image_addr, xcim_addr;\n\n\n\n    xcim = XFixesGetCursorImage(dpy);\n\n\n\n    x = xcim->x - xcim->xhot;\n\n    y = xcim->y - xcim->yhot;\n\n\n\n    to_line = FFMIN((y + xcim->height), (height + y_off));\n\n    to_column = FFMIN((x + xcim->width), (width + x_off));\n\n\n\n    for (line = FFMAX(y, y_off); line < to_line; line++) {\n\n        for (column = FFMAX(x, x_off); column < to_column; column++) {\n\n            xcim_addr = (line - y) * xcim->width + column - x;\n\n\n\n            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel\n\n                image_addr = ((line - y_off) * width + column - x_off) * 4;\n\n\n\n                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);\n\n                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);\n\n                image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);\n\n            }\n\n        }\n\n    }\n\n\n\n    XFree(xcim);\n\n    xcim = NULL;\n\n}\n", "idx": 11433, "substitutes": {"dpy": ["dp", "Dp", "Dpx", "dpc", "ldpi", " dpo", " dphy", "bphy", "dspe", "bp", "bpx", "dspo", "Dphy", "Dpy", " dpi", "vdpy", "vdpc", " dpx", "dspy", "vdpo", "dpo", " dp", " dpe", "ldpe", "dpi", "dpe", "dpx", "Dpi", "bpy", "vdpe", "dphy", "ldp", "Dpe", "ldpy", "dspc", " dpc"], "xcim": ["xbIM", "xdimal", "cmpIm", "recims", "xcimen", "xbim", "dcims", "etcima", "xaim", "vcim", "wxim", "xcimus", "acsima", "recimm", "bcem", "recimal", "cmpim", "ctxim", "contim", "ccim", "etcimal", "xcam", "vcimal", "dcim", "hostimal", "centralima", "xdem", "cmpimal", "acsIM", "abcimal", "xcimm", "lcims", "confim", "etcims", "xpif", "xdimm", "uncimus", "xdimus", "cam", "xaima", "xcimal", "hostima", "xfam", "xdimi", "xcif", "hostim", "constima", "encima", "contimal", "vcimm", "hostimm", "ccimal", "bcimm", "centralim", "xfim", "uncima", "etcim", "confimm", "xcIM", "xbIm", "xpimal", "acsim", "xdims", "xfimal", "zxim", "iccimal", "bcim", "dcima", "lcimal", "confimus", "ctxima", "unccm", "iccim", "lcim", "zximal", "centralimal", "xcIm", "bcima", "xaIm", "vcam", "xdIM", "wximm", "wximal", "contima", "ccimen", "xpimen", "encimm", "abcimm", "xcima", "zximen", "confimal", "xcem", "xbimi", "etcimi", "xbimm", "bcimal", "xpim", "encimal", "abcima", "cmpimi", "lcima", "iccimm", "cmpims", "dcimal", "xpimm", "recima", "cim", "constcm", "xfims", "centralimm", "acsimm", "constim", "cmpima", "xdim", "vcima", "recem", "uncim", "recim", "etcimm", "xdcm", "xcims", "cims", "wximus", "bcims", "vcims", "xpima", "ctxims", "xbima", "encim", "xbimal", "recimi", "zxif", "constimus", "xfima", "contimm", "iccimus", "xccm", "ccif", "xcimi", "xaimi", "xdima", "cimal", "ctximm", "abcim"], "x": ["l", "base", "n", "ax", "w", "xx", "xi", "id", "m", "b", "page", "z", "d", "i", "c", "X", "p", "el", "ix", "e", "time", "work", "cross", "f", "height", "code", "host", "j", "ice", "o", "index", "shape", "v", "yx", "name", "content", "fx", "en", "Y", "gray", "position", "wx", "xc", "col", "u", "xy", "h", "rx", "px", "on", "ip", "video", "image", "ya", "weight", "wy", "one", "dx", "ex"], "y": ["l", "ym", "ady", "yt", "oy", "ry", "w", "ny", "xx", "b", "ey", "vy", "z", "ye", "t", "i", "c", "ys", "cy", "p", "yi", "ay", "zy", "yy", "sy", "height", "j", "gy", "o", "py", "sky", "yx", "ky", "yl", "ery", "hy", "Y", "ty", "col", "yr", "type", "xy", "h", "ya", "image", "wy", "dy", "yo"], "line": ["l", "level", "base", "character", "grid", "le", "len", "model", "page", "eline", "letter", "Line", "i", "c", "block", "el", "style", "lines", "frame", "step", "pin", "entry", "code", "label", "unit", "slice", "edge", "min", "name", "sl", "user", "margin", "position", "col", "link", "dy", "layer", "lock", "li", "cycle", "year", "row", "lon", "length", "cell", "ine", "write", "weight", "lc", "office", "day", "cy", "lin"], "column": ["scroll", "channel", "forward", "dim", "byte", "grid", "character", "section", "word", "method", "second", "no", "point", "path", "page", "letter", "pointer", "ct", "c", "block", "pixel", "number", "condition", "height", "entry", "unit", "index", "slice", "module", "content", "align", "four", "margin", "variable", "position", "dimension", "offset", "pen", "col", "platform", "Column", "year", "file", "row", "attribute", "image", "cell", "weight", "arrow", "day"], "to_line": [" to_direction", "toparrow", " to_lin", "from_row", "toparline", "toparmodule", "to_row", "to_direction", "tockdirection", "to_module", " to_row", " to_frame", "to_frame", "from_line", "to_zone", " to_module", "tockline", "tocklin", "toparcolumn", "to_lin", "from_zone", "from_lin", "tockframe"], "to_column": ["toamerow", "to_pixel", " to_pixel", "TO_column", "to_cell", "TO_line", "to_row", "TO_col", " to_row", "toamecolumn", "toameline", " to_character", " to_cell", "toamepixel", "to_col", "TO_cell", "to_character"], "image_addr": [" image_ady", "image_ady", "image_address", "imageacptr", "video_addr", "imageappaddress", "imageacloc", " image_amd", "media_loc", "video_nr", "media_addr", "media_ptr", "image_oa", " image_ptr", "media_adr", " image_address", "image_loc", "image_nr", "image_ptr", "imageappoa", "imageacaddr", " image_oa", "video_part", "video_amd", "image_amd", "imageappaddr", "image_off", "image_part", "image_pad", "imageacadr", " image_off", " image_pad", "imageappoff", "image_adr"], "xcim_addr": ["xcrim_address", "xcim__sta", "xcip_url", "xcimen_sta", "xcima_dr", "xcim67player", "xcim_sta", "xcim_anne", "xcimal_off", "xcim_ord", "xcim_ptr", "xcrim_ptr", "xcip_addr", "xcima_anne", "xcim67addr", "xcim_off", "xcim67url", "xcimal_url", "xcip_player", "xcim_ref", "xcima_address", "xcim__addr", "xcrim_addr", "xcimal_address", "xcim_player", "xcimen_ord", "xcim_ad", "xcimal_ref", "xcim_dr", "xcip_ord", "xcimal_layer", "xcimen_addr", "xcim67ord", "xcimen_ad", "xcim_address", "xcrim_ref", "xcim__ord", "xcim_url", "xcima_addr", "xcim__ad", "xcim_layer", "xcimal_addr"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr,\n\n                                    unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint32_t gic_freq, val;\n\n\n\n    if (size != 4) {\n\n        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);\n\n        return 0;\n\n    }\n\n\n\n    switch (addr & 0xffff) {\n\n    case PLAT_FPGA_BUILD:\n\n    case PLAT_CORE_CL:\n\n    case PLAT_WRAPPER_CL:\n\n        return 0;\n\n    case PLAT_DDR3_STATUS:\n\n        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;\n\n    case PLAT_MMCM_DIV:\n\n        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;\n\n        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;\n\n        return val;\n\n    case PLAT_BUILD_CFG:\n\n        val = PLAT_BUILD_CFG_PCIE0_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE1_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE2_EN;\n\n        return val;\n\n    case PLAT_DDR_CFG:\n\n        val = s->mach->ram_size / G_BYTE;\n\n        assert(!(val & ~PLAT_DDR_CFG_SIZE));\n\n        val |= PLAT_DDR_CFG_MHZ;\n\n        return val;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,\n\n                      addr & 0xffff);\n\n        return 0;\n\n    }\n\n}\n", "idx": 11439, "substitutes": {"opaque": ["obaque", "opacity", " opaca", "opedaque", "opedaya", " opaco", "opedaques", "opedacity", "operaya", "opaya", "opaco", " opaya", "popaque", "popaca", "popaco", "operacity", "obaques", "opaca", " opaques", "obaca", " opacity", "popaques", "operaque", "opaques", "operaques", "obaco"], "addr": ["mac", "adr", "seq", "base", "start", "len", "ord", "prefix", "pad", "id", "src", "x", "pointer", "data", "ad", "ref", "config", "p", "ace", "slot", "arg", "amd", "ptr", "frame", "args", "eni", "mode", "host", "rt", "slice", "oa", "amp", "index", "rc", "name", "align", "r", "address", "port", "hash", "hop", "offset", "asm", "node", "eth", "grad", "layer", "pos", "rx", "ip", "sid", "adder"], "size": ["iz", "timeout", "scale", "n", "len", "g", "capacity", "password", "small", "SIZE", "send", "c", "from", "data", "e", "args", "loc", "empty", "Size", "sec", "code", "shape", "name", "six", "sized", "address", "en", "sn", "offset", "type", "pos", "length", "ize", "security", "fee"], "s": ["conf", "session", "sv", "is", "n", "g", "si", "sf", "w", "m", "stats", "t", "ssh", "b", "sa", "c", "service", "p", "server", "e", "se", "sq", "socket", "f", "sym", "o", "S", "scope", "sync", "south", "sie", "sl", "sing", "state", "services", "sb", "ns", "spec", "sys", "h", "ses", "su", "site", "ss", "settings", "ssl"], "gic_freq": ["gic_frez", "gic_libiq", "gic8refq", "gic6freiq", "gic6freqs", "gic6libq", "gic_freeqs", "gic_libq", "gic8refQ", "gic_refqs", "gic_freeiq", "gic8frece", "gic_perQ", "gic_freqq", "gic8freqs", "gic_fq", "gic_Frece", "gic_freqs", "gic_freQ", "gic_freeQ", "gic_perqq", "gic_FreQ", "gic8freQ", "gic_freiq", "gic_Freck", "gic8freq", "gic6freq", "gic_Freq", "gic_freck", "gic_fiq", "gic_libqs", "gic6libqs", "gic6frez", "gic6libiq", "gic_libz", "gic_freez", "gic_refce", "gic_refQ", "gic_freeq", "gic_Freqq", "gic8refqs", "gic_perck", "gic_Freqs", "gic_refq", "gic8refce", "gic_perq", "gic_freece", "gic6libz", "gic_fqs", "gic_frece", "gic_fz"], "val": ["count", "play", "Val", "pol", "base", "x", "pid", "sum", "config", "ref", "arg", "reg", "split", "loc", "code", "aval", "call", "bl", "al", "v", "end", "cal", "err", "type", "ld", "vals", "ee", "cond", "key", "mem", "serv", "rule", "value", "prop", "bc", "unit", "index", "eval", "ind", "live", "pre", "len", "alt", "sel", "test", "def", "ol", "num", "var", "data", "slot", "util", "rot", "sl", "part", "elt", "enc", "sol", "ret", "Value", "valid", "it", "scale", "bal", "win", "doc", "VAL", "el", "p", "lit", "pt", "sec", "vol", "fat", "pos", "fe"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int avfilter_register(AVFilter *filter)\n\n{\n\n    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)\n\n        return -1;\n\n\n\n    registered_avfilters[next_registered_avfilter_idx++] = filter;\n\n    return 0;\n\n}\n", "idx": 11444, "substitutes": {"filter": ["parent", "term", "b", "page", "block", "rule", "config", "cf", "search", "parser", "f", "ac", "entry", "alpha", "fl", "version", "v", "name", "event", "query", "feature", "guard", "apply", "object", "function", "user", "sort", "patch", "offset", "Filter", "root", "plugin", "type", "handler", "header", "attribute", "match"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n", "idx": 11449, "substitutes": {"errp": ["Erp", "errpe", " errtp", "Ertp", "nertp", "errpc", "Erpc", "errtp", " errpc", "nerp", " errpe", "Erpe", "nerpe", "nerpc"]}}
{"project": "qemu", "commit_id": "eefff991d059d299b917627d2a95bce34d2f97f3", "target": 1, "func": "int load_snapshot(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11455, "substitutes": {"name": ["parent", "alias", "NAME", "pass", "base", "n", "true", "g", "wa", "prefix", "key", "word", "all", "no", "id", "m", "again", "path", "x", "filename", "b", "block", "c", "time", "el", "names", "none", "nm", "j", "code", "label", "resource", "named", "size", "version", "new", "full", "part", "ns", "desc", "false", "error", "type", "ame", "null", "on", "url", "out", "image", "a", "Name"], "errp": ["erp", " errP", "errg", "ierapi", "errorpt", "mrapi", "arrapi", "errpatch", " erwp", "erP", "erfp", " erP", "errpr", "corpress", "errpre", "errpress", "Erwp", "argp", "argg", "ierpatch", "errt", "argping", "errwp", "arrpr", "arrping", "oderpress", "opp", "errorpre", "oppt", "ierpt", "opapi", "ErP", " erp", "mrpr", "errorfp", "errpp", " erpatch", "arrpt", "ierP", "Erpatch", "errorp", "errping", " errpa", "errorapi", "errP", "oderp", "ierp", "Erp", "aerpress", "arrg", "oderpa", "errfp", "yrpa", "yrpp", "erg", "opP", "errpt", "erping", " errpp", "erpre", "errorP", "mrp", "errapi", "mrpt", "cort", "aerpa", " errpre", "errpa", "yrp", "arrp", " errfp", "aert", "aerp", "corpp", "odert", "corp", "ierpr", "ierwp", "corpa"], "bs": ["vs", "boot", "base", "bb", "ds", "ba", "bid", "bas", "src", "b", "gs", "fb", "s", "ls", "pb", "cb", "gb", "bits", "js", "BS", "bc", "os", "obs", "cs", "bf", "bl", "eb", "lib", "sync", "sl", "las", "lb", "bot", "bis", "bi", "sb", "ns", "bytes", "hub", "sys", "platform", "null", "ps", "fs", "css", "bn", "ses", "ss", "android", "bing", "site", "bes", "bos"], "bs_vm_state": ["bs_vmksize", "bs_vm__start", "bs_mx__status", "bs_virtual_info", "bs_vmmstate", "bs_dm_states", "bs_vmkstate", "bs_vm_size", "bs_vmjstate", "bs_mx2address", "bs_mem_id", "bs_vm2status", "bs_vmmtype", "bs_vm_info", "bs_vm__state", "bs_vm6info", "bs_virtual_state", "bs_vm2address", "bs_vm2name", "bs_vm_connection", "bs_memjid", "bs_mem_state", "bs_mx__type", "bs_vmjkey", "bs_mx_status", "bs_dmjstates", "bs_vm__type", "bs_vm_status", "bs_mx__state", "bs_dm_state", "bs_mx_info", "bs_vm__address", "bs_memjsize", "bs_mx_address", "bs_vm_start", "bs_vm2data", "bs_virtual_id", "bs_vm_name", "bs_dmjstate", "bs_mx_state", "bs_vmkkey", "bs_vm6connection", "bs_mem_size", "bs_vmjsize", "bs_vm_type", "bs_cm_state", "bs_vm__info", "bs_mx2type", "bs_vm2config", "bs_vm__status", "bs_vm2state", "bs_mx2start", "bs_vm2type", "bs_vm6state", "bs_vm__states", "bs_vm2info", "bs_vmmstart", "bs_mx__info", "bs_dm_id", "bs_vm_address", "bs_vm_states", "bs_cm_name", "bs_vm_key", "bs_vm2start", "bs_vmkid", "bs_vmjstates", "bs_cm_data", "bs_vm_data", "bs_virtual_connection", "bs_dmjid", "bs_vmjid", "bs_vm6id", "bs_vm_id", "bs_cm_config", "bs_mem_key", "bs_vmmaddress", "bs_mx_type", "bs_vm_config", "bs_mx_start", "bs_memjkey", "bs_mx2state", "bs_vm__id", "bs_memjstate"], "sn": ["vi", "SN", "sp", "sh", "sv", "nb", "si", "n", "sf", "ny", "conn", "sw", "SB", "sa", "ls", " Sn", "cn", "dn", "sk", "cs", "fl", "syn", "sync", "sl", "sm", "Sn", "kn", "bi", "ns", "sb", "sd", "fn", "nc", "sys", "nu", "su", "ft", "ann", "bn", "ss", "sr", "ski", "vc", "nn", "sc"], "f": ["l", "rf", "conf", "fu", "lf", "fo", "fen", "n", "sf", "m", "fr", "fd", "t", "b", "z", "fw", "d", "i", "c", "fb", "s", "p", "e", "fit", "fp", "cb", "feed", "df", "j", "fa", "fm", "bf", "fl", "tf", "ln", "v", "r", "framework", "fin", "fn", "form", "h", "F", "file", "fs", "ft", "func", "inf", "fi", "fe", "fab", "fc"], "ret": ["fail", "red", "ref", "arg", "reg", "code", "al", "opt", "end", "att", "pret", "re", " RET", "let", "url", "ann", "resp", "arr", "rem", "flag", "val", "id", "Ret", "post", "value", "j", "res", "bf", "py", "det", "ner", "r", "ben", "en", "art", "rep", "error", "back", "mt", "rl", "rf", "ext", "str", "alt", "len", "def", "nt", " Ret", "num", "data", "reply", "status", "usr", "rt", "fun", "part", "after", "fin", "fn", "cat", "result", "success", "reset", "repl", "pass", "active", "info", "sur", "job", "run", "obj", "lit", "rets", "bit", "RET", "out", "ft", "rev", "match", "feat", "pet"], "aio_context": ["aioamcontext", "aiothecontext", "aout_context", "aiotheprivate", "aout_pointer", "aout_ctx", "aio_config", "aios_ctx", "aio_support", "aios_cert", "aioamconcept", "aio_pointer", "aios_resource", "aout_support", "aio_private", "aio_concept", "aio_cert", "aios_private", "aioamconfig", "aioamsession", "aios_concept", "aio_session", "aio_resource", "aiotheresource", "aios_context", "aiothectx", "aios_session", "aio_ctx", "aios_config"], "mis": ["me", "ts", "mn", "si", "mes", "json", "m", "model", "mr", "mas", "dj", "mm", "gm", "gs", "iss", "serv", "qs", "vis", "lu", "gp", "rs", "oci", "os", "fm", "res", "cs", "mi", "tis", "cas", "miss", "nas", "ns", "sis", "spec", "ms", "sys", "ma", "fs", "mc"]}}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,\n\n                                             ptrdiff_t buf_stride,\n\n                                             ptrdiff_t src_stride,\n\n                                             int block_w, int block_h,\n\n                                             int src_x, int src_y, int w, int h)\n\n{\n\n    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\n\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\n\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);\n\n}\n", "idx": 11468, "substitutes": {"buf": ["uf", "seq", "img", "cmp", "ff", "tc", "fd", "b", "bridge", "cp", "fb", "config", "pb", "cb", "fp", "queue", "cf", "rb", "ptr", "loc", "bc", "bt", "ctr", "alloc", "cv", "aux", "rc", "cur", "ctx", "conv", "port", "vec", "buff", "br", "proc", "buffer", "uc"], "src": ["seq", "rin", "img", "source", "sel", "http", "b", "RC", "sur", "config", "ref", "rib", "pb", "cb", "attr", "fp", "usr", "ptr", "rb", "loc", "tmp", "sub", "slice", "ctr", "rc", "sl", "sup", "cur", "conv", "sb", "secure", "url", "sr", "rob", "uc", "ssl", "sc"], "buf_stride": ["buf_brides", "buf_stide", "buf_bride", "buf_trride", "buf_arrine", "buf_striride", "buf_trides", "buf_striine", "buf_strides", "buf_striide", "buf_stides", "buf_strided", "buf_brride", "buf_strride", "buf_arride", "buf_stided", "buf_striided", "buf_brided", "buf_arrride", "buf_trided", "buf_strine", "buf_arrided", "buf_tride", "buf_brine"], "src_stride": ["src_trided", "src_shrides", "src_strides", "src_Strides", "src_strride", "src_tride", "src_shride", "src_striide", "src_brides", "src_strided", "src_brend", "src_Strided", "src_Strride", "src_shrend", "src_shrided", "src_brided", "src_brride", "src_trride", "src_Stride", "src_bride", "src_striides", "src_striided", "src_striend", "src_trides", "src_strend"], "block_w": ["block67x", "block67h", "block_W", "block_wx", "block67W", "block67wx", "block_wr", " block_wr", " block_W", "block_x", " block_wx", "block67wr", " block_x", "block67w"], "block_h": ["block_ha", "block67h", " block_ha", "block67hs", "block8ha", "block00hs", "block00ha", "block8h", "block67hi", " block_hs", "block00h", "block00oh", " block_oh", "block00w", "block8w", "block8oh", "block_oh", "block_hi", "block_hs", " block_hi", "block00hi", "block67w"], "src_x": [" src_i", " src_h", "src_h", "src_w", " src_asy", "src_i", "src_asy", " src_w"], "src_y": [" src_h", "src_h", " src_z", "src_iy", " src_iy", "src_z"], "w": ["wl", "l", "g", "wa", "win", "iw", "b", "x", "sw", "z", "wb", "fw", "d", "k", "wt", "c", "s", "work", "p", "wd", "wal", "wo", "hw", "f", "o", "v", "r", "wx", "aw", "u", "ew", "a", "y", "W", "weight", "ow"], "h": ["l", "hi", "he", "ht", "dh", "g", "ph", "hh", "m", "b", "x", "k", "z", "c", "hm", "p", "e", "gh", "eh", "f", "host", "ha", "v", "ih", "r", "hp", "how", "oh", "hs", "hd", "u", "H", "hl", "ah", "y", "ch", "rh", "uh"]}}
{"project": "FFmpeg", "commit_id": "a1a32fdb0ee63783d06c63b7d90bb382eea356ce", "target": 1, "func": "static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m)\n\n{\n\n    char *tx3g_ptr = avctx->extradata;\n\n    int i, box_size, font_length;\n\n    int8_t v_align, h_align;\n\n    int style_fontID;\n\n    StyleBox s_default;\n\n\n\n    m->count_f = 0;\n\n    m->ftab_entries = 0;\n\n    box_size = BOX_SIZE_INITIAL; /* Size till ftab_entries */\n\n    if (avctx->extradata_size < box_size)\n\n        return -1;\n\n\n\n    // Display Flags\n\n    tx3g_ptr += 4;\n\n    // Alignment\n\n    h_align = *tx3g_ptr++;\n\n    v_align = *tx3g_ptr++;\n\n    if (h_align == 0) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_LEFT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_LEFT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_LEFT;\n\n    }\n\n    if (h_align == 1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_CENTER;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_CENTER;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_CENTER;\n\n    }\n\n    if (h_align == -1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_RIGHT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_RIGHT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_RIGHT;\n\n    }\n\n    // Background Color\n\n    m->d.back_color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // BoxRecord\n\n    tx3g_ptr += 8;\n\n    // StyleRecord\n\n    tx3g_ptr += 4;\n\n    // fontID\n\n    style_fontID = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n    // face-style-flags\n\n    s_default.style_flag = *tx3g_ptr++;\n\n    m->d.bold = s_default.style_flag & STYLE_FLAG_BOLD;\n\n    m->d.italic = s_default.style_flag & STYLE_FLAG_ITALIC;\n\n    m->d.underline = s_default.style_flag & STYLE_FLAG_UNDERLINE;\n\n    // fontsize\n\n    m->d.fontsize = *tx3g_ptr++;\n\n    // Primary color\n\n    m->d.color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // FontRecord\n\n    // FontRecord Size\n\n    tx3g_ptr += 4;\n\n    // ftab\n\n    tx3g_ptr += 4;\n\n\n\n    m->ftab_entries = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n\n\n        box_size += 3;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp = av_malloc(sizeof(*m->ftab_temp));\n\n        if (!m->ftab_temp) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        m->ftab_temp->fontID = AV_RB16(tx3g_ptr);\n\n        tx3g_ptr += 2;\n\n        font_length = *tx3g_ptr++;\n\n\n\n        box_size = box_size + font_length;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp->font = av_malloc(font_length + 1);\n\n        if (!m->ftab_temp->font) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(m->ftab_temp->font, tx3g_ptr, font_length);\n\n        m->ftab_temp->font[font_length] = '\\0';\n\n        av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp);\n\n        if (!m->ftab) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        tx3g_ptr = tx3g_ptr + font_length;\n\n    }\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n        if (style_fontID == m->ftab[i]->fontID)\n\n            m->d.font = m->ftab[i]->font;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11488, "substitutes": {"avctx": ["afctx", "AVconfig", "avelc", "ahcontext", "evconfig", "ahctrl", "avectx", "AVctrl", "avecu", "AVpkg", "evcontext", "AVcontext", "avcu", "afcu", "aveconfig", "AVlc", "ajctx", "afconfig", "avlc", "ajcontext", "AVctx", "avconfig", "avcontext", "ajpkg", "avepkg", "evctx", "avctrl", "evctrl", "avpkg", "AVcu", "avecontext", "afcontext", "ajlc", "ahconfig", "ahctx"], "m": ["l", "ym", "km", "man", "dim", "me", "em", "mn", "context", "n", "g", "w", "mr", "bm", "b", "t", "mm", "gm", "k", "d", "z", "c", "s", "p", "hm", "e", "mu", "machine", "pm", "q", "f", "nm", "an", "j", "fm", "o", "module", "v", "mi", "md", "r", "ctx", "am", "im", "sm", "mod", "ms", "tm", "u", "dm", "h", "cm", "y", "um", "rm", "M", "mc", "om"], "tx3g_ptr": ["tx3gen_ptr", "tx3ga_dr", "tx3vgFcur", "tx3vgFPtr", "tx3d_Ptr", "tx3gen_handle", "tx3g__handle", "tx3vg_inter", "tx3gUptr", "tx3g__dra", "tx3gFinter", "tx3gJptr", "tx3g__ptr", "tx3gJpointer", "tx3g_inter", "tx3g_pert", "tx3gs_cur", "tx3genJhandle", "tx3vg_Ptr", "tx3gu_cur", "tx3d_length", "tx3gen_sth", "tx3g_offset", "tx3gu_addr", "tx3d_struct", "tx3g_length", "tx3d_dr", "tx3n_ctr", "tx3gUsth", "tx3vg_cur", "tx3genJsth", "tx3gs_sth", "tx3gen_pointer", "tx3d_pointer", "tx3g__pointer", "tx3gs_ptr", "tx3vgFptr", "tx3ga_pert", "tx3d_pad", "tx3g_pad", "tx3gu_pointer", "tx3g_cur", "tx3vg_ptr", "tx3n_Ptr", "tx3d_ptr", "tx3g_sth", "tx3gFPtr", "tx3g_struct", "tx3g_handle", "tx3gJhandle", "tx3gFptr", "tx3g__dr", "tx3d_offset", "tx3vgFinter", "tx3gen_dr", "tx3gUhandle", "tx3gen_dra", "tx3genJptr", "tx3gUpointer", "tx3gu_ptr", "tx3g_dr", "tx3genJpointer", "tx3g_ctr", "tx3gs_pointer", "tx3g_dra", "tx3ga_ptr", "tx3ga_pointer", "tx3g_pointer", "tx3n_addr", "tx3g_Ptr", "tx3g_addr", "tx3gFcur", "tx3gJsth", "tx3n_ptr", "tx3g__pert"], "i": ["area", "field", "n", "id", "b", "d", "c", "p", "e", "ie", "j", "ai", "v", "name", "ti", "pi", "ii", "ime", "type", "I", "ip", "ci", "a", "io", "length", "iu"], "box_size": ["font2count", "box64len", "box1data", "box64range", "boxetrange", "box1type", "box64size", " box1size", "boxetsize", "font_count", "box2limit", "box_count", "box64shape", "box1size", "box2capacity", "line_shape", "box2data", "box2count", "box_range", "box64SIZE", "box_type", "line_len", "line_size", "boxsshape", "box_SIZE", "line64len", " box1capacity", "box64count", "box_data", "boxlensize", "box_capacity", "font2size", "font_limit", " box1data", "font2SIZE", "box_shape", "box1capacity", "boxlencapacity", " box_type", " box1type", "boxslen", "boxlendata", "line64size", "box2type", "boxlentype", "line64range", "font2limit", " box_capacity", "boxetlen", "line64shape", "boxetshape", "boxssize", "box2SIZE", "box2size", "font_size", "box64limit", "boxsrange", "box_limit", "box_len", "font_SIZE", "line_range", " box_data"], "font_length": ["box_length", "fontaclen", "fontacposition", "box_position", "font_len", "fontacsize", "fontaclength", "font_position", "font_size", "box_len"], "v_align": ["v_chain", "h_aligned", "vialwork", "v2width", "h_work", "vialinline", "h_label", "v___alpha", "v_aligned", " v_alias", " v_width", "v_lead", "h_adjust", "vocalign", "v_alpha", "v___width", "v_aff", "viallead", "v_margin", "h_balance", "v___align", " v_aligned", "v2align", "h_chain", "h_aff", "v_alias", "v_lock", "v_work", "voctail", "voccenter", "h_lock", "h_center", "voclead", "vialmargin", " v_label", "h_tail", "v_balance", "h_margin", "h_repeat", "v_width", "h_lead", "v_fill", "vialalign", "v_inline", "v2label", "v_center", "h_alias", "v_tail", "v_label", " v_lead", "v___label", "v_adjust", "v_repeat", "v2alpha", "h_fill", "v_drop", " v_alpha", "h_inline", "vialbalance", "h_drop"], "h_align": ["h_aligned", "hamalign", "h__align", "v_square", "v_lead", "hp_align", "hIPaligned", "hpIPaligned", "hIPsize", "h_size", "hamlead", "v_margin", "h_balance", "hpIPsize", "hp_aligned", "h__margin", "hacgap", "h__fill", "h_equal", "v_equal", "h_scale", "hamsquare", "hIPalign", "hamequal", "v_balance", "h_dim", "h_margin", "hIPscale", "v_gap", "h_lead", "h__gap", "v_fill", "h__lead", "v_dim", "h__balance", "h_gap", "hp_scale", "hacdim", "hacbalance", "hpIPscale", "h_fill", "hpIPalign", "hacalign", "hp_size", "h_square"], "style_fontID": ["style_styleID", "style_textId", "style_textID", "style_styleid", "style_textid", "style_fontId", "style_fontid", "style_textName", "style_styleIDs", "style_fontIDs", "style_sheetName", "style_sheetID", "style_sheetIDs", "style_textIDs", "style_styleId", "style_fontName"], "s_default": [" s_best", "styles_def", " s_Default", "styles_standard", "s_def", "s_best", "sOCKdefault", "styles_basic", " s_internal", "sOCKdef", "s_password", "sOCKstandard", " s_standard", " s_guide", "s_basic", " s_password", "s_Default", "sOCKbasic", "s_guide", "styles_default", "s_internal", "s_standard"]}}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 11501, "substitutes": {"chr": ["cr", " chra", "ichm", "csr", "Chre", "cra", "chra", "ichre", " chsr", "ichsr", "car", "chsr", "Chra", "Chm", "Char", "chre", "Chr", "Chsr", "Chmr", "chmr", "chm", " chre", " chmr", "ichmr", " chm", "ichr"], "mouse": ["voice", "parent", "mac", "cookie", "me", "key", "chrome", "m", "phy", "poke", "pointer", "wire", "bridge", "rule", "close", "server", "circle", "bug", "gro", "hover", "click", "mid", "sym", "ctrl", "ae", "shape", "Mouse", "scope", "master", "move", "input", "query", "event", "remote", "state", "ctx", "inner", "address", "nick", "copy", "cue", "controller", "self", "handler", "cm", "press", "mc"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n", "idx": 11516, "substitutes": {"ret": ["flag", "active", "ext", "alt", "val", "len", "ry", "key", "def", "test", "info", "nt", "Ret", "id", "t", "pat", "data", "run", "arg", "lit", "ref", "obj", "reg", "iter", "code", "rt", "py", "det", "try", "live", "end", "fun", "desc", "art", "get", "bit", "xt", "type", "re", "et", "RET", "cat", "back", " RET", "out", "result", "ft", "match", "feat", "pet"]}}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "substitutes": {"tmpenv": [" tmpen", "nowenv", "tmpen", "tmpv", " tmpv", "fakeenc", "tempconfig", "tmpenvironment", "testenv", "testconfig", "ntenv", " tmpenc", "ntenvironment", "tmpenc", "fakeen", "testenvironment", "tempviron", "ntviron", "fakeenvironment", " tmpconfig", "tempen", "tempenc", "tempenvironment", "nowenvironment", "testv", " tmpviron", "nowviron", " tmpenvironment", "tempenv", "fakeenv", "tmpconfig", "tmpviron", "tempv"], "envvar": ["encvar", "environmentname", "senconst", "environmentVar", "environmentver", "environmentlist", "encVar", " envVar", "envlist", "environmentvar", "encvari", "envcat", "evvari", "environmentcat", " envstack", " envname", "enbar", "evVar", "enccat", "envconst", "evname", "envbar", "envver", " envbar", "environmentconst", "envname", "environmentstack", "envvari", "envstack", "envVar", " envvari", " envlist", " envcat", " envconst", "enlist", "environmentvari", "senlist", "evvar", " envver", "encver", "senvar", "envar", "environmentbar", "enstack"], "envsave": ["enstsaved", "ennsave", " ensssave", " enssaved", "elstsaving", "enversaving", "envsource", "enssave", "encsave", "elstsaved", "envssave", " envssave", " enversaving", "ensssave", "envsaves", "elvsaved", "elstsave", "envalsave", "envsaving", "encsaves", " envsaver", " envsaves", "encssave", "elvsaving", " enversaves", "ennssave", "envaving", "envource", "elstsource", "enversave", " enversave", "enstsaving", " enversaver", "ennsaves", "ennsaving", "enversaves", " envsaved", "elvsave", "elvsource", "ennsaver", "envaved", "envalsaves", " enssaves", "envsaver", "enstsave", "encsaved", " envsaving", "envalsaver", "enstsource", "envalsaving", "envsaved", " enssave", "enssaves", "ennsaved", "envave", "enversaver", "enssaved", "ennsource"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    unsigned char tag[5];\n\n    unsigned int flags = 0;\n\n    const int stream_index = pkt->stream_index;\n\n    int size               = pkt->size;\n\n    AVIContext *avi     = s->priv_data;\n\n    AVIOContext *pb     = s->pb;\n\n    AVIStream *avist    = s->streams[stream_index]->priv_data;\n\n    AVCodecParameters *par = s->streams[stream_index]->codecpar;\n\n\n\n    while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE &&\n\n           pkt->dts > avist->packet_count) {\n\n        AVPacket empty_packet;\n\n\n\n        av_init_packet(&empty_packet);\n\n        empty_packet.size         = 0;\n\n        empty_packet.data         = NULL;\n\n        empty_packet.stream_index = stream_index;\n\n        avi_write_packet(s, &empty_packet);\n\n    }\n\n    avist->packet_count++;\n\n\n\n    // Make sure to put an OpenDML chunk when the file size exceeds the limits\n\n    if (pb->seekable &&\n\n        (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) {\n\n        avi_write_ix(s);\n\n        ff_end_tag(pb, avi->movi_list);\n\n\n\n        if (avi->riff_id == 1)\n\n            avi_write_idx1(s);\n\n\n\n        ff_end_tag(pb, avi->riff_start);\n\n        avi->movi_list = avi_start_new_riff(s, pb, \"AVIX\", \"movi\");\n\n    }\n\n\n\n    avi_stream2fourcc(tag, stream_index, par->codec_type);\n\n    if (pkt->flags & AV_PKT_FLAG_KEY)\n\n        flags = 0x10;\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avist->audio_strm_length += size;\n\n\n\n    if (s->pb->seekable) {\n\n        int err;\n\n        AVIIndex *idx = &avist->indexes;\n\n        int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE;\n\n        int id = idx->entry % AVI_INDEX_CLUSTER_SIZE;\n\n        if (idx->ents_allocated <= idx->entry) {\n\n            if ((err = av_reallocp(&idx->cluster,\n\n                                   (cl + 1) * sizeof(*idx->cluster))) < 0) {\n\n                idx->ents_allocated = 0;\n\n                idx->entry          = 0;\n\n                return err;\n\n            }\n\n            idx->cluster[cl] =\n\n                av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry));\n\n            if (!idx->cluster[cl])\n\n                return -1;\n\n            idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE;\n\n        }\n\n\n\n        idx->cluster[cl][id].flags = flags;\n\n        idx->cluster[cl][id].pos   = avio_tell(pb) - avi->movi_list;\n\n        idx->cluster[cl][id].len   = size;\n\n        idx->entry++;\n\n    }\n\n\n\n    avio_write(pb, tag, 4);\n\n    avio_wl32(pb, size);\n\n    avio_write(pb, pkt->data, size);\n\n    if (size & 1)\n\n        avio_w8(pb, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 11527, "substitutes": {"s": ["tags", "session", "is", "http", "t", "sci", "gs", "parts", "parser", "plugins", "v", "bis", "ns", "spec", "self", "settings", "sg", "ds", "si", "php", "sf", "b", "i", "c", "sam", "e", "request", "sq", "us", "types", "f", "sym", "slice", "sets", "es", "r", "ps", "su", "fs", "ss", "sv", "g", "src", "small", "d", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "sn", "sb", "sys", "single", "a", "ssl", "ts", "uploads", "service", "p", "qs", "xs", "js", "rs", "aws", "S", "sie", "services", "pc", "ses", "bs"], "pkt": ["cpacket", "mk", " packet", "produqt", " pke", "rkg", "upkg", "ukt", " pkg", " punt", "Pke", "racket", "Pnt", " pnt", "punt", "upunt", "Pelt", "rct", "cppt", "Pqt", "apqt", "apct", "Pkt", "cpk", "pqt", "pk", "produacket", "cpkt", "apkt", "Pkg", "mkt", "produelt", " pqt", "packet", "uke", "rkt", " pk", "mpt", "Pct", "pnt", "Punt", "Packet", "unt", "produkt", "pke", "macket", "pelt", "upkt", " pct", "ppt", "apnt", "pct", "upacket", "pkg", "uct", " ppt", " pelt"], "tag": ["tags", " Tag", "peg", "bb", "img", "wp", "len", "g", "class", "id", "tc", "pl", "small", " tags", "buf", "capt", "block", "data", "ref", "reg", "Tag", "at", "ag", "bug", "loc", "rb", "rss", "ac", "code", "mp", "slice", "rc", "ar", "bis", "desc", "enc", "root", "TAG", "cat", "type", "pos", "null", "length", "image", "uc", "fe", "sc"], "avi": ["oi", "avan", "vi", "ani", "voice", "archive", "di", "music", "si", "media", "adi", "liv", "nav", "wikipedia", "opus", "ami", "ini", "vim", "iv", "oga", "sa", "metadata", "asu", "jam", "audi", "attr", "aaa", "afi", "mic", "eni", "abo", "pai", "ai", "mp", "umi", "mi", "ti", "ave", "addin", "photo", "ava", "abi", "picture", "audio", "bi", "ii", "wi", "avia", "iva", "omi", "api", "av", "ci", "video", "director", "ori", "aim", "imi", "fi", "anti", "vp"], "pb": ["lp", "dp", "uf", "wp", "ppa", "pg", "nb", "proc", "pit", "bp", "prot", "pl", "tc", "bm", "b", "lab", "apy", "ab", "wb", "pa", "pp", "cp", "fb", "p", "pd", "cb", "fp", "ub", "np", "gb", "pro", "opus", "pm", "rb", "prop", "parser", "bc", "pai", "db", "mp", "py", "amp", "bps", "bh", "phrase", "ctx", "abi", "lb", "tp", "jp", "sb", "pc", "PB", "summary", "cpp", "hub", "platform", "api", "fc", "ps", "rob", "bs", "typ", "bos", "vp"], "avist": ["apists", "affism", "apist", "akists", "aphert", "avinst", "affinst", "avIST", "aimIST", "aimart", "avists", "avista", "akista", "affert", "ivart", "avert", "afists", "avart", "ajism", "ivism", "affist", "akist", "apIST", "aimists", "ajist", " avict", " avists", "ajict", "ajinst", "ajert", "afist", "aphism", "AVart", "avict", "avism", " avart", " avost", "avpect", " avIST", "AVists", "avost", " avism", "ajart", " avista", "aphinst", "AVist", "aphist", "ivist", "apost", "akpect", "AVIST", "akIST", " avpect", "ivict", "afpect", "aimist", "afista", "akost"], "par": ["dp", "sp", "adr", "param", "co", "cmp", "war", "fr", "mm", "pa", "pp", "serv", "var", "player", "har", "p", "particip", "arg", "pro", "car", "po", "arp", "prop", "parser", "sk", "dr", "mp", "py", "parse", "cap", "asi", "rc", "pac", "ar", "pr", "r", "pre", "pard", "pi", "part", "pc", "spec", "pal", "as", "cat", "prep", "api", "params", "ps", "comp", "proc", "per"], "empty_packet": ["empty_octetter", "empty_compel", "empty_Packet", "empty_pacacket", "empty_bucketter", "empty_Packel", "empty_compset", "empty_packsette", "empty_sexetic", "empty_processet", "empty_capeting", "empty_packageacket", "empty_sexacket", "empty_compet", "empty_packetic", "empty_packsets", "empty_packset", "empty_sexet", "empty_packetter", "empty_packageet", "empty_kwacket", "empty_pacet", "empty_bucket", "empty_sexetter", "empty_packeting", "empty_processacket", "empty_caplet", "empty_compect", "empty_competter", "empty_octacket", "empty_octet", "empty_bucketer", "empty_packageets", "empty_packect", "empty_Packect", "empty_paclet", "empty_packageette", "empty_sexeter", "empty_planet", "empty_kwet", "empty_packeter", "empty_octeter", "empty_Packacket", "empty_complet", "empty_kwect", "empty_packel", "empty_packen", "empty_planetic", "empty_compette", "empty_buckset", "empty_buckacket", "empty_paceting", "empty_packacket", "empty_planacket", "empty_compets", "empty_kwel", "empty_packets", "empty_packlet", "empty_processen", "empty_capet", "empty_sexen", "empty_packette", "empty_competing", "empty_planen", "empty_packsacket", "empty_capacket", "empty_processetic", "empty_compacket"], "packet_count": ["packet__id", "packacket_total", "packet__count", "packetxpointer", "packetfullcount", "packetfullpointer", "packacket_id", "packetxtotal", "packet_total", "packetxcount", "packet__code", "packet_code", "packet__size", "packet_size", "packacket_pointer", "packetfulltotal", "packacket_code", "packacket_count", "packet_pointer", "packacket_size", "packet_id"], "err": ["l", "map", "seq", "arr", "flag", "def", "stats", "info", "all", "pl", "z", "num", "stat", "var", "loc", "f", "code", "rc", "r", "desc", "error", "sign", "col", " error", "file", "resp", "fe"], "idx": ["Idx", " idxs", "seq", "Idz", "idex", " idz", "_", "src", "idz", "indx", "buf", " idex", "indxs", "obj", " idxc", "Idex", "idxc", "indz", "index", "idc", "indxc", "Idxs", " idc", "indc", "Idc", "Idxc", "this", "type", "pos", "idxs", "write", "buffer"], "entry": ["member", "session", "element", "archive", "Entry", "it", "start", "enter", "key", "id", "no", "nt", "ent", "data", "reader", "set", "sec", "mission", "way", "child", "index", "try", "inc", "rc", "ries", "connection", "end", "ident", "part", "desc", "error", "offset", "get", "orig", "lock", "row", "import", "image", "insert"]}}
{"project": "FFmpeg", "commit_id": "0d021cc8b30a6f81c27fbeca7f99f1ee7a20acf8", "target": 0, "func": "static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)\n\n{\n\n    if (err != CUDA_SUCCESS) {\n\n        av_log(avctx, AV_LOG_FATAL, \">> %s - failed with error code 0x%x\\n\", func, err);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 11529, "substitutes": {"avctx": ["afctx", " avpkg", "avc", "Avcit", "capcu", "AVc", "afc", "AVpkg", "capc", "AVcontext", "avcu", "AVcit", "afcu", "avcit", "AVctx", "capcontext", " avcontext", "avcontext", "Avctx", "capctx", "avpkg", "AVcu", " avcit", "afcontext", "Avpkg", "Avcontext"], "err": ["arr", "bad", "str", "proc", "rage", "all", "unc", "mr", "rr", "kr", "cer", "pointer", "var", "data", "doc", "c", "p", "Error", "ace", "status", "attr", "cb", "e", "iter", "or", "bug", "args", "rs", "er", "lr", "ac", "dr", "ie", "code", "next", "call", "exc", "msg", "rc", "r", "fun", "req", "inner", "error", " error", "type", "result", "Er", "sr", "resp", "fee", "fi", "fe", "runner"], "func": ["seq", "context", "val", "go", "unc", "buf", "doc", "data", "addr", "stack", "package", "cb", "wrapper", "attr", "cf", "lambda", "args", "Function", "cc", "f", "pkg", "call", "name", "fun", "r", "ctx", "function", "callback", "pc", "error", "self", "fee", "cmd", "proc", "expr", "ln", "exec"]}}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    const AVCodec *dec;\n\n    char val_str[128];\n\n    const char *s;\n\n    AVRational sar, dar;\n\n    AVBPrint pbuf;\n\n\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n\n\n    print_int(\"index\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        const char *profile = NULL;\n\n        dec = dec_ctx->codec;\n\n        if (dec) {\n\n            print_str(\"codec_name\", dec->name);\n\n            if (!do_bitexact) {\n\n                if (dec->long_name) print_str    (\"codec_long_name\", dec->long_name);\n\n                else                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        } else {\n\n            print_str_opt(\"codec_name\", \"unknown\");\n\n            if (!do_bitexact) {\n\n                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        }\n\n\n\n        if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile)))\n\n            print_str(\"profile\", profile);\n\n        else\n\n            print_str_opt(\"profile\", \"unknown\");\n\n\n\n        s = av_get_media_type_string(dec_ctx->codec_type);\n\n        if (s) print_str    (\"codec_type\", s);\n\n        else   print_str_opt(\"codec_type\", \"unknown\");\n\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        print_str(\"codec_tag_string\",    val_str);\n\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            print_int(\"width\",        dec_ctx->width);\n\n            print_int(\"height\",       dec_ctx->height);\n\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n\n            sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n\n            if (sar.den) {\n\n                print_q(\"sample_aspect_ratio\", sar, ':');\n\n                av_reduce(&dar.num, &dar.den,\n\n                          dec_ctx->width  * sar.num,\n\n                          dec_ctx->height * sar.den,\n\n                          1024*1024);\n\n                print_q(\"display_aspect_ratio\", dar, ':');\n\n            } else {\n\n                print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n\n                print_str_opt(\"display_aspect_ratio\", \"N/A\");\n\n            }\n\n            s = av_get_pix_fmt_name(dec_ctx->pix_fmt);\n\n            if (s) print_str    (\"pix_fmt\", s);\n\n            else   print_str_opt(\"pix_fmt\", \"unknown\");\n\n            print_int(\"level\",   dec_ctx->level);\n\n            if (dec_ctx->timecode_frame_start >= 0) {\n\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n\n                av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n\n                print_str(\"timecode\", tcbuf);\n\n            } else {\n\n                print_str_opt(\"timecode\", \"N/A\");\n\n            }\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            s = av_get_sample_fmt_name(dec_ctx->sample_fmt);\n\n            if (s) print_str    (\"sample_fmt\", s);\n\n            else   print_str_opt(\"sample_fmt\", \"unknown\");\n\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n\n            print_int(\"channels\",        dec_ctx->channels);\n\n\n\n            if (dec_ctx->channel_layout) {\n\n                av_bprint_clear(&pbuf);\n\n                av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout);\n\n                print_str    (\"channel_layout\", pbuf.str);\n\n            } else {\n\n                print_str_opt(\"channel_layout\", \"unknown\");\n\n            }\n\n\n\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            if (dec_ctx->width)\n\n                print_int(\"width\",       dec_ctx->width);\n\n            else\n\n                print_str_opt(\"width\",   \"N/A\");\n\n            if (dec_ctx->height)\n\n                print_int(\"height\",      dec_ctx->height);\n\n            else\n\n                print_str_opt(\"height\",  \"N/A\");\n\n            break;\n\n        }\n\n    } else {\n\n        print_str_opt(\"codec_type\", \"unknown\");\n\n    }\n\n    if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n\n        const AVOption *opt = NULL;\n\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n\n            uint8_t *str;\n\n            if (opt->flags) continue;\n\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n\n                print_str(opt->name, str);\n\n                av_free(str);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n\n    else                                          print_str_opt(\"id\", \"N/A\");\n\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n\n    print_q(\"time_base\",      stream->time_base,      '/');\n\n    print_ts  (\"start_pts\",   stream->start_time);\n\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n\n    print_ts  (\"duration_ts\", stream->duration);\n\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n\n    if (dec_ctx->bit_rate > 0) print_val    (\"bit_rate\", dec_ctx->bit_rate, unit_bit_per_second_str);\n\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n\n    if (do_show_data)\n\n        writer_print_data(w, \"extradata\", dec_ctx->extradata,\n\n                                          dec_ctx->extradata_size);\n\n\n\n    /* Print disposition information */\n\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n\n    } while (0)\n\n\n\n    if (do_show_stream_disposition) {\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n\n    PRINT_DISPOSITION(DUB,              \"dub\");\n\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n\n    writer_print_section_footer(w);\n\n    }\n\n\n\n    show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n\n    fflush(stdout);\n\n}\n", "idx": 11535, "substitutes": {"w": ["wl", "world", "wp", "wa", "window", "rw", "m", "sw", "x", "t", "fw", "wav", "wb", "wt", "c", "p", "we", "reader", "xml", "wr", "wcs", "writer", "q", "wal", "wo", "writers", "hw", "r", "wx", "kw", "wu", "u", "self", "ew", "W", "ow", "tw"], "fmt_ctx": ["fmt_context", "fmt2context", "fmt_tx", "frt_ci", "frt_ctx", "fnt_ctx", "frt_context", "fmtfci", "fmtfcontext", "frt_cf", "fmt_cf", "fnt2tx", "fmt2lc", "fmt2ctx", "fnt2ctx", "fmtfctx", "fnt_tx", "fmt_ci", "fmt_lc", "fmt2tx", "fnt_context", "fnt2lc", "fnt2context", "fnt_lc", "fmtfcf"], "stream_idx": ["stream_idy", "stream_midxs", "stream_infov", "stream_idsx", "stream_infoxs", "stream_midx", "stream_idv", "stream_infoy", "stream_indr", "stream_startx", "stream_indxs", "stream_infox", "stream_midr", "stream_midv", "stream_indv", "stream_startxs", "stream_idsy", "stream_idr", "stream_idsxs", "stream_startr", "stream_idxs", "stream_startv", "stream_idsv", "stream_indx"], "in_program": ["inCsection", "in1context", "in1section", " in_command", " in_context", "in_context", "in1program", "inCcontext", "in_command", "inCProgram", "inCprogram", " in_section", " in_Program", "in_section", " in_path", "in_path", "in_Program", "in1Program"], "stream": ["channel", "context", "ack", "source", "view", "m", "stage", "model", "src", "fr", "tag", "path", "sw", "rec", "pool", "data", "draw", "reader", "output", "feed", "writer", "coll", "resource", "ream", "draft", "wave", "input", "track", "inc", "sl", "cur", "document", "desc", "form", "Stream", "transform", "row", "length", "func", "uc", "sc"], "dec_ctx": ["Dec_ci", " dec_cmp", "decallcas", "genallqa", "decacctx", "rec2context", "genalllc", "dec_cm", "Dec_wcs", "enc_jc", "decLctx", "dec_lc", "draw_loc", "desc_cm", "enc_sync", "Dec_context", "dec_hi", "dec_func", "dev_loc", "dev_ctx", "decJtx", "dec2la", "decaccm", "drawPsys", "desc_cmp", " dec_context", "decacsys", "rec_context", "enc_context", "decallqa", "rec_tx", "enc_ctx", "dec_ci", "dec_sync", "dec2tx", "decPsys", "dec_loc", "gen_cas", "decaccmp", "decJfunc", "genallcas", "enc_lc", "gen_qa", "dec_cmp", "dec2ctx", "desc_sys", "draw_sys", "gen_lc", "decallctx", "decLsys", "desc_ctx", "draw_ctx", "dev_func", "genallctx", "drawPhi", "dec_cas", "decPcontext", "deckscope", "decPctx", "decPhi", "rec2ctx", "decLloc", "dec_wcs", "deckcontext", "decJctx", "decklc", "dec_jc", "decpljc", "dec_qa", "dev_tx", "decalllc", "dec_tx", "enc_loc", " dec_tx", "dec_la", "decLci", "dec_scope", "decLcontext", "decplsync", "rec_la", "decPloc", "rec2la", "dec_sys", "draw_hi", "Dec_ctx", "drawPctx", "deckctx", "decplctx", "dec_context", "drawPloc", "decJloc", "rec2tx", "dec2context", "enc_scope", "decPci", "gen_ctx", "decLwcs", "decLhi", "rec_ctx", "decPwcs", "decplloc"], "val_str": ["tag_str", "val2arr", "enc_str", "encingspec", "val_div", "valenname", "val2string", "encingstr", "valnspec", "valenstr", "valingorig", "valnorig", "tagenstring", "val_name", "tag_string", "len_Str", "valendiv", " val_string", "encingorig", "len_str", "val_vec", "valenstring", "val_spec", "tag_name", "valingstr", "val2div", "valingspec", " val_arr", "val_string", "tag_div", "enc_spec", "valnstr", "enc_vec", " val_int", "val_int", "valingvec", "enc_orig", "tagendiv", "val_Str", "len_arr", "val2Str", "val_arr", "tagenname", "tagenstr", "val2str", "valnvec", "val2name", "val_orig", "len_string", "encingvec"], "s": ["session", "sg", "ts", "sv", "ds", "si", "g", "is", "n", "its", "m", "b", "t", "i", "gs", "sa", "c", "service", "iss", "p", "ls", "e", "se", "args", "rs", "sq", "types", "f", "os", "sub", "o", "S", "v", "series", "space", "sl", "services", "r", "sn", "sb", "ns", "spec", "type", "sys", "h", "a", "fs", "su", "site", "ses", "ss", "ssl", "sc", "security"], "sar": ["sAR", "alsAR", "BAR", "inAR"], "dar": [" var", "AR", "arc", "arr", " true", "ARR", "rw", "src", "SEC", "var", " sr", "serial", "sec", " nil", "ar", "r", "err", " dc", "desc", "row", "sc"], "pbuf": [" pbn", "bpbuf", "bpfp", "pbn", " pbuffer", "lpbuf", "prebuf", "lpfp", "buf", "pbuffer", "prebuff", "pfp", "bbuf", " puf", "pbuff", " pbuff", "puf", "bpcv", " pcv", "bbuff", "lpcv", "pcv", " pfp", "bpbn", "preuf", "prebuffer", "lpbn", "bbuffer"], "profile": ["parent", "alias", "pse", "member", "base", "character", "mobile", "val", "ph", "prof", "key", "method", "model", "phy", "gor", "tag", "path", "filename", "shadow", "p", "username", "role", "pe", "thin", "style", "label", "unit", "primary", "Profile", "version", "beta", "description", "name", "prime", "account", "fat", "sl", "feature", "pr", "program", "photo", "user", "option", "phone", "desc", "community", "summary", "mo", "pal", "type", "platform", "file", "header", "su", "person", "image", "use", "match", "family", "picture", "face", "gender"]}}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}", "idx": 11543, "substitutes": {"gb": ["GB", "gu", "ui", "gd", "boot", "bb", "pg", "nb", "g", "gio", "gpu", "phy", "bm", "b", "game", "gm", "wb", "gs", "bridge", "gin", "bo", "gp", "rb", "gt", "gal", "bug", "gh", "bc", "gy", "binary", "db", "bf", "cgi", "eb", "bg", "gate", "agg", "ig", "lib", "gi", "sync", "gg", "ctx", "gem", "lb", "ga", "sb", "pc", "usb", "git", "dc", "storage", "hub", "plugin", "gru", "gc", "cfg", "rg", "vg", "ge", "bin", "buff", "gam", "kb", "mb"], "block": ["channel", "Block", "session", "byte", "co", "bb", "board", "b", "bridge", "line", "batch", "config", "pixel", "loc", "coll", "group", "bc", "db", "unit", "bl", "device", "gate", "ck", "query", "ctx", "tx", "blocks", "bus", "pc", "ko", "node", "bit", "hub", "plugin", "spec", "lock", "self", "row", "bin", "cache", "buffer", "range"], "scan": ["mac", "scale", "comment", "src", "unc", "doc", "gain", "config", "cs", "parse", "gate", "sync", "rc", "query", "feature", "raw", "circ", "pc", "spec", "enc", "cat", "gc", "dev", "cache", "bin", "proc", "gam", "sc", "acc"], "quant": ["fix", "comment", "prefix", "depth", "pad", "complex", "quad", "total", "num", "doc", "gain", "draw", "util", "vis", "q", "wait", "input", "query", "raw", "circ", "cost", "frac", "spec", "transform", "gap", "comp", "cache", "gam", "acc"], "coeff": ["coef", "coefficients", "cef", "colefficient", "colef", " coefficients", "koeff", "COef", "coff", "ceff", "ceffect", "COeffect", "coleff", "Coeffect", "Coefficient", "collef", "Coff", "colefficients", "COefficient", "coeffect", "goefficient", "cefficient", "Coefficients", " coef", "colleff", "collff", "COeff", "COff", "goeff", "collefficient", "coefficient", "COefficients", "koef", "Coeff", "koefficient", "goef", " coefficient", " coeffect", " coff", "goefficients", "koeffect", "Coef"], "i": ["ui", "it", "g", "si", "in", "m", "id", "b", "k", "d", "c", "p", "f", "ai", "index", "mi", "ar", "r", "pi", "bi", "ii", "I", "ip", "ci", "a"], "n": ["nb", "g", "w", "m", "k", "b", "num", "d", "c", "p", "e", "f", "an", "o", "N", "name", "r", "sn", "nr", "ns", "nan", "nc", "ni", "y", "nn"], "ac": ["sac", "mac", "oc", "Ac", "ack", "abc", "jac", "tc", "unc", "auc", "k", "c", "ad", "cu", "ace", "iac", "fact", "act", "mic", "ec", "loc", "ak", "bc", "cc", "op", "ai", "cs", "alpha", "acs", "inc", "input", "ic", "cas", "am", "ga", "acl", "circ", "pc", "dc", "spec", "enc", "disc", "cat", "nc", "aa", "ca", "fc", "a", "AC", "comp", "fac", "lc", "anc", "cache", "vc", "mc", "uc", "acc", "rac"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 11546, "substitutes": {"t0": ["t4", "pt2", "ct1", " t4", "f1", "f100", "pt0", "T10", "p2", "T2", "p100", "T0", "f4", "f10", "pt100", "ct2", "p10", " t10", "f2", "ct0", "t100", "p0", "p1", "T1", "t10", "pt1", "p4", "t2", "f0", " t2"], "t1": ["nt01", "f1", "f01", "p2", "T2", " t9", "T0", "T9", " t3", "kt1", "kt2", "kt01", "f2", "nt2", "t12", "p0", "p01", "t3", "p1", "t6", "f12", "T1", "p12", "T6", " t01", "v01", "p3", " t12", "f6", "t9", "f3", "t01", " t6", "v2", "nt1", "v1", "t2", "T3", "f0", "p9", " t2"], "rd": ["ld", "rf", "dra", "diff", "adr", "ru", "td", "RD", "std", "ds", "tr", "hr", "ord", "rw", "xx", "src", "mr", "rr", "fd", "RB", "rod", "d", "ra", "red", "bd", "cd", "attr", "wr", "rb", "ptr", "rs", "lr", "dr", "rt", "dat", "rust", "xd", "nd", "rc", "r", "md", "dd", "dc", "rn", "vr", "rx", "rg", "rob", "RR", "rh", "rl", "rm"], "tmp": ["img", "cmp", "tr", "rw", "fd", "tt", "vt", "fb", "config", "pb", "cb", "attr", "np", "txt", "dist", "st", "bt", "amp", "now", "xt", "buff", "bb", "abb", "tc", "db", "py", "md", "TB", "rob", "kk", "rf", "tab", "etc", "ff", "test", "temp", "nt", "src", "mm", "wb", "buf", "cp", "ptr", "rb", "xxx", "rt", "rc", "req", "tp", "sb", "tm", "vr", "eddy", "td", "xxxxxxxx", "Temp", "stuff", "cro", "mp", "dd", "rm"]}}
{"project": "FFmpeg", "commit_id": "6722e564a82bac471d92b02550b5017c09b539ba", "target": 0, "func": "static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n\n{\n\n    if (buf_size < 13)\n\n        return AVERROR_INVALIDDATA;\n\n    if (memcmp(buf, \"FLV\", 3))\n\n        return AVERROR_INVALIDDATA;\n\n    buf      += 13;\n\n    buf_size -= 13;\n\n    while (buf_size >= 11 + 4) {\n\n        int type = buf[0];\n\n        int size = AV_RB24(&buf[1]) + 11 + 4;\n\n        if (size > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n        if (type == 8 || type == 9) {\n\n            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n\n                return AVERROR_INVALIDDATA;\n\n            os->extra_packet_sizes[os->nb_extra_packets] = size;\n\n            os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n\n            if (!os->extra_packets[os->nb_extra_packets])\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n\n            os->nb_extra_packets++;\n\n        } else if (type == 0x12) {\n\n            if (os->metadata)\n\n                return AVERROR_INVALIDDATA;\n\n            os->metadata_size = size - 11 - 4;\n\n            os->metadata      = av_malloc(os->metadata_size);\n\n            if (!os->metadata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->metadata, buf + 11, os->metadata_size);\n\n        }\n\n        buf      += size;\n\n        buf_size -= size;\n\n    }\n\n    if (!os->metadata)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n", "idx": 11553, "substitutes": {"os": ["oi", "des", "ets", "ou", "boot", "oc", "ks", "is", "nos", "mos", "iso", "ds", "org", "dos", "ais", " bos", "ops", "los", "ls", "obj", "ants", "ros", "rss", "xs", "us", "oS", "js", "op", "of", "ok", "obs", "ots", "ions", "o", "acs", "osi", "oss", "bos", "oa", "es", "oos", "otes", "ois", "object", "bis", "ns", "oid", "mot", "aos", "as", "u", "sys", "et", "od", "pos", "ips", "ot", "ob", "options", "io", "oses", "css", "fs", "uns", "bs", "so", "ow", "ens", "OS", "oes"], "buf": ["img", "fd", "block", "fb", "bd", "pb", "cb", "feed", "loc", "keep", "cap", "cas", "cur", "port", "bus", "row", "text", "buff", "buffer", "box", "bb", "b", "que", "ab", "mem", "feat", "cf", "us", "large", "bc", "msg", "header", "bag", "seq", "uu", "context", "ff", "src", "brace", "num", "wb", "data", "rb", "array", "alloc", "Buff", "rc", "bh", "home", "cat", "cache", "vec", "cmd", "br", "func", "result", "uc", "uf", "byte", "wa", "pack", "batch", "bu", "queue", "la", "cv", "ctx", "begin", "raf", "pos", "length", "bin", "aka", "gen"], "buf_size": ["buff_len", "buf_capacity", "buflexlen", "buffdepth", "buflexshape", " buf_si", " buf_side", "buf_depth", " buf_capacity", "buf64depth", " buf_scale", "buf64side", " buf_slice", " buf_mode", "buf_address", "buflexspeed", "uf_shape", "buff_speed", " buf_len", "buf_slice", "uf_scale", "buf_scale", "buffside", "buflexsize", "buf64capacity", "uf_size", "buff_shape", "buf_speed", "buf_SIZE", "uf_SIZE", "buf64size", "buf_si", "buf_side", "buff_size", " buf_address", "buf_len", "buf_shape", " buf_depth", "buffcapacity", "buffsize", "buf_mode"], "nb_extra_packets": ["nb_extra_posets", "nb_extra_capets", "nb_extra_paramels", "nb_extra_packits", "nb_extra_packels", "nb_extra_pacls", "nb_extra_poset", "nb_extra_appets", "nb_extra_comals", "nb_extra_compences", "nb_extra_comamples", "nb_extra_flushet", "nb_extra_compls", "nb_extra_packsels", "nb_extra_posloads", "nb_extra_capits", "nb_extra_packsamples", "nb_extra_packssets", "nb_extra_paramets", "nb_extra_compet", "nb_extra_packamples", "nb_extra_packshers", "nb_extra_appsets", "nb_extra_paces", "nb_extra_pacches", "nb_extra_packsches", "nb_extra_comets", "nb_extra_paramet", "nb_extra_packals", "nb_extra_possets", "nb_extra_flushences", "nb_extra_pacets", "nb_extra_packsets", "nb_extra_flushets", "nb_extra_apploads", "nb_extra_packses", "nb_extra_paramhers", "nb_extra_pachers", "nb_extra_compits", "nb_extra_comet", "nb_extra_packsloads", "nb_extra_capet", "nb_extra_packhers", "nb_extra_pacences", "nb_extra_pacels", "nb_extra_packset", "nb_extra_packls", "nb_extra_capes", "nb_extra_appals", "nb_extra_appamples", "nb_extra_packet", "nb_extra_packsits", "nb_extra_pacet", "nb_extra_packes", "nb_extra_appet", "nb_extra_compets", "nb_extra_flushls", "nb_extra_compches", "nb_extra_packches", "nb_extra_compes", "nb_extra_packloads", "nb_extra_packsals", "nb_extra_packences"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n    __get_user(regs->CP0_EPC, &sc->sc_pc);\n\n\n\n    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);\n\n    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);\n\n\n\n    for (i = 1; i < 32; ++i) {\n\n        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);\n\n    }\n\n\n\n    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);\n\n    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);\n\n    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);\n\n    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);\n\n    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);\n\n    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);\n\n    {\n\n        uint32_t dsp;\n\n        __get_user(dsp, &sc->sc_dsp);\n\n        cpu_wrdsp(dsp, 0x3ff, regs);\n\n    }\n\n\n\n    for (i = 0; i < 32; ++i) {\n\n        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 11566, "substitutes": {"i": ["oi", "diff", "l", "hi", "ui", "di", "it", "start", "si", "n", "g", "in", "zi", "adi", "id", "xi", "m", "info", "b", "x", "k", "z", "d", "c", "ji", "p", "uri", "ix", "e", "cli", "yi", "mu", "esi", "eni", "f", "ie", "hei", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "ind", "phi", "mi", "name", "abi", "qi", "bi", "pi", "part", "ii", "init", "u", "I", "li", "ip", "ci", "a", "api", "ni", "io", "y", "ri", "one", "fi", "iu"], "dsp": ["pdcap", "cdsp", "pdsh", "dbsp", "bbsp", "sdtp", "sdcap", "cdspace", "btp", "pdsp", "cdmp", "dsh", " dsh", "pdisp", "pdbsp", "pdtp", "Dsp", "disp", "sdbsp", "sdmp", "pdspace", "bmp", "cdcap", "dmp", "dspace", "sdspace", "dtp", "pdmp", "bsp", "dcap", " disp", "Disp", "Dsh", "sdsp"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_block_to_card(SDHCIState *s)\n\n{\n\n    int index = 0;\n\n\n\n    if (s->prnsts & SDHC_SPACE_AVAILABLE) {\n\n        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n            s->norintsts |= SDHC_NIS_WBUFRDY;\n\n        }\n\n        sdhci_update_irq(s);\n\n        return;\n\n    }\n\n\n\n    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n        if (s->blkcnt == 0) {\n\n            return;\n\n        } else {\n\n            s->blkcnt--;\n\n        }\n\n    }\n\n\n\n    for (index = 0; index < (s->blksize & 0x0fff); index++) {\n\n        sd_write_data(s->card, s->fifo_buffer[index]);\n\n    }\n\n\n\n    /* Next data can be written through BUFFER DATORT register */\n\n    s->prnsts |= SDHC_SPACE_AVAILABLE;\n\n\n\n    /* Finish transfer if that was the last block of data */\n\n    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n            ((s->trnmod & SDHC_TRNS_MULTI) &&\n\n            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n        s->norintsts |= SDHC_NIS_WBUFRDY;\n\n    }\n\n\n\n    /* Generate Block Gap Event if requested and if not the last block */\n\n    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&\n\n            s->blkcnt > 0) {\n\n        s->prnsts &= ~SDHC_DOING_WRITE;\n\n        if (s->norintstsen & SDHC_EISEN_BLKGAP) {\n\n            s->norintsts |= SDHC_EIS_BLKGAP;\n\n        }\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n}\n", "idx": 11592, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "state", "full", "ns", "spec", "self", "settings", "sg", "ds", "si", "your", "sites", "b", "i", "c", "e", "se", "request", "args", "us", "f", "sym", "sets", "es", "r", "sis", "this", "u", "comments", "fs", "su", "ps", "site", "ss", "uses", "ks", "g", "features", "stats", "ops", "d", "data", "ls", "status", "os", "grades", "cs", "o", "sync", "south", "new", "sb", "sys", "secondary", "a", "ssl", "conf", "sports", "ts", "rows", "in", "changes", "service", "p", "server", "qs", "tests", "ins", "xs", "js", "rs", "an", "S", "states", "services", "less", "ses", "uns"], "blkcnt": ["blkCant", "blklcnc", "blKCant", "blkdcpt", "blqdcant", "blklcant", "blKcst", "blkscpt", "blKscno", "blkscno", "blkacnt", "blkrcnt", "blqcct", "blklcst", "blKcant", "blKcnt", "blkCount", "blkscount", "blKscnt", "blkrcnc", "blkrcant", "blkacct", "blkcpt", "blkCct", "blkscct", "blkdcount", "blkscnt", "blqdcnt", "blkdcst", "blkdcnt", "blkcant", "blkcst", "blKcount", "blkdcant", "blkacno", "blkCpt", "blqcnt", "blqdcpt", "blKCnt", "blkCnc", "blkrcno", "blKCount", "blklcount", "blKCno", "blqcant", "blkdcno", "blKscount", "blkcnc", "blKCst", "blqcpt", "blKscct", "blKcnc", "blkCnt", "blkCno", "blkacount", "blkcno", "blKCnc", "blKcno", "blqdcct", "blkcct", "blKcct", "blkdcct", "blklcnt", "blklcno", "blkscant", "blkCst", "blkcount"], "index": ["count", "diff", "element", "level", "ion", "si", "section", "val", "in", "prefix", "key", "word", "date", "id", "path", "x", "page", "Index", "instance", "num", "i", "pointer", "letter", "block", "data", "value", "action", "number", "condition", "loc", "search", "body", "alpha", "append", "slice", "column", "size", "inc", "ind", "name", "connection", "end", "address", "option", "old", "position", "offset", "ticket", "type", "pos", "loop", "row", "length", "image", "insert", "match", "weight", "fe", "fee"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n", "idx": 11608, "substitutes": {"s": ["l", "sg", "ts", " ads", "is", "n", "g", "si", "ds", "your", "sf", "its", "m", "b", "t", "d", "i", "gs", "service", "c", "p", "ls", "server", "e", "tests", "or", "args", "sq", "js", "rs", "f", "os", "cs", "sym", "o", "aws", "S", "es", "sync", "south", "states", "state", "sl", "services", "sn", "ns", "sb", " shares", "sys", " is", "client", "secondary", "ses", "ps", "a", "fs", "su", "ss", "uns", "ows", "ssl"], "cli": ["l", "hi", "ui", "seq", "mobile", "shell", "conn", "prot", "http", "sci", "rl", "uri", "ls", "util", "cu", "lu", "cb", "cn", "gui", "cho", "binary", "ctrl", "ctl", "multi", "lib", "sync", "ctx", " CLI", "cl", "acl", "CL", "cm", "li", "client", "api", "ci", "GUI", "gz", "url", "lc", "cmd", "cgi", "ln", "lo", "kl", "exec"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n", "idx": 11624, "substitutes": {"as": ["As", "asc", "is", "asp", "b", "x", "instance", "bs", "gs", "var", "sa", "ad", "s", "asu", "asse", "at", "amd", "or", "ass", "rs", "os", "ac", "an", "cs", "aws", "acs", "al", "parse", "ras", "ars", "cas", "ar", "r", "las", "am", "asha", "nas", "ident", "ans", "asm", "ast", "this", "ash", "a", "pas", "ps", "ss", "ap", "atts", "AS", "any", "with"], "d": ["ld", "l", "gd", "mad", "dh", "ds", "did", "g", "da", "m", "dt", "dos", "fd", "b", "dj", "z", "data", "ad", "s", "bd", "p", "c", "e", "pd", "cd", "driver", "dn", "ded", "dl", "db", "dat", "nd", "md", "dd", "patch", "dc", "sd", "od", "a", "del", "dx", "D"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n", "idx": 11631, "substitutes": {"s": ["l", "session", "is", "its", "m", "t", "gs", "outs", "er", "v", " defaults", "ies", " values", " parts", "ed", "erences", " settings", "ings", "sg", "ds", "ments", "w", "b", "instance", "ists", "i", "c", "e", "or", "ums", "f", "sets", "scope", "es", "input", "ors", "r", "ps", "ows", "ks", "g", "d", "ands", "ls", "status", "os", "cs", "o", "sync", "native", "new", "als", "sys", "ions", "secondary", "a", "irs", "ing", "ts", " results", "itions", "ports", "p", "qs", "ins", "rs", "js", " it", " statements", "S", "states", "ches", "submit", "ers", "ses", "y"]}}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix_ide_initfn(PCIIDEState *d)\n\n{\n\n    uint8_t *pci_conf = d->dev.config;\n\n\n\n    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode\n\n    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);\n\n\n\n    qemu_register_reset(piix3_reset, d);\n\n\n\n    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);\n\n\n\n    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);\n\n\n\n    pci_piix_init_ports(d);\n\n\n\n    return 0;\n\n}\n", "idx": 11635, "substitutes": {"d": ["ld", "l", "gd", "dh", "ds", "did", "dom", "n", "dict", "da", "m", "id", "dt", "fd", "t", "b", "dj", "dos", "i", "ad", "c", "data", "bd", "p", "s", "e", "cd", "pd", "f", "dr", "dl", "db", "dat", "o", "nd", "v", "ind", "md", "done", "dd", "vd", "dc", "sd", "u", "dm", "od", "dev", "td", "D"], "pci_conf": ["pci__conf", "pki_dev", "pci_conn", "pki_config", "pki_conf", "pci__conn", "pci__config", "pcm_cfg", "pci_cfg", "pcm_spec", "pci__dev", "pci_dev", "pki_conn", "pci_spec", "pcm_config", "pcm_conn", "pcm_conf", "pci_config"]}}
{"project": "qemu", "commit_id": "da3e8a23492dbc13c4b70d90b6ae42970624e63a", "target": 0, "func": "static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    DeviceState *qdev = DEVICE(vpci_dev);\n\n    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);\n\n    virtio_net_set_netclient_name(&dev->vdev, qdev->id,\n\n                                  object_get_typename(OBJECT(qdev)));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 11641, "substitutes": {"vpci_dev": ["vpci_die", "vpci_ver", "vpci2debug", "vpki_orig", "vpcu_ver", "vpcu2serv", "vpci2die", "vpcu2device", "vpci_debug", "vpci2ver", "vpc_die", "vpcu_dev", "vpcikdev", "vpci_orig", "vpc_dev", "vpio_device", "vpki_device", "vpcu2dev", "vpci_device", "vpci_div", "vpcu_device", "vpio_dev", "vpcikev", "vpci2serv", "vpcu_debug", "vpci_serv", "vpcikdebug", "vpcu2priv", "vpc_device", "vpci2dev", "vpcu_serv", "vpci_ev", "vpci2device", "vpki_dev", "vpcu_priv", "vpci2priv", "vpio_div", "vpci2ev", "vpcu_ev", "vpc_ev", "vpcikver", "vpci_priv"], "errp": ["erp", "rrr", " errP", "errorpi", "errorf", "enerpi", "errop", " errpi", "errorop", "enerp", "errorp", "rrp", "errP", "errf", "erP", " errf", "err", " errfp", "erfp", "errpi", "rrP", " errop", "enerf", " errr", "enerop", "errr", "rrfp", "errfp"], "qdev": ["eqdec", "Qdiv", " qdef", "dqdev", "dqdi", "wdev", "eqdevice", "qdi", "qdiv", "vdevice", "qdec", "wdata", "pdev", " qdata", "eqdev", " qdevice", " qdiv", "qdata", "pdiv", "dqdiv", "Qdef", "Qdev", "wdevice", "eqdiv", "qdef", "qdevice", "pdevice", "Qdi", "vdata", "wdec", "dqdef", "pdec", " qdi", "wdiv"], "dev": ["diff", "conf", "gu", "develop", "gd", "di", "debug", "Dev", "def", "info", "go", "id", "w", "die", "conn", "dt", "dem", "development", "adv", "ver", "d", "var", "ad", "block", "data", "app", "driver", "private", "priv", "rad", " def", "nov", "hw", "serial", "host", "ev", "device", "v", "req", "mod", "dd", "dc", " Dev", "bus", "grad", "self", "od", "ch", "wd", "DEV"], "vdev": ["vvdev", "ldev", "fgu", "vmod", "ndevice", "cdiv", "qdd", "wdev", "qmod", "vvdevice", "fdevice", "vdevice", "qdiv", " vdiv", "cdev", "Vdev", "Vmod", "Vdef", " vgu", " vdevice", "wdef", "lconn", "cdevice", "quvar", "qudev", "qDev", "vvar", "vdd", "vDev", " vdd", "ldevice", "ndev", "qgu", "vdef", "lgu", "bdiv", "qudevice", "qvar", "bdd", "bdevice", "wdd", "qconn", "vconn", "vgu", "fdev", "bdev", "qdef", "vdiv", "fvar", "qdevice", "nDev", "vvgu", " vconn", "Vdd", "ndiv", "wmod", "cDev"]}}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n", "idx": 11642, "substitutes": {"dev": ["conf", "gu", "gd", "cam", "img", "tr", "dom", "prof", "Dev", "def", "conn", "w", "prom", "phy", "dem", "mem", "ver", "fw", "serv", "data", "obj", "app", "plug", "rad", "serial", "ev", "device", "md", "req", "mod", "dm", "grad", "self", "proc", "DEV"], "errp": ["erp", "erb", " errP", "nerp", "erg", "errg", "nerP", " errsp", "errcp", "corsp", "corr", "erc", "errorp", " errc", "errsp", "nercp", "errorb", "errorg", "errP", " errb", "nerr", "erP", " errg", "err", "ercp", " errfp", "Erp", "erfp", "errc", "corfp", " errcp", "Erc", "errb", "ErP", "corp", "ersp", " errr", "Err", "errr", "errfp", "errorr"], "nvram": ["nwlam", "lovgram", "ncgam", "cvscan", "nlgram", "navlam", "nwdim", "lovcamp", "nvam", "cvram", "vcdim", "naviam", "ovgram", "nvran", "nwam", "vvram", "novmem", "lviam", "vvapp", "nvcamp", "cvmem", "vvcam", "ncram", "sviam", "lvam", "vvrom", "cvcom", "svcam", "nvirm", "svscan", "lovram", "nmgam", "vvvm", "ncgram", "advram", "vvirm", "nwram", "svtm", "vvgram", "cvcamp", "svirm", "nvream", "advgram", "nwvm", "nvlam", "novcam", "NVrom", "svgam", "vvgam", "cvcam", "ovcam", "novlam", "nvtm", "vvlam", "vciam", "navgam", "nwran", "nwtm", "ncdim", "nwream", "svgram", "navcamp", "novram", "ovapp", "nwgram", "NVram", "nvvm", "navcam", "vvtm", "svam", "vcmem", "nvrom", "nllam", "nmgram", "novam", "navrom", "nvdim", "nwcom", "lvgam", "nvcom", "navmem", "nmiam", "navscan", "advran", "nwpass", "ncmem", "svmem", "ovram", "novgram", "nvgram", "cvgram", "vcran", "lvream", "nlmem", "lvram", "nmpass", "advmem", "nvapp", "svram", "nmlam", "nlcam", "nvcam", "nvscan", "nviam", "cvvm", "nccam", "nvgam", "nwmem", "vvcom", "navram", "vcgram", "nlram", "NVgram", "NVapp", "navgram", "nwirm", "nwgam", "lovcam", "vcram", "vcgam", "lvgram", "vvpass", "svream", "nwiam", "nwcam", "novran", "nmram", "nvmem", "nvpass", "navapp", "nlran"], "ret": ["rf", "arr", "pass", "alt", "val", "len", "af", "def", "nt", "Ret", "t", "x", "pat", "red", "ct", "ref", "arg", "lit", "obj", "reg", "pt", "rets", "f", "rt", "res", "det", "rc", "fun", "att", "art", "ur", "fin", "cat", "re", "RET", "back", "result", "mt", "ft", "sr", "feat", "success", "pet"]}}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 11646, "substitutes": {"p": ["lp", "l", "dp", "sp", "wp", "n", "g", "m", "bp", "pl", "point", "t", "b", "k", "pid", "pa", "pp", "i", "pointer", "d", "c", "data", "cp", "post", "s", "pb", "e", "pat", "fp", "queue", "np", "pe", "exec", "gp", "po", "q", "P", "f", "op", "j", "pkg", "o", "py", "v", "pre", "jp", "tp", "patch", "pi", "ping", "pc", "part", "plugin", "u", "api", "ps", "a", "press", "ap", "per", "vp"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstU, dstV, src1, width);\n\n}\n", "idx": 11662, "substitutes": {"dstU": ["dspV", "dSTV", "destP", "adSTU", "dSTY", "adSTV", "destV", " dSTY", "dSTU", "dstP", "adstI", " dSTU", "adSTI", " dSTV", "destU", "dspI", "adstP", " dstP", " dstY", "dvertV", "dspP", "dvertU", "dSTP", " dSTP", "dSTI", "dspU", "destY", "dvertY", "destI", "dstI", "adstU", "dvertP", "dstY", "adSTP", "adstV"], "dstV": ["dSTV", " dstF", "dndV", "destV", "dndI", "dSTF", "drcI", " dSTF", "dSTU", "destF", " dSTU", "destv", " dSTV", "drcV", "destU", "dndv", " dSTI", "dSTv", " dSTv", " dstv", "drcv", " dstI", "dstF", "drcF", "dSTI", "destI", "dstI", "dndU", "dstv"], "src1": ["srcN", " srcN", "src0", "dest0", "rc2", "rc8", "st1", "rc1", " src0", "dest2", "st2", " src3", "st8", " src8", "rc0", "stN", "dest3", "rcN", "rc3", "dest1", "src8", "src3"], "src2": ["rc4", " src3", "src4", "dest3", "rc1", "dest4", "dest2", "rc2", "rc3", " src4", "dest1", "src3"], "unused": ["Uninitialized", "uncprotected", "unprotected", "unsprotected", "uninitialized", "uncused", "Unprotected", "Unused", "Unuse", "unuse", "uncinitialized", "unsinitialized", "uncuse", "unsuse", "unsused"]}}
{"project": "FFmpeg", "commit_id": "30e256430eb88c6d4c382581b89bca171d79fbc0", "target": 0, "func": "int ff_thread_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->thread_opaque) {\n\n        av_log(avctx, AV_LOG_ERROR, \"avcodec_thread_init is ignored after avcodec_open\\n\");\n\n        return -1;\n\n    }\n\n\n\n#if HAVE_W32THREADS\n\n    w32thread_init();\n\n#endif\n\n\n\n    if (avctx->codec) {\n\n        validate_thread_parameters(avctx);\n\n\n\n        if (avctx->active_thread_type&FF_THREAD_SLICE)\n\n            return thread_init(avctx);\n\n        else if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            return frame_thread_init(avctx);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11665, "substitutes": {"avctx": ["afconn", "avcmp", "evcf", "aveci", "awcontext", " avtx", "AVcontext", "avconn", "ajkb", "AVconn", " avcontext", "avcontext", "Avtx", "Avctx", "averctrl", "afcn", "ajcoll", "AVcb", "afcontext", "afkb", "avcb", "awci", "avc", "AVcoll", "avectx", "afcoll", "afc", "afcu", "ajctx", "ajcontext", "appcmp", "afci", "awctx", "evcn", "afloc", "aveloc", "avcn", "avercontext", "Avcontext", "avloc", "appcontext", "afctx", "AVc", "Avctrl", " avkb", "avcf", "avecb", "avci", "avcoll", "avcu", "ajtx", "AVctx", "evctx", "avctrl", "avkb", "ajc", "aveconn", "avecontext", "avertx", "afctrl", "AVcf", "averctx", "aftx", "avecmp", "afcmp", "avecu", "evcontext", "ajcn", "afcf", "appctx", "ajcf", "afcb", "awcu", "avecf", "avtx", "avecoll", "apploc"]}}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "substitutes": {"mr": ["rh", "rf", "adr", "mk", "mn", "tr", "hr", "m", "fr", "rr", "kr", "mm", "gr", "wk", "MR", "attr", "usr", "ir", "rb", "rs", "lr", "er", "dr", "mid", "rt", "mir", "fm", "rc", "mi", "r", "pr", "nr", "shr", "ur", "yr", "tm", "vr", "rg", "mt", "Mr", "sr", "br", "eu", "mc", "rl", "rm"], "is_write": [" is_written", "is_flow", "any_line", "any_writing", " is_read", "is_read", "any_write", " is_left", "isPubleft", "isPubread", " is_flow", "is_writing", "is_written", "is_left", "is_line", "any_read", "isPubwrite"]}}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!blk->serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(blk->conf.bs);\n\n        if (*dinfo->serial) {\n\n            blk->serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 11685, "substitutes": {"dev": ["diff", "conf", "gu", "gd", "di", "sh", "debug", "dom", "g", "comment", "prof", "def", "Dev", "w", "info", "conn", "temp", "development", "dem", "ve", "gr", "d", "ver", "de", "data", "block", "pro", "hw", "ev", "device", "vol", "v", "sync", "md", "user", "err", "dd", "error", "bus", "spec", "der", "client", "ch", "DEV"], "blk": ["plks", "brsk", "slc", "blak", "BLak", "blkg", "plck", "belck", "belq", " blku", "plky", "blogk", "blogks", "plc", "plak", "brks", "elk", "llky", "Blak", "blks", " blck", "blsk", " blke", "ilok", "flc", " blsk", "ilck", "slak", "llck", "plkg", "blogsk", "blc", "plk", "slke", "ilku", "BLke", "belk", "llk", "brk", "slck", "plku", "llq", "slok", "slks", "brkg", "slk", "flk", "Blke", "blogkg", " blky", "ilsk", "elak", "flke", "ilak", "blku", "BLks", "plsk", "blok", " blks", "blky", "Blk", "elck", " blq", "plke", "blq", "ilk", "plok", "blke", " blak", "elke", "Blks", "blck", " blok", "flks", "belku", "BLk", "plq"], "s": ["l", "session", "is", "its", "m", "t", "gs", "sum", "sk", "v", "state", "full", "ns", "hs", "spec", "init", "self", "params", "settings", "ves", "sg", "ds", "n", "si", "sf", "w", "b", "ssh", "i", "c", "e", "request", "args", "us", "sq", "f", "sym", "sets", "es", "sup", "r", "u", "sim", "ps", "su", "fs", "site", "ss", "sh", "ks", "g", "d", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "a", "ssl", "conf", "ts", "service", "p", "server", "qs", "js", "rs", "an", "S", "states", "services", "h", "ses", "uns"], "cylinders": ["cylishers", "kellinder", "chishers", "ptyinders", "cilinder", "yminders", "ymishers", "kellinders", "ptyambers", "yocks", "kellishers", "yinders", "yishers", "chinder", "ymocks", "ptyishers", "cylinder", "cylambers", "kellambers", "yinder", "yminder", "ptyinder", "chinders", "cylocks", "cilishers", "cilinders", "cilocks", "chambers"], "heads": ["loads", "devices", "ks", "clips", "frames", "rows", "features", "links", "mods", "shows", "ops", "opens", "head", "views", "ids", "tests", "jobs", "bits", "outs", "pages", "drivers", "height", "obs", "tails", "sections", "tops", "plugins", "modules", "checks", "locks", "holes", "hops", "blocks", "scenes", "olds", "headers", "HEAD", "depth"], "secs": ["descblocks", "inctests", "reges", "secports", "seces", "descls", "ectports", "secls", "regs", "desces", "Secondblocks", "descs", "Secondes", "Secondls", " sectests", "sectests", "incs", "incports", "regblocks", " secports", "incsets", " secsets", "Seconds", "secsets", "regls", "ectsets", "ects", "ecttests", "secblocks"], "virtio_blk_id": ["virtio_blks_name", "virtio_blks_id", "virtio_blck_id", "virtio_blk_type", "virtio_blks_f", "virtio_blck_name", "virtio_blk_info", "virtio_blk_f", "virtio_blck_info", "virtio_blk_root", "virtio_blck_root", "virtio_blk_name", "virtio_blks_type"], "dinfo": ["fdInfo", "ddata", "fInfo", "did", "dsid", "adinfo", "fdinit", "pid", "pinfo", "sdinf", "linfo", "lerror", "dinit", "ldinf", "finfo", "sdvar", "linf", "aderror", " ddata", "dsinfo", "derror", " dinf", "dinf", "adinf", "lid", "lderror", "dvar", " dInfo", "finf", "dsvar", "sdid", "ldinfo", " did", " dinit", "finit", " derror", " dvar", "pinf", "sdinfo", "fdinfo", "fdinf", "lddata", "addata", "dInfo", "dsinf"]}}
{"project": "FFmpeg", "commit_id": "e048a9cab10f1d41dca7b1ad9c8ecaceb3424d86", "target": 1, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCMDecode *s = avctx->priv_data;\n    int sample_size, c, n, i;\n    short *samples;\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n    uint8_t *dstu8;\n    int16_t *dst_int16_t;\n    int32_t *dst_int32_t;\n    int64_t *dst_int64_t;\n    uint16_t *dst_uint16_t;\n    uint32_t *dst_uint32_t;\n    samples = data;\n    src = buf;\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n        return -1;\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n        return -1;\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n        /* 2 samples are interleaved per block in PCM_DVD */\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n        /* we process 40-bit blocks per channel for LXF */\n        sample_size = 5;\n    n = avctx->channels * sample_size;\n    if(n && buf_size % n){\n        if (buf_size < n) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n            return -1;\n        }else\n            buf_size -= buf_size % n;\n    buf_size= FFMIN(buf_size, *data_size/2);\n    *data_size=0;\n    n = buf_size/sample_size;\n    switch(avctx->codec->id) {\n    case CODEC_ID_PCM_U32LE:\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_U32BE:\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_S24LE:\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_S24BE:\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_U24LE:\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_U24BE:\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_S24DAUD:\n        for(;n>0;n--) {\n          uint32_t v = bytestream_get_be24(&src);\n          v >>= 4; // sync flags are here\n          *samples++ = av_reverse[(v >> 8) & 0xff] +\n                       (av_reverse[v & 0xff] << 8);\n        break;\n    case CODEC_ID_PCM_S16LE_PLANAR:\n        n /= avctx->channels;\n        for(c=0;c<avctx->channels;c++)\n            src2[c] = &src[c*n*2];\n        for(;n>0;n--)\n            for(c=0;c<avctx->channels;c++)\n                *samples++ = bytestream_get_le16(&src2[c]);\n        src = src2[avctx->channels-1];\n        break;\n    case CODEC_ID_PCM_U16LE:\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_U16BE:\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_S8:\n        dstu8= (uint8_t*)samples;\n        for(;n>0;n--) {\n            *dstu8++ = *src++ + 128;\n        samples= (short*)dstu8;\n        break;\n#if HAVE_BIGENDIAN\n    case CODEC_ID_PCM_F64LE:\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_F32LE:\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16LE:\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64BE:\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n    case CODEC_ID_PCM_S16BE:\n#else\n    case CODEC_ID_PCM_F64BE:\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16BE:\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64LE:\n    case CODEC_ID_PCM_F32LE:\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_S16LE:\n#endif /* HAVE_BIGENDIAN */\n    case CODEC_ID_PCM_U8:\n        memcpy(samples, src, n*sample_size);\n        src += n*sample_size;\n        samples = (short*)((uint8_t*)data + n*sample_size);\n        break;\n    case CODEC_ID_PCM_ZORK:\n        for(;n>0;n--) {\n            int x= *src++;\n            if(x&128) x-= 128;\n            else      x = -x;\n            *samples++ = x << 8;\n        break;\n    case CODEC_ID_PCM_ALAW:\n    case CODEC_ID_PCM_MULAW:\n        for(;n>0;n--) {\n            *samples++ = s->table[*src++];\n        break;\n    case CODEC_ID_PCM_DVD:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        switch (avctx->bits_per_coded_sample) {\n        case 20:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n                src = src8;\n            break;\n        case 24:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;", "idx": 11712, "substitutes": {"avctx": ["afconn", "avcmp", "evcf", " avca", "devcontext", "abcontext", "verpkg", "AVcontext", "alctx", "aveconfig", "avconn", "avconv", "AVconn", " avcontext", "avcontext", " avconn", "avepkg", "abpkg", "navcmp", "afcontext", "akcontext", " avcu", "avcb", " avclient", "avecca", "avc", "attctx", "avbc", "afclient", "afpkg", "avectx", "alcontext", "aveclient", "afc", "vercmp", "navconn", "afcu", " avc", "attcontext", "avcmd", "devcf", "afbc", "verconn", "verconv", "afconv", " avcf", "afloc", "aveloc", "evbc", "evloc", " avbc", "avcca", "avca", "avloc", "navpkg", "vercf", "afctx", "abconn", "AVc", "navconv", "abcmp", "akctrl", " avcmd", "avcf", "avecb", "attcf", "vercontext", "avcu", "abctx", "verctx", "alcmd", "navctrl", "afconfig", "AVctx", "abctrl", "evconn", "evctx", "avctrl", "navcontext", "aveconn", "AVcu", "avecontext", "devctx", "akconn", "afctrl", "attloc", "afcca", "AVconfig", "navctx", "devcmp", "afcmp", "navcca", "afcmd", "avecu", "abcf", "evcontext", "afcf", "avconfig", "akctx", "navcf", "alca", "afcb", "avpkg", "afca", "avecf", "vercb", "navloc", "avclient"], "data": ["sample", "channel", "arr", "val", "source", "media", "window", "da", "b", "d", "block", "config", "p", "reader", "stream", "batch", "mu", "queue", "memory", "frame", "array", "empty", "tmp", "body", "DATA", "next", "f", "dat", "size", "slice", "input", "response", "content", "raw", "r", "results", "dd", "load", "Data", "blocks", "bytes", "message", "a", "video", "image", "result", "cache", "buff", "buffer"], "data_size": ["wave_scale", "data_scale", "channel_small", "data_range", "channel_offset", "data_shape", "data_small", "data_content", "cap_range", "wave_size", "channel_size", "data_sized", "data_number", "channel_sized", "cap_size", "cap_shape", "data_offset", "wave_shape", "cap_content", "wave_number"], "avpkt": ["avvpconn", "avpckt", "AVvpkt", "avnpkt", "navpeth", "avpacket", "avfacket", "avlpkg", "avckg", "ajpacket", "navlpeth", "AVpconn", "ajpmt", "ajpcmt", "avfkt", "navpkt", "avpcacket", "avnpconn", "avpcmt", "avcpkg", "ajpcnt", "avppmt", "avpconn", "avfpkt", "AVpk", "avvpct", "avppnt", "navlpkt", "ajpkt", "avvpkt", "avfpk", "avfnt", "avpnt", "avlpeth", "AVvpconn", "avcpkt", "avpct", "avpmt", "AVvpk", "ajpnt", "avfpconn", "avckt", "avlpkt", "avvpk", "avceth", "avppacket", "AVpct", "avpeth", "avpkg", "avcpct", "AVvpct", "AVpkt", "ajpcacket", "navlpkg", "avfmt", "navpct", "avlpct", "avnpk", "avnpct", "avcct", "navlpct", "avpcnt", "avcpeth", "ajpckt", "avfpct", "avpk", "navpkg", "avppkt"], "buf": ["bag", "uf", "map", "seq", "Buffer", "img", "ff", "pad", "b", "wb", "block", "fb", "config", "p", "bd", "pb", "cb", "fp", "queue", "cf", "rb", "array", "tmp", "bc", "f", "alloc", "cv", "v", "cap", "rc", "cas", "ctx", "port", "vec", "buff", "buffer", "box"], "s": ["session", "sg", "sv", "g", "stats", "m", "w", "b", "d", "gs", "sa", "p", "e", "f", "S", "v", "sync", "r", "ns", "sb", "spec", "sys", "a", "ses", "ss", "ssl", "sc"], "sample_size": ["sample67term", "sample2speed", "slice_size", "ample_shape", "mix_sized", "buf_size", "sample2scale", "samplelexterm", "ample_time", "buf_use", "samplelexsize", "sample67size", "slice_content", "samplelexuse", "mix_size", "sample_mode", "ample_size", "mix_mode", "sample2sized", "samplelexscale", "slice_page", "ample_fee", "ample_term", "samplelexsized", "sample_term", "sample2size", " sample_scale", "sample_shape", "buf_scale", "sample_scale", "slice_sized", " sample_speed", "buf_sized", "sample_speed", "mix_scale", "sample_use", "sample_page", "ample_speed", "sample67shape", "samplelexshape", "sample_time", " sample_sized", "sample_fee", "ample_body", "sample_content", "sample_sized", "sample_body", "samplelextime", "sample67time"], "c": ["count", "l", "C", "g", "w", "m", "k", "b", "x", "z", "d", "con", "p", "e", "cn", "cf", "f", "cc", "o", "v", "r", "dc", "u", "h", "nc", "cm", "ci"], "n": ["l", "un", "C", "nb", "g", "len", "all", "w", "m", "nt", "conn", "b", "x", "k", "num", "z", "t", "d", "ne", "net", "p", "e", "np", "cn", "number", "f", "pn", "network", "j", "o", "N", "size", "v", "r", "en", "sn", "ns", "nan", "u", "nc", "h", "ni", "y", "nn"], "i": ["l", "di", "si", "m", "b", "k", "ini", "x", "d", "p", "e", "f", "j", "o", "index", "v", "mi", "pi", "ii", "u", "I", "li", "ip", "ci", "ni", "y"], "samples": ["famps", "sample", "nources", "slamps", "famples", "fample", "suffample", "slources", "suffamps", "Sannels", "dannels", "damples", "sannels", "slample", "Samples", "slamples", "suffources", "dources", "sources", "Sources", "fources", "namples", "nannels", "suffamples", "samps"], "src": ["seq", "img", "source", "sel", "b", "RC", "sur", "rec", "config", "stream", "dest", "cb", "attr", "dist", "ptr", "loc", "rb", "tmp", "rs", "inst", "host", "sub", "slice", "lib", "cv", "sync", "rc", "input", "sl", "ctx", "sb", "url", "comp", "result", "func", "ssl", "sc"], "src8": ["dest16", "dest2", "rc2", "rc8", "dest8", " src16", "src16", "rc16"], "src2": ["src1", "src_", " src_", "rc1", "source_", "source1", "src0", " src0", "rc_", "rc2", "source0", "rc0", " src1", "source2"], "MAX_CHANNELS": ["MAX_CHANES", "MAX_ChANNELS", "MAX_CHANNEL", "MAX_CHANERS", "MAX_ChANNERS", "MAX_CHANCERS", "MAX_ChANNEL", "MAX_CHANGERS", "MAX_CHANETS", "MAX_CHANELS", "MAX_CHANNETS", "MAX_ChANCES", "MAX_CHANGELS", "MAX_ChANCELS", "MAX_CHANNES", "MAX_ChANCERS", "MAX_CHANCEL", "MAX_ChANCEL", "MAX_CHANCES", "MAX_CHANEL", "MAX_CHANGETS", "MAX_CHANCELS", "MAX_CHANNERS", "MAX_CHANGES", "MAX_ChANNES", "MAX_CHANGEL", "MAX_CHANCETS"], "dstu8": ["dstui8", "dstsu2", "dstuint6", "dstsui32", "dstsui8", "dstsui6", "dstsu6", "dstU32", "dstsui2", "dstui32", "dstu2", "dstuint32", "dstU2", "dstU6", "dstui6", "dstsu32", "dstuint2", "dstu32", "dstU8", "dstu6", "dstsu8", "dstuint8", "dstui2"], "dst_int16_t": ["dst_int16_s", "dst_int16_l", "dst_int16_T", "dst_int32_T", "dst_int32_l", "dst_int32_s"], "dst_int32_t": ["dst_int64_T", "dst_int32_f", "dst_int64_type", "dst_int64_f", "dst_int32_type", "dst_int32_T", "dst_int32JT", "dst_int32Jtype", "dst_int32Jf", "dst_int32Jt"], "dst_int64_t": ["dst_int64Jd", "dst_int16_s", "dst_int64_s", "dst_int64_T", "dst_int64_d", "dst_int16_T", "dst_int64Js", "dst_int64JT", "dst_int64Jt", "dst_int16_d"], "dst_uint16_t": ["dst_uint32_s", "dst_uint32_T", "dst_uint16_T", "dst_uint16_s", "dst_uint32_p", "dst_uint16_p"], "dst_uint32_t": ["dst_uint64_t", "dst_uint64_wt", "dst_uint32_s", "dst_uint32_T", "dst_uint64_s", "dst_uint64_T", "dst_uint32_wt"]}}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n", "idx": 11714, "substitutes": {"env": ["chal", "conf", "inet", "eur", "si", "shell", "conn", "que", "net", "iv", "viron", "ne", "iss", "environment", "enable", "config", "server", "e", "ace", "erv", "esi", "txt", "ec", "eni", "manager", "code", "db", "ev", "eval", "ea", "scope", "en", "enh", "enc", "esp", "her", "engine", "cache", "eu", "core", "exec"], "ri": ["ani", "vi", "adr", "rin", "di", "ari", "si", "adi", "xi", "iri", "ini", "i", "uri", "rb", "rs", "stri", "eni", "ris", "ai", "rt", "gi", "ti", "mi", "udi", "rid", "abi", "pi", "ii", "li", "rg", "reci", "ci", "rio", "ori", "ni", "ati", "ski", "io", "sr", "ki", "RI"], "value": ["area", "reference", "Value", "scale", "si", "val", "region", "key", "record", "info", "id", "i", "service", "data", "rule", "uri", "server", "number", "entry", "resource", "values", "index", "size", "v", "format", "name", "state", "feature", "end", "address", "port", "type", "image", "result", "write", "VALUE", "fee"]}}
{"project": "qemu", "commit_id": "036078475427f2562c8e505f6bb44dbf5d8cbd95", "target": 1, "func": "static int usb_host_open(USBHostDevice *dev, int bus_num,\n\n                         int addr, const char *port,\n\n                         const char *prod_name, int speed)\n\n{\n\n    int fd = -1, ret;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (dev->fd != -1) {\n\n        goto fail;\n\n    }\n\n\n\n    fd = usb_host_open_device(bus_num, addr);\n\n    if (fd < 0) {\n\n        goto fail;\n\n    }\n\n    DPRINTF(\"husb: opened %s\\n\", buf);\n\n\n\n    dev->bus_num = bus_num;\n\n    dev->addr = addr;\n\n    strcpy(dev->port, port);\n\n    dev->fd = fd;\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"husb: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++) {\n\n            printf(\"%02x \", dev->descr[x]);\n\n        }\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n\n\n    /* start unconfigured -- we'll wait for the guest to set a configuration */\n\n    if (!usb_host_claim_interfaces(dev, 0)) {\n\n        goto fail;\n\n    }\n\n\n\n    usb_ep_init(&dev->dev);\n\n    usb_linux_update_endp_table(dev);\n\n\n\n    if (speed == -1) {\n\n        struct usbdevfs_connectinfo ci;\n\n\n\n        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n        if (ret < 0) {\n\n            perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n            goto fail;\n\n        }\n\n\n\n        if (ci.slow) {\n\n            speed = USB_SPEED_LOW;\n\n        } else {\n\n            speed = USB_SPEED_HIGH;\n\n        }\n\n    }\n\n    dev->dev.speed = speed;\n\n    dev->dev.speedmask = (1 << speed);\n\n    if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) {\n\n        dev->dev.speedmask |= USB_SPEED_MASK_FULL;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n\n\n    if (!prod_name || prod_name[0] == '\\0') {\n\n        snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    } else {\n\n        pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                prod_name);\n\n    }\n\n\n\n    ret = usb_device_attach(&dev->dev);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* USB devio uses 'write' flag to check for async completions */\n\n    qemu_set_fd_handler(dev->fd, NULL, async_complete, dev);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (dev->fd != -1) {\n\n        close(dev->fd);\n\n        dev->fd = -1;\n\n    }\n\n    return -1;\n\n}\n", "idx": 11742, "substitutes": {"dev": ["gd", "dom", "fail", "development", "ve", "ver", "de", "ad", "block", "driver", "dist", "device", "v", "end", "cur", "mod", "vd", "link", "dm", "self", "grad", "od", "av", "gu", "cam", "debug", "val", "w", "id", "go", "mem", "serv", "app", "group", "hw", "ev", "current", "md", "dc", "error", "root", "this", "ch", "ow", "exec", "boot", "di", "sh", "g", "prof", "test", "Dev", "def", "conn", "nt", "temp", "dem", "adv", "d", "var", "data", "dr", "req", "new", "enc", "node", "result", "cache", "cmd", "engine", "diff", "conf", "valid", "start", "comment", "die", "info", "dt", "mount", "server", "gh", "bug", "rad", "priv", "off", "serial", "inst", "pub", "user", "dd", "sd", "der", "client", "api", "wd", "DEV"], "bus_num": ["bus__num", "bus2number", "busvalorig", "bus2num", "busvalunit", "usb_info", "bus2name", "bus__info", "boot_number", "bus__name", "usb_orig", "boot_nu", "usb_name", "bus_nu", "busvalname", "bus_name", "boot_num", "usb_number", "boot_len", "bus_orig", "bus2nu", "boot_dim", "busvalnum", "bus__nu", "bus__number", "bus_unit", "boot_name", "bus_info", "usb_num", "usb_unit", "boot_mu", "bus_mu", "bus_len", "bus_number", "bus_dim"], "addr": ["alias", "mac", "Address", "adr", "ack", "arm", "ext", "alt", "handle", "ord", "prefix", "pad", "id", "conn", "src", "point", "rr", "fd", "bridge", "ad", "p", "work", "ref", "coord", "ace", "attr", "server", "farm", "amd", "ptr", "loc", "args", "nm", "dr", "mode", "host", "rt", "device", "route", "amp", "oa", "name", "rc", "align", "r", "md", "address", "dd", "nr", "part", "dc", "hop", "offset", "spec", "node", "orig", "eth", "vr", "layer", "od", "pos", "ip", "api", "url", "cmd", "pkg", "wd"], "port": ["tun", "PORT", "pass", "source", "method", "id", "conn", "prot", "fd", "path", "num", "pid", "ports", "config", "p", "server", "target", "driver", "Port", "pt", "ptr", "prop", "socket", "mode", "rot", "host", "unit", "device", "dir", "version", "route", "duration", "ort", "format", "name", "pipe", "proxy", "address", "plugin", "type", "platform", "pos", "ip", "url", "length", "cmd", "direction"], "prod_name": ["prod_number", "prod2names", "prod_names", "prol_name", "prodaccomment", "prop_names", "prol__name", "prodactype", "prol__names", "prod_path", "prod__name", "proc_type", "proc_name", "prop_name", "prod_type", "proc_comment", "prop_Name", "prodacnumber", "prod_Name", "prod2name", "prol_names", "prop_type", "prod__names", "prol__path", "prol_path", "prodacname", "prod__path", "prod2Name", "proc_number", "prod_comment", "prod2type"], "speed": ["sp", "fd", "sleep", "driver", "skip", "feed", "step", "sk", "device", "wait", "state", "sort", "grade", "spec", "mph", "type", "fast", "seed", "settings", "scroll", "rank", "timeout", "delay", "rate", "si", "limit", "strength", "se", "rss", "performance", "priority", "unit", "slice", "error", "sex", "ss", "slow", "fee", "power", "powered", "score", "source", "method", "effect", "send", "gain", "stream", "status", "style", "stop", "mode", "size", "shape", "sync", "order", "sl", "peed", "sn", "engine", "weight", "dy", "ssl", "lane", "level", "scale", "start", "capacity", "sw", "service", "time", "quality", "spin", "name", "Speed", "cost", "sign", "length", "write", "force", "direction"], "ret": ["count", "arr", "pass", "flag", "len", "val", "alt", "fail", "def", "conn", "id", "nt", "Ret", "pat", "data", "red", "reply", "ref", "arg", "lit", "obj", "reg", "pt", "rb", "rets", "bc", "f", "rot", "j", "db", "res", "rt", "det", "wait", "rc", "fun", "att", "part", "art", "fin", "re", "RET", "ash", "back", "sat", "result", "ft", "rev", "match", "resp", "let", "out", "rl", "mer", "success"], "x": ["xp", "ext", "n", "val", "wa", "ax", "key", "xx", "id", "xi", "w", "t", "sw", "num", "z", "k", "i", "c", "X", "p", "ix", "work", "e", "ux", "pe", "lex", "xs", "xxx", "j", "code", "xa", "index", "v", "fx", "ctx", "r", "tx", "wx", "xc", "u", "ww", "xy", "h", "pos", "rx", "px", "y", "dx", "ex"], "ci": ["vi", "ui", "di", "co", "cci", "si", "conn", "info", "ini", "sci", "i", "c", "ct", "uri", "cu", "cli", "uci", "cf", "bug", "eni", "oci", "cod", "ie", "ai", "cgi", "ctrl", "py", "ce", "mi", "ctx", "CI", "pi", "bi", "dc", "ii", "init", "cm", "li", "interface", "io", "ni", "ati", "fi", "ki"]}}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 11748, "substitutes": {"dev": ["diff", "conf", "devices", "dim", "sh", "di", "cam", "debug", "tr", "dom", "comment", "prof", "Dev", "def", "conn", "w", "prom", "die", "info", "temp", "dem", "development", "ve", "ver", "de", "data", "ad", "app", "pro", "driver", "bug", "rad", "serial", "nov", "hw", "priv", "sk", "ev", "device", "v", "md", "req", "mod", "vd", "dc", "spec", "dm", "grad", "self", "od", "engine", "ch", "DEV"], "pci": ["updi", "uppi", "pki", "spcli", "spcin", "ppki", "apii", "vpcin", "epci", "ppci", "bsi", " pii", "Pcm", " pcm", "psi", "pcu", "lpci", "pdi", "eppi", "perki", "upci", "appi", "Ppi", "pcit", "epsi", "Pki", "spki", "ppcit", " pcin", "bki", "wpci", "perci", "vpci", "pcin", " pcci", "cpci", "spci", "cpsi", "epki", "cpdi", "apdi", "pcm", "wpcin", "cpcin", "Pci", "lpcm", " pcli", "ppcm", "bpi", "spii", "ppi", "cpcci", "wpcm", "cppi", "pcci", " ppi", "Pcit", "persi", " psi", "spsi", "cpki", "apci", "lpki", "spcu", "lppi", "pcli", "upii", "vpcli", "wpcci", "cpcit", "percu", "cpii", "vpii", "pii", "cpcm", " pcu", " pki", "bci"], "d": ["dp", "ld", "gd", "di", "dh", "ds", "g", "dom", "dict", "w", "m", "id", "dt", "fd", "b", "t", "i", "c", "ad", "config", "p", "data", "bd", "e", "cd", "driver", "pd", "dn", "f", "ded", "dr", "db", "dat", "device", "o", "md", "dd", "dc", "sd", "dm", "od", "dad", "cmd", "D"], "s": ["l", "sp", "session", "sg", "ts", "ds", "n", "g", "si", "is", "w", "m", "b", "t", "i", "gs", "c", "data", "p", "ls", "e", "qs", "tests", "args", "rs", "js", "f", "os", "cs", "sym", "o", "aws", "S", "v", "sync", "sl", "services", "r", "new", "ns", "sb", "hs", "spec", "sd", "u", "sys", "self", "h", "ps", "su", "fs", "ses", "uns", "ss", "bs", "settings", "ssl"], "pci_conf": ["pili__cache", "pci__conf", "pci__con", "pdi_config", "pci_Conf", "pci__cache", "pci_conn", "pki_config", "pili_con", "pki_conf", "pci_info", "pki_cfg", "pci__config", "pci__conn", "pdi_info", "pci_cfg", "pili__config", "pili_config", "pdi_conf", "pili__conf", "pci__info", "pci_cache", "pili__con", "pci_con", "pili_cache", "pdi_conn", "pci_config", "pili_conf", "pki_Conf"], "err": ["cr", "acer", "conf", "ee", "ler", "arr", "arm", "str", "rage", "fr", "pl", "rr", "mr", "gr", "fi", "doc", "var", "Error", "e", "cb", "aaa", "ace", "ir", "ec", "rs", "bug", "er", "errors", "ie", "dr", "f", "code", "ev", "res", "o", "msg", "order", "ind", "rc", "magic", "ar", "r", "ise", "req", "done", "error", "rar", "orig", "rn", "sys", "der", "ah", "ch", "Er", "result", "cache", "y", "rh", "cry", "br", "rev"]}}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void copy_frame(Jpeg2000EncoderContext *s)\n\n{\n\n    int tileno, compno, i, y, x;\n\n    uint8_t *line;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){\n\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (s->planar){\n\n            for (compno = 0; compno < s->ncomponents; compno++){\n\n                Jpeg2000Component *comp = tile->comp + compno;\n\n                int *dst = comp->data;\n\n                line = s->picture.data[compno]\n\n                       + comp->coord[1][0] * s->picture.linesize[compno]\n\n                       + comp->coord[0][0];\n\n                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){\n\n                    uint8_t *ptr = line;\n\n                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)\n\n                        *dst++ = *ptr++ - (1 << 7);\n\n                    line += s->picture.linesize[compno];\n\n                }\n\n            }\n\n        } else{\n\n            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]\n\n                   + tile->comp[0].coord[0][0] * s->ncomponents;\n\n\n\n            i = 0;\n\n            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){\n\n                uint8_t *ptr = line;\n\n                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){\n\n                    for (compno = 0; compno < s->ncomponents; compno++){\n\n                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);\n\n                    }\n\n                }\n\n                line += s->picture.linesize[0];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11749, "substitutes": {"s": ["l", "session", "is", "m", "http", "t", "z", "gs", "er", "ges", "v", "ns", "spec", "self", "settings", "sg", "ds", "si", "n", "sf", "w", "b", "c", "se", "e", "sq", "f", "sym", "slice", "sets", "sky", "es", "r", "this", "u", "sim", "fs", "ps", "su", "site", "ss", "sh", "ks", "sv", "g", "ops", "ls", "os", "cs", "sync", "sl", "sb", "sys", "single", "side", "a", "sr", "ssl", "ts", "service", "p", "qs", "xs", "rs", "js", "an", "aws", "S", "sie", "services", "ses"], "tileno": ["ileno", "iloki", "vilnea", "turasso", "silena", "vileni", "tleno", "tilena", "sileno", "silino", "silasso", "tainoa", "tilename", "sileni", "fileni", "tilerno", "tunerno", "kileno", "filosi", "tainasso", "turono", "tleni", "tainerno", "kileni", "kilnea", "illename", "vileno", "tainono", "fileno", "tiloa", "silerno", "tainoid", "filono", "silono", "tileni", "tureno", "tuneno", "tilosi", "tunento", "tainento", "tlosi", "vilino", "siloa", "turoa", "tunoid", "tuneni", "illena", "tilino", "tilento", "silnea", "siloid", "silename", "siloki", "illeno", "tunosi", "kilino", "tunono", "ilename", "tiloki", "tilnea", "tilono", "ilena", "taineno", "tiloid", "silento", "tlono", "illoki", "tilasso"], "compno": [" comppos", "comname", "comyes", "combno", "cmpmo", "componentNO", "hostnumber", "componentlo", "cellnom", "cellnode", "cellnone", "comdo", " compname", "compnumber", "ompno", "compdo", "cmpindex", "compname", "codeno", "cmpno", "ompNo", "macno", "cmpyes", "winno", "codeio", "cmpcho", "expdo", " compsn", "cellnon", "ompnone", "hostdo", "condno", "compNo", "propyes", "combnone", "expnos", " compnum", "seqno", "compnode", "compna", "componentno", "cmpname", "componentNo", "cmpnom", "compnone", "componentpos", "conddo", "comnumber", "componentsn", "compnon", "windo", "propnode", "compnum", "cmpsn", "cmpnumber", "propgo", "cellyes", " compindex", "componentyes", "procnon", "hostno", "compNO", "cmpna", " compcho", "compgo", " compmo", "componentnum", "seqcho", "winnom", "procyes", "cmppos", "condnumber", "codelo", "expno", "cmpnone", "compnom", " compauto", "compauto", "comNo", "codenum", "componentname", "procno", "cmpdo", "compmo", "seqmo", "cmpNo", "comppos", "macNO", "macnone", "macNo", "compcho", "complo", "compio", "componentindex", "compindex", " compnos", "propNo", "celldo", "seqauto", " complo", "propno", "expnone", "compos", "componentio", "compsn", "cmpgo", "comNO", "propnon", "compnos", "componentnumber", "ompna", "combauto", "macdo", "combcho", " compnone", "macnos", "macyes", "compyes", "comno", "procnode", "seqpos", "hostname", "seqnone", "cellno", "winnone", " compdo", " compio", "comnone", "condname", "comgo", "comna"], "i": ["l", "ui", "di", "start", "si", "n", "in", "zi", "key", "w", "id", "m", "xi", "k", "b", "z", "t", "d", "c", "ji", "p", "ix", "e", "yi", "eni", "f", "ie", "j", "ai", "o", "index", "v", "ind", "gi", "mi", "qi", "pi", "bi", "ii", "u", "type", "h", "I", "li", "ip", "ci", "ori", "io", "fi", "iu"], "y": ["l", "ym", "ady", "yt", "oy", "ry", "g", "asy", "w", "m", "ny", "xi", "id", "b", "ey", "z", "vy", "uy", "d", "ye", "c", "by", "cy", "p", "e", "iy", "yi", "ay", "zy", "f", "yy", "sy", "j", "gy", "o", "py", "v", "yx", "sky", "name", "ind", "ky", "yl", "Y", "ty", "col", "yr", "type", "h", "xy", "year", "ya", "io", "ch", "wy", "dy", "yo"], "x": ["l", "ady", "xp", "n", "php", "g", "in", "ax", "key", "w", "m", "xx", "id", "xi", "b", "t", "z", "sw", "d", "ey", "k", "c", "data", "X", "p", "ix", "el", "e", "cy", "lex", "pe", "cross", "xs", "loc", "q", "f", "gy", "code", "j", "o", "index", "py", "v", "yx", "name", "fx", "yl", "hy", "ty", "tx", "Y", "wx", "xc", "u", "xy", "h", "xe", "pos", "rx", "px", "sex", "on", "ya", "image", "wy", "dx", "dy", "ex"], "line": ["l", "side", "byte", "base", "le", "lf", "scale", "len", "val", "source", "comment", "key", "word", "model", "point", "page", "letter", "ne", "Line", "data", "lo", "block", "el", "rule", "layout", "e", "liner", "po", "style", "lines", "frame", "step", "strip", "la", "code", "unit", "label", "o", "stroke", "sync", "name", "LINE", "end", "lay", "pe", "node", "link", "type", "layer", "mean", "cel", "pos", "file", "li", "cycle", "ge", "header", "lined", "out", "cell", "ine", "write", "lc", "row", "pin", "lin", "kl"], "tile": ["tle", "je", "le", "ite", "theme", "t", "ele", "uri", "ace", "pixel", "ie", "stone", "profile", "google", "surface", "port", "hop", "type", "pod", "interface", "image", "flat", "tif", "chip", "rule", "draw", "component", "e", "late", "pe", "f", "slice", "py", "module", "sky", "oodle", "live", "plate", "layer", "sim", "file", "complete", "ge", "site", "ski", "transfer", "sample", "grid", "source", "ile", "plane", "game", "Tile", "project", "coord", "cli", "style", "coll", "o", "edge", "feature", "node", "oper", "single", "tin", "core", "tun", "ole", "dot", "co", "scale", "phy", "service", "oe", "p", "texture", "server", "table", "js", "square", "ten", "coe", "match", "so", "lin", "te", "ube"], "comp": ["play", "html", "cmp", "dom", "war", "lab", "quad", "config", "ref", "gl", "loc", "cc", "ac", "code", "omp", "cap", "mod", "com", "spec", "type", "grad", "comm", "prep", "buff", "par", "mac", "cond", "cont", "serv", "con", "c", "ct", "component", "e", "app", "pro", "prop", "group", "op", "unit", "module", "cl", "col", "sim", "ch", "cell", "lc", "comb", "sc", "company", "seq", "source", "prof", "class", "src", "project", "cp", "cum", "coord", "coll", "host", "oper", "cat", "cache", "vec", "crit", "imp", "core", "chrom", "co", "comment", "info", "pack", "p", "sec", "Component", "supp", "lib", "parse", "ctx", "cor", "Comp", "coe", "ip", "ci", "clip", "loop", "css", "proc", "gen"], "dst": ["Dsc", "lst", "dST", "dsc", "DST", " dsc", " dsts", " dST", "Dst", "Dsts", "lST", "lsts", "dsts", "lsc"], "ptr": ["Ptr", "dra", "adr", "vert", "td", "tr", "str", "len", "ext", "span", "pad", "prot", "kr", "pointer", "pat", "data", "addr", "ref", "deg", "coord", "pointers", "attr", "dist", "pt", "plug", "wr", "loc", "push", "lr", "dr", "code", "rt", "trace", "ctr", "butt", "tip", "ridge", "pr", "trans", " pointer", "offset", "etr", "touch", "grad", "pair", "vr", "pos", "cel", "spl", "ft", "br", "ped", "buffer", "kl"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n", "idx": 11781, "substitutes": {"ctx": ["cam", "context", "cmp", "Context", "conn", "tc", "sci", "fw", "cp", "c", "cf", "loc", "bc", "cc", "cs", "alloc", "cv", "exc", "rc", "cas", "tx", "pc", "xc", "ca", "cm", "vc", "lc", "pkg", "kb"], "fs": ["vs", "FS", "ts", "uses", "ks", "ds", "sf", "stats", "fd", "files", "fw", "flows", "fb", "ls", "fp", "feed", "xs", "outs", "bits", "wcs", "rs", "f", "df", "os", "cs", "flags", "fps", "states", "ns", "bytes", "ms", "less", "gets", "sys", "ps", "ss", "ows", "bs", "Fs", "fts", "fc"]}}
{"project": "FFmpeg", "commit_id": "4b5a12a2cb0252c4a08b6d099eaf69523e8c62e5", "target": 0, "func": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)\n\n{\n\n    AResampleContext *aresample = inlink->dst->priv;\n\n    const int n_in  = insamplesref->audio->nb_samples;\n\n    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);\n\n    AVFilterLink *const outlink = inlink->dst->outputs[0];\n\n    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);\n\n    int ret;\n\n\n\n    if(!outsamplesref)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);\n\n    outsamplesref->format                = outlink->format;\n\n    outsamplesref->audio->channel_layout = outlink->channel_layout;\n\n    outsamplesref->audio->sample_rate    = outlink->sample_rate;\n\n\n\n    if(insamplesref->pts != AV_NOPTS_VALUE) {\n\n        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);\n\n        int64_t outpts= swr_next_pts(aresample->swr, inpts);\n\n        aresample->next_pts =\n\n        outsamplesref->pts  = (outpts + inlink->sample_rate/2) / inlink->sample_rate;\n\n    } else {\n\n        outsamplesref->pts  = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,\n\n                                 (void *)insamplesref->extended_data, n_in);\n\n    if (n_out <= 0) {\n\n        avfilter_unref_buffer(outsamplesref);\n\n        avfilter_unref_buffer(insamplesref);\n\n        return 0;\n\n    }\n\n\n\n    outsamplesref->audio->nb_samples  = n_out;\n\n\n\n    ret = ff_filter_samples(outlink, outsamplesref);\n\n    aresample->req_fullfilled= 1;\n\n    avfilter_unref_buffer(insamplesref);\n\n    return ret;\n\n}\n", "idx": 11793, "substitutes": {"inlink": ["insmachine", "inself", "rinlink", "conself", "inload", "outload", "outbase", "inmachine", "insplug", "outLink", "inlinks", "inflow", "insmission", "idplug", "insink", "incblock", "outflow", "insself", "InLink", "conbase", "incload", "Inlock", "exmission", "vinlink", "inblock", "Inlink", "insblock", "insflow", "outmission", "inclinks", "idlink", "inclink", " inload", "outlock", "incLink", "insline", "Inline", "inslock", "inslink", "vinself", "conlink", " inblock", "insbase", "outplug", "inslinks", "outmachine", "incline", "rinlock", "rinflow", "inink", "inlock", "outline", "idline", "vinmachine", " inlock", "incflow", "outself", " inflow", "inLink", "exlink", "inplug", "exline", " inLink", "vinline", "inbase", "exink", "conline", "outink", "idink", " inlinks", "rinline", "inmission"], "insamplesref": ["consizesREF", "insampsbase", "insampsref", "insimentsbase", "insamplesREF", "insamplesarc", "insipsREF", "insgroupsREF", "insizesREF", "insappsREF", "insamplesrc", "insgroupsreference", "insizesref", "insipsreference", "consizesarc", "insampsall", "outsamplesrel", "inschangesrec", "nschangesbase", "insipsarc", "insamplesbf", "insourcesall", "consizesref", "nsourcesall", "outsamplesarc", "insizesconfig", "inasappsrel", "insblocksRef", "consamplesreference", "insamplespre", "insipsref", "consamplesREF", "nsamplesrel", "nschangesref", "insamplesrec", "outsampsRef", "insamplesrel", "insformsref", "insizesRef", "nsamplesconfig", "insampsrc", "insamplearc", "insimagesref", "insampleRef", "consamplesarc", "nsourcespre", "insamplesconfig", "inasappsrc", "insformsrel", "inasamplesrel", "insamplesreference", "inasamplesrc", "insappsrel", "insampleall", "insourcesref", "nsamplesall", "outsampsbf", "insourcespre", "insizesall", "inschangesbase", "insampleref", "inspectsref", "inspectsrel", "insimagesall", "insblocksall", "outsamplesbf", "insamplesall", "outsamplesRef", "insgroupsarc", "insimentsrel", "insamplesbase", "outsampsall", "insappsrc", "insampsREF", "consizesreference", "insizesrel", "insizesbf", "insimentsref", "nsourcesref", "insourcesconfig", "inasamplesREF", "insgroupsref", "insformsbf", "inspectsrc", "insourcesrel", "insimagespre", "insampsRef", "outsampsrec", "nschangesrel", "insampsbf", "inspectsREF", "nsourcesconfig", "inasappsREF", "insizespre", "insamplesRef", "insappsref", "insizesarc", "insampsarc", "nsamplesbase", "consamplesref", "insimagesconfig", "insourcesRef", "outsampsrel", "insampsrec", "nsamplesref", "outsamplesrec", "insampsrel", "insformsRef", "inschangesrel", "insizesreference", "outsampsref", "insblocksref", "insourcesrec", "nsamplespre", "outsampsarc", "outsamplesall", "inasamplesref", "inasappsref", "insblocksarc", "inschangesRef", "inschangesref"], "aresample": ["alessample", "allowsample", "airssample", "astersamples", "capssample", "nasamp", "aresuper", "owerspling", "arspring", "airsammy", "stspling", "aresamples", "astersuper", "arsample", "oresource", "nasamples", "aresamp", "stsamples", "allowssample", "airsuper", "owersample", "stsample", "allowspring", "nassample", "rasource", "oresuper", "rasuper", "astersource", "aresource", "rasample", "airsamp", "capsammy", "owersamples", "alespring", "alesample", "owerssample", "arespling", "alesuper", "asterspling", "astersample", "rasamp", "aresammy", "allowsamples", "arsammy", "nasample", "oresamp", "asterssample", "arespring", "airspring", "stssample", "arsamples", "astersamp", "oresample", "arsamp", "capsamp", "asterspring", "aressample", "arssample", "airsample", "capsample"], "outlink": ["atdisk", "outlock", "upline", "upload", "outmodel", "atmachine", "outpack", "offline", "bootline", "inload", "outload", "uplinks", "bootlink", "infeed", "inmodel", "uplock", "outbase", " outdisk", "inmachine", "outmachine", "downline", "Outline", " outline", "indisk", "Outdisk", "inbase", "atline", "atlink", "outdisk", "inlinks", "offlink", "offlinks", "outerdisk", "outerline", "uplink", "offbase", "inlock", "offmodel", " outlock", "inpack", "bootmachine", "outline", "outerlock", "upmachine", "upbase", "downfeed", "upmodel", "outerlink", "uppack", "downmachine", "outlinks", " outpack", "downlink", "Outmachine", "Outlink", " outlinks", " outload", "outfeed", "upfeed", "bootdisk"], "outsamplesref": ["outsizesREF", "flowshipsref", "outsifiersreference", "outsfilesref", "oversamplesbf", "outsampsreference", "outamplesdef", "insampsref", "offsamplesre", "flowsamplesRef", "outsessionsref", "opensampsRef", "outsampsary", "outseriesRef", "outsifiersrel", "outsimagesRef", "outspluginsalt", "offsipesref", "outsampsalt", "outsamplesbase", "insampsalt", "outsampsdef", "outsappsrel", "oversappsref", "nosamplesrel", "outseriesold", "outsizespre", "insamplesold", "outseriesref", "outsimagesref", "outsamplesdef", "offsipesrel", "nosamplesref", "outsagesRef", "outsformsRef", "outspluginsRef", "outsamplesrel", "opensampsreference", "flowshipsreference", "oversamplesref", "offsamplesref", "insamplesbf", "outsamplesREF", "outsipesRef", "outsizesre", "flowshipsRef", "outampsary", "outsgroupsRef", "outsampsold", "outseriesbf", "outsampspre", "outsipesre", "outsamplesary", "outsessionsreference", "opensamplesreference", "outsappsref", "outsourcesrel", "outampsdef", "oversappsbf", "insamplespre", "nosipesrel", "outsgroupsary", "outsidesref", "outsizesrel", "outsitesrel", "outsitesRef", "offsipesRef", "outampsreference", "insamplesalt", "insamplesrec", "outsampsRef", "outsamplesalt", "outsizesRef", "outsifiersbase", "insampsold", "insampsreference", "outshipsrel", "insamplesrel", "outsannelsref", "flowsamplesref", "outsubsref", "outsamplesreference", "outsubsreference", "outsampsREF", "outsagesreference", "outsourcesref", "outsidesdef", "outsannelsrel", "outamplesary", "oversappsREF", "outsipesbase", "outsipesref", "outsimagesreference", "insamplesreference", "outsitesreference", "opensampsref", "outsessionsrel", "opensamplesref", "outsagesrel", "outsamplesold", "outsampsbf", "outsizesreference", "outsizesref", "oversannelsrel", "nosipesbase", "opensampsREF", "outsamplesbf", "oversappsrel", "flowshipsrel", "outsamplesre", "outsamplesRef", "outsappsbf", "outsizesbf", "opensamplesRef", "opensamplesREF", "outsubsREF", "outsagespre", "outsidesreference", "outshipsRef", "outsgroupsrec", "outsamplespre", "outsannelsRef", "insampsRef", "outsagesref", "outsourcesbf", "outsampsrec", "nosipesreference", "insampsbf", "nosamplesbase", "outsformsref", "oversamplesRef", "outsizesdef", "insamplesRef", "outsessionsbase", "outsubsRef", "outsappsREF", "outampsref", "outsourcesREF", "offsipesre", "nosipesref", "outsipesreference", "flowsamplesreference", "oversannelsref", "outsimagesrel", "insampspre", "outsampsrel", "insampsrec", "outsfilesbf", "outsizesary", "outsipesrel", "outsitesref", "oversannelsRef", "outsfilesRef", "outsamplesrec", "outamplesreference", "nosamplesreference", "outsfilesold", "insampsary", "outshipsref", "insampsrel", "outsgroupsref", "outsformsary", "outsampsref", "insamplesary", "outsidesary", "outsifiersref", "flowsamplesrel", "outshipsreference", "outspluginsrel", "outsformsrec", "oversamplesrel", "outspluginsref", "outamplesref", "oversamplesREF", "outsitesalt", "offsamplesRef", "offsamplesrel"], "ret": ["arr", "img", "flag", "alt", "val", "len", "def", "id", "Ret", " Ret", "data", "arg", "lit", "reg", "set", "rets", "code", "rt", "det", "al", "rc", "fun", "att", "part", "art", "bit", "re", "RET", "back", "url", "result", "ann", "match", "feat", "success"]}}
{"project": "FFmpeg", "commit_id": "138568e9da0e3abfc818329ab12ea3fb667639fb", "target": 0, "func": "static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    unsigned int i, entries;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    entries = get_be32(pb);\n\n    if(entries >= UINT_MAX / sizeof(MOV_stts_t))\n\n        return -1;\n\n\n\n    sc->ctts_count = entries;\n\n    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));\n\n    if (!sc->ctts_data)\n\n        return -1;\n\n    dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    for(i=0; i<entries; i++) {\n\n        int count    =get_be32(pb);\n\n        int duration =get_be32(pb);\n\n\n\n        if (duration < 0) {\n\n            av_log(c->fc, AV_LOG_ERROR, \"negative ctts, ignoring\\n\");\n\n            sc->ctts_count = 0;\n\n            url_fskip(pb, 8 * (entries - i - 1));\n\n            break;\n\n        }\n\n        sc->ctts_data[i].count   = count;\n\n        sc->ctts_data[i].duration= duration;\n\n\n\n        sc->time_rate= ff_gcd(sc->time_rate, duration);\n\n    }\n\n    return 0;\n\n}\n", "idx": 11795, "substitutes": {"c": ["cr", "l", "conf", "arc", "co", "oc", "C", "g", "w", "tc", "t", "d", "con", "cp", "s", "p", "cd", "e", "cu", "cf", "ec", "cod", "coll", "bc", "cc", "f", "ac", "cs", "ctrl", "cv", "mc", "ce", "ic", "ctx", "cur", "cl", "dc", "pc", "xc", "enc", "cpp", "u", "nc", "icc", "ca", "cm", "gc", "ci", "vc", "lc", "ch", "cache", "cus", "uc", "cy", "fc"], "pb": ["lp", "dp", "uf", "bb", "wp", "pg", "bp", "prot", "pl", "tc", "bm", "b", "lab", "ab", "wb", "pa", "buf", "cp", "fb", "p", "pd", "cb", "fp", "gb", "pro", "pt", "rb", "pm", "bc", "db", "bf", "mp", "eb", "py", "bps", "bh", "phrase", "ctx", "lb", "tp", "jp", "sb", "pc", "PB", "cpp", "hub", "plugin", "emb", "platform", "mb", "api", "ob", "xb", "proc", "rob", "fc"], "atom": [" bom", " param", "bb", "abc", " biom", " plat", " Atom", " arr", " om", " ab", " mom", " gate", " program", "orb", " atoms", " app", " slab", "AT", " dom", " tom", "cm", " symb", " form", "OM", " org", " tab", "om", " orb"], "st": ["cr", "l", "sp", "std", "ds", "str", "sf", "stage", "src", "t", "sa", "ct", "s", "se", "e", "ec", "sec", "bc", "inst", "contract", "sts", "sl", "sn", "sth", "ste", "cl", "sb", "pc", "sd", "St", "ST", "lc", "ss", "uc", "fc"], "sc": ["cr", "sp", "asc", "SC", "sh", "context", "si", "cca", "tc", "src", "go", "auc", "sw", "RC", "sci", "cer", "capt", "config", "cd", "osc", "gb", "uci", "cf", "Sc", "ec", "sq", "loc", "bc", "cc", "cs", "isc", "sub", "cv", "mc", "scope", "sync", "rc", "inc", "sche", "ctx", "sup", "cl", "desc", "pc", "spec", "enc", "cms", "FC", "sim", "cm", "ca", "usc", "soc", "esc", "comp", "css", "lc", "ch", "ss", "sr", "ocr", "cus", "uc", "core", "cy", "acc", "fc"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "start", "si", "n", "zi", "key", "id", "info", "xi", "m", "b", "ami", "ini", "z", "x", "t", "d", "p", "ix", "uri", "e", "cli", "mu", "esi", "eni", "f", "ie", "j", "code", "ai", "multi", "slice", "v", "name", "gi", "ti", "mi", "phi", "r", "abi", "qi", "ij", "ei", "counter", "bi", "pi", "ii", "u", "type", "I", "li", "ip", "ci", "api", "length", "ni", "y", "io", "ri", "lc", "fi", "iu"], "entries": ["ntrys", "intents", "entsriers", "country", "antry", "endresses", "sentrys", "Entrys", "attries", "entents", "entsries", "enturies", "entencies", "centories", "ntries", "sentries", "sentry", "anturies", "enties", "entrants", "ntrants", "entriers", "mentries", "centrys", "Entries", "estrations", "countries", "Entrics", "ientrics", "menties", "nties", "centries", "attresses", "ientry", "sentents", "idents", "attrations", "entrics", "entsories", "endies", "attrys", "entrys", "intresses", "mentrations", "intries", "idories", "ntrations", "Entry", "centrations", "idries", "antrants", "nturies", "entry", "entrations", "centents", "entresses", "mentencies", "entsents", "antries", "entories", "esties", "intry", "endrys", "idriers", "endries", "intrys", "countents", "countrys", "ientries", "ntencies", "estries", "ntrics", "ienturies", "ientrants", "ntry", "centriers", "Enties", "ientrys", "attry", "estencies", "endry", "centry"]}}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n", "idx": 11806, "substitutes": {"obj": ["arr", "img", "nb", "n", "val", "prefix", "nt", "src", "b", "ab", "iv", "buf", "ref", "Obj", "attr", "cb", "po", "act", "rb", "js", "os", "ut", "inst", "orb", "code", "j", "o", "oa", "opt", "ctx", "object", "oid", "emb", "pos", "ob", "io", "obb", "adj"], "name": ["parent", "alias", "NAME", "base", "n", "val", "comment", "prefix", "key", "word", "w", "id", "info", "path", "filename", "num", "nam", "data", "time", "names", "cn", "f", "o", "named", "size", "min", "object", "option", "new", "part", "ns", "type", "ame", "out", "ann", "Name"], "o_out": ["o_OUT", "o_outs", "o__in", "o__OUT", "o_in", " o_array", " o_in", "o__outs", " o_outs", " o_OUT", "o_array", "o__out"]}}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        if (bdrv_truncate(base, length) < 0) {\n\n            error_setg(errp, \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, errp,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(errp)) {\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 11810, "substitutes": {"bs": ["vs", "boot", "bb", "ds", "is", "src", "bas", "http", "bid", "b", "ab", "ops", "gs", "block", "fb", "s", "ls", "pb", "obj", "gb", "ins", "bits", "outs", "js", "rs", "BS", "bc", "os", "obs", "cs", "db", "bf", "eb", "bps", "es", "ras", "sync", "state", "proxy", "abi", "lb", "bot", "bis", "bi", "ns", "sb", "blocks", "bytes", "as", "null", "client", "ses", "ps", "fs", "css", "ob", "bin", "bing", "core", "bos"], "base": ["parent", "pse", "is", "based", "http", "block", "Base", "pb", "body", "fake", "state", "bis", "orig", "type", "url", "bn", "buffer", "bb", "prefix", "key", "view", "id", "bid", "b", "create", "c", "ase", "se", "bc", "f", "db", "bf", "es", "pre", "bi", "position", "root", "plugin", "kit", "file", "build", "back", "bank", "boot", "real", "source", "model", "builder", "bare", "basic", "cp", "local", "status", "cli", "os", "resource", "size", "sync", "home", "proxy", "part", "super", "use", "cache", "core", "area", "ui", "original", "start", "bas", "job", "line", "server", "p", "bu", "name", "bot", "address", "client", "api", "null"], "speed": ["count", "score", "timeout", "delay", "rate", "scale", "start", "si", "sf", "path", "send", "sleep", "time", "limit", "status", "driver", "set", "stop", "mode", "sk", "priority", "progress", "size", "slice", "wait", "Speed", "fps", "state", "peed", "buffer", "sn", "port", "position", "grade", "offset", "command", "fast", "url", "engine", "seed", "settings", "slow", "security"], "on_error": [" on_ror", "on_failed", "onofferror", "onallgrade", "on_err", "onferror", " on_layer", "onallror", " on_failed", "ononstart", " onallror", " onallclose", "onallprogress", "onofffailed", "onallerror", "on_layer", " onallfailed", " onallerror", " on_progress", "onfror", " on_close", " on_err", "on_progress", "onoffclose", "on_start", "on_grade", "ononerror", "onofflayer", " onallerr", "onallfailed", "onffailed", "ononlayer", "on_close", " onallgrade", " onallprogress", "onoffror", "onoffstart", "onfclose", "onallclose", "onallerr", " on_grade", "on_ror", "ononror", " on_start"], "cb": ["cr", "bb", "cmp", "conn", "tc", "unc", "wb", "buf", "job", "cp", "c", "fb", "pb", "cd", "fp", "cf", "rb", "cod", "bc", "cc", "db", "bf", "cs", "call", "eb", "ctrl", "cv", "CB", "ctx", "fun", "callback", "function", "err", "fn", "nc", "gc", "cfg", "handler", "ob", "func", "obb", "cgi"], "opaque": ["opsace", "Opaques", "copace", "opasso", " opane", "opane", "Opaque", " opace", " opaques", "opsaque", "Opasso", "oplaques", "copane", "opace", "opsane", " opasso", "copaque", "opaques", "oplaque", "oplasso"], "errp": ["erp", "errorc", "idp", "armfp", "orderpc", " errP", "reqpe", "errcp", "errper", "yrpi", "rrf", " errpi", "ordersp", "idfp", "reqp", " errc", "yrper", "errf", "erP", "err", "erpc", "ercp", "erfp", " errps", "errv", "yrcp", "strsp", "reqpc", "aerc", "errps", "yrP", "erc", " errper", " errf", "aerf", " errv", "ierpi", "errpi", "errc", "ierper", " errr", "armp", "idv", "aerps", "reqP", "ierP", "errorp", "strpc", "errsp", "errP", "errpc", "ierp", "orderp", "idps", "yrpe", "iersp", "errfp", "errorr", "armv", "rrc", "errpe", "strP", " errpc", " errpe", "errorpc", "armps", "rrps", "rrp", "yrp", "yrfp", " errfp", "erpe", "strp", "aerp", " errcp", "orderP", "errr", "ierpc"], "length": ["count", "l", "zip", "level", "library", "delay", "len", "section", "ph", "capacity", "ength", "view", "mount", "path", "total", "job", "angle", "block", "limit", "time", "work", "p", "value", "number", "style", "loc", "Length", "sequence", "body", "height", "code", "child", "size", "shape", "duration", "slice", "live", "name", "sl", "distance", "address", "buffer", "port", "load", "full", "pull", "cost", "position", "grade", "offset", "root", "type", "lock", "build", "url", "match", "weight", "core", "depth", "range"], "base_length": ["based_width", "base8depth", "baseClength", "baseCwidth", "base_count", " base_Length", "base48depth", "base48width", "based_depth", "base_type", "base8width", "base_sequence", "base_lock", "base_len", "base_Length", " base_width", "base_definition", "base_width", "base48type", " base_depth", "baseCdepth", "based_length", "base48length", "based8sequence", " base_len", "based_sequence", "base8sequence", "baseCsequence", " base_count", "based8width", "layer_definition", "base8length", "based8depth", "layer_full", "base_depth", " base_type", "layer_lock", "based8length", "base_full", "layer_length"], "orig_base_flags": ["orig_server_bytes", "orig_server_args", "orig_server_vals", "orig_base_bytes", "orig_server_files", "orig_cache_args", "orig_base\u00b7bytes", "orig_base\u00b7vals", "orig_cache_types", "orig_base_files", "orig_cache_flags", "orig_server_flags", "orig_base\u00b7flags", "orig_base_args", "orig_base_vals", "orig_base_types"]}}
{"project": "FFmpeg", "commit_id": "4f90688b6e1d79d85ac2e065a2cf1e7e9bd665a7", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n                                  MatroskaTrack *track)\n{\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n    uint8_t* data = *buf;\n    int isize = *buf_size;\n    uint8_t* pkt_data = NULL;\n    int pkt_size = isize;\n    int result = 0;\n    int olen;\n    switch (encodings[0].compression.algo) {\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n        return encodings[0].compression.settings.size;\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n        do {\n            olen = pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n        if (result)\n            goto failed;\n        pkt_size -= olen;\n        break;\n#if CONFIG_ZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n        z_stream zstream = {0};\n        if (inflateInit(&zstream) != Z_OK)\n        zstream.next_in = data;\n        zstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            zstream.avail_out = pkt_size - zstream.total_out;\n            zstream.next_out = pkt_data + zstream.total_out;\n            result = inflate(&zstream, Z_NO_FLUSH);\n        } while (result==Z_OK && pkt_size<10000000);\n        pkt_size = zstream.total_out;\n        inflateEnd(&zstream);\n        if (result != Z_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n#if CONFIG_BZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n        bz_stream bzstream = {0};\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n        bzstream.next_in = data;\n        bzstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n            result = BZ2_bzDecompress(&bzstream);\n        } while (result==BZ_OK && pkt_size<10000000);\n        pkt_size = bzstream.total_out_lo32;\n        BZ2_bzDecompressEnd(&bzstream);\n        if (result != BZ_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n    default:\n    }\n    *buf = pkt_data;\n    *buf_size = pkt_size;\n    return 0;\n failed:\n    av_free(pkt_data);\n}", "idx": 11813, "substitutes": {"buf": ["bag", "uf", "map", "seq", "Buffer", "len", "pad", "src", "b", "mount", "fb", "batch", "config", "addr", "cb", "queue", "array", "tmp", "empty", "bc", "padding", "alloc", "Buff", "cap", "rc", "input", "port", "result", "vec", "buff", "br", "cmd", "buffer"], "buf_size": ["buf_sn", "buflexsize", "fb_sn", "buflexdata", "buf_channel", "pkg_range", "fblexsize", "buf_range", "fb_data", "fb_channel", "buf_ize", "buflexchannel", "buf_data", "pkg_ize", "fb_size", "fblexchannel", "buf_shape", "buflexsn", "pkg_shape", "fblexsn", "pkg_size", "fblexdata"], "track": ["round", "ack", "tr", "test", "record", "board", "tag", "path", "project", "metadata", "config", "stream", "add", "car", "package", "seek", "step", "dr", "train", "trace", "order", "r", "trip", "port", "Track", "roll", "form", "tracking", "rack", "transform", " tracks", "row", "match", "tracks", "ACK"], "encodings": ["encoderations", "enccoders", "enccods", "enoderers", "enoding", "enccodations", "eccodments", "encoding", "encodedments", "enccodings", "encoderers", "eccodions", "encodeds", "encodions", "encODings", "ecodments", "encods", "encodesings", "encoderions", "ecoders", "encodesions", "enccodions", "enccodments", "enodering", "eccodings", "enodions", "enoderions", "encODing", "eccods", "eccoding", "ecodings", "ecodions", "encodedings", "encodesments", "ecoding", "encoderings", "encODions", "encodedions", "encodeding", "eccodations", "encodations", "enoders", "enccoding", "encodments", "encODers", "ecods", "enoderings", "encodeders", "encodesing", "ecodations", "enodings", "encoders", "encodering", "encODs", "encODations", "eccoders"], "data": ["parent", "zip", "devices", "sample", "arr", "byte", "base", "di", "valid", "str", "start", "len", "in", "media", "window", "pad", "record", "temp", "all", "batch", "config", "ata", "memory", "array", "empty", "xxx", "body", "la", "DATA", "none", "padding", "next", "dat", "multi", "zero", "size", " DATA", "format", "input", "response", "raw", "results", "dd", "new", "Data", "after", "bytes", "pos", "api", "extra", "cache", "result", "buffer", "database"], "pkt_data": ["pkt_scale", "petsk_data", "pkt_dat", "petsk_size", "pkt_shift", "packet_body", "packet_size", "pft_dat", "pant_block", "pkg_dat", "petsk_length", "pkt_size", "packet_start", "pant_size", "pant_data", "pkg_scale", "pant_shift", "packet_data", "pkt_value", "pkt2data", "pkg_size", "pkg_start", "pkg_data", "packet_dat", "pkt_block", "pft_size", "pft_data", "pkt2dat", "pft_value", "pkt_length", "pkt_body", "pkt_start", "pkt2size"], "olen": ["oren", "ole", "lah", "le", "valid", "len", "lif", " leftover", "linger", "liv", "numbered", "temp", "oin", "uno", "aiden", "oven", "where", "orno", "ele", "lost", "lvl", "osen", "more", "slot", "serv", "eden", "zie", "afi", "skip", "nn", "lins", "regon", "eni", "what", "eno", "loss", "foo", "sle", "blank", "non", "nil", "nom", "little", "nar", "kn", "lov", "ien", "won", "ellen", "oln", "fin", "legal", "sol", "lan", "broken", "ln", "olo", "lo", "fee"]}}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n", "idx": 11833, "substitutes": {"cs": ["ks", "ds", "c", "cp", "ls", "ace", "qs", "cf", "cn", "wcs", "ec", "cc", "ac", "acs", "ce", "rc", "ras", "sync", "CS", "ics", "cas", "cons", "ctx", "ns", "pc", "spec", "cms", "sys", "ca", "ci", "fs", "ps", "css", "lc", "cus", "sc", "Cs"], "addr": ["setup", "alias", "mac", "base", "cmp", "len", "val", "prefix", "pad", "conn", "src", "x", "pointer", "ad", "ref", "config", "ace", "attr", "ptr", "args", "socket", "mode", "dr", "host", "pkg", "index", "alloc", "oa", "rc", "name", "proxy", "r", "ctx", "address", "nr", "offset", "node", "eth", "pos", "ip", "cmd", "proc"], "is_write": ["is__writing", " is_writ", " is_written", " is_writing", "is_writ", "is__writ", " is_read", "is_read", "is__read", "is_writing", "is__write", "is_written", "is__written"], "is_exec": ["is___execute", "is__exclusive", "is_exclusive", " is_read", "is_read", " is_exclusive", " is__read", "is__read", " is__exclusive", "is__execute", "is___read", " is_execute", " is__execute", "is___exec", "is___exclusive", "is__exec", " is__exec", "is_execute"], "unused": ["uninitialized", "nused", "nuse", "onusable", "unusable", " unuse", "nusable", " uninitialized", "ninitialized", "unuse", "onused", "onuse", " unusable", "oninitialized"], "size": ["count", " bytes", "timeout", "len", "capacity", "SIZE", "mem", "data", "s", "max", "memory", "empty", "Size", "sec", "mode", "unit", "alloc", "cap", "name", "rc", "ctx", "address", "blocks", "offset", "bytes", "length", "ize"], "cpu": ["parent", " cp", "uca", "cow", "kernel", "cmp", "processor", "conn", "gpu", "bench", "net", "ne", "cp", "vm", "c", "ace", "cli", "np", "uci", "cn", "ec", "eni", "ac", "console", "unit", "ea", "clock", "ctx", "pu", "pc", "node", "cpp", "CPU", "nc", "cache", "lc", "proc", "core", "fc"], "env": ["vs", "inet", "context", "ext", "conn", "estate", "ini", "viron", "export", "ne", "environment", "vm", "config", "el", "enable", "stack", "e", "ace", "np", "global", "nw", "act", "args", "ec", "eni", "style", "cf", "network", "er", "db", "console", "ev", "skin", "eval", "exc", "scope", "energy", "ea", "oa", "edge", "state", "ctx", "loader", "en", "err", "Environment", "enc", "pect", "init", "cfg", "nc", "et", "eye", " environment", "extra", "site", "cache", "agent", "engine", "eu", "core", "settings"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static int virtio_serial_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&\n\n        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */\n\n        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */\n\n        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;\n\n\n\n    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);\n\n    if (!vdev) {\n\n        return -1;\n\n    }\n\n    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED\n\n                                        ? proxy->serial.max_virtserial_ports + 1\n\n                                        : proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    proxy->class_code, 0x00);\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}\n", "idx": 11834, "substitutes": {"pci_dev": ["pci7ev", "pci_div", "pci_data", "pcgi_serial", "pki_device", "pci7device", "pki_serial", "pci0diff", "pcgi_diff", "pcu_ev", "pcu_device", "pci2dev", "pci_diff", "pci2diff", "pci2serial", "pci2div", "pcgi_div", "pci_device", "pcu_serial", "pci_serial", "pci0serial", "pcgi_dev", "pci0div", "pcgi0dev", "pci7dev", "pci7serial", "pcgi0div", "pki_dev", "pci0dev", "pcu_data", "pcu_dev", "pcgi0serial", "pci_ev", "pcgi0diff"], "proxy": ["parent", "roxy", "play", "zip", "pse", "alias", "session", "library", "base", "source", "model", "http", "instance", "project", "pa", "shadow", "pool", "service", "bridge", "config", "server", "facebook", "component", "ace", "pro", "driver", "wrapper", "pe", "serial", "socket", "clone", "slave", "manager", "XY", "share", "profile", "resource", "child", "device", "lib", "cop", "module", "route", "linux", "ce", "slice", "connection", "remote", "response", "loader", "callback", "ruby", "port", "docker", "super", "PRO", "web", "copy", " proxies", "reverse", "plugin", "fax", "xy", "root", "Proxy", "client", "null", "su", "image", "cache", "use", "interface", "engine", "force"], "vdev": [" vvar", "vvdev", "evdevice", "svdiv", "vdiff", "ldev", "pev", "nvDev", "vvdi", "svdevice", "Vev", "wdev", "vcserial", "vcdev", "tvdiff", "vdi", "svserial", "vdevice", "Vdc", "Vdev", "Vdef", " vdc", "tvDev", "vcvar", "Vdi", "pdev", " vdevice", "nvdiff", "svvar", " vdes", "svdiff", " vdi", "vev", "svdd", "svdev", "vvar", "vdd", "nvdes", "vDev", " vdd", "ldevice", " vev", " vDev", "Vgd", "evdc", " vdiff", "VDev", "evdev", "vgd", "vvgd", "vdef", "wdiv", "pdef", " vdef", "nvdev", "vserial", "vcdiff", "vdes", "wdevice", "wdd", "tvdev", "vdiv", "vvdd", "pdevice", "tvdes", "evDev", " vserial", " vgd", "Vdd", "vdc", "ldd", "Vdevice"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n", "idx": 11840, "substitutes": {"id": ["parent", "ide", "it", "start", "did", "handle", "path", "uid", "pid", "data", "ids", "chid", "cb", "ID", "mid", "child", "kid", "name", "connection", "rid", "ident", "oid", "root", "Id", "ip", "sid", "proc"], "backend": ["backward", "frontension", " backended", "Backender", "Backward", "backended", "Backension", " backender", " backension", "Backend", " backward", "frontward", "backension", "frontended", "backender", "frontend", "Backended", "frontender"], "ret": ["std", "val", "proc", "def", "nt", "conn", "Ret", "mem", "buf", "data", "bd", "lit", "reg", "rets", "res", "linux", "rc", "fun", "urn", "desc", "eth", "fin", "RET", "result", "resp", "fi", "exec"], "errp": ["erp", " errP", "errpre", "rrbp", "excP", " errbp", "excr", "rorpre", "erv", "rrpre", "rrp", " errpre", "errP", "erP", "err", "rorP", " errv", "rorbp", "rorp", "rrP", "errbp", "errv", "excv", " errr", "errr", "excp"], "serial": ["smart", "devices", "boot", "pass", "pocket", "handle", "normal", "product", "mor", "no", "model", "erial", "gpu", "path", "mount", "public", "tty", "config", "reader", "lit", "local", "driver", "private", "feed", "machine", "array", "hw", "select", "mode", "binary", "host", "device", "Serial", "linux", "version", "series", "connection", "raw", "proxy", "port", "native", "ident", "phone", "usb", "unknown", "bus", "custom", "dev", "ser", "micro", "proc", "random"], "fd": ["cond", "gd", "lf", "ds", "handle", "ff", "af", "rd", "sf", "die", "fed", "pid", "fw", "d", "i", "buf", "data", " fid", "c", "bd", "fb", "draw", "cd", "cb", "fp", "exec", "cf", "feed", " f", "dn", "df", "f", "dl", "fa", "db", "bf", "fl", "nd", "draft", "ind", "fx", "md", "done", "dd", "vd", "FD", " FD", "dc", "sd", "hd", "fin", "fn", "handler", "F", "file", "fs", "buff", "wd", "fi", "fe", "fc"]}}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 11843, "substitutes": {"pci_bus": ["pki_bridge", "pdi_boot", "pci__system", "pci_system", "pci__bus", "pciADboot", "pciAMboot", "pcu_usb", "pcu_boot", "pcm_bus", "pdi_usb", "pki_system", "pcm_connection", "pciADusb", "pcm_boot", "pci_us", "pci__bridge", "pcm_system", "pci_usb", "pcu_bus", "pci__boot", "pki_bus", "pci_connection", "pciAMinterface", "pcu_interface", "pciAMusb", "pdi_bus", "pci_bridge", "pciADbus", "pciAMbus", "pci_boot", "pki_boot", "pciADconnection", "pdi_us", "pci_interface", "pcm_usb"]}}
{"project": "qemu", "commit_id": "75554a3ca10a7ad295d2a3d2e14ee6ba90f94c8b", "target": 0, "func": "struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n", "idx": 11844, "substitutes": {"ta": ["eta", "sea", "area", "va", "ama", "base", "TA", "ppa", "si", "source", "wa", "na", "da", "ba", "t", "pa", "ra", "sha", "sa", "tu", "ka", "meta", "qa", "ata", "ada", "au", "fa", "alpha", "ha", "asia", "oa", "ea", "tta", "asi", "sta", "ti", "address", "ga", "ty", "asta", "tm", "ca", "ma", "asa", "a", "aka", "beta", "era"], "irq": ["ircch", "irf", "ircf", "iref", "irqq", "irech", " irch", " irqq", "ireq", "arqs", "ircq", "risk", "irch", " irf", "arqq", "ircqs", " irk", "irqs", "ark", "irk", "risqq", " irqs", "risqs", "ireqs", "risq", "arq"], "fclk": ["fClke", "fmlc", "rfplq", "fplc", "fslq", "rfclke", "fmla", "cfplc", "fpla", "rfpla", "fClq", "fclke", "fClc", "cfclc", "rfplke", "rfcla", "fplke", "fmlq", "fplk", "cfclke", "fsla", "fplq", "rfclk", "fclc", "cfplq", "fcla", "fslke", "fslk", "rfplk", "rfclq", "fmlk", "cfplke", "fmlke", "cfplk", "cfclk", "fClk", "cfclq", "fclq"], "iclk": ["icrlK", "acclke", "iclK", "iaclcke", "aclks", "icelks", "acclks", "icrlk", "iaclcks", "aclk", "icelke", "iaclks", "icclke", "icLks", "icelk", "icLq", "icclks", "icLk", "iaclcq", "iclke", "iaclk", "icclk", "iclq", "acclk", "aclke", "icrlke", "iaclq", "icrlks", "iclcks", "iaclck", "iclcke", "icclq", "iaclke", "aclK", "icLke", "icelK", "iclcq", "acclK", "icclK", "iclck", "iclks"], "txdma": ["txdsna", "rxlma", " txsdma", "rxdna", "txpdama", "txpdma", "txpdwa", "txlsta", "txdssta", " txsdwa", "txdsama", "txdsga", "txdswa", "txsdta", " txdwa", "txsdwa", " txsdta", "txlna", "txmna", "txdsta", "txmga", "txdta", " txsdama", "txdama", "txlga", "rxlna", "txlma", " txdama", "txmsta", "rxdga", "txsdma", "txdna", "rxlga", "rxdsta", "txsdama", "txpdta", "txdsma", "rxlsta", "txmma", " txdta", "txdga", "txdwa"], "rxdma": ["arxdwa", "rhdmas", "rgdka", "rxdwa", "rddwa", "arddda", "rxcwa", "rhdda", "rfdka", "rxcda", "arddmas", "rfdmas", "rhdma", " rxcmas", " rxdka", "rgdmas", " rxdga", "rddmas", "arxdma", "arxdmas", "rxdmas", "rfdma", "rxdga", "rgdga", "rddda", "rxdda", "rgdma", " rxcma", "rhdwa", "arddma", " rxcga", " rxcka", "rfdga", "rxcka", "rxcga", "rxcma", "rddma", "rxcmas", "rxdka", "arddwa", " rxdmas", "arxdda"], "chr": [" chc", "chp", "schar", "cherc", " chp", " chrs", "chrs", "thre", "Chrs", "schp", "Char", "Chr", "chre", " chre", "cherre", "Chp", "schr", "schrs", "cherrs", "thrs", "thr", "chc", "thc", "cherr"], "s": ["l", "ings", "session", "sg", "base", "is", "si", "g", "span", "ds", "its", " signs", "w", "m", "t", "b", "d", "i", "gs", "sa", "c", "service", "p", "ls", "se", "e", "sq", "js", "rs", "f", "os", "cs", "sym", "o", "sets", "S", "es", "sync", "south", "sl", "services", "r", "sup", "ches", "support", "als", "sb", "ns", " parts", "spec", "as", "u", "sys", " is", "secondary", "ses", "a", "site", "su", "ps", "ss", "ures", "ows", "settings", "ssl", "ves"]}}
{"project": "qemu", "commit_id": "6e6e55f5c2e5b520d6506c2716287ba3b5d1bbc8", "target": 0, "func": "static void QEMU_NORETURN help(void)\n\n{\n\n    const char *help_msg =\n\n           QEMU_IMG_VERSION\n\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n\n           \"QEMU disk image utility\\n\"\n\n           \"\\n\"\n\n           \"    '-h', '--help'       display this help and exit\\n\"\n\n           \"    '-V', '--version'    output version information and exit\\n\"\n\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\n           \"                         specify tracing options\\n\"\n\n           \"\\n\"\n\n           \"Command syntax:\\n\"\n\n#define DEF(option, callback, arg_string)        \\\n\n           \"  \" arg_string \"\\n\"\n\n#include \"qemu-img-cmds.h\"\n\n#undef DEF\n\n#undef GEN_DOCS\n\n           \"\\n\"\n\n           \"Command parameters:\\n\"\n\n           \"  'filename' is a disk image filename\\n\"\n\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n\n           \"    manual page for a description of the object properties. The most common\\n\"\n\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n\n           \"    encryption keys.\\n\"\n\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n\n           \"    options are the same as for the 'cache' option\\n\"\n\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n\n           \"    supported. 'b' is ignored.\\n\"\n\n           \"  'output_filename' is the destination disk image filename\\n\"\n\n           \"  'output_fmt' is the destination format\\n\"\n\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n\n           \"    used format\\n\"\n\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\n           \"    '[ID_OR_NAME]'\\n\"\n\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n\n           \"    instead\\n\"\n\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n\n           \"  '-p' show progress of command (only certain commands)\\n\"\n\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n\n           \"       fully allocated\\n\"\n\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n", "idx": 11852, "substitutes": {"QEMU_NORETURN": ["QEMU_RESATURN", "QEMU_NORISTUN", "QEMU_NOREOUN", "QEMU_NOREOURN", "QEMU_RESETURN", "QEMU_NORATUN", "QEMU_RESATUN", "QEMU_RESATurn", "QEMU_NORETUR", "QEMU_NORATUR", "QEMU_NORISTUR", "QEMU_NORATURN", "QEMU_RESATUR", "QEMU_NORISTURN", "QEMU_RESETurn", "QEMU_NOREOurn", "QEMU_RESETUN", "QEMU_NORETUN", "QEMU_NORISTurn", "QEMU_NORATurn", "QEMU_RESETUR", "QEMU_NORETurn", "QEMU_NOREOUR"], "help_msg": ["help2msg", "help_info", "helplogmsg", "utillogmsg", "help_call", "util_info", "utillogMsg", "help2info", "utillogcall", "util_msg", "help2call", "help2Msg", "util_Msg", "helplogcall", "helploginfo", "help_Msg", "helplogMsg", "utilloginfo", "util_call"]}}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void coroutine_fn bdrv_create_co_entry(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    CreateCo *cco = opaque;\n\n    assert(cco->drv);\n\n\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(&cco->err, local_err);\n\n    }\n\n    cco->ret = ret;\n\n}\n", "idx": 11853, "substitutes": {"opaque": ["compatile", "obaque", "compaque", "opacity", "opatile", "oppaque", "opasso", "openasso", "obasso", "compec", "oppacity", "ipacity", "obatile", "compasso", "operatile", "ipaque", "openaques", "ipaques", "ipasso", "oppaques", "opec", "operaque", "opaques", "operasso", "openaque", "oppasso", "obec", "openacity", "operec"], "local_err": [" local_gr", "remote_error", "localayerror", "remote_fr", " local_error", "local_fr", "localayfr", " local_er", " local_rr", "local_error", "local_rr", "local_er", "local_dr", "local_gr", " local_dr", "remote_err", "localayerr"], "ret": ["arr", "pass", "base", "valid", "flag", "ext", "alt", "val", "len", "fail", "def", "_", "nt", "no", "Ret", "info", "t", "mem", "job", "ct", "reply", "block", "rl", "ref", "arg", "lit", "status", "reg", "gt", "rets", "f", "code", "rt", "res", "bf", "al", "det", "rc", "fun", "att", "en", "err", "part", "art", "sb", "lock", "re", "et", "RET", "url", "result", "rev", "mt", "ft", "resp", "sr", "fi", "success"], "cco": ["CCoco", "ccoin", "ccone", "cito", "ccaoco", "CCopy", "cct", "cfoin", "ecopy", "ccao", "ciode", "ccpo", "CCt", "cfo", "czoo", "czo", " ccoo", "ccO", "cfoo", "cfone", "ccoo", "ucco", " cct", "CCko", "ccako", "czpo", "cfpo", "ccode", "ecoo", "ecoin", "ccaone", "eco", "ccoco", "cfO", "CCoo", " ccko", " ccone", "CCpo", "ccalo", "ccaO", "cione", "CClo", "cio", "ccaoo", " cclo", "uccode", " ccode", "ccat", "uccto", " ccO", "ccopy", "CCone", "cclo", " ccto", "ecpo", "econe", "ccaoin", "CCo", "uccone", "ccapo", "ccko", "CCO", " ccoco", "ccto", "czopy"]}}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    target_ulong old, val, mask;\n\n    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;\n\n    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {\n\n        mask |= 1 << CP0EnHi_EHINV;\n\n    }\n\n\n\n    /* 1k pages not implemented */\n\n#if defined(TARGET_MIPS64)\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        int entryhi_r = extract64(arg1, 62, 2);\n\n        int config0_at = extract32(env->CP0_Config0, 13, 2);\n\n        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;\n\n        if ((entryhi_r == 2) ||\n\n            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {\n\n            /* skip EntryHi.R field if new value is reserved */\n\n            mask &= ~(0x3ull << 62);\n\n        }\n\n    }\n\n    mask &= env->SEGMask;\n\n#endif\n\n    old = env->CP0_EntryHi;\n\n    val = (arg1 & mask) | (old & ~mask);\n\n    env->CP0_EntryHi = val;\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_entryhi(env, env->current_tc);\n\n    }\n\n    /* If the ASID changes, flush qemu's TLB.  */\n\n    if ((old & env->CP0_EntryHi_ASID_mask) !=\n\n        (val & env->CP0_EntryHi_ASID_mask)) {\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n}\n", "idx": 11854, "substitutes": {"env": ["org", "net", "environment", "enable", "config", "cb", "target", "np", "txt", "global", "ec", "code", "eb", "v", "gear", "end", "cal", "err", "nc", "her", "lv", "stage", "que", "serv", "iss", "c", "vm", "e", "args", "gui", "ev", "db", "eval", "energy", "scope", "en", "enh", "eng", "emb", "chev", "extra", "site", "exec", "context", "pg", "ext", "fen", "equ", "conn", "viron", "export", "NV", "eni", "dat", "edge", "exc", "oa", "here", "enc", "esp", "ef", "et", "dev", "engine", "eu", "core", "vs", "chal", "conf", "ou", "inet", "qt", "dt", "ne", "server", "el", "obj", "erv", "next", "manager", "console", "qv", "cv", "ea", "event", "Environment", "dep"], "arg1": ["argument2", "mac0", "Arg2", "args2", " argone", "Argone", "argone", "argument0", "param2", " arg0", "argument1", "param1", "mac1", "Arg1", "args0", " arg2", "mac2", "param0", "macone", "argumentone", "Arg0", "valone", "val0", "args1", "val1", "val2", "arg2", "arg0"], "old": ["ld", "l", "diff", "recent", "arr", "original", "pass", "lf", "valid", "OLD", "alt", "and", "key", "def", "where", "low", "missing", "pred", "update", "post", "last", "var", "data", "prev", "arg", "obj", "add", "before", "high", "f", "la", "entry", "expected", "append", "eval", "nd", "ind", "current", "end", "item", "pre", "new", "list", "now", "after", "Old", "orig", "lock", "allow", "older", "replace", "gen", "lo"], "val": ["count", "vals", "Val", "cond", "arr", "base", "valid", "pass", "balance", "real", "len", "sel", "alt", "key", "mount", "x", "update", "mem", "data", "VAL", "slot", "el", "arg", "p", "local", "value", "prop", "ana", "ut", "unit", "vol", "bl", "eval", "py", "v", "index", "al", "ind", "sl", "item", "pre", "new", "bit", "pal", "lock", "change", "ret", "fe", "exec"], "mask": ["count", "parent", "map", "mac", "conf", "Mask", "diff", "filter", "fix", "valid", "delay", "flag", "scale", "ack", "ph", "key", "pad", "m", "ban", "pack", "x", "ver", "sum", "p", "max", "qa", "config", "work", "value", "bug", "f", "sk", "code", "label", "scan", "mark", "v", "flags", "ask", "miss", "patch", "check", "hash", "sign", "bit", "mean", "lock", "allow", "header", "result", "cache", "match", "weight", "fac", "depth"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n", "idx": 11861, "substitutes": {"dshmem": [" dshmemory", "dshimage", "dschmemory", "dchram", "dshaccess", " dschmemory", "dhimage", "dshiftmemory", "dchimage", "Dshmem", "Dhmem", " dschram", " dschaccess", "dschram", " dshaccess", "dshiftimage", "dschmem", "dhaccess", "dspram", "dschaccess", "dspmemory", "dshiftmem", "Dshram", "dspmem", "Dhmemory", "dshmemory", "dhram", "dspaccess", "dhmem", "Dshmemory", "dchmemory", "dshram", "Dhimage", "Dhram", " dschmem", "dchmem", "Dshimage", " dshram", "dhmemory", "dshiftram"]}}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n", "idx": 11865, "substitutes": {"ptr": ["Ptr", "tr", "test", "pad", "rw", "temp", "inter", "src", "point", "fd", "t", "tty", "rect", "buf", "pointer", "addr", "p", "ref", "pointers", "fp", "pt", "loc", "tmp", "inst", "code", "host", "slice", "ctr", "trace", "tip", "pr", "ctx", "address", "port", "pc", " pointer", "offset", "eth", "pair", "pos", "peer", "buff", "br", "proc", "buffer"], "ram_addr": ["ram2address", "rampdr", "rampaddress", "ramphost", "gram_address", "ram_dr", "ram2dr", "ram2host", "rampref", "ram_ref", "rampaddr", "gram_dr", "ram_address", "gram_host", "ram_host", "ram2addr", "gram_addr", "gram_ref"]}}
{"project": "FFmpeg", "commit_id": "03acb035d1292685cc24a2be0f62dd8332711734", "target": 1, "func": "static int decode_format80(VqaContext *s, int src_size,\n\n    unsigned char *dest, int dest_size, int check_size) {\n\n\n\n    int dest_index = 0;\n\n    int count, opcode, start;\n\n    int src_pos;\n\n    unsigned char color;\n\n    int i;\n\n\n\n    start = bytestream2_tell(&s->gb);\n\n    while (bytestream2_tell(&s->gb) - start < src_size) {\n\n        opcode = bytestream2_get_byte(&s->gb);\n\n        av_dlog(s->avctx, \"opcode %02X: \", opcode);\n\n\n\n        /* 0x80 means that frame is finished */\n\n        if (opcode == 0x80)\n\n            break;\n\n\n\n        if (dest_index >= dest_size) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (opcode == 0xFF) {\n\n\n\n            count   = bytestream2_get_le16(&s->gb);\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode == 0xFE) {\n\n\n\n            count = bytestream2_get_le16(&s->gb);\n\n            color = bytestream2_get_byte(&s->gb);\n\n            av_dlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color);\n\n            CHECK_COUNT();\n\n            memset(&dest[dest_index], color, count);\n\n            dest_index += count;\n\n\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n\n\n            count = (opcode & 0x3F) + 3;\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode > 0x80) {\n\n\n\n            count = opcode & 0x3F;\n\n            av_dlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n\n            CHECK_COUNT();\n\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n\n            dest_index += count;\n\n\n\n        } else {\n\n\n\n            count = ((opcode & 0x70) >> 4) + 3;\n\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n\n            av_dlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(dest_index - src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n\n            dest_index += count;\n\n        }\n\n    }\n\n\n\n    /* validate that the entire destination buffer was filled; this is\n\n     * important for decoding frame maps since each vector needs to have a\n\n     * codebook entry; it is not important for compressed codebooks because\n\n     * not every entry needs to be filled */\n\n    if (check_size)\n\n        if (dest_index < dest_size)\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n\n\n    return 0; // let's display what we decoded anyway\n\n}\n", "idx": 11877, "substitutes": {"s": ["l", "conf", "sports", "session", "sg", "ts", "ks", "sv", "is", "si", "g", "ds", "n", "its", "sf", "stats", "m", "src", "b", "t", "k", "gs", "service", "c", "iss", "p", "ls", "e", "se", "qs", "ins", "parts", "outs", "sq", "js", "xs", "f", "us", "rs", "cs", "aws", "sets", "S", "es", "sync", "sl", "services", "ans", "ns", "sb", "hs", "spec", "ms", "as", "sys", "h", "side", "ses", "su", "fs", "ps", "site", "ss", "bs", "settings", "ssl"], "src_size": ["src2address", "src_index", "src_capacity", " src_capacity", "source_len", "src2size", "src_scale", "src_len", "src2scale", "src_address", "source_size", " src_scale", "source_dim", "src_dim", "source_index", " src_address", "src2capacity"], "dest": ["cdn", "dim", "img", "source", "test", "temp", "info", "src", "path", "rest", "cont", "origin", "delete", "buf", "data", "sum", "config", "output", "Dest", "draw", "coord", "target", "attr", "txt", "dist", "status", "loc", "prop", "table", "tmp", "select", "dat", "append", "opt", "route", "uv", "home", "done", "neg", "sort", "desc", "trans", "dc", " destination", "transform", "options", "build", "result", "text", "match", "buff"], "dest_size": ["class2pos", "dest_type", "class_size", "source_pos", "source_offset", "class_loc", "class2size", "dest_address", "dest_index", "class2loc", "class2id", "dest2loc", "dest2pos", "source_size", " dest_length", " dest_address", "class_pos", "dest_pos", "class_id", " dest_type", "dest_length", "dest2id", "source_index", "dest_id", "dest_loc", "dest_offset", "dest2size"], "check_size": ["dest67size", "dest67length", "flush_index", "flush67pos", "dest67index", "destacsize", "flush_size", "destfpos", "dest_index", "destfindex", "dest67pos", "flush_pos", "destflength", "flush67index", "destacpos", "flush_length", "destaclength", "dest_pos", "dest_length", "flush67length", "destacindex", "destfsize", "flush67size"], "count": ["parent", "l", "base", "find", "sum", "max", "ref", "multiple", "cc", "code", "found", "call", "keep", "process", "content", "err", "offset", "type", "cycle", "text", "depth", "cond", "span", "n", "val", "key", "all", "id", "missing", "b", "total", "c", "limit", "close", "large", "f", "index", "ind", "current", "list", "error", "read", "cast", "col", "Count", "light", "len", "handle", "num", "add", "style", "coll", "label", "alpha", "size", "catch", "part", "cat", "comp", "use", "cache", "weight", "core", "time", "p", "number", "empty", "child", "name", "check", "cost", "length", "match", "force", "print"], "opcode": ["errorcodes", "Opstate", "Opcod", "OPcode", "copstate", "optc", "hopcode", "opname", "OPc", " opmode", " opcod", "ipopgrade", "OPcodes", "OPCode", "operCode", "popcod", "opscode", " optype", " opc", "popcode", "opercodes", "errorcod", "copcode", "errorCode", "copCode", "ipopcode", "popcodes", "opc", " opgrade", " opcodes", "operaque", "opscodes", "optcode", "operdesc", "opercode", "ipopcodes", "optdesc", "operc", "OpCode", "Opcode", "coptype", "opername", "opmode", " opstate", "ipopcod", "errorcode", "hopCode", " opCode", "optstate", " opaque", " opname", "hopcod", "lockcod", "opaque", "opsmode", "opgrade", "OPdesc", "opcodes", "opstate", "opcod", "lockCode", "lockstate", "optype", "OPname", "optCode", "opCode", "opdesc", "lockcode", "opermode", "popgrade", "opttype", "optcodes", "optaque", "hopcodes", "opsCode"], "start": ["sp", "it", "scale", "len", "source", "in", "key", "started", "pad", "id", "stage", "like", "send", "shift", "ad", "from", "sum", "max", "p", "add", "ish", "skip", "set", "starting", "stop", "step", "st", "ie", "Start", "mid", "index", "size", "try", "min", "space", "ind", "end", "sort", "part", "art", "offset", "get", "init", "type", "pos", "length", "use", "range"], "src_pos": ["srcPposition", "src_po", "src___sol", "rc_po", " src_cos", "rc_point", "target_pos", "sort_flo", "sort_limit", "src_sol", "srcPpoint", "srcampoint", "src67pos", "srcspo", "target_point", "http_pos", "distPposition", "dist_size", "srcamloc", "src_offset", "src67vis", "targetampos", "src67offset", "src1vis", "src___position", "targetamloc", "src00pos", "src00offset", "src1offset", "src_count", "src_flo", "src0position", "srcpposition", "srcpsol", " src_position", "src24flo", "http_offset", "sub_loc", "src67index", "src24pos", "srcPsize", "src67po", "src0po", "srcsindex", "srcspos", "sort00flo", "http_vis", "src_point", "src67loc", "sort_offset", "rc_position", "srcploc", "distPsize", "src_loc", "srcPpos", "src_limit", "sort00limit", "src24offset", "rc_pos", "srcPpo", "src0cos", " src_index", "sort00offset", "http_count", "srcPsol", "sub_position", "dist_pos", "distPsol", "src1count", "src_position", "srcpsize", "src_cos", "srcpcount", "src___size", " src_po", "src_index", "distPpos", "sub_pos", " src_loc", "srcampos", "sort00pos", "srcppos", "dist_sol", "sub_count", "src_vis", "src1pos", "src00flo", "srcsloc", "sort_pos", "src___pos", "target_loc", "src67count", "targetampoint", "dist_position", "src24limit", "src00limit", "src0pos"], "color": ["background", "chrom", "channel", " rgb", " border", "blue", " background", "source", " cursor", "id", "src", " coord", " colors", "c", "sum", " red", " Color", "COLOR", "gb", "status", "or", "attr", "style", "coll", "colored", "alpha", "resource", " col", "bg", "colour", "format", "rc", "name", " colour", "raw", " channel", "Color", "gray", "cor", "col", " rc", "black", "type", "cat", "pal", "cycle", "white", "border", "url", " source", "ch", "light"], "i": ["l", "base", "t", "x", "z", "uri", "ie", "code", "v", "phi", "ii", "offset", "type", "ori", "fi", "buffer", "oi", "n", "si", "key", "all", "_", "id", "xi", "b", "c", "e", "f", "j", "index", "slice", "ind", "bi", "bytes", "col", "u", "li", "ni", "hi", "di", "len", "g", "d", "mini", "eni", "ai", "gi", "chi", "pi", "you", "I", "iu", "ui", "byte", "it", "info", "ini", "ji", "p", "ix", "multi", "name", "mi", "ti", "qi", "pos", "ip", "ci", "api", "io", "y"]}}
{"project": "FFmpeg", "commit_id": "d3b25383daffac154846daeb4e4fb46569e728db", "target": 1, "func": "static int zero12v_decode_frame(AVCodecContext *avctx, void *data,\n\n                                int *got_frame, AVPacket *avpkt)\n\n{\n\n    int line = 0, ret;\n\n    const int width = avctx->width;\n\n    AVFrame *pic = data;\n\n    uint16_t *y, *u, *v;\n\n    const uint8_t *line_end, *src = avpkt->data;\n\n    int stride = avctx->width * 8 / 3;\n\n\n\n    if (width == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Width 1 not supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')\n\n        && avpkt->size % avctx->height == 0\n\n        && avpkt->size / avctx->height * 3 >= width * 8)\n\n        stride = avpkt->size / avctx->height;\n\n\n\n    if (avpkt->size < avctx->height * stride) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small: %d instead of %d\\n\",\n\n               avpkt->size, avctx->height * stride);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    pic->key_frame = 1;\n\n\n\n    y = (uint16_t *)pic->data[0];\n\n    u = (uint16_t *)pic->data[1];\n\n    v = (uint16_t *)pic->data[2];\n\n    line_end = avpkt->data + stride;\n\n\n\n    while (line++ < avctx->height) {\n\n        while (1) {\n\n            uint32_t t = AV_RL32(src);\n\n            src += 4;\n\n            *u++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *v++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *u++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 2) {\n\n                if (!(width & 1)) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *v++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *u++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *v++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 2) {\n\n                if (width & 1) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 11885, "substitutes": {"avctx": ["afconn", "avcmp", "avalcontext", "avalctx", "afcup", "avcs", "abcontext", "AVcontext", "aveconfig", "avconn", "ajkb", "AVconn", " avcontext", "avcontext", " avconn", "avalcup", "afcn", " avloc", "avctl", "afcontext", "afkb", "ajlc", "avecs", "navctl", "ajloc", "avecca", "ajcmp", "avectx", "avcdn", "navconn", "afcu", "aflc", "avcmd", "ajctx", "afxc", "ajcontext", "avalconn", "averx", "afloc", "aveloc", "avecn", "avalrx", "avcn", "apcu", "avcca", "avloc", " avxc", "afctx", "avelc", "afcot", "ajconfig", " avkb", "avcf", "avexc", "avecot", "avalcmd", "avcu", "abctx", "avalcmp", "ajctl", "afconfig", "AVctx", "avxc", "abcu", "apcmd", "avrx", "navcontext", "avkb", "aveconn", "AVcu", "avecontext", "ajcot", "avecdn", "afcs", "afcca", "ajcs", "ajxc", "navctx", "afcdn", "avecmp", "afcmp", "navcca", "afctl", "afcmd", "afrx", "avecu", "avcot", "navxc", "avcup", "ajcn", "afcf", "avalcdn", "avlc", "apctx", "avconfig", "abcup", "navcf", "avecf", "avalcu", "navloc", "apcontext"], "data": ["parent", "channel", "base", "img", "media", "record", "pad", "shift", "ad", "config", "memory", "frame", "body", "code", "device", "content", "align", "end", "first", "offset", "image", "depth", "buffer", "picture", "devices", "delay", "val", "date", "da", "id", "open", "i", "capt", "addr", "draw", "layout", "args", "DATA", "padding", "slice", "index", "module", "input", "Data", "bytes", "read", "header", "gap", "sample", "source", "d", "buf", "head", "action", "style", "dat", "alpha", "size", "cache", "result", "ui", "scale", "start", "window", "actions", "batch", "reader", "ata", "final", "off", "empty", "next", "height", "name", "inner", "results", "api", "video", "bin"], "got_frame": ["got__frame", "gotoutrange", "got_file", "got__file", " got_range", " got_length", "gotoutframe", "gotoutlength", "gotoutfile", "got__range", "got_range", "got_length", "got__length", " got_file"], "avpkt": ["afpacket", "avcunt", "avspett", "ovpkt", "avcpcht", "avspacket", "affacket", "avbpett", "avpageinch", "avspke", "ovpinch", "avpracket", "awbpck", "avPkt", "AVpacket", "ovlpsth", "avepsth", "avpnt", "avcpkt", "avpagekt", "avlpsth", "avpct", "avnkt", "avcpct", "AVcpcht", "avpeth", "afpkt", "avensth", "avlpinch", "awpcht", "affkt", " avprnt", " avprke", "avspcht", "avcacket", "awbpkt", "avepacket", "avspck", "avnacket", "avepck", "avprunt", "ovlpkt", "avcpacket", "avnsth", "avpcck", "avfkt", "avpilot", "avspnt", "avnpcht", "avepeth", "avncht", "ullprkt", "avspkt", "avenpkt", "ovlpnt", "AVcpkt", " avpnt", "awpett", "AVcpct", "ullpilot", "avprkt", " avprkt", "avpack", "avepft", "awpkt", "avnpacket", "afpcht", " avprutt", "awpck", "avepkt", "avprilot", "ovlpinch", "ullpkt", "avprutt", "avpceth", "avennt", "avfsth", "avpckt", "avnpett", "avsputt", "avnpft", "AVcpacket", "avnpkt", "avenkt", "avfacket", "avpagent", "avlutt", " avpke", "avPct", "avenpck", "avpft", "ovpnt", "avepnt", "avcpck", "avenpft", "awbpcht", "avpke", "avfck", "avfnt", "avpakt", "avpagesth", "ovpsth", "avPcht", "affck", "afpck", "avenpeth", "avnct", "avpcft", "AVpct", "avpaunt", "ullpunt", "AVpkt", "avcilot", "avpunt", "avnnt", "avninch", "avpinch", "ullpracket", "avprnt", "avnpck", "avckt", "avpett", "avpsth", "avbpck", "avprke", "avpacket", "avnpeth", "avbpcht", "avpaacket", "ullprilot", "AVpcht", "avnpnt", "avlkt", "avlpnt", " avputt", "avlnt", "avnpsth", "avlpkt", "avpacht", "avlke", "ullpacket", "awbpett", "avcpft", "avputt", "avpailot", "avPacket", "avpck", "ullprunt", "avenacket", "avbpkt", "avcpeth", "avpcht", "affcht", "avfcht"], "ret": ["arr", "flag", "str", "len", "val", "alt", "fail", "tr", "def", "ext", "nt", "no", "Ret", "t", "num", "job", "red", "reply", "ref", "arg", "lit", "status", "rets", "code", "rt", "res", "bf", "det", "r", "fun", "cur", "bot", "ben", "success", "rep", "error", "fin", "re", "RET", "back", "result", "ft", "match", "buffer", "pin"], "pic": ["mac", "dot", "pse", "seq", "oc", "img", "cci", "proc", "xi", "quad", "chat", "piece", "sci", "fi", "capt", "doc", "c", "config", "p", "tick", "pixel", "mini", "pins", "sec", "bc", "ac", "pick", "ctrl", "pie", "py", "fake", "parse", "ig", "module", "sync", "syn", "cache", "ic", "fat", "feature", "photo", "jp", "bi", "study", "pc", "Pic", "bus", "git", "pi", "spec", "plugin", "cat", "sys", "fn", "file", "cycle", "sit", "image", "bin", "lc", "pict", "vec", "vc", "feat", "cus", "picture", "typ", "pin", "fc"], "y": ["l", "ym", "ady", "hi", "yt", "oy", "start", "n", "ny", "w", "id", "m", "t", "x", "ey", "vy", "z", "b", "ye", "i", "d", "k", "c", "s", "cy", "p", "ys", "e", "yi", "iy", "f", "sy", "yy", "j", "height", "o", "py", "sky", "ky", "yd", "Y", "ty", "col", "yu", "type", "h", "year", "ip", "ya", "yn", "ch", "dy", "yo"], "u": ["l", "un", "ou", "ui", "uu", "up", "n", "ul", "w", "m", "uid", "b", "x", "t", "z", "k", "d", "i", "tu", "c", "p", "cu", "lu", "du", "q", "f", "o", "uv", "r", "pu", "ur", "uni", "h", "U", "nu", "a", "su", "iu"], "v": ["vs", "l", "vi", "sv", "n", "g", "val", "w", "m", "b", "x", "k", "z", "ve", "t", "vy", "i", "vt", "ver", "c", "d", "s", "p", "e", "value", "q", "f", "j", "o", "uv", "end", "r", "V", "h", "vv", "vp"], "line_end": [" line_start", " line_name", "line_size", "lineGend", "line_id", "lineacstart", " line_length", "lineaclength", "line_length", "lineGname", "line_limit", "line_End", "lineglength", "lin_limit", "line_name", " line_size", "lineamlimit", "line_shape", "lineamend", "line_start", "lineacend", "linegsize", "lineacsize", "lin_shape", "linegstart", "lineamshape", " line_id", "lineGEnd", " line_End", "lin_end", "linegend"], "src": ["channel", "img", "start", "source", "ul", "origin", "path", "sur", "filename", "iv", "rect", "d", "i", "gs", "stat", "c", "head", "s", "config", "uri", "stream", "lit", "dest", "cb", "gb", "split", "txt", "dist", "rb", "loc", "lat", "st", "sec", "inst", "slice", "rl", "rc", "uv", "ind", "sl", "sup", "cur", "sil", "sn", "desc", "sb", "spec", "front", "hl", "file", "url", "image", "vc", "sit", "sid", "sr", "ch", "feat", "text", "depth", "dy", "sc", "uc", "fc"], "line": ["l", " lin", "level", "byte", "base", "lf", "le", "start", "n", "len", "source", "page", "d", "Line", "ne", "block", "lo", "limit", "liner", "pe", "lines", "frame", "loc", "code", "unit", "slice", "edge", "name", "sl", "LINE", "user", "link", "nl", "side", "li", "pos", "row", "url", "ine", "cell", "lc", "force", "day", "dy", "lin", "range"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n", "idx": 11911, "substitutes": {"field": ["round", "map", "filter", "holder", "flag", "window", "key", "class", "record", "pad", "fields", "card", "FIELD", "fred", "data", "block", "rule", "style", "group", "f", "entry", "slice", "index", "input", "event", "end", "Field", "object", "address", "inner", "patch", "type", "form", "layer", "message", "result", "match", "seed", "buffer"], "bit": ["hit", "byte", "BIT", "fix", "it", "flag", "key", "word", "no", "quad", "tag", "b", "num", "i", "apt", "big", "ct", "slot", "letter", "band", "arg", "Bit", "value", "fact", "bug", "number", "act", "bits", "op", "ac", "f", "unit", "index", "digit", "opt", "feature", "bot", "option", "token", "patch", "part", "offset", "col", "type", "cat", "ip", "bin", "text", "feat"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 11919, "substitutes": {"str": ["cr", "sp", "tr", "is", "strings", "Str", "txt", "strip", "stri", "er", "st", "code", "ctr", "cur", "spec", "orig", "url", "text", "expr", "ocr", "arr", "id", "fr", "gr", "c", "s", "e", "iter", "f", "zero", "input", "r", "u", "lc", "sc", "exec", "seq", "ext", "hr", "unc", "kr", "data", "STR", "wr", "dr", "cs", "sl", "enc", "vec", "br", "sr", "start", "rr", "doc", "prev", "obj", "rs", "empty", "inst", "name", "pr", "inner", "frac"], "endptr": ["adaddr", " endrot", "endedptr", "endedpointer", "endPtr", "endaddr", "endingpointer", " endpointer", "idproc", "adPtr", "endpt", " endPtr", "startctr", "estpointers", "endedaddr", "adpt", "endingrot", "endprot", "idpt", "endpointer", "entprot", "addptr", "idpointer", "addprot", "endproc", "endedpt", "addwr", "adrot", " endproc", " endpointers", "adpointers", "estptr", "adprot", "startptr", "adproc", "idptr", "endwr", "startprot", "beginprot", "entptr", "addpointer", "beginpointer", "endpointers", "endrot", "entpointer", "startpointer", "entwr", "endedprot", "endctr", "startproc", "estPtr", "endingptr", "adptr", "endedctr", "estpointer", "endingproc", "beginaddr", " endctr", "adpointer", "beginptr", "startwr", "endedproc"], "err": ["later", "cr", "acer", "fg", "ler", "arr", "arm", "g", "rage", "all", "fr", "mr", "rr", "erer", "kr", "gr", "ver", "work", "Error", "attr", "iter", "wr", "act", "ir", "aster", "bug", "er", "f", "lr", "dr", "code", "res", "finder", "order", "magic", "ner", "ar", "r", "ise", "req", "pr", " r", "ger", "error", "rar", " error", "fer", "der", "orer", " Err", "eor", "result", "Er", "br", "resp", "rh", "fi", "ln", "runner"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n", "idx": 11933, "substitutes": {"klass": ["skcl", "sklass", "kazz", "oklf", "skclass", "kclass", "cklass", "cklf", "cklasses", "ckclass", " kazz", "okazz", "okclass", "Klass", "skazz", " klf", "sklasses", "sklf", " kcl", "Klasses", "Kclass", "klasses", "klf", " kclass", "kcl", "Kcl", " klasses", "oklass"], "data": ["parent", "di", "context", "ds", "da", "def", "m", "info", "d", "ad", "c", "config", "ata", "DATA", "dat", "device", "module", "input", "raw", "ctx", "dd", "load", "new", "Data", "params", "cache", "result"], "dc": ["cdn", "dk", "di", "DC", "ds", "enter", "da", "conn", "tc", "dt", "d", "doc", "c", "ct", "config", "cd", "cf", "ec", "df", "cc", "ac", "f", "dr", "cs", "device", "db", "dat", "design", "ck", "rc", "ga", "dd", "tk", "desc", "disc", "u", "nc", "vc", "lc", "mc", "acc", "sc"], "k": ["dk", "kind", "ku", "ijk", "ks", "n", "g", "key", "w", "t", "d", "i", "c", "wk", "s", "work", "p", "ad", "e", "ok", "q", "ak", "f", "sk", "ac", "o", "kid", "ck", "v", "kick", "sync", "ik", "kin", "kt", "kn", "K", "tk", "uk", "kw", "ke", "spec", "u", "self", "mk", "ki", "kk", "ko"]}}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n", "idx": 11936, "substitutes": {"wsource": [" wource", "wource", "wresource", "kwconfig", "fwspec", "Wsrc", "wsrc", "wwsource", "rwservice", "Wspec", " wservice", "rwsource", "wwource", "Wconfig", "gsource", "wasrc", "gservice", "wwsrc", "fwservice", "gource", "Wresource", "wwresource", "waource", "kwchannel", " wchannel", " wconfig", "wservice", "fwchannel", "swchannel", " wsrc", "wasource", "kwsrc", "swource", "kwsource", "swsource", "rwchannel", "wchannel", "wspec", "kwource", "rwspec", "waresource", "Wource", "Wservice", "fwsource", "gsrc", "wconfig", "Wchannel", "Wsource", "swsrc"]}}
{"project": "qemu", "commit_id": "e40c3d2e7f4b58669a1b4e5dfb684e57c0bf62ce", "target": 0, "func": "static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,\n\n                              uint32_t irq, bool use_highmem)\n\n{\n\n    Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf;\n\n    int i, bus_no;\n\n    hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base;\n\n    hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size;\n\n    hwaddr base_pio = memmap[VIRT_PCIE_PIO].base;\n\n    hwaddr size_pio = memmap[VIRT_PCIE_PIO].size;\n\n    hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base;\n\n    hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size;\n\n    int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;\n\n\n\n    Aml *dev = aml_device(\"%s\", \"PCI0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A08\")));\n\n    aml_append(dev, aml_name_decl(\"_CID\", aml_string(\"PNP0A03\")));\n\n    aml_append(dev, aml_name_decl(\"_SEG\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_BBN\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"PCI0\")));\n\n    aml_append(dev, aml_name_decl(\"_STR\", aml_unicode(\"PCIe 0 Device\")));\n\n    aml_append(dev, aml_name_decl(\"_CCA\", aml_int(1)));\n\n\n\n    /* Declare the PCI Routing Table. */\n\n    Aml *rt_pkg = aml_package(nr_pcie_buses * PCI_NUM_PINS);\n\n    for (bus_no = 0; bus_no < nr_pcie_buses; bus_no++) {\n\n        for (i = 0; i < PCI_NUM_PINS; i++) {\n\n            int gsi = (i + bus_no) % PCI_NUM_PINS;\n\n            Aml *pkg = aml_package(4);\n\n            aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF));\n\n            aml_append(pkg, aml_int(i));\n\n            aml_append(pkg, aml_name(\"GSI%d\", gsi));\n\n            aml_append(pkg, aml_int(0));\n\n            aml_append(rt_pkg, pkg);\n\n        }\n\n    }\n\n    aml_append(dev, aml_name_decl(\"_PRT\", rt_pkg));\n\n\n\n    /* Create GSI link device */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irqs =  irq + i;\n\n        Aml *dev_gsi = aml_device(\"GSI%d\", i);\n\n        aml_append(dev_gsi, aml_name_decl(\"_HID\", aml_string(\"PNP0C0F\")));\n\n        aml_append(dev_gsi, aml_name_decl(\"_UID\", aml_int(0)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_PRS\", crs));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_CRS\", crs));\n\n        method = aml_method(\"_SRS\", 1, AML_NOTSERIALIZED);\n\n        aml_append(dev_gsi, method);\n\n        aml_append(dev, dev_gsi);\n\n    }\n\n\n\n    method = aml_method(\"_CBA\", 0, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_return(aml_int(base_ecam)));\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_CRS\", 0, AML_NOTSERIALIZED);\n\n    Aml *rbuf = aml_resource_template();\n\n    aml_append(rbuf,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0000, nr_pcie_buses - 1, 0x0000,\n\n                            nr_pcie_buses));\n\n    aml_append(rbuf,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio,\n\n                         base_mmio + size_mmio - 1, 0x0000, size_mmio));\n\n    aml_append(rbuf,\n\n        aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                     AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio,\n\n                     size_pio));\n\n\n\n    if (use_highmem) {\n\n        hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base;\n\n        hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size;\n\n\n\n        aml_append(rbuf,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000,\n\n                             base_mmio_high, base_mmio_high, 0x0000,\n\n                             size_mmio_high));\n\n    }\n\n\n\n    aml_append(method, aml_name_decl(\"RBUF\", rbuf));\n\n    aml_append(method, aml_return(rbuf));\n\n    aml_append(dev, method);\n\n\n\n    /* Declare an _OSC (OS Control Handoff) method */\n\n    aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n    method = aml_method(\"_OSC\", 4, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_create_dword_field(aml_arg(3), aml_int(0), \"CDW1\"));\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.5.1. _OSC Interface for PCI Host Bridge Devices\n\n     * The _OSC interface for a PCI/PCI-X/PCI Express hierarchy is\n\n     * identified by the Universal Unique IDentifier (UUID)\n\n     * 33DB4D5B-1FF7-401C-9657-7441C03DD766\n\n     */\n\n    UUID = aml_touuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW2\"), aml_name(\"SUPP\")));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW3\"), aml_name(\"CTRL\")));\n\n    aml_append(ifctx, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\n\n                                aml_name(\"CTRL\")));\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    aml_append(ifctx, aml_store(aml_name(\"CTRL\"), aml_name(\"CDW3\")));\n\n    aml_append(ifctx, aml_return(aml_arg(3)));\n\n    aml_append(method, ifctx);\n\n\n\n    elsectx = aml_else();\n\n    aml_append(elsectx, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\n\n                                  aml_name(\"CDW1\")));\n\n    aml_append(elsectx, aml_return(aml_arg(3)));\n\n    aml_append(method, elsectx);\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_DSM\", 4, AML_NOTSERIALIZED);\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.6.1. _DSM for PCI Express Slot Information\n\n     * The UUID in _DSM in this context is\n\n     * {E5C937D0-3553-4D7A-9117-EA4D19C3434D}\n\n     */\n\n    UUID = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\n\n    uint8_t byte_list[1] = {1};\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(ifctx1, aml_return(buf));\n\n    aml_append(ifctx, ifctx1);\n\n    aml_append(method, ifctx);\n\n\n\n    byte_list[0] = 0;\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(method, aml_return(buf));\n\n    aml_append(dev, method);\n\n\n\n    Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\n\n    aml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, dev_rp0);\n\n    aml_append(scope, dev);\n\n}\n", "idx": 11957, "substitutes": {"scope": ["mac", "context", "window", "instance", "var", "config", "app", "attr", "global", "args", "bc", "mode", "resource", "alloc", "module", "req", "mod", "node", "ms", "sys", "engine", "ram", "func", "proc", "core", "buffer", "sc"], "memmap": ["memorypad", "Memcache", " mempad", "hwper", " memcap", "memmem", "memoryap", "memorymem", "Memap", "limcap", "limcache", "memorydata", "memcache", "limmem", " memblock", "ramdata", "hwcap", "accessmap", "memper", "mmcap", "hwmap", "memorymap", "hwpad", "mmmaps", "memorycache", " memcache", "memorycap", " memper", "Memblock", "ramcache", "Memmap", "memap", "memoryper", "memblock", "memdata", "mempad", "accessmaps", "limmap", " memmem", "accesscap", "rammap", " memmaps", "mmap", " memdata", " memap", "memoryblock", "ramcap", "mmmap", "memcap", "accessap", "memmaps"], "irq": ["irtce", "rique", "ierce", "rice", "riq", "ierch", "irch", "irtque", "irtq", "ierq", "rich", "irce", "irque", "ierque", "irtch"], "use_highmem": ["use_highmemory", "use_maxmemory", "use_highram", "useflowmemory", "usefhighram", "use_highmm", "use_lowmem", "use_fullram", "use_maxmem", "use_lowmm", "use_lowram", "use_fullmem", "usefhighmm", "useflowram", "use_lowmemory", "use_maxram", "useflowmm", "usefhighmemory", "useflowmem", "use_fullmemory", "use_fullmm", "use_maxmm", "usefhighmem"], "method": ["session", "class", "path", "instance", "each", "mem", "app", "package", "attr", "coll", "array", "op", "mode", "call", "module", "function", "mod", "roll", "METHOD", "ip", "math", "func", "engine", "ram", "cmd", "ssl"], "crs": ["cRS", "CRS", "xcros", "acss", "acRS", "Crs", "Cros", "acros", "Css", "acrs", "xcRS", "css", "cros", "xcss", "xcrs"], "ifctx": [" ifcontext", "ifconfig", "IFconfig", " ifcb", "fcb", " ifconfig", "fctx", "IFcb", "fcontext", "fconfig", "ifcontext", "IFctx", "ifcb", "IFcontext"], "UUID": ["GInt", "Uuid", "CInt", "uID", "uuid", "CUID", "uUID", "GID", "GUID", "UInt", "Guid", "UID", "Cuid", "CID", "uInt"], "ifctx1": ["Ifcontext1", "Ifcontext2", "ifctx2", "iflc2", "ifconfig2", "ifconfig1", "Ifctx0", "Ifcontext0", "iflc0", "ifcontext1", "ifconfig0", "Ifctx1", "iflc1", "Ifctx2", "ifcontext0", "ifctx0", "ifcontext2"], "elsectx": ["elifx", "neloadc", "neload8", "elifc", "elify", "elglc", "elapsedc", "neloady", "elglx", "elapsedx", "elgly", "neloadx", "elgl8", "nelify", "eloady", "eloadx", "eloadc", "eload8", "nelifc", "elapsed8", "elapsedy", "elif8", "nelif8", "nelifx"], "buf": ["uf", "seq", "Buffer", "img", "src", "mem", "pool", "block", "batch", "ref", "cb", "queue", "bc", "alloc", "msg", "cap", "rc", "callback", "port", "blocks", "func", "cache", "buff", "cmd", "br", "bin", "buffer", "box"], "i": ["l", "ui", "di", "it", "start", "n", "si", "in", "id", "xi", "m", "b", "k", "t", "num", "d", "c", "ji", "p", "uri", "ix", "e", "cli", "f", "j", "o", "multi", "index", "v", "jit", "name", "ti", "phi", "gi", "ind", "qi", "jp", "bi", "part", "ii", "u", "I", "li", "ip", "ci", "a", "ni", "io", "lc", "iu"], "bus_no": ["BUS_no", " bus_num", "busayeno", "plugin_mode", "bus_num", "bisaystep", "busingeno", "busingNo", "bus64no", "bus_eno", "busingkey", "pluginingmode", "busaykey", "plugin_nb", "bisayeno", "bis_step", "busaystep", "pluginingno", " bus_No", "busianla", "bus_bo", "bus_pos", "busingno", "pluginingpos", "busingmode", "busingnb", "bus_step", "bus_mode", "bus_nb", "busianno", "bis_no", "bus64pos", "plugin_pos", "busianbo", "busingstep", "bisaykey", "bus_No", "bus64nb", "busingnum", "bis_eno", "bus_la", "bus64mode", "bisayno", "BUS_bo", "BUS_la", "pluginingnb", "bis_key", "busayno", "bus_key", "plugin_no", "busingpos"], "dev": ["diff", "conf", "des", "gu", "develop", "boot", "debug", "comment", "prof", "fail", "def", "Dev", "info", "die", "model", "prom", "pack", "conn", "pad", "development", "dem", "project", "adv", "ver", "d", "fw", "var", "data", "block", "app", "package", "driver", "attr", "private", "dist", "bug", "priv", "serial", "push", "off", "ev", "device", "vol", "pub", "lib", "test", "module", "home", "cur", "req", "mod", "err", "stick", "error", "node", "grad", "self", "pos", "od", "engine", "DEV"], "rt_pkg": ["rt2pack", "nt_pack", "nt_kg", "rt2packages", "rt2pkg", "nt_packages", "rt_packages", "rt_pack", "rt2kg", "rt_kg", "nt_pkg"]}}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11958, "substitutes": {"bs": ["vs", "ts", "bb", "ubis", "ds", "its", "lbs", "ba", "bas", "b", "ab", "gs", "iss", "sa", "fb", "ls", "pb", "ros", "ins", "bits", "outs", "rs", "js", "BS", "bc", "os", "us", "plugins", "obs", "cs", "banks", "aws", "bl", "es", "ubs", "bh", "state", "las", "lb", "abi", "bis", "als", "bi", "ns", "sb", "blocks", "bytes", "cms", "ses", "fs", "ps", "ob", "css", "ss", "bing", "bes", "bos"], "p_name": [" pfsize", "powlabel", "P_size", " p_Name", "P_Name", "p__label", "p8error", "P_name", " powsession", "pfsize", "p_block", "p_num", "prev_name", "p2name", " p_num", "p_size", "powname", "powtime", "p__name", "end_error", "end_Name", "pflabel", "lp_on", "p_on", "prev_path", "prev_no", "p_key", " powname", " p_key", "lp_name", "p2size", "p_NAME", "p__size", "end_NAME", "p_label", "p_start", "p_Name", "p_time", " p_size", "pfname", "p2path", "powstart", "powsize", " pfname", "P_block", "pameNAME", " pflabel", "p2no", "powsession", " p_start", "p8Name", "p_error", "p_session", "pameName", "p8name", " pftime", "lp_key", " p_session", "p_alias", "lp_alias", "prev_size", "powName", " powName", " p_time", " p_label", "p_no", "p8NAME", "pftime", "p_path", " powstart", "pamename", "pameerror", "p__time"], "desc": ["asc", "des", "seq", "ext", "section", "comment", "test", "def", " description", "word", "info", "src", "decl", "path", "cont", "rec", "buf", "toc", "doc", "DES", "sum", "config", "dest", "feed", "dist", "loc", "cod", "sec", "code", "dir", "Description", "sub", "description", "rc", "name", "content", "Desc", "sort", "dc", "summary", "enc", " describe", "esc", "comments", "su", "text", "lc", "sc"], "s": ["session", "ts", "is", "ds", "si", "n", "stats", "b", "gs", "sa", "c", "service", "p", "ls", "qs", "ins", "js", "us", "os", "cs", "aws", "sets", "S", "es", "sync", "sie", "states", "sl", "services", "ns", "sys", "ses", "ps", "css", "ss", "settings", "ssl"], "end_name": ["end__size", "end__name", "end_named", "end_Name", "end_large", "end_time", "p_ame", "set_phase", "endfullnamed", "endayname", "ending_name", "end_call", " end_size", "endfullname", "end__time", "end_size", "set_Name", "p_named", "end_phase", "ending_call", "ending_value", "set_name", "set_large", "endaynamed", "endayame", "end_value", "end_ame", " end_time", "endfullame"]}}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static MemoryRegionSection address_space_do_translate(AddressSpace *as,\n\n                                                      hwaddr addr,\n\n                                                      hwaddr *xlat,\n\n                                                      hwaddr *plen,\n\n                                                      bool is_write,\n\n                                                      bool is_mmio)\n\n{\n\n    IOMMUTLBEntry iotlb;\n\n    MemoryRegionSection *section;\n\n    MemoryRegion *mr;\n\n\n\n    for (;;) {\n\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n\n        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);\n\n        mr = section->mr;\n\n\n\n        if (!mr->iommu_ops) {\n\n            break;\n\n        }\n\n\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n\n                | (addr & iotlb.addr_mask));\n\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n\n            goto translate_fail;\n\n        }\n\n\n\n        as = iotlb.target_as;\n\n    }\n\n\n\n    *xlat = addr;\n\n\n\n    return *section;\n\n\n\ntranslate_fail:\n\n    return (MemoryRegionSection) { .mr = &io_mem_unassigned };\n\n}\n", "idx": 11969, "substitutes": {"as": ["As", "alias", "is", "ach", "ais", "sa", "ad", "var", "s", "asu", "ace", "ase", "attr", "se", "at", "or", "amd", "ay", "ass", "er", "os", "ac", "an", "ai", "cs", "res", "aws", "acs", "ras", "ars", "rc", "asi", "ar", "r", "las", "am", "address", "tx", "ask", "asm", "aw", "ms", "ast", "sys", "asa", "a", "pas", "ares", "AS"], "addr": ["Address", "base", "ack", "xp", "enter", "pad", "anne", "x", "ad", "config", "ace", "attr", "afi", "at", "amd", "loc", "ac", "amp", "align", "nr", "hop", "offset", "asm", "orig", "grad", "rx", "url", "alias", "mac", "arr", "ord", "prefix", "id", "pe", "ar", "r", "md", "acl", "art", "layer", "inter", "len", "alt", "owner", "src", "data", "coord", "ptr", "mode", "dr", "host", "rt", "alpha", "size", "oa", "tta", "rc", "proxy", "tx", "part", "enc", "ast", "vr", "a", "adder", "adr", "area", "inet", "rd", "p", "au", "rs", "la", "route", "ea", "name", "address", "az", "dd", "ip", "wd"], "xlat": ["xpcat", "Xlon", "xploc", "xpLat", "mxlon", "Xaddr", " xlon", "mxlat", " xaddr", "xLat", "XLat", "xcat", "xaddr", "Xlat", "Xloc", "mxaddr", " xloc", "Xcat", "xloc", " xLat", " xcat", "xplat", "xlon"], "plen": [" plan", " pleng", "plon", " pllen", "Plan", "illeng", "colen", "coleng", "plEN", "ipln", "slen", "iplEN", " plEN", "sllen", "Pllen", " pln", " plign", "illign", "pln", "plening", "pleng", "slon", " plening", "illen", "Pln", "colening", "Plign", "ipllen", " plon", "Plen", "Plon", "pllen", "plan", "Plening", "illlen", "collen", "PlEN", "plign", "Pleng", "iplen", "slan"], "is_write": ["ispubread", "is__writing", " is_written", "is_flow", " is_writing", "ispubwrite", " is_network", "isacexternal", " is_binary", "is_binary", "is_network", "is__network", "ispubflow", "ispubbinary", "isfuncwritten", " is_read", "is_read", "isfuncwrite", "is__read", "isfuncexternal", " is_flow", "is_external", "is_writing", "is__write", "is_written", "isacwrite", " is_external", "isacwritten"], "is_mmio": ["is_mpui", "is_memios", "is_mpio", "is_mpro", "is_vmnet", "is_sysui", "is_mmui", "is_memlo", "is_mpios", "is_mmios", "is_sysio", "is_sysro", "is_vmio", "is_mplo", "is_mmro", "is_mmnet", "is_syslo", "is_mmlo", "is_memio", "is_mpnet", "is_mxio", "is_mxlo", "is_vmlo", "is_mxro", "is_mxui", "is_vmios", "is_memnet"], "iotlb": ["iolb", "ietlp", "otbl", "iotla", "iottlr", "kylb", "kyb", "iotbl", "ietlr", "otlr", "iotlp", "ioll", "iotl", "iottl", "kylc", "ottl", "ietlc", "iotlr", "ietb", "otla", "iottlp", "ietbl", "otlb", "otlc", "ietsb", "ottla", "ietl", "otb", "otub", "ietub", "ottlb", "iotb", "iolbl", "iotub", "iottbl", "iollc", "iottlb", "iottlc", "iollr", "iotlc", "ottsb", "ottub", "otsb", "otl", "iotsb", "iottb", "kybl", "ietla", "ottb", "iollp", "iollb", "ietlb"], "section": ["area", "session", "member", "ru", "element", "vision", "region", "tag", "instance", "container", "sa", "service", "config", "server", "component", "ace", "se", "sector", "rb", "loc", "sq", "cover", "sec", "array", "bc", "group", "entry", "db", "sub", "sections", "module", "route", "description", "rc", "connection", "assembled", "r", "mod", "address", "option", "sect", "function", "port", "part", "sb", "root", "division", "Section", "layer", "pair", "cm", "result", "lc", "join", "rl"], "mr": ["rh", "rf", "adr", "ru", "mk", "mn", "tr", "rd", "hr", "rw", "mor", "m", "fr", "rr", "bm", "kr", "mm", "gr", "wk", "vm", "eer", "hm", "MR", "cb", "attr", "usr", "au", "wr", "ir", "pm", "rs", "cover", "er", "lr", "nm", "dr", "manager", "rb", "rt", "mer", "fm", "bf", "mid", "module", "mx", "ras", "rc", "bh", "ar", "pr", "r", "md", "bro", "nr", "shr", "asm", "yr", "vr", "dm", "cm", "rx", "rg", "impl", "mt", "Mr", "lc", "br", "sr", "mc", "rl", "rm"], "d": ["dp", "ld", "gd", "di", "dh", "ds", " dd", "da", "m", "dt", "fd", "b", "ad", "c", "bd", "p", "pd", "e", "cd", "du", "dn", "dr", "j", "dl", "db", "dat", "xd", "md", "r", "dd", "vd", "part", "dc", "dm", "h", "a", "D"]}}
{"project": "qemu", "commit_id": "30de46db50d2f9f74c5f7ab1cc463b8dec026407", "target": 0, "func": "static void read_guest_mem(void)\n\n{\n\n    uint32_t *guest_mem;\n\n    gint64 end_time;\n\n    int i, j;\n\n    size_t size;\n\n\n\n    g_mutex_lock(data_mutex);\n\n\n\n    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n    while (!fds_num) {\n\n        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {\n\n            /* timeout has passed */\n\n            g_assert(fds_num);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check for sanity */\n\n    g_assert_cmpint(fds_num, >, 0);\n\n    g_assert_cmpint(fds_num, ==, memory.nregions);\n\n\n\n    /* iterate all regions */\n\n    for (i = 0; i < fds_num; i++) {\n\n\n\n        /* We'll check only the region statring at 0x0*/\n\n        if (memory.regions[i].guest_phys_addr != 0x0) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);\n\n\n\n        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;\n\n\n\n        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,\n\n                         MAP_SHARED, fds[i], 0);\n\n\n\n        g_assert(guest_mem != MAP_FAILED);\n\n        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));\n\n\n\n        for (j = 0; j < 256; j++) {\n\n            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);\n\n            uint32_t b = guest_mem[j];\n\n\n\n            g_assert_cmpint(a, ==, b);\n\n        }\n\n\n\n        munmap(guest_mem, memory.regions[i].memory_size);\n\n    }\n\n\n\n    g_assert_cmpint(1, ==, 1);\n\n    g_mutex_unlock(data_mutex);\n\n}\n", "idx": 11975, "substitutes": {"guest_mem": ["guester_lim", "guestedprogram", "guest__addr", "guestedlim", "guest__mem", "guestedtime", "guess_mem", "guestDlim", "guest__max", "guEST_mem", "guester_mem", "guester_num", "guestedMem", "guestDaddr", "guest__mor", "guest__lim", "guess_memory", "guest_data", "guest_mor", "guest_num", "guest__num", "guest_time", "guEST_Mem", "guestDmemory", "guester_max", "guestDmem", "guest_addr", "guess_data", "guess_lim", "guest_max", "guester_time", "guest_Mem", "guess_mor", "guEST_lim", "guest_memory", "guest_program", "guest_lim", "guest__memory", "guestedmem", "guEST_program", "guess_addr"], "end_time": ["endfulltick", "end67time", "ends_tim", "endfullime", "end_times", "end_length", "end67Time", " end_times", "end_ime", "end_end", "endxend", " end_ime", " end_end", "end67value", "end_tick", "end_Time", "endxTime", "ends_Time", "endfulltimes", "ends_length", " end_tick", "end_value", "endxtime", "ends_time", "end67end", " end_value", " end_Time", "endfulltime", "end_tim", "endxvalue"], "i": ["oi", "l", "hi", "ui", "di", "it", "start", "n", "si", "zi", "id", "xi", "m", "info", "k", "x", "ini", "z", "b", "d", "ji", "c", "p", "uri", "ix", "e", "mu", "yi", "cli", "eni", "f", "ie", "ai", "o", "multi", "index", "slice", "module", "v", "ind", "gi", "ti", "mi", "phi", "inner", "qi", "ij", "pi", "bi", "part", "ii", "init", "u", "type", "I", "li", "ip", "ci", "a", "ori", "ni", "io", "y", "lc", "ri", "api", "site", "image", "fi", "iu", "ki"], "j": ["l", "dj", "area", "it", "adj", "n", "g", "si", "key", "note", "w", "m", "fr", "jet", "k", "b", "x", "z", "num", "t", "d", "job", "ji", "c", "pa", "p", "jo", "jam", "e", "el", "rel", "off", "q", "js", "f", "uj", "child", "o", "fl", "index", "v", "name", "r", "ij", "jp", "part", "ii", "ja", "offset", "u", "aj", "h", "oj", "pos", "li", "not", "a", "out", "J", "y", "jc", "jl", "jj", "br"], "size": ["iz", "sh", "scale", "n", "g", "si", "capacity", "len", "_", "small", "z", "SIZE", "shift", "data", "sum", "max", "c", "mini", "args", "loc", "large", "Size", "sec", "code", "shape", "sync", "name", "sized", "izes", "address", "storage", "ii", "offset", "bytes", "cm", "ci", "ng", "length", "cache", "ize", "weight", "fee"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n\n                               uint32_t *byte_len)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n", "idx": 11978, "substitutes": {"rdma": ["drta", "rrsha", "rtmas", "drpa", "ldmas", "rtma", "ddma", "rrta", "rrama", "erdta", "rdpa", "drma", "rrpa", "drla", "rrMA", "ldMA", "drda", "ddmad", "rdda", "rdmad", "xdmas", "drama", "rdmas", "xdma", "nderma", "rhmad", "rdsha", "ldga", "drmad", "rrma", "erdmma", "rdMA", "rrga", "ddda", "rhma", "ldma", "rrmma", "erdma", "xdta", "drmas", "ddmas", "ldla", "rhla", "rdmma", "drsha", "rtmad", "ddla", "ldmma", "rhmas", "rrmas", "ldta", "rdta", "drMA", "rdla", "rdga", "ldama", "nderpa", "rtda", "rdama", "erdga", "xdla", "ndersha", "nderta", "rtla"], "wr_id_out": ["wr_id_in", "wr_id_int", "wr_name_int", "wr_type_name", "wr_type_id", "wr_name_id", "wr_name_out", "wr_name_in", "wr_type_out", "wr_id_name", "wr_id_id", "wr_type_in"], "byte_len": ["byte_length", "bit_length", "bit_offset", "byte_val", "bit_val", "bit_len", "byte_offset"], "ret": ["count", "rf", "repl", "arr", "flag", "detail", "str", "len", "val", "alt", "ext", "fail", "def", "id", "nt", "Ret", "no", "b", "t", "num", "pat", "red", "reply", "ref", "arg", "obj", "status", "reg", "gt", "rets", "empty", "f", "code", "rt", "res", "bf", "pub", "det", "rc", "r", "att", "fun", "err", "part", "art", "rep", "error", "orig", "fin", "re", "RET", "back", "out", "result", "mt", "match", "rev", "resp", "ft", "success", "reset"], "wc": ["Wf", " wf", "rf", "ewdc", "Wc", "Wdc", "ewmc", " wvc", "wp", "ewf", " robc", "swmc", "Wvc", "whdc", "rwc", "wdc", " wpc", "swc", "ewp", "rp", "Wpc", "wf", "ewc", "swlc", "Wlc", "ewvc", "rwf", " wbc", "rwlc", " wlc", "whlc", "wvc", "swp", "whc", "rc", " wdc", "ewlc", "wmc", "wpc", "Wbc", "rlc", " wp", "rwvc", "whvc", "Wp", "wlc", "rwmc", " ropc", " rodc", " roc", " wmc", "wbc", "rwdc"], "wr_id": ["wr_Id", "ptr_path", " wr_type", "wr_bid", "wr_oid", "wrSids", "WR_name", "ptr_ids", "rw_no", "wrPid", "wr_ids", "wr_type", "WR_num", "ptr_id", "wm_id", "ptrObid", "rw_type", "rw_ident", "wm_name", "writer_name", "wr_key", "wr_vid", "writer_id", "wrginfo", "wrgtarget", "wm_sid", "wrOinfo", "rw_name", "wrObid", "wr_form", "wr_num", "wm_info", "wr_ident", "writer_type", "wr_count", "usr_name", "wr_ref", "wr_no", "wm_count", "wrOname", "wrOid", "writer_ref", " wr_vid", "usr_info", " wr_num", "ptrOids", "WR_type", "wrSpath", "usr_form", "wrOform", "rw_info", "rw_id", "wrPname", "wr_info", "wrOids", " wr_Id", " wr_ids", "wm_type", "wr_target", "usr_id", "wrSid", "wrPtype", "wm_ip", "wrgtype", "wrSbid", "wr_ip", "wrgid", "WR_id", "wr_name", "ptr_bid", "wr_sid", "ptrOid", "wrOpath", "wrPref", "ptrOpath", "rw_key", "rw_oid", "rw_target", "wr_path"], "block": ["map", "channel", "Block", "byte", "section", "comment", "record", "control", "pool", "line", "data", "rule", "output", "value", "number", "condition", "frame", "group", "flow", "entry", "unit", "index", "bl", "name", "input", "object", "blocks", "list", "error", "node", "bit", "type", "lock", "row", "header", "result", "buffer", "chain"], "nb_sent": ["num_changed", "num_sent", "nbgchanged", "nbgwritten", "nbgsend", "num_send", "nbgsent", "nb_written", "nb_send", "nb_changed", "num_written"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    uint32_t minor_ver;\n\n    int comp_brand_size;\n\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n\n    char* comp_brands_str;\n\n    uint8_t type[5] = {0};\n\n\n\n    avio_read(pb, type, 4);\n\n    if (strcmp(type, \"qt  \"))\n\n        c->isom = 1;\n\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n\n    minor_ver = avio_rb32(pb); /* minor version */\n\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%\"PRIu32\"\", minor_ver);\n\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n\n\n    comp_brand_size = atom.size - 8;\n\n    if (comp_brand_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n\n    if (!comp_brands_str)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, comp_brands_str, comp_brand_size);\n\n    comp_brands_str[comp_brand_size] = 0;\n\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n\n    av_freep(&comp_brands_str);\n\n\n\n    return 0;\n\n}\n", "idx": 11979, "substitutes": {"c": ["l", "cr", "conf", "oc", "co", "C", "n", "g", "m", "tc", "k", "b", "t", "d", "con", "ct", "cp", "config", "p", "s", "cd", "cu", "e", "cf", "cn", "ec", "coll", "cc", "ac", "bc", "f", "cs", "cv", "v", "ce", "ctx", "cur", "dc", "pc", "xc", "u", "gc", "icc", "ca", "cm", "self", "ci", "vc", "lc", "ch", "anc", "cache", "mc", "uc", "cy", "sc", "fc"], "pb": ["lp", "dp", "uf", "ppa", "pg", "nb", "proc", "bp", "prot", "bm", "b", "ab", "apy", "pa", "pp", "cp", "fb", "config", "p", "pd", "cb", "fp", "gb", "rb", "tmp", "bc", "db", "bf", "mp", "eb", "py", "bps", "bh", "ctx", "lb", "bot", "tp", "jp", "sb", "pc", "PB", "cpp", "hub", "platform", "cm", "api", "rob", "xb", "typ", "fab", "fc"], "atom": ["param", "abc", "arch", "mol", "om", "gom", "m", "tc", " Atom", "article", "instance", "num", "container", "config", "obj", "app", "component", "attr", "xml", "at", "prop", "tmp", "parser", "bc", "op", "orb", "canon", "sym", "tom", "module", "name", "item", "object", "com", "node", "tm", "comm", "cm", "mom", "typ", "atomic"], "minor_ver": ["minior_VER", "minori_version", "minor__Ver", "minor__VER", "minior_Ver", "minor_vers", "minor54ver", "minor_pack", "minor_Ver", "minior64version", "minor64ver", "minor64VER", "minior64VER", "minior64ver", "minor__version", "minior_ver", "minor_VER", "miner_version", "minor54exp", "minor2ver", "minior_version", "minor_version", "minor_exp", "minori_vers", "minor__ver", "minori_pack", "minor2version", "miner_range", "minor64version", "miner_ver", "minor_range", "miner_exp", "minor2pack", "minori_ver", "minor2vers", "minor54version", "minor64Ver", "minior64Ver", "minor54range"], "comp_brand_size": ["comp_tag_size", "comp_package_sized", "comp_domainopname", "comp_model_size", "comp_brandadtype", "comp_version_size", "comp_brandsz", "comp_domainopsize", "comp_domain_name", "comp_model_type", "comp_domain_width", "comp_versionsz", "comp_brand_length", "comp_brand_name", "comp_brand_loc", "comp_brand_ize", "comp_domainopize", "comp_versionssize", "comp_brand_type", "comp_brandopwidth", "comp_brandopsize", "comp_brand_z", "comp_brandadize", "comp_model_ize", "comp_brandfsized", "comp_domain_size", "comp_version_z", "comp_version_length", "comp_brandfsize", "comp_brandopname", "comp_brandssize", "comp_version_name", "comp_package_length", "comp_brand_width", "comp_brand_number", "comp_brand_sized", "comp_brand_scale", "comp_versionslength", "comp_brandflength", "comp_brandslength", "comp_tag_name", "comp_tag_loc", "comp_tag_number", "comp_brandopize", "comp_domainopwidth", "comp_brandsname", "comp_package_size", "comp_domain_ize", "comp_brandadsize", "comp_tag_scale", "comp_versionsname"], "minor_ver_str": ["minor_version_fr", "minor_ver_arr", "minor_ver_Str", "minor_ver_fr", "minor_version_arr", "minor_ver_string", "minor_version_str", "minor_version_st", "minor_version_Str", "minor_version_string", "minor_version_br", "minor_ver_br", "minor_ver_st", "minor_version_div", "minor_ver_div", "minor_ver_char", "minor_version_char"], "comp_brands_str": ["comp_bralls_arr", "comp_brands_fr", "comp_bralls_st", "comp_bralls_r", "comp_brances_st", "comp_brances_arr", "comp_brandsmsl", "comp_brances_str", "comp_brances_string", "comp_brands_Str", "comp_brands_r", "comp_brander_string", "comp_branches_name", "comp_bralls_str", "comp_brands2st", "comp_bralls_exp", "comp_brandsmfr", "comp_brands_arr", "comp_brands_string", "comp_brands_iter", "comp_brands_sl", "comp_brands_exp", "comp_brands_war", "comp_brands2string", "comp_brands_dr", "comp_brands_name", "comp_brander_iter", "comp_branches_dr", "comp_brands2arr", "comp_bralls_iter", "comp_brander_war", "comp_brands_st", "comp_branches_Str", "comp_brander_str", "comp_branches_arr", "comp_branches_fr", "comp_branches_str", "comp_branches_sl", "comp_brandsmdr", "comp_brandsmstr", "comp_brands2str", "comp_bralls_string"], "type": ["parent", "kind", "domain", "base", "str", "val", "source", "prefix", "class", "key", "info", "id", "tag", "path", "t", "ver", "var", "Type", "block", "data", "config", "ref", "meta", "p", "time", "attr", "pe", "value", "number", "style", "types", "op", "none", "code", "unit", "label", "o", "py", "version", "index", "size", "format", "name", "order", "phrase", "pre", "address", "port", "ty", "tp", "error", "list", "col", "TYPE", "root", "link", "cat", "year", "ip", "url", "length", "y", "ype", "match", "typ"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980, "substitutes": {"bus": ["boot", "pass", "board", "http", "mount", "BBC", "bridge", "config", "ux", "plug", "bug", "bits", "serial", "us", "BUS", "os", "Bus", "sync", "USB", "port", "usb", "self", "cache", "proc"], "devfn": ["devicefile", "devFN", "DevFN", "tempfn", "Devfp", "Devfile", " devfd", "devicefp", " devfile", "Devfunction", "tempfd", "devicefn", "Devfn", "tempfp", "devicefunction", "devfp", " devfp", "tempFN", " devFN", "Devfd", " devfunction", "devfile", "devfunction", "devfd"], "offset": ["parent", "alias", "location", "reference", "timeout", "optional", "start", "prefix", "info", "pointer", "data", "slot", "limit", "set", "number", "style", "off", "padding", "o", "index", "size", "format", "align", "end", "address", "function", "position", "error", "pos", "attribute", "length", "Offset", "range", "reset"], "value": ["parent", "reference", "timeout", "Value", "start", "val", "key", "w", "data", "number", "array", "flow", "slave", "padding", "entry", "child", "values", "version", "index", "v", "format", "name", "current", "function", "address", "position", "property", "amount", "type", "message", "image", "buffer", "VALUE", "paid", "fee"]}}
{"project": "FFmpeg", "commit_id": "073811cdd29e365498b3455ee4e0eda4b957a957", "target": 0, "func": "static int decode_stream_header(NUTContext *nut){\n\n    AVFormatContext *s= nut->avf;\n\n    ByteIOContext *bc = &s->pb;\n\n    StreamContext *stc;\n\n    int class, stream_id;\n\n    uint64_t tmp, end;\n\n    AVStream *st;\n\n\n\n    end= get_packetheader(nut, bc, 1);\n\n    end += url_ftell(bc);\n\n\n\n    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);\n\n    stc= &nut->stream[stream_id];\n\n\n\n    st = s->streams[stream_id];\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    class = get_v(bc);\n\n    tmp = get_fourcc(bc);\n\n    st->codec->codec_tag= tmp;\n\n    switch(class)\n\n    {\n\n        case 0:\n\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n            st->codec->codec_id = codec_get_id(codec_bmp_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 1:\n\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            st->codec->codec_id = codec_get_id(codec_wav_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 2:\n\n//            st->codec->codec_type = CODEC_TYPE_TEXT;\n\n//            break;\n\n        case 3:\n\n            st->codec->codec_type = CODEC_TYPE_DATA;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown stream class (%d)\\n\", class);\n\n            return -1;\n\n    }\n\n    GET_V(stc->time_base_id    , tmp < nut->time_base_count);\n\n    GET_V(stc->msb_pts_shift   , tmp < 16);\n\n    stc->max_pts_distance= get_v(bc);\n\n    GET_V(stc->decode_delay    , tmp < 1000); //sanity limit, raise this if moors law is true\n\n    st->codec->has_b_frames= stc->decode_delay;\n\n    get_v(bc); //stream flags\n\n\n\n    GET_V(st->codec->extradata_size, tmp < (1<<30));\n\n    if(st->codec->extradata_size){\n\n        st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        get_buffer(bc, st->codec->extradata, st->codec->extradata_size);\n\n    }\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_VIDEO){\n\n        GET_V(st->codec->width , tmp > 0)\n\n        GET_V(st->codec->height, tmp > 0)\n\n        st->codec->sample_aspect_ratio.num= get_v(bc);\n\n        st->codec->sample_aspect_ratio.den= get_v(bc);\n\n        if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){\n\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio\\n\");\n\n            return -1;\n\n        }\n\n        get_v(bc); /* csp type */\n\n    }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){\n\n        GET_V(st->codec->sample_rate , tmp > 0)\n\n        tmp= get_v(bc); // samplerate_den\n\n        if(tmp > st->codec->sample_rate){\n\n            av_log(s, AV_LOG_ERROR, \"bleh, libnut muxed this ;)\\n\");\n\n            st->codec->sample_rate= tmp;\n\n        }\n\n        GET_V(st->codec->channels, tmp > 0)\n\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n\n        av_log(s, AV_LOG_ERROR, \"Stream header %d checksum mismatch\\n\", stream_id);\n\n        return -1;\n\n    }\n\n    stc->time_base= &nut->time_base[stc->time_base_id];\n\n    av_set_pts_info(s->streams[stream_id], 63, stc->time_base->num, stc->time_base->den);\n\n    return 0;\n\n}\n", "idx": 11983, "substitutes": {"nut": ["cot", "cit", "tun", "oren", "ox", "cdn", "ou", "utils", "qt", "yt", "boot", "orn", "nb", "n", "gat", "nt", "org", "annot", "dt", "temp", "cut", "t", "sci", "nuts", "ct", "c", "bd", "config", "cb", "np", "txt", "cn", "cf", "cro", "uts", "nw", "rot", "orb", "ut", "bt", "rt", "nat", "nit", "tube", "stone", "nv", "ctr", "kt", "UT", "art", "Nut", "dc", "storage", "cue", "uni", "nc", "cm", "ocr", "ctor", "ot", "sat", "ft", "anc", "text", "pot", "cart", "utt", "ore"], "s": ["sac", "js", "sp", "utils", "sg", "ts", "session", "ks", "sv", "ds", "n", "si", "g", "is", "its", "sf", "stats", "t", "b", "sci", "ops", "gs", "sa", "c", "service", "nuts", "p", "ls", "server", "set", "xs", "sq", "us", "f", "os", "an", "rs", "cs", "sym", "o", "aws", "S", "es", "sync", "v", "sts", "south", "sl", "services", "ctx", "r", "sup", "sn", "sb", "ns", "storage", "sd", "spec", "sys", "self", "ses", "sat", "site", "ps", "fs", "ss", "bs", "ssl", "sc"], "bc": ["cot", "BC", "cca", "tc", "auc", "wb", "BBC", "c", "ct", "fb", "config", "bd", "bitcoin", "cb", "gb", "exec", "cf", "rb", "ec", "cc", "ac", "bt", "db", "bf", "cus", "lib", "rc", "ctx", "cl", "sb", "dc", "pc", "ucc", "com", "cms", "web", "nc", "gc", "cm", "ca", "usc", "soc", "lic", "bn", "lc", "anc", "jc", "bs", "mc", "uc", "sc", "fc"], "stc": ["estct", "Stci", "dre", "estxc", "estb", "stb", "STcs", "stdc", "ttv", "Stct", "stch", "estci", "estcf", "stde", "sti", "ndcs", "stdcf", " stlc", "Stc", "ests", "estv", "STb", "estc", "ostc", " stci", " stf", "estf", "istf", "ostch", "stct", " sts", "stdxc", "stv", " sti", " stv", "ttc", "ndb", "drc", "estch", " stp", "Stf", "drcf", "stcf", "estpc", "strpc", "stci", "stlc", "estcs", "este", "isti", "ostf", "drxc", "esti", "strc", "nddc", "istc", "tts", "stp", "stpc", "strch", "STc", "stcs", "strf", "stxc", "estdc", "istp", "estp", "sts", "estlc", "stf", "ttlc", "ndc", " stct", "ste", "ostpc", "STdc"], "class": ["count", "parent", "bad", "str", "ext", "len", "section", "val", "Class", "stage", "test", "id", "method", "pack", "tag", "instance", "num", "c", "line", "max", "time", " Class", "pe", "number", "stop", "prop", "step", "op", "sec", "loss", "code", "unit", "version", "lib", "name", "event", "object", "mod", "classes", "CLASS", "cl", "part", "bus", "type", "pos", "back", "loop", " CLASS", "file", "url", "length", "comp", "func", "text", "proc", "acc"], "stream_id": [" stream_index", " streamsindex", "streamsindex", " stream_info", "streamxname", "stageerbid", "stream_type", "streamxid", "stage_bid", "streamerids", "stageerid", "stageername", "stream_info", "streamslength", "channel_type", "channel_id", "streamername", "streamxbid", "streamersid", "stage_sid", " streamsid", "channel_length", "streamsinfo", "stream_pid", "streamertype", " streamsinfo", "streamerpid", "thread_id", "stream_index", "stream_bid", "channel_name", "thread_type", "streamxsid", "thread_ids", "stream_name", "streamerbid", "streamsname", "thread_pid", "streamerid", "stage_name", "stageersid", "stage_id", "stream_length", "stream_ids", "streamstype", "stream_sid", "streamsid"], "tmp": ["sp", "base", "field", "img", "cmp", "pad", "tt", "vt", "fb", "config", "pb", "cb", "attr", "np", "txt", "loc", "body", "ock", "amp", "opt", "duration", "v", "fake", "uv", "cur", "now", "offset", "cpp", "type", "pod", "bb", "tc", "course", "cont", "post", "c", "vm", "output", "meta", "app", "prop", "slice", "nd", "sup", "pre", "storage", "kk", "tab", "wp", "nb", "ext", "len", "ff", "source", "test", "temp", "nt", "src", "bp", "appy", "page", "wb", "pp", "buf", "data", "cp", "fp", "rb", "stop", "dat", "nom", "tp", "jp", "elt", "sb", "part", "property", "ott", "cache", "uc", "acc", "yet", "cdn", "area", "start", "dt", "oe", "obj", "stuff", "next", "inst", "mp", "name", "pos", "api", "video", "proc"], "end": ["start", "len", "ff", "ended", "all", "w", "id", "m", "ent", "End", "t", "x", "page", "num", "z", "send", "post", "last", "con", "ad", "max", "limit", "close", "run", "e", "p", "stop", "code", "append", "size", "order", "event", "en", "port", "ending", "offset", "after", "enc", "pend", "h", "pos", "length", "END"], "st": ["cr", "ld", "sp", "sh", "ts", "std", "str", "start", "est", "ust", "stage", "nt", "fr", "src", "sw", "rest", "t", "sa", "ct", "stream", "stack", "set", "ost", "pt", "stop", "f", "ut", "inst", "spect", "amp", "nd", "sta", "sts", "sl", "kt", "sn", "sth", "lt", "ste", "put", "cl", "sb", "art", "ist", "trans", "sd", "ast", "stable", "St", "et", "ST", "ft", "mt", "ss", "td", "fe", "sc"]}}
{"project": "FFmpeg", "commit_id": "5127f465bd3e2cf9cbf66dea3cf7b481b522d266", "target": 1, "func": "static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *s;\n\n    unsigned char *d;\n\n    unsigned char *d_end;\n\n    unsigned char queue[QUEUE_SIZE];\n\n    unsigned int qpos;\n\n    unsigned int dataleft;\n\n    unsigned int chainofs;\n\n    unsigned int chainlen;\n\n    unsigned int speclen;\n\n    unsigned char tag;\n\n    unsigned int i, j;\n\n\n\n    s = src;\n\n    d = dest;\n\n    d_end = d + dest_len;\n\n    dataleft = AV_RL32(s);\n\n    s += 4;\n\n    memset(queue, 0x20, QUEUE_SIZE);\n\n    if (AV_RL32(s) == 0x56781234) {\n\n        s += 4;\n\n        qpos = 0x111;\n\n        speclen = 0xF + 3;\n\n    } else {\n\n        qpos = 0xFEE;\n\n        speclen = 100;  /* no speclen */\n\n    }\n\n\n\n    while (dataleft > 0) {\n\n        tag = *s++;\n\n        if ((tag == 0xFF) && (dataleft > 8)) {\n\n            if (d + 8 > d_end)\n\n                return;\n\n            for (i = 0; i < 8; i++) {\n\n                queue[qpos++] = *d++ = *s++;\n\n                qpos &= QUEUE_MASK;\n\n            }\n\n            dataleft -= 8;\n\n        } else {\n\n            for (i = 0; i < 8; i++) {\n\n                if (dataleft == 0)\n\n                    break;\n\n                if (tag & 0x01) {\n\n                    if (d + 1 > d_end)\n\n                        return;\n\n                    queue[qpos++] = *d++ = *s++;\n\n                    qpos &= QUEUE_MASK;\n\n                    dataleft--;\n\n                } else {\n\n                    chainofs = *s++;\n\n                    chainofs |= ((*s & 0xF0) << 4);\n\n                    chainlen = (*s++ & 0x0F) + 3;\n\n                    if (chainlen == speclen)\n\n                        chainlen = *s++ + 0xF + 3;\n\n                    if (d + chainlen > d_end)\n\n                        return;\n\n                    for (j = 0; j < chainlen; j++) {\n\n                        *d = queue[chainofs++ & QUEUE_MASK];\n\n                        queue[qpos++] = *d++;\n\n                        qpos &= QUEUE_MASK;\n\n                    }\n\n                    dataleft -= chainlen;\n\n                }\n\n                tag >>= 1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11985, "substitutes": {"src": ["rin", "img", "start", "source", "sel", "in", "b", "filename", "buf", "c", "config", "rib", "ls", "stream", "gb", "ins", "rb", "loc", "rs", "sq", "inst", "sub", "rc", "input", "cur", "r", "req", "load", "sb", "rx", "url", "image", "ch", "sr", "sc"], "dest": ["des", "dim", "dom", "source", "class", "path", "decl", "b", "rest", "wb", "delete", "de", "data", "destroy", "output", "Dest", "target", "dist", "du", "dir", "dat", "v", "master", "route", "name", "done", "end", "address", "desc", "dc", " destination", "dev", "del", "text", "dep", "D", "direction"], "dest_len": ["dest2length", "dest_size", "dest_val", "Dest_len", "Dest_size", "dest00len", "dest2val", "dest_Len", " dest_length", "dest00pos", "dest2Len", " dest_Len", "dest00size", "dest_pos", "dest2len", "dest00length", "Dest_length", "dest_length", "Dest_pos", " dest_val"], "s": ["l", "session", "is", "its", "m", "http", "t", "x", "gs", "v", "state", "ns", "hs", "spec", "self", "settings", "sg", "ds", "si", "n", "w", "b", "k", "c", "ids", "e", "se", "request", "args", "lines", "sq", "f", "sym", "slice", "sets", "es", "r", "as", "u", "ps", "su", "site", "ss", "sc", "ks", "sv", "g", "source", "ls", "socket", "os", "cs", "o", "size", "sl", "new", "sb", "side", "a", "sid", "ssl", "ts", "start", "service", "p", "server", "ins", "q", "js", "S", "states", "services", "h", "client", "ses", "y", "events"], "d": ["l", "ld", "dim", "di", "dh", "ds", "did", "dom", "n", "start", "g", "da", "w", "m", "id", "dt", "dos", "b", "x", "t", "z", "fd", "de", "data", "ad", "c", "p", "bd", "e", "cd", "du", "dn", "f", "ded", "dr", "db", "dir", "o", "dat", "v", "nd", "ind", "end", "md", "r", "dd", "dc", "sd", "u", "D", "h", "del", "days", "y", "dad", "dx", "dy", "direction"], "d_end": ["d__ent", "ld_offset", "sd__ent", "d_edge", "d_enter", "d_ended", "sd__end", "d_ent", "sd_ent", "d_start", "sd_start", "d__end", " d_max", "d_End", "dd_ends", "dd_END", "d_END", "ld_end", " d_offset", "sd__start", "dd_end", " d_ended", "sd__End", "d_ends", "ld_enter", " d_get", "d__End", "d_get", "sd_End", "d_offset", "ld_edge", "d_max", "d__start", "sd_end", " d_start"], "queue": ["Queue", "channel", "seq", "message", "context", "table", "client", "class", "view", "que", "store", "buf", "pool", "job", "batch", "config", "stream", "stack", "qa", "p", "server", "fp", "output", "status", "memory", "q", "array", "sequence", "ue", "f", "select", "code", "console", "progress", "fl", "index", "process", "master", "module", "pipe", "proxy", "port", "desc", "list", "command", "null", "Q", "loop", "header", "menu", "complete", "cache", "result", "use", "file", "proc", "buffer", "forward"], "qpos": ["qpid", "quargs", "sqpos", "sqmin", "questval", "sqpat", " qsize", "sqcos", "quos", "quloc", "qufat", "qos", " qpo", "reqpo", " qpose", "qsize", "reqcos", "quval", "rypt", "qpose", "kpose", " qmin", "Qneg", " qpat", "qpt", "questfat", "qupos", "sqval", "qbody", "quposition", "kpo", "qargs", "qposition", "qpointer", "qupo", "sqbody", "qucos", "reqpos", "sqpt", "sqloc", "reqpointer", "qmin", "qumin", " qcos", " qbody", "sqpointer", " qpid", "questpos", "qpo", "qusize", " qfat", "quneg", "sqpo", "qfat", "kos", "qupt", "qupose", " qloc", "Qpos", "rypid", "rypos", "qcos", "rybody", "kpos", "sqargs", "Qpt", "reqposition", " qposition", " qargs", "sqpid", "qloc", " qpt", " qval", "qupointer", "qneg", "Qpo", "qupat", " qneg", "questpo", "sqsize", "qpat", "qval", " qos"], "dataleft": ["datALEFT", "datanext", "databeft", " dataleff", "Datalefts", "datallefts", "datavefort", "datatefts", "dataledkt", "dataalefort", "datalefort", "datalext", "datalewt", " dataleFT", "datareaft", "dataalsefort", " datalesft", "datameaft", "dataledaft", "dataledfts", "databekt", "dataalseaft", "daaleft", "datateaft", "daaleaft", "datamefort", "datarefort", "datalsefort", "Datalsefty", "danefort", "datALEft", "datvaleaft", "daalekt", "datalesfts", "datadefort", "datalefts", "datateft", "dalefts", "Datalseft", "datanewt", " datalesfts", "daneft", "dataleaft", "datALEff", "datalesft", "datALExt", "datalesxt", "dataveaft", " datalesaft", " datalesff", "datalsefty", "dataaleft", " dataleaft", "daatekt", "daateft", "datalleFT", "daateaft", "datalefty", "dataalsefts", "Dataleft", "datvalefts", "datamefty", "daleft", "DatalseFT", "daneaft", "dalefort", " datalesxt", "dataalefts", "datalleaft", "datareft", "daleaft", "Dat\n", "datavefts", "dataaleaft", "danewt", "danefts", " datalefts", "datamefts", "dataleff", "datadeFT", " datalext", "dataneFT", "datanefort", "datarefts", "DataleFT", "datalekt", "daatefts", "datalseaft", "dataledft", "dataneaft", "databefts", "datameft", "datadewt", "Datalefty", "datadefts", "dat\n", "Datalsefts", "daalefts", "datanefts", "datameFT", " datalesFT", "dalewt", "datvalewt", "dataalseft", "datalesff", "datatekt", "datalesfty", "datalesaft", "databeaft", "datalsefts", "data\n", "dataneft", "datalleft", " dat\n", "dataneff", "dataleFT", "datalesFT", "datalseFT", "dataveft", "datvaleft", "datadeaft", "datalseft", "datadeft"], "chainofs": ["chainOfn", "chainaccounth", "chainreturnabs", "chainfeedb", "chainOfh", "chaindicte", "chainforssl", "blockofabs", "blockefe", "chainlibb", "chainoffs", "chainreturns", " chainofses", "chaineffs", "chainofsym", " chainlibses", "containereffsync", " chainaccountssl", "chainfeeds", "chainowns", "blockofs", " chainofn", "chainofabs", "blockofsym", "chaineffn", "chainforh", "chainofn", "chainownb", "chainlibh", "chaindefses", "blockefs", " chainofssl", "chainofe", "chainofssl", "chainownses", " chainaccounts", "containereffs", "chaindictsym", " chainofb", "chaindictabs", "chainfeedn", "chainforn", "chainaccounts", " chainaccounth", "chainefe", "chaindefb", "chainfors", "chainofsync", "chainreturne", "chaindicts", "chainreturnsym", "chainOfssl", "chainlibs", "chainoffn", "chaineffb", "chainaccountn", "blockefsym", "chainoffb", "containerofsync", " chainlibs", "blockefabs", "chainofb", "chainaccountssl", "chaindefh", "chainofses", "blockofe", "chainoffsync", " chainaccountn", "containerofb", "chaineffsync", "chainefsym", "chainofh", "chainOfs", " chainlibb", " chainofh", "containerofn", "chainfeedsync", "containerofs", "chainefabs", " chainlibh", "chaindefs", "chainefs", "chainlibses", "containereffn", "containereffb", "chainownh"], "chainlen": ["groupgen", "rulelen", "blocklon", "cyclelength", "blocklen", "chaingen", "listlon", "listcount", "blockfat", "blockpos", " chainLen", "rowlen", "chainpos", "chainfat", "containerlength", "pathLen", "rangeLen", "blocklim", "containerlen", "blocklength", "groupLen", "rulelon", "pathcount", "rangelength", "cyclefat", "grouplen", " chainlon", "rowLen", "rowlon", "channellen", " chainlength", "containerlim", "rangelen", "blockgen", "cyclelim", "pathlen", "listLen", "chainlon", "channelLen", "rowlength", "pathlon", "blockcount", "ruleLen", "chainlength", "rulelength", "cyclegen", "blockLen", "chainLen", "listlen", " chainpos", "groupfat", "chainlim", "containerLen", "cyclelen", "cycleLen", "channelpos", "rangelon", "chaincount", "channellon"], "speclen": ["speflan", "specplun", "speflent", "speplan", "spelllen", " speclens", "speceleno", "specplent", "speccine", "specileno", "specclan", "seclun", "speplen", " specilen", "speplens", "speflun", "seclenn", "speCLenn", "speplent", " specllen", " specillen", "speblan", "speblen", "speblun", "specilens", "speCleng", " specileno", "speblent", "speClen", "speplenn", " spepleng", "speccun", "specillen", "specclent", "specellen", "specclen", "selline", " speclenn", "sellen", "specclun", "specplen", "speccenn", "specllen", "sellenn", "speclan", "speClenn", "spellens", " speplen", "speplun", "speCLine", "specilen", "speCLun", "specleng", " speplenn", "speccen", "spellenn", "speclens", "seclen", "speClens", "spepleng", "secline", " specleng", "sellun", "specplan", "specelen", "speCLeng", " specilens", " speplens", "specleno", "speclent", "specelens", "speCLen", "spelline", "speclun", " specleno", "spellun", "speCLens", "spellen", "specline", "spelleno", "speclenn", "speflen"], "tag": ["tags", "flag", "ack", "category", "str", "section", "comment", "start", "date", "class", "test", "key", "id", "word", "ban", " tags", "big", "block", "head", "config", "p", "reg", "Tag", "ag", "bug", "style", "loc", "op", "code", "name", "feature", "mod", "token", "sign", "bit", "TAG", "cat", "type", "tail", "gap", "image", "use", "text", "match", "feat", "month"], "i": ["l", "ui", "di", "it", "is", "n", "si", "g", "in", "zi", "m", "xi", "id", "info", "b", "x", "ini", "z", "my", "k", "uli", "c", "ji", "p", "ix", "e", "yi", "mini", "eni", "f", "ie", "ai", "multi", "index", "v", "gi", "ti", "mi", "phi", "ind", "r", "inner", "qi", "im", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "a", "ori", "ni", "io", "y", "ri", "fi", "iu"], "j": ["l", "je", "it", "n", "g", "w", "m", "jet", "t", "k", "b", "z", "x", "dj", "job", "jen", "ji", "p", "jam", "jo", "e", "el", "kj", "jj", "q", "js", "f", "o", "v", "syn", "jit", "ind", "r", "ij", "jp", "ii", "ja", "u", "aj", "pos", "li", "J", "y", "jl", "adj"]}}
{"project": "qemu", "commit_id": "3daa41078aedf227ec98b0d1c9d56b77b6d20153", "target": 1, "func": "void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}", "idx": 11988, "substitutes": {"req": ["sem", "rf", "dq", "conf", "ru", "seq", "qt", "cmp", "ext", "tr", "rd", "str", "hr", "wa", "proc", "def", "rw", "conn", "fr", "org", "mr", "rr", "low", "require", "task", "http", "gr", "rec", "ver", "config", "ref", "arg", "obj", "tar", "cb", "request", "cf", "q", "dr", "rt", "res", "progress", "requ", "ctr", "call", "cur", "r", "pr", "err", "mod", "ctx", "jp", "loader", "desc", "pull", "spec", "required", "ro", "self", "grad", "rx", "dev", "comp", "cmd", "crit", "pkg", "rh", "dep", "exec"]}}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 11998, "substitutes": {"s": ["sg", "ts", "ks", "ds", "si", "g", "sf", "m", "t", "b", "ops", "d", "gs", "sa", "c", "p", "server", "e", "app", "xs", "sq", "js", "sec", "f", "cs", "v", "es", "S", "south", "sl", "services", "ctx", "ns", "sb", "spec", "u", "self", "sys", "client", "api", "ps", "ses", "fs", "su", "ss", "ssl"], "pc": ["cpu", "m", "tc", "bp", "pid", "rec", "pointer", "c", "ct", "p", "pb", "gb", "fp", "pt", "pm", "ptr", "cod", "bc", "ac", "cc", "cs", "db", "mp", "py", "amp", "rc", "port", "enc", "nc", "client", "px", "ci", "api", "cache", "lc", "proc", "mc", "PC", "fc"], "tmp": ["tab", "cmp", "nb", "m", "bp", "temp", "src", "tc", "fd", "t", "appy", "Temp", "wb", "buf", "vt", "pointer", "data", "c", "cp", "config", "p", "vm", "pb", "obj", "stuff", "fp", "np", "txt", "cb", "ptr", "rb", "cro", "bt", "db", "mp", "tf", "amp", "v", "jp", "tp", "sb", "now", "storage", "cpp", "emp", "cache", "result", "buff", "proc", "kk"]}}
{"project": "qemu", "commit_id": "8dfd5f96515ca20c4eb109cb0ee28e2bb32fc505", "target": 0, "func": "static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n\n                                            uint16_t code, const char *reason)\n\n{\n\n    struct iovec iov;\n\n    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n\n    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =\n\n        cpu_to_be16(code);\n\n    ioc->rawoutput.offset += 2;\n\n    if (reason) {\n\n        buffer_append(&ioc->rawoutput, reason, strlen(reason));\n\n    }\n\n    iov.iov_base = ioc->rawoutput.buffer;\n\n    iov.iov_len = ioc->rawoutput.offset;\n\n    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,\n\n                               &iov, 1, iov.iov_len);\n\n    buffer_reset(&ioc->rawoutput);\n\n    qio_channel_websock_write_wire(ioc, NULL);\n\n    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);\n\n}\n", "idx": 12023, "substitutes": {"ioc": ["ioec", "iniog", "ciocom", "iuOC", "iooc", "iuoc", " iorg", "ioci", "xiocom", "piroc", " iucc", "ioca", "iec", "iocom", "riisc", "ioy", "uoc", " iog", "ooci", "pioci", "iroc", "uioci", "piorg", "idiocl", "piocl", "iOC", "iniirc", "piOC", "ciocon", "atiroc", "xiocon", "uocol", "xiocol", "pioko", "piocom", "pioc", "atiOC", "atiisc", "abioci", "cioca", "iuocol", "ioocol", "atoc", "uec", "ciocol", "iorg", "iocol", "xioc", "iocl", "rioci", "inioc", "piocol", "kiocal", " ioci", "rioc", "aocol", "kiocl", "kioc", "uiocom", "rioko", "iocon", "itog", "uioc", "iuisc", "phioc", "iisc", "abiocom", "phiocol", "uiocol", "pitoc", "piucc", "uoca", "xiollo", "uitoc", "iditoc", "iocal", " iocl", "itirc", "ioko", "atiocl", "idiorg", "xiocal", "oocom", "iirc", "riocol", " iocal", "ciucc", " ioy", "cioc", "xioci", "idioc", "oroc", " iocom", "abiroc", "riOC", "abioc", "iuroc", " itoc", "iucc", "xiOC", " iocol", "ooc", "aocom", "ciollo", "iollo", "itoy", "iooca", "kiocom", "phiollo", "riocom", "xiocl", "riroc", "atioci", "iog", "ciec", "atioc", "itoc", " iirc", "inioy", "aoc", "phiocon", "iuoko"], "code": ["count", "ode", "Code", "ack", "id", "src", "data", "c", "close", "component", "e", "status", "cb", "value", "cause", "number", "condition", "ec", "frame", "cod", "loc", "call", "size", "process", "ce", "name", "content", "state", "address", "function", "codes", "error", "type", "message", "charge", "header", "length", "core", "buffer"], "reason": ["issue", "byte", "music", "argument", "author", "category", "comment", "source", "hide", "method", "Reason", "bid", "raise", "card", "id", "why", "effect", "money", "data", "ASON", "status", "request", "secret", "value", "cause", "condition", "loc", "body", "none", "loss", "unit", "asons", "msg", "description", "exc", "name", "connection", "content", "raw", "req", "err", "warning", "desc", "unknown", "error", "summary", "credit", "type", "message", "report", "charge", "warn", "header", "result", "write", "crit", "broken"], "iov": ["voice", "oren", "minecraft", "music", "tnc", "ibl", "omnia", "imir", "yout", "rolet", "liv", "iris", "iii", "gio", "iol", "uno", "raud", "iop", "iv", "inn", "wav", "buf", "userc", "vre", "ibr", "output", "iro", "username", "drm", "ilib", "imedia", "respond", "oyer", "nox", "airo", "coll", "club", "dylib", "orman", "oco", "hovah", "IO", "ionic", "ij", "inic", "iev", "lov", "ilo", "igroup", "anni", "obo", "rx", "vg", "soc", "girl", "iago", "io", "\u00ee", "roc", "iola", "\u00ef"]}}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)\n\n{\n\n    fadt->model = 1;\n\n    fadt->reserved1 = 0;\n\n    fadt->sci_int = cpu_to_le16(pm->sci_int);\n\n    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);\n\n    fadt->acpi_enable = pm->acpi_enable_cmd;\n\n    fadt->acpi_disable = pm->acpi_disable_cmd;\n\n    /* EVT, CNT, TMR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n", "idx": 12026, "substitutes": {"fadt": ["fpadt", "feddtie", "lfadht", "fradto", "feadty", "fastadto", "fpadto", "fullafter", "yadtg", "Faddto", "fedtor", "afaudt", "lfadhto", "fazit", "fidto", "fulladt", "fastpadto", "fidz", "fpadtf", " faddn", "fatty", "fidtor", "fadc", "fodtor", "fadhtg", "fidtu", "fadsx", " fagit", " faddd", "fadit", "fagto", " fadto", "fridt", "fadd", "fpeadter", "fulladter", "faudtt", "faudc", "feddtree", "faddd", "feadtu", "fidth", "lfadhtu", "fpeadx", "fadtg", "feddz", "fadte", "yadt", "faddto", "fullaftt", "fdtr", " fayte", "fudwt", " fdwt", "confidth", "fadst", "fodte", " fadf", "feaidht", "Faddte", "fpadtu", "yadht", "fpadht", "feddty", " faytu", "fadta", " fadtr", "fadytie", "feddte", "failts", "fadet", "Fadt", "fastpadty", "fastadty", "feadout", "fatout", "fagtie", "feadn", "fodt", "zadt", "feadwt", "faddte", "feadtie", "fodwt", "faytu", "fastadts", "fadout", "lfadto", "fullaft", "feadtr", "Faddt", "feddter", "feddt", " fagto", "fddtu", "fadate", "fADte", "fadetf", "fastpadter", "fastadter", "faddtu", "fidf", "fadwt", "confadf", " fachto", "fadato", " fadte", "fpadter", " fadet", "fradc", "zpadt", "fagf", " fagte", "fagit", "fddt", " fadd", " fagf", "faddtor", "fagtree", "confidf", "Fadto", "fadth", "fastpadt", "fpadz", "fadht", "fADht", "fastpadz", "fachit", "faddtr", "fastadz", "fudto", "fdtor", "faidto", "fadytt", "fpadty", "zadc", "fridta", "fadty", "faddtm", "fadz", "afadt", "zadht", "fastadout", "fpidt", "fADt", "confidt", "fidtt", "faftt", " fagtie", "fadec", "faft", "fadhts", "yadty", "yadhout", "confadtf", "fagte", "fulladtt", " fagt", "faddn", "feadd", " fachit", "fridit", "fidty", " fadtree", "afaudto", " fadn", "confidtf", "zpadht", "fidit", "fadeth", "facht", "fpadwt", "fayte", "feddf", "fpadx", "faidwt", "yadhty", "fpidto", "fadyit", "feadet", "fADter", "yadhtg", " fdtor", "lfadhz", "fadhto", "fadtor", "fdtie", "faytm", "feaidtu", "fattg", "faidt", " fagtree", "faidd", "fidwt", "feadt", "faddwt", "fadef", " fdtr", "Faddwt", "feadto", "fadtt", "fadyf", "fatz", "fadeto", " faytm", "fpeadto", "fadhty", "faidter", "fADc", "fpadit", "fpadth", "afaudc", "fastpadts", "faddt", "fpadout", "fADtm", "fidtf", "faidn", "faddet", "feadtg", "Fadte", "fadtree", "fpadts", "fadyter", "Fadwt", "faidtu", "fADtu", "fpadta", "feadht", "fpadf", "fedwt", "fadatree", "fadf", " fadtor", "feddit", "failto", " fadtie", "fpadtr", "confadt", "fedth", "fatt", "zadter", "faudt", " fdt", "fadts", "fdwt", "fadto", " fdth", " facht", "fudte", "fadhtu", "fadsto", "lfadtu", "fidter", "fdth", "faudto", "zpadc", "fadter", "afadto", "fulladty", "faidx", " fadtu", "fadster", "fadx", "fadhz", "fafter", "fazto", "fachto", "fpidwt", "fradt", "fadtr", "zpadter", "fadhout", "fagt", "fradtt", "fpadtor", "feaidt", "fpeadt", "feadter", "fodto", "fachtr", " fachtr", " fayt", "fadtu", "fradit", "fadett", "fadn", "feadx", "feadc", "fadyt", "failt", "fddht", "fpadc", "failout", " faddet", " fadit", " fadtm", "fidt", "fpidtor", " fadwt", "fazt", " fadth", "afaudtt", "fadtie", "confadth", "feddto", "fastadt", "fatter", "fadtf", "fafty", "yadout", "fadtm", "faddtie", " fdtie", "feaidwt", "fridto", " faddt", "fastpadout", "fidta", "afadtt", "fullafty", "faztr", "fdt", "fayt", "fedt", "afadc", "fudt", "fadyty", "fadat", "faidht", "fddwt", "faidet", "fradta", "lfadt", "lfadz"], "pm": ["imm", "km", "ym", "sem", "member", "dim", "param", "em", "om", "PM", "m", "model", "mr", "bm", "prem", "dem", "mm", "gm", "mon", "pa", "vim", "service", "vm", "hm", "pb", "pd", "wm", "po", "gp", "nm", "fm", "mp", "module", "mi", "md", "gem", "nom", "im", "sm", "mod", "am", "rpm", "pi", "iam", "pc", "asm", "mo", "tm", "plugin", "dm", "cm", "px", "ram", "um", "rm"]}}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)\n\n{\n\n    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);\n\n\n\n    if (val & ACPI_BITMASK_SLEEP_ENABLE) {\n\n        /* change suspend type */\n\n        uint16_t sus_typ = (val >> 10) & 7;\n\n        switch(sus_typ) {\n\n        case 0: /* soft power off */\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        case 1:\n\n            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.\n\n               Pretend that resume was caused by power button */\n\n            ar->pm1.evt.sts |=\n\n                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);\n\n            qemu_system_reset_request();\n\n            qemu_irq_raise(ar->pm1.cnt.cmos_s3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 12036, "substitutes": {"ar": ["AR", "arc", "arin", "adr", "arr", "ler", "ari", "arm", "air", "war", "ear", "jar", "ara", "dar", "var", "har", "el", "arg", "tar", "ace", "car", "star", "ag", "ir", "Ar", "arp", "er", "ak", "ac", "dr", "lar", "aro", "al", "alog", "ars", "ner", "nar", "aer", "art", "rar", "ur", "yr", "arb", "iar", "cart", "par", "per"], "val": ["vals", "Val", "ee", "cond", "arr", "base", "valid", "len", "sel", "key", "all", "test", "def", "x", "var", "VAL", "data", "slot", "mit", "el", "arg", "lit", "ref", "gold", "value", "pt", "ay", "loc", "prop", "sec", "aval", "vol", "index", "eval", "al", "v", "bl", "opt", "ind", "py", "sl", "cal", "pre", "als", "elt", "pret", "bit", "pal", "sol", "ret", "exec"]}}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 12038, "substitutes": {"t": ["l", "ts", "ta", "tr", "n", "w", "m", "tc", "trial", "dt", "nt", "b", "tt", "tz", "k", "tty", "d", "i", "z", "tu", "c", "time", "p", "tick", "e", "f", "ut", "T", "tf", "o", "v", "timer", "ti", "r", "ty", "tp", "tim", "tm", "unt", "u", "a", "out", "y", "td", "te"], "data": ["parent", "session", "ui", "di", "timeout", "ta", "debug", "start", "wa", "window", "date", "def", "da", "info", "w", "m", "key", "dt", "template", "temp", "update", "missing", "send", "d", "rec", "i", "ad", "time", "config", "reader", "p", "e", "ata", "ada", "action", "memory", "style", "off", "er", "DATA", "dat", "alpha", "index", "size", "module", "input", "connection", "event", "id", "done", "tx", "Data", "error", "after", "u", "type", "change", "li", "api", "message", "a", "extra", "client", "result", "cache", "database", "exec"], "nearest_delta_us": ["nearest_delta_used", "nearest_delta2US", "nearest_delt_au", "nearest_delt_us", "nearest_delt_use", "nearest_delta_US", "nearest_delta2use", "nearest_delta_au", "nearest_delta2us", "nearest_delt_u", "nearest_delta_u", "nearest_deltaptuse", "nearest_dota_US", "nearest_dota_us", "nearest_delta_aus", "nearest_dota_aus", "nearest_dota_use", "nearest_deltaptau", "nearest_delta2aus", "nearest_delt_US", "nearest_delt_used", "nearest_deltaptus", "nearest_deltaptu", "nearest_delta_use"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n", "idx": 12075, "substitutes": {"v": ["vs", "l", "vi", "sv", "g", "val", "lv", "w", "m", "t", "k", "x", "iv", "d", "i", "vt", "c", "vm", "p", "e", "tv", "env", "q", "f", "j", "inv", "o", "version", "uv", "r", "V", "u", "vv", "volt", "vp"], "errp": [" errpp", "erp", "erpp", "err", "errpc", "nerr", " errpc", "nerp", "erpc", " errr", "errr", "errpp", "nerpp", "nerpc"], "qov": ["dqovo", "workov", "Qovo", "dqoyer", "Qoor", "dqov", "workova", "Qoyer", "qova", "dqove", "Qova", "Qove", "qove", " qoyer", "qoor", "quove", "quov", " qove", "Qov", " qovo", "workove", "workoor", "quova", "qoyer", "qovo", "quoor"], "obj": ["arr", "nb", "n", "g", "alt", "str", "t", "b", "x", "num", "z", "so", "p", "ref", "Obj", "cb", "po", "objects", "args", "pt", "js", "tmp", "rb", "os", "act", "orb", "j", "rt", "o", "bj", "lib", "bl", "oa", "r", "object", "ctx", "elt", "ns", "cl", "fn", "self", "pos", "ob", "out", "rev", "obb", "br", "adj", "fi", "kl"]}}
{"project": "qemu", "commit_id": "c951d9a6751576a076ac80a5e5145ceb8d794d38", "target": 1, "func": "static void file_completion(const char *input)\n\n{\n\n    DIR *ffs;\n\n    struct dirent *d;\n\n    char path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n", "idx": 12079, "substitutes": {"input": ["ahead", "param", "wp", "Input", "img", "initial", "accept", "field", "in", "source", "prefix", "view", "temp", "id", "password", "include", "data", "c", "batch", "output", "ix", "qa", "local", "config", "request", "xml", "value", "before", "q", "empty", "array", "padding", "P", "binary", "xxx", "f", "progress", "inc", "current", "raw", "inner", "buffer", "integer", "address", "pull", "dc", "error", "enc", "init", "u", "form", "command", "null", "import", "image", "bin", "text", "inf", "uc", "pattern"], "ffs": ["affs", "cfs", "FFsb", "ffsd", "cfsl", "ufrows", "ffrows", "fundouts", " effns", " effsd", "ffieldns", "ppsys", " ffo", "bufouts", "ufs", "lfs", " ffns", "ffds", " ffrows", "pps", "FFrows", "fundsd", "ffields", "ffsi", "bufs", "lfsys", "ufsb", " effs", "fundsi", "ffsl", "FFS", "ffns", "ffS", "ffieldsd", "ffouts", "affouts", " ffsb", "ffo", "cfds", "ppds", "bufsi", "lfsl", "ffsb", " ffS", "uffds", "ffieldo", " ffsd", "uffsl", "ufS", "lfds", "affds", "FFs", "funds", "affsi", "affsd", "ffsys", "uffs", " effo", "bufsd", "affsys"], "d": ["dp", "ld", "diff", "l", "dh", "ds", "n", "did", "dom", "g", "dict", "da", "w", "m", "id", "fd", "b", "dos", "t", "z", "ud", "k", "i", "de", "c", "data", "ad", "bd", "s", "e", "pd", "cd", "du", "dn", "f", "ded", "j", "dl", "db", "dir", "dat", "o", "dr", "xd", "nd", "md", "r", "done", "end", "dd", "vd", "dc", "sd", "u", "dy", "dm", "od", "dad", "D"], "path": ["parent", "Path", "session", "base", "word", "python", "config", "xml", "txt", "po", "code", "call", "process", "content", "object", "port", "PATH", "full", "form", "self", "url", "image", "text", "chain", "php", "prefix", "key", "view", "w", "id", "c", "work", "output", "request", "value", "ath", "binary", "index", "space", "current", "list", "root", "directory", "location", "context", "source", "method", "temp", "password", "data", "stream", "local", "array", "progress", "sync", "home", "raw", "part", "enc", "cat", "message", "cache", "core", "uc", "param", "pass", "pointer", "empty", "dir", "child", "route", "name", "folder", "user", "transform", "length", "pattern"], "file": ["parent", "l", "play", "session", "base", "le", "field", "word", "point", "http", "fd", "block", "feed", "al", "connection", "object", "document", "port", "full", "type", "self", "change", "image", "text", "php", "sf", "id", "b", "plain", "c", "rule", "work", "f", "binary", "db", "bf", "live", "read", "directory", "rl", "zip", "source", "ile", "temp", "model", "page", "data", "local", "fp", "flow", "resource", "home", "sl", "message", "use", "cache", "un", "files", "filename", "line", "time", "run", "server", "dir", "lib", "name", "folder", "function", "user", "mail", "h", "File", "bin"], "file_prefix": [" file_pointer", "place_prefix", "file_fix", "file_directory", "routebookdirectory", "filename___reset", "file_padding", "money_padding", "route_radius", "file_offset", "place_area", " file_offset", "file___prefix", "file_exclusive", "file___queue", "place_context", "file_area", "file___name", "route_directory", "money_prefix", "filebookdirectory", "file64exclusive", "file___directory", "file___exclusive", "place_padding", "file__area", "file_radius", "route_exclusive", "file_name", "file__context", "filebookexclusive", "file_reset", "file___radius", "file64prefix", "input_prefix", "file_runner", "money_runner", "filename_name", "filename___prefix", "file64radius", "money_zone", "file_queue", " file_post", "routebookprefix", " file_fix", "filebookprefix", "route_prefix", " file_pad", "filename___name", "input_fix", "filename_reset", "file_zone", "input_name", "file_context", "file_pointer", "file_pad", "file64queue", "filename_queue", "file64reset", "file64directory", "file_post", "filename___queue", "filebookradius", "file__padding", "file64name", "routebookradius", "filename_prefix", "file___reset", "file__prefix", "routebookexclusive"], "input_path_len": ["input_depth_start", "input_prefix_length", "input_path_length", "input_length_line", "input_path64lf", "input_path_pos", "input_text_val", "input_path_line", "input_length0size", "input_Path_part", "input_prefix_len", "input_text0len", "input_text_length", "input_text0length", "input_path_part", "input_pointer_len", "input_depth_length", "input_text0l", "input_length_len", "input_path2line", "input_path2val", "input_length_length", "input_path2l", "input_path_left", "input_path0len", "input_path2length", "input_length_lf", "input_prefix_le", "input_length_l", "input_path64val", "input_length0val", "input_length_val", "input_Path_len", "input_path_start", "input_path_l", "input_path0val", "input_length_left", "input_path0size", "input_pathvlen", "input_pathvsize", "input_text0val", "input_pointer_Len", "input_pathjleft", "input_Path_l", "input_pathvline", "input_depth_line", "input_path_val", "input_path64size", "input_pointer_l", "input_path0lf", "input_pathvLen", "input_length_size", "input_text_len", "input_path_ln", "input_length0lf", "input_path_size", "input_pathjlen", "input_path0l", "input_path2len", "input_prefix_l", "input_length0len", "input_pointer_ln", "input_pointer_pos", "input_path64len", "input_pathjLen", "input_pointer_length", "input_pathjline", "input_path_lf", "input_path_le", "input_text_l", "input_path0length", "input_path_Len", "input_depth_len", "input_Path_Len", "input_length_pos", "input_length_Len"], "p": ["lp", "l", "dp", "sp", "wp", "up", "start", "n", "g", "prefix", "pad", "m", "bp", "point", "t", "b", "x", "pa", "pp", "i", "c", "cp", "python", "prev", "e", "fp", "np", "pe", "po", "q", "P", "f", "pn", "padding", "op", "primary", "j", "progress", "o", "v", "r", "pr", "pre", "port", "tp", "jp", "patch", "pi", "pc", "u", "ip", "api", "ps", "press", "y", "ap", "vp"], "sb": [" b", "sp", "sg", "sh", "ib", "bb", "std", "ds", "si", "nb", "abb", "sf", "ba", "info", "bp", "src", "b", "wb", "stat", "SB", " eb", "sa", "vm", "fb", "pb", "obj", "cb", "gb", "split", "stab", "rb", " s", "bc", "bt", "db", "bf", "bj", "bg", " sd", "sync", "sl", "lb", "sn", "sth", "sm", "vd", "sd", " ga", " db", "ob", "kb", "sc"]}}
{"project": "qemu", "commit_id": "6350b0904615cc0531cc3059ea34db5c009c88aa", "target": 1, "func": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n", "idx": 12083, "substitutes": {"obj": ["fo", "Object", "val", "nt", "temp", "org", "iv", "ops", "buf", "serv", "Obj", "cb", "attr", "bo", "env", "po", "pt", "coll", "tmp", "op", "os", "orb", "inst", "j", "ev", "inv", "o", "vol", "ctx", "object", "att", "pos", "api", "ob", "rev", "adj"], "v": ["vs", "l", "sv", "vu", "g", "val", "w", "m", "b", "t", "k", "vim", "d", "i", "vt", "c", "ov", "p", "e", "tv", "env", "q", "f", "j", "ev", "o", "uv", "r", "object", "V", "vd", "u", "self", "vv", "vc", "volt", "vp"], "opaque": ["OPec", "OPace", "openac", "opacity", "opusaques", "OPaque", "oppaque", "opac", "oaques", "oaque", "oacity", "opusonymous", "oponymous", "openace", "oppacity", "opusacity", "opusaque", "opponymous", "oppaques", "opace", "opec", "OPac", "operaque", "opaques", "openaque", "operac", "oonymous", "operace", "openec", "operec"], "name": ["parent", "alias", "NAME", "dim", "field", "n", "val", "comment", "prefix", "key", "word", "info", "id", "path", "x", "filename", "pointer", "var", "data", "nam", "time", "names", "attr", "none", "label", "resource", "version", "size", "description", "space", "min", "address", "option", "new", "part", "desc", "error", "property", "type", "image", "Name"], "errp": ["erf", "erp", "resultP", "resultp", " errP", "errorv", "rrb", "rrpr", "arrv", "arrP", "arrpc", "erlp", "erv", "errorp", "errorP", "errorpc", " errlp", "rrp", " erb", "rorlp", "errP", " errb", "errpc", "arrp", "erP", "resultb", " errf", "erpc", "err", "errf", "errlp", "rorp", " erpr", "rorr", " erP", "errpr", "rrP", "errv", "errb", "resultpr", "rorf", " errr", " errpr", " erp", "errr"], "dev": ["diff", "conf", "des", "debug", "fo", "prov", "dom", "val", "prof", "proc", "Dev", "def", "conn", "w", "prom", "info", "temp", "dem", "development", "iv", "adv", "d", "ver", "de", "var", "data", "cd", "pro", "driver", "private", "env", "bug", "rad", "priv", "ev", "device", "pub", "md", "mod", "dc", "node", "dm", "grad", "od", "client", "ow", "wd", "DEV"], "prop": ["conf", "term", "param", "cmp", "nb", "val", "prof", "owner", "key", "def", "info", "prot", "pred", "path", "project", "pointer", "doc", "data", "cp", "config", "p", "ref", "lit", "pb", "pro", "attr", "private", "app", "priv", "tmp", "op", "j", "pkg", "unit", "lib", "opt", " props", "phi", "Prop", "properties", "pr", "ctx", "mod", "option", "part", " property", "property", "plugin", "type", "pod", "cfg", "pos", "ip", "api", "comp", "proc", "typ"], "ptr": ["diff", "Ptr", "dim", "arr", "tr", "len", "val", "pad", "src", "buf", "pointer", "var", "data", "addr", "ref", "pointers", "attr", "pt", "loc", "priv", "tmp", "pert", "code", "size", "alloc", "index", "trace", "pr", "address", "err", " pointer", "offset", "property", "eth", "type", "pair", "vr", "pos", "length", "depth", "fe"], "local_err": ["standardipref", "local_exc", "self_rr", "self_err", "standard_status", "local_ref", " local_mr", "standard_ref", "localipstatus", "localipref", "standard_try", "standardipstatus", "localacref", "standard_err", "standardiptry", "localacstatus", "localacerr", " local_Er", "localeder", "local_Er", "local_status", " local_exc", "local_error", "standardiperr", "self_error", "localederr", "localedexc", " local_er", "localactry", "local_mr", "local_try", "local_rr", "localedEr", "local_er", "localiperr", "localiptry"], "value": ["parent", "media", "ver", "max", "ref", "target", "device", "values", "response", "end", "object", "port", "offset", "type", "volume", "image", "depth", "buffer", "reference", "val", "key", "w", "_", "id", "total", "price", " result", "unit", "index", "format", "current", "min", "position", "pair", "range", "fee", " val", "test", "temp", "src", "buf", "var", "data", "flow", "resource", "size", "version", "feature", "part", "property", "message", "attribute", "result", "VALUE", "diff", "Value", "valid", "balance", "scale", "money", "pointer", "p", "number", "child", "address", "function", "null", "length"]}}
{"project": "qemu", "commit_id": "d7cd369402191814a1bb339a730f3af411e9682f", "target": 1, "func": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 12086, "substitutes": {"opaque": ["mque", "macity", "paque", "obaque", "compaque", "opacity", "compacity", "opac", "ppaque", "ppac", "compque", "ppacity", "pque", "compaques", "obaques", "copacity", "maques", "paques", "obacity", "maque", "pacity", "ppaques", "copaque", "copac", "copaques", "opque", "obac", "opaques"], "co": ["oc", "CO", "aco", "tc", "oo", "ra", "con", "c", "cu", "bo", "cf", "Co", "po", "loc", "coll", "cc", "bc", "ac", "op", "o", "rc", "ctx", "pc", "oid", "oper", "mo", "ico", "ro", "ca", "cm", "coe", "ci", "flo", "lc", "mc", "ko", "fc"]}}
{"project": "FFmpeg", "commit_id": "6a99310fce49f51773ab7d8ffa4f4748bbf58db9", "target": 1, "func": "static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)\n\n{\n\n    int i = 0;\n\n    unsigned int ave_mean;\n\n    s->transient[ch] = get_bits1(&s->gb);\n\n    if (s->transient[ch]) {\n\n        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));\n\n        if (s->transient_pos[ch])\n\n            s->transient[ch] = 0;\n\n        s->channel[ch].transient_counter =\n\n            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);\n\n    } else if (s->channel[ch].transient_counter)\n\n        s->transient[ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 12095, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "v", "full", "ns", "details", "spec", "has", "self", "settings", "sg", "ds", "n", "si", "sites", "sf", "w", "b", "c", "e", "se", "sq", "us", "f", "sym", "sets", "es", "sup", "as", "u", "this", "rates", "sim", "fs", "su", "ps", "site", "ss", "ks", "sv", "g", "features", "stats", "ops", "d", "ys", "ls", "os", "cs", "o", "sync", "sb", "sys", "a", "ssl", "vs", "conf", "ts", "ims", "service", "p", "server", "qs", "ins", "xs", "js", "rs", "aws", "S", "states", "services", "ches", "ms", "less", "h", "ses", "uns"], "ch": ["l", "channel", "img", "arch", "ach", "ich", "ver", "cb", "CH", "sk", "code", "v", "chart", "ce", "cher", "cur", " chunk", "Ch", "change", "form", "ech", "ht", "fr", "chip", "b", "gr", "c", "chu", "work", "chn", "cf", "cho", "f", "j", "th", "cha", "che", "sch", "cl", "col", "cel", "cell", "chan", "sh", "g", "ph", "conn", "cp", "och", "coll", "zh", "bh", "chi", "cat", "vc", "br", "conf", "chrom", "p", "gh", "q", "cht", "chy", "cham", "ches", "cor", "h", "cm", "ci", "y", "cy"], "tile_size": ["chip_length", "component64scale", "component64sized", "tile6count", "layer_count", "tile_count", "tile_sized", "component_length", "component64length", "tile6scale", "component_scale", "tile64scale", "component_size", "chip_scale", "tile64length", "tile1length", "tile1scale", "tile_scale", "tile6size", "tile64sized", "tile6capacity", "tile_capacity", "tile1size", "component_sized", "layer_scale", "chip_size", "layer_size", "tile64size", "component64size", "tile_length", "layer_capacity"], "ave_mean": ["ve_size", "aveXmark", "avethemal", "save_mean", "ave__sum", "ave67mal", "ave67average", "av_mean", "aves_average", "ave_average", "ve_mean", "aves_mean", "aveXaverage", "ave\u00b7mid", "ave__average", "ave_size", "ave_mark", "av_sum", "aveXmal", "ave\u00b7mean", "ve_sum", "avethemean", "aving_sum", "ave_mid", "ve_average", "ave__mean", "ave_mal", "aves_mal", "ave67sum", "ave_sum", "av_average", "ave2mean", "ave\u00b7average", "save_sum", "aving_average", "save_mid", "aving_mal", "ave2sum", "ave2size", "avethemark", "aveXmean", "av__mean", "ave\u00b7sum", "av__average", "ave67mean", "save_average", "ave2average", "aving_mean", "aves_mark", "ave__mal", "av__sum", "avetheaverage", "av__mal", "av_mal"], "i": ["ui", "di", "it", "si", "zi", "xi", "ini", "c", "ji", "p", "uri", "yi", "mini", "ie", "j", "ai", "o", "multi", "slice", "wei", "ind", "ti", "phi", "gi", "mi", "chi", "abi", "qi", "im", "pi", "bi", "ii", "uni", "u", "I", "li", "ip", "ci", "ori", "io", "ni", "ski", "ri", "fi", "iu", "ki"], "rem": ["original", "temp", "prom", "rub", "dem", "rec", "ref", "pri", "reg", "rom", "res", "keep", "remote", "REM", "pull", "orig", "re", "comm", "cm", "change", "extra", "ret", "br", "rm", "pop", "ex"], "rem_bits": ["rem_runs", "rem__bits", "rem_s", "rem_\n", "rem__runs", "rem_locks", "rem_bytes", " rem_s", "rem__locks", " rem_locks", "rem__bytes", " rem_runs", " rem_bytes", " rem_\n"], "residue": ["resinUE", "resigUE", "residUE", "resyue", "residuum", "respicience", "residsuer", "resigance", " residsue", " residience", "Residance", "resyues", "resigue", "residsience", "resyience", "residuer", "Resinuum", "residsues", "residsance", "Resinance", "residsue", "ResinUE", "residsuum", "respicue", "residsUE", " residsues", " residsience", " residsuer", "resinuum", "resyuer", " residuer", "residues", "respicues", "respicuer", "ResidUE", "residance", "Resinue", "residience", "Residuum", "resinue", "resiguum", "resinance", " residues", "Residue"], "quo": ["quoi", "aquo", " qui", "qui", "queos", "Qubo", "Quow", " quoa", "queoo", "heloo", "qo", "Quo", " quoi", "aqui", "quoa", "aquoi", "cloi", "aquoo", "quow", "cloo", "quei", "queoi", " quos", "Quoid", "aquow", "Quoi", " quko", "qoa", "aquoid", "clbo", "Quoo", "quoo", "clos", "helo", " qubo", "queoid", "heloa", "helko", "qubo", " quoo", "aquos", "clo", "queow", "quoid", "quebo", "quko", "quos", "qko", "qoo", "aqubo", "queo"]}}
{"project": "FFmpeg", "commit_id": "405af431040a57c630716b3940d7240021e8b80c", "target": 0, "func": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    CinAudioContext *cin = avctx->priv_data;\n\n    const uint8_t *src = buf;\n\n    int16_t *samples = data;\n\n    int delta;\n\n\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n\n\n    delta = cin->delta;\n\n    if (cin->initial_decode_frame) {\n\n        cin->initial_decode_frame = 0;\n\n        delta = (int16_t)AV_RL16(src); src += 2;\n\n        *samples++ = delta;\n\n        buf_size -= 2;\n\n    }\n\n    while (buf_size > 0) {\n\n        delta += cinaudio_delta16_table[*src++];\n\n        delta = av_clip_int16(delta);\n\n        *samples++ = delta;\n\n        --buf_size;\n\n    }\n\n    cin->delta = delta;\n\n\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n\n\n    return src - buf;\n\n}\n", "idx": 12099, "substitutes": {"avctx": ["afconn", "ajcu", "afctx", "AVcf", "auctrl", "auctx", "AVctrl", "avcf", "AVcontext", "avcu", "afcf", "afcu", "aucf", "avconn", "ajctx", "ajcontext", "AVctx", "AVconn", "avcontext", "avctrl", "ajconn", "AVcu", "aucontext", "afcontext", "afctrl"], "data": ["parent", "diff", "sample", "channel", "seq", "ui", "base", "start", "frames", "len", "val", "source", "media", "window", "da", "pad", "ops", "shift", "block", "config", "batch", "reader", "cb", "mu", "dist", "memory", "frame", "array", "empty", "tmp", "body", "DATA", "next", "la", "dat", "alpha", "size", "slice", "index", "input", "rc", "content", "connection", "raw", "address", "load", "audio", "Data", "blocks", "after", "bytes", "offset", "pos", "message", "a", "video", "image", "result", "cache", "length", "bin", "buff", "beta", "buffer"], "data_size": ["image_capacity", "dataqsized", " data_start", "data_scale", "image_speed", "data_capacity", "data_range", "dataqscale", "image_size", "data_sized", "dataqsize", " data_range", "data_strength", "data_start", " data_strength", " data_sized", " data_scale", "dataqstart", "image_offset", "data_offset", "data_speed"], "avpkt": ["afpacket", "avPkg", "avpacket", "avfacket", "AVpcp", "avlpkg", "avcpacket", "affacket", "afpkg", "avckg", "AVpconn", "avfkt", "avgpconn", "avPct", "AVppcp", "afcpkt", "AVpkg", "afcpct", "avcpkg", "AVppconn", "avpconn", "avfct", "avPkt", "AVppkt", "avcpkt", "avgpkt", "avlpkt", "avpct", "avgpcp", "avppconn", "avlpcp", "avfkg", "avpkg", "afpkt", "avcpct", "afpct", "avgpkg", "affct", "AVpkt", "affkt", "avPacket", "avlpconn", "avppkg", "avpcp", "avcacket", "AVppkg", "avppcp", "afcpkg", "avcct", "affkg", "afcpacket", "avckt", "avppkt"], "buf": ["uf", "seq", "bb", "img", "len", "ff", "pack", "b", "wb", "fi", "block", "fb", "batch", "config", "dest", "cb", "fp", "queue", "cf", "rb", "loc", "array", "tmp", "bc", "alloc", "cv", "ctr", "cap", "rc", "cas", "home", "ctx", "cur", "bus", "front", "bin", "vec", "buff", "cache", "proc", "func", "buffer", "box", "uc"], "src": ["channel", "seq", "img", "proc", "source", "sel", "scene", "low", "pack", "origin", "sur", "b", "bs", "config", "uri", "stream", "dest", "cb", "attr", "split", "gb", "rss", "dist", "rb", "ptr", "loc", "tmp", "prop", "bc", "sec", "inst", "code", "sub", "supp", "slice", "ctr", " dest", "sync", "rc", "sl", "ctx", "sup", "cur", "desc", "blocks", "grad", "url", "comp", "func", "vec", "sit", "seed", "ources", "feat", "uc", "sc", "fc"], "samples": ["pamples", "sample", "damps", " sones", "Sones", "lources", "bamples", "lones", "namps", "psample", "dample", "psannels", "Sannels", "dannels", "bamp", "damples", "sones", "lamples", "bources", "sannels", "pages", "lample", "Samples", "Samps", "upsamp", "psamples", " sources", "sages", "Sample", "bages", "upsages", "sources", "Sources", " sample", "upsources", "pamp", "nample", "pources", "samp", "psamps", "namples", "upsamples", "nannels", "samps"], "delta": ["cta", "dDelta", "indvance", "adelta", "indelta", " denna", "dedDelta", "indagger", "indota", "cynamic", "ddynamic", "Delta", "ddbase", "fenna", "fta", "felta", "dedelt", "sdelt", "dedelta", " dency", "dota", " dta", "advance", "dta", "adta", "Delt", " dota", "sdDelta", " dvance", "adelt", "celta", " dynamic", "dency", "sdelta", "ddelt", "indency", "sdagger", "ddDelta", "dynamic", " dDelta", "ddelta", "adency", "indelt", "fota", "dedbase", "DDelta", "felt", "denna", "dedota", "adota", "ddota", "ddta", "fagger", "dagger", " dbase", "celt", "sdota", "delt", "sdta", "Dota", "dbase", "ddenna", "dvance", " delt"], "buf_size": ["buf_capacity", "seq_weight", "buf64num", "queue_name", "buffer_size", "buf_weight", "buffer_sized", "bufallsec", "uf_cache", "buf_cache", "buf_length", "buf__size", "av_size", "uf_number", "queue_size", "bufallslice", "buffnumber", "bufallsize", "buf_number", "queue_scale", "buf_set", "buf_num", "buf_slice", "uf_scale", "av_SIZE", "buffscale", "buf_scale", "seq_number", "buffcache", "av_capacity", "buf_name", "uf_size", "queue_length", "bufallset", "buf64weight", "buf__scale", "buf64number", "buf_sized", "buf__length", "buf_SIZE", "buffer_set", "buff_set", "buf64size", "seq_size", "buff_sec", "buff_size", "buffer_scale", "seq_num", "buf__name", "buff_slice", "buffsize", "buf_sec", "av_scale"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j, k;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[0];\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + 2]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[0][0];\n\n    my += r->dmv[0][1];\n\n    for(j = 0; j < 2; j++){\n\n        for(i = 0; i < 2; i++){\n\n            for(k = 0; k < 2; k++){\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 12106, "substitutes": {"r": ["l", "tr", "n", "hr", "w", "m", "fr", "mr", "rr", "b", "t", "kr", "gr", "d", "c", "nor", "p", "e", "rss", "ir", "rb", "rs", "er", "f", "dr", "rt", "res", "v", "R", "rc", "ner", "ar", "pr", "err", "nr", "ur", "re", "h", "rg", "result", "sr", "br", "rh"], "block_type": [" blocktypetype", " blocktypetypes", " blocktypefile", "block_file", " blockblockheader", " block_types", " block_file", "block_header", " block_header", " blockblocktype", " blocktypeheader", "block_types", " blockblockfile", " blockblocktypes"], "dir": ["round", "orient", "dim", "def", "w", "src", "path", "rec", "d", "ref", "mode", "Dir", "unit", "lib", "ind", "order", " direction", "sort", "circ", "desc", "ii", "file", "DIR", "cache", "depth", "D", "direction"], "s": ["l", "session", "is", "m", "http", "t", "x", "sci", "z", "gs", "er", "sy", "v", "bis", "ns", "spec", "self", "settings", "sg", "ds", "n", "si", "sf", "w", "b", "ship", "c", "e", "se", "sq", "us", "f", "sym", "sets", "sky", "es", "current", "sup", "en", "u", "fs", "su", "site", "ps", "ss", "sc", "ks", "g", "stats", "d", "ls", "share", "os", "o", "sl", "sb", "sys", "side", "single", "secondary", "a", "sr", "core", "ssl", "setup", "conf", "sports", "ts", "in", "service", "p", "server", "qs", "xs", "rs", "js", "sec", "multi", "S", "services", "less", "h", "ses", "y", "inf"], "A": ["As", "Ca", "AR", "LA", "MA", "At", "BA", "Q", "E", "AU", "This", "Alpha", "Average", "AV", "X", "An", "Action", "AB", "Ar", "AST", "P", "GA", "The", "SA", "G", "N", "T", "S", "AA", "And", "R", "IA", "AT", "Java", "L", "V", "AM", "Y", "Array", " a", "API", "NA", "Data", "HA", "AD", "All", "AW", "Area", "AS", "H", "I", "F", "AP", "U", "a", "AC", "Auth", "Adam", "W", "CA", "Am", "M", "AN", "D", "mA"], "B": ["BR", "GB", "Z", "Block", "BD", "Bo", "BA", "BC", "E", "O", "b", "LB", "BG", "RB", "Base", "X", "But", "BB", "FB", "BE", "AB", "P", "BS", "BI", "G", "T", "N", "QB", "S", "EB", "R", "NB", "WB", "L", "V", "MN", "Y", "BF", "UB", "Both", "H", "Br", "I", "F", "U", "Q", "Bar", "Bl", "W", "Bs", "M", "OB", "D", "DB"], "C": ["Ca", "CC", "SC", "Code", "DC", "BC", "CT", "E", "O", "CV", "GC", "CE", "MC", "Cons", "c", "Cache", "KC", "X", "CU", "VC", "Sc", "P", "YC", "G", "N", "T", "NC", "S", "R", "CS", "V", "L", "CI", "Y", "K", "Cl", "CL", "Col", "H", "Ch", "CW", "F", "Q", "U", "CNN", "CP", "Count", "W", "CA", "EC", "M", "Cu", "D", "Con"], "i": ["it", "n", "m", "b", "x", "z", "d", "c", "p", "e", "ia", "f", "ai", "mi", "phi", "ti", "bi", "pi", "ii", "h", "I", "li", "ip", "ci", "iu"], "j": ["l", "je", "n", "g", "w", "m", "b", "x", "z", "ji", "p", "kj", "q", "uj", "o", "v", "ij", "jp", "ii", "ja", "h", "pos", "J", "y", "jl"], "k": ["dk", "n", "g", "w", "m", "kr", "z", "x", "p", "e", "q", "ak", "f", "sk", "o", "v", "ik", "K", "kw", "u", "h", "y", "mk", "ki", "kk"], "mx": ["me", "mn", " mm", "mos", "hh", "m", " m", "mm", "mu", "wm", "np", "nm", "ml", "yx", "mi", "mmm", "nr", " mc", "ms", "nz", "cm", "rx", "ma", "px", "ng", "ap", "M", "mc"], "my": ["me", "mis", "mn", "mos", "in", "hh", "mr", "mm", "mon", "mu", "np", "mic", "pm", "nm", "mid", "mi", "MY", "md", "am", "Mi", "mmm", "ms", "mo", "mys", "mc", "My", "yo"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n", "idx": 12111, "substitutes": {"aioinit": ["aioi", "aIOinit", "cioinitialized", "cIOinitialized", "cIOi", "aioInit", "aroinitialized", "cIOinit", "aIOi", "aroInit", "cioi", "cioinit", "aroi", "cioInit", "cIOInit", "aioinitialized", "aIOInit", "aIOinitialized", "aroinit"], "ret": ["pass", "std", "flag", "str", "alt", "val", "len", "fail", "class", "key", "comment", "nt", "id", "Ret", "info", " Ret", "num", "pat", "data", "reply", "bd", "ref", "arg", "obj", "lit", "reg", "attr", "usr", "gt", "rets", "code", "rt", "res", "bf", "pub", "py", "det", "try", "opt", "rc", "fun", "att", "pre", "err", "desc", "art", "error", "part", "bit", "fin", "type", "re", "grad", "cat", "RET", "back", "et", "out", "result", "ft", "match", "br", "resp", "feat", "mt", "rl", "success", "pet", "fab"]}}
{"project": "qemu", "commit_id": "2c80e42395bfe0bf291c082f9399431e1ff9d758", "target": 0, "func": "dprint(int level, const char *fmt, ...)\n\n{\n\n    va_list args;\n\n\n\n    if (level <= debug) {\n\n        va_start(args, fmt);\n\n        vfprintf(stderr, fmt, args);\n\n        va_end(args);\n\n    }\n\n}\n", "idx": 12130, "substitutes": {"level": ["context", "debug", "source", "key", "where", "stage", "method", "info", "temp", "id", "tag", "path", "lvl", "line", "time", "limit", "arg", "stack", "local", "value", "style", "loc", "sec", "mode", "code", "call", "trace", "index", "scope", "inc", "format", "Level", "function", "levels", "col", "type", "layer", "lock", "message", "file", "depth", "vel"], "args": ["vals", "arr", "argument", "debug", "str", "active", "len", "val", "members", "ax", "stats", "alls", "actions", "missing", "x", "ages", "gs", "data", "line", "config", "arg", "obj", "parts", "stack", "action", "lines", "array", "empty", "parser", "cs", "call", "size", "py", "parse", "v", "ig", "format", "flags", "ars", "ras", "fun", "function", "err", " arguments", "groups", "spec", "Args", "this", "type", "params", "options", "extra", "a", "func", "cmd", "help", "atts", "events"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n", "idx": 12133, "substitutes": {"hotplug_dev": ["hotplugin_def", "hotplugin_ev", "hotplug_def", "hotplug_ev", "hotplugin_device", "hotplug_device", "hotplugin_dev"], "dev": ["diff", "conf", "kind", "gu", "di", "debug", "dom", "comment", "Dev", "w", "conn", "def", "info", "die", "prom", "development", "dem", "adv", "d", "ver", "de", "data", "server", "app", "pro", "driver", "bug", "priv", "rad", "nov", "ev", "device", "v", "state", "md", "mod", "err", "user", "dc", "error", " Dev", "spec", "grad", "engine", "cmd", "DEV"], "errp": ["erp", "rrp", "errap", "rrip", " errerror", "rrerror", "errerror", "erip", " errip", "rrap", "errip", "erap", " errap", "ererror"], "pci_dev": ["pcu_server", "pci_div", "pci__dev", "pdi_mod", "pci_mod", "pcf_home", "pci_de", "pcf_device", "pcu_ev", "pciOserial", "pdi_div", "pdi_dev", "pcu_device", "pci00ev", "pci__ev", "pci_home", "pci00device", "pcf_dev", "pci00dev", "ppi_def", "pci_server", "pci_device", "pciOdev", "pci_serial", "pci__de", "ppi_de", "pciOhome", "pci_def", "pcf_serial", "ppi_device", "pcu_dev", "pcu_def", "ppi_dev", "pciOdevice", "pci__def", "pci00server", "pci_ev", "pci__device", "pdi_server", "pdi_device"], "pbdev": ["pbconf", "pcDEV", "pgdevice", "lpapp", "ebbug", "fbdiff", "pbbug", "pcdevelopment", "lbdebug", "bpconf", "pbdevice", "ebdevice", "lpdev", "PBdi", "lpcomment", "pberror", "pbdi", "pcdevice", "pcdebug", "pgcomment", "PBver", "lpdiv", "ebvar", "pgapp", "pbDEV", "wpbug", "pbdevelopment", "sbdebug", "ebdev", "pcdiv", "lpvalid", "lbdiv", "bmdevelopment", "bmdev", "sbdiv", "fbdev", "lpdebug", "cbDEV", "pbserial", "bpDEV", "PBconn", "lpdef", "labcomment", "pcdev", "sbdevice", "pbdef", "pgdevelopment", "sbdev", "pgdev", "labtest", "pbtest", "pgdef", "sbconn", "lbDEV", "pgver", "lbdata", "labvalid", "lpdata", "pcver", "lbver", "ppDEV", "bmdevice", "pbver", "pcdiff", "bpdev", "labdevice", "cbserial", "lbdiff", "fbdevelopment", "pgtest", "ppserial", "PBdiff", "lpdevelopment", "lpserial", "PBdata", "labdevelopment", "lpdiff", "pbapp", "lbconf", "PBdev", "wpvar", "lbdev", "bpdebug", "labdiff", "wpdev", "pbvalid", "pbvar", "cbdevice", "pbconn", "lbdevice", "cbdev", "lperror", "labdev", "sbdi", "PBdef", "pbdiv", "pbdata", "fbdevice", "bmerror", "lpdevice", "PBdevelopment", "fberror", "bpdi", "lbdevelopment", "lbvar", "bpdiv", "PBdevice", "lbdef", "PBdiv", "ppdevice", "pbdebug", "lbbug", "pbcomment", "pgvalid", "ppdev", "bpconn", "lpver", "pbdiff", "lptest", "PBapp", "lpDEV", "wpdevice", "pcconf"], "s": ["session", "sg", "ds", "n", "g", "start", "w", "m", "t", "b", "d", "i", "service", "c", "p", "server", "e", "sq", "f", "resource", "o", "S", "v", "sync", "south", "sl", "services", "r", "ns", "sb", "side", "params", "a", "ss", "ssl"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12134, "substitutes": {"opaque": ["opacity", "OPaque", "oppaque", "opicit", "ospaque", "ospicit", "OPicit", "opericit", "operacity", "ospaques", " opace", "OPaques", " opaques", " ophole", "oppace", "operhole", "oppaques", "opace", "opphole", "ospacity", "ophole", "operaque", "opaques", "OPacity", "operaques", "operace"], "addr": ["mac", "adr", "seq", "cmp", "start", "str", "len", "val", "ord", "ext", "pad", "id", "conn", "src", "x", "pointer", "lvl", "data", "ad", "ref", "config", "p", "slot", "cb", "ace", "ptr", "loc", "mode", "dr", "padding", "host", "rt", "code", "index", "oa", "slice", "flags", "amp", "name", "rc", "align", "r", "address", "nr", "part", "sb", "hop", "offset", "asm", "enc", "eth", "type", "layer", "pos", "rx", "ip", "sid", "mt", "cmd", "sr", "nn"], "size": [" c", " bytes", "len", " mode", "val", "w", "SIZE", "i", "data", "c", "e", "Size", "mode", " length", "shape", "rc", "state", "ctx", "address", "offset", "bytes", "length", " sizes", "ize", "ss"], "s": ["conf", "session", "ts", "is", "n", "g", "si", "sf", "w", "m", "stats", "b", "ops", "gs", "c", "p", "ls", "e", "rs", "sq", "socket", "f", "os", "cs", "o", "S", "scope", "es", "v", "states", "r", "ns", "sb", "sys", "h", "ips", "fs", "ses", "ps", "ss"]}}
{"project": "qemu", "commit_id": "c471ad0e9bd46ca5f5c9c796e727230e043a091d", "target": 0, "func": "static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n", "idx": 12142, "substitutes": {"dev": ["diff", "conf", "gu", "dim", "valid", "debug", "g", "Dev", "w", "def", "temp", "prom", "info", "game", "dem", "ve", "adv", "d", "de", "data", "ad", "block", "p", "app", "gh", "bug", "rad", "serial", "mid", "ev", "device", "v", "order", "end", "mod", "user", "patch", "error", "enc", "self", "client", "ch", "DEV", "exec"], "start_addr": ["start_asm", "end_addr", "start64address", "startflayer", "startford", "start_adr", "start_hop", "startfaddress", "end_asm", "start_address", "start64addr", "start_gru", "startfaddr", "end_hop", "start64hop", "start_ord", "end_gru", "end_address", "end_ord", "end_layer", "start64asm", "end_adr", "start_layer"], "size": ["iz", "ui", "timeout", "score", "scale", "si", "g", "capacity", "speed", "small", "sw", "z", "SIZE", "send", "shift", "c", "sum", "s", "max", "time", "se", "e", "number", "loc", "Size", "empty", "large", "sec", "unit", "ice", "shape", "sync", "name", "sized", "end", "address", "sn", "any", "storage", "cm", "esc", "extra", "use", "length", "fee", "ize", "security", "news"], "i": ["l", "ui", "di", "it", "start", "n", "si", "in", "zi", "m", "xi", "id", "b", "x", "k", "z", "ini", "d", "c", "ji", "s", "p", "e", "yi", "q", "eni", "f", "ie", "ai", "o", "index", "v", "gi", "ti", "ind", "r", "qi", "im", "err", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "a", "ni", "io", "y", "ri", "iu"], "j": ["l", "je", "it", "adj", "n", "w", "m", "fr", "jet", "k", "x", "b", "z", "t", "d", "job", "ji", "c", "p", "jo", "obj", "e", "el", "q", "js", "er", "f", "ie", "rt", "uj", "o", "bj", "v", "jit", "r", "err", "ij", "jp", "jl", "ii", "ja", "aj", "h", "u", "pos", "li", "row", "J", "ni", "rev", "y", "jc", "ch", "jj", "br", "dy"], "part_name": ["part_num", "Part_names", "part_value", "part_names", "partfullname", "partCkey", "partfullkey", "part_code", "part_description", "partCname", "partfulldescription", "partPvalue", "partCvalue", "partPname", " part_code", "partPcode", "Part_name", "partPkey", "partCcode", " part_key", "Part_num", " part_description", " part_value", "part_key"], "vq": ["ovdq", "fqa", "varix", " vue", "vinqu", "vid", "ovque", "lch", "vql", "svcl", "zp", "ovg", "zq", " vqa", "verdq", "vdq", "lqa", " vql", "gq", "eviq", "vque", "vqu", "zqu", "svue", "vp", "varq", " vque", "varque", "evque", "vqa", " vqs", "avq", "zph", " vg", "ovqi", "lg", "vch", " vch", "vcl", "lue", "ovid", "verque", "ervql", " vk", "avg", "svqs", "bq", "vg", "evdq", "svquery", "evq", " vid", "ovq", "ervk", "bqa", "vinq", "veriq", "vincharge", "varquery", "vquery", "varcl", "sviq", "svdq", "bqs", "vqi", "avquery", "fck", "vph", "lqs", "gqs", "ervq", "svque", "bck", "gqa", " vix", "svch", " vqu", "vcharge", "avque", "avqi", "svq", "verq", "vue", "ovue", "ovcharge", "varql", " vp", "viq", "vark", "fq", " vqi", "svqa", "vk", " vcharge", "gg", " vdq", "lq", "svck", " vph", "fqs", "vinp", "vix", "vinph", "ervix", "ovqu", "vck", "vqs", "svid", "avcl"]}}
{"project": "qemu", "commit_id": "3435f39513a104294b5e3bbf3612047028d25cfc", "target": 0, "func": "void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t offset;\n\n    int flags;\n\n    void *area, *vaddr;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 12145, "substitutes": {"addr": ["setup", "alias", "adr", "Address", "seq", "arr", "base", "location", "ack", "active", "len", "section", "ord", "prefix", "region", "alt", "src", "open", "pointer", "ref", "add", " address", "coord", "ace", "attr", "amd", "ptr", "loc", "frame", "args", "array", "padding", "dr", "mode", "host", "code", "db", "ha", "slice", "shape", "amp", "route", "oa", "order", "rc", "name", "align", "remote", "state", "address", "node", "layer", "pos", "ip", "url", "arrow", "buffer"], "length": ["count", "l", "base", "section", "pad", "path", "angle", "loc", "body", "code", "duration", "end", "port", "type", "form", "row", "url", "text", "total", "limit", "Length", "large", "sequence", "padding", "slice", "format", "distance", "limited", "load", "position", "layer", "build", "partial", "join", "range", "seq", "ext", "len", "collection", "ptr", "style", "host", "size", "shape", "L", "part", "available", "tail", "level", "valid", "capacity", "ength", "filename", "line", "number", "child", "name", "address", "null", "loop", "match", "family"], "block": ["map", "un", "Block", "session", "byte", "base", "ack", "section", "comment", "record", "def", "view", "board", "point", "blocking", "container", "panel", "job", "line", "config", "ref", "work", "run", "exec", "number", "frame", "group", "flow", "network", "none", "bc", "label", "unit", "device", "bl", "slice", "name", "space", "clock", "event", "wall", "object", "pre", "address", "blocks", "error", "list", "node", "plugin", "link", "type", "lock", "ip", "row", "image", "cache", "down", "buffer", "box", "range", "chain"], "offset": ["count", "alias", "seq", "location", "timeout", "base", "delay", "initial", "start", "len", "prefix", "info", "origin", "shift", "pointer", "phase", "slot", "adding", "limit", "ref", "adjust", "layout", "target", "skip", "number", "ptr", "loc", "array", "off", "next", "padding", "entry", "host", "alpha", "o", "index", "alloc", "size", "slice", "order", "connection", "align", "address", "port", "part", "position", "error", "type", "layer", "pos", "gap", "Offset", "range", "fee"], "flags": ["count", "tags", "styles", "utils", "strings", "links", "parts", "xml", "lag", "errors", "plugins", "fl", "Flags", "shared", "state", " Flags", "codes", "groups", "details", "type", "ips", "forces", "settings", "atts", "vals", "lf", "flag", "aps", "sf", "ils", "s", "bits", "args", "lines", "pages", "types", "f", "padding", "FLAG", "rules", "tracks", "format", "properties", "ags", "locks", "blocks", "bytes", "allows", "this", "comments", "fs", "fee", "frames", "len", "features", "stats", "mods", "alls", "ages", "ops", "rights", "lists", "data", "ants", "offs", "size", "items", "ats", "als", "ases", "level", "rows", "fields", "files", "ports", "mask", "relations", "planes", "states", "els", "faces", "options", "feat", "events"], "area": ["alias", "sea", "atter", "va", "location", "ui", "base", "ATA", "up", "scale", "section", "access", "media", "region", "ba", "usa", "instance", "shadow", "ra", "data", "apa", "qa", "ata", "aaa", "memory", "aster", "array", " areas", "loc", "mode", "la", "alpha", "ha", "size", "oa", "AA", "issa", "name", "space", "state", "item", "object", "address", "az", "part", "storage", "radius", "Area", "aria", "layer", "aa", "handler", "ca", "volume", "a", "gap", "image", "range"], "vaddr": ["faddr", "waddr", "wenter", "venter", " vrf", "Verror", " vserver", "svaddr", "svaddress", "vhost", "vserver", "vattr", "woffset", "varea", "svattr", "lvarea", "lvoffset", "Vhost", "vnode", "svoffset", "voffset", " vhost", " vnode", "lserver", "hrf", "lerror", "fadd", " vaddress", "wattr", " varea", "vadd", "fadr", "Vserver", "evhost", "wmac", "fhost", " voffset", "frf", "evaddress", "evnode", "svhost", "svadr", "foffset", "vadr", "whost", "videoaddress", "wadr", "faddress", "vrf", "vmac", "videonode", "hhost", "videoenter", "vaddress", " venter", "verror", "lvaddress", " vmac", "eventer", "laddr", "lvaddr", "sventer", "haddress", "Vaddr", "Vaddress", "Varea", "fmac", "evadd", "waddress", "evaddr", " vattr", "videoaddr", "Vadd", "Voffset", "laddress", " verror", "haddr"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n", "idx": 12182, "substitutes": {"obj": ["map", "std", "img", "str", "alt", "Object", "class", "id", "src", "instance", "data", "Obj", "cb", "po", "act", "args", "pt", "js", "ass", "tmp", "rb", "inst", "j", "o", "lib", "module", "oa", "name", "ctx", "object", "mod", "ns", "oid", "art", "node", "init", "type", "pos", "func", "so"]}}
{"project": "FFmpeg", "commit_id": "1846a3eac854799fbffc9669dcf4de558b917957", "target": 0, "func": "static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx,\n\n                                      AVCodecContext *avctx,\n\n                                      int fallback_allowed)\n\n{\n\n    AVVAAPIDeviceContext *hwctx = ctx->device->hwctx;\n\n    AVVAAPIHWConfig *hwconfig = NULL;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    VAStatus vas;\n\n    int err, i, j;\n\n    int loglevel = fallback_allowed ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    const AVCodecDescriptor *codec_desc;\n\n    const AVPixFmtDescriptor *pix_desc;\n\n    enum AVPixelFormat pix_fmt;\n\n    VAProfile profile, *profile_list = NULL;\n\n    int profile_count, exact_match, alt_profile;\n\n\n\n    codec_desc = avcodec_descriptor_get(avctx->codec_id);\n\n    if (!codec_desc) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    profile_count = vaMaxNumProfiles(hwctx->display);\n\n    profile_list = av_malloc(profile_count * sizeof(VAProfile));\n\n    if (!profile_list) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaQueryConfigProfiles(hwctx->display,\n\n                                profile_list, &profile_count);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, loglevel, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    profile = VAProfileNone;\n\n    exact_match = 0;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vaapi_profile_map); i++) {\n\n        int profile_match = 0;\n\n        if (avctx->codec_id != vaapi_profile_map[i].codec_id)\n\n            continue;\n\n        if (avctx->profile == vaapi_profile_map[i].codec_profile)\n\n            profile_match = 1;\n\n        profile = vaapi_profile_map[i].va_profile;\n\n        for (j = 0; j < profile_count; j++) {\n\n            if (profile == profile_list[j]) {\n\n                exact_match = profile_match;\n\n                break;\n\n            }\n\n        }\n\n        if (j < profile_count) {\n\n            if (exact_match)\n\n                break;\n\n            alt_profile = vaapi_profile_map[i].codec_profile;\n\n        }\n\n    }\n\n    av_freep(&profile_list);\n\n\n\n    if (profile == VAProfileNone) {\n\n        av_log(ctx, loglevel, \"No VAAPI support for codec %s.\\n\",\n\n               codec_desc->name);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    if (!exact_match) {\n\n        if (fallback_allowed || !hwaccel_lax_profile_check) {\n\n            av_log(ctx, loglevel, \"No VAAPI support for codec %s \"\n\n                   \"profile %d.\\n\", codec_desc->name, avctx->profile);\n\n            if (!fallback_allowed) {\n\n                av_log(ctx, AV_LOG_WARNING, \"If you want attempt decoding \"\n\n                       \"anyway with a possibly-incompatible profile, add \"\n\n                       \"the option -hwaccel_lax_profile_check.\\n\");\n\n            }\n\n            err = AVERROR(EINVAL);\n\n            goto fail;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"No VAAPI support for codec %s \"\n\n                   \"profile %d: trying instead with profile %d.\\n\",\n\n                   codec_desc->name, avctx->profile, alt_profile);\n\n            av_log(ctx, AV_LOG_WARNING, \"This may fail or give \"\n\n                   \"incorrect results, depending on your hardware.\\n\");\n\n        }\n\n    }\n\n\n\n    ctx->va_profile = profile;\n\n    ctx->va_entrypoint = VAEntrypointVLD;\n\n\n\n    vas = vaCreateConfig(hwctx->display, ctx->va_profile,\n\n                         ctx->va_entrypoint, 0, 0, &ctx->va_config);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to create decode pipeline \"\n\n               \"configuration: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    hwconfig = av_hwdevice_hwconfig_alloc(ctx->device_ref);\n\n    if (!hwconfig) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    hwconfig->config_id = ctx->va_config;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->device_ref,\n\n                                                      hwconfig);\n\n    if (!constraints)\n\n        goto fail;\n\n\n\n    // Decide on the decoder target format.\n\n    // If the user specified something with -hwaccel_output_format then\n\n    // try to use that to minimise conversions later.\n\n    ctx->decode_format = AV_PIX_FMT_NONE;\n\n    if (ctx->output_format != AV_PIX_FMT_NONE &&\n\n        ctx->output_format != AV_PIX_FMT_VAAPI) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            if (constraints->valid_sw_formats[i] == ctx->decode_format) {\n\n                ctx->decode_format = ctx->output_format;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (output \"\n\n                       \"format).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise, we would like to try to choose something which matches the\n\n    // decoder output, but there isn't enough information available here to\n\n    // do so.  Assume for now that we are always dealing with YUV 4:2:0, so\n\n    // pick a format which does that.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            pix_fmt  = constraints->valid_sw_formats[i];\n\n            pix_desc = av_pix_fmt_desc_get(pix_fmt);\n\n            if (pix_desc->nb_components == 3 &&\n\n                pix_desc->log2_chroma_w == 1 &&\n\n                pix_desc->log2_chroma_h == 1) {\n\n                ctx->decode_format = pix_fmt;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (format \"\n\n                       \"matched).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise pick the first in the list and hope for the best.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        ctx->decode_format = constraints->valid_sw_formats[0];\n\n        av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (first in list).\\n\",\n\n               av_get_pix_fmt_name(ctx->decode_format));\n\n        if (i > 1) {\n\n            // There was a choice, and we picked randomly.  Warn the user\n\n            // that they might want to choose intelligently instead.\n\n            av_log(ctx, AV_LOG_WARNING, \"Using randomly chosen decode \"\n\n                   \"format %s.\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n        }\n\n    }\n\n\n\n    // Ensure the picture size is supported by the hardware.\n\n    ctx->decode_width  = avctx->coded_width;\n\n    ctx->decode_height = avctx->coded_height;\n\n    if (ctx->decode_width  < constraints->min_width  ||\n\n        ctx->decode_height < constraints->min_height ||\n\n        ctx->decode_width  > constraints->max_width  ||\n\n        ctx->decode_height >constraints->max_height) {\n\n        av_log(ctx, AV_LOG_ERROR, \"VAAPI hardware does not support image \"\n\n               \"size %dx%d (constraints: width %d-%d height %d-%d).\\n\",\n\n               ctx->decode_width, ctx->decode_height,\n\n               constraints->min_width,  constraints->max_width,\n\n               constraints->min_height, constraints->max_height);\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n\n\n    // Decide how many reference frames we need.  This might be doable more\n\n    // nicely based on the codec and input stream?\n\n    ctx->decode_surfaces = DEFAULT_SURFACES;\n\n    // For frame-threaded decoding, one additional surfaces is needed for\n\n    // each thread.\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n        ctx->decode_surfaces += avctx->thread_count;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n    vaDestroyConfig(hwctx->display, ctx->va_config);\n\n    av_freep(&profile_list);\n\n    return err;\n\n}\n", "idx": 12190, "substitutes": {"ctx": ["cam", "context", "cmp", "Context", "cca", "conn", "tc", "fw", "c", "ct", "cp", "config", "component", "cb", "cli", "cf", "cn", "wcs", "loc", "hw", "cc", "bc", "cs", "ctrl", "console", "cv", "ck", "sync", "rc", "cas", "tx", "pc", "xc", "kw", "cms", "gc", "nc", "ca", "cm", "client", "ci", "vc", "lc", "anc", "cus", "kb", "sc", "fc"], "avctx": ["afctx", "AVcf", "AVconfig", "navctx", "aftx", "AVtx", "ovcu", "avectx", " avtx", "avecu", "avcf", "hwcontext", "navconn", "AVcontext", "avcu", "verctx", "ovctx", "vercontext", "avconn", "ovcontext", "afconfig", "AVctx", "AVconn", "avconfig", " avcontext", "verconn", "avcontext", "ovconn", "navcf", "hwcf", "navcontext", "aveconn", "hwconn", "avecontext", "avtx", "afcontext", " avconfig", "hwcu", "vercf"], "fallback_allowed": ["fallback_allow", "fallback_expected", "fallback_allows"], "hwctx": ["iwconfig", "navctx", "rwcf", "fwc", "hawloc", "fwctx", "fwcontext", "hawctx", "fwloc", "hwc", "hwcontext", "hawconfig", "iwcontext", "navconn", "fwconn", "hwloc", "hwcmp", "iwconf", "fwcf", "iwctx", "rwctx", "hwconf", "hawcontext", "fwconf", "rwcmp", "navcf", "hwcf", "wxctx", "navcmp", "navcontext", "fwconfig", "hawconf", "hwconn", "iwc", "hawconn", "wxcontext", "rwcontext", "navloc", "wxconfig", "fwcmp", "wxc"], "hwconfig": ["hawcontext", "hawconfig", "hwclient", "rwConfig", "hwcontext", "hawConfig", "rwcontext", "fwclient", "hawclient", "hwConfig", "fwcontext", "fwconfig", "rwclient", "fwConfig", "rwconfig"], "constraints": ["constraint", "concontaints", "concontures", "Conctaint", "Conctants", "concontants", "constructures", "conctants", "constructaints", "constructaint", "construres", "concontaint", "constructants", "conctaints", "Constraints", "constrants", "Constraint", "Conctures", "conctaint", "conctures", "Construres", "Conctaints", "Constrants"], "vas": ["pse", "mis", " CS", "board", "opus", "wt", " img", "bridge", "Stage", " va", "wcs", "cas", "Va", "cal", "pic", " dc", "miss", "bus", "av", "FIG", "fi", "ba", "stage", " cs", "capt", "iss", "draw", "layout", "browser", "cf", "jas", "Bus", "VR", "hea", "nas", "fs", "pas", "gap", "ss", "cus", "AS", "rus", "fg", "di", "wp", "sv", "str", "BA", "usa", "ops", "buf", "fal", "cs", "catch", "shape", "CS", "las", "tx", "jp", " bus", "ja", "cache", "vs", " canvas", " var", "va", "ta", "auc", " pic", "isi", "qa", "vis", "cv", "sts", "pc", "fig", "css", "aka", "feat"], "err": ["cr", "acer", "ler", "arr", "str", "hr", "rage", "test", "hide", "fr", "mr", "rr", "kr", "gr", "ver", "var", "line", "Error", "fy", "late", "status", "wr", "act", "bug", "style", "aster", "ir", "er", "dr", "code", "progress", "msg", "ner", "ar", "pr", "req", "ise", "r", "error", "grade", "init", " error", "der", "header", "result", "cache", "Er", "br", "resp", "feat", "rh", "fi"], "i": ["oi", "l", "ui", "di", "it", "start", "n", "si", "g", "in", "zi", "source", "id", "info", "xi", "m", "ami", "b", "ini", "z", "d", "c", "ji", "p", "ix", "uri", "e", "yi", "eni", "f", "ie", "ai", "multi", "index", "slice", "v", "gi", "mi", "ti", "ik", "phi", "inner", "qi", "jp", "pi", "bi", "part", "ii", "init", "u", "h", "I", "li", "ip", "ci", "ni", "io", "y", "lc", "ri", "fi", "iu", "ki"], "j": ["count", "l", "je", "img", "section", "m", "z", "device", "fl", "bl", "v", "J", "n", "note", "key", "_", "all", "fr", "jet", "k", "b", "s", "jo", "e", "f", "jit", "this", "u", "li", "ni", "jl", "adj", "g", "num", "d", "uj", "o", "jp", "ja", "cat", "br", "job", "ji", "other", "p", "jam", "obj", "q", "js", "ij", "aj", "h", "pos", "y", "jj"], "codec_desc": ["codecsdesc", "codac2des", "codec2Desc", "codac2description", "codec2doc", "codec2description", "codef_desc", "codec_Desc", "codec_doc", "codac_desc", "codef_def", "codecsDesc", "codac_doc", "codac_description", "codac_des", "codec2desc", "codec_def", "codef_dec", "codef_doc", "codec_dec", "codec2dec", "codef_Desc", "codef_description", "codac2doc", "codecsdescription", "codecsdec", "codec_des", "codac2desc", "codec_description", "codec2des"], "pix_desc": ["pix2description", "pix2def", "pico2def", "pix2desc", "pico2desc", "pico2description", "pico_description", "pix_Desc", "pico_def", "pico2Desc", "pix_def", "pico_desc", "pix_description", "pico_Desc", "pix2Desc"], "pix_fmt": ["pix_Fmt", "pix_fld", "pix_gformat", "pix_sfld", "pix_Fnt", "pix_fformat", "pix_gnt", "pix_Fld", "pix_sfnt", "pix_fnt", "pix_Fformat", "pix_gmt", "pix_sfmt", "pix_gld", "pix_sfformat"], "profile": ["pse", "session", "base", "mobile", "section", "theme", "panel", "pool", "environment", "config", "facebook", "np", "thin", "connection", "object", "port", "phone", "details", "choice", "type", "knife", "interface", "image", "person", "definition", "settings", "picture", "alias", "pocket", "figure", "template", "instance", "component", "layout", "role", "pe", "shield", "title", "Profile", "module", "account", "plugin", "file", "header", "member", "prof", "class", "model", "public", "page", "data", "ahi", "style", "ana", "cache", "character", "info", "display", "filename", "shadow", "job", "service", "line", "username", "number", "name", "user", "summary", "platform", "match", "family", "face"], "profile_list": [" profile_List", "profile__List", "photo_map", "profile_List", " profile_LIST", "photo_length", " profile_table", "profileingid", "photo_lists", "Profile_List", "profileingset", " profile_map", "profile_LIST", "Profile_list", "profile5lists", "photo_list", "profile_set", "profile_table", "profile_length", "character_set", "character_list", "profile_id", "Profile_id", "character_id", "profileingLIST", "profile5map", "profile_lists", "profile5list", "profile__id", "profileinglist", "profile2map", "profile2List", "profileingtable", "profile5length", "Profile_len", "profile__list", "profile__len", "profile2list", "profile_map", "profile_len", "profileingcount"], "profile_count": ["profile_match", "line_array", "profile_array", "character_count", "phone_len", "profile64limit", "phone_count", "profile16count", "theme_count", "line_length", "profile64count", "profile_sum", "profileXlist", "theme_limit", "phone_match", "line_list", "profile__count", "profileXstate", "profileXcount", "profile__match", "profile_length", "theme16match", "character_length", "profileXlength", "theme_match", "profile16match", "profile_state", "profile_limit", "theme16count", "theme_list", "line_state", "theme16list", "line_count", "profile16list", "profile64match", "theme16limit", "profile__len", "profile16limit", "profile64list", "profile_len", "character_sum"], "exact_match": ["exact_group", "expect_sum", "exact_message", "exet_group", "expect_count", "exact_count", "exact64message", "exact64sum", "exact64count", "exact_cmp", "exact_sum", "exet_match", "expect_message", "expect_match", "exet_count", "exact64match", "exet_cmp"], "alt_profile": ["altregprofile", "altregconfig", "alt_config", "altresconfig", "la_config", "la_summary", "altregusername", "alt_summary", "la_profile", "altressummary", "altresprofile", "altresusername", "alt_username", "altregsummary", "la_username"]}}
{"project": "FFmpeg", "commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "target": 0, "func": "static int parse(AVCodecParserContext *ctx,\n\n                 AVCodecContext *avctx,\n\n                 const uint8_t **out_data, int *out_size,\n\n                 const uint8_t *data, int size)\n\n{\n\n    VP9ParseContext *s = ctx->priv_data;\n\n    int marker;\n\n\n\n    if (size <= 0) {\n\n        *out_size = 0;\n\n        *out_data = data;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (s->n_frames > 0) {\n\n        *out_data = data;\n\n        *out_size = s->size[--s->n_frames];\n\n        parse_frame(ctx, *out_data, *out_size);\n\n\n\n        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;\n\n    }\n\n\n\n    marker = data[size - 1];\n\n    if ((marker & 0xe0) == 0xc0) {\n\n        int nbytes = 1 + ((marker >> 3) & 0x3);\n\n        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;\n\n\n\n        if (size >= idx_sz && data[size - idx_sz] == marker) {\n\n            const uint8_t *idx = data + size + 1 - idx_sz;\n\n            int first = 1;\n\n\n\n            switch (nbytes) {\n\n#define case_n(a, rd) \\\n\n            case a: \\\n\n                while (n_frames--) { \\\n\n                    int sz = rd; \\\n\n                    idx += a; \\\n\n                    if (sz > size) { \\\n\n                        s->n_frames = 0; \\\n\n                        av_log(avctx, AV_LOG_ERROR, \\\n\n                               \"Superframe packet size too big: %d > %d\\n\", \\\n\n                               sz, size); \\\n\n                        return AVERROR_INVALIDDATA; \\\n\n                    } \\\n\n                    if (first) { \\\n\n                        first = 0; \\\n\n                        *out_data = data; \\\n\n                        *out_size = sz; \\\n\n                        s->n_frames = n_frames; \\\n\n                    } else { \\\n\n                        s->size[n_frames] = sz; \\\n\n                    } \\\n\n                    data += sz; \\\n\n                    size -= sz; \\\n\n                } \\\n\n                parse_frame(ctx, *out_data, *out_size); \\\n\n                return *out_size\n\n\n\n                case_n(1, *idx);\n\n                case_n(2, AV_RL16(idx));\n\n                case_n(3, AV_RL24(idx));\n\n                case_n(4, AV_RL32(idx));\n\n            }\n\n        }\n\n    }\n\n\n\n    *out_data = data;\n\n    *out_size = size;\n\n    parse_frame(ctx, data, size);\n\n\n\n    return size;\n\n}\n", "idx": 12192, "substitutes": {"ctx": ["mac", "cam", "context", "cmp", "Context", "cca", "conn", "tc", "sci", "c", "cp", "config", "cu", "cb", "cf", "lex", "wcs", "loc", "sq", "coll", "hw", "cc", "bc", "pkg", "cs", "ctrl", "ha", "cv", "ck", "sync", "rc", "cas", "conv", "cal", "ga", "tx", "kt", "jp", "pc", "xc", "nc", "grad", "ca", "cm", "vc", "anc", "lc", "crit", "cmd", "cus", "kb", "sc", "exec"], "avctx": ["avcv", "avcontext", "awctx", "AVcv", "aircontext", "AVcontext", "airctx", "avscl", "AVctx", "awcv", "aircv", "airscl", "AVscl", "awcontext", "awscl"], "out_data": ["outlexvalue", "out_source", "in_sample", "out_bytes", "out_scale", "outlexsize", "in_bytes", "outlexsource", "in_size", "out_sample", "in_window", "in_value", "out___size", "outingsize", "outPdata", "outPwindow", "in_cache", "in_resources", "outingdata", "in_source", "in_content", "outingbytes", "out_content", "out_window", "out_value", "outPsize", "outlexdata", "out_resources", "out___resources", "in_scale", "out___cache", "in_data", "outPscale", "out_cache", "outingsample", "out___data"], "out_size": ["out_storage", "out__scale", "outlexsum", " out_rate", "out_rate", "out__sum", " out_storage", "out_scale", "outNsized", "outlexsize", "out_sum", " out_scale", "in_size", "in_width", " out_width", "outNnumber", "out__size", "out_number", " out_capacity", "out64data", " out_len", "out64sized", "outlexscale", "out_sized", "out__storage", "outNsize", "out_len", " out_sum", "in_status", " out_number", "out_status", "out64size", " out_length", "outlexrate", " out_sized", "outNdata", "out_length", "in_data", "out_width", "out_capacity", "out64number"], "data": ["parent", "media", "record", "pad", "config", "package", "memory", "frame", "body", "none", "code", "values", "response", "content", "first", "offset", "change", "ma", "image", "buffer", "timeout", "date", "da", "missing", "i", "draw", "meta", "value", "DATA", "zero", "slice", "index", "input", "load", "Data", "storage", "bytes", "li", "one", "map", "zip", "sample", "source", "d", "array", "dat", "alpha", "resource", "raw", "done", "new", "message", "a", "result", "cache", "area", "byte", "scale", "start", "window", "batch", "p", "reader", "number", "empty", "next", "multi", "address", "results", "dd", "video", "length"], "size": ["count", "channel", "fail", "again", "word", "z", "SIZE", "shift", "sum", "max", "set", "loc", "frame", "body", "code", "content", "end", "grade", "offset", "type", "form", "row", "image", "iz", "timeout", "si", "n", "no", "go", "id", "i", "c", "work", "se", "e", "value", "or", "large", "group", "unit", "slice", "sized", "en", "load", "storage", "position", "error", "li", "file", "complete", "fee", "member", "len", "g", "handle", "second", "small", "page", "send", "from", "flow", "mode", "shape", "column", "sync", "raw", "sn", "new", "enc", "message", "engine", "ize", "area", "scale", "capacity", "pack", "line", "time", "p", "number", "empty", "Size", "sec", "name", "six", "address", "false", "cm", "pos", "gz", "length"], "s": ["l", "conf", "sg", "ts", "ks", "context", "sv", "ds", "si", "n", "g", "in", "is", "sf", "w", "m", "b", "t", "d", "i", "gs", "sa", "c", "service", "p", "ls", "e", "se", "parts", "xs", "sq", "rs", "outs", "f", "os", "cs", "sym", "o", "S", "es", "sync", "v", "space", "services", "sup", "r", "ns", "sb", "spec", "u", "sys", "h", "client", "a", "ses", "ps", "site", "y", "ss", "fs", "ssl", "sc"], "marker": ["callener", "marksorer", "arkorer", "Markner", " markger", "Markoder", "arketer", " Markger", "calleter", "signer", "Marketer", "marksener", "Markger", "marketer", "markedeter", "markser", "markedner", "markner", " markoder", "calloser", "signiner", "markiner", " markorer", "Markiner", " markiner", "marksger", "signeter", "caller", "markseter", "signener", "Markoser", "markers", "markeders", "markorer", "markoder", "markger", "arker", " markers", " markner", " Marker", " markoser", "arkiner", "signoser", "Markers", "markeder", "marksoser", " marketer", "Marker", "markoser", " markener", "marksiner", " Markiner", "markener", " Markoder"], "idx": ["Idx", " idxes", "idn", " idxs", "Idz", "adx", "ideX", "idex", " idz", " idX", "adz", "adxs", "adn", "indct", "idz", "indx", "idX", " idxx", "edxes", " idn", "indxp", "indxs", "adX", "edx", "edz", "indz", "idxp", "Idct", "midx", "pidz", "Idxp", "Idn", "edxs", "idez", " idct", "Idxs", "idxx", "adxes", "IdX", "pidx", "idexp", "indX", "idexx", "idxs", "idxes", "idct", "midX", "midz", "midxx", "pidxs", "idexs", "pidX"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n", "idx": 12200, "substitutes": {"dev": ["conf", "gd", "di", "cam", "debug", "dom", "Dev", "def", "w", "prom", "dem", "mem", "ver", "de", "gr", "ad", "data", "obj", "app", "driver", "amd", "rad", "serial", "priv", "hw", "ev", "device", "md", "mod", "ga", "pu", "dc", "link", "dm", "grad", "self", "od", "av", "ch", "cmd", "wd"], "d": ["ld", "l", "gd", "dh", "ds", "did", "rd", "n", "dom", " dd", "da", "w", "m", "id", "dt", "fd", "b", "t", "dj", "i", "c", "ad", "data", "bd", "p", "e", "cd", "pd", "du", "dn", "f", "ded", "db", "dat", "device", "nd", "md", "r", "dd", "vd", "dc", "sd", "u", "dm", "grad", "dy", "od", "dad", "D"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 12205, "substitutes": {"d": ["ld", "l", "gd", "di", "dh", "ds", "n", "g", "dom", "dict", "da", "m", "id", "dt", "fd", "b", "t", "z", "data", "c", "ad", "s", "p", "draw", "bd", "e", "pd", "cd", "dn", "df", "f", "ded", "dr", "dl", "db", "dat", "nd", "ind", "md", "mod", "dd", "dc", "sd", "plugin", "self", "grad", "od", "dev", "dad", "D"], "val": ["count", "vals", "Val", "pol", "ee", "base", "valid", "il", "len", "sel", "alt", "bal", "all", "_", "key", "b", "ol", "x", "VAL", "data", "fb", "el", "p", "ref", "max", "slot", "value", "pt", "ay", "f", "rot", "unit", "aval", "vol", "fl", "py", "eval", "al", "v", "ind", "sl", "cal", "pre", "put", "dev", "ot", "ann", "vel"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 12215, "substitutes": {"f": ["l", "rf", "uf", "lf", "fo", "fen", "g", "af", "sf", "m", "fr", "fd", "t", "x", "k", "b", "fw", "d", "i", "c", "fb", "s", "p", "fal", "e", "q", "df", "bf", "tf", "o", "fx", "elf", "u", "form", "h", "self", "F", "file", "fs", "a", "inf", "fi", "fe", "fc"], "v": ["vs", "l", "vi", "va", "sv", "n", "vu", "val", "lv", "view", "w", "m", "b", "x", "t", "k", "ve", "iv", "d", "i", "vt", "c", "s", "data", "p", "e", "value", "q", "j", "ev", "o", "vol", "nv", "cv", "uv", "conv", "V", "vd", "u", "h", "vv", "video", "y", "volt", "vp"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n\n{\n\n    int i, len, sz;\n\n    GetBitContext gb;\n\n    int code_table[64];\n\n\n\n    /* get the rle codes (at most 64 bytes) */\n\n    init_get_bits(&gb, src, 64 * 8);\n\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n\n        code_table[i] = get_sbits(&gb, 4);\n\n        sz += FFABS(code_table[i]);\n\n    }\n\n    src += (get_bits_count(&gb) + 7) / 8;\n\n\n\n    /* do the rle unpacking */\n\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n\n        len = code_table[i];\n\n        if (len < 0) {\n\n            len = -len;\n\n            memset(dst, *src++, FFMIN(len, dst_size));\n\n        } else {\n\n            memcpy(dst, src, FFMIN(len, dst_size));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n        dst_size -= len;\n\n    }\n\n    return src;\n\n}\n", "idx": 12216, "substitutes": {"src": ["img", "cmp", "config", "uri", "dest", "cb", "gl", "attr", "dist", "loc", "st", "code", "ctr", "uv", "cur", "grad", "url", "text", "seed", "fc", "go", "low", "b", "addr", "sq", "bc", "slice", "sup", "conv", "sth", " addr", " rc", " source", "rl", "secure", "sc", "seq", "source", "sel", "hh", "RC", "buf", "stream", "rb", "ptr", "obl", "sub", "bg", " dest", "sync", "rc", "sl", "sb", "hl", "comp", "sr", "uc", "ssl", "byte", "start", "rest", "sur", "lit", "rs", "inst", "supp", "lib", "ctx", "address", "gz"], "dst": ["dsrc", " dsc", "dost", "dsp", " dsp", "lsrc", "dsc", "adest", "dest", "Dsts", "Dsrc", "ssp", " dsrc", "lsp", " dsts", " dest", "adsp", "Dst", "dsts", "adsts", "adost", "sest", "lst", "Dost", "ssrc", "ssts", "sst", "lest", " dost", "adsrc", "adst", "sost", "adsc"], "dst_size": ["dst_length", "dsts_size", "dst_line", "dstntime", "dstnsize", "dst_scale", "dst_time", "dest_capacity", "dsc_time", "dsts_width", "dost_scale", "dst_width", "dst_capacity", "dstnline", "dost_address", "dest_address", "dsc_size", "dsc_line", "dsts_length", "dest_scale", "dest_size", "dsts_scale", "dest_time", "dost_size", "dst_address"], "i": ["oi", "l", "diff", "ui", "di", "it", "si", "in", "zi", "adi", "source", "id", "xi", "info", "b", "x", "ini", "z", "iv", "d", "c", "p", "ix", "uri", "e", "cli", "attr", "eni", "f", "ie", "j", "code", "ai", "multi", "index", "v", "rc", "ind", "gi", "ti", "mi", "phi", "r", "inner", "qi", "en", "bi", "pi", "ii", "u", "h", "I", "li", "pos", "ip", "ci", "io", "ni", "y", "ri", "fi", "iu"], "len": ["count", "l", "lp", "ld", "seq", "ler", "le", "lf", "n", "val", "source", "alt", "ul", "all", "id", "lim", "low", "z", "line", "limit", "el", "lit", "split", "loc", "f", "la", "ie", "dl", "label", "fl", "bl", "lib", "ll", "size", "min", "sl", "fun", "L", "err", "en", "pre", "lt", "elt", "lang", "hl", "li", "pos", "lon", "led", "length", "bin", "Len", "lc", "rev", "vec", "gen", "lan", "ln", "lin"], "sz": [" szz", "szen", "jszi", "jszz", "dsze", "gesze", "pszi", "geszz", "dsq", "Szi", "szi", "rszh", "Sq", "Sze", "psze", "psz", "Sz", "sq", "rsze", "rszi", "szy", "sze", "dszi", " szh", " szi", "szh", "pszh", "jszy", "geszi", " szy", " szen", "dsz", "szz", " sze", "pszen", "gesz", "geszen", "rsz", " sq", "geszy", "jsz"], "gb": ["GB", "gu", "sg", " rgb", "di", "gd", "bb", "ui", "pg", "nb", "g", "gio", "abb", " gcc", "bm", "gm", "kb", "gs", "gin", "cb", "gp", "rb", "gh", "yg", "bc", "Gb", "gy", "db", "bf", "bg", " rg", "gg", "sl", "ga", "sb", "pc", "usb", " rc", "hub", " db", "cfg", "gc", "mb", "rg", "ci", " kb", "gam", "nn", "gram"], "code_table": ["code__cache", "codealfile", " code_const", " code_file", " code_tree", "code__file", "dataalfile", "dataalcache", "code6cache", "code6file", "data_file", " code_TABLE", "code6table", "codeercache", "codealconst", "code__table", " code_index", "code_cache", "codealtable", "codercache", "code_index", "code_tree", "code_binary", "code6TABLE", "code_TABLE", "dataaltable", "code__TABLE", " code_cache", "codeerconst", "codeertable", "codealcache", "codealbinary", "data_binary", "data_cache", "code_const", "codealindex", "codertable", "code2cache", "codeerindex", "code2table", "coderfile", "dataalbinary", "code_file", "coderbinary", "data_table", "code2tree"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 12243, "substitutes": {"candidate": ["candidates", "Candidated", "indidation", "indidates", "provenidated", "coreidation", " candidation", "coreidate", "Candidates", " candidates", "Candidation", "Candidate", "candidation", "indidated", "indidate", "candidated", "provenidates", "coreidates", "provenidation", "provenidate"], "bs": ["vs", "ts", "base", "bb", "is", "ds", "its", "ba", "bas", "b", "ops", "fb", "s", "ls", "pb", "ins", "bits", "loc", "rs", "banks", "BS", "os", "bc", "ac", "bt", "cs", "db", "bl", "ubs", "bh", "lb", "bis", "bi", "ns", "blocks", "sb", "acl", "ps", "ses", "fs", "ss", "bes", "bos"], "it": ["parent", "qt", "oc", "ib", "its", "si", "section", "start", "in", "ul", "n", "ait", "IT", "ite", "pit", "t", "b", "iv", "stat", "ble", "i", "ct", "mit", "c", "p", "iti", "lit", "iter", "act", "op", "ac", "j", "ort", "ic", "end", "edit", "abi", "bis", "ita", " It", "init", "It", "you", "itter", "ip", "ant", "ci", "not", "exec"], "perm": ["qua", "filter", "cmp", "len", "prefix", "pad", "m", "prom", "mm", "pa", "rule", "policy", "p", "mask", "qa", "fp", "attr", "lambda", " permission", "priv", "tmp", "op", "f", "bc", "mission", "ac", "mode", "alpha", "mp", "sk", "module", "inc", "atom", "apply", "mod", "jp", "acl", "part", "pc", "spec", "ms", "admin", "compl", "lock", "comm", "cm", "command", "func", "fac", "partial", "proc", "per", "exec"]}}
{"project": "qemu", "commit_id": "f4bf56fb78ed0e9f60fa1ed656c14ff4c494da5a", "target": 1, "func": "static int vhost_user_set_mem_table(struct vhost_dev *dev,\n\n                                    struct vhost_memory *mem)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    int i, fd;\n\n    size_t fd_num = 0;\n\n    bool reply_supported = virtio_has_feature(dev->protocol_features,\n\n                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);\n\n\n\n    VhostUserMsg msg = {\n\n        .hdr.request = VHOST_USER_SET_MEM_TABLE,\n\n        .hdr.flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (reply_supported) {\n\n        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;\n\n    }\n\n\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        ram_addr_t offset;\n\n        MemoryRegion *mr;\n\n\n\n        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);\n\n        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,\n\n                                     &offset);\n\n        fd = memory_region_get_fd(mr);\n\n        if (fd > 0) {\n\n            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;\n\n            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;\n\n            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;\n\n            msg.payload.memory.regions[fd_num].mmap_offset = offset;\n\n            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);\n\n            fds[fd_num++] = fd;\n\n        }\n\n    }\n\n\n\n    msg.payload.memory.nregions = fd_num;\n\n\n\n    if (!fd_num) {\n\n        error_report(\"Failed initializing vhost-user memory map, \"\n\n                     \"consider using -object memory-backend-file share=on\");\n\n        return -1;\n\n    }\n\n\n\n    msg.hdr.size = sizeof(msg.payload.memory.nregions);\n\n    msg.hdr.size += sizeof(msg.payload.memory.padding);\n\n    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);\n\n\n\n    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (reply_supported) {\n\n        return process_message_reply(dev, &msg);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12245, "substitutes": {"dev": ["diff", "conf", "gu", "debug", "dom", "comment", "prof", "def", "w", "info", "conn", "Dev", "model", "temp", "game", "dem", "ver", "d", "serv", "de", "data", "doc", "var", "block", "server", "app", "bug", "serial", "mode", "mid", "ev", "device", "pub", "module", "msg", "feature", "md", "req", "mod", "user", "dc", "error", "node", "init", "self", "client", "cache", "cmd", "proc", "DEV"], "mem": ["cpu", "conf", "dim", "rem", "Mem", "mor", "conn", "lim", "gpu", "mount", "mm", "mon", "serv", "vm", "sum", "time", "server", "machine", "memory", "pm", "loc", "network", "nm", "mode", "mid", "host", "device", "msg", "mi", "connection", "program", "am", "mod", "im", "user", "mo", "disc", "tm", "disk", "image", "ram", "cache", "ann", "um", "use", "mc", "usage", "gram"], "fds": ["fannels", " fns", "tfds", "hannels", "Fannels", "tfcs", " fdes", "fdes", "Fns", "fcs", " frs", "fdb", "Fcs", " fannels", "Fds", "Frs", " fdb", "fns", "hdb", "Fdes", "tfdes", "Fdb", "hrs", "hds", " fcs", "tfns", "frs"], "i": ["vi", "ui", "di", "it", "start", "si", "n", "in", "id", "xi", "x", "ini", "num", "d", "uli", "c", "ji", "p", "ix", "uri", "e", "mu", "mini", "eni", "f", "ie", "j", "ai", "multi", "index", "v", "ind", "mi", "ti", "gi", "phi", "r", "qi", "im", "pi", "bi", "part", "ii", "uni", "u", "I", "li", "ip", "ci", "ni", "ri", "fi", "iu"], "fd": ["ld", "lf", "ds", "len", "ff", "rd", "sf", "fr", "dt", "fed", "fw", "d", "buf", " fid", "fb", "bd", "pd", "fp", "cf", "wr", "dn", "df", "nm", "f", "dl", "fa", "fm", "bf", "fl", "dir", "ln", "draft", "fx", "fat", "md", "dd", "dc", "FD", "sd", "hd", "fn", "nc", "handler", "aa", "fee", "wd", "fi", "fe", "fc"], "reg": ["REG", "ru", "sg", "co", "rem", "registered", "mn", "pg", "debug", "tr", "g", "region", "erg", "mor", "conn", "org", "rr", "tag", "ray", "rec", "gr", "serv", "stat", "sam", "config", "ref", "addr", "rule", "attr", "loc", "sec", "db", "res", "sub", "eg", "ig", "rc", "r", "req", "mod", "err", "greg", "ga", "Reg", "trans", "rar", "disc", "ro", "re", "rg", "ret", "ram", "rm"], "offset": ["area", "location", "inet", "timeout", "optional", "start", "len", "alt", "af", "prefix", "id", "no", "num", "pointer", "data", "slot", "addr", "ref", "fp", "set", "attr", "off", "ptr", "loc", "nm", "o", "index", "size", "alloc", "format", "align", "end", "address", "option", "fff", "part", "position", "error", "pos", "ip", "api", "Offset", "range"], "mr": ["km", "rf", "rh", "adr", "ru", "mn", "tr", "rd", "hr", "mor", "m", "fr", "rr", "bm", "gor", "kr", "gr", "nor", "MR", "attr", "wm", "usr", "wr", "rb", "lr", "er", "dr", "rt", "fm", "mer", "mx", "mi", "r", "pr", "nr", "shr", "yr", "vr", "cm", "rg", "mt", "sr", "br", "mc", "rl", "rm"]}}
{"project": "FFmpeg", "commit_id": "fa74cdc60d19798c951dcc242ca7273e6483f2b3", "target": 1, "func": "int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size,\n                     int64_t pts, int64_t dts, int64_t pos)\n{\n    int index, i;\n    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];\n    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {\n        s->next_frame_offset =\n        s->cur_offset        = pos;\n        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;\n    }\n    if (buf_size == 0) {\n        /* padding is always necessary even if EOF, so we add it here */\n        memset(dummy_buf, 0, sizeof(dummy_buf));\n        buf = dummy_buf;\n    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */\n        /* add a new packet descriptor */\n        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);\n        s->cur_frame_start_index = i;\n        s->cur_frame_offset[i]   = s->cur_offset;\n        s->cur_frame_end[i]      = s->cur_offset + buf_size;\n        s->cur_frame_pts[i]      = pts;\n        s->cur_frame_dts[i]      = dts;\n        s->cur_frame_pos[i]      = pos;\n    }\n    if (s->fetch_timestamp) {\n        s->fetch_timestamp = 0;\n        s->last_pts        = s->pts;\n        s->last_dts        = s->dts;\n        s->last_pos        = s->pos;\n        ff_fetch_timestamp(s, 0, 0, 0);\n    }\n    /* WARNING: the returned index can be negative */\n    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,\n                                    poutbuf_size, buf, buf_size);\n    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes\n    /* update the file pointer */\n    if (*poutbuf_size) {\n        /* fill the data for the current frame */\n        s->frame_offset = s->next_frame_offset;\n        /* offset of the next frame */\n        s->next_frame_offset = s->cur_offset + index;\n        s->fetch_timestamp   = 1;\n    }\n    if (index < 0)\n        index = 0;\n    s->cur_offset += index;\n    return index;\n}", "idx": 12255, "substitutes": {"s": ["l", "session", "is", "its", "strings", "m", "http", "t", "gs", "parts", "set", "parser", "plugins", "v", "full", "ans", "ns", "hs", "spec", "self", "settings", "buffer", "sg", "ds", "n", "si", "your", "w", "_", "id", "b", "c", "e", "se", "request", "args", "sq", "us", "f", "sym", "sets", "es", "r", "this", "u", "as", "comments", "fs", "su", "ps", "site", "ss", "seq", "ks", "g", "stats", "ops", "d", "ls", "os", "cs", "o", "sync", "native", "new", "sb", "sys", "single", "secondary", "a", "func", "ssl", "vs", "conf", "ts", "service", "p", "server", "qs", "ins", "xs", "js", "rs", "aws", "S", "states", "services", "ms", "less", "client", "options", "ses", "uns", "css", "y", "bs"], "avctx": ["AVcli", "avcmp", "afctx", "AVconfig", "devcmp", "afcmp", "abcmp", "devcontext", "abconfig", "abcontext", "AVcmp", "afcli", "AVcontext", "abctx", "afconfig", "AVctx", "avconfig", "avcontext", "devcli", "devctx", "afcontext", "avcli"], "poutbuf": [" pinbatch", "Poutbuff", "pupbuf", "pntsrc", " pinqueue", " poutlen", "puplen", "pinlen", "poutlen", "pnotqueue", "pinsrc", "pdownqueue", "pntbuf", "Poutsrc", "Pinbuff", "Pinbuf", "poutbuff", "Poutbuf", "pnotbatch", "pinbuff", "pntqueue", "pupbatch", "pnotbuf", "pupqueue", " pinlen", "pinbatch", "poutsrc", "pnotlen", "pntbuff", "pinbuf", "Poutqueue", "poutbatch", " poutbatch", "poutqueue", "pdownbuf", "pdownbuff", " pinbuf", "pinqueue", " poutqueue", "pdownsrc", "Pinsrc", "Pinqueue"], "poutbuf_size": ["poutbuf_pos", "poutbuf_Size", "poutqueue_size", "poutqueue_set", "poutbuf1size", "poutbuf___len", "poutbuf1Size", "poutbuffer_size", "poutbuffer_Size", "poutbuf_len", "poutbuf___start", "poutbuffer_6", "poutbuf_set", "poutbuffer_pos", "poutbuf_start", "poutbuffer_start", "poutqueue_len", "poutbuf___pos", "poutbuf16", "poutbuffer_len", "poutbuf_6", "poutbuf___size"], "buf": ["bag", "uf", "seq", "Buffer", "bb", "window", "tc", "src", "fd", "b", "ab", "num", "wb", "pool", "data", "fb", "config", "pb", "cb", "queue", "cf", "xff", "rb", "prop", "tmp", "bc", "alloc", "cv", "input", "cas", "ctx", "port", "offset", "header", "cache", "vec", "buff", "br", "text", "result", "cmd", "buffer", "box", "uc"], "buf_size": ["windowMcontent", "buf_capacity", "bufacSize", " buffer__Size", "buffer_size", "bufMcontent", "buf_offset", "buffer_address", "img_size", "buf_length", "uf_Size", "buf__size", "windowMize", "buf_address", "buf_number", "buf__number", "bufacfee", "img_offset", "uf_ize", " buffer_fee", "buf_content", "window_Size", "windowMSize", "buffer_name", "window_size", "bufMize", "buf__Size", " buffer_number", "buf_name", "img_length", "uf_size", " buffer_Size", "buf_sized", "img_sized", " buffer_size", "buf_fee", " buffer__size", " buffer__fee", "bufacsize", "window_ize", "buf_Size", "buf__fee", "bufMsize", "window_content", "buf_ize", "windowMsize", "bufacnumber", " buffer__number", "buffer_capacity", "bufMSize"], "pts": ["periodses", "ptsb", "ptlines", "aptses", "ptments", "ointsb", "ointns", "ointis", "ptris", "ctls", "cts", "iptlines", "ptd", "ptrs", "oints", "polylines", "aptments", "periodd", "ptis", "ctments", "ntsb", "ptses", "ntis", "ptrns", "ptns", "ctses", "periodlines", "polys", "periodls", "ipts", "aptls", "polyd", "nts", "periodments", "apts", "periods", "ptrsb", "ptls", "iptd", "ntns"], "dts": ["sdms", "dcs", "datts", " dms", "idcs", "dats", "sdsts", "dds", "dths", "indths", "datms", "ltimes", "dtimes", "datds", "idths", "indtimes", "dms", " dats", "adms", "sdts", "indts", "indcs", "lths", " dsts", "lts", "datats", "dsts", "adsts", "idts", "dps", " dps", "adts", " dds", "sdps", "adps", "lcs", "pats", "pds", "idtimes", "pms"], "pos": ["POS", "sp", "seq", "cond", "pass", "start", "n", "len", "val", "nos", "str", "def", "all", "no", "to", "x", "z", "pid", "pointer", "doc", "block", "slot", "addr", "pose", "p", "ref", "time", "status", "po", "pt", "loc", "prop", "sec", "op", "os", "body", "next", "unit", "o", "slice", "size", "Pos", "state", "end", "neg", "address", " positions", "port", "pc", "position", "offset", "type", "length", "cache", "depth"], "index": ["count", "ion", "timeout", "fix", "argument", "n", "len", "val", "si", "all", "id", "x", "num", "Index", "d", "pointer", "config", "e", "thread", "loc", "array", "f", "j", "code", "alpha", "size", "slice", "version", "inc", "shape", "ind", "input", "connection", "end", "object", "option", "fff", "position", "error", "offset", "ticket", "type", "length", "insert", "match", "weight", "partial"], "i": ["l", "ui", "di", "it", "start", "si", "len", "n", "is", "zi", "info", "xi", "x", "ini", "b", "uli", "c", "ji", "p", "ix", "uri", "e", "yi", "cli", "eni", "f", "ie", "j", "ai", "multi", "gi", "ti", "mi", "phi", "ind", "qi", "ei", "pi", "bi", "position", "ii", "offset", "u", "type", "I", "li", "ip", "ci", "api", "ni", "io", "y", "lc", "ri", "fi", "iu"], "dummy_buf": ["dummy67fb", "dummy67buf", "doodle_buf", "ducky_buffer", "doodle_fb", "dummyMbr", "dummy_fb", "dummyMbuf", "dummy_b", "ducky_buf", "dummyMqueue", "dummy_br", "dummies_b", "dummy_buff", "dummies_br", "dummy67buff", "ducky_queue", "doodle_buffer", "doodle_buff", "dummy67buffer", "dummyMbuff", "dummy_buffer", "dummies_buff", "dummies_queue", "dummies_buf", "dummies_buffer", "dummy_queue", "ducky_buff"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 12257, "substitutes": {"client": ["parent", "session", "co", "connect", "context", "chrome", "complex", "conn", "id", "method", "open", "http", "public", "simple", "container", "project", "con", "Client", "c", "config", "server", "uri", "close", "ace", "cli", "util", "queue", "cn", "private", "gui", "cod", "socket", "manager", "child", "resource", "lib", "ce", "current", "connection", "ctx", "custom", "front", "plugin", "self", "api", "ci", "clean", "cache", "cell", "core", "ssl"], "sector_num": ["sector1name", " sector_number", "sector_index", "sector64index", "sector64num", "section_number", "sector64name", " sector_Num", "sector_Num", "section_index", "sector1Num", " sector_name", "section_num", "sector_name", "sector1number", "sector64number", "sector1num", "section_name", "sector_number"], "nb_sectors": ["nb_secctors", "nb_vectors", "nb_psellers", "nb_secctions", "nb_tegments", "nb_tellers", "nb_teivers", "nb_pectors", "nb_pegments", "nb_vections", "nb_segments", "nb_seivers", "nb_sections", "nb_pections", "nb_sellers", "nb_psegments", "nb_psectors", "nb_secctor", "nb_pector", "nb_tectors", "nb_vector", "nb_vegments", "nb_secgments", "nb_pseivers", "nb_sector", "nb_vellers", "nb_veivers"], "qiov": ["Qiov", "qiu", "quiov", "qiii", " qiii", "sqovi", "fovi", "wiev", "sqiov", "quicho", "wicho", "Qicho", "wiov", "sqiii", "qovi", "sqiu", "Qrolet", "quiev", "qiev", "qicho", "wrolet", "qurolet", "fiu", "fiii", "fiov", " qovi", "Qiev", " qiu", "qrolet"], "offset": ["parent", "location", "reference", "timeout", "base", "optional", "start", "len", "shift", "i", "slot", "from", "addr", "ref", "fp", "set", "number", "off", "loc", "o", "index", "format", "align", "address", "port", "part", "position", "error", "type", "et", "pos", "url", "length", "Offset", "range", "reset"], "request": ["parent", "session", "enter", "worker", "record", "require", "claim", "config", "xml", "frame", "er", "call", "response", "object", "repeat", "get", "type", "re", "have", "question", "buffer", "reference", "save", "key", "id", "demand", "create", "post", "work", "adjust", "input", "r", "friend", "art", "error", "read", "pair", "complete", "insert", "hello", "join", "transfer", "rf", "Request", "method", "send", "data", "resource", "move", "order", "query", "req", "allow", "command", "message", "report", "attribute", "use", "result", "QUEST", "time", "server", "search", "q", "push", "next", "quest", "child", "requ", "route", "event", "apply", "address", "user"], "reply": ["bill", "repl", "related", "base", "answer", "flag", "ry", "comment", " response", "prefix", "shell", "id", "info", "rr", "http", "Reply", "send", "post", "service", "server", "pb", "respond", "lag", "repair", "be", "entry", "child", "parse", "sync", "replace", "order", "response", "remote", "query", "flash", "proxy", "apply", "r", "address", "err", "callback", "bot", "fire", "read", "link", "sys", "report", "back", "ignore", "trade", "rev", "write", "match", "resp", "force", "buffer", "transfer"], "ret": ["arr", "valid", "flag", "active", "ext", "alt", "val", "len", "af", "info", "nt", "Ret", "no", "id", "total", "mem", "last", "data", "server", "ref", "arg", "lit", "reg", "iter", "rets", "er", "f", "rot", "rt", "res", "bf", "det", "format", "order", "rc", "response", "fun", "att", "r", "en", "art", "error", "get", "bit", "cat", "re", "et", "RET", "complete", "url", "result", "rev", "match", "ft", "resp", "mt", "sr", "out", "success"]}}
