{"project": "FFmpeg", "commit_id": "32bf6550cb9cc9f487a6722fe2bfc272a93c1065", "target": 0, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "idx": 3, "substitutes": {"s": ["parser", "cs", "ss", "ops", "spec", "r", "aws", "g", "m", "ses", "sf", "settings", "sv", "ps", "c", "setup", "e", "w", "f", "sq", "sc", "o", "v", "b", "t", "fs", "ssl"], "pb": ["fc", "pl", "np", "vp", "ctx", "http", "bh", "lp", "pd", "ppa", "sb", "bps", "txt", "cpp", "lb", "hub", "prot", "eb", "loc", "rob", "pg", "bc", "platform", "api", "PB", "tp", "rb", "fp", "plug", "cb", "pid", "bf", "pa", "pkg", "bot", "p", "lc", "wb", "hp", "jp", "mp", "pm", "phrase", "summary", "pc", "bp", "lib", "um", "fb", "cp", "plugin", "b", "types", "wp", "lab", "dp", "typ", "db", "xb"], "codec": ["labesc", "genec", "predac", "labrec", "antec", "odac", "defef", "codeeco", " codect", "lowec", "condic", "cheenc", "predex", "cheuc", " codenc", "lowenc", "predec", "oddec", "cEC", " codef", "pedect", "cec", "defbc", "pedec", "lowac", "codeac", " codek", "codefc", "crossenc", "predrec", "coderec", "codect", "condect", "codeef", "crossac", "cex", "labdec", " codbec", "genuc", "Codbc", "pedenc", "Coderc", "coddec", "Codek", "codebec", "codfc", "codef", "cherec", " codrec", "copenc", " codesc", "cheect", "copec", "loweco", "cheex", "codbc", "codeenc", "odesc", "coducc", "condenc", " codex", "odbec", "labuc", "crossek", "cheec", "codenc", "antea", "odef", " coddec", "odex", "Codea", "chedec", "antek", "copef", "cucc", "odec", "defec", "pedef", "Codef", "genesc", "genex", "condec", "codesc", "labEC", "oduc", "challec", "coduc", "codex", "codeucc", " coducc", "predEC", "predeco", "CodEC", "defEC", "odrec", "codeco", " codbc", "codic", "codeek", " codEC", "codEC", "challea", "anterc", "odect", "codbec", "preduc", "labex", "labec", "challEC", "cheEC", "copuc", "crossec", "predfc", "codek", "Codec", "codrec", " coduc", "codedec", " coderc", "codac", "codeesc", "odenc", "codea", "codeex", "challerc", "coderc", " codic", "codeEC", "predenc", " codfc", "odek", "antEC", "codeec", "cheic", "codeuc"], "size": ["unit", "np", "SIZE", "se", "capacity", "name", "offset", "time", "ize", "large", "term", "second", "sized", "zip", "small", "data", "complete", "ui", "speed", "loc", "n", "video", "empty", "max", "code", "body", "sync", "style", "storage", "address", "e", "length", "len", "Size", "sec", "sn", "sum", "scale", "fee", "six", "shape", "timeout"], "big_endian": ["big_endsican", "big_endedIAN", "big_indian", "big_endsien", "big_ENDians", "big_endsiet", "big_endedian", "big_endsarian", "big_endsians", "big_endrian", "big_ENDian", "big_indarian", "big_endedrian", "big_endiet", "big_endsian", "big_endIAN", "big_endsrian", "big_endediet", "big_endedians", "big_endarian", "big_endedien", "big_endians", "big_indians", "big_endican", "big_endien", "big_endsIAN", "big_ENDican", "big_indien", "big_ENDIAN"], "id": ["this", "act", "key", "url", "head", "like", "lang", "code", "mid", "rid", "f", "path", " ID", "start", "name", "time", "zip", "sid", "image", "ui", "type", "format", "ID", "parent", "end", "api", "did", "ids", "gap", "create", "p", " fid", "plugin", "link", "root", "in", "kill", "data", "ad", "oid", "Id", "info", "str", "pid", "feat", "ident", "pad", "h", "kid", "ide", "value", "error", "gen", "shape", "def", "bit", "d", "bid", "it", "num", "side", "none", "bug", "source", "aid", "ip", "vid", "uid", "db"], "bitrate": ["blockrate", "latrate", "Bitrates", "bandrates", "blockspeed", "latspeed", "bitscale", "bandrate", "blockrates", "brate", "brates", "Bitrate", "bitspeed", "bandtime", " bitscale", "blockurrency", " bitrates", "biturrency", "bittime", " bitspeed", "laturrency", "Bitscale", "bscale", "latrates", " bittime", " biturrency", "bitrates", "blocktime"]}}
{"project": "qemu", "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189", "target": 1, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}", "idx": 12, "substitutes": {"xendev": [" xendingev", "xenerv", "xendell", "xndown", "lexendell", "xendingream", "exendream", "xendee", " xendingee", "xENDerv", "pendedev", "exendown", "crossendingerv", "xendoy", "xendederv", "lexENDell", "crossendingev", "pendov", "xstartec", "xestee", "xnddev", "xendedee", "xendeddev", "exendef", "xendream", "yendev", "xendingerv", "xstartell", "lexenddev", "crossendev", "xstartev", "xendedef", "xendingee", "xendek", "yenderv", "xentev", "exendev", "exendee", "xestev", "xenep", "exenddev", "xndep", "xendef", "xandev", "lexendee", "exendom", "xaddev", "xendec", "crossendiv", "xendingove", " xendoy", " xendingown", "xentee", "xendedov", "yendedep", "xaddee", "yendederv", "xstartiv", " xendingoy", "xendedec", "yendeddev", "xENDev", "xendedek", "lexENDdev", "exendek", "crossendingec", "xandream", "xentove", "xstartee", "lexENDee", "exndown", "exendedream", "exendedek", "xendingev", "xendingec", "xstartdev", "crossendec", "xenev", "xandee", "crossenderv", "xndell", "xendingown", "exndev", "yenddev", "xendingiv", "xentoy", "lexENDev", "xendedep", "xenddev", "xendingef", "yendedev", "pendef", "xENDell", "xandef", "xendove", "xendediv", "lexendev", "xndev", "xendedown", "xndee", "xendown", "xentef", "xaddek", "xestek", "xendedream", "xendov", "exenderv", "yendep", "exnderv", "pendedef", "xendedev", "xestom", "xendiv", "xendep", " xendee", "pendedove", "xendom", "exendedee", "xentov", "exendedev", "pendev", "crossendingiv", "xendingoy", "xendedove", "xnderv", "xendedom", "xaddom", "xendingov", "xENDdev", "xENDown", "xentown", "xENDee", "exendedom", "xendedoy", " xendown", "exendedef", "xenderv", "pendove", "pendedov", "xstarterv", "exnddev"], "i": ["cli", "n", "ij", "\u0438", "j", "g", "ti", "index", "x", "u", "gui", "uri", "fi", "abi", "interface", "isin", "zi", "ji", "ui", "pi", "id", "mi", "iu", "api", "y", "ri", "z", "reply", "ie", "p", "e", "lc", "isi", "v", "iv", "qi", "ix", "t", "count", "io", "mu", "init", "in", "li", "a", "ni", "ii", "I", "di", "uli", "m", "inner", "info", "slice", "ini", "c", "phi", "o", "si", "yi", "gi", "d", "it", "eni", "multi", "source", "ai", "ip", "l", "bi", "b", "ci", "part", "xi"], "xen_9pdev": ["xen_9ddi", "xen_29pctr", "xen_9cev", "xen_09pde", "xen_9ddem", "xen_9cengine", "xen_9qdi", "xen_16prad", "xen_9rconf", "xen_9c3", "xen_09cdev", "xen_9fdi", "xen_9f3", "xen_9nconf", "xen_9erdev", "xen_09pdev", "xen_9fgu", "xen_10pdi", "xen_9pcde", "xen_9pddef", "xen_09pdi", "xen_9erdevices", "xen_9qhome", "xen_9pctr", "xen_9fdem", "xen_9pdevices", "xen_9ipgu", "xen_9ncache", "xen_09pdem", "xen_8ddiv", "xen_9ddef", "xen_9ndev", "xen_9derror", "xen_9predev", "xen_nineddevice", "xen_30pade", "xen_109ndev", "xen_9qDev", "xen_9fde", "xen_9appconf", "xen_9padev", "xen_9prad", "xen_9cver", "xen_9tdd", "xen_9fdiv", "xen_ninedtr", "xen_09pdiv", "xen_29pcdev", "xen_09fdi", "xen_9pserver", "xen_9ferror", "xen_30phome", "xen_9pengine", "xen_9fserver", "xen_09f3", "xen_9usec", "xen_9wpdevice", "xen_9pddev", "xen_ninepdevice", "xen_09pev", "xen_9rdiv", "xen_9predef", "xen_9udev", "xen_9cdev", "xen_9pver", "xen_10pdevice", "xen_9ptr", "xen_09fserver", "xen_9ddevices", "xen_8pdev", "xen_9dsec", "xen_9fdef", "xen_9pcdevices", "xen_09psec", "xen_9wp3", "xen_29ptr", "xen_8dconf", "xen_09cDev", "xen_ninefdevice", "xen_nineddev", "xen_09p3", "xen_8ddef", "xen_30pdev", "xen_9chome", "xen_09fsec", "xen_9pedev", "xen_9fconf", "xen_9fprof", "xen_8pdiv", "xen_ninefdev", "xen_8pdef", "xen_9fdevice", "xen_8ddev", "xen_109ddev", "xen_30pdevice", "xen_9pcdevice", "xen_9pdem", "xen_9frad", "xen_9pigu", "xen_9cdi", "xen_09fev", "xen_9fsec", "xen_09pdef", "xen_9pcache", "xen_9ddiv", "xen_10pcdev", "xen_16pdef", "xen_9wpdev", "xen_9prerad", "xen_9pcdi", "xen_30pahome", "xen_9ppprof", "xen_9pade", "xen_9pprof", "xen_9cDev", "xen_nineptr", "xen_9ftr", "xen_9fDev", "xen_9tdef", "xen_09pdevice", "xen_9fengine", "xen_9p3", "xen_8pconf", "xen_9pev", "xen_9ipdev", "xen_109pcache", "xen_9fdd", "xen_109pdevice", "xen_9qdevice", "xen_9drad", "xen_9lpdem", "xen_09fver", "xen_9cdevice", "xen_9ndevice", "xen_ninepdev", "xen_9appcache", "xen_9cpdef", "xen_9pdi", "xen_9pdiv", "xen_109nconf", "xen_9ldev", "xen_9fver", "xen_16predev", "xen_09fdiv", "xen_9ldef", "xen_9cde", "xen_29pprof", "xen_30padev", "xen_9ndiv", "xen_9psec", "xen_9ddd", "xen_9pptr", "xen_09fdef", "xen_9padevice", "xen_9tev", "xen_9cerror", "xen_9pcver", "xen_09pver", "xen_09fde", "xen_10pcdevices", "xen_9ddevice", "xen_9pdd", "xen_9fcache", "xen_9pdevice", "xen_9dtr", "xen_9tdevice", "xen_109pdd", "xen_109ddevice", "xen_09fgu", "xen_9ppdev", "xen_29pdev", "xen_109ddd", "xen_9pcprof", "xen_9fdev", "xen_09fdevice", "xen_16predef", "xen_9pDev", "xen_9pdef", "xen_16prerad", "xen_9piserver", "xen_9dde", "xen_9pahome", "xen_09fdev", "xen_9cperror", "xen_9cdef", "xen_30pde", "xen_10pdev", "xen_9perror", "xen_9qde", "xen_9pconf", "xen_30padevice", "xen_109pdev", "xen_09fdem", "xen_9tdev", "xen_109ncache", "xen_9cpdev", "xen_9ldiv", "xen_9dconf", "xen_09pgu", "xen_9fev", "xen_9pderror", "xen_9pgu", "xen_9peengine", "xen_9pedevice", "xen_ninepengine", "xen_16pdev", "xen_9pde", "xen_9pcdev", "xen_9ipserver", "xen_9lpdevice", "xen_29pcprof", "xen_9ude", "xen_09pDev", "xen_10pcdi", "xen_ninefengine", "xen_9rdef", "xen_9pidev", "xen_9appdev", "xen_09cdevice", "xen_9erdi", "xen_9qdev", "xen_9lptr", "xen_09ferror", "xen_9erdevice", "xen_09pserver", "xen_9rdev", "xen_09perror", "xen_9lpdev", "xen_109pconf", "xen_10pcdevice", "xen_9ddev", "xen_9lconf", "xen_10pdevices", "xen_9phome"], "s": ["server", "service", "spec", "sa", "r", "d", "n", "g", "params", "m", "sync", "settings", "c", "p", "services", "w", "e", "f", "o", "v", "stats", "b", "S", "t", "session", "states", "fs", "ssl"], "fsdev": ["dsdef", "fsDev", "dsdev", "fsconf", "wsdev", "fsdef", "nsconf", "wsDev", "wsdef", "dsconf", "nsdef", "dsDev", "wsconf", "nsDev", "nsdev"], "str": ["dr", "name", "Str", "ss", "rs", "txt", "expr", "data", "r", "rr", "strings", "ct", "sp", "sl", "priv", "dict", "arr", "kr", "pass", "bl", "inner", "hr", "stri", "code", "fr", "err", "cr", "tr", "z", "style", "st", "c", "p", "pr", "w", "e", "doc", "f", "ocr", "br", "text", "sc", "ctr", "set", "exec", "sr", "sta", "t", "line", "val", "STR"], "ring_order": ["ring__order", "ring_position", " ring_ordered", "ring__type", "ring_ordered", " ring_type", " ring_position", "ring__position", "ring_type", "ring__ordered"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    /* subframe header */\n\n    count += 8;\n\n\n\n    /* subframe */\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        /* warm-up samples */\n\n        count += pred_order * sub->obits;\n\n\n\n        /* LPC coefficients */\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        /* rice-encoded block */\n\n        count += 2;\n\n\n\n        /* partition order */\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        /* residual */\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n", "idx": 35, "substitutes": {"s": ["sg", "js", "service", "src", "cs", "ctx", "ss", "spec", "qs", "ts", "rs", "sb", "a", "r", "ans", "is", "sl", "ins", "ms", "g", "j", "m", "ses", "ls", "xs", "ds", "sets", "gs", "ns", "l", "c", "services", "self", "e", "f", "es", "us", "sys", "sq", "conf", "sc", "o", "v", "b", "su", "S", "os", "session", "ks", "sim", "bs", "fs", "si", "sym"], "sub": ["pl", "src", "sup", "ss", "sb", "ab", "ub", "data", "oper", "form", "new", "rob", "sam", "com", "type", "bc", "sl", "job", "th", "pb", "py", "super", "rb", "ses", "info", "slice", "ch", "func", "rc", "config", "sel", "trans", "pred", "l", "self", "lc", "per", "f", "child", "conf", "sc", "sq", "exec", "summary", "ray", "sing", "sec", "sum", "ubs", "lib", "b", "su", "sim", "full", "reg", "si", "pro", "part", "uc", "desc", "Sub", "bad"], "pred_order": ["pred_grade", " pred_err", "red_error", "pred_desc", "pred_ind", "pred_rank", "red_desc", " pred_rank", "prediandesc", " pred_end", "pred_page", "predallind", "pred_enter", "predialerr", "pred_error", "pred_err", " pred_enter", "predialorder", " pred_ind", "predallrank", "pred_dir", " pred_grade", "prediandir", "red_order", "pred_end", "predialgrade", "predallorder", "predianerror", "predialpage", " pred_page", "predianorder", "red_dir"], "p": ["np", "lp", "a", "pe", "pi", "r", "d", "n", "type", "ap", "sp", "k", "op", "api", "pre", "y", "po", "tp", "j", "m", "g", "code", "fp", "P", "pos", "ep", "ps", "ip", "l", "c", "pa", "pr", "x", "e", "f", "pu", "patch", "u", "jp", "o", "v", "pc", "point", "bp", "at", "b", "cp", "t", "wp", "part", "dp", "pp"], "porder": ["cord", " pord", "cname", " pcode", "pacode", "cpenter", "porders", "paoder", "ipid", "poder", "pcorder", "Pord", " porders", " penter", "horders", "paorder", "pcode", "Pname", "cattr", "hOrder", "horder", "hattr", "paid", " pattr", "csize", "pname", "pord", "pid", "pOrder", " pOrder", "Porder", "cpname", "cOrder", "pdesc", " pid", " pdesc", "pcname", "ipcode", "corders", "center", "Pdesc", "pcdesc", " pname", " poder", "Psize", "penter", "cpord", "cporder", "pattr", "corder", "iporder", "ipoder"], "psize": ["upsization", "PSize", "opsizing", "rosize", "PSization", "rosization", "upsizing", "opsizer", "linesization", "upssize", "rossize", "psizer", "blockssize", "hesized", "ksizing", "PSIZE", "opsiz", "ppsizer", "PSiz", "upsizer", "psizing", "epsized", "roscale", "upsiz", "psIZE", "ksizer", "epsization", "epsize", "linesiz", "hesizer", "ppsize", "epsizer", "upsize", "psiz", "hesize", "linesIZE", "ppsized", "ppsization", "psized", "opsize", "upsIZE", "blocksize", "blocksization", "hesization", "pscale", "pssize", "upscale", "ksize", "ksiz", "blockscale", "linesize", "psization"], "i": ["li", "a", "ni", "ii", "ui", "pi", "d", "I", "n", "di", "is", "sp", "mi", "it", "k", "iu", "parent", "end", "api", "y", "j", "m", "info", "ini", "index", "z", "multi", "ai", "ie", "x", "l", "c", "ip", "bi", "phi", "ind", "e", "f", "u", "jp", "ori", "o", "v", "at", "b", "ix", "t", "uri", "ci", "io", "start", "si", "xi"], "part_end": [" part_sign", "partpend", "part_limit", "part_id", " part_start", "part67start", "partipend", "art_edge", "part_start", "art_start", " part_address", "part_sign", "part67center", "partpset", "part_set", " part_center", "part_head", "part_edge", " part_head", "partpsign", "part_begin", " part_set", "part_address", " part_edge", " part_limit", "partipset", " part_append", "part67address", "art_ends", "part_append", " part_id", "part_center", "part67end", "art_end", " part_begin", "partipsign", "part_ends"]}}
{"project": "qemu", "commit_id": "24408a7d2b459bed3697367b81ada76518ca96ef", "target": 0, "func": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 43, "substitutes": {"args": ["sg", "parser", "np", "arg", "ig", "missing", "cs", "any", "ass", "spec", "qs", "conn", "actions", "flags", "aws", "use", "is", "ins", "Arg", "empty", "ms", "client", "arms", "arr", "enc", "api", "ids", "g", "GS", "params", "powers", "err", "resources", "ras", "utils", "parse", "ams", "config", "gs", "ds", "md", "ns", "gas", "doc", "words", "atts", "arm", "cmd", "alloc", "uments", "Args", "ks", "ants", "msg", "init", "states", "apps", "plugins", "parts"], "cpu_model": ["cpu_buffer", "cpu_image", "cpu_language", "gpu_language", "cpujbuffer", "gpu_module", "gpu_location", "gpu_model", "cpujmodel", "cpu_location", "cpu_mode", "gpu_image", "cpujlocation", "gpu_mode", "cpu_module", "cpujmodule", "gpu_buffer"], "kernel_filename": ["boot__file", "kernelblocksize", "kernel_file", "boot__prefix", "kernel__filename", "cpu_filename", "kernel_size", "cpu_username", "boot__filename", "kernel_shell", "boot_prefix", "kernel_files", "kernel_username", "kernel__file", "kernelpyshell", "kernelpyfilename", "boot_file", "boot_files", "kernelblockshell", "boot__files", "boot_filename", "kernelpysize", "kernelpyusername", "kernelblockusername", "kernel__prefix", "cpu_shell", "kernel__files", "cpu_size", "kernelblockfilename", "kernel_prefix"], "kernel_cmdline": ["kernel_wdline", "kernel_hostspace", "kernel___cmdlined", "kernel___awkmode", "kernel_awkline", "kernel_hostline", "kernel_commandmode", "kernel_hostclass", "kernel_commandlined", "kernel_cmdspace", "kernel_cmdclass", "kernel_bitline", "kernel___cmdline", "kernel_bitclass", "kernel_bitspace", "kernel_cmdmode", "kernel___awklined", "kernel_awklined", "kernel_commandline", "kernel___cmdmode", "kernel_wdspace", "kernel_awkmode", "kernel_wdclass", "kernel___awkline", "kernel_cmdlined"], "initrd_filename": ["initrs_prefix", "initrt_filename", "initrt_sequence", "initrs_filename", "initrd_loader", "initrd_prefix", "initrd_description", "initrd_file", "initrt_file", "initrd_sequence", "initrt_description", "initrs_file", "initrs_loader"], "boot_device": ["cpu_directory", "bootpoolunit", "cpu_order", "boot_directory", "cpuingunit", "boot_order", "bootpooldirectory", "cpuingorder", "bootpoolorder", "cpuingdirectory", "bootingunit", "cpu_unit", "cpuingdevice", "cpu_device", "bootingdevice", "bootpooldevice", "bootingdirectory", "boot_unit", "bootingorder"], "cpu": ["vm", "gpu", "prem", "lp", "gc", "mx", "process", "clock", "GPU", "lu", "nic", "boot", "fps", "CPU", "proc", "pool", "pkg", "pu", "cache", "sys", "processor", "node", "linux", "pc", "cp", "gp", "pp", "mem"], "env": ["eu", "cli", "exe", "conn", "host", "visor", "environment", "global", "ssh", "kernel", "proc", "network", "config", "ec", "opt", " environment", "dev", "loader", "conf", "docker", "cache", "exec", "en", "ev", "cfg", "mode", "net", "port"], "phb": [" php", " phbi", "uphbs", "shbs", " phbs", "shb", "uphbi", "phbs", "uphp", "uphb", "shbi", "phbi", "shp", "php"], "i": [" bi", "a", "ni", "ii", "d", "I", "n", "is", "iu", "j", "m", "z", "ip", "c", "p", "e", "f", " I", "o", "s", "qi", "b", "t", "ci", "io", "in", "xi"], "sysmem": ["procmem", "ysram", "systemmor", "syslim", "sysMem", "systemlim", "systemrem", " sysrem", "systemmem", "sysram", "systemMem", " syslim", "sysrem", "procram", "sysmor", " sysram", "procmor", " sysMem", "procMem", "ysmem", " sysmor", "ysrem", "systemram", "yslim"], "ram": ["row", "cam", "gram", "access", "dim", "process", "image", "sam", "rams", "mm", "Ram", "iam", "param", "mac", "ream", "RAM", "disk", "man", "AM", "resource", "rom", "rum", "container", "sim", "gra", "nam", "mem"], "rma_alloc_size": ["rma_alloc_width", "rma_alloc_sized", "rma_init_scale", "rma_initssize", "rma_initsize", "rma_alloc_SIZE", "rma_initsnumber", "rma_init_address", " rma_loc_size", "rma_allocnsize", "rma_allocnize", "rma_alloc_capacity", "rma_initsscale", "rma_allocacscale", "rma_alloc_number", "rma_allocensize", "rma_allocacsized", "rma_allocenSIZE", "rma_init_number", " rma_alloc_scale", " rma_alloc_address", "rma_allocenscale", "rma_alloc_scale", "rma_allocfcount", " rma_loc_small", "rma_init_ize", "rma_allocssize", " rma_alloc_small", " rma_loc_address", "rma_allocfsize", "rma_allocnnumber", "rma_alloc_address", "rma_allocensized", "rma_allocacSIZE", "rma_allocfwidth", "rma_alloc_ize", "rma_allocsscale", "rma_allocfloc", "rma_init_size", "rma_allocacsize", " rma_loc_scale", "rma_alloc_loc", "rma_alloc_count", "rma_allocsize", "rma_allocsnumber", "rma_allocnscale"], "load_limit": ["load_scale", "loadlexmodel", "loader_scale", "loader_lim", "loadlexlevel", "load_level", "loadlexscale", "loader_model", "loadlexlim", "load_lim", "loadlexlimit", "loader_level", "load_model", "loader_limit"], "rtas_limit": ["rtas_limited", "rtasayadjust", "rtasaylimits", "rta_limited", "rtAS_lim", "rtas67limited", "rtas_limits", "rtAS_limit", "rtos_limit", "rtos64adjust", "rta_limit", "rtas_adjust", "rtos64limit", "rtas64limit", "rtos64size", "rtas67limit", "rtas64adjust", "rtos_size", "rtos_limits", "rtAS_limits", "rtas64limits", "rtas67default", "rtAS_size", "rtas_size", "rtos64limits", "rtas67lim", "rtos_adjust", "rta_default", "rtas_default", "rtas_lim", "rta_lim", "rtasaylimit", "rtas64size", "rtasaysize"], "fw_size": ["fw67ui", "fw67limit", "fw67size", "hw_ui", "hw_size", "fw_name", "fw_limit", "hw_limit", "fw_ui", "hw_name", "fw67name"], "filename": ["unit", "files", "name", "src", "alias", "url", "memory", "shell", "fn", "label", "Filename", "file", "fp", "password", "description", "word", "dll", "original", "username", "phrase", "prefix", "uri", "path", "mode", "root", "timeout", "title"], "spapr": ["upippr", "spaperr", "spapner", " spaprar", "spmapr", "spappner", "spAPr", "spAPar", " spaptr", " spapew", "spamprc", " spapp", "spajr", "spaxr", "spaxri", " spapsr", "SPaptar", "SPapprs", "spaperar", "sparpnr", "upaprs", "spappingr", "passapre", " spaprr", "spapsnr", " spapw", " spaptnr", "spatr", "spaperpr", " spapers", "spapsrs", "spapew", "passappingre", "sparpb", "spapenr", "spajrs", "spaperrs", "spaprs", "spappw", "spaxner", "spaptb", "spipppr", "spraprc", "swapner", "spapsrr", "spatf", "swaprc", "SPaptrs", "sparprc", " spapf", "SPaptr", "passappingr", "spappnr", "spapre", "upapar", " spaperc", "spappp", "sparpw", "spaptl", "spaptrs", "swapri", "spaptr", "spastrator", "spaxrc", "spajer", "spaptR", "spaprb", "sparpf", "passapnr", "SPaper", "sprapp", "spapnr", "swapr", "spatl", " spaptf", "spappr", "spapeb", "spapar", "spippar", "spapsr", "upappr", "SPappnr", "spaperc", "spapR", "spappingf", "spapsrc", "spamper", "spmaprator", "spapprb", "SPaptR", "spAPR", " spaperb", " spappr", "upipprs", "spapprar", "spastrc", "spapf", "spaprr", "spAPrs", "passappingf", " spapprc", " spaptrs", "spapw", " spapnr", "spaper", "spapl", "upippar", "spaptar", "sprapr", " spaptner", "sparpre", "spapeer", "spraprs", "spappingre", "spAPrc", "spapear", "spaprar", " spapl", "swaptri", "SPapnr", " spapser", "sparprs", " spaperar", "spastr", "spajnr", " spaprator", "spaptf", " spaprb", "spAPrar", "upipppr", "spappl", " spapper", "spepr", "sparprb", "spaprc", "speprc", "spmaprar", "spaptner", " spappp", " spaptl", "spapser", "SPaprs", "spapprc", " spapprator", " spaper", "SPapr", "spaprator", "passapr", "spaptrc", " spapprs", "SPappr", "spapprr", "spaptri", "spaptnr", " spapsrs", " spapb", "spappf", " spaprs", "spapsp", "spampr", "spaperb", " spapsrc", "spraprar", "spapper", "spapprs", "spapb", "spappingnr", "spipprs", "passappingnr", "swaptner", "SPapR", "sparpr", "spapprator", "spmaprc", "SPapar", " spaptb", "spastrar", "SPapper", "spatner", " spapprr", "swaptrc", "spippr", "spaptre", "spepri", "swaptr", "spapri", " spaprc", "passapf", " spapprar", "spapp", "spepner", "spapepr", " spapner", "spapers", "upapr", "spamprr"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60, "substitutes": {"avctx": ["akcas", "AVsrc", "afcontext", "avcus", "mpctx", "mpcontext", "aphcontext", "aphctx", "avglobal", "afcn", "avelc", "navsrc", "afloc", "avecas", "avkw", "abconfig", "avcontext", "aveloc", "navconn", "afcmd", "aphctrl", "akctx", "avecci", "allcontext", "afcmp", "AVcontext", "avcms", " avconn", "mpconfig", "avecu", "ovcontext", "alltx", "avectx", "avecf", "afctx", "navctx", "aveconn", "akcontext", " avcmp", "apbuf", "alllc", "avcf", "ovcmd", "aphcms", "avalconn", "afconn", "AVcms", "AVglobal", "avcn", "avconfig", "avalcontext", "aucontext", "ovkw", "auloc", "abcontext", "AVcmp", "allctx", "avecmp", "avcas", "avalctx", "airloc", " avcus", " avloc", "afcas", " avkw", "avtx", "abcmp", "aftx", "aircontext", "apcontext", "afglobal", "navctrl", "afkw", "afbuf", "auctx", "ovctx", "abctx", "aucn", "avctrl", "afcu", "afcf", "aflc", "avsrc", "mpcmp", "avecus", "apconn", "afconfig", "AVctx", " avglobal", "avcmd", "avbuf", " avbuf", "avconn", "AVctrl", "avalcci", "navcms", "AVconn", " avcontext", "afcci", "avcci", "afcus", "avalcu", "apctx", "navcontext", "avetx", "avloc", "akcf", "airconn", " avcmd", "avecontext", "avcu", " avcn", "avlc", "avcmp", "airctx", "avalsrc"], "buf": ["fd", "src", "buffer", "ctx", "bn", "byte", "sb", "queue", "data", "ab", "bc", "buff", "bin", "pb", "num", "batch", "rb", "fp", "cb", "config", "raw", "block", "cv", "vec", "nb", "bd", "ref", "cache", "gb", "cmd", "alloc", "fb", "b", "seq", "conv", "uf", "img", "rc", "mem"], "buf_size": ["buf_align", "buflexsize", "imglexsize", "wav_SIZE", "wavetSIZE", "bufetlen", "wav_size", "wavetlen", "imglexdepth", "bufetsize", "buf_SIZE", "buflexdepth", "img_align", "buflexalign", "wavetsize", "wav_shape", "buf_shape", "buf_len", "img_depth", "wav_len", "bufetshape", "img_size", "wavetshape", "bufetSIZE", "buf_depth", "imglexalign"], "s1": ["wsone", "ws1", " s0", "s0", "qsOne", " sOne", "scone", "cs2", "s01", "sc11", "s11", "svone", "sone", "S01", "SOne", "qsone", "sv01", "c11", "cOne", "ws11", "s2", " s2", "Sone", "qs01", "sOne", "c1", "cs1", "sc1", "csOne", "cs0", "S1", "qs1", "c2", "c0", "ws2", "cone", "sv1", "sc2", "svOne"], "s": ["sg", "js", "qs", "n", "sl", "client", "g", "ses", "ls", "sf", "args", "storage", "us", "f", "secondary", "sys", "u", "your", "an", "se", "fs", "parts", "sup", "spec", "ts", "sb", "aws", "y", "xs", "sets", "p", "e", "conf", "su", "site", "S", "t", "ks", "os", "session", "serv", "its", "hs", "sym", "plugins", "ssl", "cs", "ctx", "ss", "a", "rs", "new", "r", "is", "ins", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "ops", "d", "sk", "comments", "sync", "l", "services", "w", "sq", "b", "full", "states"], "height": ["resolution", "capacity", "device", "dim", "head", "stroke", "ty", "png", "lat", "direction", "home", "alpha", "pages", "manager", "arrow", "rh", "ows", "Height", "host", "image", "ht", "ui", "id", "html", "xy", "gap", "y", "max", "gallery", "mac", "layout", "length", "inches", "driver", "huge", "bottom", "input", "gh", "media", "crop", "version", "build", "above", "fw", "data", "tight", "slice", "h", "pad", "deep", "rank", "size", "rows", "history", "definition", "times", "img", "volume", "shape", "timeout", "total", "gpu", "def", "high", "window", "d", "devices", "distance", "show", "th", "grow", "duration", "dy", "hung", "style", " heights", "thin", "w", "density", "padding", "container", "depth", "dist"], "i": ["ii", "pi", "d", "n", "I", "mi", "it", "k", "y", "m", "info", "z", "ai", "x", "h", "l", "p", "c", "f", "u", "b", "ci", "io", "si", "in"], "v": ["q", "vt", "r", "d", "n", "video", "k", "y", "g", "m", "sv", "z", "h", "l", "c", "p", "w", "e", "f", "u", "V", "o", "b", "t", "va", "volume"], "j": ["js", "adj", "q", "ji", "r", "n", "J", "k", "aj", "ij", "y", "g", "pos", "m", "z", "ch", "h", "l", "x", "p", "w", "jp", "obj", "o", "b"], "aspect": ["Aspect", "exct", "aspec", "acess", "masspect", "act", "Asception", "Aspects", "asspects", "assct", "apects", "apec", "asspect", "ASpect", "raspecting", "expecting", "ASception", "maspect", "expect", " aspec", "maspects", "aspir", " asception", "ASpec", "ASpects", " ascess", "assspect", "asspecting", "asspir", "asception", "raspect", "apir", " asct", " aspir", "aspecting", "apect", "maspec", "Aspec", "rasct", "aspects", "asspec", "asscess", "exspect", "rasspect", "ascess", " aspects", "asct"]}}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70, "substitutes": {"drc": ["Dsrc", "bsrc", " dpc", "tsc", " dvc", "sdrc", "adirc", "idsrc", "dspc", "ddc", "bpc", "brc", "dsrec", "tvc", "dsc", " duc", "brec", "puc", "dsirc", "ldrec", "psrc", " dsrc", " droc", "drec", "sdsc", "dRC", "Drc", "dirc", "proc", "sdvc", " dirc", "iduc", "adsrc", "adrc", " dsc", "sddc", "dsrc", "duc", " ddc", "idroc", "ldrc", "prc", "adRC", "DRC", " dRC", " drec", "ldpc", "idrc", "trc", "ldsrc", "droc", "dvc", "dpc", "Dirc", "dssrc", "tdc", "ldirc"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 83, "substitutes": {"r": ["ur", "rg", "dr", "this", "ner", "rs", "gr", "rw", "wr", "rr", "d", "ru", "c", "rec", "cur", "k", "lr", "arr", "rf", "kr", "g", "rb", "m", "hr", "ra", "nr", "er", "fr", "err", "request", "ir", "str", "tr", "cr", "runner", "result", "l", "p", "pr", "h", "w", "self", "e", "rl", "ro", "or", "br", "ar", "attr", "u", "R", "sr", "rd", "mr", "v", "b", "req", "rx", "t", "rar", "re", "nor", "vr", "rh", "res", "rc"], "s": ["service", "cs", "http", "ss", "a", "ts", "rs", "qs", "sb", "spec", "d", "aws", "is", "y", "m", "ses", "ls", "sync", "ds", "status", "ps", "gs", "ns", "c", "p", "state", "w", "e", "services", "f", "es", "sys", "sc", "as", "stats", "b", "S", "os", "session", "bs", "fs", "si", "ssl"], "n": ["mn", " err", "no", " number", "dn", " len", "adj", "ni", "nn", " network", "d", " count", "nc", "pn", "un", " size", "span", "ng", "ne", "na", "fn", "nu", " i", "i", "y", "j", " p", " index", "g", "m", "eni", "none", "k", " l", "nt", " no", "z", " ns", "ns", "x", "N", "l", "p", "c", "nl", "e", "nb", "f", "len", "w", "cn", " ng", "u", "nan", "num", " na", "node", "en", "o", "v", "nm", " c", "sn", "b", "nw", "t", " conn", " N", "an", "nor", "net", " num"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void lm32_evr_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    hwaddr ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    hwaddr timer0_base = 0x80002000;\n\n    hwaddr uart0_base  = 0x80006000;\n\n    hwaddr timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"lm32_evr.sdram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 84, "substitutes": {"machine": ["base", "vm", "service", "device", "M", "process", "data", "image", "computer", "memory", "class", "template", "model", "instance", "space", "mac", "m", "proc", "Machine", "database", "storage", "config", "state", "loader", "cache", "message", "game", "object", "node", "linux", "connection", "module", "manager", "usb", "mode", "mem"], "cpu_model": ["cpufmodel", "core_models", " cpu_mode", "processor_server", "cpuObase", "cpu67server", "cpuOmodel", "cpuacmode", "core_model", "cpuacscale", "cpuOsettings", "cpu00settings", "gpu_base", "processor_model", " cpu_settings", "core_base", "cpu5base", "cpu_settings", "cpufserver", "cpuacbase", "cpu67model", "cpu_location", "cpu_mode", "gpu_models", "cpufmodule", "gpu_mode", "cpuacmodel", "cpu67base", "core_server", "core_mode", "cpu00params", "cpu_params", "cpu67source", "cpuOparams", "cpu_base", "cpu_server", "cpu5source", "cpu5server", "cpufmode", "cpu_module", "cpu00model", "cpu_models", "cpu_source", "cpu5model", "core_module", "gpu_model", "processor_source", " cpu_scale", "processor_base", " cpu_base", "cpu00base", "core_location", " cpu_params", "cpu_scale"], "kernel_filename": [" kernel__filename", "licenseblocklanguage", "kernelblocklanguage", "kernel__manager", "kernel_file", "license_name", "kernel__filename", "kernelblockfile", "license_language", "license_filename", "kernel_model", "licenseblockfilename", "kernelpmanager", "kernel_language", "kernelblockname", "kernel_name", " kernel_prefix", "kernelpmodel", "license_file", "kernelpfilename", " kernel_model", "licenseblockname", "kernel__prefix", "kernel__model", " kernel_manager", "licenseblockfile", " kernel__model", "kernelpprefix", " kernel__prefix", "kernelblockfilename", " kernel__manager", "kernel_prefix", "kernel_manager"], "cpu": ["unit", "np", "ilo", "vm", "cli", "consumer", "gpu", "prem", "ctx", "hw", "roc", "ni", "gc", "queue", "process", "memory", "computer", "clock", "GPU", "lu", "nc", "nic", "platform", "nu", "ne", "num", "boot", "instance", "kernel", "component", "hu", "eni", "CPU", "proc", "none", "pai", "python", "pool", "bench", "home", "result", "lc", "pu", "loader", "core", "cn", "cache", "jp", "chip", "cap", "processor", "node", "linux", "pc", "prefix", "cp", " CPU", "cmp", "uca", "module", "net", "performance", "console", "mem"], "env": ["eu", "np", "vm", "exe", "ext", "extra", "conn", "context", "window", "environment", "shell", "profile", "ea", "scope", "life", "enc", "ef", "eni", "args", "network", "password", "err", "style", "enabled", "config", "ec", "exc", " environment", "Environment", "state", "e", "theme", "loader", "core", "cache", "conf", "skin", "exec", "viron", "uv", "en", "ev", "manager", "online", "path", "engine", "img", "qt", "dir", "console", "energy", "db"], "dinfo": [" dconf", "dstate", "linfo", "dlfo", "pinfo", " dfi", " dstate", "bdinfo", "derror", "lderror", "tinfo", "ldinf", "bdinf", "dconf", "finfo", "dlresult", "bdresult", "terror", "dignore", "ldconf", "dlinfo", "bdfo", " dinf", "dinf", " dignore", " derror", "pinf", "dlignore", "lfi", "dresult", "ldinfo", "dfo", " dfo", "finf", " dresult", "dlfi", "lignore", "tinf", "dfi", "fconf", "linf", "dlinf", "pstate", "tstate"], "address_space_mem": ["address_space_memory", "address_service_ram", "address_space_ram", "address_space24ram", "address_space_mb", "address_service_mb", "address_pace_ram", "address_space_info", "address_service_mem", "address_space24mem", "address_pace_mem", "address_service_memory", "address_pace_info", "address_space24info"], "phys_ram": ["Phys_rom", "phys_scale", "phys_gram", "phys_region", "phys_disk", "physmmdim", "mount_disk", "physCram", "physurecontainer", "physmmscale", "physCrom", "Phys_system", "physCsystem", "mount_ram", "mount_dim", "physmmram", "phys_sam", "iosureregion", "iosurecontainer", "ios_region", "physureram", "ios_container", "iosureram", "ios_ram", "iosuregram", "phys_rom", "physmmdisk", "phys_system", "physCsam", "physureregion", "Phys_sam", "Phys_ram", "mount_scale", "phys_container", "physuregram", "phys_dim", "ios_gram"], "irq": ["interk", " irror", "irror", "iriror", " irk", " irqs", "interror", "interq", "irqs", "iriqs", "interqs", "iriq", "irik", "irk"], "reset_info": ["flush_init", "resetablethin", "resetjinformation", "resetoutbase", "resetinginfo", "resetableresult", "reset_hand", "reset2information", "reset2info", "flush_inf", "flusherhand", "resetoutinformation", "resetjcount", "reset2source", "resetjinfo", "resetallcount", "resetableinfo", "device_information", "resetingthin", "device_base", "resetjbase", "reseterinformation", "device_info", "flush_info", "sync_source", "flush_hand", "sync2info", "deviceoutinformation", "sync2source", "reseterinfo", "reset_thin", "reset_init", "reset2index", "resetingresult", "reset_base", " reset_result", "flusherinf", "deviceoutbase", "sync_index", "resetersource", "deviceoutinfo", "resetoutcount", "resetingdata", "sync2index", "reset_information", "resetoutinfo", "reset_source", "reset_data", "sync_info", "reset_count", "device_count", "sync_information", "sync2information", "reseterindex", "reset_inf", "resetallinformation", " reset_data", "resetallbase", "flusherinfo", "reseterinit", " reset_thin", "reseterhand", "reseterinf", "resetabledata", "flusherinit", "resetallinfo", "reset_result", "reset_index", "deviceoutcount"], "i": ["a", "ii", "pi", "mini", "r", "d", "I", "is", "id", "iu", "j", "m", "z", "ip", "l", "c", "p", "disk", "e", "f", "u", "o", "v", "s", "b", "io", "xi"]}}
{"project": "qemu", "commit_id": "cf57298af5336df2aece47ef16c290a3a81457dd", "target": 0, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 108, "substitutes": {"argv": ["Argv", "agve", "argumentv", "paramp", "agv", "argvin", "argsl", "Argvs", "argc", " argl", "pgc", "pgv", "ArgV", "axvs", "Argsv", "pgvin", "axver", "pgp", "Argc", "argsV", " argve", "argV", "Argvin", "argumentc", "argsp", " argvs", "agver", "argve", "argumentsv", "axp", "axc", "Argf", "agc", "argumentp", " argsv", "argl", "axv", "argver", "Argl", "paramv", " argf", "argsv", " argV", " argver", "Argp", "argsf", " argp", "argsc", "argvs", "argf", "axve", "paramsv", " argvin", "argp", " argc", "paramc"], "p": ["np", "q", "lp", "pe", "pi", "r", "d", "n", "sp", "pb", "api", "pre", "j", "g", "tp", "y", "m", "fp", "P", "z", "pattern", "pointer", "ps", "pa", "l", "h", "pad", "ip", "e", "f", "u", "jp", "o", "pc", "bp", "v", "at", "b", "cp", "t", "count", "wp", "pt", "part", "pp", "port"], "nr_iov": ["sr_liv", "nr_ovi", "nr_nih", "nrlexiov", "nr_iago", "nr_ilo", "nc_iov", "nrleximedia", "nl__iov", "nrqvre", "nrlexnih", "invxiov", "nr_liv", "nl_ilo", "inv_ovi", "nr__rolet", "nr_iop", "invxovi", "nr__ovi", "ncleximedia", "nrxiov", "nr_rolet", "nl_ovi", "nr_vre", "inv_iago", "nl_rolet", "nrxiago", "nrxeni", "nrlexilo", "nrqiop", "invxeni", "nl__ilo", "nc_nih", "nclexiov", "nr_eni", "nc_ilo", "nrqiov", "inv_eni", "nr_imedia", "nl__rolet", "nr__ilo", "sr_iop", "nrqliv", "nl__ovi", "nl_iov", "sr_iov", "nc_imedia", "nrxovi", "nr__iov", "sr_vre", "inv_iov", "invxiago", "nclexnih", "nclexilo"], "i": ["ami", "li", "gi", "ni", "ii", "zi", "pi", "ui", "oi", "n", "I", "di", "mi", "it", "iu", "k", "api", "j", "y", "m", "eni", "ri", "inner", "info", "ti", "ini", "index", "multi", "ani", "ai", "ie", "x", "ind", "l", "phi", "bi", "ip", "hi", "f", "e", "adi", "u", "o", "v", "s", "ki", "b", "qi", "ix", "t", "uri", "ci", "fi", "si", "xi"], "c": ["cs", "q", "cc", "r", "d", "n", "nc", "cur", "cy", "k", "end", "enc", "g", "ac", "m", "code", "cr", "z", "ch", "C", "ec", "dc", "ce", "x", "l", "h", "xc", "e", "lc", "f", "col", "unc", "u", "cmd", "vc", "o", "pc", "s", "v", "b", "t", "cf", "ci", "count"], "ctx": ["fc", "cm", "cli", "cs", "local", "kb", "hw", "conn", "context", "anc", "cc", "command", "gc", "cl", "fw", "loc", "ct", "ck", "nc", "bc", "voc", "tc", "client", "cus", "na", "cas", "instance", "fp", "tx", "sync", "cb", "event", "kw", "utils", "config", "pkg", "cu", "cv", "xc", "pa", "lc", "cn", "ca", "ctrl", "wcs", "exec", "sc", "git", "cmd", "obj", "vc", "la", "cca", "connection", "prefix", "lib", "qa", "cp", "cmp", "cf", "conv", "ci", "cfg", "sci", "console", "qq", "rc", "wx"], "acb": ["accbo", "aclb", " acbi", "acbi", "aclbook", "aclB", " accbo", "acbo", " accB", "ocbi", "acB", "ocbook", "aclbi", "accb", "ocb", " acbook", "ocB", " acbo", " accb", "acbook", "accB", " acB"], "optind": ["octnd", "OptInd", "optimind", "optionIND", "octInd", "opii", "optcount", "octint", "optioninn", " optint", "optinc", "opInd", "optann", "optnd", "optioncount", "octinn", "Optnd", "optionnd", " optIND", "optIND", "optinn", "optimann", "optionnt", "altind", "optionid", "octin", "optstart", "altin", "optid", "optionstart", "optionin", "optii", "optiminn", "optin", "optimnd", "altInd", " optinc", "optionind", "optimcount", "openii", "effIND", "optionint", "optiminc", "optionann", "octinc", " optstart", "optnt", "optimInd", "optimin", " optin", "openInd", "optionii", "altIND", "optimint", "effind", "Optid", "optimii", "opnd", " optInd", "octann", "optionInd", " optcount", "Optinc", "openind", "Optind", "optimIND", " optid", "octind", "optimnt", " optinn", "optioninc", "optInd", "opind", "effInd", "optint", "opennt", "effstart"], "len": ["js", "lan", "Len", "url", "n", "field", "dl", "sl", "lang", "ls", "err", "en", "hl", "seq", "lin", "limit", "all", "fun", "name", "ld", "ln", "span", "bl", "lt", "z", "non", "lon", "ler", "lc", "length", "la", "lib", "lit", "count", "val", "layer", "led", "li", "lp", "data", "light", "ail", "bin", "des", "lim", "body", "ll", "str", "fin", "size", "el", "gen", "repl", "list", "le", "mem", "elt", "lf", "fl", "num", "pos", "label", "dy", "coll", "rev", "style", "l", "block", "L", "resp", "min", "depth", "line", "ann", "part", "db"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121, "substitutes": {"dest": ["route", "rest", "dim", "txt", "success", "head", "de", "master", "trip", "err", "home", "opt", "address", "select", "trans", "shift", "path", "start", "option", "est", "name", "sup", "target", "access", "cl", "desc", "Dest", "ui", "id", "parent", "end", "cdn", "camp", "tmp", "coord", "hop", "text", "origin", "die", "session", "transform", "lit", "data", "loc", "member", "cb", "cont", "delete", "feat", "ident", "content", "result", "usr", "ctr", "node", "img", "dist", "mode", "done", "stage", "test", "null", "src", "class", "prop", "orig", "ord", "num", "output", "comb", "source", "temp", "status", "config", "dc", "wb", "draw", "contract", "miss", "west", "sort", "transfer", "table", "db"], "linesize": ["linsize", " linesiz", "inasized", "inasizes", " linesizes", "inasize", "linesized", "nssize", "codesize", "linespace", " linespace", " linesized", "linspace", "codessize", "codesiz", "linesiz", "linessize", " linessize", "nsized", "codespace", "linsiz", "linesizes", "nsizes", "nsize", "inassize", "linssize"], "block": ["unit", "match", "group", "lock", "row", "name", "buffer", "check", "def", "cl", "loc", "type", "bc", "chain", "section", "end", "num", "bl", "none", "event", "source", "config", "address", "word", "col", "ref", "copy", "cache", "contract", "exec", "object", "node", "comment", "Block", "blocks", "clean", "line", "load", "list", "map", "table", "pack"], "i": ["cli", "ami", "li", "gi", "ni", "ii", "zi", "ji", "pi", "ui", "oi", "d", "I", "n", "di", "k", "iu", "api", "j", "m", "ti", "multi", "index", "z", "ai", "ie", "x", "l", "c", "p", "ip", "bi", "hi", "e", "f", "col", "u", "v", "b", "uri", "ci", "io", "mu", "fi", "si", "xi"], "cm": ["cms", "vm", "DC", "cam", "ctx", "CM", "hem", "cum", "em", "cc", "mc", "dim", "bm", "sem", "km", "com", "co", "cy", "im", "mm", "tc", "iam", "param", "m", "gm", "cont", "cr", "om", "config", "address", "dc", "hm", "man", "c", "lc", "dm", "ram", "cn", "ca", "ctrl", "core", "wm", "pm", "cd", "cmd", "comm", "fm", "rm", "center", "rom", "asm", "rem", "um", "cp", "dem", "module", "cf", "car", "ci", "am", "mode", "que", "ym"]}}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n        const char *desc_file_path)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 122, "substitutes": {"desc": ["sub", "name", "src", "ext", "esc", "loc", "d", "Description", "rec", "pb", "des", "code", "dest", "dep", "info", "entry", "config", "asc", "description", "dc", "c", "doc", "diff", "lc", "Desc", "attr", "text", "sc", "exec", "sec", "path", "dir", "uc", "dist", "rc"], "bs": ["ob", "base", "cs", "abi", "ss", "rs", "sb", "bps", "bm", "BS", "ib", "bid", "bc", "banks", "ros", "pb", "tc", "client", "bis", "rb", "ses", "ls", "sync", "cb", "ds", "bas", "ps", "gs", "ns", "bi", "vs", "bos", "gb", "bt", "bb", "ubs", "blocks", "iss", "fb", "b", "os", "fs", "db"], "desc_file_path": ["desc_full_type", "desc_file_size", "desc_file__path", "desc_file2type", "desc_file_name", "desc_file2name", "desc_full_size", "desc_full_path", "desc_file2size", "desc_file_type", "desc_file__type", "desc_file_url", "desc_full_system", "desc_file__size", "desc_file2path", "desc_file_system", "desc_full_name", "desc_full_url", "desc_file__name"], "ret": ["arg", "active", "success", "alt", "rep", "code", "Ret", "reset", "RET", "valid", "rt", "group", "fun", "ext", "format", "id", "rets", "fit", "tmp", "arr", "reply", "sr", "final", "lit", "re", "val", "count", "pt", "det", "base", "att", "mt", "hash", "data", "cat", "proc", "info", "str", "back", "feat", "result", "usr", "bot", "len", "ref", "br", "value", "obj", "error", "sur", "reg", "msg", "iter", "res", "mem", "bad", "match", "def", "bit", "num", "nt", "ft", "rev", "status", "pat", "bf", "try", "rl", "red", "flag", "gt", "art", "al", "let", "part", "db", "rc"], "access": ["route", "test", "name", "src", "buffer", "esc", "key", "ga", "array", "acl", "area", "process", "image", "url", "escape", "use", "open", "id", "parent", "na", "Access", "pass", "param", "ac", "proc", "ses", "password", "request", "index", "sect", "source", "config", "asc", "ec", "address", "select", "resource", "length", "attr", "cache", "sc", "public", "object", "reference", "accessible", "seq", "qa", "error", "path", "view", "mode", "shape", "ace", "acc", "input", "rc"], "type": ["key", "ype", "url", "field", "like", "ty", "code", "file", "address", "self", "comment", "types", "path", "location", "unit", "name", "time", "position", "format", "id", "parent", "off", "y", "model", "post", "resource", "length", "t", "root", "input", "user", "family", "base", "version", "pe", "domain", "op", "search", "pre", "py", "space", "info", "function", "order", "size", "ref", "attr", "app", "date", "value", "o", "error", "TYPE", "shape", "list", "call", "test", "null", "level", "buffer", "alias", "area", "class", "platform", "pos", "label", "none", "Type", "style", "number", "source", "block", "col", "sort", "part", "day"], "fname": ["cname", "fpath", "Fname", "fcnames", "fnam", "fcnam", " fsize", "fcName", "lfName", "Fnames", " fName", " fnam", "lfname", "fcname", " fpath", "fName", "csize", "fnames", "fsize", "cnames", "cpath", "lfnames", " fnames", "Fpath", "Fsize", "lfnam"], "p": ["np", "vp", "ctx", "q", "lp", "a", "data", "r", "d", "n", "ap", "pb", "pair", "j", "g", "i", "tp", "m", "proc", "fp", "P", "python", "pointer", "pat", "h", "pa", "c", "l", "pr", "e", "f", "per", "patch", "jp", "o", "s", "pc", "bp", "point", "b", "cp", "t", "path"], "flat_offset": ["flat_path", "plain67pad", "flat2index", "flat64route", "file_offset", "flat67offset", "single_size", "single_offset", "flat_size", "flat_index", "flat67pad", "lat_start", "file_index", "single64route", "flat64size", "plain_pointer", " flat_off", "plain67pointer", "flat_pad", "flat64offset", "lat_count", "flat33offset", "flat_position", "flatIPindex", " flat_padding", "flat___offset", "file_path", "lat_len", "file2index", "flat_off", "flat33index", "flatacoffset", "flat2reset", "single64pointer", "plain_pad", "lat_offset", "plain_Offset", "flat33reset", "single64offset", " flat_position", "flatIPoffset", "flat___pad", "flat___Offset", "flat33path", "file_reset", "single64size", "flat64pointer", "plain67offset", "flatacpadding", "file2reset", "flatIPpath", "flat2path", "single_pointer", "flat2offset", "flat67Offset", "flat___pointer", "flat_start", "flat_padding", "flatacposition", "single_route", "flat_count", "plain_offset", "flat67pointer", "plain67Offset", "flat_len", "file2path", "flat_reset", "flatacoff", "flat_route", "file2offset", "flat_Offset", "flat_pointer", "flatIPreset"], "extent_path": ["extent_route", "extant_folder", "extent_dir", "extension_template", "extant_route", "extant_config", "extension_url", "extant_path", "extentacurl", "extentacdir", "extent_image", "extent_name", "extentacpath", "extant_name", "extent2template", "extension_name", "extent2dir", "extant_file", "extent_config", "extent_template", "extant_dir", "extent2url", "extent64folder", "extension_dir", "extent64route", "extentactemplate", "extension_image", "extension_path", "extent_folder", "extent64path", "extent2path", "extent_url", "extent64dir"], "extent_file": ["extent__path", "extent__queue", "extract_files", "extension__file", "extent_cache", "extant_files", "extant_path", "extension_file", "extent_files", "extant_file", "extent_filename", "extension_cache", "extension_queue", "extract_filename", "extension__cache", "extract_path", "extension__queue", "extent__file", "extension_path", "extent_info", "extent__cache", "extract_file", "extension__path", "extant_info", "extent_queue"], "local_err": ["localacmessage", "private_error", "local_der", "localapper", "self_err", "locallyer", "localacreq", "remote_ref", "local___error", "remote_er", "localacerr", "localappref", "remote_err", "local_error", "locallyerr", "localacerror", "local_er", "local_bug", "local_message", "self_spec", "localappconn", "local_spec", "locallyconn", "self_req", "self_der", "local_result", " local_message", "remote_conn", "local___err", "local___bug", "localapperr", " local_error", "local_conn", "private_bug", "private_err", "localacder", "locallyref", "localacspec", "local___result", "private_result", "local_ref", "local_req"], "extent": ["xtend", "intent", " extents", "contend", "extend", "intension", "Extent", "intant", " extension", "xtract", "Extension", "intract", " extant", "extant", "Extents", "extension", "xtension", "Extend", "content", "xtent", "extents", "contract", "contant", "xtents", "intend", "extract", "Extant", "xtant"]}}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy(AC3EncodeContext *s)\n\n{\n\n    int nb_coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            /* calculate calculate sum of squared coeffs for one band in one block */\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            /* compare sums to determine if rematrixing will be used for this band */\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            /* determine if new rematrixing flags will be sent */\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n", "idx": 149, "substitutes": {"s": ["sg", "js", "service", "this", "cs", "sup", "ss", "rs", "ts", "qs", "spec", "sb", "d", "n", "sl", "g", "space", "m", "ses", "ls", "sf", "sync", "xs", "sv", "settings", "ds", "sets", "gs", "ns", "l", "c", "p", "services", "e", "self", "f", "es", "sys", "sq", "u", "conf", "south", "o", "v", "blocks", "b", "su", "S", "t", "session", "os", "support", "fs", "si", "sym", "ssl"], "nb_coefs": ["nb_cocfcs", "nb_coefns", "nb_coeffls", "nb_coefi", "nb_Coefficientss", "nb_coiffns", "nb_Coefs", "nb_loefes", "nb_loefs", "nb_loeces", "nb_loecs", "nb_coeffd", "nb_Coefes", "nb_coecs", "nb_Coefits", "nb_loefits", "nb_coeffes", "nb_loecits", "nb_codfs", "nb_coefficientsd", "nb_coiffd", "nb_coeffcs", "nb_coffi", "nb_codfits", "nb_coefficientses", "nb_coefd", "nb_cocfes", "nb_coffns", "nb_Coefficientsd", "nb_coffs", "nb_Coefficientses", "nb_coeffns", "nb_coiffds", "nb_coefficientss", "nb_coeffi", "nb_coiffls", "nb_coiffes", "nb_coiffi", "nb_coiffs", "nb_coefds", "nb_coecits", "nb_Coefd", "nb_coefls", "nb_coefcs", "nb_coiffcs", "nb_coefficientsits", "nb_coiffits", "nb_coeces", "nb_coecd", "nb_coefficientsds", "nb_coeffds", "nb_Coefficientsits", "nb_coeffits", "nb_coefits", "nb_coefes", "nb_coffls", "nb_cocfns", "nb_coeffs", "nb_cocfs", "nb_codfes"], "blk": [" bln", "blck", "plsk", "dlks", "blkt", "brks", "brsk", "blch", "bln", "llsk", "Blsk", " blc", "brch", "brkid", "clk", "brc", "clkt", "plq", "brq", "blkid", "llq", "plch", "BLks", "dlk", " blb", "clb", "plb", "BLk", "clck", "slkt", "dlch", "BLkid", " blck", "brb", "blq", "brck", "plkid", "cln", "blsk", "slb", " blsk", "Blk", "plk", "blb", "plkt", "Blkt", "Blb", "brk", "llck", "Blc", "plck", "dlq", "Blck", "blc", "slk", "llk", "plks", "brkt", " blks", "BLck", " blkt", "sln", "blks"], "bnd": ["brnn", "lbnd", "jobind", "rbind", "brnt", "abnn", "pnt", "bND", "Bdd", "bld", "blND", "lbind", "Bnn", "Bnd", "lbdd", "lind", "Bnt", "pnd", "blend", "bind", " bind", "pind", " bld", "lbld", "blld", "lbnn", "bnt", "bldk", "pld", " bcd", "brind", "bdk", "lnt", "brld", "rbdk", "bbnd", "brnd", "bbld", " bND", " bend", "bdd", "bcd", "abnt", "blnt", "lnd", "jobdk", "abcd", "lcd", "jobnd", " bdk", "bbind", "Bld", " bord", "blord", "BND", "abind", "Bord", "bnn", "bbnt", " bnt", "abnd", "abld", "lbdk", "blnd", "lbnt", "Bind", " bdd", "lld", "rbnt", "jobnt", "blind", "Bend", "rbnd", "bord", "bldd", "blnn", "bend"], "i": ["yi", "ami", "li", "gi", "ni", "ii", "zi", "chi", "ji", "pi", "ui", "r", "d", "I", "di", "n", "id", "mi", "k", "iu", "end", "j", "y", "ri", "m", "info", "ti", "ini", "index", "z", "ai", "ie", "ip", "l", "c", "p", "phi", "bi", "hi", "x", "e", "ki", "vi", "qi", "ix", "t", "b", "uri", "ci", "io", "mu", "fi", "start", "si", "xi"], "block": ["lock", "row", "panel", "clock", "j", "address", "ack", "f", "child", "object", "join", "comment", "unit", "flow", "group", "cl", "tag", "type", "BL", "bc", "chain", "k", "parent", "frame", "off", "bl", "tx", "work", "p", "book", "layout", "Block", "plugin", "session", "init", "layer", "base", "build", "section", "inner", "slice", "ref", "cache", "obj", "node", "o", "bb", "error", "anch", "check", "http", "def", "bo", "scope", "un", "builder", "output", "label", "none", "box", "sync", "coll", "number", "style", "contract", "point", "blocks", "b", "full", "line", "product"], "block0": ["Block2", "group4", "run0", "lock2", " block4", "framezero", "lock1", "Blockzero", " block00", "group00", " block1", "block4", "block2", "run00", "group0", "block00", "frame0", "group2", " blockzero", "frame2", "run4", "run2", "Block0", "blockzero", "frame1", "Block1", " block2", "block1", "lock0"], "sum": ["unit", "match", "group", "cost", "vol", "total", "mass", "skip", "gram", "ass", "ul", " summ", "cum", "sa", "key", "hash", "ss", "cal", "data", "sun", "class", "add", "weight", "type", "cat", "out", " sums", "sh", "dict", "use", "mit", "neg", "num", "pass", "max", "pos", "Sum", "info", "style", "index", "parse", "average", "result", "alpha", "state", "us", "size", "mean", "cache", "miss", "mask", "summary", "min", "up", "comment", "um", "scale", "sign", "dot", "sort", "su", "mix", "count", "si", "part", "diff", "mem"]}}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164, "substitutes": {"x0": [" x5", "X00", " x3", "X2", " x80", "tx1", "X5", "X0", "Te", "y0", "T2", " x50", "X3", "Xee", " xee", "T0", "tx3", "T5", "X50", "t2", "t0", "t50", "xee", "x2", "yee", "T3", "t1", " x2", "X80", "T00", "Xe", "x3", "y2", " x00", "y1", "x50", "xe", "x80", "tx80", "tx0", "x00", "T1", "x5", " xe", "X1"], "x1": ["X2", "tone", "X01", "t81", "X81", "X0", "ax2", "x01", "ax0", "index0", "t0", "x81", "x2", " xone", "t1", " x81", "xone", " x01", " x2", "index01", "Xone", "ax1", "index1", "axone", "X1"]}}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n", "idx": 176, "substitutes": {"env": ["stage", "np", "vm", "server", "conn", "context", "her", "forest", "environment", "global", "priv", "scope", "end", "buf", "eng", "enc", "erv", "args", "code", "password", "er", "settings", "config", "ec", "exc", "e", "attr", "conf", "core", "uv", "forge", "loader", "viron", "en", "iv", "ev", "manager", "path", "dir", "console", "db"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178, "substitutes": {"env": ["buffer", "ctx", "context", "device", "data", "global", "environment", "nc", "scope", "enc", "py", "proc", "code", "config", "ec", "p", "dev", "e", "core", "all", "exec", "viron", "en", "ev", "path", "console", "rc", "port"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n", "idx": 179, "substitutes": {"s": ["js", "cs", "ss", "ops", "rs", "ts", "qs", "sb", "r", "d", "n", "is", "ins", "ans", "ms", "i", "g", "m", "ls", "ses", "uns", "plugins", "sync", "ds", "ps", "gs", "ns", "h", "c", "p", "sie", "services", "w", "e", "private", "f", "es", "us", "sys", "sq", "as", "sr", "stats", "su", "b", "S", "os", "ks", "session", "site", "bs", "its", "hs", "states", "se", "fs", "si", "sym", "ssl"], "link_down": ["link_update", "linkingdown", " link_off", "linkerdowns", "linkingup", " link_move", "linkingdowns", "linkfdown", "linkingown", " link_downs", " link_state", "linkingoff", "linkingupdate", " link_up", "link_downs", "link_move", "linkacupdate", " link_left", "link67left", "link67downs", "link_left", "linkfup", "linkfstate", " link_update", "linkeroff", "link_own", "linkerup", "link67down", "linkfupdate", "linkacstate", "linkerdown", "link_up", "link_off", "linkerown", "link67up", "linkacdown", "linkacup", "linkerleft", "link_state", " link_own"]}}
{"project": "FFmpeg", "commit_id": "3547f8e8f8418af0c578eba0de62ecba08e460c2", "target": 0, "func": "static int rv34_decode_mv(RV34DecContext *r, int block_type)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int i, j, k, l;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int next_bt;\n\n\n\n    memset(r->dmv, 0, sizeof(r->dmv));\n\n    for(i = 0; i < num_mvs[block_type]; i++){\n\n        r->dmv[i][0] = svq3_get_se_golomb(gb);\n\n        r->dmv[i][1] = svq3_get_se_golomb(gb);\n\n    }\n\n    switch(block_type){\n\n    case RV34_MB_TYPE_INTRA:\n\n    case RV34_MB_TYPE_INTRA16x16:\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        return 0;\n\n    case RV34_MB_SKIP:\n\n        if(s->pict_type == AV_PICTURE_TYPE_P){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n            break;\n\n        }\n\n    case RV34_MB_B_DIRECT:\n\n        //surprisingly, it uses motion scheme from next reference frame\n\n        /* wait for the current mb row to be finished */\n\n        if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n\n            ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0);\n\n\n\n        next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride];\n\n        if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        }else\n\n            for(j = 0; j < 2; j++)\n\n                for(i = 0; i < 2; i++)\n\n                    for(k = 0; k < 2; k++)\n\n                        for(l = 0; l < 2; l++)\n\n                            s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);\n\n        if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) //we can use whole macroblock MC\n\n            rv34_mc_2mv(r, block_type);\n\n        else\n\n            rv34_mc_2mv_skip(r);\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        break;\n\n    case RV34_MB_P_16x16:\n\n    case RV34_MB_P_MIX16x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n        break;\n\n    case RV34_MB_B_FORWARD:\n\n    case RV34_MB_B_BACKWARD:\n\n        r->dmv[1][0] = r->dmv[0][0];\n\n        r->dmv[1][1] = r->dmv[0][1];\n\n        if(r->rv30)\n\n            rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        else\n\n            rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);\n\n        break;\n\n    case RV34_MB_P_16x8:\n\n    case RV34_MB_P_8x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n\n        if(block_type == RV34_MB_P_16x8){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n\n            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n\n        }\n\n        if(block_type == RV34_MB_P_8x16){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n\n            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n\n        }\n\n        break;\n\n    case RV34_MB_B_BIDIR:\n\n        rv34_pred_mv_b  (r, block_type, 0);\n\n        rv34_pred_mv_b  (r, block_type, 1);\n\n        rv34_mc_2mv     (r, block_type);\n\n        break;\n\n    case RV34_MB_P_8x8:\n\n        for(i=0;i< 4;i++){\n\n            rv34_pred_mv(r, block_type, i, i);\n\n            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);\n\n        }\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 185, "substitutes": {"r": ["ur", "dr", "rg", "rs", "gr", "rr", "d", "n", "ru", "kr", "rf", "g", "rb", "m", "hr", "ri", "nr", "ra", "er", "fr", "ir", "cr", "tr", "usr", "result", "p", "c", "w", "e", "pr", "ocr", "f", "self", "br", "ar", "R", "sr", "mr", "v", "o", "rss", "b", "t", "rar", "re", "rt", "rh", "res", "rc"], "block_type": ["commentingTYPE", " block_year", "blockertype", "blockftyp", "blockableyear", "blockworkconfig", "commentingstyle", "block_style", "lock_index", "blockftype", "block_typ", "Block_type", "lock_name", "block_index", "comment_TYPE", "blockingtype", "blockablename", "blockablefamily", "blockerindex", "blockworkTYPE", "block_number", "lock_number", "blockername", "blockablenumber", "comment_type", "blockingstyle", "block_name", "block_config", "blockableindex", "blockworktype", "comment_config", "blockworkstyle", "block_TYPE", "Block_typ", "comment_style", "blockingTYPE", " block_style", "Block_size", "blockfstyle", "commentingconfig", "blockfsize", "blockablestyle", "block_size", "Block_style", "lock_type", "block_family", "blockernumber", " block_family", "commentingtype", "blockabletype", "blockingconfig", "block_year"], "s": ["sg", "js", "this", "sa", "qs", "n", "sp", "sl", "g", "ses", "ls", "sf", "storage", "x", "us", "self", "f", "sys", "sc", "u", "en", "se", "fs", "parts", "spec", "ts", "sb", "aws", "ims", "y", "xs", "sv", "z", "p", "e", "lines", "conf", "v", "su", "site", "S", "t", "session", "os", "ks", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "data", "is", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "server", "service", "http", "ops", "strings", "d", "results", "scope", "comments", "sync", "services", "w", "sq", "b", "full"], "gb": ["rg", "sg", "cm", "gpu", "gi", "gram", "kb", "hw", "ga", "sb", "gc", "bm", "ui", "hub", "mb", "gy", "eb", "gh", "gom", "gnu", "bc", "sl", "ge", "GB", "gin", "g", "gg", "rb", "gm", "gn", " rgb", "cb", "storage", "gam", "gs", "bf", "hm", "cv", "vg", "sc", "bg", "bb", "pc", "tm", "gl", "abb", "usb", "ci", "cfg", "gp", "gd", "db"], "i": ["yi", "li", "gi", "abi", "a", "ni", "ii", "zi", "ji", "pi", "ui", "oi", "d", "I", "n", "di", "is", "mi", "it", "iu", "api", "y", "g", "m", "eni", "ri", "info", "ti", "ini", "z", "multi", "index", "ai", "ie", "x", "c", "p", "h", "bi", "ip", "e", "f", "lc", "u", "ki", "v", "o", "b", "qi", "ix", "t", "uri", "ci", "io", "mu", "init", "fi", "si", "in", "xi"], "j": ["li", "q", "jl", "ii", "ji", "d", "n", "J", "y", "g", "pos", "py", "m", "z", "ie", "h", "c", "p", "f", "o", "v", "b", "t", "si"], "k": ["q", "key", "d", "n", "K", "sk", "y", "g", "m", "z", "h", "c", "p", "w", "e", "f", "u", "kk", "o", "v", "ki", "b", "ks"], "l": ["li", "lp", "lb", "n", "sl", "lr", "nl", "g", "m", "ls", "ll", "z", "h", "c", "p", "L", "e", "lc", "f", "kl", "len", "el", "o", "v", "b"], "next_bt": ["nextPBT", "next67bol", " next_bb", "nextJBT", "nextJbn", "next67bt", "nextJbh", "next67bh", "nextPbn", "nextJbt", "next_bol", "nextPbb", " next_bn", "next_bh", "next_bn", "next67BT", " next_BT", "nextJbb", "next_BT", "nextJbol", " next_bol", "nextPbt", "next_bb", " next_bh"]}}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}", "idx": 200, "substitutes": {"bs": ["js", "src", "cs", "ctx", "http", "bh", "ops", "ss", "rs", "sb", "bps", "lb", "hub", "BS", "bid", "bc", "banks", "ins", "pb", "boot", "bing", "fps", "bl", "bis", "proxy", "plugins", "ls", "ses", "bits", "settings", "source", "ds", "utils", "config", "bas", "ps", "gs", "ns", "bus", "bot", "css", "vs", "state", "bos", "gb", "bt", "obj", "ubs", "iss", "bb", "b", "os", "bytes", "its", "fs", "db", "obs", "ssl"], "target": ["unit", "match", "server", "src", "buffer", "ctx", "tor", "version", "conn", "device", "tail", "host", "url", "image", "type", "head", "Target", "scope", "parent", "platform", "client", "remote", "builder", "output", "proxy", "component", "master", "project", "nt", "source", "config", "address", "native", "result", "bus", "bot", "top", "state", "resource", "core", "object", "origin", "range", "goal", "connection", "b", "site", "plugin", "t", "manager", "port", "location", "path", "root", "net", "arget", "db", "ssl"], "replaces": ["preplaced", "greacements", "broadps", "remplace", "remplaces", "preceptions", "preacements", "greplace", "replaced", "reverts", "recholders", "preplace", "creps", " reholders", "recplaced", "reholders", "Replaced", " receptions", " reverts", "Replace", "remplaced", "greleases", "greps", "creacements", "greplaced", "creplaced", "replace", "preps", "reps", "releases", "remverts", "creplaces", "Reacements", "creholders", "broadplaces", " reacements", "preholders", "remacements", "preleases", "greplaces", "remholders", "broadacements", "reacements", "broadholders", "preverts", "remps", "receptions", "creleases", "preplaces", "remleases", " replaced", "recplaces", "recceptions", "Replaces"], "speed": ["delay", "service", "src", "ss", "rate", "spec", "priority", "grade", "url", "weight", "sl", "scope", "duration", "seed", "proxy", "score", "sync", "direction", "slice", "source", "settings", "status", "config", "address", "select", "size", "length", "drive", "scale", "stats", "strength", "sort", " source", "port", "engine", "support", "mode", "slave", "performance", "timeout", "ssl"], "granularity": ["regacity", "regulation", "granulation", "regularity", "ranular", "genular", "generular", "genity", "genulation", "sanularity", "gunity", "granule", "ginularity", "gnity", "gunulation", "generality", "genulus", "generularity", "sanality", "granapore", "gnular", "generacity", "sanulation", "kinity", "gunulus", "granality", " granulation", "genacity", "generity", " granule", " granulus", "kinacity", "generapore", "granity", "granular", " granular", "sanacity", "gnule", "sanibility", "gnularity", "regibility", "ranulation", "ginulation", " granacity", "generule", "ginular", "granacity", "granibility", "kinularity", "genularity", "kinulus", "ginulus", "gunular", "regality", "ranularity", "regapore", " granity", "sanapore", "regity", " granibility", "granulus", "sanity", "gunularity", "ginity", "ranulus"], "buf_size": ["buflexsize", "cv_loc", " buf2size", "buf_scale", "buf\u00b7size", "buff\u00b7size", "buflexize", "buf_ize", "buf64strength", "buff\u00b7strength", "buff_sum", "bufflength", " buf2rate", " buf2scale", "buf64rate", "buf_capacity", "buflexunit", "buff_size", "buff_capacity", " buf2depth", "buff\u00b7unit", "buffaddress", "cv_size", "buf2size", " buf_depth", "buf64sum", "buflexdepth", "buf_sum", "buf_number", "buf64unit", "cv_weight", "buff_number", "buf_rate", "cv_content", " buf_scale", "bufgsize", "buf_unit", "buf_depth", "buff_length", "buf64address", "buf_strength", "buf\u00b7unit", "buf2depth", "buf_content", "bufgloc", "buf64scale", "buf64depth", "buf\u00b7strength", "buf_length", "buff_address", "bufgcontent", "buflexcapacity", "buf_weight", "buf64size", "buffsize", "buff_depth", "buf_loc", "buff_ize", "buf2scale", "buff_unit", "buf_address", "buflexnumber", "buff\u00b7depth", "buf64length", "bufgweight", "buflexstrength", " buf_rate", "buf2rate", "buff_strength", "buf\u00b7depth", "buffsum"], "on_source_error": ["on_src_ror", "on_target_errors", "on_src_change", "on_resource_error", "on_sourceayevent", "on_edgearyerror", "on_edge_change", "on_source_errors", "on_edge_close", "on_edge_error", "on_sourcearyerror", "on_resource_errors", "on_source_event", "on_resource_environment", "on_source_ror", "on_source_change", "on_src_errors", "on_source2error", "on_sourceayenvironment", "on_source2response", "on_resource_event", "on_source_close", "on_sourceayerrors", "on_source_response", "on_target_response", "on_sourcearychange", "on_sourcearyclose", "on_source_err", "on_src_error", "on_target_err", "on_edgearychange", "on_edgearyclose", "on_source2ror", "on_sourceayerror", "on_target_ror", "on_source_environment"], "on_target_error": ["on_source_err", "on_site_ror", "on_source_comment", "on_targetingerror", "on_source_danger", "on_target_err", "on_targetxevent", "on_source_operation", "on_targetingdanger", "on_targetingror", "on_target_danger", "on_site_err", "on_targetapperror", "on_targetapperr", "on_targetxerr", "on_targetxerror", "on_target_operation", "on_targetaldanger", "on_targetingcomment", "on_targetalcomment", "on_targetalerror", "on_site_error", "on_targetappror", "on_target_ror", "on_site_event", "on_targetappoperation", "on_target_comment", "on_source_ror", "on_targetxror", "on_target_event", "on_targetalror"], "unmap": ["Unmaps", "UnMAP", "munblock", "unmaps", "munmap", "Unmap", "bitMAP", "munmaps", "unMAP", "bitmaps", "munMAP", "bitblock", "bitmap", "unblock", "Unblock"], "cb": ["ob", "grab", "cli", "src", "cs", "ctx", "conn", "gc", "CB", "cpp", "hub", "ck", "nc", "callback", "bc", "buff", "fn", "pb", "buf", "rb", "fp", "sync", "func", "runner", "c", "cv", "unc", "conf", "ctrl", "gb", "exec", "handler", "cmd", "bb", "fb", "cp", "cmp", "finder", "cf", "conv", "socket"], "opaque": ["opacity", "opaques", "OPacity", "opsaques", "ospaque", "spacity", "opac", "OPac", "operaque", "spaque", "OPace", "opscc", "opace", "space", "opicit", "operac", "operace", " opicit", "OPaque", "ospaques", "operacity", "opcc", " opcc", " opaques", "opsicit", "opsaque", "ospcc", "spac", "ospicit"], "errp": ["dern", "iern", "Erp", "derps", " errtp", "eorp", "erpc", "rrpc", "ierps", "errtp", "Err", "armps", "gerp", "armpa", "derp", "nerpc", "errfp", "errpc", "iterp", "gerpa", "rrr", "errn", " erp", " erping", " errr", "Erpc", "iterfp", "errping", "eorping", " erf", "err", "erpa", "Erfp", " errps", " errping", "rrcp", " erpc", "iterps", "gerfp", "eorps", "errr", "errps", " ertp", "armn", "ercp", "iterpa", " erps", "eorf", " errpc", "nertp", "erp", "nerps", " errcp", "nerp", "gerps", "ierpa", " errf", " errfp", "erps", "errf", "errpa", "errcp", "armp", "derpa", "ierp", "erfp", "rrp"], "driver": ["dr", "test", "src", "wrapper", "host", "browser", "director", "operator", "client", "builder", "proxy", "master", "settings", "source", "utils", "ds", "config", "bus", "reader", "design", "force", "drive", "core", "cache", "handler", "river", "creator", "Driver", "finder", "plugin", "manager", "port", "engine", "mode", "dist", "drivers", "ssl"], "is_none_mode": ["is_none_match", "is_partial_source", "is_none_mod", "is_partial_only", "is_nonealgrade", "is_noneingmod", "is_defaultalmode", "is_default_mode", "is_nonefulldirection", "is_nonealerror", "is_nonelymode", "is_default_error", "is_partial_mode", "is_nonealsize", "is_one_mod", "is_nonelygrade", "is_none\u00b7error", "is_partial_direction", "is_nonelyerror", "is_none_only", "is_none\u00b7match", "is_none_direction", "is_nonefullsource", "is_default_match", "is_none\u00b7mode", "is_noneofsource", "is_nonelymatch", "is_defaultalgrade", "is_none_size", "is_one_mode", "is_none_source", "is_nonealmatch", "is_nonefullmode", "is_none\u00b7grade", "is_nonealmod", "is_noneofdirection", "is_noneingmode", "is_one_size", "is_nonealmode", "is_noneofmode", "is_noneofonly", "is_none_grade", "is_nonefullonly", "is_none_error", "is_defaultalmatch", "is_noneingsize", "is_defaultalerror", "is_default_grade"], "base": ["unit", "server", "service", "buffer", "area", "security", "host", "type", "Base", "store", "chain", "scope", "parent", "boot", "client", "frame", "remote", "pre", "builder", "proxy", "sync", "master", "source", "storage", "status", "bas", "address", "bot", "state", "resource", "size", "force", "cache", "core", "stable", "origin", "range", "shadow", "kit", "prefix", "scale", "b", "site", "port", "support", "root", "db", "family"], "s": ["sg", "server", "js", "service", "cs", "sup", "http", "ss", "ops", "rs", "ts", "spec", "qs", "new", "r", "d", "n", "is", "ins", "sl", "client", "bis", "m", "ses", "ls", "sf", "sync", "settings", "request", "ds", "sets", "ps", "gs", "native", "ns", "h", "l", "c", "p", "services", "w", "e", "f", "es", "conf", "sq", "u", "sports", "sys", "o", "ubs", "v", "stats", "su", "single", "S", "os", "session", "b", "t", "port", "full", "hs", "its", "states", "fs", "si", "sym", "parts", "ssl"]}}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "substitutes": {"qi": ["Q", "li", "gi", "q", "quad", "fen", "qs", "ei", "ii", "zi", "chi", "lli", "ni", "pi", "mini", "di", "cci", "ffe", "iq", "i", "eni", "iaz", "plug", "aka", "pai", "ani", "ini", "dq", "ai", "ie", "adi", "bi", "iana", "ahi", "sq", "gui", "jp", "qa", "agi", "ci", "mu", "qt", "fi", "qq", "si", "qua", "xi"]}}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);", "idx": 244, "substitutes": {"ctx": ["cms", "cm", "cli", "cam", "cs", "kb", "hw", "conn", "context", "anc", "cc", "Context", "loc", "bc", "voc", "cas", "tx", "config", "pkg", "c", "cv", "xc", "lc", "conf", "sc", "ca", "ctrl", "cn", "vc", "connection", "cca", "pc", "qa", "cp", "cmp", "cf", "conv", "ci", "sci", "rc"], "gb": ["rg", "cli", "gio", "kb", "ga", "ges", "sb", "gc", "bm", "ub", "ui", "hub", "eb", "mb", "gy", "lb", "gru", "go", "gnu", "bc", "buff", "ge", "gz", "GB", "gin", "gg", "rb", "gm", "cb", "storage", "gs", "bf", "nb", "wb", "git", "bg", "vc", "bb", "bp", "tm", "cca", "lib", "b", "pc", "abb", "usb", "cfg", "gp", "gd", "db", "game"], "vlc": ["tllc", "mlc", "llf", "hlp", "lllc", "lvf", "lvk", "vllc", "mlp", "lvlc", "tlc", "lvc", "vlp", "mlcs", "hlcs", "llcs", "hlc", "vlf", "llv", "vlcs", "tlk", "hlv", "mlv", "llp", "llc", "llk", "vlv", "tlf", "vlk"], "symbols": ["symbolals", "Symbles", "SyMBics", "symbolol", "sympolic", "SyMBols", "Symbics", "SyMBals", "syembolic", "symmolic", "symathents", "SyMBels", "Symbels", "Symbals", "SyMBolic", "symples", "symbolonds", "syMBol", "symbol", "symbents", "syMBents", "symathols", "syembals", "symbolents", "syembols", "Symbents", "symmols", "symmels", "sympels", "SyMBol", "symbics", "syMBolic", "syMBols", "symathol", "symbonds", "symbolics", "sympols", "symbals", "Symbols", "syMBics", "syembics", "syMBonds", "syMBals", "symbels", "syMBels", "SyMBles", "Symbolic", "syMBles", "symbolic", "SyMBonds", "symathonds", "Symbol", "symbles", "SyMBents", "symbololic", "symmles", "Symbonds", "symbolols"], "bits": ["limits", "files", "cs", "bugs", "ops", "bit", "vals", "ips", "ries", "flags", "jobs", "ins", "locks", "bis", "fixes", "checks", "batch", "frames", "cats", "ls", "code", "details", "info", "ports", "outs", "utils", "pieces", "config", "ps", "status", "errors", "x", "words", "ints", "bands", "cache", "pins", "s", "ubs", "blocks", "stats", "b", "points", "bytes", "its", "bs", "states", "init", "parts"], "codes": ["windows", "odes", "maps", "cs", "ops", "sequence", "zip", "cells", "flags", "strings", "jobs", "locks", "fixes", "checks", "pos", "frames", "cats", "code", "params", "ls", "cb", "ports", "names", "cards", "outs", "cod", "config", "status", "errors", "ns", "x", "c", "items", "ones", "values", "css", "lines", "es", "length", "cache", "steps", "rows", "cases", "cycles", "seq", "bytes", "ci", "xxx", "states"], "num_lens": ["num_tayers", "num_sens", "num_Locks", "num_slenth", "num_sowers", "num_lowers", "num_lleng", "num_layers", "num_lenth", "num_denth", "num_slocks", "num_dayers", "num_llens", "num_Lens", "num_towers", "num_Len", "num_dowers", "num_len", "num_slens", "num_locks", "num_Lenses", "num_sen", "num_slenses", "num_docks", "num_ten", "num_sayers", "num_tens", "num_Leng", "num_den", "num_deng", "num_llen", "num_lenses", "num_denses", "num_Lenth", "num_dens", "num_leng", "num_llenth"], "num_codes": ["num_bits", " num_checks", "numxcod", " num_maps", "sum_codes", "sum_lines", " num_cases", "num_cod", "num_cells", "numNconfig", "num_lines", "numxcode", " num_lines", "numxmaps", "num_checks", "numNcells", "numxchecks", "num_code", "numxcases", " num_cod", "sum_config", "numNcodes", "num_config", "num_maps", "sum_cells", "numxcodes", "numxlines", "num_cases", " num_code", "numNlines", " num_bits", "numxbits"], "num_codes_sum": ["num_bits_vol", "num_codes_mm", "num_lines_size", "num_errors_count", "num_codes_num", "num_codes___max", "num_codes_range", "num_bits_max", "num_codes___range", "num_comments_all", "num_comments_sum", "num_bits_sum", "num_lines_sum", "num_comments_num", "num_bits_size", "num_errors_sum", "num_codes___sum", "num_errors_mm", "num_codes_um", "num_comments_mm", "num_codes_size", "num_errors_size", "num_lines_num", "num_bits_range", "num_bits_count", "num_codes_max", "num_lines_um", "num_codes_vol", "num_codesavenot", "num_codes_not", "num_codes_all", "num_bits_not", "num_codes___vol", "num_codesavesum", "num_codesavesize", "num_codes_count", "num_codesavecount"], "prefix": ["base", "delay", "name", "offset", "skip", "key", "sequence", "counter", "zip", "priority", "jj", "weight", "position", "type", "wrap", "format", "parent", "num", "gap", "pre", "label", "code", "master", "number", "index", "pointer", "status", "post", "result", "pad", "c", "p", "len", "length", "ref", "fix", "patch", "cache", "hop", "reset", "range", "sum", "padding", "bp", "scale", "seq", "ix", "req", "magic", "mix", "radius"], "i": ["li", "gi", "offset", "key", "a", "ni", "ii", "zi", "ji", "pi", "ui", "d", "I", "n", "di", "id", "mi", "iu", "k", "y", "eni", "code", "info", "ini", "index", "ai", "ie", "x", "ip", "c", "l", "p", "ind", "bi", "e", "f", "u", "jp", "v", "b", "qi", "ix", "ci", "io", "fi", "si", "in", "xi"], "j": ["js", "li", "q", "jl", "key", "ii", "ji", "r", "d", "n", "jj", "J", "job", "it", "k", "aj", "ij", "num", "y", "g", "pos", "m", "jo", "code", "z", "index", "ch", "h", "l", "c", "p", "ind", "jc", "x", "f", "br", "u", "jp", "jet", "dj", "o", "v", "b", "ja"], "count": ["match", "call", "base", "test", "name", "check", "offset", "q", "skip", "counter", "key", "zip", "ii", "process", "current", "n", "weight", "use", "id", "parent", "found", "handle", "num", "loop", "batch", "g", "member", "label", "code", "coll", "number", "z", "index", "ch", "x", "l", "c", "p", "ind", "w", "e", "order", "f", "len", "length", "col", "size", "fix", "cache", "patch", "conf", "child", "core", "sum", "seq", "b", "session", "depth", "low", "Count", "limit", "list", "start"]}}
{"project": "FFmpeg", "commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "target": 1, "func": "static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,\n\n                                  CodedBitstreamUnit *unit)\n\n{\n\n    BitstreamContext bc;\n\n    int err;\n\n\n\n    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n\n    if (err < 0)\n\n        return err;\n\n\n\n    switch (unit->type) {\n\n    case HEVC_NAL_VPS:\n\n        {\n\n            H265RawVPS *vps;\n\n\n\n            vps = av_mallocz(sizeof(*vps));\n\n            if (!vps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_vps(ctx, &bc, vps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_vps(ctx, vps);\n\n            if (err < 0) {\n\n                av_free(vps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = vps;\n\n        }\n\n        break;\n\n    case HEVC_NAL_SPS:\n\n        {\n\n            H265RawSPS *sps;\n\n\n\n            sps = av_mallocz(sizeof(*sps));\n\n            if (!sps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_sps(ctx, &bc, sps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_sps(ctx, sps);\n\n            if (err < 0) {\n\n                av_free(sps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = sps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_PPS:\n\n        {\n\n            H265RawPPS *pps;\n\n\n\n            pps = av_mallocz(sizeof(*pps));\n\n            if (!pps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_pps(ctx, &bc, pps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_pps(ctx, pps);\n\n            if (err < 0) {\n\n                av_free(pps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = pps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_TRAIL_N:\n\n    case HEVC_NAL_TRAIL_R:\n\n    case HEVC_NAL_TSA_N:\n\n    case HEVC_NAL_TSA_R:\n\n    case HEVC_NAL_STSA_N:\n\n    case HEVC_NAL_STSA_R:\n\n    case HEVC_NAL_RADL_N:\n\n    case HEVC_NAL_RADL_R:\n\n    case HEVC_NAL_RASL_N:\n\n    case HEVC_NAL_RASL_R:\n\n    case HEVC_NAL_BLA_W_LP:\n\n    case HEVC_NAL_BLA_W_RADL:\n\n    case HEVC_NAL_BLA_N_LP:\n\n    case HEVC_NAL_IDR_W_RADL:\n\n    case HEVC_NAL_IDR_N_LP:\n\n    case HEVC_NAL_CRA_NUT:\n\n        {\n\n            H265RawSlice *slice;\n\n            int pos, len;\n\n\n\n            slice = av_mallocz(sizeof(*slice));\n\n            if (!slice)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n\n            if (err < 0) {\n\n                av_free(slice);\n\n                return err;\n\n            }\n\n\n\n            pos = bitstream_tell(&bc);\n\n            len = unit->data_size;\n\n            if (!unit->data[len - 1]) {\n\n                int z;\n\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n\n                       \"from slice data.\\n\", z);\n\n                len -= z;\n\n            }\n\n\n\n            slice->data_size = len - pos / 8;\n\n            slice->data = av_malloc(slice->data_size);\n\n            if (!slice->data) {\n\n                av_free(slice);\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(slice->data,\n\n                   unit->data + pos / 8, slice->data_size);\n\n            slice->data_bit_start = pos % 8;\n\n\n\n            unit->content = slice;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_AUD:\n\n        {\n\n            H265RawAUD *aud;\n\n\n\n            aud = av_mallocz(sizeof(*aud));\n\n            if (!aud)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n\n            if (err < 0) {\n\n                av_free(aud);\n\n                return err;\n\n            }\n\n\n\n            unit->content = aud;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 245, "substitutes": {"ctx": ["fc", "cm", "cli", "cam", "kb", "hw", "conn", "context", "cc", "gc", "anc", "Context", "gru", "loc", "ct", "ck", "nc", "voc", "cci", "scope", "grad", "cas", "auc", "component", "kt", "tx", "coll", "lex", "sync", "kw", "utils", "crit", "config", "pkg", "cu", "c", "cv", "xc", "lc", "ocr", "cn", "wcs", "ctrl", "vc", "cca", "connection", "lib", "cp", "cmp", "req", "cf", "conv", "ci", "sci", "rc"], "unit": ["layer", "base", "null", "letter", "capacity", "version", "service", "piece", "build", "target", "split", "term", "device", "ui", "type", "uni", "position", "format", "transfer", "section", "it", "un", "num", "instance", "update", "package", "output", "component", "language", "kin", "item", "number", "style", "source", "crit", "address", "category", "block", "book", "lc", "size", "condition", "force", "reason", "u", "object", "note", "comment", "connection", "Unit", "plugin", "site", "module", "element", "uri", "rule", "relation", "volume", "units", "user", "option"], "bc": ["fc", "cm", "cms", "wic", "lic", "context", "cc", "sb", "mc", "acl", "gc", "cl", "lb", "nc", "tc", "cas", "ac", "tx", "coll", "cb", "circ", "config", "ec", "bf", "dc", "c", "xc", "CBC", "jc", "lc", "bitcoin", "oc", "ca", "sc", "ctrl", "gb", "vc", "bg", "pc", "bb", "bp", "cca", "ucc", "cf", "uca", "ci", "BC", "cfg", "uc", "db", "rc"], "err": ["dr", "go", "wr", "norm", "yr", "ver", " error", "hr", "er", "ir", "opt", "ind", "pr", "dev", "aster", "magic", "var", "valid", "Er", "all", "rh", "ise", "rage", "ner", "spec", "der", "eor", "arr", "y", "later", "nr", "fg", "ler", "e", "sr", "mr", "count", "init", "fer", "erer", "better", "icer", "gr", "Error", "rr", "more", "lr", "kr", "inner", "ini", "str", "cr", "result", "rag", "usr", "order", "ref", "attr", "br", "arm", "orr", "orer", "error", "req", "rar", "msg", "iter", "test", "far", "fy", "orig", "ry", "ah", "bug", "fr", "owner", "reader", "doc", " Err", "ar", "resp", "min", "acer", "nor"], "vps": [" veps", " vpes", "sops", "hpps", "vp", "vPs", "sveps", "spp", "svpp", "pops", " vpa", "vists", "vports", "veps", "mps", "vops", "hsp", "fpps", "hips", "vip", "vips", " vPS", " vips", "svips", "fps", "fpes", "fips", "vieps", " vp", "viops", "svps", "avPS", "vsp", "svpps", " vops", "ppp", "vpp", "svops", "VPs", "hps", "svsp", "pPS", "viports", "svpes", "viPs", "viists", "mips", "fpa", "vPS", "Vps", " vpp", "svports", "Vops", " vists", "vpes", "svPS", " vports", "svp", "vpa", "avips", "sips", "Vists", " vsp", "avps", "avp", "mpa", " vPs", "vpps", "mpps", " vpps"], "sps": [" samps", "paps", "vpl", "sesps", "pls", " sips", " spt", " sases", "samps", "slips", "sases", "dits", "spped", "pamps", "slases", "vaps", " sapes", "saps", "sips", "sper", "gspt", "gsps", "sups", "spl", "sespped", "gspped", "sits", "vls", " sper", "dps", "symps", "dips", "sandpped", "ppos", "sesper", "sandips", "vpos", " spped", "pips", " spos", "suips", "sandits", "paves", " sls", "sapes", "skypped", "sandps", "ssp", "sympt", "vips", "pamples", "supped", "sespe", "slps", "skysp", "sympped", "skyips", "sls", "spt", "samples", "skyps", " ssp", " spl", "saves", "spe", "slapes", " samples", "dpped", " saps", " spe", "susp", "ppl", " saves", "symips", "spos", "gsips"], "pps": ["pl", "phones", "clips", "charges", "js", "alls", "ops", "ppa", "bps", "cpp", "ips", "upp", "eps", "ppers", "ypes", "tracks", "pg", "pes", "px", "ipes", "ppy", "hops", "apps", "fps", "params", "aps", "packs", "powers", "push", "xs", "ports", "ds", "mph", "ps", "akes", "ups", "steps", "inches", "posts", "jp", "php", "mp", "pins", "acts", "amps", "pull", "icks", "drops", "cp", "points", "types", "ks", "forces", "pots", "pp"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n", "idx": 246, "substitutes": {"opaque": ["opacity", "oplatile", "patile", "opula", "operacre", "oplula", " opatile", "operaque", "opacre", "pula", " opacity", " opula", "oplacity", "operane", "operacity", " opacre", "opane", "pacity", "opatile", " opane", "pacre", "pane", "oplaque", "paque"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248, "substitutes": {"priv": ["conn", "mod", "device", "pi", "tty", "prop", "auth", "deb", "api", "proc", "info", "pod", "aud", "pid", "ch", "rc", "impl", "pub", "pad", "reader", "pred", "prom", "private", "attr", "Priv", "gb", "eth", "pc", "ev", "cp", "req", "riv", "pro", "pri", "pack"], "id": ["name", "fd", "def", "sid", "url", "ad", "d", "type", "oid", "head", "ID", "end", "parent", "did", "ids", "i", "ider", "Id", "code", "info", "mid", "event", "pid", "ident", "aid", "ip", "pad", "ind", "kid", "p", "iden", "ptr", "f", "ide", "ref", "error", "uid", "req", "hid", "path", "root", "one", "start"], "bulk_packet": ["bulk_plugeting", "bulk_packacket", "bulk_formET", "bulk_pacart", "bulk_sexer", "bulkjpayet", "bulk_byteET", "bulk_paramer", "bulk_promacket", "bulk_packart", "bulk_paramET", "bulkjpackload", "bulk_payET", "bulkenpackpoint", "bulk_compete", "bulk_paramant", "bulk_packsel", "bulk_scette", "bulk_compset", "bulk_packant", "bulk_packer", "bulk_compant", "bulk_framete", "bulk_packete", "bulkenpackET", "bulkenbyteET", "bulk_requestet", "bulk_promette", "bulk_packET", "bulk_hookant", "bulk_compet", "bulk_bytepoint", "bulk_scet", "bulk_packset", "bulk_promet", "bulk_packette", "bulk_formpoint", "bulk_sexacket", "bulkjpacket", "bulk_frameting", "bulkjpackET", "bulk_framet", "bulk_paramet", "bulk_packageacket", "bulk_hookET", "bulk_pluget", "bulkjpackant", "bulk_hookart", "bulk_comper", "bulk_plugET", "bulk_hookette", "bulk_requestette", "bulkenpackete", "bulk_packageel", "bulk_packsacket", "bulk_hookad", "bulk_payant", "bulk_packseting", "bulk_compart", "bulk_comppoint", "bulk_packageant", "bulkjpayant", "bulkenbyteete", "bulk_packageET", "bulk_sexet", "bulk_hooket", "bulk_pacet", "bulk_packageette", "bulk_byteet", "bulkjpayload", "bulk_packageet", "bulk_paramette", "bulk_packload", "bulk_formete", "bulk_packad", "bulk_plugete", "bulk_formet", "bulk_promET", "bulk_compette", "bulkenbytepoint", "bulk_byteete", "bulk_packeting", "bulk_hookset", "bulk_sexET", "bulkjpayET", "bulk_compET", "bulk_competing", "bulk_scad", "bulk_packageeting", "bulk_paramad", "bulk_packageload", "bulk_pacET", "bulk_packel", "bulk_compacket", "bulk_payet", "bulkenbyteet", "bulkenpacket", "bulk_scant", "bulk_payload", "bulk_compel", "bulk_compload", "bulk_framET", "bulk_requestET", "bulk_packpoint", "bulk_paramacket", "bulk_pacset"], "data": ["device", "rec", "open", "empty", "next", "options", "args", "err", "message", "DATA", "valid", "all", "name", "ata", "da", "read", "extra", "zip", "parent", "api", "package", "fail", "write", "bus", "p", "resource", "length", "val", "load", "response", "input", "version", "a", "new", "complete", "i", "body", "info", "str", "raw", "content", "result", "pad", "len", "size", "cache", "connection", "error", "bytes", "Data", "mem", "done", "delay", "append", "buffer", "def", "d", "results", "devices", "none", "source", "temp", "block", "reader", "zero", "dat"], "data_len": ["data_limit", "dataqlen", "memory_size", "dataqlength", "data_length", "dataqLen", " data_limit", "data_lang", "next_len", " data_pos", "data_pos", "dataqlimit", "memory_Len", "next_pos", " data_Len", "dataqpos", "dataqlang", "data_Len", "memory_len", "data_num", "memory_lang", " data_length", "memoryqsize", "memoryqLen", "next_num", "data_size", "memoryqlang", "memoryqlen", "data_val", "dataqsize", " data_val", "next_length"], "dev": ["serial", "adv", "ow", "name", "cam", "def", "dd", "conn", "device", "sd", "mod", "desc", "ad", "d", "ver", "di", "prof", "de", "client", "dom", "package", "DEV", "Dev", "proc", "info", "bug", "dt", "md", "ch", "temp", "pub", "raw", "dc", "gu", "p", "block", "w", "prom", "private", "dm", "doc", "app", "conf", "cache", "comment", "v", "ev", "rad", "dem", "prov", "var", "error", "valid", "pro", "req", "reg", "debug", "root", "dat", "diff", "user"], "aurb": ["aur", "thurbase", "narB", "urk", "iarad", "igrf", "airb", "urbase", "url", "urba", "augb", "ervba", "aurf", "airit", "ervf", "igrc", "igrbot", "aurbase", "aubot", "urB", "ura", "aurr", "aurp", "airB", "mrb", "mrba", "urbb", "narba", "urb", "iarbase", "ergbe", "iverab", "iara", "iarbb", "igrbe", "ervc", "urr", "ervbe", "urw", "urbot", "aurab", "iard", "aurk", "iarb", "eurbb", "aurl", "aup", "urp", "aurbb", "eurp", "igrw", "aurad", "iarp", "iverbb", "iarB", "aura", "ergbar", "mrB", "aurB", "aurba", "auga", "ervb", "aurd", "ergl", "aul", "ervp", "eurB", "thurb", "urin", "iverk", "iverb", "ervbb", "augB", "aurbot", "mrab", "ervin", "aurc", "eurba", "igrbar", "aurbe", "eura", "ibrit", "iverB", "igrin", "urf", "augp", "narb", "urd", "ibrb", "aurbar", "igrl", "urc", "thurd", "ibrB", "aub", "aurw", "igrb", "auc", "ibrd", "igrr", "iverba", "thura", "iarit", "narab", "aird", "eurb", "ervl", "eurad", "narf", "ervbar", "narc", "ervw", "aurin", "ervad", "auf", "eurc", "narp", "ergb", "aurit", "eurk"]}}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262, "substitutes": {"avctx": ["afcb", "AVctx", "avalbc", "awpkg", " avcb", " avci", "akcas", "afcmp", "afctx", "afcontext", "afcas", "avtx", "afpkg", "navctx", "afbc", "akcontext", " avcmp", "aftx", "akbc", " avcontext", " avtx", "avpkg", "avalcas", "awcontext", "AVpkg", "AVcu", " avcu", "navci", "afcu", "navcontext", "avcb", "avalcontext", "afci", "avcontext", "navcb", "avci", "awcmp", "avbc", "avcmp", "avcu", "akctx", "awctx", "AVcmp", "AVcontext", "AVtx", "avcas", "avalctx"], "s": ["sg", "js", "this", "qs", "n", "sites", "g", "ls", "ses", "args", "vs", "self", "us", "f", "sys", "u", "your", "se", "fs", "spec", "ts", "sb", "aws", "ims", "uns", "xs", "sets", "p", "e", "conf", "as", "v", "su", "S", "t", "session", "os", "ks", "its", "in", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "new", "data", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "native", "ns", "c", "es", "south", "o", "si", "service", "ops", "strings", "d", "ms", "sync", "l", "services", "w", "features", "sq", "stats", "b", "states"], "i": ["yi", "li", "gi", "abi", "key", "a", "interface", "ni", "ii", "zi", "chi", "ui", "pi", "oi", "d", "I", "di", "id", "mi", "it", "iu", "j", "y", "eni", "ri", "anti", "m", "info", "ti", "multi", "ini", "ai", "ie", "ip", "l", "c", "p", "hi", "bi", "adi", "e", "x", "f", "u", "idi", "ori", "range", "o", "v", "iv", "b", "qi", "ix", "req", "module", "uri", "line", "ci", "io", "mu", "part", "init", "fi", "si", "xi"]}}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n", "idx": 265, "substitutes": {"avctx": ["Avchan", " avcontext", "Avctx", "afchan", " avgpu", "afctx", "afcontext", "avchan", " avchan", "avgpu", "Avcontext", "avcontext", "afgpu", "Avgpu"], "s": ["sg", "js", "service", "cs", "ctx", "sup", "ss", "ops", "spec", "ts", "rs", "a", "sb", "qs", "sa", "d", "is", "aws", "ans", "sl", "side", "bis", "m", "ses", "ls", "sf", "args", "sync", "info", "settings", "ds", "sets", "ps", "gs", "ns", "l", "c", "p", "css", "services", "vs", "e", "self", "f", "es", "words", "us", "sys", "sq", "u", "as", "o", "su", "t", "os", "session", "times", "ks", "S", "its", "sie", "fs", "si", "parts", "ssl"], "length": ["delay", "se", "total", "buffer", "time", "sequence", "form", "url", "data", "ength", "d", "position", "distance", "always", "sh", "sl", "id", "section", "th", "k", "duration", "jo", "dy", "code", "body", "number", "slice", "style", "word", "l", "block", "c", "p", "len", "size", "angle", "f", "library", "Length", "padding", "path", "full", "count", "limit", "shape"], "n": ["adj", "dn", "ni", "nn", "d", "nc", "pn", "un", "fn", "k", "nu", "ne", "na", "num", "j", "max", "m", "nt", "z", "ns", "x", "N", "l", "c", "p", "w", "e", "nb", "len", "f", "u", "en", "o", "v", "sn", "t", "an", " N", "nor", "nd", "net"], "i": ["cli", "ami", "li", "gi", "abi", "key", "ni", "ii", "zi", "ui", "pi", "oi", "d", "I", "di", "is", "id", "mi", "it", "iu", "k", "api", "j", "y", "m", "eni", "inner", "ri", "info", "ti", "ini", "multi", "index", "z", "ai", "ie", "x", "l", "c", "p", "ip", "bi", "phi", "e", "f", "u", "o", "v", "qi", "ix", "uri", "ci", "io", "start", "si", "xi"], "r": ["ur", "rg", "dr", "q", "rs", "gr", "rr", "d", "ru", "k", "lr", "j", "rb", "m", "ri", "nr", "er", "cr", "x", "l", "p", "pr", "c", "w", "e", "h", "ro", "f", "rl", "br", "ar", "u", "R", "range", "sr", "rd", "v", "mr", "o", "rx", "re", "rh", "rc"], "g": ["rg", "sg", "group", "ig", "G", "gi", "q", "gr", "ga", "og", "gy", "d", "pg", "ge", "k", "ag", "ng", "gg", "gm", "m", "gn", "gam", "gs", "x", "l", "c", "p", "h", "w", "e", "f", "mg", "u", "gb", "bg", "v", "msg", "gp", "gh"], "b": ["ob", "base", "ba", "a", "be", "sb", "lb", "ab", "eb", "mb", "B", "d", "k", "pb", "boot", "y", "rb", "z", "h", "l", "c", "p", "beta", "x", "w", "e", "nb", "f", "bd", "u", "gb", "o", "bb", "v", "lib", "fb", "abb", "bar", "bs", "emb", "db", "xb"]}}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n", "idx": 272, "substitutes": {"opaque": ["iopairo", "iopcoe", " Opc", "opairo", "OPec", "copc", "iopaque", " opsea", "OPairo", "OPcoe", "OPaque", "opec", "oplcoe", "opsea", "iopec", "copaque", "oplaque", "oplec", "copsea", "opc", "oplairo", " Opaque", " Opsea", " opc", "opcoe"], "addr": ["base", "name", "src", "offset", "alias", "device", "host", "data", "ace", "ad", "add", "type", "id", " address", "pair", "pos", "mac", "nr", "index", "pointer", "config", "address", "ip", "x", "work", "ptr", "hop", "len", "ref", "Address", "attr", "amp", "prefix", "val", "mode", "ast", "start", "rc"], "value": ["flow", "VALUE", "to", "server", "name", "version", "buffer", "offset", "key", "Value", "byte", "memory", "data", "complete", "type", "format", "store", "end", "number", "write", "index", "address", "age", "values", "set", "length", "message", "amount", "alloc", "range", "v", "fee", "prefix", "valid", "reg", "val", "start", "port"], "size": ["SIZE", "name", "capacity", "offset", "ize", "security", "data", "small", "type", "id", "empty", " address", "from", "max", " Size", "storage", "address", "length", "len", "set", " length", "Size", "sum", "s", "fee", "scale", "val", "mode", "timeout", "desc"], "attrs": ["Attrs", " attributes", "acr", "acds", " attr", "Attr", " attds", "acrs", "attds", "acributes", "Attributes", "Attds", "attr", "attributes"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280, "substitutes": {}}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289, "substitutes": {"dev": ["flow", "vol", "def", "dd", "hw", "gr", "conn", "device", "spec", "data", "ver", "d", "google", "di", "sh", "der", "priv", "prof", "de", "client", "dom", "g", "DEV", "Dev", "ve", "info", "sync", "err", "temp", "ch", "ds", "block", "w", "prom", "gd", "cache", "comment", "v", "ev", "dem", "error", "os", "pro", "debug", "diff"], "conf": ["cm", "sub", "cs", "ctx", "sch", "fs", "cal", "def", "hz", "spec", "conn", "cc", "res", "cl", "host", " Conf", "com", "ck", "co", "bc", "sh", "cons", "con", "client", "py", "param", "g", "fab", "info", "cb", "bug", "cr", "arch", "ch", "config", "pub", "c", "aff", "lc", "f", "fam", "ref", "app", "cache", "ca", "sc", "exec", "cn", "core", "ram", "comment", "cd", "sum", "cp", "cell", "cf", "conv", "req", "bs", "ci", "Conf", "cfg", "init", "reg", "fi", "acc", "rc", "ssl"], "serial": ["vol", "cho", "device", "flash", "pixel", "address", "private", "power", "object", "comment", "smart", "valid", "path", "location", "vision", "pocket", "local", "spec", "zip", "template", "type", "unknown", "id", "pass", "model", "ser", "general", "Serial", "secret", "custom", "resource", "length", "patch", "driver", "iv", "sex", "usb", "io", "digital", "mobile", "version", "primary", "loc", "global", "boot", "remote", "instance", "sql", "util", "erial", "standard", "ident", "kid", "iso", "original", "specific", "public", "regular", "prefix", "error", "mode", "normal", "si", "series", "server", "micro", "material", "alias", "binary", "initial", "phone", "spot", "sync", "coll", "special", "random", "color", "specified", "quant", "rc"], "s": ["sg", "js", "sa", "qs", "n", "sl", "client", "j", "g", "ses", "ls", "sf", "args", "storage", "us", "self", "f", "secondary", "sys", "u", "sum", "fs", "sup", "stat", "spec", "ts", "sb", "uns", "request", "p", "e", "v", "su", "ves", "S", "os", "session", "ks", "t", "site", "hs", "sym", "ssl", "cs", "ss", "rs", "new", "r", "is", "i", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "south", "o", "sim", "si", "server", "service", "d", "sk", "comments", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "cylinders": ["shasts", "ellisters", "cilovies", "culinder", "skasts", "skisters", "ellarks", "culinders", "cilriers", "culovies", "cilinders", "sharks", "ellasts", "huminders", "humriers", "ellinders", "cylasts", "cylisters", "huminder", "cylinder", "skarks", "shinders", "cylarks", "cylovies", "culriers", "cilinder", "humovies", "cylriers", "shisters", "skinders"], "heads": ["opens", "views", "reads", "loads", "devices", "jobs", "head", "shows", "links", "hops", "locks", "ids", "checks", "comments", "frames", "bits", "outs", "holes", "mods", "boxes", "pages", "features", "height", "rows", "tails", "HEAD", "blocks", "types", "ks", "headers", "ashes", "depth", "olds", "versions", "plugins", "obs"], "secs": ["threadp", "consts", "reqp", "threadcs", "secp", "secses", "constp", "threads", "Secp", "threadses", "Secses", " secp", "reqs", "descs", "reqsets", "constses", "Secs", "reqseconds", "secseconds", " secsets", "descp", " secseconds", "Seccs", "seccs", "descsets", "descseconds", "secsets", "constcs"], "virtio_blk_id": ["virtio_blk_ids", "virtio_blck_id", "virtio_blck_name", "virtio_blk_type", "virtio_blk_name", "virtio_blkt_id", "virtio_blkt_name", "virtio_blkt_type", "virtio_blk_f", "virtio_blkt_f", "virtio_blk_info", "virtio_blck_ids", "virtio_blck_info"], "dinfo": ["ddata", "cddata", "linfo", "cdid", "fdhandler", " dvar", "rInfo", "ldfo", "bdinfo", "derror", "fdinf", " ddata", " dInfo", "ldata", "bdinf", "finfo", "sdhandler", "did", "ldid", "sdinf", " dinf", "dinf", " derror", "fdvar", "bdInfo", "sdvar", "sdinfo", "bderror", "fdinfo", "rdata", "dfo", "ldinfo", " dfo", "finf", "fInfo", " dhandler", "cdfo", "rinf", "linf", "lddata", "dInfo", "lInfo", "cdinfo", "dvar", "rinfo", "dhandler", " did"]}}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n", "idx": 304, "substitutes": {"buf": ["fd", "src", "buffer", "ctx", "abi", "bh", "bag", "queue", "fw", "data", "ab", "aux", "bc", "buff", "cur", "pb", "tmp", "cas", "batch", "rb", "fp", "cb", "pool", "func", "bf", "home", "result", "block", "cv", "Buffer", "vec", "f", "wb", "br", "cmd", "alloc", "fb", "seq", "b", "cp", "cf", "uf", "img", "msg", "que", "fi", "uc", "rc", "port"], "magic": ["serial", "parser", "base", "cli", "math", "offset", "generic", "extra", "spec", "stat", "mic", "data", "memory", "binary", "mini", "icon", "format", "kind", "gz", "api", "big", "info", "util", "mag", "style", "pointer", "md", "ini", "special", "ec", "dc", "MAG", "c", "phy", "afi", "random", "length", "cache", "Magic", "cmd", "meta", "padding", "prefix", "seq", "ix", "gen", "anta", "xxx", "io", "init", "fi", "complex"], "s": ["service", "cs", "ss", "rs", "a", "spec", "sb", "r", "d", "n", "is", "sl", "i", "g", "m", "ls", "z", "ns", "l", "c", "p", "e", "self", "f", "size", "us", "sys", "sq", "u", "v", "b", "S", "os", "session", "bytes", "fs", "si"], "len": ["base", "fun", "li", "lan", "offset", "cs", "Len", "loc", "n", "lf", "fl", "ln", "sl", "bin", "lang", "fn", "num", "bl", "lim", "pos", "ls", "ll", "inn", "rev", "z", "ie", "lon", "l", "L", "fin", "ler", "lc", "length", "size", "f", "kl", "vec", "e", "la", "el", "en", "v", "hl", "lib", "seq", "lin", "lit", "low", "gen", "val", "line", "ann", "limit", "part", "fi", "le", "mem"], "buflen": ["bullen", "buclen", "buFlot", "buFLeng", "cuclenc", "buflend", "fuflot", "cuflade", "buFLade", "buFlen", "cufleng", "bullot", "buflon", "fuFlen", "bullon", "fuflon", "buFlend", "bucleng", "bufron", "fuFlend", "buFLen", "buFlenc", "fuFlot", "fuflen", "cuflenc", "buclenc", "fuflend", "buFLenc", "fuFlon", "bullend", "cuclen", "cucleng", "bufleng", "buflade", "bufrend", "cuflen", "bufren", "buFlon", "buclade", "buFleng", "cuclade", "buflot", "buflenc", "buFlade", "bufrot"], "ext_backing_fmt": ["ext_backing_formformat", "ext_backing_formMT", "ext_backing_forMT", "ext_backing_FMT", "ext_backing_Fract", "ext_backing_Fitter", "ext_backing_defformat", "ext_backing_fornt", "ext_backing_defnt", "ext_backing_formmt", "ext_backing_fitter", "ext_backing_defmt", "ext_backing_forract", "ext_backing_fnt", "ext_backing_fract", "ext_backing_fformat", "ext_backing_Fmt", "ext_backing_formitter", "ext_backing_fMT", "ext_backing_formnt", "ext_backing_defitter", "ext_backing_formract", "ext_backing_formt", "ext_backing_Fnt", "ext_backing_Fformat"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n", "idx": 305, "substitutes": {"c": ["fc", "cm", "cs", "ctx", "anc", "cc", "mc", "cl", "ct", "co", "nc", "bc", "cur", "cy", "con", "tc", "cus", "enc", "ac", "coll", "cont", "cr", "ch", "C", "ec", "dc", "ce", "h", "cu", "p", "xc", "cv", "l", "e", "lc", "f", "conf", "ca", "ctrl", "cd", "sc", "u", "cache", "vc", "cit", "pc", "s", "icc", "cp", "t", "cf", "ic", "ci", "uc"], "pb": ["pl", "cm", "fc", "ctx", "bh", "lp", "ppa", "pd", "sb", "bps", "cpp", "lb", "ab", "hub", "eb", "prot", "bm", "rob", "pg", "bc", "tmp", "api", "PB", "tp", "rb", "fp", "cb", "bf", "pa", "p", "lc", "jp", "obj", "bp", "pc", "fb", "cp", "b", "aph", "pro", "dp", "pt", "uc", "typ", "pp", "db", "xb"], "atom": ["cm", "base", "orb", "null", "np", "material", "http", "arb", "term", "bn", "a", "acl", "fac", "chrom", "data", "ab", "xml", "image", "url", "com", "month", "type", "prop", "bc", "operator", "op", "num", "dom", "instance", "param", "m", "item", "fab", "chem", "mag", "temp", "om", "config", "source", "atomic", "x", "orbit", "arc", "article", "attr", "app", "arm", "object", "art", "obj", "mom", "amp", "canon", "tm", "asm", "um", "at", "b", "plane", "cell", "module", "element", "container", "account", "car", "tom", "an", "monitor", "wp", "emb", "typ", "perm", "sym"], "st": ["stage", "fc", "ist", "ust", "se", "ld", "src", "this", "rest", "ss", "sa", "sd", "sb", "cl", "r", "ad", "ct", " est", "sp", "sl", "end", "St", "bl", "ste", "kt", "ft", "fr", "nt", "cr", "str", "fe", "l", "sw", "start", "ut", "ptr", "lc", "sc", "ST", "stream", "art", "std", "sec", "amp", "sn", "s", "sts", "b", "sta", "t", "inst", "stop", "ost", "nd", "ast", "pt", "ace", "pp", "sth", "est"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321, "substitutes": {"listener": ["Listener", "latener", " listencer", "intener", "parentceiver", "listceiver", "listend", "parentener", "latender", " listceiver", "lateners", " listiner", "Listend", "parenter", "cleners", "later", " listeners", "parentender", "listeners", "listiner", "parentest", "intencer", "clender", "Listencer", "intend", "listencer", " lister", " listend", "parenteners", "listender", "clest", "clener", "latest", "intiner", "listest", "latceiver", "lister", "Listiner"], "d": ["dr", "fd", "ld", "dn", "da", "dd", "pd", "sd", "dh", "dad", "r", "ad", "xd", "n", "id", "did", "j", "i", "m", "dy", " D", "dt", "md", "ds", "dc", "ind", "ade", "p", "c", "l", "e", "dm", "f", "bd", "rd", "v", "b", "t", "od", "ded", " dd", "dat", "nd", "D", "gd"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "substitutes": {"bpp": ["rbcp", "fpp", "bupp", "ppps", "pupp", "fcp", "bpc", " bPP", "lgp", "fpps", "ebpps", "fupp", "abbPP", " bgp", "ebPP", "pcp", "ebpp", "abbpps", "ppp", " bcp", " bupp", "bpps", "bcp", "bgp", "lcp", "rbgp", "rbmp", "lmp", "bmp", "abbpc", "ebpc", "rbpp", "bPP", " bpps", " bpc", "lpp", "abbpp", " bmp"], "buf": ["src", "buffer", "ctx", "bag", "Buff", "context", "queue", "ab", "data", "loc", "window", "bc", "buff", "cur", "ph", "bin", "tab", "grad", "ha", "map", "off", "mac", "rb", "proc", "fab", "dest", "box", "comb", "cb", "aka", "plug", "feat", "config", "func", "home", "pub", "begin", "usr", "block", "cv", "Buffer", "vec", "ptr", "band", "book", "bd", "wb", "text", "cache", "uint", "uv", "gb", "cap", "cmd", "alloc", "fb", "b", "border", "cf", "conv", "font", "uf", "path", "img", "msg", "que", "uc", "db"]}}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338, "substitutes": {"netdev": [" netclient", "natdevice", "natdev", "networkconn", "netdevice", " netDev", "netdi", "etev", "etdi", "networkdevice", "nede", "netconn", " netconn", "netDev", "netclient", "netev", "neconn", "netde", "networkdev", "natclient", "tunDev", " netde", "etdev", " netev", "networkdi", "networkde", " netdi", "tundev", "networkev", " netdevice", "natDev", "nedev", "nedevice", "tunclient", "tundevice", "etdevice"], "name": ["call", "test", "server", "version", "time", "alias", "filename", "new", "n", "type", "id", "profile", "parent", "client", "package", "none", "code", "info", "names", "temp", "address", "description", "ip", "Name", "size", "cap", "username", "node", "comment", "amp", "connection", "nm", "prefix", "session", "path", "NAME", "nam", "family"], "peer": ["layer", "server", "trace", "channel", "conn", "device", "tg", "pe", "host", "type", "cur", "worker", "scope", "chain", "parent", "tc", "client", "remote", "shared", "instance", "package", "tp", "inner", "proc", "pipe", "snap", "er", "master", "pod", "request", "ep", "pointer", "pool", "owner", "pkg", "ip", "p", "state", "stack", "ptr", "self", "attr", "sys", "cache", "node", "pc", "trap", "fork", "socket", "port", "addr", "mode", "slave", "player", "root", "pp", "user", "ssl"], "errp": ["errorf", "errP", "rorpr", "erP", "erpc", "rrf", "rorr", "errorpc", "derp", "errpc", "orderr", "derpc", "orderpc", "rorp", "iterp", "rrP", "ErrorP", "erf", " errr", "acerpa", "Errorps", "Errorr", "erpa", " errps", " errP", "errr", "errps", "derr", "orderp", "rrl", "errl", "Errorp", " errpc", "acerpr", "acerp", "errorp", "derf", "erp", " errl", "iterf", "rorpa", "iterP", "errpr", " errf", "errorr", "erps", "errf", "errpa", "orderf", "acerr", "iterl", "erpr", "rrp"], "tap": ["submit", "this", "ppa", "dra", "tu", "ping", "tk", "tick", "sp", "pb", "wal", "pipe", "snap", "trip", "tr", "tin", "track", "jp", "mp", "trap", "ticket", "opa", "wp", "task", "wat", "pp", "flow", "tf", "ts", "tim", "wt", "ap", "api", "gap", "tw", "python", "pa", "p", "ptr", "php", "amp", "t", "session", "wa", "transform", "td", "pin", "np", "tool", "touch", "also", "trace", "skip", "tg", "pe", "apper", "hap", "di", "ta", "chat", "pod", "project", "atom", "tif", "pad", "setup", "cap", "app", "tm", "bp", "Tap", "hook", "enter", "each", "tip", "ga", "conn", "xml", "tc", "kin", "tp", "comb", "temp", "capt", "ten", "pc", "taker", "dat", "pot", "typ"], "fd": ["flow", "fc", "fun", " FD", "ld", "dn", "da", "ff", "bind", "fen", "dd", "pd", "fs", "FD", "sd", "xf", "fed", "dim", "fw", "fa", "dB", " f", "d", "xd", "dl", "lf", "fl", "ln", "fn", "wait", "buf", "seed", " df", "draft", "dy", "pipe", "fp", "sf", "df", "cb", "cond", "md", "pid", "dt", "ds", "bf", "fe", "dc", "writer", "fin", "len", "f", "ffff", "bd", " fid", "hd", "stream", "fat", "fx", "handler", "wd", "fm", "fee", "fb", "cf", "socket", "vd", "td", "nd", "ctl", "dir", "fi", "wat", "diff", "db"], "queues": ["queueures", "queueues", " queue", "Queues", "queueue", "Queures", "quries", " queries", "queue", "Queue", "peues", "quins", "qins", "peins", "queins", "qures", "queries", "quures", "queures", " queures", "qries", "qients", "quues", "quue", "queients", "peients", "quients", "peries", "ques", "que"], "script": ["test", "cli", "cript", "command", "scroll", "sh", "scope", "client", "secure", "code", "password", "sync", "tx", "slice", "document", "style", "sudo", "config", "func", " scripts", "writer", "setup", "draw", "sq", "sc", "exec", "scripts", "comment", "Script", "prefix", "lib", "seq", "fee", "sign", "session", "xxx", "init", "ctl", "inc", "ssl"], "downscript": ["DOWNexec", "DOWNScript", " downstyle", "upscript", "downScript", "downscripts", "upstyle", " downscripts", " downScript", "downstyle", "upScript", "upexec", "downexec", "DOWNstyle", "DOWNscripts", "upscripts", " downexec", "DOWNscript"], "err": ["dr", "ise", "icer", "rage", " er", "gr", "aaa", "Error", "rn", "wr", "rr", "r", "ver", "aa", " error", "der", "gz", "lr", "eor", "arr", "grad", "kr", "raise", "later", "rb", "nil", "nr", "er", "ir", "bug", "str", "oller", "fr", "cr", "runner", "rev", "exc", "result", "phy", "pr", "doc", "ler", "e", "order", "aster", "org", "rm", "resp", "orr", "range", "mr", "fee", "ev", "error", "acer", "req", "rar", "cf", "Er", "yer", "magic", "msg", "iter", "nor", "fi", "rh", "diff", "erer"], "vhostfdname": ["vHostfname", "vHostfdName", "vHostfdnumber", "vHostfdnam", "vHostFDnames", "vHostFDName", "vhostfno", "vHostfnames", "vHostfdno", "vhostFDname", "vhostdname", "vHostFDn", "vhostddname", "vhostdnumber", "vhostddn", "vhostfdnumber", "vhostFDno", "vhostfname", "vhostfdnam", "vHostFDname", "vhostFDnames", "vHostfdnames", "vhostfdnames", "vHostfdn", "vhostFDnam", "vhostfnames", "vhostdName", "vhostfdName", "vHostFDnumber", "vhostdfno", "vhostdn", "vhostddnumber", "vHostfdname", "vhostddnames", "vhostfnam", "vHostFDno", "vhostdno", "vHostfno", "vhostfdn", "vhostfdno", "vHostFDnam", "vhostdfnam", "vhostdfName", "vhostFDn", "vhostfName", "vhostFDnumber", "vhostFDName", "vhostdfname", "vHostfName", "vhostdnames"], "ifname": ["ifkey", "ifid", "ifn", "IFkey", "defid", "defkey", "IFid", "IFname", " ifn", "defname", "IFn", " ifid", " ifkey", "defn"], "fds": [" fded", "cfns", "cfds", "cfded", "fded", "hns", " fns", "cfcs", "hds", "fcs", "hded", " fcs", "fns", "hcs"], "vhost_fds": ["vhost_rfds", "vhost_hks", "vhost_rfns", "vhost_fns", "vhost_rfrs", "vhost_rfks", "vhost_hns", "vhost_fks", "vhost_hrs", "vhost_frs", "vhost_hds"], "nfds": ["_", "new", "r", "d", "id", "g", "proc", "func", "config", "function"], "i": ["cli", "ii", "sid", "pi", "I", "di", "n", "id", "iu", "slice", "ini", "index", "pid", "pointer", "ai", "ip", "ind", "c", "phi", "f", "ix", "uri", "ci", "io", "init", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369, "substitutes": {"job_id": ["block_ID", " job_num", "block_kid", "job_ID", "jobEID", " job_name", "jobEid", "job_ids", " job_type", "job_name", "jobEkid", "block_id", "job_kid", "jobEids", "job_num", "job_type", "block_ids"], "bs": ["ob", "js", "src", "cs", "ctx", "bh", "ss", "rs", "sb", "bps", "lb", "BS", "ib", "bid", "bc", "pb", "buf", "fps", "builder", "bis", "ses", "ls", "ds", "bas", "ps", "gs", "ns", "vs", "bos", "es", "gb", "bb", "blocks", "stats", "fb", "b", "os", "fs", "db", "obs"], "base": ["based", "background", "null", "server", "name", "buffer", "src", "cs", "http", "local", "ctx", "area", "bid", "Base", "ase", "bc", "sl", "store", "id", "client", "pre", "builder", "proxy", "body", "sync", "settings", "source", "storage", "back", "status", "bas", "home", "address", "x", "l", "work", "p", "c", "state", "bi", "e", "f", "cache", "core", "origin", " b", "padding", "o", "prefix", "v", "b", "site", "os", "uri", "full", "root", "slave", "fs", "db", "family"], "backing_file_str": ["backing_file_name", "backing_file_path", "backing_files_name", "backing_files_path", "backing_file__str", "backing_files_string", "backing_file__name", "backing_files_char", "backing_file_char", "backing_files_str", "backing_file__path", "backing_file_string", "backing_file__string"], "speed": ["fast", "level", "server", "name", " speeds", "service", "offset", "ss", "rate", "spec", "slow", "byte", "grade", "security", "bps", "send", "weight", "type", "ota", "fps", "peed", "seed", "score", "secure", "sf", "sync", "slice", "source", "settings", "status", "enabled", "state", "size", "length", "sc", "stream", "driver", "scale", "error", "engine", "Speed", "performance", "start", "si"], "on_error": ["onalerror", "onayerror", "on_err", " on_call", " on_err", " on_offset", "on_ror", "onayevent", "on_call", "onalcall", "onayror", "on_event", " on_ror", " on_event", "onayerr", "on_offset", "onalerr", "onaloffset", "onalfail", " on_fail", "on_fail"], "cb": ["fc", "call", "cm", "fun", "src", "cs", "ctx", "sb", "CB", "co", "bc", "callback", "buff", "pb", "fn", "buf", "rb", "code", "fp", "cgi", "func", "bf", "ec", "function", "c", "cv", "cow", "f", "unc", "conf", "ca", "cache", "exec", "kk", "pc", "bb", "seq", "b", "cp", "cf", "db"], "opaque": ["opacity", " opque", "pace", "pque", "posacity", " opatile", "opgate", "iopaque", "copque", "posgate", "opace", "copatile", " opacity", "copgate", "ipatile", "ipaque", "copacity", "ipque", "posaque", "iopace", " opace", "ipacity", "pacity", "opatile", "pgate", "posque", "iopc", "pc", "copaque", "opc", "paque", "opque", " opc"], "errp": ["errP", "erP", "erpc", "erlp", "errpc", " errr", "acelp", " errlp", "err", " errps", " errP", "acepc", "errr", "errps", " errpc", "erp", "aceps", "errlp", "aceP", "acer", "erps", "acep"], "s": ["sg", "submit", "js", "qs", "n", "sl", "g", "ls", "ses", "sf", "sw", "css", "sie", "us", "f", "sys", "u", "single", "an", "se", "fs", "sup", "spec", "ts", "sb", "aws", "sh", "uns", "sets", "p", "e", "v", "su", "S", "os", "session", "its", "hs", "sym", "ssl", "so", "cs", "ss", "rs", "a", "r", "is", "i", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "d", "ms", "sk", "comments", "sync", "l", "services", "w", "sq", "b", "states"]}}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372, "substitutes": {"avctx": ["ajctx", "amctx", "alconn", "afcontext", "afsync", "alcontext", "avsync", "ajsync", "avcus", "afctl", "akcmp", "avelc", "akconn", "avecca", "avcontext", "afwcs", "avca", "avalcb", "afxc", "navconn", "akctx", "afcca", "AVcca", "afcmp", "AVcontext", "avecu", "akcu", "avalcca", "ajcf", "afcv", "avectx", "amcu", "avecf", "afctx", "navctx", "aveconn", "navcf", "akcontext", "avcf", "evcas", "afconn", "ajctrl", "avcb", "abcf", "avercus", "avalcontext", "aucontext", "abcontext", "umcontext", "verctx", "ajca", "avcv", "AVcmp", "avalctrl", "avecmp", "avcas", "avalctx", "evctx", "evcu", "evcontext", "evcmp", "avewcs", "ajchan", "avxc", "afcas", "vercas", "alctx", "ajconn", "abcmp", "avecb", "umconn", "vercu", "auctx", "avalwcs", "abctx", "avctrl", "afchan", "afcu", "afctrl", "avcca", "avectl", "aflc", "afcf", "afsys", "avctl", "verlc", "aucu", "avecv", "aucf", "avwcs", "umctx", "ajctl", "ajcontext", "vercontext", "ajcus", "AVctx", "avalcv", "avconn", "avchan", "avercontext", "aveca", "vercf", "avesys", "ajcv", "avalsys", "avsys", "afcus", "avalcu", "amcmp", "alcf", "navcontext", "averchan", "evxc", "akcf", "avesync", "avecontext", "afca", "amcontext", "averctx", "akxc", "avcu", "avlc", "avcmp", "afcb", "umcf"], "picture": ["media", "base", "winner", "guide", "piece", "cam", "movie", "ctx", "ami", "service", "large", "bank", "figure", "ji", "data", "audio", "image", "share", "video", "profile", "query", "study", "frame", "camera", "package", "photo", "anti", "file", "info", "entry", "attribute", "style", "license", "storage", "parse", "feat", "config", "home", "pict", "feature", "sea", "game", "library", "ana", "summary", "definition", "comment", "shadow", "pie", "plugin", "pic", "module", "manager", "error", "statement", "family", "img", "cover", "player", "view", "import", "quote", "pause", "gif", "Picture"], "got_picture_ptr": ["got_image_struct", "got_image_address", "got_picture__addr", "got_image_ptr", "got_image_addr", "got_picture__address", "got_picture__ptr", "got_picture_reference", "got_picture_pointer", "got_picturenaddr", "got_profile_addr", "got_image_pos", "got_picturenreference", "got_image_pointer", "got_picture__offset", "got_picture_addr", "got_picturenptr", "got_image_offset", "got_picture_address", "got_picture_struct", "got_picturenpointer", "got_picture_offset", "got_profile_reference", "got_picture__pointer", "got_profile_pointer", "got_picture_pos", "got_profile_ptr"], "avpkt": ["avgpkn", "avcpdt", "avepeth", "avgpdt", "affkt", "avpake", "ajpkt", "avppct", "avspacket", "avpkn", "avlpkt", "affiece", "avpakt", "avecpqt", "avjpkn", "avcpkn", "ajdpkt", "afpct", "avfcht", "avdpkt", "avdpkh", "avepdt", "avcpet", "ajdpsk", "avlpke", "ajpsk", "avpqt", "avpacht", "avpacket", "avemeth", "avemkt", "avdpet", "avpdt", "ajdpetsk", "avpaacket", "akpaacket", "avmiece", "avepkh", "avcpnt", "avcpsk", "avfpacket", "avcpqt", "avpki", "avcpkt", "avppacket", "avemiece", "avfki", "avepki", "affacket", "avppkt", "avwke", "avfct", "avdpetsk", "avlpeth", "avfpki", "avpet", "avfke", "avfiece", "avfkt", "avpetsk", "avmkt", "avepnt", "avepkt", "avlpct", "avwcht", "akpake", "avgpkt", "avlpacket", "avecpkt", "avefpki", "avcpiece", "afpcht", "ajpetsk", "avjpdt", "avpeth", "avspcht", "avlpiece", "avpct", "avspkt", "avlpnt", "avfkh", "avpke", "avecpkn", "avdpsk", "avmnt", "avpnt", "afpkt", "akpke", "avjpqt", "avemnt", "avmeth", "avepkn", "avipetsk", "affcht", "avjpkt", "akpacket", "avipkt", "avipsk", "avfpkt", "avcpeth", "avdpki", "avpcht", "avcpetsk", "avefpacket", "akpkt", "avpkh", "akpakt", "akpacht", "affke", "avepacket", "ajpet", "avppke", "affct", "avpsk", "avefpkh", "avfacket", "avepiece", "akpcht", "avpiece", "afpacket", "avspiece", "afpke", "avfpcht", "avgpqt", "avipet", "avwacket", "avefpkt", "avwkt", "avdpacket", "avfpkh", "avfpiece", "afpiece", "avepqt", "avecpdt", "ajdpet"], "ret": ["ur", "match", "rot", "base", "arg", "fun", "att", "mt", "def", "success", "data", "get", "alt", "job", "ure", "pet", "rets", "num", "rb", "code", "ft", "nt", "rev", "back", "reply", "feat", "Ret", "rc", "bf", "result", "et", "ut", "fin", "len", "f", "ref", "flag", "gt", "art", "value", "RET", "lit", "re", "reg", "val", "rt", "det", "res"], "frame_number": ["video_no", "frameblockversion", "frame_counter", "frame_no", "frameblockno", "frameblocknumber", "video_version", "video_number", "frame_version", "video_counter", "frameblockcounter"]}}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373, "substitutes": {"sbd": ["dshd", "sbb", "jshd", "fspd", "jscd", "sysBD", "lsbb", "wsbb", "spd", "usbd", "wsBD", "sdd", "lspd", "osnd", " scd", " sdb", "osbb", "uscd", "psnd", " shd", "jsbd", " sdd", "ushd", "fsBD", "wspd", "dsbd", "sdb", "sysdb", "osfd", "sysbd", "sBD", "fsbb", "dsBD", "dsdb", " sbb", "syshd", "lsbd", " sBD", " sfd", "usdd", "shd", "sfd", " snd", "psfd", "scd", "psbd", "psbb", "snd", "osbd", "wsbd", "jsdd", "fsbd", "lsBD"], "dev": ["serial", "del", "adv", "cam", "def", "dd", "hw", "conn", "device", "mod", "sd", "data", "d", "di", "ad", "devices", "der", "de", "grad", "dom", "g", "Dev", "DEV", "des", "ve", "ds", "md", "temp", "ch", "dc", "bus", "p", "w", "self", "dm", "app", "conf", "exec", "die", "driver", "o", "ev", "dem", "rad", "req", "debug", "dis", "diff", "gd"], "s": ["sg", "server", "js", "service", "cs", "ss", "spec", "rs", "ts", "sd", "sb", "r", "d", "n", "aws", "is", "sl", "sk", "i", "g", "side", "m", "ses", "ls", "uns", "args", "sync", "ds", "ps", "gs", "ns", "h", "l", "c", "p", "services", "w", "e", "f", "self", "es", "sys", "u", "south", "o", "v", "su", "b", "S", "t", "session", "os", "an", "fs", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n", "idx": 391, "substitutes": {"s": ["sg", "server", "js", "service", "src", "ss", "spec", "a", "sb", "r", "d", "n", "sl", "ssh", "client", "i", "g", "m", "ses", "sf", "sync", "sv", "ds", "address", "ns", "c", "p", "sw", "services", "w", "self", "e", "f", "scl", "private", "es", "sys", "sq", "u", "save", "south", "o", "b", "serv", "S", "su", "session", "t", "fs", "si", "sym", "ssl"], "slave": ["parser", "server", "vp", "ss", "array", "command", "sb", "device", "oe", "new", "ui", "r", "ad", "type", "pg", "sh", "ssh", "seed", "instance", "builder", " slaves", "m", "code", "sf", "ave", "master", "slice", "config", "cod", "post", "address", "h", "c", "p", "e", "f", "child", "copy", "attr", "sc", "node", "driver", "o", "ssl", "serv", "an", "mode", "ace", "si", "port"]}}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n", "idx": 399, "substitutes": {"a": ["A", "this", "da", "ba", "sa", "ga", "h", "ab", "r", "ad", "d", "n", "aa", "aj", "parent", "na", "api", "y", "i", "ac", "m", "au", "home", "ai", "ack", "x", "l", "c", "p", "alpha", "pa", "w", "e", "f", "self", "ca", "u", "la", "art", "ia", "as", "o", "s", "at", "ama", "af", "va", "an", "am", "ast", "ae"], "b": ["base", "ba", "sb", "lb", "ab", "eb", "r", "ib", "B", "d", "ad", "n", "mb", "bc", "k", "pb", "end", "y", "i", "g", "j", "rb", "cb", "x", "l", "c", "p", "h", "bi", "w", "e", "nb", "f", "wb", "u", "other", "o", "v", "bb", "s", "fb", "bs", "db"], "status": ["stage", "server", "wrapper", "stat", "gc", "expr", "success", "speed", "new", "complete", "current", "r", "out", "STAT", "Status", "id", "wait", "handle", "fail", "score", "code", "sync", "source", "index", "temp", "progress", "result", "x", "p", "sw", "state", "e", "uses", "s", "stats", "ix", "error", "msg", "fs", "ex", "ity"]}}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402, "substitutes": {"lexer": ["Lexer", "signer", "exe", "sexe", " lexger", "lexor", "exter", "sexener", "Lexter", "flexator", " lexler", " lexor", "sexer", "exener", "Lexler", " lexter", "signger", "sexler", " lexe", "flexter", "flexor", "exger", "sexger", "signator", "lexler", "Lexger", "flexe", "lexe", "flexger", "sexter", "exer", "exler", "lexator", "lexener", "signe", "flexler", "flexener", "lexger", "Lexe", "lexter", " lexener", "flexer", "sexor", "Lexor", " lexator"], "func": ["parser", "this", "ctx", "conn", "context", "data", "class", "callback", "fn", "tc", "buf", "instance", "package", "super", "proc", "util", "parse", "function", "x", "c", "reader", "e", "self", "unc", "f", "lc", "attr", "token", "text", "Function", "handler", "obj", "node", "as", "pc", "lib", "prefix", "b", "xxx"]}}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404, "substitutes": {"bs": ["ob", "base", "http", "bh", "ss", "ba", "sb", "lb", "eb", "BS", "bid", "bc", "pb", "boot", "fps", "bis", "rb", "plugins", "bits", "ls", "ses", "ds", "bas", "ps", "gs", "bf", "ns", "abc", "bi", "vs", "bos", "sys", "gb", "obj", "bb", "blocks", "lib", "fb", "b", "os", "bytes", "fs", "db"], "fd": ["flow", "fc", "ff", "lambda", "da", "dd", "pd", "FD", "fa", "dB", "d", "dl", "lf", "fff", "fn", "buf", "draft", "sf", "fp", "df", "cond", "ds", "func", "fe", "bf", "dc", "fif", "fi", "f", "ffff", " fid", "fx", "handler", "fee", "fb", "ecd", "nd", "fs"], "sector_num": ["ector_name", " sector_count", "sector_count", "sectorPname", "section_name", "section_len", "sectorPnum", "section_num", "ector_offset", "sector_len", "section_id", "ector_id", "sector_id", " sector_name", "sectorPcount", "sector_name", " sector_len", "sectorPlen", "sector_offset", "ector_num"], "qiov": ["uuno", "kiov", "uiov", "kmus", "sqliv", "qoby", "kliv", "qquno", "sqdyl", " qilo", "qqoren", "quilo", "quliv", "filo", "fiov", "qurolet", "uoren", "qudyl", "quiov", "sqiov", "qgio", "quoby", "qumus", "quuno", " qgio", "qdyl", "qqiov", " qliv", "frolet", "qqilo", "sqgio", " qdyl", "krolet", "qmus", " qmus", " qrolet", "foby", "uilo", "qrolet", "qoren", "quoren", " qoby", "qliv", "qugio", "quno", "qilo"], "nb_sectors": ["nb_pector", "nb_perets", "nb_gectors", "nb_peors", "nb_psegments", "nb_tector", "nb_gector", "nb_vegments", "nb_teors", "nb_pegments", "nb_sector", "nb_vector", "nb_gegments", "nb_segments", "nb_sections", "nb_gerets", "nb_veors", "nb_psectors", "nb_vectors", "nb_verets", "nb_vecs", "nb_serets", "nb_psecs", "nb_pectors", "nb_vections", "nb_tectors", "nb_seors", "nb_secs", "nb_psections", "nb_tegments"], "cb": ["ob", "call", "orb", "ctx", "obb", "sb", "acl", "CB", "hub", "eb", "rob", "bc", "callback", "buff", "pb", "fn", "rb", "fp", "sync", "func", "cod", "bf", "function", "abc", "c", "cv", "wb", "unc", "ctrl", "cd", "gb", "bb", "fb", "b", "cmp", "cp", "cf", "abb", "db", "xb"], "opaque": ["opacity", "opaques", "OPacity", "hopaques", "pac", "compacity", " opac", "opac", "ipaques", "OPace", "opaco", "opace", " opacity", "compace", "hopaque", "ipaque", "compaque", "OPaque", "hopc", "ipac", "compaco", " opace", "ipacity", "pacity", " opaques", "ipc", "hopac", "pc", " opaco", "OPaco", "opc", "paque", " opc"], "type": ["unit", "call", "name", "time", "key", "pe", "method", "ype", "url", "format", "id", "pb", "op", "ocol", "ty", "py", "y", "year", "pos", "tp", "code", "Type", "style", "func", "function", "address", "block", "p", "role", "state", "f", "length", "col", "attr", "token", "o", "pc", "phase", "prefix", "plugin", "t", "types", "site", "error", "port", "path", "TYPE", "typ", "ity"], "acb": ["acbi", "acecb", "akmb", "akk", "maca", "acf", "acl", "macn", "acefb", "accb", "acce", "icbb", "acp", "ecp", "acmb", " acbe", "ack", "ancbe", "ancsb", "actf", "adb", "anca", " acr", "aceb", "accr", "ocmb", "ancfb", "ecfb", "eck", "ocbar", " acbar", "acfb", "sacp", "macb", " acl", "acB", "adbb", "ecb", "acebb", "macban", "ocsb", "ocbb", "ocb", " accb", "ecv", "acban", "accbi", "macbb", "accbe", "sacbe", "macf", "acsb", "aca", " acsb", "akr", "ACsb", " ace", " acbi", "accfb", "ancr", " acfb", "akn", "ACa", "admb", "ocfb", "ancb", "accf", "macB", "sacbi", "ake", "sacb", " acv", " acbb", "accmb", "ecmb", "acca", "akb", " ack", "accn", "icb", "icB", "acv", "actn", "actb", "rcf", " acban", "oca", "ecsb", "aksb", "accv", "accp", "acbe", "ocbd", "accbb", "acbb", "rcbb", " acf", " acmb", "akfb", "acbd", "ocl", "accbar", "ACl", "acck", "ACb", "accsb", " acp", "occb", "ica", "acbar", "rcb", "accB", " aca", "acn", "adsb", "actban", "ecbb", "acr", "akbb", "ACbd", " acbd", " acn", "ACbb", "ace", "ACfb"]}}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    const char *nested_url;\n\n    int ret;\n\n    CryptoContext *c = h->priv_data;\n\n\n\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n\n\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n    if (flags & AVIO_FLAG_WRITE) {\n\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n\n        ret = AVERROR(ENOSYS);\n\n        goto err;\n\n    }\n\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n\n        goto err;\n\n    }\n\n    c->aes = av_mallocz(av_aes_size);\n\n    if (!c->aes) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto err;\n\n    }\n\n\n\n    av_aes_init(c->aes, c->key, 128, 1);\n\n\n\n    h->is_streamed = 1;\n\n\n\n    return 0;\n\nerr:\n\n    av_free(c->key);\n\n    av_free(c->iv);\n\n    return ret;\n\n}\n", "idx": 436, "substitutes": {"h": ["H", "ctx", "http", "bh", "q", "ih", "hw", "hash", "dh", "host", "ht", "r", "d", "n", "sh", "ph", "th", "auth", "uh", "ha", "g", "m", "hr", "ah", "ch", "home", "hm", "l", "p", "hi", "hh", "w", "e", "self", "hd", "f", "eh", "hp", "u", "history", "o", "v", "hl", "s", "b", "t", "he", "hs", "kh", "oh", "rh", "gh"], "uri": ["ur", "route", "ilo", "base", "cli", "href", " ur", "dn", "http", "abi", "iri", "ii", "URI", "filename", "url", "data", "pi", "ui", "present", "doi", "uni", "id", "oid", "mi", "query", "duration", "api", "umi", "i", "nil", "ri", "file", "attribute", "ir", "source", "address", "afi", "resource", "message", "u", " URI", "origin", "username", "phrase", "connection", "prefix", "iv", "qi", "plugin", "uid", "path", "subject", "specified", "io", "dir", "directory"], "flags": ["files", "opens", "Flags", "bugs", "ops", "lag", "rules", "vals", "prot", "faces", "reads", "fl", "cons", "locks", "options", "fixes", "ids", "checks", "bits", "args", "ats", "settings", "properties", "mods", "atts", "ffff", "flag", "features", "ints", "mask", "orts", "fields", "stats", "types", "ants", "tags", "fs", "ags", "FLAG", "plugins", "parts"], "nested_url": ["nestedsfile", "nested_str", "nested_l", "nested_id", "nesting_file", "nest_name", "nest_web", "nestedsl", "nest_l", "nesting_l", "nested_name", "nested_uri", "nest_path", "nest_id", "nest_str", "nested_web", "nest_uri", "nestedsurl", "nesting_url", "nest_url", "nested_path", "nested_file"], "ret": ["match", "base", "arg", "fun", "att", "mt", "ext", "def", "bit", " Ret", "success", "data", "get", "alt", "cat", "orig", "cur", "rets", "fit", "ben", "arr", "pass", " RET", "j", "code", "nt", "ft", "err", "rev", "str", "reply", "feat", "Ret", "pat", "back", "result", "ut", "fin", "len", "flag", "ref", "gt", "fat", "resp", "art", "RET", "error", "valid", "lit", "re", "run", "val", "rt", "reg", "part", "al", "let", "det", "res", "rc", "mem"], "c": ["fc", "cm", "this", "cs", "ctx", "a", "conn", "cc", "mc", "anc", "d", "n", "co", "ct", "nc", "cur", "cy", "con", "k", "enc", "y", "i", "g", "ac", "m", "code", "coll", "cr", "ch", "config", "C", "ec", "dc", "ce", "cu", "p", "l", "jc", "or", "e", "lc", "f", "self", "cache", "ca", "u", "cd", "cn", "sc", "conf", "vc", "o", "s", "v", "cp", "b", "t", "cf", "ic", "ci", "uc"]}}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439, "substitutes": {"avctx": ["abca", "AVctx", "avectx", "afcmp", "afctx", "afcontext", "raftcontext", "afpkg", "abcmp", "avpkg", "afctl", "aveca", "svcal", "auctl", "afcal", "auctx", "AVcu", "AVctl", "abctx", "svctx", "afcu", "raftpkg", "avctl", "aucontext", "avcontext", "avca", "abcontext", "svpkg", "avecontext", "svcontext", "afca", "avcmp", "raftctx", "avcu", "raftcal", "AVcmp", "AVcontext", "avecmp", "aucmp", "avecu", "avcal"], "count": ["call", "base", "name", "total", "offset", "ext", "counter", "current", "n", "page", "type", "weight", "id", "found", "parent", "num", "max", "code", "number", "index", "work", "c", "deep", "len", "length", "size", "child", "cache", "force", "col", "sum", "seq", "depth", "path", "low", "Count", "limit", "list", "part", "start"], "i": ["yi", "li", "gi", "q", "abi", "key", "a", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "r", "d", "I", "di", "n", "id", "it", "iu", "k", "j", "y", "m", "ri", "info", "ti", "multi", "index", "ini", "ai", "ip", "l", "c", "phi", "bi", "h", "e", "x", "f", "lc", "u", "o", "v", "s", "qi", "b", "t", "ix", "uri", "ci", "io", "mu", "fi", "start", "si", "xi"], "p": ["np", "parser", "vp", "ctx", "http", "lp", "pe", "data", "pi", "current", "d", "n", "ap", "pg", "sp", "cop", "it", "parent", "pb", "k", "op", "api", "pre", "j", "comp", "tp", "g", "y", "m", "fp", "P", "sync", "ps", "post", "pa", "l", "c", "ip", "e", "private", "per", "f", "patch", "hp", "u", "jp", "pm", "exec", "up", "o", "pc", "bp", "s", "at", "v", "cp", "b", "t", "plugin", "wp", "part", "pp", "port"]}}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "substitutes": {"filename": ["files", "name", "buffer", "named", "utf", "ppa", "txt", "binary", "tty", "folder", "fn", "wl", "buf", "fax", "lua", "fil", "nil", "Filename", "fp", "file", "sf", "ilk", "database", "sudo", "feat", "kn", "bf", "word", "l", "which", "dll", "f", "kl", "length", "wb", "STDOUT", "microsoft", "username", "il", "pty", "phrase", "prefix", "tools", "path", "socket", "FH", "whatever", "println", "directory"], "fd": ["fc", "ff", "ld", "fun", "fs", "da", "dd", "ud", "pd", "FD", "conn", "sd", "fed", "fw", "fa", "out", "d", "ad", "xd", "dl", "lf", "fl", "ln", "fn", "buf", "draft", "pipe", "fp", "file", "sf", "df", "dt", "ds", "md", "cod", "cond", "bf", "feed", "dc", "fe", "temp", "ind", "c", "fin", "f", "hd", "bd", " fid", "cd", "exec", "fat", "handler", "fx", "wd", "die", "connection", "fb", "cf", "od", "ecd", "vd", "FH", "ded", "nd", "dat", "dir", "fi", "gd", "db"], "ret": ["rot", "ort", "fun", "att", "mt", "def", "conn", "success", "out", "ct", "alt", "ry", "pet", "rets", "ben", "rf", "py", "pass", "j", "fail", "lt", "ait", "ft", "nt", "err", "rev", "cond", "reply", "status", "Ret", "feat", "bf", "dt", "result", "pret", "fin", "try", "rl", "len", "ref", "fat", "resp", "std", "art", "en", "sec", "obj", "RET", "rx", "lit", "re", "ann", "rt", "val", "reg", "pt", "let", "fi", "det", "res", "db"], "fdparam": ["draftparam", "dresource", "fpar", "FDparams", "dlresource", "fparams", "FDresource", "dParam", "fdresource", "fdpar", "dparam", "dlparam", "FDparam", "fdParam", "fdparams", "dlparams", "fparam", "dparams", "FDParam", "dlParam", "draftparams", "draftpar", "FDpar"], "st": ["stage", "ist", "src", "rest", "ss", "dd", "stat", "sd", "sb", "d", "ct", " est", "store", "spect", "St", "ste", "ft", "nt", "str", "storage", "fe", "et", "ut", "state", "put", "ST", "sc", "stab", "stream", "std", "obj", "rd", "sts", "sta", "inst", "t", "stop", "station", "ost", "td", "ast", "pt", "fi", "start", "sth", "est"]}}
{"project": "qemu", "commit_id": "7d55273fcdc307399fc0e327a0c14c140cd439cf", "target": 0, "func": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    // Override warm reset address with cold start address\n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        /* XXX: put correct offset */\n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    // XXX Should be pci_bus3\n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    /* FIXME: wire up interrupts.  */\n\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 461, "substitutes": {"RAM_size": ["ram_size", "rib00len", "ram00name", "rib_timeout", "ram_name", "rib_size", "rib00timeout", "ram00size", "ram00timeout", "ram_timeout", "rib_len", "rib00size", "rib_name", "ram00len", "rib00name", "ram_len"], "boot_devices": ["cache_device", "boot2groups", "boot_device", "bootlistgroups", "cache_mode", "cache_devices", "bootlistdevice", "cache_groups", "boot_groups", "boot2mode", "cachelistdevice", "boot_mode", "cachelistmode", "boot2device", "bootlistdevices", "cachelistdevices", "cachelistgroups", "boot2devices", "bootlistmode"], "kernel_filename": ["kernelockname", "linux_Filename", "kernel_file", "kernel_family", "linux_file", " kernel_name", " kernel_file", " kernel_profile", "kernel_profile", "kernel_name", "kernelockfilename", "kernel_Filename", "linux_filename", "kernelockprofile", "linux_family", "kernelockfile"], "kernel_cmdline": ["kernel_argline", "kernel_argend", "kernel_argname", "kernel_pathline", "kernel_cmdend", "kernel_commandname", "kernel_arglen", "kernel_cmdname", "kernel_commandlen", "kernel_pathend", "kernel_pathname", "kernel_pathlen", "kernel_cmdlen", "kernel_commandline", "kernel_commandend"], "initrd_filename": ["initrt_filename", "initrd_path", "initrt_mode", "initrd_mode", "initrd_file", "initrt_path", "initrt_file"], "cpu_model": ["cpu_models", "core_models", " cpuacmode", "cpu_image", " cpuacmodel", "cpuleximage", " cpu_image", " cpu_scope", "cpuacimage", "cpulexmodel", " cpu_mode", "cpuaclocation", "cpuaccache", "cpulexscope", " cpuaccache", "core_config", "cpuacmode", " cpuacmodels", "cpuacscope", "cpu_location", "cpu_config", "cpuacmodels", "cpu_mode", "core_model", "cpu_cache", "core_format", "cpulexlocation", "cpu_format", "cpuacmodel", "cpu_scope", " cpu_cache", " cpu_models", "core_mode", " cpu_location"], "hwdef": ["ctxdecl", "rwdf", "hzdecl", "hostdata", "ctxdefinition", "iwmd", "rwdef", "hubconf", "hzdesc", "ggdecl", "hwdecl", "fwdc", "rwmd", "hzdefinition", "htmd", "hzdef", "hwspec", "fwdesc", "wxdefinition", "ggdesc", "hawspec", "hwdefinition", "FWdc", "iwDef", "htdf", "ctxdesc", "hostDef", "hlspec", "hubdef", "hldefinition", "hwDef", "wxspec", "hwmd", "hawdef", "FWdesc", "hawdefinition", "ctxdef", "rwdc", "hwdf", "hwconf", "fwconf", "iwdf", "hubdata", "rwdesc", "hostdef", "ggdef", "hwdc", "fwdef", "hostconf", "hwdata", "htDef", "FWdef", "rwDef", "fwdata", "wxDEF", "hwdesc", "wxdef", "hwDEF", "hlDEF", "FWDef", "htdef", "ggdefinition", "hawDEF", "hubDef", "fwDef", "hldef", "iwdef"], "env": ["eu", "cli", "txt", "chn", "inv", "nc", "here", "enc", "inet", "args", "err", "ec", "opt", "cv", "vs", "theme", "skin", "gui", "viron", "en", "hl", "manager", "path", "engine", "dir", "energy", "ext", "extra", "context", "esi", "her", "equ", "shell", "bc", "ea", "assets", "end", "eng", "api", "po", "utils", "fg", "e", "conf", "core", "chal", "v", "ev", "site", "session", "het", "init", "edge", "np", "external", "ctx", "enable", "environment", "global", "ne", "enh", "ini", "exc", "vel", "h", "bot", "attr", "app", "loader", "el", "obj", "kit", "nw", "cf", "img", "qt", "net", "oa", "server", "qv", "fen", "conn", "profile", "dict", "cur", "scope", "ng", "output", "eni", "erv", "ah", "style", "config", "impl", "Environment", "eh", "exec", "bg", "dat", "que", "console", "export", "db", "ench"], "filename": ["files", "src", "name", "offset", "acl", "url", "binary", "tty", "shell", "fn", "buf", "kernel", "output", "fil", "Filename", "fp", "file", "config", "dll", "f", "username", "prefix", "uri", "path", "directory"], "nvram": ["nvnam", "vram", "vrom", "vnam", "vcnam", "qtnam", "vcram", "nvmem", "qtram", "qtmem", "vcmem", "vcrom", "vmem", "nvrom", "qtrom"], "ret": ["base", "ext", "stat", "out", "rets", "num", "enc", "model", "script", "code", "nt", "Ret", "fi", "reset", "f", "len", "exec", "RET", "final", "re", "reg", "val", "res"], "linux_boot": ["linux67bit", " linux_bit", "linux67lock", "linux67boot", " linux_config", "linux_update", "linux_config", "linux_bit", " linux_bus", " linux_update", " linux_size", " linux_lock", "linux_size", "linux_lock", "linux67update", "linux_bus"], "i": ["abi", "a", "ii", "pi", "r", "d", "I", "n", "is", "it", "j", "m", "info", "ip", "l", "c", "p", "e", "f", " I", "ion", "o", "v", "s", "b", "t", "io"], "ram_offset": ["ram_size", "ram_addr", "gram_offset", "ram_slice", "gram_size", "gram_addr", "gram_slice"], "prom_offset": ["prom_addr", "rem_size", "prom_size", "rem_padding", "rem_addr", "prom_padding", "rem_offset"], "initrd_size": ["initrt_len", "initrt_size", "initrd__num", "initrd__len", "initrt_num", "initrd_len", "initrd_num", "initrd_file", "initrt_file", "initrd__size", "initrd__file"], "kernel_size": ["loader_data", "kernel_address", "loader_size", "loader_time", "loader_address", "kernel_time", "kernel_data"], "pci_bus": ["pki_BUS", "pci__bus", "pci_BUS", "pci__BUS", "pci_usb", "pki_boot", "pci__boot", "pki_usb", "pki_bus", "pci__usb", "pci_boot"], "pci_bus2": ["pci_BUS1", "pci_device4", "pci_BUS4", "pci_device5", "pci_BUS5", "pci_device2", "pci_bus5", "pci_BUS2", "pci_bus1", "pci_Bus1", "pci_Bus2", "pci_device1", "pci_bus4", "pci_Bus5", "pci_Bus4"], "pci_bus3": ["pci_ux1", "pci_ux3", "pci_Bus11", "pci_BUS3", "pci_BUS11", "pci_ux2", "pci_Bus3", "pci_ux11", "pci_BUS2", "pci_bus1", "pci_Bus1", "pci_Bus2", "pci_bus11", "pci_BUS1"], "bh": ["dh", "lb", "pb", "hr", "bal", "hi", "hus", "pr", "hl", "abb", "rh", "BT", "pl", "sb", "ht", "ib", "zh", "sh", "bl", "batch", "fp", "hab", " Bh", "pkg", "p", "hp", "la", "hy", "mr", "adh", "bs", "hs", "gh", "roth", "ssl", "bol", "ctx", "bm", "cpp", "hub", "loc", "hn", "ha", "bda", "cb", "bj", "hm", "h", "bot", "hh", "phi", "br", "bt", "bp", "bb", "shr", "las", "aph", "kh", "lo", "http", "qv", "ih", "hw", "fl", "ph", "th", "uh", "rb", "ah", "ch", "bf", "rl", "cn", "eth", "bg", "pull", "fb", "b", "sth"], "irq": ["ireqs", "hrq", "ireque", "hrqs", "hrque", "irque", "irequ", "iraq", "iraque", "iraqs", "irqu", "irqs", "iraqu", "hrqu", "ireq"], "drive_index": [" drive_len", "driver_count", " drive_id", "driver_id", " drive_count", "driver_len", "driver_index"], "hd": ["dr", "ld", "ud", "dd", "pd", "hw", "ht", "hub", "xd", "di", "ha", "md", "hm", "haw", "cow", "du", "bd", "hp", "cd", "std", "wd", "hl", "adh", "hid", "vd", "nd", "dri", "rh", "gd"], "MAX_IDE_BUS": ["MAX_IDEADDEF", "MAX_ISEADDEF", "MAX_IDE_DEF", "MAX_IDEABD", "MAX_IDEABUS", "MAX_IDEADBD", "MAX_IDEADUSB", "MAX_ISE_BUS", "MAX_ISE_USB", "MAX_ISEADBD", "MAX_ISE_DEF", "MAX_ISEADBUS", "MAX_IDEAUSB", "MAX_ISE_BD", "MAX_ISEADUSB", "MAX_IDEADBUS", "MAX_IDEADEF", "MAX_IDE_USB", "MAX_IDE_BD"], "MAX_IDE_DEVS": ["MAX_IDE_DEvs", "MAX_IDE_DAVICE", "MAX_IDE_DIvs", "MAX_IDE_DAVS", "MAX_IDE_DEVICE", "MAX_IDE_DARS", "MAX_IDE_DIVICE", "MAX_IDE_DAvs", "MAX_IDE_DERS", "MAX_IDE_DIRS", "MAX_IDE_DIVS"], "fd": ["flow", "fc", "ff", "pd", "FD", "sd", "d", "dl", "fl", "lf", "id", "fp", "df", "cb", "ds", "md", "pid", "dc", "f", "bd", "fat", "fx", "wd", "v", "fb", "vd", "dir", "fs", "db"], "MAX_FD": ["max_DEF", "MAX_DIR", "max_DIR", "max_FD", "MAX_DF", "max_DF", "MAX_DEF"], "fw_cfg": ["fw2config", "fw2conf", "fw2cfg", "fw2def", "FW_config", "FW_cfg", "FW_def", "fw_config", "fw_def", "FW_conf", "fw_conf"], "reset_info": ["resetablearea", "resetedinfo", "resetallresult", "reset64result", "reset_INFO", "resetedcheck", "resetedprivate", "resetableresult", "reset_private", "resetallprivate", "config_result", "reset_check", "resetableinfo", "offset_result", "flush_object", "resetCresult", "config_info", "flush_info", "reset_error", "resetererror", "resetCinfo", "reset64info", "resetallInfo", "reseterinfo", "config_information", "offsetablecomment", "offsetableresult", " reset_result", " reset_Info", "reset_comment", "offsetablearea", "offset_area", "reseterINFO", "reset64Info", " reset_information", "flush_check", "reset_information", "resetallobject", "offset_comment", "flush_private", "resetCarea", "reset_start", " reset_INFO", "resetedobject", "offsetableinfo", "resetCcomment", "reset_Info", "reset_area", "reset_object", " reset_error", "resetallcheck", "offset_info", "resetallinfo", "reset_result", "config_start", "resetablecomment"]}}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474, "substitutes": {"env": ["eu", "ass", "export", "nc", "here", "enc", "inet", "code", "args", "er", "event", "err", "ec", "vs", "dev", "eval", "viron", "en", "manager", "engine", "emb", "energy", "ext", "extra", "oe", "context", "her", "ea", "end", "eng", "ef", "ce", "e", "esp", "conf", "core", "v", "ev", "init", "edge", "np", "ctx", "esc", "enable", "environment", "global", "ne", "gear", "info", "ep", "exc", "vel", "et", "loader", "cache", "el", "inst", "enter", "net", "vm", "server", "conn", "eb", "scope", "eni", "erv", "dt", "config", "exec", "cfg", "que", "console", "arch", "db", "rc", "oder"], "def": ["adv", "defined", "ass", "spec", "data", "d", "aux", "der", "end", "de", "parent", "ef", "proc", "code", "entry", "dep", "Def", "df", "info", "block", "dev", "f", "ref", "eval", "conf", "DEF", "decl", "define", "definition", "req", "cf", "gen", "val", "cfg", "init", "fi", "diff"], "i": ["ami", "li", "gi", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "d", "I", "di", "n", "id", "mi", "k", "iu", "j", "y", "m", "ri", "eni", "info", "ti", "ini", "index", "multi", "ai", "ie", "ip", "l", "c", "p", "hi", "e", "f", "u", "o", "v", "ki", "qi", "b", "t", "ix", "uri", "ci", "io", "mu", "fi", "start", "si", "xi"]}}
{"project": "FFmpeg", "commit_id": "ccc27e2139336b66cdec3bb73a2cc7e60ef7e599", "target": 1, "func": "static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    BFIContext *bfi = avctx->priv_data;\n\n    uint8_t *dst = bfi->dst;\n\n    uint8_t *src, *dst_offset, colour1, colour2;\n\n    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n\n    uint32_t *pal;\n\n    int i, j, height = avctx->height;\n\n\n\n    if (bfi->frame.data[0])\n\n        avctx->release_buffer(avctx, &bfi->frame);\n\n\n\n    bfi->frame.reference = 1;\n\n\n\n    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Set frame parameters and palette, if necessary */\n\n    if (!avctx->frame_number) {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        bfi->frame.key_frame = 1;\n\n        /* Setting the palette */\n\n        if (avctx->extradata_size > 768) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Palette is too large.\\n\");\n\n            return -1;\n\n        }\n\n        pal = (uint32_t *)bfi->frame.data[1];\n\n        for (i = 0; i < avctx->extradata_size / 3; i++) {\n\n            int shift = 16;\n\n            *pal = 0;\n\n            for (j = 0; j < 3; j++, shift -= 8)\n\n                *pal +=\n\n                    ((avctx->extradata[i * 3 + j] << 2) |\n\n                    (avctx->extradata[i * 3 + j] >> 4)) << shift;\n\n            pal++;\n\n        }\n\n        bfi->frame.palette_has_changed = 1;\n\n    } else {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        bfi->frame.key_frame = 0;\n\n    }\n\n\n\n    buf += 4; // Unpacked size, not required.\n\n\n\n    while (dst != frame_end) {\n\n        static const uint8_t lentab[4] = { 0, 2, 0, 1 };\n\n        unsigned int byte   = *buf++, av_uninit(offset);\n\n        unsigned int code   = byte >> 6;\n\n        unsigned int length = byte & ~0xC0;\n\n\n\n        if (buf >= buf_end) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n", "idx": 490, "substitutes": {"avctx": ["ajctx", "ahci", "verbc", "afcontext", "avrec", "akconfig", "avqa", "alcontext", "afctl", "evci", "avnp", "afcal", "ajnp", "aveqa", "avelc", "avebc", "navci", " avrec", "alctrl", "avecca", "ahctl", "alcal", "afci", "avcontext", "navconn", "akctx", " avpkg", "afcca", "aveconfig", "afcmp", "AVcontext", "avepkg", "avecu", "avcal", "abnp", "ajcf", "avectx", "afrec", "avecf", "afctx", "navcca", "navctx", "afpkg", "aveconn", "afbc", "akcontext", "navcf", "avcf", "afconn", "navcoll", "afnp", "abcf", "akcca", "avcoll", "avconfig", "navpkg", "abcontext", "avci", "verctx", "AVcmp", "avecal", "avecmp", "evctx", "evcontext", "aveci", "avtx", "ahcontext", "alctx", "aftx", "ahctx", " avtx", "avpkg", "aktx", "navctrl", "afqa", "AVcu", "abctx", "avctrl", "afcu", "afctrl", "avcca", "avectl", "afcf", "aflc", "avctl", "evconn", "avbc", "ajcontext", "vercontext", "akqa", "afconfig", "AVctx", "AVlc", " avci", "avconn", "AVconn", " avcontext", " avcf", "vercf", " avconfig", "alpkg", "alcf", "navcontext", "afcoll", "averec", "avecontext", "avecoll", "avcu", "avlc", "avcmp"], "data": ["head", "media", "base", "response", "delay", "name", "capacity", "buffer", "da", "read", "offset", "time", "channel", "sequence", "array", "device", "queue", "actions", "area", "image", "memory", "binary", "window", "align", "open", "buff", "video", "empty", "id", "timeout", "parent", "frame", "bin", "duration", "batch", "next", "output", "script", "body", "code", "slice", "source", "index", "config", "address", "content", "result", "pad", "block", "reader", "alpha", "shift", "size", "len", "date", "cache", "message", "value", "DATA", "padding", "bytes", "val", "load", "dat", "mode", "Data", "start", "input", "rc"], "data_size": ["data_data", "data_len", "data\u00b7size", "buffer_data", "buffer_handle", "buffer_size", "data\u00b7handle", "data_handle", "buffer_len", "data\u00b7len", "data\u00b7data"], "avpkt": ["affmt", "affkt", "affck", "avcpect", "avalpsnt", "avalpks", "avlpkt", "avpsect", "avPcht", "avxpnt", "avPacket", "afpmt", "avalpect", "afpct", "avdect", "avfmt", "avcacket", "avfpnt", "avpacket", "avPkt", "avdmt", "avalpsect", "avbet", "avpect", "avalpskt", "avcpnt", "avfpacket", "avpka", "avdacket", "avcpkt", "affacket", "avbacket", "avfck", "avfct", "avalpkt", "avfect", "avpet", "avtkt", "avbkt", "avfkt", "avepnt", "avpmt", "avepkt", "avpsnt", "avcck", "avalpnt", "avefpnt", "avpck", "avlpacket", "avtmt", "affka", "avlpka", "affect", "avxpks", "avtacket", "avfka", "avpct", "avPct", "affet", "avlcht", "avepcht", "avpnt", "afpkt", "avtect", "avefpcht", "avpsks", "avalpsks", "avxpkt", "avfpkt", "avpcht", "avefpacket", "avcct", "avdkt", "avPck", "avpskt", "avepacket", "afpect", "affct", "avPnt", "avfacket", "avbka", "avxpect", "afpacket", "avpks", "avfet", "avlnt", "avlpet", "avcpks", "afpck", "avfpcht", "afpka", "avefpkt", "avlkt", "avckt", "avlacket", "afpet"], "buf": ["ff", "fd", "buffer", "bag", "queue", "ab", "loc", "bc", "buff", "cur", "cas", "num", "batch", "lim", "rb", "proc", "box", "cb", "pool", "config", "feed", "result", "block", "cv", "Buffer", "vec", "len", "ref", "br", "cache", "cmd", "alloc", "seq", "fb", "uf", "img", "uc", "rc", "port"], "buf_end": ["buf_ends", "buff_ends", "buff_ad", "buff_end", "buff_start", "buf_start", "buf_ad"], "bfi": ["Bafi", "rfe", "pfi", "Bcci", "ffe", "Bci", "fcci", "lzi", " bbi", "pfa", "mbisi", "fifi", "lfi", "mbfen", "bfa", "fbi", "ffa", "pffe", "bffe", "lbfen", "rfi", "bbi", "ebifi", "nfi", "lbafi", " bafi", "ffi", " bfen", " bisi", "gbi", "gfa", "Bisi", "pifi", "lifi", "dcci", "bani", "dfa", "abfi", "lfa", "bci", " bii", " bfe", "bafi", "bifi", "Bfi", "lbfi", "bisi", "bii", "nfa", "wfa", "ebfa", "rifi", "dafi", "gffe", "ebfi", "obzi", "lani", "Bifi", "rfen", "ebii", "bfam", "blli", "oblli", "nifi", "Bii", "mbfi", "obfa", "fci", "bfen", "nfam", "rfam", "Bfen", "rfa", " bifi", "wfen", " bffe", " bcci", "Bfe", " bfa", "Bbi", "bzi", " bzi", "dci", "fffe", "lfe", "wfi", "difi", "wafi", "abffe", " blli", "mbii", "gfi", "bcci", " bani", " bfam", "obani", "rafi", "abifi", "obbi", "dfen", "Bfa", "lii", "obfi", "bfe", "dfi", "lbfa", " bci", "abfa", "Blli"], "dst": ["frc", "dsp", "idst", "adsc", "brc", "fdr", "dsc", "adst", "adsp", "dsts", "drc", "idsts", "lsc", "bbl", "Dsp", "ssc", "lrc", "bsc", " dbl", "Drc", "lsp", "sst", "fst", "nsc", " drc", "fsc", "fsts", "adrc", " dsc", " dsts", "dbl", "ndr", "lst", "iddr", "ddr", "bst", "Dsc", " ddr", "idrc", "nrc", "Dst", "sbl", "nst"], "src": ["href", "ctx", "channel", "host", "filename", "url", "loc", "fn", "frame", "rb", "dest", "fp", "cb", "slice", "source", "config", "st", "sel", "cv", "ptr", "attr", "stream", "origin", "uri", "img", "view", "dist", "rc"], "dst_offset": ["dst_length", "dbl_size", "dst_index", "dbl_index", "dbl_offset", "dbl_length", "dst_size"], "colour1": ["draw2", "draw1", "color1", "color2", "colorone", "colourone", " colourone", "color3", " colour3", "colour3", "drawone", "draw3"], "colour2": ["draw2", "draw1", "color1", "colour4", "color2", "color4", "draw4", " colour4"], "frame_end": ["image_set", "image_ends", "image_limit", "frame_begin", " frame_offset", "frame_offset", " frame_begin", "frame2end", "frame2offset", "frame2begin", "frame_ends", "framesend", "framesoffset", "frame_limit", "image_end", "framesbegin", "frame_set"], "pal": ["isal", "pl", "base", "pocket", "delay", "nav", "buffer", "li", "skip", "cal", "ass", "panel", "area", "chi", "ab", "align", "aa", "Pal", "bin", "ph", "span", "nl", "wal", "pos", "label", "pixel", "pan", "pod", "style", "ill", "fr", "pid", "ch", "slice", "pad", "l", "alpha", "p", "len", "theme", "ref", "app", "col", "f", "mask", "el", "chal", "range", "color", "sum", "v", "scale", "prefix", "cel", "border", "cell", "al", "val", "count", "all", "pin", "pp"], "i": ["yi", "ami", "li", "gi", "a", "ni", "ii", "zi", "ji", "jit", "ui", "pi", "image", "d", "I", "n", "di", "id", "mi", "im", "iu", "k", "it", "api", "y", "m", "eni", "ri", "info", "ti", "ini", "index", "z", "multi", "ai", "ie", "x", "h", "l", "p", "ip", "bi", "phi", "e", "f", "u", "ori", "ki", "v", "ix", "qi", "b", "vi", "uri", "ci", "io", "fi", "start", "si", "in", "xi"], "j": ["js", "li", "adj", "q", "jl", "key", "ii", "ji", "jit", "jen", "d", "n", "jj", "position", "J", "oj", "out", "job", "it", "k", "aj", "ij", "uj", "y", "m", "jo", "kj", "fr", "z", "ch", "ie", "h", "l", "x", "p", "shift", "jc", "e", "f", "jp", "el", "dj", "jet", "o", "v", "b", "ix", "qi", "jon", "si", "ja"], "height": ["flow", "resolution", "crop", "buffer", "time", "def", "context", "dim", "image", "high", "window", "d", "header", "id", "head", "k", "frame", "gap", "y", "ha", "num", "direction", "style", "slice", "h", "alpha", "w", "layout", "images", "f", "ref", "size", "history", "density", "padding", "v", "scale", "qi", "container", "depth", "img", "wall", "view", "shape", "bottom", "input", "family"]}}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491, "substitutes": {"opts": ["obfs", "optfs", "optths", "opoptions", "otters", "experters", " copts", "lockoptions", "opps", "optoptions", "otts", "lockts", "options", "experds", "opds", "oboptions", " copters", "experts", "opttions", "opTS", "optts", "optTS", " coptions", "ottions", "alters", "obTS", "optps", "lockfs", "alds", "opths", "opfs", "alts", "opters", "obts", " copths", "experps", "otths", "optds", "lockTS", "optters", "alps"], "oc": ["ob", "fc", "dr", "oci", "ow", "http", "roc", "anc", "cc", "mc", "oe", "oper", "ace", "loc", "co", "nc", "bc", "voc", "oid", "client", "op", "enc", "toc", "ac", "oo", "ok", "coll", "om", "mot", "ec", "oco", "OC", "c", "word", "lc", "ocr", "unc", "org", "sc", "drive", "soc", "object", "vc", "pc", "cca", "bb", "o", "iv", "ic", "os", "oca", "root", "uc", "acc", "ou", "rc"], "dc": ["dr", "cm", "fc", "DC", "dn", "da", "ga", "cc", "mc", "device", "gc", "d", "di", "cat", "nc", "director", "bc", "tc", "cdn", "ac", "coll", "df", "dt", "ds", "inc", "config", "ec", "cu", "c", "xc", "doc", "design", "lc", "sc", "ca", "cd", "disc", "vc", "cca", "pc", "cf", " DC", "dat", "dir", "input", "db", "rc"], "driver": ["dr", "route", "this", "dn", "device", "get", "url", "director", "sl", "driving", "args", "direction", "database", "feed", "force", "object", "s", "manager", "uri", "engine", "dir", "port", "target", "host", "type", "operator", "der", "end", "pass", "text", "handler", "creator", "iv", "plugin", "serial", "version", "browser", "oid", "project", "str", "writer", "c", "design", "vers", "loader", "error", "mode", "slave", "ride", "drivers", "cost", "_", "test", "service", "construct", "wrapper", "ops", "class", "d", "platform", "ctor", "coll", "config", "owner", "reader", "rider", "drive", "username", "river", "Driver", "desc"], "path": ["serial", "route", "test", "mount", "cross", "target", "key", "context", "device", "method", "host", "alias", "data", "url", "image", "loc", "parent", "pass", "inner", "Path", "sync", "source", "request", "pattern", "pointer", "config", "step", "work", "resource", "hop", "length", "child", "loader", "text", "object", "ath", "node", "prefix", "uri", "location", "full", "root", "dir", "desc", "input", "user", "port"], "id": ["route", "target", "key", "host", "sid", "image", "url", "tag", "kind", "head", "ID", "parent", "end", "ids", "code", "Id", "mid", "source", "pid", "ident", "address", "ip", "kid", "length", "uri", "dir", "port"], "dev": ["serial", "test", "local", "def", "device", "host", "data", "ver", "der", "Dev", "proc", "dest", "sync", "block", "cache", "node", "lib", "ev", "session", "dist", "engine", "debug", "root", "dir", "user"], "bus": ["serial", "unit", "route", "base", "test", "mount", "service", "http", "local", "build", "device", "Bus", "host", "hub", "class", "cat", "BUS", "bc", "boot", "loop", "pass", "phone", "proc", "plug", "sync", "coll", "bug", "project", "nt", "back", "config", "feed", "home", "block", "state", "us", "book", "child", "front", "cache", "drive", "object", "vc", "comment", "pull", "lib", "bridge", "plugin", "os", "session", "las", "product", "usb", "io", "root", "load", "board", "db", "port"], "err": ["ise", "ner", "gr", "rs", "Error", "rr", "der", "cur", "arr", "proc", "coll", "er", "ir", "cr", "str", "ah", "ch", "usr", "pr", "ar", "ev", "req", "error", "iter", "fi", "rh", "res"], "typename": ["tyrenamed", "tyename", "helpename", "typenames", "helperate", "tyrenname", "typamed", "tyrenamel", "typerename", "helpenate", "typedames", "cyperamed", "typedamed", "typamel", "typeame", "typame", "tyenate", "cypenname", "cyperame", "typedame", "tyrenename", "helperames", "typerames", "typedname", "tyrename", "typeramed", "tyenename", "cyperename", "typeamed", "helpenename", "sypenename", "cypenamed", "typenname", "cypenename", "helpenames", "typedate", "sypamel", "typeename", "tyenames", "sypename", "typenate", "typerame", "sypenamel", "sypamed", "cypename", "helperame", "cypername", "typedename", "sypenamed", "typenamed", "typenamel", "sypame", "typeamel", "typername", "typerate", "typenename", "helperename"]}}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n", "idx": 501, "substitutes": {"func": ["call", "fun", "this", "src", "lambda", "ctx", "wrapper", "a", "cc", "cl", "class", "bc", "fn", "package", "super", "proc", "code", "cb", "kw", "function", "pkg", "c", "self", "f", "lc", "unc", "attr", "exec", "Function", "as", "pc", "amd", "thread", "b", "cf", "xxx"], "arg": ["argument", "call", "ig", "ass", "array", "new", "loc", "cat", "Arg", "empty", " argument", "arr", "enc", "param", "par", "g", "ac", "item", "args", " Arg", "ack", "arc", "ax", "ar", "exec", "sec", "amp", "pc", "var", "Args", "ann", "inc", "ace", " args"]}}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n", "idx": 510, "substitutes": {}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539, "substitutes": {"cpu": ["ilo", "cli", "roc", "gc", "process", "current", "lb", "clock", "nc", "px", "CPU", "cu", "css", "linux", "cp", "uu", " proc", "consumer", "gru", " cp", "bc", "cci", "nic", "frame", "mac", "fp", "pkg", "cow", "lc", "core", "fc", "cm", "ctx", "cpp", "computer", "ck", "prof", "boot", "proc", "cb", "pid", "c", "xc", "pu", "loader", "cache", " pc", "chip", "processor", "node", "cf", "uca", "net", "performance", "uc", "null", "vm", "server", "gpu", "intel", "hw", "conn", "uci", "tc", "platform", "fps", "comp", "auc", "none", "config", "bench", "dc", "cn", "ctrl", "pc", "cmp", " CPU", "sta", "ci", "console", "rc"], "cc": ["PC", "fc", "cm", " gcc", "cs", "ctx", "conn", "gc", "LC", "mc", "cl", "uc", "class", "ck", "co", "bc", "cci", "con", "tc", "client", "VC", "code", "cb", "cod", "ec", "dc", "ce", "cu", "c", "css", "xc", "cn", "cache", "ctrl", "core", "ca", "cca", "pc", "cp", "cmp", "ucc", "cf", "ci", "CC", "acc", "rc"], "ret": ["match", "nz", "test", "arg", "fun", "buffer", "rs", "gc", " Ret", "success", "data", "get", "alt", "job", "cur", "ry", "pet", "rets", "ben", "num", "rf", "pass", " RET", "rep", "scan", "nt", "back", "reply", "Ret", "result", "len", "reset", "ref", "sys", "ctr", "resp", "value", "sec", "en", "pc", "RET", "hard", "valid", "re", "reg", "val", "addr", "al", "fi", "det", "res", "mem"], "sc": ["fc", "sac", "src", "cs", "isc", "ss", "esc", "rs", "spec", "osc", "sb", "mc", "cl", "access", " SC", "ct", "RC", "bc", "sp", "sh", "scope", "tc", "sk", "loop", "comp", "ac", "cr", "SC", "config", "ec", "asc", "dc", "c", "sw", "cv", "lc", "soc", "sq", "ca", "core", "exec", "sys", "sr", "pc", " scr", "Sc", "si", "sci", "ctl", " Sc", "uc", "acc", " rc", "rc", " ss"], "last_tb": ["last_tyb", "last_nbl", "last_tabb", "last_Tbase", "last_interub", "last_ctabb", "last_tbs", "last_ctp", "last_torbase", "last_ptub", "last_torb", "last_Tb", "last_Tlb", "last_interf", "last_Tbl", "last_torbi", "last_nlb", "last_interk", "last_Tub", "last_pbs", "last_tbase", "last_ptk", "last_Tbi", "last_Tf", "last_pbi", "last_tyabb", "last_tp", "last_interb", "last_pbase", "last_Tbs", "last_nbs", "last_ptbs", "last_tybs", "last_tub", "last_tf", "last_torbs", "last_tbl", "last_ptlb", "last_typ", "last_ctb", "last_ctbs", "last_tbi", "last_pb", "last_Tp", "last_Tabb", "last_ptb", "last_ptf", "last_Tk", "last_nb", "last_tk", "last_tlb", "last_ptbl"], "tb": ["tbb", "rtbs", " tr", " tbb", "tsb", "ttb", "ttbs", "rtr", "tk", "ptb", "tbs", " tbi", "ttbb", "ptk", "tr", "tsr", "tsbi", "ptbs", "ptr", "ttr", "ttbi", "tsbb", "rtk", "rtb", "ttk", "tbi"]}}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n", "idx": 547, "substitutes": {"dest": ["this", "rest", "txt", "de", "destroy", "master", "home", "opt", "trans", "sc", "decl", "sum", "cp", "gest", "pack", "sup", "target", "access", "Dest", "parent", "end", "cdn", "tmp", "later", "coord", "text", "die", "wd", "lit", "outer", "build", "new", "loc", "global", "store", "des", "proc", "cont", "feat", "st", "ident", "usr", "inst", "gen", "img", "iter", "slave", "uc", "done", "stage", "test", " dst", " Dest", "class", "d", "orig", "priv", "ord", "grad", "output", "comb", "nt", "source", "temp", "config", "dc", "wb", "uv", "miss", "std", "sort", "dat", "desc", "dist"], "src": ["reflect", "sub", "cli", "this", "rest", "roc", "url", "sl", "master", "ack", "cv", "self", "scl", "sys", "sc", "sup", "target", "spec", "sb", "send", "sth", "RC", "bc", "tmp", "usc", "sit", "lc", "core", "sr", "sn", "iv", "usb", "bs", "sci", "ssl", "ctx", "rs", "ruby", "chrom", "loc", "ins", "bin", "super", "cb", "slice", "feat", "st", "sel", "attr", "sec", "gl", "inst", "sur", "req", "img", "uc", "inf", "rob", "cur", "grad", "rb", "sync", "source", "config", "impl", "ources", "stack", "rl", "sq", "uv", "gb", "cmp", "support", "dist", "rc"], "pmcw": ["pmacw", "pmlcw", "pmcwa", "pmcwd", "mplcws", "pmlcws", "pmlcwl", "pmmcwy", "pmdcew", "pmacwd", "pmpcwa", " pmcwl", "mpcw", "mpcwy", "pmlcwy", "pmlcsw", "pmpcwl", "pmcew", "pmdcws", "PMcws", " pmpcwl", "mpcws", "pmcwy", "pmmcsw", "pmlcew", "mplcwy", "pmdcwd", "pmrcwa", "PMcwd", "mplcw", "pmcws", "pmdcwl", "mpcsw", "pmdcwy", " pmpcew", "pmdcsw", "pmacwa", "pmcsw", " pmpcwa", "pmpcew", "PMcw", "pmmcw", "pmacws", "pmlcwa", "pmrcws", "PMdcws", "pmrcwd", "pmdcw", "PMdcwd", "PMdcw", "PMcwa", " pmcwa", " pmpcw", "PMdcwa", " pmcew", "pmpcw", "pmdcwa", "mplcsw", "pmmcws", "pmcwl", "pmrcw"], "i": ["cli", "key", "next", "j", "g", "anti", "ti", "index", "x", "hi", "f", "u", "s", "uri", "fi", "start", "name", "isin", "zi", "ji", "pi", "ui", "type", "id", "mi", "k", "iu", "y", "ri", "ie", "p", "e", "lc", "v", "ix", "qi", "t", "count", "io", "mu", "init", "in", "li", "a", "ni", "ii", "data", "r", "I", "di", "m", "info", "slice", "ini", "h", "c", "phi", "o", "module", "si", "yi", "gi", "ei", "oi", "d", "jj", "it", "eni", "multi", "ai", "ip", "l", "block", "bi", "b", "ci", "xi"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566, "substitutes": {"ist": ["dr", "ism", "ists", "act", "rest", "ct", "adder", "kt", "er", "ind", "pop", "set", "wp", "gest", "irst", "est", "ld", "ext", "alist", "ht", "sth", "erd", "pick", "edit", "ict", "asp", "adr", "post", "work", "esp", "isi", "wd", "uss", "ird", "iz", "nd", "ast", "pt", "artist", "ard", "IST", "osi", "xt", "ad", "add", "op", "ait", "str", "feat", "st", "oss", "et", "ide", "isu", "ista", "rss", "inst", "sim", "dit", "ust", "isc", "dd", "isd", "ant", "asi", "ord", "it", "iste", "pect", "nt", "ft", "mot", "ess", "ocr", "art", "std", "ilst", "sta", "dat", "part", "ace", "gd", "dist"], "pkt": ["pcht", " packet", " pct", "pnt", "poch", "tpacket", " poch", "jpkt", "pelt", "pkh", "tacket", "paelt", "ipkh", "Pft", "wpcht", "prekt", "paacket", "spkt", " pkg", "packet", "wpkh", "ipcht", " pqt", "preacket", "tpcht", "ipnt", "cpelt", "ipkt", " pcht", "wpnt", "pkg", "tpkt", "spkg", "Pkg", "ipacket", "cpoch", "jpacket", "pct", "pakt", "dunch", "Pkt", "ipelt", "spacket", "Pcht", "punch", "spcht", "pft", "prent", " pelt", " punch", "Pnt", "ipoch", "cpkt", "jpqt", "tkt", "spnt", "Punch", "telt", "tcht", "Pelt", "spelt", "Pct", " pft", "tpqt", "Pqt", "preelt", " pnt", "pacht", "spkh", "cpacket", "dacket", "pqt", "dkt", "wpkt", "dct", "jpft", "Packet"], "i": ["ret", "out", "I", "n", "id", "it", "num", "j", "g", "rep", "inner", "info", "nt", "multi", "h", "x", "p", "et", "fin", "f", "len", "set", "reset", "en", "debug", "start", "det", "res"], "got_output": ["gotestenabled", "genestgenerated", "given_input", " got_Output", "got_hidden", "got_control", "gotesttarget", "gotaccontrol", "got_target", "gotayenabled", "gotacoutput", "genestenabled", "gotachidden", "genestoutput", "got_Output", "given_output", " got_value", "gen_target", "got_value", "genesttarget", "gotayOutput", "got_reason", "got_progress", "got_input", "got_enabled", "got_generated", "gotestgenerated", "gotaygenerated", "gen_output", "gotayreason", " got_reason", "gotacinput", "given_control", "gotestoutput", "gotaytarget", "gen_enabled", " got_progress", "given_hidden", "gen_generated", "gotayoutput"], "avpkt": ["avnpka", "avnpkt", "ullpck", "avcurrentkt", "affkt", "affck", "avpreacket", "AVpqt", "attcpacket", "avopck", "avspacket", "avprekt", "ajpkt", "avpft", "avppsth", "avespacket", "avpakt", "avvacket", "avppka", "avbputh", "ajmft", "AVpauth", "attcpkt", "avcurrentacket", "airlelt", "avfcht", "avbcht", "avhelt", "avelacket", "avcpet", "avmcht", "navpkat", "airpKT", "avcacket", "avepka", "avgelt", "avpqt", "avbpcht", "avpett", "avpacht", "avpacket", "avppft", "avpekt", "avpaunch", "airlacket", "avpeconn", "avpkat", "avcnt", "avpaacket", "airbkt", "avcpacket", "avcpt", "avrcht", "avppkh", "avepunch", "avspeth", "avpka", "avbpqt", "avbpkt", "avpaft", "attpacket", "avgkt", "ajpcht", "ajmkt", "navdacket", "avdacket", "airpett", "avcpkt", "AVpaft", "avnpck", "avcpck", "affacket", "avspelt", "avlKT", "avppck", "avbacket", "avppkt", "avfck", "ajpft", "avbpsth", "airbett", "ampkt", "avespkt", "avspunch", "avfunch", "avfpka", "avenpkt", "ullppsth", "attcpet", "avfconn", "avelnt", "avheth", "avvkt", "avpunch", "avpet", "avbkt", "navdkat", "avfiece", "avfkt", "avmkt", "avprkat", "avepnt", "ajmelt", "avepkt", "avbpck", "navpkt", "airbft", "AVpaqt", "ampcht", "ullppck", "avfpft", "ullpkt", "avwett", "avbett", "avespunch", "avwcht", "attpck", "avbpft", "avpck", "avespcht", "avpreelt", "avbconn", "ampeth", "airlKT", "avapeth", "avepft", "avelpt", "avgft", "amspeth", "avppt", "attpkt", "avpKT", "avbuth", "avdkat", "avpeth", "avspcht", "avpreKT", "ullpkh", "ampelt", "avapelt", "avnpsth", "ajpelt", "ajmcht", "avspkt", "affconn", "attcpck", "avbck", "avvKT", "avvelt", "avenpck", "avbpkh", "airlkt", "amspkt", "avepcht", "amspelt", "airpcht", "airpft", "avdiece", "avopacket", "afpconn", "avhcht", "airpelt", "avpnt", "navpiece", "AVpkt", "avpsth", "afpkt", "avbqt", "avmft", "avputh", "avfpck", "avwft", "avfkat", "avrft", "avbft", "avelkt", "avmelt", "navdkt", "avpriece", "avgcht", "avopet", "avpconn", "avbpelt", "airbcht", "ullpsth", "avfpkt", "navdiece", "avpcht", "avpkh", "avlpt", "avdkt", "avapkt", "AVputh", "avepacket", "avprkt", "ullppkh", "avopkt", "avenpft", "avfacket", "avcurrentpt", "avnpft", "avpiece", "aveppt", "avpracket", "avpeacket", "avnpkh", "afpacket", "avepck", "AVpakt", "avfet", "avenpka", "avlnt", "airpacket", "avpaqt", "ullppkt", "navpacket", "afpck", "amspcht", "avrkt", "AVpft", "avhkt", "avpelt", "airpkt", "avlelt", "avapcht", "avwkt", "avpeck", "avlkt", "avckt", "avlacket", "avcurrentnt", "avpauth", "avrett", "attpet"]}}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, CPUState *cpu)\n\n{\n\n    CPUX86State *env = cpu->env_ptr;\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n    target_ulong pc_start = s->base.pc_next;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n    if (sigsetjmp(s->jmpbuf, 0) != 0) {\n\n        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        return s->pc;\n\n    }\n\n\n\n next_byte:\n\n    b = x86_ldub_code(env, s);\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = x86_ldub_code(env, s);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n            }\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n            }\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = x86_ldub_code(env, s);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = x86_ldub_code(env, s);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = x86_ldub_code(env, s) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n                }\n\n            }\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n        }\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n        }\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = x86_ldub_code(env, s) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = x86_ldub_code(env, s);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = x86_ldub_code(env, s);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        }\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n        }\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n                }\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                }\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        }\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = x86_lduw_code(env, s);\n\n            level = x86_ldub_code(env, s);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n        }\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n        }\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    }\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n        }\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = x86_ldq_code(env, s);\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = x86_ldq_code(env, s);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = x86_ldub_code(env, s);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = x86_ldsw_code(env, s);\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = x86_ldsw_code(env, s);\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n        }\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n        /* load shift */\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            }\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            }\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n            }\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n            }\n\n        }\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = x86_ldub_code(env, s);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            }\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n            }\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n            }\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                }\n\n                break;\n\n            }\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_rdtscp(cpu_env);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x11a:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n                }\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n                    }\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n                }\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                }\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n            }\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            }\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n                }\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n                }\n\n                break;\n\n            }\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            }\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n", "idx": 569, "substitutes": {"s": ["sg", "js", "qs", "n", "client", "options", "g", "ses", "ls", "args", "sf", "storage", "sie", "vs", "self", "us", "secondary", "sys", "sc", "u", "linux", "socket", "se", "fs", "sup", "spec", "ts", "sb", "ings", "ips", "xs", "utils", "sets", "p", "e", "conf", "core", "v", "su", "site", "S", "os", "t", "session", "ks", "serv", "its", "hs", "sci", "in", "plugins", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "r", "is", "ins", "ions", "i", "space", "m", "proc", "settings", "ds", "als", "ps", "gs", "native", "ns", "c", "es", "o", "si", "series", "server", "service", "ops", "strings", "d", "scope", "sync", "ys", "status", "services", "features", "sq", "full", "states"], "cpu": ["vm", "gpu", "cs", "ctx", "intel", "roc", "conn", "gc", "sb", "cpp", "nc", "CPU", "proc", "fp", "pool", "config", "bench", "c", "p", "SCP", "lc", "pu", "cache", "sys", "core", "sc", "processor", "node", "linux", "ssl", "cp", "cmp", "socket", "net", "gp", "fs", "mem"], "env": ["eu", "np", "server", "exe", "ctx", "conn", "context", "ens", "esm", "txt", "queue", "environment", "sl", "ea", "scope", "buf", "enc", "eni", "proc", "args", "info", "settings", "config", "ec", "exc", "c", "e", "loader", "cache", "conf", "viron", "en", "iss", "ev", "session", "engine", "console", "si", "ssl"], "b": ["ob", "orb", "buffer", "ba", "a", "byte", "sb", "be", "lb", "ab", "binary", "mb", "r", "B", "ib", "n", "d", "eb", "pb", "buf", "batch", "i", "bis", "rb", "cb", "reb", "h", "x", "c", "p", "l", "w", "e", "nb", "wb", "bg", "v", "bb", "bu", "fb", "abb", "bar", "bs", "emb", "xb"], "prefixes": [" prefixerves", "periodes", "prefixions", " prefixipes", "fixeserves", " prefixures", "refs", "spreads", "mixals", " prefixing", "spreadends", "refes", "fixesuses", "terminerves", " prefixets", "indexends", "termins", "indexs", "indexeds", "prefixeds", "fixeses", "prefixs", "fixesures", "mixs", "periods", "spreaderves", "fixlines", "prefixerves", "responsals", "prefixipes", " prefixals", "fixes", "fixesipes", " prefixions", "fixesing", "indexerves", "responsets", "responses", " prefixeds", " prefixe", "Prefes", "prefixing", "responss", "fixs", "periode", "refeds", "mixets", "prefixlines", " prefixuses", "fixese", " prefixlines", "Prefs", "prefixures", "Prefipes", "periodlines", "indexe", "fixess", "prefixets", "spreades", "prefixals", " prefixends", "Prefing", "terminuses", "refions", "fixe", "prefixe", "termines", "indexures", "indexes", " prefixs", "mixes", "indexions", "prefixends", "prefixuses"], "shift": ["ff", "row", "sup", "loc", "align", "rec", "off", "comp", "pos", "rep", "roll", "push", "hift", "Shift", "ip", "pop", "ffff", "size", "br", "ctr", "pull", "scale", "seq", "cmp", "pack"], "ot": ["rot", "O", "ort", "ow", "no", "ol", "Opt", "ian", "oll", "stat", "ops", "Len", "ogo", "out", "ots", "i", "g", "ac", " alloc", "OT", "ec", "opt", "or", "p", "oc", "o", "lib", "t", "os"], "aflag": [" aflow", "alflow", "avrag", "afrag", "alfrag", "alflace", "avlag", "aflow", " aflace", "alflag", " afrag", "avlace", "aflace", "avlow"], "dflag": [" dFLAG", "fflags", "dFLAG", "dtflag", "dtflags", "dfree", "dtfree", "ffree", "fflag", "fFLAG", "dtFLAG", " dfree", "dflags", " dflags"], "modrm": ["MODlr", "MODnm", "regnm", "modbm", "regbm", " modnm", "regrm", "MODbm", "reglr", " modbm", " modlr", "MODrm", "modnm", "modlr"], "reg": ["REG", "rest", "gr", "loc", "ru", "rec", "rep", "eg", "ro", "ram", "rem", "exec", "comm", "rel", "asm", "req", "rx", "rar", "re", "Reg", "debug", "map", "res", "dist", "mem"], "rm": ["rot", "cm", "dr", "bm", "rn", "rr", "rob", "lr", "rf", "m", "rpm", "dm", "ref", "rem", "arm", "pm", "rd", "mr", "rom", "rx", "rar", "addr", "rt", "mode", "repl", "mem"], "mod": ["rot", "sub", "fun", "access", "ver", "add", "im", "grad", "mult", "comp", "max", "mac", "rep", "m", "roll", "mods", "pop", "MOD", "lib", "req", "module", "mode", "pin", "perm", "mem"], "op": ["rot", "ops", "oper", "ap", "prop", "cop", "comp", "pre", "rep", "pool", "opt", "ip", "p", "pop", "hop", "prev", "oc", "mp", "up", "o", "cp", "cmp", "omp", "mode", "pin", "option"], "opreg": ["copreg", "optrem", "optstat", " opmod", "copstat", "copmod", "optreg", "oprem", "opstat", "optmod", "coprem", "opmod", " opstat", " oprem"], "val": ["rot", "ret", "fun", "split", "vals", "loc", "alt", "slot", "sl", "grad", "pos", "index", "len", "eval", "ref", "exec", "value", "rel", "v", "lib", "seq", "valid", "al", "mem"], "next_eip": ["next_peips", "next_iip", "next_eips", "next_uIP", "next_eib", "next_iips", "next_iib", "next_uip", "next_peip", "next_eIP", "next_peIP", "next_peib", "next_uips", "next_uib", "next_iIP"], "tval": ["Tlen", "Tval", " tlen", "tvals", "tlen", " tvals", "fvals", "farr", "fval", "tarr", "flen", "Tarr", "Tvals", " tarr"], "rex_w": ["rex1w", "rex_n", "rex1v", "rex_W", "rex1f", "rex1n", "rex_v", "nexus_n", "rx_w", "rx_x", "nexus_v", "nexus_w", "rex_x", "rx_r", "rex_f", "rx_W", "nexus_f"], "rex_r": ["pex_rb", "rex2rb", "cmp_r", "pex_x", "rex2nr", "rex_nr", "rex_l", "rex2r", "cmp_l", "rex_v", "pex2rb", "cmp_v", "pex2r", "pex2nr", "rex_rb", "cmp_h", "rex_x", "pex_r", "rex2x", "pex2x", "pex_nr", "rex_h"], "pc": ["PC", "fc", "server", "cs", "ctx", "channel", "cc", "mc", "pin", "ping", "nc", "bc", "con", "pb", "tc", "pre", "proxy", "ac", "proc", "pointer", "func", "dc", "pa", "c", "p", "xc", "arc", "lc", "cache", "sc", "sys", "mp", "vc", "bp", "prefix", "uc", "rc", "port"], "base": ["unit", "based", "server", "name", "buffer", "extra", "area", "ase", "Base", "id", "basic", "frame", "pre", "model", "builder", "body", "index", "temp", "bas", "p", "bi", "reset", "cache", "core", "origin", "processor", "prefix", "root"]}}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572, "substitutes": {"bs": ["cms", "base", "cs", "ss", "bh", "rs", "sb", "lb", "BS", "bid", "bc", "pb", "ils", "cas", "bl", "bis", "ls", "ses", "bits", "sync", "ds", "bas", "gs", "ns", "css", "vs", "bi", "bos", "gb", "bt", "bb", "bp", "iss", "fb", "its", "fs"], "filename": ["files", "fd", "name", "buffer", "src", "utf", "sequence", "txt", "memory", "url", "tty", "binary", "download", "fn", "fil", "nil", "actual", "Filename", "fp", "file", "sf", "sbm", "document", "kn", "which", "dll", "f", "length", "kl", "rl", "java", "username", "il", "phrase", "ssl", "prefix", "bytes", "path", "subject", "location", "uri", "directory"], "flags": ["files", "windows", "fun", "Flags", "utf", "ops", "bit", "lag", "format", "fn", "locks", "options", "comments", "bits", "args", "settings", "config", "ffff", "flag", "features", "mask", "fields", "stats", "types", "bytes", "reg", "fs", "FLAG"], "iscsilun": ["discslune", "iscslon", "ibsilun", "ibsilon", "iscisolin", "iscinelin", "discsilin", "iscsluns", "ibislon", "discsluns", "iscsilUn", "iscsalur", "ibsilUn", "discslin", "discsilun", "iscisolune", "iscsilin", "ibislun", "iscslin", "iscinelun", "discsilune", "iscisoluns", "iscislon", "iscislun", "iscineluns", "discsiluns", "iscsilur", "iscsilon", "iscslur", "iscsilune", "discslun", "iscslUn", "iscislUn", "iscsiluns", "iscslun", "iscsalon", "iscsalun", "iscsalUn", "ibsilur", "iscisolun", "iscislur", "iscslune", "ibislUn", "iscinelune", "ibislur"], "iscsi": ["sicsa", "islni", "iscSI", "ircdi", "uscchi", "ISCni", "miscsa", "ircchi", "ISCsa", "uscdi", "uscsi", "uscSI", "ircli", "discdi", "rcsi", "sicifi", "becsi", "wicni", "miscsi", "ircsi", "incSI", "discci", "iscsis", "islsi", "ISCsi", "sicsis", "discsi", "iscsa", "iscfi", "ircfi", "wicsi", "iscli", "iscci", "ircni", "discfi", "islsb", "discli", "rcni", "ircifi", "incani", "ircsb", "ircci", "discsie", "islsa", "iscdi", "incfi", "uscni", "discii", "wicsb", "becsie", "wicsa", "wicii", "iscsb", "iscani", "iscni", "iscchi", "iscifi", "wicsie", "sicsi", "ircsa", "miscsis", "uscci", "rcsa", "iscsie", "becii", "wicani", "incsi", "ircani", "ircSI", "discsa", "iscii", "ircsis", "rcci", "ISCci", "incsa", "becsa", "incchi", "miscifi", "incli", "incni", "uscsa", "discni"], "iscsi_url": ["iscsi_uri", "iscsi__host", "iscsi_location", "iscsi__user", "iscsi_user", "iscni__text", "iscsi___source", "iscsi__coll", "iscgi__mount", "iscsiOuri", "iscsin_user", "iscsi__text", "isceni_path", "iscii_name", "iscsi_run", "iscsi_layer", "iscsi_str", "iscni__user", "iscSI_uri", "iscSI_url", "iscbi_fl", "iscsi__name", "iscsiPrun", "iscni_file", "iscii_str", "iscni_url", "iscsi_view", "iscsi_mount", "iscgi__url", "iscsi_coll", "iscsiPUrl", "iscSI_view", "iscsi__source", "iscii_url", "iscsi2mount", "iscsi_text", "iscSI_URL", "iscsi___url", "isceni_url", "iscsiOview", "iscsi_URL", "iscni_text", "iscgi__host", "iscsin_url", "isceni_str", "iscgi_source", "iscii_service", "iscsin_server", "iscsiPurl", "iscii_run", "iscsi_path", "iscsi_host", "iscsi2host", "iscsi_file", "iscsiOURL", "iscsi_Url", "iscbi_url", "iscgi_host", "iscgi_url", "iscsin_sl", "iscsi_channel", "iscbi_location", "iscni_layer", "iscsi___file", "iscbi_coll", "iscsi_name", "iscii_channel", "iscsi2url", "iscgi__source", "iscni__url", "iscsi_service", "iscsi_server", "iscsiPservice", "iscsiOurl", "iscni_coll", "iscsi__url", "iscii_user", "iscsi___layer", "iscsi__str", "iscsi_source", "iscii_path", "iscgi_mount", "isceni_Url", "iscni__coll", "iscsi_sl", "iscsi_fl", "iscni_source", "iscsi2source", "iscii_Url", "iscsi__mount", "iscni_user"], "task": ["unit", "Task", "bit", "method", "image", "class", "parent", "instance", "\u7684", " Task", "proc", " alloc", "tx", "master", "func", "result", " tasks", "ACK", "link", "TYPE", "NAME", "transfer"], "initiator_name": ["initiation__type", "initiate_names", "initiator__names", "initiation_name", "initiating_id", "initiating_type", "initiator_names", "initiator__key", "initiator__no", "initiation__id", "initiate_name", "initiator_id", "initiate_no", "initiator_no", "initiator__id", "initiation_names", "initiator_type", "initiator__name", "initiating_names", "initiation__name", "initiation__names", "initiator_key", "initiation_type", "initiation_id", "initiator__type", "initiate_key", "initiating_name"], "ret": ["match", "arg", "fun", "att", "mt", "bit", "success", " Ret", "get", "alt", "cat", "job", "cur", "wait", "rets", "arr", "num", " RET", "rep", "proc", "code", "lt", "rb", "nt", "ft", "rev", "str", "reply", "status", "Ret", "rc", "bf", "opt", "feat", "back", "result", "fin", "ut", "nb", "len", "rl", "flag", "ref", "gt", "resp", "art", "obj", "RET", "req", "wa", "lit", "reg", "re", "val", "let", "count", "rt", "part", "pt", "det", "res", "mem"]}}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "substitutes": {"pkt": ["bwk", "macket", "cpnt", " packet", "bnt", "wacket", " pct", "pnt", "Pnt", "fet", "felt", " pwk", "pet", " pet", "bkt", " pnt", "melt", "facket", "mkt", "cpkt", "belt", "fnt", "fwk", "pwk", "pelt", "mnt", "wkt", "cpacket", "cpet", "wnt", "fkt", "pct", "packet", "backet", "wct", "Pkt", "Pct", "Packet"], "pkt_data": ["pkt_dat", "pkt_start", "pkt2dat", "pkt2len", "pkt2data", "pkg_length", "pkg_len", "packet_dat", "packet_data", "packet_len", "pkt_length", "pkg_start", "pkg_data"], "pkt_len": ["packet2seq", "pkt2length", "pkt64len", "packet2Len", "packet2length", "pkt64length", "pkt2len", "pkt_en", "pkt64Len", "pkt_Len", "packet_Len", "pkt2seq", "pkt_size", "packet_en", "pet_Len", "pkt2Len", "pet_len", "packet_len", "packet2len", "packet_size", "packet_length", "pkt_seq", "pkt_length", "pet_data", "pet_length", "packet_seq", "pkt64seq"], "vhdr": ["vhmt", "vghDR", "evbhrec", "evbhdi", "vmhrd", "evhdr", "ghrdr", " vhDR", "vmhlder", "svhrdr", "viewhDR", "vhrdr", "vithdi", "vvdr", "vrhder", "vihstr", "vohmt", "viewhrgr", "vphhr", "vshder", "evbhdr", "vhder", "viewhrrt", "vohrec", "vahdr", "vrhDR", " vphdr", " vhhr", "svrhrr", "vhrstr", "vmhlrd", "vghdc", "ghrstr", "svhrr", "vadhder", "vhlbr", "ghrd", "vhhr", "vhdvd", "vmhder", "vhrgr", "vhgr", "vshhr", "vbhdr", "vhlrid", "vithmt", " vphDR", "vohdr", " vhder", "vrhdr", "vbhmt", "viewhder", "vhdgr", "vethDR", " vghDR", "vhrrd", "vvbr", "vhrec", "vbhrc", "vohdi", "vhrhr", "viewhvd", "vithrec", "viewhrdr", "vchder", "vhlvd", " vphhr", "vhrt", "vghrt", "svhdr", "viewhrder", "svhrbr", "svrhdr", "vhdc", "vhlder", " vhrid", "varchdr", "vchrid", "vhlgr", "svhDR", " vshDR", "svchrc", "ghdr", "vphld", "evhdi", "vhrid", "vahder", "vphDR", "svrhder", "vadhld", "vhrd", "vhladr", "vbhdc", "vghder", "vphrd", " vhld", "viewhdc", "vhrc", "svchrid", "vadhrd", "vehdr", "evhrec", "vshdr", "varchder", "vmhdr", "varchDR", "vhldr", "vadhstr", "svhadr", "vhrDR", "vehrr", "vhdi", "vghdr", "vethdr", "svrhDR", "vbhrid", " vghdr", "svhder", "vhlrd", "vhrdc", "vihrd", "svchdr", "vphdr", " vghder", "viewhrDR", "vhradr", "vhrrid", " vshdr", "vchdr", "vbhder", " vphder", "vhstr", "vhddr", "vhld", " vghrid", "evbhmt", "vadhdr", "viewhrdc", "varchhr", "viewhrvd", "vithdr", "vahDR", "vhostdr", "vbhDR", "vvrid", "vohrid", "ghrrd", "vihdr", "vmhldr", "vshDR", "vohDR", "vvadr", "vhrrt", "vadhrec", "vhrder", "ghder", "vhadr", "vhostrd", "viewhrt", "vhrvd", "vethhr", "vhrbr", "vshrr", "svhrc", "evhDR", "vihder", "vhDR", "vadhDR", "svhbr", "vohder", "svchder", "viewhgr", "vbhdi", "vphder", "vhdder", "ghrder", " vshhr", "vchrc", "vahrid", "vhrr", "svhrrid", "evhmt", "svhradr", "vrhrr", "vbhrec", "viewhdr", "evbhDR", "vohrc", "vghrid", "svhrid", "vhbr", "vhostder", "vbhrt", "ghstr", "vehder", "vehDR", "vhvd"], "isip4": ["isIP8", "isep2", "iip8", "isipfour", "isepfour", "isidfour", "isid2", "iep44", "iipfour", "isp44", "isip2", "isIP6", "isip8", "iepfour", "isp6", "isep6", " isid4", " isipfour", "issid4", "issip6", "isep4", "iip4", " isid6", "isp8", "issid44", "isid44", "issip8", "isid4", " isip2", "isIP4", "isep8", "ispfour", "iep4", " isid2", "iep8", "isid6", "issip4", "isp4", "isid8", "isp2", "isep44", "iip44", "issip44", "issid8", " isidfour", "issid6", "isip44", "isIP44"], "isip6": ["issepsix", "isp3", "isi16", " isid3", "isip3", "issep12", "isql16", "isepsix", "isip16", " isid8", "isid16", "isql46", "isi6", "isip8", "isip46", "isp6", "isep6", "issipsix", " isid16", " isid6", "isql12", "issip12", "isqlsix", "issip6", "isp16", "isp8", "isi46", "isep12", "issip8", "isid3", "isep8", " isip3", "issep6", "isip12", "isid6", "isaf6", "isaf3", " isip16", "isaf16", "isi8", "isaf8", "isisix", "isipsix", "isql6", "isid8", " isid46", "issep8", " isip8", "isi12", "isql8", "isid46", " isip46"], "istcp": ["istpp", "irstcp", "istpc", "xtip", "pectp", "stcp", "stpe", "istmp", "irstp", "xtcp", "istep", "istp", "irstpc", "astpc", "irstpp", "irstmp", "ismip", "xtep", "pectpp", "astp", "astpp", "xtmp", "astcp", "distcp", "istip", "stmp", "ismmp", "ismcp", "distip", "stp", "pectpc", "pectcp", "distmp", "irstpe", "istpe", "astpe", "ismep", "distep", "astmp"], "isudp": ["isadhp", "isugpt", "issoodp", "isudl", "publ", "pudcp", "asubps", "isudsps", "isubcp", "isudsm", "isodcp", "isoodc", "asudm", "issoodpe", "isubc", "isugpe", "isubp", "isoodpt", "isudb", "isudps", "isadhpt", "pubc", "pudc", "asubm", "isugp", "isadhc", "pudl", "isuffb", "isubps", "pubp", "asudps", "isugc", "isuffps", "asudp", "pubcp", "isudm", "isodl", "isodp", "isubb", "isuffm", "isadhpe", "issoodpt", "issudpt", "asubb", "isubl", "isubm", "isudsb", "isudsp", "asubp", "issudpe", "isoodpe", "isudc", "isoodp", "pudp", "isudcp", "issudc", "issudp", "isudpe", "issoodc", "isadhcp", "asudb", "isadhl", "isudpt", "isuffp", "isodc"], "data": ["base", "missing", "name", "ata", "buffer", "li", "da", "dd", "lp", "a", "image", "ui", "new", "d", "di", "ad", "aa", "field", "id", "parent", "buf", "ada", "batch", "i", "next", "in", "body", "style", "dt", "index", "raw", "pad", "result", "alpha", "p", "block", "start", "zero", "input", "length", "f", "size", "DATA", "padding", "bytes", "valid", "addr", "val", "dat", "Data", "response", " DATA"], "len": ["pl", "fun", "name", "li", "split", "lp", "ni", "Len", "n", "alt", "lf", "ln", "sl", "sp", "bin", "fn", "end", "span", "pre", "bl", "lim", "pos", "dy", "nt", "err", "str", "lon", "l", "ind", "fin", "length", "size", " length", "f", "la", "el", "en", "seq", "lit", "line", "gen", "val", "count", "lo", "limit", "ann", "dat", "part", "db", "mem"]}}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574, "substitutes": {"errp": ["erc", " errps", "excp", "excc", "errps", "erps", "errpb", "errc", "erpb", " errpb", "excps", "excpb", "erp", " errc"], "list": ["call", "base", "see", "cli", "array", "queue", "cl", "new", "data", "LIST", "out", "cat", "chain", "record", "parent", "client", "arr", "member", "batch", "i", "bl", "detail", "code", "entry", "coll", "sync", "cont", "result", "l", "block", "e", "diff", "lc", "set", "object", "join", "obj", "comment", "lists", "card", "collection", "listed", "count", "List", "load", "table"]}}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n\n                         unsigned int c, const unsigned int *div_blocks,\n\n                         unsigned int *js_blocks)\n\n{\n\n    ALSSpecificConfig *sconf = &ctx->sconf;\n\n    unsigned int offset = 0;\n\n    unsigned int b;\n\n    ALSBlockData bd[2] = { { 0 } };\n\n\n\n    bd[0].ra_block         = ra_frame;\n\n    bd[0].const_block      = ctx->const_block;\n\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[0].opt_order        = ctx->opt_order;\n\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n\n    bd[0].use_ltp          = ctx->use_ltp;\n\n    bd[0].ltp_lag          = ctx->ltp_lag;\n\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[0].quant_cof        = ctx->quant_cof[0];\n\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[0].js_blocks        = *js_blocks;\n\n\n\n    bd[1].ra_block         = ra_frame;\n\n    bd[1].const_block      = ctx->const_block;\n\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[1].opt_order        = ctx->opt_order;\n\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n\n    bd[1].use_ltp          = ctx->use_ltp;\n\n    bd[1].ltp_lag          = ctx->ltp_lag;\n\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[1].quant_cof        = ctx->quant_cof[0];\n\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[1].js_blocks        = *(js_blocks + 1);\n\n\n\n    // decode all blocks\n\n    for (b = 0; b < ctx->num_blocks; b++) {\n\n        unsigned int s;\n\n\n\n        bd[0].block_length = div_blocks[b];\n\n        bd[1].block_length = div_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n", "idx": 585, "substitutes": {"ctx": ["sys", "cm", "cms", "cli", "cam", "cs", "act", "cal", "kb", "hw", "conn", "context", "anc", "cc", "cpp", "Context", "gru", "loc", "ck", "nc", "bc", "tc", "fn", "client", "cus", "concept", "cas", "component", "kt", "tx", "cb", "kw", "utils", "config", "pkg", "cu", "cv", "xc", "css", "setup", "lc", "cn", "sq", "ca", "wcs", "sc", "ctrl", "std", "cmd", "vc", "git", "ku", "cca", "qa", "cp", "cmp", "cf", "conv", "support", "ci", "cfg", "sci", "rc"], "ra_frame": ["ra_slice", "ra_boot", "ra_frames", "ra_flow", " ra_layout", "la_flow", "dra_frames", "la_scale", "ra_scale", "dra_slice", "dra_frame", " ra_frames", "la_frame", "ra_layout", "la_frames", "dra_boot"], "c": ["fc", "cm", "cms", "cs", "cc", "mc", "d", "ct", "nc", "bc", "ac", "cr", "ch", "C", "dc", "xc", "e", "lc", "cn", "ca", "sc", "cd", "pc", "cp", "cf", "ci", "rc"], "div_blocks": ["ra_bars", "js1blocks", "js_groups", "js_rows", "ra_groups", "js_bars", "ra_rows", "ra_blocks", "js1rows", "js1bars", "js1groups"], "js_blocks": ["cs_breaks", "js___blocks", "js___items", " js_items", " js_rooms", "js_rooms", "cs_block", "js67blocks", "jsessblocks", "jsESSframes", "js_breaks", "js___bands", "js5bags", "js_bags", "jsESSbags", "cs_blocks", "cs_rooms", "jsessrooms", "js5rooms", "js_frames", " js_block", "js67items", "jsESSblock", "js5blocks", "js_bands", "div_checks", "js___bys", "jsenchecks", "div_block", "jsenblocks", " js_bags", "jsenlimits", "js_block", " js_bys", "js5block", "jsessbreaks", "jsenblock", "js67bands", "div_limits", "js67bys", " js_frames", "js_bys", "js_checks", "jsessblock", "jsESSblocks", "js_items", " js_bands", "js_limits"], "sconf": ["scfg", "gscon", " sconfig", "gconf", "paff", "Scfg", "pdef", "pconf", "scon", "pcfg", "sdef", "pcon", "pConf", "gsconfig", "Sconf", "pconfig", "sConf", " sdef", "Saff", "gcfg", "gsconf", "saff", "gaff", "gsdef", "SConf", " scon", "sconfig", "gConf"], "b": ["base", "a", "sb", "lb", "eb", "r", "B", "d", "n", "bc", "k", "buf", "batch", "i", "j", "rb", "m", "body", "cb", "bf", "h", "l", "block", "p", "beta", "e", "nb", "f", "bg", "bb", "v", "bp", "fb", "bs", "db"], "bd": ["ff", "fd", "ld", "da", "bh", "kb", "dd", "pd", "bn", "ud", "sd", "sb", "dh", "bm", "BB", "ke", "wk", "bo", "d", "ad", "db", "dl", "fl", "bc", "sh", "th", "oda", "boot", "de", "cdn", "bl", "dk", " BD", "ok", "cb", "df", "dt", "md", "ds", "kell", "bf", "dc", "block", "bot", "nb", "hd", "wb", "gd", "dm", "gb", "cd", "bt", "gt", "dj", "wd", "cmd", "note", "bb", "ande", "fb", "od", "vd", "td", "nd", "board", "BT", "BD", " cd"]}}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599, "substitutes": {"argc": ["Argv", "argn", "argumentv", "argumentf", "agv", "confign", "configC", "catc", "catn", "configv", " argC", "arglc", "Argc", "agp", "Argn", "catp", " argn", "argumentc", "agc", "argumentp", " arglc", "agf", "ArgC", "argumentlc", " argf", "argC", " argp", "argumentn", "configc", "argf", "argp", "catlc"], "argv": ["Argv", "argumentv", "parf", "argumentf", "agv", "Argvs", "parc", " argl", "ArgV", " argb", "Argb", "Argc", "argsV", "agp", "argV", "agvs", "parv", " argvs", "argsp", "agver", "parvs", "Argf", "agc", "argumentp", "argl", "argumentl", "agf", "argver", "Argl", " argf", "argsv", " argV", " argver", "argb", "Argp", "argsf", " argp", "argsc", "argvs", "argsvs", "argf", "argsver", "argsb", "argp"], "t1": [" t0", "c3", "f1", " t8", "T2", "f2", "T0", "f3", "t0", "c1", "T3", "t8", "f0", "T8", "v2", "t3", "v1", "T1", "c0", "c2", "v0", "v8"], "t2": ["int5", "Ttwo", "t4", "a0", "p4", "T2", "int1", "p1", "temp4", "ttwo", "T0", "int0", "T5", "temptwo", "t0", "a2", "t5", "temp1", "ptwo", "T4", "a1", "int2", "p2", "temp2", "T1", "a5"], "c": ["cs", "channel", "cc", "mc", "r", "d", "n", "ct", "cat", "nc", "cy", "con", "k", "enc", "i", "ac", "m", "code", "cb", "cr", "z", "ch", "C", "ec", "orc", "dc", "ce", "ind", "p", "l", "xc", "e", "lc", "f", "col", "cn", "sc", "cd", "cmd", "comment", "v", "cit", "b", "t", "cf", "ci", "rc"], "cnt": ["icret", "rcct", "rcant", "cant", " cant", "pnt", "rcnt", "Cnc", "Cret", "icount", "Cno", " cret", "cpt", " cct", " cno", "ecount", "rcNT", "ecnt", " cNT", "acount", "cret", "CNT", "acNT", " cnc", "Cpt", "pret", "pount", "Cct", "icnt", "Cant", "icct", "rcount", "pNT", "cno", "cNT", "ecct", "cct", " cpt", "ecno", "acnt", "Cnt", "Count", "rcnc", "rcpt", "ecret", "cnc", "acno"], "buf": ["ff", "fd", "buffer", "ctx", "bh", "bag", "Buff", "context", "bo", "queue", "fw", "data", "window", "loc", "bc", "buff", "cur", "parent", "tmp", "cas", "ha", "batch", "output", "pos", "rb", "fp", "box", "aka", "cb", "coll", "err", "pool", "config", "bf", "runner", "func", "home", "result", "pkg", "block", "cv", "vec", "Buffer", "wb", "bd", "br", "cache", "cmd", "alloc", "bg", "seq", "b", "fb", "cmp", "cf", "uf", "socket", "img", "msg", "que", "fi", "uc", "rc", "port"], "offset": ["active", "url", "empty", "index", "pointer", "address", "alpha", "shift", "set", "reset", "seq", "optional", "af", "location", "limit", "start", "option", "image", "elta", "align", "position", "slot", "type", "format", "id", "parent", "end", "off", "gap", "api", "layout", "ptr", "aff", "length", "unc", "origin", "layer", "base", "skip", "data", "loc", "info", "slice", "et", "order", "len", "size", "ref", "attr", "o", "prefix", "error", "online", "timeout", "total", "append", "olerance", "array", "alias", "area", "operation", "num", "pos", "entry", "sync", "nt", "attribute", "number", "style", "config", "zero", "amount", "range", "padding", "Offset", "addr", "part", "ace"], "count": ["allow", "key", "large", "queue", "current", "n", "weight", "empty", "code", "partial", "index", "f", "child", "comment", "sum", "collection", "limit", "start", "name", "type", "id", "found", "parent", "end", "batch", "max", "p", "length", "patch", "text", "catch", "session", "val", "base", "counter", "complete", "more", "multiple", "cat", "loop", "pattern", "last", "order", "len", "size", "ref", "cache", "error", "low", "list", "match", "call", "total", "now", "num", "coll", "nt", "number", "bug", "col", "amount", "b", "depth", "full", "Count", "part"], "optind": ["octnd", "OptInd", "propnd", "optimind", "opinc", "Optii", "parentInd", "octInd", "propInd", "propend", "Optinc", "optimInd", "octint", "opend", "optii", "optinc", "optend", "Optind", " optnd", "optimnd", "parentend", "opInd", " optinc", "propind", "opint", "octind", "optnd", "optionind", "optionii", "optioninc", "opind", "optInd", "parentind", "Optnd", "optionnd", "opnd", " optInd", "optionint", "optint", "optiminc", " optii", "optimend", "optionend", "optionInd", "parentinc"]}}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 657, "substitutes": {"avctx": ["AVctx", "aircu", "aviacdn", "aviacontext", " avqa", "afcmp", "afctx", "afcontext", "aviacf", "avqa", "aircf", "aviactx", " avcmp", "AVqa", "aircontext", "avcf", " avcontext", " avcf", "afctl", "axctl", "avcdn", "afqa", "axcontext", "AVctl", " avcu", "afcu", "afcdn", "afcf", "avctl", "avcontext", "avcmp", "axcmp", "avcu", "AVcdn", "AVcf", "AVcmp", "AVcontext", "axctx", "airctx"], "frame": ["flow", "layer", "series", "media", "buffer", "Frame", "interface", "sequence", "fram", "figure", "rame", "filename", "data", "audio", "position", "picture", "video", "model", "hole", "package", "component", "frames", "photo", "code", "file", "slice", "document", "source", "Image", "function", "feature", "block", "iframe", "state", "layout", "f", "message", "object", "node", "connection", "flower", "play", "plane", "ze", "module", "element", "line", "motion", "view", "zone", "game"], "image": ["layer", "media", "cm", "service", "ami", "application", "large", "audio", "memory", "ui", "mini", "url", "position", "picture", "type", "use", "video", "page", "im", "record", "initial", "model", "instance", "update", "i", "package", "language", "m", "photo", "code", "file", "network", "pixel", "attribute", "event", "slice", "document", "database", "source", "Image", "address", "feature", "eye", "jpg", "example", "man", "function", "age", "order", "size", "copy", "date", "message", "office", "object", "node", "connection", "um", "site", "module", "element", "manager", "img", "cover", "view", "edge", "shape", "import", "imi", "game"], "compno": ["cmpno", "relto", "componentnumber", "procyes", "colleno", "cmppo", "parentyes", "relNo", "ompnone", " compyes", "modno", "collno", "comnos", "propo", "collyes", "corn", "classnos", "condnos", "curno", "cyclenumber", "hopnon", "componentna", "cmpnone", "comno", "srceno", "compnumber", "propyes", " compyo", "hopnos", "codeno", "comNO", "condname", "procNO", "cmpbo", "componentnone", "cmpNO", "collto", "cmpnos", "curNo", "hoppo", "cmpnon", "comto", " compnos", "cmpyes", "curto", "condno", "cmpo", "componentyes", "componentNO", "componentnor", "hosto", "colNo", "hostno", "coryes", "compnon", "compnone", " comppo", "sourceo", "parentno", "compto", "comppo", "modbo", "compnor", "compyo", "componentname", "compn", "componentnos", " comppos", "collNo", "relo", "hopno", "compbo", " compNo", "critno", "acone", "compo", "compna", "hostbo", "colno", "procno", "compyes", "codeyes", "relname", "compnos", "coden", "comnone", "srcn", "comNo", "condNO", "colbo", "critna", "ompno", "porto", "collpos", "ompyes", "hostnone", "sourceone", "cmpnumber", "componentpo", "codeeno", "componentnon", "condyes", "componentyo", "corname", "srcno", "componento", "curyes", "sourcen", "parentNo", "modn", " compNO", "procnos", "ompNo", "acno", "critNO", "componentpos", "cyclebo", "srcyes", "portNO", "parentto", "propno", "compNo", "modNo", "comppos", "comn", "relno", "relyes", "propname", "condn", "corno", "comyo", "comyes", "critnone", "cycleno", "compeno", "hostNO", "compNO", "codeone", "cmpNo", "classnor", "hostna", "combo", "cmpnor", "componentbo", "acn", "sourceno", "colln", "componentno", "comname", "classno", "portbo", "aco", "classpo", "collnos", "compone", "coln", "portno", "codeo", "cycleNO", "compname"], "x": ["xa", "any", "q", "key", "column", "n", "px", "j", "dx", "ady", "code", "event", "index", "sw", "self", "f", "ax", "u", "en", "s", "on", "ex", "wx", "name", "cross", "xes", "time", "id", "k", "xy", "ya", "tx", "xs", "z", "work", "p", "e", "php", "v", "ix", "wa", "sex", "xxx", "one", "plus", "in", "pe", "data", "i", "lex", "xx", "content", "h", "c", "xc", "es", "ww", "fx", "el", "yx", "yl", "xml", "d", "ph", "na", "X", "xp", "ip", "l", "w", "b", "rx", "full", "view", "wy", "my", "xi"], "y": ["yi", "row", "q", "ye", "ii", "yl", "yo", "zy", "gy", "iy", "d", "n", "yr", "type", "id", "ry", "cy", "xy", "ny", "ya", "ty", "j", "i", "year", "py", "ady", "dy", "m", "yn", "ky", "z", "yy", "ey", "ch", "h", "c", "p", "l", "w", "vy", "f", "hop", "height", "col", "u", "yt", "hy", "o", "v", "b", "ay", "t", "Y", "oy", "sky", "ym", "sy"], "image_line": ["picture_cell", "image_size", "media_line", "video_lin", "image_look", "media_lin", " image_page", "imageFline", "imageFloc", "video_line", "image_code", "picture_lin", "imageFlines", " image_liner", "image_loc", "picture_line", "image_lin", " image_size", "video_code", " image_look", " image_lin", "picture_look", "image_lines", "image_liner", "image_block", "image_cell", " image_lines", "media_loc", "media_lines", "video_lines", "image_page", "imageFlin", " image_block"], "frame_index": ["fram_ini", "frame_i", "zonelexid", "zonelexline", "file_i", "frame_pointer", "frame_ini", "zone_key", "frame_position", "file_slice", "fram_slice", "file_index", "zone_line", "framelexindex", " frame_pointer", "zone_id", "zonelexindex", "frame_slice", " frame_position", "framelexid", "frame_key", "frame_Index", "fram_index", "framelexline", "frame_id", "framelexkey", "frame_line", "zone_index", "fram_pointer", "zonelexkey", "file_Index"], "frame_ptr": [" imageacptr", " frame_tr", "frameacpointers", "frame_tr", " imageactr", "frame_rect", "frameactr", " image_pointer", "frame_pointer", "frameacptr", " frame_rect", " image_ptr", " image_tr", " image_pointers", " frame_pointer", " imageacpointer", " imageacpointers", "frameacpointer", "frame_pointers"]}}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666, "substitutes": {"stream": ["wheel", "row", "queue", "current", "url", "sl", "client", "roll", "pipe", "forward", "event", "ream", "control", "ack", "down", "sw", "track", "f", "child", "message", "object", "round", "single", "path", "board", "port", "flow", "group", "host", "form", "image", "cloud", "model", "request", "resource", "length", "web", "transform", "wave", "load", "input", "user", "channel", "loop", "filter", "live", "document", "pool", "raw", "food", "content", "design", "node", "cf", "hook", "uc", "Stream", "null", "server", "follow", "header", "output", "draft", "sync", "coll", "source", "config", "reader", "draw", "pull", "thread", "fuel", "clean", "full", "view", "table", "upload"], "feed": ["allow", "row", "large", "fed", "queue", "sl", "wait", "next", "roll", "forward", "event", "index", "control", "ack", "f", "child", "sc", "comment", "cell", "valid", "af", "board", "acc", "accept", "flow", "read", "gram", "zip", "host", "form", "image", "scroll", "id", "pass", "model", "update", "write", "request", "post", "feeding", "layout", "length", "handler", "driver", "link", "load", "import", "keep", "input", "gh", "Feed", "fast", "build", "channel", "hub", "report", "page", "insert", "loop", "search", "cr", "raw", "food", "design", "rss", "cf", "close", "fork", "gen", "low", "hook", "cook", "uc", "inf", "service", "check", "def", "ga", "throw", "follow", "grow", "seed", "gg", "draft", "entry", "bug", "source", "config", "reader", "zero", "draw", "pull", "fuel", "full", "view"], "i": ["q", "j", "g", "ti", "index", "x", "hi", "f", "u", "ori", "vi", "uri", "fi", "start", "abi", "zi", "pi", "ui", "image", "id", "mi", "k", "iu", "y", "ri", "z", "ie", "p", "e", "lc", "isi", "v", "qi", "ix", "t", "io", "root", "in", "li", "a", "ni", "ii", "chi", "data", "r", "I", "di", "is", "m", "inner", "info", "slice", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "ei", "oi", "d", "it", "iii", "eni", "none", "multi", "ai", "ip", "l", "block", "reader", "bi", "min", "b", "ci", "part", "xi"], "fd": ["fc", "ff", "find", "form", "fa", "d", "ct", "di", "aa", "ma", "fff", "fn", "found", "file", "flows", "fr", "cond", "feat", "fe", "iff", "f", "ffff", " fid", "handler", "fm", "ci"], "s": ["server", "js", "service", "spec", "qs", "ts", "rs", "a", "sb", "n", "aws", "sl", "search", "y", "g", "space", "m", "ses", "ls", "sync", "xs", "sv", "storage", "sets", "ds", "settings", "ps", "gs", "source", "ns", "l", "c", "p", "sw", "services", "e", "f", "es", "sq", "u", "o", "v", "stats", "b", "su", "S", "t", "session", "single", "site", "rss", "hs", "se", "fs", "si", "ssl"], "sf": ["fc", "tf", "vp", "fs", "sd", "sb", "xf", "fy", "fw", "cpp", "uci", "lf", "dl", "sl", "fl", "rf", "ef", "fp", "df", "fr", "ft", "sv", "bf", "fe", "fg", "sw", "aff", "f", "sq", "fx", "eph", "fm", "fee", "fb", "nw", "su", "SF", "cf", "rss", "sm", "uf", "fi", "si", "ssl"], "ss": ["cs", "sch", "ass", "rs", "sd", "sb", "pg", "sp", "sl", "sh", "ssh", "ses", "fts", "ls", "sync", "ys", "xs", "sv", "ds", "SS", "WS", "ess", "xx", "ns", "ps", "css", "vs", "sw", "oss", "f", "es", "hess", "sq", "sc", "sys", "uss", "sr", "iss", "rss", "su", "serv", "cf", "os", "bs", "se", "fs", "si", "ssl"], "ccf": ["cff", "csv", "CCb", "acf", "cfrf", "ccrf", "CCfs", "ecb", "CCs", "ecfs", "cfv", "csfs", "acfs", "ecs", "ucb", "csf", "ucs", "cffs", "CCf", "acv", "acrf", "csrf", "ucfs", "ucf", "ccb", "ecf", "ccv", "ccfs"], "ccs": ["csp", "cff", "csv", "rcl", "ccl", "ctp", "accf", "cts", "rcc", "cfs", "cfv", "ccp", "css", "accl", "csf", "ucs", "ccc", "cfp", "accc", "rcf", "ucc", "accs", "ucf", "ctf", "ctv", "ucl", "rcs", "ccv"]}}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669, "substitutes": {"env": ["eu", "vt", "txt", "nc", "here", "enc", "inet", "args", "event", "ec", "eve", "cv", "vs", "dev", "jp", "viron", "en", "qa", "engine", "rt", "energy", "ext", "target", "stat", "context", "sb", "esi", "her", "equ", "ea", "assets", "end", "cdn", "eng", "cot", "e", "core", "conf", "org", "forge", "chal", "eur", "v", "ev", "site", "init", "np", "ctx", "atten", "enable", "osc", "esm", "environment", "global", "ne", "gear", "enh", "info", "exc", "usr", "anne", "et", "loader", "obj", "nw", "req", "img", "qt", "net", "oa", "stage", "vm", "server", "fen", "conn", "pg", "dict", "priv", "pos", "eni", "erv", "entry", "ah", "config", "dc", "Environment", "uv", "dat", "que", "console", "export", "db", "ench"], "intno": ["intname", " intcomp", "uinteno", "pointname", "idno", "pointnum", " intNO", "INTno", "indnumber", "extnum", "incnumber", "INTinfo", "seqcho", "idnumber", "uintcho", "extcomp", " intname", "pointinfo", "intnumber", "pointNO", "uintnumber", " intnum", "idname", "inteno", "pointeno", "uintno", "seqeno", "extNO", " intinfo", "INTNO", "intcho", "indnos", " intnos", "pointcho", "incNO", "idnum", "incnos", "inccomp", "extnos", " intnumber", "pointnumber", "extno", "pointnos", "Intno", "incno", "INTnum", "Intnum", "intcomp", "extnumber", "intNO", "Intnumber", "pointno", "indNO", "indnum", "seqnumber", "intnos", "seqno", "incnum", "intinfo", "intnum", "indno"], "is_int": ["isFnt", " is_intel", "is7int", "as_inter", "as_oct", "as_integer", "as_int", "is_integer", "is_intel", "is_oct", "isFind", "isFhw", "is_nt", "is_ind", "is7ind", " is_ind", " is_nt", "isFint", "is7nt", "as_nt", "is7intel", "is_inter"], "error_code": [" error_cod", " error_message", "erroracmessage", "erroraccode", "erroraccodes", "erroraccod", " error_codes", "error_codes", "error_cod", "error_message"], "next_eip": ["next_eeof", "next_ceof", "next_eeip", "next_peips", "next_eips", "next_seep", "next_eep", "next_eeep", "next_ceip", "next_ceips", "next_seip", "next_peep", "next_peof", "next_peip", "next_eIP", "next_seIP", "next_peIP", "next_seips", "next_ceIP", "next_eof", "next_eeips", "next_eeIP"], "is_hw": ["is_ht", "as_hw", "is_wire", "as_ht", "as_fw", " is_ht", " is_wire", "as_rt", "is_fw", "is_rt", " is_fw"], "dt": ["dr", "cm", "np", "tn", "nat", "tf", "ctx", "mt", "dn", "target", "elt", "tg", "vt", "dh", "txt", "wt", "ct", "tk", "di", "ea", "ta", "tc", "tmp", "deb", "tp", "kt", "fp", "ds", "dq", "dc", "ut", "e", "dm", "cn", "ctr", "jp", "bt", "tt", "driver", "tm", "qa", "tz", "t", "DT", "td", "rt", "dat", "qt", "cfg", "db"], "ptr": ["dr", "rot", "base", "pend", "src", "ctx", "ext", "inter", "tip", " pointer", "prot", "loc", "eger", "pair", "next", "adr", "pos", "dy", "proc", "code", "pointers", "info", "fp", "plug", "fr", "slice", "index", "pointer", "tr", "fe", "address", "pad", "Ptr", "p", "shift", "len", "length", "ref", "br", "attr", "ctr", "patch", "jp", "obj", "inst", "req", "addr", "rt", "td", "pt", "part", "start", "rc", "port"], "type": ["unit", "test", "null", "name", "version", "time", "key", "ype", "loc", "class", "ping", "kind", "id", "like", "op", "ty", "comp", "pre", "py", "y", "pos", "none", "code", "Type", "style", " typ", "ip", "block", "p", "state", "size", "ref", "attr", "set", "value", "comment", "rel", "o", "action", "t", "types", "rule", "var", "link", "error", "TYPE", "val", "part", "shape", "typ", "port"], "dpl": ["csl", "dpe", "dplug", " dPL", "ccl", "dcbl", "pPL", "pcl", "cbl", "ldopl", " dbl", "ldbl", "pbl", " dopl", "ldpe", "dPL", "dcplug", "dspl", "dbl", "pplug", "dspe", " dpe", "ldpl", "dsl", "dcPL", "dsbl", " dcl", "dcpl", "dcl", " dsl", "dopl", "ppl", " dplug", "psl", "dsopl"], "selector": ["lectori", "SELECTory", "SELECTion", "accessor", "Selectori", " selectory", "lector", " selecto", "Selection", " selection", "Selector", "lecto", "SELECTori", "accesso", "Selectory", "selectori", "selection", "SELECTor", "selecto", "selectory", " selectori", "lection", "accessori", "accession"], "cpl": ["csl", " cPL", "dpe", "tpl", "tpp", " cfl", "cPL", "ccompl", "ccl", "cpp", "cbl", "tcompl", "cpe", " cbl", "pbl", " ccl", "dcompl", " ccompl", "ppe", "cfl", "CPL", "dPL", "dpp", "Cpl", "dbl", " csl", "dsl", "tPL", "Cfl", " cpp", "dcl", "ppl", " cpe", "psl", "Ccl", "dfl"], "ist": ["ism", "ists", "rest", "ext", "esi", "sp", "op", "aps", "sync", "push", "slice", "st", "ack", "ind", "shift", "et", "reset", "attr", "ress", "asm", "rss", "inst", "slave", "ast", "ace", "dist", "ush", "est"], "has_error_code": ["has_ror_code", "has_error_codes", "has_error_once", "has_error_call", "has_error_coded", "has_erroripcode", "has_erroraycount", "has_erroriponce", "has_error_error", "has_errorayerror", "has_ror_count", "has_error_count", "has_erroripcount", "has_ror_call", "has_erroraycode", "has_erroraycodes", "has_ror_error", "has_ror_codes", "has_erroripcoded"], "new_stack": ["new_addr", " new_scope", "newamstack", "new_depth", "newamaddr", "newamdepth", " new_addr", " new_depth", "newamscope", "new_scope"], "e1": ["eone", "ee2", "E2", "Eone", "ee4", " eall", "pall", "en3", "p4", "en4", "p1", "ea64", "econe", "ea1", "E3", "ec4", "ea2", " e4", "e4", "ee64", "e64", "ec1", " eone", "ea3", "eaone", "Eall", "E1", "E4", "p2", "enone", "eeone", "eall", "ee3", " e64", "en1", "ec3", "ee1"], "e2": ["e20", "ee2", "E2", "i1", " e16", "i16", "ee4", "ee200", "p3", "eTwo", " e200", "p200", "ec02", " eTwo", "p4", " e62", "p1", "e02", "cTwo", "iTwo", "d4", " e02", "e200", "E3", "c20", "ec4", "c1", "ec2", " e4", "e4", "E62", "e62", "d1", "c4", "ec1", "p62", "c16", "i2", "c2", "ee02", "E1", "p2", "E4", "d2", "d20", "E02", " e20", "e16", "ec3", "ee1"], "e3": ["ec5", "E5", " e15", " eiii", "ec15", "e15", " e53", "e6", "E15", "E53", " e5", "E6", "ea1", "E3", "iiii", "e5", " e4", "e03", "e4", "ea03", "i3", "E03", "ec1", "ea3", "ea53", " e03", "i4", "E4", "eiii", "e53", "Eiii", " e6", "ec3", "E1", "i6"], "ss": ["ff", "skip", "rs", "rw", "speed", "eps", "sp", "pos", "ls", "eff", "sync", "ps", "au", "css", "sw", "oss", "sq", "sc", "ress", "s", "tz", "pp", "socket", "slave", "ace", "si", "ssl"], "old_eip": ["old_ceep", "old_peip", "old_eeIP", "old_Eips", "old_zeIP", "old_eeep", "old_Epp", "old_eid", "old_eeip", "old_Eip", "old_seIP", "old_peid", "old_zeip", "old_peipped", "old_eips", "old_sepp", "old_seep", "old_cepp", "old_epp", "old_eeips", "old_pepp", "old_oeipped", "old_eeipped", "old_eIP", "old_eeid", "old_oeIP", "old_oeid", "old_peep", "old_peips", "old_zepp", "old_ceip", "old_oeip", "old_seip", "old_eepp", "old_ceIP", "old_zeep", "old_eep", "old_eipped", "old_peIP", "old_Eep"], "esp": ["sg", "sup", "spec", "sb", "speed", "clock", "sp", "pos", "nil", "sync", "push", "slice", "cr", "sel", "css", "sq", "ress", "resp", "rss", "cp", "selection", "iter", "slave", "ace", "pp", "ice"], "offset": ["no", "skip", "adjust", "oe", "alias", "esi", "data", "loc", "align", "position", "slot", "oid", "parent", "end", "seed", "pos", "entry", "slice", "index", "address", "p", "shift", "et", "start", "size", "reset", "len", "length", "padding", "o", "point", "Offset", "error", "addr", "count", "part", "timeout", "port"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n", "idx": 674, "substitutes": {"src": ["fc", "scene", "sup", "ctx", "http", "spec", "sb", "desc", "ruby", "data", "url", "image", "loc", "sl", "cur", "bin", "gz", "buf", "cdn", "rb", "secure", "dest", "sync", "cb", "slice", "source", "feat", "config", "st", "sel", "c", "inf", "text", "sq", "sc", "gb", "sec", "kk", "sr", "iv", "b", "inst", "req", "transform", "img", "support", "sci", "start", "rect", "input", "dist", "rc", "ssl"], "dst": ["ded2", "dusts", "lsts", "dsp", "cdsts", "dset", "bsts", "bsp", "ddst", " dfe", "sdbl", "godfe", "ddsts", "dust", "dsts", "ddconst", "sd2", " dsp", "ddest", "godstart", "hdfe", " dstart", " dbl", "sdste", " dconst", " dset", "dest", "sst", "cdst", "dconst", "dubl", " dste", "sdst", "hdstart", " dsts", "best", "sdest", "dfe", "dbl", "lst", " dest", "godset", "dste", "ddbl", " d2", "dedbl", "cdest", "bst", "hdst", "dedst", "dstart", "hdset", "d2", "duconst", "sest", "cdsp", "dedste", " ddest", "godst", "lest", "ldest", "ssts"], "num_pixels": ["num_nixels", "num2pixels", "num2pix", "num_ports", "num2pixel", "num2ports", "num_tipes", "num_Pips", "num_pixel", "num_cix", "num2cixels", "num2cixel", "num_tips", "num_cixels", "num_tixels", "num_nix", "num_pipes", "num2corts", "num2cix", "num_cips", "num_Pix", "num_Pipes", "num_Ports", "num_norts", "num_pix", "num_cipes", "num_pips", "num_Pannels", "num_nixel", "num_Pixels", "num_cannels", "num_tannels", "num_cixel", "num_Pixel", "num_pannels", "num_corts"], "palette": ["valettes", "holette", "fz", "Palette", " paloton", "alette", "valette", "valge", "Palignment", "fette", "allette", "paloton", "pixelette", "holoton", "palignment", "palge", " palue", "Pallette", "palne", "Paloton", "fge", " palettes", " pallette", "alz", "palz", "gamlette", "gamue", "hollette", "alge", "palue", "Palue", " palotype", "palotype", "pixelettes", "Palne", "pixellette", "gamette", " palne", "alotype", "alettes", "fettes", "holne", "pallette", "gamignment", "valz", "pixelotype", " palignment", "palettes"], "i": ["js", "li", "gi", "abi", "key", "a", "ii", "zi", "ji", "data", "pi", "ui", "oi", "image", "d", "I", "di", "page", "n", "field", "is", "id", "it", "iu", "api", "j", "y", "iii", "m", "ri", "eni", "info", "ti", "slice", "multi", "index", "source", "ai", "ie", "x", "l", "c", "p", "phi", "bi", "hi", "e", "f", "u", "ip", "gui", "jp", "o", "v", "qi", "b", "t", "ix", "uri", "ci", "io", "mu", "start", "si", "xi"]}}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    /* check for any coded coefficients in this codeblock */\n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    /* TODO: context pointer? */\n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}\n", "idx": 677, "substitutes": {"s": ["sg", "service", "cs", "sup", "ss", "spec", "sa", "a", "rs", "sb", "r", "d", "n", "is", "sl", "bis", "g", "j", "options", "m", "ses", "ls", "sf", "ds", "sets", "gs", "ns", "l", "p", "services", "w", "e", "self", "f", "es", "sys", "sq", "sc", "u", "sec", "o", "v", "su", "S", "t", "session", "ks", "os", "bs", "si", "sym"], "b": ["ob", "base", "orb", "this", "buffer", "bh", "ba", "kb", "a", "be", "sb", "lb", "ab", "mb", "ib", "B", "d", "eb", "n", "r", "bc", "buff", "bin", "k", "pb", "api", "i", "g", "j", "rb", "body", "cb", "bf", "h", "l", "p", "bi", "w", "e", "nb", "f", "wb", "bd", "self", "u", "machine", "bt", "obj", "bg", "o", "bb", "v", "lib", "bp", "fb", "t", "abb", "bar", "bs", "usb", "part", "emb", "db", "xb"], "gb": ["rg", "ctx", "gram", "ud", "kb", "ga", "cc", "sb", "mc", "gc", "bm", "ub", "hub", "gom", "gy", "mb", "gnu", "bc", "bin", "gate", "GB", "gin", "g", "gg", "rb", "gm", "m", "cb", "storage", "cod", "gam", "gs", "bf", "hm", "cu", "nb", "bb", "pc", "cca", "abb", "usb", "ci", "cfg", "gp", "gd", "db"], "c": ["fc", "cm", "cs", "ctx", "cc", "mc", "r", "cz", "d", "co", "nc", "bc", "con", "k", "g", "ac", "m", "code", "cb", "cr", "ch", "cod", "C", "ec", "dc", "ce", "cu", "l", "xc", "p", "e", "lc", "f", "unc", "cn", "ctrl", "u", "cmd", "vc", "pc", "cp", "cell", "cf", "ci", "uc", "rc"], "top": ["to", "level", "offset", "above", "target", "below", "upper", "tail", "high", "n", "position", "sp", "ny", "op", "first", "max", "j", "tp", "pos", "space", "lon", "bot", "p", "best", "pop", "len", "hop", "height", "front", "min", "up", "TOP", "padding", "t", "stop", "tops", "Top", "part", "start"], "bottom": ["base", "level", "row", "no", "below", "offset", "above", "both", "position", "margin", "boot", "op", "off", "max", "j", "dy", "style", "back", "st", "last", "Bottom", "step", "bot", "bound", "zero", "size", "height", "front", "lower", "min", "stop", "depth", "low", "good", "two", "start"], "blockcnt_one": ["blockcnc_1", "blockcntsone", "blockcntptwo", "blockcNT_two", "blockcnc_one", "blockcntstwo", "blockcnc_many", "blockcNT_One", "blockcntp1", "blockcnt_many", "blockcNT_many", "blockcNT_1", "blockcNT_one", "blockcntpmany", "blockcnc_two", "blockcntpone", "blockcnt_1", "blockcnts1", "blockcnt_One", "blockcntsmany", "blockcnt_two"], "is_arith": ["is_auritz", "is_irith", "is_grithmetic", "is_earyth", "is_aruth", "is_earuth", "is_iruth", "is_irth", "is_arinth", "is_grith", "is_earth", "is_irithmetic", "is_raruth", "is_irighth", "is_raritz", "is_laryth", "is_arth", "is_aurith", "is_iryth", "is_aritz", "is_rarith", "is_grinth", "is_grighth", "is_earitz", "is_arighth", "is_iritz", "is_aryth", "is_earith", "is_aurth", "is_earighth", "is_aurithmetic", "is_earinth", "is_larinth", "is_irinth", "is_larith", "is_larithmetic", "is_earithmetic", "is_rarth", "is_arithmetic"], "x": ["yx", "ctx", "q", "time", "key", "pe", "d", "n", "id", "px", "k", "xy", "gz", "num", "i", "g", "j", "dx", "in", "max", "code", "tx", "X", "xs", "z", "index", "xp", "xx", "step", "l", "p", "h", "work", "w", "e", "f", "ax", "height", "xc", "u", "ww", "min", "fx", "v", "xe", "ix", "t", "rx", "Y", "by", "val", "xxx", "on", "ex", "xi", "wx"], "y": ["yi", "yx", " Y", "asy", "key", "ye", "yl", "yo", "zy", "gy", "d", "n", "type", "ry", "cy", "xy", "ny", "ya", "ty", "i", "j", "py", "ady", "m", "dy", "yn", "z", "yy", "ey", "ch", "lon", "p", "l", "h", "w", "e", "vy", "f", "col", "u", "yt", "win", "o", "v", "ay", "t", "Y", "oy", "sky", "wy", "ym", "sy"], "zero_block": ["zero_byte", "twoaylock", "one_sync", "zerosbatch", "one_square", "zero_square", "empty_lock", "one_byte", "empty_batch", "two_lock", "zeroayblock", "zeroaynumber", "zero_sync", "zero_lock", "twoayblock", "two_block", "zeroaylock", "one_block", "zero_number", "empty_block", "one_lock", "zero_clock", "empty_clock", "zero_batch", "zeroslock", "twoaynumber", "two_number", "zerosclock", "zerosblock"], "qoffset": ["eqfactor", "qualfilter", "qupad", "sqaddress", "qualfactor", "querypad", "eqoff", "fstart", "querylimit", "bitfactor", " qfilter", "qerror", "ffactor", "eqlimit", "sqoff", "bitfilter", " qstart", "sqphase", "quphase", "qqpadding", "qualoffset", "qustart", "quoffset", "eqoffset", "bitoffset", "eqslot", "sqpadding", "eqpad", "qqaddress", " qphase", "qqoffset", "quaddress", "qstart", "qslot", "foffset", "queryfactor", "fphase", "qlimit", "biterror", "sqoffset", "qoff", "qulimit", "qqphase", "dqslot", "qpadding", "sqslot", "queryoffset", "qaddress", "dqlimit", "qfilter", "qphase", "qpad", "dqoff", "qualerror", "qupadding", "sqlimit", " qerror", "dqoffset", "qufactor"], "qfactor": ["eqlength", "qscale", "eqfactor", " qscale", "viewfilter", "quscale", "qualfactor", "qufac", "qqformat", "sqshift", "dqfilter", "quantsector", "qualphase", "quantshift", "quphase", "qqsector", "quantformat", "qufilter", " qlength", "qcount", "quantfactor", "viewfac", " qphase", "viewfactor", " qconst", "eqscale", "qshift", "qformat", "qsector", "qconst", "qlength", "qsf", "qualcount", "qualconst", "quconst", "qqshift", "dqscale", "viewscale", "sqfactor", " qcount", "qqfactor", "sqformat", "dqlength", "dqfactor", "eqsf", "qphase", "qfilter", "qfac", "dqfac", " qsf", "dqsf", "sqsector", "qucount", "qufactor"], "buf": ["fd", "buffer", "ctx", "bag", "Buff", "queue", "data", "brace", "uc", "ab", "header", "av", "callback", "buff", "bc", "cur", "pb", "tmp", "cas", "off", "batch", "rb", "proc", "fab", "fp", "box", "cb", "pool", "func", "config", "feed", "result", "pad", "cv", "Buffer", "vec", "xff", "wb", "bd", "br", "cache", "cap", "text", "la", "cmd", "alloc", "v", "bb", "bu", "bridge", "seq", "fb", "cf", "wa", "uf", "msg", "que", "fi", "board", "cast", "rc", "port"]}}
{"project": "FFmpeg", "commit_id": "d58a6d8537a6f34941973c5c3be93d484a4d62ed", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    FFV1Context *f = avctx->priv_data;\n\n    CABACContext * const c= &f->c;\n\n    AVFrame *pict = data;\n\n    const int width= f->width;\n\n    const int height= f->height;\n\n    AVFrame * const p= &f->picture;\n\n    int used_count= 0;\n\n\n\n    if(avctx->strict_std_compliance >= 0){\n\n        av_log(avctx, AV_LOG_ERROR, \"this codec is under development, files encoded with it wont be decodeable with future versions!!!\\n\"\n\n               \"use vstrict=-1 to use it anyway\\n\");\n\n        return -1;\n\n    }\n\n        \n\n    ff_init_cabac_encoder(c, buf, buf_size);\n\n    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);\n\n    c->lps_state[2] = 1;\n\n    c->lps_state[3] = 0;\n\n    \n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    \n\n    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){\n\n        put_cabac_bypass(c, 1);\n\n        p->key_frame= 1;\n\n        write_header(f);\n\n        clear_state(f);\n\n    }else{\n\n        put_cabac_bypass(c, 0);\n\n        p->key_frame= 0;\n\n    }\n\n\n\n    if(!f->ac){\n\n        used_count += put_cabac_terminate(c, 1);\n\n//printf(\"pos=%d\\n\", used_count);\n\n        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);\n\n    }\n\n    \n\n    if(f->colorspace==0){\n\n        const int chroma_width = -((-width )>>f->chroma_h_shift);\n\n        const int chroma_height= -((-height)>>f->chroma_v_shift);\n\n\n\n        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);\n\n\n\n        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);\n\n        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);\n\n    }else{\n\n        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);\n\n    }\n\n    emms_c();\n\n    \n\n    f->picture_number++;\n\n\n\n    if(f->ac){\n\n        return put_cabac_terminate(c, 1);\n\n    }else{\n\n        flush_put_bits(&f->pb); //nicer padding FIXME\n\n        return used_count + (put_bits_count(&f->pb)+7)/8;\n\n    }\n\n}\n", "idx": 683, "substitutes": {"avctx": ["camctx", "abcam", "afconfig", "aveconfig", "ajcf", "AVctx", "ajctx", "ablc", "avectx", "Avcb", "abcu", " avcb", "Avcc", "avconn", "afctx", "afcontext", "afcc", "avqa", "afcam", " avlc", "aveconn", "Avcontext", "ajqa", " avcc", "AVconn", "AVqa", "avcf", " avcontext", "Avctx", "avcomp", "AVconfig", "afqa", "afconn", "abctx", "camlc", "avcc", "afcu", "camcontext", "avcb", "camcu", "ajlc", "ajcomp", "afcf", "aflc", "avconfig", "abcomp", "avcontext", "abcontext", "afcomp", "avecontext", " avcam", "avcam", "AVcf", "avcu", "avlc", "AVcontext", "ajcontext", "afcb"], "buf": ["base", "ff", "fd", "src", "buffer", "ctx", "bag", "queue", "uc", "binary", "header", "bc", "buff", "pb", "num", "batch", "rb", "code", "fp", "box", "cb", "config", "cv", "xff", "vec", "wb", "len", "br", "cap", "length", "gb", "cmd", "alloc", "seq", "b", "fb", "uf", "img", "que", "map", "rc", "port"], "buf_size": ["buf_capacity", "board_ize", "bufncount", "buflexsize", "buf5speed", "buf2len", "buf2speed", "boardlexsend", "buf_count", "buflexize", "uf2len", "buf_ize", "buflexsend", "boardlexize", "buf5len", "uf2speed", "buf5size", "uf2count", "buf5count", "bufnsize", "uf2size", "buf2size", "board_send", "uf_size", "buf6speed", "buf6size", "bufncapacity", "buf6count", "board_size", " buf_count", "buf_len", "buf2count", "boardlexsize", " buf_capacity", "buf_send", "uf_count", "uf_len", "uf_speed", "buf6len", "buf_speed"], "data": ["media", "base", "buffer", "da", "channel", "def", "split", "a", "device", "image", "fa", "ui", "r", "window", "d", "memory", "align", "picture", "format", "buff", "empty", "bin", "parent", "sample", "frame", "na", "map", "next", "i", "batch", "first", "pos", "output", "proc", "code", "body", "index", "capt", "config", "feed", "pad", "fi", "block", "alpha", "start", "change", "draw", "cache", "la", "DATA", "v", "scale", "module", "img", "load", "dat", "Data", "board", "input", "rc"], "f": ["fo", "fc", "ff", "fd", "tf", "this", "fen", "flat", "xf", "fac", "fw", "form", "fa", "d", "n", "fl", "lf", "k", "rf", "F", "i", "j", "g", "ef", "y", "m", "fab", "sf", "fp", "file", "df", "fr", "info", "config", "fe", "bf", "feed", "function", "fi", "l", "h", "x", "e", "aff", "self", "ref", "w", "conf", "u", "fat", "of", "o", "v", "s", "fb", "b", "t", "cf", "af", "fs", "inf", "family"], "c": ["fc", "cm", "cam", "cs", "ctx", "q", "cc", "mc", "cl", "r", "d", "n", "co", "cat", "ct", "x", "cur", "cy", "con", "k", "client", "enc", "i", "g", "ac", "m", "cr", "z", "ch", "config", "C", "ec", "dc", "ce", "h", "l", "cu", "xc", "w", "e", "lc", "cv", "self", "cache", "sc", "ca", "u", "cn", "center", "vc", "o", "pc", "v", "s", "b", "cp", "icc", "cf", "t", "ci", "uc"], "pict": ["pl", "np", "cli", "cam", "ctx", "stat", "flat", "conn", "fw", "image", "fa", "ct", "picture", "prop", "buff", "cop", "fn", "pb", "proc", "fp", "info", "Pict", "capt", "feat", "ch", "config", "fig", "doc", "col", "fat", "gui", "obj", "qa", "cp", "pic", "img", "sci", "qt", "fi"], "p": ["pl", "np", "vp", "q", "lp", "a", "pe", "pi", "get", "n", "ap", "pg", "sp", "cop", "pb", "parent", "op", "api", "py", "i", "par", "po", "tp", "g", "m", "j", "pre", "fp", "P", "y", "ps", "post", "pa", "l", "pr", "h", "ip", "e", "per", "cache", "hp", "u", "jp", "up", "o", "pc", "v", "s", "cp", "b", "pic", "t", "pro", "part", "dp", "pp", "port"], "picture_number": ["image_counter", "image_number", "image_num", "picture_counter", "picture_no", "picture_num", "image_no"]}}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686, "substitutes": {"ret": ["match", "arg", "fun", "mt", "ext", "def", "key", "bit", "sb", "success", "data", "xt", "alt", "cat", "wrap", "id", "fit", "true", "rets", "code", "nt", "ft", "rev", "back", "feat", "Ret", "rc", "bf", "opt", "result", "fin", "f", "len", "flag", "ref", "gt", "value", "art", "afe", "round", "RET", "t", "error", "valid", "lit", "re", "reg", "val", "rt", "let", "part", "hard", "det", "res"]}}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707, "substitutes": {"opaque": ["opacity", " opque", "opaques", "ocacre", "ropxb", "ospaque", "ropacre", "opxb", "ospacre", "oconymous", "ocaque", "opacre", " opacity", "ropque", "ipxb", "ipaque", "ipque", "ospaques", "oponymous", "ipacity", "ropaques", "ropaque", "ropacity", "roponymous", " opxb", "osponymous", "opque", "ocaques"], "ret": ["rot", "match", "fun", "total", "att", "ext", "mt", "def", "hash", "Len", "success", "data", "url", "complete", "prot", "get", "alt", "bc", "id", "cur", "section", "ry", "rets", "num", "off", "rep", "nil", "code", "lt", "info", "ft", "nt", "rev", "reply", "feat", "Ret", "rc", "pub", "opt", "status", "result", "bot", "ut", "ptr", "length", "flag", "reset", "ref", "obj", "sec", "RET", "seq", "error", "sur", "al", "lit", "re", "addr", "val", "count", "rt", "reg", "det", "res", "mem"], "offset": ["rot", "base", "skip", "data", "url", "loc", "align", "position", "id", "timeout", "from", "fn", "end", "num", "off", "initial", "i", "pos", "output", "fp", "index", "pointer", "address", "shift", "et", "ptr", "size", "length", "set", "reset", "ref", "f", "origin", "obj", "range", "o", "prefix", "seq", "Offset", "error", "location", "af", "addr", "count", "part", "start"], "len": ["base", "fun", "name", "split", "elt", "conn", "Len", "data", "url", "loc", "n", "lif", "lf", "fl", "ln", "bin", "fn", "num", "enc", "pos", "lim", "file", "lt", "nt", "rev", "str", "lon", "l", "block", "fin", "length", "size", "ref", "el", "en", "seq", "bytes", "gen", "line", "val", "load", "count", "limit", "part", "all", "mem"], "acb": ["ocf", "aclb", "ancf", "achbb", "acf", "acba", "acl", "ancp", "ancbb", "ancj", "anck", "accb", "acp", "ucj", " acbe", "encbr", "ack", "ancbe", "ancsb", "macp", "accl", "aclv", "ancd", "anca", "accbd", " acba", "akib", " acr", "ACr", "aclbody", "accbf", "accr", "ancfb", "eck", " acbar", "ACba", "acfb", "ancbr", "acbf", "macb", " acl", "accbody", "acbr", "ecbo", "appk", "arcfb", "achbr", "ecb", "ecba", "ocsb", "ACv", "ocbb", "axbf", "ancl", "acll", "ocb", "arcb", " acbo", "ecv", "accbe", "macf", "ACp", "acsb", "aca", " acsb", "ucbr", "ocba", "ACsb", "appb", "accfb", " acfb", " acbr", "arczb", "achb", "ancb", "accf", "axbb", "ACd", "appd", " acv", "ancn", "macfb", "anczb", "aczb", " acbb", "akbar", "encb", "akb", " ack", "accn", "ucb", "axk", "acczb", "acv", " acib", "ecbd", "ACk", "acj", "ancbo", "ecsb", "ecbody", "acib", "ancbf", "accv", "accp", "acbe", "accbb", "acbb", " acf", "appbb", "acbo", "ucbb", "acbd", "axb", "ocl", "ACl", "encib", "eca", "acck", "ACb", "accsb", "acbody", " acp", "acbar", " acd", " aca", "acn", "arck", "accd", "ecbb", "accba", "acr", "ACf", "acd", " acn", "ACbd", "ancv", "ACbb", "akbr", "achj", "encbar", "ecf", "ecl"], "s": ["submit", "js", "opens", "src", "cs", "http", "ss", "ops", "rs", "sa", "spec", "a", "sb", "r", "is", "sl", "bis", "g", "ses", "ls", "storage", "ds", "sets", "ps", "gs", "ns", "h", "c", "p", "state", "services", "self", "e", "f", "bos", "sys", "sq", "south", "o", "iss", "stats", "b", "site", "os", "ks", "session", "socket", "states", "se", "si", "obs", "ssl"], "bs": ["cms", "base", "js", "cs", "ss", "bh", "ba", "rs", "ts", "sb", "bps", "lb", "bm", "BS", "eb", "bid", "bc", "ins", "ms", "ros", "pb", "cus", "fps", "bl", "bis", "ls", "ses", "bits", "cb", "ds", "bas", "ps", "gs", "ns", "css", "vs", "bi", "us", "bos", "gb", "bt", "bg", "bb", "iss", "fb", "b", "os", "ks", "bytes", "its", "bes", "fs", "board", "db", "obs"]}}
{"project": "qemu", "commit_id": "b6c147622d31272f9728da9ec16d146bf8c45a74", "target": 1, "func": "int qcow2_update_header(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowHeader *header;\n\n    char *buf;\n\n    size_t buflen = s->cluster_size;\n\n    int ret;\n\n    uint64_t total_size;\n\n    uint32_t refcount_table_clusters;\n\n    size_t header_length;\n\n    Qcow2UnknownHeaderExtension *uext;\n\n\n\n    buf = qemu_blockalign(bs, buflen);\n\n\n\n    /* Header structure */\n\n    header = (QCowHeader*) buf;\n\n\n\n    if (buflen < sizeof(*header)) {\n\n        ret = -ENOSPC;\n\n        goto fail;\n\n    }\n\n\n\n    header_length = sizeof(*header) + s->unknown_header_fields_size;\n\n    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);\n\n\n\n    *header = (QCowHeader) {\n\n        /* Version 2 fields */\n\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n\n        .version                = cpu_to_be32(s->qcow_version),\n\n        .backing_file_offset    = 0,\n\n        .backing_file_size      = 0,\n\n        .cluster_bits           = cpu_to_be32(s->cluster_bits),\n\n        .size                   = cpu_to_be64(total_size),\n\n        .crypt_method           = cpu_to_be32(s->crypt_method_header),\n\n        .l1_size                = cpu_to_be32(s->l1_size),\n\n        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),\n\n        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),\n\n        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),\n\n        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),\n\n        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),\n\n\n\n        /* Version 3 fields */\n\n        .incompatible_features  = cpu_to_be64(s->incompatible_features),\n\n        .compatible_features    = cpu_to_be64(s->compatible_features),\n\n        .autoclear_features     = cpu_to_be64(s->autoclear_features),\n\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n\n        .header_length          = cpu_to_be32(header_length),\n\n    };\n\n\n\n    /* For older versions, write a shorter header */\n\n    switch (s->qcow_version) {\n\n    case 2:\n\n        ret = offsetof(QCowHeader, incompatible_features);\n\n        break;\n\n    case 3:\n\n        ret = sizeof(*header);\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n    memset(buf, 0, buflen);\n\n\n\n    /* Preserve any unknown field in the header */\n\n    if (s->unknown_header_fields_size) {\n\n        if (buflen < s->unknown_header_fields_size) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n\n        buf += s->unknown_header_fields_size;\n\n        buflen -= s->unknown_header_fields_size;\n\n    }\n\n\n\n    /* Backing file format header extension */\n\n    if (*bs->backing_format) {\n\n        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n", "idx": 710, "substitutes": {"bs": ["base", "js", "cs", "ss", "bh", "rs", "sa", "sb", "lb", "ab", "BS", "bid", "bc", "banks", "pb", "bl", "bis", "rb", "ses", "ls", "bits", "sync", "ds", "bas", "gs", "ns", "vs", "bi", "bos", "gb", "lbs", "bb", "blocks", "iss", "fb", "b", "stats", "os", "ks", "las", "bytes", "bes", "fs", "obs"], "s": ["sg", "js", "sa", "qs", "sl", "g", "ses", "ls", "sf", "args", "storage", "sie", "us", "f", "set", "secondary", "sys", "all", "parts", "sup", "spec", "ts", "sb", "type", "xs", "sv", "sets", "p", "state", "e", "conf", "as", "less", "su", "site", "S", "os", "session", "ks", "sym", "ssl", "cs", "ss", "a", "rs", "byte", "is", "ins", "bis", "i", "space", "settings", "ds", "ps", "gs", "ns", "c", "es", "south", "o", "si", "_", "series", "service", "http", "sis", "comments", "details", "sync", "ess", "services", "sq", "stats", "b", "states"], "header": ["layer", "dr", "server", "version", "buffer", "offset", "channel", "large", "conn", "queue", "host", "her", "data", "Header", "head", "section", "parent", "client", "auth", "pair", "vector", "body", "code", "master", "event", "filter", "document", "config", "runner", "gender", "feature", "holder", "h", "writer", "block", "content", "reader", "cookie", "f", "cache", "message", "token", "fat", "handler", "driver", "bridge", "border", "manager", "line", "cover", "root", "player", "response", "metadata", "table", "port"], "buf": ["ff", "fd", "src", "buffer", "ctx", "bh", "bag", "Buff", "queue", "fw", "data", "ab", "aux", "bc", "buff", "pb", "tmp", "cas", "batch", "uber", "rb", "fp", "box", "cb", "pool", "feat", "runner", "home", "func", "exc", "pad", "result", "block", "cv", "Buffer", "vec", "wb", "cap", "cache", "cmd", "alloc", "obj", "carry", "fb", "b", "seq", "abb", "uf", "img", "fi", "uc", "rc"], "ret": ["match", "arg", "def", "bit", "conn", " Ret", "success", "prot", "alt", "cat", "rets", "num", "bis", "nt", "ft", "rev", "status", "Ret", "rc", "feat", "opt", "result", "fin", "len", "flag", "gt", "resp", "RET", "error", "lit", "re", "reg", "val", "rt", "fi", "det", "res"], "total_size": ["total_sized", "stable67storage", "total24storage", "totalxsize", "total96offset", "stable_size", "total128storage", "stable_storage", "total_unit", "total28len", "stable_sized", "total96size", "block0000size", "block0000offset", "totalxoffset", "total96unit", "block_unit", "total28length", "total0000offset", "page_length", "total128small", "stable67size", "totalxdepth", "total128sized", "total128size", "block_offset", "total67storage", "total_len", "total_depth", "block_size", "total0000depth", "page_len", "block0000unit", "total28capacity", "total_offset", "total67size", "total_capacity", "page_capacity", "total0000unit", "stable67small", "total24size", "total_length", "totalxunit", "total_small", "stable_small", "total24sized", "total28size", "total0000size", "total67sized", "total24small", "stable67sized", "block_depth", "page_size", "total96depth", "block0000depth", "total67small", "total_storage"], "refcount_table_clusters": ["refcount_table_colusters", "refcount_table_lows", "refcount_table_scust", "refcount_table_fluster", "refcount_table_aluster", "refcount_table_clunks", "refcount_table_filunks", "refcount_table_clients", "refcount_table_sluster", "refcount_table_scuster", "refcount_table_clues", "refcount_table_lunks", "refcount_table_flusters", "refcount_table_clust", "refcount_table_lients", "refcount_table_alues", "refcount_table_colows", "refcount_table_lusters", "refcount_table_CLows", "refcount_table_luster", "refcount_table_flicas", "refcount_table_filusters", "refcount_table_clips", "refcount_table_CLuster", "refcount_table_scluster", "refcount_table_scows", "refcount_table_slows", "refcount_table_sclients", "refcount_table_sclusters", "refcount_table_combusters", "refcount_table_slust", "refcount_table_alusters", "refcount_table_filues", "refcount_table_flows", "refcount_table_CLusters", "refcount_table_sclips", "refcount_table_cluster", "refcount_table_scusters", "refcount_table_slusters", "refcount_table_filuster", "refcount_table_alunks", "refcount_table_colicas", "refcount_table_lips", "refcount_table_combuster", "refcount_table_licas", "refcount_table_lues", "refcount_table_CLust", "refcount_table_clicas", "refcount_table_combips", "refcount_table_clows", "refcount_table_combients", "refcount_table_coluster"], "header_length": ["layer_length", "layer_len", "header2len", "headers_len", "header_limit", "header2position", "header_shape", "headers_shape", "header_position", "headers_position", "layer_size", "headers_length", "header_len", "header_size", "header2length", "layer_limit", "header2shape"], "uext": ["uXT", "ueext", "ceft", "ueXT", "uft", "cueft", "cueXT", "cext", "uxt", "ueft", "cueext", "ceext", "ceXT", "cuext"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 729, "substitutes": {"host_port": ["host_host", " host_stream", "host_ports", "server_ports", "host_stream", "hostpstream", " host_address", "hostpaddress", "host_address", "server_host", "server_port", "hostpport", "server_address"], "errp": ["errP", "erP", "aerr", "raisefp", "aerpe", "aerP", "errpe", "errfp", " errpe", " errr", "raisep", "aerp", "err", " errps", " errP", "errps", "errr", "ercp", "raisecp", "erpe", "erp", " errcp", " errfp", "erps", "errcp", "raiseps", "erfp"], "s": ["server", "opens", "ss", "ops", "rs", "ts", "sb", "ips", "new", "r", "d", "n", "seconds", "is", "sl", "ms", "i", "g", "m", "ls", "sf", "args", "sync", "settings", "ports", "ds", "status", "sets", "ps", "sound", "address", "gs", "ns", "h", "l", "c", "p", "x", "e", "lines", "f", "es", "secondary", "rows", "sq", "core", "u", "o", "v", "stats", "b", "su", "S", "os", "t", "session", "socket", "port", "its", "an", "hs", "states", "fs", "si", "ssl"]}}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740, "substitutes": {"dev": ["serial", "test", "vol", "cam", "def", "dd", "spec", "hw", "conn", "device", "mod", "desc", "data", "current", "development", "d", "ver", "devices", "di", "google", "der", "prof", "priv", "grad", "de", "dom", "off", "fail", "Dev", "DEV", "des", "proc", "info", "bug", "md", "ch", "progress", "user", "dc", "home", "pad", "block", "gu", "prom", "app", "attr", "conf", "loader", " device", "die", "comment", "ev", "dem", "rad", "error", "od", "prov", "valid", "serv", "reg", "debug", "mode", "dis", "diff", "dist"], "fdt": ["feedt", "fxwt", "mdwt", "dlT", "fdn", "dlc", "dfz", "dfT", "lfd", "vdT", "dlts", "vdout", "dirwt", "fdd", "FDtt", "fedt", "FDc", "dirt", "ydn", "gdts", "lfts", "ecdwt", "dirtt", "fdtt", "dlta", "ydtt", "fdtz", "sdtt", "mdT", "vdn", "vdtz", "ydtz", "fdout", "fdnot", "dfout", "dlnot", "feedT", "ldtt", "mdc", "ldn", "vdt", "fedc", "sdt", "gdd", "FDt", "fxc", "dft", "fedz", "fdta", "FDwt", "vdtt", "sdT", "fxt", "dld", "ecdt", "FDta", "fedwt", "feedwt", "sdz", "dlwt", "fxta", "fdz", "ydt", "fedT", "gdt", "FDout", "fdwt", "ldtz", "fedtt", "lfc", "ecdtt", "lft", "dfta", "ldt", "ecdnot", "FDT", "dftt", "dltt", "gdc", "fdts", "mdt", "fdc", "fdT", "dfwt", "dirnot", "feedta", "dlt"], "offset": ["rot", "layer", "append", "outer", "trace", "skip", "no", "et", "array", "alias", "url", "loc", "align", "scroll", "position", "slot", "format", "off", "initial", "api", "seed", "next", "pos", "output", "item", "fp", "entry", "sync", "attribute", "slice", "style", "index", "pointer", "offer", "enabled", "address", "begin", "pad", "shift", "start", "layout", "bound", "reset", "length", "set", "ref", "len", "attr", "origin", "range", "padding", "phase", "o", "prefix", "exclusive", "optional", "Offset", "error", "online", "location", "addr", "enter", "limit", "part", "timeout"], "sphb": [" sphBs", " sphsb", "scld", "pshb", "sppb", "sphsb", "sppsb", " sppsb", "sshd", "sppr", "pphr", "sppBs", " sphr", "sphar", "sshp", "sphap", "sphr", "pphb", "smphsb", " sppBs", "sphp", "smphBs", "sshr", "smphr", "pphp", " sppb", "sphd", "sphab", "sshsb", "sclp", "pshr", "pshp", "sshb", " sppr", "sclr", "smphb", "sphBs", "sshBs", "sclb", "sphad", "pshd", "pphd"], "rp": ["nrP", "rper", "nrp", " rP", "rP", "Rp", "RP", " rper", "nrper", "Rper"], "pci_status": ["pci__status", "pci_stat", "pci__error", "pcm_err", "pci__err", "pcm_error", "pcm_status", "pci__stat", "pci_err", "pci_error", "pcm_stat"], "err": ["rs", "Error", "rr", "r", " error", "proc", "info", "cb", "er", "cr", "str", "temp", "progress", "errors", "result", "ind", "e", "len", "attr", "cache", "ctr", "resp", "error", "req", "msg", "iter", "fi", "res"], "buf": ["fd", "src", "buffer", "ctx", "queue", "mem", "data", "buff", "tmp", "fp", "cb", "temp", "pool", "pad", "block", "Buffer", "ptr", "ref", "br", "cache", "cmd", "alloc", "seq", "bytes", "uf", "path", "rc", "port"], "max_msi": ["max_ksI", "max_ssi", "max_MSI", "max_ssd", "max_MSii", "max_MSd", "max_msii", "max_ssI", "max_ksii", "max_ksd", "max_ksi", "max_MSi", "max_msd", "max_ssii", "max_msI"], "max_msix": ["max_mmix", "max_ansi", "max_mi", "max_msiz", "max_mmci", "max_mmi", "max_ansix", "max_mix", "max_msci", "max_miz", "max_mci", "max_ansci", "max_ansiz", "max_mmiz"]}}
{"project": "FFmpeg", "commit_id": "a8d702859b8bd17978fb5d8cb1d6acc363031e80", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748, "substitutes": {"m": ["mn", "cm", "media", "vm", "mount", "ctx", "q", "em", "mod", "M", "mc", "bm", "km", "r", "d", "n", "ms", "im", "mm", "k", "y", "i", "g", "j", "model", "mac", "gm", "md", "om", "h", "l", "c", "p", "man", "e", "dm", "f", "jam", "arm", "message", "machine", "wm", "mp", "pm", "u", "rm", "fm", "v", "um", "tm", "mr", "sm", "b", "s", "t", "module", "manager", "am", "mu", "ym"], "gb": ["rg", "ctx", "gram", "kb", "ga", "gc", "sb", "bm", "hub", "ui", "mb", "gy", "gnu", "bc", "GB", "gin", "gg", "rb", "gm", "cgi", "kw", "gam", "bf", "gs", "Gb", "bd", "bg", " bc", "bb", "abb", "usb", "gd", "db", "xb"], "mh": ["dimhr", "bmhr", "dch", "cmch", " mhs", "emh", "dh", "dmah", "cmbh", "gph", "Mrh", "amih", "gmh", " mch", "emH", "mah", "mih", "amhr", "fmhs", "mhs", "ymsh", "mkh", "dmrh", "emhs", "h1", "vsh", " mph", "mhr", "pmh", "bmph", "emsh", "tmrh", "tmh", "hz", "mmH", "modelh", " mich", "paramrh", "Mch", "mbh", "pmhr", "mmph", "dmh", "modul", "vhs", "bmsh", "vh", "Mach", "fmch", "amz", "amv", "m1", "hih", "pmH", "hkh", "gmhr", "Mh", " m1", "hsh", "gach", "tmph", "gmrh", "ymh", "mich", "gh", "mz", "cmh", "ymkh", "dimh", "hah", "dmsh", "amph", "fmrh", " mkh", "modelhs", " mrh", "paramh", " mul", "mrh", "dimhs", "amh", "modach", "fmhr", " mih", "amH", "Mbh", "mph", "fmh", "hh", " mH", "mv", "amach", "ghr", "pmrh", " mz", "dimich", "dhr", "ymv", "model1", " mhr", "cmrh", " mah", "paramhs", "hul", " mbh", "vH", "gmH", " mv", "modh", "mmh", " msh", "mmsh", "msh", " mach", "mch", "Mich", "hv", "bmh", "tmsh", "Mhr", "mH", "hhs", "modelach", "modah", "Mhs", "tmah", "mul", "mmhr", "dhs", "hach", "mmv", "mach", "amhs", "tmv", "tmhr", "paramach"], "substr": ["subchar", "ubctr", "subctr", " subctr", "ubchar", "extctr", "ubStr", " subStr", "extStr", "extstr", " subchar", "ubstr", "extchar", "subStr"], "ret": ["match", "arg", "att", "mt", "def", "bit", "sb", "success", "r", "alt", "cur", "rets", "arr", "bl", "rep", "code", "ft", "nt", "back", "reply", "feat", "Ret", "status", "bf", "rc", "result", "ut", "len", "red", "ref", "rem", "rl", "flag", "gt", "art", "value", "en", "RET", "al", "lit", "re", "reg", "val", "rt", "let", "af", "det", "res", "bad"]}}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767, "substitutes": {"s": ["sg", "src", "cs", "ss", "spec", "ts", "sa", "a", "sb", "r", "n", "is", "sl", "sis", "bis", "i", "ses", "ls", "sf", "xs", "sv", "settings", "ds", "ns", "c", "p", "sie", "services", "e", "sed", "f", "es", "sq", "south", "sn", "sr", "b", "su", "S", "os", "bs", "an", "init", "se", "si", "in", "sym", "parts", "ssl"], "bin": ["bian", "base", "ban", "bn", "fen", "ba", "bank", "bit", "sa", "sb", "sid", "data", "bm", "binary", "spin", "sam", "n", "di", "bid", "bc", "con", "bon", "boot", "ben", "num", "bl", "gin", "bis", "scan", "gn", "inn", "ini", "bas", "non", "bot", "bi", "cookie", "nb", "len", "vin", "gb", "win", "bg", "sn", "bb", "pc", "lib", "fb", "b", "plugin", "border", "lin", "web", "gen", "bs", "an", "root", "init", "dat", "net", "pin", "db"], "st": ["stage", "ist", "ust", "ld", "src", "stal", "rest", "ss", "stan", "stat", "ts", "sa", "sd", "sb", "be", "r", "d", "ct", " est", "sp", "sl", "sh", "spect", "cur", "sk", "St", "bl", "ste", "sf", "stri", "ft", "fr", "nt", "cr", "str", "storage", "fe", "l", "sw", "ut", "lc", "stab", "sc", "ST", "stable", "stream", "bt", "std", "obj", " St", "sn", "sts", "sta", "inst", "t", "stop", "bs", "ost", "td", "nd", "ast", "se", "part", "start", "net", "sth", "sty", "est"]}}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n", "idx": 781, "substitutes": {"bs": ["ob", "base", "null", "js", "cs", "bh", "ss", "qs", "ts", "sb", "bps", "lb", "BS", "bid", "bc", "banks", "ins", "pb", "bl", "bis", "ls", "ses", "bits", "cb", "ds", "bas", "ps", "gs", "ns", "css", "vs", "bos", "obj", "s", "bu", "bb", "iss", "fb", "b", "blocks", "lib", "os", "ks", "bytes", "las", "bes", "fs", "db", "obs"], "sector_num": ["sector_number", " sector_begin", "sector_no", "sector0begin", "sector0number", "sector_begin", "sector_un", "section_name", "sectorlexnine", " sector_no", "sector_nine", "sectorlexnum", "section_number", " sector_number", " sector_sum", "sector_sum", " sector_nine", "sectorlexnumber", "section_num", "sector_len", "sector0num", " sector_name", " sector_len", " sector_un", "sector_name", "sector_Num", "section_Num", "sectorlexbegin", "sector0no"], "nb_sectors": ["nb_pector", "nb_sercs", "nb_tragments", "nb_gectors", "nb_pelements", "nb_secctors", "nb_psegments", "nb_serors", "nb_gector", "nb_spegments", "nb_vegments", "nb_serlements", "nb_tractors", "nb_velements", "nb_secrets", "nb_pecs", "nb_spelements", "nb_pefs", "nb_serrets", "nb_selements", "nb_pegments", "nb_sector", "nb_gecs", "nb_tralements", "nb_segments", "nb_gegments", "nb_psector", "nb_trafs", "nb_sections", "nb_veors", "nb_sefs", "nb_secors", "nb_pections", "nb_psectors", "nb_surlements", "nb_vectors", "nb_spectors", "nb_gections", "nb_vecs", "nb_sergments", "nb_serctors", "nb_surcs", "nb_psecs", "nb_serets", "nb_verets", "nb_pectors", "nb_surctors", "nb_secgments", "nb_seors", "nb_secs", "nb_surgments", "nb_spefs", "nb_psections"], "qiov": ["qfour", "qnox", " qroxy", "sqicho", "Qfour", "questiov", "Qroxy", "questiev", " qiop", "qicho", "questiop", " qicho", "quiov", "quroxy", "sqiev", "qufour", "sqiop", "sqiov", "qiop", "Qiov", "qunox", "questicho", " qiev", " qfour", "Qnox", " qnox", "qroxy", "qiev"], "acb": ["incl", "Acrb", "rcl", "acba", "acl", "Acb", "recbase", "ocn", " acbase", "icbar", "accb", "icbb", "incbf", "acp", " acB", " acba", "incbs", "rcbs", "recfb", " acbar", "ACba", "acfb", "acbf", " acl", "recab", "acB", "ocsb", "ocbb", "recb", "ocb", "acbs", "actp", " acab", "acsb", "aca", " acsb", " acbf", "ACB", "ACsb", "ocrb", "incb", "iacb", "actbase", " acfb", "accbase", "accrb", " acbb", "acca", "accn", "icb", "acbase", "rcbf", "actbb", "actb", "iacfb", "acrb", "Acsb", "acab", "accp", "accbb", "acbb", "accbar", "iacbase", " acbs", "accsb", "ACb", "Acbb", " acp", "ica", "acbar", "rcb", "accB", "acn", " aca", "accba", "iacab", " acn"], "ret": ["arg", "active", "gc", "success", "url", "alt", "next", "rep", "code", "Ret", "opt", "f", "reset", "en", "RET", "rt", "fun", "ext", "format", "html", "rets", "fit", "fail", "reply", "sr", "final", "hard", "lit", "re", "val", "det", "base", "att", "mt", "data", "r", "out", "cat", "true", "info", "back", "feat", "pub", "result", "ut", "len", "ref", "value", "obj", "error", "req", "reg", "res", "_", "match", "no", "def", "bit", "orig", "pet", "rf", "nt", "ft", "rev", "aud", "ber", "status", "pat", "red", "rl", "flag", "gt", "art", "resp", "let", "ann", "part", "db"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "substitutes": {"dx": ["yx", "dn", "da", "ud", "dd", "dh", "data", "zx", "loc", "d", "xd", "distance", "px", "xy", "max", "ady", "push", "xs", "dt", "ds", "z", "xp", "xx", "dc", "step", "down", "pad", "phy", "w", "front", "patch", "fix", "ww", "fx", "wd", "prefix", "ix", "rx", "DX", "depth", "view", "xxx", "start", "ex", "diff", "dist", "xi", "wx"], "dy": ["delay", "yi", "dn", "da", "dd", "ii", "dim", "zi", "data", "ui", "zy", "idy", "iy", "d", "di", "gy", "dl", "ry", "xy", "ny", "ty", "j", "i", "py", "ady", "yd", "sync", "direction", "z", "yy", "md", "ey", "dir", "ds", "lon", "down", "hi", "vy", "f", "b", "depth", "dist", "yer", "eddy", "wy", "diff", "db", "sy"], "x": ["name", "yx", "q", "image", "r", "d", "n", "px", "id", "xy", "i", "pos", "m", "X", "xs", "z", "index", "xx", "down", "h", "p", "l", "c", "w", "e", "hi", "xc", "ax", "height", "u", "en", "o", "v", "b", "ix", "rx", "t", "path", "xxx", "one", "ex", "xi"], "y": ["yi", "q", "ye", "yl", "ish", "yo", "zy", "iy", "d", "n", "type", "yan", "ry", "cy", "xy", "ny", "ya", "ty", "j", "i", "year", "py", "ady", "m", "ky", "z", "yy", "ey", "ch", "h", "l", "p", "w", "vy", "col", "yt", "o", "ay", "b", "t", "Y", "oy", "sky", "wy", "sy"], "state": ["version", "name", "key", "active", "area", "new", "d", "type", "STATE", "id", "scope", "parent", "seed", "j", "instance", "next", "State", "i", "update", "inner", "m", "none", "code", "sync", "event", "direction", "style", "err", "z", "index", "ch", "status", "st", "step", "down", "p", "e", "force", "size", "length", "f", "resource", "private", "self", "set", "value", "up", "range", "scale", "b", "ate", "error", "old", "rule", "notice", "val", "mode", "states", "part", "start", "in", "sy"], "bmap": ["cMap", "cmap", "bMAP", " bMAP", "cbmaps", "pmaps", "cmaps", "bMap", "bbmap", "bbMap", " bMap", "bmaps", "cMAP", "cbmap", "cbMap", "pmap", " bmaps", "cbMAP", "pMAP", "pMap", "bbmaps", "bbMAP"], "prev_state": ["keep_status", "keepfstate", "prev_State", "keep_state", " prev_connection", "keepfstatus", " prev_rule", "prev___states", "prev___state", "keep_call", "prevfscale", " prev_State", "prevPstatus", "prev_rule", "prev_scale", "prevPscale", "prevfcall", "prevfstate", "prev_connection", "prev___connection", "prev_call", "keep_scale", "prevPstate", " prev_config", "prevfstatus", " prev_states", "prev_status", "prevPcall", "prev_states", "prev_config", "keepfcall", "keepfscale"]}}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n", "idx": 797, "substitutes": {"obj": ["ob", "ctx", "ops", "def", "mod", "conn", "data", "objects", "parent", "op", "tmp", "api", "Obj", "j", "po", "pos", "proc", "coll", "opt", "pkg", "nb", "conf", "object", "node", "cmd", "o", "ev", "rad", "inst", "os", "module", "od", "pro", "pt"], "dev": ["fo", "test", "adv", "ow", "def", "dd", "mod", "device", "sd", "conn", "fw", "data", "new", "development", "d", "di", "ver", "gh", "priv", "de", "grad", "enc", "dom", "DEV", "Dev", "develop", "info", "bug", "dt", "md", "dc", "gu", "pred", "prom", "self", "private", "dm", "gd", "app", "conf", "cd", "object", "wd", "die", "ev", "dem", "rad", "prov", "var", "od", "oy", "pro", "error", "td", "debug", "diff"], "prop": ["rop", "property", "pl", "np", "name", "target", "term", " Prop", "def", "key", "device", "Prop", "data", "prot", "tag", "type", "priv", "pb", "buf", "op", "tmp", "span", "comp", "param", "api", "j", "po", "pos", "rb", "proc", "dest", "info", "dep", "project", "properties", "pointer", "config", "ps", "feat", "opt", "feature", "owner", "ip", "p", "pred", "pr", "ptr", "private", "f", "col", "prev", "attr", "doc", "object", "jp", "mp", "rel", "cp", "cmp", "pro", "lit", "val", "part", "pt", "fi", "pp", "option"]}}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837, "substitutes": {"req": ["ret", "q", "key", "queue", "ver", "requ", "rec", "client", "hr", "er", "ir", "err", "tr", "crit", "ec", "progress", "pr", "dev", "f", "jp", "seq", "require", "rt", "task", "ext", "spec", "rw", "sem", "id", "ra", "request", "pkg", "p", "e", "resource", "org", "comm", "sr", "ev", "re", "load", "input", "urg", "required", "rs", "gr", "tar", "mod", "rr", "ru", "dep", "str", "dq", "pub", "c", "eq", "ref", "loader", "ctr", "app", "cmd", "release", "supp", "module", "rar", "reg", "low", "cook", "res", "call", "def", "conn", "cur", "query", "grad", "rf", "rb", "fr", "config", "reader", "ro", "sq", "exec", "resp", "cmp", "rx", "pro", "quant", "desc"], "r": ["ur", "dr", "this", "q", "wr", "yr", "j", "g", "hr", "er", "ir", "err", "tr", "pr", "self", "f", "u", "rd", "var", "rt", "rh", "rw", "k", "ra", "nr", "request", "p", "or", "e", "resource", "per", "R", "sr", "v", "mr", "t", "re", "user", "rg", "rs", "gr", "rr", "ru", "lr", "kr", "m", "cr", "str", "h", "usr", "result", "c", "br", "o", "rar", "d", "cur", "rf", "rb", "fr", "rev", "l", "reader", "w", "rl", "ar", "b", "rx", "nor", "vr", "rc"], "s": ["server", "js", "service", "cs", "http", "ss", "spec", "rs", "qs", "sb", "is", "sp", "sl", "y", "j", "g", "params", "ses", "ls", "sf", "uns", "sync", "ser", "settings", "err", "z", "ds", "str", "ps", "gs", "ns", "c", "p", "sw", "or", "w", "e", "f", "es", "sys", "sq", "ar", "sec", "sr", "v", "su", "S", "os", "session", "t", "b", "fs", "si", "sym", "ssl"], "n": ["no", "adj", "not", "conn", "ni", "nn", "out", "d", "pn", "k", "un", "nu", "nl", "ne", "num", "na", "y", "i", "g", "j", "m", "nr", "network", "number", "z", "ns", "x", "l", "N", "p", "c", "h", "e", "nb", "f", "len", "size", "nan", "sn", "o", "v", "nm", "b", "t", " N", "nor", "net"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848, "substitutes": {"plow": ["flow", " pligh", "lowed", "phay", "plowed", "lOW", "oploy", "iplowe", "opligh", "iploom", " plowed", "pullowe", "fligh", "flowed", "phOW", "plows", "lowe", "oploom", "iplrow", "phow", " play", " plOW", "phoy", " plows", "iplOW", "iplow", "flows", "oplow", " plrow", " plowe", "pullow", "plowe", "oplay", "oplOW", "ploom", "plOW", "ploy", " ploy", "oplowed", "Plow", " ploom", "Plowe", "PlOW", "pligh", "pullOW", "play", "oplows", "Plrow", "low", "pullowed", "iplowed", "plrow", "iplows"], "phigh": ["philig", "phight", "shig", "Phigi", "ophalth", "PHiz", "phai", "phaich", "Phai", "PHalth", "Phalth", " phiz", "PHigg", "PHig", "phaogg", "phiz", " phight", "phaig", "shigh", "phug", "philigh", "phaug", " phalth", "Phigh", "ophug", " phigi", "phaigh", "ophight", "philogg", " phyg", "phigi", " phiy", " phai", "PHiy", "phogg", "PHigh", "phiy", "PHai", "philich", "PHigi", "phig", "phyg", " phug", "shiz", "phayg", "shigg", "phich", " phigg", "shiy", "ophig", "phaalth", "phigg", " phig", "phalth", " phich", "ophyg", "phaight", "ophigh", " phogg"], "b": ["ob", "base", " db", " bi", "bh", "a", "lb", "ab", "binary", "mb", "r", "B", "d", "ib", "n", "eb", "bc", "k", "pb", " eb", "i", "y", "bl", "g", "rb", "body", "bf", "pa", "l", "c", "p", "beta", "h", "w", "e", "nb", "f", "wb", "bi", "length", "gb", "zb", "bt", "s", "bb", "bp", "v", "fb", "bar", "bs", "db"], "sa": ["sg", "sac", "so", "asu", "da", "ss", "ba", "a", "ga", "sd", "asi", "sam", "n", "aa", "ma", "sp", "sl", "sh", "ta", "sk", "na", "za", "Sa", "au", "ai", "pa", "sea", "p", "sie", "asa", "ca", "sc", "sq", "la", "gb", "as", "pc", "s", "SA", "sta", "ama", "su", "wa", "isa", "va", "bs", "se", " si", "si", "sy"], "sb": ["sg", "SB", "src", "bh", "ss", "ba", "obb", "a", "sd", "lb", "bm", "ab", "eb", "ib", "mb", "db", "sp", "sl", "bc", "sh", "pb", "sk", "bl", "rb", "sf", "cb", "amb", "st", "bf", "pa", "bi", "nb", "wb", "sq", "sc", "gb", "zb", "bt", "sec", "sn", "bb", "bp", "s", "fb", "sta", "sm", "bs", "si", "sth"]}}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855, "substitutes": {"linker": ["layener", "layer", "lockger", " linkner", "layger", "linkger", " linkers", "layor", "locker", "inkener", " linkener", "lockor", "layner", "linkor", "linkner", "inkers", "inker", "lockher", " linkor", " linkher", "layher", "linkher", " linkger", "layers", "linkener", "linkers", "inkner"], "file": ["call", "base", "files", "name", "buffer", "offset", "time", "read", "key", "array", "queue", "data", "filename", "image", "memory", "loc", "class", "align", "type", "field", "format", "parent", "model", "code", "fp", "write", "source", "pool", "feed", "address", "content", "block", "resource", "size", "f", "per", "cache", "value", "ile", "File", "link", "path", "full", "line", "dir", "fi", "port"], "alloc_align": ["alloc__range", "loc_role", "alloc___aligned", "oc_space", "alloc__ign", "alloc_balance", "oc_array", "loc_aligned", "alloc__aligned", "oc_al", "alloc_array", "alloc_space", "loc_balance", "loc_align", " alloc_aligned", "allocfign", "alloc_al", "alloc___align", "alloc___balance", "alloc___role", "alloc__align", " alloc_range", "oc_align", "alloc_aligned", " alloc_ign", "oc_aligned", "allocfaligned", "alloc_ign", "alloc_role", "allocfrange", "allocfalign", "alloc_range"], "alloc_fseg": ["alloc_FseG", "alloc_fsege", "alloc_fpersega", "alloc_fgege", "alloc_fmege", "alloc_fpersege", "alloc_fsegs", "alloc_fgeig", "alloc_fperseG", "alloc_fseG", "alloc_rfgege", "alloc_fsega", "alloc_FgeG", "alloc_Fseg", "alloc_fmega", "alloc_Fsegs", "alloc_Fgeig", "alloc_fperseg", "alloc_Fgegs", "alloc_Fgeg", "alloc_fpersegs", "alloc_fgeG", "alloc_fperseeg", "alloc_fgeeg", "alloc_fmeeg", "alloc_fgegs", "alloc_fgega", "alloc_rfseeg", "alloc_rfsege", "alloc_rfgeeg", "alloc_Fseig", "alloc_rfseg", "alloc_rfsega", "alloc_rfgeg", "alloc_fseig", "alloc_fgeg", "alloc_fmeg", "alloc_fseeg", "alloc_fperseig", "alloc_rfgega"], "entry": ["row", "key", "ge", "ger", "next", "index", "feed", "archive", "set", "comment", "way", "cell", "valid", "engine", "se", "start", "ae", "ner", "extra", "her", "image", "parent", "end", "scan", "parse", "ie", "or", "e", "lc", "per", "org", "plugin", "link", "import", "data", "new", "r", "add", "cat", "section", "record", "insert", "ent", "member", "Entry", "inner", "info", "str", "result", "writer", "loader", "cache", "sec", "connection", "card", "error", "module", "enter", "match", "server", "service", "inter", "ga", "array", "ry", "cue", "nt", "reader", "zero", "try", "element", "line", "install", "inc", "export"]}}
{"project": "qemu", "commit_id": "95eaa78537c734fa3cb3373d47ba8c0099a36ff0", "target": 1, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 860, "substitutes": {"bs": ["ob", "base", "js", "cs", "abi", "ss", "http", "ba", "bh", "rs", "qs", "ts", "sb", "bps", "lb", "BS", "sels", "bc", "ins", "bin", "ros", "pb", "bing", "bl", "bis", "blog", "ls", "bits", "cb", "outs", "ds", "bas", "gs", "abc", "bf", "ns", "bot", "css", "vs", "bi", "us", "bos", "bd", "gb", "bt", "lbs", "uss", "bb", "ubs", "blocks", "s", "fb", "b", "iss", "os", "ks", "bytes", "las", "cks", "BC", "bes", "fs", "obs"], "errp": ["err", "errfp", "errP", " errP", "rfp", "erP", " errfp", "errr", " errr", "erp", "rp", "rP", "rr", "erfp"], "iscsilun": ["uscsilut", "ischetuna", "ircslmun", "isclifut", "isclituan", "ircslune", "iscchaluna", "ircielan", "iscslunin", "isconsequune", "iscryptin", "iscsiluno", "iscmilun", "uscslut", "iscielorn", "iscvaleunt", "iscrilu", "micielunin", "iscsilmun", "iscselmun", "iscsylvunin", "ircilandon", "isconsequun", "iscaluna", "iscivaluna", "iscrituno", "iscslunion", "socliftun", "iscllund", "iscilianuna", "iscielan", "ISCrilunin", "iscrilun", "usercslunion", "iscstatun", "uscsilgan", "usercsluna", "iscmilunin", "uscsilunt", "iscilsuc", "ISCsilu", "ISCsilunin", "iscsluni", "usciluno", "uscslu", "uscilund", "iscsilunion", "isclituno", "iscalidun", "iscselun", "uscsilorn", "iscilluna", "iscselfun", "uscieluna", "uscslunt", "ircsiloren", "iscillund", "iscalgan", "iscnilin", "soclifmun", "explryptin", "uscsilun", "ircilu", "ischetune", "iscilauna", "iscslandon", "ircslut", "ircsluna", "iscsylvuna", "iscslmun", "soclifun", "iscsilandon", "iscillune", "iscilunt", "iscvaleun", "uscslund", "iscsilken", "iscielun", "usercsilun", "iscrilken", "iscmiluan", "iscilloren", "isculinunt", "ISCsilken", "uscsiluni", "iscillunin", "iscilund", "ircsilun", "isciluno", "iscvaleuna", "uscilunt", "isciluan", "iscrubin", "ircsluan", "iscieluna", "uscsilin", "ircslunt", "socsilun", "uscsluno", "iscsilgan", "iscyllmun", "iscislund", "iscilauni", "usercsilfun", "ircslin", "iscniluna", "isclitunin", "explryptunt", "ischetun", "uscslban", "iscmilfun", "iscsilut", "isclifu", "iscmilin", "iscsiluc", "iscilaun", "iscsilu", "usciluna", "isclluna", "socsilmun", "iscalidunt", "uscsluan", "iscladune", "iscalun", "iscsellune", "isculinuna", "iscieluc", "uscielun", "uscslin", "iscilluan", "ISCrilun", "iscsiltun", "ircielun", "iscilluc", "iscsilin", "iscrubun", "iscsellmun", "ircsilut", "iscillut", "usercsiluna", "iscrubmun", "isculinban", "soclifut", "iscstatin", "uscsiluan", "iscvaleund", "iscsylvun", "ircsilmun", "iscivalan", "iscstatuna", "iscstatund", "iscoglmun", "iscrubuna", "iscSiluno", "iscielu", "iscsiluan", "socsiltun", "ircielcon", "iscllun", "uscsilu", "iscilsun", "micielun", "micsilun", "isconsequuna", "iscoglun", "ircielunin", "iscivalut", "ircsilandon", "iscSilun", "iscsloren", "ircsilcon", "iscilsuna", "iscsiluna", "iscSiluna", "iscslfun", "ircsiluna", "ircslun", "iscislun", "iscritun", "irciluna", "isclitu", "ischetunt", "iscislunt", "iscalidund", "iscilaandon", "ircsilune", "iscilau", "iscvaleune", "iscryptuna", "iscsilcon", "iscladun", "iscilauno", "ircsloren", "iscilluno", "ircslunin", "uscsiluc", "iscsilunin", "iscilandon", "ISCrilu", "iscnilmun", "explsiluna", "micsilunin", "iscislgan", "iscryptut", "iscyllut", "iscilaoren", "ircsluno", "iscnilun", "iscladuna", "iscrituna", "ircsilunin", "iscielken", "iscsilorn", "iscillcon", "iscSiluan", "iscivalun", "iscilaunin", "iscselunion", "iscchalune", "iscsellunt", "iscielcon", "isclifmun", "usercslun", "usciluan", "iscilu", "uscsluna", "isclituna", "ircsiluno", "explsilunt", "iscaliduna", "isculinun", "iscillan", "ircsilu", "iscslgan", "ircslund", "iscylltun", "iscilianunt", "iscslin", "micielken", "micsiluna", "uscieluc", "iscillun", "isclitun", "iscslu", "iscalunt", "ISCsilun", "iscchalut", "iscsiluni", "iscslune", "iscrilunin", "iscsluna", "uscilun", "iscsilund", "isculinut", "iscillu", "iscyllun", "iscivalune", "ircsilund", "ISCrilken", "iscilianund", "iscillunt", "iscsilunt", "isclluno", "uscsiluno", "iscslunt", "iscslban", "uscsilund", "iscillin", "explsilun", "iscilun", "isclifunin", "ircilun", "ircsilan", "iscislin", "iscilianun", "iscmilcon", "iscselltun", "iscivalunt", "uscsiluna", "iscogluna", "iscslun", "iscryptun", "uscslun", "iscstatunt", "iscsluno", "usercslfun", "isclifken", "iscsilfun", "explryptuna", "iscladut", "iscielunin", "micieluna", "iscsellun", "iscsilune", "ircslan", "usercsilunion", "iscryptunt", "uscsluni", "isclifun", "micsilken", "iscslan", "iscchalun", "ircsiluan", "iscsilban", "uscslgan", "isciluna", "iscsylvken", "iscselluna", "explryptun", "iscliftun", "iscsellut", "iscsiloren", "iscoglin", "iscsilan", "iscmiluna", "ircsilunt", "ircsilin", "socsilut", "iscseluna", "iscisluna", "iscilaban", "iscritund", "iscillorn", "iscilsorn", "iscslut", "uscsilban", "iscmilunion", "uscsilune", "iscilaund", "isculinuni", "uscielorn", "explsilin", "iscsluan", "iscslund", "isconsequunt", "iscselin", "iscmilan"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 883, "substitutes": {"opaque": ["opacity", " opque", " opatile", "opca", "opsacity", "opsca", "operaque", "copque", " opaca", "copatile", " opacity", "ropca", "copacity", "operacity", " opca", "opatile", "opsaque", "ropaca", "opaca", "ropaque", "copaque", "opsaca", "operatile", "ropacity", "opque", "operque"], "buf": ["null", "fd", "src", "buffer", "ctx", "bag", "context", "queue", "data", "window", "bc", "buff", "pb", "batch", "output", "code", "fp", "cb", "pool", "config", "cv", "Buffer", "vec", "ref", "cap", "gb", "cmd", "alloc", "seq", "b", "uf", " buffer", "msg", "map", "db", "port"], "size": ["unit", "SIZE", "capacity", "name", "offset", "ize", "esc", "large", "small", "data", "out", "send", "n", "loc", "empty", "num", "enc", "max", "g", "code", "storage", "z", "address", "c", "len", "length", "Size", "sec", "en", "fee", "iz", "six", "timeout"], "s": ["sg", "submit", "service", "ss", "ops", "spec", "sa", "sb", "n", "sl", "scope", "m", "ses", "ls", "sf", "secure", "sync", "storage", "ds", "gs", "ns", "c", "p", "sie", "w", "e", "f", "secondary", "sys", "sq", "conf", "sec", "o", "S", "socket", "fs", "si", "sym", "ssl"], "ret": ["fun", "no", "att", "bit", "Len", "ror", "success", "xt", "out", "r", "alt", "id", "rets", "num", " RET", "rb", "code", "nt", "number", "rev", "ft", "reply", "Ret", "rc", "bf", "result", "usr", "len", "rl", "ref", "flag", "fat", "resp", "art", "obj", "sr", "RET", "t", "error", "lit", "re", "reg", "val", "rt", "count", "iter", "det", "res"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886, "substitutes": {"dev": ["serial", "vol", "ow", "cam", "dn", "def", "hw", "spec", "conn", "device", "sd", "mod", "ga", "data", "development", "d", "ver", "ad", "di", "google", "priv", "prof", "de", "client", "end", "dom", "api", "Dev", "info", "bug", "err", "temp", "ch", "pub", "dc", "disk", "bus", "block", "gu", "p", "w", "self", "gd", "app", "conf", "cache", "obj", "die", "comment", "driver", "ev", "rad", "dem", "req", "var", "error", "valid", "od", "nov", "debug", "diff", "fi", "user"], "errp": ["errP", "rrfp", "erP", "Erp", "airp", "errc", "rrpc", "verP", "errpe", "errorpc", "errorpr", "airlp", "errfp", "errpc", "barlp", " errpe", "rrP", "rrr", "errorP", " errr", "errproc", "Erpc", "airpe", "airc", "verpc", "erproc", " errlp", "barr", "ErP", "resultp", "errr", "verp", "barp", "resultpe", " errpc", "errorp", "verpr", "erp", "rrproc", " errc", "Erpr", "errpr", "errorfp", "errlp", "resultc", "errorproc", "rrlp", "barpc", "resultlp", "erfp", "rrp"], "dinfo": ["ddata", " dcheck", " dbi", "dlfo", "hdinfo", "ldfo", "dlink", "bdinfo", " dInfo", "ldinf", "dcheck", "hdbi", "Dfo", "vdlink", "dllink", "dlinfo", "Dinfo", "dlcheck", "vdfo", "dldata", "DInfo", "bdfo", "vddata", " dinf", "dinf", "bddata", "hdcheck", "dbi", "ldInfo", "dlbi", "bdlink", "hdinf", "dfo", "ldinfo", " dfo", "vdinfo", "dlinf", "Dinf", "dInfo"], "local_err": ["remote_error", "localFerr", "localIPresult", "local_errors", "local_er", "localIPerr", " local_error", "localJtemp", "localJer", "remote_err", " local_er", "localJerrors", "local_str", " local_result", "remote_str", "local_result", "local_error", "local_temp", "localFerrors", "localIPerror", "localFtemp", "localJerr", " local_errors", " local_temp", "localFer"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899, "substitutes": {"bs": ["js", "cs", "ss", "bh", "rs", "qs", "ts", "sa", "sb", "lb", "BS", "aws", "bid", "bc", "ins", "ms", "pb", "ses", "ls", "ds", "bas", "gs", "ps", "ns", "vs", "bi", "bos", "gb", "bt", "as", "bb", "iss", "b", "os", "fs", "obs", "ssl"], "sn_info": ["snallinfo", "ns_init", "snacInfo", "snamconfig", "snappsource", "snACINFO", "serv_info", "snaminf", "syn_info", "syn_service", "serv_information", "snameopt", "sn8Info", "snameinformation", "snallinf", "nsallfamily", "syn_inf", "sn8info", " sn_diff", "snameinf", "sameopt", "sn_diff", "sn_inf", "nsallinfo", "kn_iso", "syn_off", "sn_iso", "sn_config", " sn8Info", "ns_family", "sn_init", "snappoff", "snaminformation", "snameconfig", "sn7ami", "sn7info", "sn_ami", "s_opt", "snamservice", "sn8diff", "sn_def", "sn_opt", "sn_service", "syn_source", "sl_def", "sn7def", "kn_Info", "sn7Info", "sl_ami", "snaminfo", "sn5inf", "s_source", "s_info", "servaminf", "samesource", "sn5family", "snacinfo", "sn_INFO", " sn_id", "servaminfo", "snACiso", " sn8inf", "syn_Info", "snallfamily", "snappinfo", "servamconfig", "kn_INFO", "sn_fo", "sn_information", " sn8info", " sn_fo", "sameinfo", "sn_id", "snameinfo", "serv_inf", " sn8diff", "sn8source", "knacInfo", "sn8inf", "sn5info", "snACinfo", "snallinit", "sn_source", "nsallinit", "servaminformation", "knacINFO", " sn_inf", "sl_Info", "snappinf", "knacinfo", "serv_config", "ns_info", "knaciso", "snamesource", "sn_off", "sn_family", "sn5init", "sl_info", "snacINFO", "snamInfo", " sn_Info", "snACInfo", "kn_info", "sn8opt", "sn_Info", "ns_inf", "nsallinf", "snaciso"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "args", "self", "us", "f", "secondary", "sys", "sum", "fs", "spec", "ts", "sb", "y", "uns", "xs", "sv", "request", "sets", "p", "state", "e", "conf", "as", "sn", "uses", "v", "su", "site", "S", "t", "session", "ks", "its", "in", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "i", "m", "info", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "server", "service", "ops", "d", "results", "ms", "sis", "params", "details", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "ret": ["base", "arg", "fun", "att", "mt", "def", "bit", "conn", "hash", "ror", "data", "success", " Ret", "ct", "alt", "cat", "format", "id", "pet", "rets", "arr", "num", "pass", "rb", "info", "nt", "ft", "rev", "str", "back", "feat", "Ret", "rc", "bf", "opt", "sat", "reply", "result", "et", "fin", "nb", "len", "ref", "flag", "rl", "gt", "fat", "resp", "art", "RET", "valid", "af", "lit", "reg", "re", "val", "rt", "let", "part", "pt", "fi", "det", "res", "db"], "fd": ["fc", "fun", "ff", "ld", "dn", "fs", "dd", "conn", "FD", "raf", "fa", "flo", "d", "ad", "alt", "dl", "lf", "fl", "ln", "fn", "buf", "rb", "dy", "draft", "fp", "ft", "df", "cb", "dt", "md", "cond", "func", "bf", "fe", "dc", "feed", "fin", "f", "hd", "bd", " fid", "cd", "fat", "resp", "fx", "handler", "wd", "fm", "exec", "bb", "fee", "fb", "cf", "td", "nd", "dir", "fi", "wat", "gd", "db"], "new_vid": ["new_virt", "newnewpin", "newnewsid", "old_sid", "new_pid", " new_pid", "old_vid", "new_addr", "newAvirt", "new_pin", "newAvid", "new_uid", " new_virt", "newtuid", " new_addr", "newAaddr", "newnewuid", "old_pin", "newtpin", "newApid", "new_sid", "newnewvid", "newtsid", "old_uid", "newtvid"], "inode": ["INade", "Inoder", " inoder", "infoding", "noder", "ninODE", "arinole", "innhole", "linade", "nube", " inodi", "inname", "axade", "dinute", "dinode", "ninade", "ninode", "Inore", "inhole", "arinovo", " inODE", "incoe", "axore", "vinute", "ninovo", "innoder", "gnode", "arinoder", " inova", "rinoding", "rinoder", "INoder", "infode", "dinova", "innode", "ginoder", " inonymous", "Inodi", "inoding", "INovo", "INoding", "incode", "innade", "innnode", "vinoder", "ginode", "nODE", "INode", " inome", "ancode", "Inole", "ninoder", "innome", " inhole", "INole", "ancodi", " inole", "linote", "dinoder", "gnoe", "Inoding", "inoder", "incoder", "innole", "ginODE", "riname", "inoe", "INube", "ancole", "ancoding", "inovo", "ginade", "incnode", " inade", "INore", "INote", "inore", "gnoder", "ninole", "iname", " inoding", "innoe", "inube", "gnonymous", "inODE", "rinoe", " inute", "axode", "infoder", " iname", "arinode", "node", "Inote", "inome", "infame", "Iname", "INODE", "rinode", "INhole", "innonymous", "axoding", "linode", "inodi", "Inoe", "linoding", "vinode", "InODE", "inole", "rinole", "Inade", " inube", "inade", "inova", "inote", "INome", " inoe", "inute", "Innode", "innODE", "inonymous", "vinova", "Inode"], "datalen": ["datalener", "dallens", "daliston", "dalen", "Daleno", "daclon", "dstalen", "dalledEN", "davalEN", "daclen", "duledens", "dalledent", "daleno", "daclener", "dalener", "Dalon", "dalsten", " dalens", "datalens", "duleden", " dalEN", "DatalEN", "Dalener", "Dalent", "davalener", "datalsten", "datalent", "dalEN", "dalistEN", "dalon", " dalsten", "datalon", "dallsten", "dstalent", "davalender", "Dalender", "dalistener", "dalender", " datalsten", "datalEN", "Datalent", "davalen", "daclender", "dalisten", "daclEN", "DalEN", " dalen", "datalender", "Datalon", "duledsten", "dalledeno", "dallEN", "duledEN", "Datalen", "Dataleno", "Datalener", "Datalender", " datalens", "dalleden", "dataleno", "dstalEN", "dalens", "dallen", "dalent", " datalEN", "Dalen", "dstaleno"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 906, "substitutes": {"vd": ["fd", "ld", "dn", "ud", "dd", "pd", "vt", "sd", "data", "xd", "d", "di", "dl", "uds", "adr", "ve", "df", "ov", "sv", "dt", "ds", "md", "vv", "dc", "vid", "dev", "vs", "hd", "bd", "cd", "std", "vc", "wd", "rd", "v", "adh", "lv", "od", "nv", "va", "td", "nd", "vr", "ed", "VD", "gd"], "saddr": ["ssaddr", "dsmd", "seshost", "dsock", "wsaddress", "smd", "wsmd", "ssmd", "shost", "dsadd", "dshost", "sesadd", "dsaddr", "sadd", "ssaddress", "dsaddress", "sesaddress", "nshost", "saddress", "wsock", "sesaddr", "nsadd", "ssock", "nsaddress", "sock"], "nsaddr": ["NSaddr", "netsaddress", "vsaddress", "nsAddress", "lsAddress", "ainsaddress", "NSaddress", "ainsAddress", "lsaddr", "nspad", "lsaddress", "nshost", "saddress", "NSAddress", "NShost", "lshost", "netsaddr", "vsaddr", "spad", "netspad", "ainshost", "nsaddress", "vspad", "ainsaddr"], "wsaddr": ["nwaddr", "lsrt", "WSrt", "wsrt", "wsaddress", "awsock", "lscall", "waddr", "wscall", "lsaddr", "nwrc", "WScall", "WSaddr", "WSaddress", "awsrc", "wrt", "lsaddress", "awsaddress", "nwaddress", "wsock", "nwock", "lsrc", "wcall", "lsock", "awsaddr", "waddress", "wsrc"], "nwsaddr": ["nwaddr", "nawsaddress", "nnwsaddr", "nwmd", "nwsock", "nnwalt", "Nhwock", "nwpad", "nwalt", "nmsock", "nhwaddress", "Nhwaddress", "nnwsaddress", "nmsaddress", "nawsmd", "nwpock", "Nhwaddr", "nwwaddr", "nnwsmd", "Nwsaddress", "Nhwad", "nawsaddr", "nnwsalt", "nwsaddress", "nhwaddr", "Nwsad", "nhwad", "nwsad", "Nwsock", "nwaddress", "nwwmd", "nwsalt", "nwwaddress", "nhwock", "nwpaddress", "nmsaddr", "nwsmd", "nnwmd", "nmsad", "nnwaddress", "nnwaddr", "nawsalt", "nwpaddr", "nwwalt", "Nwsaddr"], "errp": ["errP", "errq", "erP", "argpre", "Erp", "cornp", "angerp", "rrpc", "errpe", "errnp", "arglp", "errsp", "acerlp", "errpc", "corp", " errq", "rrsp", "acerpa", "Erpc", " errlp", "angersp", "corq", " errP", " errpa", "acerp", "corP", "Ersp", "erp", "acerpre", " errpre", "errlp", "angerpe", "Erpe", " errnp", "errpa", "angerpc", "errpre", "erq", "rrpe", "argp", "ernp", "argpa", "rrp"], "i": ["yi", "name", "li", "gi", "abi", "key", "a", "ni", "ii", "ei", "pi", "ui", "oi", "d", "I", "di", "is", "id", "mi", "iu", "j", "y", "m", "ri", "eni", "info", "ti", "slice", "ini", "index", "multi", "ai", "ie", "x", "l", "c", "p", "h", "bi", "phi", "e", "lc", "f", "hi", "u", "o", "v", "s", "b", "qi", "ix", "uri", "ci", "io", "mu", "fi", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 913, "substitutes": {"cpus": [" cpores", "ppis", "pcul", "cpores", "cpacs", "gpis", "ctxus", " cpio", "ctxores", "cpul", "cpuis", "pcuses", "pppu", "ctxpu", "gpus", " cppu", "gpuses", "cpis", "pcacs", "pcio", " cpuses", " cpacs", "cpuses", "cppu", "cpuacs", "ppores", "ppus", "cpuul", " cpul", "pcis", " cpis", "cpuus", "pcus", "cpio", "ctxis", "gpio"], "max_cpus": ["max_cpuores", "max_execus", "max_execuses", "max_compis", "max_pos", "max_pcos", "max_pcus", "max_executes", "max_compums", "max_gpaus", "max_ps", "max_pcores", "max_pus", "max_cpores", "max_cpis", "max_dcus", "max_cpaus", "max_cpos", "max_cps", "max_execores", "max_gpus", "max_gputes", "max_dcaus", "max_compos", "max_execos", "max_gpums", "max_compus", "max_cpuos", "max_gpos", "max_cpuus", "max_gpores", "max_cpuuses", "max_pums", "max_gps", "max_pcs", "max_pis", "max_execs", "max_dcos", "max_pores", "max_puses", "max_cpuses", "max_gpis", "max_cpums", "max_cputes", "max_dcutes", "max_execaus"], "cpu": ["unit", "fc", "np", "vm", "winner", "consumer", "gpu", "capacity", "piece", "currency", "roc", "conn", "gc", "queue", "process", "current", "lb", "clock", "GPU", "lu", "nc", "nic", "platform", "boot", "fps", "loop", "auc", "component", "CPU", "proc", "pixel", "pai", "python", "pid", "pool", "pointer", "bench", "foo", "cu", "c", "css", "lc", "pu", "loader", "core", "cache", "cap", "processor", "node", "linux", "pc", "prefix", "thread", "cp", "cmp", " CPU", "uca", "fork", "uu", "net", "performance"], "s": ["sg", "js", "ss", "ops", "rs", "ts", "sb", "ruby", "r", "strings", "d", "n", "aws", "is", "sl", "m", "ses", "ls", "sf", "sync", "python", "sv", "str", "ds", "ps", "gs", "ns", "h", "c", "p", "w", "e", "f", "es", "sys", "sq", "o", "v", "su", "b", "S", "t", "session", "os", "fs", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "8ad9fa5d8be7fd04e723020088eca664971eb363", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921, "substitutes": {"command": ["service", "name", "buffer", "channel", "sequence", "usage", "array", "method", "queue", "execute", "data", "filename", "menu", "operation", "package", "m", "file", "password", "attribute", "request", "database", "sudo", "config", "address", "function", "c", "p", "message", "exec", "handler", "cmd", "comm", "connection", "Command", "prefix", "path", "mode", "start", "input", "directory"], "bandwidth_limit": ["bandweight_log", "bandweight_level", "bandwidth_lim", "bandworking_block", "bandworking_lock", "bandweight_block", "bandwidthlimitlock", "bandweight_limit", "bandwidth_lock", "bandworking_limit", "bandwidth_log", "bandwidth_level", "bandwidth_block", "bandwidthlimitblock", "bandwidthlimitlog", "bandwidthlimitlimit", "bandweight_lock", "bandworking_lim"], "async": ["assynchronous", " asnc", "nasync", "Async", "assnc", " Asnc", "nasynchronous", "Asynchron", "asyn", " assync", " Asynchronous", " asynchron", " Async", "Asynchronous", " asyn", "asynchron", " Asyn", "assyn", "Assync", "asynchronous", "nasynchron", "assync", "nassync", " asynchronous", "asnc"], "s": ["sg", "js", "qs", "n", "sp", "sl", "client", "j", "g", "ls", "ses", "sf", "args", "x", "us", "sys", "socket", "your", "se", "fs", "sup", "spec", "ts", "sb", "aws", "y", "uns", "sets", "p", "state", "e", "conf", "v", "su", "site", "S", "t", "session", "os", "its", "sym", "plugins", "ssl", "cs", "ss", "rs", "a", "new", "data", "r", "is", "ins", "i", "m", "info", "settings", "ds", "ps", "gs", "native", "ns", "c", "es", "south", "o", "si", "server", "service", "ops", "d", "ms", "sis", "sync", "status", "l", "services", "w", "sq", "stats", "b", "full", "states"], "f": ["fo", "fc", "ff", "fd", "tf", "fs", "fen", "fed", "fw", "fa", "r", "d", "fu", "lf", "fn", "rf", "F", "i", "g", "m", "file", "fp", "sf", "df", "fr", "fe", "bf", "h", "l", "c", "p", "w", "e", "u", "fx", "o", "v", "fb", "b", "t", "cf", "af", "fi"]}}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924, "substitutes": {}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937, "substitutes": {"env": ["eu", "ext", "txt", "visor", "environment", "priv", "dict", "eng", "enc", "ef", "proc", "dest", "estate", "err", "impl", "ec", "opt", "exc", "conf", "viron", "obj", "en", "ev", "iv", "inst", "cfg", "emb"], "spapr": ["sprapri", "spapro", "spepR", "spAPR", "sprapro", "spAPro", "spAPrs", "spaperi", "spapsR", "speprar", "spAPr", "SpapR", "spaper", "SpapsR", "spraprar", "sprapr", "mpaprar", "Spapr", "mpapR", "Spapsrs", "spraprs", "Spapsr", "mprapR", "spaprar", "spaperar", "mprapr", "Spapsro", "Spapro", "mprapri", "spapsrs", "spepri", "mpraprar", "spapri", "mpapri", "sprapR", "spapsr", "mpapr", "spapR", "spapeR", "spepr", "spaprs", "spapsro", "Spaprs"], "opcode": ["opcodes", "ipcodes", "ipbar", "mpbe", "mpbar", "ipbe", "mpcodes", "mpcode", "epbar", "ipcode", "epcode", "epcodes", "opbar", "opbe", "epbe"], "args": ["argument", "keys", "call", "limits", "arg", "missing", "fun", "same", "extra", "array", "host", "data", "members", "flags", "strings", "seconds", "aws", "use", "ins", "Arg", "objects", "ms", "lang", "empty", "ims", "arms", "enc", "py", "options", "params", "event", "bug", "ports", "names", "parse", "ras", "ams", "config", "gs", "function", "p", "vs", "w", "self", "atts", "words", "lines", "fires", "as", "fields", " arguments", "stats", "Args", "ages", "ex", "apps", "parts"], "dev": ["serial", "adv", "def", "dd", "conn", "device", "mod", "sd", "host", "data", "development", "ver", "d", "di", "rec", "sh", "ad", "priv", "prof", "de", "client", "dom", "Dev", "DEV", "develop", "des", "info", "nt", "bug", "md", "ch", "pub", "user", "dc", "gu", "p", "block", "w", "private", "dm", "app", "conf", "cache", "obj", "comment", "die", "driver", "v", "ev", "dem", "rad", "inst", "var", "error", "valid", "debug", "root", "diff", "gd", "dist", "mem"], "rtce": ["tCE", "tge", "rotse", "rtco", "rotCE", "RTfe", "rotfe", "gtCE", "ttcel", "tcel", "ttco", "ttced", "ctce", "rtcel", "rotce", "rtse", "gtce", "ttce", "rtfe", "RTge", "RTse", "gtfe", "tced", "rtCE", "rtge", "ttge", "RTco", "gtse", "ctcel", "RTce", "RTCE", "ctced", "rtced", "tce", "ctCE", "ttCE", "tco"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n", "idx": 941, "substitutes": {"obj": ["ob", "orb", "so", "ctx", "act", "bo", "sb", "n", "oid", "objects", "env", "otype", "op", "tmp", "api", "Obj", "j", "po", "rb", "code", "Object", "cb", "opt", "x", "c", "p", "self", "e", "org", "office", "object", "o", "ev", "iv", "b", "t", "os", "conv", "val", "xxx", "obb"], "v": ["vm", "vp", "vt", "inv", "d", "vim", "k", "env", "api", "j", "i", "m", "ve", "ov", "sv", "z", "vv", "x", "l", "c", "p", "vs", "w", "e", "f", "u", "uv", "object", "V", "o", "iv", "ev", "b", "t", "lv", "conv", "tv"], "opaque": ["opacity", "OPacity", "OPaque", "posatile", "otac", "posaque", "otatile", "posacity", "OPatile", "otacity", "posac", "opatile", "opac", "otaque", "OPac"], "name": ["base", "named", "no", "time", "key", "a", "anc", "alias", "data", "n", "type", "unknown", "parent", "i", "space", "label", "code", "info", "names", "x", "word", "block", "Name", "size", "f", "cap", "ame", "value", "min", "comment", "nm", "prefix", "error", "path", "nice", "part", "NAME"], "errp": ["errP", "rrfp", "drlp", "derlp", "errpe", "derp", "errfp", " errpe", "drpre", "derP", "drp", "corp", "corpe", " errlp", "drfp", " errP", "corlp", "corP", "derpe", " errpre", "errlp", " errfp", "rrpre", "rrlp", "errpre", "rrp"], "s": ["syn", "sg", "js", "service", "cs", "ss", "ops", "rs", "ts", "spec", "n", "sl", "ssh", "op", "g", "m", "ses", "sf", "ds", "ps", "ns", "c", "p", "css", "services", "e", "f", "sys", "sq", "core", "o", "S", "os", "session", "an", "fs", "si", "ssl"]}}
{"project": "FFmpeg", "commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "target": 1, "func": "ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n\n                    int *seq, int flags, int64_t timestamp)\n\n{\n\n    RMDemuxContext *rm = s->priv_data;\n\n    int ret;\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        rm->current_stream= st->id;\n\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n\n        if(ret)\n\n            return ret < 0 ? ret : -1; //got partial frame or error\n\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n\n            (ast->deint_id == DEINT_ID_INT4) ||\n\n            (ast->deint_id == DEINT_ID_SIPR)) {\n\n            int x;\n\n            int sps = ast->sub_packet_size;\n\n            int cfs = ast->coded_framesize;\n\n            int h = ast->sub_packet_h;\n\n            int y = ast->sub_packet_cnt;\n\n            int w = ast->audio_framesize;\n\n\n\n            if (flags & 2)\n\n                y = ast->sub_packet_cnt = 0;\n\n            if (!y)\n\n                ast->audiotimestamp = timestamp;\n\n\n\n            switch (ast->deint_id) {\n\n                case DEINT_ID_INT4:\n\n                    for (x = 0; x < h/2; x++)\n\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n\n                    break;\n\n                case DEINT_ID_GENR:\n\n                    for (x = 0; x < w/sps; x++)\n\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n\n                    break;\n\n                case DEINT_ID_SIPR:\n\n                    avio_read(pb, ast->pkt.data + y * w, w);\n\n                    break;\n\n            }\n\n\n\n            if (++(ast->sub_packet_cnt) < h)\n\n                return -1;\n\n            if (ast->deint_id == DEINT_ID_SIPR)\n\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n\n\n             ast->sub_packet_cnt = 0;\n\n             rm->audio_stream_num = st->index;\n\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n\n            int x;\n\n            rm->audio_stream_num = st->index;\n\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n\n            if (ast->sub_packet_cnt) {\n\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n\n                ast->audiotimestamp = timestamp;\n\n            } else\n\n                return -1;\n\n        } else {\n\n            av_get_packet(pb, pkt, len);\n\n            rm_ac3_swap_bytes(st, pkt);\n\n        }\n\n    } else\n\n        av_get_packet(pb, pkt, len);\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n#if 0\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n\n\n            seq |= (timestamp&~0x3FFF);\n\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n\n        }\n\n    }\n\n#endif\n\n\n\n    pkt->pts = timestamp;\n\n    if (flags & 2)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n\n}\n", "idx": 944, "substitutes": {"rm": ["dr", "cm", "vm", "mt", "rs", "mc", "mx", "bm", "rn", "km", "r", "rr", "mm", "pb", "lr", "rf", "drm", "rb", "m", "RM", "cr", "rpm", "lc", "dm", "ref", "rem", "arm", "wm", "ram", "pm", "mp", "fm", "rd", "sr", "mr", "nm", "asm", "sm", "rt", "am", "rh"], "ret": ["match", "rot", "fun", "no", "att", "mt", "offset", "ext", "def", "bit", " Ret", "data", "success", "url", "r", "alt", "id", "pet", "rets", "fit", "num", "code", "nt", "ft", "rev", "live", "back", "reply", "feat", "Ret", "bf", "pat", "status", "result", "l", "fin", "ut", "len", "f", "flag", "ref", "gt", "art", "obj", "en", "RET", "seq", "t", "al", "lit", "re", "reg", "val", "rt", "det", "res", "rc"], "x": ["name", "cross", "yx", "q", "time", "key", "a", "pe", "image", "d", "n", "ct", "id", "px", "k", "xy", "num", "y", "i", "g", "j", "pos", "dx", "ady", "m", "dy", "tx", "event", "X", "xs", "z", "index", "ey", "xp", "xx", "h", "c", "p", "l", "sw", "w", "e", "f", "work", "ax", "xc", "u", "fx", "el", "en", "v", "s", "b", "ix", "t", "rx", "ay", "wa", "sex", "on", "ex", "my", "in", "xi"], "ast": ["act", "rest", "sa", "acl", "sam", "ct", "best", "aster", "sc", "aste", "at", "od", "an", "est", "parser", "ld", "anc", "host", "sth", "ap", "end", "api", "ac", "tx", "post", "esp", "hop", "as", "amp", "asts", "nd", "att", "mt", "ard", "ab", "ad", "asting", "add", "ta", "st", "blast", "mast", "et", "ref", "AST", "el", "node", "asm", "rss", "inst", "old", "ost", "cast", "ist", "test", "ant", "tta", "ans", "na", "ft", "md", "aid", "pat", "ess", "ar", "asted", "esta", "art", "std", "sta", "am", "part", "ace", "dist"], "sub_packet_cnt": ["sub_packet_fval", "sub_packet_wcount", "sub_packetC\n", "sub_packet_fno", "sub_packet_cno", "sub_packet_data", "sub_packet_acnd", "sub_packet_nccount", "sub_packet_account", "sub_packet_ccount", "sub_packacketCdata", "sub_packet_acct", "sub_packet_wnt", "sub_packacket_\n", "sub_packet_cval", "sub_packet_acval", "sub_packet_acnt", "sub_packacket_data", "sub_packacketC\n", "sub_packet_ncnd", "sub_packet_\n", "sub_packetcdata", "sub_packetc\n", "sub_packet_wval", "sub_packet_acno", "sub_packet_fct", "sub_packet_fnt", "sub_packet_fcount", "sub_packet_wno", "sub_packet_cct", "sub_packet_ncnt", "sub_packetCdata", "sub_packet_ncct", "sub_packet_fnd", "sub_packet_cnd"]}}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946, "substitutes": {"parent": ["mother", "null", "this", "target", "peer", "host", "data", "new", "current", "class", "comp", "package", "parents", "instance", "component", "pos", "partial", "Parent", "pointer", "pool", "owner", "pa", "p", "self", "private", "child", "ref", "object", "fat", "obj", "node", "o", "path", "root", "port"], "part": ["property", "base", "name", "key", "host", "class", "type", " component", "PART", "pair", " Part", "pre", "component", "pos", "partial", "pointer", "p", "self", "private", "child", "patch", " parts", "object", "node", "Part", "point", "prefix", " partition", "element", "path", "start", "parts"], "prop": ["rop", "property", "np", "ext", "term", "key", "ops", "Prop", "type", "ap", "cand", "priv", "cop", "pb", "op", "tmp", "comp", "api", "j", "po", "pos", "proc", "cb", "atom", "properties", "pid", "pointer", "config", "ps", "opt", "p", "pred", "pr", "dev", "lc", "hop", "col", "attr", "object", "jp", "mp", "obj", "rel", "bp", "fb", "cp", "cmp", "pro", "lit", "val", "root", "typ", "option"]}}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n", "idx": 961, "substitutes": {"s": ["sg", "server", "js", "service", "src", "cs", "ss", "spec", "sa", "ts", "sb", "is", "sis", "ls", "ses", "ds", "status", "ps", "gs", "c", "state", "services", "e", "us", "f", "es", "self", "sys", "u", "v", "su", "t", "os", "session", "fs", "si", "ssl"], "req": ["call", "ctx", "q", "rs", "gr", "spec", "conn", "rw", "queue", "desc", "sem", "rr", "r", "rob", "requ", "rec", "ry", "cur", "query", "rf", "iq", "proc", "info", "ir", "err", "request", "fr", "dq", "crit", "config", "resource", "f", "ref", "cache", "sq", "ctr", "conf", "exec", "resp", "seq", "serv", "rx", "require", "reg", "qt", "rh", "qq", "res"], "iu": ["eu", "cli", "asu", "vp", "li", "ctx", "abi", "sa", "ei", "ii", "ni", "tu", "lb", "ui", "gru", "ib", "uci", "ru", "gnu", "lu", "fu", "cci", "nu", "iq", "i", "umi", "hu", "eni", "ti", "util", "sit", "ai", "ie", "ugi", "gu", "afi", "sie", "uin", "ua", "pu", "isu", "isi", "u", "gui", "vc", "qi", "agi", "iw", "uri", "ci", "wei", "mu", "fi", "si", "input", "ou"], "rsp": ["hrspe", "rpe", "srasp", " rsl", "prsl", "rcsp", "hrsp", "hrp", "prpp", "rssa", " risp", "srsl", " rosp", "rrpc", " rpp", "prsp", "rsso", "rp", "crsp", "prst", " rpc", "rcpp", "prpc", "rsa", "srso", "rsl", "rrsp", "risp", "rcp", "crosp", "rrsa", "crp", "prsa", " rcp", " rpe", "rcsl", "rpp", "rasp", "prso", "srcp", "rspe", "srpc", "rrst", "hrisp", "prpe", " rsc", "rst", "rssp", "rosp", "rsasp", "rrisp", "rcpc", "prsc", "prasp", " rp", "prcp", "rso", "srsp", " rspe", "rspc", " rso", "srsc", "srpe", "rsst", "crspe", "rrosp", "rrspe", "rsc", "rpc", "rrp"]}}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "substitutes": {"timer": ["Timer", "icer", "server", "outer", "imer", "buffer", "ext", "time", "inter", "term", "counter", "peer", "txt", "tim", "acker", "ee", "clock", "caster", "browser", "tick", "worker", "tc", "ger", "roller", "ter", "icker", "later", "inner", "amer", "er", "master", "ti", "err", "event", "temp", "runner", "writer", "reader", "maker", "ler", "lc", "theme", "loader", "message", "handler", "mom", "processor", "driver", "tm", "mr", "thread", "hour", "iner", "acer", "manager", "cer", "sim", "player", "timeout", "walker"], "count": ["match", "call", "base", "mount", "name", "check", "lock", "read", "time", "offset", "counter", "large", "cc", "process", "current", "clock", "weight", "empty", "num", "max", "code", "number", "cond", "force", "work", "c", "cpu", "size", "length", "len", "child", "core", "cache", "app", "amount", "sum", "seq", "thread", "path", "full", "Count", "load", "ast", "start", "cast"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971, "substitutes": {"job_id": ["block_ID", "jobCids", "job_ident", " job_ident", "block_name", "jobCID", "job_ID", " job_name", "job_ids", "job_name", "block_id", " job_ids", "jobCname", "jobCid", "block_ids"], "bs": ["sub", "js", "src", "cs", "http", "ss", "local", "rs", "sb", "bps", "lb", "url", "BS", "bid", "bc", "job", "ins", "banks", "pb", "fps", "bing", "bl", "bis", "ls", "ses", "sync", "settings", "status", "bas", "ps", "disabled", "gs", "ns", "bot", "css", "state", "vs", "blast", "bos", "bi", "core", "gb", "bb", "blocks", "stats", "b", "site", "os", "las", "bytes", "root", "fs", "res"], "base": ["bat", "based", "sub", "server", "cli", "buffer", "http", "local", "flat", "sb", "area", "bare", "lb", "ui", "url", "out", "ase", "Base", "bc", "job", "pb", "basic", "client", "remote", "pre", "builder", "plain", "super", "body", "sync", "master", "settings", "live", "back", "source", "bas", "bf", "change", "bot", "block", "state", "lc", "cache", "core", "rel", "kit", "prefix", "bp", "bb", "b", "site", "full", "support", "root", "bottom", "res", "db"], "top": ["sub", "name", "http", "above", "upper", "url", "high", "sp", "job", "parent", "platform", "client", "op", "api", "pre", "first", "pos", "super", "file", "master", "settings", "config", "bas", "ps", "bot", "best", "state", "p", "css", "hop", "block", "prev", "front", "core", "pop", "origin", "up", "as", "TOP", "at", "prefix", "b", "plugin", "site", "path", "tops", "root", "Top", "part", "bottom", "ssl"], "speed": ["unit", "SIZE", "level", "name", " speeds", "skip", "ss", "offset", "rate", "spec", "bps", "url", "ime", "type", "sp", "timeout", "client", "peed", "seed", "score", "sf", "sync", "slice", "status", "ps", "step", "size", "length", "stream", "driver", "sn", "stats", "sm", "error", "sort", "stop", "engine", "root", "Speed", "limit", "ride", "start"], "on_error": ["on_err", " on_err", " on_success", "on_success", "on_start", " on_start"], "backing_file_str": ["backing_file_path", "backing_path_path", "backing_file2str", "backing_file2url", "backing_file2uri", "backing_path_uri", "backing_path_str", "backing_path_url", "backing_file2path", "backing_file_uri", "backing_file_url"], "filter_node_name": ["filter_file_path", "filter_file_name", "filter_node_path", "filter_file_type", "filter_file_names", "filter_node_type", "filter_node_names"], "errp": ["errP", "rrfp", "erP", "acerP", "ierps", "erpc", "rrpc", "ierpy", "errorpc", "errfp", "errpc", "rrps", "rrP", "rrr", "ErrorP", "errorP", " errpy", " errr", "Errorps", "Errorr", "errorps", "err", " errps", " errP", "rrcp", "acerps", "errr", "errps", "ercp", "Errorp", " errpc", "errorp", "acerp", "erp", " errcp", "acerpy", "errorr", " errfp", "erps", "errpy", "errcp", "ierr", "acerfp", "acerr", "ierp", "rrp"], "s": ["sg", "js", "cs", "http", "ss", "rs", "sa", "ts", "spec", "r", "n", "is", "sp", "sl", "sh", "uploads", "sk", "g", "m", "ses", "ls", "sf", "details", "sync", "sv", "ds", "sets", "ps", "gs", "ns", "l", "c", "p", "e", "f", "sys", "sc", "sq", "sports", "o", "stats", "b", "su", "S", "os", "hs", "se", "fs", "si", "ssl"], "reopen_queue": ["reclose_batch", "reopen_collection", "reopenempriority", "reopenfqueue", "reopenaylock", "reopenerbuf", "reopen_log", "reopened_batch", "reopen_batch", "refill_parent", "reopenslist", "reopenayparent", "reopen___priority", "reopensqueue", "refill_log", "reopenermanager", "reopen_base", "reopenallserver", "reopenerlist", "reopened_queue", "reopenaylog", "reopen_manager", "reopen_buf", "reopenscollection", "reopen___stack", "reopenermenu", "reopen_parent", "reopenerqueue", "reopen_status", "reopened__manager", "reopen_menu", "reopenerque", "reopen_priority", "reopenerbatch", "reopenercollection", "reopened__queue", "reopensparent", "recreate_status", "reclose_que", "recreate_collection", "reopenfstatus", "reopen__queue", "reopened__batch", "reclose_base", "reopenayqueue", "reopenemstack", "reopened_manager", "reopenslock", "reopenallstatus", "reopen___queue", "reopenallqueue", "reopened__que", "reopened_que", "reopen__que", "reclose_queue", "reopensstatus", "recreate_queue", "reopenallque", "refill_lock", "reopenemqueue", "reopenemque", "reopenerstatus", "reopenfserver", "reopen_list", "reopen__batch", "reopenslog", "refill_queue", "reopen_lock", "reopen__manager", "reopen_que", "recreate_list", "reopen___que", "reopen_server", "reopen_stack", "reopenfque"], "orig_overlay_flags": ["orig_overlayallrules", "orig_overline_files", "orig_override_files", "orig_overlay_flag", "orig_overline_flags", "orig_overlayacflag", "orig_overline_flag", "orig_overlayallflag", "orig_overlay_bits", "orig_overlayacfiles", "orig_overlay_locks", "orig_overlay__rules", "orig_override_flags", "orig_overlay_ants", "orig_override_rules", "orig_overlay__flags", "orig_overlayacflags", "orig_override_locks", "orig_override_ants", "orig_overlay_rules", "orig_overlay__ants", "orig_overlayallflags", "orig_override_bits", "orig_overlayallfiles", "orig_overlay_files", "orig_overline_rules"], "orig_base_flags": ["orig_base_settings", "orig_originalwrules", "orig_base64types", "orig_original_flags", "orig_base64groups", "orig_bas_bits", "orig_base64flags", "orig_fixed_flags", "orig_base_groups", "orig_basewtypes", "orig_base_rules", "orig_baselicflags", "orig_fixed_groups", "orig_basewgroups", "orig_originalwgroups", "orig_original_rules", "orig_bas_fields", "orig_base_fields", "orig_baselicfields", "orig_originalwtypes", "orig_base_types", "orig_base_bits", "orig_base_devices", "orig_fixed_settings", "orig_basewflags", "orig_base_states", "orig_base_ants", "orig_fixed_states", "orig_originalwflags", "orig_bas_devices", "orig_basewrules", "orig_original_types", "orig_bas_stats", "orig_baselicdevices", "orig_original_groups", "orig_base_stats", "orig_base64rules", "orig_bas_ants", "orig_bas_flags"], "iter": ["sub", "stat", "flat", "is", "ins", "store", "chain", "it", "loop", "super", "sync", "rev", "status", "abc", "bot", "bi", "stack", "iterator", "origin", "reverse", "at", "stats", "seq", "site", "its", "root", "fs"], "overlay_bs": ["overlay__cs", "overlay_base", "overlay_cs", "overlayer_b", "override_bs", "overlay_bas", "overline_b", "overlayer_bas", "override_base", "overlay_ls", "overlay_cases", "overlayer_base", "overlay_b", "overlay__base", "override_boxes", "overline_bs", "overlayer_ls", "override_bits", "override_b", "overlay__bs", "overline_abs", "overlayer_cs", "overlay_bits", "overlayer_bs", "overlay_boxes", "overlay_abs", "overlay__ls", "override_cases", "overlayer_abs", "overline_base"], "commit_top_bs": ["commit_top_b", "commit_top_lb", "commit_best_b", "commit_config", "commit_top_base", " commit_\n", "commit_best_base", " commit_config", "commit_best_bs", "commit_\n", "commit_best_lb"], "local_err": ["local___error", "Local_orig", "local___err", " local_req", "local_orig", "Local_err", "Local_req", "local_message", "local___req", "local_er", "local_res", "local_attr", " local_error", "localalres", "local___message", "Local_error", "localalattr", "localalerr", " local_er", "locallyerror", "localalerror", "global_err", "global_res", "locallyres", "locallyattr", "local_error", "global_error", " local_message", "locallyerr", "localalreq", "global_attr", "local_req", "localalorig"], "ret": ["fun", "def", "gc", "alt", "bc", "ry", "num", "pass", " resp", " RET", "Ret", "rc", "result", " r", "len", "resp", "RET", "al", "re", "reg", "val", "run", "res"]}}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n", "idx": 982, "substitutes": {"bs": ["null", "cs", "ss", "ba", "bn", "ops", "BS", "B", "bid", "sels", "bc", "banks", "ins", "pb", "bing", "bis", "ls", "ses", "bits", "als", "bas", "ps", "gs", "abc", "ns", "css", "vs", "bi", "Bs", "bos", "ubs", "iss", "blocks", "fb", "b", "os", "bytes", "bes", "fs"]}}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}", "idx": 1035, "substitutes": {"link": ["cross", "http", "channel", "sd", " Link", "tag", "add", "light", "type", "links", "model", "linked", "plug", "bug", "filter", "feed", "Link", "ack", "man", "or", "bridge", "plugin", "path", "line", "load", "band", "pack"], "samplesref": ["sampsreference", "samplesreference", " sampsreference", "sipesreference", "sampsRef", " samplesreference", " samplesRef", "sipesRef", "sipesref", "sampsref", " sampsref", " sampsRef", "samplesRef"]}}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038, "substitutes": {"options": ["files", "null", "external", "this", "name", "js", "groups", "http", "cho", "ops", "ts", "acl", "rules", "ips", "data", "eps", "current", "flags", "com", "global", "results", "co", "objects", "ions", "ims", "parent", "op", "checks", "pos", "comments", "params", "none", "args", "details", "ents", "Options", "info", "settings", "style", "resources", "outs", "utils", "config", "ps", "ports", "opt", "errors", "names", "or", "self", "e", "es", "app", "cache", "public", "ors", "object", "exec", "o", "s", "issues", "events", "points", "os", "times", "changes", "io", "plugins", "option"], "errp": ["errP", "resultpc", "asterps", "erP", "armpre", "ierpe", "errorpat", "resultpre", "ierps", "rrpc", "ierf", " errpr", "errpe", "nerpc", " errpe", "errpc", "erpat", "rrP", "errorP", "armP", "ierpat", "nerpre", "nerpe", "resultf", "resultps", "ierP", "armpc", "asterpr", "err", " errps", " errP", "resultp", "asterf", "errr", "errps", "errpat", "resultpe", " errpc", "asterp", "errorp", "erp", "nerp", " errpre", "errpr", " errf", "errorr", "rrpre", "errf", "ierr", "errpre", "armp", "ierpr", "ierp", "rrp"], "ov": ["ob", "oa", "raft", "ow", "kov", "ant", "vo", "upp", "OV", "av", "oid", "opp", "boot", "ou", "ova", "ko", "off", "lov", "oo", "erv", "ove", "sv", "oyer", "obile", "ovo", "ocr", "oc", "uv", "up", "oval", "o", "orf", "iv", "nov", "ev", "od", "oy", "oven", "ovan", "oh", "rov", "obb"], "obj": ["ob", "oa", "so", "adj", "ctx", "act", "ass", "ops", "bo", "data", "oi", "n", "co", "alt", "objects", "dict", "opp", "aj", "fn", "cdn", "op", "arr", "tmp", "Obj", "j", "po", "output", "eff", "Object", "coll", "cb", "nt", "bj", "str", "utils", "ind", "block", "bot", "self", "attr", "cache", "oc", "object", "art", "o", "b", "os", "od", "val", "pt", "pp", "obb"], "qdict": ["eqdict", "pclean", "qpatch", "reqdict", "quclean", "pdict", " qdata", "rdict", "dqdata", "qdetails", "qudata", "qdata", "qudict", "sqdict", "rdetails", "quict", " qpatch", "dqpatch", "qucontainer", "qict", "pdata", " qcoll", "sqcontainer", "reqpatch", "qclean", "dqcoll", " qclean", "eqdata", "qcoll", "qcontainer", "sqict", "rdata", "qdf", " qdf", "dqdict", "rdf", "eqdetails", " qdetails", "reqcoll", "pdf", " qict", "reqdata", "sqdf", "eqdf", " qcontainer", "qudf"], "local_err": ["standard_er", "localallerr", "local_doc", "localererr", "locallystatus", "localedrr", "standardaller", "foreign_war", "standardallerr", "global_msg", "foreignallerr", " local_cr", "foreign_error", "standardallmr", "localallerror", "localermsg", "internal_rr", "foreignaller", "local_status", "global_err", "local_error", "locallyerr", "foreignallerror", "local_Er", "localerorig", "local_er", "global_orig", "local_war", "localaller", "foreign_er", "locallyconn", "local_msg", "local_mr", "local_rr", "internal_err", "global_error", " local_doc", "localedconn", "internal_conn", "foreign_err", "standard_Er", "localallEr", "localererror", "localedstatus", "local_conn", " local_error", "localallmr", "standardallEr", "internal_status", "localallwar", "foreignallwar", " local_er", "locallyrr", "localederr", "standard_mr", "local_cr", "standard_err", "local_orig"]}}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040, "substitutes": {}}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n", "idx": 1046, "substitutes": {"opaque": ["opacity", " opque", "opaques", "OPca", "OPacity", "operaques", "pque", "opca", "paques", "operaque", "OPaques", "ocaque", " opacity", "occa", "ocacity", "OPaque", "operacity", "pacity", " opca", " opaques", "paque", "opque", "operque", "ocaques"], "s": ["sg", "sup", "cs", "ss", "sa", "ts", "sb", "new", "r", "d", "n", "aws", "is", "sl", "i", "g", "m", "ses", "ls", "args", "sync", "sets", "ds", "ps", "gs", "ns", "c", "p", "state", "services", "e", "f", "es", "sq", "as", "o", "v", "su", "b", "S", "fs", "si", "sym", "ssl"], "data": ["to", "missing", "ata", "buffer", "att", "da", "def", "ops", "a", "dd", "array", "new", "d", "ad", "aws", "type", "results", "ins", "id", "na", "api", "next", "i", "in", "options", "params", "args", "info", "settings", "style", "str", "ds", "als", "config", "slice", "address", "and", "ns", "result", "alpha", "p", " Data", "state", "e", "input", "f", "es", "cache", "object", "DATA", "o", "as", "session", "valid", "al", "val", "dat", "Data", "start", "si", " DATA"], "ret": ["rot", "fun", "att", "mt", "ext", "bit", " Ret", "success", "ad", "ct", "alt", "cat", "cur", "rets", "num", "py", " RET", "j", "fail", "code", "ait", "ft", "nt", "rev", "err", "str", "tr", "reply", "Ret", "bf", "pat", "result", "fin", "len", "f", "ref", "art", "en", "sr", "failed", "RET", "serv", "t", "stop", "valid", "af", "re", "reg", "val", "rt", "pt", "repl", "det", "res", "db", "rc"]}}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056, "substitutes": {"s": ["sg", "submit", "js", "service", "this", "cs", "src", "http", "ss", "stat", "rs", "ts", "a", "sb", "r", "d", "n", "is", "i", "g", "m", "ses", "secure", "sf", "sync", "sv", "ds", "status", "ps", "gs", "native", "ns", "c", "p", "services", "state", "e", "self", "f", "es", "secondary", "us", "sys", "sq", "u", "south", "sec", "as", "o", "b", "S", "t", "os", "states", "fs", "sym", "ssl"], "buf": ["ff", "fd", "src", "buffer", "ctx", "bh", "bag", "array", "context", "queue", "done", "data", "header", "bc", "buff", "bin", "tmp", "cas", "batch", "rb", "code", "fp", "comb", "args", "cb", "func", "rc", "pad", "block", "Buffer", "vec", "cv", "f", "wb", "bd", "br", "mp", "cmd", "alloc", "seq", "b", "fb", "uf", "img", "fi", "map", "db", "mem"], "len": ["fun", "li", "a", "Len", "data", "url", "n", "fl", "ln", "id", "empty", "bin", "num", "j", "pos", "dy", "code", "ll", "coll", "nt", "err", "rev", "str", "ie", "l", "c", "ler", "e", "length", "f", "size", " length", "fin", "lc", "ref", "el", "obj", "cmd", "en", "v", "seq", "count", "val", "le"]}}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n", "idx": 1059, "substitutes": {"bc": ["fc", "cms", "isc", "cs", "ctx", "anc", "cc", "gc", "acl", "cl", "mc", "sb", "context", "com", "nc", "tc", "ac", "cb", "ec", "dc", "BBC", "c", "xc", "cv", "jc", "lc", "oc", "soc", "ca", "sc", "pc", "cca", "bb", "fb", "icc", "cf", "BC", "uc", "rc"]}}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060, "substitutes": {"s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "us", "self", "f", "set", "sys", "u", "fs", "parts", "spec", "ts", "sb", "uns", "xs", "sv", "request", "sets", "p", "state", "e", "conf", "as", "uses", "v", "less", "su", "site", "S", "os", "session", "t", "ks", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "i", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "south", "o", "si", "server", "service", "d", "sis", "comments", "details", "sync", "tests", "l", "services", "w", "stats", "b", "full", "states"], "blk": ["blck", "plmk", "slK", "plsk", "clks", "mlc", "blkt", "brks", "ilK", "blch", "slke", "clk", "plc", "slsk", " blok", "clkt", "mlch", "blmk", "plch", "Blks", "clb", "blks", "mlk", "clke", "slc", "clck", "ylk", "ilok", "slkt", "ilk", "ylmk", " blck", "mlks", "blke", " blmk", "clok", "ilks", "blsk", " blsk", "slch", "slks", "Blk", "ylks", "ilke", " blkt", "Blok", "plk", "blb", "plkt", "ilkt", "slok", "blK", "brke", "Blb", "brk", "slck", "brok", "plck", "plok", "blok", "slk", "plK", "plks", "ylke", "plke", " blks", " blke", "blc", " blb"], "kind": ["cost", "hack", "Kind", "name", "cycle", "kick", "shape", "spec", "ant", "device", "ke", "method", "sid", "data", "class", "d", "division", "type", "brand", "id", "head", "th", "k", "concept", "sk", "ko", "seed", "year", "instance", "need", "kt", "info", "mid", "coll", "direction", "style", "pod", "str", "impl", "ie", "step", "ind", "kid", "role", "dev", "plugin", "magic", "depth", "path", "engine", "mode", "good", "part", "dir", "start", "needed"], "version": ["stage", "vision", "server", "Version", "device", "image", "ver", "brand", "format", "id", "seed", "package", "rev", "description", "feature", "secret", "vers", "release", "scale", "iv", "plugin", "path", "product", "engine", "VERSION", "mode", "versions", "arch"], "serial": ["vision", "series", "pocket", "server", "social", "material", "micro", "primary", "local", "generic", "spec", "device", "zip", "major", "binary", "loc", "global", "flash", "initial", "package", "component", "phone", "bug", "standard", "pattern", "json", "ident", "description", "international", "dev", "random", "custom", "private", "length", "iso", "patch", "core", "machine", "power", "public", "driver", "error", "valid", "human", "specified", "mode", "io", "root", "normal", "mobile"], "model": ["vision", "media", "base", "server", "local", "generic", "models", "time", "device", "command", "method", "zip", "image", "type", "field", "Model", "format", "id", "parent", "package", "label", "language", "params", "company", "file", "sql", "python", "license", "style", "config", "json", "description", "feature", "vel", "control", "block", "automatic", "zero", "size", "length", "message", "machine", "where", "object", "library", "single", "module", "location", "path", "human", "product", "view", "mode", "install", "mobile"], "wwn": [" Warn", "awwn", "ewws", " Wwn", "wbnn", "wpgn", " Wiw", "hwn", " wgn", " wmn", "Warn", "warn", " wnn", "wpnn", "ewiw", "Wgn", "wpwn", "Wwn", "awws", " warn", "awiw", "hww", "ewwn", "wbmn", " wiw", "wbwn", "wws", "www", "wnn", "hiw", "wpmn", "awww", " Wgn", "ewww", "wmn", "wiw", "wgn", "Wiw", "wbgn", "hws"], "cylinders": ["ymiths", "cilcles", "cyinder", "galcles", "cyeds", "galinder", "quiths", "galeds", "silences", "quins", "silins", "cilinders", "ylences", "galinders", "quences", "cyliths", "siliths", "cyinders", "silinder", "cylisters", "silisters", "quinders", "cylinder", "cyleds", "silinders", "ciliths", "ymisters", "ylins", "cycles", "cilinder", "yliths", "cylences", "cilisters", "cylins", "yminders", "ylinders", "cileds", "yminder", "cylcles"], "heads": ["sections", "clips", "opens", "maps", "workers", "boards", "unks", "views", "members", "reads", "tracks", "devices", "ins", "kins", "head", "links", "hops", "cles", "locks", "ids", "checks", "frames", "bits", "holes", "shots", "mods", "sticks", "archs", "drivers", "planes", "lines", "eeks", "length", "height", "pages", "ints", "tails", "rows", "bands", "HEAD", "cycles", "blocks", "headers", "depth", "times", "tops", "olds", "versions", "nuts", "obs"], "secs": ["structds", "reqds", "seqes", "eces", "secp", "secds", "ctp", "secses", "cts", "incs", "reqs", "ctes", "secn", "ecses", "incn", "structn", "ctses", "ecs", "ecp", "reqd", "seqp", "reqn", "structd", "incds", "seces", "seqses", "secd", "incd", "structs", "seqs"], "chs_trans": ["chs_transfer", "chs_orig", "chs__rans", "chs__ctr", "chs2private", "chs2trans", "chs__transfer", "chs_tr", "chls_transfer", "chls_rans", "chns_translation", "chs_private", "chns_trans", "chs_translation", "chs2Trans", "chs2orig", "chls_trans", "chss_orig", "chs__trans", "chs_ctr", "chns_ctr", "chls_ctr", "chns_tr", "chss_private", "chss_Trans", "chss_trans", "chs_rans", "chs_Trans"], "nb_sectors": ["nb_sellers", "nb_ectors", "nb_pecs", "nb_locctors", "nb_nectors", "nb_sections", "nb_psectors", "nb_pections", "nb_ellers", "nb_secs", "nb_egments", "nb_pseors", "nb_psegments", "nb_pellers", "nb_locgment", "nb_pegments", "nb_spellers", "nb_gerets", "nb_pserets", "nb_ceors", "nb_gections", "nb_spelections", "nb_vectors", "nb_syctions", "nb_pectors", "nb_vections", "nb_selections", "nb_vedds", "nb_segment", "nb_sydds", "nb_locgments", "nb_gectors", "nb_sedds", "nb_syctors", "nb_negments", "nb_nerets", "nb_gegments", "nb_segments", "nb_vecs", "nb_serets", "nb_pedds", "nb_locors", "nb_seors", "nb_cegments", "nb_sycs", "nb_spegments", "nb_pelections", "nb_cectors", "nb_nections", "nb_elections", "nb_spectors", "nb_cegment", "nb_psections", "nb_psegment"]}}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 1089, "substitutes": {"dev": ["serial", "group", "cam", "def", "hw", "conn", "device", "mod", "data", "ad", "ver", "d", "di", "out", "der", "priv", "de", "grad", "client", "enc", "dom", "api", "Dev", "DEV", "info", "bug", "ch", "pub", "pad", "gu", "p", "block", "w", "prom", "app", "cache", "conf", "cmd", "wd", "die", "node", "v", "obj", "ev", "rad", "var", "od", "gen", "engine", "reg", "pro", "debug", "diff", "gd", "pack"], "iova": ["diov", "ioval", "diova", "abiovo", "sioca", "ioca", "uovi", "niovi", " iovan", "iovo", "uova", "niova", "iiera", "nioval", "abiovan", " ioca", "siovi", "niovan", "siov", "iovi", " iov", " iiera", "iaga", "siova", "uovan", "siovan", "diiera", "uovo", "uoval", "dioca", " iaga", "uaga", "siiera", "abiaga", "abiova", "sioval", "iov", "iovan", " iovo"], "len": ["zen", "base", "name", "li", "lan", "den", "conn", "Len", "data", "n", "lif", "lf", "dl", "ln", "sl", "lang", "fn", "enc", "bl", "lim", "pos", "lt", "rev", "lon", "l", "fin", "lc", "length", "size", "el", "en", "seq", "lin", "gen", "line", "ann", "val", "limit", "le"], "imsg": ["ipsgn", "imsgy", "imsb", "ssgt", "ubsgm", "fsgs", "ipsg", "ipsb", "ipsgt", "fsga", "igsgy", "igsgi", "omsgt", "imgi", "imsgt", "omsb", "fsg", "mesge", "omsgi", "omsgn", "umsgy", "omsgm", "umsgm", "fsge", "lsg", "ssb", "cmg", "ubsg", "imsgi", "imsge", "mesga", "igsg", "imgs", "imge", "cmgs", "mesg", "lsgm", "imsgs", "mesgi", "ssgn", "imsgn", "imsgm", "igsgm", "lsgi", "ssg", "umsgi", "cmga", "lsgn", "igsgn", "mesgs", "img", "imga", "cmgi", "umsg", "ubsgi", "ubsgy", "omsg", "imsga"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    uint32_t val;\n\n    val = gic_dist_readb(opaque, offset);\n\n    val |= gic_dist_readb(opaque, offset + 1) << 8;\n\n    return val;\n\n}\n", "idx": 1107, "substitutes": {"opaque": ["opacity", " opque", " opcode", "iopque", "hopec", "comphole", "iphole", "compacity", "operonymous", "hoponymous", "iopaque", "iponymous", "operaque", "opcode", "opace", " opacity", "hopaque", "ipec", "operec", "ipaque", "ipque", "operhole", "compaque", "opercode", "operacity", "oponymous", "ipace", " ophole", " opec", "hophole", "iopace", " opace", "opec", "compcode", "ophole", "opque", "iopec"], "offset": ["rot", "layer", "base", "server", "target", "image", "loc", "align", "operation", "position", "slot", "parent", "off", "initial", "i", "pos", "entry", "attribute", "sector", "index", "pointer", "address", "begin", "alpha", "p", "bound", "set", "length", "f", "reset", "size", "reference", "padding", "o", "point", "phase", "optional", "Offset", "error", "online", "location", "addr", "emb", "start", "port"], "val": ["unit", "_", "rot", "base", "arg", "vol", "ol", "key", "elt", "vals", "data", "vl", "ee", "loc", "Val", "fl", "alt", "slot", "sl", "py", "pre", "bl", "pos", "aval", "cond", "sel", "vel", "x", "ind", "p", "rl", "eval", "len", "ref", "la", "el", "value", "il", "v", "pc", "ay", "valid", "al", "let", "VAL", "rt", "pt", "all", "ot"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 1108, "substitutes": {"str": ["dr", "cs", "Str", "ss", "rs", "spec", "res", "expr", "r", "strings", "wrap", "sp", "orig", "cur", "arr", "kr", "enc", "pos", "frac", "hr", "stri", "code", "er", "fr", "cr", "tr", "temp", "index", "st", "pr", "start", "vec", "lc", "br", "text", "sc", "ctr", "exec", "obj", "sec", "sr", "seq", "req", "inst", "old", "line", "iter", "input", "STR", "est"], "endptr": ["adptr", "Endpointer", "Endptr", "pendPtr", "entprot", "pendproc", "startaddr", " endctr", "Endaddr", "pendctr", " endprot", "adPtr", "endedproc", "startPtr", "endpoint", "endproc", "endctr", "endedptr", "pendpoint", "endpointer", "adpointer", "entPtr", "EndPtr", "endedctr", " endproc", "endedPtr", "entpoint", " endpoint", "endaddr", "pendptr", "pendprot", "endprot", " endPtr", "endPtr", "entptr", "startptr", "startpointer", "adaddr"], "err": ["dr", "ise", "rage", "ner", "gr", "Error", "rr", "out", "ver", "r", "der", "lr", "arr", "code", "er", "fr", "cr", "cb", "result", "ind", "c", "or", "pr", "ler", "order", "try", "e", "aster", "ctr", "cache", "ar", "resp", "die", "mr", "error", "rx", "var", "req", "Er", "msg", "iter", "rh", "res", "rc"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "PXA2xxState *pxa255_init(unsigned int sdram_size)\n\n{\n\n    PXA2xxState *s;\n\n    int iomemtype, i;\n\n    DriveInfo *dinfo;\n\n\n\n    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n\n\n\n    s->env = cpu_init(\"pxa255\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n\n                    qemu_ram_alloc(NULL, \"pxa255.sdram\",\n\n                                   sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n\n                    qemu_ram_alloc(NULL, \"pxa255.internal\",\n\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n\n                              s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n\n        if (serial_hds[i]) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 1);\n\n#else\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 0);\n\n#endif\n\n        } else {\n\n            break;\n\n        }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base,\n\n                                   s->pic[pxa255_ssp[i].irqn]);\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                             s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n\n                    pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 1119, "substitutes": {"sdram_size": ["sdram2length", "sdmem_base", "sdramlenbase", "sdram2size", "sdram64base", "sdramlensize", "sdram_capacity", "sdram64address", "sdram67number", "sdmem_number", "sdram64SIZE", "sdram67size", "sdmem_length", "sdram_length", "sdramlenaddress", "sdramlogcapacity", "sdram_number", "sdram67capacity", "sdmem_adjust", "sdram67adjust", "sdramlognumber", "sdram_SIZE", "sdramlogadjust", "sdmem_capacity", "sdmem_SIZE", "sdmem_address", "sdram2SIZE", "sdram64size", "sdram_base", "sdramlogsize", "sdram_address", "sdramlenSIZE", "sdmem_size", "sdram_adjust"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "args", "sie", "f", "set", "sys", "u", "sum", "socket", "fs", "spec", "ts", "sb", "ims", "y", "uns", "xs", "sets", "p", "state", "e", "conf", "su", "site", "S", "os", "session", "t", "its", "in", "sym", "ssl", "cs", "ss", "rs", "new", "data", "r", "is", "ins", "m", "settings", "ps", "gs", "ns", "c", "es", "south", "o", "si", "server", "service", "d", "scope", "params", "sync", "status", "l", "services", "sq", "stats", "b", "full", "states"], "iomemtype": ["_umdesc", "iotunt", "_eetype", "_umt", "_emtypes", "iotemt", "_umtype", "_emt", "_emtype", "_untypes", "_eet", "iotundesc", "_unt", "iotuntypes", "_emdesc", "iotuntype", "_undesc", "iotemtypes", "iotemdesc", "_untype", "_eetypes", "iotemtype", "_umtypes", "_eedesc"], "i": ["yi", "li", "gi", "ni", "ii", "zi", "chi", "ji", "oi", "r", "d", "I", "n", "id", "mi", "iu", "j", "y", "m", "ri", "eni", "info", "ti", "ini", "index", "multi", "z", "ai", "ie", "ip", "ind", "c", "p", "phi", "bi", "l", "x", "e", "f", "hi", "adi", "u", "v", "qi", "ix", "b", "t", "uri", "ci", "mu", "si", "xi"], "dinfo": ["minfo", "dstate", "mhelp", "dstatus", "dinter", " dfi", "dninfo", " dstate", "derror", "dbinf", "vdinf", "finfo", " dstatus", " dhelp", "sdobj", "rdinfo", "minter", "sderror", " dinter", "dbinfo", "finit", "sdinf", "dhelp", " dinf", "vderror", "dinf", "rdinf", " derror", "sdinter", "dinit", "dbstate", "sdinfo", "sdfi", "dobj", " dobj", "dninf", "dnstatus", "finf", "dbstatus", "dnstate", "rdobj", " dinit", "vdinit", "dfi", "sdhelp", "vdinfo", "rdfi", "merror"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 1121, "substitutes": {"busnr": ["usbnl", "bridgenl", "bridgenor", "bootnr", "usbnor", "pluginnb", "pluginsn", "bootnb", "bridgern", "usbnr", "busnor", "portnb", "booteno", " busnor", " busrn", "bussn", "bridgenr", "busnl", "usbrn", "busrn", "portnr", "pluginnr", "plugineno", " busnl", "bootsn", "porteno", "buseno", "portsn", "busnb"], "addr": ["oa", "route", "dr", "layer", "name", "src", "att", "lan", "offset", "ext", "inter", "dd", "conn", "alias", "host", "sid", "rr", "loc", "ad", "add", "id", "ord", "adr", "pos", "code", "nr", "aid", "address", "ange", "pad", "ip", "ptr", "hop", "len", "ref", "attr", "arm", "ar", "eth", "wd", "amp", "nm", "prefix", "amd", "at", "rx", "uri", "rt", "mode", "vr", "ace", "rc"], "bus": ["pl", "base", "mount", "service", "lock", "this", "http", "ass", "bit", "device", "Bus", "host", "class", "ver", "use", "cat", "BUS", "ash", "bc", "bin", "parent", "boot", "loop", "pos", "ac", "proc", "plug", "pod", "nt", "bug", "sync", "config", "bas", "feed", "home", "block", "p", "book", "us", "self", "band", "pu", "front", "cache", "vc", "lib", "bridge", "b", "plugin", "os", "session", "bs", "usb", "lab", "root", "io", "se", "board", "db", "pack"], "port": ["ort", "test", "mount", "service", "target", "device", "host", "class", "tag", "ver", "type", "prop", "id", "parent", "op", "api", "pre", "next", "po", "component", "proxy", "Port", "pipe", "proc", "forward", "pod", "project", "bug", "ports", "pid", "pool", "config", "pointer", "post", "address", "step", "ip", "trans", "p", "pr", "pad", "hop", "per", "patch", "contract", "object", "fat", "wd", "art", "driver", "pc", "point", "cp", "PORT", "t", "plugin", "option", "path", "pro", "pt", "part", "export", "pp", "user"], "dev": ["fo", "flow", "test", "adv", "name", "cam", "def", "dd", "conn", "device", "mod", "host", "mem", "data", "desc", "ver", "ad", "di", "d", "prop", "av", "priv", "der", "dom", "Dev", "DEV", "ve", "info", "bug", "md", "ch", "pub", "gu", "p", "w", "prom", "pu", "ref", "app", "conf", " info", "own", "cache", " device", "wd", "driver", "v", "comment", "ev", "rad", "inst", "var", "od", "error", "pro", "dist", "debug", "diff", "fi", "user"], "nused": ["snusage", "snusable", "nactive", "nusable", "snused", "Nused", "nusage", "Nusage", " nusable", " nusage", " nactive", "Nactive", "Nusable", "snactive"], "nfree": ["nbavailable", "nbfree", "pavailable", " nFree", "nFree", "nusable", "nbFree", "navailable", "pFree", " nusable", "nbusable", "pfree", " navailable", "pusable"]}}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n", "idx": 1122, "substitutes": {"v": ["q", "r", "d", "vim", "k", "env", "i", "j", "g", "m", "sv", "vv", "x", "l", "c", "p", "h", "vs", "w", "e", "gu", "f", "self", "u", "uv", "V", "value", "o", "vis", "iv", "b", "vi", "t", "lv", "var", "tv", "val"], "name": ["named", "time", "key", "a", "alias", "data", "new", "n", "type", "id", "parent", "common", "num", "label", "none", "info", "style", "names", "word", "x", "Name", "w", "f", "size", "ame", "comment", "o", "prefix", "var", "path", "nice", "part", "NAME", "desc"], "obj": ["ob", "oa", "orb", "js", "so", "adj", "offset", "alt", "objects", "otype", "fn", "xy", "arr", "tmp", "Obj", "j", "bl", "po", "pos", "rb", "args", "Object", "eff", "cb", "bj", "func", "foo", "ns", "block", "ref", "br", "object", "o", "lib", "prefix", "os", "pt", "emb", "obb"], "errp": ["Erc", "erc", "Ererror", "ererror", "erf", " errf", "Erp", "errf", "errc", "Erf", "erp", "errerror", " errc", " errerror"], "qov": ["qav", "quou", "fova", "ixovan", " qav", "quvo", "idova", "fov", "quov", "idov", "ixov", "idovo", "idvo", "fovo", "qova", "qou", "ixav", "quova", "fvo", "qovo", "qovan", "quovo", "quovan", "quav", " qovan", "ixou", " qou", "qvo"]}}
{"project": "qemu", "commit_id": "0e01b76e7cc43068f6b8cc05297f61539ccd5279", "target": 1, "func": "static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CqP:z\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'z':\n\n            ctx->zflag = 1;\n\n            break;\n\n        default:\n\n\n            return qemuio_command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return qemuio_command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    if (ctx->zflag && optind != argc - 2) {\n\n        printf(\"-z supports only a single length parameter\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag && ctx->Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag) {\n\n        int64_t count = cvtnum(argv[optind]);\n\n        if (count < 0) {\n\n            print_cvtnum_err(count, argv[optind]);\n\n\n            return 0;\n\n        }\n\n\n\n        ctx->qiov.size = count;\n\n        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,\n\n                             aio_write_done, ctx);\n\n    } else {\n\n        nr_iov = argc - optind;\n\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n\n                                pattern);\n\n        if (ctx->buf == NULL) {\n\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n            return 0;\n\n        }\n\n\n\n        gettimeofday(&ctx->t1, NULL);\n\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                         BLOCK_ACCT_WRITE);\n\n\n\n        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,\n\n                       ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    }\n\n    return 0;\n\n}", "idx": 1130, "substitutes": {"blk": ["blck", "slK", "clks", " blK", "blkt", "brsk", "clK", "ilsk", "Blsk", " blc", "slsk", "clk", "plc", " blok", "ilc", "plq", "plkk", "Blkk", "Blks", "BLks", " blb", "BLk", "plb", "slc", "slkt", "ilk", " blck", "blq", "brck", "ilb", "clok", "blsk", " blsk", "slb", "slks", "Blk", " blkt", "plk", "slok", "blK", "blb", "plkt", "ilkt", "Blkt", "brk", "ilq", "plck", "Blck", "blok", "slk", "slq", "plks", "blkk", "BLkk", "brkt", " blks", "BLck", "blc", "blks"], "argc": ["Argv", "argumentv", "argn", "agv", " argch", "argsl", "axl", " argl", "gc", "agch", "argch", "Arglc", "arglc", "gf", "argsch", "agl", "Argc", "agp", "memf", "Argn", " argn", "argumentc", "gv", "axp", "axc", "agc", "Argf", "memv", "argl", "argumentl", " arglc", "memc", "axv", "Argl", "axf", "memlc", " argf", "argsv", "gl", " argp", "argumentn", "argsc", "argf", "argp"], "argv": ["Argv", "argumentv", "Argve", " argl", "arkvs", "ArgV", " argb", "Argb", "Argc", " argve", "argV", "argumentc", "argsp", " argvs", "arkc", "argve", "axp", "axc", "Argf", "argumentp", "arkp", "argl", "argumentl", "arkv", "axv", "Argl", " argf", "argsv", " argV", "argb", "Argp", "argumentV", "argsf", " argp", "argsc", "argvs", "argsvs", "argf", "argumentb", "axve", "argsb", "argp"], "nr_iov": ["nr_uni", "nr_iop", "nr_nox", "nr1iov", "nr_ovi", "nr1iop", "NR_nox", "nr1iol", "nr_sbm", "usr_iov", "nr__iol", "nr__uni", "NR_ovi", "nr__iov", "usr_iol", "usr_uni", "nr__iop", "nr_iol", "usr_iop", "NR_iov", "nr1uni", "NR_sbm"], "c": ["cm", "cs", "q", "channel", "cc", "mc", "r", "d", "n", "cur", "cy", "k", "end", "enc", "i", "g", "ac", "m", "code", "cb", "cr", "ch", "C", "ec", "dc", "ce", "cu", "p", "xc", "l", "e", "lc", "f", "sc", "ca", "u", "cmd", "o", "pc", "cit", "s", "v", "cp", "b", "t", "cf", "cmp", "ci", "count"], "ctx": ["cli", "cal", "command", "acl", "flags", "nc", "client", "g", "chan", "cu", "cv", "css", "sys", "sc", "wcs", "jp", "vc", "cca", "s", "qa", "cp", "seq", "all", "wx", "cms", "anc", "context", "bc", "id", "cas", "component", "fp", "tx", "xs", "kw", "utils", "pkg", "lc", "unc", "lib", "anon", "sci", "qq", "fc", "cm", "np", "cs", "cc", "fw", "r", "loc", "out", "ck", "voc", "instance", "cb", "gs", "xc", "cmd", "obj", "connection", "prefix", "cf", "conv", "_", "kb", "hw", "conn", "cus", "auc", "sync", "number", "config", "block", "cn", "ca", "ctrl", "sq", "exec", "git", "cmp", "support", "ci", "cfg", "console", "rc"], "optind": ["extinn", "extid", "optionrib", "optinn", "expInd", "optimind", "optionid", "optionIND", "opinc", "origIND", "parentInd", "octInd", "origrib", "extinc", "optid", "ropInd", "optimInd", "optrib", "extind", "opend", "optii", "ropind", "optinc", "optend", "origind", "ropina", "optimnd", "opInd", "expinc", "extIND", "optimIND", " optid", "optann", "octind", "opint", "optnd", "optionind", "optionii", "optioninc", "octinn", "expind", "optionina", "origann", "parentind", "parentinn", "optInd", "opind", "origInd", "optimint", "opina", "optionnd", "ropnd", " optInd", "opnd", "expIND", " optann", "optionint", "optint", "optiminc", " optrib", "optionann", " optii", "optimend", "extInd", "optionend", "origii", "octinc", "optionInd", " optIND", "parentinc", "optIND", "optina"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n    int64_t cluster_index, uint16_t **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                 (void**) refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1136, "substitutes": {"bs": ["ob", "base", "js", "cs", "abi", "bh", "ss", "http", "sa", "sb", "bps", "lb", "bm", "BS", "aws", "bc", "banks", "pb", "fps", "bl", "bis", "locks", "plugins", "ls", "ses", "sync", "cb", "outs", "ds", "bas", "gs", "ns", "css", "vs", "bi", "bos", "gb", "lbs", "bb", "blocks", "stats", "fb", "b", "iss", "ubs", "os", "ks", "las", "bytes", "bes", "fs", "db", "obs"], "cluster_index": ["clusteridsize", "cluster_image", "cluster_column", "cluster67image", "clusterCimage", "clusters_size", "clusteridoffset", "cluster00index", "clusterCindex", "clusteridindex", "cluster_design", "cluster67size", "cluster_offset", "clue_number", "cluster_label", "clue67label", "clusters_index", "clue_label", "clue67design", "clue_index", "clusters_offset", "cluster00design", "cluster_size", "clusterCsize", "cluster67number", "cluster_number", "cluster_height", "cluster67offset", "cluster67label", "cluster67design", "clusters_image", "clue_design", "clue67number", "clue67index", "clusteridheight", "cluster_id", "cluster67index", "clusterCoffset", "cluster00number", "cluster00label"], "refcount_block": ["refcount00ver", "refcount_type", "refsize_type", "refcount\u00b7row", "refount_lock", "reflist64view", "refcount67type", "reftype_ver", "refcount64block", "refcount\u00b7lock", "reflist64section", "refcountsblock", "refcount_ver", "reflist_block", "reflist_container", "reftype_container", "reflist_view", "reftype_lock", "reftype_block", "refcountsrow", "refcount67header", "reftype00ver", "refcount_section", "refsize_header", "refount_row", "reftype00container", "refount_table", "refcount67block", "refcount___container", "refcount00block", "reflist_section", "refcount___view", "refcount\u00b7block", "refcount\u00b7condition", "refcount_header", "refount_block", "refcount___block", "refcountslock", "refount_type", "refcountscondition", "refount_condition", "refcount00lock", "reflist64container", "refcount_container", "refcount_condition", "refsize_block", "refcount_lock", "refcount___section", "refcount00container", "reftype00block", "refcount64container", "refcount_view", "refcount64section", "refcount64view", "reftype00lock", "refcount_table", "refcount_row", "refcount64ver", "refcount64lock", "reflist64block"], "s": ["js", "service", "cs", "http", "ss", "spec", "sa", "qs", "ts", "sb", "rs", "self", "aws", "is", "ins", "sl", "ims", "bis", "g", "ses", "ls", "uns", "sync", "settings", "sv", "outs", "ds", "status", "sets", "ps", "gs", "xs", "storage", "ns", "l", "c", "p", "sie", "state", "services", "e", "vs", "f", "es", "secondary", "sys", "sq", "css", "us", "south", "comm", "iss", "stats", "less", "b", "site", "S", "su", "t", "os", "ks", "full", "its", "states", "fs", "si", "sym", "parts", "ssl"], "refcount_table_index": ["refcount_cache_level", "refcount_tablePindex", "refcount_chain_position", "refcount_cache_index", "refcount_table_position", "refcount_cache_height", "refcount_tablePsize", "refcount_table_offset", "refcount_tablePheight", "refcount_cache_length", "refcount_table_ind", "refcount_chain_offset", "refcount_table_data", "refcount_chain_index", "refcount_cache_i", "refcount_table_size", "refcount_table_i", "refcount_cache_slice", "refcount_table_height", "refcount_chain_size", "refcount_tablePlevel", "refcount_table_length", "refcount_table_level", "refcount_cache_ind", "refcount_cache_data", "refcount_table_slice", "refcount_cache_size"], "ret": ["match", "arg", "fun", "no", "att", "mt", "ext", "def", "bit", "conn", "hash", " Ret", "success", "out", "alt", "cat", "job", "rets", "end", "num", " RET", "rb", "code", "lt", "info", "nt", "ft", "rev", "back", "reply", "feat", "Ret", "bf", "pub", "last", "result", "fin", "len", "flag", "ref", "reset", "red", "gt", "value", "art", "obj", "en", "sr", "RET", "error", "lit", "reg", "re", "val", "rt", "count", "pt", "let", "part", "det", "res", "db", "rc", "mem"]}}
{"project": "FFmpeg", "commit_id": "95801b6a0727d6f7e6f1204ce812b1e81613307d", "target": 1, "func": "static int alac_decode_frame(AVCodecContext *avctx,\n\n                             void *outbuffer, int *outputsize,\n\n                             const uint8_t *inbuffer, int input_buffer_size)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n\n\n    int channels;\n\n    unsigned int outputsamples;\n\n    int hassize;\n\n    int readsamplesize;\n\n    int wasted_bytes;\n\n    int isnotcompressed;\n\n    uint8_t interlacing_shift;\n\n    uint8_t interlacing_leftweight;\n\n\n\n    /* short-circuit null buffers */\n\n    if (!inbuffer || !input_buffer_size)\n\n        return input_buffer_size;\n\n\n\n    /* initialize from the extradata */\n\n    if (!alac->context_initialized) {\n\n        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: expected %d extradata bytes\\n\",\n\n                ALAC_EXTRADATA_SIZE);\n\n            return input_buffer_size;\n\n        }\n\n        if (alac_set_info(alac)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: set_info failed\\n\");\n\n            return input_buffer_size;\n\n        }\n\n        alac->context_initialized = 1;\n\n    }\n\n\n\n    init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);\n\n\n\n    channels = get_bits(&alac->gb, 3) + 1;\n\n    if (channels > MAX_CHANNELS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"channels > %d not supported\\n\",\n\n               MAX_CHANNELS);\n\n        return input_buffer_size;\n\n    }\n\n\n\n    /* 2^result = something to do with output waiting.\n\n     * perhaps matters if we read > 1 frame in a pass?\n\n     */\n\n    skip_bits(&alac->gb, 4);\n\n\n\n    skip_bits(&alac->gb, 12); /* unknown, skip 12 bits */\n\n\n\n    /* the output sample size is stored soon */\n\n    hassize = get_bits1(&alac->gb);\n\n\n\n    wasted_bytes = get_bits(&alac->gb, 2); /* unknown ? */\n\n\n\n    /* whether the frame is compressed */\n\n    isnotcompressed = get_bits1(&alac->gb);\n\n\n\n    if (hassize) {\n\n        /* now read the number of samples as a 32bit integer */\n\n        outputsamples = get_bits_long(&alac->gb, 32);\n\n        if(outputsamples > alac->setinfo_max_samples_per_frame){\n\n            av_log(avctx, AV_LOG_ERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfo_max_samples_per_frame);\n\n            return -1;\n\n        }\n\n    } else\n\n        outputsamples = alac->setinfo_max_samples_per_frame;\n\n\n\n    if(outputsamples > *outputsize / alac->bytespersample){\n\n        av_log(avctx, AV_LOG_ERROR, \"sample buffer too small\\n\");\n\n        return -1;\n\n    }\n\n\n\n    *outputsize = outputsamples * alac->bytespersample;\n\n    readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1;\n\n\n\n    if (!isnotcompressed) {\n\n        /* so it is compressed */\n\n        int16_t predictor_coef_table[channels][32];\n\n        int predictor_coef_num[channels];\n\n        int prediction_type[channels];\n\n        int prediction_quantitization[channels];\n\n        int ricemodifier[channels];\n\n        int i, chan;\n\n\n\n        interlacing_shift = get_bits(&alac->gb, 8);\n\n        interlacing_leftweight = get_bits(&alac->gb, 8);\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            prediction_type[chan] = get_bits(&alac->gb, 4);\n\n            prediction_quantitization[chan] = get_bits(&alac->gb, 4);\n\n\n\n            ricemodifier[chan] = get_bits(&alac->gb, 3);\n\n            predictor_coef_num[chan] = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = 0; i < predictor_coef_num[chan]; i++)\n\n                predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16);\n\n        }\n\n\n\n        if (wasted_bytes)\n\n            av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented, unhandling of wasted_bytes\\n\");\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            bastardized_rice_decompress(alac,\n\n                                        alac->predicterror_buffer[chan],\n\n                                        outputsamples,\n\n                                        readsamplesize,\n\n                                        alac->setinfo_rice_initialhistory,\n\n                                        alac->setinfo_rice_kmodifier,\n\n                                        ricemodifier[chan] * alac->setinfo_rice_historymult / 4,\n\n                                        (1 << alac->setinfo_rice_kmodifier) - 1);\n\n\n\n            if (prediction_type[chan] == 0) {\n\n                /* adaptive fir */\n\n                predictor_decompress_fir_adapt(alac->predicterror_buffer[chan],\n\n                                               alac->outputsamples_buffer[chan],\n\n                                               outputsamples,\n\n                                               readsamplesize,\n\n                                               predictor_coef_table[chan],\n\n                                               predictor_coef_num[chan],\n\n                                               prediction_quantitization[chan]);\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR, \"FIXME: unhandled prediction type: %i\\n\", prediction_type[chan]);\n\n                /* I think the only other prediction type (or perhaps this is\n\n                 * just a boolean?) runs adaptive fir twice.. like:\n\n                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)\n\n                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)\n\n                 * little strange..\n\n                 */\n\n            }\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        int i, chan;\n\n        for (i = 0; i < outputsamples; i++)\n\n            for (chan = 0; chan < channels; chan++) {\n\n                int32_t audiobits;\n\n\n\n                audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size);\n\n                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);\n\n\n\n                alac->outputsamples_buffer[chan][i] = audiobits;\n\n            }\n\n        /* wasted_bytes = 0; */\n\n        interlacing_shift = 0;\n\n        interlacing_leftweight = 0;\n\n    }\n\n    if (get_bits(&alac->gb, 3) != 7)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\");\n\n\n\n    switch(alac->setinfo_sample_size) {\n\n    case 16:\n\n        if (channels == 2) {\n\n            reconstruct_stereo_16(alac->outputsamples_buffer,\n\n                                  (int16_t*)outbuffer,\n\n                                  alac->numchannels,\n\n                                  outputsamples,\n\n                                  interlacing_shift,\n\n                                  interlacing_leftweight);\n\n        } else {\n\n            int i;\n\n            for (i = 0; i < outputsamples; i++) {\n\n                int16_t sample = alac->outputsamples_buffer[0][i];\n\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n\n            }\n\n        }\n\n        break;\n\n    case 20:\n\n    case 24:\n\n        // It is not clear if there exist any encoder that creates 24 bit ALAC\n\n        // files. iTunes convert 24 bit raw files to 16 bit before encoding.\n\n    case 32:\n\n        av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8 - get_bits_count(&alac->gb));\n\n\n\n    return input_buffer_size;\n\n}\n", "idx": 1137, "substitutes": {"avctx": ["afconfig", "evctx", "abca", "evcontext", "afsci", "avnas", "AVctx", "awconfig", "avecu", "avectx", "abcu", "avsci", "avconn", "afcas", "afcmp", "afctx", "afcontext", "avtx", "afcli", "navctx", "avcli", "aftx", "AVcmp", "awcu", "avalcmp", " avcontext", " avtx", "evcas", "aveca", "adcas", "navnas", "afnas", "afclient", "AVsci", " avcas", "awcontext", "awcas", "afconn", "avalsci", "AVcontext", "adctx", "navclient", "abctx", "avalcli", "afcu", "navcontext", "adcontext", "evclient", "abconfig", "avconfig", "avalcontext", "avcontext", "avca", "abcontext", "adtx", "avecontext", "evconn", "navconn", "afca", "avcu", "navcli", "avclient", "awctx", "awconn", "avcmp", "avalnas", "avcas", "avalctx"], "outbuffer": ["bootwindow", " outbuf", "Outbuf", "Outwindow", "outwindow", "Outbuffer", " outheader", "outheader", " outwindow", "bootbuf", "bootheader", "Outheader", "outbuf", "bootbuffer"], "outputsize": ["inputlength", "inputSize", "writeSize", "blocksize", "writelength", "writeSIZE", "blockSIZE", "inputSIZE", "outputSIZE", "outputSize", "outputlength", "writesize", "inputsize", "blocklength", "blockSize"], "inbuffer": [" insource", "inbuff", "insource", " inlength", "inputbuf", "conbuff", "outqueue", "inbuf", "Inqueue", "insidebuffer", "outbuf", "conbuffer", "inlength", " inbuff", "inputbuffer", "inputqueue", "insidelength", " inbuf", "inqueue", "outsource", "conbuf", "Insource", "Inbuffer", "insidebuff", "conlength", "insidebuf", " inqueue"], "input_buffer_size": ["input_buffer64size", "input_buffer_large", "input_bufferalllength", "input_buffer00large", "input_bufferalldepth", "input_buffer_SIZE", "input_buffer00size", "input_buffer_depth", "input_buffer_source", "input_buf_size", "input_file_size", "input_batch_size", "input_buffer64capacity", "input_file_length", "input_bufferallsize", "input_buffer_capacity", "input_byte_capacity", "input_byte_length", "input_buffer_small", "input_bufferlexcache", "input_batch_width", "input_buffer64width", "input_file_large", "input_batch64width", "input_buffer_width", "input_queue_SIZE", "input_bufferpsize", "input_buffer_length", "input_file_source", "input_buf_source", "input_batch64size", "input_buffer_cache", "input_buf_scale", "input_queue_offset", "input_queue_width", "input_bufferpsmall", "input_buffer00source", "input_buf_cache", "input_batch64capacity", "input_buffer_scale", "input_bufferlexsize", "input_buffer_offset", "input_file_depth", "input_byte_size", "input_queue_small", "input_bufferpoffset", "input_bufferlexscale", "input_queue_size", "input_batch_capacity", "input_bufferlexsource"], "alac": ["galacs", "Alanc", "isalmac", "this", "aliiac", "realac", "ialac", "alacs", "avack", "alc", " aloc", "Alacs", "advaut", "baliac", "alang", "avmac", " almac", " alican", "aliAC", " alacs", "almac", "salacl", "feed", "isalc", "elc", " almc", "avmc", "palmac", "alAC", "Alax", "alioc", "attain", "aldisc", "alacl", "galac", "realanc", "all", "elacl", " alacc", "calmac", "Aliac", "salac", "malAC", "alain", "alsax", "avain", "dalanc", " alec", "attacc", "isalaco", "avac", "dalack", "elAC", "buf", "isalmc", "ialAC", "alican", "aliac", "malacc", "malunc", "ilac", " alAC", "ellanc", "alsac", "length", "Alac", "maloc", "advanc", "ilmac", "alacc", "avacs", "alax", "elliac", "avican", "balac", " alaco", " alaut", "alact", "eldisc", "realacs", "elunc", "palanc", "baloc", "ellacs", "galacc", "alanc", "eliac", "advack", "elac", "ialax", "advac", "AlAC", "alaut", "advec", "alunc", "calacs", "maliac", "avaut", "realiac", "calanc", "alec", "alack", "elacc", "elact", "elmac", "palac", " alacl", "ilanc", " alact", "elaco", "alaco", "baldisc", "alsacc", "_", " alanc", "calain", " alax", "galax", " alang", "eloc", "isalac", "palacc", " aliac", " alc", "isalang", "saloc", "calec", "attac", "avanc", "almc", "aliacc", "isalacc", "calac", "dalaut", "dalac", "aliact", "alsacs", "calacc", "calaut", "attacs", " alunc", "ilican", "ialacs", "alidisc", "avang", "ellac", "elanc", "avacc", "malac", "salacc", "aloc"], "channels": ["banguages", "changuages", "echorts", " chars", "charains", "chrones", " chrones", "bapters", "Chunks", "Chrones", "chunks", " chunks", "chapters", " charms", "contannels", "charapters", " chrons", "controns", "Chrons", "contrones", "chars", " chorts", "chrons", "phorts", "CHapters", "contunks", "bains", "Channels", "charannels", "CHannels", "chorts", "phars", "pharms", "charms", "echannels", "echars", "charanguages", "phannels", "chains", "CHanguages", "echarms", "bannels", "CHains"], "outputsamples": ["outputSongs", "outputdamps", "outputsills", "outputstringsamples", "outputssamples", "outputinsances", "outputpamples", "responseportsocks", "outsamps", " outputssamps", "inputsamples", "outputsetsamples", "outinsongs", "outputpomes", "outputssample", "outinsances", "outputportsills", " outputfamps", "responsesills", "outputwsamps", " outputssomes", "outputdessions", "outputSamps", "outsamples", "outputsances", "outputsucks", "outputssamps", "inputpongs", "outputsessions", "inputpample", " outputfessions", "outputwsessions", "responseportsamples", "outputsample", "responsesocks", "outputsetsongs", "outputinsamps", " outputsample", "outputsocks", "outputsysomes", "outputwsamples", "outputfamples", "responseportsources", "outputssomes", "inputsongs", "responsesamples", "outsances", "responsesources", " outputssample", "outsongs", "outputsongs", "outputpample", "outputpances", "outinsamps", "responseportsills", "outputducks", "outputportsources", "outputfocks", "outputsources", "outinsamples", "outputpamps", "outputfessions", "outputstringsources", "outputSances", " outputfamples", "outputsysample", " outputsomes", "outputportsocks", "outputfamps", "inputpamples", " outputsamps", " outputsessions", " outputfucks", "outputSample", "outputfources", "outputstringsills", "inputsample", "outputsomes", "outputfills", "outputstringsocks", "outputSamples", "outputwsucks", "outputsysamps", "outputdamples", "outputfucks", "outputpongs", "outputinsongs", "outputportsamples", " outputssamples", "outputsetsample", " outputsucks", "outputsysamples", "outputinsamples", "outputsamps"], "hassize": ["chasssize", "Hassizes", "hasssize", "hyantssize", "harsizes", "hyassolve", "chassense", "halsize", "hactsizes", "hyantsolve", "hactsizable", "hyassize", "Hassize", "hassense", "chassize", "Harsizes", "hassesense", "hyantsize", "Harsizable", "Harsize", "hattsolve", "hassolve", "halsense", "harsense", "hassesizable", "hassizable", "Harsizing", "hantsolve", "hassessize", "chassesense", "hantsization", "chassesizable", "hantsize", "hactsize", "hattsization", "hyassization", "hyantsization", "hantssize", "harsize", "hacksizes", "hassesize", "harsizing", "chassesize", "chassizable", "hattsize", "chassessize", "hactsizing", "Hassizing", "hyasssize", "harsizable", "hassization", "hassesization", "halssize", "hassesolve", "hassizes", "harssize", "Hassizable", "hassizing", "hattssize", "hacksize", "hacksizable", "hacksizing", "halsizable"], "readsamplesize": ["wourcesize", "wsamplesized", "wviewsizer", "wviewsIZE", "wamplesizer", "wsourcesize", "wsamplesize", "wviewsize", "wsourcesized", "wamplesIZE", "wourcesIZE", "wourcesized", "wamplesized", "wviewsized", "wsourcesIZE", "wourcesizer", "wsamplesIZE", "wsamplesizer", "wamplesize", "wsourcesizer"], "wasted_bytes": ["wasted_seconds", "wasted_bits", "wasted__bytes", "wanted_bytes", "wasted__pieces", "wasted_pieces", "wastered_bytes", "wastered_bits", "wanted_codes", "wastered_blocks", "wasted__bits", "wastered_seconds", "wanted_bits", "wanted_pieces", "wasted_blocks", "wasted_codes", "wasted__codes"], "isnotcompressed": ["isnotcomposed", "isnotcondression", "isnotparlied", "isnotparressed", "isnotcondressed", "isnotComplied", "isnotexpacted", "isnotCompress", "isnotcondacted", "isnotCompressed", "isnotparress", "isnotcomplied", "isnotcondosed", "isnotcompression", "isnotcompacted", "isnotexposed", "isnotComposed", "isnotexpressed", "isnotcompress", "isnotsuppression", "isnotCompacted", "isnotCompression", "isnotexpression", "isnotparression", "isnotsuppressed", "isnotsuppress", "isnotsupplied"], "interlacing_shift": ["interlacing_offset", "interlating_offset", "interlating_shift", "interlacing___offset", "interlacing___align", "interlacing___reset", "interlacing___shift", "interlating_reset", "interlating_align", "interlacing_align", "interlacing_reset"], "interlacing_leftweight": ["interlacing_pushweight", "interlacing_lowwp", "interlacing_leftwp", "interlacing_lowshift", "interlacing_pushw", "interlacing_loww", "interlacing_lshift", "interlacing_leftw", "interlacing_pushshift", "interlacing_lweight", "interlacing_leftshift", "interlacing_pushwp", "interlacing_lowweight", "interlacing_lwp", "interlacing_lw"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n", "idx": 1145, "substitutes": {"argc": ["axdc", "argn", " argct", "arkci", "agv", "axci", "arglc", " argdc", "argct", "axlc", "axct", "axn", " argci", "argpc", "cmdc", "argci", " argn", "arklc", "arkc", "axc", "aglc", "agc", "cmddc", " arglc", "argdc", "agf", "axpc", "axv", "axf", " argf", "cmdn", "arkpc", " argpc", "cmdct", "argf"], "argv": ["Argv", "agve", "argumentv", "argumentf", "agv", "Argve", "argsl", "Argvs", "optc", " argl", "argssv", "optp", "ArgV", "paramf", "Argsv", "axvs", "axsv", "axver", "catf", "optl", "argumentver", "catvs", "Argc", "arkf", "argV", "agvs", "argumentc", " argvs", "argsp", "argve", "arkc", "paramvs", "axp", "axc", "Argf", "catv", "argumentp", " argsv", "optv", "argl", "arkl", "agf", "axv", "Argl", "axf", "argver", "arkv", "paramv", " argf", "argsv", " argV", " argver", "Argp", "argumentV", "argsf", " argp", "argvs", "argsc", "argf", "paramsv", "catve", "argp", "paramc"], "opts": ["coptes", "OPTS", "opoptions", "OPts", "optionTS", "optes", "otts", "opercs", "copoptions", "ipTS", "ipters", "optionts", "OPters", "optioncs", "ottes", "copcs", "opTS", "opcs", "opertes", "ipts", "ipcs", "otcs", "operts", "OPcs", "copts", "otoptions", "operoptions", "opters", "optionters"], "c": ["cm", "cs", "ctx", "csv", "cc", "cl", "cpp", "r", "d", "ct", "n", "cat", "nc", "bc", "co", "cy", "chain", "k", "con", "tc", "end", "i", "ac", "m", "code", "coll", "err", "cr", "ch", "config", "C", "dc", "ce", "h", "l", "p", "xc", "cu", "e", "lc", "f", "col", "cn", "sc", " pc", "cd", "cmd", "vc", "o", "pc", "v", "s", "cit", "b", "cmp", "cf", "t", "line", "ci", "count", " rc"], "cp": ["cm", "np", "cs", "ctx", "csv", "conn", "pe", "ype", "cpp", "yp", "cat", "ap", "pg", "pn", "ph", "cop", "pb", "op", "tp", "proc", "fp", "cb", "cr", "ep", "ch", "pointer", "CP", "ip", "p", "esp", "col", "hp", "cd", "jp", "mp", "cmd", "bp", "pc", "cmp", "cf", "ci", "wp", "gp", "pp"], "optind": ["argIND", "altend", "optiminst", "optimind", "optioninst", "optionIND", "optioninder", "octInd", "mpind", "propInd", "optioninit", "optioninn", " optint", "optiondir", "optinc", "optimiss", "expinc", "altiss", "optann", "optnd", "octinn", "expind", "optinit", "optionnd", "optinst", "optionini", "octend", "combind", "optIND", "varint", "optinn", "optimann", "optinder", "optionnt", "altind", "optionid", "mpInd", "optstart", "optid", "optionstart", "optii", "optiminn", "varind", "optimnd", "combint", "optionind", "optini", "mpina", " optend", " optann", "optionint", "optiminc", "optionann", " optii", "rootInd", "vertann", "octinc", "optdir", "rootIND", "optnt", "argInd", "optimInd", "rootind", "vertind", "argind", "propind", "varinder", "optionii", "optionina", "optimint", "optimii", "optiss", " optInd", "optioniss", "optimdir", "optimend", "optionend", " optinder", "optionInd", "optina", "optiminit", "vertnd", " optnt", "expInd", "propid", "optimini", "altint", "propinn", "octii", "optend", "mpIND", "optimIND", " optinit", "octind", "optimnt", " optinn", "optimid", "optioninc", "optimstart", "optInd", "vertint", "rootini", "argina", "combdir", "combstart", "optint", " optinst", "expid"], "sp": ["SP", "sg", " sc", "ct", "nc", "sl", "j", "sf", "opt", "isp", "ind", "sw", "f", "sc", "jp", "wp", "se", "start", "pp", "pl", "osp", "sup", "spl", "yp", "type", "ap", "sh", "click", "html", "span", "ny", "asp", "gap", "fp", "sv", "p", "ptr", "esp", "Sp", "amp", "sn", "serv", "sci", " SP", "gp", "pt", "sy", "np", " esp", "skip", "ss", "pe", "bsp", "loc", "page", "py", "i", "pre", "space", "slice", "ep", "st", "cap", "bp", "inst", "si", "service", "pg", "ph", "scope", "sk", "spe", "tp", "pos", "spot", "style", "ip", "pc", "line"]}}
{"project": "qemu", "commit_id": "6240d6467077a12c24878bab645d8e2983e4975a", "target": 0, "func": "static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,\n\n                                    uint32_t val)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr;\n\n    int reload = 0;\n\n\n\n    DPRINTF(\"write \" TARGET_FMT_plx \" %08x\\n\", addr, val);\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case TIMER_LIMIT:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter MSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else {\n\n            // set limit, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = val & TIMER_MAX_COUNT32;\n\n            if (!s->limit)\n\n                s->limit = TIMER_MAX_COUNT32;\n\n            ptimer_set_limit(s->timer, s->limit >> 9, 1);\n\n        }\n\n        break;\n\n    case TIMER_COUNTER:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter LSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else\n\n            DPRINTF(\"not user timer\\n\");\n\n        break;\n\n    case TIMER_COUNTER_NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n", "idx": 1167, "substitutes": {"opaque": ["opacity", " opque", "opaques", "iopque", "copacs", "opctx", "OPctx", "OPacs", "iopaque", "iopacs", "iopctx", " opacity", "iopaques", "opacs", "copctx", "OPa", "iopacity", "OPaque", "copa", "oacity", "iopa", " opaques", "oque", "copaque", "opa", "oaques", "opque", "oaque"], "addr": ["oa", "dr", "ld", "src", "fd", "offset", "ss", "mt", "dd", "conn", "host", "sid", "data", "url", "r", "loc", "ad", "align", "alt", "sl", "ord", "adr", "pos", "mac", "code", "str", "pointer", "xp", "address", "ip", "x", "afi", "ptr", "hop", "len", "cap", "attr", "ar", "eth", "amp", "pc", "asm", "seq", "tz", "rx", "sta", "vr", "rt", "ast", "ace"], "val": ["ret", "base", "test", "arg", "vol", "delay", "ol", "ctx", "local", "cal", "def", "split", "elt", "vt", "byte", "dim", "cl", "vals", "data", "pol", "Val", "slot", "alt", "fl", "sl", "grad", "arr", "num", "bl", "nil", "util", "live", "aval", "sol", "index", "sel", "x", "ind", "len", "eval", "ref", "pal", "exec", "value", "el", "min", "v", "seq", "valid", "al", "lit", "reg", "VAL", "count", "pt", "all", "mem"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "er", "sie", "self", "f", "sys", "u", "en", "your", "an", "fs", "parts", "spec", "ts", "sb", "ips", "aws", "y", "uns", "xs", "request", "sets", "p", "e", "conf", "v", "less", "su", "site", "S", "t", "session", "os", "its", "hs", "sym", "ssl", "cs", "ss", "a", "rs", "new", "r", "is", "m", "settings", "ds", "ps", "gs", "hm", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "d", "ms", "sync", "status", "l", "services", "w", "b", "full", "states"], "saddr": ["sconn", "sbcoord", "nsaddr", "sbadd", " sproxy", "Sconn", "sval", " scoord", "sincoord", "sbaddr", "paddress", "Shop", "sadd", "daddress", "sbproxy", "Saddress", " svar", " saddress", "sinadd", "svar", "shop", "dconn", "scoord", "paddr", "sinaddr", "saddress", "nsval", "pval", " sval", " sconn", "Saddr", "sinproxy", "pvar", "sproxy", "nsvar", "daddr", " shop", "nsaddress", "dhop", " sadd"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n", "idx": 1194, "substitutes": {"env": ["buffer", "ctx", "context", "device", "global", "environment", "nc", "scope", "buf", "param", "proc", "config", "ec", " environment", "h", "p", "dev", "e", "ptr", "eval", "core", "exec", "node", "en", "ev", "iv", "console", "port"]}}
{"project": "qemu", "commit_id": "b591dc59bc98ee558db4ca512aa117748ebfdeef", "target": 0, "func": "static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n", "idx": 1215, "substitutes": {"s": ["sg", "js", "service", "this", "cs", "ss", "ops", "spec", "qs", "rs", "sb", "d", "n", "ans", "is", "ins", "sl", "ms", "i", "g", "m", "ls", "ses", "sf", "sync", "xs", "sv", "tests", "sets", "ds", "ps", "gs", "ns", "c", "p", "css", "services", "self", "e", "f", "es", "us", "sys", "sq", "u", "as", "v", "less", "b", "su", "t", "S", "ks", "os", "session", "site", "bs", "times", "hs", "states", "se", "fs", "si", "sym", "ssl"], "temp": ["base", "test", "level", "fd", "local", "key", "flat", "perature", "new", "n", "type", "orig", "empty", "tc", "emp", "wait", "parent", "tmp", "num", "now", "py", "i", "pipe", "atom", "fake", "dc", "Temp", "c", "p", "w", "tem", "porary", "cache", "stable", "Tem", "v", "t", "clean", "iter", "pt", "timeout", "ex", " temporary"], "ts": ["ters", "tn", "test", "te", "js", "tf", "acs", "cs", "ss", "uts", "rs", "qs", "tk", "ms", "ims", "tc", "ta", "tes", "ments", "tp", "ls", "tx", "ents", "ats", "Ts", "xs", "ras", "tr", "ds", "als", "ps", "gs", "outs", "ns", "css", "atts", "es", "tis", "tt", "as", "tm", "stats", "tz", "t", "types", "ks", "times", "points", "bs", "hs", "fs", "TS", "ags"]}}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n", "idx": 1227, "substitutes": {"device": ["serial", "unit", "server", "mount", "service", "buffer", "target", "conn", "image", "d", "di", "devices", "type", "de", "android", "remote", "model", "package", "component", "mac", "project", "home", "address", "feature", "dc", "disk", "ip", "block", "phy", "dev", "Device", "node", "driver", "plugin", "module", "element", "product", "engine", "mode", "root", "mobile", "user", "port"], "has_base": ["has_data", "has_cache", " has_data", " has_cache"], "base": ["unit", "based", "server", "name", "buffer", "local", "area", "bare", "image", "binary", "url", "type", "Base", "bid", "ase", "id", "chain", "parent", "common", "client", "api", "model", "builder", "proxy", "mac", "file", "sync", "source", "back", "absolute", "fake", "bas", "address", "home", "pa", "block", "bot", "state", "bi", "lc", "cache", "core", "kit", "prefix", "bu", "b", "plugin", "site", "root", "mode", "part", "db", "family"], "errp": ["errP", "erP", "erpc", "rrf", "erb", "errorpc", "errpc", "rrr", "erf", "errorP", "norp", " errr", "acerpa", "norpa", "errb", "norb", "errorps", "err", "erpa", " errps", " errP", "errps", "errr", " errpa", " errpc", "errorp", "acerp", "erp", " errb", "rrb", "norr", " errf", "erps", "errf", "errpa", "acerr", "acerf", "rrp"], "bs": ["null", "js", "cs", "bh", "ss", "ba", "rs", "ts", "bo", "sb", "bps", "lb", "BS", "eb", "bid", "bc", "ins", "banks", "pb", "android", "bing", "bl", "bis", "pos", "plugins", "ls", "ses", "bits", "sync", "cb", "ds", "bas", "ps", "gs", "ns", "bus", "bot", "block", "css", "vs", "bi", "us", "bos", "bd", "br", "gb", "obj", "bb", "bu", "blocks", "iss", "fb", "b", "s", "os", "las", "bytes", "bes", "fs", "db"], "base_bs": ["base_base", " base_bas", " base_cs", " base_vs", "base_android", "base_vs", "base_b", " base_ls", "base_ls", "base_bas", " base_android", "base_cb", " base_base", " base_b", "base_cs", " base_cb"], "local_err": ["locallytx", "local2Er", "self_err", " local_cr", " local_req", " local_tx", "remote_err", "local_status", "local2req", "local_error", "locallyerr", "local_Er", "remote_status", "remote_error", "local_dr", "local_req", "self_rr", "local2err", "local_rr", " local_Er", "self_dr", " local_error", "local_tx", "locallyerror", "self_error", "locallycr", "local_cr"]}}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF &&\n\n        msi_init(dev, 0, 1, true, false) >= 0) {\n\n        /* TODO check for errors */\n\n        s->msi_in_use = true;\n\n    }\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 1277, "substitutes": {"dev": ["serial", "cam", "DC", "dn", "def", "dd", "hw", "spec", "conn", "device", "mod", "dim", "data", "r", "ad", "development", "ver", "di", "devices", "der", "prof", "grad", "de", "dom", "g", "Dev", "DEV", "ve", "info", "bug", "dt", "md", "ds", "ch", "config", "pub", "temp", "dc", "home", "bus", "gu", "w", "prom", "dm", "self", "gd", "f", "conf", "app", "Device", "die", "comment", "driver", "v", "cmd", "ev", "rad", "dem", "req", "od", "error", "valid", "pro", "engine", "debug", "diff", "db"], "errp": ["errP", " errps", " errP", "ErP", "Erp", "errr", " errr", "rps", "errps", "Erps", "rp", "rP", "Err", "rr"], "d": ["Ds", "dn", "dd", "pd", "sd", "dh", "ad", "n", "de", "i", "g", "m", "dt", "ds", "dc", "c", "p", "w", "e", "dm", "f", "cd", "t", " dd", "dp", "D", "db"], "s": ["sg", "js", "this", "com", "sp", "sl", "client", "g", "ses", "ls", "sf", "secure", "args", "er", "storage", "sw", "vs", "self", "f", "sys", "docker", "u", "your", "an", "se", "fs", "spec", "ts", "sb", "aws", "sh", "k", "api", "y", "uns", "sv", "request", "p", "e", "conf", "driver", "v", "less", "su", "site", "S", "t", "session", "serv", "os", "ks", "bs", "sym", "ssl", "cs", "ss", "rs", "sd", "data", "new", "r", "is", "i", "m", "settings", "ds", "gs", "native", "ns", "h", "c", "es", "south", "o", "req", "si", "server", "service", "http", "scope", "sk", "side", "params", "details", "sync", "tests", "l", "services", "w", "sq", "stats", "b", "full"]}}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n", "idx": 1290, "substitutes": {"s": ["server", "js", "service", "opens", "cs", "http", "ss", "ops", "rs", "qs", "ts", "a", "sb", "spec", "ips", "new", "r", "is", "sl", "i", "g", "m", "ses", "sync", "ds", "sets", "ps", "ns", "c", "p", "rates", "services", "e", "self", "f", "es", "secondary", "sys", "sq", "south", "o", "stats", "b", "events", "S", "t", "os", "fs", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "func": "FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n", "idx": 1307, "substitutes": {"nbits": [" nits", "nblocks", "Nbits", "numblocks", "nsframes", "Nits", "npieces", "numframes", "nframes", " nframes", "numbits", "nspieces", "nits", "numpieces", "nsbits", " nblocks", " npieces", "Nblocks", "numits"], "inverse": ["Inreverse", "invert", "Inverted", "inverted", "ninreverse", "Inverse", "insverted", "invers", "ninvert", "insverse", " invert", "insvers", " inverted", "insvert", "inreverse", "Invers", "Invert", "ninvers", "ninverse", "insreverse"], "s": ["sg", " caps", "js", "service", "opens", "cs", "ctx", "ss", "local", "rs", "ts", "a", "spec", "sb", "ings", " is", "r", "d", "n", "aws", "sl", "scope", " ads", " changes", "i", "g", " cs", "m", "ses", "ls", "args", "sf", "sync", "settings", " services", "ds", "als", "func", "ps", "gs", "ns", "h", "c", "p", "services", "w", "e", "f", "es", "secondary", "conf", "sq", "u", "ches", "south", "o", "v", " c", "b", "S", "t", "session", "os", "its", "hs", "fs", "si", "ssl"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1308, "substitutes": {"var": ["dr", "vm", "name", "array", "mod", "data", "r", "ver", "cat", "vari", "orig", "cur", "grad", "tmp", "rf", "comp", "variable", "err", "temp", "func", "vv", "opt", "feature", "pad", "usr", "Var", "dev", "ptr", "prev", "attr", "ctr", "vc", "bb", "v", "inst", "cf", "car", "addr", "root"]}}
{"project": "FFmpeg", "commit_id": "89325417e7b33f4b08171d9d609c48662d96b2d3", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for SIZ\\n\");\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {\n        avpriv_request_sample(s->avctx, \"Large Dimensions\");\n        return AVERROR_PATCHWELCOME;\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              ncomponents);\n        return AVERROR_PATCHWELCOME;\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents);\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n    if (i == possible_fmts_nb) {\n        if (ncomponents == 4 &&\n            s->cdy[0] == 1 && s->cdx[0] == 1 &&\n            s->cdy[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;", "idx": 1318, "substitutes": {"s": ["sg", "js", "qs", "sites", "g", "ls", "ses", "sf", "args", "vs", "us", "self", "f", "secondary", "sys", "u", "your", "se", "fs", "parts", "spec", "ts", "sb", "aws", "format", "ims", "y", "uns", "xs", "sv", "sets", "p", "e", "lines", "conf", "as", "uses", "v", "su", "site", "S", "t", "os", "session", "ks", "its", "hs", "in", "sym", "ssl", "cs", "ss", "rs", "a", "data", "new", "r", "is", "ins", "ions", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "words", "size", "es", "o", "img", "si", "_", "service", "ops", "window", "d", "results", "ans", "ms", "comments", "params", "sync", "ats", "tests", "l", "services", "w", "sq", "stats", "b", "full", "states"], "i": ["li", "counter", "a", "ii", "pi", "ui", "I", "n", "di", "is", "iu", "j", "m", "ti", "multi", "temp", "ip", "l", "c", "p", "f", "v", "b", "t", "count", "io", "si", "xi"], "ncomponents": ["bcommonents", "ncountients", " nComponent", "ncommances", "ncompenses", "ncomponent", "ncommounds", "numparlements", "sncomponents", "nmacresses", "ncondonents", "ncomonents", "bcommenses", "ncontlements", "sncomparters", " nComponents", "npropones", "nummacresses", "sncompuments", "nspuments", "nquonents", "bcommlements", "numcomplements", "ncontresses", "sncommarters", "ncompounds", "ncommonents", "numcomponents", "nummacones", "numcompones", "ncaponents", "numcompresses", "numparresses", "nproponents", "numcompients", "nmaclements", "nquarters", "ncompuments", "ncomparters", "ncondlements", "ncommonent", "ncompresses", "bcomplements", "nsponents", "ncondenses", "ncaplements", "sncommones", "nparients", "nummaconents", "ncomounds", "ncompances", "ncondances", "sncommonents", "ncountlements", "ncommones", "nsparters", "sncompones", "numparonents", "bcompounds", "ncommarters", "bcomponents", "nquones", "ncompones", "nmaconents", "npropresses", "ncondonent", " ncompances", "nproplements", "ncountresses", "ncomlements", "ncondounds", "nparresses", " ncomplements", "nspones", " nCompances", "nparlements", "numparients", "ncountonents", "ncompients", "ncommenses", "nparonents", "ncomplements", "ncontones", " ncomponent", "ncontonents", "nComplements", " nComplements", "ncapients", "nComponent", "nComponents", "nummaclements", "ncommlements", "nquuments", "ncomenses", "sncommuments", "bcompenses", "nCompances", "ncommuments", "ncapresses", "bcommounds", "nmacones"], "possible_fmts": ["possible_mats", "possible_mt", "possible_cmts", "possible_fmats", "possible_FMts", "possible_FMters", "possible_fmters", "possible_mts", "possible_mters", "possible_cmt", "possible_FMats", "possible_FMt", "possible_cmters", "possible_cmats", "possible_fmt"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "substitutes": {"job": ["flow", "base", "server", "lock", "service", "build", "queue", "process", "image", "jobs", "section", "worker", "pb", "j", "sync", "project", "bug", "cb", "pool", "config", "status", "feed", "result", "block", "work", "child", "jp", "object", "exec", "node", "connection", "seq", "b", "plugin", "manager", "Job", "run", "db"], "speed": ["cost", "level", "service", "capacity", "mass", "time", "rate", "spec", "slow", "grade", "effect", "image", "gain", "high", "race", "weight", "scroll", "sk", "duration", "peed", "seed", "score", "slice", "settings", "source", "strike", "status", "mph", "step", "rank", "skill", "size", "length", "set", "power", "powered", "scale", "fee", "strength", "error", "sort", "stop", "sex", "Speed", "limit", "performance", "port"], "errp": ["errP", "erc", "rrfp", "erP", "errc", "errpe", "errfp", " errpe", "iterp", "rrP", "erf", "rrc", " errr", "err", " errP", "iterr", "errr", "erpe", "erp", " errc", "iterf", "iterpe", " errf", " errfp", "errf", "erfp", "rrp"], "s": ["sg", "submit", "js", "service", "sup", "ss", "spec", "sb", "r", "is", "sp", "sl", "sh", "ssh", "g", "m", "ses", "ls", "sf", "ds", "ps", "gs", "ns", "c", "p", "services", "e", "f", "secondary", "sq", "u", "o", "v", "b", "S", "session", "hs", "se", "si", "sym"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_int(int *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n\n        else\n\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n\n        return;\n\n    }\n\n\n\n    extend97_int(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n}\n", "idx": 1338, "substitutes": {"p": ["n", "sp", "j", "g", "rep", "er", "progress", "x", "pr", "private", "f", "prev", "u", "jp", "s", "at", "cp", "wp", "pp", "port", "pl", "pi", "ap", "sh", "k", "pair", "api", "y", "P", "python", "post", "pa", "e", "per", "patch", "hp", "pm", "php", "v", "t", "np", "vp", "lp", "a", "pe", "data", "press", "op", "py", "pre", "m", "ps", "result", "c", "br", "cache", "app", "o", "bp", "http", "d", "cop", "it", "comp", "tp", "ch", "ip", "l", "up", "pc", "point", "b"], "i0": ["i01", "i029", " i4", "si050", "ui01", "iix", "si1", "ui0", "p1", "l0", "iu0", "i00", "qi0", "i100", "si0", "qi00", "si01", "ini8", "i4", "iok", "idok", "ui1", " iqa", "iqa", " i00", "i050", " i6", "si029", "ii50", "l2", "uiok", "i50", "si6", "pi4", "pix", " iix", " i8", " i50", " i120", "i6", "ui2", "pi6", "si5", "id0", "l00", "iu8", "p00", " i100", "iu125", "iu120", "i120", "ii4", "id00", " i5", "uiqa", "si125", "qi50", "si4", "ii0", "i125", "pi029", "iu050", "l1", "i5", "ui120", "iu50", "ui8", "si00", "p4", "ini050", "ii5", " i029", "qi100", "ui00", "siok", "p0", "si8", "ii6", "iuqa", "ini0", "i8", "pi0", "ini125", "ii100", "ii00", "p2", "id01", "siix", "i2", "ui50"], "i1": ["ii2", "p6", "i01", "si1", "pi1", "ui0", "p1", "ui100", "u100", "u2", "li6", "i100", "si0", "ini01", "xi2", "in100", "si01", "i151", "it251", "li01", "i2", "ini81", "pi01", "xi0", "ui1", " i2", "ini1", "i81", "li151", "ip151", "u251", " i8", "it01", "liup", "i6", "ui2", "li1", "i251", "in1", "li8", "pi2", "ini251", "ii8", "si81", "i1001", " i01", "ip1", " iup", "li61", "i61", "si61", "ii01", "ui251", "ii0", "si1001", "piup", "ui1001", "si251", "xi01", "p8", "it81", "in2", "siOne", "iup", "li1001", "it1", "iOne", "p0", "ip2", "li2", "ui61", "si8", "ip1001", "ui151", "ii6", "i8", " iOne", "u1", "li0", "ii1", "in251", "iiOne", "xi1"], "i": ["cli", "key", "mini", "n", "j", "anti", "ti", "index", "x", "hi", "alpha", "f", "u", "idi", "s", "uri", "fi", "ami", "abi", "zi", "ji", "ui", "pi", "id", "mi", "iu", "k", "api", "y", "ri", "ie", "gu", "e", "v", "ix", "qi", "ik", "t", "me", "io", "mu", "init", "in", "li", "a", "ni", "ii", "chi", "r", "I", "di", "is", "m", "info", "slice", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "ei", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "adi", "bi", "b", "ci", "xi"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n", "idx": 1341, "substitutes": {"dst": ["Dsrc", " dtd", "Dsts", "dsts", "dsdest", "ddest", "dST", "Ddest", "rST", " dsrc", "dsST", "dsst", "sst", "rdest", "rst", " dsts", "dsrc", "sdest", "rtd", "dstd", " dST", " ddest", "Dst", "dtd", "ssrc", "ssts"], "src": ["rib", "ctx", "rest", "split", "spec", "sb", "ruby", "url", "image", "r", "loc", "rob", "RC", "sl", "cur", "video", "buf", "rb", "dest", "sync", "cb", "slice", "source", "config", "st", "scenes", "impl", "sel", "l", "cv", "attr", "sc", "uv", "gb", "stream", "sr", "s", "gl", "b", "inst", "sur", "req", "uri", "conv", "img", "uc", "rect", "sth", "rc"], "i": ["cli", "yi", "li", "gi", "abi", "a", "ni", "ii", "zi", "chi", "ei", "ji", "ui", "pi", "oi", "r", "d", "I", "n", "di", "is", "id", "it", "iu", "k", "j", "g", "iii", "m", "eni", "ri", "info", "ti", "slice", "ini", "index", "multi", "source", "ai", "ie", "x", "l", "hi", "p", "c", "h", "bi", "e", "phi", "f", "lc", "u", "o", "v", "b", "qi", "t", "uri", "ci", "wei", "io", "mu", "fi", "si", "xi"]}}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n", "idx": 1351, "substitutes": {"errp": ["errP", "erc", "erP", "rorb", "rorlp", "errc", "erlp", "irr", "erb", "irpre", "rorp", "rrr", "rrc", "irc", "errb", " errlp", "err", " errP", "irp", "errr", "erpre", "erp", " errb", "errlp", "rrpre", "errpre", "rorP", "rrp"], "fid": [" fip", " fids", " fbid", "Fname", "dids", "lip", "fpid", "afid", "fkid", "afID", "lkid", "lfids", "gID", "tfID", "tfbid", "gid", " faid", "ifID", "lname", "lfid", "vids", "lfaid", "lid", "dbid", "did", "Fid", "gname", "tfid", "afbid", "gsid", " fname", "Faid", "ifsid", "ifname", "fID", "fids", "lbid", "FID", "frid", "Fids", "vbid", "vid", "Frid", "fname", " fpid", "Fbid", "lfrid", "ifid", "fbid", "lids", "vkid", "Fpid", " fID", "faid", "dkid", "afpid", "fsid", "fip", "tfip", " frid", " fsid", "lID"]}}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n", "idx": 1360, "substitutes": {"dev": ["adv", "dn", "def", "dd", "mod", "device", "sd", "data", "ad", "d", "ver", "development", "virt", "sh", "der", "priv", "de", "grad", "dom", "Dev", "DEV", "info", "bug", "err", "md", "ds", "dc", "p", "state", "prom", "w", "app", "conf", "wd", "o", "driver", "ev", "rad", "dem", "req", "nov", "debug", "diff", "gd", "user"], "errp": ["errP", "erP", "errsp", "derp", "errfp", "srfp", "derP", "srlp", "irmlp", " errlp", "irmps", " errps", " errP", "srp", "errps", " errsp", "dersp", "erp", "irmp", "errlp", "ersp", " errfp", "irmfp", "derfp", "srps", "erfp"], "vdev": ["vdd", "vmgrad", "vmdev", "Vdd", "Vdevice", "vmself", "vmdevice", "vgrad", "evdevice", " vdiff", "Vgrad", "vdiff", "Vdiff", "evdev", " vdd", " vself", " vgrad", "evdiff", "Vdev", " vdevice", "evdd", "Vself", "vself", "vdevice"], "v": ["vm", "server", "vp", "vt", "volt", "d", "n", "ver", "k", "i", "g", "j", "m", "sv", "z", "vv", "x", "l", "c", "p", "state", "w", "vs", "e", "f", "u", "V", "o", "ev", "b", "vi", "t", "iv", "lv", "tv", "var", "nv", "vd", "va", "vr", "vu"], "s": ["sg", "server", "js", "service", "ss", "spec", "rs", "sd", "sb", "r", "d", "sh", "sl", "g", "ses", "sv", "ds", "h", "l", "c", "p", "services", "state", "vs", "w", "f", "sq", "u", "o", "b", "su", "S", "os", "serv", "se", "fs", "si", "ssl"]}}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n", "idx": 1373, "substitutes": {"s": ["sg", "parser", "src", "cs", "ctx", "ss", "spec", "sa", "a", "qs", "sb", "data", "d", "n", "sl", "k", "client", "i", "g", "m", "ses", "sf", "settings", "sv", "ds", "ps", "gs", "ns", "c", "p", "services", "self", "private", "f", "e", "sys", "sq", "sc", "south", "v", "b", "t", "S", "session", "an", "si", "parts", "ssl"], "pkt": ["apacket", " pqt", " packet", "wacket", "Pqt", " pct", "apkt", "wkg", "pet", " pet", "pkg", "wkt", "apqt", "Pet", "Pkg", "pqt", "pct", " pkg", "apet", "packet", "wct", "Pkt", "Pct", "Packet"], "ipmovie": ["epcam", "ipvideo", "opmovie", " ipcam", "ipMovie", "ipcam", "mpMovie", "epmovie", "ippMovie", "ipfilm", "ippfilm", "opMovie", "mpmovie", "ippcam", "epMovie", "ippmovie", "opvideo", "ippvideo", "mpvideo", "mpfilm", " ipMovie", "opfilm"], "pb": ["fc", "pl", "vp", "abi", "bh", "lp", "ppa", "pd", "sb", "bps", "bm", "lb", "ab", "hub", "eb", "ub", "cpp", "binary", "prot", "ib", "prop", "bc", "platform", "tc", "api", " eb", "py", "PB", "rb", "sf", "fp", "cb", "bf", "abc", "pa", "p", "cv", "pak", "wb", "gb", "jp", "pm", "mp", "pit", "phrase", "amp", "bp", "pc", "bb", "fb", "b", "cp", "aph", "uf", "pp", "xb"], "ret": ["match", "fun", "att", "mt", "ext", "def", "bit", "conn", "hash", "sb", "success", "data", "get", "ct", "alt", "type", "cat", "job", "id", "pet", "rets", "pass", "rb", "rep", "code", "ait", "info", "nt", "ft", "rev", "cb", "replace", "reply", "status", "Ret", "rc", "bf", "feat", "back", "result", "len", "ref", "flag", "gt", "art", "obj", "value", "RET", "t", "error", "al", "lit", "re", "reg", "val", "rt", "let", "det", "res", "db"]}}
{"project": "FFmpeg", "commit_id": "46e3883519b7592e946258c68d072abd89e583c8", "target": 1, "func": "static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)\n\n{\n\n    int samples    = s->packet.frame_duration;\n\n    int redundancy = 0;\n\n    int redundancy_size, redundancy_pos;\n\n    int ret, i, consumed;\n\n    int delayed_samples = s->delayed_samples;\n\n\n\n    ret = opus_rc_init(&s->rc, data, size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* decode the silk frame */\n\n    if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        if (!swr_is_initialized(s->swr)) {\n\n            ret = opus_init_resample(s);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n\n\n        samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output,\n\n                                            FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),\n\n                                            s->packet.stereo + 1,\n\n                                            silk_frame_duration_ms[s->packet.config]);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error decoding a SILK frame.\\n\");\n\n            return samples;\n\n        }\n\n        samples = swr_convert(s->swr,\n\n                              (uint8_t**)s->out, s->packet.frame_duration,\n\n                              (const uint8_t**)s->silk_output, samples);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error resampling SILK data.\\n\");\n\n            return samples;\n\n        }\n\n\n        s->delayed_samples += s->packet.frame_duration - samples;\n\n    } else\n\n        ff_silk_flush(s->silk);\n\n\n\n    // decode redundancy information\n\n    consumed = opus_rc_tell(&s->rc);\n\n    if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8)\n\n        redundancy = opus_rc_p2model(&s->rc, 12);\n\n    else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8)\n\n        redundancy = 1;\n\n\n\n    if (redundancy) {\n\n        redundancy_pos = opus_rc_p2model(&s->rc, 1);\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID)\n\n            redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2;\n\n        else\n\n            redundancy_size = size - (consumed + 7) / 8;\n\n        size -= redundancy_size;\n\n        if (size < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid redundancy frame size.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (redundancy_pos) {\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_celt_flush(s->celt);\n\n        }\n\n    }\n\n\n\n    /* decode the CELT frame */\n\n    if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        float *out_tmp[2] = { s->out[0], s->out[1] };\n\n        float **dst = (s->packet.mode == OPUS_MODE_CELT) ?\n\n                      out_tmp : s->celt_output;\n\n        int celt_output_samples = samples;\n\n        int delay_samples = av_audio_fifo_size(s->celt_delay);\n\n\n\n        if (delay_samples) {\n\n            if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n                av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples);\n\n\n\n                for (i = 0; i < s->output_channels; i++) {\n\n                    s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0,\n\n                                                delay_samples);\n\n                    out_tmp[i] += delay_samples;\n\n                }\n\n                celt_output_samples -= delay_samples;\n\n            } else {\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Spurious CELT delay samples present.\\n\");\n\n                av_audio_fifo_drain(s->celt_delay, delay_samples);\n\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_BUG;\n\n            }\n\n        }\n\n\n\n        opus_raw_init(&s->rc, data + size, size);\n\n\n\n        ret = ff_celt_decode_frame(s->celt, &s->rc, dst,\n\n                                   s->packet.stereo + 1,\n\n                                   s->packet.frame_duration,\n\n                                   (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0,\n\n                                   celt_band_end[s->packet.bandwidth]);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n            int celt_delay = s->packet.frame_duration - celt_output_samples;\n\n            void *delaybuf[2] = { s->celt_output[0] + celt_output_samples,\n\n                                  s->celt_output[1] + celt_output_samples };\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                s->fdsp->vector_fmac_scalar(out_tmp[i],\n\n                                            s->celt_output[i], 1.0,\n\n                                            celt_output_samples);\n\n            }\n\n\n\n            ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n    } else\n\n        ff_celt_flush(s->celt);\n\n\n\n    if (s->redundancy_idx) {\n\n        for (i = 0; i < s->output_channels; i++)\n\n            opus_fade(s->out[i], s->out[i],\n\n                      s->redundancy_output[i] + 120 + s->redundancy_idx,\n\n                      ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx);\n\n        s->redundancy_idx = 0;\n\n    }\n\n    if (redundancy) {\n\n        if (!redundancy_pos) {\n\n            ff_celt_flush(s->celt);\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                opus_fade(s->out[i] + samples - 120 + delayed_samples,\n\n                          s->out[i] + samples - 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          ff_celt_window2, 120 - delayed_samples);\n\n                if (delayed_samples)\n\n                    s->redundancy_idx = 120 - delayed_samples;\n\n            }\n\n        } else {\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));\n\n                opus_fade(s->out[i] + 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          s->out[i] + 120 + delayed_samples,\n\n                          ff_celt_window2, 120);\n\n            }\n\n        }\n\n    }\n\n\n\n    return samples;\n\n}", "idx": 1377, "substitutes": {"s": ["sg", "js", "qs", "n", "g", "ls", "ses", "sf", "args", "self", "us", "f", "sys", "u", "your", "se", "fs", "spec", "ts", "sb", "ips", "aws", "ims", "uns", "xs", "sv", "sets", "p", "e", "conf", "sports", "uses", "su", "serv", "S", "t", "ks", "os", "session", "site", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "new", "is", "ins", "ions", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "words", "es", "o", "si", "server", "service", "ops", "d", "ms", "comments", "sync", "l", "services", "sq", "b", "full"], "data": ["buffer", "da", "channel", "ops", "dd", "a", "memory", "image", "ui", "window", "d", "devices", "rec", "sample", "buf", "batch", "body", "slice", "source", "ds", "raw", "pad", "x", "block", "p", "shift", "start", "result", "len", "length", "cache", "DATA", "bytes", "dat", "Data", "response", "input"], "size": ["unit", "SIZE", "se", "name", "capacity", "offset", "time", "ize", "sized", "small", "loc", "n", "empty", "enc", "pos", "code", "address", "p", "len", "Size", "en", "sec", "sum", "scale", "fee", "six", "shape"], "redundancy_size": ["redundancy_sum", "redundance_sum", "redundance_size", "redundance_pos"], "redundancy_pos": ["redundancies_len", "redundancies_position", "redundancies_offset", "redundancy_len", "redundancy_position", "redundancy_offset", "redundancies_pos"], "ret": ["match", "fun", "att", "mt", "ext", "offset", "def", "active", "bit", "sb", "success", "get", "complete", "sil", "alt", "cat", "format", "pet", "rets", "num", "pass", "max", "fail", "rep", "rb", "code", "info", "ft", "nt", "rev", "back", "reply", "status", "Ret", "rc", "bf", "feat", "opt", "result", "fin", "len", "f", "flag", "ref", "reset", "red", "gt", "art", "resp", "sec", "en", "RET", "error", "sur", "al", "lit", "reg", "re", "val", "mode", "rt", "iter", "run", "part", "full", "det", "res", "bad"], "i": ["ni", "ii", "ui", "mini", "is", "id", "mi", "it", "j", "info", "ini", "index", "ai", "ie", "ind", "p", "f", "len", "reset", "io", "init", "iter", "fi", "start", "si", "in"], "consumed": [" consumption", " consoved", "resumption", " unconslated", "conoved", "Consumed", "resoved", " consumes", "continoved", "resumed", "continuming", "conuming", "manumption", "conume", " unconsumption", "continumption", " conslated", "consumes", "continaled", " consaled", "Consuming", "conumption", "continumes", "continlated", "manumes", "conumed", "consuming", "continumed", "consume", "manoved", "conumes", "consumption", "consaled", " unconsumed", "manumed", "Consume", "continume", "Consumption", "conslated", "consoved", "resumes", " unconsaled"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381, "substitutes": {"queue": ["route", "ue", "group", "server", "cycle", "delay", "buffer", "q", "channel", "sequence", "command", "context", "menu", "Queue", "page", "job", "list", "loop", "batch", "future", "code", "file", "event", "config", "feed", "cache", "message", "gui", "connection", "collection", "prefix", "seq", "lib", "plugin", "qa", "module", "manager", "line", "que", "console"], "next": ["flow", " Next", "same", "server", "after", "primary", "offset", "key", "sequence", "second", "success", "new", "current", "data", "more", "page", "open", "end", "frame", "client", "first", "Next", "future", "code", "entry", "big", "forward", "reply", "pointer", "last", "business", "step", "foo", "self", "iterator", "prev", "front", " NEXT", "core", "object", "value", "obj", "sec", "range", "up", "seq", "link", "valid", "line", "good", "latest", "one", "start", "pack", "done"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)\n\n{\n\n    int   band, result=0, numSubbands, lastTonal, numBands;\n\n\n\n    if (codingMode == JOINT_STEREO && channelNum == 1) {\n\n        if (get_bits(gb,2) != 3) {\n\n            av_log(NULL,AV_LOG_ERROR,\"JS mono Sound Unit id != 3.\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (get_bits(gb,6) != 0x28) {\n\n            av_log(NULL,AV_LOG_ERROR,\"Sound Unit id != 0x28.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* number of coded QMF bands */\n\n    pSnd->bandsCoded = get_bits(gb,2);\n\n\n\n    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);\n\n    if (result) return result;\n\n\n\n    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);\n\n    if (pSnd->numComponents == -1) return -1;\n\n\n\n    numSubbands = decodeSpectrum (gb, pSnd->spectrum);\n\n\n\n    /* Merge the decoded spectrum and tonal components. */\n\n    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);\n\n\n\n\n\n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n\n    numBands = (subbandTab[numSubbands] - 1) >> 8;\n\n    if (lastTonal >= 0)\n\n        numBands = FFMAX((lastTonal + 256) >> 8, numBands);\n\n\n\n\n\n    /* Reconstruct time domain samples. */\n\n    for (band=0; band<4; band++) {\n\n        /* Perform the IMDCT step without overlapping. */\n\n        if (band <= numBands) {\n\n            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);\n\n        } else\n\n            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));\n\n\n\n        /* gain compensation and overlapping */\n\n        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),\n\n                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),\n\n                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));\n\n    }\n\n\n\n    /* Swap the gain control buffers for the next frame. */\n\n    pSnd->gcBlkSwitch ^= 1;\n\n\n\n    return 0;\n\n}\n", "idx": 1404, "substitutes": {"q": ["Q", "ue", "quad", "kb", "qs", "queue", "hub", "ui", "buff", "query", "g", "m", "cgi", "dq", "w", "f", "conf", "sq", "question", "qa", "qi", "req", "qt", "quant", "qq", "gd", "qu", "rc"], "gb": ["rg", "cm", "gio", "ogg", "quad", "kb", "gram", "ga", "ges", "sb", "bm", "lb", "hub", "ui", "mb", "gy", "eb", "gru", "gnu", "pg", "bc", "buff", "gz", "ko", "GB", "gin", "g", "gg", "rb", "gm", "cb", "cgi", "storage", "gam", "gs", "bf", "hm", "cv", "nb", "ym", "wb", "agg", "bg", "bb", "pc", "b", "abb", "usb", "gal", "cfg", "gp", "gd", "db", "rc"], "pSnd": ["PAsck", "pESnw", "cpOsND", " pAsstd", " pAsnt", "pAsck", "PAsnt", "pClnd", " pSinf", "PAsND", "pPsvd", "pAsdk", "pNnn", " pAsgn", "PAsnn", "pEsnt", "pAsdn", "pOsnd", " pAsdc", "PSdk", " pSnt", "pAsign", " pAsnw", "pOsld", "pCND", "pOsND", " pSne", "pOSND", "PSsd", "PNND", "pSuind", "npSck", "pAsgn", "pGSgn", "pESnt", "pEsld", "pOsnt", "pAsstd", "PSng", " pSind", "pSyncdc", "pRSnd", "pHSnt", "pESND", "pSdat", "pSuck", "pNnt", "PSund", "PAssd", "pAsvd", "pAsnt", "PSnt", "pGSnd", "pResdk", "PAsdn", " pNnd", "pAssd", "pAsne", " pSvd", " pAsvd", "PSign", "pLSdn", "pInsinf", "pCnt", "pRSND", "pNND", "PAsng", "pEsND", "cpSnd", "pCnd", "pHSind", "pAsind", " pNck", "pSnn", "pHSnn", "pShND", "pOSnn", "pLSnd", " pAsne", "pAsdat", "pNck", " pAsND", "pIsund", "PSnn", "pHSdn", "pCld", "pNnd", "PSdn", " pAsdn", " pSgn", "pSund", " pAsld", " pSnn", "pInsnd", "pNld", "npHSck", "pIsstd", "npHSND", "cpOsld", "pGSnn", "pRSstd", "pIsND", "pHSND", "cpOsnd", "psign", "PSND", " pAsdat", "pIsld", "pIsnd", "pGSnt", "PAsund", "PAsdk", "pWSng", "pSdn", "pAsinf", "pAsnn", "pSind", "npSND", "pAsund", "pEsnd", "pWSnd", "pShind", "psck", "psnd", "pSstd", "pSyncnd", "pESnd", "pHSck", "pAsdc", "npHSnd", "pSinf", "pSND", "pSsd", "pNind", "PSnd", " pSdc", " pSnw", " pAsnd", "pLSsd", "pSng", "pResnd", "PAsld", "pIsind", "pShdn", "cpSND", "pGSdn", "pSgn", "pGSne", " pSdat", "pSdc", "PNnt", "pSnw", "pSyncne", "pSdk", "npHSind", "pRSind", "pEsund", "npSnd", "pResnt", "pOSnd", " pSND", "pShnt", "pSck", "pSld", "pAsnw", " pAsnn", " pSld", "pEsdat", "pPsgn", "pGSvd", "PNck", "pClld", "pSvd", "pHSnd", " pAsind", "cpOsnt", "pGSdc", "pAsND", "pSne", "pSyncnt", " pSck", "pSnt", "pInsND", "pAsld", "cpSnt", "pResng", "PAsnd", "PSck", "pCldat", "pClnt", "pNnw", "pPsnd", "pSign", "psND", " pNND", " pSdn", "pWSnt", "pAsng", "pPsnt", "pOSld", "PNnd", " pSstd", "pLSND", "pAsnd", "pHSsd", " pNinf", "pWSck", "pInsck", "cpSld", "PSld", "pSunt", "npSind", "pNinf", "pShnd"], "pOut": [" pArray", "POutput", "PIn", "fpArray", "POut", "PArray", "pOutput", "pout", "pArray", "npIn", "npOutput", " pout", "fpIn", "npout", "Pout", " pIn", "fpout", "npOut", "fpOut", "pIn", " pOutput"], "channelNum": ["channelLen", "pageNum", "ChannelLen", "componentNumber", "pageNumber", "componentnum", "pagenum", "ChannelNum", "Channelnum", " channelNumber", "channelNumber", "channelnum", "ChannelNumber", " channelLen", "pageLen", " channelnum", "componentNum", "componentLen"], "codingMode": ["codemode", "coderMode", "codermode", "cachingType", "codedMode", "lcodeMode", "castingmode", "cachingMODE", "lcodingmode", "codedType", "lcodeMODE", "codedMODE", "codeMode", "encodingMODE", "encodingmode", "codingmode", "lcodemode", "cachingmode", "coderMODE", "encodeType", "codingType", "lcodingMODE", "codeMODE", "cachingMode", "encodingType", "codedmode", "castingMode", "codeType", "castingMODE", "encodeMODE", "encodingMode", "codingMODE", "encodemode", "encodeMode", "lcodingMode"], "band": ["key", "device", "current", "ver", "weight", "field", "code", "direction", "track", "cell", "kg", "board", "bands", "unit", "flow", "group", "bind", "tag", "song", "type", "position", "gap", "batch", "pass", "off", "component", "step", "length", "patch", "amp", "plugin", "leg", "count", "layer", "cm", "piece", "version", "offset", "channel", "byte", "data", "page", "frequency", "boot", "loop", "filter", "back", "function", "result", "ground", "phase", "card", "bb", "kat", "low", "mode", "stage", "match", "Band", "level", "bit", "broad", "d", "ord", "number", "bug", "feature", "word", "bound", "range", "point", "plane", "product", "line", "part", "day", "db"], "numSubbands": ["sumSubband", "numBbands", "numSubtracks", " numPerbands", "nSuperlines", " numPerplanes", "numsublines", " numSubcats", "sumSubtracks", "numSublines", " numSubgroups", "sumSubplanes", "numPergroups", "numSubband", "sumsubtracks", " numPercats", "numMicrobands", "numSubgroups", "numBbits", "numsubbands", "numPerbands", "numShortbands", " numSubplanes", "nSublines", "nSubbits", "numMicroplanes", "nSupergroups", "numPerplanes", "sumsubband", "nSuperbits", "numBlines", "nSubgroups", "numShorttracks", "numsubcats", "numSubbits", "numsubtracks", "numsubbits", "numBgroups", "numSuperbands", "numsubplanes", "numSubcats", "numSuperbits", "numPercats", "numsubgroups", "numMicrocats", "numShortplanes", "numsubband", "numSupergroups", "numSubplanes", "nSubbands", "sumsubplanes", "numShortband", "numSuperlines", "numMicrogroups", "sumSubbands", "sumsubbands", " numPergroups", "nSuperbands"], "lastTonal": [" lastTone", "lastForal", "lastCronic", "lastFronic", "lasttonic", " lastBonic", "lastNotonal", "lastToral", " lastFooting", "lastTahn", "lastThon", "lastFooting", "lastFahn", "LastTon", "lastXTahn", "lastXTonic", "lasttooting", " lastToned", "LastThoral", "lasttonal", "lastTone", "lastBonal", "lastConed", "lastTonic", " lastTonic", "lastBone", " lastFonal", " lastTahn", "lastTronic", " lastTronic", "lastXTronic", "LastThonal", " lastFahn", "lastTooting", " lastBronic", " lastFonic", "lastBahn", "lastThoral", "lastBoned", "lasttone", "lastConal", " lastTooting", "lastConic", "lastNoton", " lastFronic", "lastFonic", "LastThoned", "lastNotoral", "lastNotoned", "lastFoned", "lastBooting", "LastTonal", "LastThon", "LastToned", "lastThoned", "lastTon", "LastToral", "lastBonic", "lastBronic", "lastToned", "lastThonal", "lastXTonal", "lastFone", " lastBonal", " lastBoned", " lastFone", "lastFonal", "lastFon"], "numBands": ["sumBands", "sumbannels", "numChands", "sumBounds", " numBards", "numBans", "sumWands", "numBayers", "numbounds", "umBards", " numBannels", "sumBbands", "numRands", "NUMBans", "numWounds", "numbands", "numBsbands", " numBsands", "numWans", "numChbands", "sumbbands", "numBbands", "numDands", "numDannels", "numPlannels", "numChayers", "NUMBayers", "numBsays", "numCans", "numbbands", "numDayers", "numbacks", "numBounds", "numPlards", "numBacks", "numBsands", "numBays", "numCands", "sumBacks", "numPounds", "NUMDans", "NUMBannels", "numBsounds", "numCannels", "numRards", "sumWacks", "numBsards", "numDans", "sumWounds", "numWands", "sumbands", "numRbands", "umBands", "numPans", "numRannels", " numBsards", "umBsards", "numPacks", "numBannels", "NUMDands", "umBsbands", "numChans", "numChannels", "numBsannels", "NUMBands", "numCayers", "numWacks", "numbays", "sumBannels", " numBays", "numChounds", "umBbands", "NUMDayers", "numPlands", "umBsands", "numPlays", "numbannels", "NUMDannels", " numBsannels", "sumBans", "numPands", "umBsannels", "numbards", "sumWans", "sumbounds", " numBsays", "umBannels", "numbans", "numBards"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n", "idx": 1420, "substitutes": {"md": ["mn", "cm", "dd", "pd", "conn", "mc", "mb", "ad", "d", "mi", "mm", "mo", "mac", "m", "mid", "hd", "dm", "cd", "MD", "cmd", "meta", "nm", "det", "module", "mode", "nd", "metadata", "mem"], "val": ["pl", "base", "vol", "arg", "key", "elt", "vals", "ee", "Val", "fl", "sl", "bl", "pos", "index", "pid", "sol", "cond", "sel", "x", "p", "len", "f", "ref", "eval", "value", "el", "min", "il", "pc", "v", "al", "lit", "VAL", "count", "pt", "all"], "env": ["eu", "np", "vm", "server", "exe", "ass", "conn", "inv", "equ", "environment", "n", "export", "nc", "ea", "scope", "end", "enc", "po", "inet", "eni", "hr", "args", "ah", "er", "err", "config", "ec", "exc", "h", "c", "state", "vs", "e", "eval", "conf", "cache", "viron", "el", "obj", "en", "v", "ev", "nw", "inst", "cf", "manager", "me", "zone", "net", "ex", "db"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)\n\n{\n\n    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);\n\n    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);\n\n}\n", "idx": 1426, "substitutes": {"dst": ["sdost", "idost", "lsts", "ldst", "datsts", "datost", "ndsts", "idst", "sdbl", "idbl", "adst", "dsts", "idsts", "adste", "dST", "ddest", "ndbl", "gconst", "sdsts", "ldbl", "gsts", "gst", " dconst", "sst", "adsts", "lost", "dconst", "sST", "sdput", "lST", "sdst", "ldste", " dsts", "dbl", "ldsts", "lst", "dste", "idput", "idste", "idconst", "sost", "dput", "datdest", "ndst", " dST", "datst", " dost", "sddest", " ddest", "ndput", "dost", "adbl", "gost", "ssts"], "block": ["unit", "flow", "group", "lock", "name", "row", "buffer", "check", "no", "time", "def", "key", "byte", "panel", "device", "new", "image", "out", "type", "tick", "bc", "chain", "record", "un", "end", "frame", "off", "pre", "batch", "output", "label", "none", "box", "number", "index", "ip", "down", "work", "keep", "col", "prev", "cache", "object", "obj", "comment", "Block", "blocks", "point", "clean", "line", "wall", "view", "load", "list", "start", "diff", "pack"], "stride": ["charine", "STRane", "brace", "trider", "trane", "brision", "gride", "brine", "drider", " strider", "grIDE", "strue", "erride", "strice", " strid", "trided", "charide", " strue", " strided", "Strace", "striide", " strane", "striine", "strine", "STRided", "drine", "trides", "tride", "brided", "charider", "frider", "grider", "strider", "brider", "constision", "frine", "Strine", " strine", "errides", "strane", "trine", "grine", "arrice", "strIDE", "arride", "Strue", "strided", "strides", "constide", "Strided", "fride", "striider", "Strid", "STRider", "Stride", "arrider", "arrid", "STRide", " strides", " strision", "frided", "striIDE", "arrided", "drice", "bride", "arrue", "errider", "constided", "constider", "strid", "charice", "strision", "dride", " strace", "errided", "strace", "trIDE", "Strider", "errine", "arrine"]}}
{"project": "qemu", "commit_id": "b86160555f8d1fe11d6bcec393e08e645d7e1e8d", "target": 1, "func": "static void integratorcp_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"integrator.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    /* And again at address 0x80000000 */\n\n    memory_region_init_alias(ram_alias, NULL, \"ram.alias\", ram, 0, ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);\n\n\n\n    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}", "idx": 1434, "substitutes": {"args": ["sg", "parser", "arg", "ig", "missing", "same", "cs", "any", "ass", "active", "spec", "conn", "actions", "new", "flags", "aws", "results", "use", "ins", "empty", "lang", "arms", "arr", "enc", "api", "ids", "GS", "params", "err", "ras", "resources", "utils", "parse", "ams", "config", "gs", "ds", "ns", "gas", "words", "atts", "cmd", "plugin", "points", "Args", "ks", "ants", "module", "ands", "sci", "init", "ages", "states", "apps", "plugins", "parts"], "cpu_model": ["cpu___model", "cpuetmode", "cpuetmodel", "gpu_network", "cpu67server", "cpujmodel", " cpu_type", "cpu_channel", "cpu_type", "cpu_network", "gpu_size", "memory___model", "cpuetnetwork", "cpulexmodel", "cpujchannel", "memory_server", "cpu67model", "cpu_mode", "memory___range", "gpu_mode", "cpu_size", "cpulexserver", "gpu_machine", "cpulexfolder", "memory___server", "cpu_server", "cpu_range", "gpu_scope", "cpujmachine", " cpu_engine", "memory_folder", "cpu___folder", "cpu_folder", "memory_model", "cpuetmachine", " cpu_models", "cpu67range", "cpu_models", "cpulexrange", "cpu67folder", "gpu_channel", "cpu___server", "cpu_machine", "cpujmode", "gpu_model", "memory___folder", "cpu___range", "memory_range", "cpu_engine", "cpu_scope"], "kernel_filename": ["intelbookdirectory", "kernelbookmodel", "kernel_file", "cpu_filename", "kernelbookfilename", "kernel_size", "intelbookfile", "intel_directory", "intelbookmodel", "kernel_model", "kernel_directory", "intel_model", "kernelbookfile", "kernelbookdirectory", "intel_file", "intel_filename", "cpu_size", "intelbookfilename", "kernel_label", "cpu_label"], "kernel_cmdline": ["kernel_hostline", "kernel_cfline", "kernel_commandLine", "kernel_commandpass", "kernel_cfLine", "kernel_reqline", "kernel_hostsl", "kernel_commandsl", "kernel_cmdpass", "kernel_cmdsl", "kernel_reqsl", "kernel_hostpass", "kernel_commandlf", "kernel_cfpass", "kernel_commandline", "kernel_hostlf", "kernel_hostLine", "kernel_cflf", "kernel_reqLine", "kernel_cmdLine", "kernel_cmdlf"], "initrd_filename": ["initrd_files", "initrd__uri", "initrs_output", "initrt_filename", "initrt_fn", "initrt_uri", "initrd_fn", "initrs_filename", "initrd_uri", "initrd__fn", "initrs_files", "initrd_file", "initrt_file", "initrd_output", "initrd__filename", "initrs_file", "initrd__file"], "cpu": ["fc", "np", "vm", "null", "cli", "gpu", "cam", "uno", "lan", "ctx", "intel", "hw", "roc", "ni", "gc", "mc", "mx", "process", "device", "host", "computer", "clock", "gnu", "GPU", "lu", "bc", "px", "nc", "nic", "boot", "instance", "kernel", "component", "mac", "eni", "CPU", "proc", "pool", "config", "disk", "cu", "c", "bus", "cow", "vidia", "ro", "pu", "lc", "cache", "core", "cn", "loader", "chip", "processor", "node", "alloc", "pc", "linux", "cp", " CPU", "uu", "net", "performance", "mem"], "address_space_mem": ["address_space_mode", "address_pace_mode", "address_space2mem", "address_spaceacmem", "address_pace_disk", "address_space2ram", "address_space54ram", "address_spaceacgram", "address_space_gram", "address_space_ram", "address_space_memory", "address_pace2mem", "address_space2mode", "address_pace2mm", "address_pace_ram", "address_spaceacdisk", "address_space64ram", "address_pace2mode", "address_pace_gram", "address_space2usage", "address_pace2usage", "address_space54mode", "address_space2mm", "address_space_mm", "address_pace_memory", "address_pace_mem", "address_pace_mm", "address_space64gram", "address_spaceacram", "address_space2memory", "address_pace2ram", "address_pace2memory", "address_space64mem", "address_space54mm", "address_space_disk", "address_pace_usage", "address_space54mem", "address_space64disk", "address_space_usage"], "ram": ["rg", "cm", "vm", "rage", "gpu", "cam", "micro", "lan", "buffer", "gram", "hw", "access", "dim", "mc", "rw", "process", "memory", "image", "sam", "mm", "Ram", "iam", "na", "param", "space", "mac", "ra", "scan", "mor", "program", "RAM", "gam", "disk", "man", "rank", "resource", "jam", "arm", "sc", "win", "region", "rom", "thread", "rum", "sim", "am", "mode", "gra", "nam", "pack", "mem"], "ram_alias": ["ramsrole", "ram_size", "memory_area", "memory_size", "gram_prefix", "ramjrole", "memory_alias", "memory_ias", "ramjsize", "ramsalias", "ram_ias", "ram_region", "ram_ali", "gram_area", "gram_alias", "ramssize", "memory_ali", "gram_size", "memory_region", "ramsali", "memory_role", "ram_area", "ramjali", "ram_role", "ramjalias", "ram_prefix"], "pic": ["fc", "lic", "ig", "src", "Pic", "fs", "mic", "data", "pi", "icon", "bc", "bin", "nic", "arr", "py", "mac", "ac", "proc", "sync", "str", "config", "pid", "bus", "arc", "pu", "cache", "sys", "gb", "pins", "sec", "pc", "lib", "seq", "ic", "img", "fi", "pin", "xi", "__"], "dev": ["test", "vm", "adv", "gpu", "cam", "def", "dd", "hw", "spec", "mod", "device", "sd", "dim", "conn", "go", "data", "d", "di", "ver", "development", "prop", "der", "priv", "de", "grad", "dom", "DEV", "Dev", "proc", "plug", "bug", "push", "ch", "home", "dc", "result", "disk", "gu", "bus", "block", "prom", "pu", "app", "conf", "cache", "die", "node", "driver", "v", "comment", "lib", "ev", "dem", "rad", "error", "var", "od", "serv", "vd", "pro", "img", "debug", "diff", "gd", "mem"], "i": ["clip", "yi", "li", "gi", "a", "ni", "ii", "area", "zi", "ji", "chi", "ui", "pi", "oi", "d", "I", "di", "n", "id", "mi", "it", "iu", "uli", "num", "loop", "j", "y", "ri", "eni", "code", "m", "ti", "slice", "ini", "index", "ani", "multi", "z", "ai", "ip", "x", "hi", "p", "phi", "bi", "l", "e", "c", "f", "child", "u", "gui", "o", "v", "vis", "ix", "qi", "b", "t", "uri", "ci", "count", "si", "mu", "fi", "diff", "xi"]}}
{"project": "qemu", "commit_id": "30c367ed446b6ea53245589a5cf373578ac075d7", "target": 1, "func": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n", "idx": 1435, "substitutes": {"obj": ["ob", "fo", "js", "att", "ctx", "hw", "ant", "conn", "host", "inv", "objects", "env", "buf", "op", "tmp", "api", "Obj", "j", "po", "pos", "nt", "impl", "opt", "org", "object", "o", "ev", "iv", "serv", "inst", "os", "od", "img", "val", "pt", "emb", "ex"], "v": ["vm", "vp", "hw", "vt", "volt", "r", "d", "n", "k", "env", "j", "g", "i", "m", "ov", "sv", "vv", "h", "l", "c", "p", "vs", "w", "e", "f", "u", "uv", "V", "vc", "o", "s", "ev", "b", "t", "conv", "tv", "vd"], "opaque": ["opacity", "operaco", "oppac", " opac", "opac", "oppaque", "operaque", "opaco", "oppaco", " opacity", "opalias", " opalias", "operalias", "oppacity", "opsc", "operac", "opsalias", "operacity", "opsaque", " opaco", "opsac", "opc", "operc", " opc"], "name": ["property", "base", "named", "version", "time", "key", "a", "alias", "device", "data", "image", "new", "n", "type", "nam", "unknown", "parent", "num", "pass", "i", "param", "space", "label", "none", "code", "info", "number", "names", "str", "address", "description", "word", "x", "ip", "block", "Name", "size", "resource", "ame", "value", "comment", "o", "nm", "prefix", "error", "path", "port", "family", "part", "NAME", "desc", "option"], "errp": ["errorf", "errP", "resultpc", " err", "erP", "resultr", "errorpat", "eorp", "erpc", " errpr", "errpe", "errorpc", "nerpc", "errpc", "nerP", " errpe", "erpat", "eorpr", "erf", "errorP", " erp", " errr", "errorps", "err", " erf", "resultp", "errps", "errr", " erpat", "errpat", "resultpe", " errpc", "erpe", "errorp", "erp", "nerps", "eorpc", "eorr", "nerp", "errpr", "errorr", "erps", "errf", "erpr"], "dev": ["adv", "ow", "vol", "cam", "dd", "def", "hw", "conn", "device", "data", "r", "development", "d", "ad", " priv", "ver", "kind", "priv", "env", "de", "dom", "DEV", "Dev", "ve", "info", "bug", "md", "pub", "dc", "bus", "gu", "p", "prom", "w", "private", "dm", "f", "attr", "conf", "cd", "wd", "die", "o", "ev", "dem", "prov", "rad", "od", "pro", "engine", "debug", "gd"], "prop": ["property", "def", "device", "Prop", "data", "prot", "type", "priv", "pb", "env", "op", "param", "j", "pos", "proc", "info", "pod", "project", "properties", "pid", "pointer", "config", "opt", "ip", "owner", "pkg", "p", "phi", "pr", "pred", "f", "ref", "attr", "jp", "mp", "cp", "pro", "path", "lit", "root", "part", "typ", "option"], "peers_ptr": ["peers_pointers", "peers_ref", "peer_pointers", "peers_tr", "peer_tr", "peer_pointer", "peer_ptr", "peers_pointer", "peer_ref"], "ptr": ["rot", "dr", "fd", "src", "trace", "ext", "spl", "inter", "offset", " pointer", "peer", "wr", "pri", "prot", "loc", "grad", "buf", "tmp", "arr", "pair", "pos", "proc", "plug", "pointers", "tr", "str", "pointer", "pad", "Ptr", "pr", "phy", "length", "ref", "br", "attr", "ctr", "eth", "pty", "alloc", "inst", "req", "pro", "addr", "rt", "vr", "slave", "pt", "fi", "port"], "local_err": ["remote_error", "local_bug", "remote_bug", "local_errors", "local_war", "local_er", "remote_er", " local_error", "local_addr", "localenerror", "remote_err", " local_er", "localenerrors", "local_error", "remote_war", "localenerr", "localener", " local_errors", "remote_addr"], "id": ["base", "ig", "q", "key", "bit", "sid", "data", "url", "d", "type", "is", "kind", "oid", "ID", "end", "parent", "num", "api", "ids", "i", "code", "Id", "info", "ension", "mid", "rid", "index", "pid", "ident", "address", "ie", "ip", "x", "pad", "kid", "vid", "age", "p", "h", "ide", "f", "ref", "patch", "cd", "pc", "seq", "b", "uid", "path", "addr", "val", "root", "part", "one", "start", "in"], "hubport": ["hubpoint", "bittype", "labserver", "ubaddress", "homep", " hubpoint", "Hubort", "labPort", " hubports", "ubserver", "Hubtype", "ubort", "ubPort", "hubtype", "bitports", "homeport", "labort", "ubp", "bitort", "hubaddress", "HubPort", "hubp", "hubserver", " hubp", "hubPort", " hubserver", "Hubpoint", "Hubports", "labpoint", "homeaddress", "ubport", "hubort", "labports", " hubort", " hubtype", "labport", "hubports", "homeort", " hubaddress", "bitport", " hubPort", "Hubport"]}}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 1439, "substitutes": {"avctx": ["afconfig", "afcb", "AVctx", "avnas", "avectx", " avcus", "afcas", "afcmp", "afctx", "afcontext", "AVcus", " avcmp", "AVnas", "avcus", " avcontext", "manconfig", "avcms", "avecb", "afnas", "avalcas", "mancontext", "afcus", "AVcu", "afcms", "afcu", "avcb", "avcas", "avecas", "avalconfig", "mancms", "avconfig", "avalcontext", "avalcms", "avcontext", "manctx", "avalcb", "avecontext", "avcmp", "avcu", " avnas", "AVcmp", "AVcontext", "avecmp", "avecu", "avalctx"], "s": ["sg", "this", "js", "qs", "n", "g", "ses", "ls", "args", "css", "vs", "self", "us", "f", "sys", "u", "an", "fs", "stat", "ts", "sb", "aws", "uploads", "xs", "sets", "p", "e", "comm", "as", "v", "S", "t", "os", "ks", "session", "its", "bs", "sym", "ssl", "acs", "cs", "ctx", "ss", "a", "rs", "new", "r", "is", "ins", "i", "m", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "service", "ops", "d", "ans", "ms", "sync", "l", "services", "w", "sq", "b", "full"]}}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n", "idx": 1457, "substitutes": {"chr": ["chrs", " chra", "chnru", "cherrb", "CHrf", "cherr", " chrg", "chro", "CHrs", " chrs", "cherru", "chsr", "Chrg", "CHr", "chc", "Chsr", " chsr", "chnr", "thc", "thsr", " chrf", "Chc", "Chr", " chru", "thr", "chnra", "chra", "chrf", "Chrs", "thro", " chrb", "chrb", "cherra", " chc", "Chrf", "chrg", "CHrg", "chnrb", "Chro", "chru", " chro"], "s": ["sg", "js", "service", "cs", "http", "ss", "stat", "rs", "sa", "ts", "spec", "sb", "r", "d", "n", "aws", "is", "ins", "sl", "i", "g", "ses", "ls", "sf", "args", "sync", "uns", "settings", "sv", "ds", "sets", "ps", "gs", "ns", "l", "c", "p", "state", "services", "e", "self", "f", "es", "us", "o", "stats", "b", "su", "S", "t", "ks", "your", "bs", "its", "hs", "se", "fs", "si", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "73a60633143b7c51333a0772b45a47282ac445b6", "target": 1, "func": "static int probe_file(WriterContext *wctx, const char *filename)\n\n{\n\n    AVFormatContext *fmt_ctx;\n\n    int ret, i;\n\n    int section_id;\n\n\n\n    do_read_frames = do_show_frames || do_count_frames;\n\n    do_read_packets = do_show_packets || do_count_packets;\n\n\n\n    ret = open_input_file(&fmt_ctx, filename);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n#define CHECK_END if (ret < 0) goto end\n\n\n\n    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));\n\n    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));\n\n    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));\n\n\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        if (stream_specifier) {\n\n            ret = avformat_match_stream_specifier(fmt_ctx,\n\n                                                  fmt_ctx->streams[i],\n\n                                                  stream_specifier);\n\n            CHECK_END;\n\n            else\n\n                selected_streams[i] = ret;\n\n            ret = 0;\n\n        } else {\n\n            selected_streams[i] = 1;\n\n        }\n\n    }\n\n\n\n    if (do_read_frames || do_read_packets) {\n\n        if (do_show_frames && do_show_packets &&\n\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n\n        else if (do_show_packets && !do_show_frames)\n\n            section_id = SECTION_ID_PACKETS;\n\n        else // (!do_show_packets && do_show_frames)\n\n            section_id = SECTION_ID_FRAMES;\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_header(wctx, section_id);\n\n        ret = read_packets(wctx, fmt_ctx);\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_footer(wctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_programs) {\n\n        ret = show_programs(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_streams) {\n\n        ret = show_streams(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_chapters) {\n\n        ret = show_chapters(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_format) {\n\n        ret = show_format(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\nend:\n\n    close_input_file(&fmt_ctx);\n\n    av_freep(&nb_streams_frames);\n\n    av_freep(&nb_streams_packets);\n\n    av_freep(&selected_streams);\n\n\n\n    return ret;\n\n}\n", "idx": 1469, "substitutes": {"wctx": ["twcontext", "qcontext", "fcmp", "fcontext", "twcm", "webcontext", " wcontext", "wcca", "twctx", "fctx", "webctx", "twcca", "swcontext", "awcm", "Wcb", "wcmp", "webtx", "awcca", " wlc", "wcm", "awcontext", "flc", "swctx", "qtx", "webjc", "qctx", " wtx", "qjc", " wcca", "Wcontext", " wcm", "Wcmp", "wlc", "swcmp", "wtx", "Wctx", "wjc", "wcb", "swcb", " wcmp", " wcb", "awctx", "Wlc", " wjc", "wcontext"], "filename": ["files", "name", "fd", "buffer", "utf", "txt", "acl", "url", "binary", "tty", "fn", "wl", "fil", "directory", "rb", "Filename", "file", "fp", "document", "source", "kn", "bf", "word", "dll", "f", "kl", "length", "rl", "username", "il", "phrase", "path", "location", "title"], "fmt_ctx": ["fnt_tx", "fmt_loc", "fmt_co", "ftm_cas", "fmtjloc", "fnt_col", "filt_ctx", "fformat_tx", "fformat_lc", "fmt_lc", "fmt2cmp", "fnt_cmp", "frt_ctx", "frt_context", "frt_ca", "filt_context", "fnt_c", "fnt_rc", "filt_cms", "fnt_ctx", "filt_lc", "ftm_sc", "fmtjctx", "ftm_ctx", "filt_co", "fmtjc", "fmtjcontext", "fmt_tx", "fmtpcontext", "fmt_la", "fmt_cms", "fformat_cmp", "fnt_ci", "fmt_cmp", "fmt2ctx", "fnt_context", "fmtptx", "fmt_ci", "fmt_rc", "filt_cmp", "fmtpctx", "fmt_context", "ftm_la", "fnt_lc", "fmt_c", "fmtpci", "fmt2co", "fmt2cv", "fnt_loc", "fmt_ca", "fmt_col", "fmt_sc", "frt_cmp", "fmt_cas", "filt_cv", "fformat_ctx", "fmt_cv"], "ret": ["rot", "success", "alt", "job", "rep", "code", "tr", "Ret", "opt", "en", "RET", "valid", "rt", "fun", "ext", "sb", "format", "id", "rets", "fit", "arr", "fail", "reply", "rc", "sr", "session", "lit", "re", "val", "det", "att", "mt", "data", "cat", "ll", "info", "str", "back", "feat", "result", "ut", "len", "ref", "value", "obj", "error", "reg", "res", "mem", "match", "def", " Ret", "ry", "cur", "pet", "num", " RET", "rb", "nt", "ft", "rev", "status", "bf", "rl", "flag", "gt", "resp", "db"], "i": ["yi", "li", "gi", "abi", "ni", "ii", "zi", "jit", "ui", "pi", "oi", "ib", "d", "I", "di", "n", "id", "mi", "iu", "ij", "j", "y", "m", "ri", "eni", "inner", "info", "ti", "ini", "index", "multi", "ai", "ie", "ip", "ind", "l", "p", "phi", "bi", "x", "e", "lc", "f", "u", "v", "s", "ix", "qi", "b", "uri", "ci", "io", "mu", "part", "fi", "si", "xi"], "section_id": ["sectionalno", "section_uid", "sectionUsearch", "thread_id", "thread_search", " section_name", "section_ip", "section_type", " section_num", "section2type", " section_uid", "sector_type", "section2ip", "section_search", "sectionEtype", "section_name", "section_ids", "sectionalid", " section_no", "sector_name", "thread_it", "section2num", "section2id", "section_side", "section_no", "sectionEid", "sectionerids", " section_type", " section_ids", "section_it", "sectionUmin", "section_num", "sectionerid", "threadUid", " section_ip", "section_min", " section_side", "sectionUid", "sector_kid", "threadUsearch", "sectionaltype", "section_kid", "sectionEside", "sectionername", "sectionEno", "sectionUit", "threadUit", "sector_id", "sectioneruid", "sectionalside", "threadUmin", "thread_min"], "selected_streams": ["selected_feeds", "selected_reams", "selected_outputsites", "selected_streamows", "selected_threaduploads", "selected_outputd", "selected_ucd", "selected_streamd", "selected_draftments", "selected_columnuploads", "selected_streamuploads", "selected_columnds", "selected_streamships", "selected_lengthds", "selected_ucds", "selected_columns", "selected_streamflows", "selected_feedds", "selected_lengthuploads", "selected_pathd", "selected_columnflows", "selected_feedsites", "selected_hooks", "selected_reamships", "selected_draftsets", "selected_threads", "selected_paths", "selected_hookows", "selected_feedd", "selected_drafts", "selected_ucsites", "selected_lengths", "selected_streamds", "selected_hookd", "selected_threadships", "selected_threadds", "selected_reamments", "selected_pathsets", "selected_hooksets", "selected_draftships", "selected_outputs", "selected_threadflows", "selected_draftows", "selected_threadments", "selected_streamsets", "selected_lengthflows", "selected_ucs", "selected_streamsites", "selected_threadd", "selected_reamd", "selected_outputds", "selected_draftd", "selected_streamments", "selected_pathows"]}}
{"project": "qemu", "commit_id": "51b0c6065aa6e47a47094d73e24be298a4a7f3a1", "target": 1, "func": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    KVMState *s = kvm_state;\n\n    unsigned long size, allocated_size = 0;\n\n    KVMDirtyLog d;\n\n    KVMSlot *mem;\n\n    int ret = 0;\n\n\n\n    d.dirty_bitmap = NULL;\n\n    while (start_addr < end_addr) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n\n        if (mem == NULL) {\n\n            break;\n\n        }\n\n\n\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n\n        if (!d.dirty_bitmap) {\n\n            d.dirty_bitmap = qemu_malloc(size);\n\n        } else if (size > allocated_size) {\n\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n\n        }\n\n        allocated_size = size;\n\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n\n\n        d.slot = mem->slot;\n\n\n\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n\n            ret = -1;\n\n            break;\n\n        }\n\n\n\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n\n                                      mem->start_addr, mem->memory_size);\n\n        start_addr = mem->start_addr + mem->memory_size;\n\n    }\n\n    qemu_free(d.dirty_bitmap);\n\n\n\n    return ret;\n\n}\n", "idx": 1473, "substitutes": {"start_addr": ["start64address", "start64ad", "starterpos", "startwhop", "start_ad", "starteraddress", "start_slot", "starteraddr", "start_ptr", "start__address", "end_offset", "startfulladdress", "start_src", "startwaddr", "start_offset", "end_pos", "startfad", "startipaddr", "start_address", "startfullloc", "end_src", "end_hop", "startfaddr", "start_loc", "end_ad", "start_pos", "startfullroute", "start_host", "end_route", "end_host", "startipsize", "startwslot", "end_address", "startfaddress", "end_slot", "startipaddress", "start_ace", "start_size", "starterptr", "startfhost", "start64host", "startipsrc", "start_hop", "start64addr", "end_loc", "start64ace", "start64offset", "end_ptr", "start__hop", "startfulladdr", "startwaddress", "end_ace", "end_size", "start_route", "start__offset", "start__addr"], "end_addr": [" end_align", "start_ptr", "endowaddr", "end__address", "endfaddress", "end_offset", " end_address", "end_align", "endfadr", "end_pos", "end__offset", "start_offset", "end__size", "endfsize", "end_ptr", "end__addr", "start_adr", "endowaddress", "end__ptr", "end_address", "start_address", "end__adr", "end_size", "end_adr", "endfaddr", " end_pos", "endowalign", "start_size", "endowpos"], "s": ["sg", "js", "spec", "ts", "sb", "r", "n", "aws", "sl", "client", "i", "g", "instance", "m", "ses", "sf", "storage", "status", "gs", "hm", "ns", "c", "p", "state", "w", "e", "f", "sys", "sq", "south", "o", "v", "su", "b", "S", "t", "session", "os", "socket", "site", "si", "sym", "ssl"], "size": ["capacity", "large", "go", "weight", " error", "empty", "handle", "g", "code", "big", "err", "storage", "address", "Size", "en", "sum", "fee", "unit", "name", "time", "sized", "form", "ui", "id", " address", "max", " Size", "e", "length", "scale", "iz", "count", "cm", "SIZE", " name", "offset", "data", "new", "small", "speed", "loc", "use", "member", "i", "content", "len", "value", "sec", "izes", "shape", "si", "_", "ize", " code", " sizes", "false", "grow", "number", "full"], "d": ["dr", "fd", "ld", "dn", "da", "dd", "pd", "mod", "sd", "dh", "dad", "data", "n", "di", "ad", "dl", "xd", "ct", "id", "dict", "k", "de", "did", "dom", "i", "g", "j", "y", "m", "dy", "er", "dt", "md", "ds", "z", "dc", "l", "c", "p", "ind", "state", "w", "e", "dm", "f", "bd", "u", "cd", "dj", "cmd", "obj", "wd", "rd", "o", "b", "t", "od", "vd", "ded", " dd", "dat", "nd", "ed", "D", "gd", "db", "done"], "mem": ["vm", "fun", "name", "em", "hw", "conn", "mod", "dim", "mc", "access", "bm", "memory", "image", "go", "mb", "loc", "com", "lif", "slot", "sp", "ge", "buff", "mi", "im", "mm", "mo", "de", "job", "ne", "bin", "ha", "prof", "bl", "member", "g", "num", "lim", "imm", "m", "info", "mor", "gem", "md", "om", "program", "home", "gu", "dev", "w", "du", "Mem", "ram", "rem", "mon", "rm", "cache", "pm", "alloc", "sum", "node", "tm", "nm", "um", "sm", "serv", "dem", "ev", "session", "wa", "reg", "ann", "am"]}}
{"project": "FFmpeg", "commit_id": "eb465b8c56d455fddf0f4f9f2625e2fe3ff7ea06", "target": 1, "func": "static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],\n\n                   int dst_stride[3], int src_stride[3], int width,\n\n                   int height, uint8_t *qp_store, int qp_stride)\n\n{\n\n    int x, y, i, j;\n\n    const int count = 1<<p->log2_count;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int is_chroma = !!i;\n\n        int w = width  >> (is_chroma ? p->hsub : 0);\n\n        int h = height >> (is_chroma ? p->vsub : 0);\n\n        int stride = p->temp_stride[i];\n\n        int block = BLOCK >> (is_chroma ? p->hsub : 0);\n\n\n\n        if (!src[i] || !dst[i])\n\n            continue;\n\n        for (y = 0; y < h; y++) {\n\n            int index = block + block * stride + y * stride;\n\n\n\n            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );\n\n            for (x = 0; x < block; x++) {\n\n                p->src[i][index     - x - 1] = p->src[i][index +     x    ];\n\n                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];\n\n            }\n\n        }\n\n        for (y = 0; y < block; y++) {\n\n            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);\n\n            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);\n\n        }\n\n\n\n        p->frame->linesize[i] = stride;\n\n        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));\n\n    }\n\n\n\n    if (p->qp)\n\n        p->frame->quality = p->qp * FF_QP2LAMBDA;\n\n    else {\n\n        int qpsum=0;\n\n        int qpcount = (height>>4) * (height>>4);\n\n\n\n        for (y = 0; y < (height>>4); y++) {\n\n            for (x = 0; x < (width>>4); x++)\n\n                qpsum += qp_store[x + y * qp_stride];\n\n        }\n\n        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;\n\n    }\n\n//    init per MB qscale stuff FIXME\n\n    p->frame->height = height;\n\n    p->frame->width  = width;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        const int x1 = offset[i+count-1][0];\n\n        const int y1 = offset[i+count-1][1];\n\n        const int x1c = x1 >> p->hsub;\n\n        const int y1c = y1 >> p->vsub;\n\n        const int BLOCKc = BLOCK >> p->hsub;\n\n        int offset;\n\n        AVPacket pkt;\n\n        int got_pkt_ptr;\n\n\n\n        av_init_packet(&pkt);\n\n        pkt.data = p->outbuf;\n\n        pkt.size = p->outbuf_size;\n\n\n\n        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];\n\n        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];\n\n        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];\n\n        p->frame->format  = p->avctx_enc[i]->pix_fmt;\n\n\n\n        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);\n\n        p->frame_dec = p->avctx_enc[i]->coded_frame;\n\n\n\n        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];\n\n\n\n        for (y = 0; y < height; y++)\n\n            for (x = 0; x < width; x++)\n\n                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];\n\n\n\n        if (!src[2] || !dst[2])\n\n            continue;\n\n\n\n        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];\n\n\n\n        for (y = 0; y < height>>p->vsub; y++) {\n\n            for (x = 0; x < width>>p->hsub; x++) {\n\n                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];\n\n                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];\n\n            }\n\n        }\n\n    }\n\n\n\n    for (j = 0; j < 3; j++) {\n\n        int is_chroma = !!j;\n\n        if (!dst[j])\n\n            continue;\n\n        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],\n\n                      width  >> (is_chroma ? p->hsub : 0),\n\n                      height >> (is_chroma ? p->vsub : 0),\n\n                      8-p->log2_count);\n\n    }\n\n}\n", "idx": 1476, "substitutes": {"p": ["q", "current", "n", "sp", "pb", "g", "progress", "self", "private", "f", "prev", "u", "jp", "s", "at", "cp", "wp", "pp", "port", "pi", "ap", "k", "parent", "api", "P", "python", "parse", "post", "pa", "e", "per", "hp", "php", "v", "t", "np", "vp", "lp", "a", "data", "r", "press", "op", "pre", "py", "m", "proc", "project", "ps", "h", "c", "app", "cache", "o", "bp", "http", "d", "pg", "cop", "it", "comp", "tp", "temp", "ip", "l", "w", "exec", "up", "pc", "b", "pro", "part"], "dst": ["Dsrc", "frc", "fbl", "idsrc", "idst", "Dsts", " dstruct", "adst", "dsts", "drc", "idsts", " dsrc", "sst", "adsts", "fst", "fsts", "adrc", "dstruct", " dsts", "dsrc", "dbl", "Dstruct", "idstruct", "Dst", "adbl", "sbl", "ssts"], "src": ["fc", "sub", "sup", "ctx", "rest", "split", "sb", "host", "url", "prot", "loc", "rob", "rect", "ins", "sl", "cur", "gz", "grad", "comp", "rend", "enc", "serv", "rb", "proc", "secure", "dest", "ser", "sync", "comb", "pack", "cb", "source", "config", "st", "scenes", "sel", "c", "cv", "stack", "ptr", "attr", "front", "sc", "gb", "agg", "sr", "sn", "lib", "seq", "gl", "rss", "inst", "sur", "conv", "iv", "supp", "cmp", "support", "bs", "low", "img", "obl", "uc", "desc", "dist", "rc", "ssl"], "dst_stride": ["dst_brided", "dst_arrider", "dst_striided", "dst_arrided", "dst_arrand", "dst_striide", "dst_strider", "dst_striand", "dst_strand", "dst_arride", "dst_strided", "dst_brider", "dst_brand", "dst_striider", "dst_bride"], "src_stride": ["src_bride", "src_bridi", "src_strided", "src_arrride", "src_brider", "src_dridi", "src_stridi", "src_arride", "src_striride", "src_brride", "src_strider", "src_striide", "src_dride", "src_striided", "src_arrider", "src_drided", "src_striidi", "src_striider", "src_brided", "src_drride", "src_arrided", "src_strride"], "height": ["resolution", "crop", "build", "fw", "image", "high", "window", "d", "distance", "margin", "head", "duration", "gap", "bottom", "dy", "direction", "z", "holes", "h", "pad", "ip", "thin", "block", "alpha", "layout", "w", "rank", "size", "length", "density", "padding", "pull", "depth", "hang", "wall", "volume", "shape", "rh", "Height"], "qp_store": ["qp__draw", "qlp__draw", "qlp_base", "qlp__base", "qp_slice", "qlp_slice", "qp__store", "qlp_store", "qp__base", "qp_draw", "qp_base", "qlp__slice", "qp__slice", "qlp_draw", "qlp__store"], "qp_stride": ["qp_striide", "qp_strider", "qp_strided", "qp_tride", "qp_trider", "qp_trid", "qp_brider", "qp_bride", "qp_striid", "qp_strid", "qp_trided", "qp_striided", "qp_brid", "qp_brided", "qp_striider"], "x": ["yx", "q", "time", "key", "a", "r", "d", "n", "is", "px", "id", "cy", "k", "xy", "g", "pos", "dx", "ady", "m", "dy", "code", "tx", "X", "xs", "z", "index", "xp", "xx", "h", "l", "c", "w", "e", "f", "ax", "u", "ww", "o", "v", "s", "b", "ix", "t", "Y", "rx", "wa", "xxx", "on", "wy", "ex", "xi", "wx"], "y": ["yi", "ye", "ii", "yl", "yo", "zy", "gy", "iy", "d", "n", "yr", "id", "ry", "cy", "xy", "ny", "ya", "ty", "g", "py", "ady", "year", "dy", "m", "yn", "ky", "z", "yy", "ey", "index", "h", "c", "block", "hi", "w", "e", "vy", "f", "col", "u", "hy", "o", "b", "ay", "t", "Y", "oy", "sky", "ym", "sy"], "i": ["cli", "mini", "n", "ij", "ti", "index", "f", "u", "ori", "uri", "fi", "abi", "esi", "ji", "zi", "pi", "ui", "id", "mi", "k", "iu", "api", "ri", "z", "ie", "e", "isi", "v", "iv", "ix", "qi", "t", "ik", "io", "init", "li", "a", "ni", "ii", "chi", "I", "di", "is", "m", "info", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "ih", "ei", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "bi", "ki", "b", "ci", "part", "xi"], "j": ["adj", "q", "ii", "ji", "r", "d", "n", "sh", "k", "ij", "g", "pos", "m", "dy", "z", "l", "c", "shift", "e", "f", "jp", "o", "v", "b"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n", "idx": 1487, "substitutes": {"nf": [" nfe", "Nfe", "nnfe", "nyc", "lnfen", "cnf", "lnfe", "nyfen", "nc", "ynF", "ynfen", "ynfe", "nnF", "nnfen", " nfen", "nnf", "nyf", "nF", "nfen", "Nf", "nb", " nc", "Nfen", "lnf", "lnF", "nyb", "cnfe", "Nb", "ynf", "nfe", "cnb", " nb", "cnc", "Nc"], "s": ["server", "service", "cs", "ss", "rs", "sa", "ts", "sb", "r", "sl", "g", "space", "ses", "ls", "sync", "sv", "tr", "cr", "ds", "ps", "gs", "ns", "c", "p", "sie", "services", "sw", "e", "f", "es", "sys", "sq", "ar", "south", "o", "sts", "stats", "b", "su", "S", "os", "t", "bs", "se", "fs", "si", "ssl"], "sr": ["rg", "dr", "cs", "ss", "rs", "gr", "rw", "JR", "sb", "rn", "rr", "r", "yr", "ru", "sp", "sl", "lr", "rf", "kr", "spr", "rb", "SR", "hr", "nr", "ser", "fr", "ir", "cr", "tr", "RS", "sv", "sol", "usr", "pr", "sw", "ar", "ctr", "rd", "RR", "rss", "rx", "sur", "rt", "vr", "rh"]}}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1497, "substitutes": {"tcet": ["tomET", "dcent", "tcat", "TClet", "tcets", "TCrt", "kuet", "TCet", "scnt", "timset", "TCets", "bcet", "tmot", " tcote", "tocets", "tcent", "TCET", "tomet", "TCent", "tcpet", "tmet", "tmets", "tocant", "tmett", "rcet", "rcinet", "tcote", "dcant", "TCant", "tocnt", "cmnt", "cmat", "tomett", "tocrt", "hhen", "tocet", "tcen", "tcot", "rcET", "tclet", "timpet", "scent", " tcset", " tcpet", "dcets", "tcset", "tcinet", "tocET", "ncet", "bcant", "hhinet", "bclet", "bcent", "timote", "cment", "dcet", "timet", "kuote", "ncen", "tcett", "kuset", "tmET", "rcen", "tcrt", "kupet", "tcnt", "hhet", "TCot", "scat", "ncinet", "tment", "tcant", "cmet", "hhET", "tomot", "bcat", "TCnt", "toclet", "tmant", "scet", "TCett", "tmrt", "bcnt", "ncET", "tcET"], "ioba": [" ioga", "lioby", "lioha", "siogg", "sioca", "ioca", "ioco", "uobe", "tioby", "uoba", "iogg", "siobe", "pioba", "enioha", " ioca", "siobi", "liunta", "piunta", "sioga", "sioby", "tioca", "enioba", "ioma", " iogg", "uogg", "sioba", "iobi", " ioby", "ioby", "pioco", " iobe", "pioha", "tioga", "tioba", "sioma", "piobe", "lioba", "enioby", " ioma", " ioco", "pioby", "piobi", "ioha", "sioco", "iobe", "eniunta", "uoma", "iunta", " iobi", "ioga"], "tce": [" tct", "tCE", " tke", "lace", "pfe", " tace", "tcp", "ptco", " tcp", "Tfe", "ptfe", " tcf", "lfe", " tco", "tct", "fCE", "pce", "tcer", "ttcer", "ttCE", "fcer", "lce", " tche", " tfe", "lke", "ttce", "Tcp", "TCE", " tCE", "tke", "tace", "Tct", "lcp", "pcf", "tche", "fce", "lCE", "tcf", "pke", "ptce", "fche", "Tace", "Tce", " tcer", "Tco", "tfe", "ttche", "lcf", "tco", "ptct"], "entry": ["match", "route", "server", "se", "row", "service", "offset", "inter", "key", "extra", "array", "data", "image", "new", "send", "add", " Entry", "type", "cat", "ge", "ry", "cur", "it", "record", "end", "insert", "ent", "member", "seed", "component", "Entry", "inner", "info", "event", "write", "index", "parse", "feed", "address", "ie", "result", "step", "or", "reader", "e", "try", "join", "obj", "comment", "connection", "way", "cel", "cell", "error", "element", "link", "module", "line", "engine", "valid", "enter", "part", "inc", "import", "response", "export", "slave"]}}
{"project": "qemu", "commit_id": "f73a2575a3bce8a3c487331c918d2c0f9b2e489d", "target": 0, "func": "static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,\n\n                            target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong pteh = args[2];\n\n    target_ulong ptel = args[3];\n\n    target_ulong i;\n\n    uint8_t *hpte;\n\n\n\n    /* only handle 4k and 16M pages for now */\n\n    if (pteh & HPTE_V_LARGE) {\n\n#if 0 /* We don't support 64k pages yet */\n\n        if ((ptel & 0xf000) == 0x1000) {\n\n            /* 64k page */\n\n        } else\n\n#endif\n\n        if ((ptel & 0xff000) == 0) {\n\n            /* 16M page */\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    /* FIXME: bounds check the pa? */\n\n\n\n    /* Check WIMG */\n\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n\n        return H_PARAMETER;\n\n    }\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&\n\n                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    stq_p(hpte, pteh);\n\n\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n", "idx": 1500, "substitutes": {"env": ["stage", "eu", "np", "server", "ext", "fen", "conn", "context", "esi", "txt", "her", "inv", "equ", "environment", "global", "que", "profile", "dict", "ea", "scope", "enc", "ef", "eni", "erv", "enh", "event", "dt", "config", "ec", "exc", " environment", "eye", "Environment", "eve", "cv", "fg", "state", "e", "conf", "gui", "viron", "chal", "el", "exec", "en", "eur", "iss", "ev", "site", "manager", "engine", "dat", "qt", "dir", "net", "energy", "db"], "spapr": ["spapprc", "spamper", "spAPer", "papprs", "spAPrs", "spampr", "spAPr", "spaper", "spapper", "spapprs", "spamprc", "paprc", "spAPrc", "papr", "papprc", "papper", "paper", "pappr", "spappr", "spamprs", "paprs", "spaprc", "spaprs"], "opcode": ["popcode", "ipcodes", "ipptr", "ipcomp", "ipcode", "opcomp", "popcodes", "popptr", "topptr", "topcomp", "opptr", "topcode", "topcodes", "opcodes", "popcomp"], "args": ["argument", "keys", "limits", "call", "arg", "alls", "extra", "array", "vals", "data", "members", "flags", "axis", "seconds", "aws", "results", "use", "is", "ins", "objects", "ms", "includes", "ims", "arms", "enc", "options", "GS", "params", "ars", "settings", "ports", "names", "utils", "parse", "ams", "config", "gs", "p", "words", "atts", "lines", "date", "message", "fires", "as", "uses", "uments", "fields", " arguments", "stats", "parts", "points", "Args", "ants", "ages", "apps", "actions"], "i": ["yi", "li", "gi", "key", "a", "ei", "ii", "zi", "ni", "chi", "ji", "pi", "ui", "image", "mini", "d", "I", "n", "di", "uni", "is", "id", "mi", "it", "k", "iu", "j", "y", "m", "eni", "info", "ti", "slice", "ini", "z", "index", "multi", "ai", "ie", "ip", "l", "c", "p", "x", "bi", "phi", "e", "f", "u", "o", "v", "s", "b", "qi", "uri", "ci", "count", "mu", "fi", "start", "si", "xi"], "hpte": ["Hctee", "hpportea", "pnt_", "hapto", "hporte", " haptee", "haptes", "hcte", "hpteh", "hcondedge", "hptedge", "Hpted", "hctei", "hemptea", "hporteh", " hptel", "hctedge", "hPTe", "hntea", "Hptee", "hempte", "hctes", " hntea", "haptel", " haptel", " haptedge", "hptone", "hprel", " hptea", "Hpteh", "hpt\n", "hptoned", "hnt_", "hcondee", " hpto", "hpport\n", "Hpte", "Hctel", "hpointel", "Hcte", "hrtel", "hcted", "hptes", "Hptel", "hPTen", "hiptee", "hemptel", " hptee", "haptee", "Hptei", "hemptee", "hptoneh", "hpree", "hipte", "Hctea", "hcten", "hpointi", "hpten", " hnte", "hpointee", " hptE", "hpportei", "haptedge", "hported", "hrtes", "hpt_", "hveyee", "hcondes", "hPTi", "hpointe", "Hcti", "hpti", "hptel", "hprea", "Hpti", "Hcteh", " haptes", "hpre", "hveyei", "hport\n", "hntE", "hveyea", "hpted", "hconde", "pnt\n", " hptedge", "Hptea", "hpto", "ppt_", "hpointen", "hrte", "hpportee", "hPTee", "hiptE", "hrto", "Hcten", "hnte", "hctee", "hportee", " hntee", "hpport_", "hnt\n", "hctel", "Hctei", "hport_", "Hcted", "hntee", "hptei", " hptes", "Hpten", "ppt\n", "hcteh", "hptee", "hapte", "hctE", "hcti", " hapto", " hntE", "hpointes", "hptonee", "hptea", "hiptea", "hpporte", " hapte", "hptE", "hctea", "hpointo", "hveye"]}}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 1507, "substitutes": {"ctx": ["cm", "JC", "np", " cx", "cli", "gpu", "kb", "hw", "conn", "context", "anc", "cc", "cl", "mc", "Context", "hub", "gru", "loc", "ck", "bc", "scope", "tc", "grad", "client", "concept", "cas", "comp", "component", "mac", "kt", "tx", "sync", "cb", "fp", "kw", "utils", "ch", "config", "crit", "progress", "chan", "exc", "pkg", "c", "cv", "jc", "cpu", "ocr", "ca", "sq", "sc", "exec", "git", "ctrl", "cmd", "jp", "vc", "linux", "cca", "lib", "qa", "cp", "cmp", "req", "cf", "conv", "ci", " context", "sci", "qt", "rc"], "ret": ["match", "arg", "att", "mt", "ext", "def", "active", "conn", "txt", "data", "out", "aux", "alt", "cat", "store", "id", "ry", "job", "rets", "info", "cb", "nt", "rev", "python", "tr", "back", "status", "Ret", "ft", "opt", "reply", "result", "usr", "cpu", "len", "ref", "eval", "sys", "rem", "git", "gt", "jp", "resp", "obj", "value", "linux", "RET", "final", "seq", "cmp", "rx", "lit", "re", "reg", "val", "addr", "rt", "fi", "det", "res", "mem"], "arg1": ["ar2", "ar1", "tag2", "att3", "rg3", "argument3", "rg2", "argument12", "argsone", "argument2", "Argone", "args3", "arm1", " arg12", "rg1", "tag1", "tagone", " arg3", "arg0", "args2", " arg01", "Arg1", "t2", "att12", "arg01", "arg12", "arm01", "rg01", "ar0", "ar3", "arm2", "t3", "argument01", "Arg3", "Arg2", "args1", "argone", "argument1", "arg3", " arg0", "tag01", "armone", " argone", "att1", "att2"], "arg2": ["val2", "arg4", "argument96", "valsecond", " arg96", "tag2", "args4", "arg62", "argument2", " argTwo", " arg62", "argsecond", "ig0", "doc1", "ttwo", "tag1", "t2", "arg0", "args2", "Arg1", "val1", "val62", "tag62", "arg96", "argtwo", "tagsecond", "args0", " argtwo", "doctwo", "argTwo", "ig1", "argument0", "ig96", " argsecond", "Arg2", "Arg0", "args1", "Arg4", " arg4", "tTwo", "doc2", "ig2", "argument1", " arg0", "docTwo"], "add_ca": ["addsna", "addfcar", "update_ca", "append_ca", "appendfcar", "addsca", "addfcca", "addingacl", "update_na", "addingaca", "add_cas", "append_cca", "addfca", "append_car", " add_Ca", "addsba", "add_acl", " add_acl", "add_na", "addscar", "add_car", "appendfcas", "addingca", "update_ba", "addingCa", "update_car", "add_Ca", "appendfca", "appendfcca", "add_ba", " add_aca", "add_cca", "addfcas", "append_cas", "add_aca"], "compute_ca": ["compute_bc", "compute___ca", "compure_ce", "compure_ca", "compute__ce", "compute___ce", "compute_ha", "compute__ca", "compulate_ba", "compure_na", "compute__Ca", "compure_ec", "compute_Ca", "compure_bc", "compure_ha", "compute_ce", "compulate_ca", "compure_Ca", "compute_cr", "compute_ec", "compute___bc", "compute_na", "compute__na", "compute___Ca", "compute___na", "compulate_cr", "compulate_Ca", "compute_ba"], "compute_ov": ["compute_ove", "compute___uda", "compute__ovi", "compate_ov", "compute_o", "compure_uda", "computeableOV", "compute__uda", "compute___ovi", "compure_ov", "compure_ev", "compure_ou", "compute64o", "compute__ove", "compure_vo", "compate_o", "compute_ou", "compute64ov", "compure_OV", "computeablevo", "compute___ov", "compure_ove", "compute64ou", "computeableev", "compute_uda", "compute_OV", "compute_vo", "compure_oo", "compute_ovi", "computeableo", "compure_ovi", "compate_vo", "compure_o", "compute64oo", "compute__ov", "compate_ou", "compute_ev", "computeableov", "compute_oo", "computeableou", "compute___ove"], "t0": ["ty00", "tt60", "t4", " pt1", " pt2", "t20", "p1", "t00", " t000", "ft0", "nt02", "t60", " t25", "f0", "t000", " pt0", "p02", "te1", " t3", "T02", "te4", "p25", "p050", "te0", "ntok", "tree000", "t2", "tree100", "dt80", "T3", " t100", " T0", "T4", "T80", "test60", " t4", " t2", "t100", "ft000", "t02", "p3", "f1", "tree0", "tt80", "tt0", "f3", "ft2", "nt2", "t050", "at02", " T1", "nt050", "t3", "t80", " t20", "test80", "dt2", "p60", " t00", "test1", "T1", "dt0", "pok", "ft100", "nt3", "p80", "p4", "ty4", "tt1", "at3", "nt1", "T2", "f2", "T0", " T20", "dt1", "t25", "at0", "p0", "ty0", "tree2", "tok", "T00", "tt02", "at1", "ttok", "test0", "nt0", "te25", " T2", "p2", "ty1", " t050", " t02", " pt20"], "t1": ["pone", "tieName", "f1", "fone", "tone", "tie1", "te121", "litName", "p80", "tempone", "te0", "tt1", "lit1", "T2", "p1", "litOne", "f2", "at80", "tt001", "ttName", "T0", "tie001", "T121", "t001", "t121", "t01", "t2", "ttOne", "arg0", "Tone", "at0", "p0", "temp0", "arg01", "tOne", "temp1", "f0", "T80", "tieOne", "f121", "at1", " t01", "tName", "te2", "T01", "t80", " t2", "at2", "lit001", "argone", "p2", "te1", " tone", "temp2", "T1"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t*)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    mm_end = end - 7;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            \"movq       %%mm0, %%mm6    \\n\\t\"\n\n            \"movq       %%mm3, %%mm7    \\n\\t\"\n\n\n\n            \"movq         8%1, %%mm0    \\n\\t\"\n\n            \"movq         8%1, %%mm1    \\n\\t\"\n\n            \"movq         8%1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmx_null)\n\n            :\"memory\");\n\n        /* borrowed 32 to 24 */\n\n        __asm__ volatile(\n\n            \"movq       %%mm0, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"movq       %%mm6, %%mm0    \\n\\t\"\n\n            \"movq       %%mm7, %%mm1    \\n\\t\"\n\n\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n\n\n            STORE_BGR24_MMX\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        d += 24;\n\n        s += 8;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n    }\n\n}\n", "idx": 1508, "substitutes": {"src": ["fd", "rest", "rs", "sb", "r", "loc", "ins", "sl", "cur", "id", "gz", "enc", "rb", "m", "dest", "cb", "source", "ds", "config", "st", "begin", "h", "ind", "c", "f", "length", "sc", "gb", "rd", "b", "inst", "start", "inf", "dist", "rc"], "dst": ["fsrc", "pdST", "fbl", " dfe", "adst", "lfe", "dsts", "ffe", "lbl", "dST", " dsrc", " dbl", "pdst", "pdbl", "adsts", "fst", "pdsts", "dsrc", "dbl", "dfe", "lst", "adST", "lsrc", "adbl"], "src_size": ["rc_size", " src_scale", "rc_scale", "rc_data", "src___size", "rc_end", " src_end", "src___data", "src___end", "src___scale", "src_scale", "src_end", "src_data"], "end": ["ending", "ff", "after", "offset", "r", "send", "ad", "open", "id", "k", "enc", "END", "max", "m", "ended", "z", "index", "begin", "h", "x", "c", "p", "w", "e", "End", "size", "f", "en", "v", "b", "stop", "nd", "edge", "se", "start", "est"], "mm_end": ["mem_max", "mmxstart", "mmxid", " mm_start", "mm_max", "mem_offset", "mem_start", " mm_limit", "mm_begin", "mm_limit", "mmxend", "mem_end", "mm_id", "mm_offset", " mm_size", "mmxsize", "mm_start", " mm_id", " mm_begin", "mm_size"], "d": ["fd", "dn", "da", "q", "dd", "pd", "sd", "dim", "dh", "data", "r", "ad", "di", "n", "dl", "id", "i", "g", "j", "m", "dy", "z", "ds", "dt", "dc", "h", "ind", "c", "p", "l", "x", "w", "e", "f", "u", "cd", "o", "v", "b", "t", "nd", "dat", "dp", "D", "db"], "s": ["ss", "spec", "ts", "rs", "sd", "sb", "r", "n", "send", "is", "sh", "sl", "y", "j", "g", "i", "m", "ses", "sync", "sv", "z", "sets", "ds", "ps", "gs", "ns", "h", "l", "c", "p", "x", "services", "w", "e", "us", "f", "sys", "sq", "u", "south", "sec", "o", "v", "b", "su", "S", "t", "session", "states", "se", "fs", "start", "si", "sym"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 1519, "substitutes": {"opts": ["OPTS", "promets", "optfs", "OPuts", "opertr", "operfs", "otuts", "opments", "OPts", "opps", "opert", "OPfs", "optes", "operTS", "opercs", "otts", "opted", "optr", "otments", "popts", " opTS", "poputs", "optt", "obted", "promtes", "optted", " optr", "ottes", "opt", "poptes", "optets", "opTS", "optts", "optcs", "opcs", "obt", "OPtes", "optuts", "opertes", "operps", "optments", "opttr", "OPt", "promts", "obTS", "OPted", "optps", " opments", "operts", "opttes", "OPcs", "operments", "promps", "opfs", "popt", "operuts", "obts", "oputs", "optTS", "opets", "operets"], "ai": ["sa", "hai", "apache", "client", "ti", "asc", "address", "AI", "gui", "ais", "qa", "af", "an", "admin", "ae", " sa", "ami", " bi", " ca", "ui", "mi", "parent", "api", "adr", "mac", "ac", "pai", "pa", "p", "org", "lib", "qi", "plugin", "wa", "sci", "io", "pin", " ga", " mi", "cm", "li", "channel", "a", "mod", "ni", "ee", "loc", "di", "ta", "ha", "py", "i", "ait", "afi", "attr", "app", "cache", "connection", "asm", "SA", "bridge", "ay", "agi", "module", "net", "si", "server", "http", "gi", "ga", "conn", "ei", "asi", "fa", " ta", " pri", "co", "aa", "ape", "aii", "na", " li", "eni", "aud", "config", "au", "bi", " ac", "ca", " api", "pc", "ci", "ann", "db"], "peer": ["layer", "server", "name", "src", "ctx", "offset", "channel", "inter", "conn", "pe", "host", "url", "r", "type", "unknown", "chain", "scope", "worker", "parent", "client", "remote", "instance", "wire", "tp", "proc", "info", "master", "er", "source", "request", "pool", "address", "owner", "ip", "pkg", "state", "ptr", "resource", "attr", "sys", "conf", "eth", "username", "node", "ssl", "pc", "socket", "family", "mode", "slave", "root", "vr", "ace", "user"], "local": ["layer", "http", "url", "localhost", "loc", "global", "lang", "auth", "remote", "shared", "loop", "tp", "ac", "file", "tx", "master", "pool", "pkg", "state", "private", "conf", "cache", "public", "node", "pc", "lib", "location", "ssl"], "addr": ["dr", "route", "url", "alt", "adder", "direction", "home", "address", "ack", "air", "Address", "ress", "aug", "od", "uri", "arrow", "rt", "name", "ext", "host", "nn", "filename", "align", "html", "auth", "arr", "adr", "mac", "ac", "pkg", "work", "ptr", "hop", "wd", "amp", "ast", "layer", "offset", "pe", "az", "rr", "loc", "ad", "env", "ha", "str", "usr", "attr", "arm", "cmd", "node", "bb", "prefix", "rss", "enter", "oa", "server", "href", "src", "dd", "conn", "alias", "area", "ord", "config", "ip", "east", "art", "email", "amd", "over", "vr", "part", "ace"], "port": ["allow", "rot", "rest", "key", "url", "alt", "wait", " Port", "password", "direction", "address", "select", "opt", "pr", "round", "cp", "path", "all", "option", "name", "time", "target", "host", "pi", "tag", "type", "position", "id", "end", "pair", "api", "adr", "mac", "Port", "post", "non", "p", "ptr", "per", "length", "hop", "patch", "text", "pt", "nat", "version", "offset", "loc", "op", "py", "pre", "proxy", "body", "project", "slice", "ports", "pid", "pad", "h", "size", "attr", "value", "tt", "PORT", "rule", "ort", "test", "service", "no", "method", "class", "prop", "th", "pos", "phone", "dest", "source", "ip", "col", "token", "fat", "username", "point", "part"], "uaddr": ["uwd", "Uaddr", "luaddr", "luhost", "Uhost", "Uaddress", "luaddress", "uhost", "uaddress", "luwd", "Uwd"], "uport": ["ueip", "uename", "ulname", "ulip", "ulport", "uip", "ueport", "uname"], "rc": ["PC", "fc", "rg", "src", "rs", "roc", "anc", "cc", "rw", "rn", "success", "r", "loc", "rr", "rect", "ru", "ck", "nc", "RC", "rec", "bc", "cur", "tc", " RC", "rf", "irc", "ac", "rb", "ri", "cr", "back", "ras", "reply", "dc", "ack", "result", "c", "xc", "lc", "rl", "sc", "rd", "pc", "sr", "RR", "error", "rx", "ci", "rt", "inc", "rh"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_file_size(FTPContext *s)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    char *res = NULL;\n\n    const int size_codes[] = {213, 0};\n\n\n\n    snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path);\n\n    if (ftp_send_command(s, command, size_codes, &res)) {\n\n        s->filesize = strtoll(&res[4], NULL, 10);\n\n    } else {\n\n        s->filesize = -1;\n\n        av_free(res);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    av_free(res);\n\n    return 0;\n\n}\n", "idx": 1525, "substitutes": {"s": ["js", "service", "opens", "cs", "http", "ss", "ops", "rs", "ts", "qs", "a", "sb", "new", "r", "d", "n", "aws", "is", "ssh", "client", "g", "m", "ses", "ls", "sync", "xs", "settings", "ds", "sets", "ps", "gs", "ns", "c", "p", "services", "w", "e", "us", "f", "secondary", "es", "sq", "o", "b", "S", "t", "os", "socket", "support", "fs", "si", "sym", "ssl"], "command": ["name", "buffer", "def", "sequence", "communication", "array", "method", "execute", "data", "send", "operation", "type", "query", "remote", "package", "mac", "script", "code", "password", "attribute", "event", "document", "request", "md", "pattern", "sudo", "function", "content", "which", "c", "random", "clear", "length", "text", "message", "power", "exec", "php", "cmd", "comm", "node", "connection", "Command", "prefix", "error", "re", "msg", "mode", "response", "input", "directory"], "res": ["ret", "resolution", "js", "cs", "rest", "rs", "gr", "rus", "rex", "vals", "r", "Res", "rr", "results", "rec", "ms", "RES", "arr", "rh", "pres", "remote", "des", "params", "rep", "ra", "args", "err", "rev", "ras", "reply", "ps", "result", "e", "resource", "es", "prev", "rem", "rows", "RE", "ress", "resp", "rez", "reed", "rss", "req", "error", "rx", "rar", "os", "gen", "re", "reg", "msg", "response", "rc"], "size_codes": [" size_lines", "size_code", "size___codes", " size_code", " size_description", "size___errors", "size_description", "size___description", " size_errors", "size_errors", "size_200", "size___code", " size_200", "size_lines"]}}
{"project": "qemu", "commit_id": "68d45bb61c5bbfb3999486f78cf026c1e79eb301", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)\n\n{\n\n    TCGReg datalo, datahi, addrlo, rbase;\n\n    TCGReg addrhi __attribute__((unused));\n\n    TCGMemOpIdx oi;\n\n    TCGMemOp opc, s_bits;\n\n#ifdef CONFIG_SOFTMMU\n\n    int mem_index;\n\n    tcg_insn_unit *label_ptr;\n\n#endif\n\n\n\n    datalo = *args++;\n\n    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);\n\n    addrlo = *args++;\n\n    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);\n\n    oi = *args++;\n\n    opc = get_memop(oi);\n\n    s_bits = opc & MO_SIZE;\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    mem_index = get_mmuidx(oi);\n\n    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);\n\n\n\n    /* Load a pointer into the current opcode w/conditional branch-link. */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);\n\n\n\n    rbase = TCG_REG_R3;\n\n#else  /* !CONFIG_SOFTMMU */\n\n    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n\n    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n\n        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);\n\n        addrlo = TCG_REG_TMP1;\n\n    }\n\n#endif\n\n\n\n    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {\n\n        if (opc & MO_BSWAP) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0));\n\n        } else if (rbase != 0) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo));\n\n            tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));\n\n        } else if (addrlo == datahi) {\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n        } else {\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n        }\n\n    } else {\n\n        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];\n\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));\n\n            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);\n\n        } else if (insn) {\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n        } else {\n\n            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n            insn = qemu_exts_opc[s_bits];\n\n            tcg_out32(s, insn | RA(datalo) | RS(datalo));\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#endif\n\n}\n", "idx": 1533, "substitutes": {"s": ["sg", "js", "service", "cs", "http", "spec", "qs", "ts", "context", "sb", "a", "d", "is", "ions", "scope", "client", "bis", "g", "i", "m", "ses", "sf", "sync", "settings", "request", "xs", "sets", "ds", "ps", "gs", "ns", "c", "p", "sie", "services", "e", "private", "f", "self", "es", "set", "sys", "sq", "secondary", "south", "sec", "sing", "o", "stats", "b", "site", "S", "t", "session", "its", "se", "fs", "in", "sym", "ssl"], "args": ["argument", "limits", "call", "arg", "ig", "cs", "alls", "ass", "extra", "spec", "qs", "conn", "actions", "flags", "loc", "axis", "Arg", "objects", "ms", "lang", "includes", "arr", "arms", "enc", "ids", "g", "pos", "params", "bits", "body", "ars", "err", "ras", "ds", "config", "ams", "gs", "ns", "items", "afi", "doc", "words", "atts", "size", "len", "orders", "cmd", "alloc", "sec", "uments", "fields", "blocks", "icks", "points", "Args", "ks", "bytes", "addr", "inc", "parts"], "is_64": ["is_63", "IS_64", "is_24", "isf63", " is_long", "IS_63", "isf64", "IS_24", "is_long", " is_32", "is_32", "isf24"], "datalo": [" datalan", " datla", "Datalan", "datla", "mutla", "datalan", "dagi", "mutalo", "dalo", "mutalan", "dralo", "formagi", "mutalos", " datalos", "Datalos", "formalo", "Datla", "dragi", "dalos", "dalan", "datagi", "formahi", "formalos", "datalos", "Datalo", "dla", "dahi", "dralos", "drahi"], "datahi": ["dataii", " datla", "datla", " dataho", "ditla", "dataho", "netla", " dataii", "draii", "nataho", " datagi", "dralo", "natahi", "netaii", "ditagi", "drla", "datagi", "natagi", "netahi", "netalo", "ditahi", "ditaho", "natla", "drahi"], "addrlo": ["addrelo", " addrlin", "adrso", "addresslo", "padlc", "ordli", " addrHi", " addrlim", "alignli", "amdlo", "addrlow", "addrHi", " addrpl", "addrlc", "addrso", "alignhi", "rrpl", "addressLo", "ordpos", "amdHi", "rrhi", "addrzo", "rrlo", " addrli", "addressko", "adderzo", "amdLo", "amdpl", "alignlo", "amdhi", "drlo", "addresslc", "amdlin", "addrbo", "addrpos", "addrlin", " addrlow", "adrlo", "addressli", "drhi", "addresselo", "addrLo", "adderso", " addrpos", "amdko", " addrlc", "adrzo", "addressla", "adrlow", "ordlo", "addressHi", " addrelo", "addrlim", "amdlim", "padli", "alignpos", "amdla", "addresshi", "ordhi", "padlo", "addrpl", " addrso", "padbo", "addresslim", "alignelo", "rrlin", "drko", "drLo", "adderlo", "adderlow", " addrLo", " addrla", "drla", " addrbo", "addrli", "addressbo", "addrko", " addrzo", "addrla"], "rbase": ["rarlast", " rlo", "Rbas", "Rmodel", "rarmodel", "erbi", "Rpart", "rarbas", "rrmodel", "Rlo", "Rbase", "rrbase", "Rlog", " rpart", " Rlo", "rlog", "rpart", "rbas", " rbas", " Rbi", "Rbi", "Rlast", " rlog", "rlo", "rbi", "rlast", "erbase", "erbas", "bbase", "rrlast", " rbi", "rmodel", "bpart", "bbi", "rrbas", " Rbase", "bbas", " Rlog", "rarbase"], "addrhi": ["drhi", "addresslo", "drui", " addrhei", " addrui", " addrHi", "drHi", "drlo", "addressui", "ptrha", "addrHi", "ptrhei", "addressHi", "addressha", "addrui", "addresshei", "addrhei", "addrli", "ptrhi", " addrha", " addrli", "addressli", "addresshi", "drli", "addrha"], "oi": ["oa", "eu", "ilo", "oci", "xi", "cli", "ami", " bi", " ki", "yi", "iri", "ii", "ei", " pi", "ji", "ni", "zi", "asi", "ui", "pi", "osi", "obo", "di", " ii", "uci", "oid", "cci", "mi", "obi", "oda", "oni", "opp", " pci", "i", "eni", "anti", "oji", "ti", "eri", "ini", "ani", "odi", "ai", "ie", "adi", "bi", "ois", "ahi", "ogi", "ku", " vi", "ori", "ki", "rio", "o", "agi", "ik", "ci", " si", " identity", "si", " mi"], "opc": ["OPca", "oopcs", "OPct", "oopC", "Opf", " appC", " opci", "operf", "oopc", "operct", "OPc", "opca", "opct", "copc", "Opb", "copb", "OPf", "oopci", " appci", "opf", " appc", "oopca", " opct", " opC", "OPci", "OPb", "Opc", "Opcs", "opci", "copcs", "opcy", "opcs", " opf", "oopcy", " opca", "opb", "copf", " opcy", " opcs", "operci", "opC", "OPcs", " appcy", "operc"], "s_bits": ["s_ints", "s__bits", "s_bit", " s_bit", "s_bytes", "s_its", "s_flags", "s__flags", "s2bit", "n_ints", " s_cycles", "n_bits", "s__its", " s_its", "s__bit", "s2its", "n_flags", " s_bytes", " s_flags", "s__ints", "s_cycles", "s2bits", "s2flags"], "mem_index": ["mem_ref", "memnint", "memnindex", "mem__index", " mem_int", " mem_col", "memptype", "memlexcol", "mem_Index", "mem__body", "memPindex", "mem_ind", "memPref", " mem_type", " mem_body", "mem_col", "memlexindex", " mem_ind", "memPind", "memntype", "mem_type", "memnIndex", "mempint", " mem_Index", "mem_int", "mem_body", "mempIndex", "mempindex", "mem__col", "memlexbody", " mem_ref"], "label_ptr": ["label_index", "label_pointer", "labelenpointer", " label_index", "labelenoffset", "label_offset", "data_index", "labelingindex", "data_offset", " label_pointer", "labelingptr", "labelingoffset", "data_ptr", "data_pointer", " label_len", "labelinglen", "label_len", "labelenptr", "labelingpointer", "labelenindex"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,\n\n                                   GetBitContext *gb)\n\n{\n\n    int i;\n\n    MMCO *mmco = sl->mmco;\n\n    int nb_mmco = 0;\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields\n\n        skip_bits1(gb); // broken_link\n\n        if (get_bits1(gb)) {\n\n            mmco[0].opcode   = MMCO_LONG;\n\n            mmco[0].long_arg = 0;\n\n            nb_mmco          = 1;\n\n        }\n\n        sl->explicit_ref_marking = 1;\n\n    } else {\n\n        sl->explicit_ref_marking = get_bits1(gb);\n\n        if (sl->explicit_ref_marking) {\n\n            for (i = 0; i < MAX_MMCO_COUNT; i++) {\n\n                MMCOOpcode opcode = get_ue_golomb_31(gb);\n\n\n\n                mmco[i].opcode = opcode;\n\n                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n\n                    mmco[i].short_pic_num =\n\n                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &\n\n                            (sl->max_pic_num - 1);\n\n#if 0\n\n                    if (mmco[i].short_pic_num >= h->short_ref_count ||\n\n                        !h->short_ref[mmco[i].short_pic_num]) {\n\n                        av_log(s->avctx, AV_LOG_ERROR,\n\n                               \"illegal short ref in memory management control \"\n\n                               \"operation %d\\n\", mmco);\n\n                        return -1;\n\n                    }\n\n#endif\n\n                }\n\n                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n\n                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n\n                    unsigned int long_arg = get_ue_golomb_31(gb);\n\n                    if (long_arg >= 32 ||\n\n                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n\n                                             long_arg == 16) &&\n\n                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"illegal long ref in memory management control \"\n\n                               \"operation %d\\n\", opcode);\n\n                        return -1;\n\n                    }\n\n                    mmco[i].long_arg = long_arg;\n\n                }\n\n\n\n                if (opcode > (unsigned) MMCO_LONG) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"illegal memory management control operation %d\\n\",\n\n                           opcode);\n\n                    return -1;\n\n                }\n\n                if (opcode == MMCO_END)\n\n                    break;\n\n            }\n\n            nb_mmco = i;\n\n        }\n\n    }\n\n\n\n    sl->nb_mmco = nb_mmco;\n\n\n\n    return 0;\n\n}\n", "idx": 1540, "substitutes": {"h": ["H", "http", "bh", "q", "ih", "host", "ht", "zh", "sh", "ph", "ha", "uh", "g", "m", "hr", "ah", "hm", "l", "c", "hi", "p", "beh", "hh", "w", "e", "hd", "f", "u", "hp", "hel", "en", "o", "s", "hl", "v", "hy", "b", "t", "he", "hs", "oh", "rh", "gh"], "sl": ["pl", "SB", "so", "li", "sch", "bh", "ul", "sa", "sd", "sb", "acl", "cl", "loc", "isl", "zh", "fl", "sh", "lr", "sk", "bl", "g", "ls", "ll", "sf", "coll", "sv", "kel", "sel", "SL", "l", "c", "sw", "lc", "scl", "kl", "sq", "sc", "la", "el", "il", "sn", "s", "hl", "lib", "cel", "sm", "gl", "serv", "su", "se", "Sl", "si", "ssl"], "gb": ["rg", "gpu", "src", "gram", "kb", "ga", "sb", "gc", "bm", "ub", "hub", "gom", "mb", "gy", "eb", "lb", "gh", "gnu", "pg", "bc", "ge", "GB", "gin", "g", "gg", "rb", "gm", "cb", "cgi", "storage", "gam", "bf", "gs", "hm", "jpg", "gu", "nb", "bg", "bb", "pc", "cca", "lib", "tm", "gl", "usb", "gal", "cfg", "gp", "gd", "db", "game"], "i": ["ski", "yi", "hei", "ami", "li", "gi", "abi", "ni", "ii", "zi", "ji", "esi", "ui", "pi", "oi", "d", "I", "n", "di", "id", "mi", "it", "iu", "k", "uli", "ij", "j", "y", "ri", "eni", "inner", "info", "ti", "multi", "index", "ini", "z", "ai", "ie", "ip", "l", "phi", "p", "bi", "e", "lc", "f", "idi", "ki", "v", "iv", "qi", "ix", "b", "uri", "ci", "count", "io", "mu", "init", "fi", "si", "xi"], "mmco": ["mlgo", "mpCO", " mmcode", "mcloc", "mmCO", "mmcos", "cmco", "memci", "mmpo", "smcode", "mcco", "MMco", "cmcol", "mccoll", "MMci", "mmoo", "mlloc", "mcoo", " mmdo", "memcoll", "mcCo", "mcaco", "wxco", "wxque", "mmcoll", "MMloc", "mmcol", " mmaco", "tmpo", " mmoo", "smcon", "cmpo", "mmque", "mlko", " mmc", "tmko", "mmmcon", " mmgo", "mmcon", "mpco", "tmcos", "mmmko", "memco", "memcon", "wxcon", "MMCo", "mlcol", " mmque", "mcdo", "tmloc", "mlcos", " mmcos", "tmco", " mmko", "mmmloc", "mmaco", "mploc", "memCo", "smco", "smque", " mmCO", "MMdo", "mmko", "smaco", "smcos", " mmcon", "mlco", "mpcoll", "mmc", " mmcoll", "tmgo", "mmcode", "cmloc", "smoo", "mmmcoll", "mmloc", "mlpo", "mmmc", "mmmco", "mmdo", "memloc", "wxcos", "mmgo", "mmci", " mmloc", "tmcol", "memCO", "memc", "MMcoll", "mcko", "mmCo", "mccode", " mmci", " mmCo"]}}
{"project": "qemu", "commit_id": "e40a67beeda6aa6e735546e9f08f3db41e23592a", "target": 0, "func": " void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n", "idx": 1557, "substitutes": {"s": ["server", "js", "service", "ss", "rs", "ts", "spec", "a", "sb", "r", "d", "is", "sl", "y", "side", "m", "ses", "sf", "sync", "settings", "sv", "storage", "sets", "status", "ds", "ps", "gs", "ns", "c", "p", "services", "state", "e", "f", "sys", "sq", "u", "south", "o", "sr", "v", "stats", "su", "b", "S", "os", "t", "states", "fs", "si", "in", "ssl"], "i": ["yi", "li", "gi", "key", "ni", "ii", "ji", "h", "ui", "pi", "oi", "d", "I", "n", "di", "id", "mi", "k", "iu", "j", "y", "m", "ri", "eni", "info", "ti", "ini", "index", "z", "multi", "source", "ai", "ie", "x", "ip", "l", "p", "c", "bi", "hi", "e", "phi", "f", "lc", "u", "o", "v", "qi", "b", "t", "ix", "uri", "ci", "io", "mu", "fi", "start", "si", "xi"], "entry": ["server", "letter", "row", "service", "offset", "inter", "key", "tri", "image", "ge", "id", "ry", "sl", "it", "end", "ent", "pair", "Entry", "inner", "info", "event", "nt", "attribute", "source", "index", "ident", "ie", "c", "reader", "or", "try", "lc", "object", "v", "connection", "cell", "module", "element", "session", "line", "entity", "enter", "se", "import", "export", "si", "input", "option"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n", "idx": 1573, "substitutes": {"sum": ["match", "call", "cost", "sub", "null", "total", "mass", "offset", "gram", "ass", "ul", "key", "a", "hash", "image", "class", "out", "weight", "ash", "sh", "empty", "bin", "num", "i", "ac", "Sum", "cash", "ask", "info", "index", "parse", "average", "gam", "result", "alpha", "state", "doc", "zero", "us", "size", "mean", "dev", "cache", "text", "amount", "mask", "value", "fat", "miss", "comment", "um", "scale", "fee", "sign", "sort", "error", "count", "val", "all", "start", "acc", "si", "user", "pack", "mem"]}}
{"project": "qemu", "commit_id": "45eb768c706d3a5fbe55224c589e8b4e252781d9", "target": 0, "func": "static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER */\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    /* base and limit */\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    /* Supported memory and i/o types */\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t/* VGA 16-bit decode */\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n", "idx": 1616, "substitutes": {"d": ["dr", "ld", "fd", "dn", "da", "dd", "pd", "sd", "dh", "dad", "data", "ad", "n", "xd", "dl", "di", "id", "dict", "de", "dom", "i", "g", "j", "m", "sync", "dt", "ds", "md", "config", "z", "dc", "ind", "c", "p", "dos", "l", "e", "f", "bd", "cd", "dj", "die", "wd", "driver", "b", "plugin", "t", "od", "session", "vd", "td", "nd", "dat", "D", "gd", "db", "done"]}}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n", "idx": 1621, "substitutes": {"pc": ["PC", "fc", "cs", "lp", "anc", "cc", "mc", "prot", "ping", "type", "nc", "pg", "bc", "mi", "pb", "tc", "platform", "ocol", "toc", "mac", "ac", "project", "pid", "pointer", "func", "ec", "asc", "dc", "pa", "c", "p", "xc", "arc", "lc", "cpu", "oc", "sc", "ca", "pm", "sec", "amp", "vc", "point", "bp", "tz", "val", "pt", "uc", "rc", "port"], "tb": [" tbh", "tbl", "tbb", " tcb", "Tbh", "ttbh", " tbb", " tbase", "rtbs", "itbs", "Tbs", "Tb", "tsb", "Tbase", "ftbb", "tbe", "ttb", "tpb", "ttcb", "itfb", " tbl", "ttbs", "ttab", " tab", "ftab", "tbs", "ttbl", "tab", "rtpb", "fbs", "etbs", "itb", "ttbb", "rb", "rbl", "ftb", "ctbs", "ttbe", "rtab", "rbb", "etpb", "tbase", "Tbb", "tsbl", "Tcb", " tpb", "fbb", " tbs", "tbh", "fcb", "tsbb", "tfb", " tbe", "ctbase", " tfb", "etb", "ftcb", "fb", "ctbb", "rtb", "rbs", "tcb", "ctb", "etab", "itab", "etfb", "tsbe"], "ctx": ["fc", "cm", "cms", "cli", "cam", "cs", "kb", "hw", "conn", "context", "mc", "cc", "gc", "anc", "Context", "fw", "acl", "loc", "ct", "co", "nc", "bc", "voc", "tc", "cus", "cas", "fp", "tx", "cb", "kw", "config", "pkg", "cu", "c", "cv", "xc", "css", "lc", "cn", "ca", "ctrl", "sq", "sc", "jp", "git", "cmd", "sys", "exec", "vc", "cca", "qa", "cp", "cmp", "rx", "cf", "conv", "ci", "cfg", "sci", "wp", "gp", "rc"]}}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n", "idx": 1626, "substitutes": {"fd": ["fc", "ff", "ld", "fun", "dd", "fen", "pd", "FD", "sd", "fed", "fw", "fa", "flo", "d", "lf", "dl", "fl", "id", " events", "fff", "fn", "buf", "pos", "draft", "dy", "pipe", "fp", "sf", "df", "cb", "cond", "ds", "pid", "dt", "md", "fe", "feed", "dc", "cod", "fi", "ind", "function", "func", "fin", "f", "ffff", "bd", "length", " fid", "draw", "cd", "fx", "handler", "wd", "fm", "die", "connection", "fee", "fb", "events", "cf", "config", "vd", "td", "nd", "dir", "fs", "db"]}}
{"project": "FFmpeg", "commit_id": "89f464e9c229006e16f6bb5403c5529fdd0a9edd", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    TiffContext *const s = avctx->priv_data;\n\n    AVFrame *const p = data;\n\n    ThreadFrame frame = { .f = data };\n\n    unsigned off;\n\n    int le, ret, plane, planes;\n\n    int i, j, entries, stride;\n\n    unsigned soff, ssize;\n\n    uint8_t *dst;\n\n    GetByteContext stripsizes;\n\n    GetByteContext stripdata;\n\n\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n\n\n    // parse image header\n\n    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid TIFF header\\n\");\n\n        return ret;\n\n    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n\n        av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    s->le          = le;\n\n    // TIFF_BPP is not a required tag and defaults to 1\n\n    s->bppcount    = s->bpp = 1;\n\n    s->photometric = TIFF_PHOTOMETRIC_NONE;\n\n    s->compr       = TIFF_RAW;\n\n    s->fill_order  = 0;\n\n    free_geotags(s);\n\n\n\n    // Reset these offsets so we can tell if they were set this frame\n\n    s->stripsizesoff = s->strippos = 0;\n\n    /* parse image file directory */\n\n    bytestream2_seek(&s->gb, off, SEEK_SET);\n\n    entries = ff_tget_short(&s->gb, le);\n\n    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)\n\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < entries; i++) {\n\n        if ((ret = tiff_decode_tag(s, p)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    for (i = 0; i<s->geotag_count; i++) {\n\n        const char *keyname = get_geokey_name(s->geotags[i].key);\n\n        if (!keyname) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);\n\n        if (ret<0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Writing metadata with key '%s' failed\\n\", keyname);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (!s->strippos && !s->stripoff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Image data is missing\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    /* now we have the data and may start decoding */\n\n    if ((ret = init_image(s, &frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->strips == 1 && !s->stripsize) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Image data size missing\\n\");\n\n        s->stripsize = avpkt->size - s->stripoff;\n\n    }\n\n\n\n    if (s->stripsizesoff) {\n\n        if (s->stripsizesoff >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,\n\n                         avpkt->size - s->stripsizesoff);\n\n    }\n\n    if (s->strippos) {\n\n        if (s->strippos >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripdata, avpkt->data + s->strippos,\n\n                         avpkt->size - s->strippos);\n\n    }\n\n\n\n    if (s->rps <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"rps %d invalid\\n\", s->rps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    planes = s->planar ? s->bppcount : 1;\n\n    for (plane = 0; plane < planes; plane++) {\n\n        stride = p->linesize[plane];\n\n        dst = p->data[plane];\n\n        for (i = 0; i < s->height; i += s->rps) {\n\n            if (s->stripsizesoff)\n\n                ssize = ff_tget(&stripsizes, s->sstype, le);\n\n            else\n\n                ssize = s->stripsize;\n\n\n\n            if (s->strippos)\n\n                soff = ff_tget(&stripdata, s->sot, le);\n\n            else\n\n                soff = s->stripoff;\n\n\n\n            if (soff > avpkt->size || ssize > avpkt->size - soff) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid strip size/offset\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,\n\n                                         FFMIN(s->rps, s->height - i))) < 0) {\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return ret;\n\n                break;\n\n            }\n\n            dst += s->rps * stride;\n\n        }\n\n        if (s->predictor == 2) {\n\n            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"predictor == 2 with YUV is unsupported\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            dst   = p->data[plane];\n\n            soff  = s->bpp >> 3;\n\n            if (s->planar)\n\n                soff  = FFMAX(soff / s->bppcount, 1);\n\n            ssize = s->width * soff;\n\n            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j++)\n\n                        dst[j] += dst[j - soff];\n\n                    dst += stride;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n\n            dst = p->data[plane];\n\n            for (i = 0; i < s->height; i++) {\n\n                for (j = 0; j < stride; j++)\n\n                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];\n\n                dst += stride;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->planar && s->bppcount > 2) {\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 1628, "substitutes": {"avctx": ["ajcca", "evcu", "evctx", "afcb", "evcontext", "AVctx", "ajctx", "avectx", "avconn", "afcmp", "afctx", "afcontext", "navctx", "AVcb", "aveconn", "navcu", "AVconn", " avcontext", "aveca", "avecb", "afcup", "afconn", "navcup", "avcup", " avcu", "avecup", "afcu", "avecca", "navcontext", "avcb", "avcca", " avca", "avcontext", "avca", "avecontext", "evconn", "ajca", "afca", "avcu", "afcca", "AVcmp", "avcmp", "ajcontext", "avecmp", "avecu"], "data": ["base", "response", "name", "buffer", "da", "primary", "read", "def", "board", "a", "image", "window", "d", "di", "ad", "id", "empty", "video", "bin", "parent", "sample", "frame", "buf", "next", "inner", "none", "body", "code", "slice", "database", "config", "feed", "raw", "content", "result", "block", "reader", "zero", "f", "size", "len", "cache", "object", "DATA", "o", "connection", "valid", "load", "dat", "init", "Data", "start", "input", "done"], "got_frame": ["gotnewversion", "aved2version", "aved2frame", "got2version", "aved2code", "got_version", "gotbufframe", "aved_sample", "aved_code", "gotnewsample", "gotbufsample", "got2sample", "gotbufversion", "gotbufcode", "got2frame", "aved_version", "got2code", "got_sample", "gotnewframe", "got_code", "aved_frame", "gotnewcode", "aved2sample"], "avpkt": ["avnpkt", "affkt", "avfpct", "avppct", "avpft", "avlpinch", "avlpkt", "avenpacket", "afpct", "avpett", "avpacket", "avpekt", "AVpct", "affett", "AVppct", "avppkh", "avpect", "avpeki", "avfpacket", "avapett", "afckt", "AVppke", "avpinch", "avpki", "AVppkt", "avcpkt", "avppkt", "avepinch", "affinch", "avfct", "avenpkt", "afcki", "avfkt", "avepkt", "avlpct", "avfpft", "avnpinch", "afpinch", "avepft", "avfett", "avpct", "avcki", "afpki", "avcpki", "avpke", "AVpkt", "afpkt", "avcpct", "avfft", "avfpkt", "avpkh", "avcct", "avapkt", "afcct", "avepacket", "avppke", "avnpacket", "affct", "avenpft", "avcpke", "avfacket", "afcke", "avnpft", "AVpke", "avnpke", "avfinch", "avcke", "avnpkh", "avapct", "afpett", "AVppkh", "avnpct", "AVpkh", "avlpett", "afpke", "avfpinch", "avfpkh", "avckt", "avfpke", "avpeke", "avenpinch", "avapinch"], "s": ["sg", "js", "sa", "qs", "n", "styles", "g", "ses", "ls", "sf", "args", "us", "self", "f", "sys", "u", "se", "fs", "parts", "sup", "spec", "ts", "sb", "y", "xs", "sets", "e", "conf", "v", "su", "S", "t", "ks", "os", "session", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "bis", "m", "settings", "ds", "ps", "gs", "native", "ns", "h", "c", "setup", "es", "south", "o", "si", "service", "ops", "d", "ms", "side", "comments", "sync", "ys", "l", "services", "w", "features", "sq", "b", "full"], "p": ["pl", "np", "parser", "vp", "a", "lp", "pi", "r", "d", "n", "sp", "it", "pb", "op", "py", "g", "pre", " P", "tp", "m", "param", "proc", "fp", "P", "params", "er", "ps", "h", "l", "c", "w", "e", "f", "u", "jp", "o", "v", "pc", "b", "cp", "t", "wp", "pt", "pp"], "off": ["flow", "oa", "ff", "no", "half", " OFF", "offset", "def", " Off", "a", "out", "n", "alt", "field", "Off", "open", "id", "opp", "ord", "unknown", "end", " on", "now", "num", "loop", "side", "output", "pos", "none", "offs", " offline", "non", "ip", "down", "block", "shift", "len", "front", "own", "art", "cmd", "obj", "one", "o", "en", "OFF", "less", "online", "line", "low", "anon", "load", "on", "mode", "slave", "all", "start", "in"], "le": ["base", "led", "ale", "ell", "ig", "ld", "li", "level", "offset", "half", "elt", "oe", "pe", "ke", "lf", "lu", "ge", "Le", "lease", "de", "ne", "nl", "cle", "ble", "side", "league", "leave", "code", "ll", "lex", "lee", "live", "fe", "ele", "lane", "ie", "ce", "l", "ler", " el", "e", "len", "ling", "w", "la", "el", "ile", "sle", "scale", "cel", "ole", "leg", " LE", "line", "let", "low", "lo", "fle", "se", "lege", "lead", "les", "little", "LE"], "ret": ["match", "arg", "fun", "att", "ext", "utf", "def", "active", "bit", "success", "get", "alt", "lf", "format", "cur", "it", "rets", "arr", "pass", "fail", "rep", "code", "info", "ft", "nt", "rev", "back", "reply", "status", "Ret", "replace", "bf", "bad", "str", "result", "fin", "len", "f", "ref", "flag", "rem", "red", "resp", "value", "obj", "en", "rel", "RET", "valid", "lit", "reg", "re", "val", "rt", "af", "det", "res", "mem"], "plane": ["unit", "group", "np", "q", "split", "pe", "charge", "ke", "co", "fl", "sp", "pos", "code", "fly", "fe", "lane", "sea", "ro", "scale", "cp", "ane", "line", "mode", "fle", "se", "board", "port"], "planes": ["files", "days", "groups", "ops", "classes", "ips", "eps", "faces", "frames", "bits", "flows", "pieces", "ports", "cards", "ps", "items", "lines", "pages", "rows", "pins", "lists", "levels", "points", "fle", "cuts", "bands"], "i": ["this", "key", "get", "n", "uni", "g", "ti", "index", "x", "ind", "hi", "f", "u", "ori", "uri", "fi", "start", "all", "pack", "ami", "zi", "ji", "pi", "ui", "type", "id", "mi", "k", "iu", "end", "y", "ri", "z", "ie", "e", "v", "ix", "qi", "io", "mu", "in", "li", "ni", "ii", "chi", "r", "I", "di", "is", "inner", "info", "ini", "h", "c", "phi", "bytes", "si", "ski", "_", "yi", "gi", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "bi", "ki", "ci", "xi"], "j": ["vol", "adj", "jl", "ji", "r", "d", "n", "jj", "J", "jobs", "k", "aj", "pos", "jump", "kj", "z", "ie", "l", "ind", "shift", "len", "jp", "note", "jet", "obj", "b"], "entries": ["enuries", "enturies", "gentrs", "ENTriers", "enries", "entsrs", "entles", "entrations", "entsorts", "questriers", "ENTrows", "centrows", "ntrs", "entities", "conturies", "gentrations", "contles", "detrs", "questrys", "detities", "detorts", "questrows", "gentances", "entsries", "entsances", "questries", "centriers", "entrs", "ntrations", "centries", "enles", "centrs", "entsuries", "detries", "ENTrys", "contries", "entorts", "gentries", "entsrations", "ntries", "centities", "entsurs", "centrys", "ENTries", "enurs", "entrys", "entsles", "entriers", "entances", "ntances", "enturs", "entsities", "conturs", "centorts", "entrows"], "stride": ["stage", "stider", "drage", "stide", "arrage", "strides", "drider", "dride", "strage", "strider", "arrider", "arride", "arrides", "stides", "drides"], "soff": [" socc", "sufi", "suff", "loff", "loeff", "sofi", " sofi", "sueff", " soeff", "soeff", "succ", "socc", "locc", "lofi"], "ssize": ["cssizer", "rssize", "SSiz", "cssize", "SSizer", "rssiz", "cssizes", "SSize", "rssizes", "ssizes", "rssizer", "cssiz", "ssiz", "SSizes", "ssizer"], "dst": ["fst", "dsc", "pdcr", " dct", "fsc", "fct", "dcr", " dsc", "pdsc", "pdst", "dct", "fcr", " dcr", "pdct"], "stripsizes": ["stripppizable", "stripppits", "striipsizable", "strippsizable", "striipsize", "strippingize", "strippingizes", "strippizable", "strippingits", "strippsizes", "striipsizes", "stripsizable", "strippize", "strippizes", "strippsize", "strippingizable", "striipsits", "strippsits", "strippits", "stripppize", "stripsize", "stripsits", "stripppizes"], "stripdata": ["stripdat", "CCdat", "CCformat", "CCctx", "stripformat", "stripctx", "stripbuf", "CCbuf"], "keyname": ["kerename", "kerenum", " keynow", "kerenow", "keylames", "keylename", "kegnam", "kegnum", " kerename", " keynames", "keinnam", " keynename", "keynename", "kerenam", "kegnename", "kerenames", "keyonow", "keynam", "Keynename", "keinnum", " kerenow", "Keyname", "keynames", " kerenames", "Keynam", "keyoname", "keinname", "Keynum", "Kerenam", "Kerename", " kerenename", "kerenename", "keyonames", "keylame", "Kerenename", "Kerenum", "kegname", "keyonename", "keylow", "keinnename", "keynum", "keynow"]}}
{"project": "FFmpeg", "commit_id": "bd255f9feb4deea4c990e582f0ba3b90d7b64b4c", "target": 0, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n\n                                              int *got_picture_ptr,\n\n                                              AVPacket *avpkt)\n\n{\n\n    int ret;\n\n\n\n    *got_picture_ptr = 0;\n\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n\n        return -1;\n\n\n\n    avctx->pkt = avpkt;\n\n    apply_param_change(avctx, avpkt);\n\n\n\n    avcodec_get_frame_defaults(picture);\n\n\n\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n\n                                         avpkt);\n\n        else {\n\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n\n                                       avpkt);\n\n            picture->pkt_dts             = avpkt->dts;\n\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n\n            picture->width               = avctx->width;\n\n            picture->height              = avctx->height;\n\n            picture->format              = avctx->pix_fmt;\n\n        }\n\n\n\n        emms_c(); //needed to avoid an emms_c() call before every return;\n\n\n\n        if (*got_picture_ptr)\n\n            avctx->frame_number++;\n\n    } else\n\n        ret = 0;\n\n\n\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n\n     * make sure it's set correctly */\n\n    picture->extended_data = picture->data;\n\n\n\n    return ret;\n\n}\n", "idx": 1657, "substitutes": {"avctx": ["afcot", "ajctx", "evcit", "ajcit", "afcontext", " avcor", "attctx", "Avcontext", "navcu", "avhw", "ovtx", "avcus", "Avctx", "afctl", "akcmp", "avnp", "agctx", "ajnp", "afcn", "evcb", "akconn", "afloc", "attcontext", "avcot", "auhw", "afcrit", "afci", "avcontext", "aveloc", " avhw", "afxc", "akctx", "afcmp", "AVcontext", "avepkg", "Avctl", "avecu", "ovcontext", "avectx", "avecf", "afctx", "navctx", "afpkg", "avehw", "akcontext", "navcf", "avcf", "afcor", "afconn", "agcontext", "abcot", "afnp", "ovcmp", "avcb", "akcrit", "auci", "attcf", "avalctl", "avcn", "avalcontext", "aucontext", "abcontext", "avaltx", "umcontext", "avci", "avecor", "avenp", "awctx", "avecmp", "avcas", "avalctx", "evctx", "evcu", "evcontext", "evcmp", "ajcn", "avxc", "aveci", "afcas", "avtx", "aftx", "abcmp", "avpkg", "avecb", "afhw", "navctrl", "auctx", "navcmp", "ovctx", "abctx", "avctrl", "afcu", "navloc", "afctrl", "afcf", "avctl", "avectrl", "akcb", "ajcrit", "navcrit", "umctx", "avecus", "ajcontext", "avcrit", "ajcus", "AVctx", "awcb", "awpkg", "avconn", "avcit", "umcu", "ovcas", "Avcas", "AVconn", "AVxc", " avcontext", "avcor", "avalcas", "awcontext", "afcus", "ajcu", "navcontext", "attcmp", "avetx", "agcot", "avloc", "agcmp", "akcn", "afcit", "avecontext", "ajci", "avcu", "akxc", "avcmp", "afcb", "umcf"], "picture": ["media", "guide", "movie", "cam", "piece", "ctx", "ami", "service", "large", "bank", "figure", "audio", "image", "data", "share", "video", "profile", "query", "study", "frame", "camera", "package", "detail", "gallery", "photo", "anti", "file", "info", "entry", "attribute", "slice", "style", "storage", "parse", "feat", "config", "util", "pict", "feature", "jpg", "fi", "library", "ana", "gui", "summary", "game", "definition", "quote", "comment", "upload", "shadow", "meta", "pie", "brush", "plugin", "pic", "error", "module", "uri", "manager", "img", "view", "family", "statement", "whatever", "cover", "import", "player", "pause", "gif", "Picture"], "got_picture_ptr": ["got_picture_length", "got_image_tr", "got_picture_ext", "got_image_ptr", "got_picture___ptr", "got_picture___slice", "got_image_ext", "got_picture_dr", "got_picture_ref", "got_picture_tr", "got_picture_slice", "got_picture_desc", "got_image_length", "got_picture_pointer", "got_image_ref", "got_picture___addr", "got_picturealpointer", "got_picture___pointer", "got_image_pointer", "got_picture_addr", "got_picturealptr", "got_picturealdr", "got_image_dr", "got_image_desc"], "avpkt": ["avcpcht", "avpeet", "affkt", "avpreacket", "aphpecht", "affunt", "ajpkt", "avppct", "avprekt", "abpkt", "avspacket", "avcpka", "avpakt", "avPacket", "avecpqt", "avipka", "avwpke", "abpacket", "afpct", "avpeka", "avpreke", "akbpacket", "avcpet", "abfstruct", "akbpcht", "avbpunt", "avcacket", "avfqt", "avpqt", "avbpcht", "avccht", "avperkg", "avpacket", "avPkt", "avpekt", "abfkg", "AVpct", "aphpeet", "avpdt", "avbpacket", "avpaacket", "AVppct", "avcpelt", "avcpacket", "abfkt", "avprevc", "avwpacket", "avepelt", "avpka", "avbpkt", "avPke", "avcpqt", "AVppke", "AVppkt", "avspstruct", "avfkg", "avcpkt", "avppacket", "affacket", "aphpekt", "aphpcht", "avppkt", "avfct", "avperdt", "afpunt", "avpet", "avfke", "avfkt", "avpecht", "avpercht", "avepkt", "ajpvc", "aphpeka", "abpkg", "avecpkt", "avfunt", "avpaelt", "avecpacket", "ajwpkt", "abpstruct", "avpstruct", "avfstruct", "avipcht", "avpct", "AVpacket", "avspkt", "avPct", "avfelt", "avperacket", "avpkg", "avpke", "AVpkt", "afpkt", "avpvc", "ajwpacket", "avbpdt", "avipkt", "akpacket", "AVppacket", "avpcht", "avperstruct", "akpkt", "avcct", "avepacket", "ajpacket", "avppke", "affct", "aphpka", "avcvc", "avfacket", "ajwpvc", "avwpkt", "avpunt", "ajwpke", "akpcht", "avspkg", "AVpke", "akbpkt", "avcdt", "avwpvc", "avcke", "avbpct", "avcunt", "afpacket", "akpdt", "avperkt", "avecpelt", "avpaqt", "abfacket", "ajpke", "aphpkt", "avpelt", "avipet", "avckt", "akbpdt", "aphpet", "avepqt"], "ret": ["match", "rot", "arg", "fun", "att", "mt", "def", "success", "data", "alt", "cat", "cur", "pet", "rets", "arr", "num", "tmp", "code", "info", "ft", "nt", "rev", "back", "reply", "feat", "Ret", "rc", "bf", "result", "et", "ut", "fin", "len", "f", "ref", "flag", "gt", "value", "obj", "RET", "lit", "re", "reg", "val", "img", "rt", "let", "det", "res"], "frame_number": ["image_number", "frame_no", "frame_num", "image_num", "image_nr", "image_no", "frame_nr"]}}
{"project": "qemu", "commit_id": "87e459a810d7b1ec1638085b5a80ea3d9b43119a", "target": 1, "func": "static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n\n                                      MegasasCmd *cmd)\n\n{\n\n    struct mfi_pd_info *info = cmd->iov_buf;\n\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n\n    uint64_t pd_size;\n\n    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);\n\n    uint8_t cmdbuf[6];\n\n    SCSIRequest *req;\n\n    size_t len, resid;\n\n\n\n    if (!cmd->iov_buf) {\n\n        cmd->iov_buf = g_malloc0(dcmd_size);\n\n        info = cmd->iov_buf;\n\n        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n\n        info->vpd_page83[0] = 0x7f;\n\n        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info std inquiry\");\n\n            g_free(cmd->iov_buf);\n\n            cmd->iov_buf = NULL;\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info std inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {\n\n        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info vpd inquiry\");\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info vpd inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(pd_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    blk_get_geometry(sdev->conf.blk, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 1672, "substitutes": {"sdev": ["ksdev", "ksmod", "sgd", "cdev", "fdf", "csdev", "sdem", "snov", "cnov", "sdf", "dsde", "ksdi", "lsnov", " sdem", " sdf", "lsdiv", "sportsdf", " snov", "ksnov", "sdiv", " sgd", "csnov", "setsde", "dsdev", "cde", "csdi", "fdem", "csmod", "sportsdiv", "sdi", "setsgd", "sportsdem", "setsdem", "dsgd", "lsde", "dsdem", "sportsdev", " sdiv", "smod", "setsdev", " sdi", "fdev", " sde", "fdiv", " smod", "sde", "lsdev", "cdiv"], "lun": [" lul", "tun", "slune", " loun", "eluni", "luna", "llul", "lunt", "elun", "iluni", "sloun", "slul", "llunt", "loun", "ilone", " luna", "elone", "tUN", "lluna", " lune", "slUN", "ilunt", "llune", " luma", "luni", "slunc", "lone", " luni", "lune", "slunt", "lul", " lunc", "llun", "tune", "sluna", "sluma", "llunc", "elunt", " lone", "slun", "lUN", "lunc", "llUN", "eluma", " lUN", "ilun", "elune", "lloun", "tunt", "luma", " lunt"], "cmd": ["cm", "call", "cms", "cli", "ctx", "target", "def", "hw", "conn", "command", "mc", "method", "host", "cc", "data", "Cmd", "cpp", "cl", "domain", "window", "ck", "cat", "parent", "grad", "client", "buf", "gz", "dom", "off", "g", "update", "component", "mac", "code", "cb", "df", "md", "utils", "cod", "config", "dq", "crit", "func", "pkg", "c", "cookie", "setup", "child", "ctr", "conf", "ctrl", "cd", "comm", "vc", "cp", "cmp", "module", "cf", "plugin", "clean", "gen", "msg", "cfg", "mode", "ctl", "qt", "init", "qq", "input"], "info": ["fo", "tf", "name", "check", "ctx", "http", "def", "stat", "extra", "conn", "INFO", "ii", "zip", "command", "data", "ui", "image", "current", "loc", "type", "help", "id", "buff", "job", "html", "end", "Info", "op", "now", "api", "py", "i", "update", "off", "bug", "index", "config", "json", "home", "opt", "block", "hi", "afi", "information", "thin", "setup", "state", "f", "iso", "ref", "conf", "note", "error", "manager", "by", "full", "gen", "init", "diff", "fi", "start", "si", "inf", "mem"], "pd_size": ["ctx_length", "pd_length", "ctxrcapacity", "pd_capacity", "ctx_capacity", "ctxrlength", "pdrsize", "pd2capacity", "ctxrsize", "pd2size", "ctx_size", "pdrlength", "pdrcapacity", "pd2length"], "cmdbuf": ["cfdata", "mdbuff", "mdbuf", "cmdfunc", "cfgbag", "msgbuffer", "cfbuffer", "requf", "cookiebuf", "commandbu", "msgbuff", " cmddata", "mdfunc", "cmdbuff", "ctxbuf", "mdbuffer", "cookiebuffer", "ctxfunc", "commandbuf", "commandbuff", "mdbu", "msguf", "ctxbuff", "mdbag", "reqbuffer", "cfgbuf", "commandbuffer", "cmdbag", "reqbuff", "cfgbuff", " cmdbuffer", "msgbuf", "mduf", "msgbu", "reqbuf", "cmdbuffer", "cmduf", "cfbuff", "commanddata", " cmduf", " cmdbuff", "ctxbag", "cookiebuff", "cookieuf", "cmdbu", "cmddata", "cfgfunc", "commanduf", "cfbuf"], "req": ["flow", "call", "urg", "fun", "check", "ctx", "ext", "q", "http", "def", "required", "spec", "gr", "conn", "zip", "queue", "desc", "data", "rr", "r", "ver", "requ", "rec", "id", "cur", "query", "download", "grad", "fit", "comp", "iq", "proc", "need", "cb", "err", "request", "rev", "dq", "crit", "feat", "progress", "pkg", "ind", "f", "ref", "hop", "ctr", "sq", "conf", "app", "exec", "resp", "pull", "lib", "seq", "qa", "cmp", "cf", "require", "wa", "rx", "low", "rt", "msg", "init", "qt", "diff", "qq", "res", "quest", "dist"], "len": ["fun", "fd", "js", "li", "lan", "elt", "conn", "Len", "data", "url", "loc", "n", "bid", "lf", "fl", "ln", "sl", "alt", "dl", "bin", "num", "bl", "pos", "ls", "body", "args", "ll", "nt", "rev", "err", "str", "ie", "ind", "l", "fin", "lc", "length", "set", "size", "resp", "min", "el", "en", "lib", "seq", "cmp", "bytes", "gen", "low", "lit", "val", "count", "part"], "resid": ["resID", "resnum", " resinfo", "respid", "respinfo", "rsID", "rsid", " resID", "rsinfo", "respID", "rsnum", "resinfo", "respnum", " resnum"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 1710, "substitutes": {"ctx": ["fc", "cm", " cx", "cli", "gpu", "cam", "cs", "kb", "hw", "conn", "context", "anc", "cc", "txt", "cpp", "Context", "gru", "loc", "ck", "gmail", "bc", "tc", "concept", "client", "cus", "grad", "cas", "comp", "component", "fp", "tx", "kt", "cb", "sync", "utils", "config", "pkg", "cu", "c", "cv", "xc", "lc", "cpu", "cn", "ca", "sc", "ctrl", "git", "cmd", "vc", "linux", "cca", "connection", "prefix", "qa", "cp", "cmp", "cf", "ci", "cfg", "sci", "que", "qq", "input", "rc"], "l1": ["t4", "Lone", "pone", "L3", "li1", "p3", "el2", "L1", "p1", "pOne", "l0", " l0", "el3", "t2", "p0", "li2", "lone", "tOne", "t1", "li3", " lOne", "l3", "L0", " lone", "L01", "L4", "v2", "L2", "li01", "t3", "v1", "v4", "el1", "l4", "p2", "v0", "l01", "el01", " l3", "lOne"], "l2": ["Ltwo", "t4", "L3", "li1", "p72", "p8", "li8", "L1", " l4", "p1", "l0", " l0", "rl4", "l5", "rltwo", "t2", "L72", "li72", "rl2", "t5", " l5", "li2", "ltwo", "t1", "l3", "L0", "l72", "L4", "t3", "L2", "l8", "l4", "rl3", "p2", " ltwo", " l3", "L8", "L5"], "mask": ["delay", "lock", "gi", "q", "offset", "skip", "bit", "cc", "fac", "weight", "sk", "iq", "batch", "pass", "label", "mac", "m", "scan", "ask", "info", "pixel", "bug", "filter", "config", "feature", "ai", "pad", "block", "zero", "f", "fix", "conf", "patch", "comment", "sum", "scale", "Mask", "qa", "sign", "bridge", "ix", "depth", "reg", "shape", "map", "qq", "pack"], "t0": ["t4", "f1", "p3", "tee", "pt4", " t8", " tee", "p4", "d0", "t19", "T2", "p1", "pt0", "f2", "l0", "p19", "T0", "T19", "t2", "l50", "p0", "t50", "Tee", "f50", "pt2", "t1", "t8", "l3", "d8", "f0", "T4", "T8", "t3", " t50", " t2", "pt19", "d2", "p2", "dee", " t3", " t1"]}}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_process_mem2s(struct Stream *s,\n\n                                 StreamSlave *tx_dev)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned char txbuf[16 * 1024];\n\n    unsigned int txlen;\n\n    uint32_t app[6];\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return;\n\n    }\n\n\n\n    while (1) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        if (stream_desc_sof(&s->desc)) {\n\n            s->pos = 0;\n\n            memcpy(app, s->desc.app, sizeof app);\n\n        }\n\n\n\n        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if ((txlen + s->pos) > sizeof txbuf) {\n\n            hw_error(\"%s: too small internal txbuf! %d\\n\", __func__,\n\n                     txlen + s->pos);\n\n        }\n\n\n\n        cpu_physical_memory_read(s->desc.buffer_address,\n\n                                 txbuf + s->pos, txlen);\n\n        s->pos += txlen;\n\n\n\n        if (stream_desc_eof(&s->desc)) {\n\n            stream_push(tx_dev, txbuf, s->pos, app);\n\n            s->pos = 0;\n\n            stream_complete(s);\n\n        }\n\n\n\n        /* Update the descriptor.  */\n\n        s->desc.status = txlen | SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 1712, "substitutes": {"s": ["sg", "js", "this", "qs", "n", "sites", "client", "g", "ls", "ses", "args", "er", "us", "self", "f", "sys", "u", "changes", "your", "an", "se", "fs", "ows", "ts", "aws", "ims", "y", "uns", "xs", "sets", "p", "e", "lines", "conf", "as", "v", "su", "site", "S", "os", "t", "ks", "session", "its", "sym", "ssl", "cs", "ss", "rs", "new", "r", "is", "ins", "ions", "i", "m", "settings", "ds", "ps", "gs", "native", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "d", "ms", "comments", "details", "sync", "tests", "l", "services", "features", "b", "states"], "tx_dev": [" tx_serv", "tx_device", "txkroot", "context_ev", "context_dev", "txkDev", "tx2ev", "tx_root", "context_Dev", "context_root", " tx_device", "txkev", "tx2dev", "tx5Dev", " tx_ev", "tx5root", "tx2device", "tx_ev", "tx2serv", "tx5ev", "contextkdev", "contextkDev", "txkdev", "tx_serv", "tx_Dev", "contextkroot", "contextkev", "tx5dev"], "prev_d": ["prev_dc", "prevRevD", "prev2dy", "prevKb", "prevRevsd", "Prev_d", " prev_j", "prev_j", " prev2D", "prev_ds", "prevPds", "prev__d", "prev_D", "prev2j", " prev_sd", "prev2ds", " prev_b", "prevPd", "prev2d", "prevRevj", " prev2b", "prevPdy", "prev2sd", " prev2dy", "prev_b", " prev_ds", "prevKds", " prev2sd", "Prev_D", " prev2j", "prevroyD", " prev_D", "prev_dy", "prev_sd", "prevKdy", "prev__D", "prevPb", "prev__dc", "prevroyd", " prev2ds", "prevKd", " prev2d", " prev_dy", "Prev_dc", "prevRevd", "prevroyj", "prev2D", "prevroysd", "prev2b"], "txbuf": ["xbytes", "rxbytes", "xcb", "memlen", "ctxbuffer", "rxctx", "memqueue", "txbuffer", "TXbuffer", "xbuf", "txcb", "ctxbuf", "xbuffer", " txbuffer", "rxbuffer", "ctxlen", "TXcb", " txctx", "TXlen", "xqueue", "rxbuf", "xlen", "TXbuf", "membuf", "txqueue", "rxqueue", "rxlen", "ctxctx", "membuffer", " txbytes", "txctx", "txbytes", " txcb"], "txlen": ["txLen", " txl", " txLen", "txlim", "mxen", "rxl", "hoplen", "txpos", "xen", "textLen", "hoplength", " txpos", "misslon", "TXlen", "mxlen", " cxpos", "TXen", "txln", "xl", "mxval", "txlon", "xlen", "misslength", "xpos", " txln", "TXl", "textlen", "misslen", "TXLen", "hoplim", "rxlen", "rxlength", "xln", "txen", "txl", "TXlength", " txlon", "hopl", "missl", "TXval", "mxlength", "rxen", "xlon", " txlength", "rxlim", "xLen", "rxlon", " txen", "txlength", "texten", " cxlen", "textlength", "rxLen", "txval", " txval", " cxl", " cxln", " txlim"], "app": ["allow", "match", "test", "ready", "server", "name", "append", "APP", "att", "application", "a", "array", "access", "fac", "process", "form", "oper", "ab", "data", "ace", "ap", "ape", "aa", "buff", "record", "client", "arr", "enc", "instance", "g", "mac", "ac", "m", "proc", "display", "App", "pattern", "config", "ps", "raw", "exc", "ch", "ip", "x", "c", "p", "dev", "stack", "ram", "cache", "ipp", "save", "asm", "pp", "container", "path", "reg", "port", "load", "shape", "all", "map", "acc", "apps", "pack", "apply"]}}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1713, "substitutes": {"avctx": ["ajctx", "afcontext", "alcontext", "avc", "avhw", "devcontext", "mpctx", "afctl", "mpcontext", "AVhw", "afcup", "devcf", "avcontext", "apcmp", "afc", "AVc", "afcmp", "AVcontext", "avectx", "avecf", "afctx", "broadctx", "aveconn", "broadsys", "avcf", "devsys", "broadc", "afconn", "AVctl", "avalctl", "abcf", "avalcontext", "avesc", "abcontext", "allc", "AVcmp", "devctx", "avalctx", "evctx", "evcontext", "alctx", "mpcf", "mplc", "devc", "apcontext", "afhw", "ajcup", "AVcu", "abctx", "avecup", "broadcontext", "afcu", "aflc", "afcf", "afsys", "apcu", "avctl", "evconn", "devlc", "ajcontext", "AVctx", "ablc", "alhw", "avsc", "AVlc", "avconn", "evlc", "avsys", "afsc", "avcup", "apctx", "avalc", "avecontext", "devconn", "avcu", "ajsc", "avlc", "avcmp"], "c": ["fc", "cm", "cs", "ctx", "conn", "context", "cc", "mc", "cl", "anc", "com", "d", "ct", "n", "nc", "rec", "cur", "con", "k", "tc", "client", "enc", "i", "g", "ac", "coll", "cr", "ch", "config", "C", "ec", "abc", "dc", "ce", "h", "cu", "p", "l", "w", "e", "lc", "f", "arc", "oc", "cache", "ca", "sc", "u", "core", "exec", "ctrl", "vc", "sec", "s", "pc", "v", "b", "cp", "t", "cf", "ic", "ci", "uc", "rc", "can"]}}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n", "idx": 1721, "substitutes": {"hci": ["hmc", "pcu", "hdci", " hdc", "hmcu", "pci", "hmcit", "ccci", "ehci", "hdc", " hc", "hodi", "hmodi", "pcci", "cci", " hcin", "hcci", "hdi", " hodi", "ohci", "hmcin", "hc", " hdi", "hcin", "ehcu", " hcci", "hmci", "ehcin", "ehdc", "pdi", "hhdi", "hmdi", "hdodi", "ohcu", "hdcit", "hcu", " hcit", "cdi", "hhci", " hcu", "ohdc", "ccu", "hhcu", "hhcin", "ohcin", "hcit"], "params": ["same", "js", "device", "sp", "options", "args", "master", "resources", "pointer", "css", "manager", "uri", "cms", "name", "target", "spec", " parameters", "type", "mm", "parent", "tmp", "cas", "api", "model", "par", "mac", "parse", "ams", "lc", "ram", "handler", "as", "response", "plugins", "media", "missing", "cs", "ctx", "rs", "data", "eps", "camera", "instance", "i", "info", "settings", "names", "ds", "json", "ps", "gs", "phys", "result", "size", "attr", "cache", "obj", "null", "server", "vm", "ops", "array", "results", "param", "details", "ras", "source", "config", "ip", "services", "copy", "cmp", "radius"]}}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 1726, "substitutes": {"vs": ["cs", "vp", "verts", "ss", "alls", "ops", "rs", "qs", "ts", "spec", "Vs", "vals", "eps", "env", "sk", "ils", "ses", "ls", "xs", "sv", "settings", "ds", "WS", "ps", "gs", "otes", "VS", "ns", "cv", "state", "services", "vers", "es", "vc", "sts", "v", "stats", "events", "points", "os", "ks", "forces", "ants", "cf", "bs", "va", "states", "fs", "obs"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 1736, "substitutes": {"str": ["dr", "cs", "ext", "Str", "rs", "spec", "res", "txt", "rr", "r", "sp", "orig", "cur", "arr", "kr", "enc", "i", "inner", "hr", "stri", "code", "er", "fr", "cr", "tr", "temp", "st", "c", "pr", "vec", "lc", "f", "w", "br", "text", "ctr", "sc", "std", "obj", "sr", "s", "req", "old", "iter", "in", "STR"], "endptr": ["adptr", "pendPtr", "pendproc", "startaddr", "endingpointer", " endctr", "endingfd", "adPtr", "endedproc", "startPtr", "adctr", "endproc", "endctr", " endaddr", "endedptr", "endpointer", "adpointer", " endproc", "endedPtr", "endingctr", "endfd", " endpointer", "endaddr", "pendptr", " endPtr", "endPtr", "endingptr", "startptr", " endfd", "startpointer", "adaddr", "adfd"], "err": ["dr", "ise", "call", "test", "ner", "gr", "grade", "Error", "rr", "r", "ver", "id", "der", "lr", "arr", "i", "code", "er", "fr", "cr", "bug", "errors", "result", "ind", "work", "reader", "pr", "ler", "e", "try", "order", "aster", "ctr", "resp", "range", "mr", "finder", "error", "var", "req", "cer", "Er", "msg", "iter", "rh", "res", "rc"]}}
{"project": "qemu", "commit_id": "aaf89c8a49a8c1259b6b181d701070c6df83f3d7", "target": 0, "func": "static void test_migrate(void)\n\n{\n\n    char *uri = g_strdup_printf(\"unix:%s/migsocket\", tmpfs);\n\n    QTestState *global = global_qtest, *from, *to;\n\n    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;\n\n    gchar *cmd;\n\n    QDict *rsp;\n\n\n\n    char *bootpath = g_strdup_printf(\"%s/bootsect\", tmpfs);\n\n    FILE *bootfile = fopen(bootpath, \"wb\");\n\n\n\n    got_stop = false;\n\n    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);\n\n    fclose(bootfile);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcsource,debug-threads=on\"\n\n                          \" -serial file:%s/src_serial\"\n\n                          \" -drive file=%s,format=raw\",\n\n                          tmpfs, bootpath);\n\n    from = qtest_start(cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcdest,debug-threads=on\"\n\n                          \" -serial file:%s/dest_serial\"\n\n                          \" -drive file=%s,format=raw\"\n\n                          \" -incoming %s\",\n\n                          tmpfs, bootpath, uri);\n\n    to = qtest_init(cmd);\n\n    g_free(cmd);\n\n\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    global_qtest = to;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* We want to pick a speed slow enough that the test completes\n\n     * quickly, but that it doesn't complete precopy even on a slow\n\n     * machine, so also set the downtime.\n\n     */\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_speed',\"\n\n              \"'arguments': { 'value': 100000000 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* 1ms downtime - it should never finish precopy */\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_downtime',\"\n\n              \"'arguments': { 'value': 0.001 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n\n\n    /* Wait for the first serial output from the source */\n\n    wait_for_serial(\"src_serial\");\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate',\"\n\n                          \"'arguments': { 'uri': '%s' } }\",\n\n                          uri);\n\n    rsp = qmp(cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    wait_for_migration_pass();\n\n\n\n    rsp = return_or_event(qmp(\"{ 'execute': 'migrate-start-postcopy' }\"));\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    if (!got_stop) {\n\n        qmp_eventwait(\"STOP\");\n\n    }\n\n\n\n    global_qtest = to;\n\n    qmp_eventwait(\"RESUME\");\n\n\n\n    wait_for_serial(\"dest_serial\");\n\n    global_qtest = from;\n\n    wait_for_migration_complete();\n\n\n\n    qtest_quit(from);\n\n\n\n    global_qtest = to;\n\n\n\n    qtest_memread(to, start_address, &dest_byte_a, 1);\n\n\n\n    /* Destination still running, wait for a byte to change */\n\n    do {\n\n        qtest_memread(to, start_address, &dest_byte_b, 1);\n\n        usleep(10 * 1000);\n\n    } while (dest_byte_a == dest_byte_b);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n    /* With it stopped, check nothing changes */\n\n    qtest_memread(to, start_address, &dest_byte_c, 1);\n\n    sleep(1);\n\n    qtest_memread(to, start_address, &dest_byte_d, 1);\n\n    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);\n\n\n\n    check_guests_ram();\n\n\n\n    qtest_quit(to);\n\n    g_free(uri);\n\n\n\n    global_qtest = global;\n\n\n\n    cleanup(\"bootsect\");\n\n    cleanup(\"migsocket\");\n\n    cleanup(\"src_serial\");\n\n    cleanup(\"dest_serial\");\n\n}\n", "idx": 1760, "substitutes": {"uri": ["unit", "route", "base", "cli", "name", "src", "ctx", "http", "iri", "URI", "filename", "ui", "url", "folder", "loc", "uni", "format", "id", "client", "remote", "umi", "i", "ri", "fp", "file", "source", "database", "config", "address", "resource", "ref", "gb", "origin", " URI", "connection", "prefix", "plugin", "location", "path", "ci", "io", "dir", "timeout", "directory"], "global": ["server", "cli", "http", "local", "Global", "current", "co", "common", "parent", "client", "remote", "master", "general", "util", "gu", "sys", "cache", "conf", "gb", "lib", "final", "gl", "foreign", "session", "msg", "io", "all", "can"], "from": ["base", "vol", "name", "after", "before", "a", "form", "new", "current", "r", "d", "add", "cur", "false", "parent", "ou", "client", "remote", "with", "param", "pos", "component", "From", "ra", "args", "fr", "source", "back", "config", "c", "or", "state", "self", "e", "f", "resource", "ca", "u", "who", "origin", "of", "range", "as", "driver", "connection", "at", "action", "old", "by", "normal", "user"], "to": ["test", "arg", "name", "so", "after", "target", "TO", "be", "too", "go", "new", "out", "co", "To", "type", "until", "timeout", "parent", "client", "param", "options", "py", "pos", "toc", "dest", "source", "or", "top", "afi", "state", "p", "resource", "f", "size", "sys", "token", "range", "as", "o", "at", "site", "t", "rule", "socket", "by", "location", "since", "response", "user"], "dest_byte_a": ["dest_bytes_aa", "dest_bytes_a", "dest_bytes_alpha", "dest_byte_aa", "dest_bytes_b", "dest_byte_alpha"], "dest_byte_b": ["dest_byte16e", "dest_number_e", "dest_byte16b", "dest_number_d", "dest_number_b", "dest_byte16a", "dest_byte16d", "dest_number_a", "dest_byte_e"], "dest_byte_c": ["dest_bit64c", "dest_byte1c", "dest_bit_c", "dest_byte2c", "dest_byte64C", "dest_byte1dc", "dest_byte_dc", "dest_byte1d", "dest_bit64dc", "dest_byte64c", "dest_byte2dc", "dest_byte2C", "dest_bit_dc", "dest_bit_C", "dest_byte64dc", "dest_byte64d", "dest_byte_C", "dest_byte2d", "dest_bit64d", "dest_bit_d", "dest_byte1C", "dest_bit64C"], "dest_byte_d": ["dest_char_d", "dest_char_ds", "dest_byte2D", "dest_byte_z", "dest_byte_D", "dest_byte2z", "dest_byte2ds", "dest_char_z", "dest_byte2d", "dest_char_D", "dest_byte_ds"], "cmd": ["cli", "command", "acl", "go", "url", "nc", "head", "client", "g", "code", "args", "and", "cookie", "self", "child", "vc", "cp", "path", "bind", "name", "fun", "target", "anc", "host", "cl", "help", "id", "gz", "buf", "dom", "mac", "utils", "pkg", "custom", "resource", "conf", "comm", "plugin", "session", "init", "one", "qq", "input", "ctx", "cc", "Cmd", "ck", "cat", "bin", "cb", "func", "c", "ctr", "prefix", "req", "cf", "module", "gen", "img", "msg", "mode", "call", "src", "def", "conn", "method", "xml", "callback", "dict", "grad", "gg", "bug", "md", "config", "cn", "ctrl", "clean", "cfg", "rc"], "rsp": ["yrp", "drsl", "rrservice", "prsl", "rrserv", "qscope", "prpp", " rpc", "arsc", "ursp", "srpo", "rsl", "rrsp", "prserv", "rbp", "brpo", "brsp", "arsh", "Rsc", "brp", "brserv", "srbl", "arpp", "fspl", "aramp", "rrspl", "urspl", "qhtml", " rsc", "rramp", "erp", "rbsp", "ursc", "srsc", "rcservice", "qapp", "qserv", "psl", "rspl", "prbsp", "rcsp", "rsh", "prsh", "rrdi", "ersc", "qsl", "rpo", " rscope", "Rsp", "hrbsp", "rserv", "brbsp", "Rspl", "erserv", "rrsc", "rrbp", "fsc", " rp", "hrservice", "ersp", "urinc", "rSp", "arsp", "fsp", "rtpo", "srserv", "rpc", "rrpp", " rsl", "psp", "qsp", "arbsp", "arscope", "brsc", "rrapp", "rp", "hrserv", "ardi", "yrsp", "Rbp", "rtsl", "prhtml", "rhtml", "hrhtml", "rbl", " rserv", "rdi", "srpc", "hrpo", "arpc", "prSp", "srp", "rcpc", "rrsl", "srsp", " rspl", "rrbsp", "yrhtml", "qsc", "rtso", "prpo", "brso", "urhtml", "srhtml", "ppc", "rapp", "brservice", " ramp", "drsp", "hrsp", "srsl", "rrpc", "rinc", "prsp", "rrbl", "arapp", "qspl", "drbsp", "papp", "arsl", " rapp", "prpc", " rservice", "yrserv", "srSp", "rservice", "qpc", "rcsl", "urserv", "rpp", " rdi", "prso", "srapp", "brsl", "rrsh", "fbp", "hrsl", "rscope", "qpo", " rhtml", "drservice", "rso", " rbl", "rtsp", "ramp", "qinc", "ursl", "qSp", "srinc", "rsc"], "bootpath": ["outstyle", "ootfn", "ootfile", "blockloc", "toollocation", "toolname", "bootlocation", "bootcache", " bootloc", " bootcache", " bootconfig", "blockpath", "bootconfig", "bootstyle", " bootname", "outpath", "bootname", "ootstyle", "buspath", "busfile", "rootdir", "ootdir", "bootfn", " bootcase", "buscase", "rootpath", "ootcase", "toolcache", " bootdir", " bootlocation", "ootpath", "toolpath", "toolloc", "bootcase", "tooldir", " bootfn", "outfile", "busfn", "blockname", "bootloc", "rootconfig", "toolconfig", "outdir", "rootcache", "blocklocation", " bootstyle", "bootdir"], "bootfile": ["bugfile", "bootfiles", "Bootpath", "Bootlog", "ootfile", "Bootfile", "bugpath", "outpath", " bootparent", "bootFile", "bugFile", "outstore", "outlog", " bootlog", "toolfiles", "outfiles", "bootlog", "toolfile", "bootparent", "ootparent", "ootpath", "toolpath", " bootfiles", "bootstore", "outfile", "bugparent", "toolstore", " bootFile", "ootFile", "Bootfiles", " bootstore"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n", "idx": 1770, "substitutes": {"pkt": ["pcht", "procct", "Pcht", " pait", "lacket", "prockt", "lkt", " packet", "wacket", " pct", "Pait", "pnt", "Pnt", "pet", "beth", "bkt", " pet", " pnt", "Pck", "proccht", "ppt", "pait", " pcht", " pck", "Ppt", "lpacket", "wkt", " peth", "lpkt", "Packet", "Pet", "lppt", "wnt", "Peth", "pck", "bait", "procacket", "pct", "lck", "let", "packet", "backet", "wct", " ppt", "lpeth", "Pkt", "Pct", "peth"], "tso_enable": ["tso_len", "tco_enable", "tso__do", "tso_id", "tco_enabled", "tso__enable", "tco_id", "tso_do", "tso__use", "tso__enabled", "tso_use", "tco_do", "tco_use", "tso_enabled", "tco_len"], "l3_proto": ["l3_compco", "l3_perdo", "l3_perco", "l3_peraddr", "l3_pero", "l3_roto", "l3_perbo", "l3_perpc", "l3_compdo", "l3_compto", "l3_po", "l3_pedo", "l3_protco", "l3_ppc", "l3_pto", "l3_perto", "l3_proco", "l3_pebo", "l3_roco", "l3_proc", "l3_proaddr", "l3_propc", "l3_peto", "l3_protaddr", "l3_roc", "l3_pepc", "l3_perc", "l3_rodo", "l3_probo", "l3_prodo", "l3_proo", "l3_pco", "l3_compc", "l3_paddr", "l3_pbo", "l3_protto", "l3_pdo"]}}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    switch (cmd[0] >> 5) {\n\n    case 0:\n\n        req->cmd.xfer = cmd[4];\n\n        req->cmd.len = 6;\n\n        /* length 0 means 256 blocks */\n\n        if (req->cmd.xfer == 0)\n\n            req->cmd.xfer = 256;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        req->cmd.xfer = cmd[8] | (cmd[7] << 8);\n\n        req->cmd.len = 10;\n\n        break;\n\n    case 4:\n\n        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);\n\n        req->cmd.len = 16;\n\n        break;\n\n    case 5:\n\n        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);\n\n        req->cmd.len = 12;\n\n        break;\n\n    default:\n\n        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);\n\n        return -1;\n\n    }\n\n\n\n    switch(cmd[0]) {\n\n    case TEST_UNIT_READY:\n\n    case START_STOP:\n\n    case SEEK_6:\n\n    case WRITE_FILEMARKS:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case LOAD_UNLOAD:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n        req->cmd.xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME:\n\n        req->cmd.xfer = 1;\n\n        break;\n\n    case READ_CAPACITY:\n\n        req->cmd.xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        req->cmd.xfer = 6;\n\n        break;\n\n    case READ_POSITION:\n\n        req->cmd.xfer = 20;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        req->cmd.xfer *= 40;\n\n        break;\n\n    case MEDIUM_SCAN:\n\n        req->cmd.xfer *= 8;\n\n        break;\n\n    case WRITE_10:\n\n    case WRITE_VERIFY:\n\n    case WRITE_6:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case READ_10:\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case INQUIRY:\n\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n\n        break;\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (req->dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1783, "substitutes": {"req": ["dr", "q", "war", "com", "ver", "requ", "rec", "client", "ok", "err", "crit", "jp", "seq", "qa", "require", "rt", "rh", "wx", "ext", "spec", "sem", "request", "pkg", "org", "mr", "serv", "wa", "load", "qq", "input", "urg", "ctx", "required", "gr", "tar", "mod", "data", "r", "rr", "proc", "cb", "util", "dq", "ref", "app", "ctr", "cache", "sec", "cf", "reg", "low", "qt", "res", "call", "test", "http", "def", "conn", "rob", "orig", "cur", "query", "grad", "comp", "iq", "rf", "rb", "fr", "ch", "config", "sq", "exec", "resp", "pull", "cmp", "rx", "pro", "desc"], "cmd": ["cli", "q", "command", "go", "ct", "head", "client", "code", "pipe", "cod", "crit", "opt", "ack", "dev", "cookie", "force", "vc", "seq", "cp", "kg", "wx", "bind", "stat", "cl", "host", "ht", "tag", "help", "id", "buf", "dom", "mac", "ac", "pkg", "custom", "comm", "rom", "count", "nd", "qq", "input", "cm", "ctx", "mod", "cc", "Cmd", "data", "domain", "ck", "cat", "op", "cb", "func", "c", "ctr", "cf", "module", "gen", "img", "msg", "mode", "call", "def", "bit", "hw", "conn", "d", "orig", "dict", "grad", "num", "comp", "nt", "md", "ch", "config", "dc", "doc", "col", "ctrl", "cd", "std", "cmp", "clean", "cfg", "ctl", "rc"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n", "idx": 1791, "substitutes": {"queue": ["stage", "route", "group", "ue", "server", "delay", "buffer", "channel", "sequence", "command", "context", "menu", "priority", "current", "Queue", "image", "header", "page", "que", "use", "store", "parent", "lot", "buf", "client", "next", "update", "proxy", "forward", "entry", "sync", "master", "project", "event", "file", "database", "back", "pool", "config", "progress", "p", "cache", "message", "core", "gui", "connection", "collection", "prefix", "seq", "qa", "plugin", "module", "manager", "rule", "line", "list", "console", "table", "port"], "p_data": ["pfdat", " p_dat", "p1next", "pfdata", " p_next", "p1base", "p_next", "pfnew", "pfnext", "p1data", " p_base", "p_dat", "p_base", "p1new"], "p_new": [" p_old", "p_NEW", " p__fresh", "p___new", "pAMgen", "p_gen", "p__gen", "pAMnew", "c__gen", "c__new", "p__create", "p__new", "pknew", "c_old", "data_new", "pAMcreate", "p__clean", "p_next", "p_clean", "p_fresh", "pAMold", "pockNEW", "dataockNEW", "dataocknew", "p___create", "p__next", "data_NEW", "dataockfresh", "pockfresh", " p__old", " p__next", "pkNew", "p___old", "pkNEW", "c__create", "dataockNew", "c_new", " p_fresh", "c_create", "pkfresh", "p_create", "pocknew", "c__old", " p__new", "data_fresh", " p_clean", "p__old", "p_New", "p__data", " p_next", "pockNew", "p___gen", " p_NEW", "c_gen", "p__fresh", "data_New", "p_old", " p_New"], "size": ["external", "SIZE", "capacity", "cycle", "name", "rate", "sized", "small", "data", "send", "empty", "from", "max", "body", "code", "number", "push", "last", "address", "owner", "shift", "Size", "exclusive", "scale", "depth", "count", "timeout", "done"]}}
{"project": "qemu", "commit_id": "6977afda16c1e09dfbce4bdd877459a287269b72", "target": 1, "func": "int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n", "idx": 1802, "substitutes": {"shift_hint": ["shift_shdr", "shift_fbit", "shift_hints", "shift_Hut", "shift_shut", "shift_hbit", "shift_hmut", "shift_shints", "shift_Hbit", "shift_fdr", "shift_Hints", "shift_shint", "shift_hut", "shift_Hdr", "shift_hmints", "shift_fint", "shift_fints", "shift_hmint", "shift_hmdr", "shift_Hint", "shift_hdr"], "ret": ["arg", "fun", "att", "ext", "active", "bit", "conn", "mem", "success", "r", "out", "ct", "alt", "cat", "job", "cur", "pet", "rets", "num", "fail", "rep", "ft", "nt", "rev", "back", "reply", "feat", "Ret", "rc", "pat", "result", "len", "red", "flag", "ref", "reset", "git", "art", "value", "en", "RET", "hard", "lit", "re", "reg", "val", "rt", "det", "res", "bad"]}}
{"project": "FFmpeg", "commit_id": "dc64f203a62083c3d5f81e8201018279c29581af", "target": 1, "func": "static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n\n    PTXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n\n    uint8_t *ptr;\n\n\n\n\n\n    offset          = AV_RL16(buf);\n\n    w               = AV_RL16(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}", "idx": 1804, "substitutes": {"avctx": ["ajctx", "ajxc", "afcontext", "avalconnection", "navcu", "avmac", "afctl", "afcup", "afkb", "afcn", " avcu", "akconn", "avemac", "avecas", "afcrit", "afci", "avcontext", "afxc", "navconn", "afcmd", "avconnection", "akctx", "afcp", "aveconfig", "AVcontext", "avecu", "akconnection", "avkb", "avectx", "avecf", "afctx", "navctx", "afcli", "aveconn", " avcli", "navcf", "akcontext", "afconnection", "avcf", "avalobj", "afobj", "afrc", "afconn", "ajconfig", "avalcli", "akcrit", "avcp", "avalctl", "akctrl", "avcn", "avconfig", "avalcontext", "aircp", "avrc", "avci", "avalctrl", "AVtx", "avobj", "avcas", "avalctx", "avxc", "afcas", "avtx", " avcup", "avcli", "aftx", "aircontext", "avctrl", "afcu", "aveobj", "afctrl", "avectl", "afcf", "avctl", "avalmac", "navcn", "ajcrit", "ajcontext", "avcrit", "afconfig", "AVctx", "avcmd", " avci", "avconn", "avecp", "avalcf", " avcontext", "avekb", "afmac", " avconfig", " avrc", "navcup", "avcup", "navcontext", "AVkb", "avalcmd", "avalkb", "avetx", "avalconfig", "averc", "akcn", " avcmd", "avecontext", "ajci", "avcu", "akxc", "aircas", "airctx"], "data": ["media", "background", "buffer", "read", "channel", "primary", "device", "queue", "memory", "image", "audio", "binary", "window", "d", "header", "devices", "align", "open", "buff", "video", "bin", "parent", "sample", "frame", "client", "tmp", "api", "batch", "package", "next", "map", "pos", "proc", "body", "slice", "style", "database", "index", "pointer", "config", "pool", "progress", "content", "result", "pad", "reader", "size", "f", "length", "draw", "cache", "value", "DATA", "meta", "connection", "module", "bytes", "val", "load", "dat", "Data", "start", "input"], "data_size": ["data2size", "datablockscale", "total_Size", "data_timeout", "totalblocktimeout", "datablocktimeout", "total_timeout", "data_Size", "totalblockscale", "total_scale", "totalblocksize", "data2Size", "datablockSize", "data_scale", "total_size", "data2scale", "totalblockSize", "datablocksize", "data2timeout"], "avpkt": ["avbpkt", "avbpnt", "avebpnt", "avfpct", "avpct", "avpkw", "avcpkt", "avppct", "avPkg", "avppsth", "avPct", "AVPsth", "avepkw", "avppkt", "AVPct", "avbpkw", "avpkg", "AVpsth", "AVPkg", "avpromkw", "AVpkg", "avpnt", "avpsth", "AVpkt", "avepnt", "avPsth", "avepkt", "avppkg", "avpacket", "avPkt", "avebpacket", "AVpct", "avfpkg", "avpromacket", "avbpacket", "avfpkt", "avfpsth", "avpromnt", "avpromkt", "avcpacket", "avebpkw", "AVPkt", "avebpkt", "avcpkw", "avcpnt", "avepacket"], "buf": ["queue", "home", "cv", "vec", "f", "seq", "uf", "path", "uu", "port", "ff", "bag", "context", "filename", "bc", "buff", "tmp", "cas", "off", "batch", "fp", "plug", "aka", "coord", "text", "v", "ctx", "fw", "ab", "loc", "ru", "cat", "proc", "cb", "func", "feat", "usr", "ref", "br", "cache", "ctr", "cmd", "alloc", "cf", "img", "uc", "fd", "src", "buffer", "bo", "header", "window", "prop", "cur", "wav", "num", "rb", "dest", "box", "comb", "config", "block", "wb", "uint", "padding", "um", "fb", "b", "rc"], "s": ["sg", "np", "js", "service", "cs", "sup", "ss", "a", "share", "r", "d", "sk", "i", "g", "j", "space", "m", "sf", "sync", "slice", "sv", "ps", "gs", "c", "services", "e", "f", "sys", "sq", "conf", "as", "o", "v", "b", "S", "t", "sky", "an", "fs", "si", "sym", "ssl"], "picture": ["media", "np", "pocket", "guide", "buffer", "vp", "photos", "audio", "image", "video", "profile", "pb", "frame", "camera", "package", "png", "detail", "gallery", "photo", "fp", "info", "details", "capt", "config", "pict", "feature", "pkg", "conference", "cache", "game", "jp", "summary", "gui", "obj", "meta", "cp", "plugin", "pic", "img", "family", "avi", "gif", "Picture"], "p": ["pl", "np", "pkg", "vp", "q", "lp", "pd", "a", "pe", "pi", "r", "d", "n", "ap", "sp", "pb", "op", "api", "py", "pre", "i", "g", "tp", "j", "m", "po", "proc", "fp", "P", "pointer", "ps", "post", "l", "c", "pa", "pr", "e", "ip", "f", "per", "patch", "u", "jp", "mp", "up", "o", "v", "pc", "bp", "point", "b", "cp", "t", "pro", "wp", "dp", "pt", "part", "pp", "port"], "offset": ["rot", " padding", "index", "pointer", "address", "alpha", "shift", "xff", "f", "reset", " offsets", "stop", "af", "location", "limit", "start", "port", "adjust", "usage", "image", "align", "type", "position", "slot", "format", "buff", "fff", "end", "off", "api", "fp", "hop", "length", "origin", "t", "a", "loc", "i", "aw", "slice", "pad", "et", "len", "size", "o", "prefix", "timeout", "no", "buffer", "append", "alias", "num", "pos", "entry", "attribute", "bound", "ffff", "padding", "Offset", "b", "addr", "part"], "w": ["q", "n", "weight", "wal", "g", "sw", "f", "u", "wp", "all", "wx", "we", "wt", "type", "sh", " W", "end", "max", "kw", "z", "work", "e", "wd", "v", "t", "wa", "ow", "fw", "r", "aw", "m", "wh", "c", "size", "ww", "win", "ew", "iw", "img", "_", "buffer", "hw", "d", "wl", "W", "pos", "wo", "l", "wb", "height", "b"], "h": ["H", "bh", "q", "ih", "hw", "ht", "high", "r", "d", "n", "sh", "ph", "k", "uh", "ha", "g", "m", "hr", "ah", "z", "hm", "l", "hi", "c", "e", "hh", "f", "size", "height", "hd", "u", "o", "v", "b", "t", "wa", "he", "hs", "oh", "rh", "gh"], "y": ["yi", "key", "ye", "yl", "yo", "gy", "d", "n", "yr", "cy", "k", "ny", "ya", "ty", "i", "py", "j", "ady", "dy", "m", "yn", "z", "ey", "yy", "ch", "hi", "c", "l", "e", "vy", "f", "hop", "height", "col", "u", "o", "v", "b", "ay", "t", "Y", "oy", "wy", "ym", "sy"], "stride": ["strided", "STRided", "tride", "Striden", "trider", "STRision", " strade", "strider", " striden", " strider", "STRipe", "STRade", "Stripe", " stripe", "STRider", "strision", "stripe", "Stride", "STRiden", "trided", "trision", "strade", "STRide", " strided", "striden", "Strade", " strision"], "bytes_per_pixel": ["bytes_per_chip", "bytes_PER_second", "bytes_per\u00b7hour", "bytes_per_channel", "bytes_PER_byte", "bytes_PER_channel", "bytes_Per_scale", "bytes_per_hour", "bytes_per_scale", "bytes_Per_cell", "bytes_Per_byte", "bytes_per\u00b7letter", "bytes_PER_letter", "bytes_per\u00b7pixel", "bytes_PER_pixel", "bytes_per_second", "bytes_per_tile", "bytes_Per_pixel", "bytes_per_byte", "bytes_per\u00b7second", "bytes_per_cell", "bytes_per_letter", "bytes_per\u00b7channel", "bytes_per\u00b7tile"], "ptr": ["dr", "pend", "fd", "src", "buffer", "ctx", "tip", "context", "loc", "bc", "buff", "profile", "cur", "grad", "tmp", "pair", "pos", "proc", "code", "fp", "plug", "tx", "slice", "tr", "pointer", "xp", "address", "pad", "Ptr", "cv", "length", "draw", "attr", "ref", "ctr", "br", "obj", "alloc", "req", "uf", "img", "addr", "val", "pt", "fi", "rect", "port"], "x": ["name", "yx", "key", "image", "d", "n", "ct", "type", "px", "xy", "num", "max", "i", "pos", "dx", "m", "code", "tx", "work", "X", "xs", "index", "z", "xp", "xx", "c", "sw", "l", "e", "f", "ax", "u", "ww", "fx", "win", "v", "ix", "b", "t", "rx", "wa", "val", "xxx", "on", "ex", "my", "xi", "wx"]}}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817, "substitutes": {"bs": ["cms", "cs", "ss", "bh", "ba", "rs", "sa", "sb", "lb", "BS", "bc", "ins", "ms", "pb", "rb", "ls", "ses", "ds", "ps", "gs", "ns", "vs", "state", "bi", "bos", "gb", "bt", "bb", "bp", "iss", "fb", "b", "blocks", "os", "ks", "fs"], "s": ["sg", "js", "service", "cs", "http", "ss", "a", "sa", "rs", "ts", "sb", "qs", "d", "aws", "is", "sl", "bis", "g", "m", "ls", "ses", "sync", "xs", "ds", "ps", "gs", "ns", "c", "p", "services", "state", "e", "f", "es", "sys", "sq", "south", "o", "stats", "b", "S", "t", "os", "session", "your", "its", "states", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "c88305027d5a8dbeaacf04ad2ceba79a5c5fb91e", "target": 1, "func": "POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    cc->has_work = cpu_has_work_POWER9;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n", "idx": 1822, "substitutes": {"oc": ["PC", "fc", "ob", "oci", "isc", "roc", "anc", "mc", "xml", "loc", "co", "nc", "bc", "voc", "oid", "tc", "enc", "toc", "mac", "ac", "output", "ok", "config", "ec", "oco", "OC", "c", "doc", "unc", "soc", "org", "exec", "alloc", "vc", "o", "pc", "cca", "ucc", "ic", "oca", "inc", "uc", "rc"], "data": ["da", "dd", "def", "device", "ee", "d", "di", "co", "bc", "parent", "ac", "ds", "config", "raw", "doc", "unc", "cache", "DATA", "cca", "ci", "load", "dat", "Data", "input"], "dc": ["fc", "cm", "DC", "da", "conn", "mc", "d", "di", "nc", "director", "bc", "cci", "tc", "cdn", "ac", "df", "dt", "ec", "cu", "c", "xc", "jc", "doc", "lc", "design", "cd", "disc", "vc", "cca", "pc", "CC", "cf", "uc", "acc", "db", "rc"], "pcc": ["PCC", "apcf", "Pbc", "Pacc", " pca", " pcca", "cpc", "lacc", "lcc", "Pcc", " pcf", "muc", "pci", "Prc", " puc", "ccf", "puc", "pca", "cci", "cacc", "apuc", "Pck", "lcca", " pci", "mcf", "Ppc", "Pci", "apcc", " pck", "cpuc", "cpcc", " prc", " ppc", "pbc", " pbc", "mcc", "cpacc", "pCC", "pcf", "macc", "Puc", "Pca", "prc", "ccc", "pacc", "cbc", " pCC", "cca", "cuc", "cCC", "pck", "apacc", "crc", "Pcca", "lck", "pcca", "ccca", " pacc", "cpcf", "ppc"], "cc": ["cm", " gcc", "DC", "cs", "WC", "mc", "uc", "co", "ck", "nc", "bc", "cci", "tc", "client", "ac", "ec", "ce", "c", "xc", "jc", "lc", "unc", "craft", "ca", "ctrl", "cd", "vc", "cca", "pc", "ucc", "cf", "CC", "acc", "rc"]}}
{"project": "FFmpeg", "commit_id": "f028d4d1c393a13c66e828d45ba8412c0b4df6da", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!s->pb->eof_reached) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition->essence_offset) {\n\n                compute_partition_essence_offset(s, mxf, &klv);\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n", "idx": 1878, "substitutes": {"s": ["sg", "js", "this", "sa", "qs", "n", "client", "g", "ses", "ls", "sf", "storage", "self", "us", "f", "sys", "sc", "types", "se", "fs", "sup", "spec", "ts", "sb", "aws", "xs", "sv", "sets", "p", "e", "conf", "v", "su", "site", "S", "os", "session", "t", "its", "sci", "in", "sym", "ssl", "cs", "ss", "r", "is", "ins", "space", "m", "ds", "ps", "gs", "native", "ns", "c", "es", "south", "sec", "o", "sim", "si", "server", "service", "http", "ops", "d", "sync", "l", "services", "sq", "stats", "b", "support"], "ap": ["pl", "np", "att", "prop", "sp", "op", "arr", "api", "py", "AP", "arp", "tp", "ac", "aps", "ams", "ps", "attr", "cap", "jp", "mp", "as", "cp", "al", "pro", "wp", "am", "map", "pp"], "mxf": ["dxe", " mfc", " mxe", "dfx", " mfx", "dfc", "hfx", "dcf", "dxd", "fmxf", "jxf", "Mfc", "jxc", "cxf", "Mxe", "mxd", "dxf", "ccf", "cmcf", "jxd", "kcf", "fmxc", "mcf", "fmcf", "hxd", "hxf", "kxe", " mxc", "Mxa", " mxd", "mxe", " mcf", "dxc", "Mxc", "cxd", "cmxf", "Mxd", "cmxc", "hxc", "kxf", "fmxd", " mxa", "Mcf", "jcf", "mfx", "kxa", "cmxd", "mxc", "mfc", "mxa", "Mxf", "cxc"], "klv": ["kswl", "klee", "Klc", "kvd", "kevd", " knv", "riskif", " klev", "kll", "mkvl", "skwl", " kvm", " klf", "ckwl", "okli", "skln", "Kla", "Klan", "kslev", "Kvl", " kell", "kla", " klan", "riskwl", "klly", "sklf", "knv", " kwl", "mklf", "jlp", "kwl", "aklev", "klan", "mklv", "ckvd", " klc", "okvd", "skva", "oklf", "okcol", "kslee", "akell", "kcol", "skif", "klf", "kln", "kslv", "kvm", "sklan", "jwl", "kif", "kli", "Kli", " kcol", "keva", "aklv", "sklp", "akvm", "skvm", " kif", "arklv", "cklv", "Kwl", "kdd", "arkwl", "skdd", "Klf", "jlv", "sknv", "kql", "skvc", "mkla", " kla", "kslly", "klev", "arklc", "kickll", "Kql", "kicklv", "Klp", "jlf", "skvd", "okva", "sklv", "kelee", "klp", "sklev", "kewl", "ksdd", "risklv", "okvc", "arkvd", "oklc", " kdd", "cklf", "klc", "kelv", " kvl", "jql", "okwl", "kva", " kvc", "Kln", "kicklee", "risknv", "kell", "kvc", "skcol", "ksll", "skell", "Klv", "oklv", "kelly", "kvl", " kln", " kli", "sklc", "kicklly", "skql", "cklc"], "metadata": ["parser", "ata", "data", "filename", "header", "ATA", "ma", "tmp", "shared", "member", "package", "m", "entry", "info", "details", "properties", "json", "description", "adata", "iterator", "message", "stream", "summary", "definition", "node", "meta", "session", "met"]}}
{"project": "FFmpeg", "commit_id": "1577526b47439f33a999339efdec5d624b70e1da", "target": 1, "func": "static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    opj_image_cmptparm_t cmptparm[4] = {{0}};\n    opj_image_t *img;\n    int i;\n    int sub_dx[4];\n    int sub_dy[4];\n    int numcomps;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    sub_dx[0] = sub_dx[3] = 1;\n    sub_dy[0] = sub_dy[3] = 1;\n    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;\n    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;\n    numcomps = desc->nb_components;\n    switch (avctx->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}", "idx": 1883, "substitutes": {"avctx": ["camctx", "afsci", "AVctx", "avectx", "avsci", "avconn", "afcmp", "afctx", "afcontext", "afpkg", "aveconn", "Avcontext", "akcontext", "Avconn", "Avctx", "avpkg", "akcmp", "AVpkg", "afconn", "AVcontext", "avecca", "camcontext", "camcca", "avcca", "avcontext", "avesci", "avecontext", "akpkg", "akctx", "Avsci", "afcca", "camconn", "AVcmp", "avcmp"], "parameters": ["paramseters", "configparams", "paramParameters", "ramParameters", "configParameters", "paramparams", "paramsParameters", "configeters", "ramparams", "paramsparams", "rameters"], "desc": ["sub", "name", "ext", "def", "esc", "conn", "dim", "loc", "d", "Description", "rec", "der", "de", "neg", "enc", "reci", "adr", "des", "dest", "dep", "info", "df", "config", "asc", "description", "dc", "ec", "dev", "doc", "design", "diff", "Desc", "text", "sc", "decl", "ca", "summary", "sec", "comment", "req", "dir", "pri", "dist"], "cmptparm": ["cmptpore", "cmptpair", "cmppfare", "cmptpare", "cmptfare", "cmpppare", "cmppparm", "cmptbare", "cmptppare", "cmptfair", "cmppfarm", "cmptbair", "cmpppair", "cmppfore", "cmppfair", "cmpppore", "cmptppore", "cmptpparm", "cmptfarm", "cmptppair", "cmptbore", "cmptfore", "cmptbarm"], "img": ["crop", "ff", "src", "sup", "imp", "ii", "norm", "picture", "orig", "im", "ng", "buf", "tmp", "cb", "tif", "iframe", "fig", "aff", "gd", "app", "br", "cube", "obj", "bg", "amp", "iv", "transform"], "i": ["cli", "ii", "pi", "ui", "r", "d", "I", "n", "iu", "j", "pixel", "ti", "ip", "l", "c", "p", "bi", "e", "f", "u", "v", "s", "b", "qi", "t", "ci", "io", "xi"], "sub_dx": [" sub_du", "Sub_dc", "sub__ded", "sub_ds", "Sub_dx", " sub_coe", "sub__dx", "sub_du", "sub__eddy", " sub_dq", "Sub_dy", "Sub_du", "sub_wd", "sub_ded", "sub_dj", "sub__dy", "sub__dc", " sub_eddy", "sub_dc", " sub_dj", "Sub_ded", "sub_eddy", "Sub_ds", "sub__wd", "sub_coe", "sub_dq", " sub_wd"], "sub_dy": [" sub_y", "Sub_dx", " sub_d", "sub_dt", "Sub_idd", "Sub_dj", "Sub_die", "sub__dx", "Sub_di", "sub_done", "sub_y", "sub__eddy", "sub_idd", "Sub_dy", "Sub_der", "sub__dt", "sub2dx", "sub_d", "sub_der", "sub__d", "sub__y", "sub_dj", "sub__dy", "Sub_done", " sub_eddy", "sub_die", "sub_di", "sub_eddy", "sub2dj", " sub_dt", "sub2dy", "sub2done"], "numcomps": ["numquonents", "numquples", "numcompos", "nbcomps", "numcomPS", "numcomponents", "numcompps", "numproPS", "numcompples", "nbcompples", "numcomonents", "ncomppos", "numproples", "numCompos", "nbcompPS", "numComonents", "numComples", "nbcomppos", "ncomonents", "ncompps", "nbcompps", "ncompos", "ncomples", "nbcompos", "numComPS", "numComps", "numcomples", "ncompples", "numcompPS", "numcomppos", "numqups", "ncomponents", "numpropos", "numqupos", "nbcomples", "numprops", "nbcomPS", "ncomps"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n", "idx": 1894, "substitutes": {"dev": ["cam", "def", "conn", "device", "mod", "data", "development", "ver", " priv", "der", "priv", "end", "grad", "dom", " Dev", "DEV", "Dev", "develop", "ve", "info", "bug", "gu", "prom", "app", "conf", " device", "driver", "ev", "rad", "dem", "error", "var", "debug", "diff"], "d": ["fd", "ld", "dn", "dd", "pd", "sd", "dh", "dad", "r", "n", "ad", "dl", "id", "dict", "dom", "j", "g", "i", "dx", "m", "dy", "z", "md", "dt", "config", "ds", "dc", "l", "c", "p", "ind", "w", "e", "f", "dm", "bd", "u", "cd", "dj", "s", "b", "t", "ded", "nd", "dat", "dp", "D", "gd", "db", "done"], "pci_conf": ["pcm_spec", "pci_dev", "pdi_Conf", "pki_conf", "pcu_con", "pki_dev", "pci_Conf", "pct_conn", "pct_conf", "pci_config", "pcm_conf", "pci_conn", "pcu_config", "pcm_config", "pdi_con", "pci_spec", "pki_Conf", "pct_dev", "pct_config", "pcu_conf", "pki_config", "pdi_conf", "pcu_conn", "pci_con", "pcm_conn"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 1896, "substitutes": {"fs_ctx": ["f_conn", "flowadecontext", "flowadectx", "fs_conn", "fsadecmp", "flow_context", "fs_req", "fsadereq", "fs_context", "flowadecmp", "f_ctx", "f_cas", "fs_cas", "flowadereq", "flow_req", "fsadectx", "flow_ctx", "f_context", "fs_cmp", "fsadecontext", "flow_cmp"], "oldpath": ["OLDpath", " olddest", "oldlink", "olderath", "olddest", "olderpath", "oldath", "OLDlink", "OLDpointer", " oldpointer", "OLDurl", " oldurl", "Oldlink", "olderpointer", "Olddest", "Oldpath", " oldlink", "Oldath", "olderlink", " oldath", "olderdest", "oldurl", "olderurl", "oldpointer"], "dir_path": [" dir2pointer", "dir2ath", "dir_context", "dir_ath", "dir_ctx", " dir2path", "dir___ath", " dir2context", "dir___path", " dir_pointer", "dir2context", "dir_info", " dir_info", "dir2pointer", " dir2ath", "dir___pointer", "dir_pointer", " dir_ctx", " dir_context", "dir___context", "dir2path", " dir_ath"], "name": ["base", "missing", "version", "ext", "time", "key", "alias", "acl", "host", "filename", "data", "image", "domain", "url", "new", "n", "type", "parent", "member", "pass", "none", "password", "source", "names", "address", "description", "content", "word", "Name", "size", "node", "prefix", "path", "root", "NAME", "nam"], "credp": ["crcpo", "creedpa", "credf", "credpc", " creedpa", "clds", "eclds", "credpi", "creampc", "cldc", " cprivpc", "creamp", "ecldf", "creedp", "ecldp", "cprivpc", "credpa", "cprivc", "cprivf", "creams", "credpo", "ecreds", "crcpa", "ecldc", "cprivs", "cldp", "creedpo", " creds", "ecredf", " credpc", " credpi", "crdpa", "creedpi", "creamc", "credc", " creedpo", "creds", " credc", " cprivs", " cprivp", " credpo", "crdp", "ecredc", "ecredp", "cldf", "crdpo", " cprivc", " credpa", "cprivp", "crcp", " creedp", " creedpi", "crdpi", "crcpi"], "retval": ["reVAL", "Retv", "returnval", "RetVAL", "returnVal", "refcol", "altval", "altv", "reval", "intvalue", "reeval", "Retvalue", "retvalue", "ntval", "intVal", " retv", "rtcol", "reteval", "intv", "altint", " retvalue", "returnvalue", "ntint", " retVal", "refvalue", " retint", "returnVAL", "rev", "retVAL", "rtval", "rtVal", "intval", "refv", " retvalid", " retVAL", "ntVal", "RetVal", "rtvalid", "altVal", "returnv", " reteval", "refVal", "refval", "refvalid", "retint", "altvalid", "altVAL", "retVal", "retv", "retvalid", "alteval", " retcol", "ntvalid", "Retval", "retcol"], "fullname": ["fulpart", "completeline", "longnamed", "Fullspan", "fuln", "FullName", "fullspan", "fullyline", "shortName", "fulpath", "fullyName", "fulName", "fultext", "Fullpart", "fullyspan", "longcap", "longname", "shortname", "fullyname", "shortn", " fullpath", "fullycap", " fullcap", "fulln", "shortpath", "completenamed", "fullpart", "fullName", "fulcap", " fullName", "longtext", "fullypart", " fulln", "fulspan", "fullline", "fullpath", "Fullname", "fulname", "longName", "fulltext", "completename", "fullnamed", "fullcap", "fullynamed", "longline", "fullytext"], "target": ["route", "base", "null", "channel", "alias", "method", "host", "wrong", "filename", "data", "effect", "url", "tag", "template", "type", "cat", "format", "id", "Target", "prop", "parent", "platform", "client", "next", "output", "label", "component", "dest", "password", "project", "source", "pattern", "pointer", "arget", "address", "content", "result", "owner", "top", "secret", "resource", "reset", "front", "text", "token", "eth", "value", "range", "goal", "shadow", "prefix", "transform", "path", "subject", "root", "protected", "net", "task"]}}
{"project": "qemu", "commit_id": "ea486926b07d2ebd73ef67315ebb1eecf39faf5a", "target": 0, "func": "static int vfio_enable_intx(VFIODevice *vdev)\n\n{\n\n    VFIOIRQSetFD irq_set_fd = {\n\n        .irq_set = {\n\n            .argsz = sizeof(irq_set_fd),\n\n            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,\n\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n\n            .start = 0,\n\n            .count = 1,\n\n        },\n\n    };\n\n    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);\n\n    int ret;\n\n\n\n    if (vdev->intx.disabled || !pin) {\n\n        return 0;\n\n    }\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */\n\n    ret = event_notifier_init(&vdev->intx.interrupt, 0);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: event_notifier_init failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);\n\n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n\n        error_report(\"vfio: Error: Failed to setup INTx fd: %m\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /*\n\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n\n     * access as a response to an interrupt and unmask the physical\n\n     * device.  The device will re-assert if the interrupt is still\n\n     * pending.  We'll likely retrigger on the host multiple times per\n\n     * guest interrupt, but without EOI notification it's better than\n\n     * nothing.  Acceleration paths through KVM will avoid this.\n\n     */\n\n    vfio_mmap_set_enabled(vdev, false);\n\n\n\n    vdev->interrupt = VFIO_INT_INTx;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    return 0;\n\n}\n", "idx": 1900, "substitutes": {"vdev": ["evdef", " vdc", "zdie", "vvdom", "zvar", "vapp", " vvar", "gdevice", "etdie", "vvdev", "hdevelopment", "pdef", "uvrad", "ldef", "pdevice", " vhost", "cdom", "vdevelopment", " vdiff", "svapp", " vconn", "Vdiff", "prad", "wdiv", "Vvar", "vmconn", "verdev", "ldiff", "svdef", "vserv", "ggr", "nvev", "svdevice", "vhost", "vdevice", "lev", "vdiv", "vmvar", "verhost", "vrad", "wconn", "cev", "evev", "crad", "wdom", "Vdd", "wdie", "evdi", "hev", "wserv", "Vconn", "evdevice", "Vdc", "ethost", "ldev", "lgr", "vdiff", "vev", "vvev", "evdev", "wvar", "lconn", "svdi", "etver", "cdie", "Vdef", "wdiff", "vvdie", "wdev", "vdie", "wdevice", " vdevice", "uvev", "ldevice", " vdi", "pdiff", "gdev", "vvar", "svconn", "nvdevelopment", "pdie", "Vdevice", "vver", "vdc", "vdef", "verver", "vconn", "hdev", "vgr", "ldd", "gev", "zdev", "evdie", "nvdev", " vdie", "vdom", "Vdev", "etdev", " vdiv", "evconn", "uvdevelopment", "pdev", "verdie", "vdi", "nvrad", "wdc", "vdd", "vmdev", "svdd", "cdev", "hrad", " vgr", "vmdevice", "cdevice", "Vdie", " vdef", "pserv", "evapp", " vev", "uvdev", "svdev", "pev", "wev", "svrad", "svdie", "vvdevice", "pdc", "Vver", " vver", " vserv", "zver", "vvapp"], "ret": ["match", "arg", "irm", "fun", " Ret", "success", "get", "r", "alt", "ry", "id", "pet", "rets", "num", "rf", "py", " RET", "fail", "rep", "fab", "nt", "rev", "err", "back", "reply", "Ret", "rc", "pat", "result", "fin", "try", "len", "red", "flag", "ref", "reset", "std", "RET", "error", "lit", "reg", "re", "val", "rt", "repl", "pin", "det", "res", "bad"]}}
{"project": "qemu", "commit_id": "fc89efe693278c79273f3bbf6b581e8a749c85b0", "target": 0, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    /* mvc and memmove do not behave the same when areas overlap! */\n\n    } else if ((dest < src) || (src + l < dest)) {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if ((dest + 8 <= src) || (src + 8 <= dest)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version with byte accesses which always work */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 1902, "substitutes": {"env": ["eu", "np", "vm", "ctx", "atten", "fen", "conn", "context", "esi", "queue", "her", "tern", "equ", "environment", "nc", "priv", "dict", "ea", "worker", "end", "buf", "eng", "cdn", "here", "enc", "gear", "inet", "eni", "erv", "enh", "info", "dep", "ah", "er", "err", "style", "ep", "dt", "config", "kn", "ec", "opt", "exc", " environment", "eye", "Environment", "eve", "fg", "state", "dev", "e", "esp", "eh", "app", "exec", "viron", "el", "en", "v", "ev", "iv", "qa", "engine", "init", "net", "que", "console", "dat", "export", "db", "ench"], "l": ["pl", "ell", "li", "ol", "jl", "ul", "lp", "lb", "url", "r", "loc", "d", "n", "isl", "dl", "fl", "ln", "sl", "lu", "lang", "k", "wl", "nl", "y", "j", "g", "ls", "ll", "source", "z", "h", "c", "p", "L", "x", "lc", "len", "rl", "kl", "length", "f", "e", "u", "la", "el", "il", "o", "v", "s", "b", "lin", "t", "al", "lit", "line", "list", "le"], "dest": ["route", "rest", "txt", "url", "head", "de", "destroy", "secure", "direction", "home", "opt", "trans", "shift", "dev", "du", "sc", "decl", "en", "path", "location", "again", "dir", "start", "vision", "pl", "name", "sup", "target", "desc", "host", "Dest", "vert", "gz", "cdn", "end", "tmp", "later", "coord", "lc", "resource", "text", "origin", "wd", "v", "session", "transform", "lit", "data", "new", "loc", "di", "proc", "dep", "slice", "cont", "back", "wh", "feat", "ident", "st", "usr", "size", "attr", "front", "other", "inst", "gen", "img", "slave", "uc", "done", "null", "class", "d", "fl", "prop", "priv", "ord", "now", "seed", "future", "comb", "source", "temp", "config", "dc", "bound", "wb", "uv", "diff", "dist", "rc"], "src": ["route", "sub", "rib", "rest", "ul", "url", "alt", "sl", "connect", "us", "sc", "s", "hl", "uri", "obl", "start", "pl", "vision", "sup", "target", "ource", "access", "sb", "filename", "send", "RC", "sh", "gz", "gn", "sit", "resource", "length", "text", "sn", "sr", "lib", "iv", "lit", "ssl", "ruby", "r", "loc", "remote", "nil", "proc", "cb", "slice", "back", "feat", "st", "sel", "c", "front", "stream", "sec", "win", "gl", "inst", "sur", "img", "low", "uc", "null", "server", "rob", "cur", "download", "rb", "sync", "source", "ch", "config", "ources", "stack", "rl", "uv", "gb", "uint", "username", "pull", "b", "sort", "view", "desc", "dist", "rc"], "i": ["yi", "li", "gi", "ni", "ii", "ji", "h", "pi", "ui", "r", "d", "I", "n", "di", "is", "id", "mi", "it", "iu", "im", "j", "y", "m", "ri", "ti", "ini", "z", "index", "ai", "ie", "x", "c", "p", "L", "ip", "w", "e", "bi", "f", "hi", "u", "o", "v", "ind", "b", "qi", "ix", "ci", "io", "fi", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "ba0e276db4b51bd2255a5d5ff8902c70d32ade40", "target": 0, "func": "void helper_store_fpcr (uint64_t val)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n\n#endif\n\n    switch ((val >> 58) & 3) {\n\n    case 0:\n\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n\n        break;\n\n    case 1:\n\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n\n        break;\n\n    case 2:\n\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n\n        break;\n\n    case 3:\n\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n\n        break;\n\n    }\n\n}\n", "idx": 1905, "substitutes": {"val": ["ret", "base", "arg", "vol", "ol", "def", "key", "bit", "Value", "vals", "data", "pol", "d", "ver", "Val", "slot", "vert", "sl", "buf", "num", "py", "sel", "x", "p", "ut", "f", "eval", "ref", "gold", "gb", "value", "el", "v", "b", "serv", "lv", "valid", "al", "VAL", "count", "pt", "db"]}}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n", "idx": 1909, "substitutes": {"tcet": ["tgen", "tcacket", "pcet", "tcET", "tcen", " tcacket", "cuet", "tmET", "TCET", "TCable", "cuable", "tmet", "pcET", "TCet", " tcen", " tcET", "cuen", "TCen", "tgET", "pcacket", "tmen", "tget", "tcable", "tgacket", "tmable", "cuET", "pcen"], "bypass": ["samePass", "viafill", " byrupt", "BYPASS", "byread", "byPASS", "byride", "ByPass", "byfill", "Byrupt", "viapass", "byPass", "sameride", "bytepass", "samepass", " byPass", "Bypass", "ByPASS", " byread", "BYPass", "perPass", " byride", " byfill", "perread", "samePASS", "perpass", "byterupt", "BYride", "byrupt", "viaread", "BYpass", " byPASS", "perfill", "bytePass", "viaPass", "bytePASS"]}}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_wakeup_request(WakeupReason reason)\n\n{\n\n    if (!is_suspended) {\n\n        return;\n\n    }\n\n    if (!(wakeup_reason_mask & (1 << reason))) {\n\n        return;\n\n    }\n\n    runstate_set(RUN_STATE_RUNNING);\n\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);\n\n    notifier_list_notify(&wakeup_notifiers, &reason);\n\n    reset_requested = 1;\n\n    qemu_notify_event();\n\n    is_suspended = false;\n\n}\n", "idx": 1917, "substitutes": {"reason": ["unit", "group", "null", "name", "cycle", "ception", "second", "byte", "charge", "method", "effect", "process", "data", "race", "report", "type", "cause", "record", "num", "year", "component", "code", "event", "number", "err", "request", "cond", "index", "status", "crit", "warning", "write", "description", "exc", "category", "result", "change", "condition", "source", "message", "issue", "resp", "comment", "sec", "Reason", "connection", "cmp", "error", "monitor", "rule", "notice", "subject", "re", "session", "response"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int rtsp_listen(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char proto[128], host[128], path[512], auth[128];\n\n    char uri[500];\n\n    int port;\n\n    int default_port = RTSP_DEFAULT_PORT;\n\n    char tcpname[500];\n\n    const char *lower_proto = \"tcp\";\n\n    unsigned char rbuf[4096];\n\n    unsigned char method[10];\n\n    int rbuflen = 0;\n\n    int ret;\n\n    enum RTSPMethod methodcode;\n\n\n\n    if (!rt->protocols) {\n\n        rt->protocols = ffurl_get_protocols(NULL, NULL);\n\n        if (!rt->protocols)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),\n\n                 &port, path, sizeof(path), s->filename);\n\n\n\n    /* ff_url_join. No authorization by now (NULL) */\n\n    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,\n\n                port, \"%s\", path);\n\n\n\n    if (!strcmp(proto, \"rtsps\")) {\n\n        lower_proto  = \"tls\";\n\n        default_port = RTSPS_DEFAULT_PORT;\n\n    }\n\n\n\n    if (port < 0)\n\n        port = default_port;\n\n\n\n    /* Create TCP connection */\n\n    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,\n\n                \"?listen&listen_timeout=%d\", rt->initial_timeout * 1000);\n\n\n\n    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,\n\n                         &s->interrupt_callback, NULL, rt->protocols)) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to open RTSP for listening\\n\");\n\n        return ret;\n\n    }\n\n    rt->state       = RTSP_STATE_IDLE;\n\n    rt->rtsp_hd_out = rt->rtsp_hd;\n\n    for (;;) { /* Wait for incoming RTSP messages */\n\n        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);\n\n        if (ret < 0)\n\n            return ret;\n\n        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,\n\n                                 sizeof(method), &methodcode);\n\n        if (ret) {\n\n            av_log(s, AV_LOG_ERROR, \"RTSP: Unexpected Command\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if (methodcode == ANNOUNCE) {\n\n            ret       = rtsp_read_announce(s);\n\n            rt->state = RTSP_STATE_PAUSED;\n\n        } else if (methodcode == OPTIONS) {\n\n            ret = rtsp_read_options(s);\n\n        } else if (methodcode == RECORD) {\n\n            ret = rtsp_read_record(s);\n\n            if (!ret)\n\n                return 0; // We are ready for streaming\n\n        } else if (methodcode == SETUP)\n\n            ret = rtsp_read_setup(s, host, uri);\n\n        if (ret) {\n\n            ffurl_close(rt->rtsp_hd);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1937, "substitutes": {"s": ["sg", "server", "js", "service", "src", "cs", "http", "ss", "ops", "rs", "spec", "ts", "sa", "sb", "txt", "a", "ant", "qs", "r", "d", "n", "aws", "sl", "ions", "client", "op", "bis", "g", "params", "ses", "ls", "sf", "args", "details", "sync", "xs", "sv", "storage", "ds", "request", "sets", "settings", "gs", "ns", "c", "p", "services", "e", "us", "f", "es", "sys", "sq", "conf", "south", "sec", "o", "v", "su", "site", "S", "t", "session", "b", "os", "serv", "its", "fs", "si", "sym", "ssl"], "rt": ["rot", "dr", "ort", "MT", "apt", "urt", "att", "mt", "rs", "ant", "vt", "rn", "ht", "ott", "rr", "r", "rob", "ct", "ru", "xt", "it", "boot", "rf", "adr", "rb", "BT", "kt", "tx", "OT", "nt", "ft", "fr", "dt", "RS", "tr", "NT", "RT", "ut", "rl", "gd", "gt", "yt", "bt", "art", "tt", "rat", "rd", "t", "irt", "vr", "dat", "qt", "pt", "nd", "rh", "td", "rect", "ot", "rc"], "proto": ["produpos", "probo", "produto", "ropo", "prob", "peto", "proocol", "Proname", "Proocol", "protbo", "protocol", " prodo", "roo", "preto", "prepo", " proname", "protto", "pedo", "Proo", "protb", "propo", "prepos", " proocol", "prename", "Prodo", "Proto", "peb", "roto", "roocol", " prob", "peocol", "proo", "protpo", "prebo", "preocol", "propos", "protpos", "proname", "produbo", "Propo", " propo", "protdo", "prodo", "produpo"], "host": ["server", "name", "service", "act", "http", "target", "context", "url", "domain", "localhost", "header", "type", "id", "Host", "graph", "parent", "proxy", "component", "mac", "file", "password", "source", "database", "pattern", "config", "home", "address", "ip", "h", "connect", "condition", "hop", "object", "username", "node", "ith", "driver", "subject", "socket", "addr", "dir", "arch", "input", "user"], "path": ["route", "test", "name", "http", "key", "context", "data", "url", "image", "filename", "loc", "type", "prop", "id", "component", "file", "Path", "password", "request", "source", "pattern", "config", "raw", "home", "PATH", "content", "h", "p", "resource", "col", "text", "ath", "node", "ith", "prefix", "subject", "location", "limit", "dir", "user"], "auth": ["UTH", "uth", "act", "http", "conn", "array", "acl", "data", "url", "type", "author", "id", "priv", "enc", "pass", "mac", "ac", "info", "password", "config", "home", "opt", "address", "authent", "ip", "h", "thin", "afi", "private", "Auth", "token", "eth", "ath", "cmd", "crypt", "username", "wd", "ith", "account", "error", "anon", "arch", "ssl"], "uri": ["unit", "route", "base", "cli", " ur", "href", "src", "http", "iri", "URI", "filename", "pi", "ui", "url", "prot", "loc", " url", "uni", "format", "id", "remote", "api", "i", "ri", "file", "source", "storage", "config", "address", "description", "ip", "resource", " URI", "username", "prefix", "uid", "line", "io", "dir", "timeout"], "port": ["allow", " transport", "match", "ort", "test", "server", "name", "version", "service", "offset", "time", "target", "http", "key", "url", "pi", "type", "prop", "position", "page", "id", "use", "alt", "duration", "pass", "proxy", "pos", "component", "phone", "Port", "password", "direction", "slice", "ports", "index", "pid", "number", "config", "select", "address", "ip", "p", "start", "hop", "length", "size", "patch", "value", "PORT", "rule", "count", "pt", "limit", "import", "timeout", "part", "user"], "tcpname": ["tpni", "tmppath", "tippath", "tcppath", "TpName", "tppname", "tmpresource", "Tcpname", "tcapName", "tipresource", " tcpName", "TcpName", "Tmppath", "Tcppath", "tipName", " tcpni", "tcpsize", " tworknam", "Tpni", "tworkname", "tpname", " tmpsize", "tppName", "tmpName", "TcpNAME", "tworkName", "tfpresource", "TmpName", " tmpName", "tfpName", "tcapname", "tworknam", " tworkname", "Tpname", "tmpname", "tpNAME", "tipname", "tworkni", "Tcpni", "tmpni", "Tmpresource", " tmpname", "tcpni", "tcpnam", "tcapNAME", "tcpresource", "tfpni", "Tcpresource", "tfpname", "tpName", "TpNAME", " tworkName", "tfpnam", " tworkni", "tcpName", "tpsize", " tcpnam", " tcpsize", "tcpNAME", "tppsize", "tfppath", "tmpsize", "Tmpname", "tcapni"], "lower_proto": ["lower_prodo", "lower_propo", "lower_protpo", "lower_protdo", "lower_proo", "lower_protto", "lower_protocol", "lower_pero", "lower_perocol", "lower_Propo", "lower_perto", "lower_Proto", "lower_Proocol", "lower_Proo", "lower_proocol", "lower_perdo", "lower_Prodo", "lower_perpo"], "rbuf": ["rbef", "bef", "erbux", "fbundle", " bundle", "rbux", "sbuf", "sbuffy", "wbbf", "rebux", " buf", "fbbuf", "rbuff", "erbef", "rebbf", "wbuf", "sbuff", "buff", "bundle", "buf", "rbbf", "fbuc", "rebund", "bbuf", "rbundle", "sbef", "rbbuf", "rebuff", "buc", "rbuffy", "sbux", "buffy", "rbuc", " buc", "erbuffy", "wbuff", "rebuf", "erbbf", "erbund", "erbuff", "fbuf", " bbuf", "erbuf", "wbund", "sbund", "rbund"], "method": ["cli", "http", "URI", "url", "prot", "header", "format", "mi", "client", "api", "file", "config", "description", "address", "man", "ip", "resource", "text", "message", "stream", "username", "prefix", "seq", "session", "mode", "ssl"], "ret": ["match", "arg", "fun", "no", "att", "def", "bit", "success", " Ret", "data", "get", "out", "alt", "cat", "id", "pet", "rets", "end", "num", "pass", " RET", "fail", "rep", "code", "info", "nt", "ft", "str", "reply", "status", "Ret", "back", "bf", "result", "try", "len", "red", "ref", "flag", "resp", "value", "art", "obj", "sr", "lib", "RET", "error", "lit", "reg", "re", "val", "count", "let", "part", "det", "res", "rc", "bad"], "methodcode": ["methodCode", "nameCode", "typenumber", "namecode", "METHODdef", "METHODCode", "METHODcode", "typecode", "METHODnumber", "methoddef", "namenumber", "typeCode", "methodnumber", "namedef"]}}
{"project": "FFmpeg", "commit_id": "365ef88d5df4756942324b633cc439154e468276", "target": 1, "func": "int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,\n\n                            VLC *vlc, const float *level_table,\n\n                            const uint16_t *run_table, int version,\n\n                            WMACoef *ptr, int offset, int num_coefs,\n\n                            int block_len, int frame_len_bits,\n\n                            int coef_nb_bits)\n\n{\n\n    int code, level, sign;\n\n    const uint32_t *ilvl = (const uint32_t *) level_table;\n\n    uint32_t *iptr = (uint32_t *) ptr;\n\n    const unsigned int coef_mask = block_len - 1;\n\n    for (; offset < num_coefs; offset++) {\n\n        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);\n\n        if (code > 1) {\n\n            /** normal code */\n\n            offset                  += run_table[code];\n\n            sign                     = get_bits1(gb) - 1;\n\n            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;\n\n        } else if (code == 1) {\n\n            /** EOB */\n\n            break;\n\n        } else {\n\n            /** escape */\n\n            if (!version) {\n\n                level = get_bits(gb, coef_nb_bits);\n\n                /** NOTE: this is rather suboptimal. reading\n\n                 *  block_len_bits would be better */\n\n                offset += get_bits(gb, frame_len_bits);\n\n            } else {\n\n                level = ff_wma_get_large_val(gb);\n\n                /** escape decode */\n\n                if (get_bits1(gb)) {\n\n                    if (get_bits1(gb)) {\n\n                        if (get_bits1(gb)) {\n\n                            av_log(avctx, AV_LOG_ERROR,\n\n                                   \"broken escape sequence\\n\");\n\n                            return -1;\n\n                        } else\n\n                            offset += get_bits(gb, frame_len_bits) + 4;\n\n                    } else\n\n                        offset += get_bits(gb, 2) + 1;\n\n                }\n\n            }\n\n            sign                    = get_bits1(gb) - 1;\n\n            ptr[offset & coef_mask] = (level ^ sign) - sign;\n\n        }\n\n    }\n\n    /** NOTE: EOB can be omitted */\n\n    if (offset > num_coefs) {\n\n        av_log(avctx, AV_LOG_ERROR, \"overflow in spectral RLE, ignoring\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1945, "substitutes": {"avctx": ["afconfig", "evcli", "evctx", "AVctx", "evcontext", "evcmp", "avconn", "afctx", "afcontext", "akconfig", "navctx", "avconv", "akconv", "Avcontext", "avcli", "akcontext", "Avctx", "apcontext", "afconn", "Avconfig", "navcmp", "AVcontext", "antcontext", "apctx", "navcontext", "apci", "avconfig", "afci", "avcontext", "antconn", "antci", "avci", "antctx", "afconv", "avcmp", "navcli", "akctx", "AVcli", "AVcmp", "Avconv", "apconn"], "gb": ["rg", "sg", "cli", "gpu", "src", "ctx", "gram", "kb", "bn", "ga", "tg", "byte", "sb", "gc", "bm", "go", "hub", "gru", "gy", "mb", "eb", "binary", "gh", "ui", "gnu", "loc", "bc", "ge", "gz", "gate", "GB", "py", "gin", "g", "ha", "gg", "rb", "gm", "lb", "cgi", "cb", "slice", "storage", "cod", "gam", "bf", "gs", "gu", "phy", "nb", "ym", "git", "gt", "agg", "tm", "bb", "pc", "bridge", "lib", "b", "abb", "usb", "ci", "cfg", "gal", "gp", "gd", "db", "game"], "vlc": ["velct", "svf", "svct", "llf", "velci", "lvf", "lvci", "wlm", "lvc", "velf", "wlf", "llm", "lvct", "vlf", "vlac", "svci", "vlci", "llac", "svc", "lvm", "llc", "lvac", "wlc", "vlct", "velc", "wlac", "vlm"], "level_table": ["levelalcode", "levelingtab", "run_list", "level_family", "level__count", "level_list", "run_code", "level__table", "levelalcount", "level__family", "levelingtable", "level__code", "level_val", "levelaltable", "run_tab", "level_tab", "run_family", "level_code", "levelingval", "levelalfamily", "run_val", "level_count", "levelinglist", "run_count"], "run_table": ["updateallbuffer", "runlisttable", "unit_count", "rungtable", "runvaltable", "updateallwindow", "run_buffer", "update_window", "updateallbase", "unit_table", "unit_sequence", "run_interface", "update_table", "rungbase", "run_window", "runvalbuffer", "runallwindow", "runlistsequence", "rungbuffer", "runlistcount", "unit_interface", "update_buffer", "run_base", "update_base", "updatealltable", "runallbuffer", "runvalbase", "run_sequence", "runvalwindow", "runallbase", "rungwindow", "runalltable", "run_count", "runlistinterface"], "version": ["unit", "vision", "supported", "server", "build", "ception", "Version", "compatible", "url", "ver", "vert", "format", "parent", "model", "update", "package", "python", "rev", "config", "native", "feature", "step", "beta", "secret", "len", "length", "patch", "release", "v", "scale", "final", "conv", "valid", "depth", "support", "VERSION", "cover", "versions", "option"], "ptr": ["stage", "dr", "src", "buffer", "trace", "elt", "tty", "loc", "sh", "pb", "grad", "buf", "handle", "pair", "py", "pre", "pos", "fp", "push", "slice", "tr", "ipt", "pointer", "cod", "impl", "bf", "address", "pad", "Ptr", "pr", "ocr", "length", "ref", "attr", "ctr", "br", "eth", "alloc", "pc", "inst", "addr", "td", "val", "pt", "gp", "transfer", "rect", "sth", "port"], "offset": ["success", "url", "notation", "index", "pointer", "address", "alpha", "shift", "set", "iterator", "f", "fee", "optional", "action", "stop", "location", "limit", "start", "option", "unit", "sequence", "image", "align", "position", "type", "parent", "end", "off", "fp", "post", "hop", "length", "origin", "layer", "base", "trace", "skip", "loc", "axis", "member", "i", "info", "slice", "enabled", "et", "order", "len", "size", "iso", "attr", "o", "error", "oa", "stage", "anch", "append", "alias", "area", "annot", "operation", "it", "initial", "seed", "pos", "output", "entry", "sync", "attribute", "style", "bound", "padding", "point", "Offset", "line", "addr", "part"], "num_coefs": ["num_coifferences", "num_coiferences", "num_coalferences", "num_CoEFs", "num_coEFd", "num_Coefi", "num_coffd", "num_crossiffes", "num_coEFn", "num_coEFi", "num_crossiffs", "num_coffi", "num_coEFs", "num_coefi", "num_coffn", "num_coiffsets", "num_crossiffsets", "num_CoEFn", "num_coeffs", "num_coefn", "num_coofd", "num_coifsets", "num_Coefd", "num_CoEFd", "num_Coefs", "num_crossefs", "num_coalfes", "num_coalfs", "num_crosseferences", "num_crossefsets", "num_coofi", "num_coalfsets", "num_coifs", "num_crossifferences", "num_coffs", "num_coeferences", "num_coifes", "num_coefsets", "num_CoEFi", "num_coiffes", "num_coefd", "num_coofs", "num_coofn", "num_Coefn", "num_coeffd", "num_crossefes", "num_coeffn", "num_coeffi", "num_coefes", "num_coiffs"], "block_len": ["block_cache", "frame_data", "block67len", " block_cache", "block_length", "block_data", "block_size", " block_length", "block67Len", "block67length", "block67cache", "block_Len", "frame_length", "frame_size", " block_Len", "frame_len"], "frame_len_bits": ["frame_len2bits", "frame_len2pieces", "frame_Len2bits", "frame_len_cycles", "frame_val_bits", "frame_len_pieces", "frame_len_parts", "frame_Len_pieces", "frame_len2bytes", "frame_len_bytes", "frame_Len2pieces", "frame_Len2parts", "frame_val_bytes", "frame_Len_parts", "frame_val_parts", "frame_val_cycles", "frame_Len_bits", "frame_Len2bytes", "frame_Len_bytes", "frame_len2parts"], "coef_nb_bits": ["coef_num_bits", "coef_nb_frames", "coef_nb_bit", "coef_nb_pieces", "coef_num_bytes", "coef_num_frames", "coef_len_bit", "coef_len_pieces", "coef_nb_bytes", "coef_num_pieces", "coef_len_bits"], "code": ["stage", "layer", "call", "base", "Code", "test", "scene", "name", "cycle", "buffer", "coded", "rate", "bit", "second", "key", "cc", "charge", "grade", "zip", "go", "complete", "loc", "co", "type", "id", "end", "enc", "comp", "later", "component", "score", "comb", "ode", "coll", "create", "bug", "cb", "index", "status", "cod", "ch", "ec", "function", "func", "ce", "content", "change", "c", "p", "address", "age", "state", "e", "order", "f", "length", "size", "core", "message", "sec", "comment", "error", "codes", "line", "count", "desc", "pack"], "level": ["unit", "layer", "cost", "stage", "test", "base", "letter", "name", "lock", "call", "local", "vol", "ul", "key", "pe", "grade", "cl", "loc", "global", "weight", "type", "fl", "lvl", "scope", "parent", "member", "pass", "model", "coll", "index", "status", "vel", "step", "change", "lc", "len", "length", "child", "patch", "mask", "Level", "round", "scale", "cel", "error", "clean", "depth", "path", "valid", "rule", "line", "val", "count", "limit", "inc", "rol"], "sign": ["pl", "call", "sub", "name", "act", "skip", "shape", "spec", "sa", "mod", "bit", "form", "ver", "weight", "sp", "id", "sh", "ign", "parent", "sk", "enc", "pass", "max", "pos", "scan", "push", "style", "Sign", "inc", "z", "status", "parse", "ident", "feed", "err", "pad", "change", "ind", "shift", "connect", "p", "SIGN", "set", "size", "length", "fix", "dig", "patch", "draw", "cap", "save", "mask", "min", "value", "comment", "sum", "round", "pull", "scale", "action", "sort", "close", "gen", "se", "start", "plus", "diff", "pack"], "ilvl": ["iolkl", "ilkl", "iolwl", "islwl", "illv", "illkl", "illwl", "illvl", "islfl", " illv", "ilfl", "ilwl", "isllv", "elwl", "elfl", "iolvl", "ellv", "elkl", "elvl", "islvl", "iollv", " ilfl", " ilwl", "illlv"], "iptr": ["iptor", "ipR", "ptry", "ptn", "iptn", "aphn", "ipl", "iptR", "ctor", "ipr", "ipor", "inetr", "iptl", "inetR", "ippor", "inetl", "ctn", "ippl", "ptor", "aphr", "ctr", "ippr", "aphor", "ctry", "ippR", "iptry", "inetor", "aphry"]}}
{"project": "FFmpeg", "commit_id": "9241cd2095fe8395e02be5556d657d06f65ba91f", "target": 0, "func": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n\n                         AVFilterInOut *open_inputs,\n\n                         AVFilterInOut *open_outputs, AVClass *log_ctx)\n\n{\n\n    int index = 0, ret;\n\n    char chr = 0;\n\n\n\n    AVFilterInOut *curr_inputs = NULL;\n\n\n\n    do {\n\n        AVFilterContext *filter;\n\n        filters += strspn(filters, WHITESPACES);\n\n\n\n        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if (filter->input_count == 1 && !curr_inputs && !index) {\n\n            /* First input can be omitted if it is \"[in]\" */\n\n            const char *tmp = \"[in]\";\n\n            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n                goto fail;\n\n        }\n\n\n\n        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        filters += strspn(filters, WHITESPACES);\n\n        chr = *filters++;\n\n\n\n        if (chr == ';' && curr_inputs) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",\n\n                   filters - 1);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        index++;\n\n    } while (chr == ',' || chr == ';');\n\n\n\n    if (chr) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",\n\n               filters - 1);\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {\n\n        /* Last output can be omitted if it is \"[out]\" */\n\n        const char *tmp = \"[out]\";\n\n        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail:\n\n    avfilter_graph_free(graph);\n\n    free_inout(open_inputs);\n\n    free_inout(open_outputs);\n\n    free_inout(curr_inputs);\n\n    return ret;\n\n}\n", "idx": 1946, "substitutes": {"graph": ["flow", "group", "context", "hash", "follow", "raph", "image", "scroll", "format", "scope", "query", "parent", "handle", "model", "g", "proxy", "output", "network", "document", "pattern", "pool", "config", "closure", "feed", "connect", "stack", "f", "cache", "stream", "handler", "node", "tree", "connection", "dot", "path", "subject", "root", "edge", "Graph"], "filters": ["Fileners", "flts", "Filters", "feedtered", "factters", "factcers", "fileners", "matlets", "filelines", "buttered", "fts", "liftons", "iltering", "feedts", "filecers", "fileters", "matters", "synters", "fltering", "filtons", "ilters", "iltons", "filts", "butters", "ftered", "mattered", "butter", "fators", "fltons", "helts", "iltered", "FILers", "heltering", "matter", "fchers", "flter", "feedtering", "FILter", "feedlets", "mattering", "ilches", "FILchers", "syncers", "filners", "fileers", "colers", "Filers", "filcers", "liftered", "lifeners", "filers", "coltering", "FILches", "factners", "fillines", "collets", "flters", "ftering", "colors", "FILtering", "Filts", "fillets", "FILtered", "lifters", "liftering", "collines", "fters", "feedters", "fileors", "flers", "Filter", "filors", "ilors", "FILators", "helters", "FILts", "fter", "filchers", "filtered", "synners", "filtering", "coltered", "feedter", "ilers", "heleners", "filators", "colts", "matts", "filches", "colters", "butchers", "fltered", "illines", "syners", "FILters", "lifts", "facters", "colators", "colches", "Filtering"], "open_inputs": ["open_pathes", "open_paths", "open_patherences", "open_selecterences", "open_outputts", "open_pullerences", "open_columnerences", "open_outputops", "open_inputops", "open_contextches", "open_outputors", "open_pathors", "open_columnts", "open_outputches", "open_contextes", "open_platformts", "open_pulls", "open_platformerences", "open_loges", "open_platformes", "open_outputerences", "open_columnches", "open_logviews", "open_pulles", "open_logerences", "open_Inputops", "open_selects", "open_outputes", "open_outputb", "open_selectes", "open_contexts", "open_columnops", "open_contexterences", "open_outputviews", "open_columnb", "open_columnes", "open_Inputts", "open_Inputb", "open_inputb", "open_selectors", "open_contextviews", "open_inputviews", "open_inputches", "open_Inputs", "open_logs", "open_inputes", "open_inputors", "open_platforms", "open_pullts", "open_inputerences", "open_columns", "open_inputts"], "open_outputs": ["open_connecting", "open_outputors", "open_outputing", "open_columnments", "open_contextes", "open_returns", "open_contextsets", "open_patternviews", "open_graphses", "open_methodes", "open_inputflows", "open_columnflows", "open_outputerences", "open_returnes", "open_connecterences", "open_returnors", "open_outputments", "open_outputes", "open_contexts", "open_outputflows", "open_inputments", "open_inputing", "open_outputsets", "open_returning", "open_connectviews", "open_outputviews", "open_methods", "open_inputses", "open_contextses", "open_columnes", "open_patterns", "open_graphs", "open_graphes", "open_graphsets", "open_methodflows", "open_inputviews", "open_patternerences", "open_outputses", "open_columning", "open_columnors", "open_inputsets", "open_connects", "open_methodments", "open_inputes", "open_inputors", "open_inputerences", "open_patterning", "open_columns"], "log_ctx": ["logFctx", "logadecontext", "log_cn", "logercmd", " log_context", "logadelc", "loglloc", "Log_tx", "log_voc", "logerctx", "logMlc", "log_cmd", "logingobj", "log_context", "log_cu", "log_tc", "loglctx", "bug_loc", "logFcot", "log_pkg", " log_tx", "logMpkg", "log_loc", "Log_ctx", "loggtx", "log_c", " log_cot", "log_tx", " log_tc", "log_stack", "log_cot", "log_obj", "logercu", "logadeobj", "log_lc", "loggc", "logMcu", "logFlc", "Log_context", "logingvoc", "logadecmd", " log_lc", "log_cf", "logercn", "bug_stack", "logingctx", " log_voc", "Log_c", "logadectx", " log_obj", "loggcontext", " log_cn", " log_cu", "logercf", "logingcu", "loginglc", "logFtc", " log_pkg", "logMctx", "loglcn", " log_cf", "logadepkg", "bug_ctx", " log_cmd", "bug_cn", "logingtx", "logingcontext", "logMcontext", "loglstack", "logerlc", "logadecu", "loggctx", "logMobj"], "ret": ["match", "arg", "fun", "att", "mt", "def", "bit", "conn", "hash", "sb", "success", "get", "url", "alt", "cat", "wrap", "job", "id", "pet", "rets", "fit", "true", "arr", "pass", "rb", "ft", "nt", "rev", "err", "back", "reply", "feat", "Ret", "rc", "pat", "bf", "result", "usr", "bot", "trans", "len", "ref", "flag", "gt", "art", "obj", "cb", "RET", "session", "valid", "al", "lit", "re", "reg", "val", "rt", "let", "part", "det", "res", "db", "mem"], "curr_inputs": ["curr_inputos", "curr_configb", "curr_subjectes", "curr_colls", "curr_inputes", "curr_keeps", "curr_methods", "curr_configsets", "curr_initials", "curr_logos", "curr_initialions", "curr_colos", "curr_infmaps", "curr_selecterences", "curr_columns", "curr_hosterences", "curr_outputls", "curr_outputes", "curr_logls", "curr_infs", "curr_inputb", "curr_execs", "curr_contexts", "curr_infuments", "curr_inferences", "curr_execions", "curr_outputs", "curr_logs", "curr_pullerences", "curr_inputed", "curr_methodes", "curr_outputions", "curr_outputd", "curr_initiales", "curr_selected", "curr_selects", "curr_pulls", "curr_inputls", "curr_inputments", "curr_keepments", "curr_keeped", "curr_hosts", "curr_inputd", "curr_columnb", "curr_contextuments", "curr_outputb", "curr_hostuments", "curr_selectments", "curr_outputmaps", "curr_outputuments", "curr_inputions", "curr_outputerences", "curr_inputsets", "curr_contextes", "curr_keeperences", "curr_configd", "curr_outputments", "curr_cols", "curr_inputuments", "curr_execes", "curr_inputerences", "curr_subjects", "curr_outputsets", "curr_inputmaps", "curr_outputed", "curr_hostmaps", "curr_initialerences", "curr_columnsets", "curr_configs", "curr_pulles", "curr_outputos", "curr_columnd", "curr_methoduments"], "filter": ["layer", "match", "call", "route", "name", "channel", "term", "flat", "context", "url", "header", "page", "field", "format", "query", "parent", "op", "search", "fil", "ac", "file", "attribute", "slice", "config", "control", "opt", "feature", "user", "block", "c", "force", "f", "child", "attr", "cache", "patch", "fat", "handler", "plugin", "sort", "transform", "Filter", "path", "part", "apply"], "tmp": ["media", "test", "tf", "src", "ctx", "offset", "ext", "term", "extra", "vt", "zip", "sb", "txt", "data", "binary", "template", "field", "sp", "tab", "buf", "output", "space", "rb", "proc", "dest", "fp", "stuff", "perm", "source", "storage", "temp", "config", "fake", "opt", "result", "pad", "beta", "iterator", "ref", "attr", "text", "cache", "copy", "mp", "handler", "obj", "meta", "prefix", "cmp", "conv", "img", "part", "diff", "input"], "index": ["match", "route", "Index", "level", "name", "append", "offset", "active", "key", "tail", "current", "image", "weight", "page", "type", "open", "id", "section", "found", "end", "num", "search", "loop", "i", "update", "pos", "output", "info", "slice", "pattern", "config", "x", "ind", "result", "example", "alpha", "connect", "order", "condition", "length", "len", "col", "cache", "token", "action", "sort", "path", "count", "si", "part", "inc", "diff", "input"]}}
{"project": "qemu", "commit_id": "6b9b8758c15f3bc2875dbd6e2d03c5362b8d6902", "target": 0, "func": "static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    /* This will stop vhost backend if appropriate. */\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n", "idx": 1981, "substitutes": {"qdev": [" qdevice", " qver", "qswitch", "kswitch", "Qver", " qDev", "qudevice", "kDev", "qdiv", "pdevice", "qdi", "quswitch", "qdm", "Qdevice", "Qdev", "vswitch", "kev", "vdevice", " qdm", "qudiv", "kdev", "kdm", "wver", "pdi", "QDev", "Qdm", "pev", "kdevice", "kdiv", "wev", "qDev", "pver", "qver", "qev", "wdev", "qudev", "wdevice", "Qdi", "kver", "pdev", " qdi", "qdevice", "vdiv"], "n": ["syn", "mn", "np", "name", "adj", "dn", "not", "conn", "nn", "rn", "new", "current", "d", "pn", "ln", "un", "k", "fn", "nu", "ne", "na", "num", "ng", "y", "g", "m", "none", "network", "gn", "nt", "yn", "z", "non", "ns", "N", "c", "p", "l", "w", "e", "nb", "f", "self", "cn", "u", "node", "en", "sn", "v", "o", "nm", "s", "b", "t", "an", "nor", "init", "net", "on", "in"], "vdev": ["vdd", "ppriv", "fmid", "cdev", "cdd", "fpriv", "kdd", "kmid", "pconf", "pdevice", "cdevice", "vpack", "wpack", "vconf", " vpack", "kpack", "kdev", " vdd", "fdd", " vpriv", "fdevice", "kdevice", "wdev", " vconf", "wdevice", " vdevice", "vmid", "fconf", "pdev", "vpriv", "fdev", "cmid", "vdevice", "wdd"], "i": ["yi", "name", "li", "gi", "counter", "a", "ni", "ii", "zi", "chi", "pi", "ui", "oi", "d", "I", "type", "di", "is", "id", "mi", "it", "iu", "k", "j", "y", "m", "eni", "ri", "ti", "ini", "index", "multi", "ai", "ie", "ip", "x", "c", "p", "hi", "phi", "l", "e", "f", "u", "o", "v", "ki", "b", "ix", "qi", "uri", "ci", "io", "mu", "fi", "si", "xi"], "q": ["Q", "qs", "charge", "queue", "cl", "d", "ck", "co", "pg", "sh", "k", "query", "ng", "client", "iq", "g", "m", "sync", "z", "dq", "ch", "x", "c", "p", "w", "e", "f", "sq", "u", "cmd", "v", "s", "qa", "qi", "t", "req", "ic", "view", "qt", "que", "qq", "gh", "qu"], "nc": ["NC", "cm", "fc", "dn", "ctx", "bn", "conn", "cc", "mc", "nn", "rn", "nec", "ct", "co", "bc", "nic", "ng", "cdn", "nu", "na", "enc", "nt", "ec", "dc", "ns", "c", "xc", "cv", "lc", "cn", "sn", "pc", "nm", "qa", "nw", "cf", "ci", "qt"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n", "idx": 1983, "substitutes": {"dest": ["route", "this", "name", "vp", "sup", "target", " Dest", "txt", "Dest", "ui", "class", "loc", "prop", "priv", "grad", "cdn", "seed", "later", "proc", "info", "comb", "err", "source", "coord", "cont", "feat", "config", "ident", "home", "opt", "dc", "st", "usr", "trans", "ie", "ptr", "wb", "uv", "obj", "wd", "node", "die", "nw", "sort", "transform", "path", "gen", "img", "iter", "gener", "huge", "uc", "gest", "desc", "dist", "done"], "src": ["sub", "rib", "rest", "txt", "go", "url", "rec", "home", "us", "sys", "sc", "uri", "pack", "sup", "target", "stat", "spec", "ource", "sb", "ui", "sth", "tmp", "fp", "ser", "resource", "ptr", "origin", "sr", "sn", "lib", "iv", "ssl", "loc", "bin", "gin", "proc", "cb", "cont", "slice", "st", "sel", "usr", "attr", "ctr", "stream", "lower", "obj", "sec", "gl", "inst", "sur", "req", "img", "uc", "inf", "href", "class", "rob", "cur", "comp", "rb", "source", "impl", "config", "ources", "uv", "uint", "view", "desc", "dist", "rc"], "size": ["unit", "cm", "SIZE", "external", "capacity", "ize", "sized", "security", "small", "loc", "n", "uni", "empty", "grow", "enc", "y", "i", "code", "sync", "source", "z", "address", "x", "c", "p", "shift", "e", "len", "south", "Size", "en", "sn", "range", "sec", "scale", "sum", "ix", "six", "mode", "shape", "si", "rc"], "u": ["ur", "ue", "eu", "ul", "U", "uit", "universal", "tu", "ui", "uci", "uni", "ru", "lu", "gnu", "iu", "un", "nu", " su", "g", "util", " units", "cu", "l", "c", "us", "du", "pu", "uv", "uint", "ku", "up", "v", "su", "uid", "uri", "uu", "uc", "ou"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_create_branch(BDRVSheepdogState *s)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid;\n\n    char *buf;\n\n\n\n    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n\n                      SD_INODE_SIZE, 0, s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    s->is_snapshot = false;\n\n    ret = 0;\n\n    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);\n\n\n\nout:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1990, "substitutes": {"s": ["sg", "same", "js", "qs", "n", "sl", "options", "g", "ses", "ls", "args", "us", "self", "f", "secondary", "sys", "fs", "spec", "ts", "sb", "aws", "y", "uns", "xs", "sv", "sets", "p", "e", "conf", "as", "v", "su", "site", "S", "t", "ks", "session", "os", "its", "hs", "in", "sym", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "i", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "service", "ops", "ms", "side", "params", "sync", "status", "l", "services", "sq", "stats", "states"], "ret": ["arg", "active", "success", "url", "alt", "sp", "code", "err", "Ret", "opt", "sat", "f", "en", "RET", "var", "af", "valid", "rt", "fs", "fi", "fun", "ext", "id", "html", "rets", "fit", "ben", "pass", "fail", "reply", "bd", "sr", "wa", "lit", "re", "val", "det", "att", "mt", "xt", "out", "cat", "ll", "back", "feat", "result", "fin", "len", "ref", "sur", "reg", "run", "res", "bad", "def", "bit", "conn", " Ret", "pet", "fn", "num", "rf", " RET", "rb", "nt", "ft", "rev", "pat", "bf", "try", "flag", "fat", "resp", "art", "let", "rc"], "fd": ["fc", "ff", "ld", "fun", "fs", "dd", "FD", "fed", "raf", "conn", "fw", "fa", "d", "xd", "dl", "lf", "ln", "buff", "id", "fl", "fn", "draft", "sf", "fp", "df", "cb", "ds", "pid", "md", "fe", "bf", "dc", "feed", "fin", "f", "wb", "bd", "hd", " fid", "cd", "fat", "resp", "handler", "fx", "wd", "fm", "fee", "fb", "cf", "vd", "nd", "fi", "wat", "gd", "db"], "vid": ["vision", "name", "version", " id", "host", "sid", "ver", " var", "di", "bid", "slot", "virt", "vert", "oid", "id", "cat", "kind", "vic", "pet", "vag", "did", "pos", "mid", "rev", "pid", "feat", "cod", "vv", "dc", "ip", "kid", "vs", "vec", "doc", " pid", "hd", "fx", " vi", "vc", "vis", "v", "ticket", "iv", "vi", "lv", "uid", "var", "vd", "addr", "val", "vr", "VID", "gd", "db"], "buf": ["ob", "ff", "fun", "buffer", "ctx", "src", "bag", "conn", "context", "raf", "queue", "data", "fl", "bc", "buff", "pb", "tmp", "cas", "rb", "dest", "fp", "cb", "temp", "pool", "feat", "bf", "feed", "pad", "c", "cv", "xff", "vec", "f", "wb", "bd", "len", "br", "ref", "cap", "cache", "fx", "cmd", "fb", "b", "cf", "wa", "uf", "port", "fi", "uc", "db", "rc", "mem"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "substitutes": {"dev": ["serial", "def", "dd", "gr", "mod", "device", "sd", "data", "d", "ver", "sh", "priv", "prof", "de", "grad", "dom", "comp", "Dev", "proc", "err", "dt", "md", "ch", "tr", "w", "private", "self", "attr", "conf", "br", "wd", "rad", "dem", "ev", "iv", "od", "inst", "req", "pro", "debug", "gd"], "prop": ["property", "name", "ctx", "def", "device", "Prop", "data", "prot", "r", "type", "priv", "pb", "op", "tmp", "pos", "proc", "info", "properties", "pointer", "p", "phy", "pr", "pred", "f", "ref", "attr", "obj", "pro", "lit", "val", "root", "pt", "part"], "str": ["test", "arg", "name", "ext", "Str", "spec", "rs", "expr", "data", "r", "strings", "sp", "sl", "cur", "arr", "enc", "hr", "stri", "code", "fr", "err", "cr", "tr", "st", "pr", "br", "text", "ctr", "attr", "obj", "sec", "sr", "s", "val", "pt", "STR"], "ptr": ["dr", "fd", "src", "offset", "inter", "prot", "tty", "r", "loc", "sp", "buf", "py", "pos", "spr", "proc", "fp", "nt", "fr", "err", "tr", "pointer", "func", "st", "pad", "p", "pr", "Ptr", "len", "length", "ref", "br", "t", "inst", "addr", "rt", "val", "pt"], "fmt": ["cnt", "cmt", "Fformat", "ftt", "FMT", "hmt", "cfformat", "fxmt", "Fmd", " fformat", "Fnt", " fmd", "cfmt", "hpr", "fxpr", "fnt", "Fpr", "fmd", "fMT", "Fmt", "cfprintf", "Ftt", "cfMT", "cMT", "hMT", "fpr", "fxtt", "Fprintf", " fMT", "fformat", "cmd", "fxMT", " fnt", "htt"]}}
{"project": "FFmpeg", "commit_id": "2f76157eb05bf63725f96167feda6b2e07501c7e", "target": 1, "func": "av_cold int swri_rematrix_init(SwrContext *s){\n\n    int i, j;\n\n    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);\n\n    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    s->mix_any_f = NULL;\n\n\n\n    if (!s->rematrix_custom) {\n\n        int r = auto_matrix(s);\n\n        if (r)\n\n            return r;\n\n    }\n\n    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++) {\n\n            double rem = 0;\n\n\n\n            for (j = 0; j < nb_in; j++) {\n\n                double target = s->matrix[i][j] * 32768 + rem;\n\n                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);\n\n                rem += target - ((int*)s->native_matrix)[i * nb_in + j];\n\n            }\n\n        }\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n\n        s->native_one    = av_mallocz(sizeof(float));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((float*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(double));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((double*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        // Only for dithering currently\n\n//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n//         for (i = 0; i < nb_out; i++)\n\n//             for (j = 0; j < nb_in; j++)\n\n//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    //FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n", "idx": 1998, "substitutes": {"s": ["sg", "js", "this", "groups", "sa", "qs", "n", "sites", "options", "g", "ses", "ls", "sf", "args", "er", "storage", "vs", "self", "us", "f", "sys", "u", "ubs", "an", "se", "fs", "spec", "ts", "sb", "aws", "uns", "xs", "sv", "request", "sets", "p", "e", "conf", "sports", "less", "su", "serv", "S", "os", "session", "ks", "t", "site", "bs", "its", "hs", "in", "sym", "input", "ssl", "cs", "ctx", "ss", "rs", "a", "new", "r", "is", "ins", "ions", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "rates", "es", "south", "o", "si", "server", "service", "src", "http", "ops", "strings", "d", "ms", "params", "sync", "l", "services", "w", "features", "sq", "stats", "b", "states"], "i": ["yi", "li", "gi", "ni", "ii", "zi", "ji", "ui", "pi", "r", "d", "n", "I", "di", "is", "id", "mi", "im", "iu", "it", "y", "ri", "m", "eni", "info", "ini", "index", "z", "ai", "ie", "x", "ind", "ip", "p", "l", "bi", "c", "e", "f", "u", "ori", "o", "v", "ki", "b", "qi", "vi", "ik", "ix", "uri", "ci", "io", "fi", "si", "in", "xi"], "j": ["js", "li", "q", "jl", "ii", "ji", "jit", "r", "out", "d", "n", "jj", "x", "J", "oj", "jen", "it", "k", "aj", "ij", "uj", "y", "pos", "m", "jo", "kj", "bj", "z", "index", "ch", "ie", "h", "l", "ind", "p", "pr", "jc", "w", "e", "f", "u", "jp", "el", "jet", "obj", "dj", "note", "o", "v", "b", "qi", "t", "ja"]}}
{"project": "qemu", "commit_id": "1a0e4c8b02ea510508970c333ee610a90b921cbb", "target": 1, "func": "void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n", "idx": 2009, "substitutes": {"ipl_cpu": ["ipl_cp", "pl_pu", "pl_cpu", "impl_pu", "ipl_core", "ipl___cp", "pl_core", "impl_gpu", "ipl_fork", "impl_fork", "ipl_pu", "iplacpu", "ipl_current", "impl_cp", "ipl00core", "ipl___cpu", "ipl__fork", "iplaccpu", "ipl___gpu", "iplaccore", "ipl_gpu", "ipl00pu", "ipl00current", "ipl__cp", "impl_cpu", "ipl00cpu", "iplacgpu", "ipl___fork", "impl_core", "ipl__cpu", "ipl__gpu", "pl_current"]}}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        /* This is a P-frame. */\n\n        ctx->frame->key_frame = 0;\n\n        ctx->frame->pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n", "idx": 2010, "substitutes": {"ctx": ["cm", "cms", "cam", "cs", "kb", "hw", "conn", "context", "anc", "cc", "gc", "cpp", "fw", "hub", "Context", "loc", "ck", "bc", "voc", "cas", "mac", "tx", "cb", "kw", "utils", "config", "pkg", "cu", "c", "cv", "xc", "lc", "cn", "sc", "ctrl", "wcs", "conf", "ca", "cmd", "kk", "pc", "cca", "qa", "cp", "cmp", "cf", "conv", "ci", "cfg", "sci"], "gb": ["rg", "cli", "gpu", "gio", "gram", "kb", "ga", "sb", "gc", "bm", "hub", "gru", "gy", "eb", "km", "gh", "mb", "gnu", "bc", "ge", "gz", "GB", "py", "gin", "g", "gg", "rb", "gm", "cgi", "cb", "cod", "gam", "gs", "bf", "hm", "gu", "nb", "dm", "git", "gt", "bg", "bb", "pc", "cca", "b", "usb", "gal", "cfg", "gp", "gd", "db"], "dst": [" dsta", "sdost", "dsc", "ndsta", "dST", "psc", "psta", "sdsc", "Dost", "ndST", "sdst", "pST", " dsc", "pst", "ndsc", "Dsc", "dsta", "sdST", "ndst", " dST", " dost", "Dst", "dost", "DST"], "stride": ["strided", "divIDE", "bride", "strides", "STRided", "arrIDE", "brides", "brided", "striade", "strider", "brider", "striider", "striides", "STRider", "arrade", "divider", "arrider", "STRide", "strade", "divade", "STRides", "striIDE", "strIDE", "arride", "divide", "striided", "striide"], "block": ["unit", "flow", "group", "base", "lock", "row", "name", "buffer", "time", "def", "board", "byte", "image", "loc", "clock", "type", "position", "id", "chain", "section", "bin", "frame", "buf", "num", "off", "batch", "bl", "pos", "label", "none", "code", "box", "tx", "cb", "number", "slice", "config", "word", "ip", "work", "length", "ref", "copy", "cache", "object", "obj", "range", "node", "comment", "bb", "Block", "blocks", "point", "b", "plugin", "error", "clean", "line", "view", "limit", "shape", "part", "map", "pack"], "i": ["yi", "li", "gi", "abi", "a", "ii", "ji", "isin", "jit", "ui", "pi", "oi", "I", "di", "n", "id", "mi", "it", "k", "iu", "j", "y", "m", "info", "ti", "multi", "index", "z", "ai", "ie", "x", "l", "c", "p", "ind", "ip", "bi", "e", "f", "hi", "u", "o", "v", "s", "b", "ix", "qi", "uri", "ci", "io", "mu", "si", "in", "xi"], "num_coeff": ["num_conefficient", "num_nceff", "num_cooff", "num_COeff", "num_collEFF", "num_ncitch", "num_ncoff", "num_ccoff", "num_coef", "num_colleffect", "num_conEFF", "num_coitch", "num_collef", "num_calleff", "num_coneff", "num_Coefficients", "num_crossefficients", "num_ncefficients", "num_ccitch", "num_Coefficient", "num_collaff", "num_ccefficients", "num_collefficient", "num_crossefficient", "num_coefficient", "num_cceff", "num_callaff", "num_COoff", "num_COef", "num_COefficient", "num_coeffect", "num_conaff", "num_Coef", "num_Coeff", "num_crosseffect", "num_COitch", "num_callEFF", "num_coefficients", "num_coaff", "num_callefficient", "num_crosseff", "num_COefficients", "num_collefficients", "num_colleff", "num_coEFF"]}}
{"project": "FFmpeg", "commit_id": "604c9b1196c70d79bbbc1f23e75f6a8253a74da3", "target": 1, "func": "void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    avio_close(rtpctx->pb);\n\n                }\n\n                avformat_free_context(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            ffurl_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}\n", "idx": 2027, "substitutes": {"s": ["sg", "server", "js", "service", "cs", "ctx", "http", "ss", "spec", "sa", "sb", "r", "sl", "sk", "bis", "g", "ses", "sf", "sv", "storage", "ds", "sit", "st", "ps", "gs", "ns", "c", "p", "services", "w", "self", "sed", "f", "e", "sys", "sq", "u", "south", "o", "sn", "v", "su", "b", "t", "os", "session", "S", "support", "fs", "si", "ssl"], "send_packets": ["send_Packers", "send_packet", "send_framets", "send_packsets", "send_namespaces", "send_nameset", "send_framers", "send_Packpaces", "send_packETS", "send_namesETS", "send_framet", "send_packset", "send_PackETS", "send_namesets", "send_packsers", "send_packsETS", "send_packers", "send_Packet", "send_framETS", "send_packspaces", "send_Packets", "send_packpaces"], "rt": ["rot", "dr", "apt", "ld", "mt", "rs", "ant", "vt", "txt", "rn", "tri", "ht", "r", "rr", "rob", "ct", "sett", "rf", "adr", "rb", "kt", "nt", "ft", "dt", "tr", "mot", "st", "NT", "RT", "pr", "rl", "hd", "attr", "gt", "yt", "art", "bt", "rat", "tt", "rd", "vc", "ird", "rss", "rx", "t", "irt", "vd", "vr", "qt", "pt", "rh", "rect", "ot", "rc", "wx"], "i": ["yi", "ami", "li", "gi", "ni", "ii", "zi", "chi", "pi", "ui", "oi", "r", "d", "I", "di", "n", "id", "mi", "it", "iu", "k", "j", "y", "ri", "eni", "m", "ti", "multi", "index", "ini", "ai", "ie", "x", "l", "hi", "p", "ip", "bi", "c", "phi", "ind", "f", "u", "ori", "o", "v", "qi", "b", "t", "ci", "fi", "si", "xi"], "rtsp_st": ["rtsv_inst", "rtsp6inst", "rtspikst", "rtsv_ste", "rtsf_ste", "rtsp_ST", "rtsvp_start", "rtspe_stim", "rtsf_state", "rtsp_stage", "rtsp0stall", "rtspeJsts", "rtsp_step", "rtsp_ct", "rtsf_stack", "rtsp_sc", "rtscp_std", "rtsf_str", "rtsp6sr", "rtscp_st", "rtsvp5start", "rtspikct", "rtsp_inst", "rtsp_sr", "rtsvp_ST", "rtsp0st", "rtsf_inst", "rtspJct", "rtsf_client", "rtsp_state", "rtsp_St", "rtspJstim", "rtsp_ust", "rtsf_stat", "rtsp6st", "rtsvp5ld", "rtspJsts", "rtsp_ste", "rtsp_cl", "rtsvp_ld", "rtsp_std", "rtspe_st", "rtsp5sc", "rtsp_sts", "rtsp_stall", "rtsf_St", "rtsvp5st", "rtsp0sr", "rtsvp_st", "rtsl_inst", "rtspeJst", "rtscp_step", "rtscp_cl", "rtsl_ust", "rtsp0inst", "rtsp6stall", "rtspeJstim", "rtsl_sta", "rtspJst", "rtsvp_sts", "rtspeJct", "rtsf_st", "rtsvp5sc", "rtsl_st", "rtsp_stim", "rtsp_client", "rtsv_stage", "rtscp_str", "rtscp_sta", "rtsp5st", "rtsp_ld", "rtsp5ld", "rtsp5start", "rtsp_start", "rtsp_stack", "rtsl_sr", "rtsl_stall", "rtsp_sta", "rtspiksts", "rtspikstim", "rtspe_ct", "rtscp_stack", "rtsvp_sc", "rtspe_sts", "rtsv_st", "rtsp_str", "rtsp_stat"], "rtpctx": ["rrpcoll", "rrpcas", "rotpaconf", "rtploc", "rtvcb", "rtlpcb", "rdpcontext", "rtpcoll", "rotpacontext", "rotpecontext", "rtprecoll", "rtpconf", "rtcctx", "rotpconf", "rtapcb", "rtpsync", "rtpactx", "rdpcctx", "ntpconn", "rtccmp", "ntpsync", "rtpercmp", "rotpcmp", "ntpcmp", "rtpqa", "rtcqa", "rrpctx", "rtvconn", "rotpaloc", "rtpcmp", "rtcconf", "rotpeqa", "rrprectx", "rrprecmp", "rtprecmp", "rtcploc", "rotpactx", "rdpccli", "rtpcconn", "ntpcsync", "rtcloc", "ntpcconn", "rotpecmp", "rtprecas", "rdpccontext", "ntpccb", "rtpcsync", "rdpctx", "rtpcctx", "rotpectx", "rtcpcmp", "rtpecmp", "rtpercb", "ntpccmp", "rtpointcas", "rtcpcb", "rtpcb", "rtpcontext", "rtpcqa", "rtpccontext", "rtpointcoll", "rtperctx", "rtpccoll", "rdpcb", "rotpqa", "rtpectx", "rtcpcontext", "rotpctx", "rtapcms", "rtapconn", "rtpointctx", "rrprecas", "ntpcms", "rtapctx", "rtpcli", "rdpcli", "rtcpctx", "ntpccms", "rtpccas", "rrpcmp", "rtccontext", "rotpcontext", "rrprecoll", "rtpaconf", "rotploc", "rtcpsync", "rtvctx", "rtpointcmp", "rdpccb", "rtpcas", "rtpconn", "rtlpcontext", "rtpcms", "rtlpctx", "rtcpcli", "rtpccb", "rtpecontext", "rtpaloc", "rtprectx", "ntpcb", "ntpcctx", "rtpccms", "rtcpconf", "rtpeqa", "ntpctx", "rtpccmp", "rtvcms", "rtpacontext", "rtlpcli", "rtpccli", "rtpersync"], "ptr": ["te", "fd", "src", "buffer", "ctx", "offset", "inter", "rw", "wr", "loc", "tag", "type", "sp", "buff", "sh", "pb", "buf", "arr", "pair", "tmp", "adr", "pos", "rep", "code", "fp", "plug", "fr", "tr", "pointer", "address", "pad", "p", "Ptr", "pr", "length", "ref", "br", "attr", "cap", "mp", "pc", "inst", "addr", "vr", "pt", "pack", "port"]}}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n", "idx": 2047, "substitutes": {"s": ["sg", "js", "qs", "n", "sp", "g", "ses", "ls", "vs", "self", "us", "f", "sys", "u", "se", "fs", "parts", "spec", "ts", "sb", "ips", "aws", "y", "xs", "sv", "sets", "e", "conf", "as", "v", "su", "site", "S", "t", "ks", "os", "session", "bs", "its", "sym", "ssl", "cs", "ss", "rs", "new", "r", "is", "ins", "i", "m", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "service", "ops", "d", "ms", "params", "sync", "l", "services", "w", "sq", "b", "states"], "p": ["np", "vp", "q", "lp", "pe", "data", "pi", "r", "d", "press", "n", "ap", "sp", "cop", "k", "pb", "op", "api", "pre", "i", "j", "py", "tp", "g", "m", "proc", "y", "fp", "P", "ep", "parse", "ps", "post", "pa", "ip", "c", "l", "h", "e", "per", "f", "app", "cache", "u", "jp", "mp", "php", "up", "pm", "o", "pc", "bp", "v", "cp", "b", "t", "ic", "pro", "wp", "gp", "pp"], "request": ["cost", "call", "version", "buffer", "time", "key", "claim", "command", "charge", "queue", "access", "data", "url", "complete", "header", "report", "requ", "type", "use", "open", "callback", "id", "query", "parent", "frame", "pair", "initial", "rf", "hello", "create", "event", "config", "address", "begin", "result", "work", "setup", "resource", "condition", "du", "repeat", "child", "message", "demand", "pull", "Request", "fee", "req", "rx", "session", "require", "response", "input"], "value": ["flow", "ue", "VALUE", "media", "server", "name", "version", "buffer", "key", "Value", "data", "complete", "show", "dollar", "sample", "end", "pair", "hello", "update", "max", "output", "info", "password", "number", "description", "function", "result", "change", "values", "resource", "set", "message", "money", "min", "range", "v", "fee", "rule", "element", "wa", "view", "val", "response", "input", "option"], "index": ["match", "include", "Index", "call", "append", "offset", "find", "key", "context", "data", "image", "weight", "position", "page", "type", "open", "id", "end", "search", "i", "update", "pos", "none", "slice", "pointer", "address", "x", "ind", "connect", "condition", "len", "length", "size", "point", "action", "element", "inc", "start", "diff", "in", "option"]}}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = FFALIGN(frame->height, 32);\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 2049, "substitutes": {"frame": ["figure", "video", "code", "file", "event", "framework", "feed", "iframe", "self", "force", "f", "plot", "object", "play", "ze", "zone", "board", "flow", "unit", "ise", "cycle", "Frame", "sequence", "host", "image", "position", "vert", "html", "parent", "dom", "model", "update", "component", "frames", "parse", "fe", "state", "layout", "e", "die", "flower", "scale", "load", "player", "family", "layer", "base", "scene", "version", "build", "fram", "data", "boot", "slice", "document", "live", "fake", "function", "setup", "design", "ide", "date", "fx", "node", "module", "cf", "rule", "series", "buffer", "def", "window", "header", "co", "show", "coll", "df", "fr", "style", "bug", "feature", "word", "block", "draw", "range", "point", "fb", "plane", "element", "hide", "full", "line", "motion", "view", "part", "table", "game"], "align": ["offset", "ext", "adjust", "binary", "amin", "alt", "ignment", "margin", "format", "ign", "arr", "style", "replace", "pad", "work", "x", "aligned", "aff", "balance", "len", "repeat", "length", "angle", "join", "aug", "padding", "border", "al", "addr", " alignment", "val", "lead", "diff", "in"], "desc": ["layer", "sub", "fd", "src", "ctx", "ext", "def", "esc", "spec", "conn", "dim", "txt", "loc", "d", "rec", "bc", "dict", "der", "env", "de", "enc", "des", "proc", "code", "info", "dep", "cb", "df", "config", "func", "asc", "description", "cod", "dc", "ec", "or", "doc", "diff", "lc", "design", "Desc", "ref", "col", "sc", "decl", "ca", "summary", "disc", "comment", "sec", "meta", "dir", "dist"], "ret": ["arg", "success", "alt", "rep", "code", "err", "replace", "Ret", "opt", "reset", "f", "en", "RET", "rt", "fun", "format", "rets", "fit", "end", "arr", "fail", "rc", "sr", "lit", "re", "val", "det", "nat", "att", "mt", "data", "xt", "out", "cat", "wrap", "back", "result", "fin", "ut", "len", "ref", "value", "obj", "error", "reg", "run", "res", "bad", "mem", "match", "test", "def", "bit", "cur", "it", "rb", "entry", "nt", "ft", "aud", "bf", "pret", "flag", "art", "std", "al"], "i": ["cli", "yi", "li", "gi", "a", "ni", "ii", "ui", "pi", "oi", "d", "I", "n", "di", "is", "id", "mi", "it", "iu", "k", "api", "j", "y", "g", "ri", "m", "eni", "anti", "info", "ti", "slice", "ini", "index", "multi", "z", "hi", "ai", "ie", "ip", "h", "x", "p", "l", "bi", "c", "e", "phi", "f", "lc", "u", "ori", "ki", "v", "o", "s", "qi", "b", "ix", "t", "uri", "ci", "io", "fi", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "1eabfce6d53cb02066dbb0ac8471f8593ff24a24", "target": 0, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (has_msr_async_pf_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (has_msr_pv_eoi_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (has_msr_kvm_steal_time) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (has_msr_hv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (has_msr_hv_tsc) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_mtrr) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SVERSION:\n\n            env->msr_hv_synic_version = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2053, "substitutes": {"cpu": ["ilo", "cli", "roc", "queue", "lb", "clock", "nc", "px", "CPU", "CP", "cu", "css", "linux", "cp", "fi", "login", "consumer", "prem", "mc", "nic", "ubuntu", "hu", "mac", "pkg", "lc", "core", "hp", "fc", "np", "uno", "ctx", "cpp", "chrom", "computer", "ck", "GPU", "boot", "instance", "kernel", "proxy", "proc", "pool", "c", "pu", "loader", "cache", "machine", "chip", "processor", "node", "uca", "net", "performance", "uc", "vm", "gpu", "intel", "uci", "platform", "android", "comp", "auc", "sync", "config", "bench", "cn", "exec", "pc", "cmp", " CPU", "product", "cfg", "que", "console", "rc"], "env": ["eu", "stage", "oa", "cli", "ext", "context", "visor", "environment", "global", "shell", "profile", "ea", "end", "enc", "ef", "eni", "pipe", "estate", "style", "err", "config", "ec", "exc", "Environment", "cv", "fg", "age", "e", "esp", "cap", "core", "conf", "skin", "gui", "viron", "en", "ev", "path", "cfg", "net", "agent", "console", "export", "desc", "energy"], "msrs": ["msRS", "mmRs", "Msrs", "mmRS", "msRs", "MsRs", "Msrd", "mmrs", "MsRS", " msRS", " msRs", "msrd", "mmrd", " msrd"], "ret": [" e", " len", " code", "res", " Ret", " pri", " reg", "k", " flag", "num", " RET", " resp", " result", "code", "nt", "Ret", " success", " res", "len", "f", " mem", " b", "val", " rc", "rc", "mem"], "i": ["li", "abi", "ni", "ii", "pi", "ui", "I", "n", "type", "uni", "id", "it", "k", "info", "ti", "slice", "ini", "index", "c", "phi", "p", "e", "f", "b", "ci", "init", "si"], "mtrr_top_bits": ["mtrr_top_bytes", "mtrr_master_rows", "mtrr_master_bits", "mtrr_top_rows", "mtrr_top_count", "mtrr_master_count", "mtrr_master_bytes"]}}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n", "idx": 2063, "substitutes": {"mr": ["ur", "dr", "mn", "rg", "cm", "mir", "mt", "gr", "wk", "mc", "mx", "bm", "wr", "ml", "km", "rr", "MR", "r", "yr", "mer", "mm", "lr", "kr", "adr", "m", "hr", "gro", "nr", "mor", "er", "fr", "ir", "mk", "md", "LR", "usr", "gor", "pr", "igr", "br", "wm", "rm", "pm", "sr", "pc", "RR", "shr", "rt", "vr", "rh", "Mr", "rer"]}}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n\n{\n\n    int i;\n\n\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n\n    if (f->slice_count <= 0) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < f->slice_count; i++) {\n\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        int sx          = i % f->num_h_slices;\n\n        int sy          = i / f->num_h_slices;\n\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n\n        f->slice_context[i] = fs;\n\n        memcpy(fs, f, sizeof(*fs));\n\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n\n\n        fs->slice_width  = sxe - sxs;\n\n        fs->slice_height = sye - sys;\n\n        fs->slice_x      = sxs;\n\n        fs->slice_y      = sys;\n\n\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n\n                                      sizeof(*fs->sample_buffer));\n\n        if (!fs->sample_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2083, "substitutes": {"f": ["fo", "fc", "flow", "feature", "files", "this", "tf", "fd", "fun", "fen", "def", "flat", "raf", "fac", "fw", "form", "fa", "d", "lf", "fl", "field", "k", "rf", "F", "g", "j", "m", "fab", "sf", "fp", "info", "df", "fr", "file", "framework", "bf", "feed", "fe", "function", "x", "l", "c", "p", "fi", "h", "w", "e", "self", "ref", "conf", "u", "fx", "of", "fm", "v", "s", "fb", "b", "t", "cf", "uf", "af", "full", "diff", "inf", "family"], "i": ["ami", "li", "gi", "ni", "ii", "zi", "area", "ui", "pi", "mini", "d", "I", "di", "n", "id", "mi", "im", "iu", "it", "k", "ij", "api", "j", "y", "eni", "m", "inner", "ri", "info", "ti", "ini", "index", "z", "multi", "ai", "ie", "x", "l", "ip", "p", "hi", "bi", "c", "e", "ind", "phi", "u", "o", "v", "s", "ki", "qi", "ix", "b", "uri", "ci", "io", "fi", "start", "si", "xi"], "fs": ["fc", "files", "fd", "tf", "cs", "Fs", "FS", "qs", "rs", "ts", "raf", "flat", "vals", "fw", "ips", "flags", "ums", "cells", "reads", "fits", "lf", "ms", "fn", "rets", "fps", "frames", "ls", "fp", "sf", "args", "df", "fr", "file", "outs", "flows", "ds", "utils", "json", "ps", "bf", "feed", "fe", "ns", "fi", "irs", "gs", "vs", "vers", "lines", "ports", "features", "pages", "rows", "posts", "fat", "fx", "uses", "s", "linux", "fields", "fb", "ves", "cf", "ks", "times", "uf", "full", "bs", "os", "ows", "fer", "obs"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 2084, "substitutes": {"opaque": ["opacity", " opque", "patile", "pac", "operae", "iopca", " opatile", "operca", "opca", "opac", " opac", "operaque", "iopaque", "operatile", " oprobe", " opacity", "oprobe", "hopaque", "pae", "operac", "iopacity", " opae", "operacity", "hopacity", "operrobe", " opca", "hoprobe", "opatile", "opae", "paque", "opque", "hopque", "operque"], "addr": ["oa", "dr", "layer", "base", "delay", "server", "src", "offset", "target", "a", "array", "device", "alias", "ock", "host", "sid", "data", "r", "ad", "align", "alt", "slot", "id", "ord", "ada", "off", "adr", "pos", "mac", "eni", "code", "entry", "index", "pointer", "address", "ack", "pad", "x", "p", "afi", "start", "ptr", "e", "len", "ref", "Address", "cmd", "node", "padding", "point", "prefix", "asm", "seq", "amd", "cmp", "error", "socket", "mode", "part", "ace", "rc", "port"], "value": ["VALUE", "key", "current", "video", "trial", "password", "address", "set", "child", "message", "reference", "object", "comment", "fee", "valid", "all", "port", "name", "image", "type", "format", "parent", "end", "buf", "pair", "python", "p", "resource", "length", "v", "scale", "wave", "val", "one", "response", "serial", "media", "version", "offset", "Value", "byte", "data", "complete", "member", "hello", "paid", "m", "native", "function", "content", "result", "h", "values", "node", "reg", "volume", "slave", "timeout", "cost", "match", "null", "server", "service", "total", "buffer", "gi", "array", "memory", "d", "num", "initial", "vector", "variable", "item", "entry", "attribute", "number", "expression", "w", "money", "amount", "padding", "price"], "size": ["SIZE", "name", "capacity", "offset", "ize", "sized", "data", "small", "align", "empty", " address", "from", "code", "sync", "number", "address", "or", "shift", "e", "length", "len", " length", "Size", "sec", "en", "padding", "fee", "scale", "bytes", "val", "count", "timeout"], "s": ["sg", "js", "service", "this", "cs", "ss", "rs", "a", "spec", "ts", "sb", "new", "r", "d", "is", "ins", "scope", "g", "side", "params", "m", "ses", "ls", "args", "sf", "sync", "uns", "settings", "ds", "sets", "ps", "gs", "address", "native", "ns", "h", "c", "p", "sie", "services", "w", "e", "f", "es", "self", "sys", "sq", "us", "conf", "secondary", "sec", "o", "v", "stats", "b", "su", "S", "t", "session", "os", "socket", "site", "hs", "states", "fs", "si", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_mono(APEContext *ctx, int count)\n\n{\n\n    APEPredictor *p = &ctx->predictor;\n\n    int32_t *decoded0 = ctx->decoded[0];\n\n    int32_t predictionA, currentA, A, sign;\n\n\n\n    currentA = p->lastA[0];\n\n\n\n    while (count--) {\n\n        A = *decoded0;\n\n\n\n        p->buf[YDELAYA] = currentA;\n\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n\n\n        currentA = A + (predictionA >> 10);\n\n\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n\n\n        sign = APESIGN(A);\n\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n\n\n        p->buf++;\n\n\n\n        /* Have we filled the history buffer? */\n\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n\n            memmove(p->historybuffer, p->buf,\n\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n\n            p->buf = p->historybuffer;\n\n        }\n\n\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n\n        *(decoded0++) = p->filterA[0];\n\n    }\n\n\n\n    p->lastA[0] = currentA;\n\n}\n", "idx": 2093, "substitutes": {"ctx": ["cm", "parser", "np", "cli", "cam", "cs", "kb", "conn", "context", "cc", "anc", "mc", "cpp", "Context", "loc", "nc", "bc", "tc", "pb", "client", "cas", "tp", "fp", "tx", "cb", "utils", "config", "pkg", "c", "cv", "xc", "cn", "ca", "ctrl", "sc", "exec", "hp", "core", "cmd", "pc", "cca", "connection", "qa", "cp", "cf", "conv", "ci", "wp", "sci", "input", "rc"], "count": ["call", "base", "test", "group", "counter", "key", "context", "cc", "process", "type", "weight", "id", "parent", "num", "loop", "batch", "max", "comp", "code", "coll", "number", "cond", "C", "ind", "c", "force", "len", "length", "child", "col", "cache", "amount", "seq", "b", "depth", "Count", "val", "part", "list"], "p": ["this", "after", "q", "process", "get", "current", "n", "sp", "pb", "client", "j", "g", "er", "progress", "self", "private", "f", "prev", "u", "jp", "mp", "s", "at", "cp", "wp", "pp", "parser", "local", "pd", "pi", "ap", "k", "parent", "api", "y", "fp", "P", "python", "parse", "post", "pa", "pkg", "e", "per", "hp", "pm", "v", "plugin", "t", "gp", "np", "vp", "lp", "a", "data", "r", "press", "op", "py", "pre", "i", "m", "proc", "project", "ps", "h", "c", "app", "cache", "o", "bp", "http", "d", "pg", "cop", "it", "comp", "tp", "ip", "l", "w", "exec", "up", "pc", "point", "b", "full", "part"], "decoded0": [" decoded1", "decided4", "decoded1", " decided1", "decaned1", "decoded192", "decided1", "decrypted1", "decrypted0", "deccoded1", " decoded4", "decaned4", "decached4", " decoded192", "decided0", "decided192", " decided0", " decided192", "decrypted4", "deccoded4", "deccoded0", "decached192", "decoded4", " decided4", "deccoded192", "decached1", "decached0", "decaned0"], "predictionA": ["predictedY", "preditionC", "predictiona", " predictedA", "PredictedA", "predictedC", "PredictedB", "predictionB", " predictedN", "predisonN", "predisonA", "predictionsN", "predictionsY", "PredictionC", "Predictiona", "PredictionN", "predicationC", "predicationN", " predictionY", " predictedY", "predictedB", "PredictionB", "Predicteda", "predictedA", "predicationA", "predolutionA", "predictionsa", "predictedN", "predictionY", "predisonB", "predictionsB", "predolutionB", "preditionN", "PredictedN", "predisonY", "preditionA", "predictionN", " predictionN", " predictedB", "predicteda", "predictionC", "predictionsA", "PredictedC", "predolutiona", " predictionB", "PredictionA"], "currentA": ["CurrentY", "contentN", " currentY", "reportedN", "reportedY", "currentP", "reportedAverage", " currentD", " currentAn", "currentB", " currentP", "reportedB", " currentArray", "CurrentB", "CurrentA", "reportedP", "CurrentD", "CurrentP", "presentA", "currentD", "CurrentAverage", "currentY", "reportedD", "presentP", "presentAn", "contentA", "reportedAPI", "currentN", "contentAPI", "currentAPI", " currentAverage", "currentArray", "contentArray", " currentAPI", "reportedA", "currentAn", "currentAverage", " currentB", "reportedAn", "presentN", "reportedArray", " currentN"], "A": ["H", "Q", "HA", "Am", "G", "AA", "a", "sa", "array", "M", "U", "ASC", "CA", "Alpha", "B", "API", "I", "AC", "aa", "PA", "AR", "K", "AF", "W", "AP", "aw", "AV", "AW", "P", "X", "Sign", "EA", "C", "au", "ai", "NA", "N", "alpha", "L", "w", "AM", "V", "amp", "Adam", "T", "SA", "S", "Y", "LA", "am", "D", "mA"], "sign": ["match", " sig", "sub", "se", "check", "act", "ss", "key", "spec", "form", "ver", "type", "tick", "sh", "ign", " SIGN", "enc", "pass", "search", "max", "space", "scan", "lex", "Sign", "inc", "parse", "ident", "step", "x", "ind", "dash", "sw", "connect", "change", "SIGN", "ment", "set", "draw", "cap", "dig", "sq", "sc", "contract", "save", "fix", "min", "value", "sum", "vis", "pull", "scale", "action", "close", "mix", "IGN", "shape", "start", "plus", "keep", "pack"], "buf": ["nat", "ff", "src", "buffer", "append", "bh", "bag", "bn", "context", "queue", "header", "loc", "aux", "cat", "av", "bc", "buff", "cur", "hist", "bin", "prof", "num", "cas", "batch", "map", "auc", "lim", "rb", "code", "dest", "box", "comb", "cb", "hal", "feat", "config", "pool", "home", "pub", "raw", "begin", "pkg", "block", "cv", "vec", "doc", "wb", "cap", "cache", "br", "uv", "agg", "history", "bt", "la", "cmd", "alloc", "bg", "bu", "carry", "seq", "cf", "conv", "uf", "img", "uu", "fam", "uc", "rc", "port"]}}
{"project": "FFmpeg", "commit_id": "17ee7b5515cd1006a1f7ba4a9cced14f6526c1b0", "target": 0, "func": "static void print_report(AVFormatContext **output_files,\n\n                         AVOutputStream **ost_table, int nb_ostreams,\n\n                         int is_last_report)\n\n{\n\n    char buf[1024];\n\n    AVOutputStream *ost;\n\n    AVFormatContext *oc;\n\n    int64_t total_size;\n\n    AVCodecContext *enc;\n\n    int frame_number, vid, i;\n\n    double bitrate, ti1, pts;\n\n    static int64_t last_time = -1;\n\n    static int qp_histogram[52];\n\n\n\n    if (!is_last_report) {\n\n        int64_t cur_time;\n\n        /* display the report every 0.5 seconds */\n\n        cur_time = av_gettime();\n\n        if (last_time == -1) {\n\n            last_time = cur_time;\n\n            return;\n\n        }\n\n        if ((cur_time - last_time) < 500000)\n\n            return;\n\n        last_time = cur_time;\n\n    }\n\n\n\n\n\n    oc = output_files[0];\n\n\n\n    total_size = avio_size(oc->pb);\n\n    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too\n\n        total_size= avio_tell(oc->pb);\n\n\n\n    buf[0] = '\\0';\n\n    ti1 = 1e10;\n\n    vid = 0;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        float q= -1;\n\n        ost = ost_table[i];\n\n        enc = ost->st->codec;\n\n        if(!ost->st->stream_copy && enc->coded_frame)\n\n            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n\n        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"q=%2.1f \", q);\n\n        }\n\n        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            float t = (av_gettime()-timer_start) / 1000000.0;\n\n\n\n            frame_number = ost->frame_number;\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"frame=%5d fps=%3d q=%3.1f \",\n\n                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n\n            if(is_last_report)\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"L\");\n\n            if(qp_hist){\n\n                int j;\n\n                int qp= lrintf(q);\n\n                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))\n\n                    qp_histogram[qp]++;\n\n                for(j=0; j<32; j++)\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%X\", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n\n            }\n\n            if (enc->flags&CODEC_FLAG_PSNR){\n\n                int j;\n\n                double error, error_sum=0;\n\n                double scale, scale_sum=0;\n\n                char type[3]= {'Y','U','V'};\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"PSNR=\");\n\n                for(j=0; j<3; j++){\n\n                    if(is_last_report){\n\n                        error= enc->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0*frame_number;\n\n                    }else{\n\n                        error= enc->coded_frame->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0;\n\n                    }\n\n                    if(j) scale/=4;\n\n                    error_sum += error;\n\n                    scale_sum += scale;\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale));\n\n                }\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(error_sum/scale_sum));\n\n            }\n\n            vid = 1;\n\n        }\n\n        /* compute min output value */\n\n        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);\n\n        if ((pts < ti1) && (pts > 0))\n\n            ti1 = pts;\n\n    }\n\n    if (ti1 < 0.01)\n\n        ti1 = 0.01;\n\n\n\n    if (verbose || is_last_report) {\n\n        bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n\n\n\n        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n\n            \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\",\n\n            (double)total_size / 1024, ti1, bitrate);\n\n\n\n        if (nb_frames_dup || nb_frames_drop)\n\n          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\",\n\n                  nb_frames_dup, nb_frames_drop);\n\n\n\n        if (verbose >= 0)\n\n            fprintf(stderr, \"%s    \\r\", buf);\n\n\n\n        fflush(stderr);\n\n    }\n\n\n\n    if (is_last_report && verbose >= 0){\n\n        int64_t raw= audio_size + video_size + extra_size;\n\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\",\n\n                video_size/1024.0,\n\n                audio_size/1024.0,\n\n                extra_size/1024.0,\n\n                100.0*(total_size - raw)/raw\n\n        );\n\n    }\n\n}\n", "idx": 2110, "substitutes": {"output_files": ["output_bytes", "output_frames", "input_images", " output_frames", "input_bytes", "input_files", "output_images", "outputmatimages", "output_file", "outputmatfile", "input_file", " output_file", " output_images", "outputmatfiles", "outputmatbytes"], "ost_table": ["ostalltable", "ostsbuffer", "rss_buffer", "ost_system", "ostallbuffer", "ost_file", "ostsfile", "output_list", "rss_list", "ostalllist", "ost_buffer", "oststable", "rss_table", "ost_list", "ostallsystem", "output_table", "output_buffer", "rss_system", "output_file", "ostslist"], "nb_ostreams": ["nb_odaccountlets", "nb_streames", "nb_ostaccountes", "nb_oststreamers", "nb_ostroundlets", "nb_ststreames", "nb_odaccounts", "nb_ostloges", "nb_ostraws", "nb_streamd", "nb_ostrounds", "nb_ostreamlets", "nb_ststreams", "nb_odaccountsites", "nb_ostrawers", "nb_streams", "nb_ostecs", "nb_ostreames", "nb_ostlogs", "nb_oststreamd", "nb_ostaccounts", "nb_osteclets", "nb_odreams", "nb_ostreamd", "nb_odreamsites", "nb_odreamlets", "nb_ostlogd", "nb_ostroundsites", "nb_ststreamd", "nb_osteces", "nb_ostrawes", "nb_ostaccountlets", "nb_ostlogers", "nb_ostecsites", "nb_oststreams", "nb_oststreames", "nb_ststreamers", "nb_ostaccountsites", "nb_streamers", "nb_odaccountes", "nb_ostreamers", "nb_ostreamsites", "nb_odreames", "nb_ostroundes", "nb_ostrawd"], "is_last_report": ["is_last_info", "is_full_summary", "is_full_print", "is_this_run", "is_last_time", "is_next_write", "is_lastayprint", "is_lastalinfo", "is_lastalsummary", "is_lastmreport", "is_full_info", "is_lastalprint", "is_last_run", "is_last_print", "is_this_reported", "is_full_report", "is_lastmrun", "is_next_reported", "is_last__report", "is_lastayinfo", "is_last__run", "is_lastalreport", "is_lastaysummary", "is_last_summary", "is_next_report", "is_lastmsource", "is_last_source", "is_last_reported", "is_next_time", "is_lastmreported", "is_last_write", "is_last__source", "is_this_source", "is_lastayreport", "is_last__reported", "is_this_report"], "buf": ["grab", "Buff", "queue", "txt", "lb", "aux", "pb", "cv", "vec", "btn", "f", "seq", "uf", "af", "uu", "port", "bed", "bag", "raf", "bc", "buff", "tmp", "batch", "fab", "fp", "pkg", "bus", "bd", "text", "bu", "border", "ctx", "bh", "fw", "data", "ab", "loc", "prof", "bur", "proc", "cb", "pool", "feat", "pad", "usr", "h", "Buffer", "br", "cap", "cache", "front", "cmd", "bb", "ucc", "bytes", "img", "msg", "uc", "fd", "src", "buffer", "ph", "wav", "auc", "rb", "box", "config", "bf", "wb", "bg", "fb", "b", "font", "fam", " buffer", "rc"], "ost": ["ob", "ist", "orb", "ld", "src", "roc", "host", "oper", "ott", "annot", "oop", "osi", "obo", "rob", "loc", "ct", "osta", "rog", "voc", "oid", "sl", "ocol", "op", "ood", "iol", "adr", "nt", "om", "odi", "st", "post", "opt", "OC", "et", "oss", "ocr", "iot", "org", "soc", "oster", "obj", "OST", "o", "sta", "inst", "od", "os", "omp", "omm", "ast", "oh", "ot", "obs", "est"], "oc": ["ob", "orb", "oci", "http", "ogg", "roc", "osc", "cc", "oper", "og", "loc", "co", "rec", "voc", "cur", "oid", "ocl", "op", "ocol", "toc", "output", "ac", "oo", "cot", "ok", "nt", "om", "mot", "config", "ec", "oco", "OC", "c", "ocr", "org", "soc", "obj", "o", "pc", "iv", "od", "os", "oca", "uc", "ou", "obs"], "total_size": ["last_size", "total64time", "total64speed", "total_speed", " total_speed", "total67source", " total_storage", "last_number", "totallextime", "total_time", "total_number", "total67storage", "total_grade", "total64shape", " total_capacity", " total_time", "total67time", " total_source", "total67size", "total_capacity", "totallexspeed", "total64size", "last_time", "totallexshape", "total_source", " total_grade", "total_shape", " total_shape", "totallexsize", "total_storage"], "enc": ["ob", "fc", "emb", "ctx", "act", "ext", "roc", "ant", "conn", "anc", "ens", "nec", "equ", "loc", "ct", "nc", "rec", "voc", "cur", "sl", "env", "eng", "ent", "iq", "comp", "auc", "ac", "cot", "proc", "ENC", "code", "coll", "nt", "fr", "util", "ch", "cod", "ec", "orc", "sel", "ang", "c", "et", "Enc", "sys", "exec", "obj", "vc", "en", "sec", "ssl", "hl", "lib", "cel", "iv", "ev", "inst", "od", "ic", "ew", "img", "qt", "inc", "arch", "ot", "ou", "oder"], "frame_number": ["frame_reference", " frame_reference", "frame_no", "frame_object", " frame_no", "frame_position", " frame_object", "frameidno", "frame64length", "frame_size", "frame_source", "frameIdsource", " frame_notation", "frameIdobject", "frame_notation", "frameidnumber", " frame_size", "frameIdno", "frame_resolution", "frameidsource", " frame_resolution", " frame_position", "frame64size", " frame_length", "frame_length", "frame64no", "frame64number", "frameIdnumber", "frameidobject", " frame_source", " frame_len", "frame_len"], "vid": ["dr", "vision", "verb", "version", "vp", "act", "lan", "quad", "vt", "device", "liv", "host", "sid", "pi", "ver", "di", "nc", "vert", "kind", "id", "oid", "bid", "virt", "cat", "voc", "cdn", "duration", "seed", "year", "slice", "rev", "index", "pid", "aud", "feat", "vv", "cod", "live", "dc", "ip", "cv", "vs", "vec", "vc", "win", "v", "voice", "iv", "vi", "uid", "var", "uri", "vd", "ci", "volume", "vr", "pin", "VID", "gd", "vir", "port"], "i": ["oci", "yi", "ami", "li", "gi", "ni", "ii", "zi", "chi", "isin", "pi", "ui", "oi", "I", "di", "n", "udi", "id", "mi", "it", "iu", "y", "eni", "ri", "anti", "inner", "info", "ti", "ini", "index", "pid", "ani", "multi", "ai", "ie", "ip", "l", "c", "p", "phi", "adi", "e", "hi", "x", "u", "ori", "v", "vi", "qi", "uri", "ci", "io", "fi", "si", "xi"], "bitrate": ["bytewidth", "bitsrate", "byterate", "bitswidth", "bytespeed", "bitsspeed", "bitwidth", " bitwidth", "bitspeed", " bitspeed"], "ti1": ["ta2", "tu0", "tu1", "TI2", "ti0", "taone", "si1", "ta0", "TI0", "si0", "TI1", "tu2", "si2", "tione", "ta1", "sione", "ti2", "tuone"], "pts": ["hosti", "ntsets", "ctsets", "cts", "ptps", "pti", "nts", "ntps", "ptsets", "hostps", "cti", "hostsets", "hosts", "ctps", "nti"], "qp_histogram": ["qp_memograms", "qp2Histor", "qp_Histogram", "qp_highograms", "qp_Histograms", "qp2histbar", "qp2Histograms", "qp_highbar", "qp_histograms", "qp_histbar", "qp2histograms", "qp_Histbar", "qp_memogram", "qp2Histbar", "qp_Histor", "qp_highogram", "qp2Histogram", "qp_membar", "qp_histor", "qp2histogram", "qp2histor", "qp_highor", "qp_memor"], "cur_time": ["curltimes", "curJtimes", "recentltime", "last_time", "last_name", "cur_volume", "curltime", " last_depth", "recentltimes", " last_time", "cur_ime", "curJtime", "recent_name", "recent_delay", " cur_times", " last_times", "recent_times", "cur_delay", "recent_time", "curlname", "curldelay", "curJfile", "cur_weight", "curJname", " cur_volume", " cur_weight", " cur_id", "cur_id", "last_file", " cur_ime", "recentldelay", "cur_depth", "cur_file", "cur_times", "recentlname", "last_times", "cur_name"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_strong_loop_filter(uint8_t *src,\n\n                                                     const int step,\n\n                                                     const int stride,\n\n                                                     const int alpha,\n\n                                                     const int lims,\n\n                                                     const int dmode,\n\n                                                     const int chroma)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < 4; i++, src += stride){\n\n        int sflag, p0, q0, p1, q1;\n\n        int t = src[0*step] - src[-1*step];\n\n\n\n        if (!t)\n\n            continue;\n\n\n\n        sflag = (alpha * FFABS(t)) >> 7;\n\n        if (sflag > 1)\n\n            continue;\n\n\n\n        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +\n\n              26*src[ 0*step] + 25*src[ 1*step] +\n\n              rv40_dither_l[dmode + i]) >> 7;\n\n\n\n        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +\n\n              26*src[ 1*step] + 25*src[ 2*step] +\n\n              rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n\n        }\n\n\n\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n\n        }\n\n\n\n        src[-2*step] = p1;\n\n        src[-1*step] = p0;\n\n        src[ 0*step] = q0;\n\n        src[ 1*step] = q1;\n\n\n\n        if(!chroma){\n\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n\n        }\n\n    }\n\n}\n", "idx": 2115, "substitutes": {"src": ["reflect", "sub", "rest", "go", "upp", "url", "sites", "sl", "expl", "reach", "secure", "asc", "control", "ind", "shift", "cv", "connect", "btn", "scl", "sys", "sc", "u", "scripts", "upload", "aug", "hl", "obl", "start", "pack", "sup", "stat", "spec", "sb", "host", "filename", "ui", "bc", "iu", "gz", "gn", "sit", "length", "text", "integ", "agg", "sr", "lib", "iv", "transform", "sci", "rect", "input", "ssl", "build", "chrom", "loc", "use", "proc", "cb", "slice", "cont", "feat", "st", "sel", "usr", "c", "size", "attr", "stream", "sec", "rss", "gl", "inst", "sur", "supp", "conv", "req", "img", "low", "uc", "https", "stage", "http", "cur", "swing", "grad", "num", "seed", "comp", "rb", "dest", "sync", "source", "config", "scenes", "impl", "stack", "uv", "gb", "bg", "b", "cmp", "sort", "support", "view", "dist", "rc"], "step": ["route", "walk", "lock", "key", "dim", "ct", "weight", "trial", "stroke", "wait", "next", "move", "ste", "direction", "push", "index", "pointer", "progress", "x", "change", "shift", "set", "seq", "action", "sleep", "stop", "path", "start", "option", "flow", "group", "name", "split", "form", "type", "id", "frame", "gap", "pass", "batch", "dash", "length", "repeat", "patch", "amp", "scale", "session", "transform", "load", "input", "layer", "version", "trace", "offset", "mod", "drop", "page", "shock", "boot", "loop", "space", "slice", "back", "pad", "beta", "order", "steps", "sec", "phase", "mix", "Step", "run", "mode", "shape", "stage", "match", "test", "delay", "class", "d", "prop", "grad", "seed", "sync", "style", "config", "ip", "draw", "STEP", "depth", "part", "transfer"], "stride": ["collides", "strided", "stide", "ocriding", "strides", "ocrider", "erriding", "errider", "ocride", "Strided", "strider", "stides", "erride", "STRade", "collided", "stIDE", "StrIDE", "STRider", "STRiding", "Stride", "collide", "stided", "strade", "STRide", "ocrade", "errade", "collIDE", "strIDE", "striding", "Strides"], "alpha": ["rot", "xa", "linear", "A", "\u03b1", "lambda", "da", "offset", "pha", "sa", "a", "acl", "audio", "Alpha", "aa", "ma", "appa", "ta", "ac", "filter", "asc", "beta", "phi", "sc", "la", "amp", "sha", "phase", "scale", "igma", "af", "inc", "acc", "si", "rc"], "lims": ["limi", "limits", "lams", "imes", "milps", "Lims", "volgs", " Lims", " limes", "lamcs", "pls", "lamp", "Limits", "lifgs", "limp", "plps", "milp", " limits", "ligs", "limes", "ims", "imps", "lifits", "milcs", "limgs", " limi", "lifs", " Limits", " limgs", " limp", "Limgs", "Limports", "liggs", "limports", "ples", "volports", "dirports", " Limports", "dirits", "dirs", "lamps", "velgs", "mils", "ligports", " limports", "vols", "velits", " limps", "pli", "limps", "limcs", " limcs", "imi", "vels"], "dmode": ["dtool", "rdmode", "gmem", "pmodule", "madtone", "pmode", "dmem", "sdphase", "dmodule", " dmodule", "dapter", "sdlane", "pdtone", "dtone", "vdguide", "ldmode", "sdmodule", "rdmodule", "rdphase", "rmode", "pdmode", "madapter", "rdlane", "madmode", " dMode", "ldMode", "dguide", "rmodule", "dlane", "rtool", "sdtone", "rdmem", "vdmode", "dloop", "sdapter", "pdmodule", "pdMode", " dloop", "pdapter", "gmode", "madloop", "pguide", "gmodule", "dMode", "rguide", "ptool", "ldloop", "vdmodule", "sdmode", "pdloop", "sdloop", "glane", "rphase", "gphase", "dphase", "vdtool", "rmem", "ldmodule"], "chroma": ["chromac", "alphac", "normac", "alphama", "norma", "chrona", "chronac", "alphsa", "normsa", "chromama", "chronama", "chronsa", "chromsa", "normama"], "i": ["cli", "yi", "ami", "li", "gi", "ni", "ii", "zi", "chi", "ei", "ui", "pi", "r", "d", "I", "n", "di", "is", "id", "mi", "it", "iu", "k", "im", "j", "m", "eni", "info", "ti", "ini", "index", "multi", "ai", "ie", "x", "ip", "c", "p", "l", "bi", "phi", "e", "hi", "f", "u", "ori", "o", "v", "qi", "b", "t", "ix", "ik", "uri", "ci", "io", "si", "xi"], "sflag": ["osflag", "silag", " sfun", "psflag", "Scount", "cfun", "tret", "Sflag", "nflag", " sret", "siflags", "psstatus", "pquad", "scount", "plag", "siquad", "squad", " slag", "osret", "tsflag", "sforce", "secondarykill", "osforge", "secondaryflag", "cforce", "siflag", "nlag", "secondaryforge", " squad", "cflag", "slag", "sflags", "sforge", "tsstatus", "sfun", "cret", "tsfd", "pslen", " sflags", "pflags", " slen", "oskill", "skill", "tfun", " skill", "secondaryret", " sfd", "tforce", "ncount", "tslen", " sforge", "sfd", "sret", " sforce", "sstatus", "psfd", "slen", " sstatus", "pflag", "nflags", "tflag", "Slag", "Sflags"], "p0": ["q050", "P0", "p6", " p6", "pok", "p5", "f1", "ap0", "a0", "g93", "P1", "a00", "p050", "pt1", "g1", "pt050", "q00", " p00", "p00", "qfrom", "pr0", "g5", "pt0", "f2", "apfrom", "P2", "pnn", "prok", "ptfrom", "ap050", "q2", "p50", "ip0", "a2", "t0", "t50", "pfrom", "prnn", "ip1", "pr50", "f6", "ip5", " p2", "f0", "g0", "q93", "tok", " pnn", "a1", "p2", " pok", "ap1", "q5", " p50", "P6", "ip93", "tnn", "p93"], "q0": [" q00", "qt0", "qa180", "sq6", "p100", "dq00", "v80", "sqkn", " qkn", "p80", "dq8", "q00", "qa100", "y0", "qfrom", "p00", " qfrom", "sq0", "qtkn", "Q00", "y90", "dq90", "q6", "Q80", "sq3", " q3", "qu1", "q3", "sq90", "y00", "qkn", "y8", "q48", "sqfrom", "qu00", "q90", "Q1", "sq00", "q8", "qufrom", "qu0", "q100", "q80", "qa0", "q180", "p180", "qt3", "v1", "v00", "qu48", "v0", "dq0", "qt6", "sq48", "Q0", "qa1", "qu180", "qu100", " q48", " q6", "sq8"], "p1": ["qOne", "s0", "pone", "hinstance", "u0", "s1", "pgOne", "sp1", "qn", "pn", "pOne", "sone", "qone", "spOne", "spone", "pinstance", "uOne", "pg1", "pginstance", "cOne", " pOne", "ip0", "pg0", " pn", "sOne", "uone", "c1", "ipn", "ip1", "u1", "qa0", "hOne", "h1", "c0", "h0", "qainstance", "ipOne", "qa1", "qaOne", "sp0", "cone"], "q1": ["sqone", "k9", "pone", "dqone", "sq9", "sq1", "sq0", "qone", "p81", " qone", "kone", "p9", "q81", "dq1", " q81", "dq81", "dq0", "q9", "k0", "k1"]}}
{"project": "qemu", "commit_id": "03fcbd9dc5084ff4676c153fbe04fb0fcf939d09", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n\n{\n\n    DeviceClass *dc;\n\n    const char *driver, *path;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    dc = qdev_get_device_class(&driver, errp);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}", "idx": 2124, "substitutes": {"opts": ["copfs", "OPTS", "optfs", "copt", " opps", " opns", "optns", "Opps", "Opt", "popouts", "OPts", "opps", "opert", "ott", "otts", "opercs", "opted", "iopcs", "iopouts", "popts", "optt", "opouts", " opt", "prets", "Opts", "otns", "preps", "Opted", "okts", "optted", "opt", "copcs", "optcs", "optts", "opTS", "opns", "opcs", "pret", "preted", " opouts", "okt", " opcs", "OPt", "iopt", "okps", "optps", "otcs", " opfs", "otTS", "optouts", "copts", "OPcs", "opfs", "otps", "popt", "iopts", "okouts", "copps", "operts", "popps", "optTS", "operps"], "errp": ["errorf", "errP", "rrfp", "erP", "eerpa", "Erp", "derps", "erpc", "rrf", "Err", " errpr", "armpr", "gerpr", "eerps", "drpr", "gerp", "errorpc", "errorpr", "derp", "errfp", "errpc", "drP", "rrps", "rrP", "lerps", "drp", "errorP", " errpy", " errr", "Erpc", "acepy", "gerP", "errorps", " errps", " errP", "Erfp", "armf", "derpa", "errps", "errr", " errpa", "eerf", "eerp", " errpc", "derf", "errorp", "armfp", "erp", "rrpr", "rrpy", "errorfp", "errpr", "gerps", "acef", "drps", " errf", " errfp", "aceP", "erps", "errf", "errpy", "errorr", "acep", "lerP", "errpa", "lerpc", "armp", "lerp", "erfp", "rrp"], "dc": ["fc", "cm", "dr", "CD", "DC", "controller", "dn", "da", "dd", "ga", "conn", "cc", "mc", "gc", "device", "desc", "d", "di", "ct", "nc", "director", "bc", "tc", "cdn", "dk", "ac", "df", "dt", "cr", "ds", "inc", "ec", "cu", "c", "xc", "jc", "doc", "lc", "design", "oc", "sc", "ca", "cd", "disc", "vc", "creator", "cca", "pc", "cf", "dat", "enter", "dir", "input", "db", "rc"], "driver": ["serial", "dr", "route", "test", "name", "version", "cross", "dn", "service", "target", "device", "host", "url", "d", "ride", "devices", "type", "director", "operator", "der", "store", "platform", "cdn", "pass", "builder", "ctor", "coll", "project", "direction", "source", "dt", "config", "owner", "writer", "reader", "design", "vers", "length", "force", "ide", "drive", "dig", "draw", "cd", "loader", "handler", "river", "creator", "Driver", "iv", "plugin", "prov", "uri", "product", "engine", "mode", "dir", "dist", "drivers"], "path": ["route", "mount", "name", "cross", "key", "anc", "context", "alias", "method", "host", "device", "data", "url", "loc", "ride", "prop", "id", "parent", "end", "enc", "pass", "api", "package", "inner", "Path", "entry", "sync", "request", "str", "source", "pointer", "config", "raw", "PATH", "block", "child", "loader", "text", "where", "object", "ath", "node", "prefix", "clean", "uri", "session", "root", "dir", "rh", "input", "user", "port"], "dev": ["serial", "fo", "test", "ow", "def", "dd", "conn", "device", "sd", "mod", "data", "new", "development", "ver", "d", "di", "der", "priv", "auth", "de", "client", "dom", "api", "Dev", "DEV", "ve", "info", "project", "bug", "temp", "pub", "progress", "result", "gu", "block", "doc", "gd", "app", "cache", "conf", "obj", "comment", "node", "die", "tech", "ev", "prov", "error", "var", "session", "valid", "od", "engine", "debug", "diff", "dist"], "bus": ["route", "stick", "lock", "device", "url", "ver", "home", "feed", "us", "object", "vc", "comment", "engine", "dir", "board", "port", "controller", "local", "target", "Bus", "host", "bc", "pass", "plug", "state", "lc", "length", "die", "lib", "plugin", "os", "session", "catch", "usb", "io", "root", "load", "user", "serial", "mount", "hub", "cat", "BUS", "boot", "loop", "proxy", "proc", "project", "back", "cache", "machine", "bb", "bridge", "las", "ride", "test", "service", "http", "def", "class", "sync", "coll", "bug", "config", "block", "drive", "miss", "pull", "b", "db"], "err": ["ise", "test", "gr", "rs", "Error", "go", "rr", "ee", " error", "orig", "der", "lr", "arr", "ef", "proc", "ah", "er", "ir", "cr", "rev", "str", "errors", "exc", "phi", "ler", "doc", "order", "attr", "ar", "sys", "resp", "ev", "error", "acer", "req", "Er", "iter", "inc", "rh", "res", "db"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,\n\n                              int buf_size, int buf_size2)\n\n{\n\n    RVDecContext *rv = avctx->priv_data;\n\n    MpegEncContext *s = &rv->m;\n\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;\n\n\n\n    active_bits_size = buf_size * 8;\n\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n\n    if (s->codec_id == AV_CODEC_ID_RV10)\n\n        mb_count = rv10_decode_picture_header(s);\n\n    else\n\n        mb_count = rv20_decode_picture_header(rv);\n\n    if (mb_count < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->mb_x >= s->mb_width ||\n\n        s->mb_y >= s->mb_height) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n\n    left   = s->mb_width * s->mb_height - mb_pos;\n\n    if (mb_count > left) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {\n\n        // FIXME write parser so we always have complete frames?\n\n        if (s->current_picture_ptr) {\n\n            ff_er_frame_end(&s->er);\n\n            ff_MPV_frame_end(s);\n\n            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;\n\n        }\n\n        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)\n\n            return ret;\n\n        ff_mpeg_er_frame_start(s);\n\n    } else {\n\n        if (s->current_picture_ptr->f.pict_type != s->pict_type) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n\n\n    /* default quantization values */\n\n    if (s->codec_id == AV_CODEC_ID_RV10) {\n\n        if (s->mb_y == 0)\n\n            s->first_slice_line = 1;\n\n    } else {\n\n        s->first_slice_line = 1;\n\n        s->resync_mb_x      = s->mb_x;\n\n    }\n\n    start_mb_x     = s->mb_x;\n\n    s->resync_mb_y = s->mb_y;\n\n    if (s->h263_aic) {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_aic_dc_scale_table;\n\n    } else {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n\n    }\n\n\n\n    if (s->modified_quant)\n\n        s->chroma_qscale_table = ff_h263_chroma_qscale_table;\n\n\n\n    ff_set_qscale(s, s->qscale);\n\n\n\n    s->rv10_first_dc_coded[0] = 0;\n\n    s->rv10_first_dc_coded[1] = 0;\n\n    s->rv10_first_dc_coded[2] = 0;\n\n    s->block_wrap[0] =\n\n    s->block_wrap[1] =\n\n    s->block_wrap[2] =\n\n    s->block_wrap[3] = s->b8_stride;\n\n    s->block_wrap[4] =\n\n    s->block_wrap[5] = s->mb_stride;\n\n    ff_init_block_index(s);\n\n\n\n    /* decode each macroblock */\n\n    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {\n\n        int ret;\n\n        ff_update_block_index(s);\n\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n        s->mv_dir  = MV_DIR_FORWARD;\n\n        s->mv_type = MV_TYPE_16X16;\n\n        ret = ff_h263_decode_mb(s, s->block);\n\n\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n\n        // bitstream size\n\n        if (ret != SLICE_ERROR) {\n\n            int v = show_bits(&s->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_MPV_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n", "idx": 2130, "substitutes": {"avctx": ["afconfig", "AVctx", "ajctx", "AVcv", "avectx", " avnp", "afcmp", "afctx", "afcontext", "AVctrl", " avctrl", "avecf", "afpkg", "navctx", " avtc", " avcmp", "AVloc", "avcf", " avcontext", " avcf", "avpkg", "AVconfig", "verconfig", "avnp", "AVcoll", "ajcv", "AVpkg", "AVctl", "svctx", "avctrl", "ajctrl", "avtc", "afcoll", "afloc", "navcontext", "afnp", "afcf", "svctl", "avcoll", "avloc", "avctl", "navpkg", "avcontext", "navctl", "avconfig", "aveloc", "svpkg", "avecontext", "svcontext", "ajtc", "verctx", " avcv", "avcmp", "avecoll", "AVtc", " avpkg", "avenp", "avcv", "vercoll", "AVcmp", "AVcontext", "vercontext"], "buf": ["fd", "src", "buffer", "ctx", "bh", "bag", "context", "sb", "queue", "data", "bc", "buff", "pb", "tmp", "batch", "rb", "fp", "cb", "pool", "config", "cv", "vec", "f", "wb", "bd", "br", "gb", "cmd", "alloc", "bb", "fb", "b", "seq", "cf", "conv", "uf", "fi", "rc"], "buf_size": ["bufaccount", "buf_fee", "byte_scale", "buflexsize", "byte_uri", "byteaccount", "bufacunit", "buf_scale", "buf_count", "byteacfee", "buflexize", "buf_ize", "buf_sized", "buf_uri", "fb_size", "byteacunit", "fblexclean", "fblexize", "buflexclean", "byte_size", "byteacsize", "fblexsize", "byte_count", "bufacsize", "fb_sized", "byte_fee", "buf_clean", "bufacfee", "fb_ize", "fb_clean", "byte_unit", "buflexsized", "buf_unit", "byte_sized", "fblexsized"], "buf_size2": ["buf_ize182", "buf_size182", "buf_size192", "buf_ize192", "buf_scale2", "buf_rate2", "buf_end2", "buf_scaleTwo", "buf_scale1", "buf_rateTwo", "buf_ize2", "buf_scale182", "buf_end182", "buf_sizeTwo", "buf_rate1", "buf_size1", "buf_scale192", "buf_end192"], "rv": ["rrvd", "RV", "prvp", "rvd", "rrf", "rp", "rrv", " rvp", "prvd", "rvp", " rf", "srvp", "Rvp", "rV", "srv", "srV", "prv", "rf", "Rf", "Rp", "srf", "srp", "prf", "Rv", " rp", "Rvd", " rvd", "srvd", " rV", "rrvp"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "vs", "self", "us", "f", "sys", "u", "sum", "your", "se", "fs", "parts", "spec", "ts", "sb", "aws", "ims", "y", "uns", "xs", "sv", "request", "sets", "p", "e", "conf", "as", "v", "less", "su", "site", "S", "os", "ks", "t", "session", "its", "bs", "hs", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "r", "is", "ins", "i", "m", "settings", "ds", "als", "ps", "gs", "ns", "h", "c", "es", "posts", "sec", "o", "times", "si", "server", "service", "http", "ops", "d", "ans", "side", "comments", "params", "sync", "l", "services", "w", "features", "sq", "stats", "b", "states"], "mb_count": ["av_size", "mb64type", "mballcatch", "mb64num", "mem64count", "mb64count", "avFoffset", "mb_len", "mbJoffset", "bb_weight", "mbJcond", "mem_index", "mb_type", "mb_cond", "mb64index", "mb_num", "mbFcond", "mb67len", "mb67count", "rb_number", "mp_catch", "mbFsize", "av_cond", "mb67pos", "mballnumber", "rb_count", "mem_num", "mp_number", "avFcount", "mb_catch", "mbFcount", "mb_offset", "mem64type", "rb_add", "bb_pos", "av_count", "mp_count", "mbJcount", "mb_add", "avFcond", "avFsize", "mb_number", "mb_index", "bb_len", "mem64num", "av_offset", "mem_count", "mbFoffset", "mbJsize", "mb_weight", "mem64index", "mb_size", "mb67weight", "mem_type", "mballcount", "bb_count"], "mb_pos": ["MB_po", "mb5count", "MB_count", "emb_gen", "mb2pos", "mb_length", "mbfpos", "mb5pos", "mbJlength", "emb_position", "mb2count", "mb_gen", "mb__length", "emb_pos", "mb_po", "mb2len", "mb_len", "mb__pos", "mbflen", "mp_length", "MB_len", "mb__position", "mb2po", "mbfcount", "mb_position", "mbJposition", "mp_position", "mb__len", "mb5position", "mbJlen", "mb5gen", "emb_count", "mbfpo", "mbJpos", "mp_pos", "mp_len", "MB_pos"], "start_mb_x": ["start_mp_y", "start_mb_pos", "start_mp_pos", "start_mb_y", "start_mbvx", "start_mbvy", "start_mbvpos", "start_mp_x"], "active_bits_size": ["active_bytes_size", "active_bits___rate", "active_bits___size", "active_bits_rate", "active_bits_ize", "active_bits___ize", "active_bytes_rate", "active_bytes_ci", "active_bits_ci", "active_bytes_ize"], "ret": ["match", "arg", "fun", "att", "ext", "def", "bit", "success", "get", " Ret", "r", "alt", "job", "pet", "rets", "tmp", "arr", "rep", "info", "nt", "ft", "rev", "live", "back", "reply", "status", "rc", "temp", "Ret", "err", "last", "result", "bot", "reset", "len", "ref", "flag", "red", "value", "RET", "al", "lit", "re", "reg", "val", "det", "res"], "mb_x": ["mb_ya", "bb_x", "bb_ax", "MB_y", "mb_width", "mbDya", "mp_z", "bb_width", "mb___ax", "MB_count", "mbkheight", "mbDy", "mb___width", "mb8y", "mbkz", "mbkx", "mbky", "mb___xx", "mp_ya", "mb__y", "mb__z", "mb8x", "MB_x", "mbDx", "mb__x", "mb_z", "mp_height", "mp_x", "mb___x", "mp_y", "mp_w", "mb_w", "MB_width", "mb_ax", "mb8width", "mb__w", "bb_xx", "mb_height", "mbDw", "mb_xx", "mb8count"], "mb_y": ["mbJx", "mp_zy", "MB_y", "mb_width", "mp_length", "mbkarea", "mbFx", "mbFyd", "mb_sy", "mp_wy", "mbJy", "mbJzy", "mbFy", "mbklength", "mp_width", "mb_cy", "mbkx", "mbky", "mp_yd", "mb_yl", "MB_yl", "mb_wy", "mp_sy", "mb_area", "mbFwy", "MB_cy", "MB_x", "mp_area", "mp_height", "mp_x", "mb_zy", "mb_yd", "mp_y", "mb_length", "mb_height", "mbJsy"]}}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n", "idx": 2133, "substitutes": {"cpu": ["fc", "include", "np", "vm", "cli", "gpu", "intel", "hw", "conn", "gc", "lb", "computer", "clock", "uci", "nic", "boot", "fps", "instance", "component", "eni", "CPU", "proc", "config", "bench", "css", "lc", "pu", "loader", "core", "cache", "processor", "node", "linux", "pc", "cp", " CPU", "fork", "online", "uu", "performance"]}}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n", "idx": 2142, "substitutes": {"dst": ["fdest", "ldst", "lsts", "dset", "adset", "adconst", "Dset", "dsth", "idst", "fconst", "adsc", "sdset", "adst", "ldST", "dsc", "idbl", "dsts", "dedx", "lbl", "idsts", "dedsts", "dST", "fST", "idST", "sdsts", " dbl", "ldbl", "dx", " dconst", " dset", "idset", "dest", "adsts", "fst", "dconst", "fsts", "lST", "sdst", "fdx", " dsc", "datbl", " dsts", "dbl", "dedest", "ldsts", "lst", "fdst", "fdsts", " dest", "datsth", " dsth", "adST", " dx", "Dsc", "sdST", "dedst", " dST", "datst", "datST", "idsth", "Dst", "adbl", "Dbl"], "idx": [" idX", "idk", "pidwx", "indx", "adx", "adz", "aidx", "ridwx", "Idx", " idz", "indlex", "ideex", "minz", "idlex", " idex", "ridx", "Idwx", "adX", "ridX", " idlex", "aidxc", "idxt", " idxc", "dz", "indX", "dx", "idxs", "aidX", "minx", "ideX", "idex", "minX", "index", " idxs", "aidz", "dX", "idxc", "aidex", "idX", " idxt", "IdX", "dxc", "idz", "aidk", "idexs", "Idxs", "pidx", "minxt", "adxt", "pidX", " idk", "indk", "idwx", "idelex"], "sign": ["sub", "sa", "weight", "head", "ign", "enc", "script", "roll", "eff", "big", "circ", "feed", "ind", "connect", "sc", "comment", "sum", "se", "start", "pack", "name", "spec", "form", "align", "type", "sh", "id", "pass", "max", "scan", "Sign", "z", "parse", "step", "mask", "sr", "scale", "sex", "load", "plus", "keep", "ss", "small", "loc", "add", "search", "with", "lex", "SIGN", "size", "vis", "mix", "close", "reg", "shape", "cost", "call", "sch", "sk", "sync", "block", "draw", "contract", "save", "min", "pull", "sort", "pen", "inc"]}}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}", "idx": 2148, "substitutes": {"mon": ["meter", "mn", "login", "mos", " monitor", "prem", "mt", "Monitor", "conn", "bo", "mc", "bm", "chron", "domain", "mini", "flo", "month", "amon", "yahoo", "mi", "mo", "dom", "mut", "gin", "m", "mat", "mons", "mor", "master", "mag", "atom", "pid", "mot", "man", "dm", "mont", "mand", "mr", "mun", "MON", "Mon", "met", "lin", "module", "monitor", "tom", "ann", "an", "mu", "pin", "wat"], "qdict": [" qdef", "dqdef", "dqdat", "qdef", "dqdir", "dqdict", "qtdat", "qdat", "qtdict", "qdir", "qtdef", " qdat", " qdir", "qtdir"], "list": ["cli", "lock", "this", "act", "key", "queue", "get", "ml", "n", "dl", "rec", "sl", "client", "ls", "code", "master", "index", "select", "x", "self", "set", "single", "all", "pl", "group", "name", "cl", "LIST", "type", "ln", "chain", "edit", "parent", "arr", "pair", "batch", "bl", "fail", "update", "write", "p", "lc", "resource", "la", "lists", "listed", "val", "List", "load", "layer", "base", "del", "li", "lp", "a", "data", "new", "add", "page", "record", "true", "member", "pre", "i", "loop", "ll", "str", "result", "len", "other", "value", "obj", "table", "old", "module", "match", "call", "ist", "test", "null", "server", "level", "array", "detail", "item", "none", "entry", "coll", "sync", "source", "config", "l", "block", "stack", "resp", "min", "full", "view", "part", "diff"], "err": ["dr", "ise", "ret", "call", "rage", "cor", "rs", "gr", "Error", "fy", "r", "rr", "n", "der", "ry", "lr", "raise", "eor", "arr", "rh", "y", "nr", "er", "ir", "cr", "fr", "oller", "str", "status", "bug", "ras", "result", "ind", "ler", "e", "order", "rl", "f", "ref", "br", "ar", "sys", "resp", "orr", "mr", "error", "req", "rar", "Er", "iter", "ace", "res"]}}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    TrimContext       *s = ctx->priv;\n\n    int64_t start_sample, end_sample = frame->nb_samples;\n\n    int64_t pts;\n\n    int drop;\n\n\n\n    /* drop everything if EOF has already been returned */\n\n    if (s->eof) {\n\n        av_frame_free(&frame);\n\n        return 0;\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        pts = av_rescale_q(frame->pts, inlink->time_base,\n\n                           (AVRational){ 1, inlink->sample_rate });\n\n    else\n\n        pts = s->next_pts;\n\n    s->next_pts = pts + frame->nb_samples;\n\n\n\n    /* check if at least a part of the frame is after the start time */\n\n    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {\n\n        start_sample = 0;\n\n    } else {\n\n        drop = 1;\n\n        start_sample = frame->nb_samples;\n\n\n\n        if (s->start_sample >= 0 &&\n\n            s->nb_samples + frame->nb_samples > s->start_sample) {\n\n            drop         = 0;\n\n            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts + frame->nb_samples > s->start_pts) {\n\n            drop = 0;\n\n            start_sample = FFMIN(start_sample, s->start_pts - pts);\n\n        }\n\n\n\n        if (drop)\n\n            goto drop;\n\n    }\n\n\n\n    if (s->first_pts == AV_NOPTS_VALUE)\n\n        s->first_pts = pts + start_sample;\n\n\n\n    /* check if at least a part of the frame is before the end time */\n\n    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {\n\n        end_sample = frame->nb_samples;\n\n    } else {\n\n        drop       = 1;\n\n        end_sample = 0;\n\n\n\n        if (s->end_sample != INT64_MAX &&\n\n            s->nb_samples < s->end_sample) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts < s->end_pts) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_pts - pts);\n\n        }\n\n\n\n        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);\n\n        }\n\n\n\n        if (drop) {\n\n            s->eof = 1;\n\n            goto drop;\n\n        }\n\n    }\n\n\n\n    s->nb_samples += frame->nb_samples;\n\n    start_sample   = FFMAX(0, start_sample);\n\n    end_sample     = FFMIN(frame->nb_samples, end_sample);\n\n    av_assert0(start_sample < end_sample);\n\n\n\n    if (start_sample) {\n\n        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        av_frame_copy_props(out, frame);\n\n        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,\n\n                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                        frame->format);\n\n        if (out->pts != AV_NOPTS_VALUE)\n\n            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },\n\n                                     inlink->time_base);\n\n\n\n        av_frame_free(&frame);\n\n        frame = out;\n\n    } else\n\n        frame->nb_samples = end_sample;\n\n\n\n    s->got_output = 1;\n\n    return ff_filter_frame(ctx->outputs[0], frame);\n\n\n\ndrop:\n\n    s->nb_samples += frame->nb_samples;\n\n    av_frame_free(&frame);\n\n    return 0;\n\n}\n", "idx": 2157, "substitutes": {"inlink": ["INlink", "inslinks", "inload", "inlock", "Inlink", "inlinks", "rinink", "rinlink", "insself", "outline", "Inlock", "outlink", " inink", "INlock", "inasline", "Inlinks", "insline", "inink", "rinlock", "insink", " inlock", "Inline", "outload", "inslock", " inlinks", "INself", "outlock", "inaslock", "inself", "inaslink", " inself", " inload", "INline", "inslink", "inasload", "rinload", "insload"], "frame": ["dr", "js", "sche", "figure", "video", "sample", "sf", "file", "framework", "iframe", "f", "object", "pse", "ze", "zone", "fi", "flow", "time", "Frame", "sequence", "spec", "zip", "image", "component", "frames", "request", "fe", "rup", "p", "state", "e", "scale", "session", "me", "scene", "ss", "fram", "rame", "data", "m", "info", "slice", "document", "c", "setup", "node", "module", "cf", "screen", "sim", "series", "service", "window", "d", "ms", "scope", "dy", "coll", "fr", "style", "source", "feature", "range", "fb", "plane", "element", "full", "line", "motion", "view", "cfg", "part", "game"], "ctx": ["cm", "cms", "cam", "cs", "conn", "context", "anc", "cc", "Context", "loc", "ck", "bc", "scope", "tc", "mac", "m", "tx", "cb", "kw", "config", "pkg", "c", "cv", "lc", "conf", "ca", "sq", "wcs", "sc", "ctrl", "cmd", "obj", "cca", "pc", "cp", "cf", "conv", "ci", "cfg"], "s": ["sg", "js", "qs", "n", "sp", "sl", "sample", "g", "ses", "ls", "sf", "args", "vs", "us", "f", "sys", "u", "se", "fs", "parts", "stat", "spec", "ts", "sb", "ims", "span", "y", "frames", "xs", "sv", "p", "state", "e", "lines", "conf", "site", "S", "os", "session", "t", "hs", "sci", "sym", "obs", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "i", "space", "m", "settings", "slice", "ds", "ps", "gs", "ns", "h", "c", "setup", "es", "o", "sim", "si", "series", "service", "d", "ms", "scope", "sk", "sis", "sync", "source", "l", "services", "sq", "sing", "b", "states"], "start_sample": ["starting_sample", "end_stage", "startjsingle", "currentfpackage", "end_scale", "starting_scale", "start67module", "currentfsample", "start_space", "stop_sequence", "starttsample", "start_slot", "startjscale", "current_shape", "start_module", "start_shape", "current_package", "start_stage", "startPample", "pick_sample", " start_space", "starttspace", "pick_model", "startfshape", "end_ample", "currentfspace", "starttsem", "start_Sample", "current_sample", "startPsample", "starting_ample", "end_module", "start_slice", "start_side", "startxspace", "start_ample", "end_sam", "end_single", "end_package", "stop_sample", "start_scale", "start_sam", "end_group", "startxsample", "start_package", " start_side", " start_sem", "start67slot", "current_space", "startfpackage", "start_single", "pick_package", "starting_source", "startfample", "starttside", "startxslot", "startPSample", "start67space", "start_model", "startxmodule", "end_source", "stop_scale", "start67sample", "start_server", "startfsource", "end_slot", "start_size", "startjgroup", "startPscale", "start_sem", "startfspace", "startfscale", "start_sequence", "end_space", "end_sample", "start_group", "currentfshape", "end_Sample", "stop_server", "start_source", "startfsample", "end_size", "pick_slice", "startjsample"], "pts": ["seqcount", "pars", "ointds", "cts", "periodsets", "aptd", "parsym", "seqds", "conds", "periodlines", "ptcount", "periodxs", "nts", "ntsets", "iptd", "intts", "prs", "periodgroups", "eptsd", "inputs", "inputsets", "ptf", "apts", "roundlines", "parss", "ctd", "PTs", "ointf", "ptsd", "ptgroups", "pps", "PTS", "ptsw", "ptse", "condd", "condts", "monts", "uptss", "periods", "ptsym", "prd", "uptsym", "prts", "ptns", "inputxs", "ptses", "ptss", "roundsets", "PTf", "seqsd", "ipts", "epts", "aptsets", "rounds", "PTses", "ointS", "seqs", "aptxs", "uptd", "uptsi", "seqsi", "PTd", "aptsw", "ctts", "ointsets", "montd", "ptlines", "PTns", "PTss", "iptts", "periodts", "ptxs", "PTsym", "periodds", "iptsw", "PTgroups", "ptd", "parses", "ints", "aptsi", "uptses", "ptS", "ppf", "eptsi", "ptds", "intsets", "periodns", "aptts", "PTlines", "prse", "ptts", "upts", "intns", "PTsw", "seqsets", "inputts", "ptsets", "periodcount", "ntns", "roundts", "montsi", "roundns", "ointcount", "roundgroups", "oints", "PTts", "ntts", "montsd", "ptsi", "ctse", "condse", "ppS"], "drop": ["layer", "clip", "allow", "dr", "delay", "crop", "no", "append", "skip", "bag", "throw", "zip", "ignore", "alter", "send", "add", "type", "dl", "field", "pick", " dropped", "sample", "loop", "batch", "gap", "update", "move", "leave", "roll", "bug", "push", "slice", "err", "delete", "select", "Drop", "pad", "change", "step", "keep", "shift", "start", "pop", "dropping", "repeat", "col", "comment", "phase", "pull", "scale", "carry", "qa", "drops", "sleep", "error", "stop", "play", "hide", "close", "plane", "dp", "shape", "bottom", "dro", "diff", "port"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,\n\n                               const TCGArg * const args, uint16_t dead_args,\n\n                               uint8_t sync_args)\n\n{\n\n    int flags, nb_regs, i;\n\n    TCGReg reg;\n\n    TCGArg arg;\n\n    TCGTemp *ts;\n\n    intptr_t stack_offset;\n\n    size_t call_stack_size;\n\n    tcg_insn_unit *func_addr;\n\n    int allocate_args;\n\n    TCGRegSet allocated_regs;\n\n\n\n    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\n\n    flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\n\n    if (nb_regs > nb_iargs) {\n\n        nb_regs = nb_iargs;\n\n    }\n\n\n\n    /* assign stack slots first */\n\n    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);\n\n    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & \n\n        ~(TCG_TARGET_STACK_ALIGN - 1);\n\n    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);\n\n    if (allocate_args) {\n\n        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,\n\n           preallocate call stack */\n\n        tcg_abort();\n\n    }\n\n\n\n    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;\n\n    for(i = nb_regs; i < nb_iargs; i++) {\n\n        arg = args[nb_oargs + i];\n\n#ifdef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset -= sizeof(tcg_target_long);\n\n#endif\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            temp_load(s, ts, tcg_target_available_regs[ts->type],\n\n                      s->reserved_regs);\n\n            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);\n\n        }\n\n#ifndef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset += sizeof(tcg_target_long);\n\n#endif\n\n    }\n\n    \n\n    /* assign input registers */\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    for(i = 0; i < nb_regs; i++) {\n\n        arg = args[nb_oargs + i];\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            reg = tcg_target_call_iarg_regs[i];\n\n            tcg_reg_free(s, reg, allocated_regs);\n\n\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                if (ts->reg != reg) {\n\n                    tcg_out_mov(s, ts->type, reg, ts->reg);\n\n                }\n\n            } else {\n\n                TCGRegSet arg_set;\n\n\n\n                tcg_regset_clear(arg_set);\n\n                tcg_regset_set_reg(arg_set, reg);\n\n                temp_load(s, ts, arg_set, allocated_regs);\n\n            }\n\n\n\n            tcg_regset_set_reg(allocated_regs, reg);\n\n        }\n\n    }\n\n    \n\n    /* mark dead temporaries and free the associated registers */\n\n    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n        if (IS_DEAD_ARG(i)) {\n\n            temp_dead(s, &s->temps[args[i]]);\n\n        }\n\n    }\n\n    \n\n    /* clobber call registers */\n\n    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {\n\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {\n\n            tcg_reg_free(s, i, allocated_regs);\n\n        }\n\n    }\n\n\n\n    /* Save globals if they might be written by the helper, sync them if\n\n       they might be read. */\n\n    if (flags & TCG_CALL_NO_READ_GLOBALS) {\n\n        /* Nothing to do */\n\n    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n        sync_globals(s, allocated_regs);\n\n    } else {\n\n        save_globals(s, allocated_regs);\n\n    }\n\n\n\n    tcg_out_call(s, func_addr);\n\n\n\n    /* assign output registers and emit moves if needed */\n\n    for(i = 0; i < nb_oargs; i++) {\n\n        arg = args[i];\n\n        ts = &s->temps[arg];\n\n        reg = tcg_target_call_oarg_regs[i];\n\n        assert(s->reg_to_temp[reg] == NULL);\n\n\n\n        if (ts->fixed_reg) {\n\n            if (ts->reg != reg) {\n\n                tcg_out_mov(s, ts->type, ts->reg, reg);\n\n            }\n\n        } else {\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ts->reg] = NULL;\n\n            }\n\n            ts->val_type = TEMP_VAL_REG;\n\n            ts->reg = reg;\n\n            ts->mem_coherent = 0;\n\n            s->reg_to_temp[reg] = ts;\n\n            if (NEED_SYNC_ARG(i)) {\n\n                tcg_reg_sync(s, reg, allocated_regs);\n\n            }\n\n            if (IS_DEAD_ARG(i)) {\n\n                temp_dead(s, ts);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2182, "substitutes": {"s": ["js", "service", "cs", "groups", "ss", "ops", "spec", "r", "d", "n", "is", "client", "shared", "side", "g", "m", "ses", "ls", "sf", "settings", "tests", "sets", "ds", "ps", "gs", "ns", "c", "p", "services", "w", "e", "private", "f", "self", "us", "sys", "sq", "u", "conf", "o", "stats", "b", "site", "t", "S", "session", "su", "os", "its", "states", "se", "fs", "si", "sym", "ssl"], "nb_oargs": ["nb24iiargs", "nb_woargs", "nb24oargs", "nb_iiseries", "nb__oalls", "nb_diextra", "nb24ovalid", "nb_oaargs", "nb_parg", "nb_oalls", "nb_oaarg", "nb_autoargs", "nb_perg", "nb__iarg", "nb__ialls", "nb_oerg", "nb__iargs", "nb_iiargs", "nb_ierg", "nb_iextra", "nb_dierg", "nb_ivals", "nb_autoextra", "nb_oarg", "nb_iaux", "nb24iiseries", "nb_woaux", "nb_oaerg", "nb_palls", "nb_pargs", "nb_diargs", "nb24oarg", "nb_woarg", "nb_oaux", "nb_oseries", "nb24oseries", "nb__oargs", "nb24iivalid", "nb_oavalid", "nb_iarg", "nb24iiarg", "nb_ovalid", "nb_wovals", "nb_ovals", "nb_oextra", "nb_iivalid", "nb__ierg", "nb__oarg", "nb__oerg", "nb_diarg", "nb_autoerg", "nb_ivalid", "nb_ialls", "nb_iiarg", "nb_oaalls", "nb_autoarg", "nb_oaseries", "nb_iseries"], "nb_iargs": ["nb_iiarr", "nb_iags", "nb_tiflags", "nb_iiflags", "nb_tiargs", "nb_oriarg", "nb_siargs", "nb_iniargs", "nb_uiarg", "nb_parg", "nb_wems", "nb_ciems", "nb_civalid", "nb_uiarr", "nb_rarg", "nb_rores", "nb_oflags", "nb_tiarg", "nb_bargs", "nb_iiags", "nb_iiargs", "nb_iores", "nb_piarg", "nb_piflags", "nb_oriages", "nb_bass", "nb_oores", "nb_wargs", "nb_siarg", "nb_iiems", "nb_wags", "nb_ciargs", "nb_oarg", "nb_diflags", "nb_iireg", "nb_oyears", "nb_pargs", "nb_uiflags", "nb_ciarr", "nb_diargs", "nb_iems", "nb_orictr", "nb_avalid", "nb_rarms", "nb_warg", "nb_rargs", "nb_iarr", "nb_aarr", "nb_aems", "nb_siages", "nb_inivalid", "nb_aargs", "nb_oems", "nb_oass", "nb_octr", "nb_iiass", "nb_iniarr", "nb_diyears", "nb_iarg", "nb_uiargs", "nb_oreg", "nb_oages", "nb_iarms", "nb_ictr", "nb_piarr", "nb_barg", "nb_oags", "nb_diarg", "nb_sictr", "nb_ivalid", "nb_ireg", "nb_iflags", "nb_oriargs", "nb_oarms", "nb_iass", "nb_iniems", "nb_iiarg", "nb_pores", "nb_breg", "nb_iyears", "nb_tiyears", "nb_iages", "nb_piargs", "nb_parms"], "args": ["call", "ig", "ics", "alls", "groups", "cs", "extra", "actions", "method", "vals", "data", "yrs", "members", "ips", "acks", "Arg", "objects", "ms", "ins", "ims", "arr", "arms", "py", "g", "params", "frames", "ars", "str", "names", "ds", "config", "ams", "gs", "ns", "result", "items", "stack", "words", "atts", "size", "values", "flag", "orders", "alloc", "as", "v", "fields", "blocks", "uments", " arguments", "ay", "Args", "codes", "states", "all", "ae", "ags", "parts"], "dead_args": ["sync_arg", "syncacarg", "call_args", "syncacflags", "syncallargs", "sync_parts", "call_parts", "sync_flags", "syncacparts", "syncallarg", "call_flags", "syncallparts", "call_arg", "syncacargs", "syncallflags"], "sync_args": ["sync_arg", "ync_parts", "yncallparts", "sync__arg", "syncallargs", "sync_parts", "yncallflags", "sync_flags", "ync_args", "syncallarg", "syncallparts", "ync_flags", "sync__parts", "yncallarg", "ync_arg", "syncallflags", "sync__args", "sync__flags", "yncallargs"], "flags": ["ret", "fun", "fd", "alls", "cs", "Flags", "ops", "bit", "spec", "lag", "rules", "vals", "ui", "weight", "ils", "arr", "options", "bits", "settings", "utils", "status", "len", "flag", "features", "ints", "weights", "conf", "mask", "fields", "stats", "types", "ants", "count", "init", "fs", "ags", "FLAG", "actions"], "nb_regs": ["nb67regs", "nb_regS", "nb67comms", "nb_execes", "nb_rolses", "nb_reggs", "nb_threades", "nb_gregs", "nb_reges", "nb_gregS", "nb_threadals", "nb_counts", "nb_commss", "nb_recstates", "nb_indls", "nb_regns", "nb_funs", "nb_indils", "nb_reqs", "nb_regses", "nb_regils", "nb_accss", "nb_regss", "nb0000regs", "nb_gregments", "nb_accils", "nb_regcs", "nb_gregss", "nb_recS", "nb_outputments", "nb_commls", "nb_recs", "nb_regds", "nb6regss", "nb_contracts", "nb_outputs", "nb_recgroups", "nb_regours", "nb_rols", "nb_reqps", "nb_relcs", "nb_platformours", "nb0000regS", "nb_signours", "nb_relS", "nb_rolns", "nb6regS", "nb0000funs", "nb_execstates", "nb67commss", "nb_commils", "nb6gregS", "nb_inds", "nb_outputss", "nb_regments", "nb_funS", "nb_signgs", "nb67regss", "nb6gregs", "nb_reqgs", "nb_regps", "nb_signps", "nb_relds", "nb6regs", "nb6regments", "nb_threadgroups", "nb6gregss", "nb_recds", "nb67commils", "nb67commls", "nb_regals", "nb_execs", "nb0000funS", "nb_reccs", "nb_contractss", "nb_platforms", "nb_threadstates", "nb_comms", "nb_funcs", "nb_signs", "nb_accs", "nb_regstates", "nb0000funcs", "nb_rolals", "nb_platformps", "nb_threadses", "nb_outputS", "nb0000regds", "nb_execgroups", "nb67regls", "nb_reggroups", "nb_rels", "nb_indss", "nb67regils", "nb6gregments", "nb_regls", "nb_threads", "nb_reces", "nb_countses", "nb_reqours", "nb_contractments", "nb_threadns", "nb_contractS", "nb_funds", "nb_countns", "nb0000funds", "nb_accls", "nb0000regcs", "nb_countals", "nb_platformgs"], "i": ["li", "gi", "ni", "ii", "zi", "ui", "pi", "mini", "I", "n", "di", "id", "mi", "it", "iu", "j", "g", "y", "eni", "inner", "ri", "info", "ti", "ini", "index", "ani", "multi", "z", "ai", "ie", "ip", "x", "c", "p", "adi", "bi", "phi", "hi", "e", "f", "l", "u", "idi", "v", "ix", "qi", "t", "ci", "mu", "io", "fi", "si", "xi"], "reg": ["ret", "call", "sub", "ig", "no", "REG", "src", "def", "stat", "spec", "bit", "mod", "data", "tag", "rec", "orig", "lang", "num", "comp", "param", "proc", "info", "str", "config", "func", "block", "custom", "rem", "cache", "exec", "obj", "sec", "alloc", "lib", "seq", "inst", "var", "Reg", "run", "debug", "val", "all", "res", "rc", "mem"], "arg": ["argument", "call", "ig", "name", "alg", "act", "ass", "key", "bit", "op", "alias", "tag", "cat", "slot", "orig", "Arg", "cand", "ag", " flag", " argument", "ne", "arr", "ark", "enc", "param", "gin", "par", "pass", "j", "mac", "ac", "num", "g", "ask", " Arg", "err", "util", "str", "parse", "mag", "eg", "ang", "gu", "gas", "doc", "arc", "flag", "ax", "ar", "attr", "sec", "amp", "aug", "b", "cell", "var", "valid", "al", "addr", "val", "ace"], "ts": ["test", "te", "js", "tf", "acs", "cs", "ics", "alls", "ss", "uts", "rs", "tg", "qs", "tim", "ms", "ims", "tc", "ta", "tes", "tips", "ls", "tx", "ats", "Ts", "xs", "outs", "tests", "temp", "ds", "als", "ps", "str", "tl", "ns", "trans", "ptr", "atts", "tis", "tt", "tm", "stats", "t", "types", "ks", "times", "bs", "pt", "fs", "TS"], "stack_offset": [" stack_addr", "call_offset", "stack_usage", "stack64addr", "stackflowsize", "call_size", "stack64offset", "stack00offset", "stack_size", "stack_addr", "call_Offset", "stack_index", " stack_off", " stack_usage", "stack00index", "stack_Offset", "stack64scale", "stack00scale", " stack_index", "stack_scale", " stack_scale", "stackflowoff", "stackflowoffset", "stack_off", "stack64index", " stack_size", "stack00addr", "stackflowusage"], "call_stack_size": ["call_bufferflowsized", "call_stack_use", "call_thread_scale", "call_stack_scale", "call_stackswidth", "call_array_use", "call_buffer_max", "call_stack\u00b7type", "call_stackscapacity", "call_buffer_capacity", "call_stackflowcapacity", "call_buffer_left", "call_stack\u00b7slice", "call_stackflowleft", "call_stack___size", "call_stack_max", "call_ack_capacity", "call_stack_sized", "call_array_speed", "call_stack_type", "call_buffer_sized", "call_stack\u00b7speed", "call_ack_size", "call_stack\u00b7storage", "call_array_slice", "call_stack_width", "call_stack_strength", "call_buffer_storage", "call_stack_speed", "call_stack_slice", "call_array\u00b7use", "call_bufferflowsize", "call_array_size", "call_thread_size", "call_stack___speed", "call_bufferflowleft", "call_stackssize", "call_array\u00b7size", "call_stacksstrength", "call_stack_left", "call_stack\u00b7size", "call_ack_width", "call_stack_capacity", "call_buffer_size", "call_stack___slice", "call_thread_max", "call_stackflowsized", "call_buffer_type", "call_stackflowsize", "call_ack_strength", "call_array\u00b7speed", "call_stack\u00b7use", "call_stack___use", "call_stack\u00b7max", "call_stack_storage", "call_bufferflowcapacity", "call_array\u00b7slice"], "func_addr": ["func_wrapper", "function_addr", "func_address", "function_address", "func__address", "func__addr", "func__wrapper", "func_offset", "func_alias", "function_wrapper", "function_offset", "func__offset", "function_alias", "function_ptr", "func_ptr"], "allocate_args": ["allocated_arg", "allocate_size", "allate_size", "allallocablesize", "allocate_all", "allocateableall", "allalloc_args", "allate_args", "allallocableargs", "allocated_args", "allocateableargs", "allocateablearg", "allalloc_all", "allocate__size", "allocateablesize", "allocate__all", "allate_arg", "allate_params", "allalloc_size", "allocated_flags", "allallocablearg", "allocate_arg", "allalloc_arg", "allocate_flags", "allocate_params", "allocate__arg", "allocate__args", "allallocableall"], "allocated_regs": ["allocated_threadp", "allocated_REGd", "allocated_REGp", "allocated_reguments", "allocated_threaduments", "allocated_REGuments", "allocated_memp", "allocated_threads", "allocated_threadd", "allocated_REGs", "allocated_mems", "allocated_memd", "allocated_memuments", "allocated_regp", "allocated_regd"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n", "idx": 2187, "substitutes": {"arg": ["argument", "call", "ig", "any", "array", "ad", "Arg", "ag", "arr", "enc", "param", "pass", "g", "par", "ac", "args", "str", "parse", "ang", "or", "p", "work", "arc", "self", "arm", "ar", "exec", "ray", "as", "pc", "play", "var", "ic", "load", "am", "inc", "ace", "inf", "rc"], "s": ["sg", "server", "js", "service", "ss", "spec", "sa", "rs", "a", "new", "d", "is", "sl", "i", "g", "instance", "params", "m", "ls", "ses", "sf", "args", "sync", "settings", "ds", "parse", "ps", "gs", "ns", "l", "c", "p", "or", "services", "self", "e", "f", "es", "sys", "sq", "u", "south", "sec", "o", "b", "su", "S", "t", "os", "socket", "an", "hs", "si", "sym", "ssl"], "running": ["ending", "starting", " e", " performing", "active", "finished", " executing", "current", "playing", "d", " f", "n", " blocking", " continuing", "loop", "i", "runs", "inner", "m", " using", " Running", "rolling", "enabled", "standing", "runner", "loading", "result", "c", "p", " n", "f", " reading", "blocking", "working", "b", "using", "t", "testing", " d", " working", "Running", "run", "available", " starting", "reading", "successful", "rc"], "r": ["rg", " e", "q", " sr", "rs", "rn", "rr", "d", " self", "ru", "n", "ry", " ro", " re", "ng", "i", "g", " p", "rb", "m", "hr", " str", "nr", "er", "err", " no", "cr", " rs", "x", "result", "p", "ing", "c", "w", "e", " runner", "f", "ro", "rl", "ar", "R", "sr", "o", "mr", " c", "rd", "error", " d", "Running", "re", "run", "rh", " rc", "rc"]}}
{"project": "FFmpeg", "commit_id": "f95cfff07765912676cc613b55e2234b5d70f1bd", "target": 0, "func": "static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)\n\n{\n\n    static int hinted = 0;\n\n    int ret = 0;\n\n    AVDictionaryEntry *e;\n\n    const AVOption *o = NULL;\n\n    const char *option = NULL;\n\n    const char *codec_name = NULL;\n\n    char buff[1024];\n\n    AVCodecContext *ctx;\n\n    AVDictionary **dict;\n\n    enum AVCodecID guessed_codec_id;\n\n\n\n    switch (type) {\n\n    case AV_OPT_FLAG_VIDEO_PARAM:\n\n        ctx = config->dummy_vctx;\n\n        dict = &config->video_opts;\n\n        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_video_codec_id : AV_CODEC_ID_H264;\n\n        break;\n\n    case AV_OPT_FLAG_AUDIO_PARAM:\n\n        ctx = config->dummy_actx;\n\n        dict = &config->audio_opts;\n\n        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;\n\n        break;\n\n    default:\n\n        av_assert0(0);\n\n    }\n\n\n\n    if (strchr(opt, ':')) {\n\n        //explicit private option\n\n        snprintf(buff, sizeof(buff), \"%s\", opt);\n\n        codec_name = buff;\n\n        option = strchr(buff, ':');\n\n        buff[option - buff] = '\\0';\n\n        option++;\n\n        if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)\n\n            return ret;\n\n        if (!ctx->codec || !ctx->priv_data)\n\n            return -1;\n\n    } else {\n\n        option = opt;\n\n    }\n\n\n\n    o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n\n    if (!o && (!strcmp(option, \"time_base\")  || !strcmp(option, \"pixel_format\") ||\n\n               !strcmp(option, \"video_size\") || !strcmp(option, \"codec_tag\")))\n\n        o = av_opt_find(ctx, option, NULL, 0, 0);\n\n    if (!o) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                            &config->errors, \"Option not found: %s\\n\", opt);\n\n        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {\n\n            hinted = 1;\n\n            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,\n\n                                \"If '%s' is a codec private option, then prefix it with codec name, \"\n\n                                \"for example '%s:%s %s' or define codec earlier.\\n\",\n\n                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);\n\n        }\n\n    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt,\n\n                arg, av_err2str(ret));\n\n    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {\n\n        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))\n\n            return av_dict_set(dict, option, arg, AV_DICT_APPEND);\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors,\n\n                \"Redeclaring value of the option %s, previous value: %s\\n\",\n\n                opt, e->value);\n\n    } else if (av_dict_set(dict, option, arg, 0) < 0) {\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2188, "substitutes": {"opt": ["ret", "name", "append", "ext", "Opt", "term", "cho", "optim", "expr", "txt", "loc", "alt", "prop", "format", "cat", "ord", "fn", "buf", "op", "tmp", "num", "off", "options", "pos", "info", "Option", "slice", "err", "temp", "p", "attr", "text", "token", "object", "value", "obj", "cp", "error", "path", "lit", "iter", "OP", "qt", "timeout"], "arg": ["argument", "call", "parser", "ext", "loc", "cat", "Arg", "bin", "end", "op", "enc", "g", "mac", "proc", "args", "or", "oc", "exec", "obj", "alloc", "cmd", "sec", "lib", "path", "val", "all", "input", "rc"], "type": ["call", "name", "time", "key", "pe", "method", "ype", "url", "class", "field", "prop", "format", "id", "kind", "open", "parent", "op", " TYPE", "ty", "comp", "pre", "y", "i", "num", "code", "info", "event", "Type", "style", " typ", "block", "p", "col", "ref", "attr", "flag", "value", "pc", "action", "t", "types", "error", "path", "sort", "TYPE", "all", "typ", "port"], "config": ["cal", "acl", "queue", "get", "ct", "client", "options", "args", "database", "crit", "ec", "control", "fig", "sc", "gui", "qa", "cp", "manager", "fi", "ext", "spec", "not", "anc", "context", "mc", "cl", "que", "bc", "concept", "component", "FIG", "utils", "state", "lc", "Config", "conf", "text", "comm", "driver", "lib", "data", "complete", "proc", "project", "cont", "settings", "ini", "document", "feat", "json", "content", "c", "design", "ref", "front", "cache", "cmd", "sec", "obj", "connection", "req", "cf", "reg", "uc", "drivers", "service", "conn", "pg", "con", "output", "dc", "cn", "ca", "ctrl", "exec", "subject", "full", "support", "cfg", "dat", "inc", "console", "desc", "rc"], "e": ["esc", "oe", "ei", "pe", "ee", "ea", "ent", "g", "ef", "m", "er", "event", "c", "p", "E", "et", "es", "eval", "exec", "object", "obj", "node", "en", "ev", "b", "entity", "ace", "ae"], "o": ["oa", "ob", "O", "fo", "ow", "so", "no", "cho", "a", "ant", "oe", "bo", "go", "vo", "oi", "n", "co", "k", "parent", "mo", "op", "ko", "i", "j", "po", "pos", "wo", "oo", "info", "c", "p", "ao", "custom", "f", "ro", "zo", "oc", "u", "object", "obj", "one", "v", "s", "b", "t", "os", "error", "online", "io", "lo", "ando", "ot", "ou"], "option": ["route", "cho", "key", "command", "current", "always", "alt", "open", "options", "Option", "event", "index", "x", "archive", "object", "comment", "optional", "name", "term", "image", "equ", "position", "parent", "off", "package", "post", "or", "p", "custom", "length", "text", "v", "user", "version", "offset", "esc", "anything", "byte", "optim", "loc", "cat", "section", "op", "search", "i", "function", "result", "c", "app", "value", "ion", "connection", "error", "argument", "null", "append", "no", "alias", "item", "entry", "attribute", "number", "style", "block", "ption", "token", "element", "OP"], "codec_name": ["codecftype", "codesc_id", "codef_name", "codecskey", "codescsprefix", "codeca_name", "codecsname", "codef_names", "codesc_prefix", "codeca_type", "codec_num", "codecfnum", "codesc_key", "codecsid", "codec_id", "codec_Name", "codecfdata", "codeca_num", "codecsprefix", "codec2num", "codesc_name", "codescsid", "codec_data", "codec_prefix", "codescsname", "codec2type", "codef_Name", "codef_key", "codec2data", "codec_names", "codec_type", "codec2name", "codec_key", "codecfname", "codescskey", "codeca_data"], "buff": ["ob", "hack", "cli", "Buff", "txt", " buf", "empty", "pb", "feed", "ind", "xff", "comment", "cp", "uf", "rt", "fi", "bind", "ff", "ext", "utf", "bag", "zip", "gz", "buf", "tmp", "off", "bl", "text", "amp", "lit", "nd", "qq", "data", "loc", "cat", "op", "loop", "info", "cb", "cond", "back", "pad", "ref", "app", "br", "bt", "cmd", "obj", "bb", "prefix", "cf", "mem", "append", "buffer", "bo", "alias", "eb", "callback", "orig", "ph", "tab", "now", "rb", "box", "bug", "ch", "bf", "wb", "gb", "bg", "fb", "b", "font", "uff", "diff", " buffer", "rc"], "ctx": ["cm", "conf", "cli", "this", "cs", "conn", "context", "anc", "cc", "cl", "txt", "mc", "Context", "loc", "ct", "aux", "nc", "bc", "voc", "cci", "scope", "concept", "client", "buf", "cas", "auc", "fp", "tx", "coll", "cb", "sync", "dc", "pkg", "cu", "c", "cv", "xc", "lc", "cn", "sq", "ctrl", "ca", "exec", "la", "sc", "cmd", "vc", "wcs", "git", "cca", "pc", "connection", "handler", "qa", "cp", "cf", "conv", "ci", "cfg", " context", "sci", "uc", "rc"], "dict": ["dn", "def", "stat", "conn", "data", "pillar", "d", "co", "cat", "head", "con", "client", "arr", "ict", "file", "coll", "df", "sync", "ini", "utils", "dir", "json", "pkg", "ind", "block", "state", "doc", "col", "cache", "conf", "cmd", "obj", "sum", "tree", "lib", "table", "cf", "clean", "session", "gen", "view", "dat", "init", "inc", "map", "diff", "db"], "guessed_codec_id": ["guessed_codoc_info", "guessed_codeca_ids", "guessed_codac_id", "guessed_codoc_ids", "guessed_codec__id", "guessed_codec__ids", "guessed_codac_name", "guessed_codeca_id", "guessed_codeca_name", "guessed_codoc_name", "guessed_codec_ids", "guessed_codec_info", "guessed_codoc_id", "guessed_codec_name", "guessed_codac_type", "guessed_codec_type", "guessed_codac_ids", "guessed_codec__name"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n\n{\n\n    CPUMoxieState *env = &cpu->env;\n\n\n\n    /* Local cache for the instruction opcode.  */\n\n    int opcode;\n\n    /* Set the default instruction length.  */\n\n    int length = 2;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    /* Examine the 16-bit opcode.  */\n\n    opcode = ctx->opcode;\n\n\n\n    /* Decode instruction.  */\n\n    if (opcode & (1 << 15)) {\n\n        if (opcode & (1 << 14)) {\n\n            /* This is a Form 3 instruction.  */\n\n            int inst = (opcode >> 10 & 0xf);\n\n\n\n#define BRANCH(cond)                                                         \\\n\n    do {                                                                     \\\n\n        int l1 = gen_new_label();                                            \\\n\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n\n        gen_set_label(l1);                                                   \\\n\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n\n        ctx->bstate = BS_BRANCH;                                             \\\n\n    } while (0)\n\n\n\n            switch (inst) {\n\n            case 0x00: /* beq */\n\n                BRANCH(TCG_COND_EQ);\n\n                break;\n\n            case 0x01: /* bne */\n\n                BRANCH(TCG_COND_NE);\n\n                break;\n\n            case 0x02: /* blt */\n\n                BRANCH(TCG_COND_LT);\n\n                break;\n\n            case 0x03: /* bgt */\n\n                BRANCH(TCG_COND_GT);\n\n                break;\n\n            case 0x04: /* bltu */\n\n                BRANCH(TCG_COND_LTU);\n\n                break;\n\n            case 0x05: /* bgtu */\n\n                BRANCH(TCG_COND_GTU);\n\n                break;\n\n            case 0x06: /* bge */\n\n                BRANCH(TCG_COND_GE);\n\n                break;\n\n            case 0x07: /* ble */\n\n                BRANCH(TCG_COND_LE);\n\n                break;\n\n            case 0x08: /* bgeu */\n\n                BRANCH(TCG_COND_GEU);\n\n                break;\n\n            case 0x09: /* bleu */\n\n                BRANCH(TCG_COND_LEU);\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /* This is a Form 2 instruction.  */\n\n            int inst = (opcode >> 12 & 0x3);\n\n            switch (inst) {\n\n            case 0x00: /* inc */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x01: /* dec */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x02: /* gsr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            case 0x03: /* ssr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_st_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* This is a Form 1 instruction.  */\n\n        int inst = opcode >> 8;\n\n        switch (inst) {\n\n        case 0x00: /* nop */\n\n            break;\n\n        case 0x01: /* ldi.l (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x02: /* mov (register-to-register) */\n\n            {\n\n                int dest  = (opcode >> 4) & 0xf;\n\n                int src = opcode & 0xf;\n\n                tcg_gen_mov_i32(REG(dest), REG(src));\n\n            }\n\n            break;\n\n        case 0x03: /* jsra */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n\n\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x04: /* ret */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                /* The new $sp is the old $fp.  */\n\n                tcg_gen_mov_i32(REG(1), REG(0));\n\n\n\n                /* Pop the frame pointer.  */\n\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n\n\n                /* Pop the return address and skip over the static chain\n\n                   slot.  */\n\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n                tcg_temp_free_i32(t1);\n\n\n\n                /* Jump... */\n\n                tcg_gen_exit_tb(0);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x05: /* add.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x06: /* push */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                tcg_gen_subi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x07: /* pop */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x08: /* lda.l */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x09: /* sta.l */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0a: /* ld.l (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0b: /* st.l */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0c: /* ldo.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0d: /* sto.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0e: /* cmp */\n\n            {\n\n                int a  = (opcode >> 4) & 0xf;\n\n                int b  = opcode & 0xf;\n\n\n\n                tcg_gen_mov_i32(cc_a, REG(a));\n\n                tcg_gen_mov_i32(cc_b, REG(b));\n\n            }\n\n            break;\n\n        case 0x19: /* jsr */\n\n            {\n\n                int fnreg = (opcode >> 4) & 0xf;\n\n\n\n                /* Load the stack pointer into T0.  */\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x1a: /* jmpa */\n\n            {\n\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1b: /* ldi.b (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1c: /* ld.b (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1d: /* lda.b */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1e: /* st.b */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1f: /* sta.b */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x20: /* ldi.s (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x21: /* ld.s (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x22: /* lda.s */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x23: /* st.s */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x24: /* sta.s */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x25: /* jmp */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x26: /* and */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x27: /* lshr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x28: /* ashl */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x29: /* sub.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2a: /* neg */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_neg_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2b: /* or */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2c: /* not */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_not_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2d: /* ashr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x2e: /* xor */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2f: /* mul.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x30: /* swi */\n\n            {\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(temp, val);\n\n                tcg_gen_st_i32(temp, cpu_env,\n\n                               offsetof(CPUMoxieState, sregs[3]));\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x31: /* div.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x32: /* udiv.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x33: /* mod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x34: /* umod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x35: /* brk */\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n            }\n\n            break;\n\n        case 0x36: /* ldo.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x37: /* sto.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x38: /* ldo.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: /* sto.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n", "idx": 2190, "substitutes": {"cpu": ["pl", "vm", "cli", "gpu", "prem", "roc", "conn", "context", "gc", "cpp", "clock", "uci", "nc", "px", "prof", "nic", "pb", "instance", "CPU", "proc", "fp", "CP", "c", "ocr", "pu", "lc", "cn", "cache", "hp", "processor", "pty", "linux", "pc", "cca", "node", "cp", "cmp", "coe", "sci", "gp", "que", "fi"], "ctx": ["fc", "cli", "cs", "kb", "hw", "conn", "context", "cc", "mc", "cpp", "Context", "fw", "loc", "ct", "ck", "bc", "proc", "tx", "config", "pkg", "cu", "c", "cv", "xc", "sc", "sq", "ca", "exec", "ctrl", "obj", "vc", "cmd", "pc", "connection", "cca", "qa", "cp", "cmp", "cf", "support", "ci", " context", "sci", "rc"], "env": ["eu", "oa", "np", "cli", "ext", "qv", "conn", "context", "equ", "environment", "global", "profile", "ea", "priv", "scope", "enc", "eni", "code", "args", "err", "style", "config", "impl", "ec", "exc", "Environment", "cv", "fg", "stack", "ptr", "cache", "en", "ev", "online", "cfg", "dat", "qt", "que", "console", "desc", "db"], "opcode": [" opCode", "hopCode", "ipcount", "ipframe", "opercall", "OpCode", "optionCode", "opcall", "hopcode", "optcount", "optionce", "Opcode", "operce", "pcode", "ipCode", "pcall", " opcodes", "hopcodes", "pCode", "optioncod", "optCode", " opcod", " opce", "Opcodes", "opCode", "pcodes", " opcall", "opercode", "ipcodes", "optcod", "hopce", "optcode", "pframe", "operCode", "opcodes", "opcod", "optce", "ipcode", "optioncode", "pcount", "Opcomb", "opercodes", "optcodes", "opercomb", "opcomb", "optframe", "opframe", "opcount", "opce", " opcomb"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n", "idx": 2195, "substitutes": {"s": ["sg", "js", "service", "opens", "cs", "sup", "http", "ss", "ctx", "ts", "ges", "self", "sb", "cpp", "d", "n", "is", "ions", "i", "g", "bis", "ses", "sf", "sync", "settings", "tests", "sets", "ds", "status", "ps", "gs", "native", "ns", "h", "c", "p", "services", "w", "e", "us", "f", "es", "setup", "ches", "sys", "sq", "sports", "u", "lines", "south", "o", "b", "su", "t", "site", "session", "os", "hs", "states", "se", "fs", "si", "ssl"], "opc": ["copci", "optc", "ospc", "ipcu", "OPc", " opz", "hopf", "ortc", "ospcu", "hoppc", "opt", "copcs", "ripcs", "ospci", "opcs", "libf", " opf", "ospcs", "oppcs", " opcs", "oopn", "opn", "copg", "ippc", "oopt", "operf", "optf", "ripc", "libpc", "copc", "opercs", "opercu", "upc", "OPci", "opcu", "ovcu", " opcu", "hopc", "opci", "copz", "oopcit", "copf", "opcit", "ipc", "ropg", " oplc", "ipcs", "upf", "libcs", "ripf", "ortcs", "oppcu", " opci", "oopc", "ovcs", "opf", "OPcu", "copcit", " opcit", "ovf", "optcu", "uplc", "oppc", "hopt", "ipf", "ropz", "oplc", "operc", " opg", "optlc", "ropf", "ortpc", "ripcu", "hopn", "ropn", "ortf", "oopci", "ropt", "ipci", "libc", " oppc", "oppf", "oopf", "opg", "ropc", "opz", "upcu", "OPcs", "hopcs", "ovc"], "r": ["dr", "q", "rs", "gr", "h", "rr", "d", "n", "lr", "rf", "kr", "i", "g", "rb", "m", "nr", "er", "ir", "fr", "z", "l", "p", "pr", "or", "w", "e", "c", "f", "ro", "br", "ar", "u", "R", "range", "o", "v", "sr", "b", "rx", "rar", "re", "reg", "rt", "rh", "rc"], "rm": ["rg", "dr", "cm", "vm", "rage", "mx", "rn", "bm", "rr", "rob", "lr", "rf", "vre", "adr", "rb", "m", "nr", "RM", "cr", "md", "rpm", "dm", "rl", "ref", "rem", "ro", "pm", "ore", "rd", "rom", "nm", "mr", "b", "rx", "rar", "re", "addr", "rt", "vr", "ril", "reg", "rh"], "x": ["xes", "q", "xt", "d", "n", "y", "i", "g", "m", "code", "tx", "lex", "X", "xs", "z", "xp", "xx", "h", "l", "p", "xc", "c", "w", "e", "f", "ar", "u", "o", "v", "ix", "b", "rx", "re", "ex", "rc"], "rex": ["Rex", "test", " cx", "xa", "rice", "cross", "ext", "nex", "breaker", "nexus", "xf", "gru", "frac", "gre", "com", "xxxx", "orig", "fax", "xy", "dx", "proxy", "rep", "none", "flex", "tx", "lex", "number", "xs", "coord", "xp", "abc", "fe", "xx", "exc", "result", "xc", "xff", "EX", "xb", "rench", "rax", "rez", "ticket", "xxxxxxxx", "prefix", "xe", "su", "cmp", "rx", "pex", "sex", "re", "gal", "ux", "cone", "ex", "res", "xi", "wx"]}}
{"project": "qemu", "commit_id": "d0d5d0e31a874d592741a088c2c5071bae164dbf", "target": 1, "func": "qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n\n                            uint64_t bytes, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QEMUIOVector hd_qiov;\n\n    struct iovec iov;\n\n    z_stream strm;\n\n    int ret, out_len;\n\n    uint8_t *buf, *out_buf;\n\n    uint64_t cluster_offset;\n\n\n\n    if (bytes == 0) {\n\n        /* align end of file to a sector boundary to ease reading with\n\n           sector based I/Os */\n\n        cluster_offset = bdrv_getlength(bs->file->bs);\n\n        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, s->cluster_size);\n\n    if (bytes != s->cluster_size) {\n\n        if (bytes > s->cluster_size ||\n\n            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)\n\n        {\n\n            qemu_vfree(buf);\n\n            return -EINVAL;\n\n        }\n\n        /* Zero-pad last write if image size is not cluster aligned */\n\n        memset(buf + bytes, 0, s->cluster_size - bytes);\n\n    }\n\n    qemu_iovec_to_buf(qiov, 0, buf, bytes);\n\n\n\n    out_buf = g_malloc(s->cluster_size);\n\n\n\n    /* best compression, small window, no zlib header */\n\n    memset(&strm, 0, sizeof(strm));\n\n    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n\n                       Z_DEFLATED, -12,\n\n                       9, Z_DEFAULT_STRATEGY);\n\n    if (ret != 0) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    strm.avail_in = s->cluster_size;\n\n    strm.next_in = (uint8_t *)buf;\n\n    strm.avail_out = s->cluster_size;\n\n    strm.next_out = out_buf;\n\n\n\n    ret = deflate(&strm, Z_FINISH);\n\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n\n        deflateEnd(&strm);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    out_len = strm.next_out - out_buf;\n\n\n\n    deflateEnd(&strm);\n\n\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n\n        /* could not compress: write normal cluster */\n\n        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        goto success;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset =\n\n        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);\n\n    if (!cluster_offset) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    cluster_offset &= s->cluster_offset_mask;\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    iov = (struct iovec) {\n\n        .iov_base   = out_buf,\n\n        .iov_len    = out_len,\n\n    };\n\n    qemu_iovec_init_external(&hd_qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n\n    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\nsuccess:\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(buf);\n\n    g_free(out_buf);\n\n    return ret;\n\n}\n", "idx": 2213, "substitutes": {"s": ["js", "service", "cs", "ss", "stat", "spec", "sa", "ts", "qs", "sb", "rs", "current", "n", "aws", "is", "ins", "sl", "ims", "bis", "g", "i", "ses", "ls", "uns", "sync", "settings", "xs", "outs", "ds", "sets", "ps", "gs", "ns", "l", "c", "p", "sie", "state", "vs", "us", "services", "f", "self", "es", "sys", "sc", "e", "sq", "sec", "iss", "stats", "less", "b", "su", "S", "os", "session", "ks", "sim", "bs", "states", "se", "fs", "si", "sym", "obs", "ssl"], "hd_qiov": [" struct_qqilo", " struct_darrison", " struct_diov", " struct_qarrison", " struct_qqarrison", " struct_qiov", " struct_dqilo", " struct_dilo", " struct_dqarrison", " struct_dqicho", " struct_qicho", " struct_qqiov", " struct_qqicho", " struct_dicho", " struct_qilo", " struct_dqiov"], "iov": ["ilo", " bloc", " mechanism", "uno", "oren", "liv", "USB", "urate", "ouple", " barr", "uda", "sbm", "ressor", "ibl", "oyer", "oco", " hive", "iop", " io", " ensemble", "airo", " gif", "rolet", " bio", "NV", " vec", "io", " liv"], "strm": ["STRms", "striam", "czmn", "strimm", "Strf", "stran", "STRmid", "STRam", "brp", "strmid", "strimid", "strum", "striM", "crms", "TRm", "Strmid", "TRp", "czf", "strf", " strmn", " strumm", "lerumm", "Strmm", "stram", "Strum", "strms", "trM", " strp", "Stram", " tran", "Strm", "strumm", " stran", "eltimm", "strp", "lerum", "drm", "TRM", "eltm", "eltM", " trM", "StrM", "strmt", " dran", "strma", " drM", "strM", "frms", "Strimm", "drms", "lerm", " strum", "crbm", "arrmm", " trm", "STRm", "brm", "Strumm", "arrM", "frM", "trbm", "strmn", "TRma", "czM", " drma", "brM", "STRmt", "arrm", "frmt", "czm", "trm", "STRM", "trms", "trp", "STRmm", "trmm", " strf", " strimm", "strim", "Strms", "frp", "crm", " drm", "Strp", "brma", "lerM", " strma", "eltum", "frm", "drbm", "crM", "arram", " strmm", "Strmt", " trma", "drM", "strbm", "STRp", " strM", "strmm", "Strmn"], "ret": ["match", "arg", "fun", "no", "att", "mt", "ext", "def", "bit", "hash", "success", " Ret", "alt", "cat", "cur", "pet", "rets", "num", "pass", "rep", "code", "lt", "cb", "nt", "err", "rev", "str", "ft", "feat", "Ret", "back", "bf", "reply", "sat", "result", "pret", "fin", "try", "len", "flag", "ref", "gt", "resp", "fat", "sec", "RET", "magic", "valid", "lit", "reg", "re", "val", "rt", "let", "pt", "part", "det", "res", "db", "mem"], "out_len": [" out_pos", " out_Len", "out_pos", "out_val", "in_val", "in_Len", "out_limit", "out_Len", "in_len", "out_lon", "in_limit", " out_lon"], "buf": ["ff", "fd", "src", "buffer", "ctx", "offset", "bag", "Buff", "byte", "queue", "mem", "fw", "data", "loc", "aux", "bc", "buff", "pb", "tmp", "cas", "off", "batch", "uber", "lim", "rb", "fp", "box", "cb", "pool", "config", "feed", "home", "pkg", "block", "cv", "Buffer", "vec", "f", "wb", "len", "br", "cache", "cap", "text", "cmd", "alloc", "fb", "b", "seq", "req", "cf", "bytes", "uf", "msg", "uc", "rc", "port"], "out_buf": ["out_queue", "outJuf", "in_buffer", "outJbuffer", "out2buff", "out_uf", " out_fp", " out_cb", "outJbuf", "out_buffer", " out_buffer", " out_buff", "out_fp", "outingfp", "outinguf", "outingbuffer", " out_uf", "in_file", "in_buf", "out2buf", "in_uf", "outingbuf", "out_cb", "outJfile", "in_cb", "out2cb", "in_queue", "out_file", "out2buffer", "out_buff"], "cluster_offset": ["cluster_Offset", "cluster_pos", "clancer_Offset", "cluster_size", "clancer_off", "clancer_offset", "cluster_off", "cluster_position", "clancer_pos"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229, "substitutes": {"ctx": ["fc", "cm", "cli", "gpu", "src", "cs", "hw", "conn", "context", "anc", "cc", "cl", "gc", "Context", "cpp", "loc", "ct", "ck", "nc", "bc", "tc", "cus", "cas", "component", "tx", "cb", "ch", "config", "crit", "ce", "pkg", "cu", "c", "cv", "xc", "css", "lc", "cpu", "cn", "ca", "sc", "wcs", "ctrl", "cmd", "vc", "cca", "pc", "qa", "cp", "cmp", "req", "cf", "ci", "cfg", "sci", "rc"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2246, "substitutes": {"ysrc": ["src", "sysuc", "sysrc", "gsource", "cssrc", "csrc", "vsource", "gsc", "ysource", "source", "gssrc", "sssrc", "ssource", "ssuc", "ysuc", "syssrc", "sc", "yssrc", "vssrc", "csource", "vsuc", "csc", "sysource", "gsrc", "ssrc", "ysc"], "usrc": ["USrc", "Usrc", "lsdc", "usroc", "lsroc", "lssrc", "usdc", " ussrc", "usrid", "USsrc", "vsroc", "ussrc", "ssroc", "sssrc", "Ussrc", "USroc", "vsrid", "Usroc", " usroc", "lsrc", "Usrid", "vssrc", "USrid", " usdc", "ssrc", "ssdc"], "vsrc": ["wrc", "vsource", " vrc", "vssource", "wsource", " vstat", "vsstat", "vources", "vstat", "vsources", "vrc", "wources", " vsource", "vssrc", " vources", "wsrc", "wstat"], "dst": ["Dsrc", "idsrc", "dsth", "idst", "adsc", "idsc", "dsc", "adst", "dsts", "idsts", "dST", "idST", "adsth", "adsts", "adsrc", " dsc", " dsts", "dsrc", "adST", "Dsth", "Dsc", " dST", "idsth", "Dst"], "height": ["resolution", "crop", "above", "Height", "dim", "image", "high", "window", "distance", "wrap", "ty", "gap", "max", "y", "direction", "style", "slice", "pad", "h", "alpha", "thin", "deep", "rank", "images", "size", "length", "input", "hd", "density", "square", "padding", "pull", "depth", "img", "shape", "bottom", "dist"], "lumStride": ["lumScri", "lumSTri", "lumbStrap", "lumSTrap", "lumbSTrap", "lumStrrap", "lumStoreride", "lumbstri", "lumbstride", "lumstro", "lumStrride", "lumbStri", "lumstride", "lumbSTride", "lumStrip", "lumSTride", "lumStro", "lumScride", "lumbStride", "lumStorerap", "lumbstrite", "lumbstro", "lumbStrip", "lumstri", "lumStorerip", "lumSTrip", "lumSTro", "lumStrrip", "lumbSTro", "lumbStro", "lumstrite", "lumbStrite", "lumScrite", "lumbSTrip", "lumStrro", "lumScro", "lumStri", "lumSTrite", "lumStorero", "lumStrap", "lumStrite"], "chromStride": ["chromStipe", "chromSyncrip", "chromStyridden", "chromstrite", "chromSyncride", "chromStyrip", "chromstrate", "chromStandro", "chromstride", "chelStyrip", "chelStyride", "chromSTro", "chromStandrate", "chromSyncipe", "chromStridden", "chelStride", "chelStridden", "chromSTrip", "romStrate", "romSTro", "chromStrip", "romStride", "chelStipe", "chromstro", "chromSTridden", "romSTrate", "romSTride", "chromSTrate", "romSTrite", "romStrite", "chromSTride", "romStro", "chromStyride", "chelStrip", "chromSTipe", "chromStandride", "chromStyipe", "chelStyipe", "chromSyncridden", "chromStro", "chromSTrite", "chelStyridden", "chromStrite", "chromStandrite", "chromStrate"], "dstStride": ["dststore", "dstSTro", "dstStro", "dscSTride", "dscSTide", "dblStro", "dstStrite", "dblStride", "dstRestro", "dscStrip", "dblSTro", "dstSTrite", "dstStrip", "dblSTride", "dscStride", "dscSTrip", "dblSTrite", "dstStrride", "dstSTrip", "dblStrite", "dststrite", "dstRestride", "dstRestrip", "dstStrore", "dstStore", "dstStide", "dstSTride", "dstRestide", "dstStrro", "dstSTide", "dststride", "dstSTore", "dblStore", "dblSTore", "dststro", "dscStro", "dstStrrite", "dscSTro", "dscStide"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n\n                                GAChannelMethod method, int fd)\n\n{\n\n    int ret;\n\n    c->method = method;\n\n\n\n    switch (c->method) {\n\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NONBLOCK\n\n#ifndef CONFIG_SOLARIS\n\n                           | O_ASYNC\n\n#endif\n\n                           );\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n#ifdef CONFIG_SOLARIS\n\n        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n\n        if (ret == -1) {\n\n            g_critical(\"error setting event mask for channel: %s\",\n\n                       strerror(errno));\n\n            close(fd);\n\n            return false;\n\n        }\n\n#endif\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_ISA_SERIAL: {\n\n        struct termios tio;\n\n\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n        tcgetattr(fd, &tio);\n\n        /* set up serial port for non-canonical, dumb byte streaming */\n\n        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n\n                         IMAXBEL);\n\n        tio.c_oflag = 0;\n\n        tio.c_lflag = 0;\n\n        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n\n        /* 1 available byte min or reads will block (we'll set non-blocking\n\n         * elsewhere, else we have to deal with read()=0 instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2265, "substitutes": {"c": ["cm", "call", "cs", "channel", "l", "conn", "cc", "mc", "r", "d", "n", "co", "cat", "bc", "cy", "con", "k", "client", "enc", "g", "ac", "m", "cr", "ch", "cod", "C", "ec", "dc", "ce", "h", "p", "cv", "xc", "cu", "e", "lc", "f", "jc", "self", "w", "cn", "ca", "sc", "cd", "exec", "col", "vc", "pc", "v", "cp", "cmp", "b", "ci", "can"], "path": ["walk", "mount", "name", "key", "anc", "context", "txt", "data", "url", "filename", "loc", "type", "prop", "id", "parent", "end", "enc", "directory", "inner", "Path", "file", "dest", "pattern", "pointer", "config", "temp", "feed", "PATH", "p", "w", "text", "ath", "handler", "cmd", "wd", "prefix", "full", "location", "mode", "root", "dir", "rh", "port"], "method": ["route", "call", "this", "name", "version", "channel", "time", "mod", "context", "process", "url", "class", "send", "header", "operation", "type", "prop", "month", "format", "METHOD", "record", "fn", "end", "instance", "model", "package", "m", "direction", "tr", "md", "status", "config", "func", "function", "h", "man", "block", "attr", "text", "message", "eth", "mp", "cmd", "round", "sign", "sort", "module", "session", "manager", "Method", "transform", "nom", "me", "mode", "rh"], "fd": ["dn", "fed", "xd", "dl", "director", "file", "sf", "direction", "cod", "feed", "ind", "f", "fm", "fee", "af", "dir", "fi", "fs", "wat", "fun", "ld", "ff", "da", "pd", "raf", "ln", "buf", "fp", "fe", "hd", "length", "bd", " fid", "handler", "wd", "ird", "vd", "td", "nd", "fc", "FD", "sd", "fw", "loc", "ad", "fan", "cb", "cond", "ds", "pid", "func", "function", "writer", "front", "fx", "wind", "cf", "dd", "fen", "fa", "d", "lf", "fl", "fn", "draft", "dy", "df", "ft", "fr", "dt", "md", "bf", "dc", "wb", "draw", "cd", "fat", "fb", "dat", "gd", "db"], "ret": ["match", "arg", "fun", "att", "mt", "ext", "def", "bit", " Ret", "success", "data", "url", "xt", "alt", "cat", "pet", "rets", "fit", "arr", "pass", " RET", "fail", "bl", "code", "lt", "nt", "ft", "rev", "back", "reply", "status", "Ret", "rc", "bf", "pat", "pub", "result", "len", "red", "flag", "f", "ref", "rl", "gt", "resp", "art", "obj", "sr", "RET", "al", "lit", "reg", "re", "val", "rt", "run", "af", "let", "part", "det", "res", "mem"], "tio": ["gio", "tauto", "fortios", " tao", "Tiao", "Tiol", "torao", "tiao", "dtios", "tigo", "Tfolio", "torios", "dtior", "untios", "Tauto", "dicho", "torui", "untio", "ttios", "bitigo", " tcho", "piol", "Tco", "tco", "tiol", "pios", " trio", "Ttimeout", "Trio", "Tigo", " tout", "dco", "atio", " tco", " tfolio", " tui", "atiol", "dio", "tui", "gios", "bitios", " tior", "untrio", " tigo", "Tior", "tout", "ttimeout", "atios", "untout", "fui", "giao", "fio", "tcho", " ticho", "forttimeout", "bitauto", "fortio", "tao", "Tout", "dtio", " tiao", "ttio", "Ticho", "dtiao", "bitio", " tauto", "fao", " ttimeout", "trio", "fortfolio", "tios", " tios", "tior", "pio", "ttcho", "atior", "torio", "gcho", "dios", "tfolio", "ttiao", "ticho", "Tios", "pior", "dtimeout", "Tio", "fios"]}}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 2280, "substitutes": {"f": ["fo", "fc", "ff", "fd", "tf", "q", "fen", "xf", "fw", "form", "fa", "d", "lf", "buff", "fn", "rf", "F", "j", "g", "i", "m", "fp", "file", "sf", "df", "fr", "info", "bf", "feed", "fe", "fi", "l", "c", "e", "self", "conf", "fx", "handler", "fm", "v", "fb", "b", "cf", "uf", "af", "fs", "inf"], "block": ["lock", "row", "large", "key", "panel", "queue", "clock", "open", "job", "empty", "index", "address", "ack", "x", "prev", "object", "blocking", "join", "comment", "manager", "limit", "board", "map", "pack", "flow", "unit", "group", "name", "image", "type", "position", "bc", "id", "chain", "frame", "off", "batch", "bl", "tx", "work", "state", "layout", "lc", "length", "Block", "plugin", "session", "link", "base", "offset", "channel", "loc", "out", "page", "loop", "pre", "info", "cb", "pool", "function", "ref", "cache", "other", "node", "error", "module", "close", "run", "call", "ban", "check", "no", "buffer", "broad", "header", "un", "label", "none", "box", "sync", "coll", "number", "config", "ip", "range", "b", "clean", "full", "line", "view", "part"], "mr": ["dr", "mn", "rg", "cm", "vm", "mt", "rs", "gr", "spec", "wk", "mc", "mx", "bm", "wr", "ml", "km", "rr", "MR", "r", "yr", "ru", "mer", "mi", "mm", "lr", "kr", "rf", "rb", "m", "nr", "er", "fr", "cr", "tr", "md", "hm", "bro", "pr", "rpm", "rl", "dm", "br", "attr", "rm", "wm", "pm", "fm", "rd", "sr", "asm", "bridge", "shr", "manager", "module", "rt", "vr", "rh", "Mr"], "p": ["np", "vp", "offset", "q", "lp", "pe", "pi", "r", "n", "page", "ap", "pg", "sp", "pb", "pair", "api", "py", "pre", "i", "po", "tp", "j", "m", "proc", "fp", "P", "pid", "pointer", "pool", "ps", "address", "pa", "ip", "c", "pr", "l", "e", "u", "jp", "o", "pc", "point", "bp", "v", "cp", "b", "t", "wp", "pp", "port"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2297, "substitutes": {"pkt": ["apct", "pcht", "spacket", "apacket", "cpnt", "opacket", " pett", "apett", "opkt", " packet", " pelt", " pct", "pnt", "Pnt", "apkt", "cpcht", " pwk", "pet", " pet", " pnt", "apnt", "peth", "Pett", "cpkt", "ppnt", "ppacket", "ppcht", "opet", " pcht", "pwk", "pelt", "opnt", " peth", "Pelt", "cpacket", "Pet", "Pwk", "pett", "spelt", "Peth", "ppkt", "pct", "spkt", "opwk", "packet", "spct", "cpct", "Pkt", "Pct", "apeth", "Packet"], "pa": [" PA", "base", "apa", "ba", "ppa", "sa", " ma", "pi", "fa", "Pa", "ma", "PA", "ota", "ta", "na", "ha", "api", "ada", "ka", "po", "pai", "au", "sea", "p", "ua", "cpu", "pu", "ara", "ca", "ana", "jp", "ia", "pc", "cp", "ama", "wa", "opa", "eta", "va", "LA", "qua", " Pa", " sa"], "len": ["lic", "base", "ld", "lem", "lan", "li", "lp", "elt", "Len", "zi", "data", "loc", "n", "alt", "lf", "lu", "ln", "fl", "pre", "pos", "lim", "ls", "lt", "nt", "rev", "str", "z", "lon", "l", "ler", "fin", "lc", "length", "vec", " length", "size", "f", "la", "el", "en", "hl", "lib", "seq", "lin", "gen", "lit", "late", "val", "count", "part", "limit", "le"], "ventry": ["ventrys", "elementrying", "ventrey", "emptri", "questry", "cfry", "gentrying", "nightri", "vertrey", "pprying", "ppry", "nightrying", "ventary", "eventcy", "questri", "ppri", "gentrys", "emptrys", "emptries", "emptray", "questary", "nightry", "eventary", "entary", "ventray", "vertri", "ventcy", "emptrying", "gentri", "questries", "elementri", "emptrey", "entry", "entray", "elementry", "vertry", "nightrys", "ventri", "questray", "eventries", "eventrying", "emptry", "cfcy", "eventry", "cfries", "entries", "ventrying", "emptcy", "eventri", "elementrey", "vertrying", "gentry", "eventray", "eventrys", "ventries", "cfrys", "pprys"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *buf1, const uint16_t *ubuf0,\n\n                     const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                     const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                     const uint16_t *abuf1, uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target)\n\n{\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n\n\n        output_pixels(i * 4, Y1, U, Y2, V);\n\n    }\n\n}\n", "idx": 2298, "substitutes": {"i": ["cli", "yi", "li", "gi", "key", "ii", "zi", "chi", "ui", "oi", "pi", "r", "d", "I", "n", "di", "type", "is", "id", "mi", "it", "iu", "k", "ij", "api", "j", "y", "iii", "m", "ri", "info", "ti", "ini", "index", "z", "multi", "source", "ai", "ie", "x", "l", "hi", "p", "phi", "h", "w", "e", "ip", "f", "c", "bi", "adi", "isi", "u", "ori", "o", "v", "ki", "iv", "b", "ix", "qi", "ik", "uri", "ci", "io", "fi", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,\n\n                                              int linesize,\n\n                                              int block_w, int block_h,\n\n                                              int src_x, int src_y,\n\n                                              int w, int h,\n\n                                              emu_edge_core_func *core_fn)\n\n{\n\n    int start_y, start_x, end_y, end_x, src_y_add = 0;\n\n\n\n    if (src_y >= h) {\n\n        src_y_add = h - 1 - src_y;\n\n        src_y     = h - 1;\n\n    } else if (src_y <= -block_h) {\n\n        src_y_add = 1 - block_h - src_y;\n\n        src_y     = 1 - block_h;\n\n    }\n\n    if (src_x >= w) {\n\n        src   += w - 1 - src_x;\n\n        src_x  = w - 1;\n\n    } else if (src_x <= -block_w) {\n\n        src   += 1 - block_w - src_x;\n\n        src_x  = 1 - block_w;\n\n    }\n\n\n\n    start_y = FFMAX(0, -src_y);\n\n    start_x = FFMAX(0, -src_x);\n\n    end_y   = FFMIN(block_h, h-src_y);\n\n    end_x   = FFMIN(block_w, w-src_x);\n\n    av_assert2(start_x < end_x && block_w > 0);\n\n    av_assert2(start_y < end_y && block_h > 0);\n\n\n\n    // fill in the to-be-copied part plus all above/below\n\n    src += (src_y_add + start_y) * linesize + start_x;\n\n    buf += start_x;\n\n    core_fn(buf, src, linesize, start_y, end_y,\n\n            block_h, start_x, end_x, block_w);\n\n}\n", "idx": 2300, "substitutes": {"buf": ["fd", "buffer", "ctx", "offset", "bag", "array", "sb", "queue", "data", "loc", "bc", "buff", "pb", "tmp", "cas", "rb", "proc", "dest", "cb", "pool", "config", "bus", "block", "cv", "Buffer", "vec", "ptr", "stack", "ref", "br", "gb", "stream", "cmd", "alloc", "seq", "fb", "b", "cmp", "conv", "uf", "img", "count", "msg", "uc", "rc", "port"], "src": ["fc", "sub", "rib", "buffer", "ctx", "sup", "split", "stat", "rs", "spec", "sb", "image", "url", "loc", "rob", "send", "bc", "sl", "cur", "gz", "comp", "rb", "proc", "secure", "dest", "sync", "cb", "slice", "source", "feat", "config", "scenes", "st", "sel", "start", "attr", "sc", "sq", "gb", "stream", "sec", "bg", "sr", "seq", "rss", "gl", "inst", "sur", "b", "img", "support", "uc", "rect", "input", "dist", "rc", "ssl"], "linesize": ["lightssize", "lightsization", "pagesIZE", "linesization", "postsization", " linesization", "blockssize", " linesIZE", "linesized", "planesization", "pagesization", "paramsized", " linesized", "paramsization", "lightsized", "postsized", "lightsize", "paramsize", "planesize", "pagesize", "linessize", "planesized", "linesIZE", " linessize", "postsize", "blocksize", "blocksization", "postsIZE", "planessize", "paramsIZE", "pagessize", "blocksIZE"], "block_w": ["block_work", " block_work", "block64h", "blockingh", "block00wx", "block_fw", "blockings", "block67win", "blockacwt", "node_w", "block_x", "block_y", "lock_x", "nodeacwin", "blockacw", "block24w", "block25work", "block00rw", "block24wx", "node_x", "lock_h", "block_wx", "block_s", "blockIdh", "blockacwx", "blockingx", " block_wx", "lock_s", "node_sh", " block_x", "block67w", "block_sw", "nodeacx", "nodeacw", " block_rw", "block00h", "blockacws", "blockacsh", "block_sh", "blockIdw", "block24rw", "blockacwin", "blockach", "block00y", "lock_rw", "blockacsw", " block_sw", "blockIdwork", "block25h", " block_fw", "block_win", "block64wx", "lock_w", "blockacx", "blockingw", "block67x", "block00w", "lock_y", "block25w", "node_win", "block_wt", "block67sh", " block_wt", "block_ws", " block_ws", "block25fw", "block24h", "block64w", "block64sw", "block_rw", "blockIdfw", "nodeacsh"], "block_h": ["block_hw", "blocknw", "block_x", "block_y", "Block_hw", "block_hs", "block_bh", "block53hw", "block24w", "block55hs", "Block_bh", "lock_h", "Block_h", "block12gh", "block_oh", " block_oh", "block_loc", "lock_hw", " block_hs", "block67w", "block2h", "block_wa", "block53y", "block00h", "block00x", "block_gh", "block67h", "block55h", "block24hw", "block53w", " block_y", " block_loc", "block00y", "Block_ih", "block2x", "lock_w", "Block_w", "lock_y", "block_ih", "block55y", "block00ih", "block67loc", "block12w", "blocknhw", " block_wa", "block67gh", "blocknbh", "block55wa", "block12loc", "block24bh", "block2y", "Block_x", "block24h", "block2ih", "blocknh", " block_gh", "block53h", "Block_y", "block12h"], "src_x": ["src2y", "source_z", "block_x", "block_z", "block_y", "src_ady", "src2w", "srcqx", "src_n", "srcqz", "src___y", " src_h", "src2h", "source_ady", "source_X", " src_z", "sup_w", "srcqy", "sup_X", "source_xd", "block_n", "srcqady", "src_w", "sup_y", "src_X", "src2x", "source_x", "src___z", "source_y", "src_xd", "src_z", "src___n", "src_h", "src___x", "sup_x", " src_w"], "src_y": ["src2y", "src_yo", "block_x", "src_ny", "block_y", "srcureya", "src2w", "srcqx", "src_sky", " src_yo", "block_ya", "srcqyt", "srcamex", "src_yl", " src_ny", "block_yl", "srcuresky", " src_z", "srcqny", "srcacyo", "src_Y", "srcqy", "src00y", " src_yt", "src00x", "srcameyn", "src_vy", "source_Y", "srcacx", "block_sky", "src_w", "src_yn", "src_ya", "src_yt", "src2x", "source_x", "srcacy", "srcamey", "srcacyt", "source_y", "source_yo", "srcurex", "source_ya", "src_z", "src00z", " src_vy", "src00yo", "srcacya", "source_yn", "src2z", "srcacny", "srcurey", " src_w", "srcameY"], "w": ["ow", "q", "hw", "a", "cl", "fw", "r", "wt", "d", "n", "sh", "k", "W", "y", "g", "max", "aw", "wo", "m", "wh", "z", "kw", "x", "l", "p", "work", "sw", "c", "e", "f", "wb", "u", "win", "wd", "o", "v", "s", "b", "t", "wa", "ew", "iw", "wp", "rh", "wx"], "h": ["H", "q", "bh", "ih", "hw", "host", "ht", "high", "r", "d", "n", "sh", "head", "ph", "th", "k", "end", "uh", "ha", "y", "g", "m", "ah", "z", "ch", "home", "hm", "l", "hi", "c", "p", "x", "e", "hh", "f", "height", "hp", "u", "en", "o", "v", "s", "b", "t", "wa", "hs", "oh", "rh", "gh"], "core_fn": ["cr_format", "cr_function", "corePfn", "core_func", "corefuncfn", "corefuncfunction", "corePfunc", "cr_fn", "core_fs", "cr_func", "corePfunction", "corefuncfunc", "corefuncfs", "core_format", "corePformat", "core_function", "cr_fs"], "start_y": [" start_ry", "start05y", "start_ry", "start_cy", "start67yi", "start05year", " start_yi", "start_year", "end_year", "start00z", "start_yl", "startCx", "end_yn", "start67ry", "start00x", "start05yl", "startCyn", "startjry", "start67y", "startjx", "startJx", "start_ny", "end_z", "end_cy", "end_yl", "start_yn", "startJcy", "end_yi", "startjy", "startjyi", "start_yi", "start00y", "startJy", "start05x", "start67x", "startJz", "start_z", "startCy", "start00ny", "startJny", "startCyi", "end_ny"], "start_x": ["end_X", "startally", "end_width", "start_xy", "start_X", "startallx", "startallX", "start_asy", "start___xs", "end_xs", "start64y", "start00ey", "start64ey", "end_asy", "start___x", "startlx", "start00z", "end_xi", "end_ya", "start_xs", "startlwy", "start00x", "start64x", "startly", "startJx", "start___z", "start_ye", "end_z", "start_ey", "startJxi", "start___width", "end_ye", "start___asy", "start_width", "startallya", "end_xy", "start_xi", "start00y", "end_wy", "start_wy", "startJy", "start_z", "start64z", "startJxs", "startJxy", "end_ey", "startlye", "start_ya", "start___y", "startJwidth"], "end_y": ["endXx", "endLx", "end1i", " end_ny", "start_w", "end33ny", "start_yi", "endDy", "start_dy", "end2i", "endLdy", " end_ya", "end2y", "end33ya", "endXyn", "end_i", "endLy", "endLya", " endJy", "start_i", "end1w", "end33y", "endJy", "end_ya", "endXyi", "endJx", "endJya", "end_dy", "endDyi", "end33x", "end_yn", "start_yn", "endJdy", " endJx", " endJya", "end_ny", "endJny", "endDyn", "end1x", "end1y", "end_yi", "start_ya", "endDx", " endJny", "end2x", "end_w", "endXy", "end2w"], "end_x": ["endjx", "end_X", "start_ys", "end64ya", "endjyn", "end___ya", "end___ey", "start_X", "end_z", "endjy", "start_ey", "end_ys", "endJX", "end___y", "start_z", "end_ya", "endJy", "endJx", "end64y", "end_yn", "end___x", "start_yn", "end_ey", "end64yn", "start_xs", "end_xs", "start_ya", "endJz", "endjya", "end64x"]}}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2325, "substitutes": {"c": ["fc", "cm", "cs", "ctx", "cc", "mc", "com", "ct", "co", "n", "nc", "bc", "cur", "cy", "con", "tc", "enc", "g", "ac", "cr", "ch", "C", "ec", "dc", "ce", "h", "cu", "p", "xc", "l", "e", "lc", "f", "oc", "conf", "ca", "ctrl", "cd", "sc", "u", "cache", "vc", "pc", "b", "cp", "t", "cf", "ic", "ci", "uc"], "bw": ["barwd", " bws", " bwh", "bws", "adw", "lbwt", "fw", "bbwa", "Bwd", "abwd", "fwd", "bbwd", "fws", "bbwt", "barwt", "bwd", "abwh", "bwt", " bwa", "Bw", "abw", "adwh", "Bh", "barwa", "abwa", "Bws", " bwd", "fh", "bwa", "bwh", "adwa", "lbwd", "lbw", "bbw", "lbwa", "barw", "adwd"], "bh": ["yah", "bang", "ih", "obb", "sb", "bm", "lb", "hub", "ht", "ib", "db", "ph", "pb", "uh", "bl", "rb", "ah", "cb", "dq", "ch", "bf", "h", "hi", "hh", "phi", "bi", "wb", "length", "sq", "hp", "eth", "bg", "hy", "bp", "bb", "adh", "fb", "b", "abb", "bs", "kh", "rh", "sth", "xb"], "blocks": ["limits", "bars", "files", "groups", "works", "Blocks", "qs", "bags", "angles", "rules", "cells", "gets", "results", "jobs", "ins", "ools", "hops", "locks", "checks", "frames", "runs", "bits", "flows", "outs", "errors", "block", "items", "waves", "values", "words", "lines", "planes", "pages", "height", "steps", "rows", "blocking", "cycles", "books", "types", "breaks", "times", "bytes", "stores", "bs", "forces", "loads", "units", "plugins"], "i": ["layer", "cli", "yi", "hei", "ami", "li", "gi", "abi", "split", "a", "interface", "ni", "ii", "area", "zi", "ji", "ui", "pi", "oi", "d", "di", "I", "page", "id", "mi", "uli", "k", "iu", "api", "j", "iii", "eni", "ri", "info", "ti", "slice", "ini", "index", "multi", "ai", "ie", "x", "ip", "hi", "phi", "bi", "p", "e", "l", "f", "lc", "child", "u", "ori", "o", "qa", "b", "qi", "ix", "iv", "module", "uri", "ci", "io", "mu", "init", "fi", "si", "xi"]}}
{"project": "qemu", "commit_id": "cf29a570a7aa7abab66bf256fdf9540873590811", "target": 1, "func": "static void quorum_vote(QuorumAIOCB *acb)\n\n{\n\n    bool quorum = true;\n\n    int i, j, ret;\n\n    QuorumVoteValue hash;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    QuorumVoteVersion *winner;\n\n\n\n    if (quorum_has_too_much_io_failed(acb)) {\n\n        return;\n\n    }\n\n\n\n    /* get the index of the first successful read */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n", "idx": 2328, "substitutes": {"acb": ["aclmb", "ucfb", "aclb", "uck", "ancf", "akmb", "acf", "acl", "mack", "ancp", "ancbb", "actk", "racn", "akwb", " acbase", "aclf", "racb", "macd", "accb", "uclb", "acp", "ecp", "acmb", "ucp", "acgb", "ack", "macp", "accl", "aucbase", " acB", "anca", "acsgb", "aucfb", "ascbb", "aucp", "accbf", "arcf", "acclb", "ancfb", "ecfb", "eck", "acc", "acfb", "acnb", "racv", "acxb", "acbf", "macb", " acl", "raclb", "acob", "acB", "ecb", "ucbd", " acxb", "ocbb", "ancB", "ancl", " acgb", "ocb", "arcB", "arcb", "ecv", "aclsb", "ucn", "accc", "acsb", "aca", "ecc", "ecd", " acsb", "ancwb", "akp", "actxb", "ucbc", "macxb", "accfb", " acfb", "akrb", "acsxb", "actfb", "aklb", "acwb", "accbase", "ancb", "accf", "accrb", "axbb", "racl", "akbc", "macfb", " acbb", "acca", "accmb", "ecmb", "akxb", "akb", "aucb", "accn", "axbd", "ucb", "acbase", "ascb", "ucrb", "acv", "akgb", "ascfb", "actb", "acrb", "ucc", "uca", "aucf", "acbc", "ecsb", "ucnb", "ucl", "racbf", "accv", "accp", "accbb", "axnb", "acbb", " acf", "ecwb", "ucbb", " acmb", "racbb", "ecbar", "aucob", "akfb", "acbd", "macsb", "axb", "accbar", "ocl", "ACl", "eca", "acck", "ACb", "accsb", " acp", "ucv", "acbar", " acnb", "accob", "aucbf", "ascbar", " aca", "acn", "accd", "ecbb", "aucbb", "ACf", "aucl", "akbb", "ancbc", " acbd", "ecxb", "ocp", "acd", " acob", "arcbb", "ACbb", "acsbb", "ecf", "ecl"], "i": ["q", "key", "mini", "n", "im", "ij", "anti", "ti", "index", "x", "ind", "hi", "f", "u", "ori", "uri", "fi", "ami", "zi", "ji", "ui", "pi", "ib", "id", "mi", "iu", "k", "api", "y", "ri", "z", "ie", "p", "e", "ia", "v", "ix", "qi", "ik", "io", "mu", "init", "li", "a", "ni", "ii", "r", "I", "di", "m", "inner", "info", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "bi", "ki", "b", "ci", "part", "my", "xi"], "j": ["jan", "js", "li", "q", "jl", "a", "ni", "ii", "ji", "ui", "r", "jen", "d", "n", "jj", "J", "k", "aj", "ij", "uj", "y", "g", "m", "jo", "bj", "index", "z", "ie", "x", "l", "ind", "p", "jc", "e", "f", "br", "je", "u", "jp", "jet", "o", "v", "b", "qi", "si", "ja"], "ret": ["match", "rot", "arg", "fun", "att", "mt", "ext", "def", "bit", "flat", "desc", "success", "url", "out", "alt", "cat", "store", "id", "rets", "num", "pass", "fail", "lt", "nt", "ft", "err", "rev", "back", "reply", "status", "Ret", "rc", "bf", "opt", "last", "result", "bot", "et", "f", "len", "ref", "flag", "gt", "art", "en", "RET", "seq", "req", "error", "valid", "hard", "re", "reg", "val", "rt", "lit", "count", "det", "res", "mem"], "hash": ["match", "base", "lock", "total", "version", "key", " Hash", "ruby", "her", "url", "header", "alt", "bc", "id", "sh", "num", "ha", "pass", "rh", "g", "info", "number", "rev", "err", "str", "index", "status", "pool", "result", "h", "block", "ref", "Hash", "cache", "message", "dig", " hashes", "node", "sum", "sha", "seq", "error", "depth", "full", "val", "msg", "kh", "response", "res", "user", "ash"], "s": ["sg", "submit", "js", "sa", "qs", "n", "sites", "sl", "g", "ls", "ses", "sf", "args", "self", "us", "f", "set", "sys", "sc", "u", "admin", "se", "fs", "parser", "sup", "spec", "sb", "aws", "y", "xs", "sets", "p", "state", "e", "conf", "su", "site", "S", "os", "ks", "sym", "ssl", "cs", "ss", "a", "new", "r", "is", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "d", "scope", "sis", "sync", "l", "services", "w", "sq", "stats", "b", "sort", "states", "game"], "winner": ["unit", "parser", "version", "ner", "breaker", "addon", "success", "division", "n", "student", "author", "bc", "widget", "adder", "worker", "bin", "nic", "lot", "won", "num", "next", "year", "builder", "vict", "seller", "inner", "score", "master", "number", "rev", "live", "leader", "index", "status", "Winner", " winners", "runner", "ani", "slice", "result", "owner", "writer", "role", "reader", "block", "maker", "rank", "alpha", "draw", "nick", "token", "node", "creator", "win", "v", "gen", "winning", "vote", "player", "root", "init", "wp", "game"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    DeviceState *gpio_dev[7];\n\n    qemu_irq gpio_in[7][8];\n\n    qemu_irq gpio_out[7][8];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    I2CBus *i2c;\n\n    DeviceState *dev;\n\n    int i;\n\n    int j;\n\n\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n\n\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(system_memory, 0, flash);\n\n\n\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n\n\n\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n\n                      kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n\n        adc = qdev_get_gpio_in(dev, 0);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n\n                                       0x40030000 + i * 0x1000,\n\n                                       pic[timer_irq[i]]);\n\n            /* TODO: This is incorrect, but we get away with it because\n\n               the ADC output is only ever pulsed.  */\n\n            qdev_connect_gpio_out(dev, 0, adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n\n                                               pic[gpio_irq[i]]);\n\n            for (j = 0; j < 8; j++) {\n\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n\n                gpio_out[i][j] = NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n\n                                 pic[uart_irq[i]]);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void *bus;\n\n            DeviceState *sddev;\n\n            DeviceState *ssddev;\n\n\n\n            /* Some boards have both an OLED controller and SD card connected to\n\n             * the same SSI port, with the SD card chip select connected to a\n\n             * GPIO pin.  Technically the OLED chip select is connected to the\n\n             * SSI Fss pin.  We do not bother emulating that as both devices\n\n             * should never be selected simultaneously, and our OLED controller\n\n             * ignores stray 0xff commands that occur when deselecting the SD\n\n             * card.\n\n             */\n\n            bus = qdev_get_child_bus(dev, \"ssi\");\n\n\n\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n\n\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2329, "substitutes": {"kernel_filename": ["kernelprofunction", "kernelmprefix", "kernel_file", "kernel__filename", "kernelminformation", "system_file", "kernel_information", "kernelmfile", "kernelmfilename", "kernel_function", "system_function", "system_information", "kernel__file", "kernel__information", "kernelprofil", "kernelprofile", "kernel_fil", "kernel__prefix", "system_fil", "system_prefix", "system_filename", "kernel_prefix", "kernelprofilename"], "cpu_model": ["cpu_models", " cpu_module", " cpu_description", "cpuingdescription", "linuxloglocation", "cpu_filename", "linuxlogmodel", "linux_model", "linuxlogfile", "cpuemdescription", "linux_file", "cpuemmodule", " cpuemmodel", "cpu_file", "cpuemfilename", "linux_location", " cpuemfilename", "cpuingfilename", "cpulogmodels", "cpulogmodel", "cpu_location", "linux_models", "cpuingmodel", "linuxlogmodels", "cpu_description", "cpuemmodel", "cpuingmodule", " cpu_filename", "cpu_module", " cpuemdescription", "cpulogfile", "cpuloglocation", " cpuemmodule"], "board": ["flow", "server", "ban", "row", "controller", "buffer", "boards", "device", "bo", "data", "image", "Board", "flo", "brand", "stroke", "boot", "frame", "cart", "ko", "loop", "model", "hole", "coll", "bug", "database", "config", "control", "lane", "ack", "block", "bean", "design", "cache", "node", "comment", "o", "driver", "card", "bridge", "plugin", "cell", "plane", "room", "line", "deck", "table", "game"], "uart_irq": ["pu_ierc", "pu_ireQ", "pu_ierche", "pu_irche", "pu_irec", "pu_mirq", "pu_ireche", "pu_ierq", "pu_ierQ", "pu_ireq", "pu_mirc", "pu_irQ", "pu_irc", "pu_mirQ", "pu_irq", "pu_mirche"], "timer_irq": ["timer_mirQ", "timer_arQ", "timer_mirqs", "timer_ireq", "timer_mirq", "timer_ireque", "timer_arqs", "timer_arq", "timer_irQ", "timer_ireqs", "timer_ireQ", "timer_arque", "timer_irqs", "timer_mirque", "timer_irque"], "gpio_addr": ["gpios_address", "gpios_addr", "gpio_devices", "gpio_address", "gpios_dev", "gpios_devices"], "gpio_irq": ["gpio_arQ", "gpio_arq", "gpio_mirq", "gpio_miriq", "gpio_ireque", "gpio_irque", "gpio_mirque", "gpio_ireq", "gpio_arque", "gpio_irQ", "gpio_mirQ", "gpio_ireiq", "gpio_iriq", "gpio_ireQ", "gpio_ariq"], "pic": ["fc", "ig", "cam", "li", "Pic", "mc", "mic", "image", "mini", "picture", "bc", "cci", "nic", "mac", "ac", "proc", "scan", "file", "sync", "mag", "capt", "feat", "ec", "pict", "bi", "lc", "cache", "gui", "pins", "pc", "plan", "lib", "plugin", "ic", "module", "las", "img", "fi", "pin", "avi", "xi"], "gpio_dev": ["gpio_info", "gpios_info", "gpios_dev", "gpios_out", "gpio_device", "gpios_device"], "gpio_in": ["gpi_in", "gpio_inc", "gpi_ins", "gpi_inc", "gpi_out", "gpio_ins"], "gpio_out": ["gpio_outs", "gpi_in", "gpi_outs", "gpio__in", "gpio_again", "gpio__again", "gpi_out", "gpio__outs", "gpio__out", "gpi_again"], "adc": ["adm", "odc", "udm", "udf", "amdsc", "odsc", "udsc", "amdc", "udc", "adsc", "amdm", "adf", "amdf", "odm", "odf"], "sram_size": ["sramxsized", "sgram_name", "sram_name", "sgram_size", "sram_sized", "siam_Size", "sram_capacity", "sram_Size", "sgram_offset", "sgram_num", "sramxsize", "siam_capacity", "sram_num", "sgram_sized", "sram_offset", "sgram_width", "sgram_scale", "sram_width", "sramxscale", "siam_size", "sramxoffset", "sram_scale"], "flash_size": ["flashallsize", " flash_range", "flashaclength", "feed_sized", " flash_sum", "flash96chan", "flash_sized", "flash48style", "flash_white", "feed48white", "disk48scale", "flash96size", "flashalllength", "flash96white", "disk_scale", "flash48chan", "feed_chan", "flash_style", "feed48sized", "disk48offset", "flashallbytes", "feed48size", "flash48offset", "flash_chan", "flash_scale", "flash48white", "feed48chan", "flashallsum", "flash48scale", "disk48style", "disk48size", "flash_bytes", "flash_sum", "flash___scale", "disk_size", "feed_size", "flash_offset", " flash_bytes", "flashallrange", "flash48sized", "flash48size", "feed_white", "flash_length", "disk_offset", "flash_range", "flash___size", " flash_length", "flash___offset", "flashacsize", "flashacrange", "disk_style", "flash96sized", "flash___style"], "i2c": ["i2C", "i5C", "ui2C", "i4c", "ui2c", "ui2lc", "i2dc", "i4C", "i2lc", "i4lc", "i5dc", "i5c", "i4dc", "i5lc", "ui2dc"], "dev": ["serial", "cam", "conn", "device", "data", "mini", "ver", "devices", "boot", "Dev", "mac", "pos", "info", "pub", "feature", "block", "pu", "app", "conf", "loader", " device", "ev", "mode", "debug", "user", "mem"], "i": ["a", "ii", "r", "d", "I", "n", "is", "k", "y", "g", "m", "z", "x", "l", "c", "p", "h", "w", "e", "f", "u", "o", "v", "s", "b", "in"], "j": ["js", "ii", "ji", "jit", "d", "jj", "n", "J", "job", "it", "aj", "k", "im", "ij", "uj", "m", "z", "p", "f", "jp", "jet", "v", "b", "ja"], "sram": ["sperse", "scam", "ssra", "psram", "ssream", "psmem", "sra", "ascm", "asrum", "srum", "psrum", "Scam", "asram", "tsgram", "bsgram", " scm", "tsram", "asgram", "Sram", "smem", "psgram", "psra", "sream", "ssflash", "bsream", "sflash", "ssram", " smem", "bsra", " srum", "Sflash", "psperse", "Sgram", "sscam", "ssgram", " sgram", "pscm", "psream", " sflash", "bsram", "tsperse", " sperse", " scam", "tsmem", "scm", "sgram"], "flash": ["serial", "route", "fast", "ban", "row", "http", "Flash", "facebook", "fish", "large", "flat", "array", "zip", "form", "image", "broad", "small", "browser", "light", "spin", "fl", "video", "fire", "fox", "boot", "pass", "scan", "pixel", "sync", "fr", "slice", "bug", "flight", "silver", "push", "fly", "feed", "feature", "raw", "bolt", "sw", "layout", "zero", "design", "f", "FL", "cache", "shadow", "brush", "las", "transform", "low", "view", "pack"], "system_memory": ["systemallocation", "systemalradius", "system32memory", "objectalradius", "system_disk", "system_manager", "shared_image", "shared_memory", "accessMdisk", "shared_area", "access_usage", "system_radius", "systemalcamera", " system_message", "system32camera", "accessMusage", "objectalmemory", "system32location", "systemMdisk", "systemMusage", "systemMmanager", "accessMmanager", "shared_audio", "systemMmemory", "system_camera", "access_memory", " system_media", "system_area", " system_network", "system32radius", "objectallocation", "access_disk", "system_audio", "access_manager", "object_location", "objectalcamera", "systemalmemory", "accessMmemory", "system_usage", "system_image", "object_camera", "object_radius", "system_media", "system_message", "object_memory", "system_network", "system_location"]}}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}", "idx": 2334, "substitutes": {"env": ["eu", "np", "inel", "server", "ctx", "extra", "conn", "context", "environment", "global", "nc", "dict", "priv", "ea", "scope", "end", "empty", "ne", "tmp", "here", "enc", "next", "eni", "inner", "code", "args", "ep", "config", "ec", "exc", "Environment", "p", "cv", "vs", "dev", "e", "stack", "eval", "app", "cache", "conf", "loader", "core", "exec", "el", "node", "en", "v", "ev", "NV", "En", "net", "console", "export", "db"], "penv": ["fenchev", "finvt", "stenv", " pencode", "enx", "venvt", "fenp", "penchev", "venve", "pinve", "senvs", "finve", "senh", "Penvt", "renchev", "fencode", "penvt", "fenj", "pnf", "sench", "pench", "pinvt", "fenh", "penvin", "renvin", "fenvs", "pnx", "fenu", "penf", "stenh", "senv", "pencode", "envt", "venvs", " penu", "penve", "enu", "pinv", "stenvs", "penx", "senvt", "pnv", "renx", "fenvin", "stench", "fench", "pinvs", "fenf", " penp", "Penu", "venv", "senu", "finvs", "Penf", "penu", "enf", "penp", "pinu", "finv", "pinp", "senf", "pnj", "pincode", " penchev", "penvs", "fenx", " penvin", "enj", "penh", " penx", "penj", "Penv", "renv", "fenv"], "cpu_index": ["pc__size", "cpu2index", "conn67index", "pc_number", "cpu2pointer", "cpu_ind", "cpuxsize", "cpu_path", "cpu67ind", "cpu__offset", "pu_slice", "pc_index", "pu_length", " cpu_name", "conn_number", "cpu__slice", " cpu_Index", " cpu_i", "cpu_length", "conn_size", "cpu67size", "cpu_name", "cpu_slice", "cpu67index", "cpu__size", "cpu_size", "pc__number", "cpu67number", "cpu2length", "cpu2slice", "cpu__pointer", "cpuxind", "cpu__number", " cpu_path", "pu_index", "cpu__length", "pc__offset", "conn67number", "cpu_Index", "pc__index", "conn67ind", "cpuxnumber", "pc_offset", "conn_index", "conn_ind", "cpu_i", "pc_size", "pu_pointer", "cpu_pointer", "conn67size", "cpu_offset", "cpuxindex", "cpu__index", "cpu_number"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2348, "substitutes": {"ysrc": ["insrc", "sRC", "xsrc", "src", "xssrc", "sysRC", "sysrc", "iesrc", "iesrt", "ysync", "ysrt", "ysroc", "xsrt", "inssrc", "iessrc", "insRC", "sysync", "syssrc", "sysrt", "yssrc", "ysRC", "iesync", "sysroc", "xsync", "sroc", "insroc", "ssrc"], "usrc": ["ausrc", "aussrc", "urc", "udc", " ussrc", "usdc", "uource", "usource", "ussrc", "ausri", "ausdc", "ausource", " usource", "uri", " usri", " usdc", "usri"], "vsrc": ["svsrc", "ust", "fsrc", "vst", "urc", "vloc", "usource", "vsst", "svsl", "usst", "vsource", "ussrc", "ussource", "wsl", "fsource", "svsource", "vssource", "wsource", "wloc", "floc", "fsl", "vsl", "svloc", "vrc", "vssrc", "wsrc"], "dst": ["Dsrc", "bdste", "idst", " dbe", "dsts", "idsts", "ddest", "dST", "Ddest", "dbe", "bdst", "sst", "sST", " dste", "sdst", "sdsrc", "bdbe", " dsts", "dsrc", "sdest", "dste", "idste", "sdST", "idbe", "sddest", "bdsts", "Dst", "DST", "ssrc"], "height": ["resolution", "crop", "above", "Height", "dim", "image", "high", "window", "distance", "wrap", "stroke", "ty", "gap", "max", "y", "direction", "style", "pad", "h", " heights", "thin", "alpha", "deep", "rank", "images", "size", "length", "input", "hd", "density", "square", "padding", "pull", "depth", "img", "shape", "bottom", "dist"], "lumStride": ["lumScrip", "lumSTri", "lumbstride", "lumstro", "lumStrride", "lumbStri", "lumstride", "lumStrip", "lumSTride", "lumStro", "lumScride", "lumbStrrip", "lumbStride", "lumStrri", "lumbstrite", "lumbStrip", "lumbstro", "lumstri", "lumbStrride", "lumbstrip", "lumstrip", "lumSTrip", "lumSTro", "lumStrrip", "lumbStrri", "lumbStro", "lumstrite", "lumbStrite", "lumScrite", "lumStrro", "lumScro", "lumStri", "lumSTrite", "lumbStrro", "lumStrite"], "chromStride": ["chromStrri", "homStride", "chromstrite", "chromStri", "chromSTerve", "homStrri", "chromsterve", "chromUrite", "romstrite", "chromstride", "homStric", "chromEstride", "chromUro", "chromStric", "romstride", "homStrrip", "chromStrric", "chromSTro", "romstro", "chromStrrip", "homStrric", "homStrip", "chromSTri", "chromStrip", "chromSTric", "romStride", "chromstro", "chromEstri", "chromSterve", "chromEstrip", "homStri", "chromSTride", "romStrite", "chromEstric", "romSterve", "homStrride", "chromStrride", "romsterve", "chromStro", "chromSTrite", "chromUride", "chromStrite", "romStro", "chromUerve", "chromSTrip"], "dstStride": ["dscStrride", "dstStro", "dstTend", "dstClue", "dspStride", "dstRestro", "dscStrip", "dstStrip", "dstClend", "dscStride", "dspStue", "dscStrro", "dstStrride", "dstStend", "dstStrrip", "dstSTrip", "dstTrip", "dscStrrip", "dspStend", "dspTride", "dstSTue", "dspStrip", "dstRestrip", "dstRestride", "dspTend", "dstStide", "dstRestide", "dstSTride", "dspTue", "dstStrro", "dstClride", "dspTrip", "dstSTend", "dstTride", "dscStro", "dstTue", "dstClrip", "dscStide", "dstStue"]}}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n", "idx": 2349, "substitutes": {"cmd": ["cm", "call", "cli", "ctx", "conn", "command", "cc", "method", "Cmd", "cat", "client", "buf", "dom", "code", "cb", "md", "func", "cod", "dc", "pkg", "c", "cookie", "ctr", "core", "ctrl", "cd", "std", "comm", "node", "obj", "cp", "plugin", "req", "module", "cf", "cmp", "msg", "cfg"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int vqa_decode_init(AVCodecContext *avctx)\n\n{\n\n    VqaContext *s = (VqaContext *)avctx->priv_data;\n\n    unsigned char *vqa_header;\n\n    int i, j, codebook_index;;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    avctx->has_b_frames = 0;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the extradata made it */\n\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n\n\n\n\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n", "idx": 2358, "substitutes": {"avctx": ["afcontext", "navcm", " avctl", "afcup", "afkb", " avcu", "afloc", "avecas", "ovcf", "navctl", "avcontext", "afwcs", "afcp", "aveconfig", "avcm", "AVcontext", "afcmp", "avecu", "ovcontext", "verwcs", "avkb", "avectx", "avecf", "afctx", "navctx", "AVcp", "avcf", "AVctl", "avcb", "avcp", "afcm", "abcf", "avconfig", "aucontext", "abcontext", "verctx", "avecmp", "avcas", "avewcs", " avloc", "afcas", "abcmp", " avcm", "AVconfig", "avecb", "auctx", "accountcontext", "accountctx", "ovctx", "aucb", "abctx", "avecup", "afcu", "navloc", " avkb", "afcf", "avctl", "aucu", "navconfig", "avwcs", "vercontext", "afconfig", "AVctx", "avecp", " avwcs", "ovcas", "accountcf", " avcontext", " avcf", "avekb", "vercf", " avconfig", "avcup", "accountcup", "navcontext", "avloc", "avecontext", "avcu", "avcmp", "afcb"], "s": ["sg", "js", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "args", "storage", "vs", "f", "sys", "sc", "se", "fs", "parts", "spec", "ts", "sb", "aws", "uns", "xs", "sv", "sets", "p", "e", "lines", "conf", "less", "su", "S", "t", "session", "ks", "os", "its", "bs", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "o", "si", "server", "service", "http", "ops", "d", "results", "ms", "comments", "params", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "vqa_header": ["vqua_header", "vca_buffer", "vasa_comment", "vasa_main", "vqa2header", "vqa64token", "vqa_token", "vqa_buffer", "vqaOpart", "vca_block", "vcca_border", "vqa00header", "vga_header", "vcca_header", "vqa_head", "vqa00part", "vqa_request", "vqadhead", "vasa_version", "vqa_main", "vista_header", "vca_version", "vqua64token", "vqa2version", "vqua64header", "vqa_version", "vqadmain", "vqaamversion", "vqaamblock", "vqua_main", "vqa67header", "vqa_center", "vqadheader", "vqa00center", "vcca_buffer", "vcca_description", "vqa00request", "vista_center", "vqaamheader", "vqa_metadata", "vqa67center", "vqa_message", "vqa67part", "vqa_comment", "vasa_header", "vga_head", "vqua64main", "vga_message", "vqa64head", "vqaOrequest", "vqa_description", "vqa_block", "vqadcomment", "vqa_border", "vca_header", "vasa_buffer", "vqaammetadata", "vista67part", "vqa64header", "vqua_token", "vqua64head", "vista67header", "vista67request", "vqaOheader", "vqaOcenter", "vqaambuffer", "vasa_head", "vasa_metadata", "vqa67request", "vqa2buffer", "vqua_head", "vista_part", "vqa_part", "vista67center", "vga_version", "vqa64main", "vista_request"], "i": ["yi", "li", "gi", "ni", "ii", "ji", "pi", "ui", "n", "I", "di", "is", "id", "mi", "im", "iu", "it", "api", "y", "g", "ri", "eni", "info", "ti", "ini", "index", "z", "ai", "ie", "ip", "ind", "l", "p", "phi", "bi", "f", "u", "ki", "v", "o", "qi", "vi", "ik", "ix", "uri", "ci", "io", "fi", "si", "in", "xi"], "j": ["xi", "js", "li", "q", "jl", "key", "em", "ii", "ji", "jit", "ui", "jen", "d", "n", "jj", "position", "J", "oj", "job", "it", "k", "aj", "th", "ij", "uj", "off", "y", "py", "pos", "g", "m", "jo", "kj", "fr", "z", "index", "ie", "h", "ind", "l", "p", "x", "jc", "size", "f", "jam", "br", "je", "jp", "jet", "dj", "obj", "o", "v", "b", "qi", "vi", "si", "ja"], "codebook_index": ["codebookacindex", "codebreak_point", "codebook_condition", "codebook__point", "codeBOOKPcondition", "codebookPi", "codeBOOK_condition", "codeBOOKPindex", "codebookaccount", "codeBOOKPcount", "codebook___min", "codebook_info", "codebookPcondition", "codesheet_slice", "codebox_size", "codebook___index", "codebookenloop", "codebook_count", "codebreak_ind", "codesheet_min", "codebook__info", "codebook_position", "codeBOOK_i", "codebreak_index", "codeBOOKPi", "codebook__index", "codesheet_size", "codesheet_loop", "codebox_length", "codebox_label", "codebookaci", "codebox_index", "codebookPcount", "codebook___position", "codebook___condition", "codeBOOK_count", "codesheet_position", "codebook_size", "codebookenslice", "codebreak_info", "codesheet_condition", "codebook_min", "codebook_ind", "codebook_label", "codebook__ind", "codebook_i", "codebook_slice", "codebook_point", "codebookPindex", "codebook_loop", "codebookenindex", "codebookensize", "codesheet_index", "codebookaccondition", "codebook_length", "codeBOOK_index"]}}
{"project": "FFmpeg", "commit_id": "25bcf24d4d0faf0191923be8afac8f67ca98b500", "target": 0, "func": "static int open_output_file(OptionsContext *o, const char *filename)\n\n{\n\n    AVFormatContext *oc;\n\n    int i, j, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputFile *of;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n    AVDictionary *unused_opts = NULL;\n\n    AVDictionaryEntry *e = NULL;\n\n\n\n    if (configure_complex_filters() < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error configuring filters.\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {\n\n        o->stop_time = INT64_MAX;\n\n        av_log(NULL, AV_LOG_WARNING, \"-t and -to cannot be used together; using -t.\\n\");\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {\n\n        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;\n\n        if (o->stop_time <= start_time) {\n\n            av_log(NULL, AV_LOG_WARNING, \"-to value smaller than -ss; ignoring -to.\\n\");\n\n            o->stop_time = INT64_MAX;\n\n        } else {\n\n            o->recording_time = o->stop_time - start_time;\n\n        }\n\n    }\n\n\n\n    GROW_ARRAY(output_files, nb_output_files);\n\n    of = av_mallocz(sizeof(*of));\n\n    if (!of)\n\n        exit_program(1);\n\n    output_files[nb_output_files - 1] = of;\n\n\n\n    of->ost_index      = nb_output_streams;\n\n    of->recording_time = o->recording_time;\n\n    of->start_time     = o->start_time;\n\n    of->limit_filesize = o->limit_filesize;\n\n    of->shortest       = o->shortest;\n\n    av_dict_copy(&of->opts, o->g->format_opts, 0);\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n\n    if (!oc) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n\n\n    of->ctx = oc;\n\n    if (o->recording_time != INT64_MAX)\n\n        oc->duration = o->recording_time;\n\n\n\n    file_oformat= oc->oformat;\n\n    oc->interrupt_callback = int_cb;\n\n\n\n    /* create streams for all unlabeled output pads */\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        FilterGraph *fg = filtergraphs[i];\n\n        for (j = 0; j < fg->nb_outputs; j++) {\n\n            OutputFilter *ofilter = fg->outputs[j];\n\n\n\n            if (!ofilter->out_tmp || ofilter->out_tmp->name)\n\n                continue;\n\n\n\n            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,\n\n                                          ofilter->out_tmp->pad_idx)) {\n\n            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;\n\n            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;\n\n            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;\n\n            }\n\n            init_output_filter(ofilter, o, oc);\n\n        }\n\n    }\n\n\n\n    /* ffserver seeking with date=... needs a date reference */\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int err = parse_option(o, \"metadata\", \"creation_time=now\", options);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") && !override_ffserver &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int j;\n\n        /* special case for files sent to ffserver: we get the stream\n\n           parameters from ffserver */\n\n        int err = read_ffserver_streams(o, oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n\n            ost = output_streams[j];\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if(ist->st->codec->codec_type == ost->st->codec->codec_type){\n\n                    ost->sync_ist= ist;\n\n                    ost->source_index= i;\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(\"anull\");\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(\"null\");\n\n                    ist->discard = 0;\n\n                    ist->st->discard = AVDISCARD_NONE;\n\n                    break;\n\n                }\n\n            }\n\n            if(!ost->sync_ist){\n\n                av_log(NULL, AV_LOG_FATAL, \"Missing %s stream which is required by this ffm\\n\", av_get_media_type_string(ost->st->codec->codec_type));\n\n                exit_program(1);\n\n            }\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        char *subtitle_codec_name = NULL;\n\n        /* pick the \"best\" stream of each type */\n\n\n\n        /* video: highest resolution */\n\n        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                int new_area;\n\n                ist = input_streams[i];\n\n                new_area = ist->st->codec->width * ist->st->codec->height;\n\n                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                    new_area = 1;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    new_area > area) {\n\n                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                        continue;\n\n                    area = new_area;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_video_stream(o, oc, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_audio_stream(o, oc, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, \"s\");\n\n        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    new_subtitle_stream(o, oc, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            if (map->linklabel) {\n\n                FilterGraph *fg;\n\n                OutputFilter *ofilter = NULL;\n\n                int j, k;\n\n\n\n                for (j = 0; j < nb_filtergraphs; j++) {\n\n                    fg = filtergraphs[j];\n\n                    for (k = 0; k < fg->nb_outputs; k++) {\n\n                        AVFilterInOut *out = fg->outputs[k]->out_tmp;\n\n                        if (out && !strcmp(out->name, map->linklabel)) {\n\n                            ofilter = fg->outputs[k];\n\n                            goto loop_end;\n\n                        }\n\n                    }\n\n                }\n\nloop_end:\n\n                if (!ofilter) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Output with label '%s' does not exist \"\n\n                           \"in any defined filter graph, or was already used elsewhere.\\n\", map->linklabel);\n\n                    exit_program(1);\n\n                }\n\n                init_output_filter(ofilter, o, oc);\n\n            } else {\n\n                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;\n\n\n\n                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];\n\n                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n\n                    continue;\n\n                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                    continue;\n\n                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n                    continue;\n\n                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)\n\n                    continue;\n\n\n\n                switch (ist->st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL, \"Cannot map stream #%d:%d - unsupported type.\\n\",\n\n                           map->file_index, map->stream_index);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle attached files */\n\n    for (i = 0; i < o->nb_attachments; i++) {\n\n        AVIOContext *pb;\n\n        uint8_t *attachment;\n\n        const char *p;\n\n        int64_t len;\n\n\n\n        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not open attachment file %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if ((len = avio_size(pb)) <= 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not get size of the attachment %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if (!(attachment = av_malloc(len))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Attachment %s too large to fit into memory.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        avio_read(pb, attachment, len);\n\n\n\n        ost = new_attachment_stream(o, oc, -1);\n\n        ost->stream_copy               = 0;\n\n        ost->attachment_filename       = o->attachments[i];\n\n        ost->finished                  = 1;\n\n        ost->st->codec->extradata      = attachment;\n\n        ost->st->codec->extradata_size = len;\n\n\n\n        p = strrchr(o->attachments[i], '/');\n\n        av_dict_set(&ost->st->metadata, \"filename\", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);\n\n        avio_close(pb);\n\n    }\n\n\n\n    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file\n\n        AVDictionaryEntry *e;\n\n        ost = output_streams[i];\n\n\n\n        if ((ost->stream_copy || ost->attachment_filename)\n\n            && (e = av_dict_get(o->g->codec_opts, \"flags\", NULL, AV_DICT_IGNORE_SUFFIX))\n\n            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n\n            if (av_opt_set(ost->st->codec, \"flags\", e->value, 0) < 0)\n\n                exit_program(1);\n\n    }\n\n\n\n    /* check if all codec options have been used */\n\n    unused_opts = strip_specifiers(o->g->codec_opts);\n\n    for (i = of->ost_index; i < nb_output_streams; i++) {\n\n        e = NULL;\n\n        while ((e = av_dict_get(output_streams[i]->opts, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX)))\n\n            av_dict_set(&unused_opts, e->key, NULL, 0);\n\n    }\n\n\n\n    e = NULL;\n\n    while ((e = av_dict_get(unused_opts, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n\n        const AVClass *class = avcodec_get_class();\n\n        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,\n\n                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);\n\n        if (!option)\n\n            continue;\n\n        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Codec AVOption %s (%s) specified for \"\n\n                   \"output file #%d (%s) is not an encoding option.\\n\", e->key,\n\n                   option->help ? option->help : \"\", nb_output_files - 1,\n\n                   filename);\n\n            exit_program(1);\n\n        }\n\n\n\n        // gop_timecode is injected by generic code but not always used\n\n        if (!strcmp(e->key, \"gop_timecode\"))\n\n            continue;\n\n\n\n        av_log(NULL, AV_LOG_WARNING, \"Codec AVOption %s (%s) specified for \"\n\n               \"output file #%d (%s) has not been used for any stream. The most \"\n\n               \"likely reason is either wrong type (e.g. a video option with \"\n\n               \"no video streams) or that it is a private option of some encoder \"\n\n               \"which was not actually used for any stream.\\n\", e->key,\n\n               option->help ? option->help : \"\", nb_output_files - 1, filename);\n\n    }\n\n    av_dict_free(&unused_opts);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid losing precious files */\n\n        assert_file_overwrite(filename);\n\n\n\n        /* open the file */\n\n        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,\n\n                              &oc->interrupt_callback,\n\n                              &of->opts)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (strcmp(oc->oformat->name, \"image2\")==0 && !av_filename_number_test(filename))\n\n        assert_file_overwrite(filename);\n\n\n\n    if (o->mux_preload) {\n\n        uint8_t buf[64];\n\n        snprintf(buf, sizeof(buf), \"%d\", (int)(o->mux_preload*AV_TIME_BASE));\n\n        av_dict_set(&of->opts, \"preload\", buf, 0);\n\n    }\n\n    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < o->nb_metadata_map; i++) {\n\n        char *p;\n\n        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);\n\n\n\n        if (in_file_index >= nb_input_files) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d while processing metadata maps\\n\", in_file_index);\n\n            exit_program(1);\n\n        }\n\n        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,\n\n                      in_file_index >= 0 ?\n\n                      input_files[in_file_index]->ctx : NULL, o);\n\n    }\n\n\n\n    /* copy chapters */\n\n    if (o->chapters_input_file >= nb_input_files) {\n\n        if (o->chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            o->chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i]->ctx->nb_chapters) {\n\n                    o->chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   o->chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (o->chapters_input_file >= 0)\n\n        copy_chapters(input_files[o->chapters_input_file], of,\n\n                      !o->metadata_chapters_manual);\n\n\n\n    /* copy global metadata by default */\n\n    if (!o->metadata_global_manual && nb_input_files){\n\n        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n        if(o->recording_time != INT64_MAX)\n\n            av_dict_set(&oc->metadata, \"duration\", NULL, 0);\n\n        av_dict_set(&oc->metadata, \"creation_time\", NULL, 0);\n\n    }\n\n    if (!o->metadata_streams_manual)\n\n        for (i = of->ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist;\n\n            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */\n\n                continue;\n\n            ist = input_streams[output_streams[i]->source_index];\n\n            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    /* process manually set metadata */\n\n    for (i = 0; i < o->nb_metadata; i++) {\n\n        AVDictionary **m;\n\n        char type, *val;\n\n        const char *stream_spec;\n\n        int index = 0, j, ret = 0;\n\n\n\n        val = strchr(o->metadata[i].u.str, '=');\n\n        if (!val) {\n\n            av_log(NULL, AV_LOG_FATAL, \"No '=' character in metadata string %s.\\n\",\n\n                   o->metadata[i].u.str);\n\n            exit_program(1);\n\n        }\n\n        *val++ = 0;\n\n\n\n        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n\n        if (type == 's') {\n\n            for (j = 0; j < oc->nb_streams; j++) {\n\n                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n\n                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n                } else if (ret < 0)\n\n                    exit_program(1);\n\n            }\n\n        }\n\n        else {\n\n            switch (type) {\n\n            case 'g':\n\n                m = &oc->metadata;\n\n                break;\n\n            case 'c':\n\n                if (index < 0 || index >= oc->nb_chapters) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index);\n\n                    exit_program(1);\n\n                }\n\n                m = &oc->chapters[index]->metadata;\n\n                break;\n\n            default:\n\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier);\n\n                exit_program(1);\n\n            }\n\n            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2365, "substitutes": {"o": ["oa", "ob", "O", "ilo", "to", "ow", "fo", "so", "no", "http", "ant", "oe", "bo", "go", "vo", "oi", "n", "co", "oid", "mo", "from", "op", "ko", "off", "y", "po", "wo", "oo", "none", "ov", "oco", "OC", "l", "c", "or", "f", "iso", "original", "u", "other", "object", "obj", "b", "t", "os", "od", "online", "io", "one", "ot", "ou"], "filename": ["files", "missing", "name", "fd", "buffer", "named", "utf", "sequence", "figure", "txt", "acl", "method", "url", "binary", "format", "ename", "download", "fn", "nl", "initial", "lua", "output", "directory", "maximum", "fil", "Filename", "actual", "file", "fp", "sf", "nil", "journal", "document", "tif", "nuclear", "feat", "abl", "word", "println", "which", "dll", "f", "length", "kl", "wb", "message", "phrase", "username", "il", "nm", "prefix", "final", "path", "subject", "location", "msg", "xxx", "title"], "oc": ["ob", "fc", "oci", "ctx", "http", "ogg", "roc", "anc", "cc", "mc", "oe", "osc", "acl", "og", "oper", "loc", "co", "rec", "voc", "oid", "ocl", "op", "ocol", "off", "ocation", "toc", "ac", "oo", "ok", "om", "config", "ec", "oco", "dc", "opt", "OC", "cu", "c", "doc", "ocr", "unc", "soc", "org", "alloc", "pc", "os", "ic", "cf", "oca", "ocon", "ci", "uc", "ot", "ou", "rc"], "i": ["li", "ii", "ui", "pi", "d", "I", "n", "y", "info", "ti", "ini", "index", "ai", "x", "ip", "c", "f", "b", "ci", "io", "start", "si", "in"], "j": ["js", "jl", "key", "ji", "r", "n", "J", "job", "ij", "pos", "ok", "bj", "str", "json", "ie", "l", "c", "jc", "f", "je", "jp", "obj", "b", "ja"], "err": ["dr", "ner", "rs", "gr", "oe", "aaa", "Error", "rn", "rr", "r", "loc", "ace", "co", "ee", "fr", "ln", "orig", "der", "lr", "arr", "nil", "ah", "cb", "ir", "er", "str", "cr", "ini", "bug", "ch", "fe", "ec", "exc", "h", "ind", "result", "doc", "ler", "attr", "br", "resp", "mr", "ev", "error", "req", "var", "rar", "msg", "iter", "inc", "fi", "rh", "rc"], "file_oformat": ["file_tformat", "file_autostatic", "file_autotype", "file_ioversion", "file_iotype", "file_iostatic", "file_autoversion", "file_ttype", "file_oversion", "file_autoformat", "file_ioformat", "file_tstatic", "file_ostatic", "file_otype", "file_tversion"], "of": ["ob", "to", "vol", "after", "current", "Of", "open", "like", "from", "de", "ok", "sf", "eff", "f", "set", "oln", "object", "en", "at", "fee", "af", "on", "fi", "ot", "ol", "not", "ea", "found", "OF", "off", "ef", "request", "or", "length", "org", "alf", "less", "os", "root", "one", "response", "ow", "so", "a", "new", "og", "data", "oid", "boot", "op", "with", "om", "last", "et", "other", "obj", "orf", "ou", "oa", "orb", "it", "oft", "now", "comp", "ocation", "df", "ov", "style", "exec", "full", "part"], "ost": ["ob", "oci", "ogg", "og", "ott", "osi", "oper", "ont", "oid", "ocol", "ood", "iol", "nt", "om", "st", "oss", "ocr", "org", "art", "tt", "OST", "od", "oy", "omp", "ast", "ot", "sth"], "ist": ["dr", "ism", "oci", "ists", "isc", "IST", "alist", "asi", "osi", "ont", "ict", "asp", "irc", "ess", "oss", "et", "isu", "ista", "ais", "art", "ia", "OST", "inst", "ati", "wp", "ast", "sth", "est"], "unused_opts": ["unused_opercs", "unused_OPts", "unused_opt", "unused_copters", "unused_opcs", "unused_OPt", "unused_opert", "unused_copt", "unused_operters", "unused_OPcs", "unused_operts", "unused_copcs", "unused_OPters", "unused_opters", "unused_copts"], "e": ["eu", "oe", "ei", "ee", "r", "d", "n", "ea", "ef", "entry", "er", "eg", "ele", "ec", "ie", "c", "E", "es", "el", "en", "ev", "element", "entity", "ed", "ace", "ae"]}}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 2395, "substitutes": {"result": ["allow", "match", "ret", "lock", "buffer", "counter", "extra", "current", "memory", "complete", "global", "results", "record", "parent", "arr", "tmp", "instance", "params", "pack", "info", "master", "err", "filter", "replace", "slice", "status", "work", "order", "Result", "attr", "cache", "message", "comment", "cup", "table", "final", "manager", "valid", "session", "changes", "root", "shape", "response", "res"], "immn": ["umns", " immc", "umN", "ymn", " immmn", "ymm", "irmn", "irmnn", "umn", "immc", "imm", "mmr", "ymns", "mmn", "ymN", "immm", "imnn", "imN", "Immmn", "imns", "umm", "imr", "irmr", "immN", "Immn", "immmn", "imc", "mmnn", "immns", "irmN", "immnn", " immm", "imn", "mmN", "Immm", "Immc"], "imms": ["emms", "iemm", "emns", "imsps", "immmed", " imn", " imm", " imns", "imsns", "immps", "immed", "imps", "iemns", "imsmm", "imm", "limmn", "immm", "imsmed", "immms", "emps", "iemms", "limmm", "imsmn", "limms", "imsms", "imsm", "immns", "limns", "emn", "emm", " immm", "imn", "iemmed", "imns"], "immr": [" immrn", "imsb", " immrt", "impr", "imrr", "imsr", "imb", "immrc", " immrc", "imp", "imm1", "imrs", "Immrs", " immp", "immrs", "iemr", "irmrt", "imprn", " imm1", "Immrr", " immrr", "Immr", "imsrs", "iemrn", "immrn", "iemrr", "immrr", "immp", "immb", "imp1", "Immb", "irmp", "imr", "irmr", "immrt", "imrc", "iem1", "imprr", "imrt", "imsrr", "irmrc"], "mask": ["allow", "sub", "lock", "q", "key", "flags", "escape", "weight", "g", "ask", "code", "pixel", "x", "shift", "f", " Mask", "sum", "comment", "seq", "sign", "qa", "magic", "cover", "map", "pack", "group", "spec", "mark", "image", "sh", "id", "parent", "bits", "scan", "z", "p", "secret", "fix", "conf", "patch", "shadow", "scale", "count", "user", " masks", "layer", "offset", "skip", "a", "hash", "data", "m", "info", "filter", "h", "c", "order", "cache", "value", "asm", "shape", "match", "delay", "ban", "bit", "array", "alias", "sk", "seed", "bug", "ch", "Mask", "depth", "hide"], "e": ["eu", " elements", "level", "ss", "ize", "oe", "pe", "eps", "ee", "d", "n", "ea", " E", "y", "i", "g", "m", "er", "z", "ec", "fe", "ele", "ie", "x", "l", "c", "p", "h", "E", "w", "f", "es", "length", "size", "u", "el", "en", "o", "v", "scale", "ev", "b", "ze", "element", "ae", "se", "ed"], "levels": ["limits", "files", "sections", "level", "alls", "xes", "groups", "ss", "rs", "rules", "vals", "ries", "children", "eps", "members", "flags", "lvl", "fl", "sites", "ins", "sl", "wl", "locks", "ids", "checks", "i", "runs", "ls", "flows", "xs", "z", "cards", "tests", "index", "ps", "errors", "vel", "l", "ones", "values", "planes", "lc", "lines", "es", "length", "lins", "rows", "steps", "users", "pins", "fields", "blocks", "roots", "seq", "breaks", "codes", "depth", "inc", "drivers"], "s": ["cs", "ss", "a", "rs", "spec", "sb", "d", "n", "sites", "sl", "sk", "y", "i", "g", "m", "ls", "ses", "z", "ds", "ps", "ns", "x", "l", "c", "p", "w", "lines", "f", "es", "size", "sc", "u", "en", "o", "b", "S", "os", "se", "si"], "r": ["rg", "q", "rs", "rw", "rr", "d", "n", "k", "rf", "i", "g", "j", "rb", "m", "ra", "er", "ir", "rev", "cr", "z", "err", "x", "l", "c", "p", "h", "w", "f", "ar", "u", "R", "range", "sr", "v", "o", "rd", "b", "rx", "re", "rh", "res", "rc"], "len": ["layer", "ell", "ld", "li", "lan", "den", "lp", "elt", "Len", "loc", "d", "n", "lf", "fl", "ln", "sl", "dl", "i", "j", "pos", "m", "ls", "dy", "ll", "z", "lon", "l", "L", "ler", "lc", "length", "f", "la", "el", "min", "en", "v", "lin", "depth", "val", "count", "limit", "part", "le"]}}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n", "idx": 2400, "substitutes": {"s": ["sg", "cli", "js", "service", "src", "cs", "sup", "ss", "ops", "a", "context", "sb", "new", "r", "com", "d", "n", "is", "i", "g", "m", "ses", "sf", "sync", "source", "ds", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "sys", "sq", "u", "south", "o", "v", "b", "cmp", "t", "os", "S", "site", "support", "si", "ssl"], "list": ["call", "base", "test", "group", "nav", "null", "name", "li", "act", "local", "def", "lp", "array", "queue", "cl", "data", "current", "get", "LIST", "com", "out", "n", "dl", "id", "parent", "frame", "loop", "batch", "pre", "bl", "comp", "g", "i", "ls", "code", "ll", "info", "lex", "coll", "source", "back", "index", "pool", "config", "result", "l", "block", "p", "c", "w", "self", "lc", "set", "cache", "conf", "la", "object", "lists", "v", "table", "old", "full", "view", "List", "load", "wp", "all", "diff"], "poc": ["ipoca", "spuc", "spoc", "foca", " pocol", " puc", "puc", "ipoc", "Poc", "jpoca", "jpocol", "Pc", "sproc", "toc", "proc", "jpuc", "foc", "pocol", "tpuc", "froc", "focol", "jpc", "Poca", "tproc", "tpc", "tpocol", "tpoc", "toca", "spoca", "Puc", " pc", "tpoca", "tocol", "pc", "jpoc", "troc", "ipocol", "iproc", " poca", "tuc", "poca"], "ref_flag": ["refsflag", "refacflags", "refacflag", "ref_bit", "reference_flags", "reference_kind", "reference_bit", "refsbit", "refsflags", "ref2bit", "refackind", "ref2flags", "ref2flag", "ref_kind", "reference_flag", "ref_flags"], "ref": ["ob", "this", " reference", "url", "n", "alt", "field", "rec", "next", "err", "index", "pointer", "self", "f", "reference", "object", "af", "lab", "ff", "name", "ext", "id", "parent", "frame", "ef", "REF", "fe", "p", "aff", "e", "conf", "lib", "re", "val", "fc", "base", "nav", "ab", "new", "r", "loc", "remote", "pre", "proxy", "info", "cb", "c", "br", "cache", "el", "obj", "bb", "req", "cf", "old", "inf", "call", "null", "fact", "def", "lf", "comp", "rf", "fr", "source", "bf", "Ref", "block", "doc", "arc", "col", "rel", "fb", "b", "cmp", "part", "inc", "diff", "db"], "nb_refs": ["nb_defd", "nb_REFd", "nb_defblocks", "nb_relp", "nb_defs", "nb_relits", "nb_rels", "nb_reld", "nb_relerences", "nb_clp", "nb_REFls", "nb_childs", "nb_REFs", "nb_relblocks", "nb_refp", "nb_defls", "nb_refd", "nb_refblocks", "nb_defp", "nb_childerences", "nb_REFerences", "nb_cld", "nb_cls", "nb_refls", "nb_references", "nb_childblocks", "nb_rells", "nb_clits", "nb_childd", "nb_deferences", "nb_refits", "nb_defits"]}}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n", "idx": 2415, "substitutes": {"dc": ["dr", "fc", "DC", "ctx", "da", "dn", "roc", "ga", "anc", "context", "mc", "conn", "gc", "spec", "cc", "d", "ct", "tk", "nc", "dl", "bc", "director", "ea", "tc", "de", "cdn", "df", "dt", "cr", "ds", "ec", "abc", "c", "jc", "doc", "design", "dm", "draw", "oc", "ca", "ctrl", "cd", "vc", "cca", "cit", "cf", "cfg", "dat", "dp", "desc", "db", "rc"], "r": ["ur", "rg", "row", "w", " sr", " yr", "rs", "h", "rn", "wr", "rr", "d", "n", "ru", "type", "ry", " hr", "lr", " pr", "rf", "kr", "i", "j", "g", "rb", "m", "hr", "nr", "er", "ir", "err", "cr", "tr", "rev", "fr", "x", "l", "p", "pr", "c", "or", "e", "rl", "f", "ro", "attr", "ar", "br", "u", "R", "rd", "sr", "mr", "v", "rel", "o", "b", "rss", "t", "rx", "error", "rar", "re", "rt", "nor", "rh", "rc"], "tn": [" tr", "tun", " sr", "bn", "vt", "txt", "tu", "rn", "tty", " tw", "n", "tk", " priv", "tur", "ln", " ret", "pn", "hn", "tc", "zn", "fn", " cit", "span", " tid", "tp", "tw", "kt", "nr", "fp", "tx", " td", "ti", "dt", "TN", " reply", "kn", "tl", "btn", "isu", "cn", "token", "tt", "sn", "tm", "su", "nw", "t", " tu", " fn", "td", "nor", "rt", "qt", " TN", " rc", " args"]}}
{"project": "FFmpeg", "commit_id": "b9fa32082c71013e90eab9e9997967d2939cf4a6", "target": 1, "func": "static int vorbis_parse_id_hdr(vorbis_context *vc){\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t bl0, bl1;\n\n\n\n    if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') ||\n\n    (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||\n\n    (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (no vorbis signature). \\n\");\n\n        return 1;\n\n    }\n\n\n\n    vc->version=get_bits_long(gb, 32);    //FIXME check 0\n\n    vc->audio_channels=get_bits(gb, 8);   //FIXME check >0\n\n    vc->audio_samplerate=get_bits_long(gb, 32);   //FIXME check >0\n\n    vc->bitrate_maximum=get_bits_long(gb, 32);\n\n    vc->bitrate_nominal=get_bits_long(gb, 32);\n\n    vc->bitrate_minimum=get_bits_long(gb, 32);\n\n    bl0=get_bits(gb, 4);\n\n    bl1=get_bits(gb, 4);\n\n    vc->blocksize[0]=(1<<bl0);\n\n    vc->blocksize[1]=(1<<bl1);\n\n    if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (illegal blocksize). \\n\");\n\n        return 3;\n\n    }\n\n    // output format int16\n\n    if (vc->blocksize[1]/2 * vc->audio_channels * 2 >\n\n                                             AVCODEC_MAX_AUDIO_FRAME_SIZE) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \"Vorbis channel count makes \"\n\n               \"output packets too large.\\n\");\n\n        return 4;\n\n    }\n\n    vc->win[0]=ff_vorbis_vwin[bl0-6];\n\n    vc->win[1]=ff_vorbis_vwin[bl1-6];\n\n\n\n    if(vc->exp_bias){\n\n        int i, j;\n\n        for(j=0; j<2; j++){\n\n            float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float));\n\n            for(i=0; i<vc->blocksize[j]/2; i++)\n\n                win[i] = vc->win[j][i] * (1<<15);\n\n            vc->win[j] = win;\n\n        }\n\n    }\n\n\n\n    if ((get_bits1(gb)) == 0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (framing flag not set). \\n\");\n\n        return 2;\n\n    }\n\n\n\n    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->previous_window=0;\n\n\n\n    ff_mdct_init(&vc->mdct[0], bl0, 1);\n\n    ff_mdct_init(&vc->mdct[1], bl1, 1);\n\n\n\n    AV_DEBUG(\" vorbis version %d \\n audio_channels %d \\n audio_samplerate %d \\n bitrate_max %d \\n bitrate_nom %d \\n bitrate_min %d \\n blk_0 %d blk_1 %d \\n \",\n\n            vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]);\n\n\n\n/*\n\n    BLK=vc->blocksize[0];\n\n    for(i=0;i<BLK/2;++i) {\n\n        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));\n\n    }\n\n*/\n\n\n\n    return 0;\n\n}\n", "idx": 2424, "substitutes": {"vc": ["fc", "vm", "cli", "service", "cs", "ctx", "dn", "vp", "hw", "ga", "vt", "cc", "ant", "fw", "ct", "cat", "bc", "voc", "cci", "client", "dk", "VC", "gg", "ac", "ll", "cb", "nt", "util", "sv", "ch", "config", "vv", "dc", "ce", "cu", "c", "cv", "xc", "vs", "vg", "lc", "sys", "uv", "ctrl", "gt", "ku", "cmd", "wd", "bb", "serv", "plugin", "lv", "ic", "cf", "nv", "vd", "ci", "rt", "vr", "gd", "input", "db", "rc", "wx"], "gb": ["gio", "ogg", "gc", "lb", "url", "ge", "sl", "px", "g", "storage", "cv", "phy", "gui", "hl", "ld", "sb", "ui", "gru", "bc", "buff", "gz", "xy", "GB", "gap", "api", "gam", "jpg", "vg", "lc", "lib", "usb", "gp", "gh", "rg", "cm", "fc", "gae", "cc", "bm", "hub", "google", "gow", "boot", "gin", "cb", "cgi", "gs", "sel", "gd", "ged", "bb", "gl", "gal", "mode", "gpu", "kb", "bn", "hw", "ga", "binary", "gy", "eb", "mb", "ko", "gg", "rb", "gm", "bf", "wb", "gold", "cd", "gt", "git", "bg", "pc", "b", "ci", "cfg", " rc", "db", "rc", "game"], "bl0": ["Bl2", "fl50", "block0", "bl00", "pl5", "loc5", "pl0", "pl1", "cl1", "l00", "BL50", "col0", "pl3", "pl50", "pl2", " bl2", "BL0", "BL00", "bl50", "bo1", "BL1", "l0", "bl2", "blk", "bok", "block2", "BLk", "Bl00", "l50", "col2", " bl3", " blk", "cl0", "l2", " bl00", "Bl0", "fl0", "pl00", "block00", "fl00", "bo8", " bl8", "loc2", "bo0", "col00", "BL2", "BL8", "Bl3", "loc1", "cl50", "cl00", "col50", "fl1", "loc0", "bl3", "bl8", "Bl5", "bl5", "cl2", "Bl1", "blockk"], "bl1": ["Bl2", "BlOne", "lb0", "BLone", " bln", "plone", "bl9", "lb1", " blone", "ml4", "pl0", "plOne", "pl1", "ml2", "wl9", "ml3", "bln", "ml1", "obln", "sl4", " bl2", "Bl4", "obl1", "BL0", "sl1", "labelOne", "BL1", "label0", "label1", "bl2", "Bln", "blone", "wlone", "sl2", " blOne", "sl3", "Bl0", "lb4", "oblOne", "obl0", "bl4", "labelone", "pl9", "Bl3", "wl0", "wl1", "blOne", "bl3", "lbOne", "Bl1", "sl0", "slOne", "pl4", "BL9"], "i": ["li", "a", "ii", "ji", "pi", "d", "I", "n", "k", "ij", "m", "z", "ai", "x", "l", "c", "p", "bi", "e", "f", "o", "v", "b", "vi", "ci", "io"], "j": ["js", "li", "adj", "jl", "key", "ii", "ji", "jit", "r", "d", "n", "jj", "J", "oj", "fl", "k", "aj", "ij", "num", "uj", "g", "pos", "m", "jo", "kj", "fr", "z", "ch", "ie", "x", "l", "ind", "p", "jc", "e", "f", "br", "jp", "jet", "dj", "obj", "o", "v", "b", "ja"], "win": ["windows", "wan", "lock", "intel", "build", "spec", "conn", "device", "host", "get", "gain", "window", "vine", "weight", "bin", "con", "client", "won", "enc", "wal", "ac", "WIN", "scan", "can", "write", "inn", "native", "disk", "pad", "thin", "dev", "w", "Win", "skin", "mask", "gui", "play", "session", "screen", "gen", "start", "game"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,\n\n                                         src - (stride * 2) +\n\n                                         sizeof(uint8_t), stride, dst, stride);\n\n}\n", "idx": 2429, "substitutes": {"dst": ["datsts", "pddest", "dedsrc", "adst", "dedsts", "pdrc", "dsts", "drc", "ddest", " dsrc", "pdst", "adsts", " drc", "datrc", "adsrc", "adrc", "pdsts", " dsts", "dsrc", "dedst", "datdest", "datst", " ddest", "dedrc"], "src": ["sub", "sup", "rate", "stat", "sb", "url", "send", "rec", "sl", "cur", "grad", "gz", "comp", "usc", "rb", "secure", "dest", "sync", "cb", "source", "config", "st", "sel", "ie", "ctr", "sc", "sq", "gb", "stream", "bg", "sec", "sr", "rd", "lib", "b", "cmp", "inst", "sur", "supp", "gl", "img", "desc", "dist", "rc"], "stride": ["strided", " striding", "crider", "strone", "pride", "divided", "divise", "deriding", "Strise", "drider", "cride", "crIDE", " strise", "crided", "Strided", "strider", "drone", " strider", "Striding", "strid", "Strid", "StrIDE", " strone", " strid", "Stride", "derid", "derided", "dride", "arrider", "divider", "strise", "prIDE", "prider", " strided", "arrone", "strIDE", "arride", "deride", "striding", "Strider", "divide", "prided", "drided", "arrided"]}}
{"project": "qemu", "commit_id": "c1bf3531aecf4a0ba25bb150dd5fe21edf406c88", "target": 1, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n", "idx": 2451, "substitutes": {"peer": ["server", "http", "wrapper", "interface", "context", "pe", "host", "type", "worker", "scope", "parent", "pb", "remote", "instance", "proc", "pod", "er", "master", "request", "source", "address", "owner", "reader", "p", "ptr", "self", "loader", "node", "pc", "connection", "req", "socket", "port", "player", "pp", "ssl"], "device": ["serial", "layer", "server", "interface", "host", " dev", "devices", "type", "client", "package", "info", "password", "project", "attribute", "address", "feature", "owner", "ip", "dev", "resource", "attr", "Device", "node", "driver", "connection", "prefix", "plugin", "module", "manager", "depth", "addr", "mode", "dp", "user", "port"], "name": ["call", "named", "no", "wrapper", "key", "alias", "ni", "data", "image", "filename", "new", "type", "unknown", "ename", "id", "parent", "na", "hello", "label", "none", "info", "network", "password", "event", "create", "names", "str", "func", "address", "description", "word", "Name", "dev", "size", "nick", "self", "e", "ame", "username", "comment", "nm", "prefix", "path", "part", "NAME", "nam", "user"], "chr": [" chrc", "CHrt", "chers", "chrs", "chlr", "Chdr", "chdr", "Chlr", "CHrf", "Chnr", "qrc", "qrar", "ctrar", "chelr", "thrs", "chro", "chrt", "thrf", "ochr", "chsr", "cher", "ochrb", "CHr", "qro", "ochrt", "Chsr", " chrar", " chsr", "corlr", "ochrf", "chnr", " chnr", "chenr", " chrt", "cherb", "Chrb", "corrb", "ctro", "qrs", "corrs", "chedr", "Chr", "ctr", "Chrc", " chrf", "thr", "corr", "chrf", "Chrs", " chrb", "chrb", "qrf", "chrar", "qr", "thrc", "Chrf", "chesr", " chdr", "ctrc", "CHrb", "chrc", " chro"], "queues": ["scheues", "queueures", "queueues", "Queues", "queueue", "Queures", "scheients", "queue", "scheures", "Queue", "Queences", "querues", "querue", "queences", "queures", " queients", " queures", "querures", " queences", "queients", "queueences", "Queients", "scheences", "querences"], "nc": ["NC", "cm", "fc", "np", "mn", "cs", "dn", "ctx", "bn", "conn", "cc", "ni", "mc", "nn", "rn", "anc", "nec", "n", "ct", "aa", "bc", "ng", "cdn", "nl", "ne", "client", "enc", "kr", "auc", "network", "nt", "cb", "cr", "config", "ec", "dc", "ns", "c", "ync", "cv", "lc", "nb", "unc", "oc", "cn", "sc", "core", "sn", "pc", "nm", "nw", "cf", "nv", "ci", "net", "inc", "uc", "rc"], "s": ["sg", "server", "js", "cs", "ss", "rs", "qs", "conn", "sb", "r", "n", "sl", "ne", "enc", "g", "ls", "ses", "sync", "ds", "ps", "gs", "ns", "l", "c", "p", "css", "w", "e", "f", "es", "sys", "sq", "sc", "u", "sn", "sts", "o", "stats", "v", "su", "b", "os", "session", "socket", "fs", "si", "ssl"], "i": ["cli", "li", "gi", "counter", "ni", "ii", "ui", "pi", "oi", "r", "d", "I", "n", "di", "uni", "type", "id", "mi", "iu", "k", "j", "m", "ri", "eni", "info", "ti", "multi", "index", "ini", "z", "ai", "x", "ip", "c", "p", "hi", "bi", "l", "e", "f", "u", "jp", "o", "v", "b", "qi", "ix", "t", "uri", "ci", "io", "mu", "start", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe(AVProbeData *p)\n\n{\n\n    const uint8_t *d;\n\n\n\n    if (p->buf_size < 6)\n\n        return 0;\n\n    d = p->buf;\n\n    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {\n\n        return AVPROBE_SCORE_MAX;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2466, "substitutes": {"p": ["np", "vp", "lp", "a", "data", "r", "n", "ap", "sp", "pb", "op", "api", "i", "j", "tp", "m", "fp", "P", "ps", "pa", "l", "c", "e", "f", "u", "jp", "o", "v", "pc", "bp", "s", "b", "cp", "t", "pp"], "d": ["dr", "fd", "ld", "dn", "da", "dd", "pd", "dh", "dim", "dad", "data", "r", "n", "ad", "di", "dl", "id", "dict", "k", "de", "dom", "did", "i", "g", "j", "m", "dy", "dt", "ds", "md", "dc", "l", "c", "ind", "w", "e", "f", "bd", "u", "cd", "rd", "s", "o", "b", "t", "od", "nd", "dat", "dp", "D", "db"]}}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static void scsi_read_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad read tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_read_request(r);\n\n}\n", "idx": 2471, "substitutes": {"d": ["fd", "ld", "dd", "pd", "dh", "data", "ad", "xd", "di", "dl", "id", "i", "g", "m", "dt", "ds", "md", "z", "dc", "l", "c", "p", "dos", "dev", "w", "e", "f", "bd", "u", "cd", "o", "b", "t", "ded", "dp", "D", "gd", "db"], "tag": ["match", "test", "name", "TAG", "key", "mod", "device", "tail", "image", "rr", "class", "ad", "loc", "type", "cat", "id", "oid", "ag", "param", "code", "attribute", "bug", "str", "feat", "config", "word", "block", "p", "c", "e", "f", "length", "attr", "date", "patch", "token", "br", "comment", "o", "at", "t", "error", "tags", "reg", "Tag", "start", "desc", "db", "port"], "s": ["server", "rs", "sa", "spec", "a", "sb", "n", "is", "sl", "j", "g", "m", "ds", "l", "c", "p", "state", "w", "e", "self", "f", "sys", "ar", "u", "sq", "o", "v", "sr", "b", "S", "t", "session", "req", "se", "si", "ssl"], "r": ["ur", "rg", "dr", "q", "rs", "gr", "rr", "ru", "rec", "k", "arr", "kr", "rf", "g", "rb", "m", "hr", "ri", "nr", "entry", "er", "ir", "err", "request", "cr", "fr", "result", "h", "p", "pr", "c", "w", "e", "br", "ar", "u", "R", "sr", "v", "mr", "o", "rd", "b", "req", "t", "rx", "rar", "re", "rt", "vr", "rh", "res", "rc"]}}
{"project": "FFmpeg", "commit_id": "13ccba50d45662a15777b549b2fcd9b4621b0e01", "target": 0, "func": "static void opt_output_file(void *optctx, const char *filename)\n\n{\n\n    OptionsContext *o = optctx;\n\n    AVFormatContext *oc;\n\n    int i, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    oc = avformat_alloc_context();\n\n    if (!oc) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n\n\n    if (last_asked_format) {\n\n        file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Requested output format '%s' is not a suitable output format\\n\", last_asked_format);\n\n            exit_program(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    } else {\n\n        file_oformat = av_guess_format(NULL, filename, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Unable to find a suitable output format for '%s'\\n\",\n\n                    filename);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->oformat = file_oformat;\n\n    av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        /* special case for files sent to avserver: we get the stream\n\n           parameters from avserver */\n\n        int err = read_avserver_streams(oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        /* pick the \"best\" stream of each type */\n\n#define NEW_STREAM(type, index)\\\n\n        if (index >= 0) {\\\n\n            ost = new_ ## type ## _stream(oc);\\\n\n            ost->source_index = index;\\\n\n            ost->sync_ist     = &input_streams[index];\\\n\n            input_streams[index].discard = 0;\\\n\n        }\n\n\n\n        /* video: highest resolution */\n\n        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    ist->st->codec->width * ist->st->codec->height > area) {\n\n                    area = ist->st->codec->width * ist->st->codec->height;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(video, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(audio, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    NEW_STREAM(subtitle, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];\n\n            switch (ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;\n\n            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;\n\n            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;\n\n            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;\n\n            default:\n\n                av_log(NULL, AV_LOG_ERROR, \"Cannot map stream #%d.%d - unsupported type.\\n\",\n\n                       map->file_index, map->stream_index);\n\n                exit_program(1);\n\n            }\n\n\n\n            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;\n\n            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +\n\n                                           map->sync_stream_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    av_dict_copy(&oc->metadata, metadata, 0);\n\n    av_dict_free(&metadata);\n\n\n\n\n\n    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);\n\n    output_files[nb_output_files - 1].ctx       = oc;\n\n    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;\n\n    output_files[nb_output_files - 1].recording_time = o->recording_time;\n\n    output_files[nb_output_files - 1].start_time     = o->start_time;\n\n    output_files[nb_output_files - 1].limit_filesize = limit_filesize;\n\n    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid loosing precious files */\n\n        if (!file_overwrite &&\n\n            (strchr(filename, ':') == NULL ||\n\n             filename[1] == ':' ||\n\n             av_strstart(filename, \"file:\", NULL))) {\n\n            if (avio_check(filename, 0) == 0) {\n\n                if (!using_stdin) {\n\n                    fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename);\n\n                    fflush(stderr);\n\n                    if (!read_yesno()) {\n\n                        fprintf(stderr, \"Not overwriting - exiting\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                }\n\n                else {\n\n                    fprintf(stderr,\"File '%s' already exists. Exiting.\\n\", filename);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* open the file */\n\n        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->preload= (int)(mux_preload*AV_TIME_BASE);\n\n    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);\n\n    oc->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* copy chapters */\n\n    if (chapters_input_file >= nb_input_files) {\n\n        if (chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i].ctx->nb_chapters) {\n\n                    chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (chapters_input_file >= 0)\n\n        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < nb_meta_data_maps; i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            exit_program(1);\\\n\n        }\n\n\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = oc;\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy && nb_input_files)\n\n        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n    if (metadata_streams_autocopy)\n\n        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist = &input_streams[output_streams[i].source_index];\n\n            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_width   = 0;\n\n    frame_height  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    chapters_input_file = INT_MAX;\n\n    limit_filesize = UINT64_MAX;\n\n\n\n    av_freep(&meta_data_maps);\n\n    nb_meta_data_maps = 0;\n\n    metadata_global_autocopy   = 1;\n\n    metadata_streams_autocopy  = 1;\n\n    metadata_chapters_autocopy = 1;\n\n    av_freep(&streamid_map);\n\n    nb_streamid_map = 0;\n\n\n\n    av_dict_free(&codec_names);\n\n\n\n    av_freep(&forced_key_frames);\n\n    reset_options(o);\n\n}\n", "idx": 2502, "substitutes": {"optctx": ["optcontext", "optioncontext", "optionContext", "opcmp", "opctx", "optc", "optionsContext", "opcontext", "Optc", "optionc", "optionctx", "Optcontext", "optContext", "Optctx", "OptContext", "opContext", "optioncmp", "optionsctx", "optcmp", "optionscmp", "optionscontext", "opc"], "filename": ["figure", "txt", "url", "sheet", "maximum", "Filename", "file", "sf", "password", "description", "f", "message", "uri", "path", "location", "FIL", "name", "named", "utf", "sequence", "unknown", "format", "fp", "write", "jpg", "length", "that", "STDOUT", "text", "phrase", "final", "ako", "title", "required", "csv", "IL", "WHAT", "nl", "nil", "document", "feat", "json", "ident", "println", "setup", "size", "original", "stream", "prefix", "module", "String", "sha", "directory", "null", "fd", "buffer", "method", "binary", "header", "ename", "download", "fn", "wl", "fax", "platform", "initial", "output", "fil", "nature", "journal", "source", "status", "kn", "word", "dll", "rl", "kl", "token", "username", "il", "dyl", "provided", "subject", "FH", "whatever", "NAME", "metadata"], "o": ["ob", "oa", "O", "fo", "ow", "so", "roc", "ant", "bo", "go", "r", "n", "co", "oid", "mo", "parent", "op", "ko", "po", "oo", "m", "ok", "om", "oco", "c", "p", "w", "e", "ro", "object", "obj", "t", "os", "od", "io", "ot"], "oc": ["ob", "oci", "ow", "acs", "isc", "ctx", "http", "ogg", "roc", "anc", "osc", "mc", "cc", "acl", "og", "oper", "ace", "loc", "AC", "co", "pg", "bc", "voc", "oid", "cur", "op", "ocol", "enc", "irc", "auc", "toc", "ac", "oo", "ok", "coll", "mot", "config", "oco", "opt", "ec", "dc", "OC", "ack", "c", "cu", "word", "abc", "doc", "ocr", "unc", "org", "soc", "cache", "exec", "pc", "cca", "bb", "aco", "ucc", "ic", "os", "oca", "uc", "input", "rc"], "i": ["cli", "name", "li", "gi", "abi", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "r", "d", "I", "n", "type", "di", "mi", "it", "iu", "eni", "ri", "inner", "info", "ti", "ini", "index", "z", "slice", "multi", "ai", "x", "l", "c", "p", "ip", "bi", "adi", "e", "phi", "f", "hi", "block", "u", "idi", "ori", "v", "qi", "ix", "error", "ik", "b", "uri", "ci", "count", "io", "mu", "fi", "si", "xi"], "err": ["dr", "ise", "rage", "ner", "gr", "Error", "r", "rr", "ver", "loc", "yr", " error", "orig", "der", "raise", "lr", "eor", "arr", "end", "num", "kr", "later", "nil", "proc", "nr", "er", "ir", "fr", "str", "cr", "runner", "fe", "pr", "ler", "order", "self", "len", "aster", "br", "ar", "ctr", "arm", "resp", "sr", "mr", "finder", "error", "var", "req", "rar", "Er", "late", "msg", "iter", "count", "init", "nor", "all", "rh", "res", "in", "fer", "erer"], "file_oformat": ["file_obfill", "file_odscale", "file_oaformat", "file_otransform", "file_omethod", "file_soplot", "file6oat", "file_ojoin", "file_opprintf", "file_odversion", "file_odconfig", "file_Ofill", "file_onlinefill", "file_nformat", "file_oconfig", "file_oscale", "file_oamethod", "file_opattern", "file6otype", "file_isoform", "file_Otransform", "file_soformat", "file_ootransform", "file_roprintf", "file_Oformat", "file6oversion", "file_ootype", "file_ooprintf", "file_isoprintf", "file_oatransform", "file_nat", "file_opformat", "file_odat", "file_sofill", "file_ooform", "file_optype", "file_oplot", "file6oformat", "file_ntype", "file6odformat", "file_oafill", "file_odformat", "file_isoformat", "file_onlineformat", "file_sostore", "file_obformat", "file_onlinepattern", "file_ooformat", "file_oat", "file6odat", "file_soscale", "file_otype", "file_obedit", "file_onlineform", "file_nversion", "file_soconfig", "file_oajoin", "file_Opattern", "file_oascale", "file_odstore", "file_rotransform", "file_oaform", "file_jplot", "file_oaprintf", "file_Ojoin", "file_optransform", "file_oform", "file_isomethod", "file_oedit", "file_obplot", "file_oastore", "file_soedit", "file_oversion", "file_Oprintf", "file_rotype", "file_Omethod", "file_jedit", "file_jfill", "file_ostore", "file_odtype", "file_jformat", "file_ofill", "file_oapattern", "file_oprintf", "file_oaconfig", "file_roformat", "file_oojoin", "file6odversion", "file_Oform", "file6odtype"], "ost": ["ob", "dr", "ort", "ld", "src", "isc", "nn", "oper", "oop", "ott", "osi", "rob", "ct", "ont", "oid", "voc", "boot", "op", "tmp", "ood", "ocol", "tto", "ft", "nt", "st", "opt", "oss", "iterator", "ocr", "hop", "\u00f3", "org", "ST", "tt", "OST", "bb", "od", "os", "wp", "ast", "ot", "sth"], "ist": ["dr", "dit", "ism", "ists", "ld", "act", "rest", "IST", "alist", "asi", "tta", "osi", "aft", "sth", "adder", "edit", "ict", "asp", "pair", "iste", "pect", "aci", "lda", "ft", "ds", "feat", "mot", "st", "ess", "ind", "wx", "et", "lect", "hop", "isi", "ista", "art", "std", "wd", "iss", "rss", "sta", "inst", "ilst", "wp", "pt", "ast", "ace", "gd", "dist", "irst", "est"]}}
{"project": "qemu", "commit_id": "8653c0158c23ec592f0041ab48b83d6cc6d152fe", "target": 0, "func": "static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n", "idx": 2523, "substitutes": {"attr": ["property", "arg", "append", "att", "http", "rs", "conn", "method", "data", "annot", "tty", "rr", "r", "ad", "tag", "alt", "prop", "type", "parent", "lr", "arr", "pair", "api", "tmp", "py", "adr", "ac", "params", "rb", "args", "attribute", "err", "style", "temp", "feat", "func", "opt", "attach", "ptr", "atts", "ref", "cache", "app", "ctrl", "rat", "tt", "rel", "mr", "rad", "thread", "ev", "error", "var", "addr", "rt", "ann", "ributes", "acc"], "ret": ["base", "arg", "fun", "att", "mt", "ext", "active", " Ret", "data", "alt", "cat", "pet", "rets", "py", " RET", "rb", "code", "info", "ft", "nt", "rev", "tr", "reply", "Ret", "rc", "bf", "result", "et", "fin", "len", "ref", "flag", "resp", "obj", "std", "sr", "RET", "reg", "re", "val", "rt", "fi", "det", "res", "mem"], "cur_threads": ["cur_drawcount", "cur_threadcount", "cur_poolcount", "cur_pooles", "cur_draws", "cur_drawes", "cur_poolings", "cur_pools", "cur_Threades", "cur_Threadcount", "cur_Threadings", "cur_Threads", "cur_drawings", "cur_threadings", "cur_threades"], "idle_threads": ["idle_Threadories", "idle_processries", "idle_threades", "idle_countries", "idle_threadries", "idle_Threadries", "idle_processs", "idle_processes", "idle_processories", "idle_Threads", "idle_Threades", "idle_countories", "idle_countes", "idle_counts", "idle_threadories"]}}
{"project": "FFmpeg", "commit_id": "52a213865670ae69c1852d4d04cf41f8929abbd0", "target": 0, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2534, "substitutes": {"st": ["stage", "ist", "test", "this", "src", "rest", "ss", "stat", "ts", "sa", "sd", "sb", "d", "ct", "sam", "sp", "St", "ste", "kt", "sf", "nt", "ft", "fr", "str", "fe", "state", "sed", "sc", "ST", "art", "std", "tt", "s", "sts", "sta", "inst", "t", "station", "td", "ost", "nd", "pt", "start", "cast", "sth", "est"], "pkt": ["ipcht", " pft", "pcht", "spacket", "pka", "Pcht", "unt", "bq", "cacket", " pka", " packet", "pft", "bnt", "Pq", " pct", "pq", "uq", "pnt", "spft", "Pnt", "pet", " pet", "bkt", "spet", "cet", "Pka", "ipkt", "bct", " pcht", "ipka", "pkg", "ukt", "ipct", "uacket", "ckg", "Pet", "Pft", "Pkg", "ckt", "ipacket", "ipet", "pct", "spkt", " pkg", "packet", "backet", "Pkt", "Pct", "bft", "Packet"], "desc": ["sub", "src", "ext", "def", "esc", "extra", "txt", "data", "loc", "rec", "bc", "id", "buf", "des", "code", "dest", "info", "dep", "cb", "cont", "config", "dir", "asc", "description", "dc", "cod", "result", "cv", "doc", "lc", "Desc", "text", "sc", "meta", "en", "seq", "cmp", "pro", "diff", "uc", "dist", "rc"], "ret": ["match", "nz", "test", "fun", "no", "att", "ext", "def", "bit", "res", "success", "data", "xt", "alt", "rec", "cur", "id", "rets", "arr", "num", "score", "code", "nt", "rev", "back", "reply", "status", "Ret", "feat", "opt", "result", "best", "len", "ref", "resp", "std", "sec", "en", "RET", "seq", "lit", "reg", "re", "val", "det", "rc", "mem"], "ast": ["ist", "test", "att", "ctx", "rest", "act", "a", "sa", "anc", "sd", "ard", "host", "ab", "ad", "sam", "asting", "ap", "ma", "add", "alt", "ta", "end", "op", "api", "aw", "ac", "nt", "ft", "md", "post", "ess", "Ast", "aid", "p", "mast", "esp", "AST", "aster", "asted", "art", "std", "node", "amp", "pc", "asm", "at", "amd", "rss", "asts", "sta", "od", "inst", "old", "an", "ost", "am", "nd", "part", "ace", "cast", "sth", "est"], "sub_demuxer": ["sub_promuxeri", "sub_demexer", "sub_demuxed", "sub_demouseri", "sub_demuxera", "sub_promuxed", "sub_demxer", "sub_promxeri", "sub_promxera", "sub_demousera", "sub_demuxers", "sub_promuxera", "sub_democer", "sub_demomacheri", "sub_democers", "sub_promxers", "sub_demexera", "sub_demuxeri", "sub_promxer", "sub_promuxer", "sub_democed", "sub_demexeri", "sub_demxeri", "sub_demployer", "sub_democeri", "sub_demouser", "sub_demxers", "sub_demomacherer", "sub_demployed", "sub_demployerer", "sub_promxerer", "sub_promuxerer", "sub_demexers", "sub_promuxers", "sub_demxerer", "sub_demxera", "sub_promxed", "sub_demxed", "sub_demployeri", "sub_demomacher", "sub_demuxerer", "sub_demomachers", "sub_demployers", "sub_demousers"], "time_base": ["time_part", "time2part", "timealbase", " time_part", "time_end", "threadallbase", "time_based", " time_based", "time___end", "time_extra", "threadallformat", "thread_base", "time___size", " time_bas", "thread_format", "time_size", "time2based", " time_end", "timealsize", "time_format", "threadallextra", "time___base", "timeallextra", "time2base", " time_size", "timealend", "timeallformat", "thread_extra", "time2bas", "timeallbase", "time_bas"], "pb": ["fc", "pl", "np", "sub", "vp", "ctx", "primary", "bh", "ba", "lp", "sb", "txt", "bps", "lb", "ab", "bm", "ub", "eb", "hub", "ib", "rob", "mb", "cpp", "prot", "dl", "pg", "bc", "platform", "buf", "tc", "tmp", "api", "py", "PB", "rb", "fp", "cb", "python", "bf", "pkg", "pa", "bot", "p", "cv", "lc", "wb", "gb", "jp", "pm", "summary", "pit", "phrase", "meta", "pc", "bp", "bb", "fb", "cp", "b", "plugin", "uf", "wp", "lab", "dp", "typ", "db", "xb"], "pd": ["np", "fd", " db", " FD", "ld", " DP", "dd", "ud", " std", "lp", "ppa", "sd", "dra", "raf", "sb", " ta", "d", "PD", "xd", "dl", " cp", " cad", "py", "po", " df", "PB", " da", "tp", "fp", "cb", " td", " dc", "dt", "ds", "md", " disp", " PD", "bf", " prod", "pa", "p", "hd", "bd", "gd", "edd", "cd", "pm", "pc", " proto", "pp", " ep", " d", "vd", "td", " dd", "wp", "dp", " sd", " rc", "sth", " cd"]}}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n", "idx": 2535, "substitutes": {"machine": ["vm", "service", "interface", "alias", "mc", "image", "oper", "computer", "field", "boot", "model", "instance", "super", "m", "proc", "Machine", "company", "inner", "master", "source", "address", "state", "private", "message", "money", "object", "node", "comment", "inst", "manager", "element", "rule", "link", "line", "mode", "slave", "agent", "part"]}}
{"project": "qemu", "commit_id": "cc68890166c2c1c5003e3eeb8535e1872e239a95", "target": 0, "func": "static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd;\n\n    TCGv tmp, tmp2;\n\n\n\n    /* M profile cores use memory mapped registers instead of cp15.  */\n\n    if (arm_feature(env, ARM_FEATURE_M))\n\n\treturn 1;\n\n\n\n    if ((insn & (1 << 25)) == 0) {\n\n        if (insn & (1 << 20)) {\n\n            /* mrrc */\n\n            return 1;\n\n        }\n\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n\n        return 0;\n\n    }\n\n    if ((insn & (1 << 4)) == 0) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n\n        return 1;\n\n    }\n\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n\n        /* Wait for interrupt.  */\n\n        gen_set_pc_im(s->pc);\n\n        s->is_jmp = DISAS_WFI;\n\n        return 0;\n\n    }\n\n    rd = (insn >> 12) & 0xf;\n\n\n\n    if (cp15_tls_load_store(env, s, insn, rd))\n\n        return 0;\n\n\n\n    tmp2 = tcg_const_i32(insn);\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        tmp = new_tmp();\n\n        gen_helper_get_cp15(tmp, cpu_env, tmp2);\n\n        /* If the destination register is r15 then sets condition codes.  */\n\n        if (rd != 15)\n\n            store_reg(s, rd, tmp);\n\n        else\n\n            dead_tmp(tmp);\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        gen_helper_set_cp15(cpu_env, tmp2, tmp);\n\n        dead_tmp(tmp);\n\n        /* Normally we would always end the TB here, but Linux\n\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n\n                (insn & 0x0fff0fff) != 0x0e010f10)\n\n            gen_lookup_tb(s);\n\n    }\n\n    tcg_temp_free_i32(tmp2);\n\n    return 0;\n\n}\n", "idx": 2538, "substitutes": {"env": ["eu", "stage", "np", "server", "ctx", "conn", "esm", "ens", "txt", "dh", "sb", "context", "equ", "environment", "nc", "sl", "ea", "eng", "ne", "enc", "m", "proc", "eni", "sf", "estate", "enh", "ses", "er", "settings", "sv", "args", "config", "kn", "ec", "exc", "eve", "c", "anne", "vs", "e", "esp", "f", "conf", "exec", "viron", "en", "v", "iss", "ev", "site", "dat", "ex", "si", "ench", "ssl"], "s": ["sg", "server", "service", "cs", "ctx", "ss", "spec", "ts", "conn", "sa", "sb", "rs", "r", "d", "n", "is", "sites", "sl", "client", "y", "g", "space", "m", "ses", "proc", "sf", "args", "sync", "settings", "sv", "xs", "ds", "sets", "tests", "ps", "gs", "config", "ns", "c", "p", "sie", "services", "state", "e", "vs", "us", "secondary", "es", "f", "sys", "sq", "u", "conf", "set", "south", "sing", "en", "o", "v", "sr", "su", "site", "t", "S", "os", "b", "session", "states", "fs", "si", "ssl"], "insn": ["incl", "INSen", "insname", "INSN", "alsnan", "sinbn", "vinner", "insnan", "ainsd", "inzn", " insnan", "insz", "consp", "insnt", "ainssn", "INSl", "ainsns", "ind", "sinname", "inno", "alsn", "linsn", "lbsp", "issnan", "consn", "ressn", "insN", "outsN", "inszn", "inl", "issc", "insnc", "incp", "inns", "insyn", " insN", "resd", "insnor", " insna", "vinn", "insp", "INSnan", "inssn", "incn", "opensn", "insd", "INSnt", "lbsno", "INSp", "consyn", "INSz", "lbsn", " insyn", "insnin", "INSd", " insnc", "rulesbn", "allsn", " insno", "sinp", "vinns", "vinsn", "resns", "allsnor", "opensner", "sinn", "inyn", "resn", "insen", "alsnin", "allsns", " insen", "linsen", " inszn", "inn", "inshn", " insnt", "outsnc", "INSnc", "INShn", "insbn", "insner", "alsname", "consd", "insns", "insc", "insno", "issn", "inchn", "inbn", "outsz", " insd", "sinnan", "innor", "inN", " insz", "opensns", "rulesn", "INSnor", "linsner", "allsp", "insna", "inp", "INSns", "openssn", "issnin", "linssn", "lbszn", "linsns", "alsc", "INSname", "ainsn", "INSna", "outsn", "sinnt", "rulesN", "INSn", " insc", "alsnt", " inssn", "linsna", "insl", "linsnt", " insns", "sinN", " insp", " insnin", "inhn", "rulesp"], "rd": ["dr", "rg", "raid", "ld", "fd", "rod", "rest", "dd", "rs", "pd", "dra", "sd", "rw", "ARR", "rn", "wr", "rr", "r", "xd", "rob", "ru", "d", "ord", "lr", "rf", "rb", "dy", "ri", "ra", "hr", "RF", "rid", "fr", "RM", "cr", "ds", "md", "ind", "ptr", "red", "rl", "rm", "cd", "rat", "sr", "RR", "rss", "rx", "RD", "addr", "rt", "td", "vr", "nd", "ded", "rh", "rin", "db", "rc"], "tmp": ["vt", "txt", "sp", "pb", "stuff", "err", "storage", "jp", "mp", "appy", "cp", "rt", "wp", "pp", "wx", " ss", "sup", "zip", "sb", "rw", "buff", "cro", "mm", "buf", "api", "mk", "Temp", "pkg", "p", "amp", "v", "mmm", "keep", "np", "ctx", "cpp", "data", "xt", "r", "page", "boot", "py", "proc", "cb", "fake", "pad", "result", "c", "nb", "br", "cache", "app", "obj", "tt", "kk", "bb", "img", "test", "vm", "null", "src", "dd", "tab", "emp", "tc", "tp", "output", "rb", "temp", "config", "wb", "copy", "rm", "bg", "fb", "b", "cmp", "part", "pot", "db", "rc"], "tmp2": ["tmp3", " tmp32", "mp3", "tmp4", "mp32", "temp4", "mp2", "temp32", " tmp1", "mp4", "mp1", "tmp32", "tmp1", " tmp4", "temp1", "temp3", " tmp3", "temp2"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n", "idx": 2564, "substitutes": {"id": ["name", "q", "def", "sid", "data", "url", "class", "kind", "head", "oid", "ID", "parent", "ids", "Id", "mid", "info", "code", "rid", "pid", "ident", "ip", "kid", "ref", "uid", "uri", "path", "root", "db"], "backend": ["backen", "backender", "backended", "BACKend", "BACKender", "Backen", " backender", " backended", "BACKen", " backen", "Backended", "Backend", "BACKended", "frontended", "Backender", "frontender", "fronten", "frontend"], "ret": ["fun", "att", "def", "conn", "data", "rets", "auth", "proc", "reply", "Ret", "pub", "result", "ut", "fin", "red", "ref", "eth", "resp", "obj", "RET", "lit", "reg", "val", "det", "res", "mem"], "errp": ["errP", "erP", "acepo", " errpi", "acerP", "errfp", "erpo", " errP", "acefp", "errpi", "acerp", "erp", "acerpi", "aceP", " errfp", "erpi", "errpo", "acep", "acerfp", " errpo", "erfp"]}}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    int fd = -1, ret;\n\n    USBHostDevice *dev = NULL;\n\n    struct usbdevfs_connectinfo ci;\n\n    char buf[1024];\n\n    int bus_num, addr;\n\n    char product_name[PRODUCT_NAME_SZ];\n\n\n\n    dev = qemu_mallocz(sizeof(USBHostDevice));\n\n    if (!dev)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"usb_host_device_open %s\\n\", devname);\n\n#endif\n\n    if (usb_host_find_device(&bus_num, &addr,\n\n                             product_name, sizeof(product_name),\n\n                             devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buf, sizeof(buf), USBDEVFS_PATH \"/%03d/%03d\",\n\n             bus_num, addr);\n\n    fd = open(buf, O_RDWR | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        perror(buf);\n\n        return NULL;\n\n    }\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"usb_host_device_open: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++)\n\n            printf(\"%02x \", dev->descr[x]);\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n    dev->fd = fd;\n\n    dev->configuration = 1;\n\n\n\n    /* XXX - do something about initial configuration */\n\n    if (!usb_host_update_interfaces(dev, 1))\n\n        goto fail;\n\n\n\n    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    printf(\"host USB device %d.%d grabbed\\n\", bus_num, addr);\n\n#endif\n\n\n\n    ret = usb_linux_update_endp_table(dev);\n\n    if (ret)\n\n        goto fail;\n\n\n\n    if (ci.slow)\n\n        dev->dev.speed = USB_SPEED_LOW;\n\n    else\n\n        dev->dev.speed = USB_SPEED_HIGH;\n\n    dev->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    dev->dev.handle_reset = usb_host_handle_reset;\n\n    dev->dev.handle_control = usb_host_handle_control;\n\n    dev->dev.handle_data = usb_host_handle_data;\n\n    dev->dev.handle_destroy = usb_host_handle_destroy;\n\n\n\n    if (product_name[0] == '\\0')\n\n        snprintf(dev->dev.devname, sizeof(dev->dev.devname),\n\n                 \"host:%s\", devname);\n\n    else\n\n        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),\n\n                product_name);\n\n\n\n#ifdef USE_ASYNCIO\n\n    /* set up the signal handlers */\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigact.sa_sigaction = isoch_done;\n\n    sigact.sa_flags = SA_SIGINFO;\n\n    sigact.sa_restorer = 0;\n\n    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: sigaction failed\");\n\n        goto fail;\n\n    }\n\n\n\n    if (pipe(dev->pipe_fds) < 0) {\n\n        perror(\"usb_host_device_open: pipe creation failed\");\n\n        goto fail;\n\n    }\n\n    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n\n    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);\n\n    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);\n\n#endif\n\n    dev->urbs_ready = 0;\n\n    return (USBDevice *)dev;\n\nfail:\n\n    if (dev)\n\n        qemu_free(dev);\n\n    close(fd);\n\n    return NULL;\n\n}\n", "idx": 2583, "substitutes": {"usb_host_device_open": ["usb_host_device__open", "usb_host_device__new", "usb_host_device_init", "usb_host_driver_new", "usb_host_device__init", "usb_host_device__connect", "usb_host_device_new", "usb_host_driver_init", "usb_host_device_connect", "usb_host_driver_connect", "usb_host_driver_open"], "devname": ["propName", "propnames", "evname", "deviceid", "verNAME", "devicename", " devno", "deviceno", " devNAME", "appid", "deviceName", "verName", " devName", "devid", "propname", "appno", "diskno", "propNAME", "devsource", "appname", " devnames", "evName", "evno", "devNAME", " devid", "devno", "vernames", "diskname", "vername", "disksource", "diskName", "evsource", "devName", "appName", " devsource", "devnames"], "ret": ["ur", "match", "arg", "fun", "no", "att", "def", "bit", "hash", "success", "data", "out", "cat", "alt", "ry", "pet", "rets", "arr", "pass", "fail", "nt", "err", "rev", "tr", "reply", "back", "Ret", "rc", "pat", "str", "result", "fin", "len", "red", "ref", "rl", "resp", "art", "obj", "RET", "al", "full", "reg", "re", "val", "rt", "lit", "pt", "let", "fi", "part", "det", "res", "db", "mem"], "dev": ["adv", "device", "ver", "db", "de", "client", "enc", "home", "self", "comment", "var", "od", "valid", "fi", "start", "group", "sh", "end", "dom", "api", "off", "fail", "gu", "p", "bd", "conf", "wd", "die", "driver", "v", "ev", "serv", "val", "root", "gh", "user", "serial", "ow", "mod", "sd", "fw", "data", "new", "hub", "ad", "di", "prof", "ve", "info", "pub", "raw", "result", "c", "app", "cache", "attr", "cmd", "obj", "nov", "error", "debug", "test", "server", "fd", "def", "dd", "hw", "conn", "d", "av", "priv", "grad", "DEV", "Dev", "df", "bug", "nt", "md", "temp", "ch", "config", "dc", "block", "cd", "rad", "dem", "cmp", "dat", "diff", "gd", "dist", "game"], "ci": ["oci", "cli", " gcc", " ca", " ki", "li", "ctx", "cs", "conn", "ni", "ii", "cc", "pi", "ui", "di", "CI", " priv", "co", "ct", "cci", " ec", " pci", " cc", "i", " i", " cf", " li", "info", " dc", " exec", "ini", "config", "ai", "dc", "cu", "c", "ind", "lc", " info", " io", " di", "ctrl", " vi", "vc", "ki", " c", " lib", "vi", "ic", "cf", "io", " ic", "sci", "init", "fi", "si"], "buf": ["ff", "fd", "src", "buffer", "ctx", "bed", "bh", "bag", "context", "queue", "ab", "data", "loc", "prop", "bc", "buff", "pb", "tmp", "cas", "mac", "rb", "proc", "fab", "box", "cb", "feat", "config", "bf", "feed", "func", "pad", "bus", "result", "c", "cv", "vec", "ptr", "doc", "wb", "bd", "br", "ref", "la", "cmd", "alloc", "seq", "b", "fb", "cp", "cf", "conv", "bytes", "uf", "path", "fi", "uc", "desc", " buffer", "rc", "port"], "bus_num": [" bus_no", "bus2num", "bus_len", " bus_nom", " bus2number", "busacid", "BUS_no", " bus2num", "BUS_num", "bus_un", " bus_len", "bus2len", " bus_un", "busaccount", " bus_nu", "bus_nu", "bus2no", "busPnumber", " bus2len", "BUS_count", "bus_no", "busacnum", "busacno", "bus_id", "busPlen", " bus_number", "bus_number", "bus2number", "bus_count", "bus_nom", "BUS_id", "busPnum", "busPno", " bus2no"], "addr": ["oa", "layer", "dr", "route", "name", "src", "offset", "ext", "device", "alias", "az", "host", "url", "loc", "ad", "align", "alt", "nc", "id", "ord", "adr", "pos", "mac", "nr", "mid", "index", "md", "address", "ack", "pad", "ip", "owner", "ptr", "hop", "ref", "attr", "ar", "arm", "Address", "eth", "la", "node", "amp", "nm", "amd", "bridge", "rt", "mode", "part", "ace", "arch", "dist", "rc"], "product_name": [" prod_address", "product_number", "product_size", "plugin_number", "product__NAME", "productnamesize", "product__number", "plugin_name", " product_NAME", "plugin_type", "plugin_path", " prod_size", "product__name", "product_address", " product_number", "product_path", "product_type", "productnameaddress", " prod_name", "product_names", "product_NAME", "product__names", "productnamename", " product_names"], "x": ["xa", "yx", "ctx", "key", "pe", "r", "xt", "d", "n", "xxxx", "orig", "id", "k", "xy", "num", "y", "i", "dx", "ux", "pos", "code", "tx", "lex", "X", "xs", "index", "z", "xp", "xx", "h", "c", "p", "xc", "work", "w", "sw", "f", "ax", "u", "ww", "fx", "v", "ex", "ix", " X", "rx", "t", "wa", "sex", "val", "xxx", "xi", "wx"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 2594, "substitutes": {"env": ["eu", "oa", "np", "server", "emb", "ctx", "ext", "cal", "fen", "ass", "conn", "context", "txt", "queue", "her", "environment", "global", "pg", "ea", "eng", "enc", "eni", "proc", "code", "args", "erv", "ah", "info", "eff", "err", "ep", "config", "impl", "ec", "exc", "Environment", "anne", "cv", "e", "loader", "conf", "gui", "viron", "chal", "obj", "exec", "en", "v", "ev", "site", "manager", "engine", "qt", "que", "console", "energy", "db"], "arg": ["argument", "call", "ig", "target", "inter", "bit", "lb", "weight", "cat", "Arg", "ag", "grad", "op", "arr", "num", "enc", "param", "g", "par", "arp", "mac", "args", "config", "result", "ang", "p", "arc", "len", "ax", "flag", "ar", "attr", "ray", "amp", "v", "pc", "var", "val", "load", "all", "ace", "option"], "farg": [" ffrg", "larm", "fcarc", " farm", "infflag", "larg", " frg", " Falloc", "fcarg", "larp", "famp", "elfarg", "tg", "fflag", "farp", "ifamp", " ffalloc", "elfargs", " ffargs", "dfreg", "ufarp", "ifarg", "refarg", "ufreg", "elfflag", " fargs", "fwarc", "fcg", "farc", "refarc", "larc", " freg", "infarc", "ufarg", " Fargs", "refamp", " Farg", "refarm", " ffarg", " farc", "ifarc", "fwarg", "fwamp", "infargs", "frg", "fg", "targ", " falloc", "tload", "infarg", "tarc", "fload", "ifarp", " Frg", "fargs", "freg", "ufargs", "fcload", "refarp", "falloc", " fg", "dfarg", "dfarp", " farp", " fflag", "dfargs", "fwarp", " fload", "elfarc", "farm"], "f32": ["utf34", "c31", "f31", "tf31", "c34", "utf64", "tf34", "tf32", "f64", "sf32", "f16", "sf34", "sf64", "utf32", "sf16", "c32", "utf31", "c16", "tf16", " f34", " f31", " f16", "f34", " f64", "sf31"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "int gen_new_label(void)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    int idx;\n\n    TCGLabel *l;\n\n\n\n    if (s->nb_labels >= TCG_MAX_LABELS)\n\n        tcg_abort();\n\n    idx = s->nb_labels++;\n\n    l = &s->labels[idx];\n\n    l->has_value = 0;\n\n    l->u.first_reloc = NULL;\n\n    return idx;\n\n}\n", "idx": 2602, "substitutes": {"s": ["sg", "js", "service", "cs", "ctx", "ss", "ops", "rs", "ts", "spec", "sb", "small", "ins", "sl", "g", "space", "comments", "ls", "ses", "sf", "sync", "xs", "sv", "settings", "ds", "ps", "gs", "ns", "c", "p", "services", "e", "lines", "self", "sq", "u", "sc", "south", "o", "sr", "less", "su", "S", "os", "session", "hs", "states", "se", "fs", "si", "sym", "ssl"], "idx": ["Idz", " idX", "indx", "midc", "pidxf", " idb", "Idx", " idz", " idxi", "idxi", "Idxi", "Idb", "IDz", "IDb", " idxc", "Idc", "Idxc", "indxc", "idxc", "idX", "idc", "IdX", "Idxf", "midxc", "idz", "idb", " idc", "midx", "IDx", "pidxc", "pidx", "indz", "midz", "idxf", "indxi", "IDxc", "pidX", " idxf"], "l": ["pl", "ell", "ol", "li", "jl", "ul", "lp", "lb", "n", "dl", "lu", "ln", "sl", "lf", "fl", "wl", "nl", "bl", "i", "g", "j", "ls", "ll", "c", "p", "L", "lc", "rl", "kl", "u", "la", "el", "il", "o", "v", "b", "lin", "cell", "t", "al", "ly", "le"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n", "idx": 2604, "substitutes": {"bs": ["base", "cs", "rs", "ts", "sb", "bps", "lb", "BS", "sels", "bid", "bc", "banks", "pb", "bis", "ls", "ses", "bits", "ds", "bas", "gs", "ps", "ns", "vs", "bos", "isi", "gb", "lbs", "obj", "s", "ubs", "iss", "fb", "b", "os", "las", "bes", "fs", "db", "obs"], "sector_num": ["sector_number", "sector_count", "section_name", "section_number", "section_count", "section_con", "section_num", "section_size", "sector_size", "sector_nor", "sector_name", "section_note", "sector_note", "section_nor", "sector_con"], "nb_sectors": ["nb_sycs", "nb_SErics", "nb_seccs", "nb_secctors", "nb_lexources", "nb_verics", "nb_lexcs", "nb_seources", "nb_vegments", "nb_velements", "nb_serics", "nb_selements", "nb_syeters", "nb_syctors", "nb_lexgments", "nb_lexctors", "nb_veources", "nb_segments", "nb_sygments", "nb_seceters", "nb_SEgments", "nb_perselements", "nb_vectors", "nb_vecs", "nb_secgments", "nb_SElements", "nb_secources", "nb_perserics", "nb_SEctors", "nb_persectors", "nb_seeters", "nb_persegments", "nb_secs", "nb_veeters"], "cluster_sector_num": ["cluster_section_num", "cluster_section_number", "cluster_sector_name", "cluster_sector_n", "cluster_sector__sum", "cluster_section_sum", "cluster_sector_count", "cluster_section_no", "cluster_section_index", "cluster_sector__number", "cluster_sector_number", "cluster_tier_num", "cluster_sector_sum", "cluster_sector__n", "cluster_tier_number", "cluster_tier_name", "cluster_sector_no", "cluster_tier_size", "cluster_section_count", "cluster_sector_size", "cluster_section_n", "cluster_sector__num", "cluster_sector_index"], "cluster_nb_sectors": ["cluster_nb_gectors", "cluster_nb_gecs", "cluster_nb_gections", "cluster_nb_pecs", "cluster_nb_vegments", "cluster_nb_vecs", "cluster_nb_secctions", "cluster_nb_vector", "cluster_nb_pections", "cluster_nb_secs", "cluster_nb_pegments", "cluster_nb_sector", "cluster_nb_secctor", "cluster_nb_gegments", "cluster_nb_pectors", "cluster_nb_segments", "cluster_nb_vectors", "cluster_nb_gector", "cluster_nb_secctors", "cluster_nb_vections", "cluster_nb_sections", "cluster_nb_secgments"], "bdi": ["bbmi", "dadi", "pidi", "padi", "sbni", "bbdc", "nmi", "dni", "didi", "bbsi", "bni", "nini", "badi", "fdi", "bidi", "ndi", "lni", "sbini", " bidi", "bbni", " bdc", "fdc", " bsi", "pdi", "lsi", "nni", "bbini", "sbmi", " bni", "fni", "bbdi", "ldc", "fsi", "bdc", "pni", "bmi", "sbdi", "ddi", "bini", " badi", "ldi", "bsi"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 2620, "substitutes": {"cpu": ["eu", "chu", "vm", "cli", "gpu", "ctx", "intel", "roc", "hw", "conn", "gc", "process", "cpp", "clock", "uci", "nc", "nic", "platform", "boot", "comp", "instance", "eni", "CPU", "proc", "fp", "python", "pid", "utils", "config", "bench", "pkg", "c", "lc", "pu", "loader", "core", "sys", "cache", "hp", "chip", "processor", "node", "linux", "pc", "pec", "cp", "uca", "net", "rc"], "start1": ["graden", "start3", "grade1", "grade01", "end3", "offsetn", "set0", " start01", "set01", "stopLength", " start2", "start0", "offset01", "gradeOne", "start2", "startn", "startLength", "stop1", "index0", "stop2", "end2", "end1", "set1", "start01", "offset1", "stop3", "index01", " start0", " startLength", "endLength", " start3", " startn", " startOne", "offsetOne", "startOne", "index1"], "length": ["total", "buffer", "build", "offset", "time", "sequence", "tail", "filename", "url", "position", "type", "distance", "section", "end", "duration", "maximum", "number", "style", "slice", "address", "pad", "l", "block", "len", "size", "angle", "text", "library", "amount", "range", "Length", "padding", "collection", "seq", "depth", "path", "full", "available", "view", "count", "limit", "shape", "load"], "env": ["eu", "oa", "np", "external", "vm", "ctx", "ext", "ass", "enable", "conn", "context", "her", "equ", "environment", "que", "ea", "dict", "scope", "elf", "eng", "enc", "py", "eni", "erv", "file", "args", "enh", "config", "ec", "exc", "Environment", "vs", "e", "loader", "cache", "conf", "core", "el", "viron", "obj", "chal", "en", "eur", "v", "enda", "ev", "cf", "session", "engine", "dir", "console", "si", "energy", "db"], "mmu_idx": ["mmu_ini", "mmu_indt", "mmu_ridxs", "mmu_ity", "mmu_idw", "mmu_dxs", "mmu_minf", "mmu_adX", "mmu_indx", "mmu_idex", "mmu__endx", "mmu__adx", "mmu__adxs", "mmu_endxs", "mmu__adi", "mmu_Idc", "mmu_ipf", "mmu_idi", "mmu__idX", "mmu_idxe", "mmu__idct", "mmu_ridst", "mmu_indexxs", "mmu_idt", "mmu_idey", "mmu_itw", "mmu_idez", "mmu_minc", "mmu_Idz", "mmu_indy", "mmu_dxe", "mmu__endct", "mmu_idy", "mmu_inxs", "mmu__adX", "mmu__idi", "mmu_mainst", "mmu_Idw", "mmu_endct", "mmu_indexx", "mmu_idct", "mmu_idec", "mmu_ipxe", "mmu_ipc", "mmu_midxi", "mmu_indexX", "mmu_dct", "mmu_Idt", "mmu_minx", "mmu__idx", "mmu_inX", "mmu_Idx", "mmu_itx", "mmu__endxe", "mmu_ipxs", "mmu_itt", "mmu_midxs", "mmu_idf", "mmu_mainxs", "mmu_adx", "mmu_midst", "mmu_idX", "mmu_ridxi", "mmu_ridx", "mmu_endx", "mmu_indexi", "mmu_idg", "mmu_mainx", "mmu_ipct", "mmu_idc", "mmu_dx", "mmu__endxs", "mmu_mainxi", "mmu_ipg", "mmu_adi", "mmu_inx", "mmu_idxs", "mmu_Idy", "mmu_idxi", "mmu_idz", "mmu_ming", "mmu__idxe", "mmu_midx", "mmu_ipx", "mmu_idst", "mmu_endxe", "mmu__idxs", "mmu_adxs", "mmu_indw"], "i": ["cli", "yi", "name", "li", "gi", "abi", "a", "ii", "zi", "ui", "pi", "oi", "mini", "d", "I", "n", "di", "id", "it", "k", "iu", "api", "j", "g", "y", "ri", "m", "info", "ti", "multi", "index", "ini", "ai", "ie", "x", "l", "c", "p", "phi", "bi", "e", "lc", "f", "u", "jp", "o", "v", "ki", "qi", "b", "t", "uri", "ci", "io", "mu", "init", "fi", "start", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 2622, "substitutes": {"s": ["server", "js", "service", "cs", "ss", "rs", "sa", "spec", "sb", "r", "is", "sl", "ls", "ses", "sync", "settings", "ds", "ps", "ns", "c", "p", "sie", "state", "f", "es", "sys", "u", "o", "stats", "b", "S", "os", "bs", "states", "se", "si", "ssl"], "rule": ["route", "match", "lock", "name", "sche", "service", "li", "gi", "def", "ul", "rate", "rules", "ULE", "url", "r", "rr", "ule", "tag", "ee", "use", "callback", "trial", "section", "parent", "lr", "model", "update", "ri", "file", "event", "fr", "style", "slice", "err", "config", "result", "block", "role", "Rule", "state", "cookie", "e", "resource", "rl", "f", "ler", "cache", "order", "range", "comment", "o", "fee", "play", "plugin", "sort", "error", "uri", "line", "run", "val", "debug", "root", "statement", "ride", "reg"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624, "substitutes": {"dev": ["serial", "cam", "def", "dd", "hw", "conn", "device", "mod", "data", "d", "ver", "di", "av", "priv", "de", "grad", "eng", "dom", "Dev", "md", "ch", "home", "dc", "gu", "p", "w", "self", "prom", "dm", "app", "exec", "cmd", "die", "comment", "driver", "ev", "rad", "dem", "serv", "nov", "link", "valid", "pro", "img", "gd", "mem"], "s": ["sg", "js", "service", "cs", "ss", "spec", "ts", "rs", "a", "sb", "r", "d", "n", "is", "sl", "ms", "i", "side", "g", "m", "ses", "sf", "args", "sync", "storage", "ds", "ps", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "es", "sys", "sq", "obj", "sec", "o", "b", "su", "S", "t", "session", "os", "an", "states", "fs", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n", "idx": 2628, "substitutes": {"s": ["server", "js", "service", "cs", "ctx", "ops", "ts", "qs", "context", "sb", "r", "d", "is", "scope", "i", "g", "ses", "sf", "args", "sync", "settings", "sets", "gs", "ns", "h", "c", "p", "services", "w", "e", "private", "f", "secondary", "self", "us", "sys", "sq", "u", "es", "south", "sec", "b", "site", "t", "os", "session", "fs", "sym", "ssl"], "ret": ["match", "dr", "server", "fun", "att", "ext", "mt", "def", "rs", "ary", " Ret", "data", "xt", "r", "alt", "Arg", "store", "rets", "arr", "bis", "rb", "args", "info", "ft", "nt", "rev", "str", "tr", "feat", "Ret", "reply", "status", "result", "pret", "len", "red", "flag", "ref", "f", "ar", "gt", "obj", "en", "sr", "RET", "seq", "b", "valid", "al", "lit", "reg", "addr", "val", "re", "rt", "fi", "det", "res"], "arg": ["act", "lag", "alt", "enc", "g", "args", "err", "f", "ax", "en", "magic", "var", "valid", "option", "name", "ext", "target", "extra", "tag", "slot", "id", "arr", "pass", "par", "mac", "ac", "parse", "p", "lc", "amp", "v", "val", "in", "rg", "data", "ad", "cat", "use", "Arg", "ag", "op", "info", "str", "func", "result", "len", "ref", "arm", "other", "cmd", "asm", "gen", "reg", "msg", "argument", "match", "call", "ig", "bit", "num", "param", "ang", "doc", "arc", "flag", "ar", "art", "al", "addr", "inc", "ace"]}}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "int xen_config_dev_blk(DriveInfo *disk)\n\n{\n\n    char fe[256], be[256];\n\n    int vdev = 202 * 256 + 16 * disk->unit;\n\n    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;\n\n    const char *devtype = cdrom ? \"cdrom\" : \"disk\";\n\n    const char *mode    = cdrom ? \"r\"     : \"w\";\n\n\n\n    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),\n\n\t     \"xvd%c\", 'a' + disk->unit);\n\n    xen_be_printf(NULL, 1, \"config disk %d [%s]: %s\\n\",\n\n                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);\n\n    xen_config_dev_dirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe));\n\n\n\n    /* frontend */\n\n    xenstore_write_int(fe, \"virtual-device\",  vdev);\n\n    xenstore_write_str(fe, \"device-type\",     devtype);\n\n\n\n    /* backend */\n\n    xenstore_write_str(be, \"dev\",             disk->bdrv->device_name);\n\n    xenstore_write_str(be, \"type\",            \"file\");\n\n    xenstore_write_str(be, \"params\",          disk->bdrv->filename);\n\n    xenstore_write_str(be, \"mode\",            mode);\n\n\n\n    /* common stuff */\n\n    return xen_config_dev_all(fe, be);\n\n}\n", "idx": 2632, "substitutes": {"disk": ["wheel", "vol", "dn", "device", "wk", "dim", "dl", "file", "storage", "dev", "docker", "sky", "se", "pack", "prem", "da", "read", "pd", "mc", "Disk", "image", "k", "cdn", "dam", "model", "scan", "network", "parse", "isk", "work", "lc", "ram", "core", "wd", "die", "driver", "plan", "plugin", "link", "hard", "vd", "io", "dis", "sci", "load", "np", "sd", "data", "ad", "di", "pod", "slice", "ds", "design", "cache", "machine", "disc", "connection", "dri", "service", "dd", "conn", "d", "co", "sk", "sync", "df", "md", "config", "dc", "word", "block", "draw", "drive", "clean", "cer", "product", "dat", "part", "diff", "db"], "fe": ["fc", "Fe", "abe", "te", "we", "ize", "fen", "oe", "pe", "ke", "xf", "fa", "eb", "ee", "flo", " f", "que", "ge", "bee", "ffe", "BE", "de", "ne", "ef", "none", "sf", "file", "fr", "ube", " me", "bf", "wife", "ie", "ce", " pe", "e", "f", "ife", "fm", "le", "che", "fee", "ile", "play", "fine", "xe", "efe", "fb", "ze", "coe", "he", "me", "fle", "lab", "se", "fi", "ace", "ae", "fer", "FE"], "be": ["ere", "abe", "te", "Be", "se", "ba", "oe", "ke", "pe", "bare", "ome", "oper", "eb", "ee", "com", "co", "ape", "is", "ge", "BE", "bee", "de", "ine", "ne", "ben", "ble", "bre", "robe", "ste", "ve", "ube", "fr", "ber", "bf", "obe", "ie", "ce", "bi", "e", "ro", " Be", "fore", "ibe", "che", "are", "ile", "fine", "ze", "efe", "coe", "pro", "he", "FE", "bes", "fi", "ae", "fer", "le"], "devtype": ["disktype", "divlevel", "apptypes", "diskype", "disklevel", "diffname", "appname", " devlevel", "devname", "diffType", "divname", " devype", "devype", "devtypes", "apptype", "devType", "difftypes", "appType", "diskname", "difftype", " devType", "divtype", "divype", " devtypes", " devname", "devlevel"], "mode": ["MODE", "name", "version", "mod", "device", "dim", "command", "mem", "alias", "type", "use", "position", "kind", "id", "mm", "op", "member", "language", "m", "none", "password", "direction", "source", "md", "config", "description", "owner", "role", "dev", "force", "size", "cmd", "range", "username", "scale", "module", "Mode", "path", "part", "option"]}}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  int search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, k;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->ppc = pc_start;\n\n    dc->pc = pc_start;\n\n    dc->flags = cpu->env.cpucfgr;\n\n    dc->mem_idx = cpu_mmu_index(&cpu->env);\n\n    dc->synced_flags = dc->tb_flags = tb->flags;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"-----------------------------------------\\n\");\n\n        log_cpu_state(CPU(cpu), 0);\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    k = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_tb_start();\n\n\n\n    do {\n\n        check_breakpoint(cpu, dc);\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (k < j) {\n\n                k++;\n\n                while (k < j) {\n\n                    tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[k] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[k] = 1;\n\n            tcg_ctx.gen_opc_icount[k] = num_insns;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc->pc);\n\n        }\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n        dc->ppc = dc->pc - 4;\n\n        dc->npc = dc->pc + 4;\n\n        tcg_gen_movi_tl(cpu_ppc, dc->ppc);\n\n        tcg_gen_movi_tl(cpu_npc, dc->npc);\n\n        disas_openrisc_insn(dc, cpu);\n\n        dc->pc = dc->npc;\n\n        num_insns++;\n\n        /* delay slot */\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                dc->tb_flags &= ~D_FLAG;\n\n                gen_sync_flags(dc);\n\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n\n                tcg_gen_movi_tl(jmp_pc, 0);\n\n                tcg_gen_exit_tb(0);\n\n                dc->is_jmp = DISAS_JUMP;\n\n                break;\n\n            }\n\n        }\n\n    } while (!dc->is_jmp\n\n             && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n             && !cs->singlestep_enabled\n\n             && !singlestep\n\n             && (dc->pc < next_page_start)\n\n             && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    }\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        gen_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n            break;\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        k++;\n\n        while (k <= j) {\n\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 2634, "substitutes": {"cpu": ["fc", "np", "vm", "cli", "server", "gpu", "cam", "roc", "hw", "conn", "device", "mc", "gc", "cpp", "lb", "computer", "clock", "uci", "nc", "GPU", "bc", "px", "nic", "tc", "pb", "boot", "cdn", "comp", "drm", "auc", "component", "mac", "CPU", "proc", "fp", "config", "cu", "c", "cow", "lc", "pu", "core", "cache", "hp", "gb", "cn", "chip", "sys", "processor", "node", "linux", "pc", "cca", "cp", "cmp", "uu", "cfg", "gp", "performance", "uc", "rc"], "tb": [" tbh", "tbb", " tcb", "ttbh", "itbs", " tbb", "ttp", "ptrb", "tmb", "tsb", "tB", "stb", "untcb", "ttb", "ctp", "trb", "ttbs", " tab", "untrb", "ptb", "untB", "tbs", " tB", "tsbh", "pb", "ntb", "tab", "tmbi", "pbs", " tbi", "tp", " tp", "ttbb", "plb", "ptB", "ntlb", "itb", "tsp", "ctbs", "ntbr", " trb", "stbi", "tmab", "stbs", "ttbr", "tbr", "tsbi", "untb", "tbh", " tbs", "ttbi", "stp", "itbi", "tlb", "ptcb", "ntbs", "pbr", "tcb", "ctb", "itab", "itp", "tbi", "ttlb", "ctbb", "tmbs"], "search_pc": [" searchablemc", "search2PC", "search2fc", "search__PC", " searchablefc", "searchablemc", "search_PC", "search_mc", "searchablePC", "scan_pc", "searchablefc", "search__fc", "searchablepc", "search__ac", "scanableac", "search2pc", " searchablepc", "search_ac", "search__pc", " search_mc", "scan_mc", "search2mc", " search_fc", "scanablepc", "search__mc", "scan_PC", "scanablemc", "search_fc", " searchablePC", "scanablePC", " search_PC", "scan_ac", "searchableac"], "cs": ["cms", "acs", "spec", "rs", "conn", "cc", "Cs", "ck", "nc", "bc", "cons", "tc", "sk", "cus", "cas", "des", "ls", "args", "ras", "ds", "utils", "ps", "ec", "ns", "c", "css", "lc", "sys", "sc", "wcs", "ca", "pc", "cp", "cf", "ks", "fs", "CS", "rc"], "ctx": ["fc", " cx", "cli", " gcc", "conn", "context", "cc", "mc", "loc", "aux", "nc", "bc", "tc", "cas", " cc", "tx", "cb", "utils", "config", "ec", "cu", "c", "xc", "lc", "cn", "sc", "cache", "ctrl", "ca", "exec", "cmd", "pc", "cca", "cp", "cmp", "cf", "ci", "cfg", " context", "ctl", " rc", "rc"], "dc": ["fc", "cm", "dr", "cms", "DC", "da", "ga", "conn", "context", "mc", "cc", "anc", "device", "loc", "d", "di", "uci", "nc", "director", "bc", "rec", "tc", "cdn", "cus", "auc", "mac", "ac", "proc", "df", "dt", "config", "ec", "abc", "cu", "c", "xc", "jc", "doc", "design", "du", "dm", "lc", "core", "sc", "git", "cd", "exec", "ku", "disc", "vc", "cmd", "pc", "cca", "cp", "cf", " DC", "ci", "cfg", "dat", "enter", "inc", "uc", "desc", "input", "db", "rc"], "gen_opc_end": ["gen_opl_start", "gen_opc_len", "gen_opf_end", "gen_opl__end", "gen_opl_end", "gen_opf_len", "gen_opc__end", "gen_opc_ends", "gen_opc_buf", "gen_opc__buf", "gen_opc_max", "gen_opc_pos", "gen_opl__start", "gen_opc__max", "gen_opc__start", "gen_opl_max", "gen_opl_buf", "gen_opc_start", "gen_opl__max", "gen_opl__buf", "gen_opf_ends", "gen_opf_pos"], "pc_start": ["PC_max", "pc7max", "pc00add", "pcallend", "PC_first", "pc_limit", "pcfstart", "pc_first", "PC_count", "pcaccount", "pcallmax", "pc00end", "pcvend", "pc_max", "pcalllimit", "pc00first", "pcvfirst", "pcvadd", "pcfend", "PC_start", "pc00start", "pc_count", "pcacend", "pcacsize", "PC_pos", "pc7end", "pc_end", "pcfcount", "PC_end", "PC_started", "pcallstart", "pcvstart", "PC_size", "PC_offset", "pc7start", "pcfstarted", "PC_add", "pc7limit", "pc_add", "pc_offset", "pcacstart", "pc_started", "pc_pos", "pc_size", "pcacstarted", "PC_limit"], "j": ["ja", "js", "lock", "adj", "offset", "q", "jl", "key", "conn", "ke", "ji", "ii", "d", "n", "jj", "J", "job", "aj", "ij", "uj", " i", "i", "g", "y", "max", "next", "m", "jo", "ok", "kj", "z", "index", "ch", "kn", "x", "l", "ind", "p", "jc", "pop", "f", "length", "ak", "jp", "dj", "o", "v", "ik"], "k": ["ek", "q", "kick", "key", "spec", "ke", "r", "d", "n", "ck", "id", "K", "end", "sk", "ko", "kr", "y", "i", "dk", "unk", "ka", "ok", "ask", "mk", "kw", "z", "ch", "kn", "ack", "x", "l", "c", "p", "kid", "work", "w", "f", "ak", "u", "ku", "kk", "ki", "v", "o", "b", "ik", "ks", "kat", "start"], "next_page_start": ["next_page2start", "next_page_size", "next_page2end", "next_page_index", "next_page2index", "next_page64start", "next_page_count", "next_page64max", "next_page_end", "next_page2size", "next_page2count", "next_page64end", "next_page_max", "next_page64index", "next_page2max"], "num_insns": ["num_linns", "num_inspaces", "num_inpaces", "num_vinpaces", "num_itscons", "num_inscs", "num_vinns", "num_linnc", "num_lincons", "num_inn", "num_intspaces", "num_itsnc", "num_innc", "num_inscons", "num_incons", "num_intsn", "num_inns", "num_incs", "num_intscs", "num_vinn", "num_itsns", "num_vincs", "num_itsn", "num_insn", "num_linn", "num_insnc", "num_intsns"], "max_insns": ["max_gesns", "max_INSNs", "max_gends", "max_vincons", "max_incNs", "max_INSn", "max_tsvs", "max_inn", "max_incons", "max_inscons", "max_genn", "max_insnos", "max_gencs", "max_inds", "max_insNs", "max_tsnos", "max_incn", "max_tsns", "max_insvs", "max_vinds", "max_gesvs", "max_inNs", "max_gesn", "max_innos", "max_incns", "max_INSns", "max_vincs", "max_INScs", "max_insds", "max_insn", "max_inns", "max_genns", "max_vinn", "max_inccons", "max_inccs", "max_vinns", "max_invs", "max_inscs", "max_tsn", "max_incs", "max_gesnos"], "delayed_branch": ["delayed_bracket", "delayed_franch", "delayed_backet", "delayed_banch", "delayed_bancer", "delayed_fracket", "delayed_granches", "delayed_banches", "delayed_franches", "delayed_brancer", "delayed_grancer", "delayed_branches", "delayed_granch", "delayed_gracket", "delayed_francer"]}}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    IVShmemState *s = IVSHMEM(dev);\n\n    Error *err = NULL;\n\n    uint8_t *pci_conf;\n\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\n\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n\n        error_setg(errp,\n\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n\n        return;\n\n    }\n\n\n\n    if (s->hostmem) {\n\n        MemoryRegion *mr;\n\n\n\n        if (s->sizearg) {\n\n            g_warning(\"size argument ignored with hostmem\");\n\n        }\n\n\n\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n\n        s->ivshmem_size = memory_region_size(mr);\n\n    } else if (s->sizearg == NULL) {\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    } else {\n\n        char *end;\n\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n\n            return;\n\n        }\n\n        s->ivshmem_size = size;\n\n    }\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n\n        return;\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n\n            return;\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    pci_conf = dev->config;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n\n\n    /*\n\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n\n     * bald-faced lie then.  But it's a backwards compatible lie.\n\n     */\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n\n\n\n    /* region for registers*/\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &s->ivshmem_mmio);\n\n\n\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n\n    if (s->ivshmem_64bit) {\n\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    }\n\n\n\n    if (s->hostmem != NULL) {\n\n        MemoryRegion *mr;\n\n\n\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n\n\n\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n\n                                            &error_abort);\n\n        vmstate_register_ram(mr, DEVICE(s));\n\n        memory_region_add_subregion(&s->bar, 0, mr);\n\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n\n    } else if (s->server_chr != NULL) {\n\n        /* FIXME do not rely on what chr drivers put into filename */\n\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n\n            error_setg(errp, \"chardev is not a unix client socket\");\n\n            return;\n\n        }\n\n\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                        s->server_chr->filename);\n\n\n\n        if (ivshmem_setup_interrupts(s) < 0) {\n\n            error_setg(errp, \"failed to initialize interrupts\");\n\n            return;\n\n        }\n\n\n\n        /* we allocate enough space for 16 peers and grow as needed */\n\n        resize_peers(s, 16);\n\n        s->vm_id = -1;\n\n\n\n        pci_register_bar(dev, 2, attr, &s->bar);\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n\n                              ivshmem_check_version, NULL, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                error_report(\"could not truncate shared file\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            error_setg(errp, \"could not open shared file\");\n\n            return;\n\n        }\n\n\n\n        if (check_shm_size(s, fd, errp) == -1) {\n\n            return;\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd, attr, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker);\n\n    }\n\n}\n", "idx": 2649, "substitutes": {"dev": ["serial", "server", "cam", "def", "dd", "hw", "mod", "device", "conn", "data", "ver", "di", "devices", "d", "priv", "grad", "de", "dom", "Dev", "proc", "info", "ch", "pub", "gu", "phy", "prom", "w", "conf", "driver", "ev", "rad", "dem", "error", "pro", "reg", "debug", "fi", "mem"], "errp": ["errorf", "errP", "rrfp", "erP", "armpre", "rrping", "reqp", "rrf", "arrb", "errpe", "errfp", "rrP", "rrps", "errorP", "armP", " errr", "reqpre", "errping", "errb", "innerb", "armf", " errP", "arrps", "arrp", "reqpe", "innerps", "errr", "errps", "arrping", "innerping", "errorp", "erp", "rrb", "errorfp", "armr", "reqP", " errf", "errorr", " errfp", "rrpre", "errf", "innerp", "errpre", "armp", "rrpe", "armpe", "erfp", "rrp"], "s": ["sg", "js", "qs", "device", "n", "sl", "g", "ses", "ls", "sf", "args", "us", "self", "f", "secondary", "sys", "u", "an", "fs", "stat", "spec", "ts", "sb", "aws", "k", "uns", "xs", "sets", "p", "state", "e", "comm", "v", "less", "su", "site", "S", "t", "session", "ks", "serv", "os", "its", "bs", "hs", "sym", "ssl", "cs", "ss", "rs", "new", "r", "is", "ins", "i", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "sec", "o", "si", "service", "http", "ops", "d", "params", "details", "sync", "tests", "ch", "l", "services", "w", "sq", "stats", "b"], "err": ["dr", "gr", "rs", "r", "rr", "der", "rh", "er", "ir", "fr", "cr", "ch", "ec", "exc", "ind", "sys", "ar", "cache", "conf", "asm", "ev", "error", "req", "Er", "msg", "cfg", "ace", "res"], "pci_conf": ["pdi_conn", "pci_\n", "pci___", "pdi_config", "pki__", "pdi_conf", "pci_cfg", "pci__\n", "pci_config", "pki_\n", "pci__", "pci_conn", "pdi_cfg"], "mr": ["ur", "rg", "mn", "dr", "vm", "mir", "mt", "gr", "rs", "mc", "bm", "wr", "ml", "r", "MR", "rr", "yr", "ru", "mer", "mi", "mm", "lr", "kr", "rf", "adr", "rb", "m", "hr", "nr", "mor", "er", "fr", "ir", "au", "gor", "pr", "rl", "br", "attr", "rm", "wm", "pm", "sr", "nm", "asm", "shr", "mmm", "rt", "vr", "Mr"], "end": ["ending", "ff", "append", "after", "offset", "ize", "url", "r", "loc", "send", "ad", "type", "use", "open", "id", "enc", "END", "max", "pos", "ended", "event", "z", "index", "address", "begin", "h", "x", "c", "End", "e", "size", "length", "len", "value", "en", "sum", "scale", "stop", "nd", "enter", "edge", "shape", "start", "est"]}}
{"project": "qemu", "commit_id": "ab2b9f174db088633922eaa82c2bcffd84e6bb94", "target": 1, "func": "int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)\n\n{\n\n    fprintf_function fprintf_fn = info->fprintf_func;\n\n    void *stream = info->stream;\n\n    int rc;\n\n    uint8_t insn[4];\n\n    const Lm32OpcodeInfo *opc_info;\n\n    uint32_t op;\n\n    const char *args_fmt;\n\n\n\n    rc = info->read_memory_func(memaddr, insn, 4, info);\n\n    if (rc != 0) {\n\n        info->memory_error_func(rc, memaddr, info);\n\n        return -1;\n\n    }\n\n\n\n    fprintf_fn(stream, \"%02x %02x %02x %02x    \",\n\n            insn[0], insn[1], insn[2], insn[3]);\n\n\n\n    op = bfd_getb32(insn);\n\n    opc_info = find_opcode_info(op);\n\n    if (opc_info) {\n\n        fprintf_fn(stream, \"%-8s \", opc_info->name);\n\n        args_fmt = opc_info->args_fmt;\n\n        while (args_fmt && *args_fmt) {\n\n            if (*args_fmt == '%') {\n\n                switch (*(++args_fmt)) {\n\n                case '0': {\n\n                    uint8_t r0;\n\n                    const char *r0_name;\n\n                    r0 = (op >> 21) & 0x1f;\n\n                    r0_name = find_reg_info(r0)->name;\n\n                    fprintf_fn(stream, \"%s\", r0_name);\n\n                    break;\n\n                }\n\n                case '1': {\n\n                    uint8_t r1;\n\n                    const char *r1_name;\n\n                    r1 = (op >> 16) & 0x1f;\n\n                    r1_name = find_reg_info(r1)->name;\n\n                    fprintf_fn(stream, \"%s\", r1_name);\n\n                    break;\n\n                }\n\n                case '2': {\n\n                    uint8_t r2;\n\n                    const char *r2_name;\n\n                    r2 = (op >> 11) & 0x1f;\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n", "idx": 2656, "substitutes": {"memaddr": ["ramaddr", "hwptr", "memoryaddress", "hwaddress", "memorywork", "memorypad", "memoryptr", " memwork", "memaddress", "mmaddr", "memoryaddr", "mempad", "ramaddress", "hwwork", "mmaddress", "mmpad", " mempad", "memptr", "hwaddr", " memaddress", "ramptr", "memwork", "mmptr", " memptr"], "info": ["fo", "ami", "name", "buffer", "http", "gi", "abi", "def", "inter", "offset", "INFO", "raf", "alias", "data", "image", "ui", "import", "type", "help", "id", "buff", "end", "Info", "now", "api", "py", "i", "update", "options", "rf", "inner", "ok", "entry", "bug", "util", "source", "parse", "config", "json", "feed", "function", "thin", "afi", "information", "state", "setup", "f", "conf", "handler", "comment", "linux", "o", "error", "manager", "io", "init", "fi", "start", "inf"], "stream": ["Stream", "stage", "reflect", "server", "row", "src", "buffer", "channel", "wrapper", "context", "method", "host", "form", "image", "data", "window", "open", "buff", "prom", "fn", "platform", "client", "loop", "model", "output", "forward", "sync", "cont", "source", "document", "slice", "pool", "impl", "feed", "raw", "progress", "content", "result", "ack", "writer", "reader", "sw", "stack", "track", "draw", "w", "resource", "message", "public", "round", "thread", "clean", "transform", "path", "socket", "engine", "wave", "view", "valid", "hook", "trans", "console", "response", "input", "port"], "rc": ["fc", "rg", "dr", "src", "isc", "roc", "rs", "anc", "cc", "rn", "ror", "success", " src", "rr", "loc", "ct", "ck", "nc", "RC", "bc", "rec", "cur", "rog", " RC", "rh", "irc", "auc", "rb", "ac", "ra", "ok", "err", "ras", "cr", "abc", "dc", "ack", "result", "exc", "xc", "lc", "rl", "ref", "oc", "sc", "rin", "pc", "bb", "cmp", "error", " rac", "rt", "inc", "uc", "inf"], "insn": ["incb", "inm", "incp", "inns", "rsr", "insm", "insne", " insz", "ginm", "ginp", "rsd", "inconn", "rsn", " insm", "issr", "rsm", "insp", "outsns", "incr", "lsc", "insz", "incconn", "inp", "outsc", "incc", "inssn", "INSns", "inb", "incn", "insd", "incm", "inn", "INSsn", " insb", "lsd", "INSp", "insr", "outsd", "INSz", "insconn", "outsn", " insne", "ginn", "ginc", "issd", " insc", "INSn", "inne", "INSne", "lsns", "lsn", " inssn", "inz", "insns", "insc", "incd", "issm", " insconn", "issn", " insns", "insb", "inc", " insp", " insd"], "opc_info": ["opxc_handle", "opfc_job", "opnc8isu", "opcappinfo", "opcappname", "opc_source", "opc_isu", "opcACdesc", "opf_inf", "opxc_info", "opc__isu", "opc_id", "opc__inf", "opc_desc", "opcappsource", "opl_manager", "opxc_name", "opcACInfo", "opl_Info", "opnc_name", "opc_handle", "opc_inf", "opc__name", "opf_id", "opl_num", "opf_Info", "opc8isu", "opfc_info", "opnc_source", "opnc_info", "opnc_isu", "opnc8source", "opc_Info", "opc__source", "opc_num", "opc__handle", "opfc_Info", "opc__info", "opl_info", "opf_info", "opc8info", "opxc_inf", "opcACjob", "opnc8name", "opfc_desc", "opc_job", "opc_manager", "opcappisu", "opc8source", "opc_name", "opc8name", "opnc8info", "opcACinfo"], "op": ["ob", "orb", "no", "ops", "bit", "spec", "mod", "ype", "oper", "apper", "opus", "loc", "operation", "cat", "prop", "type", "format", "sp", "oid", "co", "cop", " Op", "opp", "off", "pre", "ipop", "proc", "ok", "dep", "post", "opt", "open", "ip", "block", "top", "p", "or", "pop", "hop", "set", "app", "oc", "org", "jp", "obj", "node", "o", "lib", "cp", "cmp", "error", "ic", "var", "omp", "gen", "mop", "Op", "root", "OP", "inc", "init", "vert", "pp", "option"], "args_fmt": ["args_Ftm", "args_forprintf", "args_twt", "argsphformat", "args_infwt", "args_fMT", "args_rfnt", "args_filt", "argsphtm", "args_fremt", "args_ffMT", "args_frMT", "args_Fmt", "args_formt", "argsetinfactory", "args_fprintf", "argsetinfmt", "args_forft", "args_Fld", "args_confnt", "args_fformat", "args_rfilt", "args_frprintf", "args_fft", "args_freft", "argsetinfwt", "args_Fatted", "args_fnt", "args_rfformat", "argspfformat", "args_fratted", "args_hmt", "args_tMT", "args_ffmt", "args_freilt", "args_frmd", "argsetfwt", "args_frnt", "args_fwt", "args_factory", "args_lfmt", "args_FMT", "args_hformat", "args_hld", "args_confformat", "args_infMT", "args_htm", "argsetinfMT", "args_cfmt", "args_lfMT", "args_formMT", "args_rfreet", "args_formwt", "args_tactory", "args_infmt", "args_fld", "args_confmt", "args_lfilt", "argspfld", "args_ffatted", "args_frformat", "args_fornt", "args_frilt", "argsetfactory", "args_lfmd", "args_fatted", "args_formmd", "args_cfld", "args_frent", "args_formilt", "args_forilt", "args_ftm", "args_rfmt", "argsphld", "args_confreet", "args_formmt", "args_rfft", "argsetfmt", "args_Fformat", "args_fmd", "args_freet", "args_cftm", "argsetfMT", "argspftm", "args_forformat", "args_tmt", "argsphmt", "argspfmt", "args_rfprintf", "args_infactory", "args_formactory", "args_cfformat", "args_frmt", "args_ffformat"], "r0": ["r200", "r8", "br50", "ar1", "ru0", "br00", "ar4", "hr8", "sr8", "pr48", "pr0", "ru200", "r4", "sr2", "sr4", " r8", "R200", "sr50", "sr48", "R0", "pr00", "sr0", "pr50", "ru4", "ar0", "ru1", "hr4", "r00", "hr2", " r4", "r48", "br0", "r50", "sr00", "R4", "R1", "ar200", "br48", "hr0"], "r0_name": ["r96ADnm", "r49_name", "r49_len", "r2_min", "r0ADnm", "r96_raw", "r0ADla", "r0ADname", "r96_nm", "r0ADraw", "r0_default", "r49_span", "r49_default", "r96_name", "r96_la", "r0_var", "r0_raw", "r96ADraw", "r2_var", "r0_min", "r0_la", "r0_nm", "r96ADname", "r0_span", "r0_len", "r96ADla"], "r1": ["rw2", "rAb", "ar1", "rw3", "cr81", "arAb", "cr1", "crone", "r16", "rw16", "lr1", "rt2", "rone", "sr2", "rc81", "R16", "R3", "r3", "Rup", "rcone", "srup", "rup", "sr1", "rcAb", "lr16", "rt5", "arone", "sr5", "r81", "r5", "lr2", "lr3", "rw1", "rc1", "crAb", "R2", "R1", "rtup", "ar81", "rt1", "R5"], "r1_name": ["r1_info", "r01_name", "r1Jname", "r1_member", "r01_info", "r01_span", "r1_cap", "r01_member", "r1_key", "rOne_name", "rOne_names", "r1Jtext", "r0_text", "r0_none", "r1_names", "r1_span", "r1Jkey", "r1_text", "r1_size", "rOne_cap", "r0_key", "r1Jnone", "r1_none", "rOne_size"], "r2": ["p6", "r8", "artwo", "ar2", "rc2", "rg2", "r62", "rr92", "rr62", "sr6", "r6", "p4", " r3", "ar92", "rtwo", "r4", "sr2", "rc8", "sr4", " r8", "r32", " rtwo", "r3", "rctwo", " r6", "ar62", "p32", "r92", "ar3", " r32", " r4", "rr2", "rg92", "p2", "ar8", "rg62", "sr32", "rc3"], "r2_name": ["r4_Name", "rTwo_n", "r2longvalue", "r4_value", "r2jalias", "rTwojName", "r2jname", "r2_alias", "rTwo_name", "r4_uri", "r2JName", "r2Jvalue", "rTwojn", "r4_name", "r2longName", "r2_Name", "r11_info", "r2longuri", "r11_name", "r11_count", "r2jName", "r2longname", "r2_count", "r2Juri", "r2_info", "rTwojname", "rTwo_alias", "r2_uri", "r2jn", "r2Jname", "rTwojalias", "rTwo_Name", "r2_value", "r2_n"], "csr": ["vspr", "cssrs", "vsr", "cspr", "bsr", "bspr", "bsrs", "bsrb", "vsrb", "cssr", "csrb", "csspr", "cssrb", "vsrs", "csrs"], "csr_name": ["csstring", "ecstring", "cs\n", "CS\n", "ac\n", "acstring", "ec\n", "CSstring"]}}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    compno = bytestream_get_byte(&s->buf);\n\n\n\n    c      += compno;\n\n    c->csty = bytestream_get_byte(&s->buf);\n\n    get_cox(s, c);\n\n\n\n    properties[compno] |= HAD_COC;\n\n    return 0;\n\n}\n", "idx": 2665, "substitutes": {"s": ["sg", "server", "js", "this", "src", "cs", "http", "ss", "spec", "qs", "ts", "rs", "sb", "a", "d", "n", "is", "i", "g", "side", "m", "ls", "ses", "sf", "sync", "xs", "settings", "sets", "ds", "ps", "gs", "ns", "p", "services", "w", "self", "e", "f", "es", "us", "sys", "sq", "sc", "u", "conf", "o", "v", "b", "su", "t", "S", "ks", "session", "os", "se", "fs", "si", "sym", "ssl"], "c": ["cs", "ctx", "cc", "mc", "r", "d", "n", "bc", "cy", "k", "i", "g", "component", "ac", "m", "code", "z", "config", "C", "ec", "dc", "ce", "x", "l", "p", "cu", "xc", "w", "e", "lc", "f", "oc", "sc", "u", "ca", "o", "pc", "v", "icc", "b", "t", "ic", "cf", "ci", "count"], "properties": ["property", "relations", "ties", "ctx", "ops", "classes", "data", "ips", "xml", "prop", "OPS", "objects", "styles", "pb", "ies", "options", "j", "fixes", "comments", "params", "details", "settings", "config", "ps", "perties", "p", "phy", "e", "lines", "effects", "features", " props", "cases", "fields", "chains", "types", "codes", "times", "pro", "bytes", "units", "les"], "compno": ["cmpno", "coordnone", "componentnumber", "coordyes", "colno", " compnos", "Compno", "complo", "coldo", "compyes", "compNo", "coordno", "procno", "compnos", " compyes", "hostnos", "componentNo", "cmpdo", "componentlo", "componentyes", "Compnumber", "compdo", "colto", "hostno", "colnumber", " compdo", " comporno", "hostNO", "compNO", "compnone", "procorno", "coordNo", " compnone", " compnumber", "hostorno", "cmpnumber", " compname", "compto", "componentno", " complo", "Complo", " compto", "compnumber", "componentname", "comporno", "Compname", "cmpto", "procNO", " compNO", " compNo", "procnos", "componentnone", "compname"]}}
{"project": "qemu", "commit_id": "615220ddaf23db4c5686053257c568b46967e4b5", "target": 1, "func": "static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n", "idx": 2673, "substitutes": {"i": ["cli", "name", "li", "gi", "abi", "key", "a", "ii", "zi", "ji", "chi", "h", "pi", "oi", "ui", "r", "window", "d", "I", "n", "type", "di", "is", "id", "it", "iu", "j", "m", "ri", "anti", "info", "ti", "slice", "multi", "index", "ai", "ip", "x", "c", "p", "l", "bi", "phi", "e", "hi", "f", "length", "alpha", "u", "disk", "o", "v", "ix", "qi", "t", "b", "uri", "ci", "io", "mu", "diff", "fi", "start", "si", "xi"], "colour_default": ["colour_desc", "colour__default", "colour_name", " colour_desc", " colour_def", "colour__diff", "colour2def", " colour_master", "colour__desc", "colour_list", " colour_name", "colour2name", " colour_diff", "colour__list", "colour_diff", "colour__master", "colour_master", "colour2default", "colour2desc", "colour__def", "colour_def", " colour_list"]}}
{"project": "FFmpeg", "commit_id": "28bf81c90d36a55cf76e2be913c5215ebebf61f2", "target": 1, "func": "static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)\n\n{\n\n#ifdef HAVE_MMX\n\n\t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)\n\n    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))\n\n#else\n\n    if(sws_flags != SWS_FAST_BILINEAR)\n\n#endif\n\n    {\n\n    \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    }\n\n    else // Fast Bilinear upscale / crap downscale\n\n    {\n\n#ifdef ARCH_X86\n\n#ifdef HAVE_MMX2\n\n\tint i;\n\n\tif(canMMX2BeUsed)\n\n\t{\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha\n\n\t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF\n\n\t\t\t\"movq %%mm2, \"MANGLE(temp0)\"\t\\n\\t\"\n\n\t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src\n\n\t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1\n\n\t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\"\n\n\t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF\n\n\n\n#define FUNNY_Y_CODE \\\n\n\t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\\n\n\t\t\t\"call \"MANGLE(funnyYCode)\"\t\\n\\t\"\\\n\n\t\t\t\"movq \"MANGLE(temp0)\", %%mm2\t\\n\\t\"\\\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\n\n\n\t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16),\n\n\t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF)\n\n\t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n\n\t\t);\n\n\t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;\n\n\t}\n\n\telse\n\n\t{\n\n#endif\n\n\t//NO MMX just normal asm ...\n\n\tasm volatile(\n\n\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx\n\n\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha\n\n\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movzbl  (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\n\n\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\n\n\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\n\n\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\n\n\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\n\n\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\n\n\t\t);\n\n#ifdef HAVE_MMX2\n\n\t} //if MMX2 cant be used\n\n#endif\n\n#else\n\n\tint i;\n\n\tunsigned int xpos=0;\n\n\tfor(i=0;i<dstWidth;i++)\n\n\t{\n\n\t\tregister unsigned int xx=xpos>>16;\n\n\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n\t\txpos+=xInc;\n\n\t}\n\n#endif\n\n    }\n\n}\n", "idx": 2677, "substitutes": {"dst": ["lsl", "Dsrc", "Dsl", "lsts", "dsp", "sdrc", "fbl", "idst", "Dsts", "idbl", "dsts", "drc", "dST", "fST", "idST", "sdsts", "cdST", "Drc", "cdst", "sst", "fst", "lST", "sdst", "sdsrc", " dsts", "dsrc", "dbl", "cdbl", "lst", "dsl", " dsl", " dST", "cdsp", "idsp", "fsp", "Dst", "DST", "ssrc", "ssts"], "dstWidth": ["drcLength", "DstW", "dstLength", " drcSize", "dspWidth", "DSTW", "dspwidth", " drcWidth", "dblLength", "dscLength", "dSTSize", "dscW", "DSTLength", "dSTwidth", "DSTSize", "DstLength", "dsrcHeight", " drcHeight", "dsrcLength", "Dstwidth", "drcHeight", "drcWidth", "DstSize", "dscwidth", "dsrcWidth", "dSTWidth", "dblSize", "dspW", "dconstSize", "dspHeight", "DstWidth", "dstSize", "DstHeight", " dstHeight", " dSTLength", "dblHeight", "DSTwidth", " dSTWidth", "dstHeight", "dsrcwidth", "drcSize", "dconstwidth", "dSTHeight", " dstSize", "drcwidth", " dstwidth", "DSTWidth", "dconstWidth", " drcLength", "DSTHeight", " dSTHeight", "dscWidth", "dstW", "dSTLength", "dstwidth", " dSTwidth", " dstLength", "dSTW", "dblWidth", "dscSize", "dconstLength", "dscHeight"], "src": ["include", "sub", "rib", "sup", "ctx", "rest", "stat", "spec", "rs", "Source", "ruby", "filename", "url", "loc", "SOURCE", "RC", "sl", "ipl", "gz", "buf", "fps", "SourceFile", "rb", "ls", "secure", "dest", "sync", "slice", "source", "feat", "config", "st", "asc", "sel", "jpg", "attr", "sq", "sc", "gb", "sr", "lib", "seq", "rss", "inst", "sur", "conv", "img", "rin", "inf", "rc"], "srcW": ["sourceH", "srcL", "sthM", "instW", "destL", "sourceWidth", " srcH", " srcM", "sthW", "srcH", " srcL", " srcWidth", "sourceM", "srcM", "sourceW", "sthWidth", "instL", "instH", "sthH", "instWidth", "destH", "destWidth", "destW", "srcWidth"], "xInc": ["xInit", "sexIncre", "XExp", "contentExc", "ixInc", "xExc", "contentInc", " xMin", "xInst", "xIncre", "XIncre", "sexInc", " xSec", "Xinc", "XInst", "XInc", "fxIncre", "sexSec", "xINC", "sexExc", "xDec", "ixExp", "XInit", " xInst", "yExp", "xinc", "ixInit", "yExc", " xExp", "contentInst", " xDec", "xMin", "ixinc", "fxExc", "yINC", " xinc", "XINC", "yIncre", "xSec", "XDec", "fxDec", "yinc", "XMin", "fxInc", " xINC", "yMin", " xExc", " xIncre", " xInit", "xExp", "XExc", "yInc", "contentInit", "XSec"], "i": ["li", "gi", "a", "ni", "ii", "zi", "ji", "ui", "pi", "mini", "d", "I", "n", "is", "id", "it", "iu", "j", "g", "m", "ti", "index", "z", "ai", "ie", "ip", "l", "c", "p", "phi", "bi", "x", "e", "f", "u", "ion", "o", "v", "b", "ix", "qi", "ci", "io", "on", "fi", "in", "xi"], "FUNNY_Y_CODE": ["FUNNY_Y_ACCE", "FUNNY_YAMCODE", "FUNNY_YOPCODE", "FUNNY_Y_ACORE", "FUNNY_YAMCATE", "FUNNY_Y_LCATE", "FUNNY_Y_LCPE", "FUNNY_Y_CTE", "FUNNY_YAMCLODE", "FUNNY_YADSCODE", "FUNNY_Y_CORE", "FUNNY_Y_ERCode", "FUNNY_Y2CIDE", "FUNNY_Y2ERCPE", "FUNNY_Y_ECONE", "FUNNY_YADCORE", "FUNNY_Y_OCODE", "FUNNY_YADSCTE", "FUNNY_Y_ECOD", "FUNNY_YADCTE", "FUNNY_YOPVCATE", "FUNNY_Y_Fodes", "FUNNY_Y_CPE", "FUNNY_Y_CSE", "FUNNY_Y_Code", "FUNNY_Y_ERCATE", "FUNNY_Y_CIDE", "FUNNY_Y_ACIDE", "FUNNY_Y_ECTE", "FUNNY_Y_OCONE", "FUNNY_Y_Lodes", "FUNNY_Y_SCCE", "FUNNY_Y_VCATE", "FUNNY_Y_ERCSE", "FUNNY_Y_BCORE", "FUNNY_Y_ECATE", "FUNNY_Y2ACODE", "FUNNY_YADCodes", "FUNNY_Y2ACATE", "FUNNY_Y_SCORE", "FUNNY_Y_OCATE", "FUNNY_Y_Codes", "FUNNY_Y2ERCSE", "FUNNY_Y_LCOD", "FUNNY_YAMCLodes", "FUNNY_Y_FODE", "FUNNY_Y_COME", "FUNNY_Y_LOME", "FUNNY_YAMCAME", "FUNNY_Y_ACATE", "FUNNY_Y2CSE", "FUNNY_Y_CONE", "FUNNY_YADSCCE", "FUNNY_YADCATE", "FUNNY_Y_ECodes", "FUNNY_Y_LCSE", "FUNNY_YOPCATE", "FUNNY_Y2CPE", "FUNNY_Y_SCODE", "FUNNY_Y_BCCE", "FUNNY_Y_CLodes", "FUNNY_Y2ERCODE", "FUNNY_Y_KODE", "FUNNY_Y2CATE", "FUNNY_Y_ERCodes", "FUNNY_Y_LONE", "FUNNY_Y_ERCAME", "FUNNY_Y_LCODE", "FUNNY_Y_CLAME", "FUNNY_Y_SCOME", "FUNNY_Y_CAME", "FUNNY_Y_ACodes", "FUNNY_YADSCORE", "FUNNY_Y_SCTE", "FUNNY_Y2ACIDE", "FUNNY_Y_ACODE", "FUNNY_YOPCodes", "FUNNY_Y_Fode", "FUNNY_Y2ACodes", "FUNNY_Y_CATE", "FUNNY_Y_LTE", "FUNNY_Y2CODE", "FUNNY_Y_ERCODE", "FUNNY_Y_VCode", "FUNNY_Y_SCOD", "FUNNY_Y_CCE", "FUNNY_Y_ECIDE", "FUNNY_YADCOME", "FUNNY_YADCCE", "FUNNY_YADCODE", "FUNNY_Y_VCODE", "FUNNY_Y_CLATE", "FUNNY_Y_SCIDE", "FUNNY_YOPCode", "FUNNY_YADSCOD", "FUNNY_YAMCodes", "FUNNY_Y_LATE", "FUNNY_Y_HODE", "FUNNY_Y_CLODE", "FUNNY_YAMCLATE", "FUNNY_Y_LCTE", "FUNNY_Y_LCode", "FUNNY_Y_BCATE", "FUNNY_Y_HOME", "FUNNY_YADSCATE", "FUNNY_Y_Kode", "FUNNY_Y_Hodes", "FUNNY_YOPVCode", "FUNNY_Y_BCODE", "FUNNY_YOPVCodes", "FUNNY_Y_KPE", "FUNNY_Y2Code", "FUNNY_Y_SCATE", "FUNNY_Y_SCodes", "FUNNY_Y_FATE", "FUNNY_Y_SCONE", "FUNNY_Y_HATE", "FUNNY_Y_SCAME", "FUNNY_Y_KSE", "FUNNY_Y_ECODE", "FUNNY_YADCOD", "FUNNY_Y_SCode", "FUNNY_YAMCLAME", "FUNNY_Y2ERCode", "FUNNY_Y_VCodes", "FUNNY_YADSCodes", "FUNNY_Y_LODE", "FUNNY_Y2Codes", "FUNNY_YADSCOME", "FUNNY_YOPVCODE", "FUNNY_Y_ERCPE", "FUNNY_Y_COD"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 2680, "substitutes": {"f": ["fd", "fen", "a", "fw", "fa", "r", "d", "n", "lf", "buff", "elf", "rf", "F", "i", "g", "m", "file", "fp", "info", "df", "fr", "h", "l", "c", "p", "x", "w", "e", "self", "ref", "fat", "fx", "o", "b", "t", "fs"], "pv": ["pf", "Pvt", "lpf", " pf", "Pv", "ppsv", " pV", "ppV", "lpV", " psv", "PV", "Psv", "lpv", "ppf", "Pf", "ppv", "psv", " pvt", "lpvt", "pV", "pvt"], "size": ["SIZE", "ss", "ize", "small", " sizes", "k", "i", "g", "m", " Size", "z", "fe", "h", "l", "c", "w", "e", "len", "ffff", "length", "Size", "sec", "shape", "si"], "v": ["vp", "q", "vt", "volt", "d", "n", "k", "y", "i", "j", "g", "m", "ve", "sv", "x", "l", "c", "p", "h", "w", "e", "u", "V", "o", "s", "b", "vi", "t", "nv", "val", "volume"], "v2": ["vtwo", "i1", "itwo", "V1", "Vtwo", "p1", "iii", "vii", "pii", " vii", "ptwo", "cv1", "cv2", "v1", " vtwo", "V2", "p2", " v1", "i2", "cvtwo"]}}
{"project": "FFmpeg", "commit_id": "c5f15f40b9b25f033fd9e8dd1e12763913098c11", "target": 1, "func": "static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    uint8_t nal;\n\n    uint8_t type;\n\n    int result = 0;\n\n\n\n    if (!len) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Empty H264 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    nal  = buf[0];\n\n    type = nal & 0x1f;\n\n\n\n    assert(data);\n\n    assert(buf);\n\n\n\n    /* Simplify the case (these are all the nal types used internally by\n\n     * the h264 codec). */\n\n    if (type >= 1 && type <= 23)\n\n        type = 1;\n\n    switch (type) {\n\n    case 0:                    // undefined, but pass them through\n\n    case 1:\n\n        av_new_packet(pkt, len + sizeof(start_sequence));\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n        COUNT_NAL_TYPE(data, nal);\n\n        break;\n\n\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n\n        // consume the STAP-A NAL\n\n        buf++;\n\n        len--;\n\n        // first we are going to figure out the total size\n\n        {\n\n            int pass         = 0;\n\n            int total_length = 0;\n\n            uint8_t *dst     = NULL;\n\n\n\n            for (pass = 0; pass < 2; pass++) {\n\n                const uint8_t *src = buf;\n\n                int src_len        = len;\n\n\n\n                while (src_len > 2) {\n\n                    uint16_t nal_size = AV_RB16(src);\n\n\n\n                    // consume the length of the aggregate\n\n                    src     += 2;\n\n                    src_len -= 2;\n\n\n\n                    if (nal_size <= src_len) {\n\n                        if (pass == 0) {\n\n                            // counting\n\n                            total_length += sizeof(start_sequence) + nal_size;\n\n                        } else {\n\n                            // copying\n\n                            assert(dst);\n\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n\n                            dst += sizeof(start_sequence);\n\n                            memcpy(dst, src, nal_size);\n\n                            COUNT_NAL_TYPE(data, *src);\n\n                            dst += nal_size;\n\n                        }\n\n                    } else {\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n\n                    }\n\n\n\n                    // eat what we handled\n\n                    src     += nal_size;\n\n                    src_len -= nal_size;\n\n\n\n                    if (src_len < 0)\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n\n                }\n\n\n\n                if (pass == 0) {\n\n                    /* now we know the total size of the packet (with the\n\n                     * start sequences added) */\n\n                    av_new_packet(pkt, total_length);\n\n                    dst = pkt->data;\n\n                } else {\n\n                    assert(dst - pkt->data == total_length);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 25:                   // STAP-B\n\n    case 26:                   // MTAP-16\n\n    case 27:                   // MTAP-24\n\n    case 29:                   // FU-B\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n\n               type);\n\n        result = AVERROR(ENOSYS);\n\n        break;\n\n\n\n    case 28:                   // FU-A (fragmented nal)\n\n        buf++;\n\n        len--;                 // skip the fu_indicator\n\n        if (len > 1) {\n\n            // these are the same as above, we just redo them here for clarity\n\n            uint8_t fu_indicator      = nal;\n\n            uint8_t fu_header         = *buf;\n\n            uint8_t start_bit         = fu_header >> 7;\n\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n\n            uint8_t nal_type          = fu_header & 0x1f;\n\n            uint8_t reconstructed_nal;\n\n\n\n            // Reconstruct this packet's true nal; only the data follows.\n\n            /* The original nal forbidden bit and NRI are stored in this\n\n             * packet's nal. */\n\n            reconstructed_nal  = fu_indicator & 0xe0;\n\n            reconstructed_nal |= nal_type;\n\n\n\n            // skip the fu_header\n\n            buf++;\n\n            len--;\n\n\n\n            if (start_bit)\n\n                COUNT_NAL_TYPE(data, nal_type);\n\n            if (start_bit) {\n\n                /* copy in the start sequence, and the reconstructed nal */\n\n                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n                pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n\n                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n\n            } else {\n\n                av_new_packet(pkt, len);\n\n                memcpy(pkt->data, buf, len);\n\n            }\n\n        } else {\n\n            av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H264 RTP packet\\n\");\n\n            result = AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n\n\n    case 30:                   // undefined\n\n    case 31:                   // undefined\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n\n        result = AVERROR_INVALIDDATA;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return result;\n\n}\n", "idx": 2704, "substitutes": {"ctx": ["cm", "cli", "cam", "hw", "conn", "context", "anc", "cc", "cl", "cpp", "Context", "loc", "ct", "ck", "bc", "client", "na", "cas", "ux", "kt", "tx", "fp", "cb", "lex", "util", "sync", "config", "crit", "ack", "pkg", "c", "cv", "xc", "lc", "cn", "sc", "ca", "ctrl", "jp", "wcs", "la", "cmd", "exec", "vc", "cca", "qa", "cp", "cmp", "req", "cf", "conv", "ci", "ann", "sci", "rc"], "data": ["queue", "open", "empty", "client", "next", "first", "code", "master", "database", "shift", "DATA", "start", "da", "read", "context", "align", "bc", "id", "parent", "end", "api", "batch", "tx", "write", "pkg", "bus", "p", "length", "la", "final", "session", "val", "load", "response", "input", "media", "a", "record", "proc", "body", "slice", "ds", "last", "content", "pad", "result", "loader", "cache", "stream", "connection", "req", "bytes", "img", "reg", "Data", "done", "buffer", "append", "def", "conn", "memory", "window", "d", "class", "results", "aa", "grad", "pos", "source", "config", "reader", "exec", "dat"], "st": ["stage", "rest", "ss", "sa", "sb", "ct", "St", "nt", "str", "capt", "stack", "ut", "sc", "ST", "std", "rd", "sts", "sta", "inst", "ost", "nd", "ast", "pt", "start", "sth", "est"], "pkt": ["cpeth", "cacket", " pqt", "bet", " packet", " pct", "Pqt", "Pst", "cpqt", "pet", "beth", "bkt", " pet", "Pck", "peth", " pst", "cpkt", "cck", "bct", "cst", "bqt", " pck", "pst", "cpacket", "Pet", "ckt", "pqt", "Peth", "pck", "pct", "packet", "backet", "cpct", "Pkt", "Pct", "Packet"], "timestamp": ["typend", "payence", "timestr", "paystr", "typstr", "timeend", "timeence", "timeestamp", "typence", "payend", "timence", "payestamp", "timstr", "timend", "typestamp"], "buf": ["ff", "fd", "buffer", "bh", "bag", "array", "context", "queue", "txt", "prot", "window", "aux", "bc", "buff", "callback", "orig", "bin", "pb", "tmp", "cas", "batch", "pos", "rb", "proc", "fp", "box", "dest", "cb", "pool", "config", "feat", "begin", "pad", "result", "pkg", "cv", "Buffer", "vec", "wb", "ref", "br", "cap", "text", "uint", "la", "cache", "ctr", "cmd", "bb", "hl", "b", "fb", "cp", "cmp", "conv", "cf", "uf", "port", "limit", "fi", "uc", "rc", "mem"], "len": ["delay", "fun", "fd", "li", "lan", "offset", "channel", "split", "elt", "tail", "Len", "loc", "n", "lvl", "dl", "fl", "ln", "sl", "lf", "bin", "lang", "fn", "end", "num", "pre", "lim", "pos", "body", "ll", "partial", "nt", "slice", "rev", "z", "lon", "l", "fin", "vec", "lc", "length", "size", "f", "la", "el", "il", "en", "hl", "lin", "bytes", "full", "line", "low", "val", "count", "limit", "all", "mem"], "seq": ["unit", "name", "version", "buffer", "sequence", "queue", "cl", " sequence", "nc", "format", "frame", "num", "cas", "pos", "code", "cb", "config", "vec", "ref", "sec", "qa", "req", "gen", "val", "count", "desc", "pack"], "flags": ["ff", "fd", "version", "cs", "Flags", "ops", "bit", "lag", "vals", "ips", "prot", "reads", "format", "options", "pos", "ls", "bits", "ats", "cb", "status", "ffff", "flag", "ints", "rows", "mask", "stats", "types", "bytes"], "nal": ["rnal", "nanalis", "ynAL", "naler", " nmal", "Nals", "rnbal", " nAL", "nanatal", "gnaval", "ynal", "anAL", " naval", " nalis", "nanal", "nals", "naval", "rnAL", "pnal", "anal", "Naval", "gnal", "pnAL", "ynbal", "nAL", " nbal", "pnmal", " naler", "gnatal", "anals", "gnals", "nmal", "nalis", "ynaler", "nanals", "pnals", "anmal", " nals", "natal", "Nalis", "Natal", " natal", "rnaler", "nbal", "Nal"], "type": ["unit", "base", "name", "version", "time", "key", "bit", "pe", "ype", "new", "class", "tag", "ping", "ver", "position", "format", "kind", "id", "trial", "like", "parent", "op", "ty", "y", "year", "py", "pos", "code", "info", "event", "Type", "style", "index", "x", "block", "p", "state", "length", "ref", "value", "comment", "phase", "action", "error", "types", "t", "valid", "sort", "TYPE", "count", "mode", "part", "shape", "typ", "port"], "dst": ["rdsc", "sdost", "idost", "dset", "adset", "rdsts", "Dset", "idst", "adsc", "Dsts", "sdset", "idsc", "rdST", "dsc", "idbl", "adbl", "adst", "dsts", "adste", "dST", "idST", "ssc", "sdsts", "rdst", "Dost", " dset", "sst", "adsts", "sST", "sdst", " dsc", " dsts", "dbl", "dste", "idste", "Dsc", " dST", " dost", "Dste", "Dst", "dost", "DST", "Dbl", "ssts"], "pass": ["stage", "flow", "allow", "test", "level", " bypass", "name", "row", "act", "skip", "ass", "def", "access", "r", "prop", "use", "cas", "loop", "fail", "pos", "proc", "code", "scan", "password", "push", "slice", "parse", "feed", "post", "step", "secret", "sc", "miss", "ress", "Pass", "loss", "win", "PASS", "pull", "qa", "ose", "catch", "path", "gen", "run", "mode", "view", "strip", "ride", "cess", "day", "pack", "port"], "src": ["sub", "rib", "sup", "rest", "rs", "ource", "spec", "access", "url", "filename", "loc", "rob", "flash", "RC", "sl", "cur", "rb", "proc", "secure", "dest", "ser", "sync", "scan", "cb", "slice", "source", "feat", "config", "select", "sel", "start", "size", "length", "attr", "sc", "sq", "stream", "sr", "sn", "rss", "serv", "supp", "sur", "cmp", "uri", "req", "inst", "img", "gl", "uc", "desc", "dist", "rc", "ssl"]}}
{"project": "qemu", "commit_id": "4cdd01d32ee6fe04f8d909bfd3708be6864873a2", "target": 0, "func": "void bdrv_refresh_filename(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QDict *opts;\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* This BDS's file name will most probably depend on its file's name, so\n\n     * refresh that first */\n\n    if (bs->file) {\n\n        bdrv_refresh_filename(bs->file->bs);\n\n    }\n\n\n\n    if (drv->bdrv_refresh_filename) {\n\n        /* Obsolete information is of no use here, so drop the old file name\n\n         * information before refreshing it */\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        drv->bdrv_refresh_filename(bs);\n\n    } else if (bs->file) {\n\n        /* Try to reconstruct valid information from the underlying file */\n\n        bool has_open_options;\n\n\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        opts = qdict_new();\n\n        has_open_options = append_open_options(opts, bs);\n\n\n\n        /* If no specific options have been given for this BDS, the filename of\n\n         * the underlying file should suffice for this one as well */\n\n        if (bs->file->bs->exact_filename[0] && !has_open_options) {\n\n            strcpy(bs->exact_filename, bs->file->bs->exact_filename);\n\n        }\n\n        /* Reconstructing the full options QDict is simple for most format block\n\n         * drivers, as long as the full options are known for the underlying\n\n         * file BDS. The full options QDict of that file BDS should somehow\n\n         * contain a representation of the filename, therefore the following\n\n         * suffices without querying the (exact_)filename of this BDS. */\n\n        if (bs->file->bs->full_open_options) {\n\n            qdict_put_obj(opts, \"driver\",\n\n                          QOBJECT(qstring_from_str(drv->format_name)));\n\n            QINCREF(bs->file->bs->full_open_options);\n\n            qdict_put_obj(opts, \"file\",\n\n                          QOBJECT(bs->file->bs->full_open_options));\n\n\n\n            bs->full_open_options = opts;\n\n        } else {\n\n            QDECREF(opts);\n\n        }\n\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n\n         * so the full options QDict should be equal to the options given\n\n         * specifically for this block device when it was opened (plus the\n\n         * driver specification).\n\n         * Because those options don't change, there is no need to update\n\n         * full_open_options when it's already set. */\n\n\n\n        opts = qdict_new();\n\n        append_open_options(opts, bs);\n\n        qdict_put_obj(opts, \"driver\",\n\n                      QOBJECT(qstring_from_str(drv->format_name)));\n\n\n\n        if (bs->exact_filename[0]) {\n\n            /* This may not work for all block protocol drivers (some may\n\n             * require this filename to be parsed), but we have to find some\n\n             * default solution here, so just include it. If some block driver\n\n             * does not support pure options without any filename at all or\n\n             * needs some special format of the options QDict, it needs to\n\n             * implement the driver-specific bdrv_refresh_filename() function.\n\n             */\n\n            qdict_put_obj(opts, \"filename\",\n\n                          QOBJECT(qstring_from_str(bs->exact_filename)));\n\n        }\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->exact_filename[0]) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n\n    } else if (bs->full_open_options) {\n\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n\n                 qstring_get_str(json));\n\n        QDECREF(json);\n\n    }\n\n}\n", "idx": 2737, "substitutes": {"bs": ["ob", "js", "qs", "bps", "lb", "banks", "ros", "pb", "ls", "ses", "outs", "bas", "css", "vs", "us", "s", "ubs", "fs", "abi", "ts", "sb", "BS", "ib", "ums", "bc", "bl", "bits", "utils", "bus", "lc", "bu", "web", "os", "ks", "its", "plugins", "obs", "base", "cs", "ctx", "ss", "bh", "ba", "rs", "ab", "ins", "bin", "blog", "bis", "cb", "ds", "ps", "gs", "ns", "bot", "br", "tails", "bt", "lbs", "obj", "bb", "bp", "bytes", "las", "res", "files", "null", "http", "ops", "bn", "eb", "bid", "bel", "bing", "details", "box", "ats", "sync", "ras", "abc", "bf", "block", "bi", "bos", "gb", "blocks", "iss", "fb", "b", "full", "bes", "console", "db"], "drv": ["frv", "crf", "drvm", "delvm", " drvr", "rrver", "frb", "hrf", "rdver", "prvr", " drp", "dru", "hrva", "hrv", "drva", "frV", "driva", "rrv", "delf", "crv", "drp", "srv", "srV", "hrav", "derv", "prv", "crp", "srvr", "drav", "drif", " drver", "delv", "srl", "frvr", "drf", "srf", "rdu", "hrvr", "drV", "delb", "vrvr", "rdv", "vrf", "vrv", "driv", "srp", "prf", " dru", "hrvm", "prav", "derf", "derb", "srb", " drva", "srvm", "rrb", "driver", "crl", "vrav", "drb", " drl", "dervr", " drV", "drver", "rdb", " drb", "rru", "drvr", "drl", "hrver", " drf", "hrb"], "opts": ["ryTs", "catters", "OPds", " optt", "catments", "OPts", "ryte", " optths", "ryts", "rytics", " optted", "opted", "lockts", "opks", "catouts", " optcs", "optter", "opouts", " optx", "optted", " optters", "opergs", "opt", "catter", "opcs", "operouts", " opcs", "opertes", "optty", "opertips", " opths", "opty", "operds", "opte", " optons", " opttes", "optters", "hopte", "lockgs", "optgs", "operters", "opments", " opTs", "opert", "optes", " optics", "ioptx", " opgs", "opds", " opt", "optips", "optcs", " opments", "opttes", " optes", " optts", "catt", "ropouts", "opter", "OPments", "cattips", "operty", "optt", " opte", "catts", "lockters", "operter", "operths", "ropts", "OPks", "OPt", " opds", "opttx", " opters", "opTs", "optx", "ropters", " opty", " opks", "roptips", "OPte", " optte", "hopts", "hopTs", "optons", "hoptics", " optty", "optics", "cattes", "OPters", "opgs", "optts", "opertons", "operks", "locktons", "iopgs", "iopters", "OPted", "operts", "opths", "iopts", "opters", "optte"], "has_open_options": ["has_close_option", "has_open_name", "has_openacoption", "has_open_opens", "has_open_events", "has_open___options", "has_close_events", "has_open___name", "has_close_files", "has_openacoptions", "has_close_name", "has_open_option", "has_open_files", "has_open___events", "has_close_options", "has_openacopens"]}}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "static inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n\n{\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n            /* exit request from the cpu execution loop */\n\n            *ret = cpu->exception_index;\n\n            if (*ret == EXCP_DEBUG) {\n\n                cpu_handle_debug_exception(cpu);\n\n            }\n\n            cpu->exception_index = -1;\n\n            return true;\n\n        } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n            /* if user mode only, we simulate a fake exception\n\n               which will be handled outside the cpu execution\n\n               loop */\n\n#if defined(TARGET_I386)\n\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n\n            cc->do_interrupt(cpu);\n\n#endif\n\n            *ret = cpu->exception_index;\n\n            cpu->exception_index = -1;\n\n            return true;\n\n#else\n\n            if (replay_exception()) {\n\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n\n                qemu_mutex_lock_iothread();\n\n                cc->do_interrupt(cpu);\n\n                qemu_mutex_unlock_iothread();\n\n                cpu->exception_index = -1;\n\n            } else if (!replay_has_interrupt()) {\n\n                /* give a chance to iothread in replay mode */\n\n                *ret = EXCP_INTERRUPT;\n\n                return true;\n\n            }\n\n#endif\n\n        }\n\n#ifndef CONFIG_USER_ONLY\n\n    } else if (replay_has_exception()\n\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n\n        /* try to cause an exception pending in the log */\n\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n\n        *ret = -1;\n\n        return true;\n\n#endif\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 2762, "substitutes": {"cpu": ["ilo", "chu", "cli", "roc", "device", "gc", "lb", "process", "clock", "nc", "px", "client", "CPU", "cu", "css", "phy", "linux", "cp", "socket", "uu", "consumer", "mc", "host", "ubuntu", "component", "mac", "python", "cow", "lc", "core", "fc", "np", "uno", "ctx", "cpp", "computer", "GPU", "boot", "instance", "kernel", "proxy", "proc", "pid", "pool", "c", "pu", "loader", "cache", "chip", "processor", "node", "ucc", "uca", "slave", "uc", "vm", "null", "server", "gpu", "intel", "hw", "uci", "colo", "platform", "comp", "auc", "config", "bench", "dc", "ocr", "cn", "username", "pc", "cmp", " CPU", "cfg", "que", "console"], "ret": ["match", "test", "arg", "fun", "att", "mt", "def", "success", "data", "url", "ct", "alt", "job", "pet", "rets", "fit", "num", "rf", "fail", "rep", "code", "ft", "nt", "rev", "back", "reply", "feat", "Ret", "rc", "pat", "sat", "result", "pret", "et", "len", "ref", "flag", "eth", "art", "resp", "RET", "seq", "valid", "lit", "re", "reg", "val", "rt", "let", "fi", "det", "res"], "cc": ["cs", "ctx", "conn", "mc", "anc", "cl", "gc", "uc", "ck", "co", "nc", "RC", "bc", "UC", "cci", "con", "tc", "client", "mac", "ac", "code", "ec", "dc", "ack", "cu", "c", "css", "cv", "xc", "lc", "cn", "ca", "sc", "cache", "core", "vc", "cca", "pc", "cmp", "ucc", "cf", "ci", "BC", "CC", "acc", "rc"]}}
{"project": "FFmpeg", "commit_id": "1169f0d0afc0454633cfcfad73643f0458521c67", "target": 0, "func": "void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)\n\n{\n\n#if HAVE_INLINE_ASM\n\n    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {\n\n        if (ctx->cid_table->bit_depth == 8)\n\n            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;\n\n    }\n\n#endif /* HAVE_INLINE_ASM */\n\n}\n", "idx": 2793, "substitutes": {"ctx": ["cm", "cms", "gpu", "cam", "cs", "hw", "conn", "context", "gc", "mc", "cc", "cpp", "fw", "loc", "ct", "aux", "nc", "bc", "tc", "buf", "na", "cas", "mac", "fp", "tx", "cb", "settings", "config", "pkg", "c", "cv", "xc", "lc", "cn", "ca", "ctrl", "exec", "alloc", "vc", "pc", "cca", "qa", "cp", "cmp", "cf", "conv", "ci", "sci", "rc"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 2806, "substitutes": {"env": ["eu", "oa", "vm", "server", "ctx", "ext", "fen", "em", "conn", "context", "esi", "txt", "her", "equ", "environment", "shell", "priv", "ea", "eng", "enc", "gear", "ef", "eni", "proc", "erv", "enh", "ah", "style", "ep", "config", "kn", "ec", "exc", " environment", "ack", "Environment", "c", "et", "e", "loader", "conf", "cache", "viron", "chal", "obj", "en", " environments", "iss", "ev", "site", "manager", "session", "aer", "img", "engine", "qt", "que", "console", "energy", "db", "ench"], "arg1": ["ar2", "ar1", "argument3", "ax2", "argument2", "arkone", "ar01", "ark2", " arg3", " arg01", "arg01", "ark1", "ark01", "ax01", "ar3", "axone", "argument01", "argone", "argument1", "arg3", "ax1", " argone"], "arg2": ["param1", "paramTwo", "param2", "argsTwo", "argetb", " argTwo", "Arg82", " argb", "arg82", "Argb", "arget1", "arg0", "args2", "Arg1", "arget2", " arg82", "args0", "arget82", "argTwo", "param0", "Arg2", "args1", "argb", " arg0"], "farg1": ["frargumentinf", "ferg21", "farg41", "fari11", "fagn11", " fval01", "frarg1", "ferg1", "fconfig1", "ferg41", "fagn0", "frargument41", "fark4", "frargument61", "infagnpart", "fax1", "fackpart", "fargsb", "infagn41", "cvalone", "farginf", " fArg3", "fArg0", "fag21", " fArg11", "ferginf", "infargh", "fasc3", " fArg31", "fargumentinf", "sfark4", "fArgn", "fargone", "carg3", "fargs01", "fagn81", "frargument1", " fArg1", "fArg81", "Farg1", "fargback", "farg3", " fargonce", "fArg3", "fax4", "fArg31", "farg0", "carg1", "fasc41", "farg31", "farg11", "fasc01", "cargone", "sfark1", "fconfigpart", "fagnonce", "fargh", "sfarg0", "fack1", " farg5", "sfargn", "fArg01", "farg21", "fargs3", "farg01", " farg31", "fargs4", "fval3", "fcard5", "frarginf", "fax0", "fag1", " ferg1", "cval3", " fArgonce", " farg11", "fagnh", "ferg5", " ferg5", "fconfig41", " farg41", "infarg1", "fconfigh", "fArgone", "faginf", "infagnh", "infarg41", " fval3", "fargonce", "fag61", "fcardback", "fergback", " fArg0", "fval1", "fArgb", " farg01", "fari81", "fval41", "Farg3", "fArg11", "fari1", "Fargn", "fArg2", "farg5", "cval1", "frg31", "fark1", "fagn31", "ferg61", "fargument41", "frg3", "fArgonce", " fargb", "faxn", "fag5", "sfark0", " farg0", "fagnpart", "fargsn", "frarg41", " farg81", "fag41", "Fargs3", "fval01", " fval41", "fArg1", "fagn1", "fagn3", "infagn1", " farg3", "sfarg1", "fargs1", "fargs41", "farkn", "fvalone", "fargs0", "frg1", "Fargsone", "farg61", "fackh", "farg4", "cvaln", "fcard21", "fagn41", "Fargs1", "Fargsn", "Fargone", "fasc1", "fargument1", " fargback", " ferg21", "fari0", "fack41", "infargpart", "fvaln", " farg21", "fargsone", "fagback", "fargument61", "sfarg4", "sfarkn", "fark0", "fargs2", " fArg81", "fargpart", "fargn", "cargn", "fargb", "frarg61", " fergback", "farg81", "frgonce", " fval1", "fcard1"], "farg2": ["fparam2", "fargument2", " farg02", "cvaltwo", " fark1", "farg96", "cargtwo", "fargsb", "fvalidpage", "fArg0", " farg52", "freg2", "forig2", " fArgb", "fArgtwo", "infargpage", "fargpage", "fval52", "carg3", "farkB", "farc2", "fitemtwo", "cargb", "fpar52", " fArgtwo", "fval2", " fark2", "farg3", "fregb", "fig96", "fitempage", "farg0", "fparamb", "farg52", "fpar2", "fvalid2", "farmtwo", "fargB", "forig5", "infitem82", "cvalb", "fargs3", "fval3", "carg2", "infarg2", "freg5", "cval3", "fitem2", "forarg96", "fargument96", "forigtwo", "farm96", " fArg2", "farcpage", "fark02", "fvalid82", "fparam0", " fArg0", "fArgb", "forarg2", " fargB", " fargtwo", "fArg2", "farg5", "forargtwo", "fitem82", "fark1", "freg96", " fargb", "fpartwo", " fval96", "cval2", "fargsB", "farg02", " farg0", "fvaltwo", "fval96", " fval2", "fargs02", "fargstwo", "farc82", "fargument52", "infitemtwo", "fparamtwo", "farm2", "fvalidtwo", "fargtwo", "fpar96", "fig2", "infargtwo", "figtwo", "fargs1", " farkB", " fark02", "fargs0", " fval52", "freg3", "fvalb", " fvaltwo", "forig96", "infarg82", " farg96", "infitempage", "fregtwo", "infitem2", "fig5", "farctwo", "fargs2", "farm5", "fargumenttwo", "farg82", "fargb", "forarg5", "fark2"]}}
{"project": "qemu", "commit_id": "e4d2edc9d0c58de421eb349871e90b67edec0b9c", "target": 0, "func": "static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n", "idx": 2817, "substitutes": {"async": ["assynchronous", "aock", "ASock", "aitync", "aync", "nasync", "anc", "aitnc", "nasynchronous", "asyn", " assync", "nasyn", "asock", " asyn", "aynchronous", "ASynchronous", "assyn", "ASync", "aitynchronous", "asynchronous", "assync", "nassync", "asssync", " asynchronous", "asnc", "ASnc", "aitock"], "listen_addr": ["listenMaddr", "listenraddr", "listen_eth", "listeren_anne", "listeren_adr", "listenMurl", "listen64node", "listzen_addr", "listener_address", "listen_oa", "listzenMaddr", "listen_anne", "listent_adr", "listener_node", "listen64orig", "listen_ad", "listenroa", "listenranne", "listerenradr", "listener_dr", "listzen_host", "listent_osi", "listener_orig", "listen_ptr", "listerenroa", "listerenraddr", "listening_ptr", "listen_dist", "listenwnode", "listeren_oa", "listenMhost", "listen_host", "listener_dist", "listent_oa", "listen64address", "listenradr", "listeren_addr", "listzenMhost", "listening_address", "listen_ord", "listen__ad", "listent_addr", "listzenMaddress", "listenMaddress", "listen64addr", "listener_eth", "listenadaddress", "listerenranne", "listenadaddr", "listen_orig", "listening_ad", "listenworig", "listenwaddress", "listen_dr", "listen_url", "listenwaddr", "listen__address", "listen_osi", "listen__addr", "listen_adr", "listzen_address", "listen__ptr", "listen_node", "listener_addr", "listening_addr", "listzenMurl", "listenadad", "listener_ord", "listzen_url", "listen_address", "listenadptr"], "connect_addr": ["connectingerror", "connectableloc", "connectionadd", "connect_node", "connectureaddr", "sign_addr", "connection_loc", "connection_url", " connect_adr", "connect_dr", "connect_attr", "connectioningloc", "connect_part", "connect_ad", "conn_host", "connect_url", "connect_oa", "connectableaddress", "sign_obj", " connect_node", "connectioningaddr", "connecturead", "connectureid", "connect_obj", "connectingloc", " connect_id", "connectioningurl", "conn_oa", "connect_id", "connect_ace", " connect_add", "connectingaddr", "connect_address", "connectableattr", "connectionadr", "connectionaddr", "connect_add", "sign_adr", "close_part", "sign_ace", "connect_error", "connectionace", "connect_loc", "conn_addr", "config_dist", " connect_amd", "connect_host", "connect_ord", "connectableaddr", "connectablepart", "connectingurl", "config_addr", "connecturenode", " connect_ad", "config_ord", "close_addr", "connectableurl", "connectionobj", "config_dr", "connect_amd", "conn_ack", "close_address", "connect_dist", "connectableerror", "connect_adr", "connection_addr", "connectioningerror", "connect_ack", "connection_error", "close_attr", "connectionamd"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson_cp2\";\n\n    uint32_t opc, shift_max;\n\n    TCGv_i64 t0, t1;\n\n\n\n    opc = MASK_LMI(ctx->opcode);\n\n    switch (opc) {\n\n    case OPC_ADD_CP2:\n\n    case OPC_SUB_CP2:\n\n    case OPC_DADD_CP2:\n\n    case OPC_DSUB_CP2:\n\n        t0 = tcg_temp_local_new_i64();\n\n        t1 = tcg_temp_local_new_i64();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new_i64();\n\n        t1 = tcg_temp_new_i64();\n\n        break;\n\n    }\n\n\n\n    gen_load_fpr64(ctx, t0, rs);\n\n    gen_load_fpr64(ctx, t1, rt);\n\n\n\n#define LMI_HELPER(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break\n\n#define LMI_HELPER_1(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break\n\n#define LMI_DIRECT(UP, LO, OP) \\\n\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break\n\n\n\n    switch (opc) {\n\n    LMI_HELPER(PADDSH, paddsh);\n\n    LMI_HELPER(PADDUSH, paddush);\n\n    LMI_HELPER(PADDH, paddh);\n\n    LMI_HELPER(PADDW, paddw);\n\n    LMI_HELPER(PADDSB, paddsb);\n\n    LMI_HELPER(PADDUSB, paddusb);\n\n    LMI_HELPER(PADDB, paddb);\n\n\n\n    LMI_HELPER(PSUBSH, psubsh);\n\n    LMI_HELPER(PSUBUSH, psubush);\n\n    LMI_HELPER(PSUBH, psubh);\n\n    LMI_HELPER(PSUBW, psubw);\n\n    LMI_HELPER(PSUBSB, psubsb);\n\n    LMI_HELPER(PSUBUSB, psubusb);\n\n    LMI_HELPER(PSUBB, psubb);\n\n\n\n    LMI_HELPER(PSHUFH, pshufh);\n\n    LMI_HELPER(PACKSSWH, packsswh);\n\n    LMI_HELPER(PACKSSHB, packsshb);\n\n    LMI_HELPER(PACKUSHB, packushb);\n\n\n\n    LMI_HELPER(PUNPCKLHW, punpcklhw);\n\n    LMI_HELPER(PUNPCKHHW, punpckhhw);\n\n    LMI_HELPER(PUNPCKLBH, punpcklbh);\n\n    LMI_HELPER(PUNPCKHBH, punpckhbh);\n\n    LMI_HELPER(PUNPCKLWD, punpcklwd);\n\n    LMI_HELPER(PUNPCKHWD, punpckhwd);\n\n\n\n    LMI_HELPER(PAVGH, pavgh);\n\n    LMI_HELPER(PAVGB, pavgb);\n\n    LMI_HELPER(PMAXSH, pmaxsh);\n\n    LMI_HELPER(PMINSH, pminsh);\n\n    LMI_HELPER(PMAXUB, pmaxub);\n\n    LMI_HELPER(PMINUB, pminub);\n\n\n\n    LMI_HELPER(PCMPEQW, pcmpeqw);\n\n    LMI_HELPER(PCMPGTW, pcmpgtw);\n\n    LMI_HELPER(PCMPEQH, pcmpeqh);\n\n    LMI_HELPER(PCMPGTH, pcmpgth);\n\n    LMI_HELPER(PCMPEQB, pcmpeqb);\n\n    LMI_HELPER(PCMPGTB, pcmpgtb);\n\n\n\n    LMI_HELPER(PSLLW, psllw);\n\n    LMI_HELPER(PSLLH, psllh);\n\n    LMI_HELPER(PSRLW, psrlw);\n\n    LMI_HELPER(PSRLH, psrlh);\n\n    LMI_HELPER(PSRAW, psraw);\n\n    LMI_HELPER(PSRAH, psrah);\n\n\n\n    LMI_HELPER(PMULLH, pmullh);\n\n    LMI_HELPER(PMULHH, pmulhh);\n\n    LMI_HELPER(PMULHUH, pmulhuh);\n\n    LMI_HELPER(PMADDHW, pmaddhw);\n\n\n\n    LMI_HELPER(PASUBUB, pasubub);\n\n    LMI_HELPER_1(BIADD, biadd);\n\n    LMI_HELPER_1(PMOVMSKB, pmovmskb);\n\n\n\n    LMI_DIRECT(PADDD, paddd, add);\n\n    LMI_DIRECT(PSUBD, psubd, sub);\n\n    LMI_DIRECT(XOR_CP2, xor, xor);\n\n    LMI_DIRECT(NOR_CP2, nor, nor);\n\n    LMI_DIRECT(AND_CP2, and, and);\n\n    LMI_DIRECT(PANDN, pandn, andc);\n\n    LMI_DIRECT(OR, or, or);\n\n\n\n    case OPC_PINSRH_0:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);\n\n        opn = \"pinsrh_0\";\n\n        break;\n\n    case OPC_PINSRH_1:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);\n\n        opn = \"pinsrh_1\";\n\n        break;\n\n    case OPC_PINSRH_2:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);\n\n        opn = \"pinsrh_2\";\n\n        break;\n\n    case OPC_PINSRH_3:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);\n\n        opn = \"pinsrh_3\";\n\n        break;\n\n\n\n    case OPC_PEXTRH:\n\n        tcg_gen_andi_i64(t1, t1, 3);\n\n        tcg_gen_shli_i64(t1, t1, 4);\n\n        tcg_gen_shr_i64(t0, t0, t1);\n\n        tcg_gen_ext16u_i64(t0, t0);\n\n        opn = \"pextrh\";\n\n        break;\n\n\n\n    case OPC_ADDU_CP2:\n\n        tcg_gen_add_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUBU_CP2:\n\n        tcg_gen_sub_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n\n\n    case OPC_SLL_CP2:\n\n        opn = \"sll\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRL_CP2:\n\n        opn = \"srl\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRA_CP2:\n\n        opn = \"sra\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_DSLL_CP2:\n\n        opn = \"dsll\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRL_CP2:\n\n        opn = \"dsrl\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRA_CP2:\n\n        opn = \"dsra\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    do_shift:\n\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n\n        tcg_gen_andi_i64(t1, t1, shift_max - 1);\n\n\n\n        switch (opc) {\n\n        case OPC_SLL_CP2:\n\n        case OPC_DSLL_CP2:\n\n            tcg_gen_shl_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRA_CP2:\n\n        case OPC_DSRA_CP2:\n\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n\n               we can treat SRA and DSRA the same.  */\n\n            tcg_gen_sar_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRL_CP2:\n\n            /* We want to shift in zeros for SRL; zero-extend first.  */\n\n            tcg_gen_ext32u_i64(t0, t0);\n\n            /* FALLTHRU */\n\n        case OPC_DSRL_CP2:\n\n            tcg_gen_shr_i64(t0, t0, t1);\n\n            break;\n\n        }\n\n\n\n        if (shift_max == 32) {\n\n            tcg_gen_ext32s_i64(t0, t0);\n\n        }\n\n\n\n        /* Shifts larger than MAX produce zero.  */\n\n        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);\n\n        tcg_gen_neg_i64(t1, t1);\n\n        tcg_gen_and_i64(t0, t0, t1);\n\n        break;\n\n\n\n    case OPC_ADD_CP2:\n\n    case OPC_DADD_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_add_i64(t0, t1, t2);\n\n            if (opc == OPC_ADD_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_andc_i64(t1, t2, t1);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_ADD_CP2 ? \"add\" : \"dadd\");\n\n            break;\n\n        }\n\n\n\n    case OPC_SUB_CP2:\n\n    case OPC_DSUB_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_sub_i64(t0, t1, t2);\n\n            if (opc == OPC_SUB_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 2818, "substitutes": {"ctx": ["cm", "cms", " cx", "cli", "cam", "cs", "kb", "hw", "conn", "context", "cc", "txt", "Context", "loc", "tk", "ck", "nc", "bc", "cci", "tc", "grad", "cas", "comp", "ux", "fp", "tx", "sync", "cb", "coll", "kt", "kw", "ch", "config", "progress", "dc", "pkg", "c", "cv", "xc", "scl", "sc", "ctrl", "sq", "jp", "exec", "ca", "cmd", "vc", "obj", "wcs", "cca", "lib", "qa", "cmp", "cf", "conv", "ci", " context", "sci", "qq", "rc"], "rd": ["ld", "dd", "cc", "rw", "mc", "cl", "rr", "ru", "nc", "lr", "rf", "Rs", "rb", "ri", "hr", "cr", "st", "dc", "rl", "std", "rx", "nd", "rc"], "rs": ["rg", "src", "cs", "ops", "ries", "eps", "r", "ru", "ins", "ims", "lr", "resses", "Rs", "rb", "params", "ls", "ra", "ars", "xs", "ras", "cr", "RS", "ds", "ps", "ns", "pr", "sw", "vers", "rl", "rows", "rics", "sr", "s", "ubs", "mr", "cmp", "ks", "addr", "hs", "res", "rc"], "rt": ["rot", "dr", "ret", "mt", "q", "vt", "rw", "rn", "r", "rr", "ct", "ru", "rec", "rf", "adr", "rb", "ri", "ls", "ac", "nt", "fr", "ras", "RT", "pr", "ptr", "rl", "ref", "rm", "sr", "b", "t", "rx", "req", "addr", "vr", "pt", "rh", "rc"], "opn": [" oprn", " opns", " opcn", "Opf", "optn", "optns", "optc", "hopn", "optf", "oprn", "OPc", " opb", "OPn", "opcn", "Opb", "optconn", " opconn", "hopconn", "opf", "optr", "OPr", "Opc", "hopcn", " opr", "Opn", "opern", "hopc", "opns", " opf", "opb", "opr", "optrn", "optcn", "opconn", "OPrn", "operns", "operc", "optb"], "opc": ["ropcs", " opcode", "optn", "toolc", " opci", "optc", "hopn", "optf", "OPc", "copcode", "OPn", "copc", "toolC", "optci", "opcode", "ropn", "OPf", "opf", "tooln", "OPcode", "hopf", " opC", "OPC", "hopci", "copn", "opci", "hopc", "optcs", "ropc", "optcode", "opcs", " opf", "toolf", "copf", "ropcode", " opcs", "opC"], "shift_max": ["push_min", "push_max", "push_right", "push_MAX", "shift_right", "shift_MAX", "shift_min"], "t0": ["ta2", "ty00", "tikg", "t4", "f1", "p25", "ti0", "ta50", "T50", "p4", "fkg", "ti1", "wt1", "ty50", "T2", "ta0", "p1", "f2", "t00", "tkg", "T0", "ty2", "t2", "p50", "t25", "p0", "wt25", "t50", "ty0", "wt0", "f0", "T4", "wt50", " t50", " t4", " t2", "p2", "Tkg", "ta00", "T25", " t00", "ti2", "T1"], "t1": ["st91", "t4", "Tb", "ty6", " t80", "tie1", "otONE", "ty91", "p4", "tb", "T2", "p1", "pb", "st1", "t91", "T0", "t2", "tie91", "tie80", "te6", "p0", "teONE", "te91", "st80", "T4", "ot1", "t6", "t80", "tyONE", " t4", " t2", "p2", "tONE", "ot6", "ot91", "te1", "ty1", " t91", "T1", " tb"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 2820, "substitutes": {"opaque": ["opacity", "ospacity", "OPacity", "Opca", "ospaque", "Opec", "opca", " opac", "opac", "OPac", "OPace", "opace", " opacity", "ospca", "ipec", "ipaque", "ipca", "OPaque", "ospec", "Opacity", "ipace", "ipac", "ipacity", " opace", "opec", "Opaque"], "fid": ["cname", "pID", " fids", "fpbid", "feids", "fpid", "fide", "ckid", "fkid", "pids", "lfids", "cfide", "febid", "lfid", "fekid", "cide", "lid", "fcbid", "fida", "rbid", "feid", "prid", " fide", "lfname", "fpida", "rid", " fname", "fids", "pid", "fID", "frid", "lfide", "cfida", "cids", "cid", "fname", "fcide", "fbid", "fpide", "lids", " fID", "rids", "rkid", "cfbid", "fcida", " frid", "cfid", "cbid", "lrid", "lID", "fcid"], "v9stat": ["V6stats", "f8status", "V9Stat", "V09log", "f9status", "m09stats", "V9status", "v6Stat", "v9stats", "m09not", "v8stat", "m9stat", "V8tag", "f8STAT", "v94status", "V9stat", "v8STAT", "V6min", "V09status", "f8stats", "v6min", "v8Stat", "m9log", "v91log", "v09stat", "v94stat", "v94stats", "m09log", "f9stat", "f9stats", "v9log", "v09not", "v9tag", "v9login", "v8init", "v94init", "vnineSTAT", "v9not", "V6stat", "V6login", "v_stat", "V9log", "m09stat", "V8status", "v09status", "v6stats", "v6log", "V09stat", "v91status", "v9status", "vninestats", "v6status", "v89stat", "v89log", "V6status", "v09stats", "v8log", "m9stats", "v_status", "v8login", "v89not", "v91stat", "V9min", "v9STAT", "v09min", "v09init", "vninelogin", "v09log", "V09stats", "v8tag", "vninestatus", "v8status", "v8min", "v_Stat", "v6stat", "v1stat", "f9init", "v91tag", "v6login", "v9Stat", "vninestat", "v8stats", "f9STAT", "V6Stat", "f8stat", "m9not", "V8stat", "V9stats", "V9login", "v_stats", "v1log", "v9min", "v6STAT", "v1tag", "V9tag", "v9init", "v1status", "v89stats", "f8init", "V8log"], "stbuf": ["Stbuf", "restfd", "stfd", "stfunc", "ostfd", "stdb", "stcv", "stbuffer", "stafd", "stabuffer", "sthbuf", "Stdb", "sthdata", "Stfd", "stvec", "ostbuf", "Stdata", "STfunc", "strfd", " stcv", "restbuf", "sthfd", "Stcv", " stfunc", "stabuf", "ostvec", "stdata", "restdb", "stavec", "restdata", "STcv", "strbuf", "STbuf", "Stfunc", "strbuffer", "sthdb", "ostbuffer", "strvec"], "fidp": ["faidr", "fidu", "fpidc", "fIDv", "fidv", "ofardv", "filpa", " faidpa", "ofidu", "fidpc", " fidpc", " faidf", "nardpe", "fiddp", "fidenp", "fuidpr", "fstartv", "fstartpc", " fidr", "fardpc", "fstartp", "fIdpc", "fardpr", "nidlp", " fidf", "fardp", "fiddv", "fiddu", "fidpa", "fIdv", "nidp", "fuidlp", "fardv", "fardpe", "fpidpc", "fpidp", "fardu", " fidv", " fIdp", " fidu", "fipp", "fidenpr", "ofidv", "ofardpc", "filp", "fuidpe", "fipf", "fidenpe", " faidp", "fidx", "fuidp", "nidpr", "filr", "fidex", "fidpr", " fIdu", "faidp", " faidr", "ofardp", "ofidpc", "nidpe", "fpidr", "fidenlp", "nardp", "faidf", "fiddpc", "fipr", "fIDr", "fidr", "fippa", "ofardu", "fidep", "fidlp", "fardlp", " fidc", "fIDp", "fider", "fIDu", "fIdx", " fidx", " fidpa", "fidc", "fidpe", "fIdr", "fIdp", "filf", "fiddr", "nardlp", "faidpa", "fIdu", "fidec", "ofidp", "fIdc", " fIdr", "fstartu", " fIdv", "nardpr", "fidf"], "pdu": ["bcu", "puu", "pcu", "Ptu", " ptu", "epuu", "bpuu", "sptu", "bpuc", "chtu", "ipcu", "Psu", "puc", " pud", "hdu", "bptu", "opdu", "ptu", "Pcu", "chuc", "psu", "ruu", "apdu", " psu", "cpde", "epdu", "copru", "ccu", "spdu", "opde", "pde", "fsu", "pud", "csu", "Pru", "nptu", "copdu", "ddu", "fde", "apuu", "cpdu", "ffu", " pcu", "hda", "opcu", "ipdu", "cpsu", "fcu", "bdu", "ftu", "Pdu", "spcu", "ctu", "fdu", "hcu", "cpcu", "copsu", "rtu", "copcu", "bpdu", "buu", "cptu", "dfu", "dru", "copuu", "npuu", "chuu", " pda", "aptu", "epuc", "Puu", "cda", "copfu", "fud", " pde", "Pud", "apcu", "opuu", "fuu", "eptu", "cdu", "dcu", "pda", "npdu", " puu", "optu", "Pde", " pru", "rdu", "iptu", "opru", "ipuu", "chdu", "spsu", "fru", "htu", "pru", "rru", "pfu", "npcu"], "s": ["sg", "server", "http", "ss", "ops", "spec", "a", "rs", "sb", "r", "d", "n", "is", "uploads", "scope", "i", "g", "m", "ses", "args", "sync", "settings", "storage", "gs", "ns", "h", "c", "p", "or", "state", "w", "e", "f", "secondary", "sys", "u", "south", "o", "v", "stats", "b", "S", "t", "session", "os", "location", "states", "fs", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 2832, "substitutes": {"op1": ["opone", " op0", "op4", "Op1", "OP1", "hop1", "hop2", "opt3", "oper0", "OPOne", " op4", "opt01", " opb", "opt1", "ipone", "oper1", "opt0", " opOne", "operb", "oper2", "Op2", "hop4", "ip2", "ip0", "op01", "OpOne", " opone", "op0", " op3", "ip1", "operone", "op3", "Op01", "opb", "hopb", "hop3", "opt4", "OP01", "OP0", "opt2", "hopOne", "hop0", "oper3", "optOne", "OP2", "opOne"], "op2": ["operv", "opv", " op0", "opt3", "hop1", "hop2", "oper0", "cop3", "opt1", "oper1", "oper2", "cop2", "optTwo", "hopv", "coptwo", " op3", "op0", "op3", "optwo", "hop3", "opttwo", "opt2", " opTwo", " optwo", "hop0", "opTwo", " opv", "copTwo"]}}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 2846, "substitutes": {"of_dpa": ["of_Dpa", "of_mdao", "of_duppa", "of_dpe", "of__cppa", "of_dupi", "of__dpe", "of__dao", "of_dao", "of__cpe", "of_ducp", "of_cao", "of__dpa", "of_dupa", "of_nppa", "of_mdpe", "of_Dpi", "of_mdpa", "of_dpi", "of__dppa", "of_cpa", "of_madppa", "of_cppa", "of_madpa", "of_dcp", "of_madpi", "of_Dppa", "of_mdppa", "of__cao", "of_npa", "of_Dcp", "of_madcp", "of_cpe", "of_npe", "of__cpa", "of_nao", "of_dppa"], "group": ["match", "call", "server", "name", "row", "any", "q", "key", "gru", "class", "global", "out", "gh", "type", "co", "Group", "field", "pg", "GROUP", "parent", "pair", "gap", "batch", "package", "g", "member", "output", "gg", "component", "company", "coll", "project", "event", "sync", "multi", "back", "number", "database", "config", "result", "block", "gu", "order", "diff", "child", "app", "cache", "message", "game", "agg", "object", "join", "comment", "range", "single", "plugin", "cell", "module", "rule", "option", "gen", "full", "an", "list", "band", "input", "user", "committee"], "group_tlvs": ["group_llvd", "group_tlss", "group_tlevn", "group_llvn", "group_tlln", "group_dlvs", "group_Tlfe", "group_tlegd", "group_tlevs", "group_Tlve", "group_tlls", "group_Tlvs", "group_tlli", "group_llvs", "group_tlse", "group_Tlfn", "group_tcfen", "group_tgtd", "group_dlln", "group_tlegs", "group_tlsd", "group_Tlvn", "group_tlevi", "group_tlegS", "group_tlle", "group_tlve", "group_Tlfi", "group_tlvn", "group_tcfd", "group_tgts", "group_tgtn", "group_tlsi", "group_tlfn", "group_llvi", "group_tllS", "group_tcfs", "group_Tlvi", "group_Tlvd", "group_tlegn", "group_Tlfd", "group_tlvS", "group_dlls", "group_tlld", "group_llevd", "group_dlvd", "group_tlfe", "group_tlevd", "group_dlven", "group_dlld", "group_dllen", "group_llevn", "group_tlfs", "group_tlfen", "group_tcfn", "group_tlven", "group_llevi", "group_tllen", "group_Tlfs", "group_tlfd", "group_llevs", "group_tlfS", "group_tlfi", "group_dlvn", "group_tlvi", "group_tlvd"], "l2_group": ["l2__channel", "l2_type", "l2ibclient", "l4__channel", "l3_groups", "l2_Group", "l1_group", "l1_g", "l4__g", "l2_client", "l3_type", "l4__group", "l2__group", "l2__g", "l2_g", "l4_groups", "l4__groups", "l2_channel", "l3_group", "l2ibtype", "l1_Group", "l2ibgroup", "l2ibgroups", "l2_groups", "l4_channel", "l2__groups", "l3_client", "l4_group", "l4_g"], "tlvs": ["tlvt", "untLVs", " tlve", "wtvlf", " tlimd", "tlimd", "tLVs", " tlims", "tlld", "tvlids", "tlss", "tlsids", "tinyls", "tLVabs", "wtvlids", "tlegits", "tinylstat", "itlls", "tllt", "tlvits", "untlvabs", "wtlvt", "tlvf", "wtlvs", "tllits", "tlimp", "tservs", "wtvle", "tcols", "tlegabs", "tlvids", "wtvlt", "wtlvids", "tvalls", "tlegstat", "tvle", "untLVstat", "itllits", "tlsf", "tvals", "tinylabs", "itlvits", "tlims", "tvlf", "tlve", "wtvls", "itllp", "tllp", "wtvlls", "tlime", "tservf", "tLVe", "wtlve", "tlegp", "tlvls", "itlvs", " tlvp", "tllls", "itlvp", "tvlls", "tlls", "tLVp", "tvls", "tvalt", "tvlt", "tlvstat", "tvale", "wtlvf", "tlvabs", "wtlvls", " tlime", "tlvd", "tLVstat", " tlimp", "untlvs", "tLVd", "untLVabs", "tlegs", " tlvd", "tlvp", "tservids", "tcolp", "tcolits", "untlvstat", "tlle"], "err": ["dr", "ise", "rage", "gi", "gr", "Error", "rr", " error", "orig", "cur", "lr", "arr", "rb", "code", "er", "fr", "ir", "str", "bug", "progress", "errors", "result", "ind", "usr", "phi", "dev", " Err", "br", "ctr", "resp", "error", "var", "Er", "msg", "debug", "init", "cfg", "fi", "rh", "diff", "rc"], "i": ["my", "yi", "li", "sup", "gi", "key", "a", "l", "ni", "ii", "ji", "chi", "pi", "ui", "oi", "r", "mini", "d", "I", "n", "di", "id", "mi", "uli", "iu", "k", "j", "g", "y", "m", "ri", "eni", "inner", "info", "ti", "slice", "multi", "z", "ini", "index", "ai", "ie", "x", "ip", "c", "p", "ind", "bi", "h", "e", "hi", "f", "phi", "u", "v", "qi", "ix", "t", "b", "uri", "ci", "count", "io", "mu", "init", "fi", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "8bdba1092f50d52e0af90f425811302ec91152f8", "target": 1, "func": "int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    const uint64_t fuzz_tag = FUZZ_TAG;\n\n    FuzzDataBuffer buffer;\n\n    const uint8_t *last = data;\n\n    const uint8_t *end = data + size;\n\n    uint32_t it = 0;\n\n\n\n    if (!c)\n\n        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.\n\n\n\n    AVCodecContext* ctx = avcodec_alloc_context3(NULL);\n\n    if (!ctx)\n\n        error(\"Failed memory allocation\");\n\n\n\n    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs\n\n\n\n    int res = avcodec_open2(ctx, c, NULL);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    FDBCreate(&buffer);\n\n    int got_frame;\n\n    AVFrame *frame = av_frame_alloc();\n\n    if (!frame)\n\n        error(\"Failed memory allocation\");\n\n\n\n    // Read very simple container\n\n    AVPacket avpkt;\n\n    while (data < end && it < maxiteration) {\n\n        // Search for the TAG\n\n        while (data + sizeof(fuzz_tag) < end) {\n\n            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)\n\n                break;\n\n            data++;\n\n        }\n\n        if (data + sizeof(fuzz_tag) > end)\n\n            data = end;\n\n\n\n        FDBPrepare(&buffer, &avpkt, last, data - last);\n\n        data += sizeof(fuzz_tag);\n\n        last = data;\n\n\n\n        // Iterate through all data\n\n        while (avpkt.size > 0 && it++ < maxiteration) {\n\n            av_frame_unref(frame);\n\n            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);\n\n\n\n            if (it > 20)\n\n                ctx->error_concealment = 0;\n\n\n\n            if (ret <= 0 || ret > avpkt.size)\n\n               break;\n\n\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n    }\n\n\n\n    av_init_packet(&avpkt);\n\n    avpkt.data = NULL;\n\n    avpkt.size = 0;\n\n\n\n    do {\n\n        got_frame = 0;\n\n        decode_handler(ctx, frame, &got_frame, &avpkt);\n\n    } while (got_frame == 1 && it++ < maxiteration);\n\n\n\n    av_frame_free(&frame);\n\n    avcodec_free_context(&ctx);\n\n    av_freep(&ctx);\n\n    FDBDesroy(&buffer);\n\n    return 0;\n\n}", "idx": 2857, "substitutes": {"data": ["capacity", "after", "device", "queue", "open", "video", "empty", "sample", "next", "first", "code", "index", "address", "alpha", "shift", "reset", "message", "DATA", "valid", "limit", "all", "start", "what", "name", "da", "read", "extra", "image", "ui", "format", "id", "parent", "buf", "off", "batch", "update", "p", "state", "length", "text", "count", "xxx", "one", "response", "input", "media", "missing", "offset", "channel", "a", "new", "complete", "i", "inner", "body", "slice", "raw", "content", "result", "pad", "len", "date", "cache", "value", "connection", "error", "bytes", "Data", "timeout", "done", "delay", "total", "memory", "window", "d", "results", "pos", "output", "none", "entry", "number", "style", "multi", "block", "zero", "draw", "addr", "latest", "dat"], "size": ["capacity", "large", "weight", "empty", "from", "handle", "next", "g", "code", "args", "storage", "address", "set", "Size", "sum", "fee", "start", "unit", "name", "time", "extra", "sized", "cl", "sent", "send", "position", "max", "write", "length", "core", "sn", "scale", "count", "cm", "scene", "SIZE", "offset", "channel", "small", "speed", "loc", "use", "member", "body", "function", "content", "c", "len", "cap", "sec", "close", "bytes", "six", "mode", "shape", "timeout", "done", "ize", "memory", "pos", "number", "source", "ci"], "buffer": ["flow", "base", "null", "server", "channel", "interface", "uffer", "context", "byte", "queue", "image", "window", "header", "bc", "buff", "BU", "buf", "client", "batch", "file", " Buffer", "cb", "slice", "document", "source", "config", "raw", "writer", "result", "reader", "p", "Buffer", "ref", "loader", "cache", "cube", "reference", "FFER", "b", "container", "uf", "console", "board", "input"], "last": ["base", "se", "total", "cycle", "after", "ul", "tail", "done", "current", "recent", "use", "orig", "id", "empty", "cur", "Last", "parent", "first", "max", "next", "j", "code", "event", "style", "index", "st", "p", "shift", "self", "len", "length", "prev", "cache", "value", "final", "used", "old", "close", "full", "low", "nd", "latest", "since", "start", "est"], "end": ["ending", "ff", "append", "after", "offset", "tail", "send", "n", "ad", "open", "id", "empty", "off", "next", "max", "END", "i", "pos", "enc", "mid", "ended", "event", "index", "z", "address", "h", "x", "c", "p", "End", "e", "length", "set", "len", "ion", "en", "v", "stop", "close", "line", "nd", "edge", "limit", "all", "start", "est"], "ctx": ["fc", "cm", "cam", "cs", "hw", "conn", "context", "anc", "cc", "acl", "Context", "loc", "window", "ct", "nc", "bc", "voc", "buff", "tc", "client", "buf", "cas", "mac", "fp", "tx", "coll", "cb", "kt", "slice", "sync", "config", "ec", "dc", "cu", "c", "cv", "xc", "lc", "cpu", "unc", "cn", "wcs", "ctrl", "sc", "exec", "ca", "jp", "alloc", "vc", "pc", "connection", " c", "qa", "cp", "cmp", "cf", "conv", "ci", "sci", "que", "uc", "rc"], "got_frame": ["doneayobject", "got_line", "gotNewframe", "gotayframe", "got_sequence", "gotacelement", "got_object", "doneayframe", "got___element", "wantaysize", " got_line", "gotacrange", "done_pixel", "gotNewpixel", "found_element", "wantayboot", "foundacrange", "gotaypixel", "gotaysize", "got67boot", "foundacstroke", "got_node", "got_window", "got67frame", "foundacframe", "done_frame", "gotayobject", "gotacstroke", " got_frames", "gotacframe", " got_window", "doneaypixel", "wantaysequence", "done_object", "want_boot", "doneaydate", "want_sequence", " got_node", "want_size", "got_stroke", "found_stroke", "foundacelement", "got___stroke", "got67sequence", "got_slice", "gotayboot", "found_range", "gotaydate", "gotNewdate", "got_pixel", "want_frame", "found_frame", "gotaysequence", "got_range", "wantayframe", "got_boot", "gotNewobject", "got_size", " got_slice", "done_date", "got_element", "got_frames", "got___range", "got_date", "got67size", "got___frame"], "frame": ["flow", "fc", "dr", "base", "layer", "fd", "cycle", "Frame", "fram", "zip", "context", "rame", "image", "event", "window", "loc", "position", "nc", "fl", "buff", "video", "next", "component", "frames", "code", "body", "fp", "coll", "cb", "fr", "slice", "live", "kt", "bug", "ch", "config", "framework", "fe", "c", "iframe", "p", "setup", "e", "cpu", "f", "file", "layout", "object", "el", "range", "pse", "point", "flower", "connection", "fb", "b", "ze", "cf", "element", "line", "que", "fi", "board"], "avpkt": ["akppft", " avpqt", " avnpacket", "avegkt", "avlput", "avnpkt", "affkt", "avprt", "ajpkt", "avspacket", "ajppft", " avtpatch", "avppdr", "aupcht", " avnpett", "avpft", "avnKT", "avlpkt", "afput", "avpakt", "avPcht", "ajppdr", "avPacket", " avtpKT", "avfcht", "aulpcht", "affqt", "akppkt", "afpnt", "avepdt", "avtpcht", "akpze", "avgelt", "avfqt", "avlpke", "avpqt", "avpett", "avpacket", "avPkt", "avpekt", "avppft", "avpeKT", "affut", "avnpcht", "avpdt", "avegdt", "affett", "akppze", "akppdt", "avlpft", "avcpacket", "avnacket", " avpett", "avepelt", "avegcht", "avepkg", "avfpacket", "avpaft", "avgkt", "avPke", "avcpqt", " avpatch", "avskt", "avcpkt", "avselt", "avppacket", "avpze", "aupacket", "affacket", "avspelt", "avjput", "avlpacker", "avppkt", "ajpft", "avcpett", " avpacket", "avtpkt", "avjpacket", "avpadt", "avnatch", "avelrt", "avfkt", "avpecht", "avepkt", "avelelt", "avlpdr", "avnpqt", "avlpacket", "avlqt", "ajpdr", "ajppacket", "avnpett", "affnt", "aupkt", "avfett", "avppdt", "avfacker", "afpcht", "avpKT", "avlkg", "avspcht", "avpdr", "akpft", " avnpkt", "avspkt", "ajppkt", "avlpnt", "avlpcht", "avfelt", "avscht", " avtpkt", "avpkg", "affacker", "avpacker", "avpke", "affelt", "avppze", "avlpze", "aupke", "avepcht", "afpqt", " avnpqt", "avnpelt", "aulpacket", "avpnt", "afpkt", "avelkt", "avtpKT", "avgcht", "avjpkt", "affcht", "avegelt", "avfpkt", "avpcht", " avpcht", "akpkt", "avlrt", "afpelt", "avpskt", "ajpacket", "avnpacket", "avpskg", "aulpkt", "avpselt", " avtpcht", "avfacket", "avPft", "avPdr", "avtpatch", "avnpkg", "avpeatch", "afpacket", "afpett", "akpdt", "aulpke", " avpKT", "avnprt", "avlpdt", "avput", "avpatch", "avgdt", "avlpelt", "avnnt", "aveprt", "avfpcht", "avpelt", "avlelt", "avpaze", "avpsrt", "avfut", "avfnt", "avsdt", "avelkg", "avlkt", "avnkt", "avlacket", "avfpke", "avncht", "afpacker", "avlett", "avjpacker"], "it": ["unit", "ort", "ul", "stat", "bit", "split", "IT", "jit", "get", "r", "out", "axis", "ct", "loc", "quit", "n", "I", "format", "id", "bin", "wait", "mit", "parent", "op", "edit", "fit", "loop", "i", "j", "update", "you", "ac", "ait", "info", "sit", "rit", "st", "opt", "ite", "ind", "l", "p", "which", "f", "prev", "u", "exec", "pit", "sec", "b", "t", "lit", "its", "iter", "It", "init", "limit", "qt"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 2880, "substitutes": {}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n", "idx": 2884, "substitutes": {"env": ["eu", "oa", "stage", "np", "server", "js", "ctx", "conn", "esm", "context", "txt", "environment", "ea", "dict", "scope", "enc", "m", "args", "er", "err", "settings", "config", "ec", "exc", "state", "vs", "e", "conf", "viron", "en", "v", "iss", "ev", "iv", "nw", "req", "que"], "s": ["sg", "server", "js", "cs", "ctx", "sup", "ss", "ops", "rs", "ts", "qs", "spec", "sb", "d", "n", "is", "i", "g", "m", "ses", "ls", "args", "sf", "sync", "settings", "storage", "sets", "ds", "ps", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "es", "sys", "sq", "u", "conf", "south", "o", "v", "b", "site", "S", "t", "os", "fs", "si", "sym", "ssl"], "insn": ["lsl", "incl", "valsne", "incf", " insg", "insnc", "linsnc", "insf", "insyn", " insN", "insne", "linsN", "intsner", "incg", "alsne", "incner", "lsf", " insner", " insl", "insdn", "alsi", "valscn", "valsyn", "incsn", "insna", "lsg", "linscn", " insdn", "insg", "inssn", "incn", " inscn", "valsnc", "inn", "alsyn", "inc", "innc", "incdn", "insi", " insf", "intssn", " insne", " insyn", "ansc", "insner", "valsi", "ansn", "valsn", " insi", "lsn", "alsn", " inssn", "consna", "linsn", " insnc", "insl", "intsn", "ansna", "insc", "inna", "consn", "insN", "ansnc", "inscn", "intsdn", "consc", "consnc", "valsN"]}}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n", "idx": 2895, "substitutes": {"ot": ["rot", "ort", "nat", "ol", "mt", "ant", "not", "oi", "ott", "oto", "oid", "boot", "lot", "op", "ac", "cot", "OT", "nt", "mot", "bot", "et", "ut", "iot", "oc", "gt", "fat", "art", "tt", "o", "dot", "t", "iet", "ic", "os", "rt", "pt", "pot", "oot"], "t0": ["t4", "l1", "f1", "g1", "tj", "p4", "gj", "p00", "et00", "p7", "T2", "p1", "t00", "l0", "T0", "t2", "p50", "p0", " T1", "t50", "et7", "et1", " t7", "f50", "t1", "t7", " T0", "g0", "f0", "pj", " t50", " t4", " t2", "l4", " T2", " tj", " t00", "T1", "et0", " t1"], "reg": ["rg", "ret", "mn", "arg", "ig", "REG", "da", "stat", "gr", "spec", "mod", "bit", "conn", "mem", "loc", "tag", "rec", "rog", "orig", "pg", "ng", "eng", "greg", "num", "pre", "g", "code", "big", "index", "cod", "bad", "eg", "abc", "ind", "pred", "col", "rem", "org", "rin", "sec", "region", "round", "leg", "Reg", "re", "val", "debug", "typ", "res", "rol", "rc", "port"]}}
{"project": "qemu", "commit_id": "54421cb17bc744bad15f2b1adb4adefdaea83c10", "target": 0, "func": "static int hdev_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int access_flags, create_flags;\n\n    DWORD overlapped;\n\n    char device_name[64];\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        if (find_cdrom(device_name, sizeof(device_name)) < 0)\n\n            return -ENOENT;\n\n        filename = device_name;\n\n    } else {\n\n        /* transform drive letters into device name */\n\n        if (((filename[0] >= 'a' && filename[0] <= 'z') ||\n\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n\n            filename[1] == ':' && filename[2] == '\\0') {\n\n            snprintf(device_name, sizeof(device_name), \"\\\\\\\\.\\\\%c:\", filename[0]);\n\n            filename = device_name;\n\n        }\n\n    }\n\n    s->type = find_device_type(bs, filename);\n\n    \n\n    if ((flags & BDRV_O_ACCESS) == O_RDWR) {\n\n        access_flags = GENERIC_READ | GENERIC_WRITE;\n\n    } else {\n\n        access_flags = GENERIC_READ;\n\n    }\n\n    create_flags = OPEN_EXISTING;\n\n\n\n#ifdef QEMU_TOOL\n\n    overlapped = FILE_ATTRIBUTE_NORMAL;\n\n#else\n\n    overlapped = FILE_FLAG_OVERLAPPED;\n\n#endif\n\n    s->hfile = CreateFile(filename, access_flags, \n\n                          FILE_SHARE_READ, NULL,\n\n                          create_flags, overlapped, NULL);\n\n    if (s->hfile == INVALID_HANDLE_VALUE) \n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 2903, "substitutes": {"bs": ["cms", "acs", "cs", "abi", "ss", "rs", "ts", "sa", "sb", "bps", "lb", "ab", "BS", "aws", "bid", "bc", "ins", "ros", "pb", "cus", "bl", "ls", "ses", "outs", "ds", "ps", "gs", "ns", "css", "vs", "bi", "us", "bos", "es", "gb", "bb", "iss", "fb", "b", "os", "ks", "bes", "fs", "obs"], "filename": ["route", "txt", "url", "lvl", "sheet", "maximum", "Filename", "file", "sf", "password", "database", "abl", "description", "via", "which", "message", "ame", "uri", "path", "location", "name", "named", "utf", "sequence", "image", "position", "lua", "fp", "jpg", "length", "phrase", "title", "til", "lace", "nil", "document", "feat", "json", "ident", "size", "connection", "prefix", "directory", "files", "fd", "application", "alias", "memory", "binary", "ename", "download", "fn", "wl", "fax", "initial", "fil", "params", "sword", "kj", "source", "status", "kn", "word", "dll", "kl", "token", "username", "il", "dyl", "nm", "subject", "whatever", "metadata"], "flags": ["files", "opens", "Flags", "ops", "ings", "lag", "rules", "vals", "ensions", "faces", "ils", "links", "fps", "locks", "options", "ids", "comments", "frames", "bits", "args", "ats", "settings", "ports", "properties", "lines", "ffff", "atts", "flag", "features", "ints", "fields", "fee", "stats", "types", "codes", "ants", "ages", "states", "ags", "FLAG", "parts"], "s": ["js", "service", "cs", "ss", "ops", "rs", "sa", "ts", "sb", "is", "sl", "i", "g", "bis", "ls", "ses", "args", "uns", "sync", "settings", "sv", "storage", "ds", "status", "sets", "ps", "gs", "utils", "ns", "c", "p", "sie", "state", "vs", "self", "services", "es", "sys", "sq", "conf", "sn", "ubs", "b", "su", "S", "os", "session", "ks", "its", "states", "si", "ssl"], "access_flags": [" access_requires", "access32links", "sync_types", "accessiontypes", "access67ops", "access32data", " access_links", "synclextypes", "sync_flags", "accessionreads", "synclexdds", "access_forces", " access_data", "access_requires", "access_mask", "sync_dds", "access_groups", "access67flags", "accessionflags", "access_reads", "accessiondds", "accesslexdds", " access_mask", " access_groups", "access___requires", " access_forces", "accesslexflags", "access___forces", "accesslexreads", "access___flags", " access_ops", "sync_reads", "access___groups", "synclexreads", "accesslextypes", "access_ops", "access67mask", "access_links", "access_types", "access_data", "synclexflags", "access_dds", "access32flags"], "create_flags": ["createingports", "create___flags", "write_args", "create_ports", "write_requires", "create_ants", "create___requires", "write_flags", " create_mails", "create___mails", " create_requires", "createingmails", " create___requires", "create___ports", "create_Flags", " create___mails", "create_requires", "create_mails", " create___flags", " create___ports", "createingflags", "access_ants", "createingrequires", "create_args", "access_Flags", " create_ports"], "overlapped": ["overlaped", "overfloved", " Overflapped", "overmLipped", "overlcaped", "overpapping", "overflpped", "overloved", " Overloved", "overpaped", " Overfloved", "Overlapped", "overllapping", "Overlcapping", "Overlanded", "Overflapped", "overflipped", " Overlapped", "Overflanded", "Overflipped", "overmLapped", "Overlagged", "overllapped", "overLoved", "overmLpped", "overlaapping", "overlipped", "overlaapped", "overllaped", "Overflapping", "overLaped", " Overlaped", "Overflaped", "overlcanded", "overflagged", "overlcapped", "overlcapping", " Overlapping", " Overflaped", "overmLapping", "Overlapping", "overLapping", "overpoved", "overlanded", "overlcagged", "Overflpped", "Overlcaped", "overflapping", "overlapping", "Overlcapped", "overlagged", "overLapped", "Overlcagged", "Overlpped", "overlpped", "overflanded", "overflaped", "overpapped", "overflapped", " Overflapping", "overlaipped", "Overlaped", "overllanded", "Overlipped", "overLagged"], "device_name": ["deviceablename", "devicefullinfo", "device_named", "device_path", "device_code", "device_conn", "deviceapppath", "dev_named", " device_path", " device_label", "dev_code", " device_Name", " device_part", "device_parent", "dev_name", "device2address", "dev_conn", "deviceappname", "device2name", "device_info", "device_label", "dev_parent", "device_key", "device_number", "deviceacparent", "device_address", "deviceableconn", "devicefullname", "deviceappparent", "dev_path", "deviceacname", "device_Name", "device2key", " device_key", "deviceablen", "devicefullpath", "deviceappnamed", "dev_n", "device_part", " device_info", "deviceappcode", " device_number", "device_n", " device_address", "devicefulllabel", "deviceacnamed"]}}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);\n\n        return;\n\n    }\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    /* parameter must be aligned to 1024-byte boundary */\n\n    if (si->param & 0x3ff) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (kvm_s390_store_adtl_status(cpu, si->param)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 2911, "substitutes": {"cs": ["cms", "acs", "ctx", "ics", "fs", "spec", "ts", "qs", "cc", "ck", "cons", "sk", "cus", "cas", "ls", "args", "settings", "ras", "ds", "ps", "gs", "ec", "ns", "c", "css", "lc", "sys", "sc", "core", "vc", "pc", "s", "cp", "cf", "ks", "os", "sci", "CS", "rc"], "arg": ["argument", "rg", "ig", "spec", "gc", "data", "cat", "bc", "Arg", "nic", "ag", " argument", "ark", "enc", "param", "g", "in", "mac", "ac", "proc", "args", "str", "parse", "ec", "result", "or", "doc", "self", "arc", "flag", "ar", "conf", "pc", "cell", "line", "reg", "val", "inc", "fi", "ace", " args", "rc"], "cpu": ["fc", "cm", "np", "vm", "cli", "gpu", "ctx", "spec", "conn", "mc", "lb", "clock", "uci", "nc", "px", "nic", "mac", "eni", "CPU", "proc", "config", "cu", "c", "css", "cow", "lc", "pu", "sys", "core", "cn", "chip", "processor", "linux", "pc", "cp", "cmp", "ci", "sci", "gp", "fi"], "si": ["yi", "ami", "li", "gi", "spec", "sa", "ni", "ii", "sd", "chi", "zi", "sb", "esi", "asi", "ui", "di", "cci", "mi", "iu", "i", "sis", "eni", "ti", "ini", "SI", "ai", "ie", "fi", "sie", "bi", "isi", "sys", "Si", "ki", "sn", "shi", "pc", "su", "agi", "sim", "ati", "ci", "sci", "ski"]}}
{"project": "qemu", "commit_id": "ff1d1977ffe1c276f5937a6ad4b6a5b6d2b1c6ae", "target": 0, "func": "static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = ldtul_p(mem_buf);\n\n\n\n    if (n < 32) {\n\n        env->active_tc.gpr[n] = tmp;\n\n        return sizeof(target_ulong);\n\n    }\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)\n\n            && n >= 38 && n < 73) {\n\n        if (n < 70) {\n\n            if (env->CP0_Status & (1 << CP0St_FR))\n\n              env->active_fpu.fpr[n - 38].d = tmp;\n\n            else\n\n              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;\n\n        }\n\n        switch (n) {\n\n        case 70:\n\n            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;\n\n            /* set rounding mode */\n\n            RESTORE_ROUNDING_MODE;\n\n#ifndef CONFIG_SOFTFLOAT\n\n            /* no floating point exception for native float */\n\n            SET_FP_ENABLE(env->active_fpu.fcr31, 0);\n\n#endif\n\n            break;\n\n        case 71: env->active_fpu.fcr0 = tmp; break;\n\n        }\n\n        return sizeof(target_ulong);\n\n    }\n\n    switch (n) {\n\n    case 32: env->CP0_Status = tmp; break;\n\n    case 33: env->active_tc.LO[0] = tmp; break;\n\n    case 34: env->active_tc.HI[0] = tmp; break;\n\n    case 35: env->CP0_BadVAddr = tmp; break;\n\n    case 36: env->CP0_Cause = tmp; break;\n\n    case 37: env->active_tc.PC = tmp; break;\n\n    case 72: /* fp, ignored */ break;\n\n    default: \n\n\tif (n > 89)\n\n\t    return 0;\n\n\t/* Other registers are readonly.  Ignore writes.  */\n\n\tbreak;\n\n    }\n\n\n\n    return sizeof(target_ulong);\n\n}\n", "idx": 2913, "substitutes": {"env": ["eu", "txt", "nc", "enc", "inet", "code", "event", "er", "err", "ec", "cv", "dev", "viron", "en", "engine", "ext", "extra", "context", "equ", "que", "ea", "end", "cdn", "eng", "po", "ef", "ce", "e", "conf", "core", "org", "ev", "site", "session", "me", "init", "edge", "np", "exe", "ctx", "enable", "data", "ee", "environment", "global", "ne", "exc", "et", "loader", "cache", "app", "el", "obj", "sec", "lv", "qt", "net", "oa", "stage", "vm", "server", "fen", "hw", "conn", "eb", "output", "eni", "erv", "dt", "config", "Environment", "exec", "inc", "console", "export", "db"], "mem_buf": ["memmembuf", "memory_wb", " mem_buff", "memory_buffer", "mem_buff", "memmembuffer", " mem_cb", "memmemwb", "mem2buf", "memmemuf", "mem2buff", "mem_cb", "memory_buf", "mem_buffer", "mem2cb", "memory_uf", "mem2buffer", "mem_wb", "mem_uf", " mem_buffer"], "n": ["syn", "mn", "np", "nat", "name", "no", "adj", "dn", "not", "conn", "ni", "nn", "rn", "r", "d", "nc", "pn", "un", "fn", "ng", "nu", "ne", "nl", "num", "na", "j", "i", "g", "in", "m", "none", "network", "nt", "number", "z", "non", "ns", "x", "N", "c", "p", "l", "w", "e", "nb", "len", "f", "cn", "u", "note", "min", "node", "en", "sn", "v", "nm", "o", "s", "b", "sign", "t", " N", "an", "nor", "net"], "tmp": ["vt", "txt", "sp", "job", "pb", "stuff", "err", "storage", "yy", "f", " np", "jp", "mp", "s", "appy", "cp", "var", "pp", "option", "verb", "tf", "zip", "sb", "buff", "buf", "api", "fp", "p", "v", "su", "t", "np", "att", "cpp", "data", "loc", "boot", "pre", "proc", "cb", "fake", "result", "pad", "nb", "tem", "attr", "cache", "front", "app", "bt", "obj", "kk", "bp", "tm", "bb", "test", "append", "TB", "array", "prop", "tc", "tab", "emp", "now", "tp", "output", "rb", "dest", "nt", "source", "temp", "config", "wb", "nm", "fb", "b", "cmp", "desc"]}}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n", "idx": 2914, "substitutes": {"ctx": ["cm", "cli", "src", "cs", "kb", "hw", "qs", "conn", "context", "cc", "acl", "cl", "cpp", "Context", "fw", "cn", "loc", "nc", "bc", "tc", "grad", "buf", "parent", "cus", "cas", "fp", "tx", "sync", "kw", "ch", "config", "pkg", "cu", "c", "cv", "xc", "lc", "ref", "ctr", "ca", "sq", "conf", "exec", "jp", "cache", "cmd", "vc", "obj", "sc", "pc", "cca", "qa", "cp", "cmp", "req", "cf", "conv", "support", "ci", "cfg", "sci", "ctrl"], "cb": ["ob", "src", "Callback", "obb", "conn", "CB", "cpp", "nc", "callback", "bc", "buff", "fn", "pb", "buf", "loop", "rb", "code", "fp", "cr", "func", "closure", "bf", "function", "cod", "cv", "unc", "core", "ctr", "ctrl", "cd", "gb", "conf", "cmd", "obj", "kk", "bb", "pc", "fb", "cp", "cmp", "req", "cf", "conv", "abb", "cfg", "desc", "db", "rc", "done"], "opaque": ["opacity", " opque", "opaques", "pyaques", "operaques", "boacity", " opatile", "operaque", "pyaque", "obacity", "pyacity", "obque", "compque", "opace", " opacity", "compace", "obesc", "obatile", "opesc", "compaque", "operacity", "boque", " opace", "boaque", "pyesc", "operesc", "opatile", "obaque", "obaques", "compatile", "obace", "opque", "operque"], "bh": [" ah", "abi", "kb", "ih", "obb", "sb", "dh", "bm", "lb", "ht", "hub", "cpp", "ib", "hap", "zh", "gh", "db", "sh", "bc", "ph", "pb", " kb", "uh", "batch", "bl", " dh", "rb", "fp", "ah", "ch", "bf", "hm", "h", "pkg", "ang", "hh", "phi", "bi", "sq", "hp", "gb", "bt", "bg", "wd", "bp", "hl", "adh", "bb", "fb", "b", "mr", "abb", "aph", "bs", "kh", "hs", "rh", "BT", "sth", "xb"]}}
{"project": "FFmpeg", "commit_id": "37013fd018ae02679f177f42245f3e0e3c12d587", "target": 0, "func": "static void audiogen(void *data, enum AVSampleFormat sample_fmt,\n\n                     int channels, int sample_rate, int nb_samples)\n\n{\n\n    int i, ch, k;\n\n    double v, f, a, ampa;\n\n    double tabf1[SWR_CH_MAX];\n\n    double tabf2[SWR_CH_MAX];\n\n    double taba[SWR_CH_MAX];\n\n    unsigned static rnd;\n\n\n\n#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);\n\n#define uint_rand(x) (x = x * 1664525 + 1013904223)\n\n#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)\n\n    k = 0;\n\n\n\n    /* 1 second of single freq sinus at 1000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        a += M_PI * 1000.0 * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 1 second of varying frequency between 100 and 10000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);\n\n        a += M_PI * f * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 0.5 second of low amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 0.5 second of high amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd);\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 1 second of unrelated ramps for each channel */\n\n    for (ch = 0; ch < channels; ch++) {\n\n        taba[ch]  = 0;\n\n        tabf1[ch] = 100 + uint_rand(rnd) % 5000;\n\n        tabf2[ch] = 100 + uint_rand(rnd) % 5000;\n\n    }\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            v = sin(taba[ch]) * 0.30;\n\n            PUT_SAMPLE\n\n            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);\n\n            taba[ch] += M_PI * f * 2.0 / sample_rate;\n\n        }\n\n    }\n\n\n\n    /* 2 seconds of 500 Hz with varying volume */\n\n    a    = 0;\n\n    ampa = 0;\n\n    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            double amp = (1.0 + sin(ampa)) * 0.15;\n\n            if (ch & 1)\n\n                amp = 0.30 - amp;\n\n            v = sin(a) * amp;\n\n            PUT_SAMPLE\n\n            a    += M_PI * 500.0 * 2.0 / sample_rate;\n\n            ampa += M_PI *  2.0 / sample_rate;\n\n        }\n\n    }\n\n}\n", "idx": 2929, "substitutes": {"data": ["buffer", "da", "array", "memory", "image", "binary", "window", "d", "results", "sample", "batch", "model", "output", "m", "database", "result", "x", "p", "draw", "cache", "DATA", "o", "dat", "Data", "input"], "sample_fmt": ["sample_frlt", "sample_formld", "sample_fformat", "sample_frmt", "sample_fld", "sample_frformat", "sample_flt", "sample_formlt", "sample_formmt", "sample_formformat", "sample_cmt", "sample_cformat", "sample_cld", "sample_frld", "sample_clt"], "channels": [" chars", "chnones", "shamples", "cheunks", "corords", "chnapters", "chunks", " chunks", "quores", "chapters", "shograms", "cheapters", "cheamples", "achograms", "coramples", "shannels", "quars", "chnambers", "chones", " chograms", "chars", "echunks", "ichannels", "ichapters", "chnannels", "champles", "echores", "shords", "chores", "shores", "chnords", "thannels", "quunks", "thamples", "Channels", "Chords", "quambers", "achannels", "quannels", "shunks", "thapters", "shambers", "Chones", "chords", "chograms", "thords", "corannels", "shars", "achars", "achores", "echannels", "echars", "ichones", "ichunks", "corapters", "chnunks", "cheannels", " chores", "Chapters", "shapters", "quords", "chambers", "ichamples", "Champles", "chnamples"], "sample_rate": ["system_currency", "sample__step", "sample2mode", "software_region", "system_rate", " sample_step", "sample_rated", "samplefrate", " sample_scale", "sample__rated", "software_rates", "sample_rat", "samplefrates", "sample__rates", " sample_rated", "sample64currency", "system_type", "software_rat", "sample_scale", " sample_width", "sampleprerated", "samplefscale", "sample_term", "sample_data", "sample2rates", "sample_rates", "sample_region", "sampleacrates", "sample2scale", "sample__rate", "samplepreterm", "sampleacdata", "sample64rated", " sample_rating", "sampleacrate", "sample_step", "sample64rate", " sample_mode", "sample2rate", "sampleacrated", "sampleprerate", "sample_type", " sample_term", "sample_time", " sample_time", "software_rate", "system_rated", " sample_data", "sample_mode", "sample64type", "sample_rating", " sample_rates", "sampleprerates", "sample_currency", "sample_width", "samplefmode"], "nb_samples": ["nb_servicesamples", "nb_cessions", "nb_nipes", "nb_camps", "nb_tairs", "nb_taves", "nb_tamples", "nb_tipes", "nb_Sams", "nb_namples", "nb_tannels", "nb_saves", "nb_sources", "nb_lamps", "nb_messions", "nb_stams", "nb_scamples", "nb_lances", "nb_cites", "nb_sipes", "nb_stannels", "nb_bamps", "nb_sances", "nb_scipes", "nb_Smodels", "nb_Samps", "nb_stamples", "nb_naves", "nb_tances", "nb_tites", "nb_lamples", "nb_Sources", "nb_tamps", "nb_bances", "nb_lairs", "nb_smodels", "nb_mamples", "nb_mites", "nb_Sannels", "nb_mamps", "nb_servicesources", "nb_bamples", "nb_scaves", "nb_stamps", "nb_scamps", "nb_sairs", "nb_tessions", "nb_sessions", "nb_sannels", "nb_nources", "nb_servicesamps", "nb_tams", "nb_Samples", "nb_namps", "nb_servicesmodels", "nb_nmodels", "nb_sams", "nb_bairs", "nb_camples", "nb_sites", "nb_samps"], "i": ["yi", "my", "li", "gi", "ih", "ni", "ii", "zi", "chi", "pi", "ui", "mini", "r", "d", "I", "n", "di", "sh", "id", "mi", "it", "iu", "j", "y", "m", "ri", "anti", "info", "ti", "ir", "ini", "z", "rc", "ai", "ie", "x", "l", "c", "p", "phi", "bi", "ip", "e", "alpha", "u", "ia", "ki", "b", "qi", "ik", "ix", "ic", "uri", "ci", "io", "init", "si", "in", "xi"], "ch": ["cht", "q", "cho", "chn", "com", "ver", "cher", "j", "g", "code", "chan", "x", "child", "sc", "u", "Ch", "cp", "cha", "rh", "kick", "cl", "form", "pi", "zh", "sh", "y", "batch", "z", "work", "p", "och", "e", "chart", "core", "che", "gh", "cm", "channel", "bh", "chid", "chi", "m", "ky", "h", "c", "br", "app", "el", "uch", "qu", "anch", "sch", "cor", "conn", "cur", "ph", "th", "ich", "sk", "ah", "l", "w", "col", "ech", "CH", "cel", "b", "ci", "ach", "part", "arch", "rc"], "k": ["ek", "uk", "q", "kick", "key", "ke", "r", "ad", "n", "ck", "sh", "ph", "th", "K", "it", "sk", "ko", "y", "j", "dk", "ka", "g", "m", "ok", "mk", "kw", "z", "ky", "kn", "x", "h", "c", "p", "l", "work", "w", "e", "ak", "u", "ku", "kk", "o", "ki", "b", "ik", "t", "ks", "he", "an", "kh", "gh"], "v": ["vol", "vp", "q", "vo", "d", "n", "ver", "av", "vert", "y", "g", "j", "m", "ve", "sv", "z", "vv", "x", "l", "h", "p", "c", "vs", "w", "e", "cv", "dev", "u", "uv", "V", "value", "o", "iv", "b", "vi", "lv", "ev", "conv", "tv", "t", "nv", "va", "val"], "f": ["fc", "ff", "tf", "q", "form", "fa", "r", "n", "d", "F", "y", "g", "j", "ac", "m", "sf", "fp", "info", "fr", "z", "fe", "h", "l", "x", "p", "c", "w", "e", "u", "fx", "o", "fb", "b", "t", "af", "fs", "inf"], "a": ["A", "ata", "mA", "ba", "sa", "aaa", "ga", "access", "area", "ab", "audio", "fa", "ad", "n", "d", "aa", "ma", "ea", "aj", "ta", "api", "y", "aw", "ac", "m", "z", "au", "ai", "x", "h", "alpha", "p", "c", "asa", "w", "e", "ak", "ca", "u", "la", "ia", "as", "o", "at", "s", "action", "b", "sta", "wa", "af", "va", "an", "am", "ae"], "ampa": ["A", "q", "ga", "cc", "sb", "ab", "r", "g", "iii", "ac", "z", "temp", "abc", "h", "c", "bi", "w", "e", " b", "o", "bb", "iv", "vi", "bar", "va", "ci", "rc"], "tabf1": ["abb4", "tabbb", "tabp2", "tabb3", "tabsf1", "tabc01", "dbf1", "dbf01", "dbfb", "tabcb", "tabp4", "dbsf01", "tabsf01", "abf3", "dbsfb", "abf1", "tabb4", "tabc3", "tabfb", "dbsf1", "tabc4", "tabf01", "tabc2", "tabc1", "tabp3", "tabb2", "tabf3", "abb1", "abf4", "dbsf3", "tabsf3", "abf2", "abb3", "tabsfb", "tabb01", "dbf3", "tabf4", "tabb1", "tabp1", "abb2"], "tabf2": ["tabv4", "Tabv32", "tabp0", "Tabf2", "tabp2", "tabf0", "tabc32", "tabp4", "Tabv2", "Tabf4", "Tabv4", "Tabv0", "tabc4", "tabc2", "tabp32", "tabv0", "tabv2", "Tabf0", "tabc0", "tabv32", "tabf32", "tabf4", "Tabf32"], "taba": ["forma", "tabalpha", "loopaa", "tableaa", "tabb", "formalpha", "loopalpha", "formaa", " tabalpha", "tablea", "tableA", "abaa", "rowaa", "aba", "rowA", "rowb", "loopa", "loopA", "tabaa", "tableb", " tabA", "formA", " tabaa", "abb", "abA", "tabA", "rowa"], "rnd": ["Rrand", " rwin", " rNG", "nrnt", "prnd", "prng", "rnt", "Rng", "Rnt", "nrwin", "urrand", " rrand", "Rwin", "Randi", "Rnd", "randi", " rng", "rwin", "prNG", "RNG", "urng", "rNG", "prrand", "urandi", "nrnd", " rnt", "rrand", " randi", "nrng", "urnd", "rng"]}}
{"project": "FFmpeg", "commit_id": "ea97859c8c218b83ab747a7eabcb88ca446f6751", "target": 1, "func": "static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)\n\n{\n\n    CURSORINFO ci = {0};\n\n\n\n#define CURSOR_ERROR(str)                 \\\n\n    if (!gdigrab->cursor_error_printed) {       \\\n\n        WIN32_API_ERROR(str);             \\\n\n        gdigrab->cursor_error_printed = 1;      \\\n\n    }\n\n\n\n    ci.cbSize = sizeof(ci);\n\n\n\n    if (GetCursorInfo(&ci)) {\n\n        HCURSOR icon = CopyCursor(ci.hCursor);\n\n        ICONINFO info;\n\n        POINT pos;\n\n        RECT clip_rect = gdigrab->clip_rect;\n\n        HWND hwnd = gdigrab->hwnd;\n\n        info.hbmMask = NULL;\n\n        info.hbmColor = NULL;\n\n\n\n        if (ci.flags != CURSOR_SHOWING)\n\n            return;\n\n\n\n        if (!icon) {\n\n            /* Use the standard arrow cursor as a fallback.\n\n             * You'll probably only hit this in Wine, which can't fetch\n\n             * the current system cursor. */\n\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n\n        }\n\n\n\n        if (!GetIconInfo(icon, &info)) {\n\n            CURSOR_ERROR(\"Could not get icon info\");\n\n            goto icon_error;\n\n        }\n\n\n\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n\n\n\n        if (hwnd) {\n\n            RECT rect;\n\n\n\n            if (GetWindowRect(hwnd, &rect)) {\n\n                pos.x -= rect.left;\n\n                pos.y -= rect.top;\n\n            } else {\n\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n\n                goto icon_error;\n\n            }\n\n        }\n\n\n\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n\n\n\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n\n                CURSOR_ERROR(\"Couldn't draw icon\");\n\n        }\n\n\n\nicon_error:\n\n\n\n\n\n        if (icon)\n\n            DestroyCursor(icon);\n\n    } else {\n\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n\n    }\n\n}", "idx": 2946, "substitutes": {"s1": ["s6", "c3", "s01", "c6", "f1", "sg1", "s3", "c01", "f7", "ms2", "sg6", "sg2", "f2", "sg01", "f3", "ms1", " s7", "s2", " s2", "c7", "c1", "s7", "ms01", "c2", "ms6", " s3"], "gdigrab": ["sdircab", "eddibrabe", "gdigrub", "gdrigalog", "hdigrateab", "gdrigub", "gdyrabo", "gdigralog", "hdyrab", "hdigrabo", "gdibrob", "hdigrob", "gdyrabe", "eddigrob", "gdibrabo", "gdigrationub", "sdircabo", "gdigrabe", "sdigrabe", "hdigrateabs", "gdigrationabi", "sdigrabo", "gdigrationab", "hdyrabs", "gdigerab", "gdigrateabs", "gdyrabs", "gdibrub", "gdibrabs", "eddibrob", "sdibrab", "gdarinabi", "gdirmabe", "gdatarabo", "eddigrabe", "sdibrub", "hdigrabb", "hdigratealog", "eddigrab", "gdigrationabe", "gdrigabe", "gdigerob", "gdrigabs", "gdirmab", "gdirmob", "gdigrateob", "hdyrabo", "hdigrateob", "gdigeralog", "gdigerabs", "gdibrab", "gdrigab", "gdrigabo", "gdatarabs", "gdibrabi", "gdibrabe", "sdibrabe", "gdircab", "gdatarabb", "gdrigabi", "gdircabi", "gdyrob", "sdigrabi", "sdigrub", "sdigrab", "gdibrabb", "hdigralog", "sdircabi", "gdrigob", "gdarinab", "gdatarab", "gdigrateab", "gdigrabo", "gdigrabi", "gdigrabb", "gdarinabo", "gdyrabb", "gdyrab", "gdigratealog", "hdigrab", "eddibrab", "gdigrob", "gdircabo", "hdigrabs", "gdigrabs", "hdyrabb", "sdibrabi"], "info": ["fo", "ami", "name", "li", "http", "time", "inter", "offset", "stat", "extra", "INFO", "ii", "alias", "area", "txt", "data", "image", "ui", "loc", "icon", "di", " INFO", "type", "open", "id", "end", "Info", "op", "api", "py", "i", "in", "off", "inner", "event", "bug", "util", "source", "index", "ani", "config", "function", "result", "hi", "information", "f", "conf", "text", "all", "object", "handler", "obj", "comment", "about", "hand", "of", "ix", "error", "link", "path", "ci", "io", "init", "part", "fi", "si", "inf"], "pos": ["act", " error", "sp", "px", "open", " loc", " p", "lat", "push", " positions", "index", "opt", "x", "trans", "pop", "Pos", "on", "start", "port", "POS", "pl", " POS", "spec", " src", "position", "type", "pick", "parent", "off", "pass", "po", " trans", "post", "p", "patch", "text", "os", "val", "pt", "plus", "in", "offset", "ss", "pose", "data", "loc", "axis", "press", " position", "is", " Pos", "neg", "op", " LA", " data", "pid", "feat", " response", "ps", "pad", "bot", "len", "ref", "cache", " offset", "obj", "vis", " prop", "res", " img", "no", "tip", "def", "prop", "pres", " index", "style", "config", "block", "doc", "min", "pull", "point", "rad", "pro", "line", "part"], "rect": ["rot", "row", "src", "shape", "area", "tri", "data", "url", "image", "prot", "r", "loc", "txt", "type", "grad", "client", "lat", "RECT", "box", "coll", "project", "slice", "cont", "coord", "tr", "feat", "pad", "block", "ptr", "col", "attr", "text", "patch", "contract", "object", "ect", "rat", "region", "round", "Rect", "path", "rt", "pt", "dir", "map", "radius", "rc", "port"]}}
{"project": "qemu", "commit_id": "75cc7f018328e708d94cca23c3a77e85363f25dc", "target": 1, "func": "static void machine_initfn(Object *obj)\n\n{\n\n    MachineState *ms = MACHINE(obj);\n\n\n\n    ms->kernel_irqchip_allowed = true;\n\n    ms->kvm_shadow_mem = -1;\n\n    ms->dump_guest_core = true;\n\n\n\n\n    object_property_add_str(obj, \"accel\",\n\n                            machine_get_accel, machine_set_accel, NULL);\n\n    object_property_set_description(obj, \"accel\",\n\n                                    \"Accelerator list\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"kernel-irqchip\",\n\n                             NULL,\n\n                             machine_set_kernel_irqchip,\n\n                             NULL);\n\n    object_property_set_description(obj, \"kernel-irqchip\",\n\n                                    \"Use KVM in-kernel irqchip\",\n\n                                    NULL);\n\n    object_property_add(obj, \"kvm-shadow-mem\", \"int\",\n\n                        machine_get_kvm_shadow_mem,\n\n                        machine_set_kvm_shadow_mem,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"kvm-shadow-mem\",\n\n                                    \"KVM shadow MMU size\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"kernel\",\n\n                            machine_get_kernel, machine_set_kernel, NULL);\n\n    object_property_set_description(obj, \"kernel\",\n\n                                    \"Linux kernel image file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"initrd\",\n\n                            machine_get_initrd, machine_set_initrd, NULL);\n\n    object_property_set_description(obj, \"initrd\",\n\n                                    \"Linux initial ramdisk file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"append\",\n\n                            machine_get_append, machine_set_append, NULL);\n\n    object_property_set_description(obj, \"append\",\n\n                                    \"Linux kernel command line\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dtb\",\n\n                            machine_get_dtb, machine_set_dtb, NULL);\n\n    object_property_set_description(obj, \"dtb\",\n\n                                    \"Linux kernel device tree file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dumpdtb\",\n\n                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);\n\n    object_property_set_description(obj, \"dumpdtb\",\n\n                                    \"Dump current dtb to a file and quit\",\n\n                                    NULL);\n\n    object_property_add(obj, \"phandle-start\", \"int\",\n\n                        machine_get_phandle_start,\n\n                        machine_set_phandle_start,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"phandle-start\",\n\n                                    \"The first phandle ID we may generate dynamically\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dt-compatible\",\n\n                            machine_get_dt_compatible,\n\n                            machine_set_dt_compatible,\n\n                            NULL);\n\n    object_property_set_description(obj, \"dt-compatible\",\n\n                                    \"Overrides the \\\"compatible\\\" property of the dt root node\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"dump-guest-core\",\n\n                             machine_get_dump_guest_core,\n\n                             machine_set_dump_guest_core,\n\n                             NULL);\n\n    object_property_set_description(obj, \"dump-guest-core\",\n\n                                    \"Include guest memory in  a core dump\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"mem-merge\",\n\n                             machine_get_mem_merge,\n\n                             machine_set_mem_merge, NULL);\n\n    object_property_set_description(obj, \"mem-merge\",\n\n                                    \"Enable/disable memory merge support\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"usb\",\n\n                             machine_get_usb,\n\n                             machine_set_usb, NULL);\n\n    object_property_set_description(obj, \"usb\",\n\n                                    \"Set on/off to enable/disable usb\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"firmware\",\n\n                            machine_get_firmware,\n\n                            machine_set_firmware, NULL);\n\n    object_property_set_description(obj, \"firmware\",\n\n                                    \"Firmware image\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"iommu\",\n\n                             machine_get_iommu,\n\n                             machine_set_iommu, NULL);\n\n    object_property_set_description(obj, \"iommu\",\n\n                                    \"Set on/off to enable/disable Intel IOMMU (VT-d)\",\n\n                                    NULL);\n\n\n\n    /* Register notifier when init is done for sysbus sanity checks */\n\n    ms->sysbus_notifier.notify = machine_init_notify;\n\n    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);\n\n}", "idx": 2950, "substitutes": {"obj": ["ob", "js", "this", "act", "ass", "active", "key", "current", "n", "tk", "alt", "ct", "Obj", "j", "code", "eff", "self", "object", "jet", "od", "pl", "stat", "sb", "obo", "id", "objects", "cdn", "tmp", "api", "off", "po", "Object", "core", "org", "lib", "os", "bs", "xxx", "so", "att", "ctx", "data", "ad", "cat", "oid", "aj", "op", "instance", "m", "cb", "str", "func", "ns", "bot", "oss", "ut", "nb", "attr", "br", "el", "node", "o", "inst", "module", "old", "oa", "orb", "ops", "conn", "bo", "oi", "class", "fn", "now", "pos", "rb", "nt", "kl", "cn", "b", "element", "obb"], "ms": ["mn", "mos", "ems", "acs", "cs", "ss", "em", "ts", "mod", "mc", "mx", "mb", "ans", "ma", "sp", "Ms", "mm", "arms", "mac", "m", "gm", "ls", "MS", "md", "utils", "ps", "gs", "hm", "ns", "vs", "es", "mes", "mg", "arm", "rm", "mp", "pm", "fm", "s", "mr", "nm", "pc", "sm", "os", "ks", "bs", "me", "fs", "si"]}}
{"project": "qemu", "commit_id": "d22b2f41c470067758b3636a01b452dfeda7069f", "target": 1, "func": "void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n", "idx": 2958, "substitutes": {"bs": ["base", "files", "null", "js", "cs", "abi", "ss", "bh", "ba", "sb", "bps", "lb", "ab", "BS", "bid", "bc", "banks", "pb", "bing", "bl", "bis", "ses", "ls", "bits", "sync", "cb", "ras", "ds", "bas", "gs", "ps", "abc", "ns", "boxes", "bot", "css", "vs", "state", "Bs", "bos", "bi", "gb", "lbs", "obj", "as", "s", "bb", "iss", "blocks", "fb", "b", "bu", "ubs", "os", "ks", "bytes", "stats", "las", "bes", "fs", "db", "obs"]}}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n", "idx": 2967, "substitutes": {"opaque": ["opacity", "opaques", "operaques", "ovacity", "operaque", "copaques", "obacity", "obque", "copque", "ovaque", "copacity", "operacity", "oacity", "ovque", "obaque", "obaques", "oque", "copaque", "oaques", "ovaques", "opque", "operque", "oaque"], "status": ["js", "active", "success", "Status", "sp", "job", "wait", "code", "args", "index", "description", "sys", "message", "summary", "comment", "s", "action", "fs", "login", "name", "stat", "spec", "image", "id", "api", "model", "update", "state", "uses", "serv", "site", "plugin", "user", "base", "version", "data", "complete", "settings", "str", "json", "content", "result", "order", "size", "date", "cache", "note", "prefix", "error", "module", "msg", "mode", "si", "stage", "server", "service", "check", "gi", "method", "STAT", "scope", "num", "score", "details", "sync", "style", "source", "temp", "reason", "token", "stats", "full"], "info": ["ret", "job", "options", "args", "index", "feed", "archive", "information", "f", "comment", "by", "fi", "start", "name", "abi", "stat", "extra", "zip", "image", "type", "id", "end", "Info", "api", "off", "update", "parse", "ie", "state", "conf", "die", "io", "init", "base", "INFO", "ii", "fw", "data", "di", "is", "op", "py", "i", "json", "result", "bot", "iso", "note", "about", "error", "si", "inf", "fo", "service", "check", "total", "gi", "http", "def", "ga", "alias", "now", "num", "detail", "details", "source", "config", "ip", "fb", "full", "part", "diff"], "progress": ["flow", "total", "version", "active", "usage", "percent", "grade", "activity", "data", "area", "speed", "success", "complete", "current", "press", "recent", "help", "wait", "pass", "max", "fail", "update", "move", "partial", "sync", "err", " Progress", "pool", "step", "result", "content", "work", "p", "Progress", "resource", "length", "size", "track", "demand", "history", "message", "grades", "value", "scale", "rss", "error", "bar", "quick", "path", "count", "performance", "export", "diff", "dist", "done"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2996, "substitutes": {"code": ["call", "Code", "name", "cycle", "CE", "def", "key", "cc", "charge", "pe", "go", "data", "loc", "co", "type", "nc", "id", "cur", "parent", "end", "frame", "enc", "ode", "ch", "cod", "func", "ec", "fe", "ce", "content", "change", "c", "age", "message", "reason", "ca", "sec", "comment", "seq", "error", "catch", "codes", "coe", "cf", "line", "count", "mode", "val", "desc"], "addr": ["oa", "layer", "call", "route", "arg", "name", "src", "offset", "inter", "conn", "alias", "array", "host", "nn", "url", "localhost", "r", "loc", "ad", "align", "nc", "callback", " address", "ord", "ha", "adr", "arp", "mac", "ac", "coord", "pointer", "func", "address", "ip", "x", "pad", "ptr", "hop", "ref", "Address", "arm", "ar", "attr", "eth", "cmd", "node", "amp", "asm", "point", "amd", "rx", "rt", "mode", "enter", "ast", "ace", "rc"], "vaddr": ["pfunc", "vhost", "vpad", "varg", "upad", "faddress", "vvaddr", "ufunc", "vaddress", "vfunc", "paddress", "vmd", " vmd", "waddr", " vpad", "vvarg", "whost", " vhost", "ppad", " vaddress", "fmd", "uaddr", "fhost", "wmd", "uaddress", "vvhost", "phost", "parg", " vfunc", "farg", "vvaddress", "waddress", "faddr"], "ram_addr": ["ramvaddress", "gram_work", "ram_src", "vm_name", "ramingwork", "ram_host", "vm_host", "gram_ace", "ramingaddress", "gram_src", "ram_name", "ram_address", "gram_pad", "ram_work", "ramingaddr", "ramwaddress", "ram_pad", "gram_addr", "ramwace", "ram_ace", "ramvhost", "ramvname", "gram_address", "vm_address", "ramwaddr", "vm_addr", "ramwsrc", "ramingpad", "ramvaddr"], "paddr": ["vhost", "Paddr", "chost", "jpaddress", "pptr", "faddress", " paddress", "vaddress", "pccap", "paddress", "pcaddress", "Pptr", "porig", "pcaddr", "vcap", "corig", "lpaddr", "vorig", " pcap", "pcap", "lphost", "jpptr", "fptr", "jpeth", "caddr", "phost", "feth", "caddress", "lporig", "lpaddress", "Peth", "Paddress", "jpaddr", "faddr", "peth"]}}
{"project": "qemu", "commit_id": "aef172ffdc2f9c41d9cc043a55f1259e7c07e587", "target": 1, "func": "coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    struct unmap_list list;\n\n    int r = 0;\n\n\n\n    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpu) {\n\n        /* UNMAP is not supported by the target */\n\n        return 0;\n\n    }\n\n\n\n    list.lba = offset / iscsilun->block_size;\n\n    list.num = bytes / iscsilun->block_size;\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,\n\n                         iscsi_co_generic_cb, &iTask) == NULL) {\n\n        r = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {\n\n        /* the target might fail with a check condition if it\n\n           is not happy with the alignment of the UNMAP request\n\n           we silently fail in this case */\n\n        goto out_unlock;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        r = iTask.err_code;\n\n        goto out_unlock;\n\n    }\n\n\n\n    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,\n\n                               bytes >> BDRV_SECTOR_BITS);\n\n\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    return r;\n\n}\n", "idx": 3001, "substitutes": {"bs": ["cms", "base", "abi", "bh", "ss", "rs", "sb", "BS", "bid", "bc", "pb", "fps", "bis", "ls", "ses", "bits", "sync", "ds", "bas", "gs", "ps", "abc", "ns", "css", "bi", "vs", "bos", "aos", "gb", "lbs", "bb", "iss", "fb", "b", "os", "BC", "fs", "obs"], "offset": ["base", "to", "byte", "alias", "data", "url", "loc", "align", "position", "slot", "oid", "end", "num", "off", "i", "pos", "inet", "slice", "offs", "index", "pointer", "address", "block", "start", "zero", "order", "len", "length", "set", "size", "origin", "range", "padding", "o", "prefix", "seq", "Offset", "fee", "error", "location", "addr", "limit", "part", "timeout"], "bytes": ["nos", "base", "files", "nets", "ops", "elt", "byte", "classes", "bps", "data", "ips", "binary", "seconds", "Bytes", "devices", "reads", "abytes", "objects", "empty", "boot", "resses", "tes", "runs", "bits", "outs", "pieces", "errors", "items", "ones", "values", "lines", "len", "pages", "es", "size", "rows", "length", "words", "blocks", "fee", "seq", "used", "its", "net", "units", "les"], "iscsilun": ["iscilaumen", "incsiluna", "iscesistun", "iscrielUN", "cussilmun", "iscielmun", "ircslune", "ircslur", "iscstatune", "iacnilun", "iscielund", "iscisloun", "ISCsilmun", "iscielunt", "ircilUN", "iscmilune", "iscSilUN", "iscsellen", "iscilUN", "isclitmun", "iscriluna", "ISClitmun", "iacsilund", "iscilun", "iscsellon", "isconsequune", "ircilun", "iscintelon", "micivaluna", "iscniluna", "iscsuspuna", "iscolitUN", "isciryun", "iacnilune", "irciluan", "ircilune", "uscslon", "ircsiltun", "iscmilun", "uscsiluna", "iscrubune", "iscintelune", "iscislmun", "iscslun", "iscrubUN", "ircsilur", "iscrielune", "micivaluan", "isclesiun", "iscilaun", "iscilaune", "uscslun", "isclesiuna", "iscsilmun", "cusonsequune", "iscillintun", "isconsequun", "iscnilun", "iscislan", "ISCsilan", "iscivaluan", "incislun", "isciryunt", "iscivaluna", "incisluna", "iscnilund", "iscillinmun", "iscivalun", "iacsilun", "iscsiltun", "iscsuspoun", "ircielun", "cussilune", "iscsilen", "iscielan", "micivalune", "iscsilUN", "iscrubun", "inciryuna", "iscrilun", "iscinelun", "iscsellun", "micsiluan", "cusonsequmun", "uscsilon", "micsilune", "iscstatun", "iscislune", "ircieltun", "iacsiluna", "iscSilune", "uscsluna", "iscslen", "ircsloun", "isclituna", "iscsilune", "isclitune", "iscsloun", "iscrielun", "isclesiune", "iscsuspun", "isclesiuan", "isciryune", "iscintelen", "iscintelun", "iscielUN", "iscintelund", "iscilune", "inciryun", "cussilumen", "cusonsequumen", "iscinelune", "iacnilund", "cussilun", "incsiloun", "iscrieluan", "iscolitun", "iscslon", "ircsilmun", "ircslund", "incsilune", "iscriloun", "iscsilumen", "iscintelur", "ircsiluan", "isconsequumen", "isciluna", "iscselloun", "ISCSilUN", "iscstatmun", "uscsilun", "micsiluna", "incsilunt", "inciryunt", "incisloun", "iscilon", "incislune", "isclitun", "ircsluna", "iscsiluan", "iscesisun", "iscnilune", "iscsilan", "iscmiluna", "ircsilen", "ISCsilun", "ISClitan", "cusonsequun", "iscillinun", "ISClitun", "ISCsilUN", "micsilun", "ircslon", "iscslune", "isciryuna", "ISCSiluna", "iscstatumen", "iscolitund", "iscsuspune", "iscsilon", "ircielmun", "iscSilun", "iscsluna", "ISCsilon", "iscesismun", "iscielune", "ircslUN", "iscrilune", "iscsilund", "iscisluna", "iscsiluna", "iscielun", "ISCSilon", "iscSiluna", "incsilun", "iscesisuna", "iscivalune", "ircsiluna", "iscillinuna", "iscinelur", "iscslUN", "isconsequmun", "iscmilunt", "iscineluna", "ircslun", "ircsilUN", "iscislon", "ircsilund", "iscSilon", "iscislun", "iscsilur", "iscinteluna", "ircieluna", "iscolituna", "iscsiloun", "ircsiloun", "ircsilun", "iscslur", "uscsilune", "uscslune", "iscsilunt", "isciluan", "inciryune", "iscieltun", "iscrubuan", "iscilamun", "iscinteloun", "ircslen", "ircsilon", "iscsluan", "iacsilune", "iscliton", "isclitan", "iscslund", "iscieluna", "ISCSilun", "ISCsiluna", "iacniluna", "ircsilune", "ISClituna", "micivalun"], "iTask": ["iJob", "itask", "ciResult", "apiEmpty", "apiJob", " iClient", " iRequest", "liCommand", "iSend", "iRest", "eJob", "xiTask", "xiJob", "inShort", "oiCommand", "iutask", "iuThis", "inCommand", "sTask", "uiAttempt", "stask", "eEmpty", "antiAttempt", "inTask", "iiJob", "apitask", "giTask", "uiKey", "iAttempt", "iProcess", "gitask", " iLink", " iThread", "iKey", "iiLink", "iResult", "inSocket", " iController", "iNode", "IController", "xiThread", "iiParent", "uiThread", "giJob", "siProcess", "iRequest", " iKey", "ciTask", "ptask", "etask", "oiSocket", "idiClient", " iRest", "iiSocket", "antiKey", " iCheck", " iParent", "idiRest", "uiJob", "antiRequest", "INode", " iProcess", " iNode", "antiSend", "iParent", "ciNode", "oiShort", "iiTask", "antiTest", "iniJob", " iSend", "ILink", "iiShort", "eTask", "pEmpty", "ISend", "iController", "iiNode", "iiAttempt", "sThread", "iThis", "oiTask", "iCommand", "iiThread", "liNode", "antiChild", "iitask", "iniThread", "uiRequest", " iAttempt", " iCommand", "citask", "iThread", "idiTest", " iResult", "uiTask", "antiController", "iniAttempt", "iCheck", "pTask", "IResult", "liTask", "iniTask", "siThis", "giThread", "ITask", "antiClient", " iTest", "iSocket", " itask", "ciThread", "iChild", "antiRest", "xitask", "pJob", "iClient", "IProcess", "iuProcess", "iTest", "iShort", "ciCheck", "apiTask", "iiCommand", " iThis", "iuTask", "iiProcess", "sitask", "ICheck", "ICommand", " iChild", "IChild", "siTask", "antiTask", "liParent", "iEmpty", "idiTask", "iLink"], "list": ["ist", "base", "null", "cli", "this", "lock", "li", " List", "ul", "def", "lp", "array", "queue", "cl", "acl", " L", "data", "LIST", "out", "n", "type", "add", "id", "chain", "record", "parent", "arr", "tmp", "member", "batch", "bl", "g", "i", "detail", "pre", "code", "ll", "info", " l", "sync", "str", "index", "pool", "st", " LIST", "ack", "result", "l", "block", "L", "x", "len", "core", "join", "obj", "lists", "seq", "t", "listed", "full", "count", "List", "map", "wx"]}}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3003, "substitutes": {"cs": ["cms", "acs", "ctx", "fs", "ss", "spec", "qs", "conn", "cc", "rs", "Cs", "ck", "nc", "bc", "ins", "cons", "tc", "sk", "cus", "cas", "ls", "cr", "ds", "ps", "ec", "dc", "ns", "ce", "c", "css", "vs", "lc", "ced", "sys", "sc", "cache", "cn", "wcs", "pc", "s", "cp", "cf", "ks", "ci", "CS", "rc"], "address": ["route", "test", "server", "capacity", "name", "offset", "channel", "inter", "target", "interface", "array", "alias", "area", "host", "image", "url", "localhost", "position", "type", "api", "mac", "inet", "eni", "network", "password", "attribute", "number", "contact", "coord", "index", "pointer", "config", "ack", "ip", "p", "order", "resource", "size", "length", "ptr", "Address", "cache", "message", "office", "reset", "reference", "ress", "ion", "chip", "point", "email", "prefix", "cp", "site", "error", "uri", "location", "path", "addr", "mode", "enter", "ace", "port"], "rw": ["route", "row", "src", "workers", "hw", "rs", "fw", "wr", "rn", "r", "rr", "ru", "lr", "rf", "tw", "rb", "wn", "ran", "nr", "wh", "raw", "usr", "work", "sw", "w", "ptr", "rl", "wb", "rows", "ww", "sr", "RW", "working", "nw", "rss", "rx", "rack", "iw", "addr", "rt", "wp", "rew", "vr", "rh", "rc", "wx"], "mmu_idx": ["mmu_Idz", "mmu_namex", "mmu_inxc", "mmu_idexc", "mmu_idw", "mmu_Idx", "mmu_idxc", "mmu_inx", "mmu_idv", "mmu_nameX", "mmu_inv", "mmu_midp", "mmu_IdX", "mmu_idev", "mmu_Idxc", "mmu_idz", "mmu_midg", "mmu_midx", "mmu_inw", "mmu_Idg", "mmu_idX", "mmu_idew", "mmu_idp", "mmu_midz", "mmu_namexc", "mmu_idg", "mmu_nameg", "mmu_Idp", "mmu_idex"], "cpu": ["cm", "np", "vm", "cli", "gpu", "ctx", "hw", "conn", "cc", "computer", "clock", "uci", "nc", " cp", "bc", "nic", "tc", "boot", "CPU", "proc", "utils", "config", "bench", "c", "cv", "lc", "pu", "core", "cn", "cache", "sys", "processor", "pc", "connection", "cp", "cmp", "uu", "net"], "env": ["eu", "oa", "np", "vm", "cli", "server", "ctx", "exe", "ext", "fen", "conn", "context", "anc", "chn", "environment", "nc", "ea", "scope", "cdn", "eng", "ne", "enc", "kernel", "eni", "proc", "code", "estate", "err", "dt", "config", "kn", "ec", "exc", "dc", "Environment", "c", "cv", "state", "e", "esp", "core", "cache", "conf", "cn", "exec", "viron", "gui", "en", "pec", "v", "ev", "lv", "cf", "engine", "cfg", "agent", "net", "console", "qt", "energy", "db"], "physical": ["external", "gpu", "http", "local", "intel", "target", "primary", "interface", "data", "binary", "present", "type", "pg", "sp", "relative", "platform", "Physical", "remote", "tp", "proc", "network", "info", "pixel", "password", "python", "pointer", "config", "phys", "native", "p", "thin", "virtual", "secondary", "sq", "php", "linux", "pc", "prefix", "ssl", "cp", "hard", "path", "pro", "protected", "performance", "protein", "integer"], "prot": ["rot", "ret", "test", "cli", "server", "tf", "att", "ext", "primary", "fen", "stat", "txt", "binary", " protocols", "type", "prop", "Prot", "pb", "platform", "rf", "pos", "plain", "proxy", "proc", "fp", "password", " protocol", "prototype", "python", "status", "config", "pointer", "phys", "pred", "virtual", "reset", "ptr", "secondary", "col", "php", "ssl", " proto", "prefix", "seq", "pro", "addr", "io", "protected", "transfer", "protein", "port"], "access_type": ["accessityinfo", "accessitytype", "accessitylike", " access_like", "access_info", " access_time", "accesserinfo", " access_types", "access_state", " access_info", "accesstypetypes", "accesserlike", "access_like", " access_order", "accessertime", "access_loc", "accessalloc", "accessertype", " access_state", "accesstypestate", "accesstypetype", "access_types", "accessalinfo", "accessaltype", " access_loc", "accessitytime", "accesstypeorder", "access_time", "access_order"]}}
{"project": "qemu", "commit_id": "e26110cfc67d48331a76e9b1e6f7fed7569e1ab3", "target": 0, "func": "static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n", "idx": 3020, "substitutes": {"type": ["base", "test", "name", "key", "array", "pe", "method", "class", "tag", "field", "kind", "id", "parent", "py", "y", "i", "code", "info", "Type", "style", "index", "str", "x", "block", "p", "role", "object", "plugin", "t", "types", "rule", "module", "TYPE", "part", "list", "typ"], "l": ["pl", "ol", "li", "Li", "ul", "lp", "lb", " L", "d", "n", "dl", "fl", "ln", "shell", "like", "sl", "lr", "nl", "iol", "i", "j", "m", "ls", "lt", "ll", "z", "c", "p", "L", "e", "lc", "f", "kl", "u", "el", "o", "v", "s", "b", "t", "line", "lo", "list", "le"]}}
{"project": "qemu", "commit_id": "8bd7f71d794b93ce027b856f5b79a98f4f82e44c", "target": 0, "func": "static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n", "idx": 3040, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "f43a16049ef07585789d311f314f236a314f91f7", "target": 0, "func": "int opt_cpuflags(const char *opt, const char *arg)\n\n{\n\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n\n    static const AVOption cpuflags_opts[] = {\n\n        { \"flags\"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = \"flags\" },\n\n        { \"altivec\" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = \"flags\" },\n\n        { \"mmx\"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = \"flags\" },\n\n        { \"mmx2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = \"flags\" },\n\n        { \"sse\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = \"flags\" },\n\n        { \"sse2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = \"flags\" },\n\n        { \"sse2slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = \"flags\" },\n\n        { \"sse3\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = \"flags\" },\n\n        { \"sse3slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = \"flags\" },\n\n        { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n", "idx": 3054, "substitutes": {"opt": ["pl", "name", "ext", "Opt", "bit", "spec", "optim", "cat", "prop", "alt", "ord", "buf", "op", "pair", "options", "proc", "Option", "config", "attr", "oc", "text", "cmd", "var", "path", "val", "OP", "option"], "arg": ["argument", "call", "ig", "name", "bit", "cat", "Arg", "end", "op", "enc", "param", "mac", "proc", "args", "config", "len", "flag", "ar", "cmd", "lib", "var", "gen", "val", "load", "inc", "mem"], "cpuflags_opts": ["cpuflags_opcs", "cpuflags_optcs", "cpuflags_ops", "cpuflags_optionts", "cpuflags_optioncs", "cpuflags_opencs", "cpuflags_opc", "cpuflags_opents", "cpuflags_optc", "cpuflags_options", "cpuflags_openc", "cpuflags_optionc", "cpuflags_opens", "cpuflags_optts"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);\n\n}\n", "idx": 3065, "substitutes": {"dst": ["idst", "dsc", "drc", "dST", "idST", "datdr", " dsrc", "cdst", "cdrc", " drc", "datrc", " dsc", "cdsrc", "dsrc", "iddr", "ddr", "cdsc", " ddr", "idrc", " dST", "datst", "datST"], "src": ["sub", "sup", "rate", "rs", "sb", "url", "loc", "rob", "d", "use", "bc", "sl", "buf", "bis", "i", "rb", "dest", "cb", "slice", "source", "config", "st", "sel", "rl", "sc", "gb", "sec", "bg", "sr", "s", "iv", "b", "inst", "sur", "img", "low", "dist", "rc"], "stride": ["strided", "strine", "sprend", "drice", "strend", "ctrip", "arrend", "ctrider", "drend", "strone", "ctrine", " strend", "STRine", " strride", "strride", " strade", " strice", "STRip", "strider", "drone", " strider", "Strided", "spride", "drride", "sprided", "strice", "drade", "arrade", "STRider", " strone", "dride", "Stride", "Strride", " strine", "sprice", "STRide", "strade", " strided", "ctride", "arride", "strip", " strip", "Strone", "drided", "arrided"]}}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n", "idx": 3070, "substitutes": {"opaque": [" opque", "opaques", "pac", "OPc", " opac", "paques", "psa", "opac", "OPac", "OPaques", " opsa", "OPque", "OPaque", "openc", "OPsa", "openque", " opaques", "opsa", "openaques", "openaque", "opc", "paque", "opque", " opc"], "s": ["sg", "submit", "same", "server", "js", "service", "opens", "cs", "http", "ss", "ops", "spec", "ts", "a", "rs", "sb", "new", "d", "n", "is", "sl", "scope", "i", "g", "params", "m", "ses", "sf", "spot", "sync", "settings", "storage", "ds", "sets", "status", "ps", "gs", "ns", "c", "p", "rates", "services", "state", "e", "f", "es", "secondary", "sys", "sq", "conf", "south", "sec", "o", "stats", "b", "S", "t", "session", "os", "your", "hs", "states", "fs", "si", "sym", "parts", "ssl"], "divider": ["dividers", "DIVcer", "devide", "promide", "provinner", "devider", "Dividable", "Division", "promider", " divide", " divided", "incision", "decide", "Divided", "DIVision", "divisionoration", "divinner", "DIVider", "divisionision", "division", "providers", " division", "DivIDER", "divided", " divcer", "Divcer", "divoration", "deciders", "decides", "Divides", "divIDER", "divisionider", " divinner", "incider", "providable", "Divinner", " dividable", "decidable", "promice", "multiplider", "divcer", "provide", "provider", "divides", "incoration", "devidable", "divride", "multiplride", " divIDER", "multiplision", " divice", "DIVidable", "decIDER", "deviders", "divice", "decider", "Divide", "provided", "Divider", "provIDER", "incride", "dividable", "promision", "multiploration", "decision", "divide", " divides", "divisionride", "decice"]}}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 3076, "substitutes": {"ssd": ["csse", "rssdk", "bsD", "cssds", "cssd", "bsds", "pss", "sss", "psdk", "vse", "isssd", "ass", "vsd", "opensds", "sse", "bsdc", "pssd", "essd", "csssd", "vssd", "opensd", "issdk", "psdc", "asd", "psb", "bsd", "nsdc", "asds", "opensdk", "nsds", "nsd", "SSsd", "psds", "ssdb", "psd", "essdc", "ssdat", "ssb", "issds", " ssdb", "ssdc", "essds", "nsdk", "vsdc", " ssds", "rsssd", "asdk", "issd", "sssd", " ssdat", "nss", "SSdc", "rssd", "cssdb", "ssds", "issb", "essdb", "cssD", "cssdc", "SSds", "psD", "isse", "ssD", "rssdc", "rssdat", "esssd", "opensb", "rssds", "SSd", "issdc", "ssdk", "psdat", " sssd"], "surface": ["metadata", "generic", "peer", "folder", "faces", "sample", "client", "ula", "sheet", "sf", "master", " Surface", "sound", "database", "archive", "alpha", "sole", "f", "aster", "skin", "message", "cell", "cover", "texture", " surf", "spec", "interface", "filename", "image", "ui", "shell", "package", "ser", "request", "ptr", "resource", "core", "forge", "ope", "sr", "FACE", "tile", "tle", "player", "edge", "rect", "sym", "layer", "scene", "data", "use", "face", "proxy", "project", "slice", "document", "func", "content", "result", "pad", "setup", "public", "stream", "node", "bridge", "sur", "Sur", "enter", "slave", "stage", "server", "src", "buffer", "material", "wrapper", " surfaces", "area", "binary", "cur", "shared", "prototype", "source", "feature", "grave", "draw", "save", "airo", "console", "ace", "transfer", "game"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750fx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 3082, "substitutes": {"env": ["eu", "nc", "here", "enc", "gov", "code", "args", "er", "event", "err", "ec", "progress", "cv", "dev", "vs", "skin", "gui", "viron", "jp", "en", "engine", "energy", "ext", "context", "equ", "ea", "eng", "e", "org", "forge", "v", "ev", "site", "np", "ctx", "gr", "enable", "forest", "environment", "gear", "enh", "exc", "c", "loader", "app", "el", "obj", "nw", "enter", "net", "done", "stage", "oa", "vm", "server", "fen", "conn", "dict", "output", "erv", "ah", "style", "dt", "status", "config", "kn", " environment", "Environment", "exec", "bg", "dat", "console", "export", "db", "ench"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n", "idx": 3098, "substitutes": {"stream": ["Stream", "test", "server", "src", "buffer", "channel", "context", "method", "host", "form", "window", "wrap", "sl", "client", "model", "pipe", "file", "source", "document", "tr", "pool", "feed", "progress", "reader", "sw", "stack", "w", "resource", "track", "draw", "child", "thread", "valid", "socket", "path", "engine", "view", "each", "input", "port"], "stream_printf": [" stream_print", "stream__println", "stream__print", " stream_flush", "stream__callback", "stream_format", " stream_println", "stream_callback", "stream_flush", "streampflush", " stream_callback", "stream_println", "streampprint", "stream__printf", "streampformat", "streampprintf", "stream_print", " stream_format"]}}
{"project": "FFmpeg", "commit_id": "9924f1bc34242bb9315c355108f3ce744c1f33c5", "target": 0, "func": "static int mkv_write_header(AVFormatContext *s)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    ebml_master ebml_header;\n\n    AVDictionaryEntry *tag;\n\n    int ret, i, version = 2;\n\n    int64_t creation_time;\n\n\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n\n        mkv->mode = MODE_WEBM;\n\n    else\n\n        mkv->mode = MODE_MATROSKAv2;\n\n\n\n    if (mkv->mode != MODE_WEBM ||\n\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n\n        version = 4;\n\n\n\n    if (s->nb_streams > MAX_TRACKS) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"At most %d streams are supported for muxing in Matroska\\n\",\n\n               MAX_TRACKS);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n\n            version = 4;\n\n    }\n\n\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n\n    if (!mkv->tracks) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n\n    end_ebml_master(pb, ebml_header);\n\n\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n\n    mkv->segment_offset = avio_tell(pb);\n\n\n\n    // we write 2 seek heads - one at the end of the file to point to each\n\n    // cluster, and one at the beginning to point to all other level one\n\n    // elements (including the seek head at the end of the file), which\n\n    // isn't more than 10 elements if we only write one of each other\n\n    // currently defined level 1 element\n\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n\n    if (!mkv->main_seekhead) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n\n    if (ret < 0) goto fail;\n\n\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n    pb = mkv->info_bc;\n\n\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n\n        else\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n\n\n        if (mkv->mode != MODE_WEBM) {\n\n            uint32_t segment_uid[4];\n\n            AVLFG lfg;\n\n\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n\n\n            for (i = 0; i < 4; i++)\n\n                segment_uid[i] = av_lfg_get(&lfg);\n\n\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n\n        }\n\n    } else {\n\n        const char *ident = \"Lavf\";\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n\n    }\n\n\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n\n        uint8_t date_utc_buf[8];\n\n        AV_WB64(date_utc_buf, date_utc);\n\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n\n    }\n\n\n\n    // reserve space for the duration\n\n    mkv->duration = 0;\n\n    mkv->duration_offset = avio_tell(pb);\n\n    if (!mkv->is_live) {\n\n        int64_t metadata_duration = get_metadata_duration(s);\n\n\n\n        if (s->duration > 0) {\n\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else if (metadata_duration > 0) {\n\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else {\n\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n\n        }\n\n    }\n\n    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    else\n\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    pb = s->pb;\n\n\n\n    // initialize stream_duration fields\n\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n\n\n    ret = mkv_write_tracks(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    for (i = 0; i < s->nb_chapters; i++)\n\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n\n\n    ret = mkv_write_chapters(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    ret = mkv_write_tags(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n", "idx": 3117, "substitutes": {"s": ["sg", "submit", "js", "this", "qs", "sa", "n", "sites", "sl", "client", "g", "ses", "ls", "sf", "self", "us", "f", "secondary", "sys", "u", "single", "events", "your", "an", "se", "fs", "parts", "sup", "spec", "ts", "sb", "aws", "uploads", "uns", "xs", "sv", "request", "sets", "p", "e", "conf", "v", "su", "serv", "S", "os", "ks", "session", "bs", "its", "hs", "in", "plugins", "sym", "ssl", "cs", "ss", "a", "rs", "new", "r", "is", "ins", "ions", "m", "settings", "ds", "als", "ps", "gs", "ns", "c", "es", "south", "si", "server", "service", "http", "ops", "ads", "d", "ans", "sis", "comments", "sync", "tests", "l", "services", "w", "features", "sq", "stats", "b", "support", "states"], "mkv": ["ikv", "okv", "okV", "ikov", "skov", "wkv", "ckv", "mku", "okh", "ckV", "mkl", "kv", "mkver", "ckj", "tkver", " mkh", "ckvv", "skc", "ikc", " mkl", "mkj", " mkV", " mkver", "bbov", " mkj", "mkvv", "okl", "wkvv", "tkov", "wkj", "mkc", "okov", "skV", "tkv", "mkV", "skv", "kl", "bbv", "bbver", "mkh", "ikV", "tku", "okc", "mkov", "kV", " mkvv", "wkV", "kh", "bbu", " mku", " mkov"], "pb": ["parser", "verb", "ctx", "primary", "lp", "sb", "mc", "lb", "ab", "bm", "cpp", "hub", "ub", "prot", "vim", "type", "bc", "platform", "buf", "tmp", "PB", "rb", "fp", "cb", "pa", "cv", "wb", "message", "gb", "summary", "pm", "obj", "phrase", "amp", "meta", "bp", "pc", "bb", "mp", "fb", "cp", "bs", "wp", "typ", "db"], "ebml_header": ["ebsl_headers", "ebml_metadata", "ebsl_header", "ebsl_main", "ebml_headers", "ebml_main", "ebsl_metadata"], "tag": ["test", "row", "version", "name", "TAG", "key", "xml", "cat", "type", "rec", "id", "record", "entry", "bug", "tr", "config", "last", "description", "feature", "ack", "stream", "comment", "module", "tags", "Tag", "desc"], "ret": ["vision", "server", " compat", "out", " val", " revision", "con", "j", " clen", " resp", " result", " Version", "code", "rev", " success", "result", " r", "cv", "dev", " ver", "len", "resp", " vers", "VERSION", " rc", "rc"], "i": ["ski", "cli", "yi", "name", "my", "li", "gi", "abi", "iri", "ni", "ii", "zi", "pi", "ui", "mini", "oi", "d", "n", "I", "type", "di", "id", "mi", "it", "iu", "api", "j", "g", "y", "eni", "ri", "inner", "m", "info", "ti", "ini", "index", "multi", "temp", "ai", "ie", "ip", "ind", "p", "phi", "e", "f", "ori", "o", "v", "iv", "qi", "ix", "b", "ik", "uri", "ci", "io", "mu", "init", "fi", "start", "si", "xi"], "creation_time": ["creation4time", "creation4info", "creation2tc", "create_tc", "creation2info", "create_time", "creation4timer", "creation4tc", "create_info", "creation_tc", "creation2timer", "creation2time", "create_timer", "creation_info", "creation_timer"]}}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n", "idx": 3130, "substitutes": {"s": ["submit", "this", "service", "opens", "ss", "ops", "spec", "sa", "a", "sb", "new", "ans", "is", "sl", "scope", "g", "space", "params", "m", "ses", "sf", "sync", "settings", "request", "ds", "ns", "c", "p", "services", "state", "self", "e", "secondary", "f", "conf", "sq", "sys", "south", "o", "su", "b", "S", "os", "session", "your", "an", "states", "si", "in", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_sws_init_swScale_mmx(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_INLINE_ASM\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        sws_init_swScale_MMX(c);\n\n#if HAVE_MMXEXT_INLINE\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        sws_init_swScale_MMX2(c);\n\n#endif\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n#if HAVE_YASM\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 3153, "substitutes": {"c": ["cm", "cs", "ctx", "cc", "mc", "context", "ct", "nc", "bc", "cur", "con", "k", "ac", "m", "coll", "cr", "ch", "C", "ec", "dc", "ce", "cu", "p", "l", "cv", "e", "lc", "f", "u", "center", "vc", "pc", "s", "v", "b", "t", "cf", "ci", "uc", "rc"]}}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget(const uint8_t **p, int type, int le)\n\n{\n\n    switch (type) {\n\n    case TIFF_BYTE:\n\n        return *(*p)++;\n\n    case TIFF_SHORT:\n\n        return tget_short(p, le);\n\n    case TIFF_LONG:\n\n        return tget_long(p, le);\n\n    default:\n\n        return UINT_MAX;\n\n    }\n\n}\n", "idx": 3158, "substitutes": {"p": ["np", "vp", "lp", "data", "pi", "d", "n", "ap", "sp", "pb", "op", "api", "pre", "i", "g", "j", "tp", "m", "P", "pointer", "ps", "progress", "ip", "pa", "c", "x", "l", "w", "e", "f", "patch", "cache", "u", "jp", "o", "pc", "bp", "point", "v", "b", "cp", "t", "wp", "pp", "port"], "type": ["unit", "name", "version", "key", "pretty", "method", "ype", "cl", "class", "ct", "ase", "format", "id", "sl", "op", "py", "y", "i", "pre", "pos", "code", "info", "Type", "style", "index", "address", "block", "role", "set", "len", "col", "ref", "value", "o", "pc", "scale", "action", "plugin", "t", "types", "al", "TYPE", "val", "typ", "ity"], "le": ["pl", "led", "ale", "ld", "li", "lem", "pe", "cl", "lb", "lf", "lu", "ge", "Le", "sl", "ne", "ble", "leave", "ll", "ve", "lex", "lee", "ple", "ele", "ie", "l", "ling", "ler", "e", "lc", "kl", "middle", "ar", "able", "la", "el", "ile", "sle", "less", "ole", "cell", " LE", "line", "let", "lo", "ial", "lead", "les", "little", "LE"]}}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    int i, quant, level, orientation, quant_idx;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    DiracContext *s = avctx->priv_data;\n\n    DiracSlice *slice = arg;\n\n    GetBitContext *gb = &slice->gb;\n\n\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n\n    quant_idx = get_bits(gb, 8);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n\n            quants[level][orientation] = quant;\n\n        }\n\n    }\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (i = 0; i < 3; i++) {\n\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n\n        int64_t bits_left = 8 * length;\n\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n\n\n\n        if (bits_end >= INT_MAX) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n\n                               &s->plane[i].band[level][orientation], NULL);\n\n            }\n\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3160, "substitutes": {"avctx": ["AVctx", "ajctx", "avecm", "awcb", "awconfig", "avectx", "Avcb", "afctx", "accontext", "afcontext", "AVcb", "abcb", "Avcontext", "acctx", "Avctx", "AVconfig", "accb", "awcontext", "ajcu", "AVctl", "abctx", "afcu", "avcb", "ajcontext", "afcm", "acctl", "avctl", "abconfig", "avconfig", "avcontext", "abcontext", "avecontext", "avcu", "awctx", "avcm", "AVcontext", "ajcm", "Avctl", "avecu"], "arg": ["argument", "call", "parser", "ig", "target", "spec", "array", "alias", "slot", "use", "cand", "Arg", "lang", "ag", "ark", "arr", "gap", "param", "pass", "enc", "args", "parse", "abc", "ang", "or", "arc", "flag", "ar", "ray", "alloc", "amp", "ay", "agi", "cell", "gen", "val", "load", "ace", "can"], "i": ["lock", "li", "gi", "ni", "ii", "zi", "chi", "pi", "ui", "oi", "mini", "d", "I", "n", "type", "di", "uni", "id", "mi", "iu", "g", "j", "m", "eni", "ri", "ti", "ini", "index", "multi", "ai", "ie", "x", "ind", "c", "p", "ip", "l", "phi", "e", "f", "u", "o", "v", "b", "ix", "qi", "depth", "uri", "ci", "io", "si", "in", "xi"], "quant": ["serial", "cost", "quiet", "total", "q", "quad", "local", "channel", "bit", "spec", "charge", "dim", "d", "requ", "cat", "pick", "id", "cur", "query", "mult", "client", "gap", "comp", "package", "component", "multipl", "frac", "secure", "util", "aud", "str", "inc", "post", "pad", "rank", "length", "draw", "patch", "text", "specific", "std", "comment", "quality", "round", "scale", "prefix", "qa", "qual", "req", "mix", "depth", "quick", "gen", "tax", "direct", "count", "volume", "qt", "complex", "diff", "qu", "integer"], "level": ["vol", "lock", "ul", "key", "url", "weight", "lvl", "field", "enc", "code", "file", "index", "child", "sc", "where", "quality", "round", "levels", "path", "wall", "limit", "pri", "flow", "pl", "unit", "ld", "name", "local", "time", "spec", "cl", "type", "id", "parent", "found", "pass", "model", "fail", "update", "inc", "step", "lc", "condition", "length", "resource", "la", "scale", "less", "count", "serial", "layer", "version", "half", "pe", "loc", "di", "loop", "year", "vel", "size", "value", "el", "Level", "old", "error", "rule", "low", "mode", "lo", "si", "stage", "cost", "letter", "ale", "fl", "wl", "coll", "sync", "style", "source", "temp", "status", "l", "block", "col", "rel", "pull", "thread", "clean", "depth", "full", "line", "day", "rol"], "orientation": ["equimation", "ortotation", "orientformation", "occupination", "rientrency", "organation", "directionution", "homity", "orientedration", "rotational", "variations", "oriento", "directionination", " orientations", "orientatio", "riention", "directionATION", "variation", " oriention", " orientruction", "designution", "conductity", " orientition", "rientoration", "conductaton", "rientraction", "directionational", "orientedination", "rientition", "designuation", "rotraction", "occupational", "location", "iterimation", "orientotation", "homization", "iteration", "ortimation", "orientity", "rientity", "orientoration", "iterotation", "equation", "directionration", "designity", "variational", "ortational", "ortriction", "conductation", "rientformation", "locimation", "occupning", "orientning", "designaton", "orientraction", " orientatio", "designrency", "orientruction", "occupration", "rotity", " orientraction", "orientition", "occupization", "rotformation", "rientration", "rientation", "orientuation", "orientution", "rientuation", "conductization", "iterational", "homation", "rientATION", "occupancy", "rototation", "variATION", "orientational", "oriention", "orientration", "equo", " orientformation", "rientruction", "variancy", "orientedization", "designization", "directionatio", "directionation", "rotation", "orientriction", "orientimation", " orientity", "designation", "ortation", "rientatio", "variution", "rientimation", "directionruction", "orientedning", "organuation", "directionion", "orientedatio", "orientaton", " orientational", "orientedriction", "orientancy", "rotimation", "organrency", "orientrency", "designational", "orientization", "occupatio", "directionition", "rientational", " orientoration", "orientations", "equration", "orientedation", "ortning", "ortization", "occupations", "orientination", "riento", "homaton", "locration", "organATION", "designATION", " orientancy", "directionoration", "occupation", "loco", "orientATION", "occupriction"], "quant_idx": ["quant_minxes", "quant2aidn", "quant_endx", "quant_pidxes", "quant_adxe", "quant_aidx", "quant__endX", "quant_aidxes", "quant2idx", "quant_fx", "quant_fxes", "quant_idxe", "quant2aidxs", "quant_idxs", "quant_pidx", "quant_dv", "quant_dx", "quant0pidx", "quant_idn", "quant_pidn", "quant_adx", "quant_pidxs", "quant_aidn", "quant2idxes", "quant_pidb", "quant_idxes", "quant_pidv", "quant0idx", "quant_fv", "quant_minxs", "quant0pidb", "quant_idX", "quant0idb", "quant__endv", "quant_idexes", "quant2idxs", "quant_idv", "quant__idX", "quant_endxe", "quant_minn", "quant_dX", "quant2idn", "quant0idxes", "quant_dxe", "quant__endx", "quant_idex", "quant0pidv", "quant_endv", "quant_adX", "quant__idxe", "quant2aidxes", "quant_idb", "quant_fb", "quant_ideb", "quant2aidx", "quant0pidxes", "quant_endX", "quant_aidxs", "quant_idev", "quant_adv", "quant__idx", "quant__endxe", "quant__idv", "quant_minx", "quant0idv"], "quants": ["quapters", "qents", "quancy", "inquantis", "quantis", "acquances", "aquapters", "requancy", "Quantis", "qancy", "inquatts", "acquant", "requents", " quantis", "aquants", "quatts", "requant", "quents", "quances", "inquants", "inquant", "aquents", "Quant", "aquant", "Quants", "qant", "requants", "acquants", " quatts", "aquances", "acquapters", "Quatts", " quapters", "qants", "aquancy", " quances"], "MAX_DWT_LEVELS": ["MAX_DWT_LELLP", "MAX_DWT_LVEL5", "MAX_DWT_LVELN", "MAX_DWT_LEvel5", "MAX_DWT_LELLS", "MAX_DWT_LVELS", "MAX_DWT_LEVEL5", "MAX_DWT_LEALLN", "MAX_DWT_LLLP", "MAX_DWT_LLL5", "MAX_DWT_LEALL5", "MAX_DWT_LELLN", "MAX_DWT_LEVELN", "MAX_DWT_LEvelP", "MAX_DWT_LEVELP", "MAX_DWT_LEvelS", "MAX_DWT_LELL5", "MAX_DWT_LVELP", "MAX_DWT_LEALLP", "MAX_DWT_LLLN", "MAX_DWT_LEvelN", "MAX_DWT_LEALLS", "MAX_DWT_LLLS"], "s": ["sg", "sa", "qs", "n", "sl", "j", "g", "ses", "ls", "sf", "storage", "self", "f", "sys", "sc", "u", "sky", "se", "fs", "parts", "sup", "spec", "sb", "aws", "sv", "utils", "p", "e", "core", "conf", "su", "site", "S", "t", "session", "serv", "os", "sci", "sym", "ssl", "cs", "ctx", "ss", "rs", "a", "data", "r", "is", "bis", "space", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "rates", "es", "si", "service", "ops", "d", "scope", "side", "params", "details", "sync", "l", "services", "sq", "b"], "slice": ["unit", "layer", "match", "parser", "sub", "np", "rice", "service", "crop", "split", "shape", "array", "pe", "dim", "ii", "sb", "zip", "image", "binary", "slot", "ge", "sl", "sample", "gate", "seed", "package", " sliced", "gm", "source", "index", "parse", "storage", "ie", "thin", "p", "diff", "sq", "sc", "range", "node", " slicing", "ring", "v", "scale", "uri", "ci", "view", "sci", "slave", "gp", "se", "edge", "Sl", "si", "ice", "game"], "gb": ["rg", "sg", "cli", "gio", "gpu", "cs", "ctx", "gram", "quad", "kb", "ga", "bo", "sb", "gc", "dim", "bm", "lb", "hub", "binary", "gy", "ui", "mb", "gh", "eb", "pg", "ge", "buff", "bc", "sl", "gz", "xy", "gate", "GB", "gin", "g", "gg", "rb", "gm", "gn", "cb", "cgi", "gem", "storage", "gam", "gs", "bf", "phy", "ged", "gold", "cd", "agg", "bg", "bb", "pc", "lib", "b", "plugin", "abb", "gen", "ci", "cfg", "kg", "gal", "gp", "gd", "db", "xb"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_wb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRWBContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 16000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 16000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->last_bitrate    = avctx->bit_rate;\n\n\n\n    avctx->frame_size  = 320;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->state     = E_IF_init();\n\n\n\n    return 0;\n\n}", "idx": 3161, "substitutes": {"avctx": ["avercmd", "ajctx", "amctx", "ajcms", "afcontext", "akcmd", "avalcoll", "ayctx", "afcms", " avcu", "akconn", "avecca", "afloc", "avcontext", "avca", "avfw", "aycontext", "afcmd", "akctx", "afcca", "avcm", "ajsci", "avcms", "avecu", "akcu", "afsci", "avecm", "amcu", "avectx", "avsci", "ajpkg", "avecf", "afctx", "afpkg", "ajcci", "aycu", "akcontext", "akloc", "avcf", "avalconn", "afconn", "ajctrl", "afcm", "avcoll", "avalcontext", "amconn", "ajca", "aycms", "avalctx", "evctx", "evcu", "evcontext", "affw", " avloc", "avefw", "ajconn", "avpkg", "avctrl", "afcu", "afctrl", "evcms", "avcca", "afcf", "avectrl", "avalcm", "avesci", "avalpkg", "ajcontext", "ajcca", "avcmd", "avconn", "avalcci", "avalcf", " avcontext", "avercontext", " avcf", "aveca", "afcci", "avcci", "averconn", "avalcu", "afcoll", "avloc", "avalcms", "avecontext", "afca", "averctx", "avcu", "avecoll", "avalfw", "amcontext"], "s": ["sg", "js", "service", "acs", "cs", "ctx", "ss", "ops", "a", "sa", "rs", "spec", "sb", "data", "r", "n", "ans", "aws", "is", "ssh", "sk", "i", "g", "bis", "m", "ses", "ls", "args", "sync", "storage", "gs", "ns", "c", "p", "services", "w", "e", "f", "sys", "sq", "u", "as", "o", "v", "b", "S", "os", "t", "fs", "si", "ssl"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162, "substitutes": {"q_ptr": ["q_pt", "p_pointer", " q_pointer", " q_Ptr", "q_Ptr", "q_pointer", " q_ctr", "q_ctr", "p_req", "q_req", "p_pt", "p_ptr"], "num": ["unit", "mn", "np", "null", "no", "version", "dim", "nn", "norm", "d", "n", "uni", "nc", "bin", "un", "con", "nu", "ne", "initial", "Num", "m", "nr", "number", "index", "om", "inc", "zero", "nb", "len", "du", "size", "rem", "mon", "u", "mom", "node", "sum", "um", "nm", "prefix", "su", "NUM", "nom", "gen", "count", "mu", "net", "one", "nam", "done"], "den": ["zen", "flow", "mn", "hen", "dn", "da", "lan", "fen", "dan", "dim", "nn", "norm", "flo", "di", "fl", "der", "bin", "con", "de", "ne", "side", "des", "Den", "none", "ven", "DEN", "iden", "dev", "fin", "design", "len", "dm", "ide", "rem", "mon", "core", "mask", "min", "range", "en", "su", "gen", "wall", "nd", "pri", "day"]}}
{"project": "FFmpeg", "commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "target": 1, "func": "void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)\n\n{\n\n    int i;\n\n\n\n    s->dts    =\n\n    s->pts    = AV_NOPTS_VALUE;\n\n    s->pos    = -1;\n\n    s->offset = 0;\n\n    for (i = 0; i < AV_PARSER_PTS_NB; i++) {\n\n        if (s->cur_offset + off >= s->cur_frame_offset[i] &&\n\n            (s->frame_offset < s->cur_frame_offset[i] ||\n\n             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame\n\n            // check disabled since MPEG-TS does not send complete PES packets\n\n            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){\n\n\n\n            s->dts    = s->cur_frame_dts[i];\n\n            s->pts    = s->cur_frame_pts[i];\n\n            s->pos    = s->cur_frame_pos[i];\n\n            s->offset = s->next_frame_offset - s->cur_frame_offset[i];\n\n            if (remove)\n\n                s->cur_frame_offset[i] = INT64_MAX;\n\n            if (s->cur_offset + off < s->cur_frame_end[i])\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 3176, "substitutes": {"s": ["sg", "js", "this", "qs", "n", "g", "ls", "ses", "sf", "vs", "self", "us", "f", "sys", "u", "fs", "parser", "spec", "ts", "sb", "y", "xs", "sets", "p", "e", "lines", "conf", "as", "less", "su", "site", "t", "S", "ks", "os", "session", "its", "hs", "sym", "obs", "ssl", "cs", "ss", "a", "rs", "r", "is", "ins", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "service", "http", "ops", "d", "ms", "comments", "sync", "l", "services", "w", "sq", "stats", "b", "states"], "off": ["oa", "flow", "ff", "no", "after", "offset", "before", "def", "ui", "out", "alt", "Off", "open", "un", "op", "now", "next", "pos", "eff", "info", "offs", "offer", "post", "non", "raw", "ip", "down", "block", "shift", "set", "length", "art", "of", "up", "o", "over", "OFF", "error", "old", "online", "low", "load", "on", "diff"], "i": ["cli", "key", "n", "field", "j", "g", "ti", "index", "x", "ind", "hi", "f", "u", "ori", "uri", "fi", "ami", "name", "split", "isin", "zi", "ji", "pi", "ui", "id", "mi", "iu", "k", "api", "y", "ri", "ie", "p", "e", "lc", "v", "ix", "qi", "t", "io", "init", "mu", "li", "ni", "ii", "chi", "I", "di", "uli", "m", "info", "slice", "ini", "h", "c", "phi", "o", "si", "ski", "yi", "gi", "ei", "oi", "d", "it", "multi", "source", "ai", "ip", "l", "bi", "b", "ci", "xi"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 3179, "substitutes": {"i": ["yi", "my", "li", "gi", "abi", "ni", "ii", "zi", "ji", "jit", "ui", "pi", "oi", "d", "I", "n", "di", "id", "mi", "it", "iu", "k", "j", "bis", "y", "m", "eni", "inner", "ri", "info", "ti", "slice", "multi", "index", "ini", "ai", "ie", "x", "ind", "ip", "phi", "adi", "bi", "p", "e", "l", "f", "c", "u", "idi", "ori", "o", "v", "iv", "qi", "b", "t", "ix", "uri", "ci", "io", "init", "part", "fi", "si", "in", "xi"], "encoded": [" enccoded", "engoder", " encoder", "enoding", "enrypted", "entoding", "Encoding", "unicoder", "decoding", "integoding", "decoded", "integcoded", " encicated", "entcoded", "decicated", "Encrypted", "engoding", "Encoder", "deccoded", "encoder", "unicoded", "enoder", "Encoded", "engoded", " encoding", "Enccoded", "encicated", "encoding", "entoder", "unicoding", "encrypted", "enccoded", "uniccoded", "integoded", "decoder", "entoded", "engcoded", "enoded", "integicated", "decrypted"], "test_cases": ["testpleclasses", "testAllcontent", "testedParfiles", "testLfiles", "test_content", "testEreports", "test64rooms", "testingrooms", "test64cases", "test_test", "tested_reports", "test_tips", "Test_cases", "testaldetails", "testalclasses", "testaltips", "testalcases", "testEtests", "testedPartests", "test_tests", "serveralclasses", "serveraldetails", "testAlltest", "testalsteps", "test_files", "test_details", "Test_rooms", "testingcases", "testaltimes", "test_steps", "testLdetails", "testingtests", "tested_tests", "server_details", "testalfiles", " test_tips", "testplefiles", "testEcases", "test64reports", "testPartests", "testParfiles", "Test_tests", "testAllcases", "serveralcases", "testLcases", "testplecases", "testdefcases", "server_classes", "test_rooms", " test_times", "testingreports", " testdefcontent", "testEtips", "testParreports", "testEtimes", "test_reports", " testdeftests", "testEsteps", "test_classes", "tested_files", "server_cases", "testpledetails", "testEfiles", "testdefcontent", " test_test", "testAlltests", "test_times", " test_content", " test_tests", "testLclasses", "testdeftest", " test_steps", "test64tests", "testParcases", "tested_cases", " testdeftest", "server_files", "serveralfiles", "testedParreports", "testdeftests", " testdefcases", "Test_reports", "testedParcases"], "obj": ["ob", "js", "act", "ass", "active", "txt", "n", "alt", "Obj", "j", "code", "eff", "err", "opt", "x", "pr", "css", "object", "jp", "ex", "ot", "name", "ext", "id", "arr", "tmp", "api", "off", "po", "Object", "z", "p", "sn", "lib", "iv", "os", "val", "init", "pt", "so", "att", "ctx", "data", "out", "cat", "op", "py", "cb", "json", "ns", "result", "nb", "ref", "attr", "el", "o", "inst", "img", "adj", "elt", "bo", "dict", "pos", "coll", "style", "block", "kl", "art", "b", "part", "obb"], "str": ["dr", "js", "name", "cs", "ext", "Str", "rs", "elt", "wr", "data", "r", "n", "sl", "dict", "arr", "enc", "Obj", "j", "bl", "pass", "hr", "stri", "code", "fr", "err", "style", "cr", "tr", "z", "st", "ind", "block", "css", "pr", "br", "text", "object", "sr", "o", "pt", "STR"]}}
{"project": "qemu", "commit_id": "0857a06ef784783887e756d4b7b5f874512c506c", "target": 1, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n", "idx": 3180, "substitutes": {"dc": ["fc", "cms", "cm", "fd", "DC", "cam", "ctx", "da", "ga", "cc", "mc", "context", "d", "ct", "ck", "nc", "bc", "director", "ea", "tc", "cdn", "cb", "df", "dt", "ds", "cod", "ec", "abc", "c", "xc", "jc", "doc", "design", "dm", "draw", "oc", "ca", "cd", "exec", "disc", "vc", "cit", "cca", "pc", "cf", "dat", "db", "rc"], "sr": ["dr", "rg", "route", "src", "rs", "rw", "sb", "rn", "etr", "ruby", "rr", "r", "yr", "ru", "sl", "cur", "lr", "kr", "rf", "adr", "spr", "rb", "hr", "SR", "nr", "ser", "fr", "ir", "cr", "tr", "usr", "pr", "sw", "rl", "attr", "ctr", "sc", "RR", "rss", "serv", "rx", "sur", "rt", "vr", "radius", "rc", "ssl"], "access": ["allow", "rib", "row", "url", "escape", "open", "code", "password", "index", "asc", "address", "alpha", "connect", "sc", "object", "en", "play", "qa", "path", "accept", "acc", "est", "rage", "name", "read", "rw", "expr", "image", "id", "auth", "ACC", "pass", "max", "ac", "request", "rc", "hop", "serv", "edge", "att", "ss", "esc", "ee", " acc", "add", "use", "ha", "Access", "ident", "attr", "cache", "public", "accessible", "req", "error", "close", "ride", "uc", "cast", "match", "see", "src", "ga", "array", "method", "priv", "ord", "num", "param", "source", " Access", "abc", "exec", "view", "ach", "inc", "ace"], "access_text": [" access_source", "access_length", "access_txt", "access___text", "access_string", "accessPletter", "accessPbytes", "access2string", " access_name", "access_bytes", "accessPtext", "accessPtxt", " access_length", "accessible_txt", "access_letter", "access_name", "accessingname", " access_txt", "access___bytes", "accessible_bytes", "Access_name", "accessible_letter", "access_TEXT", "access___letter", "accessible_text", "Access_string", "access___txt", "access2text", "access2name", " access_TEXT", "Access_text", "accessingsource", "accessingtext", "access_source"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n", "idx": 3182, "substitutes": {"ctx": ["cm", "cms", "cli", "gpu", "cam", "cs", "kb", "cor", "hw", "ga", "conn", "context", "anc", "cc", "txt", "cpp", "Context", "gc", "gru", "loc", "ck", "nc", "bc", "tc", "grad", "client", "cus", "cas", "component", "mac", "fp", "tx", "sync", "cgi", "cb", "config", "crit", "ce", "pkg", "cu", "c", "cv", "xc", "css", "lc", "cpu", "cn", "sc", "ca", "ctrl", "exec", "jp", "cmd", "vc", "cca", "pc", "connection", "qa", "cp", "cmp", "cf", "conv", "ci", "cfg", "sci", "rc"], "t0": ["t4", "ta000", "tty1", "f1", "ta50", " t8", "T50", "p4", "f4", "ta0", "T2", "p1", "tty000", "f2", "T0", "tty50", "rt8", "p0", "t50", "t8", "tty0", "f0", "t000", "T4", "T8", " t4", "ta1", "p2", "T000", "rt0", "rt1", "T1"], "t1": ["t4", " tOne", "TOne", "tone", "t81", " t81", "p4", "tt1", "teone", "the3", "T2", "p1", "t9", "test3", "T0", "tt81", "t01", " t9", "ttOne", "te9", "Tone", "p0", "tOne", "T3", "T4", "t3", "te2", "T01", " t4", "test01", "tt2", "p2", "te1", " tone", "the1", "T9", "the01", "T81", "test1", "T1"], "t2": ["vtwo", "at200", "Ttwo", "t4", " ttwo", " tTwo", "x1", "it200", "t32", "at4", "it32", "tt8", " t8", "p200", "p4", "T2", "p1", "ttwo", "T0", " t52", "t52", "p0", "p32", "dt52", "x2", "xtwo", "t8", "ttTwo", "ptwo", "t200", "dt8", "v2", "dtTwo", "tt52", "v1", "tTwo", "at2", "it2", "tt2", "p2", "v0", "dt2", "T6", " t6", "x6", "at32", "t6", "T1", "it4"], "nr": ["nos", "oa", "nz", "np", "eno", "ner", "nob", "ni", "area", "nn", "rn", "wr", "inv", "r", "rr", "n", "ru", "uni", "nc", "rec", "lr", "nu", "nl", "num", "rf", "next", "adr", "rb", "eni", "ra", "ri", "mid", "nt", "number", "nb", "len", "min", "range", "ori", "sn", "rel", "mr", "nw", "rss", "NR", "rx", "rar", "nor", "init", "net", "arin"]}}
{"project": "FFmpeg", "commit_id": "c61b28e0421f0f9502dfb21495a03cda191def15", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,\n\n                        float **out_samples)\n\n{\n\n    ATRAC3Context *q = avctx->priv_data;\n\n    int ret, i;\n\n    uint8_t *ptr1;\n\n\n\n    if (q->coding_mode == JOINT_STEREO) {\n\n        /* channel coupling mode */\n\n        /* decode Sound Unit 1 */\n\n        init_get_bits(&q->gb, databuf, avctx->block_align * 8);\n\n\n\n        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,\n\n                                        JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Framedata of the su2 in the joint-stereo mode is encoded in\n\n         * reverse byte order so we need to swap it first. */\n\n        if (databuf == q->decoded_bytes_buffer) {\n\n            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;\n\n            ptr1          = q->decoded_bytes_buffer;\n\n            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)\n\n                FFSWAP(uint8_t, *ptr1, *ptr2);\n\n        } else {\n\n            const uint8_t *ptr2 = databuf + avctx->block_align - 1;\n\n            for (i = 0; i < avctx->block_align; i++)\n\n                q->decoded_bytes_buffer[i] = *ptr2--;\n\n        }\n\n\n\n        /* Skip the sync codes (0xF8). */\n\n        ptr1 = q->decoded_bytes_buffer;\n\n        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {\n\n            if (i >= avctx->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n\n\n        /* set the bitstream reader at the start of the second Sound Unit*/\n\n        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);\n\n\n\n        /* Fill the Weighting coeffs delay buffer */\n\n        memmove(q->weighting_delay, &q->weighting_delay[2],\n\n                4 * sizeof(*q->weighting_delay));\n\n        q->weighting_delay[4] = get_bits1(&q->gb);\n\n        q->weighting_delay[5] = get_bits(&q->gb, 3);\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];\n\n            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];\n\n            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);\n\n        }\n\n\n\n        /* Decode Sound Unit 2. */\n\n        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],\n\n                                        out_samples[1], 1, JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Reconstruct the channel coefficients. */\n\n        reverse_matrixing(out_samples[0], out_samples[1],\n\n                          q->matrix_coeff_index_prev,\n\n                          q->matrix_coeff_index_now);\n\n\n\n        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);\n\n    } else {\n\n        /* single channels */\n\n        /* Decode the channel sound units. */\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            /* Set the bitstream reader at the start of a channel sound unit. */\n\n            init_get_bits(&q->gb,\n\n                          databuf + i * avctx->block_align / avctx->channels,\n\n                          avctx->block_align * 8 / avctx->channels);\n\n\n\n            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],\n\n                                            out_samples[i], i, q->coding_mode);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    /* Apply the iQMF synthesis filter. */\n\n    for (i = 0; i < avctx->channels; i++) {\n\n        float *p1 = out_samples[i];\n\n        float *p2 = p1 + 256;\n\n        float *p3 = p2 + 256;\n\n        float *p4 = p3 + 256;\n\n        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);\n\n        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);\n\n        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3183, "substitutes": {"avctx": ["afconfig", "evctx", "AVctx", "ablc", "evcontext", "navutils", "afsq", "avectx", "AVlc", "evsq", "avconn", "aveconnection", "afcmp", "afctx", "afcontext", "abcu", "afcc", "navctx", " avcc", "abcmp", " avcmp", "afconnection", "aircontext", " avcontext", "apconfig", "apcontext", "AVconfig", "navconnection", "abcc", "avlc", "afconn", "navcmp", "abctx", "avctrl", "avcc", "apctx", "navcontext", "avutils", "afcu", "afctrl", "aflc", "abconfig", "avconfig", "airctrl", "avcontext", " avsq", "airconn", "abcontext", "abconn", "apcmp", "avecontext", "evconn", "abutils", "afutils", "navconn", "avcmp", "avcu", "avconnection", "avsq", "AVcmp", "AVcontext", "abctrl", "avecmp", "airctx", "avecu", " avconn"], "databuf": ["datacuf", "databoull", "datABull", " datobef", "databbuf", "datacluf", "datobale", "dataloguf", " databbuf", " datobuffer", "datacuffer", " datobull", "datbuf", "datambuf", "datobbuf", "datbuffer", " databuff", "datacuff", "datABuf", "datambuffer", "databsuff", "datambale", "databsull", "databuffer", "databouf", "datacull", "databale", " databale", "databef", " databull", "databuff", " datobuff", "datacluff", "datABuff", "datalogbuf", "databull", "dataclef", "datalogull", "datbuff", " datobuf", "databouffer", "datacluffer", "databsuf", "datbef", "datambull", " datobale", "datobuff", "databoale", " databuffer", " datobbuf", "datobuf", " databef", "datABbuf", "datobull", "databsuffer", "dataloguff", "datobuffer", "datobef"], "out_samples": ["out_bources", "out_pamp", "out_sounds", "out_tounds", "out_bamples", "out_pamples", "out_Samps", "out_tamps", "out_tamples", "out_samp", "out_Sounds", "out_tamp", "out_Sources", "out_Samples", "out_pources", "out_sources", "out_bamp", "out_samps", "out_Samp", "out_pamps", "out_bamps"], "q": ["Q", "ue", "check", "ctx", "http", "cal", "quad", "qs", "queue", "cl", "get", "d", "requ", "ck", "n", "que", "pg", "co", "sh", "cur", "query", "k", "client", "comp", "iq", "g", "update", "m", "sync", "request", "dq", "config", "ch", "post", "ce", "h", "pkg", "c", "p", "x", "w", "e", "input", "f", "self", "cache", "sq", "u", "core", "conf", "question", "cmd", "comment", "o", "v", "qa", "qi", "req", "t", "cf", "aq", "view", "qt", "quant", "qq", "quest", "qu"], "ret": ["fun", "no", "att", "mt", "def", "bit", "res", " Ret", "data", "success", "r", "out", "alt", "cur", "rets", "num", "pre", " RET", "pass", "rep", "rb", "code", "nt", "back", "reply", "status", "Ret", "rc", "bf", "feat", "opt", "result", "x", "fin", "len", "f", "ref", "flag", "art", "obj", "en", "RET", "t", "error", "wa", "al", "lit", "re", "val", "rt", "iter", "run", "det"], "i": ["cli", "my", "yi", "li", "gi", "key", "ni", "ii", "zi", "ji", "chi", "ui", "pi", "d", "I", "di", "n", "x", "id", "mi", "uli", "iu", "it", "j", "y", "m", "ri", "inner", "eni", "info", "ti", "slice", "ini", "index", "multi", "z", "ai", "ie", "ip", "ind", "hi", "p", "phi", "bi", "l", "e", "c", "f", "u", "ki", "v", "o", "qi", "ix", "b", "uri", "ci", "io", "mu", "fi", "si", "xi"], "ptr1": ["pointer0", "ptr15", "pse61", "pointer9", "pointer8", "Ptr9", "ptrname", "ptr3", "dr0", " ptrname", "ref8", "sthOne", "ptr9", "ptr0", "pt4", "tr2", "pt1", " ptr9", "pointername", "pointer15", "refone", "pointer2", "Ptr3", "pointer4", "pointern", "pse1", "Ptr2", "pt0", "pointer61", " ptrOne", "tr1", "Ptrn", "dr2", "pointerone", "ptrone", "ptr4", "ref2", "pse2", " ptr15", "pt3", "dr4", "ptrOne", "tr4", "trone", "sth01", "pointer1", "pt2", "pointer01", "Ptr1", "ptname", " ptr3", "Ptr01", "ref1", "tr8", "dr3", "sth2", "pointer3", "ptr61", " ptr61", "tr0", "sthn", "ptr01", "pse15", "pointerOne", "ptr8", "ptrn", "sth1", "dr1", "sth61"], "ptr2": ["pointer0", "dest2", "ptrb", "ptrtwo", "ptr3", "pointerTwo", "ptrii", "ptr0", "pt4", "pt1", "ptD", "ptrD", "padTwo", "pointer2", "pointer4", "ptrTwo", "ptb", "pt0", "pad4", "pad1", "pointerb", "dr2", " ptrii", "ptr4", " ptrtwo", "desttwo", "drTwo", "pt3", "dr4", "destii", "pointer1", "pt2", "pointerii", "pointertwo", "dest1", " ptr3", "pad2", "dr3", "pointer3", "pointerD", " ptrD", " ptrb", "dr1", " ptr0"]}}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 3184, "substitutes": {"env": ["eu", "np", "server", "ctx", "build", "extra", "conn", "context", "esi", "txt", "her", "equ", "environment", "global", "que", "vert", "operator", "dict", "ea", "client", "eng", "ne", "here", "enc", "ef", "output", "inet", "eni", "erv", "event", "er", "err", "style", "inc", "config", "ec", "opt", "exc", "vel", "eve", "fg", "et", "dev", "e", "self", "esp", "vs", "app", "conf", "core", "hess", "exec", "viron", "el", "obj", "chal", "en", "eur", "v", "ev", "site", "manager", "engine", "init", "edge", "emb", "console", "net", "export", "energy", "db"], "val": ["unit", "ret", "call", "base", "arg", "test", "vol", "li", "ul", "split", "vals", "data", "ee", "Val", "fl", "sl", "grad", "pre", "update", "cash", "slice", "sel", "p", "len", "eval", "cache", "exec", "value", "min", "el", "sum", "v", "seq", "valid", "VAL", "iter", "all"], "shift": ["cost", "sup", "offset", "extra", "adjust", "array", "align", "wrap", "sh", "seed", "max", "i", "frac", "push", "slice", "hift", "index", "Shift", "pad", "work", "stack", "pop", "force", "size", "length", "repeat", "ffff", "ctr", "sq", "set", "power", "center", "range", "reverse", "square", "pull", "scale", "fold", "sleep", "seq", "sort", "shr", "mix", "transform", "count", "strip", "shape", "diff", "pack"], "temp": ["base", "test", "null", "fact", "total", "buffer", "cert", "offset", "extra", "key", "flat", "txt", "data", "current", "form", "ee", "wrap", "orig", "empty", "cur", "tc", "emp", "fit", "tmp", "seed", "pre", "output", "partial", "eff", "source", "atom", "tr", "fake", "opt", "Temp", "c", "length", "tem", "Result", "cache", "ctr", "cel", "cf", "mix", "valid", "count", "iter", "shape", "timeout", "diff", "input"], "result": ["match", "ret", "test", "extra", "array", "grade", "effect", "success", "data", "new", "complete", "current", "r", "ver", "results", "use", "cur", "parent", "tmp", "pair", "rh", "i", "instance", "output", "cash", "master", "err", "work", "order", "Result", "length", "zero", "cache", "message", "value", "sum", "cup", "final", "sign", "mix", "valid", "count", "diff", "response", "res"]}}
{"project": "qemu", "commit_id": "95ce326e5b47b4b841849f8a2ac7b96d6e204dfb", "target": 1, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 3205, "substitutes": {"term_hist_entry": ["term_hist_id", "term_histalnr", "term_hist_nr", "term_history_number", "term_orig_id", "term_histsid", "term_history_size", "term_hist_index", "term_hist_no", "term_histsentry", "term_history_nr", "term_histsindex", "term_orig_no", "term_hist_size", "term_hist64start", "term_histalentry", "term_histidnumber", "term_history_entry", "term_hist_number", "term_history_Entry", "term_orig_index", "term_histidsize", "term_hist64entry", "term_histalcount", "term_history_index", "term_histsno", "term_orig_entry", "term_hist_ry", "term_history_count", "term_histidindex", "term_hist_count", "term_hist_Entry", "term_histidentry", "term_hist_start", "term_hist64enter", "term_history_ry", "term_history_enter", "term_history_start", "term_hist_enter"]}}
{"project": "FFmpeg", "commit_id": "3d2c3ef4b46d96023d6f0d358e4d7d65568da67c", "target": 0, "func": "static int decode_cabac_mb_cbp_luma( H264Context *h) {\n\n    int cbp_b, cbp_a, ctx, cbp = 0;\n\n\n\n    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;\n\n    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;\n\n\n\n    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);\n\n    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;\n\n    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;\n\n    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;\n\n    return cbp;\n\n}\n", "idx": 3211, "substitutes": {"h": ["H", "http", "bh", "ul", "ih", "hw", "hash", "dh", "host", "ht", "r", "header", "d", "ang", "sh", "ph", "hist", "th", "ha", "uh", "g", " H", "m", "hr", "ah", "ch", "hm", "l", "c", "p", "hi", "work", "w", "e", "self", "f", "hd", "eh", "hh", "history", "u", "hp", "hl", "adh", "b", "t", "he", "hs", "oh", "rh", "gh"], "cbp_b": ["cbpu_b", "cbp_r", "cbp_B", "cbp_l", "cbp25b", "cbpu25as", "cbpu25a", "cbp_bb", "cbp25a", "cbp_as", "cbpo_bb", "cbpo_bs", "cbnp_bi", "cbp__r", "cbp25k", "cbpu_l", "cbpo_k", "cbp25bb", "cbpc_r", "cbp25l", "cbp_bs", "cbp25as", "cbpc_bb", "cbpu_a", "cbnp_b", "cbp25bs", "cbpu25b", "cbnp_B", "cbpu_as", "cbpc_a", "cbpu25l", "cbp_k", "cbp__bb", "cbp__b", "cbpc_b", "cbpo_b", "cbnp_r", "cbp__a", "cbp_bi"], "cbp_a": ["cbapi5ga", "cbp5a", "cbapi5an", "cbp128ga", "cbp__as", "cblp_ae", "cbapi_ga", "cblp6ae", "cbp64as", "cbp128aj", "cbc_ga", "cbpi_a", "cblp_a", "cblp_area", "cbp_ga", "cbp_area", "cbp6area", "cbp__area", "cbp__ae", "cbp_as", "cbp_n", "cbp_aj", "cblp6area", "cbp5an", "cbc_ab", "cbpi_b", "cbp128a", "cblp_as", "cbp_A", "cbp6ae", "cbp64ae", "cbp_ab", "cbapi5aj", "cbp64a", "cbp6as", "cbp_ae", "cbp_an", "cbpi_p", "cbapi_aj", "cblp6a", "cbpi_n", "cbapi_an", "cbp64area", "cbp5aj", "cbc_A", "cbc_a", "cbp128an", "cblp6as", "cbapi5a", "cbp__a", "cbp5ga", "cbp6a", "cbapi_a", "cbp_p"], "ctx": ["fc", "cm", "np", "cli", "src", "cs", "csv", "kb", "hw", "conn", "context", "cc", "anc", "txt", "fw", "cpp", "ht", "loc", "ct", "ck", "co", "nc", "bc", "cy", "tc", "fn", "buf", "cas", "comp", "component", "fp", "tx", "sync", "cb", "cue", "kw", "dt", "ch", "config", "feat", "progress", "x", "cu", "c", "pkg", "cv", "xc", "css", "lc", "unc", "cn", "sc", "ca", "ctrl", "sq", "jp", "wcs", "cmd", "vc", "kk", "cca", "qa", "cp", "cmp", "cf", "conv", "ci", "val", "cfg", "sci", "rc", "wx"]}}
{"project": "FFmpeg", "commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "target": 1, "func": "void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    QSVFrame *cur;\n\n    AVPacket pkt;\n\n    int ret = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n\n\n    if (q->reinit_pending) {\n\n        close_decoder(q);\n\n    } else if (q->engine_ready) {\n\n        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode get param error %d\\n\", ret);\n\n        }\n\n\n\n        ret = MFXVideoDECODE_Reset(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode reset error %d\\n\", ret);\n\n        }\n\n\n\n        /* Free all frames*/\n\n        cur = q->work_frames;\n\n        while (cur) {\n\n            q->work_frames = cur->next;\n\n            av_frame_free(&cur->frame);\n\n            av_freep(&cur);\n\n            cur = q->work_frames;\n\n        }\n\n    }\n\n\n\n    /* Reset output surfaces */\n\n    av_fifo_reset(q->async_fifo);\n\n\n\n    /* Reset input packets fifo */\n\n    while (av_fifo_size(q->pkt_fifo)) {\n\n        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);\n\n        av_packet_unref(&pkt);\n\n    }\n\n\n\n    /* Reset input bitstream fifo */\n\n    av_fifo_reset(q->input_fifo);\n\n}\n", "idx": 3227, "substitutes": {"avctx": ["AVctx", "afsci", "AVlc", "avsci", "afcmp", "afctx", "afcontext", "navctx", "capctx", "AVmac", " avcmp", "AVcmp", "avcf", " avcontext", "avmac", "afmac", "AVsci", " avmac", "navsci", "capcmp", "navcontext", "capcf", "navlc", "aflc", "afcf", "capcontext", "avcontext", "avcmp", "AVcf", "avlc", "AVcontext"], "q": ["Q", "call", "ue", "check", "ctx", "cal", "qs", "context", "queue", "cl", "get", "d", "requ", "ck", "co", "pg", "id", "query", "k", "client", "iq", "i", "g", "update", "batch", "m", "info", "sync", "event", "request", "z", "dq", "ch", "config", "ce", "h", "l", "c", "p", "work", "w", "self", "e", "f", "input", "conf", "sq", "u", "core", "question", "cmd", "comment", "quant", "v", "lib", "qa", "qi", "req", "t", "module", "quick", "view", "qt", "que", "qq", "quest", "qu"], "cur": ["ur", "dr", "aur", "row", "rest", "current", "ct", "ver", "open", "cher", "client", "enc", "ok", "err", "tr", "circ", "feed", "pr", "child", "oc", "prev", "var", "car", "quad", "spec", "der", "pair", "focus", "par", "ser", "Cur", "or", "per", "sr", "keep", "fer", "build", "gr", "fac", "r", "cat", "tur", "bur", "cr", "pub", "sel", "usr", "c", "attr", "ctr", "req", "sur", "uc", "qu", "sch", "inter", "cor", "conn", "ry", "con", "query", "param", "gg", "ah", "fr", "rev", "ch", "cer", "ach", "arch", "sth", "rc"], "pkt": ["mqt", " pkid", "pek", " pKT", "opacket", "opkt", " pqt", " packet", "bpkt", "opct", " pct", "Punk", "Pqt", "Pk", "pekid", "peqt", "pet", " pet", " pk", "mKT", "bpkg", "bpKT", "mkt", " punk", "pekt", "bpqt", "Pkid", "mkg", "opunk", "pkg", "punk", "pKT", "Pet", "pk", "pqt", "peet", "peacket", "pkid", " pkg", "pct", "packet", "Pkt", "Pct", "Packet"]}}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 3228, "substitutes": {"a": ["oa", "base", "A", "da", "ba", "sa", "aaa", "array", "area", "ad", "n", "aa", "ma", "aj", "y", "i", "ac", "m", "x", "pa", "c", "p", "alpha", "asa", "e", "f", "app", "ar", "ca", "u", "la", "as", "s", "va", "an", "am", "ae"], "b": ["ob", "base", "ba", "sb", "ab", "eb", "ib", "B", "d", "n", "ad", "r", "mb", "y", "i", "j", "g", "rb", "x", "l", "c", "p", "w", "e", "f", "bd", "u", "v", "bb", "s", "bp", "fb", "bs", "db"], "x0": ["ux0", "ax6", "xx3", "ex0", "X00", " x3", "f1", "X2", "x25", " x100", "X0", "ix0", "ix00", "X100", " x50", "X3", "ex00", "Xee", " xee", " x25", "ax0", "X50", "ax029", "f00", "ix000", "xx1", "lex100", "xee", "ux029", "x2", "f50", "ux1", "x029", "X25", "f0", " x2", "ix1", "ux6", "ixee", " x029", "lex1", "ex1", "x3", " x00", "ix25", "ex000", " x000", "lex0", "x50", " x6", "ax1", "lex2", "x6", "x000", "x100", "ax00", "xx2", "x00", "ex2", "xx0", "X1"], "x1": ["xx3", " x3", " xn", "X2", "X9", "xx9", "X01", "x9", " xb", "X0", "x01", "xOne", "X3", "XOne", "vb", "xxOne", "X11", "Xn", "xx1", "x11", "xn", "x2", " x2", " x01", " x11", "v2", "xb", "x3", " xOne", "vn", "v1", "Xb", " x9", "xx11", "xx2", "xx01", "xx0", "X1"]}}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_reset(DeviceState *dev)\n\n{\n\n    XHCIState *xhci = XHCI(dev);\n\n    int i;\n\n\n\n    trace_usb_xhci_reset();\n\n    if (!(xhci->usbsts & USBSTS_HCH)) {\n\n        DPRINTF(\"xhci: reset while running!\\n\");\n\n    }\n\n\n\n    xhci->usbcmd = 0;\n\n    xhci->usbsts = USBSTS_HCH;\n\n    xhci->dnctrl = 0;\n\n    xhci->crcr_low = 0;\n\n    xhci->crcr_high = 0;\n\n    xhci->dcbaap_low = 0;\n\n    xhci->dcbaap_high = 0;\n\n    xhci->config = 0;\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i+1);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        xhci_port_update(xhci->ports + i, 0);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numintrs; i++) {\n\n        xhci->intr[i].iman = 0;\n\n        xhci->intr[i].imod = 0;\n\n        xhci->intr[i].erstsz = 0;\n\n        xhci->intr[i].erstba_low = 0;\n\n        xhci->intr[i].erstba_high = 0;\n\n        xhci->intr[i].erdp_low = 0;\n\n        xhci->intr[i].erdp_high = 0;\n\n        xhci->intr[i].msix_used = 0;\n\n\n\n        xhci->intr[i].er_ep_idx = 0;\n\n        xhci->intr[i].er_pcs = 1;\n\n        xhci->intr[i].er_full = 0;\n\n        xhci->intr[i].ev_buffer_put = 0;\n\n        xhci->intr[i].ev_buffer_get = 0;\n\n    }\n\n\n\n    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    xhci_mfwrap_update(xhci);\n\n}\n", "idx": 3236, "substitutes": {"dev": ["serial", "test", "cam", "def", "spec", "hw", "conn", "device", "mod", "data", "tty", "development", "ad", "ver", "devices", "d", "der", "priv", "de", "sk", "grad", "dom", "DEV", "Dev", "proc", "nt", "temp", "ch", "home", "w", "conf", "wd", "rad", "ev", "req", "var", "pro", "debug", "mode"], "xhci": ["xehco", "exhcin", "xpvi", "xhlvi", "xahbc", "myhmii", "xenki", "xehsi", "xhhcu", "ixhcli", "xrhii", "txhcci", "oxhcca", "fxhcp", "xbhli", "xxehco", "oxhari", " xehcci", "xhlco", "xhtdi", "xhwli", "xxehci", "xhlli", "xehlc", "sexhostco", "wehlcin", "myahii", "xhcm", "txehci", "xahcu", "oxhdlc", "xhdcod", " xphli", "xhhii", " xehcin", "phphlsci", "xihcu", "xxbc", "xhdr", " xhco", "eventhcli", "xhce", "xhmcin", "xhtcin", "xrhcu", "plusehdi", "fxehii", "xxehcci", "exphce", "myhii", "xhlcm", "xhtki", " xhcus", "xahki", " xehcu", "eventhdci", "Xhci", "wehcin", "xhmii", " xhcci", "xrhci", "xhlcin", "phphcin", "exhcci", "Xhdi", "xhwcin", "xhsbc", " xhbc", "xuhcus", "xhco", "xhda", "xhcus", "fxhcod", "rxehcu", "phihii", "xwki", "xhcy", "exphco", "xxehcit", "xihii", "plushcci", "xwii", "phphlci", "xpcci", "xwcycle", "xphki", "phihcu", "xhcin", "xhostvi", "xphcy", "xwcli", "fxhci", "eventhci", "xhsii", "xenci", "xhsi", "xhcit", "txehcu", "xhlcci", "xhwai", "tyhci", "xahcli", "xbhlc", "xhlbc", "xhlcu", "hhcin", "xihci", "xhlci", "xhtci", "xrhcin", "xhscod", "sexhci", " xhii", "ixhdcod", " xwcycle", "xehcm", "xshcus", "xhlcycle", "xhhcod", "phphlcin", "ixhdli", "xphlc", "fxehcod", "myhdi", "oxhci", "exhco", "xehcli", "xhtii", "xehdi", "xuhci", "exphci", "xpci", "xrhcycle", "sexhsci", "fxehco", "xhhsci", "xxhcci", "xhdcin", "xhwci", "ixhci", "myahci", "eventhco", "xphcit", "xehce", " xphci", "xhldr", "eventhodi", "xphii", "Xehki", "xhwct", "xhdda", "xbhcit", "xhmcit", "xxhcit", "xxcci", "rxhdr", "oxhlii", "xwco", "xhlcit", " xwci", "xhostco", "xvii", "xhlari", "rxhcu", "xahdr", "myahcci", "xencin", "xhmdi", "tyhai", "xxii", "xhui", "txehvi", "xhwcus", "xpii", "xehcu", "xphcp", "xphli", "xshcci", "xbhci", "xhdbc", "plusehsi", "xhostcci", "xhostci", "xehdr", "xhii", "txhcu", "xahli", "xphce", "txehki", "xhmci", "hhcus", "xshcin", "xwcin", "oxhlvi", " xwbc", "ixhdci", "txhki", "xxhco", "xhlc", "eventhdco", "xrhli", "xhtcu", "exphcli", "exphcin", "txhci", "xehodi", "exhci", "phhcu", "xahci", "phphsci", "xehci", "sexhostsci", "tyshai", "xbhco", "xihui", "phhii", "fxhii", "exhcli", "Xehii", "xhldi", " xhcycle", "xhcca", "xihlc", "xhct", "xhdcu", "xphsci", "oxhlc", "plusehci", "oxhlci", "xehda", "xhdodi", "xehli", " xhlc", "xphci", "xrhsci", "txhli", "wehlcit", "xhdlc", "xhtcit", "rxhci", "rxehcci", " xphco", "xphsi", "plushci", "txehcm", "xrhce", "txhvi", "wehcit", "myhci", "xhlsci", "xhlui", "xuhcin", " xwii", "myhcci", "xphco", "plusehcci", " xhcy", " xphcy", "xhari", "xshli", "xphcli", "xhdi", "xwcm", "Xhii", "xehsci", " xwki", "myhmcit", "oxhdari", " xhcu", "xshai", "xrhki", "xwbc", "hhci", "xbhcy", "xhai", "xhcli", "oxhcci", "xhcp", "xhtcod", "tyshli", "oxhvi", "xrhcci", "xhtli", " xhcit", "xhdii", "xhllc", "xvci", "fxehcp", "tyshcci", " xphcit", "fxehci", " xphlc", "xehcin", "sexhostci", "txhda", "exhce", "oxhlcci", "xwcu", "phihci", " xhki", "exphcci", "xhlii", "xrhco", "myhcit", "xhli", "rxehci", "wehsci", "huhct", "xxhci", "xhodi", "xhmsci", "oxhii", "myahbc", " xehci", " xwcus", "huhcin", "xhlcy", "xhhci", "xahii", "plushdi", "phphci", "xehcod", "myhmdi", "xhbc", "sexhce", "xehki", "xhostce", "xhostsci", "xrhui", " xhcin", "tyshci", "ixhcod", "oxhdcca", "wehlsci", "phphcu", "sexhostce", "xhssci", "xehvi", "xahcci", "xhhcin", "xhdco", "phhci", "xphdi", "xbhcin", "txehli", "xwodi", "wehlci", "xhdcca", "xehcci", "xrhlc", "rxehdr", "xhscus", "xhcod", "fxehsci", "phihui", "xvcit", "xhsci", "xuhct", "xhostii", "xhlcca", "txhcm", "xhki", "xhtcli", "hhct", "xhdari", "eventhdodi", "xhdli", "phphlcu", "fxhco", "xhlki", "xenii", "xwlc", "huhcus", " xwlc", "tyhli", "xrhcli", "xhcu", "xhslc", "ixhdcli", "ixhli", "xhwcci", "plushsi", "rxhcci", "xhvi", "xvdi", "phhui", "xhcycle", "xwci", "xhlce", "xihari", "fxhsci", "xhlsi", "xhtco", "oxhdci", "xahco", "huhci", " xwcin", "xwcus", "xphda", "xhdci", "Xhki", "xshci", "xihcca", "myhmci", "sexhco", "xbhsci", "xphcin", "wehci", "Xehdi", "xhtcci", " xhli", "xehcit", "xhlcus", "xhlcp", "xphcci", "xehii", "tyhcci", "xehcp", "xphcu", "xhcci", "xxci", "eventhdcli", "xwvi", "xhdcci", "xhdcli", "txehcci", "xrhai", "xshct", "Xehci", "myhbc", "txehda"], "i": ["cli", "mini", "n", "j", "g", "ti", "index", "x", "f", "u", "gui", "jp", "uri", "fi", "abi", "interface", "esi", "isin", "zi", "ji", "ui", "pi", "image", "id", "mi", "iu", "k", "api", "y", "ri", "z", "ie", "p", "e", "lc", "isi", "v", "iv", "qi", "ix", "t", "io", "init", "mu", "li", "a", "ni", "ii", "I", "di", "is", "udi", "uli", "inner", "info", "slice", "ini", "c", "phi", "o", "inst", "module", "si", "series", "yi", "gi", "oi", "d", "it", "iii", "eni", "fr", "multi", "ai", "ip", "l", "adi", "bi", "b", "ci", "xi"]}}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3237, "substitutes": {"pvr": ["tpwr", " Prt", "lpver", " Pvt", "prt", " Pvr", "lprt", "tpver", "fvt", "fcv", "tpvr", "fwr", " prt", " pwr", "ppwr", " Pver", "ppcv", "tpcv", "lpcv", "pver", " pcv", "ppvt", "pcv", "lpvr", " pvt", "lpvt", "pwr", "lpwr", "fvr", " pver", "pvt", "ppvr"], "def": ["del", "defined", "fun", "name", "cl", "desc", "data", "new", "d", "aux", "id", "parent", "comp", "pass", "ef", "info", "Def", "df", "push", " Def", "cond", "feed", "pkg", "block", "dev", "eval", "ref", "f", "DEF", "conf", "bd", "definition", "exec", "el", "obj", "req", "var", "valid", "gen", "lit", "val", "init", "part", "det", "diff", "dist", "__"], "i": ["yi", "name", "li", "gi", "abi", "a", "ni", "ii", "ui", "pi", "oi", "r", "d", "n", "I", "di", "mi", "it", "k", "iu", "j", "y", "ri", "m", "info", "ini", "index", "multi", "ai", "ie", "x", "ind", "l", "p", "ip", "c", "bi", "e", "f", "u", "ori", "o", "v", "ix", "b", "qi", "t", "uri", "ci", "io", "init", "part", "fi", "si", "xi"], "ret": ["match", "group", "arg", "fun", "no", "att", "mt", "bit", "flat", "success", "xt", "ct", "alt", "cat", "cur", "id", "rets", "num", "code", "nt", "ft", "rev", "back", "reply", "feat", "Ret", "status", "pat", "result", "x", "len", "f", "ref", "flag", "gt", "en", "RET", "lit", "re", "reg", "val", "count", "rt", "part", "let", "iter", "det", "res"]}}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n", "idx": 3256, "substitutes": {"T0": ["tFalse", "P0", " TFalse", "P1", "VT0", "T50", "Targ", "T2", "PT1", " T00", "t00", "t2", " T50", "t0", " T1", "t50", "PT2", "VTFalse", "VT1", "Parg", "t1", " Targ", "targ", "T00", "TFalse", "PT0", " T2", "PT50", "P00", "T1"], "vaddr": ["Vadd", "vwork", "verhost", "vhost", "svaddress", "faddress", " vadd", "verptr", "vaddress", "Vaddr", "paddress", "vadd", " vhost", "svaddr", "fwork", " vint", " vaddress", "svint", "vint", "paddr", "Vptr", "fhost", "fptr", "padd", " vwork", "Vaddress", "fint", "veraddress", "vptr", "svwork", "veraddr", "svhost", "faddr", "Vhost"]}}
{"project": "qemu", "commit_id": "99fd437dee468609de8218f0eb3b16621fb6a9c9", "target": 0, "func": "static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n", "idx": 3266, "substitutes": {"slot": ["serial", "route", "rot", "arg", "vol", "service", "no", "offset", "bit", "pin", "ruby", "sid", "image", "binary", "loc", "tag", "cat", "scroll", "shell", "sl", "oid", "job", "type", "boot", "lot", "seed", "hole", "Slot", "pos", "spot", "entry", "pixel", "nt", "slice", "sector", "index", "pointer", "address", "role", "secret", "len", "size", "zo", "token", "shadow", "connection", "serv", "hour", "session", "socket", "addr", "val", "zone", "timeout", "option"], "ssdt_ptr": ["ssdc_ptr", "ssdt_pointers", "sscit_pointer", "ssdt_handle", "ssdt_dr", "sscot_ptr", "ssdt_pointer", "sscit_dr", "sscot_pointer", "sscit_ptr", "sscot_addr", "ssdt_inter", "ssdt_struct", "ssrt_dr", "ssrt_ptr", "ssdt___pointer", "sscot_struct", "sscot_pointers", "ssdt_data", "ssdt_addr", "ssrt_inter", "sscit_addr", "ssrt_pointer", "ssdt_ext", "ssdt___ext", "ssdc_pointer", "ssdc_addr", "ssdc_handle", "sscot_dr", "ssdt___ptr", "ssrt_data", "ssrt_ext"], "eject": [" erupt", "ejected", "eecess", "eeJECT", "EJECT", "Ejected", "Ejection", "eejected", " ejection", "ejection", "erupt", "Eject", "bejection", "ecess", "Ecess", "beJECT", "eeject", "beject", "eJECT", " ejected", "becess", "Erupt", "eerupt", "eejection"]}}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n", "idx": 3274, "substitutes": {"main_stride": ["main_striides", "main_shrice", "main_striided", "main_trade", "main_shride", "main_strides", "main_strride", "main_drided", "main_stine", "main_bride", "main_shrides", "main_brride", "main_trride", "main_dride", "main_drides", "main_strided", "main_stides", "main_strice", "main_strade", "main_brice", "main_tride", "main_brine", "main_striide", "main_strine", "main_stade", "main_shrided", "main_stided", "main_striine", "main_brided", "main_drice", "main_trided", "main_brides", "main_brade", "main_stide"], "ref": ["ob", "base", "rib", "def", "ab", "url", "alt", "lf", "parent", "remote", "rf", "pre", "ef", "pos", "info", "source", "REF", "config", "bf", "fe", "Ref", "aff", "arc", "f", "red", "conf", "cache", "reference", "min", "range", "rel", "b", "review", "re", "lab", "part", "diff"], "ref_stride": ["ref_strided", "ref_striide", "ref_arride", "ref_strider", "ref_collided", "ref_divided", "ref_Strided", "ref_brider", "ref_strade", "ref_striided", "ref_strine", "ref_bride", "ref_divider", "ref_brided", "ref_collade", "ref_collite", "ref_Strides", "ref_brite", "ref_arrided", "ref_divide", "ref_arrider", "ref_Strider", "ref_arrade", "ref_arrine", "ref_brade", "ref_strides", "ref_Stride", "ref_brides", "ref_divides", "ref_arrite", "ref_striine", "ref_striider", "ref_brine", "ref_strite", "ref_collide"], "height": ["flow", "radius", "resolution", "level", "crop", "row", "build", "time", "above", "dim", "image", "window", "d", "zh", "weight", "distance", "id", "ty", "gap", "bottom", "lat", "dy", "direction", "hold", "style", "h", "alpha", "thin", "top", "hi", "w", "rank", "size", "length", "deep", "rows", "inches", "density", "center", "padding", "pull", "depth", "arrow", "img", "shape", "Height"], "temp": ["flow", "buffer", "local", "term", "flat", "vt", "txt", "form", "current", "cut", "wrap", "tc", "emp", "parent", "tmp", "i", "max", "tw", "m", "source", "fake", "Temp", "c", "p", "w", "size", "tem", "cache", "v", "prefix", "cel", "t", "clean", "wa", "pt", "white"], "x": ["xa", "cross", "yx", "any", "time", "a", "r", "d", "n", "ct", "px", "id", "im", "k", "xy", "i", "j", "max", "pos", "ady", "dx", "m", "tx", "lex", "X", "index", "xp", "xx", "h", "l", "p", "c", "xc", "w", "e", "f", "ax", "u", "ww", "el", "fx", "v", "b", "ix", "t", "rx", "wa", "sex", "xxx", "wy", "one", "ex", "my", "xi", "wx"], "y": ["yi", "a", "ye", "yl", "yo", "zy", "d", "n", "yr", "type", "id", "cy", "xy", "ny", "ya", "ty", "j", "i", "g", "py", "m", "dy", "yn", "yy", "ey", "ch", "h", "l", "p", "c", "w", "e", "vy", "f", "size", "u", "yt", "o", "v", "s", "b", "ay", "t", "Y", "oy", "wy", "ym", "sy"], "sum0": ["um1", "mem0", "um4", "um0", "Sum4", "Sum2", "dim2", "Sum1", " sum3", "dim0", "Sum3", "um3", "sum2", "dim1", "Sum0", " sum2", " sum4", "mem4", "sum3", "sum4", "mem1", "mem2"], "sum1": ["um1", "um0", " sum9", "Sum2", "sum8", "ram1", "Sum9", "umOne", "Sum1", "gramOne", "ram8", "ram2", "gram2", "um2", "gram1", " sumOne", "Sum8", "SumOne", "sum2", "Sum0", "gram9", "ram0", " sum2", "sum9", "sumOne", " sum8"], "z": ["Z", "yi", "q", "ez", "zip", "ii", "zi", "zy", "r", "zh", "d", "n", "fl", "id", "xy", "zz", "ya", "i", "j", "g", " w", "m", "dy", "code", "xx", "oz", "l", "c", "p", "h", "w", "e", "vy", "f", "zo", "u", "v", "s", "yz", "ix", "ze", "t", "tz", "Y", "iz", "wa", "zone"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n", "idx": 3278, "substitutes": {"obj": ["ob", "oa", "orb", "js", "src", "act", "ctx", "bh", "elt", "bo", "sb", "txt", "oi", "class", "n", "objects", "parent", "boot", "api", "Obj", "j", "instance", "po", "rb", "code", "eff", "Object", "coll", "cb", "args", "cod", "self", "nb", "cn", "object", "art", "el", "node", "java", "o", "lib", "inst", "os", "od", "val", "xxx", "init", "emb"]}}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279, "substitutes": {"bs": ["ob", "base", "js", "cs", "ctx", "ss", "ops", "rs", "ts", "sa", "qs", "sb", "bps", "lb", "BS", "ib", "aws", "bc", "ins", "pb", "cas", "bl", "bis", "rb", "plugins", "ls", "ses", "bits", "cb", "ds", "als", "bas", "ps", "gs", "ns", "css", "vs", "bi", "us", "bos", "es", "gb", "as", "bu", "bb", "iss", "fb", "b", "blocks", "os", "ks", "fs", "db", "obs", "ssl"], "options": ["base", "files", "null", "opens", "ops", "ts", "data", "ips", "eps", "global", "ions", "scope", "includes", "false", "op", "params", "none", "ls", "args", "details", "info", "Options", "file", "settings", "outs", "style", "offs", "config", "ps", "errors", "opt", "x", "p", "values", "e", "bos", "lines", "es", "steps", "other", "object", "public", "obj", "o", "lib", "optional", "os", "times", "io", "fs", "option"], "flags": ["files", "offset", "Flags", "ops", "bit", "lag", "vals", "ips", " flag", "comments", "bits", " Flags", "args", "file", "settings", "config", "errors", "flag", "features", "ints", "mask", "stats", "bytes", "fs", " bits", "FLAG", "parts"], "errp": ["errorf", "errorpre", " errtp", " errpi", "rrf", "ierf", "errtp", "errorb", "errorpc", "rorr", "errpc", "rorp", "cerpa", "errn", " errr", "cerp", "cern", "errortp", "ierpi", "errb", " errn", "rorpi", "arrp", "cerpi", "arrn", "errr", " errpa", " errpc", "errorp", "errpi", " errb", "rrb", "arrpi", "rorpa", "arrpa", " errpre", "rortp", "ierpa", " errf", "errorr", "rorf", "rrpre", "errf", "errpa", "errpre", "rorpc", "ierp", "rrp"], "s": ["base", "js", "cs", "ss", "ops", "ts", "sa", "sb", "n", "is", "sl", "ses", "ls", "sv", "ds", "utils", "ps", "gs", "ns", "c", "p", "state", "vs", "self", "f", "sys", "v", "b", "su", "S", "os", "session", "t", "states", "si", "https", "ssl"], "opts": ["catters", "OPts", "obcs", "opouts", "alments", "opt", "copcs", "opcs", "olts", "operouts", " opcs", "optps", "opls", "opty", "copters", "opte", "experps", " opttes", "optters", "experouts", "alps", "OPty", "olty", "olt", "opta", " opns", "opments", "opps", "opert", "optes", "olpt", "otta", "catcs", " opt", "experta", "operta", "optcs", " optg", "optments", " opments", "opttes", " optes", "alts", "obts", "catps", " optts", " opps", "optns", "optg", "otts", "operty", "optt", "otouts", "oppt", " opte", "catts", "OPpt", "OPt", "otps", "copts", " opls", " opg", "operpt", " optns", "obls", "experts", "optls", "opg", "optts", "opns", "obt", "alte", "operts", "opters", "copps", "optte", "operps"], "local_err": [" local_spec", "local___nor", "local64orr", " local_nor", "localpyerror", "global_init", "localedbug", "localederror", "local8init", "local_worker", "localpynor", "local64error", "local__err", "local67er", "local67erer", "local___error", "local__cry", "local67cry", "localpybug", "remote_er", " local_orr", "local_orr", " local_war", "remote_err", "localpystatus", " local_bug", " local_cb", "local_status", "global_err", "custom_error", "local_error", "local_cry", "localedwar", "remote_worker", "local_cb", " local_erer", "local__erer", "custom_gr", "local_er", "remote_error", "local_bug", "custom_er", "local_init", "local_war", "local__error", "localpyer", "local_spec", " local_cry", "local8status", "global_status", "local_msg", "local67worker", "local64cb", "localpyerr", "local_erer", "local___err", "custom_err", "local___bug", "local64err", " local_error", "localpyinit", " local_er", " local_msg", "local_gr", "local_nor", "local8err", "local67err", "localederr", "local67error", "local8er", "global_er"], "ret": ["match", "rot", "base", "arg", "fun", "mt", "ext", "def", "bit", "flat", " Ret", "success", "data", "get", "alt", "cat", "id", "wait", "rets", "fit", "pet", "pass", " RET", "rep", "lt", "ft", "nt", "rev", "str", "back", "ber", "Ret", "feat", "bf", "pat", "sat", "opt", "result", "reply", "bot", "rc", "et", "ut", "len", "flag", "ref", "gt", "art", "RET", "final", "t", "req", "valid", "lit", "reg", "let", "val", "rt", "re", "part", "run", "det", "res", "bad"]}}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3288, "substitutes": {"s": ["sg", "server", "js", "service", "this", "cs", "groups", "http", "ss", "stat", "spec", "rs", "a", "context", "sb", "current", "is", "scope", "client", "g", "m", "ses", "sf", "sync", "settings", "sv", "request", "sets", "ds", "gs", "native", "ns", "c", "p", "services", "setup", "e", "private", "f", "secondary", "self", "sys", "sq", "u", "set", "south", "b", "site", "S", "t", "session", "support", "se", "fs", "complex", "si", "input", "sym", "ssl"], "addrlo": ["addresslo", "addrLo", "addresslittle", " addrHi", "amdlo", "addressla", "drlo", "Addresshi", "drLo", "Addresslo", "addrHi", "drlittle", "amdlittle", "AddressLo", "addressHi", "addressLo", "amdla", " addrLo", "drla", "AddressHi", "addrlittle", "addresshi", "addrla", "amdLo"], "addrhi": ["Addresshi", "Addresspi", "addrHi", " addrha", "addrpi", "addhi", " addrHi", "AddressHi", "addHi", "addpi", "Addressha", "addrha", "addha", " addrpi"], "s_bits": ["ps_pins", "ps_flags", "s2parts", "ps_parts", "s_flags", "s2pins", "s_parts", "s_pins", "ps_bits", "s2bits", "s2flags"], "tlb_offset": ["tlb2off", "tlb_attribute", "tlb_Offset", "tbl2size", "tlb_location", "tlb__size", "tlb__Offset", "tlp_location", "tbl2offset", "tlb_len", "tl_base", "tla_Offset", "tlp_sum", "tlb2offset", "tlp_offset", "tlc_len", "tlb_base", "tla_no", "tlb_off", "tla_offset", "tla_off", "tlb_line", "tlp_position", "tbl_size", "tlb_addr", "tlb2addr", "tlb2size", "tlb__off", "tbl_off", "tlb__offset", "tlb_no", "tlb__addr", "tlc_offset", "tlp_attribute", "tlp_Offset", "tbl_addr", "tbl2addr", "tbl_offset", "tlb8offset", "tlp_size", "tlb__len", "tlp_line", "tlc_Offset", "tlb8base", "tlb_sum", "tl_off", "tl_size", "tlb8off", "tlb_size", "tl_offset", "tlb8size", "tlc_size", "tbl2off", "tlb_position"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static void qdm2_decode_super_block(QDM2Context *q)\n\n{\n\n    GetBitContext gb;\n\n    QDM2SubPacket header, *packet;\n\n    int i, packet_bytes, sub_packet_size, sub_packets_D;\n\n    unsigned int next_index = 0;\n\n\n\n    memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));\n\n    memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));\n\n    memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));\n\n\n\n    q->sub_packets_B = 0;\n\n    sub_packets_D    = 0;\n\n\n\n    average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]\n\n\n\n    init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);\n\n    qdm2_decode_sub_packet_header(&gb, &header);\n\n\n\n    if (header.type < 2 || header.type >= 8) {\n\n        q->has_errors = 1;\n\n        av_log(NULL, AV_LOG_ERROR, \"bad superblock type\\n\");\n\n        return;\n\n    }\n\n\n\n    q->superblocktype_2_3 = (header.type == 2 || header.type == 3);\n\n    packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);\n\n\n\n    init_get_bits(&gb, header.data, header.size * 8);\n\n\n\n    if (header.type == 2 || header.type == 4 || header.type == 5) {\n\n        int csum = 257 * get_bits(&gb, 8);\n\n        csum += 2 * get_bits(&gb, 8);\n\n\n\n        csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum);\n\n\n\n        if (csum != 0) {\n\n            q->has_errors = 1;\n\n            av_log(NULL, AV_LOG_ERROR, \"bad packet checksum\\n\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    q->sub_packet_list_B[0].packet = NULL;\n\n    q->sub_packet_list_D[0].packet = NULL;\n\n\n\n    for (i = 0; i < 6; i++)\n\n        if (--q->fft_level_exp[i] < 0)\n\n            q->fft_level_exp[i] = 0;\n\n\n\n    for (i = 0; packet_bytes > 0; i++) {\n\n        int j;\n\n\n\n        if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) {\n\n            SAMPLES_NEEDED_2(\"too many packet bytes\");\n\n            return;\n\n        }\n\n\n\n        q->sub_packet_list_A[i].next = NULL;\n\n\n\n        if (i > 0) {\n\n            q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i];\n\n\n\n            /* seek to next block */\n\n            init_get_bits(&gb, header.data, header.size * 8);\n\n            skip_bits(&gb, next_index * 8);\n\n\n\n            if (next_index >= header.size)\n\n                break;\n\n        }\n\n\n\n        /* decode subpacket */\n\n        packet = &q->sub_packets[i];\n\n        qdm2_decode_sub_packet_header(&gb, packet);\n\n        next_index      = packet->size + get_bits_count(&gb) / 8;\n\n        sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2;\n\n\n\n        if (packet->type == 0)\n\n            break;\n\n\n\n        if (sub_packet_size > packet_bytes) {\n\n            if (packet->type != 10 && packet->type != 11 && packet->type != 12)\n\n                break;\n\n            packet->size += packet_bytes - sub_packet_size;\n\n        }\n\n\n\n        packet_bytes -= sub_packet_size;\n\n\n\n        /* add subpacket to 'all subpackets' list */\n\n        q->sub_packet_list_A[i].packet = packet;\n\n\n\n        /* add subpacket to related list */\n\n        if (packet->type == 8) {\n\n            SAMPLES_NEEDED_2(\"packet type 8\");\n\n            return;\n\n        } else if (packet->type >= 9 && packet->type <= 12) {\n\n            /* packets for MPEG Audio like Synthesis Filter */\n\n            QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);\n\n        } else if (packet->type == 13) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = get_bits(&gb, 6);\n\n        } else if (packet->type == 14) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);\n\n        } else if (packet->type == 15) {\n\n            SAMPLES_NEEDED_2(\"packet type 15\")\n\n            return;\n\n        } else if (packet->type >= 16 && packet->type < 48 &&\n\n                   !fft_subpackets[packet->type - 16]) {\n\n            /* packets for FFT */\n\n            QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);\n\n        }\n\n    } // Packet bytes loop\n\n\n\n    if (q->sub_packet_list_D[0].packet != NULL) {\n\n        process_synthesis_subpackets(q, q->sub_packet_list_D);\n\n        q->do_synth_filter = 1;\n\n    } else if (q->do_synth_filter) {\n\n        process_subpacket_10(q, NULL);\n\n        process_subpacket_11(q, NULL);\n\n        process_subpacket_12(q, NULL);\n\n    }\n\n}\n", "idx": 3290, "substitutes": {"q": ["Q", "ue", "this", "check", "http", "quad", "qs", "context", "queue", "cl", "form", "get", "r", "requ", "ck", "co", "pg", "sh", "cur", "query", "k", "client", "iq", "update", "component", "info", "sync", "er", "event", "request", "z", "dq", "config", "ch", "ce", "c", "p", "self", "input", "f", "e", "cache", "sq", "u", "core", "conf", "question", "comment", "o", "v", "quant", "qa", "qi", "req", "t", "view", "qt", "que", "qq", "quest", "qu", "rc"], "gb": [" algorithm", "sg", "cli", " gcc", " db", " factory", "gio", "vt", "gc", "gnu", " backend", " cc", "g", "storage", " encoding", " rg", " rc", "G", "gram", "sb", "ui", "gru", "bc", " kb", "gz", "GB", "gn", " rgb", " dc", "gam", "gu", "hd", "lib", "usb", "gp", "gh", "rg", "yg", " ble", "ctx", " bin", "tg", "byte", "bm", "hub", " storage", "gow", "bin", "gin", "cb", "cgi", "gs", "nb", "bb", "bridge", "gal", " gp", "vm", "gpu", "gi", "kb", "bn", "ga", "mb", "gy", " eg", "gg", "rb", "gm", "git", "bg", "ki", "pc", "ci", "cfg", "gd", "db"], "header": ["dr", "key", "queue", "n", "head", "client", "hr", "code", "forward", "event", "master", "index", "vv", "du", "f", "prev", "message", "cover", "option", "parser", "context", "type", "que", "bc", "buff", "parent", "component", "fp", "general", "request", "core", "handler", "border", "plugin", "init", "gp", "player", "response", "gh", "input", "layer", "version", "outer", "offset", "channel", "counter", "byte", "bm", "data", "prot", "rr", "ck", "record", "gin", "kernel", "m", "inner", "body", "info", "cgi", "document", "back", "content", "writer", "h", "size", "cache", "stream", "definition", "center", "bridge", "error", "module", "rule", "headers", "match", "server", "buffer", "bn", "hw", "Header", "class", "author", "callback", "query", "output", "gm", "item", "source", "config", "block", "reader", "carry", "line", "inc", "metadata"], "packet": ["packsET", "duET", "compet", "compoder", "packets", "duets", "packsets", "duacket", "quantacket", "ppacket", "compET", "duet", "ppet", "packacket", "packsacket", "ppoder", "packoder", "packset", "quantets", "ppets", "quantoder", "compets", "compacket", "packET", "quantet"], "i": ["layer", "base", "buffer", "abi", "offset", "ii", "ui", "pi", "binary", "d", "I", "di", "uni", "n", "id", "bin", "code", "info", "ti", "slice", "ip", "c", "p", "len", "ci", "io", "in"], "packet_bytes": ["packet__data", "packet___bytes", "packets_bits", "packets_gets", "packet__bits", "packets_data", "packet__bytes", "packet___size", "packet_bits", "packet_data", "packets_size", "packets_bytes", "packet_size", "packet___gets", "packet___bits", "packet_gets", "packet__size"], "sub_packet_size": ["sub_packet_len", "sub_packets_size", "sub_packet___position", "sub_packet_bytes", "sub_packet___size", "sub_packet___bytes", "sub_packet_position", "sub_packets_len", "sub_packet___len", "sub_packets_position", "sub_packets_bytes"], "sub_packets_D": ["sub_packets_d", "sub_packets_unit", "sub_packet_B", "sub_packet_bytes", "sub_packetsAllbytes", "sub_packetsPd", "sub_packets_DS", "sub_packetsPD", "sub_packet_DS", "sub_packetsAllD", "sub_packets_B", "sub_packetsAllunit", "sub_packetsAlld", "sub_packetsPbytes", "sub_packet_D", "sub_packet_d", "sub_packet_unit", "sub_packetsPunit", "sub_packets_bytes"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n", "idx": 3293, "substitutes": {"c": ["cm", "a", "context", "r", "d", "cy", "ac", "m", "C", "dc", "h", "l", "p", "cu", "w", "e", "lc", "f", "u", "vc", "o", "s", "cit", "pc", "b", "icc", "t", "ci"], "dst": ["Dsrc", "dbst", "odsts", "odsrc", "Dsts", "Dft", "dbsts", "odst", "dsts", "ddest", "dST", "Ddest", " dsrc", "dbdest", " dsts", "dsrc", "dbST", "odft", " dST", " ddest", "Dst", " dft", "DST", "dft"], "dstW": ["Dstw", "dstH", "ddrW", "dstw", "DstC", "DSTC", "DSTW", "dstsWh", "drcH", "dstreamH", " dstsWidth", "ddrC", "dstWh", "drcWh", "dstreamWidth", "dscW", " dstWidth", " dstsW", "drcW", "dstreamWh", " dstWh", " dstsWh", "dSTWeight", "dstsH", "dscC", "dSTC", "dstC", "drcWidth", "DSTw", "dscWeight", "dstreamW", "dstsW", " dstH", "dSTw", "ddrw", "dstWeight", "dstWidth", "dstsWidth", "DSTWeight", "DstWeight", "ddrWeight", " dstsH", "dscw", "DstW", "dSTW"], "src": ["fc", "sub", "target", "sb", "data", "url", "loc", "sl", "fn", "gz", "rb", "super", "secure", "dest", "sync", "cb", "source", "slice", "config", "asc", "control", "ref", "sq", "sc", "sort", "inst", "conv", "transform", "support", "img", "start", "acc", "inf", "dist", "rc", "ssl"], "filter": ["layer", "match", "route", "sub", "test", "buffer", "offset", "channel", "target", "url", "header", "use", "fn", "search", "fil", "file", "forward", "source", "replace", "slice", "config", "control", "user", "feature", "block", "alpha", "force", "f", "per", "ref", "flag", "cache", "mask", "il", "range", "v", "sort", "Filter", "support", "limit", "map", "rc"], "filterPos": [" filterLen", "FilterPoint", "FilterSize", "filSize", "filPosition", "filPoint", "filterLen", "filterPosition", "FilterPosition", "FilterPos", "filterPoint", "filLen", "FilterType", " filterPoint", "filPos", " filterPosition", "filterType", "FilterLen", " filterType", "filType"], "filterSize": ["limitCount", "sortSize", "limitPos", " filterLen", "shapeLen", "sortLen", "filScale", "filZone", "filSize", " filterScale", "sortScale", "filterLen", "filterCount", " filterName", "sortPos", "sortName", "limitSize", "filterZone", " filterCount", "limitZone", "filLen", " filterZone", "filName", "shapePos", "filPos", "filterScale", "filterName", "filCount", "shapeSize"], "i": ["cli", "ami", "li", "gi", "key", "a", "ni", "ii", "zi", "ji", "ei", "esi", "pi", "ui", "oi", "d", "I", "n", "di", "is", "id", "mi", "it", "k", "iu", "y", "ri", "eni", "info", "ti", "slice", "ini", "index", "z", "ai", "ie", "x", "l", "p", "ip", "bi", "h", "e", "f", "u", "ori", "o", "v", "ki", "qi", "ix", "b", "uri", "ci", "val", "io", "init", "sci", "fi", "start", "si", "xi"], "j": ["js", "li", "adj", "jl", "key", "ii", "ji", "jit", "ui", "r", "jj", "n", "J", "oj", "it", "k", "aj", "ij", "uj", "y", "g", "m", "jo", "fr", "z", "ch", "ie", "x", "l", "p", "pr", "jc", "bi", "e", "f", "u", "jp", "el", "obj", "o", "v", "b", "qi", "req", "t", "val", "pt", "ja"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n", "idx": 3320, "substitutes": {}}
{"project": "qemu", "commit_id": "25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0", "target": 1, "func": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n", "idx": 3322, "substitutes": {"sockfd": ["sockedfd", "sockedFD", "socksFD", "sockfx", "sboothandle", "sockshandle", "csockedctx", "sbootdb", "csockedfd", "siphandle", "csockFD", "sbootctx", "socksctx", " sockhandle", "sockctx", "sipfd", "sbootfx", "socksfd", " socksfd", "sockFD", "csockfd", " socksdb", "socksfx", "socksdb", "sockedfx", "csockedFD", " sockFD", "sbootFD", " sockdb", " sockshandle", "sockedctx", " socksFD", "csockfx", "sbootfd", "sockhandle", "sockdb", "csockctx", "csockedfx", "sipdb", "sipFD"], "iov": ["ilo", "oci", "\u00ef", "gio", "uno", "oren", "liv", "ovi", "oi", "obo", "uci", "uni", "udi", "iris", "iev", "iol", "ium", "irc", "lov", "iii", "eni", "inet", "oji", "iro", "ov", "ir", "odi", "oco", "ovo", "nih", "anni", "iop", "uo", "imet", "voice", "iv", "rolet", "icho", "io", "imi", "irin"], "ret": ["base", "fun", "total", "no", "att", "ext", "def", "bit", "finished", "done", "success", "data", "desc", "complete", "url", "r", "get", "ver", "alt", "cat", " done", "found", "rets", "num", "rf", "pass", "fail", "pos", "rb", "code", "orted", "info", "nt", "cb", "err", "rev", "dt", "reply", "back", "Ret", "rc", "progress", "bf", "result", "fin", "order", "try", "len", "f", "ref", "resp", "obj", "die", "sr", "failed", "RET", "seq", "error", "hide", "re", "reg", "rt", "val", "count", "iter", "res", "db", "mem"]}}
{"project": "qemu", "commit_id": "e24e49e6194626e4ec9f1aecce6d6a6847320bce", "target": 1, "func": "static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n", "idx": 3327, "substitutes": {"bs": ["cs", "ss", "ba", "rs", "qs", "ts", "sb", "bps", "lb", "BS", "bc", "banks", "pb", "fps", "bis", "rb", "ls", "ses", "ras", "ds", "bas", "ps", "gs", "ns", "css", "vs", "bos", "gb", "lbs", "bb", "ubs", "iss", "blocks", "fb", "b", "ks", "las", "bes", "fs"], "backing_file": ["backacking_files", "backing__files", "backingingfile", "backacking_class", "backing_dir", "backingingclass", "backding_format", "backing_files", "backding_dir", "backding_file", "backacking_file", "backing__file", "backing__format", "backingingfiles", "backing_format", "backing_class", "backing__dir", "backding_files"], "backing_fmt": ["backing_formformat", "backingingdmb", "backing_fmb", "backing_facct", "backing_formMT", "backing_forformat", "backing_facMT", "backing_formb", "backing_cmb", "backing_dma", "backing_fct", "backingingfmt", "backingingdma", "backing_forma", "backing_dformat", "backing_cmt", "backing_cma", "backing_facmt", "backing_fformat", "backing_fma", "backing_cformat", "backing_formct", "backing_cct", "backing_fMT", "backingingdmt", "backingingdformat", "backing_facformat", "backing_formt", "backing_cMT", "backingingfformat", "backing_dmb", "backing_formmt", "backingingfma", "backingingfmb", "backing_dmt"]}}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 3330, "substitutes": {"pix": ["pik", "ipixels", "ipixel", "Pox", "pox", "Pixel", "pio", "ipix", "npixel", "cpix", " pixels", " pixel", "picon", "spik", "ipicon", "pixel", "npox", " pox", "cpicon", "fixels", "Pix", "ficon", "Pixels", "fix", "cpik", "pixels", " pio", "cpixels", "npixels", "spixels", "fixel", " pik", "spio", "cpixel", "npix", "cpio", "spix"], "stride": ["strided", "strine", "switchided", "bride", "stringive", "stringider", "stringided", "etrided", "tride", "trider", "strive", "brided", "brine", " strive", "switchide", "strider", " strider", "etride", "brider", " stripe", "tripe", "switchipe", "trive", "stripe", " strine", "switchider", "trided", "stringide", "etrider", " strided", "etrine"], "bS": ["pPs", "cP", "nbP", "mbPs", "fN", "pOs", " bPs", "bOs", "bP", "mbP", "bPs", "aSS", "nbD", "pSS", "aC", "cN", "mbD", "pS", "nbS", "fSS", "mbS", "fC", "bN", " bD", " bSS", "bC", "bSeries", " bC", "cSS", "aP", " bSeries", " bOs", "fS", " bSC", "bD", "cS", "fOs", "aS", "bSS", "pSeries", "bSC", " bN", "pSC", " bP", "pC", "aN", "nbPs"], "qp": ["Qp", "qunp", "qup", "sqnp", "Qc", "qc", " sqP", "Qe", "qub", "sqe", "Qlp", "QP", "qlp", " sqp", "sqp", " qlp", "qnp", "ipe", "ippr", "ipc", "qe", "qb", "qpr", "ipp", "sqc", " qb", "quc", " sqlp", "sqb", "qP", " qc", "Qpr", "sqpr", " qnp", " qP"], "h": ["H", "ctx", "http", "q", "bh", "ul", "ih", "hw", "conn", "context", "hash", "host", "ht", "r", "n", "sh", "ph", "uh", "ha", "api", "g", "hu", "m", "hr", "ah", "ch", "home", "hm", "l", "c", "p", "hi", "x", "w", "e", "hh", "f", "hd", "eh", "hhh", "history", "u", "hp", "v", "s", "hl", "b", "t", "he", "FH", "kh", "hs", "oh", "rh", "gh"], "tc": ["fc", "cm", "ff", "tf", "cs", "ctx", "term", "cc", "mc", "tim", "tu", "ui", "ace", "loc", "bc", "ta", "pb", "cus", "tmp", "cas", "toc", "ac", "tx", "cb", "index", "config", "ec", "asc", "dc", "tl", "cu", "c", "beta", "xc", "css", "lc", "unc", "oc", "cache", "sc", "ctrl", "contract", "ca", "gb", "cases", "tt", "kk", "TC", " TC", "pc", "ticket", "tm", "icc", "bb", "fb", "uca", "ic", "cf", "t", "ci", "uc", "acc", " rc", "rc"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,\n\n                          const char *boot_device,\n\n                          DisplayState *ds, const char *kernel_filename,\n\n                          const char *kernel_cmdline,\n\n                          const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    unsigned int i;\n\n    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;\n\n    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,\n\n        *espdma_irq, *ledma_irq;\n\n    qemu_irq *esp_reset, *le_reset;\n\n    ram_addr_t ram_offset, prom_offset, tcx_offset;\n\n    unsigned long kernel_size;\n\n    int ret;\n\n    char buf[1024];\n\n    int drive_index;\n\n    void *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        cpu_sparc_set_id(env, i);\n\n        envs[i] = env;\n\n        if (i == 0) {\n\n            qemu_register_reset(main_cpu_reset, env);\n\n        } else {\n\n            qemu_register_reset(secondary_cpu_reset, env);\n\n            env->halted = 1;\n\n        }\n\n        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n\n        env->prom_addr = hwdef->slavio_base;\n\n    }\n\n\n\n    for (i = smp_cpus; i < MAX_CPUS; i++)\n\n        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > hwdef->max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    /* load boot prom */\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->slavio_base,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX)\n\n        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                buf);\n\n        exit(1);\n\n    }\n\n\n\n    /* set up devices */\n\n    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);\n\n\n\n    for (i = 0; i < MAX_IOUNITS; i++)\n\n        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)\n\n            iounits[i] = iommu_init(hwdef->iounit_bases[i],\n\n                                    hwdef->iounit_version,\n\n                                    sbi_irq[hwdef->me_irq]);\n\n\n\n    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],\n\n                              iounits[0], &espdma_irq, &esp_reset);\n\n\n\n    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],\n\n                             iounits[0], &ledma_irq, &le_reset);\n\n\n\n    if (graphic_depth != 8 && graphic_depth != 24) {\n\n        fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth);\n\n        exit (1);\n\n    }\n\n    tcx_offset = qemu_ram_alloc(hwdef->vram_size);\n\n    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,\n\n             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n\n\n\n    if (nd_table[0].model == NULL)\n\n        nd_table[0].model = \"lance\";\n\n    if (strcmp(nd_table[0].model, \"lance\") == 0) {\n\n        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n\n    } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n        fprintf(stderr, \"qemu: Supported NICs: lance\\n\");\n\n        exit (1);\n\n    } else {\n\n        fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n        exit (1);\n\n    }\n\n\n\n    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,\n\n                        hwdef->nvram_size, 8);\n\n\n\n    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],\n\n                          sbi_cpu_irq, smp_cpus);\n\n\n\n    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],\n\n                              nographic, ESCC_CLOCK, 1);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],\n\n              serial_hds[0], ESCC_CLOCK, 1);\n\n\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    main_esp = esp_init(hwdef->esp_base, 2,\n\n                        espdma_memory_read, espdma_memory_write,\n\n                        espdma, *espdma_irq, esp_reset);\n\n\n\n    for (i = 0; i < ESP_MAX_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_SCSI, 0, i);\n\n        if (drive_index == -1)\n\n            continue;\n\n        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);\n\n    }\n\n\n\n    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,\n\n                                    RAM_size);\n\n\n\n    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,\n\n               boot_device, RAM_size, kernel_size, graphic_width,\n\n               graphic_height, graphic_depth, hwdef->nvram_machine_id,\n\n               \"Sun4d\");\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n}\n", "idx": 3333, "substitutes": {"hwdef": ["cowdef", "iwdesc", "rwdef", "cowdefinition", "htdesc", "fwdefined", "wDef", "cpuDef", "hawDef", "hwdecl", "fwdecl", "hwspec", "cpudefined", "hawspec", "hpDef", "hwdefinition", "iwDef", "hwdefined", "hpdefined", "cpudef", "wdefinition", "fwdefinition", "hwDef", "fwspec", "rwdev", "hawdef", "hawdefinition", "iwdefined", "hawdecl", "iwdefinition", "hpdecl", "hawdefined", "htdefinition", "cowDef", "hpdef", "hwdev", "cowdesc", "fwdef", "htDef", "wspec", "rwDef", "hwdesc", "iwdev", "cpudev", "rwdefined", "htdef", "wdef", "fwDef", "iwdef"], "RAM_size": ["ram_size", "RAM_addr", "RAMFSIZE", "ram_addr", "RAM_width", "RAMMwidth", "RAMMlength", "RAMFlength", "ramOsize", "RAMMsize", "RAM_length", "ram_width", "ramOSIZE", "ramOunit", "RAMFsize", "RAM_SIZE", "ram_unit", "ram_SIZE", "ram_length", "RAM_unit", "ramOaddr", "RAMFwidth", "RAMMSIZE"], "boot_device": ["boot_model", "boot_loader", "bootaldevice", "bootalloader", "bootbookmodel", "bootbookdevice", "bootbookmode", "cpu_loader", "boot_mode", "cpu_mode", "bootalmode", "cpu_device", "bootalmodel", "bootbookloader"], "ds": ["DS", "cs", "da", "ss", "dd", "rs", "dh", "eps", "di", "ils", "cdn", "des", "ls", "tx", "sync", "df", "ys", "sv", "dt", "ps", "dc", "ns", "irs", "vs", "dm", "std", "ks", "fs", "db"], "kernel_filename": ["hw_filename", "kernel1file", "hw_file", "kernel_file", "hw_files", "kernel1files", "kernel1location", "kernel_files", "kernel_location", "hw_location", "kernel1filename"], "kernel_cmdline": ["kernel_initlines", "kernel_bootlist", "kernel_initlist", "kernel_cmdlines", "kernel_bootlines", "kernel_initlink", "kernel_bootlink", "kernel_bootline", "kernel_cmdlink", "kernel_commandlines", "kernel_commandline", "kernel_initline", "kernel_cmdlist", "kernel_commandlist", "kernel_commandlink"], "initrd_filename": ["initrdamfp", "initrd_files", "initrdamfiles", "initrs_fp", "initrd_fn", "initrs_filename", "initrs_files", "initrdamfn", "initrs_fn", "initrdamfilename", "initrd_fp"], "cpu_model": ["core_models", "cpu__mode", "cpugserver", " cpu_Model", " cpu_mode", "core_model", " cpupsource", " cpu_description", "cpupmode", "cpu_control", " cpupmodel", "core_control", "cpupsource", "cpu_mode", "cpu_description", "cpugmode", " cpupmode", "cpu_size", " cpu_size", "core_server", "core_mode", " cpu_source", "cpu__engine", "cpu_server", "cpugmodel", "cpugcontrol", "core_engine", "cpu__model", "cpu_store", "cpupdescription", "cpu_models", "cpu_source", "cpu_Model", "cpupmodel", " cpu_store", "cpu__models", "cpu_engine", " cpupdescription"], "env": ["eu", "cli", "txt", "inv", "nc", "here", "enc", "inet", "args", "event", "err", "ec", "vs", "dev", "gui", "viron", "en", "engine", "dir", "energy", "zen", "ext", "extra", "context", "her", "equ", "bc", "shell", "ea", "end", "eng", "ef", "ie", "e", "conf", "org", "core", "v", "working", "ev", "iv", "site", "session", "init", "np", "exe", "ctx", "gr", "enable", "environment", "ne", "proc", "cb", "ini", "exc", "vel", "loader", "cache", "app", "el", "obj", "inst", "cf", "net", "vm", "server", "qv", "conn", "essential", "dict", "priv", "scope", "output", "eni", "erv", "ah", "dt", "config", "impl", " environment", "Environment", "exec", "console", "export", "db"], "envs": ["atenv", "atenvs", "infs", "atenvironments", "inv", " enfs", "Environments", "ENvs", "ENviron", "environments", "ENfs", "enfs", "environ", "atenviron", "Enfs", "Env", "Envs", "ENvironments", " environ", " environments", "inviron", "invs", "ENv"], "MAX_CPUS": ["MAX_CPus", "MAX_CAPUS", "MAX_CPUUS", "MAX_CPUTION", "MAX_PCINS", "MAX_cpUL", "MAX_cpINS", "MAX_GPUS", "MAX_PUUTION", "MAX_PCUSE", "MAX_PCUL", "MAX_GPUSE", "MAX_PCus", "MAX_CPUSE", "MAX_GPUL", "MAX_CPUs", "MAX_PCUs", "MAX_CPUUTION", "MAX_CPUus", "MAX_CAPUSE", "MAX_CPUUs", "MAX_PCUS", "MAX_GPINS", "MAX_CPINS", "MAX_PUUS", "MAX_CAPus", "MAX_GPUTION", "MAX_CAPUs", "MAX_CPUL", "MAX_GPus", "MAX_cpUs", "MAX_PUus", "MAX_cpUS", "MAX_GPUs", "MAX_PUUs"], "i": ["cli", "key", "mini", "n", "uni", "j", "g", "anti", "ti", "index", "x", "hi", "f", "u", "en", "s", "uri", "fi", "name", "sup", "split", "esi", "ji", "zi", "pi", "ui", "id", "mi", "iu", "y", "ri", "z", "ie", "p", "e", "v", "ix", "qi", "t", "io", "init", "mu", "li", "a", "ni", "ii", "axis", "I", "di", "is", "udi", "uli", "m", "inner", "info", "slice", "ini", "c", "phi", "si", "ski", "yi", "gi", "d", "it", "eni", "multi", "ai", "ip", "l", "adi", "bi", "min", "ki", "b", "line", "ci", "my", "xi"], "iounits": ["iumerITS", "ioulips", "I8ITS", "I8its", "iounips", "iumerips", "i8its", "I8ips", "iounites", "ioulites", "Iounips", "I8ites", "iounITS", "ioulits", "i8ITS", "i8ips", "i8ites", "IounITS", "Iounits", "iumerits", "iumerites", "Iounites", "ioulITS"], "MAX_IOUNITS": ["MAX_IUGIT", "MAX_IUGINS", "MAX_IOBITS", "MAX_IOUNits", "MAX_IOBits", "MAX_IOUNIT", "MAX_ICUGIT", "MAX_IUGits", "MAX_ICUGits", "MAX_IUGITS", "MAX_ICUNITS", "MAX_ICUNIT", "MAX_IOUNINS", "MAX_IUNIT", "MAX_ICUNits", "MAX_IOBIT", "MAX_IUNITS", "MAX_ICUGITS", "MAX_ICUGINS", "MAX_IUNINS", "MAX_ICUNINS", "MAX_IOBINS", "MAX_IUNits"], "espdma": ["ispsdla", "esppdma", "espdmm", "espgdma", "ispdla", "espdla", "esppdla", "espsdmma", "ispdmm", "ispdmma", "esppdmma", "ispsdmma", "espsdla", "ispdma", "esppdmm", "espgdmm", "ispsdmm", "espdmma", "espsdmm", "espsdma", "espgdla", "ispsdma", "espgdmma"], "ledma": ["ledmma", "ldmas", "ledms", "ldma", " ledmma", " ledmas", "iledmas", "iledms", " ledms", "ldms", "ldmma", "ledmas", "iledma", "iledmma"], "main_esp": ["main_isp", "central_isp", "central_esp", "main_sp", "central_sp", "main_cp", "central_cp"], "nvram": ["ncram", "vram", "nvgram", "ncRAM", "lvram", "ncmem", "nvRAM", "lvgram", "nvmem", "lvmem", "ncgram", "vRAM", "vgram", "vmem", "lvRAM"], "sbi": ["sgi", " sgi", "rsbi", "lsgi", "lsbi", "rsgi", "lsci", "rsci", "sci", "sfi", "rsfi", "lsfi", " sfi", " sci"], "cpu_irqs": ["cpu_igrqu", "cpu_igrq", "cpu_rues", "cpu_ireques", "cpu_iraues", "cpu_ironq", "cpu_rqs", "cpu_iraqs", "cpu_rq", "cpu_pirqu", "cpu_ironqs", "cpu_pirq", "cpu_arues", "cpu_irues", "cpu_irques", "cpu_arqs", "cpu_ireq", "cpu_iraques", "cpu_ironqu", "cpu_pirxes", "cpu_pirqs", "cpu_iraq", "cpu_arques", "cpu_pirues", "cpu_irq", "cpu_arq", "cpu_igrxes", "cpu_ironxes", "cpu_ireues", "cpu_pirques", "cpu_ireqs", "cpu_irqu", "cpu_igrqs", "cpu_irxes", "cpu_rques"], "sbi_irq": ["sbi_arq", "sbi_arcle", "sbi_drqu", "sbi_irtq", "sbi_drqs", "sbi_ircle", "sbi_drq", "sbi_irqs", "sbi_irtqs", "sbi_irtcle", "sbi_arqs", "sbi_arqu", "sbi_irtqu", "sbi_irqu", "sbi_drcle"], "sbi_cpu_irq": ["sbi_cpu_arqs", "sbi_cpu_irce", "sbi_cpu_earce", "sbi_cpu_earq", "sbi_cpu_irqs", "sbi_cpu_mirq", "sbi_cpu_mirqs", "sbi_cpu_earqs", "sbi_cpu_mirce", "sbi_cpu_arq", "sbi_cpu_arce"], "espdma_irq": ["espdma_iraq", "espdma_risq", "espdma_irqu", "espdma_risque", "espdma_irqs", "espdma_risqs", "espdma_iraque", "espdma__irque", "espdma_ierq", "espdma_irque", "espdma__irq", "espdma_ierque", "espdma_iraqu", "espdma_ierqu", "espdma__ierque", "espdma_ierqs", "espdma__irqs", "espdma_risqu", "espdma__ierqs", "espdma__irqu", "espdma_iraqs", "espdma__ierqu", "espdma__ierq"], "ledma_irq": ["ledma_riquest", "ledma_pirp", "ledma_pirQ", "ledma_arq", "ledma_arp", "ledma_irquest", "ledma_riQ", "ledma_riq", "ledma_pirquest", "ledma_arquest", "ledma_irQ", "ledma_pirq", "ledma_irp", "ledma_rip", "ledma_arQ"], "esp_reset": ["esp__free", " esp_set", "esp_set", "esp__init", " esp_init", " esp_free", "esp__set", "esp_init", "esp__reset", "esp_free"], "le_reset": ["les_init", "les_reset", "les_set", "le_init", "le_offset", "les_offset", "le_set"], "ram_offset": ["ram_size", "gram_length", "gram_offset", "gram_size", "gram_index", "ram_index", "ram_length"], "prom_offset": ["prom_addr", "rem_limit", "rem_addr", "prom_reset", "rem_reset", "rem_offset", "prom_limit"], "tcx_offset": ["tcm_offset", "tcx64off", "tcx_ref", "tcx64ref", "tcx64index", "tcx64offset", "tcm64off", "tcm_off", "tcm64ref", "tcm_index", "tcx_index", "tcm64index", "tcm64offset", "tcx_off", "tcm_ref"], "kernel_size": ["kernel_strength", "kernel_len", " kernel_length", "kernel___size", " kernel_strength", " kernel_len", "kernel___strength", "kernel___len", "kernel_length", "kernel___length"], "ret": ["buffer", "data", "alt", "mi", "rets", "num", "batch", " RET", "rep", "info", "nt", "Ret", "rc", "result", " mem", "RET", "final", "re", "reg", "val", "all", "res", "mem"], "buf": ["buffer", "bag", "board", "data", "loc", "buff", "bin", "batch", "box", "cb", "pool", "func", "raw", "pad", "block", "cv", "ptr", "cap", "alloc", "blocks", "seq", "var", "bytes", "uf", "map", " buffer", "mem"], "drive_index": [" drive_cache", " driver_index", " driver_cache", " driver_number", " driver_length", " drive_length", " drive_number"], "fw_cfg": ["fw2config", "hw_config", "hw2config", "fw2cfg", "hw2cfg", "hw2fg", "fw2fg", "fw_fg", "hw2cf", "hw_fg", "fw_cf", "fw_config", "hw_cf", "fw2cf", "hw_cfg"]}}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)\n\n{\n\n    int num_cq_events = 0, ret = 0;\n\n    struct ibv_cq *cq;\n\n    void *cq_ctx;\n\n    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;\n\n\n\n    if (ibv_req_notify_cq(rdma->cq, 0)) {\n\n        return -1;\n\n    }\n\n    /* poll cq first */\n\n    while (wr_id != wrid_requested) {\n\n        ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n        if (wr_id != wrid_requested) {\n\n            DDDPRINTF(\"A Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                print_wrid(wrid_requested),\n\n                wrid_requested, print_wrid(wr_id), wr_id);\n\n        }\n\n    }\n\n\n\n    if (wr_id == wrid_requested) {\n\n        return 0;\n\n    }\n\n\n\n    while (1) {\n\n        /*\n\n         * Coroutine doesn't start until process_incoming_migration()\n\n         * so don't yield unless we know we're running inside of a coroutine.\n\n         */\n\n        if (rdma->migration_started_on_destination) {\n\n            yield_until_fd_readable(rdma->comp_channel->fd);\n\n        }\n\n\n\n        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {\n\n            perror(\"ibv_get_cq_event\");\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        num_cq_events++;\n\n\n\n        if (ibv_req_notify_cq(cq, 0)) {\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        while (wr_id != wrid_requested) {\n\n            ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n            if (ret < 0) {\n\n                goto err_block_for_wrid;\n\n            }\n\n\n\n            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n            if (wr_id == RDMA_WRID_NONE) {\n\n                break;\n\n            }\n\n            if (wr_id != wrid_requested) {\n\n                DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                    print_wrid(wrid_requested), wrid_requested,\n\n                    print_wrid(wr_id), wr_id);\n\n            }\n\n        }\n\n\n\n        if (wr_id == wrid_requested) {\n\n            goto success_block_for_wrid;\n\n        }\n\n    }\n\n\n\nsuccess_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return 0;\n\n\n\nerr_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3348, "substitutes": {"rdma": ["robmma", "hrmma", "rrema", "rhga", "robema", "djda", "rrmas", "rdga", "rmc", "rbga", "rbema", "rtmar", "rhema", "rhmas", "rda", "hrma", "rnmeta", "lrma", "djmas", "hrmas", "drmas", "rdmeta", "rnmas", "rbla", "rdla", "rdm", "ldmc", "rema", "rhm", "robmas", "rdmma", "robma", "drma", "rdmar", "rhmc", "ldema", "rdda", "drema", "rbma", "rma", "drga", "rnmar", "lrmeta", "rtmc", "rdmas", "rmma", "drla", "rdema", "rrm", "djmma", "ldma", "rtla", "rnma", "rrma", "djma", "hrema", "ldmas", "rtmma", "rtma", "rtda", "rtmas", "rtema", "ldda", "rdmc", "lrmas", "ldm", "lrmar", "rtmeta", "drmc", "rhma", "rhla", "rmas"], "wrid_requested": ["wrid_questeded", "wrid_passing", "wrid_Requestled", "wrid_requestd", "wrid_passed", "wrid_Requestipped", "wridtrespondeded", "wrid_requed", "wrid_QUESTped", "wrid_request1", "wrid_respond1", "wridtrequesting", "wrid_respondeded", "wrid_warnached", "wrid_reqised", "wrid_warnED", "wrid_requestached", "wrid_RequestED", "wrid_requestised", "wrid_quested", "wridFrequested", "wridtresponded", "wrid_nameing", "wrid_Requestes", "wrid_returned", "wrid_passED", "wrid_times", "wridFrequesting", "wrid_reqes", "wridFpassing", "wridtrespond1", "wrid_questing", "wrid_claimed", "wrid_questED", "wrid_responded", "wrid_returnled", "wrid_Requestached", "wrid_claimED", "wridtrequested", "wrid_requestipped", "wridtresponding", "wrid_quest1", "wrid_Requestped", "wridFpassed", "wridFpassped", "wrid_reqed", "wridFrequestped", "wridtrequesteded", "wrid_nameised", "wrid_requesting", "wrid_warned", "wrid_responding", "wridFrequestED", "wrid_requestED", "wrid_Requested", "wrid_requipped", "wrid_requED", "wrid_reqED", "wrid_nameED", "wrid_requestled", "wrid_warnled", "wrid_nameed", "wridFpassED", "wrid_Requestd", "wrid_returnached", "wrid_claimipped", "wrid_timed", "wrid_uploadED", "wrid_timED", "wrid_requestped", "wrid_requesteded", "wrid_reqing", "wrid_uploaded", "wrid_QUESTED", "wrid_claimd", "wrid_uploadeded", "wrid_Requesteded", "wrid_timing", "wridtrequest1", "wrid_Requestised", "wrid_passped", "wrid_QUESTing", "wrid_QUESTed", "wrid_returnED", "wrid_Requesting", "wrid_requestes", "wrid_Request1", "wrid_requd", "wrid_uploading"], "cq": ["cfqq", "lcq", "ncqs", "cqs", "cqa", "cfqs", "ccqa", "lcqs", "CQ", "rcqa", "ccqu", "cQ", "fcqs", "cql", "lcqa", "pcqq", "pcql", "Cqa", "tcqt", "dcqt", "dcql", "fcqa", "cfqu", "rcqs", "dcq", "cfq", "lcqu", "pcqu", "Cqs", " cqu", "fcQ", "cqt", "ncqq", "fcq", "ncqu", " cqs", " cqa", "pcqs", "Cq", "rcq", "cvc", "cqu", "tcq", "ccqs", "ccq", "ncq", "tcql", "pcq", "tcvc", "cqq", "pcqt", "rcQ", "pcvc", "dcvc"], "cq_ctx": ["cw_tx", "cq_loc", "cq_context", "cq_cf", "cw_context", "cq_conn", "cq_tx", "cw_ctx", "cw_conn"], "wr_id_in": ["wr_id__from", "wr_name_pin", "wr_id67on", "wr_id67init", "wr_id_ini", "wr_id__login", "wr_idjon", "wr_type_inc", "wr_idjin", "wr_type_init", "wr_id_init", "wr_id__in", "wr_info_ins", "wr_id_inc", "wr_id_int", "wr_type_from", "wr_id_pin", "wr_id_from", "wr_id_type", "wr_id_login", "wr_type_ini", "wr_id_out", "wr_name_inc", "wr_id67inc", "wr_info_in", "wr_name_in", "wr_type_on", "wr_type_in", "wr_id_ins", "wr_id_on", "wr_info_int", "wr_type_login", "wr_name_out", "wr_id__inc", "wr_idjinc", "wr_type_type", "wr_idjinit", "wr_info_inc", "wr_id67in"], "num_cq_events": ["num_cv_rows", "num_cqsblocks", "num_cv_events", "num_cqsevents", "num_cv_event", "num_cqsevent", "num_cqxevent", "num_cv_blocks", "num_cq_Events", "num_cqsrows", "num_cqxevents", "num_cQ_event", "num_cQ_events", "num_cq_event", "num_cQ_Events", "num_cq_rows", "num_cq_blocks", "num_cqxEvents"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t *)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    __asm__ volatile(\"pxor    %%mm7,%%mm7    \\n\\t\":::\"memory\");\n\n    __asm__ volatile(\"pcmpeqd %%mm6,%%mm6    \\n\\t\":::\"memory\");\n\n    mm_end = end - 3;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            PACK_RGB32\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r)\n\n            :\"memory\");\n\n        d += 16;\n\n        s += 4;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n        *d++ = 255;\n\n    }\n\n}\n", "idx": 3375, "substitutes": {"src": ["sub", "offset", "split", "rs", "sb", "data", "url", "r", "loc", "ins", "sl", "cur", "gz", "rb", "dest", "sync", "cb", "slice", "source", "ds", "config", "st", "length", "sc", "sq", "gb", "stream", "range", "rd", "b", "inst", "sur", "img", "start", "inf", "dist", "rc"], "dst": [" dstage", "dsp", "adfe", "dstage", " dfe", "adsp", "adst", "dsts", "ffe", " dsp", " dbl", "rdconst", "datconst", " dconst", "rdst", "adsts", "fst", "dconst", "fsts", "rdbl", "datbl", " dsts", "dfe", "dbl", "datst", "rdstage", "fsp", "datstage"], "src_size": ["src__ize", "src_ize", "rc_size", "src_len", "rc_scale", "src__size", "src_scale", "rc_len", "src__scale", "rc_ize"], "end": ["ending", "ff", "after", "offset", "r", "send", "ad", "n", "open", "id", "k", "ent", "enc", "END", "max", "day", "i", "m", "ended", "z", "index", "begin", "h", "x", "c", "p", "dev", "w", "e", "End", "size", "f", "set", "win", "en", "stop", "nd", "edge", "se", "start", "est"], "mm_end": ["sm_end", "cm_start", "mm_tail", "sm_tail", "mm_max", "mm_close", "mm_ends", "sm_ended", "cm_close", "cm_end", "cm_max", "cm_stop", "mm_ended", "mm_start", "cm_ended", "mm_stop", "sm_ends"], "d": ["Ds", "ld", "fd", "dn", "da", "dd", "sd", "dh", "dB", "r", "ad", "n", "di", "dl", "id", "D", "y", "i", "g", "j", "did", "m", "dy", "z", "ds", "dt", "dc", "h", "l", "c", "p", "x", "ind", "w", "e", "dos", "f", "dds", "bd", "u", "cd", "o", "v", "b", "t", "od", "ded", "dat", "ed", "start"], "s": ["days", "ss", "rs", "ts", "spec", "sd", "r", "n", "send", "sites", "sh", "sl", "id", "is", "devices", "y", "j", "g", "side", "i", "ids", "m", "ls", "ses", "sync", "sv", "z", "ds", "sets", "tests", "ps", "gs", "ns", "h", "l", "c", "p", "w", "e", "us", "f", "es", "lines", "secondary", "sq", "u", "rows", "south", "sec", "o", "v", "b", "su", "S", "t", "os", "times", "session", "states", "se", "start", "si", "ssl"], "bgr": ["bwr", "mwr", "abrow", "mgrad", "bdr", "brow", "pge", "ambrow", "abdr", "mctr", "rdr", "abbr", " bdist", "ambdr", "ambbr", " bfr", "fdr", "bbr", "fdist", " bwr", "dgrad", "dctr", "bge", " bctr", "dgr", "rgr", "ffr", "dge", "bfr", "fwr", " bgrad", "rwr", " brow", "abge", "mdr", "bctr", "rdist", "mgr", "bdist", " bdr", " bbr", "pbr", "mfr", "pdr", "ambgr", "bgrad", "abgr", "fgr", "mge", " bge", "pgr"]}}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n", "idx": 3392, "substitutes": {"opaque": ["opacity", " opque", "pque", "compacity", "operca", "opca", "opac", "opsacity", "operaque", "obacity", "obque", "compque", " opacity", "hopaque", "compac", "ipaque", "ipque", "ipca", " opa", "obac", "opsque", "compaque", "hopacity", "pa", "pacity", " opca", "ipc", "obaque", "opsaque", "hopac", "opsa", "opa", "opc", "paque", "operc", "opque", "hopque", "operque", " opc"], "chr": ["archr", "chorer", " chrc", "khrer", "motsr", "choR", "shrr", " chra", "cherR", "chR", "cherrator", "echr", "ochrr", "cherr", " chrg", "ocherr", "cltr", "chrt", "ochr", "archerr", "echsr", "chsr", "archrr", "motr", "chartr", "chcr", "charr", "cherrer", "charra", "Chrg", "Chsr", "ochtr", " chcr", " chsr", "chorator", "archtr", "clrt", "chrer", "shtr", "echrb", "chrr", " chrt", "khR", "clra", "Chrb", "motrg", "sherr", "echrc", "Chr", "Chrc", "clr", "Chcr", "chra", "khr", "chrator", "shr", " chrb", "khrator", "chrb", "charrt", "chtr", " chtr", "chrg", "motcr", "chrc", "chor"], "d": ["fd", "ld", "dn", "da", "dd", "pd", "sd", "dh", "dad", "r", "ad", "di", "n", "dl", "ct", "xd", "id", "dict", "de", "dom", "did", "g", "dy", "m", " D", "dt", "ds", "md", "z", "dc", "x", "l", "c", "p", "ind", "w", "e", "dm", "f", "bd", "du", "u", "cd", "driver", "s", "rd", "o", "b", "t", "od", "ded", "nd", "dat", "D", "gd", "db"]}}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n", "idx": 3394, "substitutes": {"s": ["js", "cs", "ss", "ops", "ts", "sb", "ips", "aws", "results", "ins", "ans", "ils", "ses", "ls", "settings", "sets", "als", "ds", "ps", "gs", "ns", "ares", "p", "rates", "services", "e", "es", "ches", "sys", "rows", "o", "b", "ves", "S", "ks", "states", "ures", "fs", "ows", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,\n\n                                     const uint8_t *src_in[4],\n\n                                     int srcW, int xInc, const int16_t *hChrFilter,\n\n                                     const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                     uint8_t *formatConvBuffer, uint32_t *pal)\n\n{\n\n    const uint8_t *src1 = src_in[1], *src2 = src_in[2];\n\n    if (c->chrToYV12) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    } else if (c->readChrPlanar) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst1, dst2, dstWidth);\n\n}\n", "idx": 3397, "substitutes": {"c": ["cm", "call", "cs", "conn", "cc", "mc", "cl", "cpp", "r", "com", "d", "ct", "co", "n", "nc", "bc", "cur", "cy", "con", "k", "tc", "enc", "comp", "g", "ac", "m", "coll", "cr", "ch", "config", "C", "ec", "dc", "ce", "h", "l", "p", "cu", "xc", "e", "lc", "f", "oc", "conf", "ca", "u", "ctrl", "cache", "sc", "core", "vc", "s", "cit", "pc", "b", "cp", "t", "cf", "ic", "ci", "uc", "rc"], "dst1": [" dstOne", " drcOne", "dest2", "dscOne", " dscFirst", "dstdFirst", "dstsOne", " drcFirst", "drcX", "drd1", " dscOne", "drcFirst", "dsc0", "dsc1", "dsts1", "dst3", "drcOne", "drc0", "dstd2", " dsc3", " drc1", "dscFirst", "drd2", "dscX", "drc1", "destOne", "dsc3", "dstX", "dest0", "dsc2", "dstFirst", "dest3", "dstone", "dst0", "drdFirst", " dstFirst", " dst3", "dstsFirst", " dsc1", " drcX", " dst0", "dest1", "drcone", "dstdone", "destFirst", "dstd1", " dsc2", "drc2", "dstsX", "dsts2", " dstX", "dstsone", " dstone", "dstOne", " drcone", "drd3", " drc2", " dsc0"], "dst2": ["dest2", "drest152", " dstSecond", "ddestBoth", "dest8", " dst152", "drcBoth", "dST2", "DscTwo", "Dst1", "drc4", "drest8", "drcTwo", "ddest2", "dsc152", "DrcTwo", "DscBoth", "Drc4", "dsc1", "destSecond", " dst8", "Drc02", "dSTTwo", "dstageSecond", " destSecond", "Dsc2", "dest152", "dST02", " dstTwo", "drc1", "dstage2", "dsc2", "dstageTwo", "Dst4", "dST4", "drest1", "dscTwo", "dstage1", "DstTwo", "ddest02", "dst152", " dsc1", " dsc8", "dst02", "dst4", "ddest4", "dest1", "drc02", "dstTwo", " dest1", " destTwo", "dscBoth", " dsc152", "dstSecond", "Dst02", " dsc2", "drc2", "Dst2", "dstBoth", "Dsc1", "dsc8", "dst8", "drest2", " dest2", "ddest1", "dscSecond", "DstBoth", "ddestTwo", "Drc2", "destTwo"], "dstWidth": ["drcLength", "dest2", " drcwidth", "dstLength", "dastHeight", "dST2", "adstswidth", "dastWidth", "adstwidth", " destLength", " drcWidth", "dastW", " dstLength", " destwidth", "dSTwidth", "adst2", " destWidth", "destHeight", "drcW", " dstwidth", "destLength", " drcHeight", "adstsHeight", "Dstwidth", "drcHeight", "dsc2", "dSt2", "drcWidth", " dstW", "destwidth", "dscwidth", "adstsWidth", "adstHeight", "DST2", "dSTWidth", "dstswidth", "DstWidth", "adsts2", "DstHeight", " dstHeight", "dstsHeight", "DSTwidth", "dstHeight", "dstsWidth", "dSTHeight", "drc2", "drcwidth", "Dst2", "adstWidth", "dsts2", "DSTWidth", " destW", "DSTHeight", "dStWidth", "dscWidth", "dstW", "dstwidth", "dStwidth", " destHeight", "destWidth", "dastLength", "destW", " dest2", "dStHeight", " drc2", "dscHeight"], "src_in": ["src_out", "cv_again", "rc_out", "src__in", "st_out", "st_ini", "src_gin", "src_again", " src_out", " src_again", "src_isin", "st_ins", "src_ins", "src2ini", "rc_isin", "src__isin", "cv_gin", "src2inc", "src__ins", "st__in", "src2in", "src_inc", "cv_in", "src__out", "src2again", "src__again", "src2ins", "src__gin", "st__ini", "st_in", "src2out", "st__ins", "st__out", "rc_in", "cv_inc", "src__ini", "src_ini", "src__inc", "rc_inc", "src2gin"], "srcW": [" srcN", "scw", "slL", "sourceH", "srcL", "rc2", "rcV", " srcV", "rcN", "slw", "surW", "rcWidth", "destL", "srcWh", "rcL", "destV", "srcN", "destN", "srcH", "destw", "source1", "rcWh", " srcWidth", "source2", "scW", "srcw", "slW", "srcV", "sourceV", "scL", "sourceW", "sourceL", "surH", " srcw", "destH", "rcW", "slWh", "sourcew", "rc1", "surw", "destWidth", "surL", "destW", "rcw", "srcWidth", "sourceN", "scWh"], "xInc": ["xIncrease", "xAdd", "xIncre", "XIncre", "exExp", "XEnc", "xEnc", "XInc", " xAdd", "exAdd", "XIncrease", "exinc", "yExp", "xinc", " xEnc", "xxIncrease", " xExp", " xinc", "xxEnc", "yinc", " xIncre", "xxInc", "xxIncre", "xExp", " xIncrease", "yInc", "exInc", "yAdd"], "hChrFilter": ["hMcrFilter", "hCrrFilter", "hChuFormat", "hChruCover", "hCrrWidth", "hChuFilter", "hCrrlWidth", "hChpFormat", "hChpBuffer", "hChruFill", "hChrarWidth", "hCrrFrame", "hChrtFilter", "hCrrFill", "hChrBuffer", "hChpFilter", "hChrarFilter", "hMcrWidth", "hchpFactor", "hChroFormat", "hChroBuffer", "hChroCover", "hChrarFill", "hMcrCover", "hChroWidth", "hchpFilter", "hChrFrame", "hChrtFrame", "hChpFactor", "hChrlWidth", "hChroFill", "hMcrarFilter", "hChruWidth", "hchpFormat", "hCrrlFilter", "hMcrarWidth", "hChrFill", "hChrarCover", "hChruFilter", "hChrCover", "hMcrarCover", "hchrFactor", "hchrFilter", "hChrtFill", "hChlerFilter", "hchrBuffer", "hMcrarFill", "hChrlFrame", "hchpBuffer", "hChrlFilter", "hChrWidth", "hCrrlFrame", "hChroFilter", "hChuBuffer", "hMcrFill", "hChrlFill", "hChroFactor", "hCrrlFill", "hChrFactor", "hChrFormat", "hChlerFrame", "hChlerFill", "hChrtWidth", "hChlerWidth", "hchrFormat", "hChuFactor"], "hChrFilterPos": ["hChrMaskPos", "hChrFilterDef", "hChlFilterOrigin", "hChlRulePo", "hChrLevelWin", "hChlRuleWin", "hChrMaskLen", "hChrFilterNeg", "hChroFilterNeg", "hChrRulePos", "hChrHeaderType", "hChlBufferDef", "hChrFeatureTop", "hChroFilterPo", "hChroFilterPos", "hChrMaskDef", "hChrFilterType", "hChrHeaderLen", "hChrFeaturePos", "hChrLevelPos", "hChrHeaderPos", "hChrFilterOrigin", "hChrRulePo", "hChrBufferLen", "hChlFilterDef", "hChlFilterType", "hChrFilterWin", "hChrHeaderDef", "hChrFilterTop", "hChlBufferPos", "hChrHelperNeg", "hChrHelperTop", "hChlRulePos", "hChrFactorPos", "hChrHelperPos", "hChlFilterWin", "hChrRuleWin", "hChlBufferLen", "hChlBufferType", "hChlFilterLen", "hChrHelperPo", "hChlRuleOrigin", "hChrFactorOrigin", "hChrMaskType", "hChrBufferType", "hChrBufferDef", "hChrFactorWin", "hChroFilterTop", "hChrFeaturePo", "hChrRuleOrigin", "hChlFilterPo", "hChrBufferPos", "hChlFilterPos", "hChrLevelPo", "hChrLevelOrigin", "hChrFactorPo", "hChrFilterPo", "hChrFeatureNeg", "hChrFilterLen"], "hChrFilterSize": ["hChrFactorSize", "hChrnFilterLength", "hChrFactorZone", "hChrImageSet", "hChrFilterLength", "hChrImageLength", "hChmFilterInfo", "hChrBufferNo", "hChrRuleLength", "hChrBufferSize", "hChrFormatName", "hChrfilterSize", "hChrFilterZone", "hChrFilName", "hChrbFilterZone", "hChrLimitSize", "hChrRuleSet", "hChrbFormatName", "hChrnImageSet", "hChmBufferNo", "hChrFactorLen", "hChrLimitSet", "hChrFactorNo", "hChrnFilterSet", "hChrBufferLen", "hChrFormatSize", "hChrFilZone", "hChrfilterNo", "hChrbFilterSize", "hChrnFilterSize", "hChrfilterInfo", "hChrFilSize", "hChrbFormatSize", "hChrFormatZone", "hChrFactorName", "hChmBufferInfo", "hChmBufferSize", "hChrFilterNo", "hChrImageSize", "hChmBufferLen", "hChrFilterSet", "hChrBufferInfo", "hChrFilterName", "hChrbFormatZone", "hChrLimitLength", "hChmFilterNo", "hChrnImageLength", "hChrRuleSize", "hChrFactorInfo", "hChrfilterLen", "hChrFilterInfo", "hChrnImageSize", "hChmFilterSize", "hChrbFilterName", "hChrFilterLen", "hChmFilterLen"], "formatConvBuffer": ["formatConuvReader", "formatConvdBuffer", "formatConvCenter", "formatConfStream", "formatEnvFormat", "formatEnvBuff", "formatConpFormat", "formatEnVBegin", "formatEnvStream", "formatEnfCenter", "formatConVStream", "formatConuvBuffer", "formatConpBuff", "formatConfBuff", "formatConuvBuff", "formatConVBuffer", "formatConchBuff", "formatConvsBuff", "formatConovLine", "formatConfFile", "formatConconvBuffer", "formatConvBegin", "formatAnvBuff", "formatConconvCenter", "formatConfCenter", "formatConovBegin", "formatConfBuffer", "formatConovBuffer", "formatConlCenter", "formatConverStream", "formatEnVFile", "formatEnVBuffer", "formatConVBuff", "formatEnVFormat", "formatEnfFrame", "formatConVBegin", "formatEnvBegin", "formatConvReader", "formatEnvBuffer", "formatConvsFile", "formatEnVStream", "formatEnfBuffer", "formatConovBuff", "formatEnvCode", "formatConfFrame", "formatConpBuffer", "formatConconvFrame", "formatConconvBuff", "formatConchBegin", "formatConVLine", "formatEnvFile", "formatConvStream", "formatAnfReader", "formatConvdBuff", "formatConvFormat", "formatConfCode", "formatConlBuffer", "formatEnvCenter", "formatConverBuff", "formatEnVLine", "formatConfFormat", "formatAnfBuff", "formatConVCenter", "formatConverBuffer", "formatEnVBuff", "formatConchBuffer", "formatConchLine", "formatConVReader", "formatAnfBuffer", "formatEnvLine", "formatConvCode", "formatConfReader", "formatConlBuff", "formatEnvFrame", "formatEnVCode", "formatAnvReader", "formatConlFrame", "formatConvFrame", "formatConVCode", "formatConvFile", "formatAnvBuffer", "formatEnVCenter", "formatConvdCode", "formatConVFile", "formatConVFormat", "formatConvLine", "formatEnfBuff", "formatConvBuff", "formatConvsBuffer", "formatConvsCenter"], "pal": ["pl", "what", "li", "local", "cal", "alias", "panel", "area", "vals", "fac", "ee", "align", "ap", "Pal", "bin", "nl", " Pal", "label", "pixel", "fal", "cale", "conf", "ar", "el", "le", "rel", "plan", "scale", "al", "val", "opal", "real", "ace", "pp", "pack"], "src1": ["sc2", " src01", " srcN", "src01", "rc2", " srcOne", "src3", "rcN", "rc01", "rcFirst", "src0", "srcN", "locN", "rc3", " src0", "source1", "source2", "compOne", "source3", "rc0", "sc3", "rcOne", "host1", "sourceOne", "sc1", "scOne", "loc2", "hostOne", "comp01", "host0", "comp1", "loc1", "hostFirst", "rc1", "loc0", " srcFirst", " src3", "srcOne", "srcFirst"], "src2": ["ctx02", "sup0", " src02", "rcAll", "rc4", "rc2", "rcBoth", "rss2", "url4", "sq02", "rc02", "src0", "source8", "sq0", "src02", "srcAll", "rc8", "configTwo", "src4", "rcSecond", "config1", "source1", " src0", "ctx2", "srcTwo", "ctx0", "sqtwo", "source2", "rctwo", "ctxtwo", "configBoth", "rss1", "rssTwo", "url2", "rcTwo", "rc0", "sup2", "src8", "urlSecond", "sourceTwo", "srctwo", "config2", " src8", "supAll", "bufAll", "source02", "rssBoth", "srcSecond", "bufTwo", "rc1", "sq2", "source0", "url1", "supTwo", "srcBoth", " src4", " srcSecond", "buf0", " srcTwo"], "buf2": ["uf2", " buf4", "buff3", "buf4", "uf4", " buf3", "src3", "uf0", "buff2", "src4", " buf8", "buf8", "uf8", "src8", "uf1", "uf3", " buf0", " buf1", "buff1", "buff4", "buf1", "buf3", "buf0", "buff0", "buff8"]}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n{\n    BlockDriverState *bs = child->bs;\n    /* Perform I/O through a temporary buffer so that users who scribble over\n     * their read buffer while the operation is in progress do not end up\n     * modifying the image file.  This is critical for zero-copy guest I/O\n     * where anything might happen inside guest memory.\n     */\n    void *bounce_buffer;\n    BlockDriver *drv = bs->drv;\n    struct iovec iov;\n    QEMUIOVector local_qiov;\n    int64_t cluster_offset;\n    int64_t cluster_bytes;\n    size_t skip_bytes;\n    int ret;\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n                                    BDRV_REQUEST_MAX_BYTES);\n    unsigned int progress = 0;\n    /* FIXME We cannot require callers to have write permissions when all they\n     * are doing is a read request. If we did things right, write permissions\n     * would be obtained anyway, but internally by the copy-on-read code. As\n     * long as it is implemented here rather than in a separate filter driver,\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n     * it could request permissions. Therefore we have to bypass the permission\n     * system for the moment. */\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n    /* Cover entire cluster so no additional backing file I/O is required when\n     * allocating cluster in the image file.  Note that this value may exceed\n     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which\n     * is one reason we loop rather than doing it all at once.\n     */\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n    skip_bytes = offset - cluster_offset;\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n                                   cluster_offset, cluster_bytes);\n    bounce_buffer = qemu_try_blockalign(bs,\n                                        MIN(MIN(max_transfer, cluster_bytes),\n                                            MAX_BOUNCE_BUFFER));\n    if (bounce_buffer == NULL) {\n        ret = -ENOMEM;\n        goto err;\n    while (cluster_bytes) {\n        int64_t pnum;\n        ret = bdrv_is_allocated(bs, cluster_offset,\n                                MIN(cluster_bytes, max_transfer), &pnum);\n        if (ret < 0) {\n            /* Safe to treat errors in querying allocation as if\n             * unallocated; we'll probably fail again soon on the\n             * read, but at least that will set a decent errno.\n             */\n            pnum = MIN(cluster_bytes, max_transfer);\n        assert(skip_bytes < pnum);\n        if (ret <= 0) {\n            /* Must copy-on-read; use the bounce buffer */\n            iov.iov_base = bounce_buffer;\n            iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER);\n            qemu_iovec_init_external(&local_qiov, &iov, 1);\n            ret = bdrv_driver_preadv(bs, cluster_offset, pnum,\n                                     &local_qiov, 0);\n            if (ret < 0) {\n                goto err;\n            bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n            if (drv->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(bounce_buffer, pnum)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,\n                                          &local_qiov, 0);\n            if (ret < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,\n                                pnum - skip_bytes);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);\n            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,\n                                     &local_qiov, 0);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                goto err;\n        cluster_offset += pnum;\n        cluster_bytes -= pnum;\n        progress += pnum - skip_bytes;\n        skip_bytes = 0;\n    ret = 0;\nerr:\n    qemu_vfree(bounce_buffer);\n    return ret;", "idx": 3398, "substitutes": {"child": ["sub", "server", "fd", "bit", "conn", "queue", "cl", "current", "GV", "children", "ab", "bid", "bc", "job", "cur", "bin", "parent", "client", "cus", "buf", "inner", "code", "ch", "pool", "c", "block", "cache", "core", "crypt", "sec", "pc", "lib", "Child", "root", "fs", "uc", "ssl"], "offset": ["layer", "base", "starting", "outer", "uration", "alias", "acl", "security", "annot", "url", "initialized", "image", "loc", "align", "position", "slot", "timeout", "end", "initial", "off", "seed", "pos", "outing", "fp", "info", "entry", "slice", "index", "enabled", "config", "pointer", "address", "ip", "alpha", "shift", "reset", "length", "set", "size", "reference", "origin", "padding", "phase", "o", "fee", "prefix", "optional", "Offset", "error", "online", "location", "count", "root", "part", "start"], "bytes": ["files", "null", "ops", "byte", "zip", "bps", "items", "ips", "data", "complete", "binary", "url", "eps", "Bytes", "seconds", "bc", "parent", "gz", "resses", "tes", "bits", "ls", "outs", "pieces", "utils", "enabled", "errors", "address", "css", "values", "lines", "len", "es", "pages", "steps", " offsets", "blocks", "seq", "fee", "codes", "its", "count", "fs", "les"], "qiov": ["questionregor", "Qregor", "qregor", "qiop", "questioniov", " qregor", " qiop", "Qiov", "qliv", " qliv", "Qiop", "Qliv", "questionliv", "questioniop"], "bs": ["base", "sub", "js", "cs", "bh", "ss", "ba", "bn", "rs", "boards", "sb", "bps", "lb", "ab", "BS", "eb", "ib", "bid", "bc", "banks", "ins", "bin", "pb", "bel", "bing", "bl", "bis", "plugins", "ls", "ses", "bits", "cb", "settings", "bal", "outs", "ds", "bas", "bf", "ps", "gs", "ns", "bot", "css", "vs", "bi", "bos", "org", "gb", "obj", "cases", "bb", "ubs", "blocks", "s", "fb", "b", "lib", "iss", "os", "ks", "las", "bes", "fs", "db", "obs"], "bounce_buffer": ["bair_buffer", "bounce_transfer", "bounce_source", "bounceeddevice", "bait_uffer", "bait_buffer", "bounce64buffer", "batteryedsize", "bounce64table", "bounces_header", "bouncetheader", "bair_queue", "bounce_header", "bounceedqueue", "bounceinguffer", "bair64queue", "bounceingtable", "battery_size", "batteryeddevice", "bounces_buffer", "battery_device", "bair_table", "bounceingqueue", "bounce_buf", "bouncetsource", "bounce_queue", "bounce_uffer", "bait_transfer", "bouncetbuffer", "bouncetbuf", "battery_queue", "bounceedbuffer", "battery_buffer", "bounceedsize", "bounceingtransfer", "bounces_buf", "batteryedqueue", "bair64buffer", "bounces_source", "bounce_size", "bair64table", "batteryedbuffer", "bounceingbuffer", "bounce_device", "bounce64queue", "bounce_table"], "drv": ["DRv", "hrf", "hrb", "rrf", "hrv", "rrv", "DRc", "drc", "DRV", "rrc", "hrV", "drf", "drV", " drc", "DRb", "drb", " drV", "DRf", " drb", " drf", "rrb"], "iov": ["minecraft", "ilo", "\u00ef", "gio", "uno", "oren", "hw", "volt", "liv", "orman", "wikipedia", "yout", "club", "gru", "iasm", "obo", "rob", "orde", "voc", "arrison", "mus", "wav", "buf", "iev", "drm", "iol", "vre", "iris", "iii", "isco", "dylib", "lov", "output", "ominium", "RF", "coll", "ir", "iro", "sbm", "ressor", "ibl", "oyer", "ibr", "ilib", "ortex", "vg", "imedia", "oc", "soc", "iop", "roxy", " cohort", "river", "nox", "dyl", "voice", "rolet", "rx", "userc", "io", "rov"], "local_qiov": ["local_dqiov", "local_quiov", "local_qoyer", "local_giov", "local_dqoyer", "local_giop", "local_dqiev", "local_iqiop", "local_iqoyer", "local_iqliv", "local_qiev", "local_dqliv", "local_quadiev", "local_quadliv", "local_quliv", "local_yoyer", "local_poyer", "local_piev", "local_quadiov", "local_piop", "local_piov", "local_gliv", "local_qliv", "local_quadiop", "local_quiop", "local_dqiop", "local_yiop", "local_yiov", "local_yiev", "local_quiev", "local_iqiov", "local_quoyer", "local_qiop", "local_goyer"], "cluster_offset": ["cluster_len", "claco_start", "clayer_start", "cluster_address", "cluster_align", "clusters_size", "cluster_position", "clister_label", "cluster1offset", "clusterappoffset", "clusterapplocation", "clister67len", "clayer_length", "clusters_length", "clayer_align", "cluster_label", "clister_len", "cluster67len", "clayerPoffset", "cluster__offset", "cluster1position", "claco_offset", "cluster_length", "cluster_start", "clusterPlength", "clusterPoffset", "clister67start", "clusters_offset", "cluster_location", "cluster_part", "cluster0offset", "clusterPalign", "cluster_size", "clusterapplength", "clayerPalign", "cluster67offset", "cluster67label", "claco_part", "clayer_offset", "cluster0size", "cluster67start", "cluster0location", "clayerPstart", "cluster1size", "clister_offset", "clister67label", "claco_position", "clusterPstart", "clayerPlength", "clister67offset", "clusterappsize", "clusters_position", "cluster__size", "cluster0length", "clister_start", "cluster__position", "clusters_location", "cluster1len", "cluster__address", "clusters_address"], "cluster_bytes": ["cluster8length", "cluster__bits", "cliversity_bytes", "clorer_bytes", "cluster___stores", "clusteringpages", "cluster_flows", "cliversity_length", "clancer_size", "clusterMflows", "cluster_stores", "clensus_bits", "clustersvalues", "cliversityMpieces", "cluster_units", "cluster67bytes", "cluster_seconds", "cluster_bits", "clorerslimits", "cluster___bytes", "clorerspages", "cliversity_flows", "clensus67bits", "cluster___size", "clensus_offset", "cliversity_pieces", "clorer_values", "cluster67units", "clusters_bits", "cluster__bytes", "clusterspages", "cluster2bits", "clorersvalues", "cluster__values", "clancer_offset", "clusterMpieces", "clusteringbytes", "clorersbytes", "cluster_pages", "cluster__offset", "clusterMbytes", "cliversityMbytes", "cluster_length", "cluster67bits", "clusters_offset", "clensus67units", "clusteringvalues", "cluster_values", "clorer_pages", "clensus67offset", "cluster___offset", "cliversityMlength", "cluster_size", "clensus_units", "clensus67bytes", "cluster_lines", "cluster67offset", "clusterslimits", "cluster67values", "cluster8pieces", "clusters_bytes", "cluster2pieces", "cluster_pieces", "cluster2length", "clorer_limits", "clustersbytes", "cluster2bytes", "clusters_values", "cluster_limits", "clancer_stores", "cliversityMflows", "clusteringlimits", "clusterMlength", "clensus_bytes", "cluster8bytes", "clancer_bytes", "cluster8flows"], "skip_bytes": ["skip_bits", " skip_seconds", "skipingbytes", "skip00bytes", "skip_items", " skip_size", "skip_files", "skip_size", "skip00units", "skip2bits", "skip00lines", "skip_units", "skip2bytes", "skip2seconds", "skip_resources", "skip_seconds", " skip_files", " skip_items", "skip00resources", "skip2size", "skip_lines", " skip_resources", "skipingseconds", "skipingfiles", " skip_lines", " skip_units", "skipingitems", " skip_bits"], "ret": ["match", "fun", "att", "mt", "def", "bit", "hash", "success", " Ret", "url", "out", "alt", "cat", "id", "pet", "rets", "fit", "arr", "num", "pass", " RET", "rb", "code", "nt", "ft", "rev", "back", "reply", "feat", "Ret", "rc", "bf", "opt", "sat", "result", "fin", "try", "len", "ref", "flag", "gt", "resp", "art", "obj", "RET", "final", "error", "valid", "lit", "re", "reg", "val", "iter", "count", "rt", "let", "det", "res"], "pnum": ["PNom", "pinumber", "pcUM", "bnUM", "panumb", "pcums", "ennUM", "pnummer", "ynumber", "ynumer", "cnum", "rnumb", "pnut", "pronut", "pnym", "rnumption", "cnumer", "pcenum", "panummer", "pronumer", "pnenum", "pcum", "pronum", "pnumber", "pronuma", "bnum", "pnom", "PNumb", "pnUM", "panum", "pnumb", "pronumb", "panumer", "pnuma", "pronumber", "rnuma", "pinom", "cnumption", "pronenum", "rnumber", "pnums", "rnummer", "pronUM", "bnuma", "pinum", "PNum", "PNummer", "cnuma", "rnenum", "rnum", "pnumer", "PNym", "pnumption", "pronumption", "rnym", "rnUM", "PNumer", "PNumber", "pinym", "ynuma", "cnumb", "ynum", "pronums", "rnumer", "bnut", "ennut", "ennuma", "rnums", "ennum", "rnom", "cnenum"]}}
{"project": "qemu", "commit_id": "2cbe2de5454cf9af44b620b2b40d56361a12a45f", "target": 1, "func": "static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}", "idx": 3399, "substitutes": {"dev": ["serial", "cam", "def", "hw", "conn", "device", "fw", "data", "ad", "ver", "di", "devices", "av", "sh", "prop", "priv", "d", "grad", "de", "dom", "Dev", "pos", "proc", "pub", "bus", "pad", "p", "prom", "attr", "conf", "eth", "rad", "serv", "dem", "ev", "var", "od", "error", "pro", "img", "inst", "gd"], "errp": ["errP", "resultr", "erP", " ErrP", "erlp", "errfp", " errr", " errlp", "err", " errps", " errP", "resultp", "errr", "errps", " Errps", "resultP", "erp", "errlp", " Errp", " errfp", "erps", "resultlp", " Errfp", "erfp"]}}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    char buf[1024];\n\n    VncShareMode mode;\n\n    int size;\n\n\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n\n    switch (vs->vd->share_policy) {\n\n    case VNC_SHARE_POLICY_IGNORE:\n\n        /*\n\n         * Ignore the shared flag.  Nothing to do here.\n\n         *\n\n         * Doesn't conform to the rfb spec but is traditional qemu\n\n         * behavior, thus left here as option for compatibility\n\n         * reasons.\n\n         */\n\n        break;\n\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n\n        /*\n\n         * Policy: Allow clients ask for exclusive access.\n\n         *\n\n         * Implementation: When a client asks for exclusive access,\n\n         * disconnect all others. Shared connects are allowed as long\n\n         * as no exclusive connection exists.\n\n         *\n\n         * This is how the rfb spec suggests to handle the shared flag.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            VncState *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 3401, "substitutes": {"vs": ["js", "alls", "qs", "vt", "ver", "ls", "VS", "cv", "css", "prev", "vc", "s", "events", "manager", "va", "wp", "versions", "fs", "blogs", "spec", "vals", "ums", "vert", "cas", "xs", "sv", "utils", "state", "lines", "as", "v", "sts", "vas", "iv", "ves", "plugin", "su", "os", "ks", "bs", "its", "plugins", "obs", "nav", "cs", "vp", "verts", "ss", "rs", "Vs", "eps", "ins", "env", "settings", "ports", "ds", "ps", "gs", "ns", "oss", "values", "vers", "es", "posts", "lv", "points", "las", "vm", "server", "http", "ops", "views", "pg", "ms", "docs", "ils", "sk", "pos", "ov", "otes", "vid", "services", "stats", "vr"], "data": ["media", "base", "response", "ata", "buffer", "da", "offset", "channel", "a", "array", "queue", "vals", "memory", "window", "parent", "sample", "api", "batch", "i", "next", "code", "entry", "args", "body", "config", "ip", "result", "block", "reader", "p", "state", "values", "alpha", "cache", "message", "text", "DATA", "uri", "load", "dat", "Data", "map", "input"], "len": ["lic", "ig", "byte", "Len", "cl", "lf", " limit", "bl", "pos", "z", "vec", "length", "cap", " length", "en", "seq", "ix", "val", "all"], "buf": ["ff", "fd", "nat", "buffer", "src", "bed", "bh", "ctx", "bag", "ba", "Buff", "queue", "bm", "ab", "uc", "fw", "window", "loc", "header", "fl", "bc", "buff", "pb", "batch", "rb", "code", "fp", "box", " cmd", " buffers", "cb", "pool", "pad", "bus", "block", "cv", "Buffer", "vec", "stack", "wb", "bd", "cap", "br", "la", " b", "bg", "cmd", "bp", "bb", "bridge", "seq", "b", "fb", "ucc", "uf", "port", "va", "img", "que", "fi", "map", " buffer", "rc", "mem"], "mode": ["route", "lock", "key", "device", "dim", "command", "ase", " module", "mo", "de", "code", "mid", "direction", "message", "manager", " scheme", "map", "rage", "name", "effect", "activity", "sid", "ui", "type", "id", "mm", "model", "mac", "ode", "gone", "state", "layout", "phrase", "driver", "scale", "plugin", "Mode", "me", "sym", "MODE", "guide", "version", "mod", "ward", "use", "kind", "member", "language", "m", "slice", "role", "definition", "phase", "module", "rule", "slave", "stage", "level", " role", "grade", "operation", "side", "none", "style", "multi", "md", "status", "config", "owner", "token", "range", "ace", "day"], "size": ["unit", "SIZE", "capacity", "name", "offset", "time", "ize", "large", "sized", "area", "small", "speed", "mini", "loc", "align", "weight", "type", "page", " sizes", "empty", "ny", "member", "max", "code", "sync", "number", "style", "z", "storage", "address", "content", "shift", "length", "message", "Size", "sum", "en", "scale", "fee", "iz", "count", "shape"], "client": ["consumer", "server", "cli", "service", "channel", "local", "conn", "command", "cl", "current", "image", "window", "character", "co", "friend", "open", "worker", "con", "Client", "parent", "end", "remote", "api", "secure", "company", "contact", "project", "source", "request", "config", "ce", "ip", "gu", "reader", "state", "custom", "resource", "child", "cache", "core", "contract", "public", "cmd", "connection", "pc", "plugin", "cell", "container", "manager", "session", "socket", "close", "product", "player", "net", "response", "user", "port"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,\n\n                                                 const uint8_t *src_y,\n\n                                                 int32_t src_stride,\n\n                                                 uint8_t *dst,\n\n                                                 int32_t dst_stride)\n\n{\n\n    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;\n\n    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;\n\n    v8i16 res0, res1;\n\n    v16u8 res;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);\n\n    src_y += (5 * src_stride);\n\n\n\n    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);\n\n    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);\n\n    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);\n\n    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);\n\n\n\n    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);\n\n    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);\n\n    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,\n\n                                                          mask0, mask1, mask2);\n\n    SRARI_H2_SH(hz_out0, hz_out1, 5);\n\n    SAT_SH2_SH(hz_out0, hz_out1, 7);\n\n    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);\n\n\n\n    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);\n\n    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);\n\n    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);\n\n    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);\n\n\n\n    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);\n\n\n\n    /* filter calc */\n\n    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,\n\n                                                  src_vt3, src_vt4, src_vt5);\n\n    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,\n\n                                                  src_vt5, src_vt6, src_vt7);\n\n    SRARI_H2_SH(vert_out0, vert_out1, 5);\n\n    SAT_SH2_SH(vert_out0, vert_out1, 7);\n\n\n\n    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);\n\n    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);\n\n\n\n    SAT_SH2_SH(res0, res1, 7);\n\n    res = PCKEV_XORI128_UB(res0, res1);\n\n\n\n    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);\n\n    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);\n\n    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);\n\n    dst0 = __msa_aver_u_b(res, dst0);\n\n\n\n    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);\n\n}\n", "idx": 3416, "substitutes": {"src_x": ["src64h", "src64y", "src_w", "src_h", "src64w", " src_w", "src64x", " src_h"], "src_y": [" src_xy", "src_vy", "source_vy", "source_Y", " src_ya", "src_ya", "src_cy", "src_Y", "src_xy", "source_y", " src_cy", "source_xy"], "src_stride": ["src_bride", "src_StrIDE", "src_strided", "src_frided", "src_tride", "src_brider", "src_strade", "src_rride", "src_trider", "src_striride", "src_brride", "src_stided", "src_Strade", "src_stade", "src_strider", "src_brade", "src_striide", "src_frIDE", "src_striided", "src_frade", "src_ride", "src_rade", "src_striider", "src_strIDE", "src_trided", "src_rided", "src_brided", "src_stIDE", "src_fride", "src_Stride", "src_Strided", "src_strride", "src_stide", "src_trride"], "dst": ["adsts", "adsp", "adst", "dsts", "Dsts", "dsp", "adest", " dsp", "Dsp", " dsts", " dest", "Dst", "Dest", "dest"], "dst_stride": ["dst_trider", "dst_stide", "dst_strider", "dst_tride", "dst_octider", "dst_octride", "dst_stider", "dst_strided", "dst_octide", "dst_octided", "dst_trided", "dst_trride", "dst_strride", "dst_stided"], "src_hz0": ["src_cz1", "src_hz8", "src_cz0", "src_hw1", "src_hm8", "src_hm0", "src_hm2", "src_hw0", "src_cz8", "src_hw8", "src_hm1", "src_cz2", "src_hw2"], "src_hz1": ["src_htone", "src_cz1", "src_voltone", "src_czone", "src_cz9", "src_volt1", "src_volt9", "src_volt2", "src_ht1", "src_hz9", "src_ht9", "src_hzone", "src_ht2", "src_cz2"], "src_hz2": ["src_cz1", "src_z4", "src_frequency1", "src_z1", "src_frequency2", "src_cz4", "src_hz4", "src_z2", "src_frequency32", "src_cz32", "src_frequency4", "src_hz32", "src_z32", "src_cz2"], "src_hz3": ["src_frequency9", "src_cz3", "src_cz1", "src_frequency3", "src_frequency1", "src_z1", "src_frequency2", "src_cz9", "src_z3", "src_z2", "src_z9", "src_hz9", "src_cz2"], "dst0": ["dsp2", "dsc0", "dsp6", "dsp10", " dst6", "dsts0", "dsp0", "dst10", "dsc2", "dsc10", " dsc10", "dst6", "dsts10", "dsc6", "dsts6", " dsc2", "dsts2", " dst10", " dsc6", " dsc0"], "dst1": ["dest2", "dsc61", "dsc1", "dsts1", " dest61", "dsc2", " dst61", "dest1", " dest1", "dst61", "dsts2", " dest2", "dest61", "dsts61"], "dst2": ["dest2", "dest02", "dost02", "dost0", " dest0", "dsc0", "dsc1", "dost1", "dsc02", "dest0", " dest02", "dsc2", " dst02", "dst02", "dest1", " dest1", " dest2", "dost2"], "dst3": ["dsts63", " dest5", "dsts1", "dest63", "dft1", "dft5", " dest63", " dst5", "dest3", " dst63", "dest5", " dest3", "dsts5", "dest1", "dft63", "dft3", " dest1", "dst63", "dsts3", "dst5"], "src_vt0": ["src_ft0", "src_rt3", "src_vt48", "src_rt1", "src_pt1", "src_ft3", "src_wt6", "src_rt2", "src_VT0", "src_VT1", "src_wt1", "src_pt0", "src_ret0", "src_rt5", "src_pt5", "src_ret6", "src_rt6", "src_ft5", "src_ft48", "src_vp48", "src_vp1", "src_VT8", "src_ft1", "src_ft2", "src_rt8", "src_wt2", "src_wt3", "src_ret2", "src_ret1", "src_rt0", "src_rt48", "src_ft8", "src_pt2", "src_wt0", "src_vp0", "src_VT2", "src_vp2"], "src_vt1": ["src_v1", "src_wtart", "src_ft7", "src_dt1", "src_ht7", "src_rt4", "src_v7", "src_vtart", "src_gt3", "src_dt2", "src_rt0", "src_ht2", "src_pt2", "src_dt0", "src_gt4", "src_gt1", "src_rt1", "src_rt2", "src_vc5", "src_fifart", "src_wt1", "src_ftart", "src_ft2", "src_gt2", "src_wt0", "src_fif1", "src_ft3", "src_ft0", "src_rt3", "src_ht4", "src_pt1", "src_ht3", "src_vc2", "src_ht1", "src_rt32", "src_vc3", "src_vc1", "src_gt0", "src_pt5", "src_ft5", "src_ft1", "src_pt3", "src_dt32", "src_fif0", "src_v2", "src_ft32", "src_vt32"], "src_vt2": [" src_\n", "src_0", "src_vt20", "src_rt02", "src_wt6", "src_gt02", "src_rt5", "src_rt4", "src_mt0", "src_vet2", "src_pt32", "src_gt3", " src_0", "src_mt1", "src_ht2", "src_pt2", "src_gt4", "src_8", "src_gt1", "src_\n", "src_rt1", "src_rt2", "src_wt1", " src \n", "src_rt20", "src_ft2", " src_2", "src \n", "src_wt2", "src_mt6", "src_gt2", "src_wt0", "src_ft0", "src_rt3", "src_ht4", "src_pt1", "src_pt4", "src_ht3", " src_8", "src_gt5", "src_ht1", "src_rt32", "src_ht5", "src_vt02", "src_ft20", "src_ht02", "src_vet4", "src_ft1", "src_mt2", "src_ft6", "src_ft4", "src_2", "src_vet1", "src_ft32", "src_vt32", "src_vet20"], "src_vt3": ["src_ftthree", "src_vp34", "src_vrd", "src_htd", "src_pt25", "src_rt4", "src_vr2", "src_irt1", "src_vr1", "src_pt2", "src_ht2", "src_rt1", "src_rt2", "src_wt1", "src_irt3", "src_vp3", "src_ft2", "src_vr3", "src_wt2", "src_vt25", "src_ft3", "src_rt3", "src_vtthree", "src_ht4", "src_pt1", "src_ht3", "src_ftd", "src_vp1", "src_ht34", "src_ht1", "src_rt34", "src_vt34", "src_irt2", "src_irtthree", "src_wt25", "src_pt3", "src_ft1", "src_vp25", "src_wt3", "src_htthree", "src_vp4", "src_vp2", "src_vtd"], "src_vt4": ["src_wt5", "src_wt4", "src_rt1", "src_wt6", "src_rt2", "src_wt1", "src_rt5", "src_rt6", "src_rt4", "src_ft1", "src_ft2", "src_gt5", "src_wt2", "src_gt2", "src_ft6", "src_ft4", "src_gt4", "src_gt1"], "src_vt5": ["src_ft0", "src_rt1", "src_rt2", "src_rt5", "src_ft5", "src_ft1", "src_ft2", "src_ht0", "src_ht1", "src_rt0", "src_ht5", "src_ht2"], "src_vt6": ["src_wt4", "src_ht4", "src_wt6", "src_rt2", "src_ht8", "src_ht6", "src_rt6", "src_rt4", "src_rt8", "src_wt2", "src_ht2", "src_wt8"], "src_vt7": ["src_irt8", "src_wt1", "src_ht8", "src_ht7", "src_wt17", "src_irt7", "src_ht1", "src_ht17", "src_irt1", "src_irt17", "src_wt7", "src_vt17", "src_wt8"], "src_vt8": ["src_gt6", "src_rt5", "src_rt6", "src_rt4", "src_ft5", "src_gt5", "src_rt8", "src_ft6", "src_gt8", "src_ft4", "src_ft8", "src_gt4"], "mask0": ["weight1", "ask3", "mask50", "weight2", " mask3", "ask0", "weight50", "sum50", "ask1", "sum1", "sum0", "sum2", "mask3", "weight3", " mask50", "ask2", "weight0"], "mask1": ["mask5", "ask3", "ask5", "mark8", " mask3", "pass1", " mask5", "pass3", "ask1", " mask8", "mark1", "pass2", "mask3", "mask8", "ask2", "pass5", "mark2", "ask8"], "mask2": ["mask5", "ask5", "lock2", "mark8", "ask0", "mask4", " mask5", "lock8", "mark4", "lock5", " mask8", "mark5", "ask4", "mask8", "ask2", "mark2", " mask4", "lock0", "ask8"], "hz_out0": ["hz_mask0", "hz_mask1", "hz_intee", "hz_inee", "hz_maskee", "hz_in0", "hz_int1", "hz_int0", "hz_outee", "hz_in1"], "hz_out1": ["hz_inone", "hz_off1", "hz_offOne", "hz_outone", "hz_bitone", "hz_inOne", "hz_outOne", "hz_offone", "hz_bit1", "hz_bitOne", "hz_in1"], "vert_out0": ["vert_mask3", "vert_bited", "vert_bit1", "vert_in3", "vert_out3", "vert_bit3", "vert_mask1", "vert_bit0", "vert_in0", "vert_mask0", "vert_in1", "vert_outed", "vert_masked", "vert_ined"], "vert_out1": ["vert_maskOne", "vert_in2", "vert_mask3", "vert_out2", "vert_outOne", "vert_Out3", "vert_in3", "vert_mask2", "vert_OutOne", "vert_out3", "vert_Out2", "vert_mask1", "vert_inOne", "vert_Out1", "vert_in1"], "res0": ["rem2", "Res0", "Res2", "Res8", "resolution2", "rem8", "rem0", "res8", "resolution8", "resolution0", "res2"], "res1": ["resolution1", "resolution3", "rem2", "Res3", "Res2", "resolution2", "rem1", "rem3", "res3", "res2", "Res1"], "res": ["resolution", "rs", "gr", "vals", "Res", "ver", "ms", "RES", "pres", "rep", "bits", "rev", "ps", "vers", "rem", "rows", "ress", "mask", "rel", "blocks", "rss", "req", "depth", "re", "reg", "resh", "fs"]}}
{"project": "qemu", "commit_id": "a27365265cc2fed1178bf25a205e8ee02a9c0caf", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 3440, "substitutes": {"bs": ["base", "js", "cs", "ss", "qs", "sa", "sb", "lb", "ab", "BS", "bc", "pb", "fps", "bl", "bis", "ses", "ls", "bits", "sync", "ds", "bas", "ps", "ns", "vs", "state", "bos", "obj", "as", "ubs", "iss", "blocks", "fb", "b", "bb", "os", "ks", "las", "bes", "fs", "obs", "ssl"], "sector_num": ["sector_number", " sector_Num", "sector0name", "sector0number", " sector_number", " sector_nom", "sector0num", " sector_name", "sector_nom", "sector0nom", "sector_name", "sector_Num"], "qiov": ["qovi", "eqiov", " qilo", "qiris", "quilo", "qqdyl", "quicho", "qicho", "Qicho", "eqiris", " qicho", "eqicho", "qudyl", "quiov", "Qiov", "qqiov", "qdyl", "eqovi", " qovi", "qqilo", " qdyl", "Qiris", "qqicho", "Qovi", " qiris", "qilo"], "nb_sectors": ["nb_pector", "nb_separgments", "nb_secctors", "nb_separators", "nb_vegments", "nb_veators", "nb_separivers", "nb_secctor", "nb_pegments", "nb_sector", "nb_vector", "nb_segments", "nb_serators", "nb_separctors", "nb_sections", "nb_pections", "nb_vectors", "nb_sergments", "nb_serivers", "nb_serctors", "nb_secgments", "nb_pectors", "nb_vections", "nb_secctions", "nb_seators", "nb_veivers", "nb_seivers"], "cb": ["ob", "fc", "orb", "fun", "cs", "ctx", "Callback", "cc", "sb", "CB", "eb", "bc", "callback", "buff", "fn", "pb", "rb", "code", "fp", "func", "ec", "function", "bf", "abc", "c", "cv", "f", "unc", "ctrl", "cd", "bb", "pc", "fee", "fb", "b", "cf", "db"], "opaque": ["opacity", "opaques", "OPacity", "opbc", "hopaques", "pac", "OPc", " opac", "opac", "operaque", "OPaques", "obacity", "OPace", "opace", " opacity", "hopaque", "operac", "operace", " opbc", "OPaque", "operacity", "hopacity", "pbc", "pacity", " opaques", "obaque", "obc", "obace", "opc", "paque", "operc", "operbc"], "s": ["service", "src", "cs", "http", "ss", "ops", "sa", "sb", "is", "ses", "sv", "storage", "ds", "ps", "gs", "ns", "c", "p", "services", "e", "self", "secondary", "sys", "sq", "o", "stats", "su", "b", "S", "os", "session", "socket", "states", "fs", "si", "ssl"]}}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 3449, "substitutes": {"opaque": ["opacity", " opque", "opaques", "iopque", "oaque", "ovacle", " opac", "opac", "iopaque", "copaques", "iopac", "copque", " opacity", "copac", "ovaque", "copacle", "copacity", "iopacity", "oacity", "opacle", "oacle", "copaque", "oaques", "ovaques", "opque", "ovacity"], "addr": ["dr", "route", "act", "acl", "url", "lvl", "alt", "adder", "enc", "ady", "code", "index", "pointer", "address", "ack", "x", "ind", "en", "rt", "name", "host", "sid", "nn", "align", "id", "ea", "frame", "buf", "arr", "adr", "ac", "coord", "work", "p", "ptr", "hop", "amp", "edge", "layer", "base", "np", "offset", "data", "rr", "loc", "ad", "r", "env", "ha", "enh", "pad", "usr", "h", "anne", "afi", "order", "ref", "attr", "arm", "el", "fx", "node", "kk", "cmd", "asm", "ino", "req", "ost", "mode", "oa", "src", "intel", "inter", "conn", "alias", "aa", "ord", "grad", "pos", "md", "config", "ip", "nick", "ar", "padding", "pc", "amd", "cmp", "sta", "ace", "rc"], "val": ["ret", "base", "arg", "vol", "ol", "li", "cal", "def", "key", "elt", "vals", "data", "loc", "Val", "slot", "fl", "sl", "it", "end", "buf", "arr", "enc", "bl", "pre", "py", "pos", "tx", "bal", "aval", "sel", "x", "l", "block", "p", "ind", "fi", "eval", "ref", "f", "la", "el", "value", "ival", "il", "v", "seq", "serv", "b", "var", "valid", "al", "reg", "VAL", "am", "pt", "rt", "all", "count", "db", "mem"], "size": [" err", "ctx", " iv", "vals", "data", " pri", " ret", " arg", "pos", " data", " pos", " el", "eval", "length", " length", "value", "padding", "v", "al", "VAL", "mem"], "s": ["sg", "js", "service", "this", "cs", "ss", "rs", "ts", "spec", "a", "sb", "new", "r", "n", "aws", "is", "ins", "sl", "ms", "y", "g", "side", "m", "ses", "ls", "args", "uns", "sync", "settings", "ds", "ps", "gs", "ns", "l", "c", "p", "sie", "state", "w", "e", "services", "f", "self", "es", "conf", "sq", "us", "sys", "secondary", "rows", "as", "o", "v", "b", "site", "t", "S", "session", "ks", "os", "your", "hs", "states", "fs", "si", "sym", "parts", "ssl"], "adsr": ["assesr", "andsdr", " adsdr", "Adrr", "artsrr", "assesnr", "edsrr", " adsrt", "aidpr", "acksp", "psrt", "edsr", "aidr", "adesr", "adsp", "artsrd", "Adr", "ddcr", "artsrf", "adscr", "aidrr", "adsrd", "psrr", "adsrr", "ansrr", "adsdr", "andsr", "aidrt", "acksrr", "ansrt", "ansr", "assesdr", "acksr", "artsr", "ksrr", "ksrf", "ksr", "adescr", "andsnr", "adesrf", "assesp", "ksrd", "edsrd", "edsrf", "adsrt", "assesrt", "adspr", "adesp", "ddr", "adesrr", "andsrt", "Adcr", "adsnr", "acksrt", " adsnr", "adesrt", "pspr", "anspr", "ddrr", "adsrf", "ddrf", "assesrr", "Adrf", "psr"], "len": ["base", "led", "fun", "ld", "name", "li", "lan", "den", "ni", "Len", "dim", "loc", "ellen", "n", "lvl", "lf", "lif", "ln", "sl", "dl", "sp", "lang", "un", "fn", "end", "id", "lim", "pos", "dy", "ls", "ll", "lt", "fl", "z", "ie", "lon", "l", "ind", "fin", "e", "lc", "length", "f", "la", "el", "il", "en", "rel", "lib", "seq", "lin", "lit", "line", "ann", "count", "gen", "part", "limit", "in", "le", "mem"], "i": ["base", "li", "gi", "a", "ni", "ii", "zi", "ui", "oi", "pi", "d", "n", "I", "uni", "di", "is", "id", "mi", "it", "k", "j", "pos", "eni", "ri", "code", "ti", "ini", "z", "index", "ai", "x", "ip", "l", "p", "ind", "bi", "hi", "e", "c", "f", "phi", "adi", "u", "il", "en", "ori", "v", "o", "vi", "qi", "ix", "b", "uri", "ci", "start", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,\n\n                                                       uint8_t alpha_in,\n\n                                                       uint8_t beta_in,\n\n                                                       uint32_t img_width)\n\n{\n\n    uint16_t out0, out1, out2, out3;\n\n    v8i16 tmp1;\n\n    v16u8 alpha, beta, is_less_than;\n\n    v8i16 p0_or_q0, q0_or_p0;\n\n    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;\n\n    v16i8 zero = { 0 };\n\n    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;\n\n    v16u8 is_less_than_alpha, is_less_than_beta;\n\n    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;\n\n\n\n    {\n\n        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;\n\n\n\n        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,\n\n                      row0, row1, row2, row3, row4, row5, row6, row7);\n\n\n\n        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,\n\n                          p1_or_q1_org, p0_or_q0_org,\n\n                          q0_or_p0_org, q1_or_p1_org);\n\n    }\n\n\n\n    alpha = (v16u8) __msa_fill_b(alpha_in);\n\n    beta = (v16u8) __msa_fill_b(beta_in);\n\n\n\n    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);\n\n    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);\n\n    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);\n\n\n\n    is_less_than_alpha = (p0_asub_q0 < alpha);\n\n    is_less_than_beta = (p1_asub_p0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than_alpha;\n\n    is_less_than_beta = (q1_asub_q0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than;\n\n\n\n    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);\n\n\n\n    if (!__msa_test_bz_v(is_less_than)) {\n\n        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);\n\n        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);\n\n        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);\n\n        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);\n\n\n\n        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);\n\n        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);\n\n\n\n        /* convert 16 bit output into 8 bit output */\n\n        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);\n\n        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);\n\n\n\n        p0_or_q0_org =\n\n            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);\n\n        q0_or_p0_org =\n\n            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);\n\n\n\n        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);\n\n\n\n        data_cb_or_cr -= 1;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 0);\n\n        out1 = __msa_copy_u_h(tmp1, 1);\n\n        out2 = __msa_copy_u_h(tmp1, 2);\n\n        out3 = __msa_copy_u_h(tmp1, 3);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n        data_cb_or_cr += img_width;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 4);\n\n        out1 = __msa_copy_u_h(tmp1, 5);\n\n        out2 = __msa_copy_u_h(tmp1, 6);\n\n        out3 = __msa_copy_u_h(tmp1, 7);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n    }\n\n}\n", "idx": 3452, "substitutes": {"data_cb_or_cr": ["data_cb_nor_cm", "data_cb_nor_cr", "data_cb_or_cm", "data_cb_orjCR", "data_cb_orjca", "data_cb_orjcr", "data_cb_orjcm", "data_cb_or_ca", "data_cb_nor_CR", "data_cb_or_cd", "data_cb_or_CR", "data_cb_nor_ca", "data_cb_or_Cr"], "alpha_in": ["alpha_ins", " alpha_ins", "pha_out", "alpha_out", "alpha_login", "pha_login", "pha_ins", "pha_in", " alpha_out", "alpha_bin", " alpha_bin"], "beta_in": ["beta_IN", "phi_in", "beta__inc", "phi_inc", " beta_internal", " beta_IN", "beta_internal", "beta_ins", "phiJstring", "beta_string", "phiJin", "beta_again", "beta_inc", "betaJinc", "beta__string", " beta_ins", "phiJinc", "phi_string", "beta__again", "betaJagain", "phiJagain", "betaJstring", "phi_again", "beta__in", "betaJin"], "img_width": ["image2count", "img_weight", "image2width", "img2name", "image_size", "img2Width", "image_name", "image2length", "image_width", "img_Width", "image_count", "imgallwidth", "imgfwidth", "imgalllength", "img2length", "img2weight", "image2name", "img_name", "image_length", "img2count", "img2width", "imgfcount", "imgflength", "img2size", "image_Width", "img_length", "img_size", "img_count", "imgfname", "image_weight", "imgallname", "imgallcount"], "out0": [" out5", "diff0", "diff2", "out5", "in5", "in0", "in2", "diff5"], "out1": [" out01", "block1", "in01", " out8", "out01", "in8", "out8", "block01", "in1", "block8"], "out2": ["input2", "out8", " out8", "input8", "in8", "in0", "in2", "input0"], "out3": ["output5", "input5", "inputThree", "inThree", "input03", "out5", "in3", "input3", "outputThree", "in03", "in5", "out03", "outThree", "output03", "output3"], "tmp1": ["tmp11", "proc11", "jp7", "proc1", "qq1", "tmp7", "jp1", "jpOne", "procOne", "jp11", "qq11", "qq7", "qqOne", "tmpOne", "proc7"], "alpha": ["A", "\u03b1", "lambda", "da", "extra", "a", "pha", "upper", "alias", "sa", "area", "acl", " Alpha", "Alpha", "data", "weight", "aa", "Beta", "ma", "margin", " gamma", "ta", "api", "i", "ac", "params", "ra", "average", "asc", "phi", "p", "ca", "la", "ana", "meta", "padding", "amp", "scale", "error", "mu", "init", "inc"], "beta": ["unit", "sub", "\u03b1", "lambda", "offset", "abi", "term", "extra", "ba", "una", "ii", "mega", "\u03b2", "binary", "aa", "Beta", "margin", "ta", "tmp", "output", "params", "negative", "pa", "phi", "bi", "gas", "balance", "lc", "padding", "bb", "fee", "qa", "b", "error", "uca", " \u03b2", "si"], "is_less_than": ["is_less___than", "is_less_per", "is_more_with", "is_less_with", "is_less___per", "is_more_than", "is_more_per", "is_less___with"], "p0_or_q0": ["p0_or_r90", "p0_or_p1", "p0_or_Q1", "p0_or_r0", "p0_or_r1", "p0_or_q1", "p0_or_Q0", "p0_or_Q90", "p0_or_p90", "p0_or_p0", "p0_or_q90"], "q0_or_p0": ["q0_or_P2", "q0_or_q2", "q0_or_w2", "q0_or_w5", "q0_or_q5", "q0_or_q1", "q0_or_P1", "q0_or_p1", "q0_or_P0", "q0_or_P5", "q0_or_w0", "q0_or_w1", "q0_or_p2", "q0_or_q0", "q0_or_p5"], "p1_or_q1_org": ["p1_or_q1_orb", "p1_or_q1sorg", "p1_or_q0_orb", "p1_or_q0_org", "p1_or_q1_reg", "p1_or_q0_com", "p1_or_q1_com", "p1_or_q0_reg", "p1_or_q1sorb", "p1_or_q1scom"], "p0_or_q0_org": ["p0_or_q0_or", "p0_or_q1_reg", "p0_or_q0rcom", "p0_or_q0_com", "p0_or_q1_org", "p0_or_q0rorg", "p0_or_q0_reg", "p0_or_q0rreg", "p0_or_q1_com", "p0_or_q1_or"], "q0_or_p0_org": ["q0_or_p0__or", "q0_or_p1_com", "q0_or_p0_reg", "q0_or_p0__org", "q0_or_p1_or", "q0_or_p0__reg", "q0_or_p1_reg", "q0_or_p0__com", "q0_or_p0_com", "q0_or_p0_orm", "q0_or_p1_orm", "q0_or_p0_or", "q0_or_p1_org"], "q1_or_p1_org": ["q1_or_p0_orb", "q1_or_p1_Org", "q1_or_p1_reg", "q1_or_p0_reg", "q1_or_p167Org", "q1_or_p167org", "q1_or_p167orb", "q1_or_p1_orb", "q1_or_p0_Org", "q1_or_p0_org"], "p0_asub_q0": ["p0_asub_r1", "p0_asub_p0", "p0_asub_pee", "p0_asub_p1", "p0_asub_qee", "p0_asub_q1", "p0_asub_q2", "p0_asub_fee", "p0_asub_Qee", "p0_asub_f1", "p0_asub_f2", "p0_asub_r0", "p0_asub_Q2", "p0_asub_r2", "p0_asub_p2", "p0_asub_ree", "p0_asub_f0", "p0_asub_Q1", "p0_asub_Q0"], "p1_asub_p0": ["p1_asub_ck", "p1_asub_q1", "p1_asub_p2", "p1_asub_q2", "p1_asub_q0", "p1_asub_P2", "p1_asub_P4", "p1_asub_p1", "p1_asub_c0", "p1_asub_qk", "p1_asub_q4", "p1_asub_c2", "p1_asub_P0", "p1_asub_pk", "p1_asub_p4", "p1_asub_Pk", "p1_asub_c1", "p1_asub_P1", "p1_asub_c4"], "q1_asub_q0": ["q1_asub_c0", "q1_asub_c1", "q1_asub_b00", "q1_asub_b1", "q1_asub_c00", "q1_asub_b4", "q1_asub_p0", "q1_asub_q1", "q1_asub_p4", "q1_asub_q00", "q1_asub_c4", "q1_asub_b0", "q1_asub_p00", "q1_asub_p1", "q1_asub_q4"], "is_less_than_alpha": ["is_less_than_Alpha", "is_less_than_inc"], "is_less_than_beta": ["is_less_than___alpha", "is_less_than_Beta", "is_less_than_0", "is_less_than___beta", "is_less_than___0", "is_less_than___Beta"], "p1_org_r": ["p1_org_rs", "p1_org_ru", "p1_or_or", "p1_or_rs", "p1_org_or", "p1_or_r", "p1_or_ru"], "p0_org_r": ["p0_org_rs", "p0_gov_rs", "p0_org_rb", "p0_org__rb", "p0_org__rs", "p0_gov_lr", "p0_org__r", "p0_org__lr", "p0_org_lr", "p0_gov_r", "p0_gov_rb"], "q0_org_r": ["q0_orgrictroot", "q0_or_root", "q0_or_r", "q0_orgiandr", "q0_orgrictr", "q0_orgrictdr", "q0_org_root", "q0_orgianroot", "q0_or_dr", "q0_orgianr", "q0_org_dr"], "q1_org_r": ["q1_or_r", "q1_org_rs", "q1_org_rb", "q1_org_nr", "q1_or_rb", "q1_or_nr", "q1_or_rs"], "row0": ["raw50", "row50", "roundE", "raw8", "col0", "col5", "rows0", "port80", "col80", "rowsE", "ow6", "row8", "ro0", "row000", "raw6", "rows000", "row80", "ow0", "rows2", " row8", "port0", "ow8", "round2", "rowE", "ro80", "ow50", "ro5", "port5", " row000", "round0", " rowE", "round000", " row50", "raw0"], "row1": ["rank100", "ow2", " row100", "row100", "r2", "r100", "ow1", "rows0", "rows11", "ow4", "rank1", "rows3", "ow11", "rows4", "ow0", "rows2", "ow3", "rank2", "rows1", "r5", "row11", "r1", " row11", "rank5"], "row2": ["rw2", "ow2", "block6", "rw3", "post1", "col5", "ow62", "ward2", "post4", "block3", "block4", "block2", "col1", "col2", "rw62", "rw5", "ow3", "block5", "row62", "post5", "block62", "ow5", "col4", "post2", "ward6", "ward5", "ward4"], "row3": ["row53", " row53", "port3", "row03", " row03", "view5", "ow1", "ow4", "view53", "raw5", "ow6", "ow03", "view4", "raw1", "raw6", "ow3", "raw3", "port03", "ow53", "view3", "ow5", "port5"], "row4": ["ow2", "ow7", "row44", "ow4", "ow6", "rows3", "raw44", "raw4", "raw6", "rows4", "rows2", "ow3", "raw3", " row44", "rows6", "raw7", "ow44"], "row5": ["row9", "raw2", " rowFive", "raw50", "ro50", "row50", "row56", " row56", "ro2", "rowFive", "ro6", "raw5", "roFive", "raw6", "post6", "raw3", "post5", "raw9", " row9", "ro56", "post3", "rawFive", "ro5", "ro9", " row50", "post2", "raw56"], "row6": ["ro12", "ry12", " row12", "row26", "post62", "ro86", "ow26", "ro6", "post4", "row86", "ow4", "ry86", "raw5", "ow6", "ry5", "ro26", "raw4", "raw6", "post6", "raw62", " row86", "row62", "post5", " row26", "ow5", "ro5", "ry6", "row12", " row62", "ro4"], "row7": [" row77", "ro8", "ry7", "ro77", "raw8", "row57", "raw57", "ro7", "row17", "raw73", "ow7", " row57", "row73", "row8", " row73", "raw4", "row77", "ow8", "ry4", "raw7", "raw17", "ro73", "ry17", " row17", "ow57", "ow77", "raw77", " row8", "ry77"]}}
{"project": "FFmpeg", "commit_id": "e15824e75b5549e53eb5c1ffb79766321ac8d122", "target": 1, "func": "int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                          AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                          const uint8_t *buf, int len, uint16_t seq, int flags)\n\n{\n\n    int sbit, ebit, gobn, mbap, quant;\n\n    int res;\n\n\n\n    //av_log(ctx, AV_LOG_DEBUG, \"got h261 RTP packet with time: %u\\n\", timestamp);\n\n\n\n    /* drop data of previous packets in case of non-continuous (loss) packet stream */\n\n    if (data->buf && data->timestamp != *timestamp) {\n\n        h261_free_dyn_buffer(&data->buf);\n\n    }\n\n\n\n    /* sanity check for size of input packet */\n\n    if (len < 5 /* 4 bytes header and 1 byte payload at least */) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short H.261 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n      decode the H.261 payload header according to section 4.1 of RFC 4587:\n\n      (uses 4 bytes between RTP header and H.261 stream per packet)\n\n\n\n         0                   1                   2                   3\n\n         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n\n           Start bit position (SBIT): 3 bits\n\n           End bit position (EBIT): 3 bits\n\n           INTRA-frame encoded data (I): 1 bit\n\n           Motion Vector flag (V): 1 bit\n\n           GOB number (GOBN): 4 bits\n\n           Macroblock address predictor (MBAP): 5 bits\n\n           Quantizer (QUANT): 5 bits\n\n           Horizontal motion vector data (HMVD): 5 bits\n\n           Vertical motion vector data (VMVD): 5 bits\n\n\n\n    */\n\n    sbit  =  (buf[0] >> 5) & 0x07;\n\n    ebit  =  (buf[0] >> 2) & 0x07;\n\n    gobn  =  (buf[1] >> 4) & 0x0f;\n\n    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01);\n\n    quant =  (buf[1] >> 4) & 0x0f;\n\n\n\n    /* pass the H.261 payload header and continue with the actual payload */\n\n    buf += RTP_H261_PAYLOAD_HEADER_SIZE;\n\n    len -= RTP_H261_PAYLOAD_HEADER_SIZE;\n\n\n\n    /* start frame buffering with new dynamic buffer */\n\n    if (!data->buf) {\n\n        /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */\n\n        if (!gobn  && !sbit && !mbap && !quant){\n\n            res = avio_open_dyn_buf(&data->buf);\n\n            if (res < 0)\n\n                return res;\n\n            /* update the timestamp in the frame packet with the one from the RTP packet */\n\n            data->timestamp = *timestamp;\n\n        } else {\n\n            /* frame not started yet, need more packets */\n\n            return AVERROR(EAGAIN);\n\n        }\n\n    }\n\n\n\n    /* do the \"byte merging\" at the boundaries of two consecutive frame fragments */\n\n    if (data->endbyte_bits || sbit) {\n\n        if (data->endbyte_bits == sbit) {\n\n            data->endbyte |= buf[0] & (0xff >> sbit);\n\n            data->endbyte_bits = 0;\n\n            buf++;\n\n            len--;\n\n            avio_w8(data->buf, data->endbyte);\n\n        } else {\n\n            /* ebit/sbit values inconsistent, assuming packet loss */\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, len*8 - ebit);\n\n            skip_bits(&gb, sbit);\n\n            if (data->endbyte_bits) {\n\n                data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits);\n\n                avio_w8(data->buf, data->endbyte);\n\n            }\n\n            while (get_bits_left(&gb) >= 8)\n\n                avio_w8(data->buf, get_bits(&gb, 8));\n\n            data->endbyte_bits = get_bits_left(&gb);\n\n            if (data->endbyte_bits)\n\n                data->endbyte = get_bits(&gb, data->endbyte_bits) <<\n\n                                (8 - data->endbyte_bits);\n\n            ebit = 0;\n\n            len = 0;\n\n        }\n\n    }\n\n    if (ebit) {\n\n        if (len > 0)\n\n            avio_write(data->buf, buf, len - 1);\n\n        data->endbyte_bits = 8 - ebit;\n\n        data->endbyte = buf[len - 1] & (0xff << ebit);\n\n    } else {\n\n        avio_write(data->buf, buf, len);\n\n    }\n\n\n\n    /* RTP marker bit means: last fragment of current frame was received;\n\n       otherwise, an additional fragment is needed for the current frame */\n\n    if (!(flags & RTP_FLAG_MARKER))\n\n        return AVERROR(EAGAIN);\n\n\n\n    /* write the completed last byte from the \"byte merging\" */\n\n    if (data->endbyte_bits)\n\n        avio_w8(data->buf, data->endbyte);\n\n    data->endbyte_bits = 0;\n\n\n\n    /* close frame buffering and create resulting A/V packet */\n\n    res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    return 0;\n\n}\n", "idx": 3456, "substitutes": {"ctx": ["cm", "cli", "cam", "hw", "conn", "context", "anc", "cc", "cl", "cpp", "loc", "aux", "bc", "buff", "tc", "cas", "ux", "fp", "tx", "cb", "pkg", "c", "cv", "xc", "lc", "ca", "ctrl", "sc", "jp", "exec", "cmd", "cca", "cp", "cmp", "cf", "conv", "ann", "rc"], "data": ["dr", "this", "after", "command", "current", "empty", "client", "first", "next", "event", "master", "database", "change", "alpha", "message", "DATA", "qa", "valid", "start", "map", "what", "da", "extra", "context", "image", "ui", "send", "parent", "end", "api", "batch", "off", "update", "fail", "model", "tx", "post", "p", "resource", "la", "lib", "final", "session", "wa", "val", "load", "response", "input", "media", "missing", "li", "new", "complete", "ad", "add", "proc", "body", "info", "slice", "last", "function", "result", "writer", "loader", "cache", "stream", "connection", "req", "error", "Data", "done", "server", "no", "def", "dd", "conn", "window", "d", "class", "results", "aa", "output", "pos", "style", "config", "reader", "exec", "al", "full", "view", "dat", "diff", "db", "rc"], "st": ["pl", "src", "rest", "ss", "sa", "ct", "sp", "St", "nt", "cr", "str", "sw", "stack", "ut", "sc", "ST", "std", "rd", "sts", "sta", "inst", "ost", "nd", "ast", "se", "pt", "sth"], "pkt": ["Pst", "apct", "apkt", "apacket", "apst", "pct", "pst", "packet", " packet", " pst", "Pkt", "Pct", " pct", "Packet"], "timestamp": ["tmeline", "tunetime", "timvision", "tmest", "Timeter", "timest", "stimetime", "imestamp", "impt", "timpt", "Timeness", "Timetime", "imity", "stimeness", "metetime", "dimension", "imeline", "metestamp", "stimestamp", "soundvision", "tuneter", "Timest", "imetime", "timeeline", "dimestamp", "Timvision", "Timeline", "imest", "dimest", "soundest", "timeestamp", "stimeter", "ramestamp", "imension", "timension", "timeter", "tmestamp", "soundestamp", "rameline", "timity", "soundeline", "dimeline", "metity", "metpt", "tmvision", "timeest", "timetime", "timeness", "tuneness", "Timestamp", "metest", "rampt", "timeline", "ramity", "timeension", "meteline", "tunestamp"], "buf": ["row", "Buff", "queue", "brace", "aux", "pb", "code", "home", "cv", "vec", "f", "hl", "uf", "socket", "path", "fi", "port", "ff", "utf", "bag", "context", "rw", "filename", "bc", "buff", "tmp", "cas", "off", "batch", "fab", "fp", "bus", "ptr", "length", "text", "la", "bu", "wave", "band", "mount", "bh", "ab", "loc", "cat", "bin", "ha", "loop", "lim", "proc", "cb", "pool", "func", "feat", "br", "ctr", "cap", "cmd", "alloc", "cf", "conv", "img", "uc", "pause", "fd", "src", "buffer", "header", "window", "orig", "cur", "ph", "fn", "rb", "comb", "box", "config", "bf", "block", "wb", "fb", "b", "hide", "fam", "db", "rc"], "len": ["pl", "base", "led", "fd", "li", "lan", "offset", "den", "fen", "split", "lp", "elt", "Len", "loc", "n", "lvl", "lf", "fl", "ln", "sl", "bin", "lang", "fn", "un", "nl", "bl", "lim", "pos", "body", "ll", "fp", "nt", "rev", "z", "lon", "l", "fin", "lc", "length", "size", " length", "la", "el", "min", "win", "en", "il", "hl", "lin", "gen", "line", "lit", "count", "val", "limit", "list", "part"], "seq": [" queue", " id", " code", " dup", " cas", " sequence", " pri", " cur", " ref", " count", " sent", " ret", " prev", " aux", " resp", " cmd", " num", " reply", " disp", " pos", " cipher", " fin", " req", " leng", " sup", " serial", " ecc", " rc"], "flags": ["ret", "fd", "days", "cs", "Flags", "vals", "lvl", "format", "fn", "frame", "fps", "options", "frames", "bits", "ents", "ats", "flag", "features", "rows", "mask", "fields", "bytes", "count", "fs", " bits", "rc"], "sbit": ["wsbit", "sunit", "sbyte", "wsBIT", "sesbyte", "cstag", "symbin", "ssBIT", "stag", "Sbyte", "sBIT", " sunit", "Sbit", " sct", "tsbyte", "sescol", "ssbits", "SBIT", " stag", "sbin", "symBIT", "wsunit", "sesbug", "ssboot", "wsct", "tsbit", "sbits", "csBIT", " sbug", "symbyte", "sct", "scol", " sbits", "obsbit", "gscol", "wsbits", "sesbit", "ssbyte", "csbit", "gsbug", "ssbit", "wstag", "tsct", "symbit", "tstag", "wsbyte", "Sbin", "sbug", "sboot", "obsboot", "ssbin", "Sboot", "csunit", "Sbits", " scol", "obsbyte", "gsbyte", "obsBIT", "gsbit", " sbyte", " sBIT"], "ebit": ["abbitted", "zebith", "eksith", "ambid", " ebitter", "eksit", "abbit", "debid", "debits", "ambit", "ebiter", "ellid", "obit", "obith", "ambill", "obitted", "zebitting", "eksitter", "abbiter", "zebitter", "abbith", "herit", "obiter", "ellill", "zebit", "ebith", "ellit", "ebitted", "ebitting", "eksitting", "debit", "ebid", "heritted", "ebitter", "ambits", " ebitting", "ebits", "ellits", " ebith", "debill", "ebill", "heriter", "herith"], "gobn": ["ubbnp", "bubn", "gorn", " gobnp", "gorner", "bubnet", " gobb", "gobnt", " gobner", "gobna", " gobna", "gorc", " gobns", "gown", "ubbn", "gobc", "gownp", "gownt", "bubne", "gobns", "gobner", "gowc", " gobc", "gobb", "gowne", "gobnet", "bubnt", "gowns", "gowb", "ubbns", "gobne", "gobnp", " gobnt", "gowna", " gobnet", "ubbb", "gorna", "gownet", "gowner", " gobne"], "mbap": ["MBash", "bgaps", "ambapt", "mbak", "ebAP", "ebapt", "mdap", "pgak", "bgash", "mbash", "pgaps", "mbapt", "pgap", "mdapt", "ambap", "ebapper", "mbaps", "megAP", "megap", "megaps", "MBaps", "ebash", "ambAP", "mbAP", "pgAP", "megak", "mbapper", "mdapper", "MBap", "ebap", "MBak", "bgAP", "ambapper", "mdAP", "bgap", "ebaps", "MBAP"], "quant": ["serial", "cost", "quiet", "q", "quad", "spec", "context", "charge", "requ", "cur", "priv", "query", "compl", "gap", "comp", "iq", "neutral", "frac", "secure", "bug", "util", "ident", "pub", "progress", "pkg", "pad", "eq", "Quant", "dev", "random", "forced", "private", "patch", "sq", "cmd", "comment", "quality", "qa", "qi", "supp", "qual", "final", "sim", "quick", "tax", "qt", "inc", "complex", "qq", "multipl", "qua", "qu"], "res": ["nos", "ret", "resolution", " results", "js", "cs", "rest", "rs", "vals", "ries", "r", "Res", "ver", "results", "ms", "cons", "rys", "arr", "RES", "num", "pres", "des", "rep", "runs", " result", "details", "ris", "err", "ras", "rev", "ps", "errors", "ns", "result", " r", "vs", "reset", "ches", "es", "rem", "rows", "ress", "resp", "rss", "req", "os", "bytes", "re", "reg", "val", "count", "msg", "resh", "rh", "rc"], "gb": [" mode", "sg", " img", "rg", " gcc", " db", " bi", "gram", " bin", "ba", "kb", "ga", " g", "bo", "sb", "nn", "bm", "ui", "hub", " storage", " src", "gy", "gh", "di", " addr", "bc", " eg", "sl", "gow", "bin", " kb", " py", "GB", "gin", "g", "gg", "rb", "gm", "gn", " rgb", "gam", "gs", " rg", "gu", "nb", "Gb", "gd", "git", "gt", "bg", "ki", "pc", "bb", " GB", " gl", "lib", "ubs", "abb", "ci", "cfg", " gy", "gp", " rc", "db"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int vdpau_mpeg_start_frame(AVCodecContext *avctx,\n\n                                  const uint8_t *buffer, uint32_t size)\n\n{\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    Picture *pic             = s->current_picture_ptr;\n\n    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;\n\n    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;\n\n    VdpVideoSurface ref;\n\n    int i;\n\n\n\n    /* fill VdpPictureInfoMPEG1Or2 struct */\n\n    info->forward_reference  = VDP_INVALID_HANDLE;\n\n    info->backward_reference = VDP_INVALID_HANDLE;\n\n\n\n    switch (s->pict_type) {\n\n    case AV_PICTURE_TYPE_B:\n\n        ref = ff_vdpau_get_surface_id(&s->next_picture.f);\n\n        assert(ref != VDP_INVALID_HANDLE);\n\n        info->backward_reference = ref;\n\n        /* fall through to forward prediction */\n\n    case AV_PICTURE_TYPE_P:\n\n        ref = ff_vdpau_get_surface_id(&s->last_picture.f);\n\n        info->forward_reference  = ref;\n\n    }\n\n\n\n    info->slice_count                = 0;\n\n    info->picture_structure          = s->picture_structure;\n\n    info->picture_coding_type        = s->pict_type;\n\n    info->intra_dc_precision         = s->intra_dc_precision;\n\n    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;\n\n    info->concealment_motion_vectors = s->concealment_motion_vectors;\n\n    info->intra_vlc_format           = s->intra_vlc_format;\n\n    info->alternate_scan             = s->alternate_scan;\n\n    info->q_scale_type               = s->q_scale_type;\n\n    info->top_field_first            = s->top_field_first;\n\n    // Both for MPEG-1 only, zero for MPEG-2:\n\n    info->full_pel_forward_vector    = s->full_pel[0];\n\n    info->full_pel_backward_vector   = s->full_pel[1];\n\n    // For MPEG-1 fill both horizontal & vertical:\n\n    info->f_code[0][0]               = s->mpeg_f_code[0][0];\n\n    info->f_code[0][1]               = s->mpeg_f_code[0][1];\n\n    info->f_code[1][0]               = s->mpeg_f_code[1][0];\n\n    info->f_code[1][1]               = s->mpeg_f_code[1][1];\n\n    for (i = 0; i < 64; ++i) {\n\n        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];\n\n        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];\n\n    }\n\n\n\n    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);\n\n}\n", "idx": 3460, "substitutes": {"avctx": ["AVctx", "ajctx", "avectx", "navctx", "avconv", "AVkw", "augc", "avgc", "avekw", "auctx", "AVgc", "avegc", "AVctl", "ajconv", "navcontext", "avkw", "navctl", "avctl", "aukw", "avcontext", "aucontext", "navconv", "AVconv", "avecontext", "ajctl", "AVcontext", "ajcontext"], "buffer": ["media", "uffer", "queue", "memory", "image", "filename", "audio", "data", "window", "picture", "buff", "buf", "seed", "file", "source", "document", "reader", "Buffer", "length", "ram", "text", "message", "stream", "comment", "uf", "transfer", "input", "port"], "size": ["SIZE", " window", "ize", "large", "data", "image", " storage", " sizes", " limit", "buf", "g", " Size", "file", " encoding", " bytes", "length", " length", "Size", "izes", "scale", " source", "shape", " resize"], "s": ["sg", "js", "this", "qs", "sa", "n", "sites", "g", "ses", "ls", "args", "sf", "storage", "us", "f", "set", "sys", "sc", "sum", "fs", "parts", "sup", "stat", "spec", "ts", "sb", "api", "y", "sv", "request", "sets", "p", "e", "conf", "as", "su", "S", "t", "session", "os", "ks", "its", "hs", "ages", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ions", "bis", "space", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "setup", "es", "o", "si", "server", "service", "http", "ops", "d", "comments", "params", "details", "sync", "source", "irs", "l", "services", "soc", "sq", "stats", "b", "full", "states"], "pic": ["fc", "sac", "cam", "ctx", "Pic", "fs", "spec", "sa", "mc", "data", "image", "pi", "mini", "picture", "bc", "cci", "nic", "study", "cus", "enc", "mac", "ac", "photo", "fp", "file", "config", "fe", "pict", "c", "p", "doc", "lc", "f", "sys", "pins", "sec", "pc", "ic", "img", "fi", "pin"], "pic_ctx": ["pic_context", "pic__context", "pic__ctx", "picture_ctrl", "picture_loc", "picjctx", "picture_ct", "pic__ci", "pic_ct", "picjci", "picture_ctx", "pic_ctrl", "pic_ci", "pic__ctrl", "picture_ci", "picjctrl", "pic_loc", "picture_context", "picjcontext"], "info": ["key", "success", "audio", "get", "from", "options", "event", "index", "home", "archive", "information", "f", "message", "gui", "summary", "comment", "manager", "by", "af", "start", "ami", "tf", "name", "abi", "ext", "time", "extra", "image", "ui", "type", "help", "id", "buff", "end", "Info", "frame", "api", "off", "update", "p", "conf", "text", "meta", "init", "user", "guide", "offset", "INFO", "ii", "fw", "data", "new", "di", "is", "op", "py", "inner", "slice", "json", "result", "afi", "iso", "app", "note", "about", "error", "img", "si", "inf", "fo", "http", "gi", "def", "alias", "follow", "show", "num", "style", "source", "config", "feature", "ip", "thin", "notice", "full", "part", "diff", "metadata", "desc"], "ref": ["ob", "base", "href", "fact", " reference", "src", "offset", "name", "inter", "def", " pointer", "ab", "url", " references", "loc", "type", "alt", "rec", " pref", "id", "parent", "frame", "remote", "num", "pre", " referenced", "instance", "ef", "rev", "source", "REF", "index", "pointer", "config", "fe", "bf", "address", "result", "Ref", "ind", "p", "aff", "f", "col", "cache", "conf", "reference", "object", "resp", "obj", "comment", "rel", "prefix", "b", "cmp", "req", "af", "re", "reg", "count", "part", "fi", "diff", "inf", "rc"], "i": ["li", "a", "ii", "pi", "image", "I", "di", "is", "mi", "it", "iu", "j", "m", "ti", "ip", "l", "c", "p", "e", "f", "o", "v", "b", "t", "ci", "fi", "si"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_decode_init_vlc(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, \n\n                 intra_MCBPC_bits, 1, 1,\n\n                 intra_MCBPC_code, 1, 1);\n\n        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, \n\n                 inter_MCBPC_bits, 1, 1,\n\n                 inter_MCBPC_code, 1, 1);\n\n        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,\n\n                 &cbpy_tab[0][1], 2, 1,\n\n                 &cbpy_tab[0][0], 2, 1);\n\n        init_vlc(&mv_vlc, MV_VLC_BITS, 33,\n\n                 &mvtab[0][1], 2, 1,\n\n                 &mvtab[0][0], 2, 1);\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rvlc_rl_inter);\n\n        init_rl(&rvlc_rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        init_vlc_rl(&rl_inter);\n\n        init_vlc_rl(&rl_intra);\n\n        init_vlc_rl(&rvlc_rl_inter);\n\n        init_vlc_rl(&rvlc_rl_intra);\n\n        init_vlc_rl(&rl_intra_aic);\n\n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_lum[0][1], 2, 1,\n\n                 &DCtab_lum[0][0], 2, 1);\n\n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_chrom[0][1], 2, 1,\n\n                 &DCtab_chrom[0][0], 2, 1);\n\n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n\n                 &sprite_trajectory_tab[0][1], 4, 2,\n\n                 &sprite_trajectory_tab[0][0], 4, 2);\n\n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n\n                 &mb_type_b_tab[0][1], 2, 1,\n\n                 &mb_type_b_tab[0][0], 2, 1);\n\n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n\n                 &h263_mbtype_b_tab[0][0], 2, 1);\n\n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n\n                 &cbpc_b_tab[0][1], 2, 1,\n\n                 &cbpc_b_tab[0][0], 2, 1);\n\n    }\n\n}\n", "idx": 3476, "substitutes": {"s": ["sg", "js", "cs", "ss", "qs", "is", "ms", "g", "params", "m", "ses", "sf", "sets", "gs", "ns", "c", "p", "services", "e", "f", "sys", "sq", "S", "session", "fs", "si", "ssl"]}}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 3484, "substitutes": {"opaque": ["opacity", "opaques", "OPacity", "phpaque", "oppaques", "oppac", "compacity", "ipaques", "opac", "phpque", "phpaques", "OPac", "copaques", "oppaque", "compque", "copque", "OPaques", "ipaque", "copacity", "compaques", "oppacity", "compaque", "OPaque", "phpacity", "ipac", "ipacity", "copaque", "opque"], "offset": ["base", "buffer", "skip", "array", "data", "position", "slot", "type", "empty", "timeout", "parent", "off", "initial", "i", "pos", "fp", "args", "number", "slice", "index", "pointer", "address", "pad", "p", "shift", "et", "ptr", "set", "length", "len", "reset", "f", "reference", "range", "padding", "o", "at", "sn", "Offset", "error", "location", "addr", "start"], "size": ["SIZE", "ize", "data", " sizes", "type", " address", "args", "address", "c", "shift", "e", "set", "length", "len", " length", "Size", "fee", "bytes", "count", "timeout"], "s": ["service", "opens", "abi", "ss", "ops", "spec", "sa", "ts", "rs", "sb", "ips", "aws", "is", "sl", "scope", "ls", "ses", "args", "uns", "sync", "settings", "ds", "sets", "ps", "gs", "ns", "c", "p", "sie", "services", "e", "self", "es", "secondary", "sys", "sq", "S", "os", "session", "socket", "se", "si", "sym", "ssl"], "n": ["name", "no", "dn", "ni", "nn", "out", "d", "nc", "k", "un", "fn", "ne", "nl", "num", "na", "y", "j", "i", "g", "pos", "m", "nr", "nt", "number", "z", "ns", "x", "N", "c", "p", "l", "w", "e", "nb", "f", "len", "u", "min", "en", "o", "sn", "nm", "v", "b", "t", " N"]}}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    \n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    skip_bits(&s->gb, 4);\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        s->has_b_frames = 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        mpeg1_init_vlc(s);\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n", "idx": 3499, "substitutes": {"avctx": ["apconnection", "ajctx", "afsq", "afcontext", "mpctx", "mpcontext", "awcf", "afloc", "avcontext", " avconnection", "aveloc", "afxc", "apcmp", "avconnection", "awtx", "aveconfig", "afcmp", "AVcontext", "avecu", " avconn", "mpconfig", "avectx", "afctx", "aveconn", "aptx", "afconnection", "avcf", "afconn", "airsq", "ajconfig", "mpcu", "avcb", "abcf", "avconfig", "abcontext", "airsys", "awctx", "AVtx", "evctx", "evcontext", "abtx", "avxc", "avtx", "AVcb", "abloc", "aftx", "aircontext", "apcontext", "AVconfig", "abctx", "afcu", "afcf", "afsys", "evconn", "avsq", "ajcontext", "apconn", "afconfig", "AVctx", " avxc", "avconn", "AVconn", " avcontext", "avexc", "aircmp", "ajcb", "evsys", "awcontext", "avsys", "apctx", "avloc", "airconn", "abconn", "avecontext", "apsq", "avcu", "avcmp", "afcb", "airctx"], "buf": ["ff", "fd", "src", "buffer", "ctx", "byte", "queue", "mem", "data", "ab", "bc", "buff", "pb", "num", "batch", "max", "rb", "proc", "fp", "cb", "raw", "c", "block", "cv", "Buffer", "vec", "nb", "wb", "ref", "br", "gb", "cmd", "alloc", "seq", "fb", "b", "conv", "uf", "img", "rc", "port"], "buf_size": ["buf_source", "buflexsize", "cmd_size", "path_chan", "buflexspeed", "cmdlexspeed", "pathamsize", "buf_SIZE", "bufamsize", "bufamsource", "cmd_speed", "buf_chan", "path_size", "pathamchan", "bufamSIZE", "buflexSIZE", "pathamSIZE", "cmdlexsize", "path_source", "cmd_SIZE", "pathamsource", "buf_speed", "path_SIZE", "bufamchan", "cmdlexSIZE"], "s1": ["shareOne", " s_", "s0", " s0", " sOne", "sesOne", "s01", "share01", "share1", "sh1", "Sons", "ps2", "ses1", "ses01", "SOne", "shOne", "args2", "shons", "ses_", "s2", " s2", "ps1", "sOne", "share_", "c001", "c1", "s_", " s001", "sons", "args0", "kons", " s01", "S1", "ss2", "c2", "c0", "s001", "args1", "kOne", "ssOne", "args001", "psOne", "k1", "ss1"], "s": ["sg", "js", "this", "qs", "sa", "n", "sl", "g", "ses", "ls", "args", "x", "vs", "us", "self", "f", "sys", "u", "an", "your", "se", "fs", "parts", "spec", "ts", "sb", "aws", "y", "xs", "request", "sets", "p", "e", "conf", "as", "serv", "su", "S", "t", "ks", "os", "session", "site", "bs", "its", "in", "sym", "plugins", "ssl", "cs", "ctx", "ss", "rs", "a", "new", "r", "is", "ins", "settings", "ds", "ps", "gs", "ns", "h", "c", "words", "es", "south", "sec", "o", "si", "server", "service", "http", "ops", "d", "ms", "params", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "height": ["resolution", "capacity", "dim", "stroke", "ty", "lat", "direction", "images", "quality", "arrow", "hang", "rh", "ows", "Height", "port", "we", "host", "image", "ht", "id", "html", "gap", "y", "max", "dom", "gallery", "work", "layout", "length", "inches", "wa", "huge", "bottom", "gh", "family", "crop", "build", "above", "tight", "data", "fw", "wrap", "slice", "han", "h", "pad", "deep", "rank", "size", "rows", "history", "definition", "img", "volume", "shape", "timeout", "gpu", "def", "high", "window", "d", "distance", "th", "grow", "duration", "iii", "dy", "hung", "style", " heights", "ip", "thin", "w", "density", "range", "padding", "container", "depth"], "i": ["yi", "ami", "li", "gi", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "r", "d", "n", "I", "di", "mi", "uli", "k", "iu", "g", "y", "m", "eni", "ti", "ini", "index", "z", "ani", "multi", "ai", "ie", "x", "h", "l", "p", "c", "phi", "w", "e", "bi", "f", "u", "ip", "ori", "b", "vi", "ix", "qi", "t", "ci", "io", "fi", "si", "in", "xi"], "v": ["q", "volt", "ii", "d", "n", "av", "k", "y", "g", "m", "ve", "sv", "z", "vv", "x", "l", "h", "p", "c", "vs", "w", "e", "f", "u", "uv", "V", "b", "vi", "lv", "tv", "val", "si"], "j": ["js", "li", "q", "ii", "ji", "jit", "r", "d", "n", "jj", "J", "k", "aj", "ij", "uj", "y", "g", "max", "m", "z", "x", "h", "l", "p", "c", "jc", "w", "f", "u", "jp", "dj", "o", "b", "si"]}}
{"project": "FFmpeg", "commit_id": "d600b18f224e02f8bfc6660bfa442e7ff3fb057c", "target": 1, "func": "void ff_rfps_calculate(AVFormatContext *ic)\n{\n    int i, j;\n    for (i = 0; i<ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n        // the check for tb_unreliable() is not completely correct, since this is not about handling\n        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.\n        // ipmovie.c produces.\n        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);\n        if (st->info->duration_count>1 && !st->r_frame_rate.num\n            && tb_unreliable(st->codec)) {\n            int num = 0;\n            double best_error= 0.01;\n            for (j=0; j<MAX_STD_TIMEBASES; j++) {\n                int k;\n                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))\n                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))\n                for(k=0; k<2; k++){\n                    int n= st->info->duration_count;\n                    double a= st->info->duration_error[k][0][j] / n;\n                    double error= st->info->duration_error[k][1][j]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(j);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, \"rfps: %f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))\n                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&st->info->duration_error);\n        st->info->last_dts = AV_NOPTS_VALUE;\n        st->info->duration_count = 0;\n        st->info->rfps_duration_sum = 0;\n    }\n}", "idx": 3502, "substitutes": {"ic": ["fc", "cm", "icer", "lic", "cli", "ics", "isc", "acs", "cs", "ctx", "anc", "cc", "mic", "IC", "icing", "ct", "aic", "bc", "iac", "cci", "tc", "ict", "enc", "irc", "ac", "aci", "ec", "dc", "cu", "c", "lc", "oc", "exec", "vc", "sn", "cit", "pc", "icc", "ix", "ik", "pic", "ici", "ci", "sci"], "i": ["yi", "ami", "li", "gi", "ih", "ni", "ii", "zi", "chi", "ji", "ui", "oi", "pi", "r", "d", "I", "n", "di", "is", "id", "mi", "im", "iu", "ij", "y", "m", "eni", "ri", "ti", "ini", "index", "ai", "ie", "x", "ind", "l", "p", "ip", "c", "hi", "e", "f", "u", "ori", "o", "ki", "v", "qi", "ix", "ik", "ci", "io", "fi", "si", "in", "xi"], "j": ["js", "q", "key", "jen", "n", "oj", "job", "ij", "g", "ijk", "x", "pr", "f", "jing", "u", "jp", "jet", "s", "syn", "ja", "time", "ji", "end", "y", "z", "p", "length", "jam", "java", "v", "li", "jl", "ii", "jit", "mpeg", "r", "J", "section", "aj", "uj", "m", "bj", "json", "c", "je", "stream", "note", "dj", "o", "times", "jon", "jan", "_", "adj", "d", "jj", "num", "pos", "jo", "kj", "fr", "l", "jc", "b", "xi"], "st": ["stage", "pl", "ist", "ust", "this", "ld", "src", "rest", "ss", "mt", "stat", "sa", "ts", "sd", "sb", "pe", "cl", "data", "r", "d", "ct", "sp", "sl", "sh", "end", "sk", "client", "St", "bl", "ste", "kt", "sf", "lt", "ft", "nt", "style", "dest", "str", "dt", "sv", "fr", "step", "trans", "l", "c", "sw", "et", "ut", "stack", "lc", "start", "sc", "ST", "std", "tt", "sn", "sts", "play", "sta", "inst", "t", "stop", "td", "nd", "ost", "pt", "ast", "ace", "sth", "est"], "k": ["ek", "uk", "q", "kick", "key", "a", "ke", "km", "r", "d", "n", "ck", "id", "K", "sk", "ko", "kr", "y", "dk", "g", "kin", "ka", "ok", "mk", "kw", "ky", "z", "kn", "work", "kid", "p", "c", "e", "f", "ak", "u", "ku", "kk", "ki", "v", "pull", "o", "ik", "ks", "kat", "kh"]}}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n", "idx": 3513, "substitutes": {"s": ["sg", "js", "cs", "groups", "ss", "ops", "rs", "sb", "r", "com", "d", "n", "i", "m", "ses", "sf", "sync", "settings", "sv", "tests", "sets", "gs", "ns", "h", "c", "p", "services", "w", "e", "f", "secondary", "es", "sys", "sq", "u", "sec", "o", "stats", "b", "S", "os", "t", "session", "ssl"], "reg": ["rg", "ret", "urg", "arg", "ig", "sg", "isc", "REG", "stat", "roc", "rs", "conn", "spec", "gc", "gr", "mod", "r", "loc", "tag", "report", "rec", "grad", "eng", "num", "j", "g", "proc", "tr", "config", "eg", "or", "c", "registered", "org", "rem", "sc", "gb", "core", "exec", "sec", "region", "pc", "asm", "thread", "sign", "inst", "Reg", "re", "debug", "acc", "res", "rc", "mem"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->sps.direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 3517, "substitutes": {"h": ["H", "http", "bh", "q", "ih", "hw", "cl", "host", "ht", "sh", "ph", "ha", "g", "hr", "ah", "ch", "hm", "l", "hi", "hh", "c", "p", "w", "self", "e", "f", "eh", "hp", "u", "history", "handler", "v", "hl", "s", "t", "he", "hs", "oh", "rh", "gh"], "sl": ["pl", "ell", "li", "sch", "spl", "bh", "ul", "split", "sa", "sb", "acl", "cl", "oper", "ml", "sil", "flo", "loc", "isl", "zh", "dl", "fl", "sh", "pg", "ln", "wl", "lr", "sk", "nl", "bl", "ls", "ll", "sf", "util", "slice", "kel", "sel", "tl", "l", "SL", "c", "sw", "lc", "rl", "kl", "f", "sc", "la", "el", "hel", "il", "sn", "s", "hl", "cel", "sm", "gl", "su", "t", "serv", "lit", "se", "Sl", "si", "ssl"], "mb_type": ["mb_family", "MB_types", "mb_length", "mb_id", "mb_types", "db_family", "mbqtype", "db_TYPE", "db_id", "MB_type", "mbqtypes", "mb_size", "MB_id", "mn_TYPE", "mn_type", "mbqlength", "MB_length", "mn_size", "db_type", "mbqid", "mb_TYPE"], "mb_type_col": ["mb_type_row", "mb_types_column", "mb_type_type", "mb_types_type", "mb_types_row", "mb_type_column", "mb_types_col"], "l1mv0": ["l1mx0", "l1cmv1", "l1cmw2", "l1mv2", "l1mh1", "l1cmw6", "l1mx1", "l1cmv2", "l1mx2", "l1cmv6", "l1mw6", "l1mw2", "l1cmv0", "l1cmw1", "l1mv6", "l1mx6", "l1mw0", "l1mw1", "l1cmw0", "l1mh0", "l1mh6", "l1mh2"], "l1mv1": ["l1mb0", "l1mh1", "l1dh3", "l1dv3", "l1dv0", "l1mb1", "l1mw3", "l1mh3", "l1dh1", "l1dv1", "l1mw0", "l1mw1", "l1mh0", "l1dh0", "l1mv3", "l1mb3"], "l1ref0": ["l1reference1", "l1p1", "l1ref4", "l_ref0", "l1p2", "l_ref4", "l_ref1", "l_reference0", "l1Ref4", "l_ref2", "l_reference2", "l1p4", "l1reference4", "l_reference1", "l1Ref0", "l1reference2", "l1Ref2", "l1reference0", "l1ref2", "l1Ref1", "l1p0", "l_reference4"], "l1ref1": ["l1ref8", "l1reference1", "l1arc1", "l2f1", "l1f1", "l2ref1", "l1arc8", "l2f8", "l1reference8", "l2ref8", "l1f8"], "i8": ["m10", "p6", "i10", "u16", "p10", "m16", "i16", "u8", "p8", "p16", "u6", "m8", "m6", "u10", "i6"], "i4": [" i6", "i64", "l8", "l4", "l6", "l64", "int8", "int64", " i64", "int6", "int4", "i6"], "ref": ["call", "base", "null", "arg", "row", " reference", "buffer", "cal", "def", "inter", "rec", "id", "num", "comp", "pre", "pos", "ef", "info", "index", "REF", "pointer", "config", "Ref", "block", "p", "aff", "arc", "f", "col", "cache", "conf", "reference", "range", "comment", "rel", "val", "count", "all", "diff", "input", "rc"], "mv": ["bmj", " mj", "bmvp", "mvp", "pmvp", "pmv", " mvp", "pmj", "pmq", "bmv", " mq", "bmq", "mj", "mq"], "list": ["cli", "act", "rest", "ul", "key", "large", "queue", "com", "like", "g", "code", "index", "self", "diff", "set", "child", "comment", "seq", "all", "map", "pl", "group", "name", "cl", "LIST", "type", "id", "chain", "parent", "arr", "pair", "batch", "bl", "hold", "LI", "p", "lc", "e", "conf", "la", "lists", "listed", "count", "List", "load", "base", "li", "complete", "out", "cat", "record", "loop", "member", "pre", "i", "cont", "str", "pool", "feat", "len", "cache", "gl", "old", "module", "low", "CL", "call", "see", "test", "null", "server", "comp", "entry", "coll", "sync", "source", "ch", "config", "l", "block", "L", "stack", "pull", "full", "view", "que", "table"], "C": ["H", "O", "JC", "DC", "G", "CM", "FC", "U", "LC", "M", "CA", "I", "K", "F", "W", "VC", "P", "EC", "N", "c", "L", "E", "CR", "V", "R", "T", "S", "D", "CL"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,\n\n        unsigned size)\n\n{\n\n    GemState *s = (GemState *)opaque;\n\n    uint32_t readonly;\n\n\n\n    DB_PRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val);\n\n    offset >>= 2;\n\n\n\n    /* Squash bits which are read only in write value */\n\n    val &= ~(s->regs_ro[offset]);\n\n    /* Preserve (only) bits which are read only in register */\n\n    readonly = s->regs[offset];\n\n    readonly &= s->regs_ro[offset];\n\n\n\n    /* Squash bits which are write 1 to clear */\n\n    val &= ~(s->regs_w1c[offset] & val);\n\n\n\n    /* Copy register write to backing store */\n\n    s->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n", "idx": 3521, "substitutes": {"opaque": ["opacity", "OPacity", "Opesc", "opoch", "OPesc", "operaque", " opoch", " opacity", "OPque", "ipaque", "ipque", "Opque", "operoch", "opesc", "OPaque", "operacity", "Opacity", "Opoch", "ipacity", "Opaque", "ipesc", "opque"], "offset": ["rot", "url", "next", "code", "index", "pointer", "address", "aligned", "set", "reset", "f", "article", "fee", "seq", "optional", "location", "course", "start", "option", "port", "image", "align", "position", "slot", "type", "parent", "off", "fp", "disabled", "ptr", "hop", "length", "site", "layer", "base", "outer", "skip", "required", "loc", "axis", "slice", "enabled", "role", "et", "order", "len", "ref", "attr", "value", "alloc", "o", "phase", "prefix", "error", "online", "mode", "slave", "adjusted", "timeout", "oa", "server", "append", "bit", "alias", "operation", "num", "initial", "seed", "pos", "attribute", "range", "padding", "Offset", "sort", "addr", "part"], "val": ["rot", "ret", "vol", "arg", "cal", "key", "dim", "vl", "alt", "sl", "bal", "x", "pr", "eval", "fee", "seq", "valid", "fi", "unit", "pl", "ol", "local", "split", "stat", "vals", "sil", "slot", "vert", "buf", "bl", "pass", "update", "fail", "lt", "tx", "sol", "p", "v", "serv", "lit", "count", "pt", "base", "Value", "byte", "data", "ee", "loc", "pre", "nil", "ve", "live", "aval", "sel", "role", "ut", "len", "ref", "el", "value", "fx", "reg", "VAL", "lo", "mem", "isal", "test", "buffer", "bit", "elt", "pol", "Val", "fl", "prop", "pos", "block", "pret", "pal", "ival", "il", "b", "al", "part"], "size": [" af", " slot", " len", "vals", " pri", " overflow", " count", " error", " ret", " address", " flag", " fl", "pos", " index", " delta", " align", " pos", "len", " el", " length", " mem", " flags", "ival"], "s": ["sg", "submit", "js", "n", "sites", "sl", "client", "g", "ses", "ls", "sf", "sie", "self", "private", "f", "secondary", "set", "sys", "u", "your", "se", "fs", "spec", "ts", "sb", "aws", "y", "uns", "sets", "p", "state", "e", "conf", "su", "site", "S", "t", "session", "ks", "os", "bs", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "i", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "http", "d", "scope", "sis", "comments", "sync", "l", "services", "sq", "b", "states"], "readonly": ["loadOnly", "weakOnly", "writalone", "weakall", " readlocked", "ReadOnly", "writonly", " readOnly", "Readforce", "Readalone", "rideOnly", "readlocked", "loadsafe", "readall", "writOnly", "readOnly", "bitOnly", "loadall", "ridesafe", " readsafe", "bitforce", "Readonly", "weightOnly", "readsafe", "readforce", "loadonly", "fullocked", "readjust", "weightlocked", " readall", "bitonly", "rideonly", "weightjust", "fuljust", "fulonly", "fulOnly", "weakonly", "Readall", "readalone", " readjust", "rideall", "weakalone", "weightonly", " readforce", "writall"], "phy_addr": ["phy___node", "py_name", "py_offset", "phy_offset", "phy_ptr", "phy___offset", "phy_node", "py_addr", "py_ptr", "phy_kn", "py_address", "phy_address", "py_node", "phy67addr", "phy___addr", "phy___address", "py_kn", "phy67address", "phy_prefix", "phy_name", "py_prefix", "phy67offset", "phy67node"], "reg_num": ["REG_number", "reg_orig", "reg_no", "REG_no", "REG_orig", "reg2number", "reg_number", "reg2num", "reg2orig", "reg2no", "REG_num"]}}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "void cpu_loop(CPUMIPSState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr, ret;\n\n    unsigned int syscall_num;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_mips_exec(env);\n\n        switch(trapnr) {\n\n        case EXCP_SYSCALL:\n\n            syscall_num = env->active_tc.gpr[2] - 4000;\n\n            env->active_tc.PC += 4;\n\n            if (syscall_num >= sizeof(mips_syscall_args)) {\n\n                ret = -ENOSYS;\n\n            } else {\n\n                int nb_args;\n\n                abi_ulong sp_reg;\n\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n\n\n\n                nb_args = mips_syscall_args[syscall_num];\n\n                sp_reg = env->active_tc.gpr[29];\n\n                switch (nb_args) {\n\n                /* these arguments are taken from the stack */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                case 8: get_user_ual(arg8, sp_reg + 28);\n\n                case 7: get_user_ual(arg7, sp_reg + 24);\n\n                case 6: get_user_ual(arg6, sp_reg + 20);\n\n                case 5: get_user_ual(arg5, sp_reg + 16);\n\n                default:\n\n\n\n                ret = do_syscall(env, env->active_tc.gpr[2],\n\n                                 env->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n", "idx": 3540, "substitutes": {"env": ["eu", "queue", "txt", "nc", "enc", "args", "sf", "er", "event", "ec", "eye", "eve", "dev", "f", "gui", "viron", "en", "manager", "NV", "engine", "dir", "fi", "ext", "extra", "context", "esi", "ea", "end", "cdn", "eng", "api", "fg", "state", "e", "esp", "conf", "core", "forge", "v", "ev", "site", "session", "init", "np", "ctx", "data", "environment", "global", "ne", "gear", "py", "ini", "exc", "cache", "obj", "nw", "iter", "enter", "qt", "net", "inf", "stage", "vm", "server", "conn", "profile", "scope", "output", "eni", "erv", "entry", "config", " environment", "Environment", "exec", "dat", "que", "console", "export", "db"], "info": ["fo", "tf", "ami", "after", "service", "gi", "http", "def", "extra", "conn", "INFO", "ii", "alias", "desc", "success", "data", "image", "ui", "fw", "di", "type", "id", "end", "Info", "api", "py", "i", "inner", "entry", "index", "tif", "status", "config", "ie", "result", "ip", "afi", "state", "information", "iso", "f", "conf", "obj", "qa", "error", "init", "diff", "fi", "start", "si", "inf"], "trapnr": ["trapNR", "catchnr", " trapnl", "rapnl", "raprin", "hubnr", "ticknum", "traprin", "trapnu", "catchnom", "rapnum", "tripnor", "catchnum", "tapnr", " traprin", " trapNR", "hubnor", "rapnr", " trapnu", "trapnom", "tripnr", "ticknr", " trapnor", "tapnom", " trapnum", "tickrin", "tripnu", "tickrn", "tripNR", "trapnor", "taprn", "tapnum", "ticknom", "catchrn", "trapnum", "ticknl", "trapnl", "hubNR", "hubnu", "traprn"], "ret": ["match", "arg", "fun", "mt", "ext", "def", "bit", "success", "xt", "alt", "cat", "job", "fire", "rets", "num", "rep", "code", "ft", "nt", "rev", "back", "reply", "status", "Ret", "rc", "sat", "result", "pret", "fin", "try", "len", "red", "ref", "flag", "gt", "en", "RET", "al", "lit", "re", "reg", "val", "rt", "part", "fi", "det", "res", "mem"], "syscall_num": ["syscall_Num", "syscall_no", "sysCall_dim", "syscallabledim", "syscallablenumber", "sysflow_Num", "sysflow_no", "syscall_n", "syscallxn", "sysCall_num", "sysCall_number", "syscall_number", "syscallablen", "sysCall_n", "syscallablenum", "syscall_mn", "syscallxmn", "sysflow_number", "sysflow_num", "syscall_off", "syscall_dim", "syscallxnum", "syscallxoff"], "nb_args": ["nb25num", "nb25args", "nb__reg", "nb1args", "nb67args", "np_arg", "bn_args", "bm_args", "nb_ass", "bm_resources", "nb_reg", "nb67resources", "nb_num", "bm25params", "bm25abs", "nb25params", "nb67abs", "nb67params", "bn_items", "nb25resources", "bm25args", "bm_abs", "np_args", "nb_resources", "nb1arg", "nb_params", "nb1reg", "nb_items", "nb__params", "nb1params", "bn_num", "nb__args", "nb25items", "nb25abs", "nb__arg", "bm25resources", "np_params", "nb_arg", "bn_ass", "np_reg", "nb25ass", "nb_abs", "bm_params"], "sp_reg": ["Sp_rc", "sp2tag", "sp_tag", " sp_num", "sp2register", "Sp_reg", "sp2ref", "mp_reg", "Sp_region", "sp_register", " sp2len", "mp_REG", "sp5REG", " sp_register", "sp2num", "sp5region", " sp_len", "sp2region", "sp_len", "mp_region", "spacfun", "sp_num", "sp2group", "sp5reg", " sp2REG", "sp_fun", " sp2group", " sp2conn", " sp_REG", " sp_tag", " sp_conn", "sp_rec", "Sp_fun", "spacreg", "spacregion", " sp_rec", "sp_rc", "sp_region", " sp2tag", " sp2ref", "sp_REG", "sp_conn", "spacrc", "sp2conn", "sp_group", "sp2REG", "sp2reg", " sp2register", "mp_rec", " sp_group", " sp2num", " sp_ref", " sp2rec", "sp2len", "sp5rec", "sp_ref", " sp2reg", "sp2rec"]}}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n", "idx": 3551, "substitutes": {"s": ["sg", "server", "js", "service", "src", "cs", "http", "ss", "spec", "ts", "a", "sb", "d", "n", "aws", "client", "i", "g", "m", "ls", "ses", "sf", "sync", "settings", "slice", "storage", "sets", "ds", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "es", "sq", "o", "v", "S", "t", "os", "socket", "support", "ssl"], "stream_index": ["streamerindex", "forwardidsource", "fileerpointer", "streamerstring", "stream_prefix", "streamidposition", "streamidindex", "streamidsource", "streamerlevel", "streamflowsource", "fileerindex", "forward_source", "stream_string", "streamalindex", "stream_level", "forward_length", "fileerstring", "forward_index", "streamingprefix", "stream_length", "forwardidlength", "streamingindex", "file_pointer", "stream_source", "forwardidposition", "streamingaddress", "streamerpointer", "streamflowposition", " stream_address", "forwardidindex", "streamalstring", "streamflowlength", "streamflowindex", "fileerlevel", "forward_position", "streamidlength", "stream_pointer", " stream_prefix", "stream_address", "file_index", "stream_position", "streamallevel", "file_level", "file_string", "streamalpointer"], "timestamp": ["framestamp", "paramcision", "memoffset", "Timetime", "timcision", "timmark", "paramoffset", " Timeline", " Timetime", "timoffset", "paramestamp", "Timeline", "neweline", "Timmark", " Timestamp", "newmark", "memcision", "memestamp", "newetime", "timetime", "framoffset", "newestamp", "memetime", "parametime", "Timestamp", "timeline", "framcision", "frametime", " Timmark"], "flags": ["ff", "fd", "Flags", "time", "spec", "ts", "vals", "ms", " flag", "options", "bits", "args", " positions", "style", "xff", "len", "f", "flag", "date", "mask", "sec", " whence", "seq", "bytes", "count", "fs", "port"], "tmv": ["tmg", "mmtv", "mtper", "htmcf", "tctv", "pmf", "tomv", "tmov", "timv", "mmcf", "TMv", "tcv", "timg", "tmvv", "tomper", "tcver", "TMcf", "tomg", "tmper", "htmvv", "mmvc", "tomcf", "pmv", "timov", "TMver", "TMvv", "pmvc", "htmv", "mf", "tmver", "tktv", "mtov", "tmvc", "tkv", "mmuv", "htmver", "tmuv", "mv", "tmtv", "tomov", "tmcf", "tkvv", "tomf", "mq", "tomvc", "tcf", "tkf", "timper", "pmcf", "mmq", "muv", "tmf", "tccf", "mmv", "mmf", "tcvv", "mmvv", "tlf", "tmq", "tlq", "tluv", "mtg", "mtv", "tlv"], "pos": ["POS", "no", "offset", "spec", "loc", "position", " position", "slot", "prop", "tell", "type", "found", "end", "neg", "pres", "i", "pass", "po", "index", "pid", "pointer", "cond", "pad", "block", "p", "len", "size", "patch", "mon", "cache", "conf", "min", "obj", "rel", "pc", "o", "seq", "os", "Pos", "val", "addr", "part", "pt", "start", "port"]}}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;", "idx": 3555, "substitutes": {"opaque": ["opacity", "uppacity", "compacity", "ipopalpha", "compserver", "opac", "ipopacity", "operaque", "obacity", "opalpha", "operalpha", "compac", "uppaque", "operac", "obac", "observer", "compaque", "operacity", "obaque", "ipopaque", "operserver", "opserver", "uppalpha"], "addr": ["oa", "dr", "base", "name", "src", "ctx", "offset", "dd", "host", "data", "ace", "ad", "add", "align", "ord", "adr", "pos", "ac", "nr", "tx", "index", "pointer", "config", "address", "holder", "x", "ptr", "hop", "len", "ref", "Address", "node", "scale", "amd", "cmp", "mode", "ost", "part", "shape", "start", "port"], "val": ["base", "arg", "vol", "buffer", "ol", "ul", "stat", "elt", "vals", "data", "loc", "Val", "slot", "sl", "pos", "tx", "aval", "als", "sel", "x", "block", "len", "eval", "fat", "el", "value", "il", "v", "b", "valid", "al", "VAL", "all", "mem"], "size": ["unit", "SIZE", "ctx", "offset", "ize", "data", "loc", "ac", " Size", "z", "address", "x", "e", "length", "len", " length", "Size", "sec", "v", "scale", "fee", "al"], "s": ["service", "ss", "ops", "sa", "sb", "ips", "r", "sl", "op", "m", "ses", "ls", "sync", "ns", "c", "p", "state", "w", "e", "services", "f", "es", "secondary", "sys", "sq", "o", "v", "S", "t", "session", "os", "socket", "hs", "fs", "si", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "3d5822d9cf07d08bce82903e4715658f46b01b5c", "target": 1, "func": "static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,\n\n                                  Jpeg2000CodingStyle *codsty,\n\n                                  Jpeg2000ResLevel *rlevel, int precno,\n\n                                  int layno, uint8_t *expn, int numgbits)\n\n{\n\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    int cwsno;\n\n\n\n    if (layno < rlevel->band[0].prec[precno].decoded_layers)\n\n        return 0;\n\n    rlevel->band[0].prec[precno].decoded_layers = layno + 1;\n\n\n\n    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {\n\n        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {\n\n            s->g = tile->tile_part[++(*tp_index)].tpg;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)\n\n        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);\n\n\n\n    if (!(ret = get_bits(s, 1))) {\n\n        jpeg2000_flush(s);\n\n        return 0;\n\n    } else if (ret < 0)\n\n        return ret;\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n\n            band->coord[1][0] == band->coord[1][1])\n\n            continue;\n\n        nb_code_blocks =  prec->nb_codeblocks_height *\n\n                          prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            int incl, newpasses, llen;\n\n\n\n            if (cblk->npasses)\n\n                incl = get_bits(s, 1);\n\n            else\n\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n\n            if (!incl)\n\n                continue;\n\n            else if (incl < 0)\n\n                return incl;\n\n\n\n            if (!cblk->npasses) {\n\n                int v = expn[bandno] + numgbits - 1 -\n\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n\n                if (v < 0 || v > 30) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"nonzerobits %d invalid or unsupported\\n\", v);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                cblk->nonzerobits = v;\n\n            }\n\n            if ((newpasses = getnpasses(s)) < 0)\n\n                return newpasses;\n\n            av_assert2(newpasses > 0);\n\n            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {\n\n                avpriv_request_sample(s->avctx, \"Too many passes\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((llen = getlblockinc(s)) < 0)\n\n                return llen;\n\n            if (cblk->lblock + llen + av_log2(newpasses) > 16) {\n\n                avpriv_request_sample(s->avctx,\n\n                                      \"Block with length beyond 16 bits\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            cblk->lblock += llen;\n\n\n\n            cblk->nb_lengthinc = 0;\n\n            cblk->nb_terminationsinc = 0;\n\n            do {\n\n                int newpasses1 = 0;\n\n\n\n                while (newpasses1 < newpasses) {\n\n                    newpasses1 ++;\n\n                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {\n\n                        cblk->nb_terminationsinc ++;\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)\n\n                    return ret;\n\n                if (ret > sizeof(cblk->data)) {\n\n                    avpriv_request_sample(s->avctx,\n\n                                        \"Block with lengthinc greater than %\"SIZE_SPECIFIER\"\",\n\n                                        sizeof(cblk->data));\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                cblk->lengthinc[cblk->nb_lengthinc++] = ret;\n\n                cblk->npasses  += newpasses1;\n\n                newpasses -= newpasses1;\n\n            } while(newpasses);\n\n        }\n\n    }\n\n    jpeg2000_flush(s);\n\n\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n\n            bytestream2_skip(&s->g, 2);\n\n        else\n\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found. instead %X\\n\", bytestream2_peek_be32(&s->g));\n\n    }\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {\n\n                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]\n\n                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4\n\n                ) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                        \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\",\n\n                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);\n\n                cblk->length   += cblk->lengthinc[cwsno];\n\n                cblk->lengthinc[cwsno] = 0;\n\n                if (cblk->nb_terminationsinc) {\n\n                    cblk->nb_terminationsinc--;\n\n                    cblk->nb_terminations++;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data_start[cblk->nb_terminations] = cblk->length;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 3561, "substitutes": {"s": ["sg", "server", "js", "service", "src", "cs", "sup", "http", "ss", "ops", "spec", "ts", "rs", "sb", "r", "d", "is", "sites", "sl", "scope", "client", "sk", "i", "g", "bis", "side", "m", "ses", "ls", "sf", "sync", "sv", "sets", "ds", "gs", "ns", "l", "c", "p", "services", "e", "self", "f", "es", "sys", "sq", "sc", "u", "conf", "south", "sec", "o", "v", "b", "su", "t", "site", "session", "S", "os", "se", "fs", "si", "input", "sym", "ssl"], "tile": ["layer", "texture", "ilo", "tf", "service", "target", "tg", "flat", "device", "txt", "tu", "grade", "stone", "image", "google", "tk", "song", "ge", "sl", "sample", "league", "tp", "kt", "sf", "coll", "pixel", "file", "slice", "tif", "ele", "feature", "ie", "ite", "address", "phy", "skill", "game", "gb", "grid", "chip", "note", "node", "square", "surface", "scale", "plane", "site", "ole", "Tile", "uri", "sky", "tle", "zone", "table", "port"], "tp_index": ["tf_Index", "tk_pointer", "tp_Index", "lp_index", "tp_number", "tp__value", "tp_key", "lp_value", "lp_Index", "tp_part", "tk_role", "tk_key", "tp_value", "tf_part", "tf_offset", "tp__index", "tf_index", "tp_role", "lp_number", "tk_index", "tp__number", "tp_offset", "tp__Index", "tp_pointer"], "codsty": ["cmdestyle", "condrs", "odety", "cmdys", "cmdety", "condys", "condestyle", "codestyle", "codety", "condety", "odestyle", "cmdrs", "codys", "odrs", "odys", "codrs"], "rlevel": ["bletter", "srlog", "prlevel", "cpc", "rilevel", "crule", "rlayer", "srlevel", "srvel", "erpc", " rale", " rlevels", " rfl", "rstage", " rscope", " rvel", "erlevel", "rlevels", "bfl", "rlog", "clevel", " rLevel", "plevel", "rilayer", "pstage", "rfl", "blevel", "srstage", "rffl", "rale", "prLevel", "perlevel", "rrule", "errule", "rflevel", "rarfl", "rarletter", "rilog", "ervel", "plog", "ristage", "rvel", "srrule", "srpc", " rlocal", "rarlevels", "prfl", "prlocal", "pvel", "rLevel", "rscope", "pale", "srlayer", "rletter", "perscope", "blevels", "rlocal", " rletter", "rfLevel", "pervel", "pscope", "rarlevel", "player", "perale", "rflocal", "rpc", "cvel"], "precno": ["precsnos", "perfnos", "pefNO", "prefeno", "preccno", "propnumber", "precnone", "preceno", "precsnum", "perfNO", "preccnos", "prefno", "procno", "propno", "prezNO", "pregeno", "precnum", "pecNO", "preznumber", "prelnos", "perfeno", "procnone", "precsNo", "pregno", "pecno", "prepNO", "pregNO", "prezno", "Prefnos", "pecnum", "pefno", "prepnumber", "prepnone", "prelnum", "PrecNo", "percnos", "preleno", "prelnumber", "preznone", "Prefnum", "peceno", "prelNo", "prelnone", "perceno", "precceno", "procnumber", "precnumber", "precnos", "prepno", "propnone", "perfno", "percno", "PrefNo", "precsno", "Precnos", "prefNO", "Prefno", "precNo", "propNO", "preccNO", "Precnum", "prefnum", "prelNO", "Precno", "pregnum", "pefnum", "pefeno", "procNO", "precNO", "percNO", "prefnos", "prefNo", "prelno"], "layno": ["linno", "playyes", "lbnr", "colno", "laynor", "layernumber", "colyes", "linnumber", "layerNo", "langnumber", "langnos", "langyes", "langnr", "cpunumber", "laynos", "layernos", "colnor", "playnor", "layNo", "lbnumber", "cpunor", "linnor", "lbNo", "linnos", "cpunos", "laynr", "layerno", "cpuno", "playno", "layernor", "colnos", "layernr", "lbno", "playnos", "langNo", "layyes", "langno", "laynumber", "langnor"], "expn": ["playno", "playnum", "xpnum", "xpn", "expnt", "condn", "playnt", "xpnt", "expno", "condno", "condnum", "playn", "condnt", "xpno", "expnum"], "numgbits": [" numGbit", "numGbytes", " numGits", "numbbits", " numGbits", "numbits", "numbbit", "numgbit", "numgbbit", "numGits", "numgits", "numgbbits", "numbbytes", "numgbytes", "numgbbytes", " numgbit", " numGbytes", "numGbits", "numGbit", " numgbytes", " numgits"], "bandno": [" bandnumber", "brandnumber", " bandorno", "bandnone", "fieldname", " bandnu", "pluginnone", " bandnos", "bootnumber", "bandNo", "groundnumber", "bandnos", "fieldino", "busno", "bandsha", "tagno", "bootname", "groundname", "groundno", "groundorno", " bandino", "bandnumber", "bootnor", "portnum", " bandname", " bandnone", "busorno", "brandsha", "bandorno", "layNo", "brandnor", "pluginname", "groundNo", "groundnos", "bootino", "fieldno", " bandNo", "pluginnos", " bandnum", "laynu", "bandnum", "portNo", "busNo", "pluginno", "bandname", "tagnumber", "bootsha", "bootno", "portnu", "brandno", "groundnone", "bandnu", "bandnor", "bandino", "fieldnumber", "laynum", "portno", "tagsha", "tagnor", "busnumber"], "cblkno": ["cblqno", "cblkeno", "cplkknumber", "cllkidnumber", "cBlkNo", "cblklnum", "cplknu", "cblzno", "cblsknumber", "cblKno", "cplkNO", "cclkno", "cblkidnumber", "cmapknone", "cblkidnum", "cclkyno", "cBlklo", "cblkgnum", "cblkidno", "cblkgnon", "cblknone", "cblckeno", "cblklnon", "cclkna", "cblkideno", "cblsknu", "cclkNo", "cblckNo", "cblkknu", "cblkkNO", "cblkidna", "cmapknon", "cblskno", "cblfno", "cblksnum", "cllknum", "cblkgnone", "cllkno", "cblkknumber", "cclkyNo", "cblkidni", "cblckna", "cblklno", "cblznumber", "cblznu", "cllkidid", "cblkkno", "cplkkno", "cllkidnum", "cmapklnone", "cllknumber", "cblqid", "cblklo", "cblksno", "cblksnon", "cllkid", "cmapknum", "cblkni", "cblkyna", "cmapklnon", "cblkgno", "cblKnum", "cblqnum", "cclkeno", "cblflo", "cblklnone", "cblkyNo", "cblckno", "cmapkno", "cblfNo", "cblknum", "cblkyno", "cllkidno", "cblkNO", "cblfni", "cclkyeno", "cblknon", "cblknumber", "cBlckNo", "cblzNO", "cblKnumber", "cblKid", "cclkyna", "cBlckni", "cblqnumber", "cBlckno", "cmapklno", "cblkidNo", "cblksnone", "cBlkni", "cblkyeno", "cblknu", "cplkknu", "cBlcklo", "cblkid", "cmapklnum", "cplknumber", "cblkna", "cBlkno", "cblcklo", "cblkidlo", "cblkNo", "cplkno", "cblskNO", "cblkidid", "cblckni", "cplkkNO"], "ret": ["match", "arg", "fun", "no", "att", "ext", "def", "bit", "sb", "txt", "success", "sil", "xt", "out", "alt", "cur", "id", "pet", "rets", "arr", "bis", "ft", "back", "reply", "feat", "Ret", "bad", "pat", "bf", "str", "result", "pret", "fin", "ut", "len", "ref", "flag", "resp", "value", "en", "RET", "valid", "lit", "re", "reg", "val", "rt", "det", "res", "mem"], "nb_code_blocks": ["nb_call_bits", "nb_code64blocks", "nb_code_cycles", "nb_line_block", "nb_call_units", "nb_code2frames", "nb_code_frames", "nb_call_blocks", "nb_code64block", "nb_codepblock", "nb_code_bits", "nb_code2block", "nb_code_groups", "nb_call_frames", "nb_codepblocks", "nb_code2units", "nb_code64groups", "nb_codepunits", "nb_codepframes", "nb_line_groups", "nb_code_block", "nb_code64cycles", "nb_code_units", "nb_line_cycles", "nb_line_blocks", "nb_code2blocks", "nb_call_block"], "cwsno": ["cwdno", "cwsdo", "cwlno", " cwdname", " cwdno", "cwldo", "cwsname", "cwlname", "cwbname", "cwddo", " cwdNO", " cwsNO", " cwsdo", "cwdNO", "cwlNO", " cwddo", "cwbno", "cwsNO", " cwsname", "cwdname", "cwbdo", "cwbNO"], "band": ["device", "audio", "field", "event", "direction", "track", "period", "cell", "zone", "board", "unit", "flow", "group", "vision", "host", "nn", "image", "tag", "song", "position", "frame", "gap", "batch", "component", "coord", "bus", "book", "patch", "v", "web", "plugin", "leg", "session", "usb", "station", "layer", "guide", "version", "channel", "byte", "road", "bin", "record", "boot", "project", "filter", "back", "nb", "ground", "node", "connection", "phase", "bridge", "module", "low", "mode", "stage", "cost", "Band", "match", "service", "bit", "broad", "class", "d", "co", "output", "number", "disk", "word", "bound", "flag", "gb", "range", "point", "plane", "b", "product", "line", "part", "day", "db"], "prec": ["pree", "prif", "prep", "produc", "Prec", "percs", " pref", "producs", "arep", "pric", "prof", "Precc", "arec", "pre", "perl", "prl", "proc", "perc", " preb", "precr", " precc", "percr", "procr", " prep", "Precs", "prf", "prib", "perg", "pref", "Pref", "Prel", "procs", "perp", " precs", "produf", "Pree", "Preb", "aref", " pree", "prc", "Prep", " preg", "precc", "produg", "preg", "Precr", "prel", "precs", "perf", "prcc", "prip", "arecs", "pere", "preb"], "cblk": ["Cflk", "Cblc", "cBLkt", "cblkt", "cbrkt", "cblke", " cplq", "cbrke", "cplkt", "cBLf", "cbrf", "cflc", "cBLq", "Cflc", "Cblf", "cblf", "cbrk", "Cflke", " cblkt", "cplke", "Cflf", " cblf", "cplf", "cblq", "cplk", " cplk", " cplkt", "cBLk", "cflf", "cbrc", "Cblke", "Cblk", "cplc", " cplf", "cbrq", "cplq", "cflke", " cblq", "cflk", "cblc"], "incl": ["inc\n", "in\t", "inc\t", "out\t", "incf", " in0", "in\n", "outf", "out\n", "inc0", " in\t", " in\n", "in0", "inf", "out0", " inf"]}}
{"project": "qemu", "commit_id": "bba4e1b591531c087fce4ae501dc1ca299d8fb42", "target": 1, "func": "static void curses_refresh(DisplayChangeListener *dcl)\n\n{\n\n    int chr, nextchr, keysym, keycode, keycode_alt;\n\n\n\n    curses_winch_check();\n\n\n\n    if (invalidate) {\n\n        clear();\n\n        refresh();\n\n        curses_calc_pad();\n\n        graphic_hw_invalidate(NULL);\n\n        invalidate = 0;\n\n    }\n\n\n\n    graphic_hw_text_update(NULL, screen);\n\n\n\n    nextchr = ERR;\n\n    while (1) {\n\n        /* while there are any pending key strokes to process */\n\n        if (nextchr == ERR)\n\n            chr = getch();\n\n        else {\n\n            chr = nextchr;\n\n            nextchr = ERR;\n\n        }\n\n\n\n        if (chr == ERR)\n\n            break;\n\n\n\n#ifdef KEY_RESIZE\n\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n\n        if (chr == KEY_RESIZE) {\n\n            clear();\n\n            refresh();\n\n            curses_calc_pad();\n\n            curses_update(dcl, 0, 0, width, height);\n\n            continue;\n\n        }\n\n#endif\n\n\n\n        keycode = curses2keycode[chr];\n\n        keycode_alt = 0;\n\n\n\n        /* alt key */\n\n        if (keycode == 1) {\n\n            nextchr = getch();\n\n\n\n            if (nextchr != ERR) {\n\n                chr = nextchr;\n\n                keycode_alt = ALT;\n\n                keycode = curses2keycode[nextchr];\n\n                nextchr = ERR;\n\n\n\n                if (keycode != -1) {\n\n                    keycode |= ALT;\n\n\n\n                    /* process keys reserved for qemu */\n\n                    if (keycode >= QEMU_KEY_CONSOLE0 &&\n\n                            keycode < QEMU_KEY_CONSOLE0 + 9) {\n\n                        erase();\n\n                        wnoutrefresh(stdscr);\n\n                        console_select(keycode - QEMU_KEY_CONSOLE0);\n\n\n\n                        invalidate = 1;\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (kbd_layout) {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS)\n\n                keysym = curses2keysym[chr];\n\n\n\n            if (keysym == -1) {\n\n                if (chr < ' ') {\n\n                    keysym = chr + '@';\n\n                    if (keysym >= 'A' && keysym <= 'Z')\n\n                        keysym += 'a' - 'A';\n\n                    keysym |= KEYSYM_CNTRL;\n\n                } else\n\n                    keysym = chr;\n\n            }\n\n\n\n            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n\n            if (keycode == 0)\n\n                continue;\n\n\n\n            keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n\n            keycode |= keycode_alt;\n\n        }\n\n\n\n        if (keycode == -1)\n\n            continue;\n\n\n\n        if (qemu_console_is_graphic(NULL)) {\n\n            /* since terminals don't know about key press and release\n\n             * events, we need to emit both for each key received */\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = curses2qemu[chr];\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n", "idx": 3582, "substitutes": {"dcl": [" dfl", " dCL", "fcl", "dCL", "dscl", "dccl", "Dscl", "DCL", "dcbl", "Dcl", " dscl", "dcCl", "Dfl", " docl", " dbl", " dCl", "dfl", "dCl", "DCl", "dcfl", "dbl", "Docl", "fscl", "focl", "fCL", "docl", "Dbl"], "chr": ["cherc", "qri", "cherg", "chri", "grtr", "ichadr", "charrn", "CHar", "chartr", "cher", "charre", "phrf", "chertr", "chanr", "chari", "charrc", "corrc", " chlr", "charar", "charnr", "chep", "schr", "charrf", "chtr", "CHrb", "grrc", "grR", "chp", "chre", "chytr", "chlr", "ichrb", "cherR", "charpr", "chR", "cherr", " chrg", "chelr", "chsr", "chc", "ichrc", "ichlr", "ichar", "cornr", " chrn", "chec", "ichrg", "chyr", "schrb", "qre", " chrb", "chrb", "chetr", " chtr", "qr", "qnr", "charlr", "charri", "chyrf", "schrc", " chR", "phnr", "ichnr", "shR", "chynr", " chpr", "shrb", "chnr", " chnr", "ichp", "chenr", "grr", "ichR", "ichrf", "cherre", "cheR", "charsr", "shr", "chrn", "phr", "chesr", "chrg", " chre", "shrg", " chrc", "chare", "phrn", "shlr", "CHpr", "corsr", "ichc", "charr", "chere", "chadr", "CHr", " chadr", "ichr", "chpr", "charadr", "cherb", "ichtr", " chrf", " chp", "charrb", "chrf", "corr", "shar", "schrg", " chc", "cherf", "chrc"], "nextchr": [" nextchnr", "startachrb", "nextcherre", "currentchr", "nextachrf", "lastcherc", "lastchr", " nextChrt", "currentcharry", "nextcherb", "nextchar", " nextchra", "nextarchrt", "lastcharrc", "nextcornr", " nextChrs", " nextcorrb", "nextachrt", "nextachrs", "nextcurrb", "lastcharrs", "nextChr", "startachr", "nextchrb", "nextichrb", "nextChrs", "nextcurr", "nextichp", "lastchrs", "startchrf", "currentcharnr", "nextechrs", "nextachn", "nextCHR", "nextcharrb", "nextcharrs", "nextChra", "firstachrb", "nextcorrc", " nextchre", "nextcharl", " nextChR", " nextChre", "nextchary", "nextachr", "startachn", "lastchers", "nextcurrf", " nextcorr", " nextChrb", "nextachra", "nextarchra", "nextChrb", "startchn", "nextchrl", "nextarchrs", "nextChre", "firstachrs", "nextChp", " nextchR", "currentchrc", " nextchrb", "nextcherf", "nextChri", "nextechr", "nextchrf", " nextchrl", "firstchr", " nextchrs", " nextchrt", "nextchanr", "nextcharnr", "nextarchr", "nextChrc", "nextchery", "startchrb", "currentchnr", "startachrf", "nextcherl", " nextChra", "nextChnr", "nextcher", "nextachrb", "nextcharry", "nextcorr", "nextchn", "nextcharrc", "lastcharr", "nextcherr", " nextChnr", "nextcharr", "lastcharrb", " nextChri", "nextcorrs", " nextchp", "nextchep", "lastchrb", "nextCHrs", "nextechri", "nextchrs", "nextchra", "nextchers", "lastchnr", "nextcorrb", "startchr", "nextchre", "nextcharb", "nextCHnr", " nextcorrl", "nextchp", "nextChR", "lastchenr", "currentchry", "nextechre", " nextChr", "nextichr", "firstachr", "nextcherrs", "nextchry", "currentcharr", "nextcharR", "nextchrc", "firstchrt", "currentcharrc", "nextichrs", "nextcherc", "nextchert", "nextCHr", " nextchri", "firstchrs", " nextChp", "nextcurn", "nextchrt", "nextchenr", "nextchri", "nextcherri", "nextChrt", "firstachrt", "nextchR", "lastchrc", "nextcorrl", "nextchen", "firstchrb", " nextcornr", "lastcher", "nextcharc", "nextchnr"], "keysym": ["lesyd", "keysyr", "Keysy", " keysyd", " keysyp", "lightsy", "ksm", "Keysymm", "kesyr", "ysm", "keyy", " keysm", "lesyp", " keysymm", "ksyd", "lesym", "keysyn", "opensyd", "lightsyn", "keyyp", "lightsym", "keyym", "ksymm", "lightsyp", "rowsys", "kesys", "ksys", "keysm", "rotsyr", "rotsyp", "keysymm", "kesy", "lesyr", "ksyp", " keysy", "keysyp", "rowsymm", "ysym", "keyyr", "opensyp", "opensy", "rotsyd", "kesyp", "Keysys", "ysy", " keysys", "ksyr", "rowsy", "rowsym", "rotsym", "opensym", "keysys", "kesymm", "keysyd", " keysyn", "kesym", "ksyn", "lightsyr", "ksym", "opensyr", "ksy", "Keysym", " keysyr", "keysy", "ysyd"], "keycode": ["rulecode", "charco", "Keycode", "vercycle", "hashp", "keycycle", "colcode", "rowCode", "locknum", " keyco", "hashcode", "vercode", "charcod", "keyc", "charnum", " keycoded", "typecycle", "charcoded", " keyfunc", "changeCode", "keyvalue", "charc", "rowcodes", "lockcode", "callfunc", "charconst", " keycodes", "keycount", "callcode", "charCode", " keycat", "keyp", " keyp", "fieldco", "kecycle", "charfunc", "charcat", "typecount", "keyco", "keycat", "kecod", "changevalue", "keyfunc", "Keycod", "fieldnum", "charcode", "typecode", "charp", "rowcat", "kec", " keyconst", " keyc", "kecode", "callcat", "hashcoded", "Keycycle", "vercod", " keyCode", "keyconst", "changecode", "lockCode", "vercount", "keycodes", "rulec", " keyvalue", "rulecod", "typecod", "colc", "fieldcode", "callc", "keycoded", "Keycount", " keycycle", "rulecycle", "keyCode", " keycod", "lockcod", "fieldCode", "hashCode", "colcod", " keynum", "rowcode", "charvalue", "charcodes", "keycod", "colconst", "keynum"], "keycode_alt": ["keyc_text", "keyc_ALT", "keycode_ret", "keycode_text", "keycodes_ALT", "keycodes_ret", "keycode_flat", "keyc_ret", "keycode_ALT", "keycodexALT", "keycodes_Alt", "keyc_alt", "keycodexflat", "keyc_att", "keycode_Alt", "keycodes_alt", "keycodexalt", "keycodexatt", "keycode_att", "keyc_flat"]}}
{"project": "FFmpeg", "commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "target": 1, "func": "static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n", "idx": 3596, "substitutes": {"line": ["base", "letter", "row", "name", "buffer", "li", "offset", "time", "key", "byte", "url", "page", "lf", "id", "sl", "frame", "nl", "ine", "pass", "side", "Line", "code", "entry", "file", "body", "slice", "source", "lane", "word", "l", "block", "e", "lines", "lc", "len", "text", "el", "range", "comment", "lin", "cell", "rule", "link", "LINE", "lo", "user", "le"], "duration": ["unit", "stage", "series", "delay", "after", "trace", "offset", "time", "sequence", "context", "d", "video", "until", "span", "relative", "gap", "i", "m", "Duration", "event", "number", "document", "pad", "during", "doc", "len", "length", "repeat", "date", "range", "v", "uri", "since", "timeout", "between", "port"], "start": ["series", "base", "name", "offset", "time", "ize", "read", "data", "ace", "d", "ad", "n", "type", "use", "id", "cur", "it", "from", "span", "gap", "next", "i", "pos", "mid", "info", "source", "str", "parse", "Start", "index", "st", "ie", "pad", "step", "ce", "p", "x", "ip", "ind", "c", "set", "length", "len", "date", "art", "origin", "range", "stop", "run", "init", "begin", "se", "started", "in"], "end": [" extend", "ending", "se", "append", "offset", "time", "data", "n", "type", "id", "est", "END", "max", "i", "pos", "ended", "index", "z", "address", "begin", "ind", "c", "p", "End", "e", "set", "length", "len", "date", "size", "range", "en", "stop", "nd", "limit", "edge", "all", "port"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "substitutes": {"klass": ["Kcl", "oklass", "klasses", " kazz", "kickclass", "okull", "skazz", "Kull", "kickazz", "kull", "okclass", "Klf", "kicklass", "skull", "Kclass", "kicklf", " kcl", "sklasses", " klf", "skclass", "klf", "skcl", "kazz", "Klasses", "Klass", "sklass", "kclass", "okcl", "Kazz", " klasses", "kcl", " kclass"], "data": ["da", "dd", "def", "context", "device", "cc", "rec", "record", "parent", "i", "params", "m", "info", "create", "df", "config", "json", "raw", "result", "reader", "dev", "DATA", "dat", "Data", "input", "db"], "k": ["ek", "uk", "cs", "q", "kick", "key", "device", "ke", "d", "tk", "ck", "kind", "K", "sk", "ko", "kr", "g", "dk", "kin", "ka", "m", "ijk", "ok", "kt", "mk", "kw", "kn", "c", "kid", "p", "self", "f", "u", "ku", "kk", "ki", "o", "ik", "ks"], "dc": ["fc", "DC", "da", "cc", "mc", "device", "d", "di", "tk", "ck", "nc", "director", "bc", "tc", "de", "cdn", "dk", "ac", "df", "dt", "ds", "config", "ec", "c", "doc", "lc", "design", "sc", "cd", "cmd", "disc", "pc", "cf", "dat", "acc", "desc", "db", "rc"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 3602, "substitutes": {"pdev": ["opdevice", "fdef", "jev", "sprad", "nvar", "pdebug", "qdebug", "ppdevice", "Peng", "nde", "pdef", "Pdevice", "pdevice", "lpdc", "cpdev", "copdevice", "prad", "nprad", "fdd", "prcam", "fdevice", "prev", " pdevice", "qver", "copdev", "ndevelopment", "ndef", " pvalid", "vserv", "ndiv", "pconn", "ipdevice", "npdebug", "spdebug", "nDEV", " pdf", "pde", "ppdevelopment", "prvalid", "lpdebug", "qdev", " pcam", "vrad", "cev", " pconf", "Pver", "qconf", "ppdc", "opdef", "ipdiv", "lprav", "lpvar", "fde", " pdiv", "ppdi", "lpengine", "ceng", "preconn", "prdef", "pwd", "qdef", "vdebug", "preev", "Pdevelopment", "lpdev", "cdc", " pdebug", "cpdevice", "cpdef", "updev", "opdev", "pedev", "ppvar", "updiv", "pcdevice", "fdev", "peng", "fdiv", "pcdiv", "ndc", "jde", "Pev", "cdiv", "cengine", "ndd", "vdev", "cdef", "pcam", "prediv", "prdevice", "pedebug", "prwd", "opdiv", "Pdev", "ppdev", "tdevice", "pconf", "copdevelopment", "ndevice", "jdev", "preng", "Pdiv", "ndi", "ppdiv", "prdf", "pengine", " pde", "prede", " pev", "lpdevice", "prevar", "pevar", "pcvar", "uprav", "spdev", "pprad", "ppserv", "cpdiv", "pDEV", "qdevice", "ndev", "pvalid", "ccam", "npdev", "perad", " pwd", "pcengine", "ipvar", "cdev", "pcdevelopment", "tdiv", " pdef", "pdd", "pcdc", "nver", "Pdef", "lpdd", "pcdev", "npvar", "ppdef", "cdevice", "prdiv", "prdev", "tdev", "pserv", "spserv", "predevice", "cde", "nrav", " pvar", "lpdiv", "jconn", "pdevelopment", "ipdev", "pdi", "prav", "copdi", "lprad", "pev", "upDEV", "lpdef", "qde", "pver", "tdf", "pdiv", "pvar", "pdc", "ppdebug", "predevelopment", "pdf", "lpDEV", "cconf", "lpwd", "lpvalid", " pconn", "predev"], "is_default_rom": ["is_default2rom", "is_no_mode", "is_default2chrom", "is_default_mode", "is_default_chrom", "is_no2mode", "is_no2rom", "is_no2chrom", "is_default2ram", "is_no_ram", "is_no2ram", "is_no_rom", "is_default2mode", "is_default_ram", "is_no_chrom"], "errp": [" errd", "yrp", "errP", "serpr", "serlp", "serwp", "Erp", "finderr", "finderb", "errc", "ererpr", "erb", "yrpr", "errpe", "yrlp", " errpe", "iterp", "errfp", "erd", "rrc", " errr", "errd", "Errorpa", "ererp", "iterfp", "ferpa", "errb", "serp", "rrpa", "err", "Erfp", " errP", "ErP", "ferpi", "ferc", "errr", "ererwp", "ererlp", "rrp", "finderd", "Errorp", "errpi", "finderp", "erp", "Errorpi", " errb", "iterpe", "iterP", "ferp", "errpr", "errlp", "Errorc", "Erpe", " errfp", "yrwp", "errpa", "rrpi", "errwp"], "size": ["capacity", "any", "large", "go", "mini", "n", "weight", "empty", "handle", "g", "code", "storage", "address", "x", "Size", "en", "sum", "fee", "unit", "time", "sized", "security", "form", "ui", "type", "sh", "ny", "p", "e", "length", "core", "sn", "scale", "iz", "count", "SIZE", "crop", "esc", "small", "speed", "loc", "page", "use", "member", "year", "i", "body", "function", "c", "len", "cache", "value", "sec", "mode", "shape", "si", "ize", "class", " sizes", "now", "sync", "number", "style", "range", "full", "ice"], "path": ["route", "call", "test", "trace", "ctx", "time", "key", "anc", "alias", "context", "method", "url", "image", "binary", "folder", "loc", "type", "prop", "id", "parent", "enc", "po", "inner", "code", "Path", "file", "box", "sync", "bug", "slice", "source", "entry", "temp", "pointer", "config", "dir", "raw", "home", "PATH", "content", "progress", "work", "p", "c", "index", "resource", "length", "ref", "loader", "text", "cache", "child", "ath", "cmd", "node", "connection", "sign", "clean", "uri", "location", "full", "link", "root", "part", "shape", "rh", "desc", "user"], "ptr": ["dr", "ig", "mount", "fd", "src", "buffer", "trace", "offset", "ext", "ctx", "tty", "loc", "bc", "scope", "grad", "buf", "lr", "adr", "pos", "rb", "args", "pointers", "err", "slice", "str", "pointer", "address", "len", "ref", "attr", "br", "exec", "alloc", "inst", "addr", "val", "pt", "que", "fi", "rc", "port"], "name": ["key", "large", "url", "n", "client", "code", "file", "address", "x", "dev", "self", "child", "ame", "comment", "start", "option", "port", "time", " names", "anc", "host", "filename", "image", "type", "id", "parent", "end", "pass", "package", "create", "resource", "mask", "val", " NAME", "title", "base", "version", "a", "data", "small", "new", "global", "member", "space", "info", "names", "str", "Name", "len", "cap", "cache", "value", "node", "connection", "prefix", "error", "list", "shape", "mem", "call", "null", "no", "alias", "memory", "num", "pos", "none", "number", "word", "block", "w", "nm", "full", "nice", "part", "NAME", "desc"], "vmsd": ["lmsdn", "mamsn", "vMsl", "vamsl", "vmsds", "lmsb", "vmesd", "viasdn", "lmesds", "varsdh", "vomsn", "vcsb", "lmesd", "mamshd", "lmsds", "vumsp", "vumssd", "vMsd", "vvsd", " vmsp", "vamshd", "lmesb", "vmsdn", "vmsp", "vMShd", " vmsds", "mmsd", "vamsd", "mmsn", "vmsdt", "lmesdn", " vrsds", "vmesdn", "vmsb", "vumsd", "vrsd", "vvssd", "vmsl", "vmesb", "viasds", " vumsp", "vrsds", "vMSl", "varsdt", " vmsdt", "vmshd", "varsds", "viasd", "vMSd", "vmesdt", " vrsd", "mamsd", "mmshd", "mamsl", "vvsn", "vomsd", "vumsn", "vomsp", " vumssd", "varsd", "vcsds", "vcsd", " vrsdh", "vrsdt", " vrsdt", "lmsd", "vMSn", "vamsn", "vcsdn", " vumsn", "vvsp", "vMsn", " vmsdh", "vMshd", "mmsl", "vmsdh", "vrsdh", "vmesdh", " vmssd", "vmesds", " vumsd", "viasb", "vmssd", " vmsn", "vmsn", "vomssd"]}}
{"project": "FFmpeg", "commit_id": "21bffa93a6fc73e1f1859f8bc224409eaaf27658", "target": 1, "func": "static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n\n{\n\n    AVStream       *video_st    = s->streams[0];\n\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n\n    int audio_rate = audio_par->sample_rate;\n\n    // TODO: should be avg_frame_rate\n\n    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);\n\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n\n\n    avio_wb32(pb, 0x94); /* size */\n\n    ffio_wfourcc(pb, \"uuid\");\n\n    ffio_wfourcc(pb, \"PROF\");\n\n\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n\n    avio_wb32(pb, 0xbb88695c);\n\n    avio_wb32(pb, 0xfac9c740);\n\n\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n\n\n    avio_wb32(pb, 0x14); /* size */\n\n    ffio_wfourcc(pb, \"FPRF\");\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n\n\n    avio_wb32(pb, 0x2c);  /* size */\n\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x2);   /* TrackID */\n\n    ffio_wfourcc(pb, \"mp4a\");\n\n    avio_wb32(pb, 0x20f);\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_rate);\n\n    avio_wb32(pb, audio_par->channels);\n\n\n\n    avio_wb32(pb, 0x34);  /* size */\n\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x1);    /* TrackID */\n\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n\n        ffio_wfourcc(pb, \"avc1\");\n\n        avio_wb16(pb, 0x014D);\n\n        avio_wb16(pb, 0x0015);\n\n    } else {\n\n        ffio_wfourcc(pb, \"mp4v\");\n\n        avio_wb16(pb, 0x0000);\n\n        avio_wb16(pb, 0x0103);\n\n    }\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb16(pb, video_par->width);\n\n    avio_wb16(pb, video_par->height);\n\n    avio_wb32(pb, 0x010001); /* ? */\n\n}\n", "idx": 3610, "substitutes": {"pb": ["ob", "pl", "fc", "np", "vp", "ctx", "bh", "lp", "pd", "ppa", "sb", "bps", "wikipedia", "bm", "lb", "cpp", "hub", "prot", "summary", "rob", "prop", "pg", "bc", "dl", "platform", "api", "blog", "py", "PB", "tp", "rb", "proc", "fp", "pid", "bf", "post", "phys", "pkg", "p", "nb", "lc", "wb", "attr", "posts", "gb", "jp", "pm", "mp", "bt", "www", "amp", "obj", "pc", "bp", "bb", "um", "fb", "cp", "plugin", "b", "uf", "bs", "wp", "dp", "wat", "typ", "db", "xb"], "s": ["sg", "js", "service", "ctx", "ss", "ops", "rs", "ts", "sa", "qs", "sb", "spec", "aws", "is", "sl", "g", "ses", "ls", "sf", "fts", "sync", "sv", "storage", "ds", "ps", "gs", "ns", "h", "l", "c", "p", "services", "e", "f", "es", "sys", "sq", "v", "b", "su", "t", "os", "ks", "bs", "hs", "fs", "si", "ssl"], "video_st": ["video_str", "audio_st", "media_st", "video_inst", "videoacst", "videoacstr", "audio_str", "audio_inst", "media_stream", "video_sta", "media_std", "media_src", "videoacsta", "audio_sta", "video_sth", "video_stream", "audio_sth", "videoacsth", "video_std", "video_src"], "video_par": ["audio_per", "video5rec", "video_per", "video_params", "video_sp", "videoJsp", "video5par", "videoJper", "document_rec", "document_param", "videoJpar", "document_par", "video_rec", "videoJparams", "audio_sp", "video5param", "video5parse", "video_parse", "video_param", "audio_params", "document_parse"], "audio_par": [" video_rec", "video_comp", "video_rec", "audio_base", " video__rec", "audioJdis", " video_base", " video_params", "audio__rec", "video_dis", "video_pc", "audioJrec", "video_params", "video_sp", "audio_rec", " video__par", "audio__par", "audio_per", "audioJsp", "audio_dis", " audio_proc", " audio_comp", "audio__params", "audio_comp", "audio_sp", "audio_proc", " audio_per", " video__base", "audioJpar", "audio_pc", " video__params", "audio__base", "audio_params"]}}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n", "idx": 3611, "substitutes": {"sphb": ["shpb", "sPhw", "sppb", "shpd", "sPhd", "sppr", "shpr", "shpw", " shpr", " shpb", "sppd", " sphr", "sppw", "sphr", "sphw", " sphw", "sphd", "sPhr", " sphd", " shpd", "sPhb", " shpw"], "pdev": ["cDev", "hserv", "cdev", "sdd", "pdd", " pdd", "hDev", "sdev", "Pdev", "Pdevice", "Pde", "pdevice", "cdevice", "pserv", "hdev", "Pdd", " pde", "PDev", "hdevice", "sdevice", "Pserv", " pdevice", "cserv", "pde", "sde", "pDev"], "path": ["route", "act", "key", "url", "folder", "n", "lang", "here", "enc", "file", "pointer", "home", "feed", "progress", "self", "track", "object", "sign", "rh", "board", "port", "bind", "name", "context", "image", "id", "buff", "parent", "pass", "Path", "work", "p", "hop", "length", "text", "core", "transform", "room", "root", "mount", "ctx", "hub", "loc", "cat", "graph", "PATH", "content", "h", "c", "ref", "loader", "cache", "cmd", "node", "prefix", "buffer", "conn", "method", "ph", "box", "temp", "config", "bound", "col", "ath", "point", "thread", "font", "part"], "buf": ["route", "base", "null", "mount", "fd", "src", "buffer", "ctx", "read", "ff", "bag", "Buff", "context", "queue", "data", "broad", "url", "folder", "loc", "cat", "bc", "buff", "cas", "rb", "args", "box", "file", "cb", "coll", "fp", "str", "pool", "config", "func", "feed", "runner", "raw", "home", "result", "block", "cv", "Buffer", "vec", "bound", "wb", "ref", "br", "text", "bd", "loader", "cache", "cmd", "padding", "prefix", "seq", "b", "fb", "cf", "font", "bytes", "uf", "room", "uc", "rc", "port"], "host": ["route", "server", "mount", "name", "src", "cross", "http", "channel", "target", "conn", "array", "device", "method", "url", "hub", "localhost", "loc", "header", "format", "head", "Host", "graph", "parent", "boot", "platform", "remote", "comp", "pos", "ac", "file", "box", "source", "str", "pool", "config", "home", "address", "content", "h", "c", "connect", "dev", "hop", "ref", "front", "cache", "object", "cmd", "node", "driver", "prefix", "container", "room", "addr", "ost", "ann", "root", "cast", "port"]}}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)\n\n{\n\n    //FIXME Optimize (just quickly writen not opti..)\n\n    int i;\n\n    for (i=0; i<dstW; i++)\n\n    {\n\n        int val=1<<18;\n\n        int j;\n\n        for (j=0; j<lumFilterSize; j++)\n\n            val += lumSrc[j][i] * lumFilter[j];\n\n\n\n        dest[i]= av_clip_uint8(val>>19);\n\n    }\n\n\n\n    if (!uDest)\n\n        return;\n\n\n\n    if (dstFormat == PIX_FMT_NV12)\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(u>>19);\n\n            uDest[2*i+1]= av_clip_uint8(v>>19);\n\n        }\n\n    else\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(v>>19);\n\n            uDest[2*i+1]= av_clip_uint8(u>>19);\n\n        }\n\n}\n", "idx": 3621, "substitutes": {"lumFilter": ["LumHeader", "lubFilter", "LumbControl", "lumControl", "lumerFormat", "lumFile", "LumFormat", "LumFile", "lumbControl", "LumMaster", "lumbFilter", "lrumHeader", "LumControl", "LumBlock", "lubHeader", "lumMaster", "lumsBlock", "LumbHeader", "lumsFormat", "lumbBlock", "lumerFile", "lumerBlock", "lubControl", "lumHeader", "LumbFilter", "lrumFilter", "lrumMaster", "lumbHeader", "lumbFormat", "lumsFilter", "lumBlock", "lumbMaster", "lrumControl", "LumbFile", "LumFilter", "LumbBlock", "lumsFile", "lumerFilter", "lumbFile", "lumFormat", "lubMaster", "LumbMaster", "LumbFormat"], "lumSrc": ["lumSsrc", "lumNrc", "lumbAsRC", "lumNsrc", "lumSRC", "lumAsRC", "lumPsdr", "lumDsdr", "lumNdr", "lumAsdr", "lumbSsrc", "lumPsRC", "lumSdr", "lumDsRC", "lumDsrc", "lumbAsrc", "lumAsrc", "lumbAsdr", "lumbSRC", "lumAssrc", "lumPsrc", "lumNRC", "lumbSdr", "lumPssrc", "lumDssrc", "lumbAssrc", "lumbSrc"], "lumFilterSize": ["lumaFilterSection", "lumFileCount", "lumLimitSize", "lumBlockCount", "lumHandlerCount", "lumHandlerSection", "lumFileSize", "lumFilterSection", "lumFilterLen", "lumLimitSIZE", "lumBlockLen", "lumHandlerLen", "lumFileSection", "lumBlockSection", "lumFileLen", "lumBufferCount", "lumFSIZE", "lumLimitsize", "lumaFileCount", "lumHandlerSize", "lumaFSize", "lumLimitCount", "lumBufferSize", "lumaFilterLen", "lumBlockSize", "lumFilterCount", "lumaFileSize", "lumFSize", "lumaFilterSIZE", "lumaFilterCount", "lumaFSIZE", "lumFCount", "lumBuffersize", "lumaFsize", "lumaFilterSize", "lumaFCount", "lumaFileSection", "lumaFileLen", "lumFsize", "lumFilterSIZE", "lumaFiltersize", "lumBufferSIZE", "lumFiltersize"], "chrFilter": ["chmFilter", "shrarHandler", "chrarHandler", "ichrReader", " chrFactor", "ichrLayer", "chrcFilter", "uchrFactor", "chrFormat", "uchrgFormat", "chrcLayer", "shrHandler", "uchrFilter", "chrbFil", "shrarFactor", "chrfFil", "chreFilter", "chrFil", "ichrcLayer", "chrtReader", "chrnHeader", "chrdFactor", "chrfFactor", " chrdFilter", "chrdSource", "chrcHandler", "chrarFactor", "chrgFormat", "chrnFilter", " chrxfilter", "chrfilter", "shrarFilter", "chrdFilter", "chrxfilter", "chrtFilter", "chrtLayer", "chrfFormat", "chrFactor", "chrHeader", "chrgFactor", "chrbHandler", "chmFactor", "chrnReader", " chrdSource", " chrxHandler", "chrHandler", "shrarHeader", "chrgFilter", "ichrcReader", "chrgFeature", "uchrFeature", "shrFactor", "chrbFactor", "chrReader", "uchrgFilter", "uchrFormat", "chreSource", " chrHandler", "chrffilter", "chrxFilter", "chrcFactor", "chrxHandler", "chrcReader", "chrcHeader", "chrfFeature", "chrbfilter", " chrdFactor", "uchrgFeature", "chrtHandler", "chmSource", " chrSource", "uchrgFactor", "chrtHeader", " chrxFil", "chreFactor", "chrbFilter", "chrtFactor", "chrxFil", "chrnLayer", "chrfFilter", " chrfilter", "chrbFeature", "chrFeature", "shrFilter", "chrbFormat", "shrHeader", "chrSource", " chrxFilter", "ichrHeader", "chrarFilter", "chrfHandler", "ichrFilter", " chrFil", "ichrcFilter", "ichrcHeader", "chrarHeader", "chrLayer"], "chrSrc": ["chrSrx", "chrsSRC", "chrFsroc", "chrtSrc", "chrtASrc", "chrbSsrc", "chrInssrc", "chrcShrc", "chrfSrt", "chrShsrc", "chrSsc", "chrfSvc", "chrbSric", "chrEsrc", "chrcShri", "chrShrc", "chrsSsrc", "chrFssrc", "chrASvc", "chrfDesrt", "chrSRC", "chrtASrt", "chrDessrc", "chrShsc", "chrfDessrc", "chrcSrc", "chrPssrc", "chrSubrt", "chrASrt", "chrASrc", "chrbInsrc", "chrAssrc", "chrtASsrc", "chrbInssrc", "chrEssrc", "chrEsroc", "chrSrt", "chrSsrc", "chrEsRC", "chrSubsrc", "chrsAsRC", "chrtASrx", "chrDrx", "chrSubrc", "chrAsrc", "chrInsroc", "chrFsrc", "chrDesvc", "chrbSroc", "chrAsRC", "chrPsri", "chrtSsrc", "chrFsric", "chrfSrc", "chrtSrx", "chrASrx", "chrsAssrc", "chrInsRC", "chrUsrc", "chrShri", "chrbInsroc", "chrDesrt", "chrsSrc", "chrcShsc", "chrOsrc", "chrcShsrc", "chrSroc", "chrASsrc", "chrPsrc", "chrsAsrc", "chrEsric", "chrcSsrc", "chrOssrc", "chrSubvc", "chrUssrc", "chrbInsric", "chrDsrc", "chrInsrc", "chrSri", "chrcSri", "chrSric", "chrfDesrc", "chrUsrt", "chrPssc", "chrDrc", "chrfDesvc", "chrtSrt", "chrOsri", "chrUsrx", "chrbSrc", "chrDesrc", "chrSvc", "chrOssc", "chrcSsc", "chrfSsrc", "chrInsric", "chrDrt"], "chrFilterSize": ["chrFilterLen", "chrLimitCount", "chrFilSize", "chrbFilterCount", "chrBuffersize", "chruMaskStyle", "chlFactor6", "chrbFilterSIZE", "chruMaskCore", "chrFile6", "chrbUsersize", "chlFilterLen", "chrUserCount", "chruMaskSize", "chrbUserSIZE", "chrbFilterSize", "chrFilterCount", "chrMaskStyle", "chrBufferSIZE", "chrLayerCore", "chrFactor6", "chrBufferSize", "chrFilter6", "chlFilterSize", "chrFileLen", "chrFilterSIZE", "chrMaskCore", "chrFileSize", "chrbUserCount", "chrMaskSize", "chrUsersize", "chrbUserSize", "chlFactorLen", "chrFilCore", "chrLayerStyle", "chrLimitSIZE", "chrLimitsize", "chrFactorLen", "chrFactorSize", "chrBufferLen", "chrBufferCount", "chruFilterCore", "chrBuffer6", "chrUserSize", "chlFactorSize", "chrLayerSize", "chrFiltersize", "chrFilterCore", "chrFilterStyle", "chrbFiltersize", "chrUserSIZE", "chruFilterSize", "chrLimitSize", "chlFilter6", "chrFilStyle", "chruFilterStyle"], "dest": ["match", "sub", "test", "src", "outer", "rest", "target", "flat", "dim", "data", "Dest", "loc", "prop", "cdn", "tmp", "options", "output", "slice", "source", "coord", "config", "opt", "dc", "trans", "result", "du", "wb", "text", "decl", "south", "sort", "transform", "path", "gen", "img", " destination", "dat", "export", "desc", "dist"], "uDest": ["iuDest", "zuDi", "uStream", "uSc", "uBuff", "uiSource", "cuForce", "cuDi", "Udest", " uDesc", "uiSc", " uSc", "cuDist", "uiPriv", "uDist", "nuPriv", "pStream", "uDesc", "uForce", "pSource", " uForce", "cudest", "uiBuff", "cuDesc", "UDest", "zuDist", " uBuff", "udest", "uDi", "uiDist", "nuDest", "zuDest", "cuDest", "pDest", "uSource", "iuBuff", " udest", "uiDesc", "iSc", " uDi", "UForce", "nuSource", "cuSc", "iuSc", "iDest", "zuDesc", "uiForce", "iDist", "USc", "UDist", "pPriv", "iuDist", "uPriv", "uiStream", "nuStream", " uDist", "uiDest"], "dstW": ["DscW", "dstH", "Dstw", "dstCW", "dstaH", " drcH", "dstw", "drcH", "drcCW", " dstCW", "dscW", "DscH", "DstH", "dscCW", "drcW", "DscP", "dstaCW", "Dscw", "dstP", "dstaw", "dspH", "dscP", " drcw", "dstaW", "DstP", "drcP", " dstH", "dspW", "drcw", " dstw", "dspw", "dspP", "dscH", " drcCW", "dscw", "DstW", " drcW"], "chrDstW": ["chrNmtW", "chrDsnP", "chrDrcGW", "chrDsnC", "chrDSTN", "chrDSTWe", "chrDrcL", "chrSrcW", "chrSrcH", "chrDmtL", "chrDSTY", "chrDstsWe", "chrSrcGW", "chrDstH", "chrDrcC", "chrDstP", "chrNmtL", "chrNstL", "chrDSTW", "chrNstC", "chrKstW", "chrDmtC", "chrDstC", "chrDostSW", "chrDSTSW", "chrDsnL", "chrKstN", "chrNmtP", "chrDstSW", "chrNstW", "chrDostW", "chrSstGW", "chrDrcH", "chrKostWe", "chrDstWe", "chrKostSW", "chrDrcP", "chrSrcY", "chrDmtP", "chrDstL", "chrDostN", "chrDostH", "chrDSTH", "chrKstWe", "chrDstsW", "chrKostW", "chrKostN", "chrDstY", "chrSstH", "chrDstsSW", "chrDstsN", "chrDostGW", "chrNstP", "chrDrcY", "chrDSTGW", "chrDsnW", "chrDrcW", "chrDostWe", "chrSstW", "chrDstN", "chrDstGW", "chrSstY", "chrDmtW", "chrKstSW", "chrDostY", "chrNmtC"], "dstFormat": ["DscFormat", "dscFormat", "destFormat", "dspType", "DscFunction", " dscW", "DscType", "dscType", " dscType", "dscW", "DstFormat", "destF", " dscF", "destType", "dSTMethod", "dSTType", "DstType", "dstFunction", "dSTFormat", " dscFormat", "DstMethod", "DscMethod", "dSTF", "dscFunction", "dspFormat", " dstF", " dstType", "dscF", "dSTFunction", "dspFunction", "dstF", "DstFunction", "dstMethod", "dstType", "destW", "dSTW", "dscMethod", "dspMethod"], "i": ["ret", "cli", "key", "mini", "n", "g", "ti", "index", "x", "alpha", "f", "u", "ori", "at", "vi", "uri", "fi", "ami", "name", "abi", "zi", "ji", "pi", "ui", "id", "mi", "k", "iu", "api", "y", "ri", "z", "ie", "gu", "p", "e", "isi", "v", "qi", "ix", "t", "ik", "val", "io", "mu", "init", "me", "in", "layer", "li", "ni", "ii", "jit", "I", "di", "is", "m", "info", "slice", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "ei", "oi", "d", "it", "eni", "source", "ai", "ip", "l", "adi", "bi", "ki", "b", "line", "ci", "xi"], "j": ["js", "ld", "li", "adj", "q", "jl", "key", "ii", "ji", "jit", "jen", "d", "jj", "n", "J", "oj", "job", "it", "aj", "k", "ij", "uj", "y", "g", "jo", "m", "er", "fr", "bj", "z", "ch", "json", "ie", "x", "l", "h", "p", "pr", "jc", "ind", "e", "bi", "f", "jam", "br", "je", "u", "other", "jp", "el", "dj", "jet", "obj", "o", "v", "qi", "b", "ik", "ix", "val", "all", "si", "ja"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n", "idx": 3634, "substitutes": {"n": ["mn", "adj", "dn", "q", "not", "conn", "new", "r", "d", "nc", "un", "fn", "k", "nu", "ne", "na", "num", "y", "j", "g", "m", "none", "network", "nt", "z", "ns", "N", "c", "p", "l", "w", "e", "self", "f", "nb", "u", "node", "en", "o", "s", "nm", "v", "sn", "b", "t", "an", "nor", "on", "net"], "addr": ["oa", "dr", "route", "np", "arg", "name", "no", "ld", "offset", "mt", "conn", "nn", "host", "data", "sid", "url", "r", "loc", "ad", "add", "align", "xt", "rr", "alt", "ord", "arr", "adr", "pos", "mac", "code", "nr", "mid", "str", "md", "config", "address", "ack", "ip", "pad", "x", "p", "doc", "ptr", "len", "hop", "ref", "hd", "arm", "eth", "la", "fx", "ress", "amp", "node", "asm", "amd", "seq", "ix", "sta", "rx", "mode", "rt", "net", "ace", "rc"], "val": ["unit", "ret", "base", "vol", "delay", "ol", "offset", "def", "stat", "bit", "elt", "vals", "Val", "slot", "alt", "sl", "grad", "end", "pre", "max", "update", "pos", "index", "sel", "x", "ind", "len", "eval", "ref", "value", "el", "fx", "v", "old", "valid", "al", "reg", "VAL", "count", "start", "db", "mem"], "qid": ["Qbit", "dqinfo", "Qid", "Qno", "qpid", " qip", "viewid", "qis", "queryno", "sqip", " qide", "viewis", " qbit", "qsid", "sqid", " qsid", "Qip", " qi", "dqbit", " qids", "qId", "qip", "issueip", "qf", "sqis", "qbit", "issueid", "quide", "queryId", "dqip", "qqide", "qi", "qide", "qids", "queip", "dqid", "dqId", "quid", "quesid", "queryid", "qinfo", "issuesid", "Qids", "viewip", "issuepid", " qId", " qinfo", "viewinfo", " qno", "qno", "quepid", "quip", "sqinfo", "quin", " qis", "Qf", "dqf", "quinfo", "Qi", " qin", "qqid", " qpid", "qqin", "quf", "queid", "qui", "QId", "queryids", "qqinfo", " qf", "qin"], "start_sqs": ["start_reql", "start_squd", "start_qid", "start5sqp", "start5sqs", "start5eqp", "start_reqid", "start_qs", "start_sects", "start5eqches", "start_quid", "start_eqgs", "start_sqd", "start_eqches", "start5sqgs", "start_squs", "start_sectses", "start_sectd", "start_ql", "start_eqp", "start_qd", "start_qus", "start_squls", "start_sectls", "start_qqgs", "start_qud", "start_qqp", "start5sqches", "start_eqs", "start_qses", "start_qqches", "start_qls", "start_sqls", "start_sqid", "start5eqs", "start_qqs", "start_reqs", "start_qul", "start_sqp", "start_sqgs", "start_sql", "start_sqches", "start_squses", "start_reqd", "start5eqgs", "start_sqses"], "cq": ["gqi", "ocquire", "conquire", "cqs", "cfpe", "cQ", "ocq", "pce", "cpe", "cfqu", "cque", "acce", "acp", "ppe", "cfq", "cqt", "pql", " cque", "cp", "ecqa", "lcque", "ecqu", "encql", "acq", "pque", "lcce", "lcqs", "fcqs", " cp", "pqu", "conql", "qke", "cquire", "fcQ", "conqt", "pk", "cqi", "qqu", "gqt", "acqu", "dcqi", " cpe", "qq", "encqu", "conqi", "encq", "ecq", " cqi", "cce", "qQ", "pq", "gq", "acke", "ck", "gqu", "encue", " cw", "cke", "rcqu", "pqs", "dcue", " cce", " cquire", " cqu", "rcq", " cke", "acQ", " ck", "dcqu", "ocw", "acql", "lcq", "pQ", "fcqu", "acqa", "fcp", "cqa", "rcqa", "gqa", "conw", "cql", "dcql", "dcqt", "cfk", " cue", "fcqa", "dcq", "gql", "cue", "ocqi", "ecql", "fcq", " cqs", "cw", "cqu", " cql", " cQ", "conq", "rcQ", "fcql"], "sq": ["q", "qs", "queue", "ship", "ct", "client", "zz", "company", "sf", "scl", "sys", "sc", "join", "nox", "qa", "seq", "sky", "se", "zen", "cross", "quad", "sh", "sv", "request", "square", "lib", "qi", "su", "aq", "qq", "gh", "ssl", "ctx", "small", "squ", "quit", "pay", "sql", "ds", "dq", "pool", "sel", "eq", "cap", "hess", "ku", "fx", "apse", "kk", "quire", "supp", "req", "close", "shape", "qua", "qu", "qv", "liv", "Square", "pg", "cur", "query", "sk", "rf", "iq", "entry", "sync", "coll", "col", "ctrl", "sing", "pull", "view", "que"]}}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred(Indeo3DecodeContext *s)\n\n{\n\n  int i, j;\n\n\n\n  s->ModPred = av_malloc(8 * 128);\n\n\n\n  for (i=0; i < 128; ++i) {\n\n    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));\n\n    s->ModPred[i+1*128] = i ==   7 ?  20 :\n\n                          i == 119 ||\n\n                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));\n\n    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));\n\n    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));\n\n    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));\n\n    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));\n\n    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));\n\n    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));\n\n  }\n\n\n\n  s->corrector_type = av_malloc(24 * 256);\n\n\n\n  for (i=0; i < 24; ++i) {\n\n    for (j=0; j < 256; ++j) {\n\n      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :\n\n                                   j < 248 || (i == 16 && j == 248) ? 0 :\n\n                                   corrector_type_2[j - 248];\n\n    }\n\n  }\n\n}\n", "idx": 3658, "substitutes": {"s": ["sg", "js", "service", "cs", "ctx", "ss", "ops", "rs", "qs", "ts", "spec", "sb", "r", "d", "n", "is", "g", "vs", "ses", "ls", "sync", "ats", "settings", "sv", "sets", "ds", "utils", "ps", "gs", "ns", "h", "l", "c", "p", "services", "w", "e", "self", "f", "es", "features", "sys", "sq", "u", "gb", "lines", "south", "conf", "o", "v", "stats", "less", "su", "b", "S", "t", "session", "ks", "os", "bs", "its", "hs", "states", "fs", "si", "sym", "ssl"], "i": ["cli", "key", "n", "im", "g", "anti", "ti", "index", "x", "ind", "hi", "f", "u", "idi", "ori", "uri", "fi", "ami", "name", "abi", "ali", "esi", "ji", "zi", "pi", "ui", "image", "id", "mi", "iu", "api", "y", "ri", "z", "ie", "p", "e", "isi", "ia", "v", "ix", "qi", "ik", "me", "io", "init", "in", "li", "ni", "ii", "r", "I", "di", "is", "uli", "m", "info", "ini", "c", "phi", "o", "ic", "si", "yi", "gi", "http", "asi", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "adi", "bi", "ki", "b", "ci", "my", "xi"], "j": ["js", "adj", "li", "q", "jl", "key", "ni", "ii", "ji", "r", "jen", "d", "n", "jj", "J", "oj", "job", "im", "k", "aj", "ij", "uj", "y", "g", "m", "jo", "kj", "bj", "z", "ch", "ie", "x", "l", "h", "p", "pr", "bi", "jc", "e", "c", "f", "jam", "length", "je", "u", "jp", "note", "dj", "jet", "o", "v", "b", "qi", "ix", "si", "ja"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681, "substitutes": {"s": ["sg", "js", "service", "src", "cs", "ctx", "rs", "ts", "a", "context", "sb", "txt", "d", "i", "g", "m", "ses", "sf", "sync", "settings", "sv", "xs", "temp", "ds", "ps", "ns", "c", "p", "services", "w", "e", "f", "es", "sys", "sq", "u", "conf", "south", "v", "b", "su", "t", "S", "session", "support", "fs", "ssl"], "rlow": ["Rlower", "plow", "irmid", " rlo", "irlow", "rwlow", "rlower", "rmid", "rwmid", " rlower", "xlower", "Rhigh", "rlo", "xhigh", " rmid", "rwlo", "plower", "rold", "Rlow", "Rold", "irlower", "xlow", "irlo", "rwlower", "xold", "pold", "phigh"], "rhigh": [" rhighest", " rhi", "rrhigh", "rthi", "frhi", "rhighest", " rlimit", "rttop", "rthigh", "rtop", "rlimit", "frlimit", "rrlimit", "rhi", "rrhi", "frtop", "rrtop", "rrhighest", " rtop", "rthighest", "frhigh"], "val": ["base", "test", "vol", "ctx", "a", "elt", "vt", "vals", "data", "r", "loc", "Val", "fl", "prop", "alt", "sl", "py", "pre", "g", "j", "bl", "pos", "m", "cond", "temp", "func", "fe", "sel", "x", "ind", "p", "f", "eval", "ref", "len", "ffff", "value", "el", "min", "v", "b", "t", "var", "valid", "al", "reg", "VAL", "rt", "pt", "part", "xxx", "db"], "tmp": ["property", "np", "test", "vm", "ff", "src", "ctx", "TB", "vt", "sb", "txt", "data", "buff", "cro", "pb", "tab", "buf", "emp", "tc", "api", "py", "j", "pre", "boot", "tp", "rb", "m", "proc", "fp", "stuff", "cb", "storage", "temp", "config", "vv", "fake", "Temp", "p", "cv", "beta", "ptr", "nb", "f", "attr", "cache", "app", "br", "uv", "mp", "jp", "obj", "tt", "kk", "bt", "v", "fb", "b", "cp", "t", "abb", "tv", "rt", "pt", "part", "pot"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3691, "substitutes": {"s": ["sg", "js", "qs", "sites", "g", "ses", "ls", "args", "storage", "sie", "self", "us", "f", "secondary", "sys", "u", "changes", "se", "fs", "spec", "ts", "sb", "aws", "ims", "uns", "xs", "sets", "or", "p", "state", "e", "conf", "sports", "su", "site", "S", "os", "session", "ks", "t", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "strings", "d", "ans", "sis", "side", "sync", "status", "l", "services", "sq", "stats", "b", "full", "states"], "data": ["base", "response", "name", "buffer", "da", "offset", "def", "conn", "ui", "memory", "window", "ad", "field", "rec", "open", "id", "bin", "buf", "arr", "api", "batch", "next", "pos", "body", "info", "slice", "ds", "raw", "pad", "result", "x", "p", "block", "size", "length", "cache", "la", "DATA", "seq", "req", "bytes", "wa", "addr", "val", "dat", "limit", "Data", "start", "input", "mem"], "len": ["ret", "lock", "lan", "Len", "url", "n", "alt", "dl", "field", "lang", "err", "index", "f", "en", "seq", "lin", "valid", "rt", "limit", "all", "start", "name", "lif", "ln", "id", " ret", "end", "lt", "non", "lon", "lc", "length", "lit", "count", "val", "layer", "base", "led", "li", "offset", "lp", "bin", "pre", "lim", "body", "ll", "fin", "size", "ref", "cap", "el", "iter", "list", "done", "den", "elt", "lf", "un", "num", "pos", "nt", "rev", "l", "min", "line", "part"]}}
{"project": "FFmpeg", "commit_id": "29c2fcb6776f80a0a5551bb82b43bc14c8202331", "target": 1, "func": "static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)\n\n{\n\n    int16_t icoef;\n\n    int recent = s->cdlms[ich][ilms].recent;\n\n    int16_t range = 1 << (s->bits_per_sample - 1);\n\n    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample\n\n\n\n    if (input > pred) {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] +=\n\n                s->cdlms[ich][ilms].lms_updates[icoef + recent];\n\n    } else {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] -=\n\n                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?\n\n    }\n\n    s->cdlms[ich][ilms].recent--;\n\n    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);\n\n\n\n    if (input > pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];\n\n    else if (input < pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n\n\n\n    /* XXX: spec says:\n\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;\n\n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;\n\n\n\n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n\n        seperate buffers? Here I've assumed that the two are same which makes\n\n        more sense to me.\n\n    */\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n\n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n\n\n\n    if (s->cdlms[ich][ilms].recent == 0) {\n\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n\n                follow kshishkov's suggestion of using a union. */\n\n        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_prevvalues,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_updates,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;\n\n    }\n\n}\n", "idx": 3714, "substitutes": {"s": ["sg", "js", "this", "qs", "n", "sites", "g", "ses", "ls", "sf", "sie", "us", "self", "set", "f", "secondary", "sys", "sc", "your", "an", "se", "fs", "parts", "sup", "spec", "ts", "sb", "aws", "uns", "xs", "sv", "sets", "p", "state", "e", "conf", "less", "su", "site", "S", "t", "session", "ks", "os", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "is", "i", "ds", "ps", "gs", "native", "ns", "c", "es", "o", "si", "service", "ops", "sis", "comments", "sync", "tests", "ess", "l", "services", "w", "features", "sq", "b", "full", "states"], "ich": ["dr", "act", "ship", "chn", "current", "iche", "ct", "cand", "im", "code", "progress", "ind", "force", "unch", "ext", "host", "ish", "activity", "ht", "image", "form", "ict", "irc", "choice", "cot", "urn", "ill", "och", "aff", "org", "hp", "icy", "che", "iv", "ix", "qi", "hard", "cm", "imp", "chi", "icht", "ait", "hm", "isch", "chip", "el", "ic", "sim", "img", "inf", "ike", "anch", "ig", "isc", "intel", "ih", "rich", "conn", "strong", "igh", "ocl", "egg", "sk", "pect", "ah", "isol", "ch", "intelligence", "config", "mot", "impl", "ci", "ach", "dat", "arch", "ench"], "ilms": ["ulmos", "lms", "ailvs", "ailks", "ulme", "ILm", "elcs", "hlmm", "silmos", "ailmins", "alm", "silms", "ilcs", "hlmes", "almos", "ilMS", "silks", "lmos", "ailmes", "elMS", "hlks", "hlmad", "illks", "ilmins", "ailme", "ulmins", "illns", "elme", "elmins", "ilmm", "ailmos", "ilmad", "ailmad", "illcs", "elmm", "ailarms", "ulfs", "elms", "ilmos", "illmes", "silns", "olms", "ailfs", "ailms", "ILmm", "ILms", "ulmm", "hlms", "elks", "ailns", "ilm", "illmm", "elmad", "ulmes", "lmes", "illms", "lks", "olvs", "ailMS", "illarms", "elm", "silmes", "ailcs", "ulks", "ilvs", "ulms", "ailm", "olmm", "illmad", "ilmes", "hlm", "ILmes", "elarms", "ailmm", "ulm", "ulMS", "almm", "illfs", "illvs", "ilns", "illm", "alms", "ilarms", "ularms", "illmos", "hlns", "silmm", "ilks", "elmes", "ilfs", "ulns", "olks", "elmos", "ulmad", "ilme", "elns", "illme"], "input": ["include", "cli", "qq", "att", "intel", "q", "act", "active", "spec", "not", "conn", "context", "Input", "array", "audio", "image", "binary", "current", "form", "domain", "data", "format", "empty", "query", "concept", "client", "sample", "insert", "batch", "model", "irc", "in", "output", "iq", "i", "request", "source", "tif", "back", "config", "feed", "feature", "result", "alpha", "c", "phy", "state", "f", "length", "child", "inf", "text", "stream", "chip", "cmd", "amp", "qa", "supp", "error", "session", "img", "support", "view", "init", "inc", "uc", "accept"], "pred": ["adv", "defined", "prep", "bed", "rod", "rest", "def", "sd", "data", "new", "current", "form", "Pred", "prop", "rec", "orig", "buff", "ped", "fit", "client", "tmp", "next", "rend", "pre", "fitted", "actual", "rep", "future", "live", "cond", "cod", "proven", "last", "ind", "prom", "dev", "red", "ref", "stream", "range", "changed", "confirmed", "failed", "fetched", "old", "cell", "valid", "val", "eddy", "ed", "cast", "diff", "dist", "expected", "done"], "icoef": ["ichoaf", "ciaf", "icaeff", "icoalf", "miceff", "coof", "coeff", "iciuff", "ciene", "vocEF", "icaof", "coaf", "ICOeff", "voceff", "ICOEF", "cieff", "ciEF", "iconeff", "ciuff", "icief", "icheeff", "ICOeb", "icoec", "ichoeff", "coenge", "igoene", "ciefe", "ichoef", "floef", "micef", "ICOef", "icoeff", "ichoEF", "icoaf", "icoeb", "vocef", "icouff", "ichoec", "icaEF", "icoefe", "icoaxy", "iconception", "iscoEF", "ciof", "chiuff", "icaef", "icaaf", "icoEF", "iconaped", "icoaped", "icoception", "igoef", "igoefe", "icheaxy", "iconef", "ichoof", "micEF", "coception", "ciec", "coec", "chieff", "ichoaxy", "cieb", "cienge", "iconaxy", "icoof", "iciec", "micec", "floefe", "cief", "icaec", "coEF", "icheef", "icienge", "icoene", "icoenge", "chiec", "ICOalf", "iscoalf", "ichoalf", "igoeff", "ichoaped", "icaception", "floene", "floeff", "coef", "iscoef", "icieff", "icheaped", "voceb", "chief", "iconof"], "cdlms": ["mdlms", "cdlumm", "cdylems", "xdlmes", "cdlmm", "cdflcs", "cdylcs", "cdlamps", "xdllems", "dclumm", "ckljs", "cdslmm", "cdlmas", "cdlloms", "cdylms", "cdrmes", "clouddlmas", "cdulastics", "cdrlmas", "cdflmm", "cdLm", "cdolcs", "CDlps", "ddlims", "CDlms", "cmdhlmas", "ddellmes", " cddlfs", "dcrmm", "cdloms", "cdslfs", "cdolmm", "dclms", "cdalmm", "cdlems", "cdliamps", "xdlfs", " cdlfs", "cddlmes", "cdylmes", "codlvs", " cddlms", "cdklmm", "cdylm", "cdlcfs", "ckyloms", "cdlvs", "codflmm", "cdrmm", "ddellns", "cdaljs", " cdlmes", "cdhlastics", "cddlims", "cdsljs", "dclmm", "ddellims", "codlems", "cmdhlastics", "dcflmes", "cdellems", "cdellims", "xdllmm", "cdrlmm", "xdelmm", "dcluims", "xdllcs", "dcrems", "codlms", "cdlm", "cdrlm", "CDlimas", "codflmes", "cdnlems", "cdleems", "cdlpm", "ckylms", "cdlcps", "cdelvs", "cdlcms", "cdlps", "cdnlamps", "cdhlms", "cdklems", "dcflms", "cdllm", "cdljs", "codklms", "cklms", "cdlsms", "cdyloms", "cddlfs", "cddlm", "dcLmes", "xdelmes", "cdelmm", "cmdlastics", " cddlmes", "cdklms", "cmdhlems", "dclfs", "codklmm", "codlmes", "cddlms", "cdnlps", "cdflmes", "xdlcs", "ddlms", "codflms", "cdellmm", "CDlmas", "cdlcmes", "cdklastics", "cdnlmm", "cdyljs", "cdlljs", "cdlimas", "cdleims", "cdrlmes", "cdulm", "cdolms", "cdlfs", "cdnlcs", "cloudlmas", "cdklvs", "codflems", "cdflms", "clouddlm", "dcrms", "cdelfs", "cdlcmas", "cdelmes", "mdlfs", "cdflems", "cdellns", "cdlsfs", "cdnlms", "cdlastics", "cdrlfs", "cdlips", "CDlips", "clouddlims", "cdlens", "cdylmm", "cdlefs", "cdlns", "xdlms", "cdnlvs", "cdlemm", "cdlsmes", "cdelms", "codklvs", "dcLpm", "ckylmm", "cdlmes", "cmdlms", "cdslms", "cloudlims", "cmdlmas", "dcflems", "cdellmes", "dcflcs", " cdlems", "CDlims", "cdellms", "cdluims", "cdlymm", "cdlims", "ckyljs", "cdelems", "cdrlms", "cdllmm", "ddellms", "cdeljs", "cloudlm", "mdeljs", "cdelns", "cdrljs", "CDliamps", "dclpm", "ckloms", "cdLmes", "codklmes", "cddlmas", "cdllcs", "cdluns", "cmdlems", "mdljs", "cdhlmas", "cdhlems", "cdolfs", "dclm", "cdlums", "cdaloms", "cdllims", "cdulmas", "cdnlmes", "mdlmm", "dclems", "cdrms", "dcrmes", "cdLms", "ddlns", "codlmm", "cloudlms", "cdrlns", "dclymes", "dclyfs", "dclims", "cddlems", "CDlamps", " cddlems", "cdilems", "cdolems", "dcluns", "xdllms", "dclcs", "cdilcs", "cdlcamps", "dclymm", "cdklmes", "cdlyms", "cdylvs", "cdlymes", "xdelfs", "cdelims", "dclmes", "cdulems", "cdllmas", "cdlemes", "cdllems", "xdlmm", "cdilmes", "xdlems", "cdlsmm", "xdelvs", "mdelfs", "cdylpm", "cdrlims", "cdolmes", "dclums", "dcLm", "ddlmes", "mdelms", "cdulpm", "xdlvs", "xdelms", "cdlcs", "cdulms", "cdlcmm", "cdlumes", "cdulmes", "cdLpm", "cmdhlms", "mdelmm", "cdilms", "dclns", "cdlyfs", "cdnlmas", "dcLms", "dclyms", "clouddlms", "cdalms", "cdllms", "cdklmas", "cklmm", "cdrems"], "recent": ["allow", "row", "large", "active", "command", "current", "folder", "rec", "client", "many", "event", "currently", "progress", "archive", "significant", "aug", "qa", "today", "valid", "quick", "running", "ready", "extra", "common", "dom", "off", "gap", "component", "create", "hold", "post", "example", "custom", "session", "sofar", "good", "received", "version", "new", "small", "complete", "Recent", "modern", "popular", "record", "remote", "unique", "feat", "reported", "last", "raw", "ide", "original", "date", "ctr", "history", "region", "confirmed", "old", "past", "gen", "low", "reg", "expected", "stage", "ale", "gpu", "prop", "orig", "ord", "now", "num", "future", "item", " recently", "feature", "random", "range", "full", "latest", "diff", "since", "complex", "desc", "dist"]}}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3721, "substitutes": {"filt_ctx": ["fill_c", "filt_ca", "fil_conn", "filt_voc", "fil_voc", "filt___voc", "filt___ctx", "filt___context", "fil_scope", "flt_ctx", "fill_ctx", "flt_loc", "filt_context", "filt_conn", "fil_cmd", "filt_lc", "filt_scope", "flt_cp", "fill_context", "filt_c", "flt_conn", "flt_lc", "flt_context", "filt___ca", "fil_ca", "filt_cs", "fil_context", "fill_ca", "filt_cp", "filt_loc", "fil_ctx", "fil_cs", "filt_cmd"], "ctx": ["fc", "cm", "cli", "cam", "src", "cs", "conn", "context", "cc", "cpp", "Context", "loc", "ck", "bc", "graph", "scope", "tc", "concept", "client", "cas", "comp", "tx", "cb", "config", "crit", "pkg", "cu", "c", "cv", "xc", "lc", "cn", "sc", "ctrl", "ca", "exec", "cmd", "obj", "pc", "cca", "connection", "qa", "cp", "cmp", "cf", "conv", "support", "ci", "cfg", "rc"], "index": ["match", "Index", "base", "name", "offset", "find", "active", "context", "current", "image", "column", "loc", "type", "id", "fff", "end", "num", "search", "instance", "pos", "info", "slice", "config", "x", "ind", "example", "len", "length", "ref", "f", "col", "size", "connection", "prefix", "depth", "addr", "part", "inc", "input"], "filt_name": ["flt_Name", "fil_name", "filtPName", "factory_NAME", "filtacNAME", "filtacnames", "filt_names", "filt__NAME", "filt_value", "filt__type", "fillFvalue", "filtPname", "fillFName", "factory_name", "filt__name", "filt_block", "filtFname", "factoryactype", "factoryacname", "filtactype", "filt_id", "flt_name", "filtFName", "fil_names", "filt_NAME", "ffilter_name", "factoryacNAME", "fill_value", "factory_type", "filtPpath", "factory_names", "filtFvalue", "flt_id", "filt__names", "fill_Name", "filt_Name", "flt_node", "ffilter_Name", "filt__Name", "ffilter_path", "factoryacnames", "filt_path", "filt_node", "fill_name", "fillFname", "filtacname", "filt_type", "ffilter_block", "fil_Name", "filtPblock"], "args": ["limits", "files", "arg", "missing", "ig", "name", "ics", "alls", "groups", "works", "null", "ass", "extra", "spec", "array", "actions", "acl", "vals", "data", "ips", "flags", "strings", "results", "help", "empty", "objects", "includes", "links", "arr", "enc", "options", "ids", "comments", "params", "bits", "body", "ars", "resources", "names", "cards", "ras", "config", "ams", "gs", "str", "result", "example", "p", "items", "afi", "values", "atts", "lines", "size", "cache", "alloc", "fields", "blocks", " arguments", "qa", "ay", "Args", "bytes", "changes", "ages", "init", "parts", "allows"], "log_ctx": ["log_cn", "logwcb", "log_ca", "logalcn", "failpcf", "log_fn", "logpctx", "log_sys", "logerctx", "logpfn", "fail_fn", "tagercb", "logpcn", "failpcn", "tagersys", "logencci", "logboardctx", "log_scope", "logervc", "fail_ctx", "tag_cb", "logingvc", "log_vc", "Log_ctx", "tagerctx", "logwvc", "lock_cci", "tag_ctx", "logenscope", "logenctx", "logercb", "logalctx", "Log_context", "logboardcontext", "lock_scope", "lock_ca", "failpctx", "log_cf", "logwctx", "logingcb", "logboardjc", "logingctx", "tag_vc", "logwsys", "logersys", "log_sc", "logalcf", "tagervc", "Log_jc", "logboardsc", "lock_ctx", "logalfn", "logpcf", "fail_cn", "log_cci", "log_cb", "failpfn", "logenca", "tag_sys", "Log_sc", "fail_cf", "logingsys", "log_context", "log_jc"], "filt": ["infizzle", "Filt", "sfizzle", "flld", "bil", "dfil", " fld", "inffilter", "filler", " facet", "firt", "flt", "Flt", "dfld", "biller", "infilt", "sflt", "sfld", "sfilt", "fil", "Facet", " fil", "bilt", "dfiller", "dfilt", "sffilter", "infld", " filler", "bld", "sfacet", "infirt", "fizzle", " flt", "fld", "facet", "ffilter", "Fizzle", "flizzle", "flilt", " ffilter", " fizzle", " firt", "flirt"], "inst_name": ["instacdata", "inst__span", "inst__id", "instameName", "Inst_data", "inst_conn", "inst_id", "inst_Name", "instamename", "instameid", " inst_conn", "inst_data", "inst_prefix", "instance_info", "inst_names", " inst_span", "inst__name", "instamespan", "inst__Name", "Inst_names", "Inst_name", "instance_name", " inst_id", "instacnames", "inst_info", "inst_span", " inst_names", "instacname", "instance_names", "instance_prefix", " inst_Name"], "tmp_args": ["tmp_items", " tmp_arg", "tmp_ams", "temp_members", " tmp_parts", "tmp2args", "tmp_params", "tmp_arg", "tmp_options", "tmp_members", "temp_items", "temp_ams", " tmp_options", "temp_errors", "tmp2parts", "temp_arg", "tmp_errors", "temp_args", "tmp2arg", "tmp_parts", "tmp2caps", "tmp_caps", " tmp_params", " tmp_caps"], "ret": ["match", "base", "arg", "fun", "att", "mt", "ext", "utf", "def", "gc", "success", "data", "url", "r", "alt", "cur", "job", "pet", "rets", "grad", "arr", "num", "pass", "fail", "rb", "code", "info", "ft", "nt", "err", "str", "reply", "feat", "Ret", "back", "tr", "bad", "opt", "result", "bot", "ut", "f", "len", "flag", "ref", "red", "gt", "value", "obj", "RET", "valid", "al", "re", "run", "val", "reg", "rt", "part", "lit", "let", "det", "res", "debug", "db", "rc", "mem"]}}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n", "idx": 3722, "substitutes": {"s": ["sg", "js", "this", "qs", "n", "sites", "g", "ses", "ls", "sf", "args", "self", "f", "sys", "u", "se", "fs", "parts", "sup", "spec", "ts", "sb", "ims", "y", "uns", "xs", "sets", "p", "e", "lines", "conf", "comm", "v", "less", "su", "site", "S", "os", "t", "session", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "m", "settings", "ds", "ps", "gs", "ns", "h", "es", "south", "sec", "o", "si", "server", "service", "ops", "ms", "side", "sync", "tests", "l", "services", "w", "features", "sq", "b", "full", "states"], "i": ["cli", "yi", "li", "gi", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "mini", "I", "di", "is", "id", "mi", "it", "iu", "k", "j", "y", "eni", "ri", "code", "info", "ti", "slice", "ini", "z", "multi", "ch", "index", "ai", "ie", "ip", "x", "p", "hi", "bi", "l", "e", "phi", "f", "u", "o", "v", "ki", "qi", "ix", "b", "uri", "ci", "io", "init", "fi", "si", "in", "xi"], "send_coef_bits": ["send_coefxbits", "send_coiffacvals", "send_coeff_jobs", "send_coeff_dates", "send_coef32bits", "send_coef_dates", "send_coof_notes", "send_coef2jobs", "send_coefxparts", "send_coeff_bits", "send_coeff_words", "send_coefacbits", "send_coef_jobs", "send_coef2bit", "send_coefacvals", "send_coefacdetails", "send_coef2bits", "send_coof_details", "send_coefxdetails", "send_coef_parts", "send_coef_blocks", "send_coefpbit", "send_coef32vals", "send_coiffacdetails", "send_coiff_vals", "send_coiff_bits", "send_coeff_blocks", "send_coiffacpoints", "send_coiff_points", "send_coof_bits", "send_coefpdates", "send_coiffacbits", "send_coef_bit", "send_coefpblocks", "send_coef_vals", "send_coefxnotes", "send_coef2words", "send_coef32points", "send_coeff_bit", "send_coef_details", "send_coof_parts", "send_coef_notes", "send_coefpbits", "send_coefacpoints", "send_coef_points", "send_coef_words", "send_coef32details", "send_coiff_details"], "cbits": ["lcbit", "pcbands", "dcjobs", " cbps", "cints", " cbytes", "cits", "Cbits", "cbytes", "cplanes", "ucubs", " crows", "fubs", "cbit", "pcbits", "Cbps", " csteps", " cjobs", "pclocks", " cbs", " cbands", "fits", " clocks", "pcjobs", "lcubs", "cbands", "cbugs", "Cbytes", "cfbits", "ucplanes", "lcbits", "ecbs", "clocks", "dcbands", "cfbps", "cbs", "ecsteps", "ucbits", " cbugs", "cfbytes", "cfubs", "dclocks", "Cbugs", "ccbytes", "cfsteps", "ccbugs", "cfrows", "cjobs", "dcbits", "fbit", "crbps", "cubs", "crbits", " cints", "cfints", "crubs", "ecbits", "cfbs", "cbps", "fbits", " cits", " cbit", " cplanes", "ecrows", "ccbps", " cubs", "ucbytes", "csteps", "crows", "crints", "ccbits", "lcits", "cfplanes"], "c": ["cycle", "q", "cc", "r", "d", "n", "co", "ct", "nc", "bc", "cur", "chain", "cy", "k", "y", "ac", "m", "code", "cr", "z", "ch", "C", "ec", "dc", "ce", "x", "cu", "p", "xc", "l", "w", "e", "lc", "f", "col", "arc", "oc", "cache", "ca", "u", "sc", "core", "o", "v", "pc", "b", "cp", "t", "cf", "ic", "ci", "count", "inc", "uc", "ice"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void ppc_spapr_init(ram_addr_t ram_size,\n                           const char *boot_device,\n                           const char *kernel_filename,\n                           const char *kernel_cmdline,\n                           const char *initrd_filename,\n                           const char *cpu_model)\n{\n    PowerPCCPU *cpu;\n    CPUPPCState *env;\n    int i;\n    MemoryRegion *sysmem = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    target_phys_addr_t rma_alloc_size, rma_size;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long load_limit, rtas_limit, fw_size;\n    long pteg_shift = 17;\n    char *filename;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n    if (rma_alloc_size == -1) {\n        hw_error(\"qemu: Unable to create RMA\\n\");\n        exit(1);\n    }\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n        rma_size = rma_alloc_size;\n    } else {\n        rma_size = ram_size;\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    rtas_limit = MIN(rma_size, 0x80000000);\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n    /* init CPUs */\n    if (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, cpu);\n        env->hreset_vector = 0x60;\n        env->hreset_excp_prefix = 0;\n        env->gpr[3] = env->cpu_index;\n    }\n    /* allocate RAM */\n    spapr->ram_limit = ram_size;\n    if (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n    }\n    /* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM */\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->external_htab = spapr->htab;\n        env->htab_base = -1;\n        env->htab_mask = spapr->htab_size - 1;\n        /* Tell KVM that we're in PAPR mode */\n        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        env->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(env);\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n                                           rtas_limit - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(filename);\n    /* Set up Interrupt Controller */\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    /* Set up VIO bus */\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n    }\n    /* Set up PCI */\n    spapr_create_phb(spapr, \"pci\", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (i = 0; i < nb_nics; i++) {\n        NICInfo *nd = &nd_table[i];\n        if (!nd->model) {\n            nd->model = g_strdup(\"ibmveth\");\n        }\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n            spapr_vlan_create(spapr->vio_bus, nd);\n        } else {\n            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n        }\n    }\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, \"sPAPR memory map:\\n\");\n    fprintf(stderr, \"RTAS                 : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, \"FDT                  : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (kernel_filename) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename,\n                                              KERNEL_LOAD_ADDR,\n                                              load_limit - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n            exit(1);\n        }\n        fprintf(stderr, \"Kernel               : 0x%08x..%08lx\\n\",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        /* load initrd */\n        if (initrd_filename) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}", "idx": 3731, "substitutes": {"ram_size": ["ram64size", "ram_shift", "ramallshift", "ramalllimit", "ram_limit", "ram_content", "ram_name", "ram64address", "gram_name", "ram_address", "mem_limit", "mem_capacity", "mem_size", "mem_number", "ram64content", "gram_size", "ram_capacity", "ramallsize", "gram_content", "disk_shift", "gram_address", "ram_number", "disk_size", "disk_limit", "ram64name"], "boot_device": ["boot_model", "bootaldevice", "kernel_device", "bootboarddevice", "boot_platform", "bootalplatform", "kernel_model", "bootboardmode", "boot_mode", "kernel_mode", "kernel_platform", "bootalmode", "bootboardplatform", "bootalmodel", "bootboardmodel"], "kernel_filename": ["kernelnfilename", "kernel_file", " kernel_file", " kernel_platform", " kernel_mode", "kernel_mode", "kernel_platform", "kernelnmode", "kernelnfile", "kernelnplatform"], "kernel_cmdline": ["kernel_argline", "kernel_hostlen", "kernel_hostline", "kernel_argname", "kernel_cmdlines", "kernel_commandname", "kernel_arglen", "kernel_arglines", "kernel_cmdname", "kernel_commandlen", "kernel_hostname", "kernel_cmdlen", "kernel_commandlines", "kernel_commandline", "kernel_hostlines"], "initrd_filename": ["initrt_filename", "initrd_buffer", "initrd_name", "initrd_file", "initrt_file", "initrt_name", "initrt_buffer"], "cpu_model": ["cpu_service", "pu_models", " cpu_Model", "pu__state", "pu__controller", "cpu_controller", "cpu67unit", "processor_service", "cpu_state", "cpu67Model", "CPU_models", "processor_model", "pu_state", "pu_controller", "CPU_Model", "processor_mode", "cpu67model", "cpu_mode", "cpu__controller", " cpu_module", "cpu67models", "cpu__model", "cpu_module", "cpu__state", " cpu_models", "pu__model", "cpu_models", "pu_model", "CPU_unit", "cpu_Model", "cpu_unit", "pu__models", "cpu__models", "CPU_model", "processor_module"], "cpu": ["np", "chu", "vm", "consumer", "xi", "gpu", "uno", "ctx", "hw", "conn", "ni", "gc", "process", "PU", "computer", "clock", "uci", "GPU", "nc", "pn", "lu", "nic", "pb", "platform", "nu", "ne", "num", "instance", "kernel", "auc", "hu", "eni", "CPU", "proc", "pai", "python", "pool", "config", "bench", "runner", "p", "css", "lc", "pu", "cache", "core", "hp", "cn", "processor", "node", "linux", "pc", "cp", " CPU", "cmp", "uca", "uu", "gp", "performance", "rc"], "env": ["eu", "np", "vm", "ext", "agents", "enable", "conn", "context", "queue", "environment", "global", "shell", "profile", "ea", "dict", "scope", "assets", "eng", "here", "enc", "ef", "eni", "args", "network", "dep", "estate", "dest", "err", "ani", "ep", "config", "ec", "exc", " environment", "eye", "Environment", "vel", "state", "stack", "e", "attr", "core", "cache", "conf", "skin", "gui", "viron", "el", "en", "v", "ev", "session", "cfg", "net", "que", "console", "edge", "energy", "db"], "i": ["ami", "li", "gi", "a", "ni", "ii", "chi", "pi", "ui", "mini", "oi", "d", "I", "n", "di", "is", "id", "uli", "mi", "iu", "k", "j", "m", "eni", "anti", "ri", "ti", "ini", "z", "index", "multi", "ai", "ip", "c", "p", "gu", "hi", "w", "e", "phi", "f", "u", "o", "v", "ki", "b", "qi", "t", "ix", "uri", "sim", "ci", "io", "mu", "fi", "si", "in", "xi"], "sysmem": ["ysmodel", "ysram", "syslim", "sysmodel", "sysmax", "systemmodel", "Sysmon", "systemmem", " sysmemory", "sysram", " syslim", "Sysmax", "sysmemory", "osmon", " sysmax", " sysram", "osmem", "oslim", "systemmemory", "ysmem", "Syslim", "ysmemory", " sysmon", "systemram", "osmax", "Sysmem", "sysmon", " sysmodel"], "ram": ["rage", "cam", "gram", "array", "access", "dim", "image", "mm", "Ram", "iam", "ra", "network", "config", "RAM", "gam", "disk", "man", "cow", "resource", "loader", "cache", "sc", "range", "region", "rum", "img", "gra", "mem"], "rma_alloc_size": ["rma_oc_len", "rma_alloc0scale", "rma_disk0size", "rma_raw_size", "rma_alloc1size", "rma_raw_len", "rma_alloc64weight", "rma_disk_capacity", "rma_allocadsize", "rma_disk0scale", "rma_alloc67value", "rma_disk_limit", "rma_alloc1name", "rma_alloclexsize", "rma_alloc64sn", "rma_alloc67size", "rma_alloc1address", "rma_alloc_capacity", "rma_alloclexnumber", "rma_allocadvalue", "rma_alloclexvalue", "rma_alloc_len", "rma_alloc_limit", "rma_raw_number", "rma_alloc67len", "rma_alloc_number", "rma_disk_scale", "rma_alloc_small", "rma_raw67size", "rma_alloc_offset", "rma_alloc_storage", "rma_alloc_scale", "rma_alloc0capacity", "rma_alloclexlen", "rma_disk0limit", "rma_alloc_address", "rma_alloc_name", "rma_allocaclen", "rma_alloc0limit", "rma_oc_size", "rma_oc_small", "rma_alloc0size", "rma_disk_size", "rma_raw67len", "rma_allocadlen", "rma_alloc1storage", "rma_alloc64address", "rma_alloc_stream", "rma_allocadnumber", "rma_alloc64size", "rma_allocacstream", "rma_raw_value", "rma_raw67value", "rma_raw67number", "rma_allocacsize", "rma_allocacsmall", "rma_alloc_weight", "rma_alloc_sn", "rma_alloc_value", "rma_disk0capacity", "rma_oc_stream", "rma_alloc67number"], "rma_size": ["rlia67address", "rma___length", "rma_handle", "rlia_size", "rma_shape", "rlia_address", "rma_address", "rma_term", "rsha_full", "rma__size", "rma67term", "rma_name", "rma__shape", "rlia67size", "rma___size", "rma67size", "rma67capacity", "rma_full", "rma_length", "rsha_length", "rda_capacity", "rma67address", "rda_name", "rama_capacity", "rlia67term", "rma__term", "rsha_capacity", "rma67shape", "rlia67shape", "rma___full", "rlia_shape", "rda_size", "rama_source", "rma__address", "rsha_size", "rma_source", "rda_handle", "rma67name", "rama_size", "rma_capacity", "rama_speed", "rma67handle", "rlia_term", "rma___capacity", "rma_speed"], "load_limit": ["load_limits", " load_lim", "loadallsource", "load_origin", "load_source", "fw_lim", " load_limits", "loadalllim", "load_lim", "loadalllimit", "fw_position", "loadallposition", "fw_limit", "fw_source", " load_origin", "load_position"], "rtas_limit": ["rtas_num", "rtas_limited", "rtas_large", "rtma2limit", "rtma2size", "rtras_limited", "rtma_size", "rtma_limit", "rtas_limits", "rtas2len", "rtma_num", "rtras_size", "rtma2len", "rtas_len", "rtas2lim", "rtas_size", "rtras_limit", "rtma2lim", "rtma_lim", "rtas2limit", "rtas2size", "rtas_lim", "rtma_len", "rtma_large", "rtras_limits"], "fw_size": ["hw_offset", "fw0data", "fw_data", "fwlexscale", "fw0offset", "hw_scale", "fw_offset", "fw0size", "fwlexdata", "hw_size", "hw_data", "fw_scale", "fwlexsize", "fwlexoffset", "fw0scale"], "filename": ["files", "name", "src", "buffer", "fd", "acl", "memory", "url", "binary", "shell", "fn", "wav", "buf", "Filename", "file", "fp", "password", "dll", "f", "kl", "loader", "username", "prefix", "path"]}}
{"project": "FFmpeg", "commit_id": "69d0a2922f76e4e121c9f434bdf29f55b26c0c66", "target": 0, "func": "static av_cold int sonic_encode_init(AVCodecContext *avctx)\n\n{\n\n    SonicContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    int i, version = 0;\n\n\n\n    if (avctx->channels > MAX_CHANNELS)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo streams are supported by now\\n\");\n\n        return AVERROR(EINVAL); /* only stereo or mono for now */\n\n    }\n\n\n\n    if (avctx->channels == 2)\n\n        s->decorrelation = MID_SIDE;\n\n    else\n\n        s->decorrelation = 3;\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)\n\n    {\n\n        s->lossless = 1;\n\n        s->num_taps = 32;\n\n        s->downsampling = 1;\n\n        s->quantization = 0.0;\n\n    }\n\n    else\n\n    {\n\n        s->num_taps = 128;\n\n        s->downsampling = 2;\n\n        s->quantization = 1.0;\n\n    }\n\n\n\n    // max tap 2048\n\n    if ((s->num_taps < 32) || (s->num_taps > 1024) ||\n\n        ((s->num_taps>>5)<<5 != s->num_taps))\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of taps\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    // generate taps\n\n    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));\n\n    for (i = 0; i < s->num_taps; i++)\n\n        s->tap_quant[i] = ff_sqrt(i+1);\n\n\n\n    s->channels = avctx->channels;\n\n    s->samplerate = avctx->sample_rate;\n\n\n\n    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);\n\n    s->frame_size = s->channels*s->block_align*s->downsampling;\n\n\n\n    s->tail_size = s->num_taps*s->channels;\n\n    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));\n\n    if (!s->tail)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );\n\n    if (!s->predictor_k)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < s->channels; i++)\n\n    {\n\n        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));\n\n        if (!s->coded_samples[i])\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n\n\n\n    s->window_size = ((2*s->tail_size)+s->frame_size);\n\n    s->window = av_calloc(s->window_size, sizeof(*s->window));\n\n    if (!s->window)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->extradata = av_mallocz(16);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&pb, avctx->extradata, 16*8);\n\n\n\n    put_bits(&pb, 2, version); // version\n\n    if (version == 1)\n\n    {\n\n        put_bits(&pb, 2, s->channels);\n\n        put_bits(&pb, 4, code_samplerate(s->samplerate));\n\n    }\n\n    put_bits(&pb, 1, s->lossless);\n\n    if (!s->lossless)\n\n        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision\n\n    put_bits(&pb, 2, s->decorrelation);\n\n    put_bits(&pb, 2, s->downsampling);\n\n    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024\n\n    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table\n\n\n\n    flush_put_bits(&pb);\n\n    avctx->extradata_size = put_bits_count(&pb)/8;\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n\n        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n\n\n    avctx->frame_size = s->block_align*s->downsampling;\n\n\n\n    return 0;\n\n}\n", "idx": 3743, "substitutes": {"avctx": ["afconfig", "aveconfig", "evctx", "AVctx", "evcontext", "alconn", "avectx", "appcontext", "evcf", "avconn", "afcmp", "afctx", "afcontext", "avecf", "alcontext", "aveconn", "alctx", " avcli", "avcli", "appctx", "appcmp", "AVconn", "avcf", " avcontext", " avcf", "AVconfig", "rafconn", "rafctx", "afconn", "afcn", "AVcms", "afcms", "abctx", "appcn", "rafcms", "afcf", "avcn", "AVcn", "avconfig", "abconfig", "avcontext", "abconn", "abcontext", "avecontext", "evconn", "rafcontext", "AVcf", "avcmp", "AVcli", "AVcmp", "AVcontext", "alcli", "avecmp", "avcms", " avconn"], "s": ["sg", "js", "this", "qs", "n", "sites", "g", "ses", "ls", "args", "vs", "self", "us", "f", "secondary", "sys", "sc", "u", "your", "fs", "parts", "spec", "ts", "aws", "ims", "uns", "xs", "sets", "p", "e", "conf", "as", "uses", "v", "less", "su", "site", "S", "t", "session", "ks", "os", "its", "bs", "hs", "in", "sym", "plugins", "ssl", "cs", "ctx", "ss", "rs", "a", "new", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "native", "ns", "h", "c", "rates", "es", "sec", "o", "si", "server", "ops", "d", "results", "ms", "sync", "ats", "tests", "l", "services", "w", "features", "sq", "stats", "b", "full", "states"], "pb": [" img", " config", "ctx", " sc", " std", " subp", " src", " self", " acc", " enc", " out", " conv", " impl", " plugin", " app", " cipher", " sp", " conf", " proto", " parent", " pl", " sup", " mc", " rc"], "i": ["yi", "version", "li", "abi", "gi", "counter", "a", "key", "ni", "ii", "zi", "chi", "ji", "current", "pi", "ui", "mini", "d", "n", "I", "type", "di", "id", "mi", "uli", "k", "iu", "it", "num", "j", "y", "eni", "m", "inner", "info", "ti", "multi", "index", "z", "ini", "ai", "x", "ip", "hi", "p", "phi", "bi", "c", "e", "len", "u", "o", "v", "ix", "qi", "b", "t", "ci", "count", "io", "mu", "fi", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n\n{\n\n    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n\n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n\n\n    if (mode > 6U) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"out of range intra chroma pred mode at %d %d\\n\",\n\n               h->mb_x, h->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if (!(h->top_samples_available & 0x8000)) {\n\n        mode = top[mode];\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n\n        mode = left[mode];\n\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n\n                   (!(h->left_samples_available & 0x8000)) +\n\n                   2 * (mode == DC_128_PRED8x8);\n\n        }\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n", "idx": 3748, "substitutes": {"h": ["H", "ctx", "http", "bh", "q", "ih", "hw", "conn", "context", "dh", "hash", "host", "ht", "r", "header", "sh", "ph", "th", "hist", "k", "auth", "uh", "ha", "y", "g", "hu", "m", "hr", "ah", "ch", "home", "hm", "l", "c", "p", "hi", "him", "hh", "e", "f", "hd", "eh", "u", "hp", "history", "v", "hl", "adh", "um", "b", "t", "he", "hs", "kh", "oh", "rh", "gh"], "mode": ["route", "key", "device", "command", "dim", "success", "when", "go", "de", "move", "code", "mid", "direction", "home", "shift", "du", "theme", "message", "power", "option", "rage", "name", "time", "access", "ui", "type", "position", "id", "mi", "model", "max", "ode", "step", "gone", "state", "core", "maybe", "driver", "scale", "site", "Mode", "me", "MODE", "mate", "guide", "version", "mod", "mega", "ror", "ward", "use", "kind", "member", "language", "m", "project", "result", "role", "size", "date", "cmd", "phase", "error", "module", "rule", "slave", "ride", "stage", "cost", "match", "level", "delay", "no", "method", "grade", "purpose", "month", "ko", "side", "mage", "none", "mission", "style", "source", "md", "lane", "feature", "range", "depth", "ace", "rc"], "is_chroma": ["is_opera", "is_chromi", "is_chromA", "is_opero", "is_roman", "is_comas", "is_romb", "is_coma", "is_romas", "is_romo", "is_comA", "is_operb", "is_roma", "is_chromb", "is_operan", "is_operas", "is_romi", "is_romA", "is_operi", "is_chromas", "is_operA", "is_coman", "is_chromo", "is_chroman"], "top": ["call", "to", "primary", "above", "upper", "current", "high", "header", "ap", "head", "op", "first", "next", "max", "toc", "master", "config", "opt", "bot", "best", "pop", "hop", "prev", "front", "all", "up", "TOP", "dot", "full", "tops", "root", "Top", "bottom", "plus", "table"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n", "idx": 3755, "substitutes": {"info": ["this", "txt", "from", "next", "options", "home", "opt", "hi", "private", "f", "comment", "qa", "manager", "start", "name", "ami", "tf", "extra", "image", "ui", "help", "id", "end", "Info", "auth", "api", "off", "update", "parse", "p", "state", "conf", "die", "io", "init", "base", "li", "offset", "INFO", "ii", "fw", "data", "new", "di", "add", "ions", "op", "py", "i", "inner", "util", "back", "result", "afi", "setup", "iso", "app", "note", "about", "obj", "error", "si", "inf", "fo", "check", "http", "def", "show", "it", "now", "tp", "config", "hand", "full", "part", "diff"], "as": ["parser", "to", "nas", "so", "acs", "asu", "http", "ss", "ass", "a", "sa", "ga", "rs", "spec", "alias", "asi", "ans", "ap", "ase", "aws", "ma", "is", "auth", "asp", "api", "off", "ac", "ars", "ras", "ams", "bas", "asc", "address", "func", "pa", "or", "afi", "us", "As", "pas", "AS", "ar", "sys", "s", "at", "asm", "os", "var", "session", "al", "las", "bs", "an", "by", "am", "ast", "se", "ace"]}}
{"project": "qemu", "commit_id": "4fb588e95bacb770746cc794ef165fd71a4d27ea", "target": 0, "func": "static void block_job_completed_txn_abort(BlockJob *job)\n\n{\n\n    AioContext *ctx;\n\n    BlockJobTxn *txn = job->txn;\n\n    BlockJob *other_job, *next;\n\n\n\n    if (txn->aborting) {\n\n        /*\n\n         * We are cancelled by another job, which will handle everything.\n\n         */\n\n        return;\n\n    }\n\n    txn->aborting = true;\n\n    /* We are the first failed job. Cancel other jobs. */\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        aio_context_acquire(ctx);\n\n    }\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        if (other_job == job || other_job->completed) {\n\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n\n             * them; this job, however, may or may not be cancelled, depending\n\n             * on the caller, so leave it. */\n\n            if (other_job != job) {\n\n                block_job_cancel_async(other_job);\n\n            }\n\n            continue;\n\n        }\n\n        block_job_cancel_sync(other_job);\n\n        assert(other_job->completed);\n\n    }\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        block_job_completed_single(other_job);\n\n        aio_context_release(ctx);\n\n    }\n\n}\n", "idx": 3763, "substitutes": {"job": ["ob", "route", "base", "sub", "lock", "queue", "process", "new", "image", "jobs", "unknown", "worker", "section", "parent", "pb", "client", "batch", "j", "output", "jo", "sync", "project", "cb", "event", "bug", "live", "config", "runner", "fake", "address", "result", "block", "work", "child", "better", "object", "node", "connection", "b", "plugin", "error", "module", "session", "manager", "Job", "hide", "run", "slave", "db"], "ctx": ["fc", "cm", "np", "cs", "kb", "conn", "context", "gc", "acl", "txt", "cc", "anc", "mc", "loc", "ct", "ck", "co", "bc", "voc", "scope", "grad", "buf", "cus", "client", "cas", "mac", "fp", "tx", "sync", "coll", "kw", "cr", "config", "crit", "dc", "pkg", "cu", "c", "xc", "cv", "css", "lc", "cn", "sq", "ctrl", "ca", "sc", "jp", "cmd", "kk", "pc", "cca", "lib", "qa", "cp", "cmp", "rx", "cf", "req", "ci", "rc"], "txn": ["Txl", "rxp", "Txg", "rtl", " txl", "TXb", "tempn", "rtns", "rxl", "TxN", "ftN", "tempns", "cfn", " txp", "rxns", "TXns", "cfnb", "Txp", "TXg", "Txn", "txtn", "xns", "xnan", "xN", "TXn", " txns", "ctxns", "txN", " txb", "rxN", "ctxnet", "txns", "txnet", "ctxn", "cfl", "cfns", "xn", "tempnet", "txtl", "TXl", "TXnb", "tempp", "Txns", "xb", "txp", "txl", "rxnet", "txnan", "rtn", "Txb", "ftns", "rtnb", "xg", "ctxp", " txnan", "txg", "txtN", "rxn", " txN", "ftnan", "txtb", "ftn", "rxb", "txnb", "txb"], "other_job": ["otheringjob", "another_home", "another_member", "other_home", " other_queue", "other___log", "otherxmanager", "common_job", "othersmessage", "another_message", " other_hub", "old_address", "other_image", "common_worker", "otherxhome", "old_home", "another_log", "othersjob", "othersmember", "another_process", "http_job", "old_job", "other_Job", "otherxbot", "other_address", "other___Job", "other___job", "httpingsync", "httpingjob", "httpingcb", "another_job", "other_queue", "other_message", "other_module", "other_hub", "another_worker", "other_layer", "other_log", "anothererhome", "other_reason", "other___queue", "otherksession", " other_image", "another___bug", " other_worker", "othererblock", "other_block", "oldxhome", "http_sync", "another___log", "anotherernode", "otherermanager", "otherpoxsync", " other_block", "http_runner", "common_log", "otherkhome", "another_node", "otherpoxjob", "oldxjob", "other___bug", "anothererblock", "other_business", "another_session", "othersworker", "anotherermanager", "other_jobs", "another_reason", "anothererbot", "anotherssession", "common_business", "httpingrunner", "common_jobs", "otherxbusiness", "other___reason", "other_worker", "otherernode", "other_lock", "other_manager", "anothererlock", "othererjob", "otherxlayer", "otherxsession", "other_bug", "another___job", "otherxaddress", "otheredsession", "otherssession", "oldxaddress", "other_session", "another_manager", "other_member", "anothersjob", "other_plugin", "otheringrunner", "another_layer", "otherxmember", "otheringcb", "otherxlock", "othererlock", "otheredjob", "otheringsync", " other_Job", "http_cb", "anothersbot", "other_runner", "othererbot", "otherkjob", " other_module", "oldxsession", "othererhome", "otherpoxrunner", "another_bot", "other___block", "another_lock", "other_cb", "other_sync", "other_process", "old_session", " other_plugin", "otherkaddress", "other_node", "otherpoxcb", "another_block", "otherxlog", "othersprocess", "anothersmember", "common_block", "other_bot", "anothererjob", "another___reason", "otherxjob", "otheredhome", "another_plugin", "common_layer", "otheredaddress", "another_bug", "othersbot"], "next": [" Next", "name", "primary", "second", "follow", "success", "new", "data", "more", "open", "worker", "frame", "client", "now", "first", "later", "max", "Next", "future", "code", "reply", "config", "runner", "last", "step", "result", "shift", "state", "size", "prev", "range", "sec", "seq", "cmp", "link", "close", "low", "start", "done"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n", "idx": 3766, "substitutes": {"mr": ["dr", "rg", "mn", "vm", "mt", "rs", "gr", "mc", "mx", "r", "rr", "MR", "mi", "mm", "lr", "kr", "adr", "rb", "m", "nr", "er", "ir", "fr", "RM", "usr", "pr", "br", "rm", "pm", "sr", "pc", "rx", "shr", "rt", "vr", "rh", "Mr"], "size": ["SIZE", "name", "capacity", "cs", "ize", "esc", "small", "loc", "empty", "g", "code", "args", "number", "storage", "address", "ptr", "len", "length", "Size", "sec", "sn", "scale", "fee", "iz", "six", "addr", "io", "shape", "timeout"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3770, "substitutes": {"ioc": ["iaOC", "antioci", "iioci", "ciec", "iog", "uoco", "piog", "pioc", "xioc", "iec", "ioco", "iaog", "piocl", "xiec", "piisc", "piec", "ciocl", "tiocl", "iorg", "antiOC", "iioc", "piorp", "gioci", "uOC", "xiOC", "iiorg", "iioco", "iorp", "giOC", "antioc", "pioco", "antiorg", "ioci", "pioci", " iog", "iaoc", "iocl", "iiorp", "iOC", "uorp", "gioc", "giocl", "xiocl", "iiOC", "tiOC", "piOC", " iisc", "cioc", "tioc", "uoc", "ciOC", "cioci", "piorg", "iaisc", "tioci", "iisc", " iOC"], "localAddr": ["remoteAddp", "localChb", " localChrs", "localIngb", "localAddest", "localErp", "localAttp", "localAddressr", "localAddp", "localStr", "remoteAddressest", "localCher", "localErest", "localIngr", "localErr", "localAdder", "localAtter", "localStest", "localAttrs", "localAddressest", "localIngp", "localAddressp", "localStp", "localAddb", "localAddri", "localAttr", "localAddressri", "localChr", " localAddb", "localChri", " localChr", " localAdder", " localChri", "localAddresser", " localAddrs", "localAddressrs", "localIngri", "localAddrs", "remoteAddressp", "localErrs", "remoteAddressr", "remoteAddressrs", "remoteAddest", " localChb", " localAddri", "localStrs", "remoteAddrs", "localChp", " localChp", " localCher", "localAddressb", "localChrs", " localAddp"], "remoteAddr": [" remoteAddp", "remoteAddp", "remoteAttrs", "remoteAttp", "RemoteAttp", "RemoteAddb", "remoteIdn", " remoteAddressn", "RemoteAddp", "internalAddr", "RemoteAddrs", "remoteErrs", "remoteAddn", "RemoteAttb", "remoteAddressn", "remoteAddrc", "internalAddrs", " remoteAddrs", "remoteIdr", "RemoteAttr", " remoteAddressr", " remoteAddn", "remoteErn", "remoteIdp", "remoteAddressb", "RemoteAttrs", "internalAddrc", "remoteAddressrc", "remoteAddb", "remoteAttb", "remoteErrc", "RemoteAddr", "remoteErp", "remoteAddressr", "remoteAddressp", "remoteErr", "remoteAddressrs", " remoteAddressrs", "internalAddp", "remoteIdrs", "remoteAddrs", "remoteAttr", " remoteAddressp", "remoteIdb"], "errp": ["errorf", "errP", "erP", "rp", "errpe", "rr", "errfp", " errpe", "iterp", "errpc", "erf", "errorP", " errr", "rf", "err", " errps", " errP", "acepc", "iterps", "errr", "errps", " errpc", "errorp", "iterpc", "erp", "aceps", "iterpe", "errorfp", " errf", " errfp", "acepe", "errf", "acep", "rP", "erfp"], "fd": ["flow", "fc", "ff", " FD", "ld", "dn", "da", "fs", "fun", "dd", "fen", "pd", "FD", "sd", "xf", "fed", "fa", "d", " f", "xd", "dl", "fl", "ln", "lf", "fff", "fn", "buf", "draft", "dy", "fp", "sf", "df", "cb", "md", "ds", "pid", "feed", "fe", "dc", "bf", "reader", "fin", "du", "len", "f", "bd", "ffff", " fid", "hd", "cd", "handler", "fx", "wd", "fm", "die", "rd", "fee", "fb", "cf", "af", "vd", "nd", "dat", "diff", "fi", "gd", "db"]}}
{"project": "qemu", "commit_id": "bb3cb951ef530da7d248051347c974e4d20e6ea0", "target": 0, "func": "static void dec_bit(DisasContext *dc)\n\n{\n\n    TCGv t0, t1;\n\n    unsigned int op;\n\n    int mem_index = cpu_mmu_index(dc->env);\n\n\n\n    op = dc->ir & ((1 << 9) - 1);\n\n    switch (op) {\n\n        case 0x21:\n\n            /* src.  */\n\n            t0 = tcg_temp_new();\n\n\n\n            LOG_DIS(\"src r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            if (dc->rd) {\n\n                t1 = tcg_temp_new();\n\n                read_carry(dc, t1);\n\n                tcg_gen_shli_tl(t1, t1, 31);\n\n\n\n                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);\n\n                tcg_temp_free(t1);\n\n            }\n\n\n\n            /* Update carry.  */\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x41:\n\n            /* srl.  */\n\n            t0 = tcg_temp_new();\n\n            LOG_DIS(\"srl r%d r%d\\n\", dc->rd, dc->ra);\n\n\n\n            /* Update carry.  */\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            if (dc->rd) {\n\n                if (op == 0x41)\n\n                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                else\n\n                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n            }\n\n            break;\n\n        case 0x60:\n\n            LOG_DIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x61:\n\n            LOG_DIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x64:\n\n        case 0x66:\n\n        case 0x74:\n\n        case 0x76:\n\n            /* wdc.  */\n\n            LOG_DIS(\"wdc r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0x68:\n\n            /* wic.  */\n\n            LOG_DIS(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n", "idx": 3778, "substitutes": {"dc": ["dr", "roc", "device", "ct", "nc", "director", "rec", "head", "circ", "ec", "cu", "du", "sc", "gui", "vc", "cca", "qa", "wp", "dir", "acc", "da", "spec", "mc", "cloud", "bc", "cci", "ea", "cdn", "dom", "mac", "ac", "lc", "dm", "cit", "td", "input", "fc", "cm", "cc", "mic", "data", "loc", "di", "cat", "cgi", "cr", "ds", "c", "xc", "design", "cache", "ku", "center", "cmd", "disc", "cf", "ic", "enter", "uc", "DC", "ga", "conn", "d", "tc", "dest", "df", "source", "dt", "central", "config", "jc", "doc", "draw", "cd", "exec", "pc", " DC", "dat", "inc", "desc", "db", "rc"], "t0": ["t4", "temp100", "d0", "p1", "t00", "l0", " t000", "l50", "temp0", "t5", "f0", "t000", " t50", " t3", "f000", "ta2", "it192", "p100", "ta50", "t2", "l2", "T100", "temp1", "T3", "it0", "temp00", "T4", " t4", " t2", "l8", "T050", " t6", "temp2", "t100", "t6", "f192", "p5", "f1", " t8", "p00", "ta0", "dt192", "t050", "at050", "t50", "t8", "d1", "tty0", "t3", "it000", "d5", "t192", "T6", "temp5", "T1", "et0", "dt0", "tty1", "dt000", "p4", "at3", "T2", "tty000", "T0", "it1", "dt1", "at0", "p0", "et1", "et6", "d00", "at1", "ta8", "p2", " t050", "T000"], "t1": ["t4", "dt0", " tname", "pone", "tty1", "tty01", "f1", "tone", "ttone", "p8", "pt1", " t8", "it91", "f4", "pt91", "tt1", "ptone", "dt4", "T2", "p1", "t9", "pt0", "f2", "t91", "tt0", "T0", "it1", "tty3", "T5", "itone", "t01", "dt1", " t9", "t2", "p0", "tt3", "t5", "tt5", "it0", "t8", "p9", "f0", " t5", "T4", "t3", "T8", " t01", "T01", "tname", " t4", " t2", "Tname", "p2", "tt01", "ttyone", " t3", " tone", "dtname", "p91", "T9", "T1"], "op": ["orb", "lock", "offset", "ops", "bit", "mod", "expr", "oper", "oop", "opus", "loc", "operation", "type", "prop", "cat", "sp", "operator", "opp", "id", "cop", "it", "open", "oid", "off", "loop", "pos", "ac", "ok", "info", "index", "om", "cod", "post", "opt", "ip", "ind", "top", "p", "pop", "hop", "len", "prev", "app", "oc", "set", "jp", "mp", "o", "cmp", "lit", "Op", "OP", "option"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 3795, "substitutes": {"mr": ["rg", "mn", "dr", "mt", "rs", "gr", "wk", "mc", "bm", "km", "r", "rr", "MR", "yr", "mm", "lr", "kr", "rf", "adr", "rb", "m", "nr", "mid", "er", "mk", "cr", "md", "hm", "usr", "pr", "lc", "rl", "ref", "br", "rm", "fm", "sr", "pc", "tm", "rx", "shr", "rt", "vr", "rh", "Mr", "rc"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n", "idx": 3811, "substitutes": {"s": ["opens", "src", "cs", "groups", "a", "qs", "context", "r", "d", "n", "ions", "scope", "span", "i", "bis", "m", "ses", "sync", "settings", "tests", "sets", "ns", "c", "p", "services", "e", "setup", "f", "secondary", "sq", "sports", "south", "o", "v", "b", "t", "session", "support", "fs", "ssl"], "insn": ["incl", "INSner", "incb", "incp", "inns", "outsp", " insign", "inpn", " insz", "Insc", "Inspn", " insl", "insen", "outsns", "insp", "Insign", "insz", "inp", "outsc", "incc", " insen", "inspn", "incn", "INSns", "inner", "inen", "incign", "INSpn", "inn", "insign", " insb", "Insner", "outsen", "Insn", "outsn", "Insns", "incz", " insc", "INSn", "insner", "inz", "insns", "insl", "insc", "Insb", " insns", "insb", "inc", " insp", "inl"], "r1": [" r01", "r01", "rc01", "pr3", " r3", "rOne", "pr0", "pr1", "r0", "r3", "srOne", "sr3", " r0", "rc0", "rcOne", "sr01", "pr01", "sr1", "rc1", "rc3", " rOne"], "r2": ["r8", "rg2", "r62", "er5", "sr8", "rg5", "R62", "rg8", "p1", "r0", "r4", "sr2", "sr4", " r0", "p0", "er8", "R0", " r62", "sr5", "r5", "p62", "rg4", "er4", "er2", "p2", "R2", "R1"], "rn": ["rg", "mn", "dn", "roc", "rw", "nn", "rr", "r", "nc", "rec", "ln", "pn", "hn", "fn", "lr", "ne", "rf", "rb", "ra", "nr", "gn", "err", "RM", "cr", "rev", "ron", "rl", "cn", "rm", "NRS", "RN", "rd", "sn", "RR", "nw", "rx", "cf", "rar", "nv", "rt", "rh", "ern", "rin", "rc"], "ofs": [" ofn", "effn", "offd", "OFsup", "effm", "ofn", "ofc", "OFs", "ofd", "effc", "ofsettings", "ifn", " ofsteps", "Ofs", "ofsteps", "Ofc", "accounts", "offs", "OFn", "offp", "offm", " ofd", "OFsettings", "ifs", "ofsup", "ofm", " ofsup", " ofp", "ifm", "effs", "OFd", "accountsup", "OFsteps", " ofm", "OFc", "Ofn", " ofc", "Ofsteps", "offn", "accountc", "accountsettings", "Ofd", " ofsettings", "Ofm", "ofp", "ifp"], "pre": ["li", "pi", "r", "ap", "PRE", "sp", "rec", "Pre", "ne", "pair", "py", "i", "po", "pos", "y", "j", "m", "fp", "fr", "post", "pa", "pad", "ip", "p", "pr", "e", "per", "prev", "jp", "min", "up", "en", "o", "pc", "prefix", "wa", "pro", "re", "wp", "pri", "pin"], "w": ["we", "q", "a", "rw", "fw", "r", "d", "n", "wrap", "W", "max", "y", "i", "wo", "kw", "wh", "z", "h", "word", "work", "p", "sw", "c", "f", "wb", "prev", "u", "ww", "win", "o", "b", "t", "ew", "wa", "wave", "wp", "wx"]}}
{"project": "qemu", "commit_id": "2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590", "target": 0, "func": "static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value / 1000;\n\n}\n", "idx": 3815, "substitutes": {"obj": ["ob", "oa", "base", "ctx", "act", "conn", "host", "image", "oid", "objects", "env", "boot", "buf", "parent", "tmp", "api", "Obj", "j", "instance", "po", "Object", "cb", "x", "p", "ut", "cache", "core", "org", "cn", "jp", "exec", "object", "o", "os", "conv", "val", "io", "ex"], "v": ["vm", "server", "vp", "vt", "volt", "r", "n", "vim", "env", "api", "i", "j", "m", "sv", "vv", "x", "l", "c", "p", "vs", "w", "e", "f", "uv", "u", "object", "V", "o", "ev", "b", "t", "conv", "val"], "opaque": ["obacity", "opacity", "obhole", "Ophole", "Opacity", "obatile", "opsacity", "opshole", "ophole", "opsatile", "opatile", "Opatile", "obaque", "Opaque", "opsaque"], "name": ["base", "null", "version", "no", "time", "key", "a", "data", "image", "domain", "new", "n", "type", "id", "parent", "na", "num", "max", "i", "space", "label", "none", "code", "info", "number", "names", "str", "description", "x", "word", "Name", "start", "size", "resource", "nan", "min", "comment", "range", "node", "prefix", "error", "path", "val", "part", "NAME"], "errp": ["errP", "erc", " err", "rrpp", "erP", "ryp", " erP", "erpc", "errc", "rrpc", "ryP", "erb", " erpt", "errpc", "rrP", "rrr", "mrp", "errpatch", " erp", "rrc", " errr", "mrpp", "errb", "rrpa", "mrP", "err", "errpt", " errP", " errpt", "errr", "rypp", " erpatch", " errpc", "erp", " errc", " errb", "erpt", "rypa", "erpatch", " erb", "errpa", " errpatch", "errpp", "mrpa", "rrp"], "cpu": ["np", "vm", "gpu", "ctx", "hw", "conn", "queue", "process", "clock", "GPU", "instance", "kernel", "CPU", "proc", "fp", "pool", "cow", "lc", "pu", "loader", "cache", "core", "cn", "processor", "node", "pc", "cp", "cmp", "val", "io", "gp", "performance", "fi", "net", "mem"], "value": ["flow", "unit", "VALUE", "media", "property", "null", "version", "total", "no", "offset", "rate", "key", "usage", "Value", "when", "data", "image", "memory", "current", "weight", "type", "position", "format", "id", "parent", "end", "now", "num", "max", "update", "number", "index", "function", "feature", "non", "result", "address", "pa", "age", "values", "force", "size", "length", "message", "money", "amount", "reference", "object", "range", "min", "node", "scale", "prefix", "fee", "valid", "val", "count", "volume", "limit", "start", "diff", "price"]}}
{"project": "qemu", "commit_id": "6764579f894950afe87d8ec3b323adde8925d4fd", "target": 1, "func": "static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    struct cow_header_v2 cow_header;\n\n    struct stat st;\n\n    int64_t image_sectors = 0;\n\n    char *image_filename = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockDriverState *cow_bs;\n\n\n\n    /* Read out options */\n\n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;\n\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n", "idx": 3824, "substitutes": {"filename": ["login", "files", "til", "FIL", "fd", "name", "utf", "jl", "figure", "txt", "url", "binary", "download", "fn", "wl", "wav", "lua", "fil", "nil", "Filename", "fp", "file", "slice", "database", "tif", "feat", "kn", "abl", "jpg", "dll", "f", "kl", "summary", "username", "il", "phrase", "prefix", "location", "path", "subject", "nuclear", "directory"], "opts": ["optmt", "expers", "opers", " optches", "ops", "opments", "opches", "opter", "OPts", "expertes", "opps", "opmt", "opttd", "optes", "experls", "otts", "opercs", "experches", "ots", "OPtd", "optter", " opmt", "expertd", "experts", "optls", " opter", "optts", "opcs", " optmt", "OPs", "OPtes", "optches", "optments", "experments", "opls", "otcs", "operts", "OPps", "OPcs", "otps", "opttes", "optd", " optter", " optes", " opttes", " optments", " optts", "operps", " optls"], "errp": ["errP", "irps", "erP", " errpr", "errpe", "derp", " errpe", "rarf", "irpe", "rarpr", "erf", "errorP", " errr", "rarp", "errorps", "err", " errps", " errP", "irp", "errr", "errps", "derf", "errorp", "irf", "erp", "derpe", "errpr", " errf", "errorr", "erps", "errf", "rarr", "erpr", "derps"], "cow_header": ["Cow_headers", "gow_detail", "Cow_header", "cow_content", "ow_director", "flow_content", "gow_header", "ow_layer", "cow_filename", "cow___writer", "cow_head", "cow___head", "ow_head", "cow_layer", "flow_header", "cow_director", "cow2head", "cow___header", "cache_head", "cow_version", "cow_server", "cow2headers", "ow_server", "cow___counter", "gru_main", "ow_cover", "cow_buffer", "cowbooktransfer", "ow_transfer", "cow_headers", "cow_cover", "Cow_layer", "cow_writer", "cow_counter", "Cow_head", "ow_bridge", "cowbookheader", "cache_writer", "ow_header", "ow_consumer", "flow_head", "cache_counter", "cow_player", "flow_buffer", "cow_dr", "cow_bridge", "cow_description", "cow_detail", "cow_transfer", "ow_definition", "ow_buffer", "gow_description", "cowbookbridge", "flow_director", "flow_version", "cowbookheaders", "ow_detail", "gru_header", "ow_filename", "flow_headers", "cow_definition", "gru_dr", "ow_headers", "gru_player", "cow_consumer", "cow_main", "cow2layer", "cow2header", "cache_header", "ow_player", "gow_cover", "ow_version"], "st": ["stage", "ist", "service", "rest", " sc", "ss", "r", "istic", "ct", "sp", "sl", "store", "end", "St", "param", "first", "ste", "ft", "fr", "str", "fe", "step", "sw", "state", "stack", "set", "put", "sc", "ST", "stream", "art", "std", "en", "sn", "sts", "sta", "inst", "stop", "ost", "nd", "ast", "se", "stress", "start", "sth", "est"], "image_filename": ["media__filename", "image_fn", "image__filename", "image_fp", "large_Filename", "imageFfilename", "img_fn", "img_processor", "media__file", "image__file", "image_source", "image64filename", "image__uri", "imageFsource", "image__url", "image_width", "image_uri", "image__processor", "image_username", "large_source", "image_processor", "img__username", "image64location", "imageFFilename", "media_directory", "img__uri", "image64Filename", "img_filename", "img__processor", "image_location", "media_file", "image___username", "image___uri", "image64width", "image__username", "large_filename", "image___processor", "img_username", "img_Filename", " image_Filename", "image_file", "image__directory", "media_filename", "large_file", "media__url", "media_url", "img__filename", "img_uri", "media__directory", "image_directory", " image_location", "imageFfile", "image_Filename", "image_url", " image_width", "image___filename", "img_fp"], "local_err": ["localesterr", "local7sr", "local7gr", "global_gr", " local_gr", " local_dr", "local_sr", " local_req", "localester", "local_die", "local_status", "local_ler", "global_err", "local_error", "local_iter", "localestdie", "global_req", "local_er", "localestdr", "local7iter", "local_dr", "Local_ler", " local_die", "global_error", "Local_iter", "Local_err", "Local_sr", "Local_status", "Local_gr", " local_er", "local_gr", "local7err", "local_req"], "ret": ["match", "arg", "fun", "no", "att", "mt", "def", "hash", "success", "data", "url", "alt", "cat", "rets", "end", "arr", "num", "pass", " RET", "j", "rb", "lt", "nt", "ft", "rev", "reply", "status", "Ret", "rc", "bf", "feat", "result", "usr", "len", "red", "flag", "ref", "rl", "gt", "resp", "std", "art", "obj", "en", "rel", "sr", "nm", "RET", "valid", "al", "re", "reg", "val", "rt", "count", "pt", "let", "lit", "det", "res", "db", "mem"], "cow_bs": ["cowAfs", "cow7bb", "cow7base", "cow_bb", "gow_vs", " cow7fs", " cow_fs", "hub67bb", "cow67bs", " cow_server", "cowAserver", "cowAbm", "cache_obj", "cow_server", "cache_sb", "hub67bs", " cow7bm", "cow7BS", "cow7bs", "hub_bs", "cow_base", "cow67bb", " cow7bs", "cow67BS", "hub_bb", "cowAbs", "cow_sb", "cow_vs", "cowGobj", "gow_bs", "gow_fs", "cowGfs", "cow_fs", "cache_bs", "cowGbs", "cache_fs", "cow_BS", " cow7server", "cowGsb", "hub67BS", "cow7fs", "hub_BS", "hub67base", "cow_bm", "cow67base", "cow7server", "cow_obj", " cow_bm", "hub_base", "gow_base", "cow7bm"]}}
{"project": "FFmpeg", "commit_id": "4a023d5b53132ced3643d0e8397baa80cf75f656", "target": 0, "func": "static av_cold int check_format(AVCodecContext *avctx)\n\n{\n\n    AVCodecParserContext *parser;\n\n    uint8_t *pout;\n\n    int psize;\n\n    int index;\n\n    H264Context *h;\n\n    int ret = -1;\n\n\n\n    /* init parser & parse file */\n\n    parser = av_parser_init(avctx->codec->id);\n\n    if (!parser) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 parser.\\n\");\n\n        goto final;\n\n    }\n\n    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;\n\n    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);\n\n    if (index < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to parse this file.\\n\");\n\n        goto release_parser;\n\n    }\n\n\n\n    /* check if support */\n\n    h = parser->priv_data;\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 8:\n\n        if (!CHROMA444(h) && !CHROMA422(h)) {\n\n            // only this will H.264 decoder switch to hwaccel\n\n            ret = 0;\n\n            break;\n\n        }\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported file.\\n\");\n\n    }\n\n\n\nrelease_parser:\n\n    av_parser_close(parser);\n\n\n\nfinal:\n\n    return ret;\n\n}\n", "idx": 3832, "substitutes": {"avctx": ["AVctx", "avectx", "avsc", "AVlc", "avsci", "avconn", "averlc", "afcmp", "afctx", "afcontext", "AVctrl", "avtx", "AVsc", " avlc", "aveconn", "Avcontext", "AVconn", "aftx", "Avconn", " avcontext", "avercontext", "Avctx", "avertx", "AVsci", "rafctx", "afconn", "AVcontext", "avelc", "avctrl", "afloc", " avsc", "afctrl", "rafloc", "aflc", "avloc", "avcontext", "aveloc", "avesc", "AVtx", "avecontext", " avsci", "averctrl", "rafcmp", "rafcontext", "averctx", "Avsci", "avlc", "avcmp", "avecmp", " avconn"], "parser": ["argument", "server", "angler", "buffer", "ctx", "http", "dd", "lp", "pd", "spec", "context", "txt", "audio", "xml", "pillar", "r", "student", "author", "format", "worker", "k", "parent", "pb", "ger", "jack", "builder", "instance", "tp", "inner", "script", "fp", "tx", "lex", "er", "master", "util", "slice", "central", "parse", "kw", "au", "writer", "c", "reader", "p", "book", "ler", "loader", "ar", "php", "handler", "pc", "v", "plugin", "magic", "manager", "fork", "root", "init", "part", "se", "player", "xxx", "paragraph", "arser", "Parser"], "pout": [" pin", "ipin", "spOut", " pouts", "pOut", " pOut", "POut", "ipout", "cpagain", "pagain", "cpOut", "ipOut", "pouts", "rOut", "rOUT", "Pin", "spOUT", "cpOUT", "spagain", "cpout", "pOUT", "Pout", "spout", "ragain", "Pouts", "rout", "ipouts", "pin"], "psize": ["opsizing", "upsizing", "opsizer", "psizer", "alsizes", "opsIZE", "alsize", "epsIZE", "psizing", "epsized", "psIZE", "upsiz", "epsize", "psizes", "alsized", "epsizes", "epsizer", "upsize", "psiz", "epsizing", "opsizes", "epsiz", "psized", "opsize", "upsIZE", "opsized", "alsizer", "opsiz"], "index": ["unit", "match", "ret", "Index", "arg", "append", "skip", "offset", "find", "active", "key", "array", "success", "align", "weight", "position", "field", "id", "section", "found", "end", "num", "search", "loop", "i", "pos", "scan", "info", "number", "slice", "ini", "pattern", "pointer", "x", "ind", "result", "len", "length", "where", "ion", "value", "error", "element", "valid", "path", "addr", "part", "list", "pin"], "h": ["H", "ctx", "http", "bh", "q", "ih", "hw", "conn", "context", "host", "data", "ht", "r", "header", "d", "n", "help", "sh", "ph", "ha", "uh", "g", "m", "hr", "ah", "ch", "hm", "l", "c", "p", "hh", "x", "w", "e", "hd", "f", "eh", "hp", "history", "u", "handler", "o", "v", "hl", "s", "t", "he", "hs", "oh", "rh"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n", "idx": 3834, "substitutes": {"dc": ["fc", "cm", "dr", "fd", "DC", "ctx", "da", "roc", "ga", "conn", "cc", "mc", "context", "gc", "spec", "device", "loc", "d", "ct", "di", "nc", "bc", "rec", "cci", "ea", "tc", "grad", "cdn", "mac", "ac", "dest", "coll", "df", "dt", "ds", "config", "dir", "ec", "c", "xc", "jc", "doc", "du", "design", "draw", "dm", "oc", "lc", "sc", "cd", "exec", "gui", "std", "cmd", "vc", "disc", "comment", "cca", "cit", "pc", "die", "cf", " DC", "enter", "dat", "dp", "uc", "desc", "input", "db", "rc"], "insn_len": ["insn_en", "insn_li", "insp_led", "insn_val", "insn_length", "insnOxpre", "insp_pre", "insn2length", "insnOxlong", "insl_length", "insl2Len", "insnOxlen", "insn_n", "insn_pre", "insp_Len", "insn2li", "insl_Len", "insn2Len", "insl_len", "insl2length", "insc_en", "insl2li", "insl2len", "insn2len", "insc_len", "insnOxval", "insn_long", "insc_val", "insn_led", "insp_len", "insp_val", "insp_long", "insl_li", "insn_Len", "insc_n"], "t0": ["tfrom", "pt8", " tau", "T192", "ts0", "ts192", "T50", "pt00", "it50", "tj", "tt1", "T2", "tt18", "int00", "pt0", "t00", "tt0", "int0", "T0", "it1", "intfrom", "ptfrom", "T18", "tx00", "ts1", "t2", "tau", "t50", "int8", "ttj", "t1", "it0", "tx8", "t8", "txfrom", "t18", " t18", " t50", " t2", "Tj", "t192", "tt2", " t192", " tj", "ttau", "tx0", "Tau", "T1", " t1"]}}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "substitutes": {"dev": ["serial", "test", "server", "cam", "def", "dd", "mod", "device", "dim", "data", "r", "development", "ver", "d", "devices", "priv", "grad", "de", "dom", " Dev", "DEV", "Dev", "m", "ve", "info", "bug", "temp", "pub", "gu", "w", "prom", "e", "dm", "f", "conf", "Device", " device", "die", "driver", "v", "o", "ev", "rad", "dem", "error", "pro", "engine", "debug", "mode"], "s": ["sg", "js", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "storage", "sie", "self", "f", "set", "sys", "u", "changes", "an", "fs", "spec", "ts", "sb", "y", "uns", "sv", "request", "sets", "p", "state", "e", "lines", "conf", "as", "v", "less", "su", "serv", "S", "t", "session", "os", "site", "ks", "its", "hs", "sym", "plugins", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "sim", "si", "server", "service", "http", "d", "ms", "side", "params", "details", "sync", "status", "l", "services", "w", "features", "stats", "b"]}}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n", "idx": 3845, "substitutes": {"f": ["fo", "fc", "fd", "tf", "fs", "fen", "a", "fac", "fa", "d", "elf", "fn", "F", "i", "m", "fab", "file", "fp", "sf", "df", "fe", "bf", "l", "c", "p", "e", "fx", "o", "v", "fb", "b", "t", "cf", "af", "fi"], "opaque": ["opacity", "opaques", "OPacity", "Opec", " oponymous", "OPec", "Opace", "OPace", "opace", "opusaque", " opacity", "opusaques", "OPaque", "omponymous", "Opacity", "oponymous", " opec", " opace", "ompaque", "opec", " opaques", "Opaque", "ompaques", "opusonymous"], "version_id": ["ver_id", "version_i", "ver_count", "ver_sid", "versionerid", "version_sid", "versionalsid", "ver_number", " version_ids", "versionerversion", "ver_ids", "versionali", "version_d", "version_name", "ver_version", "version_count", "versionernumber", "versioneri", "ver_name", "version_version", "versionalids", " version_d", "versionalid", " version_i", "version_number", "ver_i", "version_ids"], "n": ["name", "nn", "rn", "d", "nc", "pn", "k", "ne", "na", "y", "i", "g", "j", "ac", "m", "network", "nt", "z", "ns", "N", "c", "p", "l", "w", "e", "nb", "cn", "u", "node", "o", "v", "sn", "s", "b", "nw", "t", "an", "nor", "net"], "vdev": ["lvdevice", "lserv", "Vdevice", "lvver", "vver", "ddev", "vDev", "lvdev", "ldev", "Vserv", "dDev", " vda", " vDev", "vda", "lver", "vev", " vev", "lvserv", "dev", "pev", "dda", "Vdev", "vserv", "ldevice", "pdev", "Vver", "pda", "pDev", "vdevice"]}}
{"project": "FFmpeg", "commit_id": "3f8148911c6e6e1f2a042bd4ca3ad8516a92130c", "target": 0, "func": "static int read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]={0}, ret[3]={0};\n\n    AVIOContext *f[3] = {NULL};\n\n    AVCodecContext *codec= s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path, s->img_number)<0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for(i=0; i<3; i++){\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if(i>=1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i]= avio_size(f[i]);\n\n\n\n            if(!s->split_planes)\n\n                break;\n\n            filename[ strlen(filename) - 1 ]= 'U' + i;\n\n        }\n\n\n\n        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        size[0]= 4096;\n\n    }\n\n\n\n    av_new_packet(pkt, size[0] + size[1] + size[2]);\n\n    pkt->stream_index = 0;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    pkt->size= 0;\n\n    for(i=0; i<3; i++){\n\n        if(f[i]){\n\n            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if(ret[i]>0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 3901, "substitutes": {"s1": ["s6", "wsone", "ws1", " s0", "s0", "hs11", " sOne", "c3", "c6", "hs81", "s11", "s3", " sone", "g1", "ses1", "wsOne", "S81", "s81", "csons", "sone", "l0", "SOne", "wsons", "sesone", "sys6", " s11", "ws11", "s2", "ses0", "Sone", "sOne", "sys1", "c1", "sys2", "sons", "cs1", "csOne", " sons", "hs1", "dsone", "ses81", "S1", "dsOne", "sys3", "ds81", "c2", "l81", "g3", "ds11", "ds1", "ses11", "g2", "g6", " s81", "l1"], "pkt": ["apacket", "ppkg", " pKT", "pkk", " packet", "apkt", "cpkk", "cpkt", "ppacket", " pmt", "pkg", "PKT", "cpmt", "apkk", " pkk", "pKT", "cpacket", "Packet", "Pkg", "ppKT", "ppkt", " pkg", "packet", "Pkt", "pmt", "apmt"], "s": ["sg", "js", "sa", "qs", "n", "g", "ses", "ls", "args", "vs", "us", "self", "sys", "sc", "u", "fs", "parts", "spec", "ts", "sb", "aws", "ims", "y", "xs", "sv", "sets", "p", "e", "conf", "comm", "as", "v", "site", "S", "t", "session", "os", "ks", "its", "sym", "plugins", "ssl", "cs", "ctx", "ss", "a", "rs", "data", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "sec", "o", "si", "server", "service", "http", "d", "ms", "comments", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "filename_bytes": ["filename_lines", "filename_frames", "message_requires", "filename_bits", "image_bytes", "username_bytes", "image_parts", "filename2details", "filename_details", "image_seconds", "username_details", "filename2lines", "filename_parts", "message_seconds", "filename_zip", "message_bytes", " filename_frames", "message_bits", "filename_seconds", "filename_requires", " filename_lines", "username_zip", "filename2zip", "filename2bytes", "username_lines"], "filename": ["files", "SIZE", "name", "src", "fd", "buffer", "utf", "txt", "data", "binary", "url", "image", "memory", "ename", "download", "fn", "gz", "png", "output", "fil", "nil", "sheet", "Filename", "sword", "fp", "file", "password", "sf", "slice", "source", "status", "kn", "json", "bf", "feat", "jpg", "word", "which", "wx", "dll", "length", "kl", "original", "message", "username", "il", "phrase", "nm", "prefix", "final", "uri", "location", "path", "subject", "whatever", "metadata", "directory"], "i": ["ski", "yi", "li", "sup", "gi", "abi", "split", "ni", "ii", "zi", "chi", "ui", "pi", "mini", "oi", "d", "I", "di", "type", "n", "id", "mi", "iu", "j", "y", "g", "m", "eni", "inner", "ri", "ti", "slice", "multi", "index", "ini", "ch", "z", "ai", "ie", "x", "ip", "c", "p", "ind", "hi", "phi", "e", "l", "bi", "lc", "u", "v", "qi", "ix", "b", "module", "vi", "uri", "ci", "count", "io", "init", "mu", "diff", "fi", "start", "part", "si", "xi"], "size": ["capacity", "large", "url", "n", "empty", "from", "enc", "j", "g", "code", "file", "args", "storage", "address", "x", "message", "Size", "en", "sum", "fee", "se", "name", "time", "rate", "sized", "security", "form", "ui", "send", "type", "parent", "y", "max", "z", "e", "length", "core", "sn", "v", "scale", "sex", "SIZE", "offset", "esc", "data", "speed", "small", "new", "loc", "use", "member", "body", "content", "c", "es", "len", "sec", "mode", "shape", "si", "ize", " sizes", "fl", "source", "status", "l", "w", "export", "desc"], "ret": ["fo", "buffer", "esc", "get", "small", "memory", "out", "loc", "empty", "num", "g", "code", "body", "info", "ft", "back", "temp", "status", "content", "result", "value", "sum", "en", "full", "mode", "response", "desc", "rc"], "f": ["fc", "fun", "fd", "tf", "q", "fen", "fw", "form", "fa", "r", "d", "fl", "fn", "frame", "rf", "F", "j", "g", "m", "file", "fp", "sf", "df", "fr", "z", "feed", "fe", "h", "l", "c", "p", "x", "w", "e", "fx", "v", "fb", "b", "t", "cf", "fs"], "codec": ["prederc", "labesc", "odef", "codeca", "Coderc", "coddec", "odeca", "labec", "codef", "callerer", "Codect", "odec", " codenc", "callec", "indec", "predec", "Codef", "labdec", "odEC", "Codic", " codef", "Codec", "Codesc", " codesc", "predesc", "codesc", " coduc", "codedec", " coderc", "inderc", "codeect", "calleca", "codeesc", "labEC", "buffec", "oduc", "odenc", "bufferer", "coduc", "callEC", "oderc", "coderer", "labect", "coderc", "Coddec", "buffeca", "oderer", "buffEC", "Coduc", "indef", "odesc", "CodEC", "codeEC", "codect", "predenc", "labic", "codic", "indEC", " codEC", "codeec", "codEC", "codenc", "codeic"], "img_number": ["image_line", "img_umber", "imgIdobject", "image_nom", "img_maximum", "img_no", "imgitymaximum", "img__no", "imgitynum", "imgqno", "img__position", "imgIdnom", "image_num", "imgPline", "image_umber", "imgIdno", "imgPposition", "imgqnom", "img_position", "img_counter", "image_object", "image_first", "img_nom", "image_counter", "image_number", "image_maximum", "img_object", "imgnnumber", "img__line", "img_line", "imgPnumber", "imgPno", "imgqnumber", "imgqcounter", "imgnfirst", "image_no", "img_first", "image_final", "imgityfirst", "img__number", "img_type", "img_page", "imgnmaximum", "imgnnum", "image_page", "image_type", "imgIdcounter", "img_final", "imgitynumber", "image_position", "imgIdumber", "imgIdnumber", "img_num"]}}
{"project": "FFmpeg", "commit_id": "7ed47e97297fd5ef473d0cc93f0455adbadaac83", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    SmackerContext *smk = s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = avio_rl32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = avio_rl32(pb);\n    smk->height = avio_rl32(pb);\n    smk->frames = avio_rl32(pb);\n    smk->pts_inc = (int32_t)avio_rl32(pb);\n    smk->flags = avio_rl32(pb);\n    if(smk->flags & SMACKER_FLAG_RING_FRAME)\n        smk->frames++;\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = avio_rl32(pb);\n    smk->treesize = avio_rl32(pb);\n    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(s, AV_LOG_ERROR, \"treesize too large\\n\");\n//FIXME remove extradata \"rebuilding\"\n    smk->mmap_size = avio_rl32(pb);\n    smk->mclr_size = avio_rl32(pb);\n    smk->full_size = avio_rl32(pb);\n    smk->type_size = avio_rl32(pb);\n    for(i = 0; i < 7; i++) {\n        smk->rates[i]  = avio_rl24(pb);\n        smk->aflags[i] = avio_r8(pb);\n    smk->pad = avio_rl32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames);\n    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));\n    smk->frm_flags = av_malloc(smk->frames);\n    if (!smk->frm_size || !smk->frm_flags) {\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = avio_rl32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = avio_r8(pb);\n    /* init video codec */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);\n    st->duration = smk->frames;\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if (smk->rates[i]) {\n            ast[i] = avformat_new_stream(s, NULL);\n            if (!ast[i])\n                return AVERROR(ENOMEM);\n            smk->indexes[i] = ast[i]->index;\n            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (smk->aflags[i] & SMK_AUD_BINKAUD) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (smk->aflags[i] & SMK_AUD_PACKED){\n                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (smk->aflags[i] & SMK_AUD_STEREO) {\n                ast[i]->codec->channels       = 2;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                ast[i]->codec->channels       = 1;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            ast[i]->codec->sample_rate = smk->rates[i];\n            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;", "idx": 3913, "substitutes": {"s": ["sg", "parser", "js", "service", "cs", "ss", "spec", "ts", "qs", "sa", "sb", "r", "sam", "n", "sl", "sis", "g", "comments", "m", "ses", "ls", "sf", "plugins", "sync", "sv", "storage", "ds", "request", "gs", "ns", "c", "p", "services", "w", "e", "us", "f", "sys", "sq", "sc", "u", "conf", "summary", "south", "o", "v", "b", "su", "S", "t", "ks", "site", "session", "types", "support", "an", "si", "sym", "ssl"], "pb": ["pl", "fc", "parser", "vp", "ctx", "bh", "lp", "pd", "ppa", "esi", "sb", "bps", "lb", "ab", "cpp", "prot", "eb", "hub", "rob", "prop", "pg", "bc", "platform", "tc", "buf", "api", "PB", "tp", "rb", "proc", "fp", "sf", "cb", "bf", "abc", "phys", "pa", "pkg", "p", "apy", "lc", "rpm", "wb", "gb", "jp", "summary", "pm", "mp", "phrase", "pc", "bp", "asm", "fb", "b", "plugin", "cp", "uf", "wp", "lab", "dp", "typ", "db", "xb"], "smk": ["Smk", "tmok", "tmku", "mmck", " smdk", " smok", "syk", "simdk", "mbq", "svok", "svck", "symok", " smwork", "smK", "symku", "slc", "irmke", " smq", "omsk", "ymK", "mmk", "skkin", "svke", " smg", "slkit", "tmke", "svc", "Smck", "ymkt", "skk", " smkt", "slk", " smK", "symdk", "mmok", "mbkit", "Smok", "symke", "tmq", "irmk", " smsk", "spework", "symck", "spek", "slik", "ymck", "spekin", "tmc", "tmck", "smck", "irmK", "lammk", "bmck", "ymik", "mbke", "ymk", "mmik", "symsk", " smck", "SmK", "smwork", "tmsk", "symak", "smf", " smv", "emok", "lammd", "smku", "snke", "slok", "Smch", "snk", "symwork", "svsk", "emke", "mmke", "slq", "sksk", "mmdk", "spedk", "mmch", "tmg", "mmkt", " smf", "smv", "speg", "omk", "smc", " smc", "mmku", "svku", "smek", "speek", "slke", "spekg", "swke", "omwork", "snek", "symc", "emK", "smch", "lammek", "smak", " smak", "sykg", "smg", "mmkg", "smq", "bmg", "smik", " smd", "omkin", "symkit", "lammsk", "sld", "smkit", "sped", "bmsk", "swck", "mbk", "slck", " smek", "symg", "svdk", "symk", " smkg", "smkg", "mmc", "tmk", "svek", "simk", " smch", "smkin", "simck", "ymke", "swv", "syd", "smd", "mmg", " smik", "smke", "tmik", "speok", "swk", "smdk", "slkg", "ymok", "speak", "slv", "smok", "svk", " smke", "skwork", "mmK", "irmok", "simf", "tmdk", "smsk", "syc", "bmk", "symq", "speck", "slg", "mmek", "snck", "mmf", "emk", "ymsk", "mmsk", "spesk", "slsk", "smkt"], "st": ["ist", "ld", "src", "rest", "ss", "sa", "ts", "sb", "ct", "sp", "sl", "sh", "St", "bl", "ste", "cr", "str", "sw", "sc", "ST", "std", "sn", "sts", "rd", "sta", "inst", "ost", "sth"], "ast": ["rest", "ts", "sa", "ab", "ac", "ream", "au", "post", "ess", "AST", "sc", "std", "obj", "node", "amp", "asm", "at", "asts", "inst", "sta", "path", "port", "ost", "am", "emb", "pp", "sth", "est"], "i": ["my", "li", "gi", "abi", "key", "ni", "ii", "zi", "ji", "chi", "h", "ui", "pi", "image", "d", "I", "n", "di", "is", "udi", "id", "mi", "it", "iu", "uli", "j", "y", "eni", "inner", "ri", "m", "info", "ti", "slice", "ini", "index", "z", "multi", "ai", "ie", "ip", "x", "c", "p", "ind", "bi", "hi", "phi", "e", "f", "l", "adi", "u", "ori", "ki", "v", "o", "qi", "ix", "t", "b", "uri", "ci", "init", "fi", "start", "si", "in", "xi"], "ret": ["row", "buffer", "rs", "aux", "ru", "alt", "tmp", "nt", "rev", "back", "tr", "rc", "Ret", "result", "ref", "resp", "std", "obj", "en", "RET", "seq", "re", "val", "rt", "res"], "tbase": ["mbuffer", "dBase", "mbase", "tseq", "tbuffer", "dbuffer", "outbase", "dbase", "dseq", "outBase", "outbuffer", "tBase", "mseq", "mBase", "outseq"], "frames": ["files", "groups", "plays", "quarters", "fram", "rules", "views", "vals", "flags", "cells", "seconds", "tracks", "faces", "Frames", "games", "links", "frame", "hops", "fps", "runs", "bits", "flows", "ports", "shots", "scenes", "tones", "ones", "planes", "images", "lines", "values", "pages", "features", "steps", "rows", "videos", "weights", "bands", "cycles", "blocks", "events", "points", "codes", "headers", "bytes", "times", "versions", "caps", "parts"]}}
{"project": "qemu", "commit_id": "9f1963b3f72521f75a549f8afd61b19e7da63c6f", "target": 0, "func": "static int coroutine_fn raw_co_discard(BlockDriverState *bs,\n\n                                       int64_t sector_num, int nb_sectors)\n\n{\n\n    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);\n\n}\n", "idx": 3920, "substitutes": {"bs": ["base", "cs", "ss", "bh", "ba", "rs", "sb", "lb", "BS", "bid", "bc", "pb", "fps", "bl", "bis", "ses", "ls", "bits", "outs", "ds", "als", "bas", "gs", "ps", "bf", "ns", "bus", "vs", "bi", "bos", "gb", "lbs", "obj", "bb", "ubs", "iss", "blocks", "fb", "b", "os", "ks", "bytes", "las", "bes", "fs", "obs"], "sector_num": ["sector_number", " sector_number", " sector_nom", " sector_name", "sector_nom", "sector_name", " sector_min", "sector_min"], "nb_sectors": ["nb_nesections", "nb_secctors", "nb_nefs", "nb_vefs", "nb_vegments", "nb_cections", "nb_serfs", "nb_nectors", "nb_negments", "nb_sersections", "nb_segments", "nb_vesections", "nb_sections", "nb_veors", "nb_cectors", "nb_secors", "nb_ceors", "nb_vectors", "nb_sergments", "nb_secgments", "nb_serctors", "nb_vections", "nb_seors", "nb_sesections", "nb_secctions", "nb_cegments", "nb_sefs"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n", "idx": 3924, "substitutes": {"bs": ["ob", "base", "js", "src", "cs", "sb", "bps", "BS", "bid", "bc", "banks", "ins", "pb", "fps", "bis", "plugins", "ses", "ls", "ds", "bas", "ps", "gs", "ns", "css", "vs", "bos", "lbs", "obj", "as", "iss", "blocks", "fb", "b", "os", "las", "bes", "fs", "db", "obs"], "sector_num": ["sector_number", " sector_count", "sector_count", " sector_nb", " sector_number", " sector_name", " sector_note", "sector_name", "sector_note", "sector_nb"], "nb_sectors": ["nb_sesctors", "nb_peors", "nb_pseivers", "nb_psegments", "nb_spegments", "nb_vegments", "nb_spections", "nb_speriers", "nb_spesector", "nb_serctions", "nb_peonents", "nb_pegments", "nb_sesonents", "nb_pseriers", "nb_speivers", "nb_segments", "nb_sesgments", "nb_seonents", "nb_sections", "nb_sesors", "nb_veors", "nb_veonents", "nb_seriers", "nb_spectors", "nb_psectors", "nb_vectors", "nb_sergments", "nb_serctors", "nb_veriers", "nb_vesector", "nb_sersector", "nb_vections", "nb_pectors", "nb_seors", "nb_veivers", "nb_sesector", "nb_seivers"], "flags": ["files", "fun", "cs", "offset", "Flags", "utf", "ops", "bit", "lag", "bps", "vals", "data", "ips", "faces", "type", "fl", "lf", "callback", "nl", "fps", "options", "nil", "bits", " Flags", "args", "sf", "info", "fts", "settings", "utils", "status", "feat", "fe", "factor", "fi", "fg", "vs", "flag", "features", "ints", "mask", "fields", "fee", "stats", "types", "forces", "bytes", "ants", "count", "fs", "ags", "FLAG"], "cb": ["ob", "fc", "orb", "fun", "cs", "ctx", "cc", "gc", "CB", "eb", "db", "callback", "bc", "buff", "pb", "fn", "buf", "rb", "fp", "cgi", "func", "cod", "bf", "ec", "dc", "c", "cv", "unc", "ctrl", "cd", "cmd", "bb", "cca", "pc", "fb", "cp", "b", "cf", "obb"], "opaque": ["opacity", " opque", "opsec", "compacity", "Opec", " opac", "opsacity", "opac", "operaque", "compque", "opace", " opacity", "compace", "hopaque", "hopace", "operec", "Opque", "operac", "opsque", "compaque", "operacity", "Opacity", "hopacity", " opace", "opec", "Opaque", "opsaque", "Opac", "opque", "hopque", "operque"]}}
{"project": "qemu", "commit_id": "25db9ebe15125deb32958c6df74996f745edf1f9", "target": 0, "func": "static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n", "idx": 3926, "substitutes": {"d": ["fd", "da", "dd", "a", "sd", "dh", "device", "data", "ad", "devices", "dict", "g", "m", "dt", "ds", "md", "z", "dc", "l", "c", "p", "dev", "state", "e", "dm", "f", "bd", "driver", "o", "s", "b", "dp", "D", "gd", "db"], "proxy": ["null", "server", "service", "http", "wrapper", "alias", "device", "image", "cop", "bin", "parent", "client", "instance", "component", "super", "clone", "pipe", "sync", "Proxy", "slice", "index", "pid", "pool", "config", "pointer", "native", "address", "ip", "pa", "p", "linux", "f", "ref", "copy", "cache", "child", "library", "roxy", "core", "docker", "driver", "connection", "v", "shadow", "pc", "pse", "lib", "web", "plugin", "container", "socket", "root", "slave", "io", "gp", "port"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,\n\n                            TCGReg dst, TCGReg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIK\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = ~rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opinv;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3933, "substitutes": {"s": ["cli", "service", "cs", "ctx", "ops", "a", "context", "sb", "com", "d", "n", "is", "ions", "scope", "i", "g", "bis", "comments", "m", "ses", "sf", "sync", "settings", "ds", "sets", "ns", "h", "c", "p", "services", "w", "e", "f", "sq", "u", "cases", "sec", "o", "b", "t", "session", "states", "se", "complex", "si", "ssl"], "cond": ["fc", "fact", "fd", "ctx", "local", "Cond", "def", "context", "cl", "rupt", "loc", "com", "ct", "nc", "con", "parent", "comp", "pre", "imm", "code", "coll", "cont", "config", "crit", "ps", "x", "ind", "c", "p", "xc", "l", "e", "condition", "lc", "f", "ref", "exec", "resp", "sec", "b", "cmp", "close", "six", "reg", "ex"], "opc": ["OPct", "Opf", "copci", " opci", "iopca", "ipcu", "OPc", "opca", "opct", "copc", "OPf", "iopcu", "opf", " opct", "ipci", "OPci", "Opc", "Opcs", "opcu", "ipca", " opcu", "copcs", "opci", "ipct", "opcs", " opf", " opca", "copf", " opcs", "ipc", "iopc", "ipcs", "copct", "Opct", "ipf", "iopf"], "opinv": ["opv", "oppconv", "ipv", " opconv", "optc", "optInv", " opInv", "opInv", "optinv", "hopinv", "oppcit", " opcit", "hopcit", "ipinv", "hopconv", "optv", "opconv", "opcit", "ipc", "oppinv", "ipInv", " opv"], "dst": ["Drd", "ldst", "dsp", "bste", "ldbe", "Dhs", "ydste", "bsp", "madbe", "Dsts", "dsc", " dbe", "dsts", "madsts", "dbe", "Dsp", "sdsts", "sdsc", "ldost", "sdst", " dsc", " dsts", "ldsts", "dste", "ydrd", "bst", "Dsc", "dhs", "sdhs", "madst", " dhs", "ydst", "madost", "brd", " dost", "drd", "Dste", "Dst", "dost", "ydsp"], "lhs": ["lhus", "lrrs", "Lrs", "lh", "dlhs", "Lhea", "lrHS", "dlht", "lrhea", "Lhs", "klhus", "rht", "LHS", "klrs", "lHS", " lh", "dlobs", "rHS", "dlh", "klHS", "lht", " lht", "rhus", "robs", "klhs", "lobs", " lhus", "klh", "klhea", " lobs", "lrs", "lrhs", "rh", "lhea", " lHS"], "rhs": ["rrhs", " rhh", "srh", "lh", " rhi", "pHS", "nrhs", "nrht", "rva", "rgh", "srHS", "Rhl", " rhl", "Rhes", "pva", "Rho", "rht", "ph", "lhess", "prh", "Rhs", " rgh", "rhl", "lhes", "rhh", "lHS", " rht", "rHS", "prhs", "srhs", "nrho", "yrhs", "rrHS", " rhess", " rho", "rhess", "rhes", "nrgh", "prhl", "Rh", "RHS", "Rht", "prhh", " rhes", "rhi", "yrh", "rrva", "lho", "lhi", " rHS", "phs", "rho", " rva", " rh", "rrh", "yrhess", "yrHS", "rh", "Rhh", "srhi", "Rgh"], "rhs_is_const": ["rhs_is_unsigned", "rhs_isaylinear", "rhs_is_cond", "rhs_antilesslinear", "rhs_as_int", "rhs_isamcond", "rhs_is_con", "rhs_islesslinear", "rhs_antilessconst", "rhs_isamlinear", "rhs_isaycond", "rhs_isamunsigned", "rhs_is_struct", "rhs_is_linear", "rhs_anti_unsigned", "rhs_isayunsigned", "rhs_is_int", "rhs_islessconst", "rhs_antilessunsigned", "rhs_isamconst", "rhs_anti_linear", "rhs_antilesscond", "rhs_as_struct", "rhs_islesscond", "rhs_anti_cond", "rhs_islessunsigned", "rhs_anti_const", "rhs_as_con", "rhs_isayconst", "rhs_as_const"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int twl92230_init(i2c_slave *i2c)\n\n{\n\n    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);\n\n\n\n    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);\n\n    /* Three output pins plus one interrupt pin.  */\n\n    qdev_init_gpio_out(&i2c->qdev, s->out, 4);\n\n    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);\n\n    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];\n\n\n\n    menelaus_reset(&s->i2c);\n\n\n\n    return 0;\n\n}\n", "idx": 3946, "substitutes": {"i2c": ["iouc", "i182cy", "i3xc", "i3e", "I2c", " i3cs", "i10u", "i2cu", "i5dc", "e2u", "i3f", "i182c", "i3cy", "i2u", "i4e", "i92c", " i4c", "i10c", "ui2c", "i1f", "e10e", "ui2f", "i2dc", "i3cs", "ialtxc", "e10c", " i2xc", "i3c", "i2lc", "I2e", "i2cs", "ialtc", "i4dc", " i4e", "ui3cy", "ialtcs", "iouxc", "i2cit", "i2ci", "i10e", "e2e", "i182f", "i1ci", "ui3f", "I2cu", "i3cit", "iorelc", "i1e", "i2cy", "iorec", "i2f", "iorecu", " i2dc", "i1cu", "i2xc", "i1cy", " i3cit", "i1dc", "ui3e", "ioucit", " i2ci", " i4ci", "ui3c", "ialtcit", "ioucs", "i4ci", " i3xc", "ui2e", "i92e", "e10u", "ioree", " i2e", "i4c", "i2e", "i5ci", "i1lc", "i1c", "i182e", "ui2cy", " i3c", "i5c", " i2cs", " i2cit", "i1u", "e2c", "i92u", "i5e", " i4dc", "I2lc"], "s": ["sg", "server", "js", "service", "cs", "ss", "spec", "ts", "rs", "sb", "r", "d", "n", "seconds", "is", "sites", "sl", "k", "y", "i", "g", "m", "ses", "ls", "uns", "args", "sync", "settings", "z", "sets", "ds", "gs", "ns", "l", "c", "p", "services", "w", "e", "self", "f", "set", "us", "es", "sys", "conf", "u", "sq", "south", "o", "v", "b", "su", "S", "t", "session", "os", "state", "states", "fs", "si", "in", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "e8c4df40e399fc87c6167c5557c11e0d904ca720", "target": 1, "func": "static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n    AVCodecContext *enc = trk->enc;\n\n    unsigned int samplesInChunk = 0;\n\n    int size= pkt->size;\n\n\n\n    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */\n\n    if (!size) return 0; /* Discard 0 sized packets */\n\n\n\n    if (enc->codec_id == CODEC_ID_AMR_NB) {\n\n        /* We must find out how many AMR blocks there are in one packet */\n\n        static uint16_t packed_size[16] =\n\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};\n\n        int len = 0;\n\n\n\n        while (len < size && samplesInChunk < 100) {\n\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n\n            samplesInChunk++;\n\n        }\n\n        if(samplesInChunk > 1){\n\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n\n            return -1;\n\n        }\n\n    } else if (trk->sampleSize)\n\n        samplesInChunk = size/trk->sampleSize;\n\n    else\n\n        samplesInChunk = 1;\n\n\n\n    /* copy extradata if it exists */\n\n    if (trk->vosLen == 0 && enc->extradata_size > 0) {\n\n        trk->vosLen = enc->extradata_size;\n\n        trk->vosData = av_malloc(trk->vosLen);\n\n        memcpy(trk->vosData, enc->extradata, trk->vosLen);\n\n    }\n\n\n\n    if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {\n\n        /* from x264 or from bytestream h264 */\n\n        /* nal reformating needed */\n\n        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);\n\n        if (ret < 0)\n\n            return ret;\n\n        assert(pkt->size);\n\n        size = pkt->size;\n\n    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n\n        /* copy frame to create needed atoms */\n\n        trk->vosLen = size;\n\n        trk->vosData = av_malloc(size);\n\n\n\n        memcpy(trk->vosData, pkt->data, size);\n\n    }\n\n\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n\n        if (!trk->cluster)\n\n            return -1;\n\n    }\n\n\n\n    trk->cluster[trk->entry].pos = url_ftell(pb);\n\n    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;\n\n    trk->cluster[trk->entry].size = size;\n\n    trk->cluster[trk->entry].entries = samplesInChunk;\n\n    trk->cluster[trk->entry].dts = pkt->dts;\n\n    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;\n\n\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n\n        pkt->pts = pkt->dts;\n\n    }\n\n    if (pkt->dts != pkt->pts)\n\n        trk->hasBframes = 1;\n\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n\n    trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY);\n\n    if(trk->cluster[trk->entry].key_frame)\n\n        trk->hasKeyframes++;\n\n    trk->entry++;\n\n    trk->sampleCount += samplesInChunk;\n\n    mov->mdat_size += size;\n\n\n\n    put_buffer(pb, pkt->data, size);\n\n\n\n    put_flush_packet(pb);\n\n    return 0;\n\n}", "idx": 3956, "substitutes": {"s": ["sg", "cli", "js", "service", "server", "cs", "sup", "http", "ss", "spec", "qs", "sa", "a", "sb", "r", "d", "n", "aws", "sl", "bis", "g", "params", "m", "ls", "ses", "sf", "sync", "sv", "ds", "gs", "ns", "c", "p", "services", "e", "self", "f", "us", "conf", "sq", "sc", "sports", "sys", "u", "o", "v", "stats", "b", "su", "S", "t", "an", "sci", "se", "si", "sym", "ssl"], "pkt": ["spacket", "piece", "macket", "cacket", "spiece", "feter", "upacket", "funk", " peter", "packkg", " packet", "ppunk", "Punk", "fkg", "prpt", "upiece", "packkt", "fet", " pwk", "cunk", "upunk", "pet", " pet", "prwk", "facket", "peter", "mkt", "ppt", " punk", "ppacket", "pwk", "rkt", "mkg", "munk", "Ppt", "pkg", "punk", "racket", "prkt", "packacket", " peth", "fiece", " piece", "pracket", "Packet", "spkg", "Pkg", "ckt", "reth", "ciece", "Pwk", "Pet", "rpt", "ppwk", "packeter", "Peth", "ppkt", "fkt", " pkg", "spkt", "upkt", "packet", " ppt", "Piece", "Pkt", "peth"], "mov": ["smOV", "cmour", "mOV", "smou", "cmove", "tmov", " mOV", "cmev", "demev", "mev", "mou", "smove", "tmove", "demove", "move", "cmov", "smov", "demour", " move", "tmou", "demov", " mour", "mour", " mou", " mev", "tmOV"], "pb": ["fc", "np", "ctx", "bh", "lp", "pd", "ppa", "sb", "bps", "bm", "lb", "cpp", "ub", "prot", "hub", "ib", "rob", "bc", "platform", "ocol", "api", "param", "PB", "rb", "fp", "cb", "ream", "pid", "pa", "pkg", "p", "orp", "wb", "pm", "summary", "phrase", "amp", "bp", "pc", "bb", "fb", "cp", "plugin", "abb", "aph", "uf", "wp", "dp", "gp", "typ", "db"], "trk": [" trK", "Trk", " trkt", " trkin", "prku", "perK", "rtK", "trq", "turok", "srku", " trok", "prok", "hrK", "turK", "turke", "prsk", " trg", "wrkin", "frkt", "hrke", "Trks", "hrks", "prc", "ersk", "trkt", " trwork", " trke", "TRks", "prk", "perke", "hrk", "trak", " trf", "prkick", "wrk", "frk", "trku", "rtwork", "perks", "terke", "prg", "rtc", " trks", "trkick", "prf", "trg", "prK", "TRke", " trku", "srsk", "wrks", "frke", "Trck", "frq", "frK", "hrok", "erke", "trf", "erf", " trc", " trq", "trck", "perk", "trsk", "terkick", "prke", "TRk", "srke", "TrK", "hrck", "hrg", "rtk", "prwork", "trke", "turkick", "srk", "trK", "trkin", "trake", "trakin", "terk", "TRK", "prck", "trwork", "traks", " trsk", "turq", "turk", "prkt", "frg", "prks", "erk", "terok", "trc", "wrke", "frks", " trck", "trks", "trok"], "enc": ["eu", "acl", "rn", "ct", "nc", "rec", "sl", "open", "lang", "secure", "ENC", "cod", "ec", "ack", "cv", "encrypted", "oc", "sys", "vc", "en", "rh", "acc", "alg", "ext", "spec", "anc", "equ", "auth", "eng", "mac", "ac", "kw", "ce", "Enc", "lc", "unc", "lib", "iv", "ev", "sci", "ssl", "ctx", "loc", "voc", "env", "ent", "util", "c", "app", "cache", "alloc", "sec", "ic", "conv", "img", "ou", "bn", "hw", "ant", "conn", "nec", "con", "comp", "iq", "auc", "coll", "nt", "ch", "config", "cel", "cmp", "install", "inc", "oder"], "packed_size": ["packed_length", " packed_capacity", "packed2count", "packed_shape", "oded_shape", "oded_range", " packed_length", "packed2length", "packed_count", " packed_count", "oded_size", "packed_range", "packed_capacity", "packed2capacity", "packed2size"], "samplesInChunk": ["samplesInCheunk", "samplesInCHoca", "samplesInChartunk", "samplesInPartunk", "samplesINCheoca", "samplesInCompacket", "samplesInCick", "samplesInChick", "samplesPerChunk", "samplesInCompick", "samplesPerCHica", "samplesInCheacket", "samplesInPartica", "samplesInCHunk", "samplesPerChoy", "samplesPerChoku", "samplesInChoku", "samplesInCompunks", "samplesPerCHunks", "samplesInChipica", "samplesInPartick", "samplesInchunks", "samplesInChartunks", "samplesINChacket", "samplesInCHunks", "samplesInChipick", "samplesInCompunk", "samplesInChunks", "samplesInchacket", "samplesInChoca", "samplesInCompoy", "samplesInCHica", "samplesInCHoy", "samplesInChipunk", "samplesInCunk", "samplesInchoy", "samplesInCHoku", "samplesPerChick", "samplesINCheunk", "samplesInChartoy", "samplesInCoy", "samplesInCHacket", "samplesInCHick", "samplesInchoku", "samplesInChoy", "samplesINCheacket", "samplesInChartoku", "samplesInchunk", "samplesINChunk", "samplesINChoca", "samplesPerCHoku", "samplesInChacket", "samplesPerCHunk", "samplesPerChica", "samplesPerCHoy", "samplesPerCHacket", "samplesPerCHick", "samplesInChica", "samplesPerChacket", "samplesPerChunks", "samplesInchoca", "samplesInCheoca", "samplesInCunks"]}}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 3960, "substitutes": {"ctx": ["cm", " cx", "cli", "null", "cam", "src", "kb", "cor", "hw", "conn", "context", "cc", "txt", "anc", "cpp", "loc", "cz", "aux", "ck", "bc", "voc", "cy", "scope", "tc", "gz", "client", "cas", "mac", "kt", "tx", "sync", "cb", "fp", "xs", "config", "pkg", "cu", "c", "cv", "lc", "ctr", "ca", "ctrl", "wcs", "exec", "sc", "cn", "cmd", "alloc", "vc", "linux", "cca", "connection", "lib", "qa", "cp", "cmp", "req", "cf", "rx", "ci", " context", "sci", "qt", "rc"], "opc": ["OPct", "optn", "optc", "hopn", "operct", "OPc", "opct", "OPn", "opcn", "copc", "optct", "OPcn", "hopct", "copn", "opern", "hopc", "opercn", "copct", "opC", "copC", "optcn", "optC", "hopC", "operc"], "rt": ["rot", "dr", "route", "ret", "cycle", "src", "mt", "target", "rs", "ant", "vt", "rn", "rr", "r", "loc", "wt", "ru", "type", "cat", "vert", "format", "it", "tab", "boot", "rf", "adr", "rb", "lat", "nt", "ft", "fr", "cr", "rid", "dt", "rev", "feat", "RT", "ptr", "rl", "reset", "ref", "sys", "gt", "yt", "art", "tt", "vc", "rd", "rx", "req", "addr", "vr", "pt", "typ", "rect", "rc"], "base": ["unit", "rot", "based", "server", "name", "buffer", "rest", "extra", "area", "lb", "ace", "loc", "ase", "Base", "id", "boot", "pre", "source", "bas", "bf", "address", "ite", "l", "p", "beta", "et", "bi", "set", "reset", "ref", "len", "core", "cache", "size", "lc", "range", "bb", "prefix", "scale", "b", "site", "uri", "addr", "count", "part", "root", "start", "db"], "offset": ["rot", "name", "adjust", "alias", "acl", "area", "data", "url", "loc", "align", "position", "type", "alt", "format", "slot", "boot", "off", "initial", "pos", "fp", "attribute", "index", "address", "alpha", "p", "et", "set", "reset", "f", "attr", "length", "size", "len", "ref", "origin", "range", "padding", "phase", "o", "prefix", "seq", "Offset", "b", "location", "addr", "part", "start"], "opn": [" oprn", "OPns", "opnc", "ipN", " opns", "iprn", "optn", "hopn", "hopnu", "optc", "optN", "oprn", "OPc", "rootnu", " opb", "OPn", "OPnc", "ipb", "optl", "ipl", " opnu", "rootc", "opern", "hopc", "okn", "ipn", "opns", " opnc", "operN", "opb", "rootn", "ipc", " opN", "okc", "operl", "opN", "opnu", "hopl", "operc", " opl", "optrn", "opl", "oknc", "rootN", "hopN", "okns", "optb"], "t0": ["t4", "pt8", "p3", "f1", "p8", "pt4", "pt1", "f4", "p4", "pt00", "tt1", "p00", "T2", "p1", "pt0", "f2", "t00", "tt0", "T0", "T5", "f5", "t2", "p0", "t5", "tt5", "pt2", "T3", "t8", "f0", " t5", "T4", "T8", "t3", " t4", " t2", "p2", " t3", " t00", "T1"], "t1": ["pt9", "Tached", "Tb", "p3", "tone", "pt1", "taone", "tb", "T2", "p1", "ta0", "t9", "pt0", "pb", "T0", "t2", "Tone", "at0", "pached", "p0", "pt2", "ppre", "T3", "tached", "Tpre", "p9", "t3", "atpre", "at1", "tpre", " t2", "at2", "ta1", "p2", " t3", " tone", "T9", "atached", "T1", " tb"]}}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "substitutes": {"dma": ["Dda", "mdma", "mdla", "mwa", "mma", " dwa", "bMA", "bma", " dta", "mdwa", "mdMA", "dwa", "Dwa", "mMA", "dta", "Dmm", " dMA", " dda", "dmm", "bta", " dmm", "ldla", "dMA", "mmp", " dmp", "dda", "ldma", "ldMA", "DMA", "bmp", "ldwa", "mmm", "Dma", "dmp", "dla", "Dla", "mta", "mda"], "is_write": ["is_read", "id_writ", "id_mode", "id_write", "is_writ", "id_read", "is_mode"], "bm": ["cm", "base", "vm", "dn", "bh", "bn", "em", "bo", "mc", "sb", "lb", "binary", "fl", "bc", "BM", "mi", "bin", "im", "pb", "mm", "bl", "umi", "y", "lim", "m", "gm", "cb", "sbm", "md", "om", "bf", "gs", "hm", "p", "bi", "nb", "dm", "ym", "bd", "ram", "cache", "wm", "rm", "gb", "rem", "bt", "pm", "obj", "bg", "fm", "bb", "mr", "tm", "nm", "sm", "b", "bp", "module", "bs", "an", "cfg", "am", "gp", "db"], "s": ["sg", "js", "service", "so", "cs", "ss", "rs", "sa", "spec", "ts", "sb", "ings", "qs", "r", "d", "is", "ins", "sl", "ions", "ms", "y", "sis", "g", "m", "ses", "ls", "sync", "ys", "sv", "storage", "ds", "sets", "ps", "gs", "ns", "c", "p", "state", "services", "e", "w", "f", "es", "secondary", "sys", "sq", "conf", "set", "sn", "sr", "o", "stats", "b", "su", "S", "os", "session", "serv", "sim", "t", "bs", "an", "its", "hs", "states", "se", "fs", "si", "sym", "ssl"], "pci_dev": ["pcm_device", "pci__addr", "pdi_div", "pciMdevice", "pci__mode", "pci2div", "pcm_div", "pci2device", "pci__device", "pci_priv", "pci_device", "pci2conn", "pci_addr", "pciMmode", "pciMdiv", "pdi_mode", "pci__dev", "pdi_priv", "pcm_dev", "pdi_device", "pcm_conn", "pci2dev", "pci_div", "pciMdev", "pci_conn", "pdi_dev", "pci2priv", "pci_mode", "pdi_addr"], "prd": ["frdd", " prcd", "sprdm", " prdh", "sprb", " prdt", "perd", "yrdd", "frd", " prt", "prb", "rd", "prs", "rt", " prn", "prr", "erdh", "perr", "parb", "sprdd", "privd", "Prd", "sprd", "parcd", "Prds", "erds", " prb", "sprs", "erd", "prcd", "prdh", "ptrds", " prs", "privs", "sprcd", "perb", "frn", "pert", "ird", "Prdh", "prdm", "ptrn", "sprdy", "trd", "ern", "prdy", " prr", "trds", "rr", " prdd", "pern", "frds", "prt", "ptrs", "prds", "privdt", "pard", "yrd", "irdy", "ptrdy", " prdy", "trs", "prdt", "privds", "ptrdm", "perdy", "ptrb", " prds", "yrds", "sprds", " prdm", "ptrd", "rb", "Prn", "parn", "irs", "prn", "yrb", "trdt", "prdd", "sprn", "irds"], "l": ["ell", "ld", "li", "ol", "jl", "ul", "lp", "lb", "vl", "r", "d", "n", "dl", "lu", "ln", "fl", "lf", "sl", "nl", "i", "j", "m", "ls", "ll", "z", "tl", "c", "p", "L", "e", "lc", "f", "length", "kl", "rl", "El", "u", "la", "el", "il", "en", "o", "v", "b", "lin", "lit", "le"], "len": ["base", "ell", "ld", "li", "lan", "ol", "lp", "elt", "ni", "Len", "url", "loc", "n", "lf", "lu", "ln", "fl", "sl", "dl", "bl", "j", "lim", "pos", "dy", "ll", "lt", "err", "rev", "z", "lon", "L", "ler", "lc", "length", "kl", "f", "size", "la", "el", "il", "en", "v", "hl", "lib", "lin", "full", "line", "low", "val", "count", "limit", "le"]}}
{"project": "FFmpeg", "commit_id": "5a2ad7ede33b5d63c1f1b1313a218da62e1c0d48", "target": 0, "func": "static int apply_window_and_mdct(vorbis_enc_context *venc,\n\n                                 float *audio, int samples)\n\n{\n\n    int channel;\n\n    const float * win = venc->win[0];\n\n    int window_len = 1 << (venc->log2_blocksize[0] - 1);\n\n    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;\n\n    AVFloatDSPContext *fdsp = venc->fdsp;\n\n\n\n    if (!venc->have_saved && !samples)\n\n        return 0;\n\n\n\n    if (venc->have_saved) {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memcpy(venc->samples + channel * window_len * 2,\n\n                   venc->saved + channel * window_len, sizeof(float) * window_len);\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2, 0,\n\n                   sizeof(float) * window_len);\n\n    }\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->samples + channel * window_len * 2 + window_len;\n\n\n\n            fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2 + window_len,\n\n                   0, sizeof(float) * window_len);\n\n    }\n\n\n\n    for (channel = 0; channel < venc->channels; channel++)\n\n        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,\n\n                     venc->samples + channel * window_len * 2);\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->saved + channel * window_len;\n\n\n\n            fdsp->vector_fmul(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n        venc->have_saved = 1;\n\n    } else {\n\n        venc->have_saved = 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 3971, "substitutes": {"venc": ["tenpc", "vence", "genec", "fenec", "renf", "gencu", "venl", "tenp", "avenlc", "avencf", "enc", "wennc", "velf", "fenc", "venp", "verncs", "avennc", "avence", "rencu", "VENcs", "hencu", "dennc", "venf", " venf", "vanc", "tenec", "venlc", "VENc", "vendc", "tenl", "VENrc", "denp", "tendc", "gencs", "avene", "tenc", "rene", "tenf", "vernec", "avenic", "avenec", "ovenlc", "venrc", "venpc", "renpc", "ovenec", "avenf", "VENcu", "vinc", "wenec", "genlc", "wene", "vellc", "vanf", "denlc", "tencs", "avendc", "verne", "vency", "renrc", "tene", "vancy", "denec", "venxc", "ovenf", "vernf", "avenxc", "avenp", "tenv", "avenl", "renxc", "vinxc", "wenf", "denc", "vencu", "renlc", "enl", "genc", "renl", "avenpc", " venic", "vernlc", "denl", "isenf", "fenf", "wencu", "wence", "vinl", "venv", "isenc", "rencs", "vinpc", "tenlc", "genf", "vencf", "VENf", "renc", "hene", "wenc", "velc", "henf", "ovenc", "dendc", "enf", "venic", "denf", "vincu", "vince", "venec", "avencu", " vencf", "vinrc", " vencu", "tencu", "wencs", "wenp", "vene", "isencf", "vennc", "isenic", "avenc", "avencs", "vinec", "fenl", "vencs", "vinf", "dency", "velec", "henc", "renec", "renp", "avency", "VENce", "vernc", "vanp", " venv", "rence", "enec", "renv"], "audio": ["media", "buffer", "a", "array", "Audio", "byte", "data", "image", "mpeg", "binary", "window", "format", "video", "bin", "wav", "sample", "i", "output", "space", "ac", "m", "file", "source", "sound", "config", "feed", "native", "alpha", "length", "voice", "play", "wa", "img", "wave", "io", "volume", "input"], "samples": ["ssamples", " samps", "chummies", "nample", "sums", "vourses", "ssipes", "Sounds", "sample", "tamp", "ssamps", "isample", "sourses", "jsolutions", "samps", "isummies", "sounds", " sounds", "bample", "chourses", "opensamples", " samp", "fipes", " songs", "damps", "vipes", "isamples", "samp", "bources", "jsamples", "Sample", "Saved", "summies", " sannels", "tamples", "chums", "namples", "sesources", "taved", "damples", "channels", "sipes", "Samps", "Samp", " sourses", "bamples", "opensamps", "namps", "ssongs", "tamps", " saved", "Sannels", "fannels", "Sources", "songs", "chaved", "opensannels", "inseeds", "baved", "dourses", "sesamps", "insourses", "jsaved", "sitesannels", "vums", "insaved", "dample", "sitesamps", "opensipes", "Samples", "insamples", "sitesamples", "famples", "sources", " solutions", "bourses", "sesample", "bamps", "sesamples", "chample", "cheeds", " sipes", "champles", "beeds", "vannels", "dums", "seeds", "vamples", "jsannels", "dannels", "isaved", "fourses", "solutions", "dummies", "sitesounds", "ssannels", "saved", "sannels", "dolutions", "daved", "Songs"], "channel": ["route", "row", "key", "panel", "queue", "url", "column", "nc", "video", "sample", "client", "pixel", "event", "direction", "password", "database", "chan", "feed", "man", "change", "bean", "annels", "message", "comment", "path", "socket", "course", "an", "option", "unit", "group", "name", "cycle", "target", "image", " channels", "tube", "character", "type", "slot", "format", "chain", "frame", "gap", "batch", "hole", "model", "package", "component", "custom", "resource", "core", "question", "handler", "plugin", "session", "player", "user", "layer", "wan", "version", "outer", "byte", "global", "page", "section", "remote", "member", "language", "project", "Channel", "function", "category", "c", "size", "stream", "center", "phase", "connection", "campaign", "error", "module", "contin", "stage", "call", "server", "letter", "service", "second", "chron", "window", "month", "platform", "button", "variable", "item", "attribute", "source", "ch", "config", "word", "block", "mon", "token", "container", "element", "ann", "que", "can"], "win": ["wan", "lock", "row", "conn", "image", "gain", "window", "ad", "n", "weight", "widget", "margin", "rec", "con", "bin", "fn", "lang", "client", "ng", "na", "won", "enc", "batch", "wal", "max", "num", "in", "pos", "ac", "scan", "rain", "inn", "write", "config", "disk", "block", "work", "thin", "w", "Win", "draw", "col", "skin", "gui", "nan", "min", "play", "clean", "wa", "gen", "wave", "run", "limit", "input"], "fdsp": ["this", "hdse", "hdsl", "vdpc", "fdsm", "g", "dfsp", "vdse", "ndsp", "dfsc", "vdsc", "fdsk", "vdsm", "all", "fdsl", "dfse", "end", "dnspe", "dfsk", "hdsk", "dfp", "dnpc", "ldsh", "dntp", "fdpc", "wave", "hdp", "ndsm", "vdp", "hdsp", "vdcp", "dfpc", "vdsl", "hdpc", "ldsl", "hdsh", "dfsm", "ndsc", "fdspe", "ldpc", "fdcp", "img", "_", "ndcp", "buffer", "ldspe", "dftp", "vdsk", "fdp", "vdsp", "d", "ldtp", "ldsp", "dnsp", "config", "dfcp", "fdsh", "fdse", "dfspe", "vdsh", "fdsc", "fdtp"], "offset": ["layer", "rot", "null", "activation", "append", "adjust", "alias", "url", "annot", "image", "loc", "align", "window", "position", "slot", "help", "alt", "parent", "end", "off", "initial", "seed", "i", "output", "pos", "label", "entry", "info", "pixel", "attribute", "notation", "style", "index", "address", "ip", "pad", "alpha", "shift", "layout", "reset", "size", "f", "attr", "length", "origin", "value", "padding", "o", "prefix", "Offset", "error", "online", "location", "addr", "part", "limit", "start"]}}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n", "idx": 3977, "substitutes": {"l": ["pl", "ol", "li", "ul", "lp", "cl", "lb", "r", "d", "n", "dl", "ln", "sl", "lr", "i", "m", "ls", "ll", "x", "c", "p", "L", "e", "lc", "f", "length", "len", "kl", "u", "la", "el", "o", "v", "b", "t", "al", "val", "lo", "list", "le"]}}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n", "idx": 3984, "substitutes": {"gain": ["unit", "group", "gar", "paren", "hack", "gan", "wan", "guide", "dn", "gram", "atten", "ga", "conn", "nn", "go", "align", "gnu", "format", "gross", "bin", "grain", "gate", "gap", "pass", "gin", "g", "kin", "gg", "auc", "scan", "forward", "gn", "password", "inn", "parse", "config", "gam", "gender", "rank", "attr", "wm", "gb", "loss", "win", "ain", "range", "scale", "bridge", "sign", "sort", "clean", "rule", "gen", "wave", "learn", "gp", "shape", "acc", "input", "can"], "fraction": ["fractions", "bletcher", "Fletcher", "Fract", "rfract", "rference", "infraction", "lfractions", "Fancy", "infault", "infancy", "refract", "frequency", "Fraction", "bract", "ofrequency", "infractions", "rfraction", " fractions", "ofractions", "refletcher", "ofraction", "ofancy", " fault", "Fault", "feraction", "ference", "feractions", "fletcher", " fract", "Flux", "bractions", "lflux", "braction", "refractions", "flux", "fract", "inference", "infract", "lfraction", "felux", "Fractions", "Frequency", "fault", "rfractions", "refraction", " fletcher", "lfletcher", "fancy", "feletcher", "Ference", "infrequency"], "db": ["cm", "base", "fd", "ba", "dd", "sd", "sb", "nn", "bm", "ab", "dB", "mb", "ib", "d", "eb", "dl", "ma", "bc", "pg", "pb", "deb", "gg", "rb", "dy", "scan", "DB", "big", "cb", "amb", "sql", "mag", "ds", "bf", "bi", "nb", "dm", "bd", "gb", "mp", "min", "bg", "bb", "scale", "lib", "fb", "b", "Db", "dp", "real"]}}
{"project": "qemu", "commit_id": "c641483fbe0aa08cd7c0580d019dc2d5a7e71138", "target": 1, "func": "static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n", "idx": 3988, "substitutes": {"s": ["submit", "js", "src", "ss", "ops", "spec", "ts", "rs", "sb", "d", "is", "sl", "g", "m", "ses", "sf", "sync", "sv", "storage", "ds", "status", "ns", "c", "p", "services", "state", "e", "self", "f", "es", "sys", "sq", "sports", "u", "south", "o", "b", "S", "t", "os", "session", "an", "states", "se", "input", "sym", "ssl"], "dma_cb": ["dma_done", "dfa_CB", "dfa_callback", "dfa_rb", "dfa_done", "dma_CB", "dma_rb", "dfa_cb", "dma_callback"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 4006, "substitutes": {"bs": ["base", "nas", "js", "cs", "ctx", "abi", "ss", "http", "bh", "rs", "ts", "qs", "sb", "bps", "lb", "bm", "BS", "ubs", "bid", "bc", "banks", "ros", "bin", "pb", "bing", "bl", "bis", "plugins", "ls", "ses", "bits", "details", "sync", "cb", "ys", "xs", "bal", "ds", "als", "ras", "bas", "ps", "gs", "ns", "css", "vs", "bi", "us", "bos", "es", "sys", "gb", "lbs", "obj", "bb", "blocks", "stats", "iss", "b", "fb", "pse", "os", "ks", "las", "bytes", "bes", "fs", "db", "obs"], "query_backing": ["query_defging", "query_tunishing", "query_defering", "query_bbinding", "query_frontering", "query_boundlocking", "query_frontding", "query_returned", "query_landing", "query_frontging", "query_boundging", "query_callbacked", "query_frontinding", "query_boundending", "query_returnending", "query_bbding", "query_callbacklocking", "query_defing", "query_frontings", "query_callbackending", "query_boundning", "query_udings", "query_backering", "query_udinding", "query_landging", "query_uding", "query_bounding", "query_backed", "query_returning", "query_frontishing", "query_landding", "query_returnlocking", "query_backning", "query_backishing", "query_backlocking", "query_bounded", "query_tuning", "query_backending", "query_udding", "query_backings", "query_bbings", "query_backinding", "query_defding", "query_backging", "query_landering", "query_callbacking", "query_boundishing", "query_backding", "query_tunging", "query_bbing", "query_frontning", "query_tunning", "query_fronting"], "s": ["sg", "js", " results", "ists", "qs", "n", "g", "ses", "ls", "sf", "er", "css", "self", "f", "secondary", "sys", "u", " values", "ubs", "your", "fs", "ows", "parts", "spec", "ts", "ges", "sb", "ings", "aws", "y", "sets", "or", "p", "e", "lines", "conf", "sports", "v", "less", "su", "ves", "S", "t", "session", "os", "ks", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "r", "is", "ies", "i", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "rates", "words", "es", "rows", "obj", "o", "ed", "si", "service", "http", "ops", "d", " statements", "details", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states", "bes"]}}
{"project": "FFmpeg", "commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "target": 1, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, const uint8_t *src_end,\n\n                                    int width, int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *src_start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    return AVERROR_PATCHWELCOME;\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        if (end - dst < count) {\n\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            if (i+2 >= src_end - src)\n\n                return AVERROR_INVALIDDATA;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n            dst += i;\n\n        }\n\n    }\n\n    return  src - src_start;\n\n}\n", "idx": 4009, "substitutes": {"l": ["pl", "ell", "ld", "ol", "li", "jl", "ul", "lp", "acl", "lb", "url", "ml", "loc", "d", "n", "dl", "lu", "ln", "sl", "fl", "shell", "k", "wl", "nl", "bl", "iol", "m", "ls", "ll", "c", "p", "L", "e", "lc", "rl", "kl", "f", "u", "la", "el", "il", "o", "s", "v", "lib", "b", "gl", "t", "al", "lo", "list", "le"], "dst": ["ndsrc", "Dirst", "ddsts", "pdost", " dsp", "ndost", "odost", "lsth", " dest", "odsth", "dct", "Dsrc", "sdost", "dirst", "ndsts", "dsth", "Dest", "idsc", "dsts", "drc", "Dsp", " dsrc", "sdsts", "Drc", "Dost", "pdst", "adsth", "idrest", "pdsts", " dsc", "dste", "idste", "ddsth", "Dsth", " dct", "ndst", "Dst", "adct", "idost", "dsp", " drest", "pdirst", "ddst", "idct", "dsc", "ddsrc", "adst", "adrest", "lrc", "sdsc", "sdst", "dsrc", "drest", "lst", "fdrest", "Dsc", "fdost", "odest", " dost", "Dste", "dost", "adost", "idst", "ddrc", "Dsts", "odst", "ddost", "dest", "lost", " drc", "adrc", " dsts", "fdst", " dsth", "sdsp", "Drest", "fdste", "ddsc", "sdirst"], "src": ["sub", "rib", "rest", "url", "flash", "rec", "sl", "secure", "ind", "cv", "sc", "s", "seq", "start", "pack", "sup", "ource", "sb", "host", "send", "sh", "gz", "buf", "tmp", "usc", "ser", "sit", "resource", "length", "core", "text", "sn", "sr", "sci", "ssl", "ctx", "rs", "chrom", "ruby", "r", "loc", "use", "proc", "cb", "slice", "st", "sel", "c", "size", "stream", "sec", "rss", "gl", "inst", "sur", "supp", "low", "img", "uc", "inf", "stage", "http", "rob", "cur", "comp", "rb", "dest", "sync", "source", "ch", "config", "sq", "uv", "gb", "cmp", "support", "desc", "dist", "rc"], "src_end": ["rc_id", "src_close", "rc_size", "srcjid", "srcjend", "srcjstart", "src_size", "rc_start", "rc_end", "src_id", "rc_close", "srcjclose"], "esc_count": ["esc_connection", " sc_connection", "loc_count", "esc_length", "escitycount", "sec_Count", "esc_low", "loc_len", "sec_batch", " sc_size", " sc_depth", "esc33depth", "esc33size", "loc_num", " sc33count", "escitylow", "esc33count", "loc_length", " sc33connection", " sc33size", "sec_size", "sec_low", " sc33depth", "esc_len", "esc33connection", "esc_start", "esc_Count", "esc_num", "esc_depth", "sec_count", "sec_start", "esc_batch", "esc_size", " sc_count", "escitybatch", "escitysize"], "count": ["call", "base", "name", "isc", "check", "offset", "a", "cc", "process", "current", "loc", "n", "weight", "type", "add", "id", "found", "common", "num", "max", "code", "coll", "low", "inc", "ch", "feed", "ind", "c", "work", "p", "e", "f", "len", "size", "length", "cache", "child", "col", "min", "sum", "s", "b", "old", "depth", "full", "line", "Count", "val", "limit", "list", "all", "start", "keep"], "src_start": ["src_max", "rc_id", "rc_start", "rc_end", "src_id", "rc_last", "rc_max", "src_last"], "end": ["ending", "pend", "append", "offset", "rest", "tail", "r", "ad", "send", "n", "id", "head", "enc", "END", "max", "code", "entry", "ended", "dest", "z", "last", "st", "h", "ind", "c", "p", "x", "w", "e", "End", "set", "size", "length", "u", "ion", "en", "old", "stop", "nd", "edge", "limit", "start", "rc", "est"], "i": ["cli", "n", "j", "ti", "index", "x", "ind", "hi", "f", "u", "ori", "at", "uri", "fi", "start", "ami", "name", "ali", "esi", "zi", "ji", "ui", "pi", "ib", "type", "id", "iu", "api", "y", "ri", "z", "ie", "p", "e", "isi", "v", "qi", "ix", "t", "io", "init", "in", "base", "li", "a", "ni", "ii", "r", "I", "di", "is", "info", "slice", "ini", "c", "phi", "si", "inf", "yi", "gi", "ei", "oi", "d", "it", "eni", "multi", "ai", "ip", "bi", "b", "ci", "xi"]}}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static int ram_init_all(RAMState **rsp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (ram_state_init(rsp)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 4017, "substitutes": {"rsp": ["rrserv", " risp", " rosp", "nrsk", "Rserv", "arsc", "rsl", "rrsp", "Rsc", " rsc", "rrpt", "erisp", "Rpt", "erp", "rbsp", "arpt", "srsc", "rSP", " rbsp", "rrhtml", "psl", "pp", "rrp", "ersc", "Rsp", "rserv", "rrsc", "srSP", " rp", "srsk", "rrspace", "rpt", "ersp", "ersl", "rsk", "erbsp", "Rsk", "arsp", "srserv", "arspace", " rsl", "psp", "hrp", "rp", "erosp", "risp", "rhtml", "srp", "rosp", "erSP", "srsp", "rrsl", "hrosp", "srbsp", "rrbsp", "rrosp", " rSP", "hrsp", "srsl", "srisp", "arserv", " rpart", "rpart", "arsl", "nrserv", "phtml", "rrpart", "rspace", "Rspace", " rhtml", "hrpart", "nrsp", "Rsl", "rsc", "nrsc"], "local_err": ["external_error", " local_req", " local_rs", "local_errors", "localableerr", "external67ref", " local_error", "localablers", "localablegr", "local_rs", "external_err", "local_gr", " local_gr", "localableerror", "local_error", " local_errors", "local67ref", "local67err", "external_ref", "local_ref", "local67error", "external67error", "local_req", "external67err"], "block": ["flow", "unit", "group", "base", "lock", "row", "name", "buffer", "ban", "build", "channel", "this", "def", "byte", "image", "tag", "type", "open", "job", "bc", "chain", "section", "record", "end", "frame", "num", "off", "batch", "bl", "pre", "label", "inner", "box", "sync", "event", "number", "slice", "network", "address", "ip", "word", "work", "result", "ref", "copy", "cache", "prev", "object", "join", "exec", "range", "node", "comment", "Block", "blocks", "b", "plugin", "error", "rule", "link", "session", "full", "line", "run", "load", "map", "pack"]}}
{"project": "FFmpeg", "commit_id": "86b0d9cd58137fc499f263267c3219ac6186b98e", "target": 0, "func": "static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 4025, "substitutes": {"pix": ["bx", "Pixel", "bIX", " pico", "Px", " pixels", "px", " px", "bixels", "bpico", "PIX", "pico", "bpixel", " pixel", "bixel", "pixel", "bix", "Pico", "fixels", "Pix", "Pixels", "bpix", "fix", "pixels", "fx", "bpixels", "fixel", "pIX", " pIX"], "stride": ["brice", "strided", "spriding", "drice", "bride", "strides", "brid", "sprides", "stringided", "stringiding", "sprip", "brides", "brided", "collade", "collice", "spride", "strider", "collip", " strider", "strid", "stringice", "strice", "briding", "brider", "sprided", "drade", "sprade", " strid", "dride", "stringide", "sprid", "drip", "collide", "sprice", "strade", " strides", "sprider", "striding", "strip"], "bS": ["BSP", "pPs", "pIs", " bV", "cP", " bPs", "bootPS", "basPs", "bP", "bOS", "bPs", "rbSi", "BS", "bPS", "pS", " bSet", "cSeries", "fSS", "bSU", " bSS", "rbS", "bC", "bSeries", " bC", " bSeries", " bSU", "aaP", "cOS", "bootS", " bSP", "rbP", "aaS", "rbSS", "fS", "bSi", "fSi", "bV", "cC", "pPS", "bSet", "basS", "cS", "pOS", " bOS", "bootSi", "basSet", "pSeries", "bSS", "BSU", "pSi", "BP", "bIs", " bPS", "aaSP", "pSet", "basV", "bootIs", "aaSU", " bP", "pV", "pC", " bIs", " bSi", "bSP", "pP", "fP"], "qp": ["Qp", "qup", " qpre", "qtpn", "qtp", "qtP", "qc", "eqpc", "Qpc", "qupa", "qpre", "eqp", "qtbp", "Qpa", "qpc", "QP", "sqp", "sqpn", " qpn", "Qpre", " qbp", "Qbp", "sqbp", "sqc", "qpa", "qupc", "sqP", "quc", "qP", "sqpre", " qc", "eqpa", "Qpn", "eqc", "Qc", " qP"], "h": ["H", "ctx", "http", "q", "bh", "ih", "hw", "conn", "hash", "context", "dh", "host", "ht", "r", "zh", "help", "sh", "ph", "html", "uh", "ha", "y", "j", "g", "api", "m", "hr", "ah", "ch", "han", "home", "hm", "c", "p", "hi", "him", "w", "e", "self", "f", "hd", "eh", "hh", "hp", "history", "hy", "v", "hl", "s", "t", "he", "hs", "oh", "rh", "gh"], "tc": ["fc", "tf", "cs", "ctx", "abi", "ul", "term", "cc", "mc", "ui", "binary", "loc", " tcp", "nc", "margin", "bc", "ta", "pb", "cus", "tmp", "cas", "toc", "ac", "tx", "index", "config", "gam", "ec", "dc", "cu", "c", "xc", "beta", "css", "lc", "sc", "ctrl", "ca", "gb", "tt", " bc", "TC", " TC", "pc", "tm", "bb", "icc", "padding", "t", "uca", "ic", "ci", "uc", "acc", " rc", "rc"]}}
{"project": "FFmpeg", "commit_id": "8c5cd1c9d33b4b287f85d42efb1aecfaee31de6c", "target": 1, "func": "static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,\n\n                                      int w, int h)\n\n{\n\n    ImageContext *img;\n\n    HuffReader *hg;\n\n    int i, j, ret, x, y, width;\n\n\n\n    img       = &s->image[role];\n\n    img->role = role;\n\n\n\n    if (!img->frame) {\n\n        img->frame = av_frame_alloc();\n\n        if (!img->frame)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    img->frame->format = AV_PIX_FMT_ARGB;\n\n    img->frame->width  = w;\n\n    img->frame->height = h;\n\n\n\n    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {\n\n        ThreadFrame pt = { .f = img->frame };\n\n        ret = ff_thread_get_buffer(s->avctx, &pt, 0);\n\n    } else\n\n        ret = av_frame_get_buffer(img->frame, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (get_bits1(&s->gb)) {\n\n        img->color_cache_bits = get_bits(&s->gb, 4);\n\n        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid color cache bits: %d\\n\",\n\n                   img->color_cache_bits);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,\n\n                                            sizeof(*img->color_cache));\n\n        if (!img->color_cache)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        img->color_cache_bits = 0;\n\n    }\n\n\n\n    img->nb_huffman_groups = 1;\n\n    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {\n\n        ret = decode_entropy_image(s);\n\n        if (ret < 0)\n\n            return ret;\n\n        img->nb_huffman_groups = s->nb_huffman_groups;\n\n    }\n\n    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *\n\n                                           HUFFMAN_CODES_PER_META_CODE,\n\n                                           sizeof(*img->huffman_groups));\n\n    if (!img->huffman_groups)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < img->nb_huffman_groups; i++) {\n\n        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];\n\n        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {\n\n            int alphabet_size = alphabet_sizes[j];\n\n            if (!j && img->color_cache_bits > 0)\n\n                alphabet_size += 1 << img->color_cache_bits;\n\n\n\n            if (get_bits1(&s->gb)) {\n\n                read_huffman_code_simple(s, &hg[j]);\n\n            } else {\n\n                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    width = img->frame->width;\n\n    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)\n\n        width = s->reduced_width;\n\n\n\n    x = 0; y = 0;\n\n    while (y < img->frame->height) {\n\n        int v;\n\n\n\n        hg = get_huffman_group(s, img, x, y);\n\n        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);\n\n        if (v < NUM_LITERAL_CODES) {\n\n            /* literal pixel values */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            p[2] = v;\n\n            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);\n\n            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);\n\n            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);\n\n            if (img->color_cache_bits)\n\n                color_cache_put(img, AV_RB32(p));\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {\n\n            /* LZ77 backwards mapping */\n\n            int prefix_code, length, distance, ref_x, ref_y;\n\n\n\n            /* parse length and distance */\n\n            prefix_code = v - NUM_LITERAL_CODES;\n\n            if (prefix_code < 4) {\n\n                length = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = (prefix_code - 2) >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                length = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);\n\n            if (prefix_code > 39) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"distance prefix code too large: %d\\n\", prefix_code);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (prefix_code < 4) {\n\n                distance = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = prefix_code - 2 >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                distance = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n\n\n            /* find reference location */\n\n            if (distance <= NUM_SHORT_DISTANCES) {\n\n                int xi = lz77_distance_offsets[distance - 1][0];\n\n                int yi = lz77_distance_offsets[distance - 1][1];\n\n                distance = FFMAX(1, xi + yi * width);\n\n            } else {\n\n                distance -= NUM_SHORT_DISTANCES;\n\n            }\n\n            ref_x = x;\n\n            ref_y = y;\n\n            if (distance <= x) {\n\n                ref_x -= distance;\n\n                distance = 0;\n\n            } else {\n\n                ref_x = 0;\n\n                distance -= x;\n\n            }\n\n            while (distance >= width) {\n\n                ref_y--;\n\n                distance -= width;\n\n            }\n\n            if (distance > 0) {\n\n                ref_x = width - distance;\n\n                ref_y--;\n\n            }\n\n            ref_x = FFMAX(0, ref_x);\n\n            ref_y = FFMAX(0, ref_y);\n\n\n\n            /* copy pixels\n\n             * source and dest regions can overlap and wrap lines, so just\n\n             * copy per-pixel */\n\n            for (i = 0; i < length; i++) {\n\n                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);\n\n                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);\n\n\n\n                AV_COPY32(p, p_ref);\n\n                if (img->color_cache_bits)\n\n                    color_cache_put(img, AV_RB32(p));\n\n                x++;\n\n                ref_x++;\n\n                if (x == width) {\n\n                    x = 0;\n\n                    y++;\n\n                }\n\n                if (ref_x == width) {\n\n                    ref_x = 0;\n\n                    ref_y++;\n\n                }\n\n                if (y == img->frame->height || ref_y == img->frame->height)\n\n                    break;\n\n            }\n\n        } else {\n\n            /* read from color cache */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);\n\n\n\n            if (!img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (cache_idx >= 1 << img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"color cache index out-of-bounds\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            AV_WB32(p, img->color_cache[cache_idx]);\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4029, "substitutes": {"s": ["sg", "js", "this", "qs", "sp", "sl", "g", "ses", "ls", "args", "self", "f", "sys", "sc", "se", "fs", "sup", "spec", "ts", "sb", "aws", "sh", "xs", "request", "sets", "e", "conf", "sports", "su", "site", "S", "t", "ks", "session", "os", "its", "input", "sym", "ssl", "cs", "ctx", "ss", "rs", "a", "r", "is", "ins", "ions", "m", "ds", "ps", "gs", "ns", "c", "es", "sec", "sim", "si", "service", "src", "http", "ops", "d", "comments", "details", "l", "services", "sq", "stats", "b"], "role": ["rg", "route", "rot", "rage", "name", "service", "tool", "key", "alias", "dim", "acl", "image", "url", "r", "rr", "align", "tag", "policy", "type", "slot", " Role", "Role", "profile", "id", "scope", "frame", "member", "proxy", "label", "rb", "file", "style", "slice", "RO", "function", "state", "balance", "resource", "rl", "ro", "theme", "attr", "force", "gb", "definition", "value", "username", "range", "node", "rel", "ring", "region", "scale", "ole", "module", "rule", "uri", "val", "mode", "repl", "ride", "rol", "le", "family"], "w": ["we", "ow", "q", "a", "hw", "fw", "wt", "d", "n", " W", "W", "max", "g", "m", "wh", "z", "l", "sw", "c", "f", "wb", "height", "u", "win", "wd", "b", "t", "wa", "ew", "wx"], "h": ["H", "q", "bh", "ih", "ht", "r", "n", "sh", "ph", "th", "k", "ha", "max", "g", "m", "ah", "z", "ch", "hm", "hi", "c", "l", "e", "hd", "f", "height", "u", "o", "b", "t", "oh", "rh", "gh"], "img": ["dr", "embed", "com", "im", "enc", "g", "hr", "big", "aut", "iframe", "fig", "images", "f", "ahi", "u", "mp", "aug", "fm", "af", "emb", "gif", "tf", "ext", "image", "ht", "ib", "icon", "html", "eng", "dom", "api", "bl", "ie", "jpg", "fg", "aff", "org", "amp", "lib", "ev", "input", "cm", "np", "att", "imp", "fw", "og", "lim", "m", "info", "cb", "util", "str", "tif", "om", "feat", "c", "app", "br", "obj", "agi", "inst", "cf", "inf", "ig", "imag", "src", "def", "ih", "utm", "d", "pg", "orig", "ng", "num", "iq", "output", "rb", "style", "md", "ch", "config", "impl", "feature", "gb", "exec", "bg", "fb", "inc", "gd", "rc"], "hg": ["pbg", "pg", "hG", "pgs", " hgs", " hG", "rhG", "rhgs", "hbg", "rhbg", "hgs", " hbg", "rhg", "pG"], "i": ["ii", "image", "r", "d", "I", "n", "is", "k", "m", "z", "index", "l", "ip", "e", "f", "b", "ix", "ci", "io", "in"], "j": ["js", "adj", "q", "ji", "r", "d", "n", "J", "sp", "k", "aj", "op", "g", "pos", "m", "z", "l", "len", "jp", "obj", "o", "b", "t", "ja"], "ret": ["arg", "active", "success", "url", "alt", "job", "code", "Ret", "opt", "en", "RET", "rt", "fun", "ext", "format", "id", "rets", "end", "pass", "fail", "reply", "post", "lit", "re", "val", "count", "pt", "det", "att", "mt", "data", "out", "cat", "wrap", "info", "back", "str", "feat", "last", "result", "usr", "et", "ut", "len", "ref", "obj", "reg", "res", "mem", "no", "def", "bit", "num", "rf", "rb", "nt", "ft", "rev", "status", "bf", "flag", "gt", "resp", "art", "al", "let", "part", "desc", "rc"], "x": ["image", "n", "px", "xy", "dx", "m", "pixel", "X", "z", "l", "c", "f", "col", "fx", "win", "ix", "rx", "wa", "ex"], "y": ["ii", "d", "n", "type", "k", "g", "py", "dy", "m", "z", "l", "c", "lon", "e", "vy", "f", "col", "height", "size", "o", "b", "t", "Y"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void ff_mspel_motion(MpegEncContext *s,\n\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                               int motion_x, int motion_y, int h)\n\n{\n\n    Wmv2Context * const w= (Wmv2Context*)s;\n\n    uint8_t *ptr;\n\n    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;\n\n    int emu=0;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    dxy = 2*dxy + w->hshift;\n\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n\n    src_y = s->mb_y * 16 + (motion_y >> 1);\n\n\n\n    /* WARNING: do no forget half pels */\n\n    v_edge_pos = s->v_edge_pos;\n\n    src_x = av_clip(src_x, -16, s->width);\n\n    src_y = av_clip(src_y, -16, s->height);\n\n\n\n    if(src_x<=-16 || src_x >= s->width)\n\n        dxy &= ~3;\n\n    if(src_y<=-16 || src_y >= s->height)\n\n        dxy &= ~4;\n\n\n\n    linesize   = s->linesize;\n\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n\n\n        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos\n\n                              || src_y + h+1 >= v_edge_pos){\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,\n\n                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);\n\n            ptr= s->edge_emu_buffer + 1 + s->linesize;\n\n            emu=1;\n\n        }\n\n\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);\n\n\n\n    if(s->flags&CODEC_FLAG_GRAY) return;\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        dxy = 0;\n\n        if ((motion_x & 3) != 0)\n\n            dxy |= 1;\n\n        if ((motion_y & 3) != 0)\n\n            dxy |= 2;\n\n        mx = motion_x >> 2;\n\n        my = motion_y >> 2;\n\n    } else {\n\n        mx = motion_x / 2;\n\n        my = motion_y / 2;\n\n        dxy = ((my & 1) << 1) | (mx & 1);\n\n        mx >>= 1;\n\n        my >>= 1;\n\n    }\n\n\n\n    src_x = s->mb_x * 8 + mx;\n\n    src_y = s->mb_y * 8 + my;\n\n    src_x = av_clip(src_x, -8, s->width >> 1);\n\n    if (src_x == (s->width >> 1))\n\n        dxy &= ~1;\n\n    src_y = av_clip(src_y, -8, s->height >> 1);\n\n    if (src_y == (s->height >> 1))\n\n        dxy &= ~2;\n\n    offset = (src_y * uvlinesize) + src_x;\n\n    ptr = ref_picture[1] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);\n\n\n\n    ptr = ref_picture[2] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);\n\n}\n", "idx": 4041, "substitutes": {"s": ["sg", "js", "qs", "current", "n", "sites", "sl", "client", "g", "ses", "ls", "sf", "us", "self", "f", "set", "private", "sys", "sc", "your", "an", "se", "fs", "spec", "ts", "ges", "sb", "aws", "ims", "y", "uns", "xs", "sv", "sets", "p", "e", "lines", "conf", "as", "uses", "v", "less", "su", "site", "S", "t", "session", "ks", "os", "its", "hs", "sym", "plugins", "ssl", "cs", "ss", "rs", "new", "r", "is", "ins", "ions", "i", "m", "settings", "ds", "als", "ps", "gs", "ns", "c", "es", "south", "sec", "o", "si", "service", "http", "d", "ans", "comments", "sync", "tests", "l", "services", "sq", "b"], "dest_y": ["dest_py", "dest_sy", "dest_x", "src_sy", "src_py"], "dest_cb": ["source_cm", "source_cb", "destOz", "source_z", "dest_mag", "dest_cm", "destOcb", "destOcm", "dest_z", "source_mag", "destOmag"], "dest_cr": [" dest_rx", "dest__cb", "dest__cr", " dest_z", "dest_rx", "dest_z", "dest__z", "dest__rx"], "ref_picture": ["ref_resolution", "refdbpicture", "refloguri", " ref_uri", "ref2resolution", "reference_picture", "refvalpicture", "reflogpicture", "reflogaudio", "reference2picture", "refvalaudio", "ref2picture", "refdbpic", "refvaluri", "reference_resolution", "refdbresolution", "ref_uri", "reflogimage", "reference2resolution", "refvalimage", " ref_image", "ref_pic", "ref2pic", "reference2pic", "ref_audio", " ref_audio", "ref_image", "reference_pic"], "pix_op": ["pix_oper", "pixel_oper", "pix64op", "pixel_op", "pix64ops", "pix64map", "pix64oper", "pix_map", "pixel_map", "pixel_ops", "pix_ops"], "motion_x": ["motionIdon", "motion_dx", "motionIdy", "move_y", "motion_xs", "motion01dx", "move_height", "motion2y", "motion01x", "move_on", "move_x", "motion2dx", "motion01xs", "motion_height", " motion2dx", "move_z", "motionIdx", "motionIdheight", "motion_on", "motion01y", "motion00xs", " motion2y", " motion2x", "motion2xs", " motion_xs", "motion_z", "motion00dx", "move_w", " motion_dx", "motion2x", "motion_w", "motion00x", "motion00y", " motion2xs"], "motion_y": ["camera64ry", "motion__type", "motion_vy", "motion64ry", "motion01ey", "loss_y", "loss_x", "motion2y", "motion_type", "motion00type", "motion64y", "camera_ry", "motion_yt", "motion__yt", "motion01ry", " motion_yt", "loss_yd", "motion_ey", "camera_ey", "loss_yt", "motion2yt", "motion_ry", "motion__x", "motion_yd", "motion01y", "camera_y", "camera_vy", " motion2y", " motion2type", " motion2x", " motion2yt", "motion00yt", "motion01vy", "motion__y", "camera64vy", "camera64ey", "motion2x", "camera64y", "motion00x", "motion2type", "motion64ey", " motion_type", "motion00y", "motion64vy"], "h": ["H", "q", "bh", "ih", "hw", "a", "ht", "r", "n", "sh", "ph", "ha", "uh", "y", "i", "m", "z", "ch", "hm", "l", "c", "hi", "p", "hh", "e", "x", "f", "hop", "hp", "u", "v", "b", "hs", "oh", "rh", "gh"], "w": ["we", "ow", "q", "hw", "rw", "fw", "r", "window", "d", "n", "wt", " W", "wl", "W", "y", "g", "m", "wh", "z", "kw", "ess", "x", "l", "c", "p", "sw", "work", "f", "wb", "wcs", "u", "ww", "v", "nw", "b", "wa", "iw", "wp", "wx"], "ptr": ["dr", "hei", "src", "buffer", "trace", "ext", "inter", "fd", "peer", "tty", "prot", "loc", "rob", "r", "prop", "rog", "sh", "sp", "grad", "buf", "tmp", "pair", "j", "i", "pos", "code", "dest", "fp", "push", "slice", "tr", "pointer", "fe", "address", "pad", "fi", "Ptr", "p", "shift", "len", "length", "attr", "ctr", "alloc", "pull", "cmp", "inst", "req", "addr", "td", "pt", "pri", "ace", "rc", "port"], "dxy": ["dquad", "hpx", "mphi", "Dzip", "dwy", "sdwy", "sdphy", "bxy", "dtpy", "hquad", "ddy", " dpx", "dzip", "hwy", "Dphi", "dphy", "dpx", "bwy", "bpx", " dphy", "dhoxy", "idpx", "dhxy", "dummy", "dgb", "Dpy", "hxy", "nzip", "Dquad", " dwy", "mwy", "iddy", " doxy", "dhphy", "vxy", "mxy", "dhwy", "dphi", "Dwy", "dtxy", " dpy", " dummy", "Dcoord", "Dxy", " dgb", "sdxy", "npy", "dtpx", "nquad", " dquad", " dzip", "vummy", "mcoord", " dphi", "idxy", "Dummy", " dcoord", "dcoord", "doxy", "dpy", "Dgb", "idpy", "vwy", "vgb", "sdoxy", " ddy", "nxy", "bquad", "dtdy"], "offset": ["np", "mt", "adjust", "oe", "area", "image", "loc", "align", "position", "mm", "off", "i", "pos", "aw", "foo", "ip", "p", "shift", "hop", "origin", "meta", "padding", "o", "location", "addr"], "mx": ["mn", "cm", "np", "cycle", "host", "loc", "axis", "ap", "px", "ms", "mi", "mm", "lr", "m", "nr", "tx", "mag", "md", "xp", "hh", "hop", "sq", "mp", "pm", "mr", "cp", "rx", "wave", "wx"], "my": ["mn", "np", "mos", "micro", "ni", "mic", "nn", "cl", "gy", "loc", "mi", "ms", "mm", "mo", "ng", "py", "mid", "md", "yy", "mph", "sq", "pm", "My", "mr", "nm", "me", "ym", "wx"], "src_x": [" src_xy", "src67x", "src2y", " src_xs", "src_ex", " src_ex", " src_wx", "src67y", "src_xs", "src_width", "src6xs", "src2w", " src_width", "src_yx", " src_full", "src67yx", "src2X", "source_X", "src6yx", " src_z", "src_full", "src00y", "src00x", " src_yx", "src_image", "srcacx", " src_image", "srcacheight", "src_w", "src_ya", "src_X", " src_X", "src2x", "src67xs", "source_x", "src6y", "src_xy", "source_y", "src_wx", "src00full", " src_ya", "source_w", "src_z", " src_height", "src00z", "src_height", "srcacwidth", "srcacex", "src6x", " src_w"], "src_y": ["src2y", "src_yo", "obl_y", "rc_y", "rc_x", "src___ya", "src__zy", "src_dy", "rc_vy", " src_dy", "src_ny", "src__ya", "srcJya", "srcJx", "obl_yi", "srcJry", "dest_x", "src___iy", "obl_ry", "srcJyi", "src2ey", "srcPy", "src___y", "srcJey", "src_ey", "rc_yo", " src_ny", "src__yi", "obl_ey", " src_z", "src_yi", "src2ya", "src_ys", "rc2ey", "rc2y", "srcPx", " src_ey", "src__ey", "dest_ys", "src_vy", "src___height", " src_iy", "src_zy", "src_ya", "rc2ya", "src2x", "src___z", "rc_ya", "srcJyo", "rc2x", " src_ya", "src__y", "srcPdy", "src_z", "src_iy", "src__ry", "srcPz", " src_height", "src_height", "src___yi", "srcJy", "src___x", "rc_ey", " src_yi", " src_zy", "src_ry", "dest_z", "src__ny"], "v_edge_pos": ["v_edge_port", "v_ge_position", "v_edge__position", "v_issue_pos", "v_ge__position", "v_edge_abs", "v_edgeingposition", "v_edge_res", "v_issue_position", "v_edge_type", "v_nw___Pos", "v_ge__off", "v_edge__res", "v_ge__pos", "v_nw_pos", "v_ge_off", "v_edgexport", "v_nw_Pos", "v_pe_position", "v_edge___len", "v_edgelypos", "v_edge___pose", "v_edge_len", "v_ge_port", "v_edgeingpos", "v_edge\u00b7type", "v_edge_cos", "v_edge_pose", "v_edge\u00b7po", "v_line_type", "v_edgexpos", "v_edge_Pos", "v_edge__pose", "v_edgeingcos", "v_nw_len", "v_pe_cos", "v_edge_po", "v_ge__port", "v_nw_pose", "v_edge__off", "v_line_po", "v_edge___pos", "v_edge__len", "v_edge__pos", "v_issue_res", "v_ge_pos", "v_line_position", "v_edgexposition", "v_pe_abs", "v_nw___len", "v_edge___Pos", "v_edge\u00b7position", "v_line_pos", "v_edgexoff", "v_pe_pos", "v_edgelycos", "v_edge\u00b7pos", "v_edge_position", "v_nw___pose", "v_edge_off", "v_nw___pos", "v_edge__Pos", "v_edgelyabs", "v_edgelyposition", "v_edge__port", "v_issue_Pos", "v_edgeingabs"], "linesize": ["pointsize", "linsize", " linesiz", "opensiz", "linksiz", "linsizer", "linesization", "breaksization", "opensized", "filesize", "planesizing", "ipsize", "opensization", "postsization", "linsIZE", "ipssize", " linesization", "pointsized", "breaksiz", "ipsizing", " linesIZE", "linesized", "linesizer", " linesizer", "opensize", "pagesization", "cssize", "linsizing", "worksize", "linksizer", "pointsizing", " linesized", "filesiz", "linksizing", "pagesiz", "postsized", "csiz", "filesIZE", " linesizing", "breaksizer", "linesiz", "worksizer", "csize", "pointsiz", "planesize", "linksize", "filesizer", "ipsiz", "linesizing", "planesiz", "pagesizer", "worksiz", "pagesize", "linessize", "planesized", "linsized", " linessize", "linesIZE", "postsize", "postsiz", "linsiz", "csization", "worksizing", "linsization", "breaksize", "linssize"], "uvlinesize": ["uvstringsize", "upplinesiz", "uvonessize", "uvonesize", "uvlineiz", "upplinesizable", "uvlinsize", "cvlinesize", "uvvalsize", "uvonesiz", "upplinsiz", "uvvalsizes", "uvvalsizable", "cvlinesiz", "upplinsizes", "novpagesizer", "novpagesizes", "novpagessize", "novpagesize", "uvlinsizer", "uvlinsizes", "upplinesize", "novlinesizes", "uvlinesizes", "uvvalsiz", "upplinesizes", "uvlineizer", "uvonesizer", "uvpagesizer", "uvstringsizable", "uvlineizes", "novlinesizer", "cvlinesizer", "uvlinsizable", "upplinsize", "uvpagesize", "uvpagessize", "cvlinessize", "uvpagesizes", "novlinessize", "uvlinessize", "uvlinssize", "uvlinesizable", "novlinesize", "uvstringsizes", "uvlinesizer", "uvstringsiz", "uvlinesiz", "uvlineize", "upplinsizable", "uvlinsiz"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane,\n\n                             unsigned char *src_plane,\n\n                             unsigned char *ref_plane,\n\n                             unsigned char *decoded_plane,\n\n                             int width, int height, int src_stride, int stride)\n\n{\n\n    const AVFrame *f = s->avctx->coded_frame;\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    uint8_t *src     = s->scratchbuf + stride * 16;\n\n    const int lambda = (f->quality * f->quality) >>\n\n                       (2 * FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width  = (width  + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n        s->m.avctx                         = s->avctx;\n\n        s->m.current_picture_ptr           = &s->m.current_picture;\n\n        s->m.last_picture_ptr              = &s->m.last_picture;\n\n        s->m.last_picture.f.data[0]        = ref_plane;\n\n        s->m.linesize                      =\n\n        s->m.last_picture.f.linesize[0]    =\n\n        s->m.new_picture.f.linesize[0]     =\n\n        s->m.current_picture.f.linesize[0] = stride;\n\n        s->m.width                         = width;\n\n        s->m.height                        = height;\n\n        s->m.mb_width                      = block_width;\n\n        s->m.mb_height                     = block_height;\n\n        s->m.mb_stride                     = s->m.mb_width + 1;\n\n        s->m.b8_stride                     = 2 * s->m.mb_width + 1;\n\n        s->m.f_code                        = 1;\n\n        s->m.pict_type                     = f->pict_type;\n\n        s->m.me_method                     = s->avctx->me_method;\n\n        s->m.me.scene_change_score         = 0;\n\n        s->m.flags                         = s->avctx->flags;\n\n        // s->m.out_format                    = FMT_H263;\n\n        // s->m.unrestricted_mv               = 1;\n\n        s->m.lambda                        = f->quality;\n\n        s->m.qscale                        = s->m.lambda * 139 +\n\n                                             FF_LAMBDA_SCALE * 64 >>\n\n                                             FF_LAMBDA_SHIFT + 7;\n\n        s->m.lambda2                       = s->m.lambda * s->m.lambda +\n\n                                             FF_LAMBDA_SCALE / 2 >>\n\n                                             FF_LAMBDA_SHIFT;\n\n\n\n        if (!s->motion_val8[plane]) {\n\n            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *\n\n                                                 block_height * 2 + 2) *\n\n                                                2 * sizeof(int16_t));\n\n            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *\n\n                                                 (block_height + 2) + 1) *\n\n                                                2 * sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type = s->mb_type;\n\n\n\n        // dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mb_type = s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table                      = s->motion_val16[plane] +\n\n                                               s->m.mb_stride + 1;\n\n        s->m.dsp                             = s->dsp; // move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size      = s->avctx->dia_size;\n\n        s->m.first_slice_line = 1;\n\n        for (y = 0; y < block_height; y++) {\n\n            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n\n            s->m.mb_y                  = y;\n\n\n\n            for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                       width);\n\n                for (x = width; x < 16 * block_width; x++)\n\n                    src[i * stride + x] = src[i * stride + x - 1];\n\n            }\n\n            for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n                memcpy(&src[i * stride], &src[(i - 1) * stride],\n\n                       16 * block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x = x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line = 0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,\n\n                        CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line = 1;\n\n    for (y = 0; y < block_height; y++) {\n\n        for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                   width);\n\n            for (x = width; x < 16 * block_width; x++)\n\n                src[i * stride + x] = src[i * stride + x - 1];\n\n        }\n\n        for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n\n\n\n        s->m.mb_y = y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7 * 32];\n\n            int count[3][6];\n\n            int offset       = y * 16 * stride + x * 16;\n\n            uint8_t *decoded = decoded_plane + offset;\n\n            uint8_t *ref     = ref_plane + offset;\n\n            int score[4]     = { 0, 0, 0, 0 }, best;\n\n            uint8_t *temp    = s->scratchbuf;\n\n\n\n            if (s->pb.buf_end - s->pb.buf -\n\n                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x = x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_I ||\n\n                (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                 CANDIDATE_MB_TYPE_INTRA)) {\n\n                for (i = 0; i < 6; i++)\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],\n\n                                  7 * 32);\n\n                if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0] = vlc[1] * lambda;\n\n                }\n\n                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n\n                                         5, 64, lambda, 1);\n\n                for (i = 0; i < 6; i++) {\n\n                    count[0][i] = put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            } else\n\n                score[0] = INT_MAX;\n\n\n\n            best = 0;\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                    CANDIDATE_MB_TYPE_INTER) {\n\n                    for (i = 0; i < 6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],\n\n                                      7 * 32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb = s->reorder_pb[5];\n\n                    mx      = motion_ptr[0];\n\n                    my      = motion_ptr[1];\n\n                    assert(mx     >= -32 && mx     <= 31);\n\n                    assert(my     >= -32 && my     <= 31);\n\n                    assert(pred_x >= -32 && pred_x <= 31);\n\n                    assert(pred_y >= -32 && pred_y <= 31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5] = s->m.pb;\n\n                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy = (mx & 1) + 2 * (my & 1);\n\n\n\n                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,\n\n                                                   ref + (mx >> 1) +\n\n                                                   stride * (my >> 1),\n\n                                                   stride, 16);\n\n\n\n                    score[1] += encode_block(s, src + 16 * x, temp + 16,\n\n                                             decoded, stride, 5, 64, lambda, 0);\n\n                    best      = score[1] <= score[0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4062, "substitutes": {"s": ["sg", "js", "this", "qs", "sa", "n", "sl", "client", "g", "ses", "ls", "sf", "us", "secondary", "sys", "sc", "u", "sum", "fs", "parts", "sup", "spec", "ts", "context", "sb", "sv", "sets", "p", "e", "lines", "conf", "as", "v", "su", "site", "S", "t", "session", "os", "ks", "its", "in", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "m", "ds", "ps", "gs", "native", "ns", "h", "c", "es", "south", "o", "sim", "res", "si", "service", "ops", "strings", "d", "ans", "ms", "sync", "status", "l", "services", "w", "sq", "b", "states"], "plane": ["flow", "layer", "clip", "flat", "pe", "dim", "image", "axis", "weight", "fl", "code", "slice", "source", "lane", "planes", "ide", "core", "plan", "card", "scale", "plate", "qa", "ane", "path", "line", "mode", "limit", "port"], "src_plane": ["ref_layer", "srcwlayer", "srcwlane", "srcwplane", "srcwplanes", "src_layer", "ref_lane", "ref_planes", "src_lane", "src_planes"], "ref_plane": [" ref_sea", " ref_channel", "refacplane", "referenceacplane", "referenceacsea", "refinglane", "refingsea", "referenceaclane", "refingchannel", "reference_lane", "referenceacline", "refacsea", "reference_plane", "reference_line", "refacline", "ref_pose", "ref_channel", "ref_lane", "refaclane", " ref_pose", "ref_line", "reference_sea", "refalsea", "refalpose", "refalplane", "refalchannel", "refingpose", "refingline", "ref_sea", "refingplane"], "decoded_plane": ["decodedensource", "decodedegerscreen", "decode_plane", "decoded_source", "decodedenplane", "decode_source", "decodedegersource", "decoded_lane", "decoded_screen", "decodedegerlane", "decode_screen", "decodedenscreen", "decode_lane", "decodedenlane", "decodedegerplane"], "height": ["media", "resolution", "missing", "crop", "capacity", "build", "above", "def", "dim", "tight", "memory", "ht", "gain", "high", "window", "distance", "stroke", "ty", "bottom", "gravity", "huge", "hold", "direction", "style", "holes", " heights", "h", "thin", "hi", "layout", "deep", "rank", "east", "length", "size", "inches", "history", "rows", "density", "definition", "padding", "pull", "depth", "ashes", "location", "times", "hang", "volume", "shape", "rh", "gh", "Height"], "src_stride": ["src_bride", "src_frided", "src_strided", "src_drider", "src_frider", "src_brider", "src_drision", "src_strider", "src_strision", "src_dride", "src_drided", "src_brision", "src_frision", "src_brided", "src_fride"], "stride": ["strided", "shride", "tride", "trider", " strride", "strride", "drider", "strandi", "Strided", "strider", "drride", "drision", "trandi", "strision", "dride", "Stride", "Strision", "Strride", "shrision", "trided", "trision", "shrider", "drandi", " strided", " strision", "shrided", "drided", " strandi"], "f": ["flow", "fc", "fo", "tf", "q", "def", "fen", "fac", "form", "data", "fa", "image", "d", "n", "fl", "lf", "field", "page", "frame", "rf", "F", "j", "g", "api", "m", "file", "info", "fp", "df", "sf", "fr", "config", "fe", "bf", "feature", "feed", "h", "l", "c", "p", "fi", "w", "e", "aff", "self", "conf", "u", "fx", "of", "o", "v", "fb", "b", "t", "cf", "af", "full", "part", "fs", "inf"], "x": ["base", "image", "d", "n", "px", "xy", "pos", "dx", "m", "pixel", "X", "z", "index", "h", "c", "p", "l", "w", "e", "ax", "o", "ix", "view", "ex"], "y": ["row", "d", "n", "type", "cy", "j", "pos", "m", "dy", "z", "index", "h", "c", "p", "w", "e", "vy", "col", "size", "o", "Y", "ym"], "i": ["unit", "channel", "ii", "pi", "d", "I", "n", "di", "type", "id", "j", "pos", "m", "index", "z", "h", "l", "c", "p", "qi", "uri", "line", "ci", "io", "limit", "in"], "block_width": ["ref48width", "block67lon", " block_maximum", "ref_lon", "block_income", " block_income", "block\u00b7width", "block_length", "block67wen", "ref48wen", "ref48lon", "ref_width", "block_wen", "layout_size", "block_size", "layout48size", "layout_length", "block48wen", "layout48sw", "block48size", "layout48width", "layout48length", "block\u00b7maximum", "block_sw", "ref_wen", "block48sw", "block_maximum", "block67width", "block48length", "block\u00b7income", "block48lon", " block_size", "layout_width", "block48width", "block\u00b7size", "layout_sw", "block_lon"], "block_height": ["block_right", "block00height", "layout_thin", "block_resolution", " block_right", "block67height", "blockinglayout", "blockingresolution", "plugin67health", "block48right", "layout_right", "block_layout", "plugin_layout", "blockinghealth", "block_thin", "block67resolution", "plugin_health", "block67health", "block00right", "plugin_resolution", "block48height", "block67layout", "block_health", "plugin67layout", "plugin67resolution", "layout_height", "blockingheight", "plugin_height", "block00width", "layout_width", "block48width", "block00thin", "plugin67height"], "level": ["unit", "layer", "stage", "syn", "lock", "letter", "server", "q", "local", "channel", "key", "cl", "d", "n", "weight", "type", "lvl", "id", "parent", "wl", "list", "loop", "pass", "model", "code", "file", "coll", "style", "source", "index", "VEL", "vel", "step", "l", "lc", "length", "condition", "child", "col", "where", "all", "value", "other", "Level", "quality", "round", "scale", "way", "thread", "levels", "clean", "depth", "full", "line", "val", "mode", "lo", "limit", "inc", "pri", "day"], "threshold": ["THrift", "ethreshold", " thresh", "shcondition", "THreshold", "shresh", "ethrail", "THensor", "Thresh", " thrail", "rethrift", "rethresh", "thresh", " thensor", "thareshold", "thrift", "sthreshold", "Threshold", "sthumbnail", "ethensor", "shumbnail", "thrust", "Thrust", "sthresh", "thcondition", "ithreshold", "Thumbnail", "tharail", "shreshold", "thumbnail", "rethrail", "THresh", "ithcondition", "thensor", "tharesh", "ithresh", "sthrust", "rethrust", "ithumbnail", "rethreshold", "thrail", "THrail", "tharift", "Thcondition", "rethumbnail", "ethresh"], "src": ["sub", "ctx", "filename", "url", "image", "loc", "sl", "fn", "tmp", "rb", "secure", "dest", "cb", "slice", "source", "feat", "config", "ctr", "sc", "gb", "stream", "seq", "conv", "img", "input", "rc", "ssl"]}}
{"project": "FFmpeg", "commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "target": 1, "func": "static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             int is_extradata)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    AVBufferRef *buf = NULL;\n\n    int size = 0;\n\n    uint8_t *data = (uint8_t *)\"\";\n\n    uint8_t *start;\n\n    int ret = 0;\n\n\n\n    if (avpkt->size) {\n\n        if (avpkt->buf) {\n\n            buf = av_buffer_ref(avpkt->buf);\n\n            size = avpkt->size;\n\n            data = avpkt->data;\n\n        } else {\n\n            buf = av_buffer_alloc(avpkt->size);\n\n            if (buf) {\n\n                memcpy(buf->data, avpkt->data, avpkt->size);\n\n                size = buf->size;\n\n                data = buf->data;\n\n            }\n\n        }\n\n        if (!buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n        if (!is_extradata)\n\n            ctx->packets_sent++;\n\n    } else {\n\n        if (!ctx->packets_sent) {\n\n            // Short-cut the flush logic to avoid upsetting MMAL.\n\n            ctx->eos_sent = 1;\n\n            ctx->eos_received = 1;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    start = data;\n\n\n\n    do {\n\n        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));\n\n        if (!buffer) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n\n\n        buffer->data = data;\n\n        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);\n\n\n\n        if (is_extradata)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;\n\n\n\n        if (data == start)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;\n\n\n\n        data += buffer->length;\n\n        size -= buffer->length;\n\n\n\n        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;\n\n        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;\n\n\n\n        if (!size)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;\n\n\n\n        if (!buffer->length) {\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;\n\n            ctx->eos_sent = 1;\n\n        }\n\n\n\n        if (buf) {\n\n            buffer->ref = av_buffer_ref(buf);\n\n            if (!buffer->ref) {\n\n                av_free(buffer);\n\n                ret = AVERROR(ENOMEM);\n\n                goto done;\n\n            }\n\n        }\n\n\n\n        // Insert at end of the list\n\n        if (!ctx->waiting_buffers)\n\n            ctx->waiting_buffers = buffer;\n\n        if (ctx->waiting_buffers_tail)\n\n            ctx->waiting_buffers_tail->next = buffer;\n\n        ctx->waiting_buffers_tail = buffer;\n\n    } while (size);\n\n\n\ndone:\n\n    av_buffer_unref(&buf);\n\n    return ret;\n\n}\n", "idx": 4064, "substitutes": {"avctx": ["afsci", "avkb", "avsci", "afcmp", "afctx", "afcontext", "akcontext", "abcmp", "aircontext", " avcontext", "aircmp", "aksci", "afkb", "airdc", "abdc", "abctx", " avkb", "avdc", "avcontext", "abcontext", " avsci", "afdc", "akctx", "avcmp", "akkb", "airctx"], "avpkt": ["avkunct", "akpatt", "avjpeter", "aveckt", "affkt", "avpak", "avcet", "ajpak", "ajpkt", "avpromelt", "avspacket", "ajpaacket", "avpk", "avpft", "avvdt", "avppet", "avlpkt", "avtuth", "avespacket", "akPdt", "avpakt", " avapacket", "avvacket", "airspkg", "AVwkt", "avopkg", "AVwacket", "avwnt", "avparacket", "avfcht", "afpnt", "akPkt", "avfk", " avpnt", "ajfpsth", "avppstruct", "avmcht", "aveckg", "afpdt", "avfpnt", "avfqt", "avpqt", "avecet", "avpett", "avpacket", "avvpki", "avPkt", "avfpkg", "avpdt", "affett", "akppt", "avpatt", "avpaacket", "avcpacket", "affki", "ajpsth", "avPatt", "avapnt", "avcpnt", " avpett", "avepkg", "avfpacket", "avapett", "avpeter", "avmett", "avpki", "avpsacket", "avvett", "avfuth", "avcpkt", "airspkt", "avppacket", "avfki", "affacket", "avapacket", "avppeter", "avppkt", "akPpt", " avpacket", "avespkt", "avepet", "avvkt", "avPpt", "avjpacket", "avpet", "avtkt", "avfkt", "avmkt", "avlpatt", "avepkt", "avpsnt", "avecstruct", "avfpft", "avcstruct", "avppkg", "avespqt", "ajputh", "avPdt", "akPatt", "ajfpkt", "avespcht", "avcpatt", "affnt", "avfpunct", "avpromkt", "avfett", "avlppt", "avpstruct", "avppt", "afpcht", "avvpnt", "avepstruct", "avtacket", " avapnt", "afpatt", "avspcht", " avapkt", "AVpacket", "afpki", "ajpauth", "avtett", "avopstruct", "ajpelt", "avspkt", "avvpkt", "avkkg", "afpeter", "avfdt", "airspft", "avfelt", "avpkg", "airpkg", "avpski", "AVwnt", "affelt", "avparqt", "avjpelt", "avepcht", "airpft", " avapett", "avmnt", "avpnt", "avfsth", "avpsth", "afpkt", "avppelt", "airspunct", "ajfpelt", "AVpkt", "avputh", "avwft", "ajpk", "avspft", "avpromsth", "avfatt", "avopet", "affcht", "avjpkt", "avfft", "avpromacket", "affatt", "avfpkt", "avpunct", "avpcht", "avmatt", "akpkt", "avkft", "affeter", "avapkt", "afpelt", "avpskt", "ajpacket", "avepacket", "AVpnt", "avvpft", "avopkt", "avfacket", "avvpacket", "avfeter", "avparkt", "avspqt", "ajfpacket", "avspkg", "avspunct", "avckg", "avfpelt", "avtdt", "afpacket", "akpdt", "afpett", "avparcht", "avtpt", "avlpdt", "avkkt", "affdt", "avtk", "avfpcht", "avpelt", "AVpft", "avtatt", "airpkt", "avwacket", "airpunct", "avfnt", "avwkt", "avckt", "avfpsth", "AVwft", "avepqt", "avmacket", "avpauth", "ajpakt"], "is_extradata": ["is_extradada", "is_exradata", "is_extradATA", "is_extradina", "is_extradat", "is_extrafada", "is_extartata", "is_xtrafATA", "is_extrafala", "is_xtradata", "is_extrastata", "is_extadrala", "is_extrafaton", "is_xtradat", "is_exrafate", "is_extmodata", "is_extartat", "is_extrafATA", "is_exradATA", "is_extandat", "is_extadata", "is_exradate", "is_extmodate", "is_extandina", "is_xtrafat", "is_extrastaton", "is_xtrafata", "is_exrafATA", "is_xtradina", "is_extrafina", "is_extadATA", "is_extandATA", "is_extadada", "is_extadrata", "is_extradate", "is_xtradATA", "is_extmodala", "is_extrastada", "is_descrafada", "is_extartATA", "is_extartina", "is_extrafat", "is_extradaton", "is_extadrATA", "is_extradala", "is_descradATA", "is_extadaton", "is_extrastATA", "is_extandata", "is_exrafata", "is_exrafala", "is_descrafaton", "is_descradada", "is_extrafata", "is_extrafate", "is_xtrafina", "is_descradata", "is_descrafata", "is_descrafATA", "is_exradala", "is_descradaton", "is_extadrate", "is_extmodATA"], "ctx": ["cms", "cli", "kb", "hw", "conn", "context", "cc", "fw", "cn", "loc", "window", "aux", "ck", "ct", "nc", "co", "bc", "tc", "client", "cas", "tx", "sync", "cb", "kw", "utils", "crit", "config", "git", "pkg", "c", "cv", "xc", "lc", "conf", "ca", "wcs", "ctrl", "exec", "sq", "sc", "cmd", "alloc", "obj", "vc", "cca", "connection", "qa", "cp", "cmp", "req", "cf", "conv", "ci", " context", "sci", "wx"], "buf": ["grab", "queue", "aux", "pb", "uncle", "runner", "home", "feed", "cv", "vec", "f", "seq", "uf", "fi", "fun", "bag", "context", "raf", "bc", "buff", "tmp", "cas", "off", "fp", "tx", "plug", "pkg", "bus", "ptr", "bd", "bu", "bh", "fw", "ab", "loc", "bin", "uber", "proc", "cb", "pool", "func", "feat", "pub", "usr", "h", "Buffer", "ref", "br", "cache", "cap", "front", "cmd", "alloc", "bb", "cf", "img", "uc", "fd", "src", "bo", "header", "cur", "ux", "rb", "box", "config", "block", "wb", "carry", "fb", "b", "fam", "rc"], "data": ["capacity", "queue", "url", "open", "empty", "sample", "next", "first", "code", "args", "partial", "index", "progress", "address", "alpha", "shift", "reset", "message", "DATA", "action", "stop", "valid", "limit", "background", "name", "read", "extra", "ui", "image", "align", "send", "type", "id", "parent", "end", "off", "batch", "p", "resource", "length", "la", "scale", "val", "root", "load", "init", "count", "response", "input", "media", "base", "missing", "version", "offset", "a", "new", "complete", "loc", "ad", "bin", "i", "inner", "body", "info", "raw", "content", "result", "pad", "size", "len", "date", "cache", "value", "error", "bytes", "mode", "Data", "timeout", "done", "delay", "no", "memory", "window", "results", "pos", "output", "number", "source", "config", "block", "zero", "padding", "full", "addr", "dat"], "start": ["to", "starting", "delay", "src", "no", "skip", "time", "read", "offset", "before", "new", "get", "send", "use", "open", "id", "cur", "from", "end", "seed", "next", "first", "pos", "mid", "info", "source", "parse", "Start", "st", "last", "step", "pad", "block", "shift", "set", "range", "stop", "count", "root", "init", "started", "in", "rc", "done"], "packets_sent": ["packet_sent", "packets___generated", "packets_send", "packets__needed", "packet_fetched", "packets__received", "packet_received", "packets_fetched", "packets___fetched", "packet_needed", "packets_generated", "packets__send", "packets_received", "packets___received", "packet_generated", "packets___sent", "packets__sent", "packets_needed", "packet_send"], "buffer": ["command", "device", "queue", "url", "file", "er", "feed", "holder", "f", "message", "comment", "manager", "uf", "port", "texture", "parser", "usher", "read", "interface", "image", "bc", "buff", "batch", "timer", "ptr", "resource", "length", "border", "bar", "wave", "player", "input", "layer", "offset", "seek", "uffer", "byte", "worker", "bin", "document", "writer", "result", "Buffer", "loader", "cache", "bb", "bridge", "FFER", "rule", "iter", "slave", "timeout", "pause", "server", "delay", "memory", "binary", "header", "window", "callback", "builder", "entry", "source", "block", "reader", "copy", "token", "b", "element", "transfer", "table"]}}
{"project": "FFmpeg", "commit_id": "969267482de97b08503d27d2fe090ec820273e40", "target": 1, "func": "static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n\n{\n\n    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;\n\n    AVCodecContext          *avctx = ost->st->codec;\n\n    int ret;\n\n\n\n    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||\n\n        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))\n\n        pkt->pts = pkt->dts = AV_NOPTS_VALUE;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {\n\n        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);\n\n        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {\n\n            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max);\n\n            pkt->pts = pkt->dts = max;\n\n\n\n\n\n    /*\n\n     * Audio encoders may split the packets --  #frames in != #packets out.\n\n     * But there is no reordering, so we can limit the number of output packets\n\n     * by simply dropping them here.\n\n     * Counting encoded video frames needs to be done separately because of\n\n     * reordering, see do_video_out()\n\n     */\n\n    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {\n\n        if (ost->frame_number >= ost->max_frames) {\n\n            av_free_packet(pkt);\n\n            return;\n\n\n        ost->frame_number++;\n\n\n\n\n    while (bsfc) {\n\n        AVPacket new_pkt = *pkt;\n\n        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,\n\n                                           &new_pkt.data, &new_pkt.size,\n\n                                           pkt->data, pkt->size,\n\n                                           pkt->flags & AV_PKT_FLAG_KEY);\n\n\n\n\n\n\n\n\n\n\n\n        if (a > 0) {\n\n            av_free_packet(pkt);\n\n            new_pkt.destruct = av_destruct_packet;\n\n        } else if (a < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\",\n\n                   bsfc->filter->name, pkt->stream_index,\n\n                   avctx->codec ? avctx->codec->name : \"copy\");\n\n            print_error(\"\", a);\n\n            if (exit_on_error)\n\n                exit_program(1);\n\n\n        *pkt = new_pkt;\n\n\n\n        bsfc = bsfc->next;\n\n\n\n\n    pkt->stream_index = ost->index;\n\n    ret = av_interleaved_write_frame(s, pkt);\n\n    if (ret < 0) {\n\n        print_error(\"av_interleaved_write_frame()\", ret);\n\n        exit_program(1);\n\n", "idx": 4070, "substitutes": {"s": ["sg", "parser", "server", "js", "service", "so", "cs", "ctx", "src", "ss", "ops", "spec", "ts", "sa", "sb", "aws", "sl", "sk", "op", "client", "g", "ses", "details", "lex", "sv", "storage", "utils", "ds", "sets", "st", "gs", "ps", "ns", "c", "p", "services", "f", "sys", "sq", "sc", "sec", "o", "stats", "S", "os", "session", "t", "sci", "ssl"], "pkt": ["pcht", "cpnt", "Pant", "opacket", " packet", " pct", "tpet", "pnt", "tpacket", "poch", " pet", "Pck", "Pett", " poch", "opet", "pelt", "opck", "apunct", "opnt", "cpunct", "apkg", "pskt", "cpet", " pant", "prekt", "lpdt", "spkt", " pkg", "packet", "spett", "ipcht", " pdt", "tpett", " pett", "preacket", "pant", "apkt", "tpelt", "ipant", "ipkt", " pcht", "pkg", "tpkt", "lpkt", "Pkg", "psunct", "ipacket", "pct", "apet", "Pkt", "spacket", "Pcht", "spcht", "opkt", "dett", "prent", " pelt", "Pnt", "ipoch", "gkt", "cpkt", "opkg", " pck", "dcht", "lpacket", "pset", "Pelt", "gct", "Pet", "pett", "preet", "gcht", "gacket", "Pct", "punct", "pdt", "pskg", "pet", " pnt", "Pdt", "tpnt", "lpct", "cpkg", "cpacket", "ipet", "dacket", "Poch", "pck", "dkt", "cpck", "Packet"], "ost": ["ob", "ist", "ort", "orb", "ld", "so", "rest", "http", "roc", "osc", "host", "oper", "osi", "oop", "ott", "osta", "rob", "ad", "ont", "oid", "ocol", "op", "ood", "iol", "tto", "pod", "nt", "ov", "st", "post", "archive", "oss", "et", "ocr", "hop", "oc", "ods", "org", "\u00f3", "object", "stream", "art", "obj", "tt", "OST", "o", "sn", "bb", "rss", "sta", "inst", "os", "od", "rt", "ast", "oh", "ot", "upload", "obs", "est"], "bsfc": ["bsFC", "bscf", "bsvc", "bosvc", "boscf", "bsxf", "dsxf", "psfc", "csxf", "dspc", "apsFC", "vsFC", "apsfs", "apsfb", "vsfs", "bosfc", "psvc", "bsfb", "pspc", "dscf", "csfs", "psFC", "csvc", "vsfb", "cscf", "csfb", "bosFC", "bspc", "psxf", "bsfs", "csfc", "csFC", "apsfc", "vsfc", "pscf", "dsfc", "cspc"], "avctx": ["evctx", "aveconfig", "AVctx", "evcontext", "evcmp", "avectx", "AVlc", "avconn", "afcmp", "afctx", "afcontext", "avehw", "aveconn", "Avcontext", "akcontext", "AVconn", "avc", "avcf", "avhw", " avcontext", " avc", "Avctx", "avpkg", "Avcf", "Avpkg", " avcf", "AVhw", "afhw", " avconfig", "verconn", "avlc", "vercu", "afconn", "AVcu", "AVcontext", "ovctx", "ovcu", "avelc", "abctx", "avec", "abc", "ovcmp", "abconfig", "avconfig", "akcf", "avcontext", "verlc", "abcontext", "akpkg", "avecontext", "evconn", "verctx", "avcu", "akctx", " avpkg", "ovconn", "AVcmp", "avcmp", "vercontext", "avecmp", "vercmp", "avecu"], "ret": ["row", "no", "total", "rs", "MAX", "success", "id", "num", " resp", "code", "Ret", "last", " success", "result", " res", "len", "ref", "rows", "resp", "std", "sec", "value", "val", "count", "res"], "frame_number": ["fram_position", "fram_note", "frameMnumber", "frame_no", "framesposition", "framesnumber", "fram_no", "fram_number", "framesnote", "frame_position", "frameMno", "frame_version", "frame_note", "fram_version", "frameMversion", "framesno"]}}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 4080, "substitutes": {"l2_cache": ["l2dmodel", "l2pubtime", "l1_table", "l2xroot", "l2pubsource", "l2_last", "l2lextable", "l2fheader", "l92_database", "l1_cache", "l2aclast", "l2dcache", "l2_menu", "l92_table", "l2_config", "l2lexlast", "l1_root", "l2mtable", "l92lextable", "l2_root", "l92lexdatabase", "l2lexcache", "l2accache", "l2xcache", "l1_menu", "l2dsession", "l2lextime", "l2lexcookie", "l1_model", "l1_config", "l1_source", "l2xsize", "l1_size", "l2lexheader", "l2fcache", "l2_database", "l1_last", "l2dtable", "l2fdatabase", "l2lexdatabase", "l2actable", "l2accookie", "l2xtable", "l2_engine", "l2thetable", "l1_time", "l2theroot", "l2thecache", "l92_header", "l2_cookie", "l92lexheader", "l1_session", "l2mcache", "l2ftable", "l2mengine", "l1_engine", "l92_cache", "l2_model", "l2_size", "l2_session", "l2_header", "l2lexsource", "l1_cookie", "l2_time", "l1_image", "l2_image", "l2mmenu", "l2pubtable", "l2thesize", "l92lexcache", "l2pubcache", "l2_source"], "l2_table": ["l2presource", "l2mtable", "l22cache", "l2dbcache", "l1_table", "ltwo_table", "l2_node", "ltwo_server", "l2jtable", "l2dbtemplate", "l2_machine", "l2jsource", "l2dbtree", "l2_tree", "l22server", "ltwo_node", "l1_tree", "l2jtree", "l2_resource", "ltwojmachine", "l2mnode", "ltwo_cache", "ltwo2node", "ltwo_source", "ltwo2table", "l2dbtable", "ltwo2server", "l1_resource", "ltwojtable", "l2_server", "l2ptable", "l1_template", "l1_cache", "l2jcache", "l22node", "ltwojsource", "ltwo2cache", "l22table", "l2fcache", "l2fmachine", "l2_source", "l2ptree", "l2mcache", "l2jmachine", "ltwojcache", "l2mserver", "l2ftable", "l2_template", "l2pcache", "ltwo_machine", "l2jtemplate", "l2fsource"], "entry": ["route", "row", "key", "ries", "ge", "event", "index", "feed", "address", "child", "object", "comment", "way", "cell", "valid", "se", "start", "term", "zip", "her", "image", "id", "parent", "exist", "package", "ie", "e", "session", "link", "import", "offset", "data", "cat", "page", "section", "record", "insert", "ent", "search", "member", "Entry", "inner", "info", "ident", "result", "je", "value", "obj", "node", "connection", "card", "module", "enter", "slave", "si", "match", "server", "letter", "service", "ry", "it", "jo", "nt", "source", "reader", "try", "cel", "element", "line", "view", "part", "table"], "n_entries": ["n_entry", "n_ntencies", "n___entry", "n__entries", "n_entents", "n__entry", "n_Entances", "n_chry", "n_expries", "n_expry", "n__Entrows", "n_countencies", "n_secries", "n___entents", "n___expances", "n_chents", "n___expents", "n_Entrows", "n_secry", "n_countrys", "n_ntry", "n_ntrys", "n_sentry", "n_ntries", "n_expents", "n_secrys", "n_sentencies", "n_sentrys", "n_chries", "n_entrys", "n_secrows", "n__entrows", "n_entances", "n___entries", "n_entrows", "n_countrows", "n__Entry", "n_entencies", "n__Entrys", "n_Entries", "n___expries", "n__Entries", "n_sentries", "n_country", "n_Entry", "n___entances", "n_expances", "n___expry", "n_Entents", "n_countries", "n_Entrys", "n_chances", "n__entrys"]}}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}", "idx": 4091, "substitutes": {"c": ["cm", "this", "acs", "cs", "ctx", "anc", "cc", "mc", "cl", "ct", "co", "bc", "cur", "con", "k", "tc", "enc", "i", "g", "ac", "m", "coll", "cr", "z", "ch", "config", "C", "ec", "dc", "ce", "cu", "p", "cv", "l", "w", "self", "lc", "f", "e", "cache", "ca", "sc", "cd", "u", "vc", "pc", "s", "v", "cp", "cmp", "t", "cf", "ci", "uc", "rc"], "avctx": [" avcmd", "AVctx", " avcontext", "afcmd", "avcmd", "avcb", "AVcmd", " avcb", "afctx", "afcontext", "AVcb", "AVcontext", "afcb", "avcontext"], "high_bit_depth": ["high_bitvaldetails", "high_bitbitrate", "high_check_depth", "high_pixelpcount", "high_bit_dim", "high_bitingsize", "high_bitvaldensity", "high_pixel_rate", "high_checkpredetails", "high_bitbitdim", "high_bitingrate", "high_pixel_count", "high_checkpredepth", "high_bitprate", "high_bitvaldepth", "high_checkpredensity", "high_bit_details", "high_bitingdepth", "high_bitpredepth", "high_pixel_depth", "high_bit_size", "high_bit_density", "high_pixelprate", "high_check_density", "high_bitingdim", "high_bitbitsize", "high_check_details", "high_bitbitdepth", "high_pixelpdepth", "high_bitpdepth", "high_bit_count", "high_bit_rate", "high_bitpredetails", "high_bitpredensity", "high_bitpcount"]}}
