{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 4093, "substitutes": {"usb_net_init": ["usb_net_setup", "usb_net__config", "usb_nets_init", "usb_net__setup", "usb_nets_config", "usb_nets_set", "usb_nets_setup", "usb_net_config", "usb_net__init", "usb_net_set", "usb_net__set"], "cmdline": ["mdstring", "cll", "commandine", "commandlin", "mdline", "cmdLINE", " cmdl", "commandstring", "cmdlin", " cmdLINE", "mdl", "cmdl", "mdlin", "cmdine", "commandl", "commandline", " cmdstring", " cmdine", "clline", "cline", " cmdlin", "commandLINE", "cmdstring", "clLINE"], "dev": ["od", "id", "rad", "bd", "nov", "di", "Dev", "dd", "adv", "device", "bug", "data", "rc", "ad", "info", "dem", " prod", "debug", "valid", "gu", "de", "nd", "d", "obj", "dist", "conf", "ev", "def", "DEV", "wd", " Dev", "priv", "error", "ready", "cam", "die", "driver", "dc", "df", "inst", "err", "result", "pub", "development", " def", "ver", "var", "new", "develop", "gd", "app", "test", "fi", "conn", "diff", "cd"], "opts": ["opls", "OPts", "ropps", " optr", " opps", "protes", "prots", "opttr", "optls", " optps", "ropcs", "roptr", "optt", "ropts", "optr", "opttes", "optts", " optts", "optcs", "opps", "roptes", "OPns", " opttes", "otps", "opcs", "ops", "copls", "copts", "OPt", "opns", "ots", "otts", " opns", "otls", "opt", "optns", "OPs", "optps", "props", "cops", " opcs", "optes", " optes", " opt", "copps", " ops", "procs"], "idx": ["lenxs", "IDx", "lenx", " idpc", "IDw", " idxc", "idw", " idc", "pidxc", "indX", " idix", "idc", "IDc", "IDxc", " IDxc", "idpc", "Idx", "idX", "indix", "Idxc", "Idw", " idX", "lenpc", "IdX", " IDx", "pidx", " idw", "indx", "idix", "lenxc", "pidX", " idxs", "idxc", "Idc", " IDpc", "indxc", "Idix", "pidc", "idxs", " IDxs"]}}
{"project": "FFmpeg", "commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "target": 1, "func": "static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,\n\n                              int dump_payload, AVRational time_base)\n\n{\n\n    HEXDUMP_PRINT(\"stream #%d:\\n\", pkt->stream_index);\n\n    HEXDUMP_PRINT(\"  keyframe=%d\\n\", (pkt->flags & AV_PKT_FLAG_KEY) != 0);\n\n    HEXDUMP_PRINT(\"  duration=%0.3f\\n\", pkt->duration * av_q2d(time_base));\n\n    /* DTS is _always_ valid after av_read_frame() */\n\n    HEXDUMP_PRINT(\"  dts=\");\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->dts * av_q2d(time_base));\n\n    /* PTS may not be known if B-frames are present. */\n\n    HEXDUMP_PRINT(\"  pts=\");\n\n    if (pkt->pts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->pts * av_q2d(time_base));\n\n    HEXDUMP_PRINT(\"\\n\");\n\n    HEXDUMP_PRINT(\"  size=%d\\n\", pkt->size);\n\n    if (dump_payload)\n\n        av_hex_dump(f, pkt->data, pkt->size);\n\n}\n", "idx": 4095, "substitutes": {"avcl": [" avfi", "ajfi", "avsh", "appfi", "appcl", "ajcl", "avfi", "avsel", "ajsel", "appsh", " avsel", " avsh", "ajsh", "appsel"], "f": ["function", "fen", "fr", "tf", "elf", "feed", "sf", "v", "s", "b", "rf", "i", "fed", "m", "l", "d", "e", "w", "file", "func", "t", "fn", "df", "ff", "fac", "n", "fp", "exec", "p", "h", "fs", "proc", "c", "g", "fd", "handler", "fc", "r", "F"], "level": ["levels", "name", "local", "count", "parent", "vel", "enc", "format", "stream", "loc", "debug", "Level", "limit", "length", "loop", "code", "len", "lo", "depth", "path", "temp", "scale", "stage", "lvl", "type", "lc", "mode"], "pkt": ["compacket", "cpkt", " pwk", "cpant", "apet", "opkt", " pnt", "pret", " packet", "pernt", "pkl", "apacket", " pdt", "perkl", "nkt", "pront", "perkt", "compkt", "peth", "pect", "procht", "copet", " pkl", "compet", "Pdt", "punt", "produet", "Pet", "fnt", "peacket", "pwk", " peth", "nwk", "opet", "facket", "apkt", "Packet", "pekt", "prkt", "peret", "copacket", "apnt", " punt", "prokt", "perunt", "pept", " pcht", "hkt", "produkl", "packet", "heth", " pet", "compdt", "opnt", " ppt", "nacket", "ppt", "cpcht", "proant", "pet", "pant", "Pnt", "hdt", "net", "prnt", "prunt", "Pwk", "het", " pant", "pdt", "produnt", "pnt", "fkt", "copwk", "Pkt", "pct", "copkt", "pcht", " pct", "opacket", "cpnt", "Pct", "Ppt", "Peth", "fct", "produkt"], "dump_payload": ["dump_playloaded", "dump_enloaded", "dump_playpack", "dump_playq", "dump_workload", "dump_enpack", "dump_payq", "dump_playload", "dump_enload", "dump_workpack", "dump_Payment", "dump_Payflow", "dump_Payloads", "dump_payloads", "dump_playloads", "dump_workloaded", "dump_enq", "dump_shapeloads", "dump_workq", "dump_payment", "dump_shapeload", "dump_shapement", "dump_playflow", "dump_shapeflow", "dump_payloaded", "dump_payflow", "dump_paypack", "dump_Payload", "dump_playment"], "time_base": ["timesbase", "time2block", "time_scale", "timecodebase", "timefbase", "addressalscale", "timedentry", "timedbase", "time16base", "address_base", " time_block", "time16source", "clock_source", "time2base", "clock_base", "clock_data", "timecodescale", "time_block", "timecodebody", " time_index", "time_index", " time_unit", "time2unit", "timealbase", "addressalbody", "timecodeindex", "timesdata", "time_part", " time_entry", "timessource", "time16part", "timefentry", "addressalindex", "time_type", "timefindex", "time_body", "timefunit", "timedindex", "address_scale", "timedunit", "time16data", "timealindex", "address_body", "time_source", "timespart", "addressalbase", "timealbody", "time_entry", "time2type", "time_data", "time_unit", "address_index", " time_type", "timealscale", "clock_part"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void handle_mousewheel(SDL_Event *ev)\n\n{\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n    SDL_MouseWheelEvent *wev = &ev->wheel;\n\n    InputButton btn;\n\n\n\n    if (wev->y > 0) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (wev->y < 0) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return;\n\n    }\n\n\n\n    qemu_input_queue_btn(scon->dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(scon->dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n}\n", "idx": 4104, "substitutes": {"ev": ["ah", "eng", "hw", "ever", "ep", "el", "v", "entry", "eva", "ell", "exc", "enc", "ae", "window", "event", "ce", "eb", "em", "e", "cell", "eg", "vent", "dev", "esc", "model", "rev", "ee", "ec", "req", "iv", "erv", "eve", "ov", "lv", "EV", "ew", "Ev", "ek", "vv", "env", "cv", "element", "Event"], "scon": ["fconf", "dcon", "dconn", "syncon", "dcl", "sconf", "Scon", " scm", "jcon", "jconf", "sCON", "Sconst", "sconn", "jconn", "fconn", "sconst", "psconst", " sconn", "Scm", " sconst", "synconn", "sco", "pscon", " sco", "fcon", "syncl", "synCON", "dconf", "scm", "psco", "fCON", " scl", " sCON", "Sco", "fcl", "pscm", "scl", "jcl"], "wev": ["wex", "WEv", "WEf", "Wev", " weh", "pef", " wef", " wec", "peh", "hef", "wec", "Wef", "wef", " wex", "weva", "ouv", "wv", "Wex", "pev", "hev", " wew", "WEw", " wevs", "wf", "WEva", "ouvs", "weh", "ouf", "hec", "ww", "wva", "wew", "pex", "ouc", "Weh", " weva", "hevs", "wevs"], "btn": ["scroll", "kn", "button", "fw", "wx", "bd", "focus", "ctl", "bt", "config", "bug", "b", "qt", "rc", "sync", "kk", "wp", "widget", " bout", "wt", "poll", "uc", "fb", "wb", "bg", "tag", " button", "fl", "mot", "bb", "cli", "bs", "kt", "ck", "tn", "fn", "butt", "bot", "ctx", "menu", "bc", "cb", "fp", "cmd", "ou", "batch", "boot", "don", "txt", "cn", "tk", "dt", "bool", "fc", "text", "touch", "biz", "bn", "src", "ctrl", "ui", "tc"]}}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n", "idx": 4141, "substitutes": {"s": ["sf", "S", "http", "spec", "browser", "b", "sys", "ses", "services", "f", "service", "us", "cs", "ss", "sc", "sb", "w", "se", "sd", "ts", "fs", "c", "ssl", "sq", "src", "rs", "r"], "bus": ["plugin", "base", "pack", "build", "ch", "feed", "block", "hub", "id", "http", "BUS", "device", "config", "plug", "bug", "sync", "cat", "Bus", "buf", "db", "usb", "book", "bs", "us", "conf", "ck", "mount", "driver", "lib", "path", "pass", "bc", "self", "bridge", "serial", "root", "boot", "gen", "os", "back", "board", "ash", "front", "cache", "test", "host"], "dev": ["ch", "serv", "od", "v", "id", "block", "rad", "nov", "pro", "di", "Dev", "spec", "device", "dd", "adv", "dn", "plug", "bug", "data", "ow", "ad", "info", "der", "debug", "valid", "gu", "de", "d", "ve", "mod", "av", "obj", "dist", "conf", "ev", "def", "DEV", "dom", "priv", "kind", "error", "w", "cam", "die", "driver", "dc", "sd", "ready", "err", "self", "pub", "serial", "root", "req", "h", "development", "ver", "var", "off", "user", "test", "app", "prov", "conn", "diff", "end", "feature"], "features": ["types", "options", "models", "properties", "feed", "ins", "rules", "fee", "fts", "spec", "works", "plugins", "nets", "config", "atts", "words", "ributes", "data", "format", "debug", "ips", "details", "mac", "results", "f", "stats", "args", "ports", "dist", "fields", "classes", "faces", "driver", "steps", "fn", "tests", "reports", "feat", " feat", "devices", "Features", " Features", "bugs", "settings", "products", "fs", "items", "fd", "product", "params", "fc", "fi", " feature", "conn", "dim", "flags", "feature", "prefix"]}}
{"project": "FFmpeg", "commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "target": 1, "func": "int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4159, "substitutes": {"pkt": ["payacket", "cpkt", "Pait", "tpelt", " pki", "paracket", "Pant", " pnt", "Pcht", "upct", "sett", "ppnt", "promant", "wpacket", "paynt", "spnt", " pdt", "fpnt", "Pki", "lelt", "parnt", "mkg", "nkt", "payett", "perkt", "cpacket", "peth", "Pett", "jpnt", "parkt", "lpkt", "prct", "punt", "Pdt", "promacket", "Pet", "spelt", "prekt", "fpkt", " peth", "npacket", "prcast", "upkt", "ppacket", "facket", "Packet", "Pelt", "wpnt", "prent", "pcast", "prkt", "ykt", "peret", "fet", "spkt", "tpkt", " punt", "lkt", "yacket", "promkt", "Pkg", "npkg", "pki", "neth", "skt", "packet", "parcht", "pelt", "mct", "spet", "cpct", "tpacket", "tpet", " pait", "ppeth", " pet", "upunt", "ppkt", "snt", "Punt", "let", "lpacket", "jpelt", "nnt", "lpdt", " pcast", "pet", "pant", "Pnt", "prnt", "jpacket", "promki", "lnt", "lpct", "wpcht", "peracket", "wpkt", " pant", "pdt", "pnt", "pait", "fkt", "jpkt", "mkt", "preeth", "npkt", "Pkt", "pett", "jpcast", "ynt", "pct", "prekg", "lacket", "fpelt", "paykt", "perkg", "upacket", "macket", " pelt", "npnt", "sacket", "nkg", "cpkg", "pcht", "yeth", " pct", "fpet", "cpet", "npct", "cpnt", "Pct", "spacket", "Peth", " pkg", "jpct", "fait", "pkg", " packet"], "i": ["gi", "ti", "v", "id", "is", "I", "di", "s", "ci", "ni", "x", "xi", "si", "ri", "io", "b", "slice", "info", "bi", "in", "module", "qi", "m", "ix", "l", "key", "f", "pi", "yi", "j", "ii", "iu", "it", "ai", "cli", "d", "init", "u", "e", "interface", "uri", "ori", "k", "n", "isin", "multi", "mi", "ini", "ie", "z", "eni", "iv", "start", "oi", "c", "ip", "g", "y", "lc", "li", "fi", "index", "zi", "end", "ui"], "size": ["position", "large", "shape", "x", "password", "data", "style", "unit", "speed", "used", "weight", "align", "code", "len", "any", "connection", "depth", "error", "empty", "go", "mini", "h", "sp", "zero", "line", "g", "page", "y", "query", "li", "engine", "general", "max", "mode", "function", "name", "SIZE", "extra", "id", "count", "fee", "s", "send", "channel", "value", "sum", "last", "slice", "capacity", "content", "grade", "server", "member", "six", "number", "zip", "sized", "path", "ey", "ie", "scale", "z", "type", "model", "site", "form", "end", "ui", "external", "address", "eng", "time", "sec", "security", "use", "sync", "sex", "loc", "key", "version", "j", "small", "Size", "reason", "e", "message", "timeout", "source", "start", "pos", "c", "location", "core", "cache", "set", "get", "ny", "si", "body", "live", "offset", "side", "length", "fe", "owner", "full", "storage", "day", "n", "load", "ice", "strength", "term", "ize", "nice", "shift"], "p": ["patch", "cp", "hp", "P", "o", "bp", "python", "v", "pr", "a", "prev", "up", "s", "pa", "pre", "po", "x", "b", "data", "pp", "op", "wp", "pe", "lp", "ap", "m", "l", "f", "pi", "at", "pg", "post", "j", "d", "pc", "py", "q", "param", "u", "np", "part", "e", "point", "dp", "w", "per", "port", "t", "k", "n", "after", "fp", "jp", "h", "z", "vp", "sp", "pointer", "c", "ip", "g", "y", "api", "tp", "pl", "app", "r", "ps"]}}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n", "idx": 4165, "substitutes": {"dev": ["pack", "pid", "ch", "o", "v", "md", "rad", "pu", "pro", " priv", "Dev", "progress", "device", "plug", "data", "io", "pipe", "ad", "info", "private", "de", "pi", "d", "pc", "conf", "ev", "def", "u", "dp", "priv", "push", "w", "cam", "port", " device", "pad", "pub", "req", "prop", "ver", "proc", "c", "api", "app", "r"], "p": ["cp", "P", "o", "bp", "v", "pp", "op", "i", "m", "f", "pi", "pc", "param", "np", "dp", "e", "w", "t", "n", "fp", "vp", "prop", "proc", "c", "g", "tp", "pb", "r"], "s": ["o", "sr", "v", "S", "spec", "sg", "session", "si", "sync", "sys", "ses", "m", "ns", "stats", "sl", "d", "service", "ss", "e", "sh", "an", "sb", "ops", "se", "ds", "n", "ts", "su", "sv", "sp", "fs", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "ps", "js"]}}
{"project": "qemu", "commit_id": "4508d81a788f451c83604e1d0033243e191d71a7", "target": 1, "func": "ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,\n\n                                uint32_t flags)\n\n{\n\n    ram_addr_t bdloc;\n\n    int i, n;\n\n\n\n    /* We put the bd structure at the top of memory */\n\n    if (bd->bi_memsize >= 0x01000000UL)\n\n        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);\n\n    else\n\n        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);\n\n    stl_phys(bdloc + 0x00, bd->bi_memstart);\n\n    stl_phys(bdloc + 0x04, bd->bi_memsize);\n\n    stl_phys(bdloc + 0x08, bd->bi_flashstart);\n\n    stl_phys(bdloc + 0x0C, bd->bi_flashsize);\n\n    stl_phys(bdloc + 0x10, bd->bi_flashoffset);\n\n    stl_phys(bdloc + 0x14, bd->bi_sramstart);\n\n    stl_phys(bdloc + 0x18, bd->bi_sramsize);\n\n    stl_phys(bdloc + 0x1C, bd->bi_bootflags);\n\n    stl_phys(bdloc + 0x20, bd->bi_ipaddr);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);\n\n    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);\n\n    stl_phys(bdloc + 0x2C, bd->bi_intfreq);\n\n    stl_phys(bdloc + 0x30, bd->bi_busfreq);\n\n    stl_phys(bdloc + 0x34, bd->bi_baudrate);\n\n    for (i = 0; i < 4; i++)\n\n        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);\n\n    for (i = 0; i < 32; i++)\n\n        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);\n\n    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);\n\n    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);\n\n    n = 0x6A;\n\n    if (flags & 0x00000001) {\n\n        for (i = 0; i < 6; i++)\n\n            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);\n\n    }\n\n    stl_phys(bdloc + n, bd->bi_opbfreq);\n\n    n += 4;\n\n    for (i = 0; i < 2; i++) {\n\n        stl_phys(bdloc + n, bd->bi_iic_fast[i]);\n\n        n += 4;\n\n    }\n\n\n\n    return bdloc;\n\n}\n", "idx": 4166, "substitutes": {"env": ["cfg", "ea", "emb", "el", "ef", "config", "vt", "environment", "nc", "rc", "enc", "tty", "buf", "state", "ev", "def", "em", "e", "code", "en", "inst", "hl", "ec", "iv", "console", "fs", "shell", "proc", "ed"], "bd": ["od", "bin", "not", "md", "vd", "dd", "bt", "pd", "b", "dh", "data", "bm", "ad", "fb", "db", "dan", "d", "bb", "BD", "td", "wd", "sb", "hide", "die", "da", "nit", "sd", "ds", "df", "bot", "dc", "bc", "cb", "nb", "ba", "boot", "gb", "kb", "ld", "ande", "bf", "fd", "gd", "dt", "ud", "bl", "cdn", "hd", "nd", "cd"], "flags": ["types", "options", "fg", "flag", "bits", "bands", "ags", "features", "Flags", "bit", "mask", "lag", "vals", "bus", "offset", "f", "stats", "args", "ffff", "ints", "ops", "bytes", "fps", "blocks", "fs", " bits", "lf", "xff"], "bdloc": ["dbcor", "bderr", "dbspec", "bcerror", "blok", "bllock", "btconfig", "mdutil", "bdroot", "bdrc", "kblocation", "btlocation", "kblit", "bdsrc", "ndlocal", "blang", "pdloc", "bcspec", "dblocal", "hderr", "bdlock", "dLOC", "bberror", "pdlocation", "bbok", "dklocation", "bllang", "bclock", "dblocation", "pdstat", "bctag", "pdlang", "blloc", "bcorg", "bbvoc", "dloc", "pdconn", "dkhome", "dberr", "bclocal", "bbloc", "bborg", "bcok", "cballoc", "dkcor", "cbloc", "hdlocal", "bdlocation", "bdlocal", "dballoc", "bcalloc", "cbtag", "bdconfig", " cdhome", "blsrc", "dborg", "pdcoll", "bblim", "nderr", "bblang", "blstat", "bdlang", "dkloc", "dklocal", "mdlim", "bdcor", "bcerr", "BDlocation", "hdcoll", "BDLOC", "bclit", "ldlocation", "bflit", "cblocation", "mdconfig", "ldalloc", "bdcoll", "mdlocation", "hdconfig", "hdlang", "bchome", "derr", "hdcor", "bbhome", "ndvoc", "pdok", " cdLOC", "bdalloc", "bclocation", "hdlim", "kblim", "bblit", "bdspec", "hdvoc", "bllim", "dlang", "block", "bfloc", "bblocation", "bbcoll", "bclang", "bbconn", "bdstat", "btloc", "hdlocation", " cdlocation", "bcconn", "dbvoc", "dkerror", "hdloc", "ldtag", "hdroot", "ndspec", "bdLOC", "hdutil", "ndlocation", "hdconn", "dbLOC", "bdtag", "hdhome", "blcor", "BDhome", "bderror", "mdloc", "dbconn", "dkvoc", "hdrc", "dbrc", "bcrc", "hderror", "dbok", "dblang", "btutil", "bdorg", "dbroot", "bbLOC", " cdloc", "bdlim", "ldloc", "bflocation", "bcsrc", "bdok", "bsrc", "mdlang", "bllocation", "bcloc", "bflocal", "ndloc", "bdconn", "bdhome", "bbcor", "dberror", "ndhop", "bdhop", "ndroot", "hdalloc", "dkhop", "dbloc", "dbhop", "bdutil", "bblocal", "kbloc", "BDloc", "kblang", "dbstat", "dblit", "bdvoc", "hdLOC", "bloc", "bdlit"], "i": ["gi", "ali", "o", "ei", "ti", "v", "id", "I", "chi", "di", "ci", "ji", "ni", "x", "xi", "si", "io", "ri", "b", "slice", "info", "bi", "data", "in", "qi", "ix", "l", "key", "yi", "pi", "phi", "d", "iu", "j", "ii", "my", "ai", "init", "uli", "it", "u", "e", "code", "uri", "multi", "mi", "jp", "ini", "ie", "p", "jit", "mini", "eni", "oi", "hi", "ind", "c", "ip", "g", "y", "lc", "li", "fi", "index", "zi", "diff", "mu", "ui"], "n": ["o", "s", "nt", "ni", "nc", "sn", "m", "l", "num", "f", "N", "ns", "nm", "j", "nr", "net", "u", "np", "e", "len", "t", "fn", "p", "z", "c", "ind", "g", " ni"]}}
{"project": "qemu", "commit_id": "92cb05574b7bd489be81f9c58497dc7dfe5d8859", "target": 0, "func": "bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n", "idx": 4173, "substitutes": {}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4178, "substitutes": {"mon": ["master", " monitor", "stat", "amon", "dm", "ann", "bin", "platform", "om", "pin", "tun", "mid", "config", "mat", "tom", "com", "wm", "Mon", "mo", "meter", "m", "unit", "module", "mac", "num", "mos", "client", "mn", "gin", "my", "atom", "wat", "member", "man", "mun", "con", "mc", "mount", "connection", "dom", "an", "message", "mut", "mag", "mi", "phys", "lock", "mons", "don", "monitor", "mr", "un", "am", "mm", "sym", "ms", "bo", "MON", "mont", "mor", "manager", "conn", "mu"], "password": ["patch", "Password", "address", "login", "name", "padding", "word", "channel", "device", "sudo", "username", "words", "config", "secret", "data", "token", "enc", "pattern", "key", "description", "param", "wd", "code", "auth", "port", "encrypted", "cmd", "pass", "p", "crypt", "attribute", "sword", "wallet", "text", "account", "phrase", "command", "prefix"], "opaque": ["opque", "operque", "operaques", "Opaque", " opque", "ipaques", "ipque", "operaque", "ipaque", "Opque", "copace", "Opacity", "hopaque", " opacity", "hopque", " opace", "Opace", "opaques", "operacity", "copaque", "ipacity", "opace", "opacity", "copque", "hopacity", "hopaques", "copacity"], "bs": ["bas", "as", "lb", "ob", "bps", "b", "bm", "ses", "bi", "BS", "bes", "ns", "ls", "iss", "bb", "cs", "ss", "vs", "sb", "gs", "ks", "bis", "ds", "bc", "ils", "ba", "css", "gb", "acs", "fs", "utils", "bos", "ms", "bay", "bl", "aos", "rs", "pb", "ras", "ps"]}}
{"project": "FFmpeg", "commit_id": "9c3a8693a20da3ad89a327bf778e13c2cd74c81c", "target": 0, "func": "dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n\n                    enum dshowDeviceType devtype, IBaseFilter **pfilter)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IBaseFilter *device_filter = NULL;\n\n    IEnumMoniker *classenum = NULL;\n\n    IMoniker *m = NULL;\n\n    const char *device_name = ctx->device_name[devtype];\n\n    int skip = (devtype == VideoDevice) ? ctx->video_device_number\n\n                                        : ctx->audio_device_number;\n\n    int r;\n\n\n\n    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,\n\n                                   &CLSID_AudioInputDeviceCategory };\n\n    const char *devtypename = (devtype == VideoDevice) ? \"video\" : \"audio\";\n\n\n\n    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],\n\n                                             (IEnumMoniker **) &classenum, 0);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate %s devices.\\n\",\n\n               devtypename);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {\n\n        IPropertyBag *bag = NULL;\n\n        char *buf = NULL;\n\n        VARIANT var;\n\n\n\n        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        var.vt = VT_BSTR;\n\n        r = IPropertyBag_Read(bag, L\"FriendlyName\", &var, NULL);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        buf = dup_wchar_to_utf8(var.bstrVal);\n\n\n\n        if (pfilter) {\n\n            if (strcmp(device_name, buf))\n\n                goto fail1;\n\n\n\n            if (!skip--)\n\n                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n\n        } else {\n\n            av_log(avctx, AV_LOG_INFO, \" \\\"%s\\\"\\n\", buf);\n\n        }\n\n\n\nfail1:\n\n        if (buf)\n\n            av_free(buf);\n\n        if (bag)\n\n            IPropertyBag_Release(bag);\n\n        IMoniker_Release(m);\n\n    }\n\n\n\n    IEnumMoniker_Release(classenum);\n\n\n\n    if (pfilter) {\n\n        if (!device_filter) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not find %s device.\\n\",\n\n                   devtypename);\n\n            return AVERROR(EIO);\n\n        }\n\n        *pfilter = device_filter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4196, "substitutes": {"ctx": ["cp", "cfg", "anc", "hw", "fw", "ci", "config", "nc", "rc", "cca", "wp", "concept", "uc", "loc", "cm", "tx", "cal", "cl", "client", "conv", "pc", "cc", "cli", "conf", "np", "ck", "sc", "acl", "cam", "cmd", "bc", "cu", "cms", "Context", "fp", "context", "p", "ctrl", "ca", "qa", "kb", "c", "cn", "cf", "lc", "fc", "cv", "ac", "cas", "conn", "pkg", "xc", "tc"], "device_filter": ["device_Filter", "user_format", "devicepfilter", "user_search", "user_user", "device__format", "device_search", "device__Filter", "device__sort", "device_format", "device_fil", "device_user", "device_sort", "devicepsearch", "devicepformat", " device_format", "user_filter", "devicepuser", " device_sort", " device_fil", " device_Filter", "device__filter"], "classenum": ["producten", " classconfig", "Classenum", "Classpath", "Classconfig", "CLASSmetadata", "typeenum", " classum", "productenum", "productum", " classen", " classmetadata", "classpath", "Classnum", " classpath", "typefeat", "CLASSnum", "CLASSen", "CLASSconfig", "typepath", "classnum", " classnum", "classen", "classfeat", " classfeat", "productmetadata", "classum", "CLASSum", "classmetadata", "typenum", "CLASSenum", "Classfeat", "classconfig", "Classen"], "m": ["machine", "o", "dm", "v", "gm", "md", "vm", "om", "s", "M", "b", "i", "bm", "perm", "module", "rm", "l", "mac", "f", "d", "metadata", "sm", "mod", "man", "e", "mc", "hm", "mt", "port", "t", "n", "tm", "mi", "p", "context", "fm", "h", "mr", "c", "g", "im", "ms", "mm", "y", "model", "jam", "manager", "cm", "dim", "mu"], "device_name": ["deviceFnames", "devicesnames", "deviceacfilter", "deviceFgroup", "device_size", "dev_id", "deviceingaddress", "devicesname", "deviceacsize", "devicesnumber", "deviceacname", " device_group", "deviceingid", "deviceFnumber", "deviceacnames", "device_group", "deviceingname", "dev_number", "devicesgroup", " device_number", "deviceingnumber", "dev_address", " device_names", " device_size", "device_names", "dev_name", "deviceFname", "device_number", "device_id", "device_address"], "r": ["dr", "rw", "o", "er", "nor", "fr", "cr", "sr", "ret", "v", "rt", "rr", "s", "rb", "b", "rc", "or", "l", "rh", "ru", "f", "attr", "d", "nr", "q", "res", "it", "u", "e", "error", "ar", "w", "ur", "rg", "k", "t", "n", "err", "lr", "rl", "result", "p", "end", "h", "run", "z", "ner", "R", "re", "line", "mr", "c", "g", "hr", "br", "rs", "kr", "rec", "rar"], "device_guid": ["device_ruide", "device_uuid", "device_runame", "device_Guid", "device_guin", "device_uuname", "device_collide", "device_collin", "device_ruid", "device_guide", "device_Guin", "device_guname", "device_Guname", "device_uuin", "device_Guids", "device_Guip", "device_guip", "device_collids", "device_uuide", "device_Guide", "device_guids", "device_uuip", "device_ruip", "device_uuids", "device_collid"], "devtypename": ["devTypenename", "devtyrename", "devtyrenename", "devtyperename", "devtyrenum", "devtyrenname", "devtyperum", "devTYperame", "devTyrenum", "devTyrenname", "devtypenum", "devtymename", "devtymenum", "devTYpename", "devtyperame", "devTYperename", "devTyrename", "devtymenname", "devTYpername", "devtyperAME", "devtyenAME", "devtyrenAME", "devtyenename", "devtypenAME", "devtypername", "devTYperAME", "devTypenname", "devTypename", "devTYpenname", "devtypenname", "devtymenename", "devTyrenename", "devtyename", "devtyenname", "devTYpenename", "devTYpenAME", "devTypenum", "devtypenename"], "bag": ["bind", "bed", "pack", "gate", "band", "pak", "buff", "ag", "bin", "packed", "box", "rag", "rb", "config", "bug", "b", "data", "slice", "card", "map", "grab", "tag", "package", "tab", "buffer", "jar", "w", "sb", "zip", "brush", "wrap", "pad", "go", "ab", "container", "array", "p", "batch", "z", "bags", "filter", "comb", "br", "pkg"], "buf": ["cmp", "fam", "buff", "vec", "block", "box", "la", "rb", "tmp", "config", "b", "val", "data", "queue", "uc", "grab", "map", "wb", "fb", "uf", "tab", "bb", "buffer", "sb", "Buffer", "func", "port", "pad", "ab", "cb", "bc", "bytes", "seq", "pool", "batch", "ptr", "alloc", "br", "cv", "text", "ref", "aux", "src", "cas", "pkg", "ff"], "var": ["dr", "pack", "fr", "vr", "sr", "v", "pr", "rr", "Variable", "cur", "entry", "vari", "tmp", "val", "b", "op", "slice", "cat", "tag", "attr", "av", "arg", "bb", "ser", "man", "rar", "jar", "ar", "per", "arr", "dev", "func", "t", "pad", "err", "str", "p", "parse", "car", "AR", "variable", "ptr", "par", "ver", "type", "br", "Var", "adr", "ref", "bar"], "skip": ["rn", "cmp", "row", " rec", "cr", " c", " tr", "jump", "mid", "M", "op", "rc", "ignore", "cl", "ipp", "mn", "order", "need", "strip", "loop", "ry", "all", "mc", "stop", "error", "allow", " sr", "pass", "err", "ski", "me", "process", "trace", " s", "sleep", "sp", "proc", "ip", "ro", "include", "Skip", "li", "keep", "no", "par", "rec", "mode"]}}
{"project": "FFmpeg", "commit_id": "a755b725ec1d657609c8bd726ce37e7cf193d03f", "target": 0, "func": "static int do_decode(AVCodecContext *avctx, AVPacket *pkt)\n\n{\n\n    int got_frame;\n\n    int ret;\n\n\n\n    av_assert0(!avctx->internal->buffer_frame->buf[0]);\n\n\n\n    if (!pkt)\n\n        pkt = avctx->internal->buffer_pkt;\n\n\n\n    // This is the lesser evil. The field is for compatibility with legacy users\n\n    // of the legacy API, and users using the new API should not be forced to\n\n    // even know about this field.\n\n    avctx->refcounted_frames = 1;\n\n\n\n    // Some codecs (at least wma lossless) will crash when feeding drain packets\n\n    // after EOF was signaled.\n\n    if (avctx->internal->draining_done)\n\n        return AVERROR_EOF;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))\n\n            ret = pkt->size;\n\n    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n    } else {\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    if (ret == AVERROR(EAGAIN))\n\n        ret = pkt->size;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->internal->draining && !got_frame)\n\n        avctx->internal->draining_done = 1;\n\n\n\n    if (ret >= pkt->size) {\n\n        av_packet_unref(avctx->internal->buffer_pkt);\n\n    } else {\n\n        int consumed = ret;\n\n\n\n        if (pkt != avctx->internal->buffer_pkt) {\n\n            av_packet_unref(avctx->internal->buffer_pkt);\n\n            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        avctx->internal->buffer_pkt->data += consumed;\n\n        avctx->internal->buffer_pkt->size -= consumed;\n\n        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;\n\n        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    if (got_frame)\n\n        av_assert0(avctx->internal->buffer_frame->buf[0]);\n\n\n\n    return 0;\n\n}\n", "idx": 4198, "substitutes": {"avctx": ["akcontext", " avcf", "afctrl", "navcn", "rafcontext", "afcas", "avecas", "avalcmd", "ivcn", "aveqa", "vercu", "ivcontext", "navcontext", "aveloc", "alctx", "ivctx", "afxc", "aveconfig", "afctx", "aircmd", "apctx", "allconfig", "avqa", "avalcu", "ajctx", "navctx", "navcca", "avalcot", "verctrl", " avcontext", "afsq", "altx", "verxc", "allcontext", "avcdn", "afrc", "airctx", "rafcot", "avcmd", "avalctl", "avalcdn", "akcmp", "afcot", "afloc", "afcmp", "avcmp", "avecca", "akctx", "afcn", "aircf", "rafctl", "abcontext", "avecms", "navcu", "avalctx", "avxc", "aveconn", "avecontext", "akcf", "akconn", "afcf", "avlc", "avctrl", "avexc", "avecu", "rafctx", "avelc", "avalcontext", "avalcf", "verconfig", "navsq", "abconn", " avcms", "navconfig", "aflc", "avcas", "alcu", "afctl", "vercontext", "avecn", "avcu", "avconfig", "afcmd", "avcca", "avcms", "allcf", "akctrl", "navconn", "navcf", "allctx", "avcontext", "afpkg", "afcdn", "vercdn", "avcot", "afqa", "avloc", "avconn", "ajconn", "abctx", "alconn", "apcu", "avcn", "alcontext", "avctl", "ivrc", "afcms", "apcontext", "verconn", "avectx", "avepkg", "avsq", "navxc", "avrc", "avcf", "verqa", "aptx", "aftx", "averc", "avecf", "avtx", " avloc", "verctx", "ajsq", "aircontext", "afconn", "avpkg", "afcontext", "afconfig", "ajcontext", "akpkg", " avlc", "afcca", "avecmp", "alcas", "afcu", "abcu", "vercf"], "pkt": ["cpkt", "felt", "apkid", "tpdt", " pnt", "Pcht", "pqt", " pka", " pdt", "apacket", "pucht", "pkid", "cpacket", "cpka", " pk", "Pett", "pk", "lpkt", "prct", "epka", "cpelt", "promacket", "Pet", "lpkid", "promet", "prcht", "lpcht", "apkt", "Packet", "prkt", " pett", "tpkt", "promkt", " pcht", "Pkg", "tpant", "packet", "pracket", "promett", "pelt", "cpct", " pet", " pqt", "cpqt", "epacket", "epk", "lpacket", "ipkt", "lpdt", "pet", "pant", "cpk", "epkh", "epkt", "epnt", "ipacket", " pkh", " pant", "pdt", "pnt", "fkt", " pkid", "Pkt", "pett", "pka", "pct", "pkh", "lpant", " pelt", "ipkh", "cpkg", "pcht", "tpcht", " pct", "apkg", "ipnt", "cpet", "fqt", "puacket", "pukt", "Pct", "lpkg", "puet", " pkg", "fct", "pkg", " packet"], "got_frame": ["got_fram", " got_slot", "got_pixel", "gotableframe", "gotayline", "gotayframe", "gotablesample", "gotaypointer", "given_pointer", "gotaysample", "gotfframe", "gotfpixel", "given_frame", "got_hole", " got_word", " Got_frame", "Got_fram", "got_slot", "got_sample", "got_word", " got_hole", "gotablepointer", "Got_frame", "gotableline", "got_range", "got_pointer", "gotfposition", "gotffram", "got_class", " got_class", "Got_pixel", "given_line", "got_size", " Got_fram", " Got_range", "got_position", "Got_position", "got_line", " Got_size", "given_sample"], "ret": ["flag", "rb", "data", "status", "f", "used", "arg", "active", "match", "code", "len", "det", "error", "RET", "sat", "rl", "rev", "ft", "fun", "resp", "slot", "function", "msg", "id", "nt", "value", "lt", "val", "rf", "art", "valid", "url", "bad", "mt", "str", "usr", "ut", "fail", "back", "reg", "rt", "sec", "alt", "rc", "bit", "cat", "debug", "db", " RET", "num", "fin", "ext", "att", "pet", "obj", "sb", "en", "fit", "feat", "Ret", "re", "gt", "desc", "ref", "r", "rets", "final", "format", "reply", "sur", "lit", "res", "def", "part", "result", "opt", "bf", "success", "rep"]}}
{"project": "qemu", "commit_id": "e8f1f9db8787be08e0ae3ed5a94da68966dbfff1", "target": 0, "func": "void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n", "idx": 4209, "substitutes": {"mon": ["amon", "kin", "dm", "ann", "mand", "bin", "met", "pin", "mat", "mo", "Mon", "meter", "m", "mos", "mn", "gin", "bean", "mot", "man", "mun", "dom", "con", "mt", "mc", "bro", "mut", "mag", "mi", "mons", "monitor", "mr", "mm", "lin", "bo", "mont", "MON", "mor", "dim", "mu"], "vlan_id": ["vpn_id", "vLAN_id", "vlan_address", "vpn_type", "vlan_name", "vpn_name", "vLAN_name", "vpn_ids", "vlan_type", "vLAN_address", "vlan_ids", "vLAN_ids"], "device": ["plugin", "address", "mobile", "name", "domain", "phy", "Device", "spec", "component", "value", "channel", "scope", "password", "data", "object", "unit", "tag", "package", "project", "attr", "d", "service", "target", "connection", "item", "dev", "port", "driver", "dc", "devices", "serial", " dev", "prop", "direction", "node", "attribute", "ip", "type", "product", "model", "user", "android", "addr", "host", "directory", "conn", "mode", "feature"], "vlan": ["vsl", "vnic", "Vlan", "Vpn", "svpn", "evda", " vl", " vnic", "vpn", " vpn", "vda", "vlc", "evnic", "vsla", " vla", "vslan", "evla", " vlc", "Vnic", " vlas", "svlc", "svlan", "Vda", "Vlas", "svlas", "vl", "vlas", "vsnic", "Vla", "Vlc", "vla", " vda", "evl", "evlan"], "vc": ["nv", "cp", "oc", "hw", "serv", "vr", "rt", "v", "wx", "vd", "dn", "vm", "vid", "ci", "vt", "nc", "rc", "rec", "sn", "gt", "wk", "ll", "loc", "VC", "ga", "client", "cci", "pc", "cc", "service", "cs", "ce", "bb", "wd", "auth", "dev", "dc", "cmd", "ctx", "ant", "bc", "cu", "rl", "ic", "vp", "c", "ct", "cn", "lc", "wl", "cf", "fc", "lv", "api", "cv", "ac", "vv", "conn", "xc"]}}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static void vfio_bar_write(void *opaque, hwaddr addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf.byte = data;\n\n        break;\n\n    case 2:\n\n        buf.word = cpu_to_le16(data);\n\n        break;\n\n    case 4:\n\n        buf.dword = cpu_to_le32(data);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported write size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d) failed: %m\",\n\n                     __func__, addr, data, size);\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d)\\n\",\n\n            __func__, bar->nr, addr, data, size);\n\n\n\n    /*\n\n     * A read or write to a BAR always signals an INTx EOI.  This will\n\n     * do nothing if not pending (including not in INTx mode).  We assume\n\n     * that a BAR access is in response to an interrupt and that BAR\n\n     * accesses will service the interrupt.  Unfortunately, we don't know\n\n     * which access will service the interrupt, so we're potentially\n\n     * getting quite a few host interrupts per guest interrupt.\n\n     */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n}\n", "idx": 4211, "substitutes": {"opaque": [" opec", "plc", "Opec", "opc", "placo", "OPacity", "OPec", "Opaque", "Opca", "OPaque", " opc", "OPc", " opca", "OPca", " opaco", "opec", "plaque", "OPaques", "Opacity", " opacity", "opaco", "OPaco", "opaques", "plaques", "opacity", "opca", " opaques"], "addr": ["base", "address", "dr", "r", "name", "layer", "host", "area", "id", "ady", "word", "config", "Address", "x", "rc", "ada", "nc", "oa", "ad", "alias", "ace", "offset", "attr", "url", "server", "nr", "args", "adder", "align", "code", "len", "uri", "part", "pad", "rx", "coord", "filename", "amp", "asm", "frame", "ptr", "pos", "pointer", "start", "ip", "amd", "adr", "ord", "ref", "index", "src", "mode", "add"], "data": ["base", "address", "name", "padding", "extra", "block", "id", "alpha", "la", "a", "done", "dat", "device", "value", "config", "dd", "ada", "val", "i", "format", "ad", "image", "missing", "window", "valid", "null", "bus", "offset", "d", "length", "space", "align", "DATA", "byte", "number", "buffer", "len", "code", "uri", "da", "raw", "Data", "pad", "empty", "bytes", "work", "array", "input", "reader", "batch", "zero", "start", "pos", "memory", "api", "video", "cache", "next", "index", "partial", "mode", "shift", "ui", "prefix"], "size": ["function", "false", "address", "name", "SIZE", "extra", "large", "sec", "a", "count", "complete", "shape", "send", "config", "sync", "sn", "enc", "loc", "capacity", "offset", "length", "args", "small", "Size", "align", "handle", "from", "number", "code", "len", "e", "error", "en", "six", "raw", "storage", "esc", "ctx", "sized", "empty", "bytes", "end", "scale", "zero", "pos", "cap", "c", "g", "handler", "ize", "max", "mode", "shift"], "bar": ["base", "row", "host", "aer", "bin", "ker", "cur", "hub", "far", "parent", "hand", "browser", "consumer", "bg", "gap", "b", "bug", "feature", "home", "com", "cat", "queue", "window", "mac", "db", "gar", "cart", "client", "foo", "project", "job", "ga", "server", "tab", "buffer", "jar", "bag", "cam", "Bar", "fac", "ab", "bc", "container", "bridge", "ba", "border", "array", "car", "ca", "work", "batch", "result", "var", "cap", "br", "board", "ac", "ha", "cache", "broad", "arrow", "loader", "camp", "worker", "bars"], "buf": ["cp", "feed", "buff", "lb", "vec", "block", "fw", "box", "bd", "rb", "config", "rc", "home", "cat", "queue", "uc", "grab", "loc", "fb", "wb", "uf", "window", "foo", "abb", "obj", "buffer", "bag", "Buffer", "port", "func", "ctx", "bc", "cb", "ab", "result", "border", "seq", "batch", "runner", "alloc", "console", "proc", "cap", "comb", "br", "board", "cv", "pb", "fi", "aux", "src", "cas", "ff"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf5208evb_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    target_phys_addr_t entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"m5208\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_init_ram(ram, \"mcf5208.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, \"mcf5208.sram\", 16384);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, env);\n\n\n\n    mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used)\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, ELF_MACHINE, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 4213, "substitutes": {"args": ["plugin", "apps", "ig", "ins", "arms", "sg", "plugins", "config", "atts", "words", "Args", "enc", "ae", "states", "vals", "ants", "parts", "arg", "assets", "init", "cs", "actions", "fields", "acl", "ass", "parser", "gs", "ks", "arr", "cmd", "empty", "parse", "aws", "Arg", "alloc", "am", "utils", "g", "resources", "ands", "api", "ams", "ids", "params", "ac", "lines", "aux", "ras", "flags"], "cpu_model": ["cpu_models", "kernel_controller", "cpu\u00b7controller", "gpu_folder", "cpu\u00b7address", "cpu\u00b7folder", "gpu_network", "cpu_channel", "cpu_manager", "gpu_model", "gpu_mode", "kernel_model", "core_channel", "kernel_mode", "cpuingchannel", "core_model", "cpuingmanager", "cpu_lock", "gpu_module", "gpu_models", "cpu_module", "cpu_network", "core_module", "cpu_folder", "gpu_address", "cpuingmodel", "cpu\u00b7model", "cpu_mode", "cpu_controller", "core_manager", "cpuingmodule", "cpu\u00b7lock", "cpu_address", "kernel_lock", "cpu\u00b7mode"], "kernel_filename": ["kernelpfile", "cpu_memory", "kernelpfilename", "kernel__memory", "kernel_file", "linux_filename", "kernelbooklocation", "kernelpmodel", "kernelbookfilename", "kernelbookmemory", "kernel_model", "cpu_location", "kernel__filename", "kernel_config", "kernel__file", "linux_model", "linux_config", "kernel_location", "kernelpconfig", "kernelbookfile", "cpu_filename", "kernel_memory", "linux_file", "cpu_file", "kernel__location"], "env": ["enable", "energy", "ea", "ig", "v", "vm", "scope", "session", "config", "esp", "bg", "environment", "exc", "si", "enc", "image", "eu", "db", "profile", "export", "eye", "ext", "gui", "obj", "init", "net", "conf", "ev", "np", "vs", "e", "priv", "inventory", "her", "img", "en", "file", "dev", "ctx", "kernel", "err", "equ", "Environment", "context", "ec", "network", "eni", "iv", "viron", "console", "global", "shell", "proc", "txt", "core", "skin", "cache", "app", "loader", "manager", "conn", "ass", "dict"], "kernel_size": [" kernel_capacity", "kernel64size", "kernel_mode", "kernel_capacity", "kernel64mode", " kernel_mode", "kernel64capacity"], "elf_entry": ["elf_slice", "ram_slice", "elf_reader", "ram_entry", "ramalrow", "ramalreader", "elf_row", "ram_reader", "ram_row", "ramalentry", "ramalslice"], "entry": ["base", "ensor", "row", "vec", "count", "nt", "data", "record", "info", "card", "image", "ries", "ii", "ry", "byte", "uple", "cell", "arr", "file", "field", "icle", "array", "parse", "Entry", "index", "par", "view"], "pic": ["kit", "kin", "ig", "vec", "bin", "piece", "pen", "mic", "spec", "quad", "pin", "config", "xi", "cus", "style", "sync", "cy", "typ", "sys", "bi", "image", "qi", "circ", "pins", "picture", "bus", "pi", "gui", "pc", "mot", "sci", "cli", "tick", "ics", "nic", "jack", "lot", "scan", "jc", "pict", "lic", "lib", "ctx", "study", "bc", "mag", "feat", "cycle", "pass", "jp", "pres", "seq", "ic", "mini", "cpu", "doc", "console", "proc", "capt", "lc", "lin", "fc", "ku", "cache", "fi", "git", "img", "pick", "feature", "Pic"], "address_space_mem": ["machine_\n", "address_spacebootram", "address_\n", "address_spacebootmem", "address_spacebootgram", "address_pace_ram", "address_space_rm", "address_service_mem", "address_x", "address_service_mm", "address_surface___mm", "address_surface___mem", "address_surface_rom", "address_space___reg", "address_spacelmem", "address_pace_process", "address_pace_mem", "address_space_program", "address_space___mm", "address_spacealram", "address_pace_rm", "address_spacealprogram", "address_service_rm", "address_space___rom", "address_spacexmem", "address_service_mode", "address_space_memory", "address_spacealprocess", "address_surface_reg", "address_space_gram", "address_space_mm", "address_spacelmm", "address_space_loc", "address_pace_tem", "address_pace_loc", "address_space_process", "address_surface_mem", "address_pace_mm", "address_space_mode", "address_space___mem", "address_pace_memory", "machine_x", "address_pace_program", "address_surface___reg", "address_space_rom", "address_spacextem", "address_spacelreg", "address_space_tem", "address_space_ram", "address_space_reg", "address_surface_mm", "address_pace_lim", "address_spacealmem", "address_spacexmm", "address_surface___rom", "address_spacebootlim", "address_spacelrom", "address_space_lim"], "ram": ["dam", "program", "pack", "rw", "hw", "arm", "mem", "iam", "vm", "lam", "sum", "sys", "ray", "image", "region", "mac", "resource", "rage", "sam", "ra", "pc", "space", "man", "mc", "micro", "gam", "sc", "cam", "rg", "gra", "disk", "sim", "ctx", "ruby", "process", "nam", "am", "memory", "mm", "core", "gram", "gem", "jam", "rum", "Ram", "RAM", "mor", "cm", "dim", "rar"], "sram": ["scam", "ssregion", "Sram", "absgram", "sescam", "sesmem", "ssmem", "fgram", "sran", "absmem", "asram", "dsmem", " siam", "dsregion", " sran", "sesregion", "Sallow", "ssrum", " sallow", " sgram", "fram", "fmem", "dsram", "asran", "sesgram", "abscam", "srum", "ssallow", " srum", "Srum", "ssiam", "siam", "ssgram", "absram", "sgram", "fcam", "Sgram", "asiam", "dsgram", "sesram", "ssran", "smem", "sallow", "asgram", "sregion", "ssram"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4217, "substitutes": {"ctxt": ["CTXT", "pttxt", "ctXT", "cfXT", "cfext", "cttxt", "CTxt", "CTtxt", "cftxt", "ptxt", "ptXT", "cfxt", "CText", "ctext", "ptext"], "ap": ["archive", "cp", "address", "hap", "bp", "ep", "al", "pa", "esp", "gap", "op", "apache", "ax", "data", "oa", "pod", "apt", "ae", "xml", "map", " sap", "apped", "AP", "attr", "snap", "aj", "arp", "aper", "av", "pac", "np", "acl", "ak", "ar", "aped", "auth", "arr", "lap", "aval", "ctx", "ape", "ab", "jp", "apper", "aps", "Ap", "p", "array", "context", "amp", "lex", "apy", "tap", "sp", "nav", "cap", "ip", " AP", "api", "tp", "apa", "ac", "ha", "app", "au", "awa", "af"], "token": ["writer", "tool", "stat", "o", "iter", "kn", "not", "annot", "parent", "note", "word", "channel", "session", "aa", "po", "quote", "object", "data", "socket", "wt", "key", "tag", "resource", "valid", "event", "offset", "child", "call", "atom", "service", "document", "tick", "number", "stop", "len", "ak", "error", "item", "target", "an", "cho", "t", "fn", "Token", "sign", "ant", "translation", "KEN", "root", "lex", "oken", "node", "rule", "tree", "type", "user", "cookie", "text", "element", "seed", "prefix"], "val": ["base", "vol", "ot", "name", "serv", "na", "v", "el", "al", "pr", "rt", "value", "pa", "x", "data", "b", "format", "elt", "op", "Val", "pt", "unit", "loc", "valid", "vals", "tx", "key", "lit", "cal", "VAL", "sl", "fl", "arg", "vale", "split", "part", "len", "ol", "aval", "lat", "ctx", "str", "p", "eval", "doc", "pos", "true", "rule", "sel", "ul", "var", "vl", "il", "label", "li", "bl", "text", "pl", "fi", "au", "ref", "pol", "cel"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline uint64_t ldq_phys_internal(hwaddr addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 4218, "substitutes": {"addr": ["dr", "rn", "layer", "vr", "x", "data", "xp", "oa", "rm", "ace", "route", "align", "len", "ar", "hop", "access", "conn", "mode", "name", "arm", "id", "spec", "config", "edge", "slice", "module", "url", "nr", "mt", "pad", "work", "amp", "usr", " address", "node", "ip", "adr", "amd", "grad", "size", "address", "rt", "md", "rc", "ad", "ext", "adder", "obj", "np", "wd", "rss", "cmd", "coord", "asm", "frame", "start", "ref", "r", "src", "add", "cmp", "rr", "ady", "dd", "alias", "inter", "offset", "attr", "ack", "part", "rx", "pointer", "ord", "host"], "endian": ["endedip", "engator", " endians", "endator", "enerian", "endsians", "endedians", " endius", "endius", "engian", "endedian", "engip", "endip", "enerial", "enerius", "endial", " endial", "endsial", "endians", "endedator", "endsius", "endsip", "enerians", "endsian", "endsator", "engians"], "ptr": ["address", "dr", "cmp", "buff", "rt", "pr", "pend", "eth", "plug", "tr", "rc", "slice", "inter", "pe", "pt", "loc", "peer", "buf", "offset", "attr", "length", "pc", "py", "handle", "ctr", "td", "kt", "code", "len", "point", "buffer", "rect", "inst", "arr", "driver", "butt", "ctx", "pad", "p", "Ptr", "uint", "eval", "alloc", "pointer", "pos", "proc", "bf", "fd", "type", "br", "adr", "pair", "cod", "src", "ref", "pb", "r", "index", "grad", "dim", "cel"], "val": ["serv", "play", "el", "a", "x", "b", "data", "style", "unit", "arg", "len", "all", "pass", "err", "ver", "sel", "li", "slot", "base", "pid", "al", "count", "value", "lt", " data", "pt", "valid", "vals", "cal", "sl", "it", "ol", "lib", "ctx", "win", "ee", "eval", "fail", "util", "test", "end", " Val", "vol", " ret", "reg", "rt", "alt", "vel", "loc", "key", "db", "VAL", "obj", "pc", "py", "dev", "p", "ind", "ref", "fat", "ret", "v", "pre", "format", "Val", "live", "l", "call", "part", "aval", "result", "cond", "bl"], "section": ["sub", "patch", "address", "option", "function", "script", "fat", "area", "sec", "journal", "entry", "parent", "shadow", "component", "session", "config", "sect", "layout", "setting", "environment", "data", "slice", "module", "loc", "region", "key", "ion", "package", "sections", "sector", "child", "version", "server", "mod", "description", "service", "vision", "small", "member", "part", "cell", "sc", "six", "connection", "division", "se", "comment", "storage", "instance", "container", "search", "character", "root", "network", "ner", "sel", "location", "Section", "lc", "core", "ment", "pair", "site", "account", "set", "group"]}}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "func": "void main_loop_wait(int nonblocking)\n\n{\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n    int timeout;\n\n\n\n    if (nonblocking)\n\n        timeout = 0;\n\n    else {\n\n        timeout = qemu_calculate_timeout();\n\n        qemu_bh_update_timeout(&timeout);\n\n    }\n\n\n\n    os_host_main_loop_wait(&timeout);\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    qemu_run_all_timers();\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "idx": 4221, "substitutes": {"nonblocking": ["notblocking", "nonlinear", "notblock", " nonlocking", "Nonblock", " Nonblock", " Nonblocking", " nonblock", "notlinear", "notlocking", " Nonlocking", " Nonlinear", "nonlocking", "nonblock", "Nonblocking", " nonlinear", "Nonlocking"], "rfds": ["rfdds", "xfda", "fwds", "refdb", "fys", "rafdb", "RFdds", "fDS", "rfDS", "rbdd", "sfds", "sfdds", "refds", "lfys", "alfDS", "alfds", "rfda", "xfys", "rfdd", "rfdb", "alfdb", "xfd", "rbdb", "refd", "fda", "rfrs", "xfDS", "rafd", "fdds", "rafds", "RFrs", "alfda", "lfds", "sfda", "xfdd", "frs", "xfdb", "lfd", "lfDS", "rbds", "refdd", "fwdds", "RFda", "rfd", "RFd", "sfd", "rafdd", "fds", "fd", "fwrs", "fwd", "rbd", "RFds", "RFys", "rafda", "rfys", "sfys", "rafDS", "rbDS"], "wfds": [" wfsrs", "wcfdds", "wrfdds", " wfsda", "wcfrs", "wfsda", "wxfds", "swcfrd", "wfcs", "wwxfks", "wfsrd", "wFdds", " wfys", "wwfks", "wrfns", "wdfcs", " wfns", " wfda", " wfsys", "wrfys", "wfays", "wfscs", "wfrs", "wfys", "wtfdds", "wsfys", "wdfords", "swfdds", "wwfords", " wfsds", "wfda", "wsfds", " wfays", "wFds", "wfrd", "wcfds", "swcfys", "wdfds", "wrfays", "wxfays", "wrfrs", "wdfks", "wfsks", "wsfdds", "swfys", "wxfdds", " wfsdds", "wrfds", "wfsys", "wfords", "wfsays", "wFys", "wwxfds", "wxfcs", " wfsays", "wxfys", " wfrd", "wwxfords", "wfsords", "wtfys", "wwfds", "wfsrs", "swfrd", "wfks", " wfdds", " wfrs", "wrfda", "swfds", "wxfks", "wfsds", "wfdds", "wcfns", "swcfdds", "wcfys", "wFda", "wfns", "wsfrd", "wxfords", "wfsns", "wtfrd", "wwxfcs", " wfsns", " wfsrd", "swcfds", "wwfcs", "wfsdds", "wtfds", "wcfrd"], "xfds": ["rafdds", "xfda", "rfdds", "rafdb", "rfords", "fxdd", "rfDS", "sfds", "sfdds", "rfld", "sfDS", "rfda", "cfds", "fxld", "rfdd", "fxded", "rfades", "rfdb", "xfd", "cfades", "cfd", "cfdds", "fxords", "fxDS", "rfded", "fxd", "xfDS", "xfipes", "cfipes", "rafds", "xfld", "xfdds", "cfDS", "sfda", "xfades", "rafld", "xfdd", "xfdb", "fxds", "xfded", "xfords", "fxades", "rfd", "sfdb", "sfd", "rafdd", "fxdds", "cfords", "rfipes", "rafded", "cfda", "fxipes", "rafDS"], "ret": ["red", "iter", "rt", "mem", "alt", "count", "try", "trial", "nt", "val", "rc", "inter", "format", "reply", "status", "live", "num", " Ret", "event", "lit", "job", "att", "pet", "obj", "res", "match", "def", "round", "part", "len", "error", "det", "out", "RET", "err", "response", "rev", "result", "temp", "req", "Ret", "ft", "re", "fun", "resp", "success", "ref", "rets"], "nfds": ["Ncfns", "nsfcs", "nxfda", "wrfdds", "nfdb", "nrfnas", "Nfns", " nfcs", "ntfd", " nrfdds", "Ncfdds", "ncfds", "nfbds", "nsfdds", "nsfda", "ntfds", "nrfd", " nrfd", "Nfdds", "wrfys", "ntfdds", "ncfd", "wfd", "ncfld", "wfys", " nfda", "nfcs", "nfns", "nrfds", "nufld", "nfld", "ntfdy", "Nfdb", "ncfnas", "nfd", " nrfnas", "nrfld", " nrfcs", "ncfdb", "nfdds", " nrfda", "nrfdds", " nfdds", "nxfds", "nfdy", "wrfdy", "wrfld", "wfld", "nfbdb", "nxfdds", "nrfda", "ncfys", "wrfd", "wrfds", "Nfds", "nwds", "Ncfdb", "nrfcs", "nfnas", "nwdds", "nufdds", "nufds", "nwdb", "wfdy", "ncfns", "nufd", "nufys", "nufnas", "nfbdds", "ncfdy", "ncfdds", " nfnas", "wfdds", "nsfds", " nrfds", "nrfdy", "nfys", "nfbns", "nxfcs", "nwns", "Ncfds", " nfd", "nrfys", "nfda"], "tv": ["time", "tf", "v", "rt", "show", "vm", "tun", "channel", "tmp", "vt", "qt", "config", "up", "val", "inter", "stream", "info", "tty", "uv", "live", "window", "html", "event", "server", "youtube", "loop", "select", "td", "ev", "vi", "twitter", "timer", "dev", "t", "json", "tm", "cb", "exec", "TV", "volt", "rev", "temp", "tz", "sv", "txt", "ssl", "video", "lv", "ov", "vv", "tt", "cv", "vc", "test", "fi", "tc"], "timeout": ["option", "time", "frequency", "scroll", "block", "fee", "parent", "beta", "trial", "nt", "tun", "value", "blocking", "socket", "io", "sync", "i", "token", "unit", "window", "offset", "event", "tube", "wait", "Timeout", "limit", "server", "length", "init", "table", "period", "duration", "delay", "number", "len", "buffer", "service", "error", "clock", "out", "connection", "timer", "second", "t", "n", "interrupted", "lock", "rate", "ticket", "until", "pool", "temp", "sleep", "root", "boot", "range", "type", "slot", "tt", "cache", "seed", "size"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4253, "substitutes": {"errp": ["raisepc", "erc", "erpc", "erP", "rarr", "rarc", "raiseP", "rarp", " errlp", "raisep", "errP", "errpc", "erpb", " errP", "raiselp", " errpc", " errc", "rarpb", "err", "errlp", " errpb", "erlp", "errc", "errr", "erp", "errpb", " errr"], "bs": ["bas", "base", "kit", "as", "bp", "lb", "ib", "ins", "is", "bits", "s", "bt", "bg", "b", "bps", "sync", "abi", "ses", "bi", "its", "BS", "fb", "bes", "ns", "state", "ls", "obj", "bb", "cs", "ss", "vs", "sb", "banks", "bis", "ds", "lib", "ctx", "bytes", "bc", "ba", "blocks", "boot", "css", "gb", "fs", "os", "bos", "bid", "ps", "bl", "pb", "rs", "src", "bh"], "local_err": ["localacerr", "global_msg", "local_bug", " local_state", "localserror", "localser", "localacver", "global_err", "localacrr", " local_rr", "localserr", " local_error", "localOer", "localacer", "localOerror", "local_msg", "global_error", "local_error", " local_er", "local_rr", "localsbug", "local_er", "localOerr", "local_ver", " local_bug", " local_ver", "global_er", "localOstate", "local_state"], "it": ["stat", "bas", "axis", "ib", "It", "iter", "bin", "ins", "id", "sit", "entry", "parent", "pit", "ite", "ci", "chain", "op", "i", "edit", "bit", "in", "its", "loc", "unit", "l", "lit", "j", "init", "which", "iti", "ibl", "iterator", "ait", "mit", "section", "ant", " It", "exec", "p", "jit", "and", "start", "IT", "ind", "ip", "ul", "c", "end"], "aio_context": ["aio__ctx", "aios_support", "aiojcontext", "aio_connection", "aio_ctx", "aiojproxy", "aiojctx", "aios_config", "aios_connection", "aioacctx", "aio__context", "aio__support", "aio_proxy", "aio_version", "aioaccontext", "aios_temp", "aiojconfig", "aios_version", "aios_ctx", "aios_context", "aios_proxy", "aio_support", "aio_config", "aioactemp", "aio__connection", "aioacversion", "aio_temp"]}}
{"project": "FFmpeg", "commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "target": 1, "func": "static int parse_adaptation_sets(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    char *p = w->adaptation_sets;\n\n    char *q;\n\n    enum { new_set, parsed_id, parsing_streams } state;\n\n    if (!w->adaptation_sets) {\n\n        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 4255, "substitutes": {"s": ["o", "serv", "v", "S", "less", "http", "spec", "sg", "b", "si", "sync", "ses", "services", "m", "f", "ns", "stats", "sl", "service", "sci", "cs", "ss", "u", "e", "sc", "an", "sb", "se", "gs", "t", "ds", "n", "ts", "su", "self", "south", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "new", "rs", "r", "ps", "js"], "w": ["writer", "way", "rw", "hw", "nw", "v", "fw", "W", "wx", "wei", "a", "wave", "word", "sw", "wan", "wn", "wall", "x", "b", "ow", "wm", "wp", "widget", "wa", "wt", "m", " W", "window", "wb", "wh", "l", "f", "wo", "d", "u", "wd", "e", "we", "tw", "t", "k", "n", "wcs", "win", "self", "work", "ww", "kw", "wr", "wal", "war", "web", "h", "iw", "this", "wu", "c", "new", "g", "wl", "y", "ew", "current", "r", "aw"], "p": ["patch", "cp", "P", "pid", "bp", "python", "ep", "press", "v", "pr", "a", "pa", "pat", "pre", "po", "pp", "b", "x", "i", "op", "ping", "pe", "lp", "ap", "m", "l", "f", "pi", "post", "pg", "d", "j", "pc", "u", "np", "part", "e", "dp", "point", "per", "port", "t", "k", "n", "pad", "fp", "jp", "h", "vp", "z", "sp", "pos", "c", "ip", "g", "y", "api", "tp", "pair", "r", "ps"], "q": ["P", "name", "ch", "quick", "iq", "v", "id", "qq", "count", "qt", "x", "i", "pe", "queue", "m", "qi", "quant", "ix", "l", "cl", "f", "post", "ue", "dq", "d", "eq", "ph", "u", "e", "sh", "depth", "que", "port", "qs", "Q", "k", "n", "t", "question", "qu", "quality", "qa", "req", "h", "z", "sp", "c", "ip", "g", "sq", "y", "query", "r", "max", "end", "quest"], "state": ["stat", "name", "ch", "o", "st", "position", "are", "al", "is", "a", "count", "cur", "parent", "id", "config", "STATE", "po", "session", "val", "style", "slice", "pe", "ate", "art", "m", "wa", "ace", "states", "tag", "resource", "key", "f", "post", "at", "private", "j", "handle", "param", "u", "part", "an", "e", "port", "t", "k", "instance", "after", "State", "err", "self", "work", "old", "un", "start", "am", "step", "rule", "new", "g", "ke", "type", "y", "pair", "current", "conn"], "mem": ["program", "hw", "Mem", "buff", "reg", "bin", "rom", "vm", "mat", "val", "sum", "bm", "mo", "m", "rm", "buf", "ram", "num", "mod", " Mem", "ph", "em", "sh", "mc", "prom", "tm", "ctx", "mi", "access", "qu", "pool", "temp", "mb", "rem", "sp", "am", "memory", "node", "ip", "mm", "im", "du", "gram", "cache", "ref", "ha", "mor", "lim", "max", "dim"], "as": ["master", "_", "a", "atts", "pas", "x", "parts", "d", "las", "bs", "all", "ar", "access", "array", "aws", "am", "acs", "sa", "var", "ams", "inas", "ac", "cas", "ast", "ass", "pack", "asu", "al", "is", "ap", "with", "was", "at", "ai", "ts", "ask", "ais", "ms", "rs", "ras", "ans", "er", "are", "ins", "nas", "mas", "ays", "als", "asts", "num", "ra", "has", "from", "cs", "action", "an", "auth", "ks", "instance", "asm", "os", "cache", "app", "r", "bas", "ance", "to", "http", "asa", "com", "modules", "alias", "AS", "ma", "ns", "args", "res", "us", "ss", "ars", "gs", "As", "ase", "seq", "this", "asc", "es"], "nb_as": ["sb_was", "num_mas", "nbllasu", "nb_asu", "nbJas", "nblockas", "nb25ase", "nb_sa", "nbNase", "nb_nas", "nb__ras", "nb_ase", "sb_asu", "nbJras", "nbllwas", "nbBmas", "sblockas", "nblockwas", "nb_an", "num_an", "sblockwas", "nbllas", "num_as", "nb__asc", "nbNan", "nb_asc", "num_ase", "sblockras", "nb25ras", "nbBas", "num_AS", "nbBras", "nb_AS", "nbllras", "sb_ras", "nb__sa", "sblockasu", "nb_was", "nb__was", "num_asc", "nb25an", "nb__as", "nblockras", "nbJwas", "sb_as", "num_ras", "num_sa", "nb_ras", "nbJmas", "nbBasu", "nbJnas", "nbNras", "nblockasu", "num_asu", "nb__AS", "nb25as", "nbNas", "nbJAS", "nb_mas", "num_nas", "num_was"]}}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}", "idx": 4256, "substitutes": {"ctxt": ["pttxt", "cttxt", "CTrt", "catext", "CTct", "nttxt", "actxt", "ptext", "ntxt", "CTxt", "actct", "ctrt", "CText", "CTert", "acttxt", "actert", "CTtxt", "ptxt", "ptx", "ctx", "ntct", "ntext", "actrt", "ctext", "actx", "ntert", "actext", "catx", "cattxt", "ctert", "CTx", "catxt", "ctct", "ntrt"], "token": ["iter", "socket", "data", "wt", "status", "track", "document", "connection", "cho", "bot", "pass", "stage", "tree", "user", "reference", "tool", "option", "name", "header", "word", "channel", "value", "pattern", "valid", "null", "atom", "tick", "number", "target", "comment", "sign", "path", "field", "node", "rule", "txt", "type", "cookie", "text", "element", "ok", "stat", "note", "po", "normal", "key", "version", "tn", "t", "lex", "variable", "start", "seed", "prefix", "o", "annot", "open", "complete", "scope", "session", "quote", "tag", "resource", "event", "attr", "call", "stop", "fn", "Token", "result", "context", "KEN", "root", "opt", "oken", "column", "request", "date"], "ret": ["base", "aug", "flag", "reg", "rt", "mem", "alt", "complete", "get", "val", "data", "format", "cat", "pret", "reply", "db", "key", "fin", "valid", "job", "lit", "ext", "att", " Ret", "url", "obj", "arg", "res", "active", "match", "def", "mt", "det", "auth", "arr", "RET", "bot", "feat", "rev", "result", "Ret", "ft", "usr", "re", "true", "fun", "hash", "gt", "utf", "success", "ref", "fi", "conn", "rets"]}}
{"project": "FFmpeg", "commit_id": "5b29af624fe8be5379fd649019a04ff44bfde04f", "target": 0, "func": "static int aac_encode_frame(AVCodecContext *avctx,\n\n                            uint8_t *frame, int buf_size, void *data)\n\n{\n\n    AACEncContext *s = avctx->priv_data;\n\n    int16_t *samples = s->samples, *samples2, *la;\n\n    ChannelElement *cpe;\n\n    int i, j, chans, tag, start_ch;\n\n    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];\n\n    int chan_el_counter[4];\n\n    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n    if (data) {\n\n        if (!s->psypp) {\n\n            memcpy(s->samples + 1024 * avctx->channels, data,\n\n                   1024 * avctx->channels * sizeof(s->samples[0]));\n\n        } else {\n\n            start_ch = 0;\n\n            samples2 = s->samples + 1024 * avctx->channels;\n\n            for (i = 0; i < chan_map[0]; i++) {\n\n                tag = chan_map[i+1];\n\n                chans = tag == TYPE_CPE ? 2 : 1;\n\n                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,\n\n                                  samples2 + start_ch, start_ch, chans);\n\n                start_ch += chans;\n\n            }\n\n        }\n\n    }\n\n    if (!avctx->frame_number) {\n\n        memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n               1024 * avctx->channels * sizeof(s->samples[0]));\n\n        return 0;\n\n    }\n\n\n\n    start_ch = 0;\n\n    for (i = 0; i < chan_map[0]; i++) {\n\n        FFPsyWindowInfo* wi = windows + start_ch;\n\n        tag      = chan_map[i+1];\n\n        chans    = tag == TYPE_CPE ? 2 : 1;\n\n        cpe      = &s->cpe[i];\n\n        for (j = 0; j < chans; j++) {\n\n            IndividualChannelStream *ics = &cpe->ch[j].ics;\n\n            int k;\n\n            int cur_channel = start_ch + j;\n\n            samples2 = samples + cur_channel;\n\n            la       = samples2 + (448+64) * avctx->channels;\n\n            if (!data)\n\n                la = NULL;\n\n            if (tag == TYPE_LFE) {\n\n                wi[j].window_type[0] = ONLY_LONG_SEQUENCE;\n\n                wi[j].window_shape   = 0;\n\n                wi[j].num_windows    = 1;\n\n                wi[j].grouping[0]    = 1;\n\n            } else {\n\n                wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel,\n\n                                              ics->window_sequence[0]);\n\n            }\n\n            ics->window_sequence[1] = ics->window_sequence[0];\n\n            ics->window_sequence[0] = wi[j].window_type[0];\n\n            ics->use_kb_window[1]   = ics->use_kb_window[0];\n\n            ics->use_kb_window[0]   = wi[j].window_shape;\n\n            ics->num_windows        = wi[j].num_windows;\n\n            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];\n\n            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];\n\n            for (k = 0; k < ics->num_windows; k++)\n\n                ics->group_len[k] = wi[j].grouping[k];\n\n\n\n            apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2);\n\n        }\n\n        start_ch += chans;\n\n    }\n\n    do {\n\n        int frame_bits;\n\n        init_put_bits(&s->pb, frame, buf_size*8);\n\n        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))\n\n            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n\n        start_ch = 0;\n\n        memset(chan_el_counter, 0, sizeof(chan_el_counter));\n\n        for (i = 0; i < chan_map[0]; i++) {\n\n            FFPsyWindowInfo* wi = windows + start_ch;\n\n            tag      = chan_map[i+1];\n\n            chans    = tag == TYPE_CPE ? 2 : 1;\n\n            cpe      = &s->cpe[i];\n\n            put_bits(&s->pb, 3, tag);\n\n            put_bits(&s->pb, 4, chan_el_counter[tag]++);\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]);\n\n                s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda);\n\n            }\n\n            cpe->common_window = 0;\n\n            if (chans > 1\n\n                && wi[0].window_type[0] == wi[1].window_type[0]\n\n                && wi[0].window_shape   == wi[1].window_shape) {\n\n\n\n                cpe->common_window = 1;\n\n                for (j = 0; j < wi[0].num_windows; j++) {\n\n                    if (wi[0].grouping[j] != wi[1].grouping[j]) {\n\n                        cpe->common_window = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            s->cur_channel = start_ch;\n\n            if (cpe->common_window && s->coder->search_for_ms)\n\n                s->coder->search_for_ms(s, cpe, s->lambda);\n\n            adjust_frame_information(s, cpe, chans);\n\n            if (chans == 2) {\n\n                put_bits(&s->pb, 1, cpe->common_window);\n\n                if (cpe->common_window) {\n\n                    put_ics_info(s, &cpe->ch[0].ics);\n\n                    encode_ms_info(&s->pb, cpe);\n\n                }\n\n            }\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n\n            }\n\n            start_ch += chans;\n\n        }\n\n\n\n        frame_bits = put_bits_count(&s->pb);\n\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n\n            break;\n\n        }\n\n\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n\n\n    } while (1);\n\n\n\n    put_bits(&s->pb, 3, TYPE_END);\n\n    flush_put_bits(&s->pb);\n\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n\n\n    // rate control stuff\n\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n\n        s->lambda *= ratio;\n\n        s->lambda = FFMIN(s->lambda, 65536.f);\n\n    }\n\n\n\n    if (!data)\n\n        s->last_frame = 1;\n\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n           1024 * avctx->channels * sizeof(s->samples[0]));\n\n    return put_bits_count(&s->pb)>>3;\n\n}\n", "idx": 4260, "substitutes": {"avctx": ["afca", "avmath", "AVlc", "ajlc", "afcontainer", "evcontext", "ajcontainer", "alctx", "aveloc", "aveconfig", "afctx", "evmac", "apctx", "avemath", "aveca", "ajctx", "ajcomp", "aphctx", "avecontainer", " avcontext", "avca", " avcomp", "airmac", "airctx", "afloc", "AVloc", "avecca", "avectl", "avcomp", "abcontext", "aveconn", "avecontext", "avlc", "evcu", "afmath", "avecu", "aphscope", "ajconnection", "avconnection", "aflc", "afconnection", "afctl", "avcu", "avconfig", "AVcontext", "avcca", "aircu", "aphcontext", "avcontext", "afcomp", "avloc", "alctl", "apca", "aphconnection", "avconn", "evctx", "abctx", "ajconn", "apcu", "alcontext", "avctl", "ajloc", "apcontext", "avectx", "abcca", "AVctx", "ajmath", "afscope", "avscope", "ajcca", " avloc", "avcontainer", "ajscope", "aircontext", "afconn", "afcontext", "afconfig", "alloc", "avmac", "ajcontext", "afcca", "afcu", "afmac", "abconfig"], "frame": ["game", "time", "channel", "config", "iframe", "slice", "body", "image", "Frame", "draw", "window", "event", "f", "meta", "state", "series", "document", "code", "buffer", "fram", "fps", "seq", "scale", "video", "frames", "board", "setup"], "buf_size": ["buf_capacity", " buffer_scale", "buflenscale", "buf64size", " buffer2size", " buffer2capacity", "buf64capacity", "buf2capacity", " buffer_capacity", "buf64scale", "buflencapacity", "buf_shape", "buf64shape", "buf_scale", "buf2shape", " buffer2scale", " buffer2shape", "buflenshape", "buflensize", "buf2size", " buffer_size", "buf2scale", " buffer_shape"], "data": ["function", "base", "as", "append", "na", "block", "alpha", "a", "complete", "done", "di", "dat", "session", "channel", "ada", "repeat", "slice", "final", "body", "image", "draw", "window", "results", "f", "media", "d", "DATA", "buffer", "len", "da", "message", "zip", "binary", "ata", "Data", "pad", "empty", "multi", "response", "bytes", "callback", "result", "p", "input", "array", "scale", "batch", "start", "none", "memory", "video", "sample", "cache", "partial", "next", "shift", "ui", "size"], "s": ["sf", "S", "a", "b", "support", "f", "parts", "d", "service", "bs", "conf", "self", "aws", "sa", "g", "sym", "y", "setup", "sets", "sites", "is", "services", "its", "states", "server", "ls", "sc", "ops", "ds", "ctx", "ts", "eps", "sv", "fs", "sq", "ms", "rs", "stat", "as", "ins", "sg", "comments", "sync", "ses", "sci", "cs", "u", "sis", "e", "sb", "ks", "secondary", "t", "qs", "p", "c", "os", "ssl", "r", "ps", "v", "http", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "args", "series", "space", "us", "ss", "gs", "full", "n", "su", "this", "params", "es", "js"], "samples": ["sounds", "namples", "tannels", "issannels", " sframes", "Sample", "dources", "insubs", "nubs", " sclasses", "chummies", "insummies", "issamples", "tounds", "inannels", "samps", "Sannels", "laces", "sannels", "damples", "inones", "pources", "Samps", "tummies", "lamps", "channels", "chclasses", "nummies", "nases", "lamples", "lourses", " sample", "chubs", "slannels", "Samples", "chides", "Sources", "summies", "pamps", "tamples", " sannels", "champles", "sclasses", "lample", " sides", "slamples", "nannels", "pamples", "issample", "saces", "chones", " sourses", "chases", "subs", "slummies", "issframes", "inases", "lannels", "slounds", " summies", "sources", "sframes", "nample", "damps", " saces", "pannels", "inamples", "sides", "dannels", "sones", "insannels", " sounds", "Sframes", "namps", "insamples", "sample", "sases", "nones", "sourses"], "samples2": ["yamples2", "Samples2", "samples42", "nannels\n", "sacters42", "sannels\n", "samples1", "sacters1", "ssamps42", "sannels02", "ssamples2", "samps2", "sannels2", "yocks1", "socks2", "Samples02", "Samples1", "samps52", "sampsdata", "namplesdata", "sages52", "socks52", "samplesTwo", "ssamps2", "yamples52", "sagesTwo", "sannels42", "ssamples42", "ssamples1", "Sannels02", "samps\n", "socksTwo", "sacters2", "sages1", "sannelsdata", "samples52", "samps42", "namples\n", "yocksTwo", "yamples1", "samps02", "samplesdata", "socks1", "sampsTwo", "samps1", "sages2", "Sannels1", "sannels1", "yamplesTwo", "nannelsdata", "Sannels2", "yocks52", "yocks2", "ssamps1", "samples02"], "la": ["lang", "layer", "ea", "local", "ka", "wave", "wa", "avi", "loc", "lag", "l", "vals", "cl", "ma", "ls", "wat", "lo", "da", "arr", "lu", "qa", "wal", "kl", "capt", "lc", "li", "ha", "au", "mu"], "cpe": [" cpes", "arcpe", "Cpe", "cfe", "Cene", "pple", "Cpes", "pme", "cme", " cke", "Cple", "Cme", "acpes", "pke", "pene", "arcene", "acke", "arcple", "cple", "cpy", "acpe", "Cke", "pfe", "acpy", "cpes", " cpy", "cene", "Cfe", "ppes", "acme", "acfe", "ppe", "ppy", "cke", " cfe", "arcke"], "i": ["gi", "r", "name", "ch", "v", "id", "I", "is", "di", "ci", "ik", "ki", "ji", "ni", "b", "x", "si", "xi", "io", "slice", "ri", "info", "bi", "m", "in", "qi", "ix", "l", "key", "f", "pi", "yi", "phi", "d", "ii", "iu", "it", "ai", "init", "my", "u", "e", "code", "uri", "ori", "n", "multi", "mi", "ini", "ie", "p", "source", "z", "eni", "start", "c", "ip", "im", "g", "y", "type", "api", "li", "inner", "fi", "index", "zi", "min", "ui"], "j": ["jet", "fr", "ch", "o", "v", "el", "pr", "oj", "jl", "ji", "b", "x", "m", "pt", "kj", "l", "key", "f", "job", "d", "ij", "ii", "q", "aj", "length", "part", "e", "jen", "w", "J", "jan", "jc", "n", "uj", "jp", "jo", "ie", "p", "jit", "h", "z", "jj", "c", "ind", "g", "y", "ja", "br", "dj", "li", "adj", "syn", "index", "r", "js"], "chans": ["cheants", "hats", "ichats", "chases", " chases", " chan", "chars", "echants", "ichunks", "chats", "schases", "hannels", "cheases", "echan", " channels", "chants", "chas", " champs", "shunks", "chanes", " chants", "channels", "cheans", "shants", "shanes", " chunks", " chars", "ichans", " chatches", "cheats", "cheas", "shats", "shans", "schans", "ichants", "hans", "ichannels", "ichanes", "Chan", "shases", "ichases", "schatches", "schamps", "chatches", "champs", "echannels", "chunks", " chats", " chas", "Channels", "ichatches", "shas", "schats", "chan", "echans", "echars", " chanes", "cheamps", "Chars", "echats", "ichamps", "Chans", "hants"], "tag": ["patch", "stat", "lang", "dr", "row", "reg", "ag", "block", "word", "session", "bug", "gap", "use", "Tag", "tags", "bit", "cat", "ad", "co", "token", "real", "loc", "brand", "key", "attr", "TAG", "length", "mod", "ack", "bad", "atom", "big", "match", "tick", "code", "category", "comment", "field", "feat", "year", "batch", "par", "style", "doc", "ver", "attribute", "rule", "g", "capt", "type", "product", "user", "class", "month", "ban", "test", "r", "date", "min", "tail", "feature"], "start_ch": ["start64chi", "start67sch", "start_ich", "start_ci", " start_ech", "start_cher", "start67ch", "Start_ch", "start64ach", " start_ci", "startJch", "start_k", "start_Ch", "start_chan", "art_ch", "Start_che", " start_cher", "start64chan", " start_Ch", "startJich", "art_chan", "Start_k", " start_zh", "start_sh", "art67sch", "start_zh", " start_sch", "start64ich", " start_ach", " start_sh", "start_chi", "art67cho", "start67chan", "startJzh", " start_cor", "art_sch", "start_cor", "art_cho", "Start_chn", "start_che", "start_cho", "start_sch", "art67ch", "start_ech", "startJchan", "art67chan", "start67cho", " start_ich", "start_chn", "start_ach", " start_chan", "start64ch", " start_chi"], "chan_map": ["chan_pad", "chan_pos", "channel_cache", "chan_default", "chan2MAP", "chanDdefault", "chan_MAP", "chan_block", "chanNblock", "chanDmaster", "chanNmap", "channel_master", "chan_pool", "chan_cap", "channel_map", "chanLpool", "chan_master", "channel_maps", "chanOmap", "chanLmaster", "chanLstream", "chanNconfig", "chanOMAP", "ch_map", "chan_config", "channel_pool", "chan_stream", "chan2maps", "ch_pos", "channel_stream", "ch_config", "channel_meta", "chan_list", "chan_cache", "chan_maps", "ch_block", "chanNpos", "channel_cap", "chanOmaps", "chanLdefault", "chan_meta", "chanOcache", "chanLmap", "channel_list", "chanOmeta", "channel_default", "chanDmap", "chanOpad", "channel_MAP", "channel_pad", "chanOlist", "chanLcap", "chanDcap", "chan2map", "chan2meta"], "chan_el_counter": ["chan_el6info", "chan_list_trace", "chan_el_info", "chan_el6counter", "chan_el6trace", "chan_el_seq", "chan_list_info", "chan_el6seq", "chan_list_seq", "chan_list_counter", "chan_el_trace"], "windows": ["views", "wx", "nas", "ows", "Windows", "features", "mas", "list", "x", " window", "rows", "wa", "details", "window", "vals", "ma", "codes", "images", "gui", "ints", "all", "w", "da", "n", "win", "wcs", "multi", "devices", "array", "this", "WINDOWS", "console", "wide", "acs", "new", "ms", "frames", "events", "Window", "flags"], "wi": ["gi", "rw", "ti", "wei", "wx", "mic", "di", "wic", "wan", "wid", "ni", "wa", "avi", "wt", "wk", "wb", "wo", "gui", "hea", "Wi", "wcs", "mi", "ini", "wal", "iw", "wav", "wu", "ui"], "ics": ["icc", "isi", "irc", "ris", "ig", "ico", "mic", "ik", "icons", "icks", "circ", "ips", "ix", "xs", "ns", "xes", "icing", "icon", "cs", "cons", "aic", "IC", "nic", " ic", "ops", "lic", "wcs", "bc", "ents", "ices", "ic", "css", "ica", "pic", "ICS", "acs", "ids", "igs", "isc"], "k": ["kn", "v", "ka", "ik", "b", "kk", "m", "key", "K", "sk", "dk", "d", "q", "it", "kt", "unk", "km", "ks", "n", "kw", "z", "c", "kl", "g", " K", "tk", "ok"]}}
{"project": "FFmpeg", "commit_id": "6a6bc43f5f79587b8936334cc0b3a6616f4807ac", "target": 0, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    GetByteContext gb;\n\n    GetBitContext  gb2;\n\n    int nslices, slice, slice_height, ref_slice_height;\n\n    int cur_y, next_y;\n\n    uint32_t off, slice_size;\n\n    uint8_t *Y, *U, *V;\n\n    int ret;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    nslices = bytestream2_get_le16(&gb);\n\n    off = FFALIGN(nslices * 4 + 2, 16);\n\n    if (src_size < off) {\n\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!nslices || avctx->height % nslices) {\n\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n\n                              avctx->width, avctx->height);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    ref_slice_height = avctx->height / nslices;\n\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n\n                              avctx->width, avctx->height);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y = pic->data[0];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n\n\n    cur_y  = 0;\n\n    next_y = ref_slice_height;\n\n    for (slice = 0; slice < nslices; slice++) {\n\n        slice_size   = bytestream2_get_le32(&gb);\n\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        if (slice_size > src_size - off) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n\n                   slice_size, src_size - off);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (slice_size <= 16) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n\n                   AV_RL32(src + off), slice_size - 16);\n\n        }\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n\n                             pic->linesize[0], pic->linesize[1],\n\n                             pic->linesize[2]);\n\n\n\n        Y += pic->linesize[0] *  slice_height;\n\n        U += pic->linesize[1] * (slice_height >> 1);\n\n        V += pic->linesize[2] * (slice_height >> 1);\n\n        off += slice_size;\n\n        cur_y   = next_y;\n\n        next_y += ref_slice_height;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4306, "substitutes": {"avctx": ["evconn", "avconf", "axcontext", "axloc", "afca", "ajctl", "aveci", "AVlc", "ajcomponent", "axcup", "avercontext", "avecor", "evcontext", "aveqa", "avcomponent", "avesync", " avcor", "apcf", "navcontext", "aveloc", "aveconfig", "afctx", "apconn", "apctx", "evcms", "evloc", "avqa", " avtx", "aveca", "ajctx", "avalc", "navctx", "evci", "afcor", " avcontext", "avca", "evcmp", " avca", "airctx", "ajcos", "avcor", "avalctl", "afci", "Avconn", "afloc", " avcup", "afcmp", "airqa", "avcmp", "avcos", "avalctx", "avec", "aveconf", "avercu", "aveconn", "avconsole", "Avctx", "avecontext", "afcf", "avlc", "axctx", "navsync", "evcu", "AVcu", " avcu", "avecu", "avalcontext", "avsync", "avc", " avcms", "navconfig", "aflc", "afctl", "evlc", "avcu", "avconfig", "AVcontext", "averctx", "avcms", "avalcomponent", " avconf", "afsync", "afconsole", "avcontext", "afconf", "afqa", "avloc", "avconn", "evctx", "afcos", "ajconn", " avcmp", "avalcos", "avctl", "aveconsole", "afcms", "apcontext", "Avcf", "avectx", "avetx", "averconsole", "AVctx", "airca", "avcf", "aftx", "afcup", "avtx", " avloc", "avecomponent", "Avcontext", "aircontext", "avcup", "afconn", "afcontext", "afconfig", "afcomponent", "ajcontext", " avconn", "avci", "avecmp", "afc", "afcu"], "pic": ["plugin", "ig", "vec", "bin", "piece", "pin", "quad", "config", "crop", "cus", "rc", "sync", "typ", "sys", "module", "bi", "image", "pins", "mac", "picture", "pi", "cci", "aci", "pc", "sci", "cam", "file", "pict", "fn", "lib", "bc", "feat", "fp", "jp", "cb", "cycle", "cube", "seq", "ic", "parse", "wire", "mini", "frame", "iv", "fig", "doc", "proc", "capt", "txt", "lc", "cf", "fc", "photo", "ac", "vc", "fi", "git", "chat", "img", "feature", "Pic"], "src": ["sub", "cur", "spec", "rb", "config", "rc", "data", "stream", "in", "loc", "image", "uc", "buf", "attr", "url", "sl", "sci", "split", "sc", "uri", "sb", "inst", "fn", "storage", "ctx", "cb", "fp", "filename", "source", "seq", "input", "iv", "proc", "sel", "fc", "ref", "rs", "img"], "src_size": ["ssl_date", "src_number", "slice_scale", "rc_Size", "rc_width", "share_body", " src_clean", "src_length", "src_width", "src_ize", "src_body", "ssl_size", " src_weight", "ssl_function", "src2Size", "src_function", "src_code", "rc_data", "src_scale", "src_time", "srcallsize", "share_ize", "src2size", "src2data", "src_clean", "src_data", "srcalltime", "src_date", "slice_number", "src2width", "slice_code", "rc_size", "ssl_length", "src_weight", "srcallclean", " src_time", "srcallweight", "src_Size", "share_size"], "gb": [" db", "gp", "gc", "cfg", " rgb", "gm", "hub", "nn", " eg", "ci", "sg", "ki", "rb", "Gb", "bg", "b", "gnu", "bm", "gpu", "gio", "gu", "db", "ga", " rc", "usb", "gin", "abb", "sl", "pc", "py", "cc", "bb", "xb", "gz", "byte", "mc", "sb", "gam", "gs", "rg", "storage", "ctx", "bc", "GB", "cb", "nb", "mb", "gal", "kb", "bf", "g", "gd", "lc", "gram", "fc", "gg", "cv", "cm"], "gb2": [" buffer2", " gcc2", "g2"], "nslices": ["linslices", "nscilores", "nslicences", "outseales", "nsqlences", "onsplees", "nsligises", "nslaes", "nsligops", " nsucitions", " nslicences", "nsucences", "nscilales", "lsciales", "linsaulals", "onslicees", "outslaese", "onslices", "nsquees", "nsplences", "outslicets", " nsucES", "nameslicences", "nsealets", "nameslicores", "nslinences", " nslicES", "nsuces", "nslaions", "nslipets", "Nslices", "outslicions", "nslicees", "nscies", "nslipops", "nsaulales", "nsclises", "nsplales", "lslicists", "nsciees", "outslaences", "nsliges", "lslices", "nslinees", "namesqueences", "nsigets", "Nslicops", "nsealES", "nslicops", "nsquores", "nsigitions", "onslicals", "nameslices", "nsigES", "outslaions", "nsclops", "nslicets", "nsqles", "nsples", "nsciES", "onslicES", "nsaules", "nsealitions", "linslicals", " nsucences", "Nslicises", "namesqueales", "outslaes", "nsucES", "nsealences", "lsciists", "linslicales", "nslinets", "nslines", "nsqlese", "nslicales", "linsaulales", "nslicese", "nsligets", "nameslicales", " nslicitions", "nslicitions", "nsqueences", "nsqlions", "onsplES", "lslicions", "nsligists", "Nslipises", "nsques", "nscanales", "nsquales", "nsqueores", "nslicions", "nsaulals", "nscials", "nscles", "nslaese", "nslicals", "nsciles", "Nslicets", "nslinals", "linslicences", "nscanences", "nsplists", "nslipises", "nsplions", "nsealions", "namesquees", "nsiges", "nsclets", "nseales", "nsligales", "nsciales", "nslipes", "Nslipops", "nslicores", "nsucitions", "outsealies", "nsaulences", "nslinES", "outslicences", "nslicists", "linsaulences", "nslinies", "outslicese", "nsigies", "nsplees", "nsciists", "nsligions", "lslicales", "Nslipets", "outsealences", "onsples", "lscies", "nslicises", "Nslipes", "outslicies", "nsealies", "nslaences", "nsigences", "nscilences", "nsealese", "nscanals", "onsplals", "nsqueales", "namesqueores", "linsaules", "nslicES", "outslices", "nsplES", "outsealets", "nsciions", "lsciions", "nscanes", "nsquences", "nsplals", " nsuces", "nslicies"], "slice": [" slicing", "layer", "position", "diff", "trial", "shape", "edge", "single", "crop", "i", "pe", "blade", "image", "unit", "region", "loc", "live", "missing", "route", "offset", "player", "ii", "sl", "sci", "service", "split", "pie", "part", "len", "uri", "zip", "fit", "volume", "instance", "ski", "mi", "source", "ie", "scale", "ice", "pick", "pocket", "pos", "multiple", "node", "range", "slave", "sq", "video", "li", "sample", "inner", "hole", "dim", "shift", "seed", "slot"], "slice_height": [" slice_width", " slice_head", "slice_data", "slice\u00b7size", "slice_head", " slice_weight", "slice_weight", "slice\u00b7head", "slice_width", " slice_data", "slice\u00b7height", "slice\u00b7width"], "ref_slice_height": ["ref_slot_size", "ref_scale_height", "ref_slice_width", "ref_slot_height", "ref_slot_dim", "ref_scale_width", "ref_slice2depth", "ref_scale_length", "ref_slot_depth", "ref_slot_width", "ref_slice_size", "ref_slice2height", "ref_slice2size", "ref_slice2width", "ref_slice_depth", "ref_slice_length", "ref_slice_dim", "ref_slice2length", "ref_scale_size"], "cur_y": ["fer_y", "curOnz", "next_z", "curJz", "ferAllx", "curOny", "ferAllz", "curAlly", "nextJy", "curJx", "fer_yn", "ferAlly", "fer_x", "cur_x", " cur_z", "cur_yn", " cur_x", "curOnny", "next_x", "curJny", "nextJY", "curAllz", "fer_z", "cur_z", "nextJx", "curJyn", "curAllyn", "ferAllyn", "cur_Y", "cur_ny", "curJy", "nextJz", "next_Y", " cur_ny", "curOnx", "curJY", "curAllx"], "next_y": ["nextJya", " nextJy", " next_ya", "next_yl", " next_x", " nextJY", "next_yd", "post_ys", "nextWys", " nextPy", "nextWy", " nextJyl", "nextPya", "next_ya", "nextOney", "nextOneys", "nextOnery", "post_ry", "nextJy", " nextPx", "nextPy", "nextXy", "nextWry", "nextWyd", "nextXya", " nextJx", "next_ry", "nextPY", "nextOneyd", "next_ys", "nextXY", "next_x", "nextJY", " next_yl", "nextJx", "post_yd", " nextPya", " next_Y", " nextPY", "next_Y", "nextPx", "post_y", "nextJyl", "nextXx"], "off": ["flow", "o", "SIZE", "extra", "block", "open", "alt", "value", "eff", "offs", "op", "non", "style", "shift", "now", "bit", "ON", "unit", "region", "valid", "num", "offset", "ext", "obj", "length", "ack", "small", "original", "def", "len", "down", "error", "online", "out", "dev", "raw", "after", "feat", "own", "of", "load", "old", "output", "pos", "Off", "OFF", "new", "type", "ip", "orig", "back", "half", "ord", "ref", "front", "no", "on", "end", "ff", "low"], "slice_size": ["slot_ize", "slice_ize", "slice_unit", "sample_size", "slice_loc", "slice_length", "sample_height", "archive_length", "sliceingunit", "archiveingunit", "slice_sized", " slice_loc", "slice\u00b7size", "slot_sized", "slice_storage", "slice\u00b7sized", "archive_unit", "slice_width", "slot_width", "sliceingsize", "archiveingsize", " slice_sized", "sample_storage", "archive_size", "slice\u00b7loc", "sample_SIZE", "sliceinglength", "archiveinglength", "slice_SIZE", "slot_size"], "Y": ["H", "D", "ID", "P", "IP", "I", "S", "W", "CI", "M", "YY", "C", "API", "G", "N", "MI", "SH", "UV", "Q", "A", "GB", "B", "IX", "R", "y", "type", "X", " y", "PI", "T", "CH", "Z", "F"], "U": ["D", "IL", "P", "UC", "I", "S", "W", "M", "O", "C", "UD", "G", "N", "OU", "u", "UL", "L", "UV", "Q", "LU", "A", "B", "UT", "US", "R", "UR", "X", "UU", "T", "UI", "UN", "F"], "V": ["H", "D", "Vi", "NV", "P", "VI", "VA", "v", "W", "S", "I", "M", "C", "G", "VC", "N", "VT", "E", "J", "L", "UV", "Q", "VW", "B", "GV", "TV", "R", "X", "T", "VD", "VL", "F"], "ret": ["red", "reg", "rt", "id", "mem", "alt", "nt", "value", "rot", "val", "data", "cat", "info", "reply", " RET", "num", " Ret", "lit", "fin", "ext", "att", "f", "arg", "res", "bad", "match", "def", "code", "len", "det", "out", "arr", "en", "RET", "result", "Ret", "re", "fail", "fun", "back", "success", "ref", "rep", "aux", "no", "rets"]}}
{"project": "FFmpeg", "commit_id": "6ebc7240606e8f1fccd2edbe4ffac150053a16cc", "target": 0, "func": "static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,\n\n                         GetBitContext *gb, SBRData *ch_data)\n\n{\n\n    int i;\n\n    unsigned bs_pointer = 0;\n\n    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots\n\n    int abs_bord_trail = 16;\n\n    int num_rel_lead, num_rel_trail;\n\n    unsigned bs_num_env_old = ch_data->bs_num_env;\n\n\n\n    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];\n\n    ch_data->bs_amp_res = sbr->bs_amp_res_header;\n\n    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];\n\n\n\n    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {\n\n    case FIXFIX:\n\n        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);\n\n        num_rel_lead                        = ch_data->bs_num_env - 1;\n\n        if (ch_data->bs_num_env == 1)\n\n            ch_data->bs_amp_res = 0;\n\n\n\n        if (ch_data->bs_num_env > 4) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /\n\n                   ch_data->bs_num_env;\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;\n\n\n\n        ch_data->bs_freq_res[1] = get_bits1(gb);\n\n        for (i = 1; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];\n\n        break;\n\n    case FIXVAR:\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_trail + 1;\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        for (i = 0; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);\n\n        break;\n\n    case VARFIX:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    case VARVAR:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        if (ch_data->bs_num_env > 5) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    }\n\n\n\n    if (bs_pointer > ch_data->bs_num_env + 1) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR,\n\n               \"Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\\n\",\n\n               bs_pointer);\n\n        return -1;\n\n    }\n\n\n\n    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;\n\n\n\n    ch_data->t_q[0]                     = ch_data->t_env[0];\n\n    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];\n\n    if (ch_data->bs_num_noise > 1) {\n\n        unsigned int idx;\n\n        if (ch_data->bs_frame_class == FIXFIX) {\n\n            idx = ch_data->bs_num_env >> 1;\n\n        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR\n\n            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);\n\n        } else { // VARFIX\n\n            if (!bs_pointer)\n\n                idx = 1;\n\n            else if (bs_pointer == 1)\n\n                idx = ch_data->bs_num_env - 1;\n\n            else // bs_pointer > 1\n\n                idx = bs_pointer - 1;\n\n        }\n\n        ch_data->t_q[1] = ch_data->t_env[idx];\n\n    }\n\n\n\n    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev\n\n    ch_data->e_a[1] = -1;\n\n    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0\n\n        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;\n\n    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1\n\n        ch_data->e_a[1] = bs_pointer - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 4307, "substitutes": {"ac": ["oc", "gc", "anc", "ag", "Ac", "acc", "cus", "rac", "enc", "auc", "ad", "mac", "inc", "soc", "pc", "ack", "cc", "jac", "arc", "tc", "acl", "mc", "cam", "dc", "iac", "fac", "bc", "cms", "cu", "ic", "AC", "ca", "ec", "acs", "am", "c", "cit", "vc", "cache", "aux", "af"], "sbr": [" shr", "spr", "wspr", "jsbr", "sBR", "shr", " sBR", "lfr", " spr", " sper", " sfr", "wsBR", "ansbr", "jsfr", "anspr", "wshr", "sbre", "jsper", "lbre", "jsbre", " sbre", "anshr", "sfr", "lbr", "sper", "wsbr", "lper", "ansBR"], "gb": ["game", "gp", "cgi", "gc", "cfg", "buff", "gm", "hub", "bd", "rb", "bg", "gnu", "bm", "gom", "db", "gu", "ga", "usb", "abb", "gin", "pc", "gz", "bb", "py", "eb", "hm", "sb", "gam", "rg", "gs", "storage", "ctx", "bc", "GB", "cb", "nb", "mb", "ogg", "gy", "kb", "ge", "g", "bf", "gd", "gt", "gram", "gg", "cm", "ui"], "ch_data": ["ch_master", "ch_ata", "chackresult", "archmmodule", "ch8ata", "ch_ad", "cherpmissing", "cha13data", "arch_da", "chackmissing", "cha_model", "ch_script", "cha_method", " ch_info", "chocdat", "dev_DATA", "echmmissing", "achacwindow", "cha_writer", "chkdat", "archkda", "ch6method", "chappdata", "chkdata", "chlexwriter", "ch5ata", " ch_database", "cha13method", "ech_manager", "chPtemplate", "ch8master", "chirmata", " chAdata", "ch1data", "chackinfo", "che_data", "devalltemplate", "cha_loader", "chaymanager", "enchackresult", "chayresult", " chAreader", " chAinfo", "chpthis", " chCthis", "devallthis", "chpwriter", " ch_reader", "chaymissing", "ch6data", "chCthis", "chappsite", "ch_writer", "cha_master", "cmockdata", "chkda", "chkdiv", "chocmodel", "chstemplate", "cher_config", "chockui", "ch7layout", "che_div", "ch_ui", "ch7template", "cha7session", "chingdatabase", "echmresult", "ch6ata", "cha7loader", "chPad", "ch5ui", "ch5result", "challdata", "chpmissing", "cha8ata", "ch_site", "chmmissing", "ech_missing", "chnPad", "ch5missing", "cm_batch", "chPconfig", "ch_loader", "chip5data", "cy_ata", "chip_entry", "chMda", "cher_missing", "dev_data", "ch5batch", "ch7session", "chnPdata", "chMdata", "chsdat", "arch_module", "cha13site", "enchackmanager", "chingthis", "unch_module", "ach_dat", "chCmodel", "cy___data", "devallDATA", "cy_style", "chirmdata", "ach_window", "cm_data", "arch_template", "ch___method", "ch_parent", "unchirmaction", "ch_this", "che_Data", "ach_data", "chlexdatabase", "chip5info", "ch_method", "chappdat", "ch_style", "chocda", "ch_info", "chmdata", "ch8data", "ch8style", " chCmodel", "chMscript", "arch_dat", "cmockbatch", "chn_ad", "cha_pos", "chtdat", "dev_this", "ch_Data", "ch13method", "ch_la", "cherpdata", "ch5info", "arch_model", "chtmodule", "archmtemplate", "chacdata", "ch7model", "cher_dat", "ch_batch", "ch_entry", "cher_data", "chirmentry", "echmmanager", "cy_method", "echmdata", "chMinfo", "ch_database", "chacthis", "ch7result", "ch___config", "ench_result", "cy___method", "chklayout", "chCmanager", "arch_data", "chpconfig", "chPdat", "achacdata", "chn_dat", "echmdat", "unch_script", "chacdatabase", "cha_results", "ch13data", "cmockui", "ech_info", "cy___ata", "chmtemplate", "chsData", "ech_dat", "enchackmissing", "chmdat", "unch_da", "chn_data", "chAinfo", "chaocdata", "ch___ata", "ch6loader", " ch_model", "unchirmmodel", "chMdat", "chirmmodel", "ch1dat", "chappmethod", "chPresults", "ench_data", "chpdat", "chCdat", "chmresult", "archkmodel", "ch1site", "chocresults", "cm_ui", "chMmanager", "unchirmdata", "chktemplate", " ch_writer", "chirmaction", "chnPthis", "archmdat", "chaocresults", "ech_data", "chksession", "chnPdat", "unch_data", "chip_data", " ch_parent", "chirminfo", "archmdata", "chkmodel", "chsdiv", "ch_module", "ch_model", "chfaction", "cha_dat", "challtemplate", "cha_session", "ch_results", " chingdata", "ch_manager", "challpos", "chirmmodule", "cha_style", "chtdata", "chip_ata", "challDATA", "chAwriter", "chacparent", "chappmodule", "ch_div", "chkresult", " ch_layout", "cha8data", "ch7this", " chingdatabase", "ench_missing", "chCdata", "cy_data", "ch6session", "ench_manager", "ch_da", "cherpconfig", "ch7loader", "cha8style", "ch5manager", "ch_pos", " chCdata", "chip_info", "chAreader", "cy___style", "achacdat", "ch_config", "ch1method", "choctemplate", "ch7DATA", "ch13site", "cha_ata", "unch_action", "chappwindow", "chsdata", "unchirmmodule", "chingdata", "dev_template", "chaydata", "ch6style", "ch5data", "chockbatch", "chip5ata", "challreader", "challwriter", "ch___missing", "chkData", "chPmodel", "chaocdat", "cha7model", "ch5entry", "chn_this", "ch_dat", "enchackdata", "chlexata", "ch___style", "chmmanager", "ach_la", "chkloader", "chlexdata", "chackwriter", "challinfo", "ech_result", "chPda", "cha_data", " chAwriter", "chacla", "chminfo", "chapptemplate", "chCinfo", "devalldata", "chocdata", " chCwriter", "cha7data", "chPmissing", "ch_missing", "chfdata", "achacla", "chfmodel", "ch_session", "chappla", "chingparent", "chockthis", "chPdatabase", "ch_DATA", "chfmodule", "ch7data", "archktemplate", "challmodel", "ch_action", "cherpdat", " ch_result", "ch1ad", "unch_model", "ch___dat", "chmmodule", "challthis", "cha8master", "ch5this", " chingparent", "chpdata", "chsresults", "ch_result", "cha_site", "ch6model", "chockdata", "chlexentry", "ch13dat", "chAdata", "ch_template", "chackdata", "cha13dat", "chCwriter", "echminfo", "chMdatabase", "chip5entry", "cmockthis", "chackdatabase", "chPdata", "chpmodel", " ch_this", "chaoctemplate", "unch_database", "chacwindow", "ch_reader", "chPparent", "chPthis", "ch___data", " chingthis", "archkdata", "chackmanager", "chacdat", "cha_template", "chlexinfo", "ch_window", "che_dat", "chttemplate", "ch1this", "cm_this", "ch_layout"], "i": ["I", "di", "ci", "xi", "x", "b", "data", "bi", "gu", "f", "pi", "d", "ii", "oi", "g", "y", "li", "fi", "index", "zi", "gi", "ti", "id", "count", "ki", "ji", "slice", "abi", "info", "ix", "phi", "it", "ai", "ami", "uri", "field", "mi", "ini", "ie", "z", "ip", "ui", "counter", "ni", "ri", "io", "key", "yi", "j", "cli", "u", "e", "k", "source", "p", "start", "hi", "c", "mu", "o", "v", "si", "m", "in", "qi", "l", "iu", "init", "n", "multi", "jit", "eni", "inner", "min"], "num_rel_lead": ["num_rev_tail", "num_relslead", "num_relsleader", "num_rel_tail", "num_rel_edge", "num_rel_Lead", "num_rel_goal", "num_revsleader", "num_reltedge", "num_relsedge", "num_relsLead", "num_relsleading", "num_rev_lead", "num_rel_leader", "num_revsedge", "num_rel2leading", "num_rel_leading", "num_reltleader", "num_relinggoal", "num_rel2Lead", "num_revslead", "num_revstail", "num_rev_edge", "num_relstail", "num_rel2lead", "num_relinglead", "num_relingtail", "num_rev_leader", "num_relttail", "num_reltlead"], "num_rel_trail": ["num_rel_railing", "num_rel_protiling", "num_rel_protil", "num_rel_triill", "num_rel_protrail", "num_rel_protill", "num_rel_triiling", "num_rel_trarail", "num_rel_rarail", "num_rel_rail", "num_rel_triil", "num_rel_raill", "num_rel_traill", "num_rel_trirail", "num_rel_trailing"]}}
{"project": "qemu", "commit_id": "45b339b18c660eb85af2ba25bfcaed5469660d77", "target": 0, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.result;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.result;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,\n\n                                                    async->td);\n\n            return TD_RESULT_NEXT_QH;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);\n\n    return TD_RESULT_COMPLETE;\n\n\n\nout:\n\n    /*\n\n     * We should not do any further processing on a queue with errors!\n\n     * This is esp. important for bulk endpoints with pipelining enabled\n\n     * (redirection to a real USB device), where we must cancel all the\n\n     * transfers after this one so that:\n\n     * 1) If they've completed already, they are not processed further\n\n     *    causing more stalls, originating from the same failed transfer\n\n     * 2) If still in flight, they are cancelled before the guest does\n\n     *    a clear stall, otherwise the guest and device can loose sync!\n\n     */\n\n    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {\n\n        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);\n\n        uhci_async_unlink(as);\n\n        uhci_async_cancel(as);\n\n    }\n\n\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n", "idx": 4315, "substitutes": {"s": ["o", "is", "S", "spec", "sg", "session", "si", "sys", "ses", "m", "status", "f", "ns", "state", "sl", "ls", "service", "cs", "ss", "conf", "sis", "sie", "sb", "se", "secondary", "su", "p", "south", "sv", "fs", "sa", "os", "g", "ssl", "sq", "rs", "r"], "td": ["lang", "dh", "elt", "data", "token", "typ", "d", "det", "sd", "ht", "lc", "dt", "pb", "lf", "nd", "cd", "tf", "st", "dn", "nt", "wn", "ctl", " dd", "lt", "pt", "tif", "table", "sth", "tw", "butt", "ds", "zh", "ts", "ld", "txt", "cod", "pl", "ff", "std", "email", "md", "bd", "dat", "tmp", "dial", "ad", "BT", "th", "db", " sd", "tl", "att", "pc", "wd", "sb", "tn", "dev", "t", "tm", "cmd", "gb", "ind", "ssl", "fd", "dl", "TD", "od", "dd", "pd", "rd", "edd", "kt", "ln", "cz", "fc"], "async": ["ASync", "rassync", "asssync", "Assync", "asyn", "aynchron", "abscent", "ASynchron", "acynchronous", "rasynchronous", "assynchronous", "ASsync", "Asynchronous", "aync", "acyn", "ASyn", "ayn", "ASynchronous", "assynchron", " assync", "aynchronous", "abssync", "ascent", "rasync", "asynchronous", "acync", " asynchron", "acsync", "Async", "asynchron", "assync", "absynchronous", " ascent", "rasyn", "Ascent", "rasynchron", "Asyn", "Asynchron", " asynchronous", "absync", "assyn", " asyn"], "int_mask": ["int1ask", "const_mask", "const_ask", "const128limit", "int_sum", "int1map", "const_offset", "const_limit", "int_map", "int1mask", "int128ask", " int_ask", "const_map", "int128limit", "int64limit", "int128counter", "const128counter", " int_map", "int_limit", "int_ask", " int_sum", "const128mask", "const128ask", "const_counter", "int_counter", "int64mask", "const_hack", "int128mask", "int1sum", "int64ask", "int64counter", "int_hack", "int_offset"], "max_len": ["max33lif", "max33lang", "maxlogfail", "max64len", "min_lin", "max__fail", "max_el", " max_lif", "max33pos", "max_Len", "min_fail", "maxlogel", " max_lang", "maxlogpos", "max__len", "max_lif", "max64en", "max__lif", " max_en", " max_length", "max_pos", "max__el", "min_val", "max_lang", "maxloglen", "min_pos", " max_pos", "max__pos", "max_length", "min_len", " max_Len", "max33len", "min_length", "max64length", "max_fail", "max_lin", "min_el", "max64Len", "max_en", "max_val", "max__lang"], "err": ["cmp", "er", "cur", "rr", "spec", "progress", "mid", "exc", "sys", "attr", "res", "error", "arr", "dev", "rx", "cb", "str", "rev", "req", "mr", "ver", "proc", "fun", "ind", "resp", "cache", "conn", "msg"], "ret": ["flag", "reg", "rt", "el", "al", "alt", "mem", "cur", "nt", "pat", "pre", "rot", "lt", "val", "last", "bit", "cat", "format", "reply", "status", "db", "fin", "lit", "att", "pet", "obj", "arg", "res", "match", "def", "des", "len", "code", "det", "arr", "RET", "mi", "feat", "rl", "rev", "result", "seq", "Ret", "ft", "opt", "re", "fun", "back", "resp", "success", "ref", "fi", "rep", "group", "r", "rets", "msg"], "pid": ["plugin", "uid", "od", "bin", "id", "vid", "pin", "ci", "nt", "pa", "mid", " dd", "val", "pd", "si", "token", "sn", "perm", "pt", " proc", "ix", "db", "pi", "phi", "pri", "pet", "d", "pc", " p", " conn", "py", "sid", "len", " pin", "ds", "kid", "pad", "mi", "ticket", "p", "pty", " pos", " pc", "prop", "pos", "pointer", "proc", "ind", " id", "ip", "fd", "oid", "pron", "pb", "addr", "conn", " tid", "slot"], "as": ["ans", "act", "er", "ann", "are", "al", "is", "a", "nas", "aster", "asa", "pas", "alias", "or", "ap", "ad", "AS", "with", "was", "at", "las", "ai", "bs", "an", "ay", "ak", "ar", "asp", "action", "As", "ask", "task", "ais", "asha", "am", "acs", "sa", "os", "var", "ms", "asc", "ach", "ac", "app", "es", "ras", "ast", "ass", "aw"]}}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n", "idx": 4337, "substitutes": {"f": ["fen", "fr", "tf", "feed", "sf", "v", "s", "b", "rf", "i", "m", "fx", "l", "d", "j", "fe", "buffer", "e", "w", "file", "fn", "t", "df", "xf", "n", "fp", "filename", "p", "h", "fs", "c", "g", "fd", "fc", "fi", "r", "F", "af"], "eflags": ["eflases", "efllages", "efdlag", "efdlagg", "efdlages", "eflatts", "eflcases", "eflbags", "eblars", "efrales", "alfdlagg", "efliugs", "evllugs", "ecdlag", "evrag", "eflaags", "efplags", "efliacks", "ecloages", "efplages", "ecdlags", "efliagn", "eflinks", "evlaches", "eflaugs", "efloars", "eflcagn", "eclagn", "alflats", "eflays", "alfflages", "efslags", "efliales", "efdlacks", "efsags", "efrag", "eflbases", "eflaages", "efgags", "ecloagn", "eflcag", "eflcars", "efslats", "efflugs", "eflaats", "ecloars", "efflcases", "efflcatts", "evllag", "eclays", "eclugs", "eflugs", "efllags", "alfdlags", "efgaches", "efllats", "ecdlales", "eblacks", "efslag", "efllinks", "evlags", "eblugs", "alflages", "eflaars", "alfflugs", "efflags", "efcag", "efliays", "efloagn", "efrags", "efflatts", "efflages", "efflases", "eclags", "efgag", "ecsales", "efflcags", "alflags", "evrats", "eblags", "eclars", "eclales", "efdlugs", "alflugs", "eflag", "eflagn", "efsag", "eflcatts", "ecloags", "efslinks", "ebliugs", "eflats", "ebliags", "eflcags", "eflagg", "alfdlages", "eflales", "efsays", "efliag", "eflbatts", "evrags", "eflyats", "efliages", "evlinks", "evrinks", "ecsays", "efrinks", "eflbats", "eflyases", "efllag", "eflcugs", "evrages", "eflars", "evllages", "efdlales", "efrages", "alfdlars", "ebliacks", "efplag", "eflyatts", "efliags", "eflcages", "alflars", "eflcats", "evraches", "efflcats", "eflcales", "efrats", "eflyags", "eflaagg", "efflats", "efdlars", "eclag", "eclages", "evlugs", "efloages", "evlats", "ebliars", "efllugs", "eflaches", "eflcagg", "evllags", "alfflags", "efdlags", "ecsag", "alfflats", "efliars", "efraches", "ecsags", "efllacks", "eflages", "efcags", "efcages", "efrays", "efgages", "alflagg", "efllars", "evlages", "efcaches", "efplugs", "efsales", "efloags", "eflacks", "evlag", "ecdlugs"], "cc_op_name": ["cc_oper_str", "cc_op_path", "cc_oper_id", "cc_oper_name", "cc_op_str", "cc_op_names", "cc_op_id", "cc_oper_path", "cc_op_size", "cc_oper_no", "cc_op_type", "cc_op_no", "cc_oper_names", "cc_oper_size", "cc_oper_type"]}}
{"project": "FFmpeg", "commit_id": "612ecfbbbb3f4238d44cca5f250ffc6147d03ec2", "target": 0, "func": "static int gif_read_image(GifState *s)\n\n{\n\n    int left, top, width, height, bits_per_pixel, code_size, flags;\n\n    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;\n\n    uint8_t *ptr, *spal, *palette, *ptr1;\n\n\n\n    left = bytestream_get_le16(&s->bytestream);\n\n    top = bytestream_get_le16(&s->bytestream);\n\n    width = bytestream_get_le16(&s->bytestream);\n\n    height = bytestream_get_le16(&s->bytestream);\n\n    flags = bytestream_get_byte(&s->bytestream);\n\n    is_interleaved = flags & 0x40;\n\n    has_local_palette = flags & 0x80;\n\n    bits_per_pixel = (flags & 0x07) + 1;\n\n\n\n    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);\n\n\n\n    if (has_local_palette) {\n\n        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));\n\n        palette = s->local_palette;\n\n    } else {\n\n        palette = s->global_palette;\n\n        bits_per_pixel = s->bits_per_pixel;\n\n    }\n\n\n\n    /* verify that all the image is inside the screen dimensions */\n\n    if (left + width > s->screen_width ||\n\n        top + height > s->screen_height)\n\n        return AVERROR(EINVAL);\n\n\n\n    /* build the palette */\n\n    n = (1 << bits_per_pixel);\n\n    spal = palette;\n\n    for(i = 0; i < n; i++) {\n\n        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);\n\n        spal += 3;\n\n    }\n\n    for(; i < 256; i++)\n\n        s->image_palette[i] = (0xffu << 24);\n\n    /* handle transparency */\n\n    if (s->transparent_color_index >= 0)\n\n        s->image_palette[s->transparent_color_index] = 0;\n\n\n\n    /* now get the image data */\n\n    code_size = bytestream_get_byte(&s->bytestream);\n\n    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,\n\n                       s->bytestream_end - s->bytestream, FF_LZW_GIF);\n\n\n\n    /* read all the image */\n\n    linesize = s->picture.linesize[0];\n\n    ptr1 = s->picture.data[0] + top * linesize + left;\n\n    ptr = ptr1;\n\n    pass = 0;\n\n    y1 = 0;\n\n    for (y = 0; y < height; y++) {\n\n        ff_lzw_decode(s->lzw, ptr, width);\n\n        if (is_interleaved) {\n\n            switch(pass) {\n\n            default:\n\n            case 0:\n\n            case 1:\n\n                y1 += 8;\n\n                ptr += linesize * 8;\n\n                if (y1 >= height) {\n\n                    y1 = pass ? 2 : 4;\n\n                    ptr = ptr1 + linesize * y1;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 2:\n\n                y1 += 4;\n\n                ptr += linesize * 4;\n\n                if (y1 >= height) {\n\n                    y1 = 1;\n\n                    ptr = ptr1 + linesize;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 3:\n\n                y1 += 2;\n\n                ptr += linesize * 2;\n\n                break;\n\n            }\n\n        } else {\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    /* read the garbage data until end marker is found */\n\n    ff_lzw_decode_tail(s->lzw);\n\n    s->bytestream = ff_lzw_cur_ptr(s->lzw);\n\n    return 0;\n\n}\n", "idx": 4341, "substitutes": {"s": ["serv", "sf", "S", "a", "features", "b", "f", "parts", "state", "service", "hs", "conf", "self", "h", "aws", "g", "sym", "sets", "is", "spec", "services", "its", "states", "ls", "native", "ops", "bis", "ds", "ts", "settings", "sv", "fs", "new", "sq", "your", "site", "rs", "stat", "as", "strings", "ins", "sg", "plugins", "comments", "sync", "ses", "cs", "vs", "e", "sb", "ks", "secondary", "qs", "t", "p", "c", "os", "ssl", "ims", "r", "ps", "o", "http", "session", "si", "sys", "m", "ips", "l", "xs", "side", "ns", "stats", "us", "ss", "uns", "gs", "se", "params", "es", "js"], "top": ["master", "name", "to", "position", "padding", "middle", "platform", "parent", "wrong", "below", "x", "up", "op", "style", "bottom", "pt", "th", "dot", "offset", "client", "foo", "TOP", "icon", "Top", "upper", "leading", "stop", "high", "target", "above", "t", "bot", "lat", "lon", "hop", "temp", "tops", "sp", "toc", "tip", "front", "current", "on", "first", "size"], "height": ["dy", "thumbnails", "Height", "hd", "padding", "scroll", "alpha", "wall", "shape", "layout", "inches", "x", "up", "style", "ths", "rows", "bottom", "th", "window", "rh", "windows", "thin", "length", "upper", "center", "huge", "resolution", "high", "w", "depth", "above", "volume", "history", "lat", "quality", "h", "level", "gh", "ht", "head", "rank", "density", "max", "dim", "size"], "bits_per_pixel": ["bits_per___integer", "bits_per_char", "bits_per__inch", "bits_per\u00b7component", "bits_per_integer", "bits_per__integer", "bits_per___inch", "bits_per___pixel", "bits_per_channel", "bits_PER_channel", "bits_per_inch", "bits_per_character", "bits_PER_square", "bits_per\u00b7channel", "bits_Per_channel", "bits_per_byte", "bits_per_double", "bits_per_component", "bits_Per_component", "bits_per_chip", "bits_Per_pixel", "bits_PER_pixel", "bits_per_square", "bits_per\u00b7pixel", "bits_per__pixel"], "code_size": [" code_strength", " code_type", "code\u00b7unit", "code_type", "code___size", "code___strength", "code_unit", "code64term", "code_term", "code64type", " code64type", " code64size", "call_sized", "code_strength", "code_sized", " code_term", " code64strength", "code_shape", "code64size", "code\u00b7sized", "code\u00b7shape", " code64term", "call_unit", "code64strength", "code___type", "code\u00b7size", "code___term", "call_size", "call_shape"], "flags": ["groups", "types", "options", "strings", "files", "padding", "flag", "rules", "bits", "bands", "alls", "features", "ags", "weights", "atts", "Flags", "data", "styles", "mask", "status", "details", "states", "links", "vals", "planes", "lag", "f", "codes", "ants", "parts", "forces", "windows", "stats", "weight", "args", "fl", "lins", "ints", "vs", "fields", "ops", "seconds", "steps", "bytes", "ils", "fps", "quality", "settings", "tops", "fs", "utils", "errors", "fd", "frames", "lines", "reads", "lights"], "is_interleaved": ["is_overleeded", "is_overoleaved", "is_interluaved", "is_overoleaving", "is_interleeded", "is_interveaving", "is_interoleaving", "is_interleaveave", "is_interluaded", "is_interpleaving", "is_interoleeded", "is_interpleeded", "is_interveaved", "is_interleaveaved", "is_interoleave", "is_overoleeded", "is_interveave", "is_interlueded", "is_interpleaded", "is_interleave", "is_overleaved", "is_overleaded", "is_interleaded", "is_interluaving", "is_interveaded", "is_interleaving", "is_interoleaded", "is_overoleave", "is_interpleaved", "is_interleaveaded", "is_overleaving", "is_overoleaded", "is_interoleaved", "is_overleave", "is_interleaveaving"], "has_local_palette": ["has_local_borderze", "has_local_borderette", "has_local_pixelette", "has_local_allettes", "has_local_palnette", "has_local_borderlete", "has_local_palze", "has_local_opallete", "has_local_alette", "has_local_allnette", "has_local_opalette", "has_local_palignment", "has_local_borderettes", "has_local_pixelnette", "has_local_pixelettes", "has_local_opalettes", "has_local_allignment", "has_local_allete", "has_local_filnette", "has_local_pixelze", "has_local_pallete", "has_local_filignment", "has_local_filette", "has_local_pixellete", "has_local_palettes", "has_local_pixelite", "has_local_opalite", "has_local_alettes", "has_local_pixelignment", "has_local_palite", "has_local_allette", "has_local_filettes", "has_local_alite", "has_local_opalze"], "y": ["yy", "dy", "padding", "Y", "yo", "ny", "x", "sky", "pt", "image", "yn", "ya", "xy", "l", "speed", "f", "yi", "j", "py", "w", "yl", "t", "p", "h", "z", "level", "type"], "pass": ["yy", "rw", "row", "ep", "nn", "XX", "pin", "Y", "wn", "up", "pp", "password", "val", "wp", "pt", "sl", "pc", "py", "ss", "code", "col", "zip", "path", "win", "pos", "xx", "X", "Z", "min"], "y1": ["wone", "p1", "w2", "pone", " y2", " yone", "w1", "y2", "p2", "yone"], "linesize": ["pagesIZE", "codesIZE", "pinsizes", "pagesizing", "linesizes", "pagesizes", "linesizing", "pinsize", "pinsIZE", "codesizes", "linesIZE", "codesize", "pagesize", "pinsizing", "codesizing"], "n": ["o", "v", "nn", "nt", "ny", "b", "x", "nc", "sn", "ni", "m", "l", "num", "f", "N", "ns", "d", "j", "net", "np", "u", "len", "e", "all", "w", "pn", "t", "k", "nb", "p", "ne", "h", "network", "z", "c", "g", "cn", "r", "size"], "i": ["gi", "name", "ti", "v", "id", "I", "chi", "di", "ci", "ki", "ji", "ni", "xi", "ri", "si", "io", "ani", "slice", "x", "info", "bi", "m", "abi", "qi", "b", "ix", "l", "f", "pi", "yi", "phi", "j", "ii", "d", "iu", "it", "ai", "uli", "init", "u", "e", "ami", "uri", "multi", "mi", "ini", "p", "h", "z", "eni", "oi", "c", "ip", "li", "inner", "fi", "index", "zi", "ui"], "ptr": ["dr", "eth", "tr", "xp", "pt", "tty", "loc", "buf", "fl", "pc", "fe", "len", "sh", "inst", "arr", "port", "fp", "eps", "tile", "iv", "alloc", "pointer", "pos", "sp", "fd", "cv", "addr", "src"], "spal": ["servala", "Spals", " spala", "ppel", "Spall", "spals", "espala", " spals", "sppal", "espel", "espall", "Spala", "servaler", "isppal", "serval", " spel", "spAL", "SPal", " spaler", "instala", " spall", "SPala", "ispel", " sppal", "SPall", "ispal", " spAL", "spala", "instpal", "spaler", "ispala", "SPals", "Spal", "spall", "ppall", "servAL", "ppal", "instel", "espal", "ppala", "SPaler", "SPAL", "instal", "spel"], "palette": [" palue", "pallete", "alettes", "alment", "opalble", "Palettes", "isalettes", "pallette", " palettes", " palhole", "calette", "palhole", "fillette", "binette", "isalble", "plue", "palue", "Pallette", "binettes", "palment", "isallette", "alhole", "Pallete", "alue", "palble", "filment", "plhole", "filettes", "cellble", "binlete", "calment", "calettes", "cellettes", "Palette", "plettes", "alette", "binlette", "celllette", "cellette", "allette", "plette", "opallette", "opalettes", "isalette", "opallete", "filette", "callette", "opalette", "palettes"], "ptr1": ["buffer2", "tr1", "pointer2", "ptr2", "ptrone", "pointerone", "buffer1", "pointer1", "trone", "bufferone", "tr2"]}}
{"project": "FFmpeg", "commit_id": "43a4cb070bf7588c53fd192e8fbc71a52fa14a4c", "target": 0, "func": "static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                             int buf_size, void *data)\n\n{\n\n    AlacEncodeContext *s = avctx->priv_data;\n\n    PutBitContext *pb = &s->pbctx;\n\n    int i, out_bytes, verbatim_flag = 0;\n\n\n\n    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"input frame size exceeded\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (buf_size < 2 * s->max_coded_frame_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"buffer size is too small\\n\");\n\n        return -1;\n\n    }\n\n\n\nverbatim:\n\n    init_put_bits(pb, frame, buf_size);\n\n\n\n    if (s->compression_level == 0 || verbatim_flag) {\n\n        // Verbatim mode\n\n        const int16_t *samples = data;\n\n        write_frame_header(s, 1);\n\n        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {\n\n            put_sbits(pb, 16, *samples++);\n\n        }\n\n    } else {\n\n        init_sample_buffers(s, data);\n\n        write_frame_header(s, 0);\n\n        write_compressed_frame(s);\n\n    }\n\n\n\n    put_bits(pb, 3, 7);\n\n    flush_put_bits(pb);\n\n    out_bytes = put_bits_count(pb) >> 3;\n\n\n\n    if (out_bytes > s->max_coded_frame_size) {\n\n        /* frame too large. use verbatim mode */\n\n        if (verbatim_flag || s->compression_level == 0) {\n\n            /* still too large. must be an error. */\n\n            av_log(avctx, AV_LOG_ERROR, \"error encoding frame\\n\");\n\n            return -1;\n\n        }\n\n        verbatim_flag = 1;\n\n        goto verbatim;\n\n    }\n\n\n\n    return out_bytes;\n\n}\n", "idx": 4344, "substitutes": {"avctx": ["avca", "avsync", "afca", "aveconsole", "avcam", "avecam", "airctx", "abconn", "abloc", "afcu", "AVlc", "avectx", "aflc", "avalloc", "avalcontext", "acca", "avcu", "AVctx", "afcmp", "avalcmp", "AVcontext", "airqa", "avcmp", "avesync", "avconfig", "airca", "aveloc", "afctx", "avalconn", "abconsole", "afsync", "acqa", "abcontext", "avcontext", "avalctx", "avqa", "avalconsole", "AVcmp", "avalcu", "aveconn", "acctx", "avconsole", "aircontext", "avecontext", "afconn", "accontext", "afcontext", "avlc", "afconfig", "afcam", "avalcam", "AVsync", "AVconfig", "abctx", "AVcu", "afqa", "AVconn", "avloc", "avecu", "avecmp", "avelc", "avconn", "abconfig"], "frame": ["base", "flow", "header", "block", "channel", "config", "iframe", "slice", "image", "Frame", "sequence", "window", "fb", "f", "version", "series", "document", "fe", "code", "buffer", "point", "message", "fram", "fp", "seq", "line", "type", "video", "cf", "frames", "board", "fc", "sample", "element", "fi", "setup", "size"], "buf_size": ["buf___scale", "buf_small", "buf_sized", "off_small", "off_sized", "buf___size", "buflexSize", "buf___z", "buffer_scale", "buflexscale", "buf_z", "buffer_shape", "buf_length", "offxsize", "bufxSize", "bufxsized", " buf_length", "buflexshape", "bufxsmall", "off_Size", "buflexset", "buflexsized", "offxsmall", "off_size", "buflexsmall", "buf_shape", "buflexsize", "buf___length", "offxsized", "buf_Size", "offxSize", "buffer_set", "buf_scale", "buffer_size", " buf_z", "bufxsize", "buf_set", " buf_scale"], "data": ["base", "as", "o", "block", "v", "a", "dat", "dd", "config", "x", "slice", "rows", "b", "record", "m", "image", "body", "in", "buf", "window", "db", "f", "parts", "media", "d", "DATA", "buffer", "e", "da", "message", "raw", "binary", "ds", "sd", "Data", "p", "input", "array", "this", "batch", "reader", "xxx", "pos", "none", "c", "new", "board", "frames", "sample", "cache", "next", "es", "size"], "s": ["sf", "S", "a", "b", "support", "f", "parts", "d", "service", "bs", "conf", "self", "aws", "sp", "sa", "g", "sym", "types", "is", "spec", "info", "services", "ls", "sc", "ops", "bis", "ds", "ctx", "ts", "south", "sv", "fs", "sq", "rs", "summary", "as", "ans", "sg", "plugins", "ses", "small", "cs", "u", "e", "sb", "ks", "secondary", "t", "qs", "p", "c", "os", "ssl", "sup", "r", "ps", "o", "v", "session", "si", "sys", "m", "details", "l", "xs", "ns", "us", "ss", "gs", "storage", "n", "su", "params", "es", "js"], "pb": ["cp", "bp", "lb", "hub", "platform", "pro", "pa", "rb", "pd", "bps", "b", "pp", "bm", "wp", "lp", "fb", "buf", "wb", "uf", "pm", "db", "pg", "mp", "prot", "pc", "bs", "xb", "eb", "dp", "sb", "parser", "ctx", "bc", "PB", "fp", "cb", "jp", "ab", "nb", "p", "vp", "gb", "ppa", "proc", "bf", "bos", "api", "um", "tp", "pl", "rob", "cpp", "bh"], "i": ["gi", "ti", "v", "id", "I", "a", "di", "ci", "x", "ji", "ni", "xi", "ri", "si", "io", "slice", "abi", "info", "bi", "b", "qi", "ix", "f", "pi", "phi", "d", "ii", "iu", "j", "init", "ai", "uri", "n", "multi", "mi", "ini", "ie", "p", "z", "eni", "start", "oi", "hi", "c", "ip", "type", "li", "fi", "index", "zi", "mu", "ui"], "out_bytes": ["outFbits", " out_bps", " out_seconds", "outurelines", " out_tes", "out_tes", " out64seconds", "out__seconds", "out64bits", "outurebits", "out__bits", "in_bytes", "outurebytes", "out_seconds", "out_bits", "out_cycles", "outFcycles", "out64bytes", "in_lines", "out__bytes", "outFseconds", "outureouts", "outlextes", "out_bps", " out64bits", "out_outs", "outlexbps", " out_bits", "in_outs", "in_cycles", "outFbytes", "out_lines", "in_seconds", " out64bytes", "in_bits", "outlexbytes", "out64seconds", "outlexbits"], "samples": ["camps", "Sannels", "pipes", "sages", "sannels", "cages", " samps", "Samps", "pamps", "sipes", "cipes", "sources", " sannels", "camples", "Sages", "examps", " sources", "pages", "Sipes", "exources", "exannels", "Samples", "Sources", "samps", "examples", "pamples"]}}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360, "substitutes": {"d": ["D", "dr", "o", "od", "id", "md", "bd", "vd", "done", "rad", "dn", "dat", "di", "dd", "session", "config", "dos", "s", "b", "dh", "data", "pd", "sync", "x", "ad", "m", "dx", "draw", "l", "db", "nd", "f", "de", "ded", "td", "dom", "def", "wd", "e", "defined", "da", "dev", "driver", "ds", "sd", "t", "dc", "n", "cmd", "xd", "p", "did", "and", "ld", "c", "ind", "du", "ct", "fd", "gd", "dl", "dt", "dj", "g", "ed", "diff", "cd", "dict"], "i": ["gi", "name", "o", "ti", "v", "id", "I", "di", "ci", "ji", "ni", "x", "ri", "si", "io", "b", "xi", "info", "bi", "m", "in", "qi", "l", "f", "pi", "phi", "adi", "ii", "iu", "j", "ai", "cli", "u", "e", "ami", "uri", "t", "k", "n", "multi", "ini", "ie", "p", "mini", "eni", "oi", "ind", "c", "ip", "g", "type", "api", "y", "li", "inner", "fi", "index", "zi", "ui"], "r": ["dr", "fr", "er", "sr", "rt", "v", "rr", "rb", "b", "x", "rf", "rd", "rc", "ri", "m", "rh", "l", "ru", "f", "ir", "nr", "res", "u", "e", "w", "ar", "rg", "t", "k", "n", "rx", "err", "result", "p", "h", "R", "mr", "re", "c", "range", "g", "br", "rs", "kr"], "smram": [" smrom", "shgam", " smRAM", "smgram", "svrum", "mmrom", " smgam", "SMram", "smgam", "ymram", "sharm", "smran", " smrum", "sbmm", "sbrom", "mmgram", "SMRAM", "mmmm", "smRAM", " smgram", " smarm", "mmran", "slmm", "mgam", "SMran", "mram", "SMrum", "smrom", "svram", "slgram", "ymrum", "shrom", "slram", "ymgram", "slrom", "svgram", "ymRAM", "smmm", "mmrum", "shram", "smrum", "mrom", "marm", "SMgram", "sbram", "mmram", "smarm", "svran", "sbgram"], "smram_enabled": ["smam_led", "smram__disabled", "smam_Enabled", "smram_powered", "smrom_available", "smream_supported", "smram_enable", "smram_provided", "smrom_provided", "smrom_disabled", "smram_available", "smram_supported", "smream_enable", "smram__led", "smream_powered", "smream_enabled", "smram__enabled", "smam_enabled", "smram__Enabled", "smram_disabled", "smam_disabled", "smram_led", "smrom_enabled", "smram_Enabled"]}}
{"project": "qemu", "commit_id": "e98768d43799cd3f00b358bfbe455fdae793d3e8", "target": 1, "func": "static int vmdk_open_vmdk4(BlockDriverState *bs,\n\n                           BlockDriverState *file,\n\n                           int flags)\n\n{\n\n    int ret;\n\n    uint32_t magic;\n\n    uint32_t l1_size, l1_entry_sectors;\n\n    VMDK4Header header;\n\n    VmdkExtent *extent;\n\n    int64_t l1_backup_offset = 0;\n\n\n\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (header.capacity == 0) {\n\n        int64_t desc_offset = le64_to_cpu(header.desc_offset);\n\n        if (desc_offset) {\n\n            return vmdk_open_desc_file(bs, flags, desc_offset << 9);\n\n        }\n\n    }\n\n\n\n    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {\n\n        /*\n\n         * The footer takes precedence over the header, so read it in. The\n\n         * footer starts at offset -1024 from the end: One sector for the\n\n         * footer, and another one for the end-of-stream marker.\n\n         */\n\n        struct {\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED footer_marker;\n\n\n\n            uint32_t magic;\n\n            VMDK4Header header;\n\n            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];\n\n\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED eos_marker;\n\n        } QEMU_PACKED footer;\n\n\n\n        ret = bdrv_pread(file,\n\n            bs->file->total_sectors * 512 - 1536,\n\n            &footer, sizeof(footer));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Some sanity checks for the footer */\n\n        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||\n\n            le32_to_cpu(footer.footer_marker.size) != 0  ||\n\n            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||\n\n            le64_to_cpu(footer.eos_marker.val) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.size) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)\n\n        {\n\n            return -EINVAL;\n\n        }\n\n\n\n        header = footer.header;\n\n    }\n\n\n\n    if (le32_to_cpu(header.version) >= 3) {\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"VMDK version %d\",\n\n                 le32_to_cpu(header.version));\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                bs->device_name, \"vmdk\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n\n                        * le64_to_cpu(header.granularity);\n\n    if (l1_entry_sectors == 0) {\n\n        return -EINVAL;\n\n    }\n\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n\n                / l1_entry_sectors;\n\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n    }\n\n    extent = vmdk_add_extent(bs, file, false,\n\n                          le64_to_cpu(header.capacity),\n\n                          le64_to_cpu(header.gd_offset) << 9,\n\n                          l1_backup_offset,\n\n                          l1_size,\n\n                          le32_to_cpu(header.num_gtes_per_gte),\n\n                          le64_to_cpu(header.granularity));\n\n    extent->compressed =\n\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n\n    extent->version = le32_to_cpu(header.version);\n\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n\n    ret = vmdk_init_tables(bs, extent);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4362, "substitutes": {"bs": ["bas", "base", "lb", "ins", "s", "rb", "bt", "bg", "b", "lbs", "ses", "bi", "BS", "obs", "fb", "db", "ns", "ls", "bb", "ss", "cs", "vs", "sb", "gs", "banks", "bis", "ds", "ctx", "bytes", "bc", "ils", "ba", "css", "gb", "fs", "utils", "os", "bf", "bos", "bid", "ps", "bl", "pb", "rs", "bh", "js"], "file": ["base", "fat", "name", "fr", "layer", "files", "feed", "play", "sf", "bin", "store", "http", "entry", "channel", "bug", "b", "data", "io", "stream", "queue", "image", "File", "db", "resource", "f", "content", "state", "server", "ile", "table", "buffer", "code", "download", "comment", "port", "zip", "full", "lib", "path", "binary", "fp", "filename", "work", "fa", "lock", "source", "ca", "settings", "reader", "fs", "rule", "fd", "model", "il", "cache", "loader", "library"], "flags": ["types", "options", "nl", "fr", "files", "flag", "sf", "bits", "features", "Flags", "config", "bit", "mask", "status", " flag", "details", "vals", "FLAG", "ants", "parts", "version", "stats", "linux", " Flags", "conf", "ints", "fields", "ops", "locks", "lib", "dll", "nil", "ils", "filename", "fps", "settings", "fs", "utils", " bits", "fd", "lf"], "ret": ["flag", "el", "data", "ll", "status", "arg", "match", "code", "len", "det", "error", "arr", "RET", "pass", "err", "rl", "ft", "fun", "resp", "msg", "base", "al", "nt", "val", "art", "info", "pt", "valid", "html", "bad", "mt", "str", "usr", "fail", "back", "hash", "no", "red", "reg", "sr", "ag", "rt", "alt", "cat", "let", "num", "att", "obj", "fit", "wrap", "Ret", "run", "re", "gt", "ref", "rets", "final", "format", "reply", "lit", "mer", "res", "over", "result", "req", "bf", "success"], "magic": ["master", "stat", "base", "MAG", "domain", "padding", "extra", "chip", "intel", "count", "mic", "spec", "config", "bug", "pillar", "style", "format", "module", "info", "status", "agent", "standard", "meta", "metadata", "icon", "args", "tech", "table", "acl", "kind", "error", "depth", "parser", "binary", "cmd", "volume", "mag", "ini", "filename", "seq", "serial", "special", "mini", "reader", "xxx", "pointer", "gen", "memory", "Magic", "orig", "math", "handler", "model", "slot", "cookie", "cache", "git", "general", "journal", "generic", "command", "prefix"], "l1_size": ["l1rsize", "l1rsum", "l1_sum", "l3_length", "l1_capacity", "l3_size", "l1rlength", "l3_capacity", "l1_length", "l3_sum", "l1rcapacity"], "l1_entry_sectors": ["l1_entry_psectors", "l1_entry_vectors", "l1_entry_vegments", "l1_entry_segment", "l1_entry_psegment", "l1_entry_psegments", "l1_entry_gectors", "l1_entry_secs", "l1_entry_gecs", "l1_entry_gegments", "l1_entry_vegment", "l1_entry_psecs", "l1_entry_gegment", "l1_entry_vecs", "l1_entry_segments"], "header": ["writer", "master", "plugin", "dr", "name", "fr", "layer", "er", "flag", "block", "parent", "entry", "channel", "config", "cover", "pillar", "data", "token", "info", "module", "queue", "image", "holder", "event", "client", "offset", "player", "content", "meta", "metadata", "server", "adder", "version", "document", "table", "buffer", "code", "her", "parser", "section", "Header", "comment", "message", "driver", "headers", "container", "filename", "bridge", "reader", "h", "frame", "line", "request", "creator", "rule", "head", "handler", "cache", "index", "journal", "manager", "conn", "tail", "feature"], "extent": ["extract", "expent", "expension", "exent", "extension", "exrent", "Extent", "Extract", "Extrent", "exension", "extrent", "exract", "exprent", "expract", "Extension"], "pad": ["patch", "address", "cmp", "padding", "chip", "od", "pay", "quad", "quote", "crop", "pod", "ads", "stack", "dash", "ad", "cat", "map", "mac", "offset", "blank", "pc", "bad", "align", "push", "code", "part", "bag", "butt", "ape", "work", "ped", "scale", "amp", "dump", "ptr", "start", "cap", "cast", "Pad", "cod", "addr", "pick", "shift", "add"], "QEMU_PACKED": ["QEMU_PAACKLED", "QEMU_PADDTED", "QEMU_PUACK_", "QEMU_PACKLED", "QEMU_PAIXED", "QEMU_PAATCHLED", "QEMU_PAATCHed", "QEMU_PACKENDED", "QEMU_PAACKed", "QEMU_PADDED", "QEMU_PATCHLED", "QEMU_PACHed", "QEMU_PAACKTED", "QEMU_PATCH_", "QEMU_PATCHTED", "QEMU_PUACKENDED", "QEMU_PATCHED", "QEMU_PIXled", "QEMU_PUACKed", "QEMU_POCKING", "QEMU_PATCHENDED", "QEMU_PAACKled", "QEMU_PACHENDED", "QEMU_PACKed", "QEMU_PAIXING", "QEMU_PAACKED", "QEMU_PAIXled", "QEMU_PAATCHTED", "QEMU_PIXING", "QEMU_POCKED", "QEMU_PACKled", "QEMU_PADDled", "QEMU_PIXLED", "QEMU_POCKled", "QEMU_PIXTED", "QEMU_POCKed", "QEMU_PACK_", "QEMU_PAIXed", "QEMU_PUACKED", "QEMU_PACKTED", "QEMU_PACKING", "QEMU_PIXed", "QEMU_PATCHed", "QEMU_PACHED", "QEMU_PADDING", "QEMU_PIXED", "QEMU_PACH_", "QEMU_PAACKING", "QEMU_PAATCHED", "QEMU_PADDLED", "QEMU_PADDed"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385, "substitutes": {"control": ["master", "sub", "address", "flow", "build", "feed", "block", "pull", "http", "Control", "config", "layout", "update", "object", "sync", "controlled", "edit", "route", "holder", "null", "content", "client", "event", "server", "length", "create", "ack", "connect", "close", "error", "full", "rol", "forward", "lib", "exec", "load", "controller", "bridge", "input", "output", "respond", "protected", "follow", "hold", "rule", "off", "contract", "type", "contact", "design", "model", "core", "element", "accept", "form", "group", "command", "ctrl"]}}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n", "idx": 4389, "substitutes": {"vser": ["wsoc", "wSER", "svserver", "evcer", "vserver", "evser", "svser", "wser", " vserv", "lvsoc", "vsoc", "svserv", "vcer", "vserv", " vSER", "svsoc", "svcer", "wserver", "svSER", "lvserver", "evserv", " vcer", "lvser", "lvSER", "vSER", "evSER"], "vdev": ["voltdes", "vbus", "evser", "vdevice", "voltser", " vserv", "varser", " vdes", "vardevice", "varbus", "vserv", "voltdev", "lser", " vdevice", " vbus", "lbus", "evdev", "ldev", "evserv", "ldevice", "vdes", "voltserv", "vardev", "evdes"]}}
{"project": "FFmpeg", "commit_id": "56ee3f9de7b9f6090d599a27d33a392890a2f7b8", "target": 0, "func": "static int poll_filter(OutputStream *ost)\n\n{\n\n    OutputFile    *of = output_files[ost->file_index];\n\n    AVFrame *filtered_frame = NULL;\n\n    int frame_size, ret;\n\n\n\n    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n        return AVERROR(ENOMEM);\n\n    } else\n\n        avcodec_get_frame_defaults(ost->filtered_frame);\n\n    filtered_frame = ost->filtered_frame;\n\n\n\n    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n\n        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))\n\n        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,\n\n                                         ost->st->codec->frame_size);\n\n    else\n\n        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (filtered_frame->pts != AV_NOPTS_VALUE) {\n\n        filtered_frame->pts = av_rescale_q(filtered_frame->pts,\n\n                                           ost->filter->filter->inputs[0]->time_base,\n\n                                           ost->st->codec->time_base) -\n\n                              av_rescale_q(of->start_time,\n\n                                           AV_TIME_BASE_Q,\n\n                                           ost->st->codec->time_base);\n\n    }\n\n\n\n    switch (ost->filter->filter->inputs[0]->type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (!ost->frame_aspect_ratio)\n\n            ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n\n\n        do_video_out(of->ctx, ost, filtered_frame, &frame_size);\n\n        if (vstats_filename && frame_size)\n\n            do_video_stats(ost, frame_size);\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        do_audio_out(of->ctx, ost, filtered_frame);\n\n        break;\n\n    default:\n\n        // TODO support subtitle filters\n\n        av_assert0(0);\n\n    }\n\n\n\n    av_frame_unref(filtered_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 4411, "substitutes": {"ost": ["dr", "roc", "om", "omp", "eff", "object", "ow", "et", "stream", "owl", "obs", "oster", "hop", "boost", "\u00f3", "ft", "oper", "ond", "ct", "ov", "ast", "nd", "omm", "oc", "ocr", "st", "hyd", "nt", "word", "osi", "ous", "pod", "art", "ocl", "orb", "ott", "OST", "oop", "server", "mot", "ood", "sth", "POST", "oss", "sta", "ld", "node", "rob", "rod", "ocol", "op", "ob", "ust", "oh", "post", "org", "osta", "rss", "ist", "online", "inst", "oy", "OT", "os", "OD", "bos", "design", "tt", "add", "ot", "o", "od", "http", "dd", "opp", "tto", "rest", "iot", "rost", "iol", "ctor", "opt", "oid", "ort", "ord", "host", "lov"], "of": ["ot", "oc", "fr", "o", "to", "sf", "not", "http", "eff", "config", "ob", "object", "ow", "or", "et", "comp", "art", "orb", "de", "f", "with", "at", "alf", "org", "from", "e", "ol", "af", "df", "own", "Of", "one", "ou", "sta", "iol", "pos", "OF", "os", "off", "new", "fd", "ov", "oid", "set", "no", "on", "ast", "orf"], "filtered_frame": ["filered_frame", "filned67sample", "fillated67frame", "filbed_class", "filchedOhost", "filtered67iframe", "filcluded_frame", "filtered_Frame", "filbedUmodule", "filtered_stroke", "filtered_record", "filteredKscene", "filted_fram", "filbed_frame", "filbed_scene", "filtered67sample", "filtered67point", "filned_point", "filtered_motion", "filatted_frame", "filtered_video", "filtered_slice", "filned_frame", "filtered_frames", "filteredKrecord", "filtered__fram", "filtered00frame", "filchedOframe", "filtered_orig", "filned67feature", "filched_scene", "filteredUmodule", "filtered_iframe", "filenced_slice", "filtered_point", "filted_video", "filteredOhost", "filenced_frame", "filteredJiframe", "filteredOmodule", "filtered_element", "filted_base", "filters_frame", "fillated67boot", "filtered_boot", "filtered_line", "filtered67boot", "filtered_thread", "filters_node", "filned67frame", "filtered___filename", "filteredUscene", "filtered_module", "filned_sample", "filchedOrecord", "filtered67frame", "filtered_node", "filtered1frame", "filbedUframe", "filcluded_Frame", "filteredKhost", "filtered___scene", "filteredUframe", "filched_record", "filtered___message", "filatted_filename", "filtered_class", "filched_frame", "filtered___feature", "filtered_host", "filered_time", "filted_thread", "fillated_frame", "filtered1base", "filtered67feature", "filters_point", "filtered00thread", "filtered_part", "filteredOclass", "filteredOrecord", "filtered_sample", "filteredOframe", "filters_orig", "filtered1element", "filcluded_motion", "fillated67iframe", "fillated_iframe", "filtered_message", "filted_frame", "filtered__line", "filted_board", "filteredUclass", "filtered00part", "filched_host", "filtered_time", "filatted_scene", "fillated_boot", "filted_part", "filteredKframe", "filenced_stroke", "filned67point", "filted_feature", "filtered___video", "filbedUscene", "filtered_feature", "filtered___fram", "filteredOscene", "filtered_base", "filbedUclass", "filtered_filename", "filtered__sample", "filned_feature", "filbed_module", "filtered_board", "filtered__frame", "filcluded_frames", "filteredJtime", "filtered_scene", "filtered_fram", "filted_element", "filted_message", "filchedOscene", "filteredJboot", "filered_boot", "filteredJframe", "filtered___frame"], "frame_size": ["frame64range", "frame_sized", " frame_SIZE", "image_SIZE", "frame_slice", "fram_width", "frame1size", "image_resolution", "framealformat", "frame64width", "framealresolution", "image_scale", "frame_scale", "frame64size", "frame64rate", "image_size", "frame1speed", "frame_SIZE", "frame_format", " frame_speed", "frame_resolution", "image_format", "frame_speed", "framealscale", "frame_width", "fram_slice", "image_rate", "frame_rate", "frame64scale", "frame1SIZE", "fram_size", "framealsize", "page_width", "frame64SIZE", "page_sized", "frame64slice", "frame_range", "fram_range", "page_size"], "ret": ["flag", "reg", "rt", "al", "cur", "alt", "id", "nt", "value", "rb", "val", "last", "data", "rf", "rc", "format", "bit", "art", "sur", "fin", "num", "lit", "f", "ext", "att", "arg", "res", "match", "def", "part", "len", "mt", "ur", "det", "all", "arr", "en", "RET", "pass", "feat", "empty", "result", "ut", "Ret", "ft", "run", "re", "fun", "back", "utf", "success", "ref", "rep", "rets"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "substitutes": {"mr": ["dr", "gr", "fr", "er", "vr", "sr", "rt", "pr", "rr", "md", "rb", "shr", "mid", "MR", "tr", "rc", "rd", "rf", "bm", "wk", "m", "rm", "rh", "tx", "attr", "mn", "nr", "pc", "km", "mc", "mt", "Mr", "rg", "timer", "tm", "rx", "lr", "rl", "err", "gro", "war", "usr", "yr", "mm", "RR", "hr", "br", "lc", "adr", "kr", "rs", "r"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 4479, "substitutes": {"avctx": ["axcu", "avcn", "avca", "akcontext", "awctx", "AVcam", "axcontext", "afca", "avcam", "apcontext", "avectx", "afcv", "aflc", "awclient", "ajlc", "vrclient", "ajcv", "avcu", "AVctx", "AVcontext", "ajcp", "avecp", "vrcv", "akctx", "afcn", "afctx", "akcn", "axcam", "apctx", "abcontext", "avcv", "avcontext", "afcp", "afclient", "avcp", "ajcu", "avclient", "awcontext", "avecontext", "avlc", "afcontext", "ajctx", "afcam", "axctx", "ajcontext", "abcv", "apcn", "AVcu", "awcv", "akca", "apca", "vrcontext", "avelc", "afcu", "abcu", "abctx", "vrctx"], "afq": ["alfquery", "affz", "affdq", "awu", "alfq", " afqu", "awiq", "awl", "effqa", " afquery", "faQ", "afct", " afk", "awdq", " afqa", "avqa", "awQ", "effquest", " afl", "awquery", "afck", "awquest", "AFl", "effq", "ajq", "alfqa", "ajck", "afdq", "alfk", "affqt", "awq", "alfck", "fadq", "faq", "ampqu", "affqa", "faqt", " afct", "ampqa", "affq", "AFu", "afz", "awqt", "alfct", "alfquest", "affqu", "afqt", " afu", "effck", "AFq", "ampck", "awct", "afiq", "ampquest", "afk", "avquest", "avck", "afqa", "afl", "affQ", "afquery", "avq", "ampz", "awck", "afQ", "afquest", "afu", "awk", "afqu", "ajiq", "ampiq", " afz", "ampq", "ajquest", "AFk"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n", "idx": 4488, "substitutes": {"cpu": ["cp", "prem", "gp", "cmp", "gc", "lb", "chip", "intel", "platform", "pu", "vm", "component", "device", "gpu", "px", "mac", "pc", "np", "nic", "clock", "disk", "rpm", "kernel", "process", "pool", "computer", "processor", "boot", "alloc", "pointer", "proc", "GPU", "c", "cn", "lc", "performance", "cache", "current", "CPU", "cm"], "parm": ["pbarms", "Park", " param", "pparms", "lparms", "lpark", "pbaram", "nparam", "nparms", "park", "Parm", "parms", "Para", "pbattr", "param", "npattr", "lpara", "nparm", " parms", "pattr", "lparm", " pattr", "ppark", "pbarm", "ppara", "pparm", "para", "Parms"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint8_t *s = src;\n\n    const uint8_t *end;\n\n    const uint8_t *mm_end;\n\n    uint16_t *d = (uint16_t *)dst;\n\n    end = s + src_size;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*src):\"memory\");\n\n    __asm__ volatile(\n\n        \"movq          %0, %%mm7    \\n\\t\"\n\n        \"movq          %1, %%mm6    \\n\\t\"\n\n        ::\"m\"(red_15mask),\"m\"(green_15mask));\n\n    mm_end = end - 11;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movd          %1, %%mm0    \\n\\t\"\n\n            \"movd         3%1, %%mm3    \\n\\t\"\n\n            \"punpckldq    6%1, %%mm0    \\n\\t\"\n\n            \"punpckldq    9%1, %%mm3    \\n\\t\"\n\n            \"movq       %%mm0, %%mm1    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm3, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"psrlq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $3, %%mm3    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %2, %%mm3    \\n\\t\"\n\n            \"psrlq         $6, %%mm1    \\n\\t\"\n\n            \"psrlq         $6, %%mm4    \\n\\t\"\n\n            \"pand       %%mm6, %%mm1    \\n\\t\"\n\n            \"pand       %%mm6, %%mm4    \\n\\t\"\n\n            \"psrlq         $9, %%mm2    \\n\\t\"\n\n            \"psrlq         $9, %%mm5    \\n\\t\"\n\n            \"pand       %%mm7, %%mm2    \\n\\t\"\n\n            \"pand       %%mm7, %%mm5    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n            \"psllq        $16, %%mm3    \\n\\t\"\n\n            \"por        %%mm3, %%mm0    \\n\\t\"\n\n            MOVNTQ\"     %%mm0, %0       \\n\\t\"\n\n            :\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\n\n        d += 4;\n\n        s += 12;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        const int b = *s++;\n\n        const int g = *s++;\n\n        const int r = *s++;\n\n        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);\n\n    }\n\n}\n", "idx": 4519, "substitutes": {"src": ["sub", "sr", "ins", "cur", "rb", "b", "rc", "i", "sn", "slice", "dest", "loc", "sur", "image", "support", "sl", "ls", "gz", "ss", "sc", "rss", "sb", "inst", "source", "gb", "start", "sup", "c", "sel", "sq", "rs", "r", "img"], "dst": ["idsts", "Dst", "dbl", "fsts", "dusp", "Dost", "idst", "Dsts", "dsp", "dsts", "idbl", "Dbl", "dust", " dsts", "dstr", " dsp", "sdst", "sdsts", "idost", "dost", "sdstr", "fbl", "fost", "dustr", "sdsp", "dusts", " dstr", "fst"], "src_size": [" src_scale", "rc_end", "src_end", "rc_scale", "rc_size", "src_scale", " src_end"], "s": ["S", "a", "features", "x", "b", "i", "f", "ats", "w", "sd", "h", "g", "sym", "y", "times", "sets", "sites", "is", "spec", "its", "states", "sl", "ls", "sh", "bis", "ds", "ts", "south", "z", "sv", "fs", "sq", "events", "groups", "posts", "days", "sec", "sync", "ses", "j", "cs", "u", "e", "sb", "ks", "t", "tests", "p", "blocks", "start", "c", "r", "sup", "ps", "o", "v", "session", "words", "si", "m", "l", "side", "ns", "args", "space", "us", "ss", "gs", "se", "n", "su", "params", "es"], "end": ["END", "est", "append", "st", "id", "open", "shape", "send", "edge", "mid", "x", "b", "enc", "dest", "ad", "m", "ending", "ion", "f", "offset", "ended", "e", "all", "stop", "w", "size", "en", "se", "dev", "k", "t", "n", "day", "win", "ent", "p", "begin", "h", "z", "start", "c", "ind", "ens", "set", "r", "max", "nd", "ff", "End"], "mm_end": ["mm2start", "sm_end", "sm_id", "mi2end", "mm_start", "mi2start", "mm_size", "mem_ended", "sm_start", "mi2size", "sm_max", "mem_END", "mi_size", "mi_edge", "mi_end", "mm_edge", "mm2size", "mi2edge", "mm_ended", "mem_end", "mm_END", "mem_start", "mm_max", "mi_start", "mm2end", "mm_id", "mm2edge"], "d": ["D", "dy", "o", "v", "id", "dn", "di", "dat", "dd", "b", "dh", "x", "i", "data", "ad", "m", "l", "db", "f", "j", "q", "u", "e", "w", "da", "dc", "sd", "n", "ds", "k", "t", "p", "h", "z", "c", " D", "g", "ind", "y", "Ds", "r", "cd"]}}
{"project": "qemu", "commit_id": "e61031cdd81826c433a8bbfa3aca2bae4ffaf845", "target": 1, "func": "static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,\n\n                                void *opaque)\n\n{\n\n    GtkDisplayState *s = opaque;\n\n    int x, y;\n\n    int mx, my;\n\n    int fbh, fbw;\n\n    int ww, wh;\n\n\n\n    fbw = surface_width(s->ds) * s->scale_x;\n\n    fbh = surface_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    x = (motion->x - mx) / s->scale_x;\n\n    y = (motion->y - my) / s->scale_y;\n\n\n\n    if (x < 0 || y < 0 ||\n\n        x >= surface_width(s->ds) ||\n\n        y >= surface_height(s->ds)) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,\n\n                             surface_width(s->ds));\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,\n\n                             surface_height(s->ds));\n\n        qemu_input_event_sync();\n\n    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 4521, "substitutes": {"widget": ["game", "gets", "scroll", "fw", "wx", "scope", "sw", "session", "wid", "layout", "iframe", "wp", "pipe", "image", "draw", "window", "gui", "sl", "wordpress", "select", "w", "Widget", "win", "theme", "skin", "loader"], "motion": ["game", "flow", "position", "scroll", "mpeg", "comm", "effect", "sem", "up", "iframe", "wp", "mo", "image", "draw", "mos", "mp", "media", "select", "ss", "km", "sc", "down", "error", "cam", "mission", "otion", "speech", "me", "theme", "Motion", "mega", "frame", "sp", "mph", "mm", "video", "webkit", "model", "params", "move", "anim", "activity", "upload", "element", "mode", "mouse", "ui"], "opaque": ["opsac", "OPac", "opusaque", "opque", "OPque", "OPonymous", "oponymous", "OPacity", "opsaque", " opque", "opsaques", "OPaque", "opusacity", "opac", "opsonymous", " oponymous", "OPaques", " opacity", "opaques", "opusque", "opusonymous", "opacity", " opaques", " opac"], "s": ["sf", "S", "a", "features", "b", "data", "i", "status", "f", "parts", "d", "service", "conf", "sports", "self", "aws", "g", "sym", "sets", "sites", "is", "spec", "services", "its", "states", "server", "sl", "ls", "native", "sie", "ops", "ds", "ts", "south", "settings", "fs", "sq", "ms", "your", "site", "rs", "as", "ins", "ows", "sg", "plugins", "comments", "sync", "ses", "ions", "cs", "u", "e", "an", "submit", "sb", "ks", "en", "t", "qs", "tests", "p", "input", "css", "c", "os", "ssl", "r", "ps", "o", "views", "less", "http", "scope", "session", "words", "si", "styles", "sys", "m", "details", "l", "side", "ns", "stats", "us", "ss", "gs", "se", "full", "storage", "n", "su", "spot", "request", "params", "es", "js"], "x": ["ya", "name", "area", "position", "cross", "yx", "v", "id", "wx", "value", "Y", "ex", "ax", "i", "xi", "xp", "b", "pe", "wa", "data", "m", "dx", "px", "fx", "ix", "xy", "tx", "xs", "l", "f", "image", "key", "event", "d", "e", "an", "point", "w", "en", "t", "n", "rx", "height", "win", "p", "input", "h", "z", "xxx", "c", "xx", "X", "index", "on", "size"], "y": ["yy", "dy", "name", "o", "python", "zy", "sy", "wx", "ady", "Y", "yt", "yo", "ny", "b", "iy", "i", "cy", "sky", "m", "ya", "yn", "xy", "ty", "yi", "d", "py", "ry", "ay", "w", "yl", "oy", "ery", "t", "height", "lon", "vy", "ey", "year", "p", "yan", "ye", "ky", "h", "z", "gy", "ys", "ym", "ish"], "mx": ["yy", "dy", "ml", "yx", "fy", "md", "wx", "wave", "zx", "hz", "xp", "wm", "ax", "wp", "cy", "mo", "wa", "m", "fx", "px", "xy", "tx", "pm", "wy", "mn", "py", "mc", "MX", "hh", "rx", "mag", "mi", "me", "mb", "fm", "mr", "gy", "memory", "mm", "ym", "xx", "webkit", "ms", "cm"], "my": ["yy", "dy", "fy", "mmm", "md", "nn", "mic", "ady", "zx", "ny", "wm", "i", "cy", "m", "ya", "ix", "xy", "mys", "pm", "ma", "mos", "mn", "gray", "nm", "Mi", "py", "ry", "ay", "mc", "mis", "any", "ami", "rx", "mag", "mi", "me", "ky", "mr", "gy", "am", "mph", "mm", "sym", "ms", "why", "ym", "your", "MY", "My"], "fbh": ["fbx", "fdh", "fey", "fxhi", "fsy", "few", "bbsh", "fxw", "fsh", "fcg", "pbh", "bbh", "fbsh", "bx", "ebk", "fcy", "pbhi", "fby", "ebw", "bw", "fdsh", "fek", "bby", "feh", "fex", "bk", "fch", "ebx", "bbw", "fdy", "fbg", "bbk", "fsg", "fsx", "fbhi", "fdw", "pbk", "fxk", "fcx", "fxh", "pbw", "feg", "bbhi", "bh", "ebh", "fbk", "fxsh", "fxy"], "fbw": ["fbx", "cbm", "rby", "fy", "fw", "fbm", "cbw", "fh", "fbv", "fcw", "fv", "cbx", "rbx", "bbh", "cfx", "fx", "rbm", "cby", "fby", "bbx", "rbh", "bby", "rbw", "fch", "bbw", "cfh", "cfv", "bbm", "fcv", "fcx", "cbh", "cfw"], "ww": ["rw", "hw", "nw", "yah", "fw", "wx", "nn", "wed", "dd", "sw", "wn", "sem", "wp", "oh", "wa", "wk", "dx", "fx", "wb", "wy", "wo", "wd", "w", "www", "tw", "hh", "rx", "wow", "whe", "kw", "qa", "wal", "iw", "gh", "mm", "wl", "sq", "xx", "ew"], "wh": ["rw", "hw", "ko", "nw", "fw", "wx", "eth", "sw", "WH", "wm", "wp", "oh", "wa", "wk", "rh", "sk", "wy", "how", "wo", "ffff", "ph", "han", "wd", "sh", "w", "we", "www", "tw", "self", "hop", "whe", "kw", "wr", "wal", "h", "hy", "gh", "hi", "mm", "who", "xx", "rah", "Wh", "ff"]}}
{"project": "FFmpeg", "commit_id": "b46a77f19ddc4b2b5fa3187835ceb602a5244e24", "target": 0, "func": "int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,\n\n                         int level)\n\n{\n\n    VDPAUHWContext *hwctx = avctx->hwaccel_context;\n\n    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;\n\n    VdpVideoSurfaceQueryCapabilities *surface_query_caps;\n\n    VdpDecoderQueryCapabilities *decoder_query_caps;\n\n    VdpDecoderCreate *create;\n\n    void *func;\n\n    VdpStatus status;\n\n    VdpBool supported;\n\n    uint32_t max_level, max_mb, max_width, max_height;\n\n    VdpChromaType type;\n\n    uint32_t width;\n\n    uint32_t height;\n\n\n\n    vdctx->width            = UINT32_MAX;\n\n    vdctx->height           = UINT32_MAX;\n\n\n\n    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))\n\n        return AVERROR(ENOSYS);\n\n\n\n    if (hwctx) {\n\n        hwctx->reset            = 0;\n\n\n\n        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {\n\n            vdctx->decoder = hwctx->context.decoder;\n\n            vdctx->render  = hwctx->context.render;\n\n            vdctx->device  = VDP_INVALID_HANDLE;\n\n            return 0; /* Decoder created by user */\n\n        }\n\n\n\n        vdctx->device           = hwctx->device;\n\n        vdctx->get_proc_address = hwctx->get_proc_address;\n\n\n\n        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n\n\n        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&\n\n            type != VDP_CHROMA_TYPE_420)\n\n            return AVERROR(ENOSYS);\n\n    } else {\n\n        AVHWFramesContext *frames_ctx = NULL;\n\n        AVVDPAUDeviceContext *dev_ctx;\n\n\n\n        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit\n\n        // is called. This holds true as the user is not allowed to touch\n\n        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format\n\n        // itself also uninits before unreffing hw_frames_ctx).\n\n        if (avctx->hw_frames_ctx) {\n\n            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        } else if (avctx->hw_device_ctx) {\n\n            int ret;\n\n\n\n            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n            if (!avctx->hw_frames_ctx)\n\n                return AVERROR(ENOMEM);\n\n\n\n            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n            frames_ctx->format    = AV_PIX_FMT_VDPAU;\n\n            frames_ctx->sw_format = avctx->sw_pix_fmt;\n\n            frames_ctx->width     = avctx->coded_width;\n\n            frames_ctx->height    = avctx->coded_height;\n\n\n\n            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n            if (ret < 0) {\n\n                av_buffer_unref(&avctx->hw_frames_ctx);\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        if (!frames_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware frames context is \"\n\n                   \"required for VDPAU decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        dev_ctx = frames_ctx->device_ctx->hwctx;\n\n\n\n        vdctx->device           = dev_ctx->device;\n\n        vdctx->get_proc_address = dev_ctx->get_proc_address;\n\n\n\n        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n    }\n\n\n\n    if (level < 0)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        surface_query_caps = func;\n\n\n\n    status = surface_query_caps(vdctx->device, type, &supported,\n\n                                &max_width, &max_height);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    if (supported != VDP_TRUE ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n", "idx": 4524, "substitutes": {"avctx": ["vcu", "navbc", "AVtx", "AVlc", "afcas", "hwcf", "verpkg", " avcas", "evcontext", "navcv", "abcmp", "navcontext", "afxc", "afctx", "avkb", "navctx", "ovbc", "hwcontext", "abcf", " avcontext", "evcmp", "afcv", "evcf", "afcmp", "avcmp", "navpkg", "vxc", "abcontext", "avcv", "navcu", "avxc", "AVcmp", "ovcontext", "avecontext", "afcf", "avlc", "AVcu", "svcv", "avecu", "avbc", "avekb", "aflc", "avcas", "AVcas", "evlc", "vercontext", "avcu", "navcmp", "AVcontext", "ovconn", "afkb", "navconn", "navcf", "hwcu", "vctx", "hwxc", "avcontext", "navlc", "afpkg", "svcf", "navtx", "avconn", "evctx", "abctx", "AVpkg", "avectx", "avepkg", "svcontext", "ovctx", "AVctx", "avcf", "aftx", "avtx", "afbc", "hwcmp", "verctx", "afconn", "avpkg", "afcontext", "verkb", " avlc", "avecmp", "afcu", "vcontext", "svctx"], "profile": ["plugin", "program", " plugin", " profiles", "prof", " Profile", "method", " proto", "TYPE", "val", "image", " preview", "details", "picture", "py", "def", "buffer", " profiling", "file", "port", " prog", "path", " mode", " prof", "pb", "summary", "Profile", "view"], "level": ["levels", "name", "layer", "clean", "local", "id", "count", "method", "parent", "scope", "vel", "stack", "key", "l", "Level", "child", "limit", "length", "loop", "code", "len", "col", "error", "depth", "path", "temp", "scale", "stage", "lvl", "where", "line", "global", "thread", "model", "wl", "VEL", "test", "index", "mode"], "hwctx": ["fwcmp", "hawconn", "hlcmp", "hwcf", "fwxc", "hwctrl", "hwtx", "iwctx", "hwlc", "rwctrl", "rwctx", "vcctx", "wxcmp", "fwconn", "fwkb", "hwcontext", "fwloc", "hwkb", "fwsci", "rhcf", "rwcf", "wxctx", "rhctx", "hawcontext", "fwcontext", "vdcn", "hwcn", "fwlc", "hlctx", "avcmp", "fwtx", "nvtx", "lvloc", "nvcmp", "rhcontext", "rwkb", "hlcontext", "hwloc", "iwconn", "rwloc", "rwsci", "wxcontext", "iwctrl", "rhloc", "iwcf", "iwloc", "fwcn", "rwlc", "hwconn", "rwcn", "hwxc", "avcontext", "fwcf", "lvcontext", "iwxc", "nvctx", "vdloc", "hawctx", "hwsci", "rwcontext", "vccontext", "hawcf", "iwcmp", "hawxc", "hlxc", "iwtx", "iwlc", "vdcontext", "lvcf", "avcf", "wxxc", "vcconn", "hawsci", "iwkb", "hwcmp", "vccf", "lvctx", "fwctx", "nvcontext", "fwctrl", "iwcontext", "rwcmp"], "vdctx": ["svkb", "xdctx", "hdcmp", "hdcf", "hdctx", "nvcf", "vdcrit", "vdkb", "vidcontext", "vvcrit", "vcctx", "vidcli", "nvxc", "hwcp", "hwcontext", "nvpkg", "dlsync", "vdxc", "hdxc", "hdpkg", "vddc", "hwcv", "vvctx", "nvtx", "nvcrit", "vdcli", "vidctx", "viddc", "dlctx", "nvcmp", "hdcontext", "vdcf", "nvctrl", "vdsync", "vvcli", "hdcrit", "dlctrl", "hdtx", "hdkb", "vdtx", "sdcp", "hdctrl", "nvdc", "vdconn", "hdsync", "vdctrl", "vdpkg", "vdcp", "xdpkg", "vctx", "hwxc", "vvcf", "sdctx", "hdconn", "vdcmp", "vvdc", "xdkb", "vvcontext", "nvconn", "nvkb", "nvctx", "dlcontext", "sdcv", "nvcli", "nvcv", "vccontext", "nvcp", "svcontext", "vdcontext", "sdcontext", "xdcontext", "vcconn", "svpkg", "hwcmp", "nvsync", "nvcontext", "vdcv", "svctx"], "surface_query_caps": ["surface_view_pieces", "surface_query_abilities", "surface_view_caps", "surface_query_pieces", "surface_view_abilities", "surface_view_cap", "surface_query_cap"], "decoder_query_caps": ["decoder_request_cap", "decoder_query_abilities", "decoder_query_cap", "decoder_query_cards", "decoder_request_abilities", "decoder_request_cards", "decoder_request_caps"], "create": ["enable", "creat", "copy", "open", "send", "save", "execute", "update", "sync", "invoke", "draw", "make", "media", "call", "Create", "code", "activate", "process", "source", "parse", "stage", "define", "creator", "write", "apply", "construct", "setup", "add"], "func": ["function", "pack", "unc", "execute", "nc", "sync", "sys", "module", "conv", "call", "pc", "ack", "cc", "code", "fn", "cmd", "Function", "cb", "exec", "callback", "process", "stage", "alloc", "fun", "apply", "src", "grad", "setup"], "status": ["function", "stat", "name", "complete", "method", "STAT", "sync", "unit", " Status", "state", "stats", "obj", "active", "reason", "str", "process", "source", "result", "output", "stage", "Status", "success", "current", "summary", "mode"], "supported": ["function", " compatibility", "flag", "platform", " platform", "compatible", "b", " library", "Supported", "support", "valid", "null", " required", "used", "enabled", "state", "mod", " allowed", " support", "lib", " enabled", " compatible", " connected", "prop", " capable", " supports", " native", " valid"], "max_level": ["maxalllayer", "max67block", "max_length", "max_layer", "max_block", " max_layer", " max_block", "maxalllevel", "maxalllength", "max67layer", "max67length", "maxallblock", " max_length", "max67level"], "max_mb": ["min_level", "min_mode", "min_lvl", "min_mb", "max_mode", "max_lvl"], "max_width": [" max_weight", "max_weight", " max_window", "max___width", "max_length", "max___window", "max_window", "max___length", "max___weight", " max_length"], "max_height": ["maxaldata", "maxalheight", " max_data", "maxalwidth", " max_h", "maxalh", "max_h", "max_data"], "type": ["function", "types", " Type", "name", "time", "position", "block", "id", "method", "parent", "shape", "value", "TYPE", "op", "object", "style", "slice", "format", "typ", "rel", "pe", " TYPE", "unit", "key", "resource", " typ", "version", "state", "call", "by", "number", "code", "kind", "error", "port", "t", "ype", "source", "p", "rule", "attribute", "class", "y", "link", "set", "Type", "view", "role"], "height": ["density", "Height", "build", "host", "padding", "id", "alpha", "shape", "device", "layout", "crop", "gap", "inches", "style", "x", "image", "draw", "window", "ty", "capacity", "weight", "length", "thin", "resolution", "definition", "deep", "depth", "w", "k", "volume", "history", "pad", "container", "quality", "input", "h", "direction", "hold", "strength", "memory", "ip", "rank", "stroke", "index", "max", "dim", "size"], "frames_ctx": ["videos_ctx", "frames_context", "frames_anc", "frames_chan", "videos_xc", "frames_xc", "flows_anc", "videos_chan", "flows_ctx", "flows_lc", "frames_lc", "flows_xc", "videos_context"], "dev_ctx": ["device_alloc", "dev_context", "devPcb", "device_cb", "devPalloc", "device_ctx", "device_context", "devPcontext", "dev_cb", "devjalloc", "devPctx", "devjcontext", "devjcb", "devjctx", "dev_alloc"], "ret": ["row", "layer", "flag", "ag", "al", "value", "vel", "val", "rc", "conv", "res", "ry", "def", "all", "col", "det", "deep", "RET", "result", " result", "Ret", "re", "back", "resp", "group"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int estimate_qp(MpegEncContext *s, int dry_run){\n\n    if (s->next_lambda){\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = s->next_lambda;\n\n        if(!dry_run) s->next_lambda= 0;\n\n    } else if (!s->fixed_qscale) {\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);\n\n        if (s->current_picture.f.quality < 0)\n\n            return -1;\n\n    }\n\n\n\n    if(s->adaptive_quant){\n\n        switch(s->codec_id){\n\n        case AV_CODEC_ID_MPEG4:\n\n            if (CONFIG_MPEG4_ENCODER)\n\n                ff_clean_mpeg4_qscales(s);\n\n            break;\n\n        case AV_CODEC_ID_H263:\n\n        case AV_CODEC_ID_H263P:\n\n        case AV_CODEC_ID_FLV1:\n\n            if (CONFIG_H263_ENCODER)\n\n                ff_clean_h263_qscales(s);\n\n            break;\n\n        default:\n\n            ff_init_qscale_tab(s);\n\n        }\n\n\n\n        s->lambda= s->lambda_table[0];\n\n        //FIXME broken\n\n    }else\n\n        s->lambda = s->current_picture.f.quality;\n\n    update_qscale(s);\n\n    return 0;\n\n}\n", "idx": 4539, "substitutes": {"s": ["serv", "rates", "a", "S", "features", "browser", "rb", "b", "grades", "i", "status", "results", "f", "d", "bs", "service", "conf", "uploads", "self", "aws", "g", "sym", "times", "sets", "sites", "is", "spec", "services", "its", "states", "server", "ls", "ops", "sim", "bis", "ds", "ts", "south", "settings", "fs", "sq", "ms", "your", "lines", "rs", "uses", "as", "er", "ins", "sg", "plugins", "comments", "sync", "ses", "ions", "cs", "u", "vs", "e", "sis", "submit", "parser", "sb", "ks", "t", "qs", "ings", "p", "css", "c", "os", "ssl", "ims", "set", "r", "ps", "o", "scope", "session", "si", "sys", "m", "xs", "ns", "stats", "args", "us", "ss", "uns", "gs", "se", "storage", "n", "su", "request", "es", "js"], "dry_run": ["dry__module", "dry_module", "dryappcall", "dryacmin", "dryOverrun", "dry__runs", "dryOvertrue", " dry_true", "dry_runs", " dry_runs", "dryappmin", "dryapprun", "dyappoutput", "dry_min", "dryacoutput", " dry_module", "dryowtrue", "dryowRun", "dyapprun", "dy_run", "dryaccall", "dyappcall", "dryowrun", "dryowdate", " dry_Run", "dryOverdate", " dry_date", "dry_date", "dry_Run", "dryacrun", "dry_runner", "dryOverRun", "dry__run", " dry_runner", "dry_output", "dy_output", "dy_call", "dyappmin", "dy_min", "dry_true", "dry_call", "dryappoutput", "dry__runner"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 4540, "substitutes": {"ctx": ["cp", "cmp", "cgi", "anc", "parent", "ci", "component", "config", "rc", "cca", "sync", "gpu", "loc", "cm", "tx", "client", "cci", "obj", "cli", "sci", "cc", "sc", "connection", "cam", "cmd", "bc", "exec", "cb", "Context", "cu", "context", "qa", "ca", "cpu", "c", "lc", "cv", "vc", "cpp", "cas", "conn", "pkg", "xc", "tc"], "sprn": ["prns", "prname", " sprns", " sprname", "Sprname", "sprns", "sprname", " sprN", "Sprn", "prN", "sprN", "SprN", "prn", "Sprns"], "gprn": ["gsprns", " gPRn", "gprns", "Gprns", "ggrn", "gsprno", "Gprn", "gsprn", "gprno", "grrns", " gPRno", "grrk", " gPRN", "gprN", " gprN", "ggrk", "gPRns", "grrN", "gprk", "gPRn", "gPRN", "ggrns", " gPRns", "GprN", "Gprk", " gprno", "grrn", "gsprN", "ggrN", " gprns", "gPRno"]}}
{"project": "qemu", "commit_id": "46746dbaa8c2c421b9bda78193caad57d7fb1136", "target": 0, "func": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)\n\n{\n\n#ifdef CONFIG_KVM\n\n    struct kvm_irqfd irqfd = {\n\n        .fd = event_notifier_get_fd(&vdev->intx.interrupt),\n\n        .gsi = vdev->intx.route.irq,\n\n        .flags = KVM_IRQFD_FLAG_RESAMPLE,\n\n    };\n\n    struct vfio_irq_set *irq_set;\n\n    int ret, argsz;\n\n    int32_t *pfd;\n\n\n\n    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||\n\n        vdev->intx.route.mode != PCI_INTX_ENABLED ||\n\n        !kvm_resamplefds_enabled()) {\n\n        return;\n\n    }\n\n\n\n    /* Get to a known interrupt state */\n\n    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);\n\n    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n    vdev->intx.pending = false;\n\n    pci_irq_deassert(&vdev->pdev);\n\n\n\n    /* Get an eventfd for resample/unmask */\n\n    if (event_notifier_init(&vdev->intx.unmask, 0)) {\n\n        error_report(\"vfio: Error: event_notifier_init failed eoi\");\n\n        goto fail;\n\n    }\n\n\n\n    /* KVM triggers it, VFIO listens for it */\n\n    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);\n\n\n\n    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {\n\n        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    argsz = sizeof(*irq_set) + sizeof(*pfd);\n\n\n\n    irq_set = g_malloc0(argsz);\n\n    irq_set->argsz = argsz;\n\n    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;\n\n    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;\n\n    irq_set->start = 0;\n\n    irq_set->count = 1;\n\n    pfd = (int32_t *)&irq_set->data;\n\n\n\n    *pfd = irqfd.resamplefd;\n\n\n\n    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);\n\n    g_free(irq_set);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");\n\n        goto fail_vfio;\n\n    }\n\n\n\n    /* Let'em rip */\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n\n\n    vdev->intx.kvm_accel = true;\n\n\n\n    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);\n\n\n\n    return;\n\n\n\nfail_vfio:\n\n    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;\n\n    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);\n\nfail_irqfd:\n\n    event_notifier_cleanup(&vdev->intx.unmask);\n\nfail:\n\n    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n#endif\n\n}\n", "idx": 4551, "substitutes": {"vdev": ["kdc", "vdd", "nvdiff", "jdevice", " vmd", "voltdiv", "vdc", "pdev", "qdiv", "tvdiff", "voltdev", "pver", "pdd", " vver", " vdd", "vdiv", " vdi", "nvdd", "pdiff", "gdef", "Vdef", "vgu", "gdev", "Vdie", "vdie", "kde", "pmd", "vdi", "krad", "vdiff", "nvmd", "vver", "nvdiv", "nvgu", "gdc", " vgu", "kdebug", "qdevice", " vdebug", "voltrad", "vrad", "jdev", "nvdev", "fdevice", "tvdevice", "mdiv", "svdev", "jdi", "svde", "pgu", "Vdc", "gdevice", "hdb", "vdevice", "svdc", "tvdev", "fver", "kdef", " vdiv", "hdiff", "nvdie", "jdc", "vdef", "kdie", "pdb", "qdev", "kdi", "kver", "vde", "Vdev", "hdev", "mdie", "kdevice", "svdie", "Vdi", "mdev", "kdev", "mdiff", "qdebug", " vde", "pdie", "jrad", "hdevice", "kdiv", "Vdevice", " vdevice", "Vde", "fdev", "tvdb", " vdiff", "vmd", "vdb", "Vver", "pdevice", "jdef", "voltdi", "vdebug", "fdiff", "pdiv", "jdiv"], "irq_set": ["irqfsend", "irqu_set", "irqu1set", "irquest__send", "irqrsetting", "irquest_get", "irqqadd", "irqqset", "irsh_export", "irqu1add", "irqu_setting", "irq__set", "irquest__set", "irqu_add", "irq__send", "irqfid", "irq_setting", "irb_SET", "irquest_et", "irqu_Set", "irq_et", "irquest_send", "irqMsetting", "irqqsetting", "irb_send", "irq_write", "irQ_add", "irqu1default", "irqu1setting", "irqMset", "irqsid", "irquest_id", "irqfopen", "irqfset", "irq1default", "irQ_set", "irsh_set", "irsh_setting", "irqMexport", "irb_set", "irquest__id", "irquest_set", "irb_start", "irqu_default", "irq_init", "irqsset", "irqMsend", "irq1set", "irq_id", "irqrsend", "irquest__get", "irQ_write", "irquest_open", "irq_Set", "irshMset", "irq_start", "irqsget", "irq1setting", "irshMexport", "irq__id", "irqfSet", "irq_add", "irqssend", "irqrset", "irqqdefault", "irqrexport", "irqu_open", "irq_default", "irq_get", "irq__get", "irquest_init", "irshMsetting", "irq_open", "irqfget", "irq_export", "irq1add", "irqu_get", "irshMsend", "irq_SET", "irq_send", "irQ_get", "irsh_send"], "ret": ["std", "flag", "reg", "sec", "sy", " success", "mem", "nt", "val", "rc", " res", " RET", " Ret", " gen", " rc", " code", " len", "j", " resp", "res", "ry", "def", "len", "RET", "Ret", "fun", "rets"], "argsz": ["argszen", "valsz", "paramsz", "argsiz", " argsza", "argize", "argza", " argsgz", "ArgsZ", "Argsz", "argszip", "argzo", "amsza", "paramsiz", " argsZ", "paramsy", "argsZ", "Argsgz", " argszen", "argsza", "paramszip", "amszen", "argsize", "argsy", "argzip", "bitszip", "Argsiz", "bitsize", "argZ", "argszo", "argzen", " argsx", "valszip", "amsZ", "valsiz", "arggz", "argiz", "paramszo", "argx", "paramsize", "valszo", "argy", " argsiz", "bitsy", "argsx", "argsgz", "bitsz", "amsz", "Argsx", "argz"], "pfd": ["pFD", "Pfd", "cpFD", "fdf", "pd", "qFD", " pf", "ffd", " pFD", "pf", " pd", "qdf", "qd", "fFD", "cpd", "Pdf", "qfd", "Pf", "cpfd", " pdf", "cpdf", "pdf", "PFD", "ff"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 4555, "substitutes": {"ctx": ["cp", "cmp", "cgi", "hw", "cfg", "ci", "component", "gru", "config", "nc", "rc", "cca", "sync", "cus", "comp", "gpu", "loc", "tx", "cal", "obj", "pc", "linux", "cc", "sci", "cs", "cli", "crit", "ck", "sc", "que", "cam", "conn", "cmd", "wcs", "bc", "cu", "cms", "Context", "jp", "exec", "context", "ctrl", "ca", "qa", "css", "cpu", "kb", "c", "txt", "ct", "cn", "cf", "lc", "fc", "cz", "cv", "vc", "git", "cpp", "cas", "grad", "cm", "pkg", "xc", "tc"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 4556, "substitutes": {"opaque": ["oopicit", "opque", "operque", "ipopaque", "operaques", "oopque", " opque", "operaque", " opity", "oopity", " opicit", " opca", "ipopacity", "operity", " opacity", "opaques", "operacity", "ipopca", "opericit", "oopaque", "opacity", "opca", "operca", " opaques", "opicit", "ipopaques", "opity"], "offset": ["base", "address", "o", "position", "padding", "reset", "no", "id", "entry", "parent", "fee", "skip", "object", "data", "alias", "et", "shift", "sync", "slice", "Offset", "phase", "loc", "null", "key", "url", "limit", "length", "align", "delay", "initial", "part", "len", "error", "bound", "timeout", "seq", "ptr", "pos", "pointer", "start", "alloc", "off", "attribute", "location", "type", "range", "oid", "slot", "ref", "notation", "set", "addr", "index", "next", "seed", "mode", "optional"], "size": ["address", "SIZE", "data", " bytes", "length", "args", " length", "Size", "bytes", "ptr", "ize"], "s": ["ing", "sf", "S", "a", "b", "ums", "i", "status", "results", "f", "service", "hs", "w", "ar", " parts", " statements", "aws", "sa", "g", "sym", "y", " entries", "types", "sets", "ers", "is", "services", "its", "states", "server", "sl", "ls", " results", "ops", "ds", "ts", "south", "settings", "ors", " values", "fs", "sq", " defaults", "rs", "as", "er", "ins", "sy", "sg", "als", "sync", "ses", "ions", "has", "ports", "cs", "e", "sb", "secondary", "qs", "t", "erences", "ings", "p", "ies", "c", "os", "ssl", "ed", "r", " signals", "ps", "o", "scope", "session", "si", "sys", "m", "l", "ns", "stats", "us", "ss", " symbols", "gs", "storage", "es", "js"]}}
{"project": "qemu", "commit_id": "430b26a82da61876c4eaf559ae02332582968043", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    s->config_file = g_strdup(qemu_opt_get(opts, \"config\"));\n\n    ret = read_config(s, s->config_file, options, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the image file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    bs->supported_write_flags = BDRV_REQ_FUA &\n\n        bs->file->bs->supported_write_flags;\n\n    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &\n\n        bs->file->bs->supported_zero_flags;\n\n    ret = -EINVAL;\n\n\n\n    /* Set request alignment */\n\n    s->align = qemu_opt_get_size(opts, \"align\", 0);\n\n    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {\n\n        error_setg(errp, \"Cannot meet constraints with align %\" PRIu64,\n\n                   s->align);\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (ret < 0) {\n\n        g_free(s->config_file);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 4563, "substitutes": {"bs": ["bas", "base", "tails", "lb", "bin", "ins", "is", "http", "bits", "plugins", "bt", "als", "b", "bps", "socket", "sync", "ros", "ses", "bi", "bing", "its", "BS", "obs", "fb", "bes", "client", "ns", "state", "ls", "obj", "iss", "bb", "ss", "cs", "las", "vs", "us", "sb", "ops", "ks", "gs", "full", "bis", "ds", "banks", "qs", "ctx", "bytes", "bc", "ts", "cb", "ils", "outs", "ubs", "Bs", "blocks", "css", "web", "gb", "fs", "file", "bh", "os", "sa", "utils", "bl", "pb", "rs", "es", "ps", "js"], "options": ["option", "o", "to", "files", "http", "pro", "scope", "values", "config", "pre", "op", "x", "io", "optional", "info", "details", "vals", "f", "sl", "args", "obj", "opens", "keys", "e", "ops", "cho", "json", "lib", "ts", "outs", "Options", "p", "array", "settings", "css", "opt", "none", "global", "fs", "os", "c", "errors", "params", "cache", "es", "ps", "js"], "flags": ["files", "flag", "bits", "ags", "features", "Flags", "format", "mask", "ips", "lag", "vals", "FLAG", "ants", "parts", "stats", "args", " Flags", "ints", "fields", "ops", "bytes", "ents", "settings", "fs", " bits", "errors", "rets"], "errp": ["rrpre", "errorpo", "yrp", "erpc", "erfp", "cryr", " erping", "errpe", "ierf", " errpo", "crypc", "errpre", " errf", "derpe", "errorp", "rrp", " errfp", "orderpo", "ierping", " erper", "errper", "yrpe", "yrpr", "rrr", "errP", "errorP", "errping", "errpc", " errP", "derp", "ierp", "errpr", " errping", "erf", " erp", " errpc", " errc", " errper", " errpe", "err", "errorfp", "orderfp", "yrc", "ierper", "errc", "erpre", "derpr", "errr", "errpo", "errf", "erp", "cryp", "rrfp", "orderp", " erf", "derc", "errfp", " errpre", " errpr", " errr", "cryf", "orderP"], "s": ["S", "b", "i", "obs", "f", "state", "d", "service", "hs", "self", "h", "sa", "g", "sets", "is", "spec", "services", "its", "states", "sl", "ls", "iss", "ops", "bis", "ds", "ts", "settings", "fs", "your", "site", "rs", "as", "sg", "plugins", "sync", "ses", "cs", "u", "e", "sb", "ks", "secondary", "t", "qs", "p", "css", "c", "os", "ssl", "r", "ps", "o", "http", "scope", "session", "words", "si", "sys", "l", "xs", "ns", "stats", "args", "ss", "uns", "gs", "full", "n", "su", "params", "js"], "opts": [" oppt", "catts", "OPts", "olgs", "OPcs", "okty", " opps", "optics", " optta", " optcs", "optta", "olts", "operts", "opted", "coptics", "olpt", "opters", "okps", "okts", "copt", "expertics", "optt", "catuts", "olt", "operters", "copty", "opttes", "catters", "optts", " optts", "oppt", "OPgs", "optcs", "OPpt", "copted", "opps", " opted", "copcs", "expercs", "experters", "opertes", "optters", "opcs", "copts", "OPt", "optted", "OPters", "oputs", " oputs", "optty", "catcs", "opgs", "copters", "experts", "opta", "opt", " optt", "opty", "optps", " opgs", "optuts", " opcs", "optes", "operps", " optes", " opta", " opt", "copps", "OPtics", "okt", " opters"], "local_err": ["remote_err", "local5doc", "local_break", "localacinit", "local_orig", "local_out", "recentIPorig", "localacerror", "local_error", "global_init", "remote_msg", " local_msg", "local_errors", "localalinit", "localacerr", "global_break", "localerout", "global_err", " local_doc", " local_error", "recentIPerror", "remote_errors", "local5error", "localalbreak", "local\u00b7error", "local\u00b7er", "recent_orig", "localererror", "local_msg", "localIPerror", " local_cry", "remote_er", "localacbreak", "localIPorig", "recentIPerr", "recent_error", "localIPerr", "localercry", "remote_error", "recent_err", "local5err", "local_doc", "local_rh", " local_out", "local\u00b7err", "local_cry", "local_init", "global_error", "localererr", "local\u00b7rh", "remote_rh", "local_er", "localalerror", "localalerr"], "ret": ["flag", "pat", "x", "data", "status", "sil", "arg", "active", "match", "code", "len", "det", "RET", "sat", "pass", "rev", "ft", "fun", "base", "al", "id", "nt", "lt", "val", "art", "pt", "valid", "mt", "str", "pub", "ut", "no", "reg", "rt", "alt", "bit", "cat", "let", " RET", "fin", " Ret", "num", "ext", "att", "pet", "obj", "out", "en", "t", "fit", "feat", "Ret", "run", "re", "gt", "ref", "rets", "mem", "reply", "lit", "mer", "res", "def", "part", "result", "opt", "success"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n", "idx": 4569, "substitutes": {"str": ["dr", "gr", "fr", "er", "st", "sr", "cr", "rr", "pr", "s", "style", "f", "obj", "res", "cs", "e", "code", "arr", "func", "exec", "Str", "ptr", "sp", "doc", "txt", "hr", "STR", "text", "rs", "kr", "r", "stri"], "err": ["dr", "gr", "fr", "er", "nor", "cr", "iter", "pr", "rr", "try", "aster", "bug", "rc", "ise", "der", "rh", "ler", "order", "nr", "res", "ctr", "code", "e", "error", "ar", "arr", "rx", "good", "lr", "cb", "result", "req", "ner", "mr", "ver", "ind", "var", "resp", "Er", "test", "r", "rar", "msg"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,\n\n                                  unsigned size)\n\n{\n\n    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;\n\n    int w, i;\n\n    uint32_t ret = 0;\n\n\n\n    DPRINT_L2(\"read offset 0x%08x\\n\", offset);\n\n\n\n    switch (offset) {\n\n    case FIMD_VIDCON0 ... FIMD_VIDCON3:\n\n        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];\n\n    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:\n\n        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];\n\n    case FIMD_WINCON_START ... FIMD_WINCON_END:\n\n        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;\n\n    case FIMD_SHADOWCON:\n\n        return s->shadowcon;\n\n    case FIMD_WINCHMAP:\n\n        return s->winchmap;\n\n    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:\n\n        w = (offset - FIMD_VIDOSD_START) >> 4;\n\n        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;\n\n        switch (i) {\n\n        case 0:\n\n            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<\n\n            FIMD_VIDOSD_HOR_SHIFT) |\n\n            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 1:\n\n            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<\n\n                FIMD_VIDOSD_HOR_SHIFT) |\n\n                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 2:\n\n            if (w == 0) {\n\n                ret = s->window[w].osdsize;\n\n            } else {\n\n                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<\n\n                    FIMD_VIDOSD_AEN0_SHIFT) |\n\n                    pack_upper_4(s->window[w].alpha_val[1]);\n\n            }\n\n            break;\n\n        case 3:\n\n            if (w != 1 && w != 2) {\n\n                DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n                return 0xBAADBAAD;\n\n            }\n\n            ret = s->window[w].osdsize;\n\n            break;\n\n        }\n\n        return ret;\n\n    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:\n\n        w = (offset - FIMD_VIDWADD0_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;\n\n        return s->window[w].buf_start[i];\n\n    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:\n\n        w = (offset - FIMD_VIDWADD1_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;\n\n        return s->window[w].buf_end[i];\n\n    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:\n\n        w = (offset - FIMD_VIDWADD2_START) >> 2;\n\n        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<\n\n            FIMD_VIDWADD2_OFFSIZE_SHIFT);\n\n    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:\n\n        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];\n\n    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:\n\n        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;\n\n        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;\n\n        return s->window[w].keycon[i];\n\n    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:\n\n        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;\n\n        return s->window[w].keyalpha;\n\n    case FIMD_DITHMODE:\n\n        return s->dithmode;\n\n    case FIMD_WINMAP_START ... FIMD_WINMAP_END:\n\n        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;\n\n    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:\n\n        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];\n\n    case FIMD_TRIGCON:\n\n        return s->trigcon;\n\n    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:\n\n        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];\n\n    case FIMD_COLORGAINCON:\n\n        return s->colorgaincon;\n\n    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:\n\n        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];\n\n    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:\n\n        i = (offset - FIMD_SIFCCON0) >> 2;\n\n        return s->sifccon[i];\n\n    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:\n\n        i = (offset - FIMD_HUECOEFCR_START) >> 2;\n\n        return s->huecoef_cr[i];\n\n    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:\n\n        i = (offset - FIMD_HUECOEFCB_START) >> 2;\n\n        return s->huecoef_cb[i];\n\n    case FIMD_HUEOFFSET:\n\n        return s->hueoffset;\n\n    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:\n\n        w = ((offset - FIMD_VIDWALPHA_START) >> 3);\n\n        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;\n\n        return s->window[w].alpha_val[i] &\n\n                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);\n\n    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:\n\n        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;\n\n    case FIMD_BLENDCON:\n\n        return s->blendcon;\n\n    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:\n\n        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;\n\n    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:\n\n        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];\n\n    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];\n\n    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;\n\n    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;\n\n    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:\n\n        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;\n\n    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:\n\n        w = (offset - FIMD_PAL_MEM_START) >> 10;\n\n        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:\n\n        /* Palette aliases for win 0,1 */\n\n        w = (offset - FIMD_PALMEM_AL_START) >> 10;\n\n        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    }\n\n\n\n    DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n    return 0xBAADBAAD;\n\n}\n", "idx": 4570, "substitutes": {"opaque": ["OPac", "opatile", "opacs", "oplatile", "opque", "OPque", "oplaque", "oplacity", " opque", "ipque", "OPacs", "operaque", "OPaque", "opac", "ipaque", "operalias", "operatile", " opacs", " opalias", " opacity", "ipacs", " opatile", "ipac", "operacity", "opacity", "opalias", " opac", "oplalias"], "offset": ["energy", "position", "padding", "reset", "entry", "data", "et", "style", "f", "align", "buffer", "len", "error", "connection", "fp", "array", "attribute", "off", "index", "reference", "mode", "optional", "slot", "base", "id", "slice", "null", "url", "limit", "number", "operation", "ip", "range", "type", "iso", "element", "addr", "end", "address", "afi", "block", "alpha", "starting", "sync", "bit", "phase", "loc", "image", "esi", "outer", "exclusive", "online", "bound", "bytes", "timeout", "p", "pos", "start", "location", "api", "ref", "next", "set", "seed", "o", "alias", "Offset", "length", "part", "lock", "seq", "ptr", "alloc", "pointer", "oid", "shift"], "size": ["SIZE", "count", "data", " sizes", " bytes", "length", "args", " length", "Size", "align", "len", " error", "bytes", "timeout", "ize"], "s": ["ing", "ches", "sf", "S", "b", "results", "f", "service", "hs", "conf", "self", "aws", "sa", "g", "sym", "sets", "ers", "is", "spec", "rows", "services", "its", "states", "ls", "sl", " results", "ops", "ds", "ts", "outs", "settings", "ools", "fs", "sq", "lines", "rs", "er", "ins", "ows", "sg", "sync", "or", "ses", "ions", "cs", "e", "sb", "secondary", "t", "qs", "ings", "p", "ies", "c", "ssl", "ed", "r", "ps", "o", "v", "session", "si", "sys", "m", "l", "ns", "stats", "us", "ss", "uns", "gs", "su", " services", "utils", "es", "js"], "w": ["way", "rw", "o", "nw", "v", "fw", "W", "a", "wx", "wei", "nt", "wall", "sw", "wan", "x", "b", "ow", "wp", "widget", "wa", "wt", "now", "wk", "m", "window", "l", "num", "wb", "f", "wo", "wait", "d", "q", "u", "e", "we", "tw", "t", "n", "k", "win", "work", "ww", "p", "week", "kw", "wal", "h", "iw", "z", "c", "off", "g", "y", "wl", "ew", "current", "index", "r", "end", "aw"], "i": ["gi", "ti", "ret", "v", "id", "I", "di", "ci", "ni", "b", "x", "si", "xi", "bi", "m", "l", "f", "pi", "d", "j", "ii", "iu", "it", "u", "e", "t", "k", "n", "mi", "ini", "p", "z", "start", "c", "ip", "type", "li", "index", "zi", "end", "ui"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n", "idx": 4571, "substitutes": {"a": ["abc", "as", "area", "ea", "alpha", "la", "pa", "value", "aa", "b", "x", "data", "i", "ad", "ae", "m", "ma", "ga", "f", "d", "u", "an", "ata", "n", "A", "ab", "ba", "p", "input", "h", "sa", "c", "ac", "au", "aux"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qemu_chr_open_null(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ChardevCommon *common = backend->u.null;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 4607, "substitutes": {"id": ["ID", "base", "name", "iq", "rid", "parent", "data", "info", "client", "url", "create", "init", "sid", "def", "code", "uri", "path", "cb", "seq", "wire", "root", "ip", "fd", "bid", "ident", "ids", "oid", "ref"], "backend": ["frontid", " backender", "backender", "backward", "frontward", "frontend", " backid", "Backid", "Backender", "fronten", "Backended", " backward", "Backen", " backen", "backended", "Backward", "backen", "frontended", "backid", " backended", "Backend", "frontender"], "ret": ["gc", "reg", "mem", "complete", "val", "rec", "data", "rc", "buf", "lit", "obj", "res", "def", "RET", "lib", "exec", "result", "lex", "Ret", "re", "proc", "success", "ref", "aux", "fi", "conn"], "errp": ["erfp", "reqP", "errorr", "errpre", "reqps", "errorp", "errorpre", " errfp", "errP", "errpi", " errP", " errpi", "aceps", "err", " errps", "reqp", "errorfp", "errps", "errr", "erp", "acepi", "reqpi", "errfp", " errpre", "aceP", "acep", " errr", "erpre"], "chr": ["cherru", " chb", " chrt", "chb", "Chsr", "charr", "echrb", "chrc", "Chrb", " chrc", "cherrr", "archru", "chrt", "charrn", "chardr", "grri", "anchr", "grr", "chru", "chsr", "schr", "chrg", "Chrn", "cher", "Chrt", "echr", " chsr", "Chr", "anchrg", "cherr", " chdr", "echb", "schrt", "cherb", " chrg", "chert", "charrt", "cherri", "grrr", "charrb", "chrn", "Chrc", "archri", " chrn", "chrb", "chri", "schrb", "echsr", "chern", " chrb", "charrg", "anchdr", "chrr", "archrr", "schrn", "chdr", "grru", "archr", "anchrt", "Chb", "cherc"], "common": ["fast", "cmp", "complex", "recent", "parent", "security", "family", "normal", "Common", "info", "valid", "known", "foreign", "client", "standard", "document", "specific", "conf", "native", "con", "control", "basic", "comment", "public", "lib", "ctx", "context", "shared", "global", "custom", "central", "util", "broad", "cache", "general", "generic"]}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4609, "substitutes": {"s": ["stat", "as", "o", "sets", "v", "is", "S", "a", "spec", "sg", "session", "socket", "si", "sync", "sys", "ses", "m", "services", "status", "its", "states", "in", "xs", "f", "ns", "d", "ls", "args", "service", "ss", "hs", "conf", "cs", "sis", "e", "u", "sb", "ops", "ks", "se", "gs", "ds", "qs", "t", "ts", "su", "self", "p", "south", "settings", "aws", "sv", "fs", "c", "os", "g", "ssl", "sq", "sym", "site", "syn", "es", "ps", "js"], "mode": [" modes", "MODE", "name", "gone", "dim", "dm", "ward", "md", "dd", "device", "Mode", " module", "style", "mo", "phase", "module", "ace", "mac", "de", "rage", "side", "grade", "state", "mod", "loop", "sid", "table", "cli", "code", "kind", "driver", "iden", "ode", "source", "ODE", "scale", "stage", "direction", "level", "range", "slave", "type", " m", "no", "lane", "role"], "key": ["name", "row", "er", "id", "fee", "x", " Key", "data", "pe", "info", "ace", "sk", "client", "order", "state", "j", "call", "keys", "service", "net", "match", "code", "e", "ck", "KEY", "error", "connection", "k", "cor", "ctx", "kid", "ey", "lock", "result", "ee", "ie", "kw", "ke", "ip", "type", "class", "Key", "link", "query", " connection", "group", "index", "seed"], "pkt": ["cpct", "payacket", "cpkt", "Pkt", "payet", " pet", "Pck", "ppk", "ppelt", "ppkt", "pct", " pwk", "Picket", "apet", "paracket", "pck", " pnt", "Pcht", "pwk", "payicket", "paykt", "ppnt", "Pk", "ppck", "ppacket", "pet", "ppet", "apkt", "Pnt", "apacket", "Packet", "ppwk", "Pelt", "apcht", "pcht", "parct", " pct", "cpet", " pck", "cpacket", "picket", "Pct", " pk", " picket", "pk", " pcht", "Pwk", "pnt", "packet", "parcht", "cpelt", "Pet", "parkt", "pelt", " packet"], "conn": ["cp", "rn", "gate", "ch", "act", "nw", "ann", "reg", "rt", "comm", "dn", "nt", "sg", "ci", "session", "wan", "po", "config", "nc", "sync", "oa", "enc", "cat", "ad", "co", "cm", "db", "ga", "client", "pg", "ns", "org", "pc", "ai", "connect", "cc", "conf", "cs", "con", "mc", "connection", "auth", "en", "dc", "cmd", "ctx", "n", "go", "oss", "Conn", "p", "ca", "ec", "c", "g", "ct", "cn", "core", "lc", "cf", "adj", "ac", "syn", "gn"]}}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)\n\n{\n\n    int i;\n\n    for(i=0; i<4 && tags[i]; i++){\n\n        enum CodecID id= codec_get_id(tags[i], tag);\n\n        if(id!=CODEC_ID_NONE) return id;\n\n    }\n\n    return CODEC_ID_NONE;\n\n}\n", "idx": 4610, "substitutes": {"tags": ["groups", "types", "strings", "packages", "cases", "users", "Tags", "bands", "s", "ags", "features", "atts", "words", "nets", "mat", "styles", "rows", "tools", "xml", "names", "cats", "codes", "images", "heads", "stats", "ports", "relations", "terms", "fields", "classes", "ks", "tests", "ts", "reports", "jobs", "devices", "p", "chains", "bugs", "phones", "blocks", "bags", "members", "c", "ims", "frames", "ids", "ps", "boxes"], "tag": ["patch", "option", "name", "time", "ig", "ag", "id", "count", "bug", "b", "Tag", "bit", "cat", "image", "loc", "key", "num", "TAG", "at", "length", "bad", "match", "code", "category", "comment", "port", "year", "attribute", "ind", "type", "month", "cache", "r", "date", "tail"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "a", "di", "ci", "xi", "x", "si", "b", "ri", "io", "slice", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "phi", "d", "ii", "j", "iu", "it", "ai", "init", "u", "e", "part", "uri", "k", "multi", "mi", "ini", "ie", "p", "h", "oi", "ind", "ip", "y", "li", "fi", "index", "r", "end", "ui"]}}
{"project": "qemu", "commit_id": "27e0c9a1bbd166a67c16291016fba298a8e47140", "target": 0, "func": "static void ide_atapi_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n\n\n    if (s->identify_set) {\n\n\tmemcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));\n\n\treturn;\n\n    }\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    /* Removable CDROM, 50us response, 12 byte packets */\n\n    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));\n\n    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */\n\n    put_le16(p + 20, 3); /* buffer type */\n\n    put_le16(p + 21, 512); /* cache size in sectors */\n\n    put_le16(p + 22, 4); /* ecc bytes */\n\n    padstr((char *)(p + 23), s->version, 8); /* firmware version */\n\n    padstr((char *)(p + 27), \"QEMU DVD-ROM\", 40); /* model */\n\n    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */\n\n    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */\n\n    put_le16(p + 62, 7);  /* single word dma0-2 supported */\n\n    put_le16(p + 63, 7);  /* mdma0-2 supported */\n\n#else\n\n    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */\n\n    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */\n\n#endif\n\n    put_le16(p + 64, 3); /* pio3-4 supported */\n\n    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */\n\n    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */\n\n    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */\n\n    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */\n\n\n\n    put_le16(p + 71, 30); /* in ns */\n\n    put_le16(p + 72, 30); /* in ns */\n\n\n\n    if (s->ncq_queues) {\n\n        put_le16(p + 75, s->ncq_queues - 1);\n\n        /* NCQ supported */\n\n        put_le16(p + 76, (1 << 8));\n\n    }\n\n\n\n    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */\n\n#endif\n\n    memcpy(s->identify_data, p, sizeof(s->identify_data));\n\n    s->identify_set = 1;\n\n}\n", "idx": 4611, "substitutes": {"s": ["sf", "S", "a", "features", "b", "i", "status", "f", "parts", "state", "service", "hs", "conf", "aws", "sp", "g", "sym", "y", "sets", "is", "spec", "services", "its", "states", "ls", "sl", "ds", "ts", "settings", "fs", "new", "sq", "ms", "your", "site", "rs", "as", "ins", "sg", "plugins", "comments", "sync", "ses", "ions", "cs", "sis", "e", "sb", "ks", "t", "qs", "c", "os", "ssl", "set", "r", "ps", "session", "si", "sys", "sts", "l", "xs", "ns", "stats", "args", "us", "ss", "gs", "se", "n", "es", "js"], "p": ["patch", "cp", "hp", "P", "o", "bp", "press", "v", "pr", "prev", "http", "progress", "pa", "pre", "po", "pp", "b", "data", "i", "x", "wp", "up", "pe", "lp", "ap", "m", "l", "op", "f", "pi", "post", "at", "pg", "mp", "j", "d", "pc", "q", "it", "py", "np", "u", "part", "e", "dp", "point", "ar", "per", "port", "t", "k", "n", "fp", "jp", "h", "z", "vp", "sp", "pointer", "proc", "c", "ip", "g", "y", "page", "br", "tp", "api", "pl", "current", "pb", "ps"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n", "idx": 4615, "substitutes": {"env": ["energy", "reset", "el", "environment", "password", "style", "et", "gui", "gear", "conf", "ev", "code", "her", "exec", "equ", "Environment", "enh", "ec", "stage", "vert", "dt", "engine", "conn", "ah", "vm", "config", "qt", "nc", "eu", "inet", "cal", "eye", "server", "assets", "ini", "ne", "viron", "eve", "site", "En", " environment", "forge", "agen", "end", "eng", "er", "dat", "esp", "exc", "db", "atten", "export", "ext", "esi", "net", "np", "e", "que", "en", "dev", "erv", "global", "core", "ette", "loader", "dict", "enable", "fen", "ea", "v", "enc", "event", "args", "init", "n", "context", "eni", "console", "cv", "esm", "manager", "cdn"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "a", "chi", "di", "s", "ci", "ni", "x", "b", "io", "si", "xi", "ri", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "iu", "ii", "d", "it", "ai", "vi", "u", "e", "w", "t", "k", "n", "multi", "mi", "ie", "p", "eni", "z", "hi", "c", "ip", "ind", "y", "li", "fi", "index", "zi", "ui"], "r": ["er", "sr", "v", "rb", "b", "x", "rc", "or", "m", "rh", "resource", "l", "ir", "ru", "like", "f", "attr", "d", "nr", "res", "e", "w", "ar", "rg", "arr", "ur", "k", "t", "n", "err", "rl", "lr", "str", "result", "p", "array", "run", "h", "R", "re", "mr", "c", "range", "g", "hr", "br", "rs", "rec"], "xsave": [" xparse", "axparse", "ypack", "mxsav", "xparse", "exparse", "axslave", "rxsav", "rxpose", "xiwrite", "xstore", "xisaving", "axappend", "xxstore", "exsav", "xpack", "sexsave", "txpose", "xpose", "mxsave", "xappend", "xapply", "xxappend", "crosssaving", "excreate", "xset", "xxparse", "sexape", " xave", "xsav", "sexsav", "rxsave", "yxscale", " xsav", "rxave", "wxstage", "Xsave", "axadd", "Xset", "plexapply", "xslave", " xstore", "xxsave", "plexset", "crossready", "xstage", "xisave", " xwrite", "xcreate", "xxwrite", "ysave", "sexparse", " xcreate", "exsave", "xxcreate", "txsav", "xscale", "yxsaving", "nexcreate", "mxadd", "axapply", "expack", "ysav", "crossave", "ycreate", " xappend", "nexsave", "Xparse", " xstage", "txsave", "axsav", "plexsave", "sexstage", "Xave", "Xpose", "xape", "exave", "axcreate", " xsaving", "xxslave", "xadd", "sexave", "wxsav", "xiready", "xxsav", "Xsav", "axwrite", "xicreate", "txave", "exslave", "xistore", "xwrite", " xapply", " xscale", "plexave", "crosssave", "xxapply", "Xready", "xxpack", "xready", "wxape", "xiave", "xave", "wxsave", " xape", "mxcreate", "xxadd", "axsave", "Xstage", "yxcreate", "xsaving", "yxsave", "nexscale", "Xsaving", "Xapply", " xset", "nexsaving"], "cwd": ["pcwn", "fnt", "cwl", "cwt", "cft", "fpt", "fcwa", "lcwn", "lcwk", "cwn", "rcwk", "cwk", "cnt", "scft", " cnt", "pcwd", "pcwk", "scwk", " cwt", "scmd", "cpt", "lcwd", "acmd", "cwa", "fcnt", "cws", "rcwd", "cmd", "fcpt", " cpt", "conft", "rcws", "scwd", "conmd", " cwl", "acwk", "conwk", "fcwd", "rcwl", "pcwt", "conwd", "acft", "lcwt", "fwa", " cwa", "fwd", " cwn", "acwl", " cws", "acwd", "acws", " cwk"], "swd": ["wwf", "swD", "wwl", "smd", "Sws", "ewf", "twp", "twsd", "SWds", "Swds", "wws", "ewd", "sms", "swl", "smsd", "ewp", " tws", "Swd", "SWD", "wwp", "Swl", "tws", "SWs", "SWd", " twt", "swt", " sws", "sws", " swf", " swt", " twds", "wwD", "swf", "twt", "twl", "swp", "ewds", " swds", "swds", "twds", "smp", " swp", "wwd", "swsd", "wwsd", "twD", "wwds"], "twd": ["wwf", " twl", "wwl", "twsd", " twc", "wws", "twc", "rwc", "swl", " tws", "rwl", "wxs", "sexf", "nwds", "tws", "swt", " twt", "sext", "nwsd", "wxd", "twf", "wwc", "sexl", "wwt", "wxt", "nwd", " twds", "twl", "twt", "swf", " twsd", "nwl", "swds", "twds", "rwd", "wwd", "rws", "wxl", "swsd", "sexd"], "fop": ["rfhop", "nop", " fhop", "coper", "infomp", "flops", "fops", "fomp", "homp", "infhop", " foper", "comp", "fhop", "floper", "infoper", "flop", "rfoper", "pop", "hoper", "nhop", "rfop", "flomp", "hop", "phop", "foper", "hhop", " fops", "noper", " fomp", "nomp", "cops", "infop", "cop", "poper"]}}
{"project": "FFmpeg", "commit_id": "57d04d3f11290d1848efa3b47031762f936d4cb3", "target": 1, "func": "static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,\n\n\tint numLines, int levelFix)\n\n{\n\n\tint i;\n\n\tif(levelFix)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\t\t\t\t\t\t\"pxor %%mm4, %%mm4\t\\n\\t\"\n\n\n\n#define SCALED_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm0 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm1 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n\telse\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\n\n#define SIMPLE_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n}\n", "idx": 4639, "substitutes": {"dst": [" dsts", "odsts", "odnt", " dsp", "dsp", "ldsp", "ldsts", "odsp", " dnt", "dsts", "odst", "ldnt", "dnt", "ldst"], "dstStride": ["dstScrite", "dststrite", "dstSTri", "dststide", "dblStride", "dblScri", "dstScri", "dstScide", "dblScrite", "dblStide", "dstStri", "dstSTide", "dblStrite", "dstStide", "dststride", "dstSTrite", "dstStrite", "dblScride", "dstSTride", "dstScride", "dststri", "dblStri", "dblScide"], "src": ["sub", "stat", "bin", "rb", "config", "ources", "rc", "data", "dest", "stream", "loc", "buf", "attr", "url", "gz", "rss", "lib", "rx", "cb", "ruby", "source", "seq", "proc", "ssl", "rob", "rec"], "srcStride": ["srcDestrite", "srcstOverride", "srcDestro", "srcStrite", "rcstOverride", "rcstrite", "srcstrite", "rcStro", "rcStrite", "srcstro", "rcstride", "srcDestOverride", "srcShro", "srcDestride", "srcShride", "rcStOverride", "srcstride", "srcStro", "rcStride", "srcShrite", "rcstro", "srcShOverride", "srcStOverride"], "numLines": ["numSlines", " numLocks", "numLcs", " numllines", " numlocks", " numLlines", " numLcs", "numLlines", "numlines", "numSlocks", "numllines", "numLocks", "numSllines", "numlocks", "numCllines", "numClines", " numlines", "numSlcs", "numClocks", "numClcs", "numlcs", " numlcs"], "levelFix": [" levelApply", "loopfix", "lvlfix", "layerCheck", "lvlFix", "loopFixed", " levelFIX", " levelMod", "typeCheck", "levelFIX", " levelFixed", "levelMod", "levelCheck", " levelCheck", "loopFIX", "loopFix", "levelfix", "layerMod", "layerApply", "layerFix", "lvlFixed", "typeApply", "typeFix", " levelfix", "typeMod", "levelApply", "levelFixed", "lvlFIX"], "i": ["v", "I", "is", "a", "ci", "b", "bi", "m", "l", "f", "pi", "phi", "j", "ii", "d", "it", "ai", "e", "L", "k", "n", "p", "line", "c", "ip", "li", "index", "r"]}}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n", "idx": 4645, "substitutes": {"tpm2_ptr": ["tpm2_loc", "tpm2_cur", "tpm1_req", "tpm1_tr", "tpm2__src", "tpm1_desc", "tpm2__ref", "tpm1_ref", "tpm1_str", "tpm2_sth", "tpm2Optr", "tpm2__fd", "tpm2_Ptr", "tpm1_loc", "tpm2Oloc", "tpm1_cur", "tpm2Opointer", "tpm2_pointer", "tpm1_buffer", "tpm1_pert", "tpm1_Ptr", "tpm2__buffer", "tpm2__loc", "tpm2_req", "tpm2Oref", "tpm2__ptr", "tpm2_src", "tpm2_ref", "tpm1_src", "tpm1_addr", "tpm2_tr", "tpm2__req", "tpm2_fd", "tpm2_str", "tpm2__pointer", "tpm1_ptr", "tpm2_desc", "tpm2_buffer", "tpm1_sth", "tpm2_addr", "tpm1_fd", "tpm1_pointer", "tpm2_pert"]}}
{"project": "FFmpeg", "commit_id": "ae93965359e71c1f88ba170f8efd6a198344c235", "target": 1, "func": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)\n\n{\n\n    do {\n\n        int nb_output = 0;\n\n        int min_poc   = INT_MAX;\n\n        int i, min_idx, ret;\n\n\n\n        if (s->sh.no_output_of_prior_pics_flag == 1) {\n\n            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n                HEVCFrame *frame = &s->DPB[i];\n\n                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&\n\n                        frame->sequence == s->seq_output) {\n\n                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n                }\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n            HEVCFrame *frame = &s->DPB[i];\n\n            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&\n\n                frame->sequence == s->seq_output) {\n\n                nb_output++;\n\n                if (frame->poc < min_poc) {\n\n                    min_poc = frame->poc;\n\n                    min_idx = i;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* wait for more frames before output */\n\n        if (!flush && s->seq_output == s->seq_decode && s->sps &&\n\n            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)\n\n            return 0;\n\n\n\n        if (nb_output) {\n\n            HEVCFrame *frame = &s->DPB[min_idx];\n\n            AVFrame *dst = out;\n\n            AVFrame *src = frame->frame;\n\n            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n\n            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);\n\n\n\n            ret = av_frame_ref(out, src);\n\n            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);\n\n            else\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < 3; i++) {\n\n                int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n\n                int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n\n                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +\n\n                          (frame->window.top_offset   >> vshift) * dst->linesize[i];\n\n                dst->data[i] += off;\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"Output frame with POC %d.\\n\", frame->poc);\n\n            return 1;\n\n        }\n\n\n\n        if (s->seq_output != s->seq_decode)\n\n            s->seq_output = (s->seq_output + 1) & 0xff;\n\n        else\n\n            break;\n\n    } while (1);\n\n\n\n    return 0;\n\n}\n", "idx": 4668, "substitutes": {"s": ["sf", "S", "a", "b", "f", "parts", "d", "service", "conf", "w", "self", "h", "aws", "g", "sym", "y", "sets", "is", "spec", "slice", "services", "states", "server", "sl", "ls", "ops", "sim", "ds", "ts", "outs", "south", "settings", "z", "fs", "new", "sq", "site", "rs", "as", "ins", "single", "sync", "ses", "cs", "e", "sb", "ks", "t", "qs", "source", "p", "c", "os", "ssl", "frames", "r", "ps", "o", "http", "less", "scope", "session", "si", "sys", "in", "m", "l", "xs", "side", "ns", "space", "us", "ss", "uns", "gs", "se", "full", "n", "request", "sample", "es", "js"], "out": ["OUT", "flow", "o", "ch", "block", "v", "config", "b", "op", "x", "sys", "in", "m", "image", "f", "ext", "conv", "call", "obj", "init", "point", "w", "fn", "t", "cmd", "n", "err", "outs", "source", "p", "output", "again", "req", "doc", "line", "c", "Out", "new", "g", "orig", "ref", "r", "img"], "i": ["base", "gi", "r", "ti", "v", "id", "I", "di", "ci", "ni", "x", "xi", "si", "io", "slice", "ri", "b", "info", "bi", "in", "m", "qi", "module", "ix", "l", "key", "num", "image", "f", "pi", "yi", "phi", "j", "iu", "ii", "it", "ai", "split", "u", "vi", "e", "uri", "ori", "multi", "mi", "ini", "ie", "p", "mini", "eni", "start", "oi", "hi", "c", "ip", "g", "y", "li", "fi", "index", "zi", "mu", "ui"], "min_idx": ["min_dc", "min_dz", "min_exitp", "min__IdX", "min_inc", "min_dxb", "min__idxs", "min_Idp", "min_midc", "min_inxs", "min_indy", "min_exitom", "min_dx", "min_indx", "min_indom", "min_idz", "min_idc", "min_idp", "min__Idx", "min_midx", "min_Idx", "min_midxs", "min_exity", "min_Idy", "min_Idxb", "min__idc", "min_Idom", "min__idx", "min_idom", "min_Idxs", "min_Idc", "min_inx", "min_Idz", "min__Idc", "min_idX", "min_idy", "min__Idxs", "min_inX", "min_midX", "min_exitx", "min_idxs", "min__idX", "min_IdX", "min_indp", "min_idxb"], "ret": ["std", "rt", "mem", "alt", "nt", "val", "rc", "final", "bit", "flat", "reply", "info", "fin", " Ret", "lit", "att", "arg", "res", "def", "part", "len", "det", "en", "arr", "full", "RET", "feat", "str", "result", "Ret", "ft", "re", "xt", "fun", "gt", "ref", "fi", "img", "rets"], "frame": ["flow", "layer", "position", "component", "pse", "object", "iframe", "style", "unit", "ace", "sequence", "f", "rame", "state", "document", "code", "zone", "file", "fram", "motion", "framework", "stage", "line", "fi", "setup", "scene", "function", "config", "layout", "slice", "module", "target", "driver", "cycle", "filename", "process", "parse", "scale", "node", "cf", "video", "element", "hole", "ze", "feature", "game", "fr", "phy", "block", "flower", "sche", "face", "image", "loc", "Frame", "profile", "version", "e", "point", "que", "message", "feat", "source", "run", "c", "core", "frames", "fen", "screen", "cfg", "scope", "session", "up", "format", "draw", "window", "call", "fe", "plane", "coll", "figure", "sample", "host", "date"], "nb_output": ["nb_hidden", "nb67config", "nllogoutput", "nl_update", "nb67target", "nb2generated", "np_input", "np_return", "nllogconfig", "nblogconfig", "nblogupdate", "nb_generated", "nb64generated", "nb_config", "nb64input", "nllogtarget", "nb_stop", "blog_update", "nc64generated", "blog_generated", "nc_stop", "nl_target", "nc_output", "nb2update", "np_hidden", "nb64output", "nc_input", "nc_generated", "blog_output", "nb67update", "nbloghidden", "nc64stop", "nb_input", "nc64output", "blog_export", "nbloginput", "nb_export", "nc64input", "nblogreturn", "nblogoutput", "nl_config", "nb_update", "nb2output", "nb_target", "nl_output", "nllogupdate", "nb67output", "nb2export", "nb_return", "nblogtarget", "nb64stop", "np_output"], "dst": [" dsc", "Dst", "fbl", "fsrc", "Dsrc", "dbl", " dbl", "Dsc", " dsrc", "fst", "Dbl", "dsrc", "dsc", "fsc"], "src": ["sub", "scene", "stat", "host", "sr", "sec", "spec", "rb", "config", "rc", "sync", "sn", "slice", "comp", "record", "sys", "dest", "loc", "image", "buf", "attr", "url", "sl", "dist", "sc", "target", "sb", "inst", "ctx", "bc", "cb", "feat", "source", "seq", "gl", "gb", "sup", "node", "proc", "sel", "fc", "ref", "rs", "img", "rec", "setup"], "desc": ["sub", "reg", "sec", "config", "disc", "data", "rc", "enc", "comp", "info", "dest", "loc", "de", "attr", "meta", "d", "description", "dist", "des", "def", "dir", "code", "sc", "Desc", "comment", "dc", "esc", "bc", "doc", "gen", "dep", "decl", "asc", "text", "ref", "rec"]}}
{"project": "FFmpeg", "commit_id": "4b9ac0b5f070f35eff671d83cee436db40631112", "target": 0, "func": "static int mpegaudio_parse(AVCodecParserContext *s1,\n\n                           AVCodecContext *avctx,\n\n                           uint8_t **poutbuf, int *poutbuf_size, \n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    MpegAudioParseContext *s = s1->priv_data;\n\n    int len, ret;\n\n    uint32_t header;\n\n    const uint8_t *buf_ptr;\n\n\n\n    *poutbuf = NULL;\n\n    *poutbuf_size = 0;\n\n    buf_ptr = buf;\n\n    while (buf_size > 0) {\n\n\tlen = s->inbuf_ptr - s->inbuf;\n\n\tif (s->frame_size == 0) {\n\n            /* special case for next header for first frame in free\n\n               format case (XXX: find a simpler method) */\n\n            if (s->free_format_next_header != 0) {\n\n                s->inbuf[0] = s->free_format_next_header >> 24;\n\n                s->inbuf[1] = s->free_format_next_header >> 16;\n\n                s->inbuf[2] = s->free_format_next_header >> 8;\n\n                s->inbuf[3] = s->free_format_next_header;\n\n                s->inbuf_ptr = s->inbuf + 4;\n\n                s->free_format_next_header = 0;\n\n                goto got_header;\n\n            }\n\n\t    /* no header seen : find one. We need at least MPA_HEADER_SIZE\n\n               bytes to parse it */\n\n\t    len = MPA_HEADER_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    if (len > 0) {\n\n\t\tmemcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t\tbuf_ptr += len;\n\n\t\tbuf_size -= len;\n\n\t\ts->inbuf_ptr += len;\n\n\t    }\n\n\t    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {\n\n            got_header:\n\n\t\theader = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n\t\t    (s->inbuf[2] << 8) | s->inbuf[3];\n\n\n\n                ret = mpa_decode_header(avctx, header);\n\n                if (ret < 0) {\n\n\t\t    /* no sync found : move by one byte (inefficient, but simple!) */\n\n\t\t    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\t    s->inbuf_ptr--;\n\n                    dprintf(\"skip %x\\n\", header);\n\n                    /* reset free format frame size to give a chance\n\n                       to get a new bitrate */\n\n                    s->free_format_frame_size = 0;\n\n\t\t} else {\n\n                    s->frame_size = ret;\n\n#if 0\n\n                    /* free format: prepare to compute frame size */\n\n\t\t    if (decode_header(s, header) == 1) {\n\n\t\t\ts->frame_size = -1;\n\n                    }\n\n#endif\n\n\t\t}\n\n\t    }\n\n        } else \n\n#if 0\n\n        if (s->frame_size == -1) {\n\n            /* free format : find next sync to compute frame size */\n\n\t    len = MPA_MAX_CODED_FRAME_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n            if (len == 0) {\n\n\t\t/* frame too long: resync */\n\n                s->frame_size = 0;\n\n\t\tmemmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\ts->inbuf_ptr--;\n\n            } else {\n\n                uint8_t *p, *pend;\n\n                uint32_t header1;\n\n                int padding;\n\n\n\n                memcpy(s->inbuf_ptr, buf_ptr, len);\n\n                /* check for header */\n\n                p = s->inbuf_ptr - 3;\n\n                pend = s->inbuf_ptr + len - 4;\n\n                while (p <= pend) {\n\n                    header = (p[0] << 24) | (p[1] << 16) |\n\n                        (p[2] << 8) | p[3];\n\n                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n                        (s->inbuf[2] << 8) | s->inbuf[3];\n\n                    /* check with high probability that we have a\n\n                       valid header */\n\n                    if ((header & SAME_HEADER_MASK) ==\n\n                        (header1 & SAME_HEADER_MASK)) {\n\n                        /* header found: update pointers */\n\n                        len = (p + 4) - s->inbuf_ptr;\n\n                        buf_ptr += len;\n\n                        buf_size -= len;\n\n                        s->inbuf_ptr = p;\n\n                        /* compute frame size */\n\n                        s->free_format_next_header = header;\n\n                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;\n\n                        padding = (header1 >> 9) & 1;\n\n                        if (s->layer == 1)\n\n                            s->free_format_frame_size -= padding * 4;\n\n                        else\n\n                            s->free_format_frame_size -= padding;\n\n                        dprintf(\"free frame size=%d padding=%d\\n\", \n\n                                s->free_format_frame_size, padding);\n\n                        decode_header(s, header1);\n\n                        goto next_data;\n\n                    }\n\n                    p++;\n\n                }\n\n                /* not found: simply increase pointers */\n\n                buf_ptr += len;\n\n                s->inbuf_ptr += len;\n\n                buf_size -= len;\n\n            }\n\n\t} else \n\n#endif\n\n        if (len < s->frame_size) {\n\n            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)\n\n                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;\n\n\t    len = s->frame_size - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    memcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t    buf_ptr += len;\n\n\t    s->inbuf_ptr += len;\n\n\t    buf_size -= len;\n\n\t}\n\n        //    next_data:\n\n        if (s->frame_size > 0 && \n\n            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n\n            *poutbuf = s->inbuf;\n\n            *poutbuf_size = s->inbuf_ptr - s->inbuf;\n\n\t    s->inbuf_ptr = s->inbuf;\n\n\t    s->frame_size = 0;\n\n\t    break;\n\n\t}\n\n    }\n\n    return buf_ptr - buf;\n\n}\n", "idx": 4681, "substitutes": {"s1": ["s81", "cone", "sone", "c2", "ts1", "c1", "ds2", "tsone", "s2", "S2", "dsone", "s0", "sp0", "S1", "gs1", "gs2", "ds11", "ts11", "ds1", "gs0", "sp81", "gs81", "sp1", "c11", "s11", "ts2", "S81", "S0", "sp2"], "avctx": ["akcontext", "awctx", "akconfig", "maccp", "AVctx", "afcmp", "avconfig", "AVcontext", "avcmp", "awkb", "macconfig", "afkb", "macctx", "akctx", "afctx", "afcp", "avcontext", "avcp", "AVcmp", "maccontext", "awcontext", "akcp", "afcontext", "avkb", "afconfig", "awcmp", "AVkb"], "poutbuf": ["pinfb", "pOutqueue", "poutfb", "mpoutbuffer", "painsbuffer", "pargfp", "mpoutqueue", "p_buffer", "pOutfb", "painsfb", " p_buf", "pagainfp", "pinqueue", "pagainbuf", "mpinfb", "pagainbuff", "mpinbuffer", " poutbuff", " p_buff", "pagainbuffer", "mpinbuf", "mpoutbuf", "pOutbuf", "p_fp", "painsbuf", "pOutbuffer", "poutbuffer", "pargbuf", "p_buff", "poutbuff", "pargbuffer", " p_fp", " p_buffer", "pinbuf", "pinbuffer", "poutfp", " poutfp", "poutqueue", "painsqueue", "mpoutfb", "p_buf", "pargbuff", "mpinqueue", " poutbuffer"], "poutbuf_size": ["poutbuf___size", "poutbuf_sized", "poutfile_unit", "poutbuf___capacity", "poutbuf_capacity", "poutbuf___unit", "poutfile_scale", "poutbuf_unit", "poutqueue_sized", "poutbuf___scale", "poutqueue_Size", "poutfile_capacity", "poutbuf_scale", "poutqueue_size", "poutbuf_Size", "poutfile_size"], "buf": ["buff", "vec", "block", "rb", "tmp", "b", "data", "queue", "uc", "fb", "wb", "uf", "null", "window", "offset", "length", "buffer", "Buffer", "cmd", "ctx", "bc", "fp", "cb", "empty", "filename", "seq", "uint", "zero", "alloc", "cf", "cv", "pb", "src"], "buf_size": ["bufacsync", "bufFbody", "buf_sized", "queue_Size", "wav_pos", "buff_sync", "bufCsize", "frame_style", "frame67size", "queue_capacity", "buf_len", "buff_body", "wavfsized", "buf_sec", "bufqpos", "frame_size", "frame67start", "wavfpos", "buff2sec", "bufacsize", "buffSize", "bufCSize", "bufFsize", "buffstart", "buf2pos", "buffstyle", "buf_pos", "wavfsize", "buff2body", "buf67start", "buffpos", "bufClen", "wav_size", "buf2sized", "frame_start", "buf_body", "queue_size", "wav_sized", "queue_len", "buff_size", "buffsized", "buff2size", "buff2sync", "buf_style", "bufFsync", "buf_capacity", "fb_number", "bufqsize", "buf2body", "fb_pos", "fbqSize", "buf67style", "wavfcapacity", "buf2capacity", "buf67Size", "fb_Size", "frame67style", "buf_number", "buf2sync", "buffcapacity", "buf67size", "buf_start", "bufqSize", "frame67Size", "wav_capacity", "fbqpos", "fb_size", "buff_sec", "bufacbody", "fbqsize", "frame_Size", "fbqnumber", "bufacsec", "buf2sec", "bufFsec", "buf_Size", "bufCcapacity", "bufqnumber", "buf_sync", "buffsize", "buf2size"], "s": ["sf", "S", "a", "b", "data", "i", "f", "parts", "d", "service", "hs", "conf", "w", "self", "h", "sa", "g", "sym", "y", "sets", "is", "spec", "services", "its", "states", "server", "ls", "ops", "bis", "ds", "ctx", "ts", "sv", "fs", "new", "sq", "ms", "site", "rs", "as", "strings", "ans", "ins", "sg", "comments", "sync", "ses", "has", "cs", "u", "vs", "e", "ks", "secondary", "qs", "t", "c", "os", "ssl", "ims", "r", "ps", "o", "v", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "us", "ss", "uns", "gs", "se", "full", "n", "su", "es", "js"], "len": ["dy", "vec", "mem", "el", "count", "la", "nt", "lt", "val", "lan", "data", "elt", "non", "lp", "ll", "loc", "l", "num", "fin", "f", "lit", "ler", "fl", "length", "ls", "sl", "limit", "split", "code", "low", "en", "L", "ul", "n", "lib", "hl", "led", "lon", "rev", "ie", "seq", "span", "z", "pos", "gen", "fun", "ln", "Len", "ind", "line", "ld", "lin", "lc", "dl", "li", "il", "bl", "pl", "lf", "lim", "conn", "le", "size"], "ret": ["del", "flag", "reg", "bin", "rt", "red", "sr", "alt", "count", "nt", "val", "rc", "reply", "fin", "num", "lit", " Ret", "att", "obj", "arg", "res", "match", "det", "en", "arr", "RET", "ben", "err", "str", "rev", "result", "Ret", "ft", "opt", "usr", "re", "fun", "back", "hash", "resp", "success", "ref", "no", "conn", "rets", "msg"], "header": ["writer", "dr", "name", "layer", "er", "rr", "pin", "config", "cover", "pillar", "data", "final", "rf", "body", "title", "null", "fb", "offset", "f", "event", "player", "meta", "version", "description", "buffer", "code", "definition", "margin", "section", "Header", "her", "message", "forward", "headers", "fp", "cb", "response", "filename", "str", "border", "result", "over", "err", "h", "protected", "column", "line", "ln", "cap", "detail", "head", "type", "cf", "dt", "pair", "cookie", "conn", "tail", "prefix"], "buf_ptr": [" buf_flush", " buf_ctr", " buf_pointer", "bufUptr", "buf_pointer", "queue_addr", "bufUflush", "queue_pointer", "buf_ctr", "bufUsize", "buf_addr", "buf_flush", "queue_size", "buf_loc", "queue_ptr", " buf_loc", "bufUpointer"], "inbuf_ptr": ["infb_size", "inqueue_fd", "inbufNcur", "inbuf_slice", "inbuf_size", "inbuf0offset", "inbuf_err", "infb_pointer", "inbufNptr", "inqueue_pointer", "inbuf_ctr", "inqueue_loc", "inbuf_fd", "infb_ptr", "inbufNpointer", "inbuf0pointer", "inqueue_ptr", "inbuf_pointer", "inbuf_Ptr", "inbuf0ptr", "inbuf0tr", "inbuf_que", "inqueue_err", "infb_loc", "inbuf0que", "inbuf_cur", "inqueue_cur", "inbuf_tr", "inbufNerr", "inbuf_offset", "inbuf_loc"]}}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n    JNIEnv *env = NULL;\n\n\n\n    *attached = 0;\n\n\n\n    pthread_mutex_lock(&lock);\n\n    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {\n\n\n\n        av_log(log_ctx, AV_LOG_INFO, \"Retrieving current Java virtual machine using Android JniInvocation wrapper\\n\");\n\n        if (check_jni_invocation(log_ctx) == 0) {\n\n            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libdvm.so\", log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libart.so\", log_ctx)) != NULL) {\n\n                av_log(log_ctx, AV_LOG_INFO, \"Found Java virtual machine using Android JniInvocation wrapper\\n\");\n\n            }\n\n        }\n\n    }\n\n    pthread_mutex_unlock(&lock);\n\n\n\n    if (!java_vm) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not retrieve a Java virtual machine\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);\n\n    switch(ret) {\n\n    case JNI_EDETACHED:\n\n        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Failed to attach the JNI environment to the current thread\\n\");\n\n            env = NULL;\n\n        } else {\n\n            *attached = 1;\n\n        }\n\n        break;\n\n    case JNI_OK:\n\n        break;\n\n    case JNI_EVERSION:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"The specified JNI version is not supported\\n\");\n\n        break;\n\n    default:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Failed to get the JNI environment attached to this thread\");\n\n        break;\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 4685, "substitutes": {"attached": ["atached", "assapped", "attachributed", "detapped", "attachment", "hatach", "attatched", "assatched", "attach", "attachached", "attapped", " attach", " attapped", "attributed", "Attached", "hatributed", "atach", "ATTributed", "Attach", "attracted", "hatached", "assached", "ATTached", "Attachment", "ATTach", "attachach", "atatched", "Attapped", "attachracted", "hatracted", "atapped", "assach", "detach", "detached", "detachment", " attatched", "ATTracted", "assachment"], "log_ctx": ["logPctx", "logjloc", "logureconsole", " log_loc", "logvalctx", "logingcf", "la_tx", "modelboardchannel", "lex_loc", "loglcn", "log_cur", "log_service", "log_conn", "log_cor", "la_service", "lex_cf", "logLogctx", "logWservice", "logurectx", "loglctx", "write_conn", "logallctx", "logvalloc", "logingctx", "logMspec", "bug_connection", "LOGlctx", "logxconfig", "log_lc", "model_lc", "logvalconnection", "logplechannel", "bug_loc", "loglexconsole", "loglogcur", "loglercf", "logingcourse", "logPconsole", "logWtx", "logjcur", "logMctx", "loglexcb", "logerctx", "model_csv", "lex_ctx", "logPcb", "logjctx", "writeurecb", "logllc", "logercf", "writeureconsole", "laWspec", "base_lc", "baseerlc", "logvalcontext", "logboardcsv", "model_ctx", "base_cf", "base_tx", "logboardlc", "logingcas", "LOGlloc", "baseercf", " log_course", " log_cu", "logplecsv", "logWctx", "logertx", "logLogloc", "Log_ctx", "logxcu", "baseerctx", "LOG_tx", " log_cb", "loglogco", "loglogloc", "logjco", "logurecb", "laWservice", "log_tx", "loglconfig", "bug_context", " log_config", "log_loc", "LOG_cas", " log_tx", "log_connection", "logxloc", "log_cas", "log_co", "logingtx", "la_spec", "logWspec", " log_lc", "LOG_cn", "LOGingcontext", "log_config", "LOGingctx", "LOGlcor", "logureconn", "model_channel", "write_cb", "write_console", "LOGingcas", "loglerctx", "writeureconn", "log_course", "logltx", "logxctx", "log_location", "logplectx", "log_console", "baseertx", "log_cu", "bug_ctx", "log_cf", "logLloc", "logallconfig", "laWtx", "laWctx", " log_cf", "logMservice", "logMtx", "Log_cur", "LOG_loc", "logerlc", "log_csv", "loglercb", "LOGingtx", "loglloc", "logLctx", "loglogctx", "logLogcf", "loglercourse", "lex_location", "logalltx", "logplelc", "LOG_ctx", "logPconn", "logingcb", "LOG_context", "log_context", "log_channel", "modelboardcsv", "LOG_cor", "modelboardlc", "logingcontext", "loglexconn", "writeurectx", "logboardctx", "logLoglocation", "loglcor", "LOGlcn", "Log_loc", "loglexctx", "log_spec", "la_ctx", "base_ctx", "Log_co", "write_ctx", "logalllc", "logLcf", "logboardchannel", "log_cb", "modelboardctx", "log_cn", "logLlocation"], "env": ["vr", "reset", "ef", "environment", "ex", "data", "style", "password", "et", "gear", "align", "conf", "ev", "code", "RET", "empty", "err", "equ", "Environment", "rev", "ec", "output", "conn", "extra", "vm", "config", "val", "eval", "viron", "back", "cf", "addr", "end", "rt", "dat", "sg", "tmp", "vel", "exc", "loc", "db", "export", "ext", "np", "vs", "e", "en", "dev", "erv", "dep", "api", "lv", "cache", "app", "ref", "dict", "enable", "ea", "ret", "v", "scope", "session", "alias", "enc", "window", "attr", "init", "endif", "lock", "result", "context", "req", "console", "cv"]}}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    Qcow2COWRegion *start = &m->cow_start;\n\n    Qcow2COWRegion *end = &m->cow_end;\n\n    unsigned buffer_size;\n\n    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);\n\n    bool merge_reads;\n\n    uint8_t *start_buffer, *end_buffer;\n\n    QEMUIOVector qiov;\n\n    int ret;\n\n\n\n    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);\n\n    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);\n\n    assert(start->offset + start->nb_bytes <= end->offset);\n\n    assert(!m->data_qiov || m->data_qiov->size == data_bytes);\n\n\n\n    if (start->nb_bytes == 0 && end->nb_bytes == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* If we have to read both the start and end COW regions and the\n\n     * middle region is not too large then perform just one read\n\n     * operation */\n\n    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;\n\n    if (merge_reads) {\n\n        buffer_size = start->nb_bytes + data_bytes + end->nb_bytes;\n\n    } else {\n\n        /* If we have to do two reads, add some padding in the middle\n\n         * if necessary to make sure that the end region is optimally\n\n         * aligned. */\n\n        size_t align = bdrv_opt_mem_align(bs);\n\n        assert(align > 0 && align <= UINT_MAX);\n\n        assert(QEMU_ALIGN_UP(start->nb_bytes, align) <=\n\n               UINT_MAX - end->nb_bytes);\n\n        buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes;\n\n    }\n\n\n\n    /* Reserve a buffer large enough to store all the data that we're\n\n     * going to read */\n\n    start_buffer = qemu_try_blockalign(bs, buffer_size);\n\n    if (start_buffer == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n    /* The part of the buffer where the end region is located */\n\n    end_buffer = start_buffer + buffer_size - end->nb_bytes;\n\n\n\n    qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0));\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    /* First we read the existing data from both COW regions. We\n\n     * either read the whole region in one go, or the start and end\n\n     * regions separately. */\n\n    if (merge_reads) {\n\n        qemu_iovec_add(&qiov, start_buffer, buffer_size);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n    } else {\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov);\n\n    }\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Encrypt the data if necessary before writing it */\n\n    if (bs->encrypted) {\n\n        if (!do_perform_cow_encrypt(bs, m->offset, start->offset,\n\n                                    start_buffer, start->nb_bytes) ||\n\n            !do_perform_cow_encrypt(bs, m->offset, end->offset,\n\n                                    end_buffer, end->nb_bytes)) {\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* And now we can write everything. If we have the guest data we\n\n     * can write everything in one single operation */\n\n    if (m->data_qiov) {\n\n        qemu_iovec_reset(&qiov);\n\n        if (start->nb_bytes) {\n\n            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        }\n\n        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);\n\n        if (end->nb_bytes) {\n\n            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        }\n\n        /* NOTE: we have a write_aio blkdebug event here followed by\n\n         * a cow_write one in do_perform_cow_write(), but there's only\n\n         * one single I/O operation */\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n    } else {\n\n        /* If there's no guest data then write both COW regions separately */\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);\n\n    }\n\n\n\nfail:\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    /*\n\n     * Before we update the L2 table to actually point to the new cluster, we\n\n     * need to be sure that the refcounts have been increased and COW was\n\n     * handled.\n\n     */\n\n    if (ret == 0) {\n\n        qcow2_cache_depends_on_flush(s->l2_table_cache);\n\n    }\n\n\n\n    qemu_vfree(start_buffer);\n\n    qemu_iovec_destroy(&qiov);\n\n    return ret;\n\n}\n", "idx": 4697, "substitutes": {"bs": ["bas", "lb", "ins", "is", "bt", "b", "bm", "ses", "bi", "BS", "obs", "fb", "db", "bes", "ns", "ls", "iss", "bb", "ss", "cs", "vs", "sb", "banks", "ks", "bis", "ds", "bc", "cb", "cms", "ab", "mb", "aws", "gb", "fs", "sa", "os", "ms", "bos", "bid", "bl", "pb", "es", "src", "bh", "js"], "m": ["machine", "o", "dm", "arm", "v", "gm", "md", "om", "M", "b", "i", "wm", "bm", "module", "l", "pm", "f", "mp", "meta", "d", "sm", "j", "mod", "man", "u", "e", "mt", "mc", "an", "hm", "t", "k", "n", "tm", "mi", "p", "fm", "h", "mr", "am", "c", "g", "mm", "ms", "y", "um", "ym", "im", "r", "manager", "cm", "mode"], "s": ["v", "sec", "is", "S", "spec", "scope", "session", "b", "si", "ses", "services", "states", "f", "ns", "state", "d", "sl", "sm", "args", "service", "ss", "cs", "conf", "e", "w", "gs", "ops", "storage", "ds", "n", "t", "ts", "p", "settings", "fs", "sa", "c", "os", "g", "ssl", "ms", "params", "rs", "r"], "start": ["name", "st", "id", "open", "cur", "check", "get", "mid", "config", "starting", "pre", "last", "style", "use", "data", "sync", "i", "ad", "art", "info", "in", "l", "sk", "offset", "post", "state", "grade", "it", "init", "from", "part", "stop", "sh", "all", "Start", "se", "en", "k", "first", "self", "load", "work", "source", "p", "ie", "old", "scale", "parse", "and", "sp", "pos", "step", "ind", "range", "head", "new", "next", "current", "set", "min", "max", "diff", "seed", "add"], "end": ["address", "END", "est", "append", "id", "open", "alt", "entry", "send", "edge", "get", "mid", "update", "last", "use", "or", "enc", "ad", "dest", "art", "ending", "ion", "offset", "post", "event", "order", "export", "add", "client", "ended", "server", "e", "size", "E", "w", "f", "en", "se", "dev", "stop", "k", "after", "win", "ent", "p", "old", "begin", "and", "z", "line", "range", "head", "orig", "um", "env", "inner", "ord", "ed", "set", "max", "nd", "End"], "buffer_size": ["bufferlexscale", "buffer_max", "table_number", "bufferlexoffset", "queue_offset", "buffer_strength", "bufferlexsize", "buffer32size", "header_bytes", "buffer32shift", "uffer_range", "table_sized", "buffer64strength", "queue_shape", "buffer_shape", "buffer_range", "buffer32scale", "table_capacity", "buffer_shift", "buffer64range", "queue_size", "buffer_sized", "buffer_bytes", "bufferlexshift", "table_size", "header_size", "buffer64fee", "buffer32offset", "buffer_scale", "queue_max", "buffer_capacity", "uffer_size", "header_len", "buffer_number", "queue_shift", "uffer_strength", "buffer64size", "uffer_fee", "buffer_len", "buffer_offset", "buffer_fee", "queue_scale"], "merge_reads": ["mergeablebreaks", "merger_values", "mergrade___reads", "merge__reads", "mergrade___runs", "mergeallloads", "merge_breaks", "mergrade___breaks", "merge__breaks", "mergment_breaks", "mergeallread", "merger_read", "merger_reads", "mergrade_runs", "mergeablereads", "mergeedreads", "merge___reads", "merge___runs", "merge_books", "merge__runs", "merge_runs", "mergeedruns", "mergment_bytes", "merger_runs", "merge_values", "mergeedvalues", "merge___breaks", "mergrade_reads", "merger_books", "mergeallbooks", "mergeallreads", "mergeableruns", "mergeablebytes", "mergrade_breaks", "mergment_runs", "merge_loads", "mergeedread", "merger_loads", "merge_read", "merge__bytes", "mergment_reads", "merge_bytes"], "start_buffer": ["read67buffer", "cur_resource", "start67buffer", "startfullbutton", "read_entry", "start_header", "start_queue", "start___transfer", "start___device", " start_queue", "startJentry", " start_transfer", "from_uffer", "startfullport", "start_port", "startJbuffer", "read_buffer", "start_resource", "start_device", "start_layer", "start_button", "startJbuf", "cur_button", "startJlayer", "read67layer", "start_transfer", "startfullbuffer", "start___queue", "from_gear", " start_device", "read67buf", "read_buf", "start_entry", "start_gear", "read_layer", "start_uffer", "start67buf", "cur_buffer", "start67layer", "start_buf", "start67entry", "from_header", "start___buffer", "read67entry", "startfullresource", "from_buffer", "cur_port"], "end_buffer": ["begin__buffer", "end__buffer", "end\u00b7buffer", "begin__queue", "begin_queue", "begin_buf", "begin_buff", "end_buff", "begin__buff", "end__buf", " end_server", "end\u00b7queue", "begin__buf", " end_window", " end_queue", "end_buf", "end_queue", "end\u00b7server", "end__buff", "end__queue", "end\u00b7window", "end_server", "end_window", "begin_buffer"], "qiov": ["qliv", "qtiop", "dqiov", "qiop", "questiro", "qaliv", "dqiol", "qamu", "qtiov", "qtliv", "qtmu", "qiro", "dqiro", "quiol", "questiov", " qiop", "qmu", " qmu", " qliv", "quiro", "qaiop", "qaiov", "dqliv", "qiol", "questliv", "quliv", "quiov", "questiol"], "ret": ["std", "row", "al", " success", "value", "val", "rc", "rows", " res", " RET", "num", " Ret", " rc", " resp", "res", "def", "len", "RET", "result", "eval", " result", "Ret", "re", " val", "resp"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "void sws_rgb2rgb_init(int flags)\n\n{\n\n#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX\n\n    if (flags & SWS_CPU_CAPS_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n    else if (flags & SWS_CPU_CAPS_MMX2)\n\n        rgb2rgb_init_MMX2();\n\n    else if (flags & SWS_CPU_CAPS_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    else if (flags & SWS_CPU_CAPS_MMX)\n\n        rgb2rgb_init_MMX();\n\n    else\n\n#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */\n\n        rgb2rgb_init_C();\n\n}\n", "idx": 4698, "substitutes": {"flags": ["groups", "types", "options", "afi", "powers", "properties", "files", "flag", "books", "limits", "posts", "rules", "bits", "caps", "bands", "alls", "features", "Flags", "plugins", "atts", "offs", "ages", "allows", "styles", "format", "mask", "lag", "requires", "vals", "FLAG", "planes", "ants", "f", "parts", "stats", "args", "ports", "opens", "ffff", "fields", "faces", "locks", "fps", "settings", "fs", "fun", "members", "cards", "fd", "frames", "fires", "lf", " Flags", "lists"]}}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static double tget_double(GetByteContext *gb, int le)\n\n{\n\n    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};\n\n    return i.f64;\n\n}\n", "idx": 4718, "substitutes": {"gb": ["gi", "gp", "gc", "hw", "ig", "ib", "gm", "hub", "ci", "rb", "bg", "b", "gnu", "bm", "abi", "db", "gu", "gio", "ga", "usb", "gin", "sl", "pc", "bb", "cli", "eb", "sc", "mc", "sb", "gam", "rg", "gs", "binary", "storage", "ctx", "bc", "GB", "cb", "gal", "gy", "ge", "kb", "g", "gd", "lc", "gram", "gg", "cod", "ui"], "le": ["stable", "ig", "te", "el", "les", "al", "LE", "ci", "let", "ole", "ele", "l", "eu", "de", "ler", " LE", "sle", "ve", "ue", " ble", "ile", "ce", "lo", "e", "len", "leg", "ple", "led", "ule", "lu", "he", "ie", "ee", "ne", "scale", "ice", "ge", "slave", "lc", "li", "ly", "Le"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_power5plus(CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    /* XXX: not correct */\n\n    gen_low_BATs(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 4760, "substitutes": {"env": ["enable", "fen", " environments", "energy", "er", "eng", "gov", "ea", "press", "v", "kn", "el", "sites", "spec", "progress", "dat", "ception", "session", "config", "environment", "password", "exc", "style", "nc", "enc", "eu", "db", "event", "export", "ext", "gui", "org", "server", "ench", "assets", "args", "gear", "forest", "ev", "np", "dir", "e", "que", "en", "err", "equ", "Environment", "enh", "context", "ec", "stage", "output", "viron", "console", "erv", "global", "shell", "eve", "txt", "het", "dt", "engine", "cv", "site", " environment", "forge", "agen", "conn", "dict"]}}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n", "idx": 4761, "substitutes": {"ctx": ["cp", "cmp", "gc", "hw", "anc", "fw", "hub", "ci", "component", "config", "ctl", "cus", "rc", "cca", "sync", "concept", "loc", "cm", "support", "tx", "cl", "client", "conv", "cli", "cc", "cs", "sci", "crit", "ck", "sc", "mc", "cam", "conn", "cmd", "bc", "cb", "exec", "cu", "fp", "coll", "context", "kw", "qa", "ca", "css", "gb", "kb", "c", "ct", "cn", "cf", "lc", "fc", "cv", "vc", "src", "cpp", "cas", "cdn", "ctrl", "pkg", "xc", "tc"], "bit_rate": ["bituresize", "rot_scale", "bitfscale", "biturerate", " bit_rates", " bit_width", "bits_rates", "bit_rat", "bit__scale", "bit__rate", "bit_type", "bit_size", " bit_ration", "bits_width", "rot_size", "bits_type", " bit_scale", "bitfrates", "rot_loop", "bit___rates", "bitfdelay", " bit_size", "bit_loop", "bit_ration", " bit_address", "bit___rat", "bitfrate", "bit__type", "bitureaddress", "biturescale", "bit___rate", "bit_rating", "bit_address", "bit_width", "bit_delay", "bit_rates", "bit___ration", " bit_rat", " bit_rating", "bit__width", "bits_base", "bits_rate", "bits_delay", "rot_rate", "bits_scale", "bit_scale", "bit_base"], "bits_per_sample": ["bits_per_group", "bits_per_scale", "bits_in_scale", "bits_in_sample", "bits_per_slice", "bits_per_channel", "bits_per_size", "bits_per_space", "bits_in_channel", "bits_per_side"]}}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb,\n\n                                  AVCodecParameters *par,\n\n                                  int native_id, int qt_id)\n\n{\n\n    AVIOContext *dyn_cp;\n\n    uint8_t *codecpriv;\n\n    int ret, codecpriv_size;\n\n\n\n    ret = avio_open_dyn_buf(&dyn_cp);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (native_id) {\n\n        ret = mkv_write_native_codecprivate(s, par, dyn_cp);\n\n    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (qt_id) {\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,\n\n                                                    par->codec_id);\n\n            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id\n\n                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)\n\n            ) {\n\n                int i;\n\n                avio_wb32(dyn_cp, 0x5a + par->extradata_size);\n\n                avio_wl32(dyn_cp, par->codec_tag);\n\n                for(i = 0; i < 0x5a - 8; i++)\n\n                    avio_w8(dyn_cp, 0);\n\n            }\n\n            avio_write(dyn_cp, par->extradata, par->extradata_size);\n\n        } else {\n\n            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))\n\n                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,\n\n                                                  par->codec_id);\n\n            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n                ret = AVERROR(EINVAL);\n\n            }\n\n\n\n            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);\n\n        }\n\n    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        unsigned int tag;\n\n        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);\n\n        if (!tag) {\n\n            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n\n                   avcodec_get_name(par->codec_id));\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n        if (!par->codec_tag)\n\n            par->codec_tag = tag;\n\n\n\n        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);\n\n    }\n\n\n\n    codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv);\n\n    if (codecpriv_size)\n\n        put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n\n                        codecpriv_size);\n\n    av_free(codecpriv);\n\n    return ret;\n\n}\n", "idx": 4762, "substitutes": {"s": ["o", "sf", "v", "spec", "sg", "scope", "session", "b", "sys", "ses", "services", "f", "client", "ns", "server", "service", "us", "cs", "u", "e", "sc", "sb", "gs", "parser", "ops", "ks", "t", "ds", "ctx", "p", "context", "aws", "sv", "fs", "c", "os", "g", "ssl", "sq", "site", "app", "r", "ps", "js"], "pb": ["cp", "pro", "rb", "pp", "pd", "typ", "wp", "lp", "mp", "prot", "obj", "pc", "sc", "sb", "parser", "lib", "ctx", "bc", "PB", "cb", "fp", "jp", "vp", "proc", "txt", "tp", "pl", "src", "cpp"], "par": ["dr", "serv", "person", "ep", "entry", "component", "aa", "pas", "rel", "prep", "mp", "arg", "arin", "ar", "per", "arr", "har", "pass", "ca", "sp", "oper", "proc", "var", "syn", "mor", "pol", "view", "particip", "cur", "parent", "spec", "wp", "pe", "param", "comment", "jp", "pal", "str", "parse", "pub", "Par", "star", "cap", "mm", "adr", "bar", "patch", "fr", "er", "pard", "pro", "pa", "gap", "pp", "op", "cat", "inc", "like", "PAR", "post", "arp", "pc", "ph", "parser", "p", "dep", "app", "ps", "prem", "cmp", "pr", "la", "prev", "session", "pre", "inter", "comp", "peer", "resource", "attr", "arc", "part", "car", "processor", "war", "request", "params", "rar"], "native_id": ["nativeacident", "native2type", "native2id", "format_ids", "remote_info", "nativeappid", "native_info", "format_ident", "native_type", "remote_type", "native_check", "remote_id", "format_id", "nativeacids", "nativeicalids", "native_ident", "native_ids", "formaticalcheck", "format_check", "nativeapptype", "nativeicalcheck", "formaticalident", "formaticalid", "nativeacid", "nativeicalident", "nativeappinfo", "nativeicalid", "native2info", "nativeaccheck", "formaticalids"], "qt_id": ["textamesource", "core_key", "qt_key", "qt_index", "text_source", "text_ids", "core00oid", "qt00id", "qt_source", "text_id", "qtameids", "qtamesource", "qt00ids", "core00ids", "qtameid", "core_id", "core_oid", "core_ids", "qt_oid", "textameindex", "text_index", "core00id", "qtIdindex", "textameids", "qt_ids", "qtameindex", "textameid", "core00key", "qt00oid", "qt00key", "qtIdsource", "qtIdids", "qtIdid"], "dyn_cp": ["dyn_keep", "dynADcat", "dyn_sk", "dyn_proc", "dyn67cmp", "dyn_cat", "dyn_pp", "dyn__rc", "dynccol", "dynthecsv", "dynwcmp", "dynamic_cp", "dynthecp", "dyn__pub", "dyn__cat", "dummyADcsv", "dynADproc", "dummyADcpp", "dynvch", "dync_cp", "dyn_mp", "dummy_cpp", "dyn_cpp", "dyn__cmp", "dynamic_pkg", "dyn67cp", "dyn_cmp", "dynADcsv", "dyntheproc", "dyn_pkg", "dyncch", "dynvcpp", "dyn_csv", "dynam_pp", "dynamic_zip", "dyn_rc", "dyn__mp", "dynwcp", "dynccpp", "dynADcp", "dyna_pub", "dynwpc", "dynam_cmp", "dyna_cat", "dynADmp", "dynjcmp", "dynam_cp", "dyn__cp", "dynjcp", "dynjmp", "dynCcp", "dyn_zip", "dummy_proc", "dummyADproc", "dyna_cp", "dyn_col", "dyna_rc", "dynamic_keep", "dynam_sk", "dync_cpp", "dyna_cmp", "dync_pc", "dynccp", "dynjrc", "dync_cmp", "dynthecpp", "dynADpub", "dynvcol", "dyn67sk", "dynwcpp", "dynCpp", "dyn_pc", "dummy_cp", "dyn67pp", "dummyADcp", "dynvcp", "dyna_mp", "dynCsk", "dyn_pub", "dynCcmp", "dyn_ch", "dynADcpp", "dummy_csv"], "codecpriv": ["codexname", "codexprivate", "codefdata", "codecprivate", "codecdata", "codacdata", "codefpriv", "codacname", " codecname", "codexpriv", " codecprivate", "codacprivate", "codacpriv", "codefprivate", " codacdata", "codexdata", " codacname", " codacpriv", "codecname", "codefname", " codacprivate", " codecdata"], "ret": ["flag", "reg", "sr", "rt", "cur", "id", "alt", "mem", "nt", "rb", "get", "val", "rc", "bit", "cat", "art", "let", "reply", "pt", "status", "valid", " RET", "fin", " Ret", "lit", "num", "att", "pet", "arg", "bad", "res", "match", "ry", "def", "code", "len", "mt", "det", "arr", "RET", "pass", "feat", "rl", "rev", "result", "Ret", "ft", "ut", "re", "fail", "fun", "back", "bf", "resp", "gt", "success", "ref", "rets"], "codecpriv_size": ["codecpriv_len", "codecpriv_count", "codecpriv_small", "codecinfo_count", "codecinfo_len", "codecinfo_size", "codecinfo_small"], "i": ["gi", "o", "ti", "v", "I", "chi", "di", "ci", "ji", "ni", "x", "xi", "si", "ri", "abi", "bi", "in", "m", "qi", "ix", "key", "pi", "phi", "j", "ii", "ai", "uli", "e", "uri", "k", "n", "multi", "ini", "p", "h", "mini", "z", "hi", "ind", "ip", "c", "li", "inner", "fi", "index", "zi", "ui"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n", "idx": 4766, "substitutes": {"dest": ["master", "est", "miss", "done", "di", "shape", "data", "delete", "uc", "status", "route", "cont", "die", "Dest", "hop", "access", "output", "stage", "trans", "vert", "trip", "img", "mode", "option", "name", "id", "parent", "config", "sum", "null", "content", "dist", "target", "path", "usr", "node", "txt", "class", "ident", "text", "test", "end", "ui", "feature", "address", "origin", "home", "flat", "loc", "wb", "cl", "select", "outer", "coord", "feat", "source", "temp", "prop", "transfer", "global", "orig", "west", "desc", "sup", "src", "dim", "options", "ward", "pull", "sort", "session", "de", "rest", "project", "lit", "dc", "cb", "result", "context", "opt", "transform", "comb", "ord", "success", "camp", "cdn", "shift"], "line_size": ["line_0", "line2length", "line2scale", "line_scale", "line2time", "line640", "line2size", " line_length", "line2sized", "line_time", "line64sized", " line_scale", "line_length", "line_sized", "line64scale", "line20", " line_time", " line_0", " line_sized", "line64size"], "block": ["Block", "address", "cp", "name", "row", "pack", "clean", "parent", "word", "check", "chain", "config", "pre", "module", "map", "loc", "cl", "event", "content", "table", "byte", "match", "buffer", "col", "section", "comment", "lock", "source", "blocks", "line", "none", "node", "rule", "ip", "type", "page", "bl", "group", "keep", "end"], "i": ["gi", "ti", "v", "I", "count", "a", "is", "di", "ci", "ki", "ji", "ni", "b", "x", "si", "io", "xi", "abi", "info", "bi", "qi", "l", "f", "pi", "d", "j", "ii", "iu", "cli", "ai", "u", "e", "col", "uri", "k", "t", "n", "multi", "mi", "ie", "p", "z", "oi", "c", "ip", "api", "li", "fi", "index", "zi", "mu", "ui"], "cm": ["cp", "address", "prem", "cr", "hem", "gm", "rom", "comm", "iam", "om", "vm", "ci", "config", "mult", "sem", "com", "cus", "wm", "cca", "bm", "cy", "co", "module", "dem", "m", "image", "gom", "ram", "cl", "pm", "nm", "cc", "cs", "param", "man", "cum", "cont", "con", "mc", "km", "que", "CM", "em", "cam", "cms", "member", "fm", "ca", "asm", "don", "uca", "mode", "am", "c", "mm", "im", "ym", "lc", "cf", "cn", "core", "rem", "ctrl", "dim"]}}
{"project": "qemu", "commit_id": "a01aedc8d32e6f5b08a4041b62be3c5fab7a3382", "target": 1, "func": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n", "idx": 4768, "substitutes": {"obj": ["base", "otype", "o", "act", "objects", "el", "parent", "Obj", "po", "ob", "object", "val", "op", "elt", "b", "module", "orb", "attr", "org", "j", "mod", "code", "inst", "bot", "lib", "cb", "self", "coll", "p", "node", "os", "class", "api", "bo", "ref", "bj"], "name": ["base", "o", "id", "parent", "word", "x", "object", "data", "alias", "b", "named", "names", "key", "f", "attr", "call", "Name", "property", "part", "NAME", "code", "size", "len", "comment", "ame", "n", "path", "pass", "old", "nam", "none", "type", "nice", "prefix"], "get": ["patch", "find", "give", "GET", "gets", "play", "show", "send", "check", "sort", "update", "use", "et", "like", "export", "post", "make", "client", "call", "ve", "create", "it", "init", "service", "property", "exec", "ie", "parse", "want", "ge", "fix", "gen", "start", "can", "g", "read", "api", "put", "apply", "got", "neg", "Get", "getting", "msg"], "set": ["patch", "bind", "find", "base", "enable", "cut", "reset", "id", "change", "open", "store", "send", "check", "session", "update", "force", "use", "SET", "et", "sync", "unit", "export", "post", "Set", "call", "mod", "create", "it", "handle", "push", "sc", "se", "en", "sign", "process", "parse", "ut", "vert", "un", "pos", "gen", "start", "write", "read", "cast", "clear", "util", "put", "apply", "diff", "end", "add"], "errp": ["Erp", "erpc", "errorr", "Erpc", "iser", "errorf", " errf", "errorp", "Erps", "errpc", "erps", "errorpc", " errpc", "isepc", "err", "iseps", "errps", "isep", "errr", "erp", "Err", "errf", " errr", "erf"], "prop": ["pot", "cp", "option", "cmp", "cfg", "properties", "Prop", "pr", "parent", "pro", "rop", "value", "rb", "tmp", "po", "config", "bug", "op", "val", "data", "pod", "b", "pred", "comp", "cat", "info", "object", "buf", "num", "pp", "lit", "mp", "attr", "phi", "prot", "init", "conf", "np", "property", "part", "priv", "col", "cb", "jp", "nb", "p", "root", "opt", "ptr", "pos", "pointer", "proc", "type", "api", "dt", "term", "pb", "fi", "ps", "pkg"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n", "idx": 4769, "substitutes": {"v": ["vol", "nv", "o", "a", "vd", "vm", "value", "V", "va", "vt", "x", "b", "val", "i", "or", "uv", "l", "f", "conv", "d", "ve", "j", "ii", "q", "u", "vi", "vs", "e", "ev", "w", "k", "t", "n", "volt", "p", "h", "vert", "sv", "vp", "z", "iv", "c", "var", "g", "lv", "vv", "r", "vu", "view"], "m": ["o", "dm", "gm", "md", "a", "vm", "s", "M", "b", "x", "i", "bm", "l", "pm", "f", "pi", "mn", "nm", "mad", "d", "j", "mod", "q", "sm", "u", "e", "mc", "hm", "k", "n", "mi", "p", "h", "z", "mr", "c", "g", "mm", "ms", "y", "mA", "r", "min", "cm", "dim", "mu"]}}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n", "idx": 4770, "substitutes": {"s": ["sf", "S", "a", "b", "i", "f", "parts", "d", "service", "hs", "conf", "w", "self", "h", "aws", "g", "sym", "y", "sets", "sites", "is", "services", "its", "states", "sl", "ls", "ops", "ds", "ts", "south", "settings", "fs", "new", "sq", "ms", "site", "rs", "as", "sg", "plugins", "sync", "ssh", "ses", "cs", "u", "sis", "an", "e", "sb", "ks", "t", "qs", "p", "os", "c", "ssl", "ps", "o", "http", "session", "si", "sys", "m", "l", "side", "ns", "args", "ss", "uns", "gs", "se", "su", "es", "js"]}}
{"project": "FFmpeg", "commit_id": "ddef3d902f0e4cbd6be6b3e5df7ec158ce51488b", "target": 1, "func": "static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n\n                              MOVTrack *track, AVStream *st)\n\n{\n\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n\n                                      track->timescale, AV_ROUND_UP);\n\n    int version = duration < INT32_MAX ? 0 : 1;\n\n    int flags   = MOV_TKHD_FLAG_IN_MOVIE;\n\n    int rotation = 0;\n\n    int group   = 0;\n\n\n\n    uint32_t *display_matrix = NULL;\n\n    int      display_matrix_size, i;\n\n\n\n    if (st) {\n\n        if (mov->per_stream_grouping)\n\n            group = st->index;\n\n        else\n\n            group = st->codecpar->codec_type;\n\n\n\n        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,\n\n                                                            &display_matrix_size);\n\n        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))\n\n            display_matrix = NULL;\n\n    }\n\n\n\n    if (track->flags & MOV_TRACK_ENABLED)\n\n        flags |= MOV_TKHD_FLAG_ENABLED;\n\n\n\n    if (track->mode == MODE_ISM)\n\n        version = 1;\n\n\n\n    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */\n\n    ffio_wfourcc(pb, \"tkhd\");\n\n    avio_w8(pb, version);\n\n    avio_wb24(pb, flags);\n\n    if (version == 1) {\n\n        avio_wb64(pb, track->time);\n\n        avio_wb64(pb, track->time);\n\n    } else {\n\n        avio_wb32(pb, track->time); /* creation time */\n\n        avio_wb32(pb, track->time); /* modification time */\n\n    }\n\n    avio_wb32(pb, track->track_id); /* track-id */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track->entry && mov->mode == MODE_ISM)\n\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n\n    else if (!track->entry)\n\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n\n    else\n\n        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);\n\n\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb16(pb, 0); /* layer */\n\n    avio_wb16(pb, group); /* alternate group) */\n\n    /* Volume, only for audio */\n\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avio_wb16(pb, 0x0100);\n\n    else\n\n        avio_wb16(pb, 0);\n\n    avio_wb16(pb, 0); /* reserved */\n\n\n\n    /* Matrix structure */\n\n\n    if (st && st->metadata) {\n\n        AVDictionaryEntry *rot = av_dict_get(st->metadata, \"rotate\", NULL, 0);\n\n        rotation = (rot && rot->value) ? atoi(rot->value) : 0;\n\n    }\n\n\n    if (display_matrix) {\n\n        for (i = 0; i < 9; i++)\n\n            avio_wb32(pb, display_matrix[i]);\n\n\n    } else if (rotation == 90) {\n\n        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);\n\n    } else if (rotation == 180) {\n\n        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);\n\n    } else if (rotation == 270) {\n\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n\n\n    } else {\n\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n\n    }\n\n    /* Track width and height, for visual only */\n\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n\n        int64_t track_width_1616;\n\n        if (track->mode == MODE_MOV) {\n\n            track_width_1616 = track->par->width * 0x10000ULL;\n\n        } else {\n\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n\n                                                  track->par->width * 0x10000LL,\n\n                                                  st->sample_aspect_ratio.den);\n\n            if (!track_width_1616 ||\n\n                track->height != track->par->height ||\n\n                track_width_1616 > UINT32_MAX)\n\n                track_width_1616 = track->par->width * 0x10000ULL;\n\n        }\n\n        if (track_width_1616 > UINT32_MAX) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n\n            track_width_1616 = 0;\n\n        }\n\n        avio_wb32(pb, track_width_1616);\n\n        if (track->height > 0xFFFF) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n\n            avio_wb32(pb, 0);\n\n        } else\n\n            avio_wb32(pb, track->height * 0x10000U);\n\n    } else {\n\n        avio_wb32(pb, 0);\n\n        avio_wb32(pb, 0);\n\n    }\n\n    return 0x5c;\n\n}", "idx": 4781, "substitutes": {"pb": ["hp", "cp", "bp", "lb", "buff", "hub", "platform", "pa", "rb", "tmp", "plug", "pd", "pp", "bps", "b", "typ", "wp", "bm", "lp", "pt", "fb", "uf", "pm", "pg", "prot", "obj", "pc", "bs", "xb", "np", "eb", "dp", "sb", "bsp", "aph", "ctx", "bc", "PB", "fp", "jp", "cb", "p", "pub", "apy", "vp", "gb", "ppa", "proc", "bf", "bos", "api", "um", "tp", "lv", "lc", "dl", "blog", "pl", "cpp", "bh", "pkg", "bj"], "mov": ["mux", " movo", "cmov", "mmov", "tmove", "emov", "rmove", " move", "cmove", "mev", "rmov", "cmux", "mmOV", "amov", "migration", "smigration", "emove", "rmux", "emev", "tmovo", "amove", "mmove", "emOV", "smood", "mood", "smov", "smovo", "tmigration", "tmov", "mmev", "amev", "movo", "smux", "move", "cmood", "mOV", " migration", "rmood", "amOV", "smove"], "track": ["time", "play", "complete", "tracking", "trial", "note", "sort", "session", "config", "gap", "skip", "tr", "token", "stream", "record", "module", "m", "route", "tag", "package", "project", "event", "song", "post", "order", "call", "metadata", "ack", "toggle", "roll", "match", "round", "comment", "forward", "Track", "t", "port", "tm", "sound", "hop", "coll", "stage", "run", "mode", "request", "step", "node", "rule", "rock", "tracks", "thread", "type", "report", "model", "transform", "contact", "rack", "test", "form", "group", "set", "audio", "trace", "add"], "st": ["std", "ste", "sf", "store", "ost", "sw", "tmp", "tr", "sn", "stack", "stream", "steam", "pt", "stress", "stab", "support", "sk", "rest", "client", "station", "sam", "sm", "sl", "St", "td", "stop", "sc", "sth", "sb", "ist", "inst", "storage", "ctx", "ST", "str", "sta", "stage", "ft", "sp", "start", "step", "ast", "bl", "src", "stall", "grad", "stim"], "display_matrix": ["display_meturity", "display_dimrix", "display_attression", "display_attrices", "display_morrix", "display_monric", "display_matrices", "display_maturity", "display_dimrices", "display_monrix", "display_matix", "display_dimride", "display_textribution", "display_mathix", "display_patribution", "display_metix", "display_materialix", "display_mathurity", "display_compric", "display_numric", "display_morrices", "display_compression", "display_materialression", "display_atrix", "display_metrix", "display_manogram", "display_textric", "display_morric", "display_matression", "display_manric", "display_atric", "display_atix", "display_mathrix", "display_textrix", "display_matrics", "display_monride", "display_manrix", "display_mathric", "display_textrics", "display_dimric", "display_dimogram", "display_matogram", "display_matric", "display_attric", "display_compix", "display_materialric", "display_aturity", "display_materialrix", "display_attrix", "display_comprix", "display_patric", "display_matribution", "display_patrics", "display_numrix", "display_matride", "display_attix", "display_patrix", "display_manride", "display_monogram", "display_metric", "display_numrics", "display_numribution"], "display_matrix_size": ["display_matric_size", "display_matrix_sum", "display_matrix_small", "display_matrices_scale", "display_matrix_scale", "display_matric_sum", "display_matric_scale", "display_matric_capacity", "display_matrix_capacity", "display_matrix_SIZE", "display_matrices_small", "display_matrix_Size", "display_matric_Size", "display_matrices_size", "display_matrices_SIZE"], "i": ["axis", "ti", "v", "id", "I", "a", "s", "ci", "ni", "x", "si", "slice", "io", "info", "in", "pi", "j", "ai", "e", "n", "multi", "p", "z", "c", "ip", "g", "ind", "li"]}}
{"project": "FFmpeg", "commit_id": "4189fe11ffcbdcd311eb9a3437586a94492c4cde", "target": 1, "func": "static int vobsub_read_seek(AVFormatContext *s, int stream_index,\n\n                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)\n\n{\n\n    MpegDemuxContext *vobsub = s->priv_data;\n\n\n\n    /* Rescale requested timestamps based on the first stream (timebase is the\n\n     * same for all subtitles stream within a .idx/.sub). Rescaling is done just\n\n     * like in avformat_seek_file(). */\n\n    if (stream_index == -1 && s->nb_streams != 1) {\n\n        int i, ret = 0;\n\n        AVRational time_base = s->streams[0]->time_base;\n\n        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);\n\n        min_ts = av_rescale_rnd(min_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);\n\n        max_ts = av_rescale_rnd(max_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);\n\n        for (i = 0; i < s->nb_streams; i++) {\n\n            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,\n\n                                            min_ts, ts, max_ts, flags);\n\n            if (r < 0)\n\n                ret = r;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n\n\n    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,\n\n                                   min_ts, ts, max_ts, flags);\n\n}", "idx": 4798, "substitutes": {"s": ["o", "sets", "sf", "v", "ins", "is", "S", "spec", "sg", "plugins", "features", "session", "comments", "b", "si", "sync", "sys", "ses", "services", "m", "ips", "support", "l", "xs", "f", "ns", "d", "ls", "sl", "service", "us", "ss", "cs", "sports", "e", "sc", "sb", "w", "sim", "gs", "se", "qs", "t", "n", "ds", "uploads", "su", "self", "p", "settings", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "events", "ps", "js"], "stream_index": ["client_diff", "streampindex", "resource_index", "input_ind", "resource_size", "streamingnum", "streamingelement", "stream_address", "streamingind", "stream_slice", "streamerindex", "inputingindex", "stream_size", "streamNamehandle", "record_handle", "streamingid", "streampind", "recordNameindex", "streamsind", "resourceerind", "stream_edge", "inputingslice", "input_slice", "stream_ini", "streamNameindex", "streamsindex", "streamPind", "stream_num", "streamersize", "stream_id", "streamPid", "input_index", "resource_ind", "streamsdiff", "streampid", "stream_ind", " stream_num", "input_id", "resourceersize", " stream_element", "record_ini", "streamingindex", "inputingind", "streamslevel", "stream_handle", "resourceeraddress", "streameraddress", "streamssize", "streampslice", "stream_diff", "client_index", "streamsaddress", "streamsedge", "recordNameini", "stream_element", "inputingid", "streamerind", "client_edge", "stream_level", "resourceerindex", "resource_address", "recordNamehandle", "streamNameini", "streamPslice", "streamPindex", "streamingslice", "client_level", "record_index"], "min_ts": ["max_tz", "min00cases", "max_times", "minJpoints", "min00ts", "min64times", " min_atts", "min64ts", "max_uts", "max_its", "minJts", "min_tp", "min_cases", "minalltimes", "minablets", "min_atts", "min_ats", "min_uts", "min00uts", "min_times", "min00times", "max_points", "min_points", "min64its", "max_TS", "minJtimes", " min_ments", "minallts", "minabletimes", "minalltp", "minablecases", "min_tz", "min__ts", "minJtz", "min__points", " min_ats", "min_ments", "min_its", "max_cases", "min_TS", "min64TS", "max_tp", "minableuts", "minallTS", "min__tz", "min__times"], "ts": ["points", "types", "tes", "posts", "verts", "alt", "alls", "ags", "ets", "atts", "ays", "ages", "asts", "dates", "ths", "tr", "rows", "tags", "pt", "its", "vals", "Ts", "ns", "ats", "ls", "TS", "tips", "ports", "cs", "ss", "ras", "ints", "tim", "ics", "mt", "ks", "tests", "ickets", "t", "outs", "ents", "arts", "tz", "ails", "acs", "fs", "ta", "amps", "tracks", "ms", "ims", "uts", "ps", "ids", "tt", "ensions", "test", "times", "rs", "events", "min", "tc"], "max_ts": ["max33ts", "max33times", "min_td", " max_tm", "max_td", "min_ics", "max_tm", "max_tz", "maxNtm", "max_times", "max68tis", " max_times", " max_trans", "max48tim", "maxLtrans", "max68times", "maxLtimes", "max48tz", "max_ims", "max67tim", "max_ics", "max67ts", "min_times", "maxNts", "maxNims", "max6times", "min_tis", "maxLts", "max6ics", "max_TS", " max_ims", " max_TS", "min_tz", "max33tm", "max33ims", "max67tz", "max_trans", "max6ts", "max48times", "max_tim", "max_tis", "max67times", "min_ims", "maxNtimes", "max68ts", "max68ics", "maxLTS", "min_tim", "max6tis", "max48ts"], "flags": ["types", "options", "nl", "files", "flag", "rules", "bits", "bands", "fts", "alls", "features", "Flags", "ags", "atts", "comments", "styles", "mask", "lag", "details", "planes", "vals", "FLAG", "ants", "forces", "windows", "stats", "ats", "args", "fo", "mods", "ints", "fields", "vs", "faces", "locks", "func", "reports", "fps", "settings", "fs", "fun", "utils", "fd", "rets", "lf", "times", "orts", "reads"], "vobsub": ["svorblish", "voclpath", "vobube", "vaudpath", "vcbsub", "ivaudpath", "vobSub", "vorblish", "vabsec", "vobblish", "vcbSub", "vobbsec", "vorbsub", "vobstart", "ivaudsec", "ivaudstart", "voclstart", "svobsub", "voclsub", "vabpub", "tvobSub", "vaudstart", "vabstart", "voclsec", "ivobpath", "vobpub", "ivobsub", "ivobstart", "vobbsc", "vabsc", "vorbsec", "vobsec", "tvabsub", "svorbsec", "vobsc", "vabSub", "vabsub", "tvabsc", "vcbpub", "vobpath", "tvabSub", "vaudlish", "svobube", "svoblish", "vabpath", "tvobpub", "vobbube", "vcbsc", "svorbsub", "tvobsub", "ivobsec", "svobsec", "vaudsec", "svorbube", "vobbsub", "vaudsub", "tvobsc", "voblish", "ivaudsub", "tvabpub", "vobbSub", "vorbube", "vaudube", "vobbpub"], "i": ["gi", "o", "ib", "ret", "ti", "v", "id", "I", "di", "ci", "b", "x", "xi", "ri", "slice", "si", "abi", "io", "bi", "m", "qi", "ix", "l", "f", "pi", "phi", "j", "ii", "iu", "q", "ai", "it", "u", "len", "code", "uri", "e", "en", "t", "k", "n", "multi", "mi", "ini", "p", "mini", "oi", "hi", "ind", "c", "ip", "type", "y", "li", "inner", "fi", "index", "r", "ui"]}}
{"project": "FFmpeg", "commit_id": "c177f2ec4a21d62fdefd925ad69c24a2f9dad303", "target": 0, "func": "static av_cold int aac_encode_init(AVCodecContext *avctx)\n\n{\n\n    AACContext *s = avctx->priv_data;\n\n    int ret = AVERROR(EINVAL);\n\n    AACENC_InfoStruct info = { 0 };\n\n    CHANNEL_MODE mode;\n\n    AACENC_ERROR err;\n\n    int aot = FF_PROFILE_AAC_LOW + 1;\n\n    int sce = 0, cpe = 0;\n\n\n\n    if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to open the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->profile != FF_PROFILE_UNKNOWN)\n\n        aot = avctx->profile + 1;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the AOT %d: %s\\n\",\n\n               aot, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE,\n\n                                       1)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to enable SBR for ELD: %s\\n\",\n\n                   aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE,\n\n                                   avctx->sample_rate)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the sample rate %d: %s\\n\",\n\n               avctx->sample_rate, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    switch (avctx->channels) {\n\n    case 1: mode = MODE_1;       sce = 1; cpe = 0; break;\n\n    case 2: mode = MODE_2;       sce = 0; cpe = 1; break;\n\n    case 3: mode = MODE_1_2;     sce = 1; cpe = 1; break;\n\n    case 4: mode = MODE_1_2_1;   sce = 2; cpe = 1; break;\n\n    case 5: mode = MODE_1_2_2;   sce = 1; cpe = 2; break;\n\n    case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number of channels %d\\n\", avctx->channels);\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE,\n\n                                   mode)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set channel mode %d: %s\\n\", mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER,\n\n                                   1)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set wav channel order %d: %s\\n\",\n\n               mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_QSCALE || s->vbr) {\n\n        int mode = s->vbr ? s->vbr : avctx->global_quality;\n\n        if (mode <  1 || mode > 5) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"VBR quality %d out of range, should be 1-5\\n\", mode);\n\n            mode = av_clip(mode, 1, 5);\n\n        }\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Note, the VBR setting is unsupported and only works with \"\n\n               \"some parameter combinations\\n\");\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE,\n\n                                       mode)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the VBR bitrate mode %d: %s\\n\",\n\n                   mode, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    } else {\n\n        if (avctx->bit_rate <= 0) {\n\n            if (avctx->profile == FF_PROFILE_AAC_HE_V2) {\n\n                sce = 1;\n\n                cpe = 0;\n\n            }\n\n            avctx->bit_rate = (96*sce + 128*cpe) * avctx->sample_rate / 44;\n\n            if (avctx->profile == FF_PROFILE_AAC_HE ||\n\n                avctx->profile == FF_PROFILE_AAC_HE_V2 ||\n\n                s->eld_sbr)\n\n                avctx->bit_rate /= 2;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE,\n\n                                       avctx->bit_rate)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the bitrate %d: %s\\n\",\n\n                   avctx->bit_rate, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    /* Choose bitstream format - if global header is requested, use\n\n     * raw access units, otherwise use ADTS. */\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX,\n\n                                   avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the transmux format: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (s->latm && s->header_period) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD,\n\n                                       s->header_period)) != AACENC_OK) {\n\n             av_log(avctx, AV_LOG_ERROR, \"Unable to set header period: %s\\n\",\n\n                    aac_get_error(err));\n\n             goto error;\n\n        }\n\n    }\n\n\n\n    /* If no signaling mode is chosen, use explicit hierarchical signaling\n\n     * if using mp4 mode (raw access units, with global header) and\n\n     * implicit signaling if using ADTS. */\n\n    if (s->signaling < 0)\n\n        s->signaling = avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE,\n\n                                   s->signaling)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set signaling mode %d: %s\\n\",\n\n               s->signaling, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER,\n\n                                   s->afterburner)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set afterburner to %d: %s\\n\",\n\n               s->afterburner, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->cutoff > 0) {\n\n        if (avctx->cutoff < (avctx->sample_rate + 255) >> 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"cutoff valid range is %d-20000\\n\",\n\n                   (avctx->sample_rate + 255) >> 8);\n\n            goto error;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH,\n\n                                       avctx->cutoff)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the encoder bandwidth to %d: %s\\n\",\n\n                   avctx->cutoff, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to initialize the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to get encoder info: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n#if FF_API_OLD_ENCODE_AUDIO\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n#endif\n\n    avctx->frame_size = info.frameLength;\n\n    avctx->delay      = info.encoderDelay;\n\n    ff_af_queue_init(avctx, &s->afq);\n\n\n\n    if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER) {\n\n        avctx->extradata_size = info.confSize;\n\n        avctx->extradata      = av_mallocz(avctx->extradata_size +\n\n                                           FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto error;\n\n        }\n\n\n\n        memcpy(avctx->extradata, info.confBuf, info.confSize);\n\n    }\n\n    return 0;\n\nerror:\n\n    aac_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 4800, "substitutes": {"avctx": ["akcontext", "evconn", "versync", " avvoc", "akscope", "AVlc", "verpkg", " avcca", "evcontext", "airsync", "alctx", "navcontext", "afctx", "avcal", "apctx", " avtx", "alpkg", "akcca", "accontext", "avkb", "afcal", "navctx", "avcli", " avcontext", "akvoc", "Avtx", "aucontext", "airctx", "ausync", "Avconn", "avhw", "avalcli", "afloc", "afcmp", "avcmp", "navpkg", "akctx", "avalctx", "AVcmp", "Avctx", "airpkg", "avecontext", "avlc", "avalcal", " avcu", "AVconn", " avcli", "avecu", "avelc", "avalcontext", "avekb", "afcli", "afhw", "avsync", " avcms", "aflc", "evlc", "vercontext", "avcu", " avhw", "AVcontext", "avcca", "avcms", "afkb", "afsync", "avcontext", "afpkg", "afcoll", "acctx", "avvoc", "aucmp", "appkg", "accu", "alcoll", "avloc", "AVkb", "apcoll", "avconn", "evctx", "alcontext", "afcms", "apcontext", "avectx", "avepkg", "AVctx", "avcoll", "afscope", "akcms", "navscope", "aftx", "avscope", "avtx", " avloc", "Avcontext", "verctx", "aircontext", "akhw", "afconn", "acpkg", "avpkg", "afcontext", "afvoc", "akpkg", " avconn", "AVsync", "afcca", "auctx", "acloc", "afcu", " avcal"], "s": ["r", "o", "sets", "sf", "v", "is", "S", "a", "spec", "sg", "session", "b", "data", "i", "si", "sync", "sys", "ses", "services", "info", "xs", "f", "ns", "ls", "service", "us", "cs", "ss", "hs", "e", "sc", "sb", "gs", "ops", "bis", "storage", "qs", "n", "ctx", "ds", "t", "su", "p", "settings", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "sym", "y", "rs", "sup", "js"], "mode": ["plugin", " modes", "END", "MODE", "program", "name", "dim", "block", "id", "md", "channel", "Mode", "device", "language", "layout", "TYPE", "manager", "MOD", "phase", "module", "m", "key", " Mode", "grade", "mod", "toggle", "sid", "table", "match", "code", "power", "when", "mission", " error", "cade", "message", "MAC", "prefix", "ODE", "scale", " status", "stage", "direction", "range", " coding", "type", " ERROR", "disable", "move", " m", "activity", "command", "lane", "role"], "err": ["dr", "yer", "iter", "rb", " resp", "magic", "conf", "error", "arr", " cause", "reader", "finder", "mr", "ver", "var", "resp", "user", "y", "Er", "kr", "msg", "ah", "arm", "spec", "aster", " ex", "eor", " rc", "server", "nr", "later", "ait", " error", " sr", "str", "ini", "usr", "doc", "yr", " req", "fr", "fg", "er", "act", " fe", "rc", "erg", " reply", "ler", " f", "e", "temp", "ner", "erer", "ind", "orig", " r", "r", "Error", " er", " errors", "gr", "pr", "rr", "bug", " res", "sys", "der", "rh", "ir", "attr", "order", " Error", "res", " env", "ry", "aut", "lr", "cb", "result", "wr", " result", " msg", "req", " act", " exc", "rar"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static int vorbis_floor1_decode(vorbis_context *vc,\n\n                                vorbis_floor_data *vfu, float *vec)\n\n{\n\n    vorbis_floor1 *vf = &vfu->t1;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t range_v[4] = { 256, 128, 86, 64 };\n\n    unsigned range = range_v[vf->multiplier - 1];\n\n    uint16_t floor1_Y[258];\n\n    uint16_t floor1_Y_final[258];\n\n    int floor1_flag[258];\n\n    unsigned class, cdim, cbits, csub, cval, offset, i, j;\n\n    int book, adx, ady, dy, off, predicted, err;\n\n\n\n\n\n    if (!get_bits1(gb)) // silence\n\n        return 1;\n\n\n\n// Read values (or differences) for the floor's points\n\n\n\n    floor1_Y[0] = get_bits(gb, ilog(range - 1));\n\n    floor1_Y[1] = get_bits(gb, ilog(range - 1));\n\n\n\n    av_dlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1_Y[0], floor1_Y[1]);\n\n\n\n    offset = 2;\n\n    for (i = 0; i < vf->partitions; ++i) {\n\n        class = vf->partition_class[i];\n\n        cdim   = vf->class_dimensions[class];\n\n        cbits  = vf->class_subclasses[class];\n\n        csub = (1 << cbits) - 1;\n\n        cval = 0;\n\n\n\n        av_dlog(NULL, \"Cbits %u\\n\", cbits);\n\n\n\n        if (cbits) // this reads all subclasses for this partition's class\n\n            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,\n\n                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);\n\n\n\n        for (j = 0; j < cdim; ++j) {\n\n            book = vf->subclass_books[class][cval & csub];\n\n\n\n            av_dlog(NULL, \"book %d Cbits %u cval %u  bits:%d\\n\",\n\n                    book, cbits, cval, get_bits_count(gb));\n\n\n\n            cval = cval >> cbits;\n\n            if (book > -1) {\n\n                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,\n\n                vc->codebooks[book].nb_bits, 3);\n\n            } else {\n\n                floor1_Y[offset+j] = 0;\n\n            }\n\n\n\n            av_dlog(NULL, \" floor(%d) = %d \\n\",\n\n                    vf->list[offset+j].x, floor1_Y[offset+j]);\n\n        }\n\n        offset+=cdim;\n\n    }\n\n\n\n// Amplitude calculation from the differences\n\n\n\n    floor1_flag[0] = 1;\n\n    floor1_flag[1] = 1;\n\n    floor1_Y_final[0] = floor1_Y[0];\n\n    floor1_Y_final[1] = floor1_Y[1];\n\n\n\n    for (i = 2; i < vf->x_list_dim; ++i) {\n\n        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;\n\n\n\n        low_neigh_offs  = vf->list[i].low;\n\n        high_neigh_offs = vf->list[i].high;\n\n        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin\n\n        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;\n\n        ady = FFABS(dy);\n\n        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 4801, "substitutes": {"vc": ["nv", "vim", "gc", "vr", "ib", "asu", "vg", "rt", "v", "wx", "vd", "vm", "http", "ci", "vt", "bt", "sys", "uv", "fb", "db", "VC", "client", "gui", "cli", "cc", "cs", "bb", "wd", "dc", "lib", "ctx", "bc", "cb", "voc", "ic", "vp", "sv", "c", "lc", "lv", "api", "fc", "vv", "gg", "cv", "util", "cache", "cdn", "ctrl", "cop", "xc"], "vfu": ["svf", "vpu", "gpu", " vFU", "vorfs", "vorpu", "vFU", "vorf", " vpu", "svfu", " vfs", "gFU", "gfu", "gf", "ffu", "ffs", "svFU", "fpu", "svpu", "vorfu", "vfs", "ff"], "vec": ["buff", "vector", "buf", "window", "xy", "vals", "version", "ve", "length", "q", "cs", "def", "buffer", "len", "func", "fn", "binary", "lib", "score", "fps", "seq", "prop", "fs", "fc", "cv", "dim", "feature"], "vf": ["avf", " vb", "svf", "Vcf", "avc", " vfc", "svfen", "lfs", " vfen", "vvf", "vcf", "vvfen", "evcf", " vfe", "lfc", "evfs", "svfac", "Vfu", "mcf", "avcf", "evb", "svfe", "vfac", "svfu", " vfs", "vvcf", "evf", "vvfu", "svb", "Vf", "svfs", "Vfs", "mfe", "mf", "vfen", "mfs", "vfc", "svc", "vvfac", "vvc", " vfac", "avfs", "svcf", "vb", " vcf", "lf", "vfe", "vfs", "lcf", "svfc"], "gb": ["game", "plugin", "gp", "agg", "gc", "cfg", "bp", "vg", "gm", "hub", "vd", "ci", "gru", "rb", "vt", "Gb", "bg", "gnu", "sync", "bm", "gom", "database", "gpu", "uv", "db", "gu", "gio", "ga", "gow", "usb", "gin", "abb", "metadata", "pc", "gz", "bb", "eb", "hm", "sb", "gs", "rg", "gam", "binary", "storage", "lib", "bc", "GB", "cb", "multi", "nb", "mb", "gy", "kb", "range", "g", "bf", "gd", "gt", "gram", "gg", "cv", "git", "gn", "bn", "ui"], "range_v": ["ange_h", "range_u", "rangeallV", "range00V", "range00vector", "range_V", "ange_v", "range_vector", "ange_V", " range_u", "range_h", "range00u", " range_V", "range00v", "rangeallh", " range_vector", "rangeallv"], "floor1_Y": ["floor1PIP", "floor1FileGY", "floor2_y", "floor1PYY", "floor1AllY", "floor1JX", "floor1_P", "floor1HashP", "floor1LB", "floorOnePX", "floor1_GY", "floorOne_X", "floor1Py", "floor1LogY", "floor1_C", "floorOnePYY", "floor1JY", "floor1Filey", "floor1_YS", "floorOnePy", "floor1_X", "floor1FileDAY", "floorOne_YS", "floor1FileC", "floorOnePYS", "floor1_y", "floor1_IS", "floor1PYS", "floor1PB", "floorOne_YY", "floor1LogDAY", "floor1PP", "floor2_Y", "floor1JB", "floor2PYY", "floor1_IP", "floor2_YY", "floor1HashY", "floorOne_B", "floor151_GY", "floor1FileY", "floorOnePP", "floor151_y", "floor1PX", "floor151_C", "floor151_Y", "floor1Ly", "floor1_YY", "floor1LX", "floor1Jy", "floor1_B", "floor1LogIS", "floor2PIP", "floor1LY", "floor2Py", "floor2PY", "floor1AllP", "floorOnePY", "floor1FileIS", "floorOne_Y", "floor1Logy", "floor1PY", "floor1AllYS", "floor1HashYY", "floorOne_P", "floorOnePB", "floorOne_y", "floor1AllYY", "floor1HashYS", "floor1_DAY", "floor2_IP"], "floor1_Y_final": ["floor1_YRMAX", "floor1_y_Final", "floor1_YRFinal", "floor1_Y_MAX", "floor1_YRfinal", "floor1_y_final", "floor1_y_MAX", "floor1_Y_Final", "floor1_YRmax", "floor1_y_max", "floor1_Y_max"], "floor1_flag": ["floor1_Z", "floor1_flags"], "class": ["function", "plugin", "option", "Class", "name", "id", "count", "parent", "lass", "complete", "spec", "s", "component", "session", "config", "x", "object", "style", "com", "family", "use", "comp", "module", "unit", "cl", "bus", "package", "attr", "CLASS", "f", "url", "state", "length", "version", "code", "cell", "part", "classes", "sc", "section", "connection", "file", "full", "lib", "instance", "str", "lock", "bridge", "source", "seq", "p", "scale", "prop", "rule", "c", "attribute", "type", "user", "model", "cache", "test", "group", "current"], "cdim": ["xdim", "ndIM", "xdIM", "cdom", "xdom", "udims", " cdims", " cdom", "ndims", "cdims", "ydsim", "xdims", "CDim", "cdIM", " cdIM", "cdip", "ydima", "ndim", " cdsim", "ndom", "cdima", "CDims", " cdip", "cdsim", "CDIM", " cdima", "udim", "xdip", "CDip", "ydim", "udsim", "udima", "ydims"], "cbits": ["pvals", "acbs", "fops", " cwords", "vbits", "crbs", "ucits", "cplanes", "cvals", "dcval", "Cbit", " cvals", "Cubs", "pubs", "vwords", "cwords", " cplanes", " cbit", "corebits", "corevals", "cbs", "vvals", "Cwords", "cops", " cits", "cits", "dcparts", "pbits", "crvals", "lcbits", "ucints", "lcits", "fbits", "ucplanes", "cints", "fvals", "cubs", "tcparts", "Cvals", " cubs", "vbit", "lcops", "acval", " cbs", "crval", "acabs", "acbits", "lcplanes", "lcval", " cops", "cparts", "coreval", "tcval", "acvals", "lcints", "tcops", "Cbits", "Cval", "dcbits", "ucbits", "lcparts", " cints", "Cabs", "tcbits", "crbits", "Cints", "cbit", "coreops", "dcops", "pints", "fval"], "csub": ["csum", "codesuper", "ksuper", "lsub", "ksuc", "cksube", "nsug", "lsube", "rsuc", "codesuc", "rsub", "rsUB", "cksub", "lsug", "lsuper", "nsube", "ksubs", "nsub", "csube", "ksub", "csug", "cksuper", "nsuper", "ksum", "ksube", "codesUB", "cksum", "cksug", "csUB", "csuper", "lsubs", "lsum", "rsuper", "csuc", "codesub", "cksubs", "ksUB", "csubs"], "cval": ["pvals", "cret", "csel", "Cval", "Ceval", " cret", " cvalid", "dbits", " call", "lcsel", " cpos", "cuvalue", "dsel", "Call", "pvalue", "Cvals", " cvalues", "ceval", " ceval", "cueval", "cvalid", "dval", "pvalues", "call", " col", "dvals", "Cabs", "cuabs", "acval", "cachevalue", "cvalue", "cacheeval", "pall", "col", "cvals", "acol", "acvalid", "acvalue", " cvals", " cvalue", "acret", "pval", " csel", "Cvalue", "aceval", "lcval", "pvalid", "Cvalid", "cuval", "cvalues", "Cret", "cacheval", "lcbits", "acpos", "cachepos", "pol", "cpos", "lcvals", "Cvalues"], "offset": ["option", "o", "area", "position", "origin", "padding", "axis", "annot", "entry", "sort", "rot", "skip", "slice", "et", "alias", "optional", "Offset", "art", "loc", "f", "order", "url", "ii", "length", "align", "outer", "len", "error", "port", "after", "pad", "hop", "nb", "p", "end", "pos", "start", "range", "iso", "label", "index", "seed", "shift", "slot"], "i": ["gi", "o", "v", "id", "I", "a", "chi", "di", "s", "ci", "ni", "b", "x", "io", "xi", "si", "info", "m", "in", "qi", "ix", "l", "f", "yi", "pi", "phi", "d", "ii", "iu", "it", "ai", "u", "e", "udi", "uri", "w", "part", "k", "n", "mi", "ini", "lock", "ie", "p", "jit", "h", "z", "eni", "start", "line", "c", "ip", "ind", "y", "type", "li", "fi", "index", "ui"], "j": ["jet", "fr", "o", "ch", "v", "el", "oj", "jl", "note", "ji", "x", "b", "m", "qi", "kj", "l", "f", "job", "d", "ij", "ii", "aj", "u", "part", "e", "w", "J", "section", "jc", "k", "n", "uj", "jp", "jo", "ie", "p", "jit", "z", "un", "jj", "ld", "c", "range", "g", "y", "ja", "dj", "li", "adj", "journal", "js"], "book": ["base", "pack", "row", "build", "books", "hour", "bin", "block", "journal", "box", "count", "author", "trial", "session", " bus", "object", "style", "alias", "family", "b", "chapter", "record", "home", "kk", "uc", "unit", "valid", "db", "bus", "letter", "child", "version", "order", "sheet", "cc", "bb", "Book", "BOOK", "number", "code", "cell", " books", "file", "k", "lib", "bc", " record", "ab", "lock", "year", "coll", "week", "old", " count", "school", "un", "rule", "back", "c", "read", "label", "half", "month", "test", "group", "account", "library"], "adx": ["acp", "idx", "adX", "adp", "sdX", "acx", "sdp", "sdx", "sdw", "acX", "idX", "adw", "acw", "idw", "idp"], "ady": ["yy", "yx", "fy", "sy", "md", "wx", "ny", "kk", "ada", "eddy", "px", "ty", "wy", "ry", "ay", "adh", "oy", "asy", "ey", "yan", "idy", "ky", "ca", "edy", "hy", "dj", "mx", "axy", "az"], "dy": ["yy", "zy", "md", "dn", "di", "dd", "dx", "xy", "wy", "dq", "d", "py", "dir", "dp", "die", "da", "ds", "lon", "vy", "gy", "ld", "hi", "dj", "deb", "dl", "dt", "dim"], "off": ["flow", "o", "block", "offs", "op", "up", "home", "oa", "num", "length", "def", "down", "out", "dev", "over", "lon", "ox", "pos", "ip", "orig", "ov", "no", "on", "max", "mode", "ff", "low"], "predicted": ["predefined", "prediction", "condefined", "dedressed", "indressed", "indiction", "predressed", "condiction", "dediction", "dedicted", "condicted", "condressed", "indicted", "dedefined", "indefined"], "err": ["er", "iter", "rr", "bug", "exc", "order", "init", "later", "ev", "len", "error", "arr", "dev", "rx", "cb", "str", "score", "rev", "result", "req", "ver", "ind", "errors", "orig", "inner", "cache", "test"]}}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815, "substitutes": {"s": ["stat", "o", "sets", "sf", "ins", "is", "S", "spec", "sg", "session", "si", "sync", "sys", "ses", "services", "m", "status", "states", "xs", "f", "ns", "state", "stats", "ls", "sl", "args", "iss", "service", "bs", "cs", "ss", "conf", "series", "sis", "e", "sie", "sb", "gs", "ks", "ops", "uns", "bis", "ds", "qs", "t", "secondary", "sim", "ts", "su", "self", "p", "south", "settings", "aws", "sv", "fs", "c", "os", "ssl", "sq", "sym", "site", "es", "se", "ps", "js"], "bioc": [" bioci", "biOC", "miog", "kiocl", "kioc", "bioci", "abiog", "ciocl", "biou", "fioc", "niOC", "diog", "kiOC", " biou", "miou", " biOC", "biocal", "bioco", "biog", "dioco", "abiocol", "abiOC", "biocol", "nioc", "mioc", "abiocal", "fiOC", " biocol", " biocal", " biocl", " biog", "ciou", "abiocl", "dioci", "cioc", "niocal", "biocl", "abioci", "abioco", "miocl", "ciog", " bioco", "dioc", "kioco", "fiocol", "abioc", "fiog", "niog"], "fb": ["fen", "fg", "buff", "lb", "sf", "fw", "obb", "RF", "rb", "tmp", "bg", "ob", "rf", "raf", "orb", "buf", "wb", "f", "usb", "bb", "xb", "fe", "eb", "facebook", "sb", "fn", "ab", "cb", "fp", "bc", "nb", "fa", "fm", "fab", "fs", "bf", "fd", "deb", "cf", "fc", "FB", "ref", "pb", "fi", "ff"], "current_time": ["currentalsleep", "currentacTime", "current00delay", "current_length", "contentalsleep", "currentFfrequency", "current_duration", "current_path", "current_image", "current_delay", "contentalimage", "content_length", " current_path", "total_speed", "current00count", "content_image", "current_speed", "total_runtime", "current_TIME", "currentingtime", "currentalimage", "current00TIME", "current_frequency", "currentacdelay", "currentFcount", "currentacpath", "content_sleep", "current67time", " current_Time", "current00Time", "current_count", " current_TIME", "current00frequency", "current67length", "current_runtime", "total_time", "currentaltime", "currentFTIME", " current_frequency", "current_Time", "contentaltime", "contentallength", " current_count", "current67image", "currentingspeed", "currentactime", "content_time", "currentingduration", "currentFtime", "currentingruntime", "current00path", "current00time", "total_duration", "currentallength", " current_delay", "current_sleep", "current67sleep"], "local_err": ["remote_err", "local_orig", "foreign_progress", "localapperror", "localapper", "localableerr", "local_error", "foreign_dr", "foreignxprogress", "localxdr", "remote_state", "foreignxerr", "global_err", "custom_result", "localamstate", "localxcache", "global_notice", "localamerror", "localipprogress", "local_result", "local_notice", "localiperr", "custom_msg", "localxprogress", "localipdr", "local_dr", "local_msg", "localxerr", "localappnotice", "localableorig", "custom_rr", "foreign_cache", "remote_error", "foreignxdr", "localableer", "foreignxcache", "global_orig", "local_cache", "localamerr", "localipcache", "local_progress", "custom_err", "localapperr", "foreign_err", "global_error", "localableresult", "local_rr", "local_er", "global_result", "global_er", "local_state"], "ret": ["red", "reg", "flag", "rt", "sr", "alt", "count", "try", "nt", "rb", "rot", "val", "rc", "bit", "let", "reply", "pt", " RET", "num", " Ret", "lit", "att", "arg", "res", "ry", "match", "len", "mt", "code", "det", "out", "RET", "pass", "rl", "rev", "result", "Ret", "ft", "re", "fun", "bf", "resp", "success", "ref", "no", "rets"], "delay_ms": ["delay_mins", "delay32ms", "delay_details", "delayFts", "delay__mins", "delay_bytes", "delayingbytes", "pause_loads", "delay32mins", "pausevalyrs", "delayFdetails", "delayacbytes", " delay_details", "delayacmb", "delayingmb", " delay_ts", "delay_loads", "delay32ts", "delayvalmins", "pausevalloads", "pausevalmins", "delayingms", "delayacms", "delay_ts", " delay_mb", "pause_yrs", "pausevalms", "delay_yrs", "delayvalloads", "delay__yrs", " delay_mins", "delayacmins", "pause_mins", "delayFms", " delay_bytes", "delayFmins", "delayvalms", "delay_mb", "delay32details", "delay__ms", "delay__loads", "delayvalyrs", "pause_ms", "delayingmins"]}}
{"project": "qemu", "commit_id": "c97294ec1b9e36887e119589d456557d72ab37b5", "target": 0, "func": "static void pc_init1(QEMUMachineInitArgs *args,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(args->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (args->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = args->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = args->ram_size;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n\n\n    if (smbios_defaults) {\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            args->machine->name);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(system_memory,\n\n                       args->kernel_filename, args->kernel_cmdline,\n\n                       args->initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, args->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 4835, "substitutes": {"args": ["plugin", "limits", "ig", "extra", "ins", "spec", "arms", "alls", "sg", "config", "atts", "cus", "Args", "sys", "ips", "details", "states", "html", "vals", "argument", "ants", "parts", "ext", "ns", "arg", "py", "init", "cli", "cs", "conf", "actions", "pc", "fields", "size", "acl", "ass", "parser", "gs", "ks", "arr", "ds", "cmd", "self", "parse", "this", "aws", "ana", "alloc", "Arg", "doc", "utils", "global", "g", "ams", "ids", "params", "ac", "cache", "current", "ras", "conn", "flags", "msg"], "pci_enabled": ["pdi__supported", "pdi_protected", "pdi_enable", "pci__enable", "pci_enable", "pci__enabled", "pdi_enabled", "pci__protected", "pci_protected", "pdi__protected", "pdi__enable", "pdi__enabled", "pci__supported", "pci_supported", "pdi_supported"], "kvmclock_enabled": ["kvmclock_available", "kvmclock_enable", "kvmclock_supported", "kvmClock_disabled", "kvmclock_disabled", "kvmClock_supported", "kvmClock_enabled", "kvmClock_available"], "system_memory": [" system_model", "system_machine", "systemsmemory", "system_media", "systemsmodel", " system_media", "system___model", "systemsmachine", "system___memory", "system___machine", "system_model", "system___media", "systemsmedia", " system_machine"], "system_io": ["system_ios", "system_info", " system_ios", " system_info"], "i": ["o", "v", "I", "a", "is", "s", "xi", "b", "io", "m", "l", "f", "pi", "d", "iu", "j", "e", "disk", "n", "p", "proc", "c", "ip", "im", "g", "ed", "r"], "below_4g_mem_size": ["below_4g_memsscale", "below_4g_mem_sum", "below_4g_memory_size", "below_4g_memory_type", "below_4g_mem_name", "below_4g_memssum", "below_4g_memory_scale", "below_4g_mem_type", "below_4g_memory_sum", "below_4g_memstype", "below_4g_mem_scale", "below_4g_memssize"], "above_4g_mem_size": ["above_4g_mem_scale", "above_4g_memssize", "above_4g_memory_size", "above_4g_memory_sum", "above_4g_mem_sum", "above_4g_mem_small", "above_4g_mem_sec", "above_4g_memsscale", "above_4g_memssec", "above_4g_memory_scale"], "pci_bus": ["pcijboot", "pcm_boot", "pci__usb", "pci__block", "pcm_block", "pcm_usb", "pci_usb", "pci_boot", "pci__boot", "pcijusb", "pcijbus", "pci_block", "pcm_bus", "pcijblock", "pci__bus"], "isa_bus": ["ci_boot", "isa1device", "isa_boot", "ci_device", "ci_driver", "isa1bus", "ci_bus", "isa1driver", "isa_driver", "isa_device", "isa1boot"], "i440fx_state": ["i440fxpconfig", "i440fx_conn", "i440fx2port", "i440fx2config", "i440fx_config", "i440fs2conn", "i440fs2port", "i440fs_conn", "i440fx2state", "i440fs_config", "i440fxpstate", "i440fs_port", "i440fx2conn", "i440fs_state", "i440fs2state", "i440fx_port", "i440fs2config", "i440fxpconn", "i440fxpport"], "cpu_irq": ["cpu_irtce", "cpu_irce", "cpu_pirq", "cpu_IRqs", "cpu_irtqs", "cpu_pirQ", "cpu_pirce", "cpu_IRq", "cpu_irQ", "cpu_irtq", "cpu_IRce", "cpu_irtQ", "cpu_IRQ", "cpu_pirqs", "cpu_irqs"], "gsi": ["pdi", "gmi", " gni", "Gdi", "psi", "pni", " gdi", "pmi", "Gsi", "gni", "gdi", " gmi", "Gni", "Gmi"], "i8259": ["i8192", "u8259", "i6259", "u8192", "i8255", "u8255", "i9192", "i6192", "i9266", "i6266", "i6255", "i9259", "u8266", "i8266", "i9255"], "smi_irq": ["smi_earf", "smi_earqs", "smi_ironqu", "smi_irqs", "smi_mirqu", "smi_earqu", "smi_ironqs", "smi_mirqs", "smi_earq", "smi_ironf", "smi_ironq", "smi_irqu", "smi_mirq", "smi_irf", "smi_mirf"], "gsi_state": ["gdi_type", "gsi_config", "gsi_type", "gdi_state", "gdi_info", "gdi_config", "gsi_info"], "hd": ["dri", "hp", "dr", "hw", "hub", "md", "hard", "vd", "bd", "dd", "HD", "pd", "dh", "hid", "rh", "hs", "udi", "hm", "wd", "xd", "h", "dump", "ht", "ld", "du", "gd", "ha", "dim", "cd"], "MAX_IDE_BUS": ["MAX_IDE_bus", "MAX_ISE_BUS", "MAX_ISE_bus", "MAX_IDEADUSB", "MAX_IDEADBI", "MAX_IDE_PU", "MAX_IDERAMPU", "MAX_IDEADBUS", "MAX_ISE_USB", "MAX_IDEJPU", "MAX_IDE_USB", "MAX_IDE_BI", "MAX_ISE_PU", "MAX_IDEJbus", "MAX_IDEJBUS", "MAX_IDERAMbus", "MAX_ISE_BI", "MAX_IDERAMBUS"], "MAX_IDE_DEVS": ["MAX_IDE_DEFS", "MAX_IDE_DAVS", "MAX_IDE_DAVERS", "MAX_IDE_DIVICE", "MAX_IDE_DVERS", "MAX_IDE_DAVICE", "MAX_IDE_DVICE", "MAX_IDE_DIVS", "MAX_IDE_DFS", "MAX_IDE_DEVERS", "MAX_IDE_DEVICE", "MAX_IDE_DAFS", "MAX_IDE_DIVERS", "MAX_IDE_DIFS", "MAX_IDE_DVS"], "idebus": ["ipdev", "ipbus", "idenbook", "ipbook", "sideBUS", "ipBUS", "idedev", "sidedev", "sidebus", "sidebook", "idenbus", "idenBUS", "ideBUS", "idebook", "idendev"], "rtc_state": ["rtf_state", "rtc_conn", "rtf_mode", "rtf_config", "rtf_conn", "rtc_mode", "rtc_config"], "floppy": ["FLoppy", "FLappy", "flipop", "plipop", "flappy", "ploppy", "FLops", "zappy", "plops", "zoppy", "plappy", "FLipop", "flops", "zops", "zipop"], "ram_memory": ["gram_mem", "ram_usage", "ram_data", "ram_manager", "ram_mem", "system_data", "gram_address", "system_usage", "system_mem", "gram_manager", "ram_address", "gram_memory"], "pci_memory": ["pcm_address", "pciicanmem", "pciicanmemory", "pcm_mem", "pcm_connection", "pcm_memory", "pciicanaddress", "pci_mem", "pci_address", "pciicanconnection", "pci_connection"], "rom_memory": ["ram_message", "ramplemem", "ram__port", "ramplemessage", "ram_mem", "rampleport", "rom_mem", "ram__memory", "ram__message", "ram__mem", "ramplememory", "ram_port", "rom_message", "rom_port"], "icc_bridge": ["icc_version", "iccureserver", "lc_config", "lc_driver", "lc_state", "acl_version", "icc_pad", "cci_driver", "cci_pad", "cci_ridge", "icc_dev", "iccureversion", "icc_ridge", "icc_brid", "cci_bridge", "iccMridge", "acl_server", "icc_state", "icc_drive", "icc_driver", "pc_dev", "iccuredrive", "iccMdriver", "icc_server", "acl_bridge", "pc_driver", "pc_bridge", "pc_brid", "acl_drive", "iccMpad", "iccMbridge", "icc_config", "iccurebridge", "lc_bridge"], "fw_cfg": ["hw_fg", "fw_state", "hw_state", "fw_config", "fw_fg", "hw_cfg", "hw_config"], "guest_info": ["guestallstate", "guest_cfg", "guess_state", "guest_status", "guess_status", "guess_info", "guess_cfg", "guest1info", "guest1cfg", "guest1state", "guestallcfg", "guestallstatus", "guest1status", "guestallinfo", "guest_state"]}}
{"project": "qemu", "commit_id": "4bb3893908385836410346725dd9e584dcd24836", "target": 0, "func": "uint32_t wm8750_adc_dat(void *opaque)\n\n{\n\n    WM8750State *s = (WM8750State *) opaque;\n\n    uint32_t *data;\n\n\n\n    if (s->idx_in >= sizeof(s->data_in))\n\n        wm8750_in_load(s);\n\n\n\n    data = (uint32_t *) &s->data_in[s->idx_in];\n\n    s->req_in -= 4;\n\n    s->idx_in += 4;\n\n    return *data;\n\n}\n", "idx": 4842, "substitutes": {"opaque": [" opec", "opque", "ocaque", "OPque", "operque", "OPacity", "ocque", "operaques", "ipaques", "ipec", "ocacity", "operaque", "OPaque", "ipaque", "opec", "ocaques", "OPaques", "pec", "opaques", "paque", "operacity", "opacity", " opaques", "paques"], "s": ["as", "o", "sets", "sf", "ins", "is", "S", "a", "http", "spec", "sg", "scope", "sites", "session", "b", "si", "i", "slice", "sync", "ses", "services", "m", "its", "in", "states", "xs", "f", "ns", "state", "d", "ls", "sl", "stats", "ss", "cs", "u", "e", "an", "sb", "gs", "ops", "ks", "t", "ds", "n", "ts", "su", "self", "p", "south", "settings", "aws", "fs", "sa", "c", "new", "os", "ssl", "sym", "g", "your", "params", "es", "rs", "ps"], "data": ["as", "options", "o", "bin", "v", "alpha", "change", "a", "dat", "value", "session", "aa", "val", "style", "i", "ad", "wa", "body", "m", "image", "in", "valid", "window", "results", "media", "d", "DATA", "e", "da", "ata", "n", "Data", "bytes", "empty", "response", "load", "result", "p", "input", "output", "batch", "memory", "cache", "partial", "r", "ui"]}}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n", "idx": 4849, "substitutes": {"v": ["vim", "o", "a", "s", "value", "V", "vt", "val", "x", "data", "i", "m", "uv", "l", "f", "conv", "version", "j", "q", "u", "vi", "vs", "e", "k", "t", "p", "virtual", "h", "vp", "sv", "iv", "var", "c", "g", "lv", "vv", "view"]}}
{"project": "FFmpeg", "commit_id": "11de006babf735aafa3462d43dd2c02bb6ac6e2f", "target": 0, "func": "static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    struct video_data *s = s1->priv_data;\n\n    AVFrame *frame = s1->streams[0]->codec->coded_frame;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    int res;\n\n\n\n    av_init_packet(pkt);\n\n    if ((res = mmap_read_frame(s1, pkt)) < 0) {\n\n        return res;\n\n    }\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (frame && s->interlaced) {\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first = s->top_field_first;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    return pkt->size;\n\n}\n", "idx": 4873, "substitutes": {"s1": ["s4", "s81", "s001", "c2", "sc4", "ses1", "c1", "sec01", "ks81", "s2", "p2", "sys01", " s81", "c4", "c6", "ps4", "ksOne", "sc6", "sl01", "S01", "sl001", " s2", "S1", "sc2", "sec1", "ps2", "p11", "slOne", "sl1", "secOne", "ks01", "sys2", "sys001", "sc1", " s11", "sesOne", "ps1", "p1", "sys11", "ses01", "s11", "s6", "ks1", "ps6", "sys81", "p81", "SOne", "sec001", "sOne", "S81", "ses81", "sysOne", "sys1", "s01"], "pkt": ["spet", "racket", "rnt", "rkt", "Pkt", "pakt", " pet", "Pck", "miece", "piece", "bnt", "bpt", " piece", "bkt", "papt", " pnt", "pck", " ppt", "ppt", "pet", "Pnt", "spnt", "Packet", "paacket", "spkt", "mkg", "mck", "mkt", " pck", "backet", "spacket", "Ppt", "Pkg", " pkg", "paet", "Piece", "pnt", "packet", "rpt", "Pet", "pkg", " packet"], "s": ["o", "sf", "v", "S", "a", "spec", "sg", "session", "b", "data", "si", "i", "sys", "ses", "services", "m", "l", "f", "parts", "ns", "stats", "d", "sl", "series", "space", "service", "cs", "u", "e", "sc", "w", "gs", "sb", "ds", "t", "n", "source", "p", "sa", "c", "os", "g", "ssl", "sq", "frames", "ps"], "frame": ["function", "game", "flow", "dy", "row", "o", "fr", "position", "block", "v", "component", "scope", "session", "pse", "object", "iframe", "style", "slice", "record", "module", "image", "Frame", "fb", "window", "sequence", "html", "fake", "f", "draw", "rame", "state", "d", "series", "document", "e", "point", "w", "message", "fram", "df", "lock", "coll", "p", "scale", "line", "node", "c", "range", "setup", "cf", "video", "frames", "element", "fi", "summary", "feature"], "res": ["nos", "gr", "row", "r", "reset", "ret", "reg", "cr", "red", "id", "runs", "ris", "ress", "Res", "val", "rc", "rows", "details", "rh", "vals", "results", "reed", "def", "resolution", "len", "rss", "rus", "error", "arr", " Res", "bytes", "err", "rev", "result", "pres", "blocks", "resh", "req", "re", "RES", "mr", "os", "errors", "resp", "ms", "br", "rap", "breaks", "rep", "rs", "ras", "ps", "js"], "interlaced": ["interlace", "interpace", "INTERlace", "interrace", "interraces", "interpolaced", "interpaced", "interpolaces", "INTERlaced", "interracer", "INTERlaces", "interpolace", "INTERracer", "interlaces", "INTERlacer", "INTERrace", "interpolacer", "interpacer", "interraced", "interpaces", "INTERraces", "interlacer", "INTERraced"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n", "idx": 4874, "substitutes": {"klass": ["Kclass", "Klass", "oklass", "kleton", "klasses", " klasses", "sklass", "sklasses", "ccleton", "cclass", " kclass", "okcl", "skcl", "okclass", "Kcl", "kclass", "Klasses", "ccclass", "kcl", "cclasses", "skclass", "Kleton", " kleton", "oklasses", " kcl"], "data": ["o", "parent", "di", "dat", "dd", "config", "i", "rc", "m", "f", "child", "d", "DATA", "def", "da", "ata", "raw", "Data", "ctx", "load", "p", "input", "reader", "params", "cache"], "dc": ["cp", "oc", "dr", "cr", "dn", "di", "dat", "disc", "nc", "rc", "cca", "uc", "ga", "dk", "d", "cc", "ck", "mc", "sc", "da", "df", "bc", "ec", "ca", "DC", "c", "ct", "cf", "dt", "tk", "fc", "design", "ac", "cdn", "conn", "cd", "tc"], "k": ["oc", "o", "kin", "kn", "ik", "s", "spec", "kick", "kk", "ad", "m", "K", "sk", "f", "dk", "d", "q", "cc", "cs", "ck", "e", "kind", "w", "mc", "ks", "n", "kid", "self", "p", "kw", "c", "ke", "g", "tk", "ku", "mk", "ok"]}}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    MPADecodeHeader c;\n\n    int vbrtag_size = 0;\n\n    MP3DecContext *mp3 = s->priv_data;\n\n\n\n    ffio_init_checksum(s->pb, ff_crcA001_update, 0);\n\n\n\n    v = avio_rb32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return -1;\n\n\n\n    if (avpriv_mpegaudio_decode_header(&c, v) == 0)\n\n        vbrtag_size = c.frame_size;\n\n    if(c.layer != 3)\n\n        return -1;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n\n\n    mp3->frames = 0;\n\n    mp3->size   = 0;\n\n\n\n    mp3_parse_info_tag(s, st, &c, spf);\n\n    mp3_parse_vbri_tag(s, st, base);\n\n\n\n    if (!mp3->frames && !mp3->size)\n\n        return -1;\n\n\n\n    /* Skip the vbr tag frame */\n\n    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);\n\n\n\n    if (mp3->frames)\n\n        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},\n\n                                    st->time_base);\n\n    if (mp3->size && mp3->frames && !mp3->is_cbr)\n\n        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);\n\n\n\n    return 0;\n\n}\n", "idx": 4879, "substitutes": {"s": ["sets", "ches", "sf", "is", "S", "spec", "sg", "session", "b", "si", "sync", "sys", "ses", "services", "m", "its", "states", "xs", "f", "ns", "sl", "ls", "space", "service", "bs", "cs", "ss", "us", "conf", "e", "sc", "sb", "w", "se", "sim", "gs", "ks", "ds", "storage", "t", "qs", "ops", "ts", "su", "self", "p", "aws", "sv", "fs", "sup", "sa", "os", "g", "ssl", "sq", "sym", "es", "rs", "src", "ps", "js"], "st": ["std", "r", "est", "ste", "store", "ost", "tmp", "b", "si", "style", "sn", "stack", "stream", "ust", "support", "sts", "rest", "state", "d", "sl", "St", "fe", "cs", "ss", "td", "e", "sc", "sth", "sb", "stop", "inst", "sh", "sd", "ds", "t", "ctx", "storage", "ts", "ST", "str", "p", "sta", "stage", "sp", "start", "step", "sa", "ct", "src", "ast", "nd"], "base": ["bas", "kit", "address", "name", "area", "stable", "origin", "store", "id", "a", "beta", "val", "ada", "b", "i", "stack", "bi", "ace", " bases", "l", "ma", "rest", "client", "at", "f", "offset", "version", "server", "ii", "byte", "u", "buffer", "len", "out", "full", "bound", "pad", "ase", "p", "old", "based", "scale", "root", "Base", "stage", "temp", "gb", "zero", "start", "ver", "hi", "bf", "api", "cache", "ases", "set", "index", "r", "end", "ui", "prefix"], "v": ["o", "ch", "store", "a", "vd", "vm", "channel", "va", "V", "value", "b", "val", "x", "i", "format", "m", "uv", " channel", "l", "f", "pi", "at", "conv", "d", "ve", "j", "q", "u", "vi", "code", "e", "vs", "w", "k", "t", "n", "volt", "rev", "p", "h", "vert", "z", "sv", "iv", "ver", "g", "api", "lv", "vv", "cv", "vc", " version", "r"], "spf": [" spp", "ipF", "ipv", "SPp", "aspfw", "aspv", "ipf", " spg", "scg", "scf", "arpfx", "swfs", "scv", "scfg", "epf", "spF", " spfw", "epF", " spfg", "aspf", "spb", "swb", " spv", "scfe", "arpf", "SPb", "spv", " spF", "ispfs", "scfs", "scfd", "scfw", "ispfg", "ispf", " spfd", "scfx", " spfs", "spfe", "spfo", "spfx", " spfx", "arpfd", "spfd", "epfs", "aspfo", "scfo", "swf", " spfo", "SPf", "swp", "spfw", "spg", "SPfs", "epv", "ispfe", "spp", " spb", "arpg", "spfs", " spfe", "ipfs", "spfg"], "c": ["cp", "ch", "cr", "a", "spec", "ci", "config", "b", "x", "rc", "i", "cy", "enc", "co", "C", "m", "uc", "l", "cl", "f", "d", "pc", "cc", "cs", "ce", "u", "code", "e", "sc", "mc", "con", "t", "dc", "n", "ctx", "k", "bc", "cu", "coll", "p", "ic", "ctrl", "ec", "h", "g", "ct", "cf", "lc", "fc", "ac", "vc", "cm", "xc", "tc"], "mp3": ["pp3", "comp3", "pm3", "mag13", "mt23", " mp53", "mb3", " mpthree", "mm6", "mp6", "Mp13", "map253", "avthree", "mb35", "mp23", "mb23", "Mp3", "MP3", "map3", "media23", "av253", "MP6", "Mp03", " mp6", "mag6", "media03", "pp35", "Mp2", "mb1", "av03", "Mp6", "pp53", "mbthree", "mt15", "mp2", " mp15", "mp35", "mapthree", " mpcd", "mb6", "mb13", "mp253", "mp13", "amp3", "mp48", "mb253", "mag3", " mp23", "pp03", "av3", "mb15", "jp1", "av48", " mp4", "mpthree", "jp4", "mb03", "map03", "ampcd", "jp03", "MP03", "mp15", "magthree", "mp03", "MPthree", "mm3", " mp2", "mm03", "mb2", " mp03", "comp13", "mediathree", "MP13", " mp1", "comp03", "mpcd", "mb4", "amp6", "pp23", "mt3", "Mpcd", "mb53", "mm53", "jp3", "pm03", "pm35", "pm23", "mt6", "ppthree", "pp2", "MP48", "mp1", "amp2", "media3", "mp4", "mp53", "comp48"]}}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay_all(MemoryRegion *mr)\n\n{\n\n    IOMMUNotifier *notifier;\n\n\n\n    IOMMU_NOTIFIER_FOREACH(notifier, mr) {\n\n        memory_region_iommu_replay(mr, notifier, false);\n\n    }\n\n}\n", "idx": 4892, "substitutes": {"mr": ["dr", "gr", "fr", "mir", "er", "vr", "ris", "sr", "dm", "ml", "rt", "rr", "md", "vm", "rb", "mid", "MR", "tr", "rf", "bm", " MR", "module", "m", "rm", "rh", "ir", "pm", "attr", "mn", "ra", "nr", "mc", "mt", "rg", "rx", "lr", "mi", "fm", "reader", "gb", "rule", "yr", "mm", "RR", "hr", "br", "adr", "kr", "rs", "r", "manager", "cm"], "notifier": ["annification", "annotification", "notification", "ntification", "annotifier", "Notifier", "notener", "notifer", " notifer", " notification", "annifer", "annotener", " notizer", "Notifer", "bitification", "nonener", "annifier", "nonifer", "ntizer", " notger", "Notger", "annizer", "bitifer", "ntifier", "notger", "notizer", "annotifer", "nonifier", "Notification", "bitifier", " notener", "bitger", "nonification", "ntifer"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix3_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 4893, "substitutes": {"dev": ["hw", "ch", "block", "v", "md", "rad", "spec", "Dev", "dd", "device", "adv", "bug", "data", "info", "dem", "debug", "gu", "de", "d", "mod", "conf", "def", "ev", "DEV", "priv", "kind", "error", "comment", "w", "prom", "inst", " device", "err", "pub", "serial", "req", "mode", "development", "ver", "engine", "desc", "app", "test", "loader", "grad", "conn", "diff", "end"], "s": ["o", "serv", "sf", "v", "S", "spec", "sg", "session", "b", "si", "i", "sync", "sys", "ses", "services", "m", "f", "state", "d", "sl", "server", "ss", "conf", "e", "sh", "sb", "w", "storage", "t", "n", "ds", "p", "south", "settings", "sv", "c", "os", "g", "ssl", "sq", "js"], "pci_conf": ["pii_conf", "pii_Conf", "pki_def", "pci_conn", "pci_config", "pci_Conf", "pcm_sum", "pii_config", "pcm_conf", "pki_conf", "pcm_conn", "pki_config", "pii_conn", "pcm_config", "pci_sum", "pki_conn", "pci_def"]}}
{"project": "FFmpeg", "commit_id": "842b6c14bcfc1c5da1a2d288fd65386eb8c158ad", "target": 0, "func": "static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;\n\n    int val, stream_type, i;\n\n\n\n    q = data;\n\n    put16(&q, 0xe000 | service->pcr_pid);\n\n\n\n    program_info_length_ptr = q;\n\n    q += 2; /* patched after */\n\n\n\n    /* put program info here */\n\n\n\n    val = 0xf000 | (q - program_info_length_ptr - 2);\n\n    program_info_length_ptr[0] = val >> 8;\n\n    program_info_length_ptr[1] = val;\n\n\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        MpegTSWriteStream *ts_st = st->priv_data;\n\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        switch(st->codec->codec_id) {\n\n        case AV_CODEC_ID_MPEG1VIDEO:\n\n        case AV_CODEC_ID_MPEG2VIDEO:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG2;\n\n            break;\n\n        case AV_CODEC_ID_MPEG4:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG4;\n\n            break;\n\n        case AV_CODEC_ID_H264:\n\n            stream_type = STREAM_TYPE_VIDEO_H264;\n\n            break;\n\n        case AV_CODEC_ID_CAVS:\n\n            stream_type = STREAM_TYPE_VIDEO_CAVS;\n\n            break;\n\n        case AV_CODEC_ID_DIRAC:\n\n            stream_type = STREAM_TYPE_VIDEO_DIRAC;\n\n            break;\n\n        case AV_CODEC_ID_MP2:\n\n        case AV_CODEC_ID_MP3:\n\n            stream_type = STREAM_TYPE_AUDIO_MPEG1;\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;\n\n            break;\n\n        case AV_CODEC_ID_AAC_LATM:\n\n            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;\n\n            break;\n\n        case AV_CODEC_ID_AC3:\n\n            stream_type = STREAM_TYPE_AUDIO_AC3;\n\n            break;\n\n        default:\n\n            stream_type = STREAM_TYPE_PRIVATE_DATA;\n\n            break;\n\n        }\n\n        *q++ = stream_type;\n\n        put16(&q, 0xe000 | ts_st->pid);\n\n        desc_length_ptr = q;\n\n        q += 2; /* patched after */\n\n\n\n        /* write optional descriptors here */\n\n        switch(st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if(st->codec->codec_id==AV_CODEC_ID_EAC3){\n\n                *q++=0x7a; // EAC3 descriptor see A038 DVB SI\n\n                *q++=1; // 1 byte, all flags sets to 0\n\n                *q++=0; // omit all fields...\n\n            }\n\n            if(st->codec->codec_id==AV_CODEC_ID_S302M){\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'B';\n\n                *q++ = 'S';\n\n                *q++ = 'S';\n\n                *q++ = 'D';\n\n            }\n\n\n\n            if (lang) {\n\n                char *p;\n\n                char *next = lang->value;\n\n                uint8_t *len_ptr;\n\n\n\n                *q++ = 0x0a; /* ISO 639 language descriptor */\n\n                len_ptr = q++;\n\n                *len_ptr = 0;\n\n\n\n                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n\n                    next = strchr(p, ',');\n\n                    if (strlen(p) != 3 && (!next || next != p + 3))\n\n                        continue; /* not a 3-letter code */\n\n\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n\n\n                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n\n                    *q++ = 0x01;\n\n                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)\n\n                    *q++ = 0x02;\n\n                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)\n\n                    *q++ = 0x03;\n\n                else\n\n                    *q++ = 0; /* undefined type */\n\n\n\n                    *len_ptr += 4;\n\n                }\n\n\n\n                if (*len_ptr == 0)\n\n                    q -= 2; /* no language codes were written */\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            {\n\n                const char default_language[] = \"und\";\n\n                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n\n\n\n                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n\n                    uint8_t *len_ptr;\n\n                    int extradata_copied = 0;\n\n\n\n                    *q++ = 0x59; /* subtitling_descriptor */\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - extradata_copied >= 5) {\n\n                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n\n                            extradata_copied += 5;\n\n                            q += 4;\n\n                        } else {\n\n                            /* subtitling_type:\n\n                             * 0x10 - normal with no monitor aspect ratio criticality\n\n                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */\n\n                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n\n                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n\n                                /* support of old 4-byte extradata format */\n\n                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n\n                                extradata_copied += 4;\n\n                                q += 4;\n\n                            } else {\n\n                                put16(&q, 1); /* composition_page_id */\n\n                                put16(&q, 1); /* ancillary_page_id */\n\n                            }\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n\n                    uint8_t *len_ptr = NULL;\n\n                    int extradata_copied = 0;\n\n\n\n                    /* The descriptor tag. teletext_descriptor */\n\n                    *q++ = 0x56;\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3) {\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - 1 > extradata_copied) {\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 2);\n\n                            extradata_copied += 2;\n\n                            q += 2;\n\n                        } else {\n\n                            /* The Teletext descriptor:\n\n                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)\n\n                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.\n\n                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */\n\n                            *q++ = 0x08;\n\n                            *q++ = 0x00;\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                 }\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {\n\n                *q++ = 0x05; /*MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'd';\n\n                *q++ = 'r';\n\n                *q++ = 'a';\n\n                *q++ = 'c';\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor */\n\n                *q++ = 4;\n\n                *q++ = 'K';\n\n                *q++ = 'L';\n\n                *q++ = 'V';\n\n                *q++ = 'A';\n\n            }\n\n            break;\n\n        }\n\n\n\n        val = 0xf000 | (q - desc_length_ptr - 2);\n\n        desc_length_ptr[0] = val >> 8;\n\n        desc_length_ptr[1] = val;\n\n    }\n\n    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,\n\n                          data, q - data);\n\n}\n", "idx": 4896, "substitutes": {"s": ["as", "sets", "ches", "sf", "v", "ins", "is", "S", "spec", "session", "b", "si", "sync", "sys", "ses", "services", "its", "support", "states", "l", "f", "parts", "ns", "server", "sl", "series", "space", "ss", "cs", "gs", "ks", "sim", "t", "ds", "qs", "storage", "tests", "su", "settings", "aws", "sv", "sa", "c", "ys", "g", "ssl", "sq", "y", "os", "rs", "ps", "js"], "service": ["Service", "serv", "sr", "v", "scope", "session", "config", "si", "sync", "stream", "sys", "info", "services", "image", "support", "so", "resource", "server", "sl", "j", "space", "cs", "connection", "se", "storage", "sd", "ctx", "ie", "settings", "reader", "sv", "sp", "bank", "fs", "c", "g", "query", "vc", "js"], "ts": ["tes", "ets", "atts", "tr", "services", "tu", "tx", "Ts", "att", "ns", "ats", "ls", "TS", "cs", "ss", "ics", "gs", "ks", "t", "ds", "qs", "tests", "outs", "ents", "trans", "acs", "fs", "utils", "ms", "ims", "uts", "tt", "test", "rs", "ps", "tc"], "data": ["mem", "block", "a", "dat", "config", "format", "stream", "map", "buf", "vals", "offset", "f", "d", "length", "DATA", "byte", "def", "buffer", "len", "ops", "arr", "raw", "ds", "Data", "bytes", "empty", "seq", "input", "array", "req", "reader", "xxx", "zero", "read", "cache", "r", "rec", "shift"], "q": ["ch", "o", "iq", "v", "id", "count", "qq", "value", "qt", "x", "queue", "qi", "quant", "l", "f", "ue", "dq", "length", "d", "u", "w", "depth", "qs", "Q", "k", "t", "n", "qu", "seq", "qa", "req", "h", "z", "charge", "c", "g", "sq", "type", "query", "requ", "quest"], "desc_length_ptr": ["program_length32length", "program_length32ptr", "program_length_info", "program_length32pointer", "program_length_length", "program_len_ptr", "program_length_ptr", "program_len_pointer", "program_length32info", "program_len_info", "program_len_length", "program_length_pointer"], "program_info_length_ptr": ["program_info_length_pointer", "program_info_length__length", "program_info_info_pad", "program_info_info_pointer", "program_info_info_tr", "program_info_length_tr", "program_info_len_len", "program_info_length_pad", "program_info_len_pointer", "program_info_length__pointer", "program_info_length_len", "program_info_info_pointers", "program_info_length_pointers", "program_info_length__pointers", "program_info_length__ptr", "program_info_info_val", "program_info_length_length", "program_info_len_length", "program_info_info_length", "program_info_info_ptr", "program_info_length_val", "program_info_len_ptr"], "val": ["vol", "base", " v", "v", "al", "el", "sec", "alt", "value", "x", "b", "Val", "pt", " value", "fx", "buf", "l", "vals", "cal", "valid", "f", "ival", "tx", "d", "sl", "fl", "VAL", "len", "e", "depth", "ol", "aval", "k", "bc", "seq", "eval", "sel", "vl", "ul", "il", "li", "bl", "ref", "au", "r", "grad", "max"], "stream_type": ["streamenunit", "source_style", "streamsstyle", " stream_id", "streamalid", "streamfformat", "channel_TYPE", "outputentype", "streamerunit", "resource_shape", "outputenid", "streamingname", "streamingid", "streamingtype", "stream_unit", "channel_type", "output_id", "streamingTYPE", "stream_target", "streamabletype", "source_type", "channel_template", "stream_format", "stream_TYPE", "streamingtemplate", "stream_state", "output_type", "stream_template", "stream_id", "streamenlength", "resourceingcount", "streamftemplate", "streamalstyle", "stream_list", "streamingshape", "streamvaltemplate", "streamenlist", "outputenlength", "source_mode", "streamerlist", "sourcesid", "streamalstate", "streamsid", "resource_id", "streamftype", "ream_type", "streamsmode", "source_id", "stream_length", "resource_count", "streamaltype", "stream_count", "program_length", "stream_value", "resourceingid", "streamertype", "streamenvalue", "resourceingshape", "program_type", "stream_shape", "streamalformat", "sourcestype", "streamfTYPE", "streamablestyle", "resourceingtype", "streamvaltype", "stream_mode", "channel_format", "streamalvalue", "output_target", "streamenid", "streamingstate", "program_id", "output_length", "program_name", "streamingvalue", " stream_template", "ream_list", "streaminglength", "streamstarget", "streamentarget", "ream_unit", "streamingformat", "stream_style", "streamingcount", "ream_format", "streamvalid", "streamableid", "streamalmode", "sourcesmode", "ream_state", "streamstype", "sourcesstyle", "streamslength", "streamervalue", "outputentarget", "stream_name", "streamentype", "streamablemode", "ream_value", "resource_type"], "i": ["gi", "o", "ti", "v", "id", "I", "di", "ci", "ni", "x", "b", "si", "ri", "xi", "io", "info", "abi", "m", "qi", "ix", "yi", "pi", "phi", "d", "ii", "j", "iu", "ai", "my", "uli", "it", "u", "e", "uri", "k", "multi", "mi", "ini", "ie", "eni", "oi", "hi", "c", "ip", "im", "y", "li", "fi", "index", "zi", "mu", "ui"], "st": ["std", "r", "est", "fr", "ste", "sr", "ost", "sw", "stal", "tr", "sn", "stream", "pt", "stress", "sts", "rest", "d", "sl", "St", "fe", "td", "sc", "sth", "sb", "ist", "inst", "sd", "t", "ds", "ST", "str", "sta", "stage", "sp", "start", "sa", "ld", "src", "ast", "nd", "stim"], "ts_st": ["ds_stream", "ts_stream", "ts_ost", "ds_st", "ts_sc", "ds_ost", "ds_sc"], "lang": ["std", "ml", "la", "entry", "enc", "art", "tu", "in", "th", "tag", "tx", "de", "ga", "obj", "en", "sd", "str", "trans", "sa", "lc", "bl", "pl", "au", "rs", "src", "ast", "nd"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 4899, "substitutes": {"dc": ["dr", " DC", "gc", "ea", "dm", "di", "dat", "config", "disc", "nc", "rc", "cca", "data", "circ", "uc", "loc", "enter", "draw", "db", "de", "ga", "gui", "d", "pc", "cc", "dir", "dp", "mc", "sc", "die", "da", "jc", "ds", "df", "conn", "bc", "cu", "exec", "input", "ec", "ca", "DC", "doc", "c", "du", "ct", "fd", "cf", "lc", "design", "fc", "dt", "ac", "vc", "desc", "cdn", "cm", "diff", "cd", "tc"], "t0": ["T2", "Tfe", " t4", "te50", " t80", "te1", "T0", "tfe", "t4", "tt50", " t1", "T1", "te0", "t3", "T50", "t80", "T3", "tt1", "p4", "t2", "T80", "tt0", "tt2", "p1", " t50", "t1", "it1", "p0", "T4", "te2", " t2", "itfe", "tt3", " t3", "tt80", "it0", " tfe", "t50"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_trap (DisasContext *ctx, uint32_t opc,\n\n                      int rs, int rt, int16_t imm)\n\n{\n\n    int cond;\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    cond = 0;\n\n    /* Load needed operands */\n\n    switch (opc) {\n\n    case OPC_TEQ:\n\n    case OPC_TGE:\n\n    case OPC_TGEU:\n\n    case OPC_TLT:\n\n    case OPC_TLTU:\n\n    case OPC_TNE:\n\n        /* Compare two registers */\n\n        if (rs != rt) {\n\n            gen_load_gpr(t0, rs);\n\n            gen_load_gpr(t1, rt);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    case OPC_TEQI:\n\n    case OPC_TGEI:\n\n    case OPC_TGEIU:\n\n    case OPC_TLTI:\n\n    case OPC_TLTIU:\n\n    case OPC_TNEI:\n\n        /* Compare register to immediate */\n\n        if (rs != 0 || imm != 0) {\n\n            gen_load_gpr(t0, rs);\n\n            tcg_gen_movi_tl(t1, (int32_t)imm);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    }\n\n    if (cond == 0) {\n\n        switch (opc) {\n\n        case OPC_TEQ:   /* rs == rs */\n\n        case OPC_TEQI:  /* r0 == 0  */\n\n        case OPC_TGE:   /* rs >= rs */\n\n        case OPC_TGEI:  /* r0 >= 0  */\n\n        case OPC_TGEU:  /* rs >= rs unsigned */\n\n        case OPC_TGEIU: /* r0 >= 0  unsigned */\n\n            /* Always trap */\n\n            generate_exception(ctx, EXCP_TRAP);\n\n            break;\n\n        case OPC_TLT:   /* rs < rs           */\n\n        case OPC_TLTI:  /* r0 < 0            */\n\n        case OPC_TLTU:  /* rs < rs unsigned  */\n\n        case OPC_TLTIU: /* r0 < 0  unsigned  */\n\n        case OPC_TNE:   /* rs != rs          */\n\n        case OPC_TNEI:  /* r0 != 0           */\n\n            /* Never trap: treat as NOP. */\n\n            break;\n\n        }\n\n    } else {\n\n        int l1 = gen_new_label();\n\n\n\n        switch (opc) {\n\n        case OPC_TEQ:\n\n        case OPC_TEQI:\n\n            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);\n\n            break;\n\n        case OPC_TGE:\n\n        case OPC_TGEI:\n\n            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);\n\n            break;\n\n        case OPC_TGEU:\n\n        case OPC_TGEIU:\n\n            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);\n\n            break;\n\n        case OPC_TLT:\n\n        case OPC_TLTI:\n\n            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);\n\n            break;\n\n        case OPC_TLTU:\n\n        case OPC_TLTIU:\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n            break;\n\n        case OPC_TNE:\n\n        case OPC_TNEI:\n\n            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);\n\n            break;\n\n        }\n\n        generate_exception(ctx, EXCP_TRAP);\n\n        gen_set_label(l1);\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 4924, "substitutes": {"ctx": ["cmp", "anc", " c", "config", "rc", "cca", "loc", "buf", "tx", "conv", "obj", "sci", "cc", "ck", "sc", "cam", "conn", "bc", "cb", "fp", "Context", "jp", "cu", "context", " context", "ca", "kb", "utils", "c", "ct", "cf", "cv", " cx", "cas", "grad", "ctrl", "pkg", "tc"], "opc": ["opercu", "optC", "iopcu", "oopc", "optcu", "iopc", "operci", "optct", "optf", "oopf", "OPci", "operC", "optc", " opC", "optenc", "copenc", "optcs", "iopC", "opC", "OPc", "opcs", "operct", "opct", "copc", "operc", "oopenc", "opci", "openc", "opercs", "ropc", "copC", "OPC", "oopC", "ropC", "copf", " opcs", "ropcu", "ropci", "opcu", " opct", "OPcu", "opf"], "rs": ["dr", "rw", "vr", "ris", "sr", "rates", "pr", "rr", "ins", "spec", "sw", "rb", "RC", "tr", "rc", "rd", "rm", "xs", "ns", "pps", "ra", "sl", "ls", "mods", "res", "cs", "Rs", "ras", "hs", "vs", "rss", "ars", "rg", "rpm", "ds", "rx", "lr", "rl", "ubs", "eps", "mr", "ims", "src", "RS", "r", "kr", "ps"], "rt": ["irt", "dr", "vr", "cr", "sr", "irm", "rr", "alt", "nt", "rb", "tmp", "rot", "lt", "tr", "rc", "rd", "ri", "rf", "igr", "pt", "rm", "m", "attr", "ru", "ls", "ras", "mt", "rss", "RT", "tm", "rx", " rm", "rin", "ptr", "mr", "rat", "ort", "rit", "rob", "r", "rec"], "imm": ["irt", "imp", "serv", "irm", "gm", "mem", "iter", "alt", "vm", "mitt", "imi", "tmp", "lt", "elt", "bm", "igr", "m", "rm", "pt", "lig", "pm", "attr", "sl", "mods", "mun", "em", "km", "mt", "mit", "sim", "inst", "Imm", "nat", "tm", "amm", "mi", "fm", "asm", "iv", "im", "mm", "ym", "ims", "il", "adr", "ort", "lim", "cm", "dim", "orm"], "cond": ["condition", "cmp", "red", "code", "sec", "box", "count", "nt", "pre", "x", "val", "rupt", "fact", "comp", "co", "pt", "unit", "loc", "call", "reason", "crit", "len", "cont", "col", "xc", "con", "Cond", "mit", "part", "cell", "day", "bound", "cmd", "lay", "bc", "lock", "fail", "pos", "ind", "c", "ct", "fd", "lc", "resp", "bool", "thread", "success", "no", "lim"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPSR\\n\");\n\n        return 0;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPCR\\n\");\n\n        return 0;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4961, "substitutes": {"opaque": ["opacle", "opque", "OPque", "ophole", "obaque", " opque", "cophole", "OPaque", " ophole", "OPacle", "obque", " opacle", "OPaques", "obhole", "opaques", "copacle", "copaque", "OPhole", "copque", "obaques", " opaques"], "offset": ["base", "address", "o", "position", "padding", "reset", "id", "count", "entry", "skip", "object", "op", "i", "et", "token", "alias", "Offset", "info", "loc", "num", "f", "order", "url", "limit", "length", "enabled", "align", "from", "initial", "part", "len", "e", "error", "online", "number", "pad", "fp", "prefix", "p", "end", "array", "operation", "pos", "pointer", "start", "off", "range", "location", "type", "node", "element", "ref", "index", "addr", "set", "account", "reference", "mode", "shift", "slot"], "size": ["address", "SIZE", "count", "fee", "data", "format", "length", " length", "small", "Size", "from", "align", "args", "len", "bytes", "timeout", "scale", "start", "pos", "type", "desc", "ize", "set"], "s": [" comments", "ing", "ches", "S", "a", "b", "irs", "i", "ients", "f", "parts", "d", "service", "w", "self", "g", "sym", "ands", "y", " changes", " entries", "sets", "ers", "sites", "is", "ments", "spec", "rows", "services", "its", "states", "server", "ls", "ops", "eds", "ds", "ts", "outs", "south", "settings", "new", "sq", "your", "lines", "ores", "rs", "er", "ins", "ows", "sg", "als", "comments", "sync", "ses", "ions", "ports", "cs", "u", "e", "sb", "ks", "secondary", "qs", "t", "erences", "ings", "p", "ians", "ies", "c", "os", "ssl", "ims", "ed", "r", "ps", " signals", "o", "v", "session", "si", "sys", "m", "in", "ips", "sts", "l", "ists", "ns", "ries", "stats", "us", "ss", "gs", "n", "su", "izes", " services", "es"], "ret": ["flag", "reg", "mem", "alt", "nt", "pat", "get", "val", "data", "final", "bit", "info", "reply", " RET", "num", "fin", "lit", "job", " Ret", "f", "res", "match", "def", "len", "det", "out", "RET", "leg", "feat", "str", "rev", "result", "seq", "Ret", "ft", "re", "fun", "back", "g", "resp", "gt", "success", "ref", "fi", "rep", "desc", "r", "rets"], "bank": ["lang", "flow", "band", "Bank", "b", "token", "bm", "sk", "f", "service", "byte", "buffer", "kind", "error", "banks", "scan", "file", "bot", "hop", "company", "page", "user", "query", "ku", "rec", "mode", "plugin", "base", "name", "row", "domain", "id", "count", "ANK", "nt", "module", "book", "grade", "comment", "lib", "field", "work", "batch", "rule", "range", "type", "model", "ban", "ank", "account", "group", "command", "library", "feature", "feed", "bin", "block", "change", "pa", "device", "op", "cat", "key", "cell", "division", "k", "year", "p", "school", "core", "board", "cache", "app", "prefix", "machine", "gp", "ch", "anc", "scope", "session", "bug", "com", "alias", "cy", "brand", "tag", "resource", "project", "child", "order", "length", "result", "root", "plan", "rank"]}}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;", "idx": 4995, "substitutes": {"s": ["sf", "S", "a", "features", "b", "data", "i", "f", "parts", "rame", "service", "conf", "sports", "self", "g", "sym", "sets", "is", "spec", "services", "sl", "ls", "ops", "bis", "ds", "ctx", "ts", "sv", "fs", "sq", "ms", "site", "rs", "cpp", "as", "ins", "sync", "ses", "cs", "u", "e", "sb", "qs", "t", "p", "css", "c", "os", "ssl", "frames", "r", "src", "ps", "screen", "session", "si", "sys", "m", "in", "l", "ns", "us", "ss", "gs", "se", "n", "context", "this", "es", "js"], "frame": ["game", "scene", "flow", "fr", "v", "session", "b", "iframe", "m", "image", "Frame", " Frame", "window", "f", "state", "j", "series", "document", "e", "w", "fram", "ctx", "p", "c", "video", "frames", "view"], "y": [" x", "yy", "dy", "o", "yd", "zy", "v", "sy", "Y", "yo", "ny", "x", "iy", "b", "i", "cy", "sky", "m", "yn", "ya", "yu", "ty", "xy", "yi", "f", "j", "my", "py", "ry", "e", "ay", "w", "oy", "t", "n", "vy", "ey", "year", "p", "ye", "ky", "z", "gy", "hy", "c", "ys", "yr", "type", "ym", "isy"], "P": ["H", "D", "IP", "LP", "CP", "XP", "HP", "W", "S", "I", "PA", "Y", "V", "ARP", "C", "NP", "API", "PIN", "AP", "Port", "N", "MP", "PO", "Part", "Point", "Path", "DP", "PS", "E", "J", "L", "Q", "RP", "Ps", "A", "JP", "BP", "p", "FF", "R", "OP", "TP", "FP", "X", "VP", "PF", "T", "PP", "GP", "F"]}}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 5035, "substitutes": {"opaque": ["opatile", "oaaques", "ospaque", "openaques", "ospatile", " opifice", "oaaque", "openaque", "openatile", "oaacity", "ospifice", "opifice", " opacity", " opatile", "opaques", "copaques", "ospaques", "copaque", "opacity", "openifice", " opaques", "copacity"], "new_rate": [" new_rated", "new_limit", " new_limit", " new_range", "newWrates", " new_rates", "new_rates", "new_range", "newWlimit", "new_rated", "newWrated", "newWrate"], "s": ["o", "sets", "sf", "rates", "sec", "ins", "S", "ments", "spec", "sg", "scope", "ows", "als", "si", "sync", "sys", "ses", "services", "m", "ips", "states", "f", "ns", "sl", "ls", "ss", "cs", "hs", "e", "submit", "sb", "gs", "se", "ops", "secondary", "ks", "ds", "storage", "n", "qs", "ts", "su", "p", "south", "settings", "fs", "sa", "c", "os", "ssl", "sq", "sym", "ms", "es", "rs", "ps"]}}
{"project": "FFmpeg", "commit_id": "aefdb735c3df9480c1ca9bcf4a3835bd66271bd1", "target": 0, "func": "static void reverse_matrixing(float *su1, float *su2, int *prev_code,\n\n                              int *curr_code)\n\n{\n\n    int i, nsample, band;\n\n    float mc1_l, mc1_r, mc2_l, mc2_r;\n\n\n\n    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {\n\n        int s1 = prev_code[i];\n\n        int s2 = curr_code[i];\n\n        nsample = 0;\n\n\n\n        if (s1 != s2) {\n\n            /* Selector value changed, interpolation needed. */\n\n            mc1_l = matrix_coeffs[s1 * 2    ];\n\n            mc1_r = matrix_coeffs[s1 * 2 + 1];\n\n            mc2_l = matrix_coeffs[s2 * 2    ];\n\n            mc2_r = matrix_coeffs[s2 * 2 + 1];\n\n\n\n            /* Interpolation is done over the first eight samples. */\n\n            for (; nsample < 8; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +\n\n                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);\n\n                su1[band + nsample] = c2;\n\n                su2[band + nsample] = c1 * 2.0 - c2;\n\n            }\n\n        }\n\n\n\n        /* Apply the matrix without interpolation. */\n\n        switch (s2) {\n\n        case 0:     /* M/S decoding */\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] =  c2       * 2.0;\n\n                su2[band + nsample] = (c1 - c2) * 2.0;\n\n            }\n\n            break;\n\n        case 1:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = (c1 + c2) *  2.0;\n\n                su2[band + nsample] =  c2       * -2.0;\n\n            }\n\n            break;\n\n        case 2:\n\n        case 3:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = c1 + c2;\n\n                su2[band + nsample] = c1 - c2;\n\n            }\n\n            break;\n\n        default:\n\n            assert(0);\n\n        }\n\n    }\n\n}\n", "idx": 5044, "substitutes": {"su1": ["tu1", "_", "tu01", "su10", "suOne", "suitOne", "su100", "suone", "su31", "suit10", "ru11", "su7", "sem10", "sing11", "ru1", "si2", "sifirst", "su81", "g", "suit1", " su11", "se81", " su100", "seOne", "tuOne", "ru100", "gru2", "loc1", "su61", "sem1", "gru1", "u61", " sufirst", "sing1", "se1", "gru81", "loc31", "suitone", "se2", "locone", "Su61", "sefirst", "Su31", "tuone", "SuOne", " su01", "prof81", "se61", "u1", "semOne", "si1", "tu10", "u2", "semone", "prof1", "sing100", "se7", "u31", "ru7", " su31", "sufirst", "prof2", "Su7", "tu31", "ruOne", "Su2", " suone", "se31", "su01", "ru2", "Su1", "loc01", "su11"], "su2": ["sub", "Su22", "ru14", " su20", "Su36", "su3", "suit4", "se20", "su20", "sutwo", "Su62", "se3", "s2", "usc2", "sftwo", "site20", "rub", " su62", "ru22", "su22", "ru02", " su36", "su02", "Su2", "Su02", "ru152", "Su4", "s22", "stwo", "usc4", "site0", "usc3", " sutwo", "su36", "se1", "sb", "su14", "su62", "suit2", " su3", "Sutwo", "site1", "su4", "suit62", "ru36", "rutwo", "suit14", "ru0", "ru2", " su0", "site2", "Su0", "sf2", "suit152", "se2", "usctwo", "ru4", " su4", " su02", " su22", "sf152", "se0", "suittwo", "Sub", "su0", "su152", "sf14", "setwo", "se4"], "prev_code": ["pre_code", "prevliccode", "prevlicline", "prev_pair", "prevlicdiv", "prev_que", "prevliccodes", "pre_que", "pre_div", "pre_pair", "prev_div", "prev_codes", "prev_line", "pre_codes", "pre_line"], "curr_code": ["currs_code", "curr2codes", "curr_id", "curr2code", "curre_codes", "currs_codes", "curr2id", "curr2count", "curr_codes", "curre_cod", "currs_id", "curr_cod", "currs_count", "curre_code", "curr_count"], "i": ["gi", "ri", "v", "id", "I", "di", "s", "ci", "ki", "ni", "b", "x", "io", "xi", "ani", "si", "slice", "inn", "bi", "m", "in", "qi", "image", "ix", "l", "f", "pi", "phi", "d", "ii", "j", "iu", "ai", "u", "e", "ami", "uri", "k", "n", "mi", "ski", "ini", "ie", "p", "h", "eni", "oi", "ind", "ip", "c", "li", "fi", "index", "ui"], "nsample": ["nsammy", "namesample", "naslace", " nspec", "xsply", "tsample", "linsample", "ssample", "csanne", "nspec", "csamp", "outsammy", "tssample", "nasolve", " nsume", "minspling", "ansape", "bsamples", "unsamp", "xsample", "consample", " nsame", "bssample", "namesamp", "onspec", "nasplay", "sspling", "pssample", "antispling", "nspring", "minssample", "namescale", "nsume", "psame", "nspling", "namespec", "lsamp", "nassample", "namessample", "netsdim", "npling", "unscale", "NSsample", "nascale", "netssample", "insample", "linspring", "xsolve", "unsample", "nasanne", "namespace", "nscale", "linsamples", "minsample", "naspace", "nspace", "netsape", "kspring", "inspling", "nsape", " nspling", "xslace", "outsample", "anspring", "jspling", "conspling", "ensample", "nsply", "csamples", "nossample", "netsply", "nasape", "jssample", "ainsample", "nasammy", "ssamples", "anspling", "npec", "antispace", "lsplay", "ainspling", "antissample", "xsamp", "enssample", "onspler", "namespler", "naspec", "outspling", "NSpling", "jsample", "nsplay", "unssample", "ansanne", "ainssample", "cspling", "nsame", "ksamples", "namesplay", " nspler", "naspring", "xsamples", "unsolve", "nsamp", "psample", "nsamples", "nasamp", "unspring", "onspling", "tsamples", "noslace", "nsanne", "namesply", "nsolve", "NSape", "nasdim", "xspling", " nsape", "consamp", "antisample", "onsample", "nosample", "sssample", "naspling", "naspler", "onssample", "namesame", "conssample", "tspling", "anssample", " nsamp", " nssample", "xssample", "nssample", "nasamples", "netsample", "nosamples", "NSamples", "NSanne", "jsammy", "namespling", "ansample", "enscale", "insamp", "nample", "nospling", "nasample", "NSamp", "NSample", "outssample", "namesume", "ksample", " nsanne", "minsamples", "kssample", "nosamp", "psume", "linssample", "cssample", " nsdim", "namesamples", "enspring", "inssample", "ainsamp", " nspring", "bspling", "nspler", "bsample", "netspling", "noscale", "nsdim", "lsample", "nslace", "csample", "lssample", "anspler"], "band": ["bass", "layer", "position", "nn", "di", "xi", "force", "style", "unit", "letter", "f", "cart", "weight", "code", "connection", "pass", "nb", "mb", "stage", "output", "boot", "line", "filter", "off", "page", "label", "front", "lf", "mode", "function", "plugin", "frequency", "count", "word", "channel", "list", "slice", "art", "loop", "number", "port", "path", "field", "work", "old", "batch", "back", "range", "mm", "type", "product", "model", "group", "low", "road", "block", "Band", "bands", "device", "gap", "pp", "io", "use", "bit", "phase", "key", "song", "station", "version", "j", "net", "cell", "point", "section", "bound", "ind", "core", "board", "bind", "chrom", "v", "qi", "brand", "tag", "length", "part", "power", "day", "direction", "pair"], "mc1_l": ["mc2_b", "mc1Logp", "mc1_e", "mc1shdl", "mc1_lp", "mc1_rl", "mc1nonl", "mc2_ol", "mc1shrl", "mc15_l", "mc1nondl", "mc1_b", "mc1_p", "mc15_rl", "mc15_dl", "mc1Logl", "mc1shlp", "mc1__e", "mc2_p", "mc1__b", "mc1Logb", "mc1Logol", "mc1_dl", "mc1nonlp", "mc1__l", "mc15_lp", "mc1shl", "mc1_ol", "mc2_e", "mc1__r", "mc1nonrl"], "mc1_r": ["mc4__r", "mc2_b", "mc1__p", "mcl_mr", "mc12r", "mc4__p", "mc1__mr", "mc4__l", "mc1__r", "mc12b", "mc12ur", "mc4_l", "mcl_l", "mcl_r", "mc4_b", "mc2_rt", "mc1_b", "mc1_p", "mc4__b", "mc2_ur", "mc1__b", "mcl_b", "mc1_rt", "mc1_ur", "mc1__l", "mc1_mr", "mc4_p", "mc4_r", "mc12rt"], "mc2_l": ["mc2_s", "mc2_b", "mc22_r", "mc2__v", "mc2_le", "mc2__la", "mc0__s", "mc0_s", "mc0__l", "mc0__e", "mc22_b", "mc2__b", "mc2_la", "mcb_l", "mc2__r", "mc2_v", "mc0_e", "mc0_v", "mc0__v", "mcb_rl", "mc0_l", "mcb_nl", "mc22_la", "mc2_nl", "mc2__l", "mc22_l", "mc2__s", "mc2__e", "mcb_le", "mc2_e", "mc2_rl"], "mc2_r": ["mc2_b", "mc2_R", "mc0_sr", "mc2_rs", "mc4_v", "mc0_r", "mc4_b", "mc0_u", "mc0_rs", "mc2_rb", "mc2_v", "mc2_u", "mc2_rr", "mc2_sr", "mc4_rb", "mc4_r"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_reset(DeviceState *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n\n    uint64_t nb_sectors;\n\n\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    if (nb_sectors) {\n\n        nb_sectors--;\n\n    }\n\n    s->qdev.max_lba = nb_sectors;\n\n    /* reset tray statuses */\n\n    s->tray_locked = 0;\n\n    s->tray_open = 0;\n\n}\n", "idx": 5054, "substitutes": {"dev": ["ch", "hw", "dm", "block", "md", "dn", "di", "Dev", "dd", "device", "data", "info", "dem", "der", "de", "state", "ve", "d", "conf", "ev", "dom", "DEV", " Dev", "sh", "priv", "w", "prom", "def", "ds", " device", "err", "req", "development", "ver", "dt", "app", "grad", "conn", "diff"], "s": ["o", "sets", "sf", "is", "S", "spec", "sg", "session", "b", "si", "i", "sync", "sys", "ses", "m", "services", "its", "l", "side", "f", "ns", "d", "sl", "ls", "service", "cs", "ss", "conf", "e", "an", "sh", "sb", "gs", "ks", "uns", "ds", "qs", "n", "t", "ts", "su", "p", "south", "settings", "sv", "fs", "c", "os", "g", "ssl", "sq", "sym", "params", "es", "rs", "ps", "js"], "nb_sectors": ["nb_psecs", "nb_veors", "nb_vectors", "nb_pevers", "nb_psections", "nb_sexivers", "nb_secors", "nb_secsections", "nb_gectors", "nb_sescers", "nb_seqs", "nb_subgments", "nb_pseapters", "nb_seapters", "nb_apegments", "nb_geapters", "nb_nevers", "nb_sesections", "nb_segment", "nb_secapters", "nb_seccers", "nb_sygments", "nb_secivers", "nb_secs", "nb_subctors", "nb_vegments", "nb_vections", "nb_seivers", "nb_subcers", "nb_segments", "nb_sesctors", "nb_psegments", "nb_serctors", "nb_gegment", "nb_psevers", "nb_pectors", "nb_sexctors", "nb_sesgments", "nb_syors", "nb_servers", "nb_secctors", "nb_gegments", "nb_negments", "nb_secctions", "nb_sections", "nb_pegments", "nb_sessections", "nb_secvers", "nb_severs", "nb_apectors", "nb_secgments", "nb_sergments", "nb_secqs", "nb_vegment", "nb_apegment", "nb_sexgments", "nb_subsections", "nb_secers", "nb_apections", "nb_syctors", "nb_seors", "nb_syqs", "nb_pecs", "nb_sexvers", "nb_psectors", "nb_serivers", "nb_veqs", "nb_necs", "nb_nectors", "nb_gections"]}}
{"project": "FFmpeg", "commit_id": "eedd9148733ff4467c62092ad1c1a26d6125b249", "target": 1, "func": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n\n                               int *len, int *strid, int read_packet) {\n\n    AVIOContext *pb = s->pb;\n\n    PVAContext *pvactx = s->priv_data;\n\n    int syncword, streamid, reserved, flags, length, pts_flag;\n\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n\n    int ret;\n\n\n\nrecover:\n\n    startpos = avio_tell(pb);\n\n\n\n    syncword = avio_rb16(pb);\n\n    streamid = avio_r8(pb);\n\n    avio_r8(pb);               /* counter not used */\n\n    reserved = avio_r8(pb);\n\n    flags    = avio_r8(pb);\n\n    length   = avio_rb16(pb);\n\n\n\n    pts_flag = flags & 0x10;\n\n\n\n    if (syncword != PVA_MAGIC) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (reserved != 0x55) {\n\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n\n    }\n\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n\n        pva_pts = avio_rb32(pb);\n\n        length -= 4;\n\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n\n        /* PVA Audio Packets either start with a signaled PES packet or\n\n         * are a continuation of the previous PES packet. New PES packets\n\n         * always start at the beginning of a PVA Packet, never somewhere in\n\n         * the middle. */\n\n        if (!pvactx->continue_pes) {\n\n            int pes_signal, pes_header_data_length, pes_packet_length,\n\n                pes_flags;\n\n            unsigned char pes_header_data[256];\n\n\n\n            pes_signal             = avio_rb24(pb);\n\n            avio_r8(pb);\n\n            pes_packet_length      = avio_rb16(pb);\n\n            pes_flags              = avio_rb16(pb);\n\n            pes_header_data_length = avio_r8(pb);\n\n\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n\n                                          \"trying to recover\\n\");\n\n                avio_skip(pb, length - 9);\n\n                if (!read_packet)\n\n                    return AVERROR(EIO);\n\n                goto recover;\n\n            }\n\n\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n\n            if (ret != pes_header_data_length)\n\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n\n            length -= 9 + pes_header_data_length;\n\n\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n\n\n            pvactx->continue_pes = pes_packet_length;\n\n\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20)\n\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n\n        }\n\n\n\n        pvactx->continue_pes -= length;\n\n\n\n        if (pvactx->continue_pes < 0) {\n\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n\n            pvactx->continue_pes = 0;\n\n        }\n\n    }\n\n\n\n    if (pva_pts != AV_NOPTS_VALUE)\n\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n\n\n    *pts   = pva_pts;\n\n    *len   = length;\n\n    *strid = streamid;\n\n    return 0;\n\n}\n", "idx": 5060, "substitutes": {"s": ["stat", "login", "sf", "v", "is", "S", "http", "spec", "sg", "plugins", "session", "single", "comments", "b", "si", "sys", "ses", "services", "m", "support", "private", "f", "client", "ns", "server", "ls", "stats", "service", "sci", "cs", "ss", "us", "conf", "e", "sc", "sie", "sb", "gs", "parser", "submit", "sim", "bis", "ds", "t", "se", "secondary", "storage", "ts", "su", "self", "p", "south", "sv", "request", "sa", "c", "g", "ssl", "sq", "sym", "secure", "core", "site", "es", "rs", "sup", "manager", "an", "js"], "pts": ["iptns", "ctns", "iptsets", "streams", "ctsets", "streaml", "ptl", "iptl", "ptns", "ptsets", "cts", "ctl", "streamsets", "ipts", "streamns"], "len": ["lang", "ann", "el", "pre", "lan", "val", "enc", "ll", "buf", "l", "fin", "fl", "limit", "split", "en", "fn", "lib", "lon", "lock", "rev", "pos", "gen", "ln", "Len", "lin", "bl", "lf", "lim"], "strid": ["collId", "strids", "encids", "streamids", "streamID", "streamId", "collids", "collID", "strID", "strId", "encID", "encid", "collid", "encId"], "read_packet": ["read_framume", "read_packacket", "read_octacket", "read_packume", "read_framete", "read_signete", "read_octume", "read_packete", "read_framet", "read_signume", "read_framacket", "read_octet", "read_octete", "read_signet", "read_signacket"], "pb": ["verb", "cp", "plugin", "login", "bp", "lb", "hub", "platform", "pa", "plugins", "rb", "plug", "pd", "b", "bps", "typ", "bm", "lp", "uc", "fb", "db", "wb", "uf", "pm", "pg", "mp", "prot", "phrase", "pc", "bs", "xb", "bb", "eb", "dp", "sb", "parser", "rpm", "ctx", "bc", "PB", "fp", "jp", "cb", "phys", "p", "mb", "summary", "vp", "prop", "gb", "primary", "ppa", "ub", "bf", "api", "um", "tp", "fc", "cv", "pl", "ref", "rob", "cpp", "bh", "pkg", "tc"], "pvactx": ["pvectxc", "pVactex", "pvACTx", "pvACTex", "pvectxt", "pvarty", "pvacy", "pvcactxt", "pvcortx", "pvcactxc", "pvortc", "pVACTex", "pvcactx", "pvACTy", "pVactx", "pvartex", "pvACTxt", "pvcortxt", "pVACTx", "pvacx", "pvectc", "pvcactc", "pVACTy", "pvactc", "pvacty", "pvactxt", "pvartxt", "pvectx", "pvortx", "pVactxt", "pvcortxc", "pvACTc", "pvcortc", "pvACTxc", "pVacty", "pvacxt", "pVACTxt", "pvartx", "pvacex", "pvortxt", "pvortxc", "pvactxc", "pvactex"], "syncword": ["yncbyte", "syntag", "syncletter", "readwords", "synctag", "synbyte", "Syncwords", "synWord", " syncbyte", " syncletter", "yncword", "syncbyte", "Syncword", "yncletter", " synctag", " syncwords", "synwords", "SyncWord", "ynctag", "syncwords", "yncwords", "Synctag", "synword", "readbyte", "readWord", "Syncletter", "readword", "syncWord", "Syncbyte"], "streamid": [" streams", "modelend", "Streamname", "objectid", "streamids", "streamide", "contextid", "contextID", " streamend", "reams", "modelId", "streamend", "Streamid", "threadID", "streamident", "threadid", "modelid", "channelId", "threadide", "channelip", "channelID", "streamip", "StreamID", "channelid", "objectId", "poolident", "threadname", "poolId", " streamID", "modelID", "poolname", " streamId", "streams", " streamids", "modelip", "threadId", "streamID", "streamId", "reamident", "poolid", "StreamId", "modelname", " streamide", "channelide", "channelend", "Streamids", "threadident", " streamident", "contextident", " streamname", "reamID", "contexts", "streamname", "objectname", "objectids", "reamid", " streamip"], "reserved": ["Reserves", "Resigned", "reserv", "unserve", " reserv", " reserve", "preserved", "unserved", "Reserving", "resigned", "reservation", "preserv", "presigned", "rserve", " reserving", "unserv", "Reservation", "preservation", "rservation", "pserving", "rserved", "reserving", "rsigned", "preserving", "pserves", "pserved", "reserves", "unserving", " reserves", "reserve", "pserve", "preserve", "Reserve", "Reserved"], "flags": ["levels", "types", "options", "strings", "nl", "files", "flag", "rules", "count", "bits", "alls", "features", "Flags", "ags", "words", "atts", "tags", "mask", "status", "ips", "details", "lag", "vals", "links", "planes", "ants", "codes", "parts", "stats", "args", "ints", "fields", "relations", "ops", "locks", "bytes", "filename", "fps", "settings", "fs", "utils", "errors", "items", "ids", "lines", "lf", "reads", "lists"], "length": ["options", "build", "time", "padding", "position", "block", "id", "pull", "count", "total", "shape", "value", "style", "slice", "Length", "rows", "th", "sequence", "l", "key", "capacity", "offset", "url", "limit", "weight", "maximum", "sl", "ph", "duration", "delay", "number", "buffer", "sh", "mount", "depth", "angle", "L", "zip", "full", "section", "always", "path", "other", "load", "lock", "end", "quality", "h", "cost", "level", "range", "type", "ength", "partial", "library", "size"], "pts_flag": ["pts_flags", "pts_len", "ptsets_flag", "ptsets_log", "pts_field", "ptsets_len", "pts2len", "pts2count", "ptsets_count", "ptsets_flags", "pts_log", "ptn_field", "ptn_count", "pts_count", "pts_fun", "ptn_flags", "ptsets_fun", "pts2flag", "ptn_flag"], "startpos": ["endval", "endpos", "Startposition", "stopPos", "stoppos", " startval", "Startval", "startposition", "Startpos", " startPos", " startposition", "endloc", "startval", "startloc", "stopval", "endposition", "stoploc", " startloc", "endPos", "startPos", "StartPos"], "ret": ["reset", "reg", "flag", "sec", "alt", "nt", "val", "rc", "rel", "valid", " RET", "res", "def", "scan", "RET", "result", "seq", "batch", "Ret", "re", "back", "resp", "success", "rep", "rs", "rets"], "pes_signal": ["pes_signaler", "pes_SIGNature", "pes_ignal", "pes_Signature", "pes_codon", "pes_codal", "pes_seal", "pes_Signal", "pes_signon", "pes_seals", "pes_SIGNaler", "pes_seon", "pes_Signaler", "pes_signaling", "pes_codaler", "pes_signature", "pes_ignature", "pes_sealer", "pes_signals", "pes_Signaling", "pes_ignaling", "pes_SIGNaling", "pes_codals", "pes_ignaler", "pes_ignon", "pes_ignals", "pes_SIGNal"], "pes_header_data_length": ["pes_header_data_len", "pes_header_header_type", "pes_header_header_length", "pes_header_data_width", "pes_header_header_width", "pes_header_data_type", "pes_header_header_len"], "pes_packet_length": ["pes_packacket_1", "pes_packacket_len", "pes_packacket_sequence", "pes_packet__width", "pes_packet__sequence", "pes_packet_1", "pes_packet_width", "pes_packacket_\n", "pes_packet_\n", "pes_packet__length", "pes_packacket_length", "pes_packet__len", "pes_packet_len", "pes_packacket_width", "pes_packet_sequence"], "pes_flags": ["pes___flag", "pes_comments", "pes___flags", "pe_comments", "pe_flag", "pes_data", "pes___comments", "pe_data", "pes_flag", "pe_flags", "pes___data"], "pes_header_data": ["pes_header_size", "pes_header__message", "pes_header__size", "pes_header_message", "pes_headers_size", "pes_header__data", "pes_headers_message", "pes_headers_data"]}}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n", "idx": 5071, "substitutes": {"src": ["sub", "chrom", "sr", "sec", "cur", "spec", "rb", "config", "b", "rc", "data", "stack", "slice", "stream", "dest", "comp", "sync", "loc", "uc", "buf", "attr", "conv", "url", "sl", "length", "gz", "sci", "stars", "dist", "low", "sc", "uri", "sb", "rect", "inst", "cb", "source", "input", "req", "ptr", "gb", "start", "sup", "iv", "sel", "ssl", "scl", "front", "rob", "img", "seed", "shift", "size"], "stride": ["Striden", "strine", "Strider", "STRider", " strider", " strside", "slided", "hrside", "STRide", "charride", "strided", "charided", "hrided", "STRside", "STRride", "shride", "Strade", " strided", "charice", "shrice", "sliden", "stiden", "charide", "strride", "strside", "Strine", "Strice", "strice", "slide", "Strride", "slade", "charider", "charine", "hride", "Strided", "shrided", "stided", "shrine", "stide", "stade", "striden", "strider", "strade", "STRided", "hrider", "Stride"], "i": ["gi", "ti", "v", "id", "I", "chi", "di", "ci", "ji", "ni", "b", "x", "si", "xi", "io", "ri", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "phi", "d", "iu", "ii", "j", "it", "ai", "init", "u", "e", "uri", "k", "multi", "mi", "ini", "ie", "p", "h", "mini", "eni", "start", "strength", "oi", "hi", "ip", "api", "li", "fi", "index", "r", "zi", "mu", "ui"], "dc0": ["cx", "DC8", "lc5", "c2", " dcx", "c1", "DCarg", "c0", "DC5", "mc8", "rc5", "rc0", "DCx", "dc5", "dcx", "lc50", "nc0", "rc00", "DC19", "DC0", "nc19", "fc5", "dc8", "nc2", "fc8", "dc1", " dc1", "dc2", "DC1", "carg", " dcarg", "fc19", "dc50", "fc50", "ac00", "lc0", "dcarg", "lc8", "rc2", "mc5", "DC00", "nc00", "ac0", "mc50", "fc2", " dc2", "ac2", "fc0", "DC2", "fc00", "rc8", "mc0", "dc00", "dc19"]}}
{"project": "qemu", "commit_id": "955cc8c9541779e09895a9c5ccbf8ace15d884f5", "target": 0, "func": "static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n", "idx": 5093, "substitutes": {"sch": ["cp", "osc", "ocr", "ch", "cr", "spec", "wic", "sw", "shr", "sche", "or", "inch", "ich", "rh", "sk", "kh", "soc", "sl", "service", "ss", "conf", "sc", "sh", "sb", "se", "cho", "dev", "sd", "chid", "cer", "cor", "shop", "chn", "gb", "gor", "sp", "gh", "cht", "cm", "Sch"], "addr": ["address", "aid", "name", "afi", "act", "padding", "arm", "ag", "rt", "id", "alpha", "alt", "config", "balance", "x", "data", "oa", "alias", "ad", "art", "loc", "ace", "route", "ix", "tx", "lace", "offset", "mac", "url", "adder", "nr", "ack", "grad", "len", "size", "ar", "arr", "pad", "coord", "hop", "bridge", "array", "amp", "ptr", "aff", "pos", "node", "ip", "amd", "adr", "ac", "ref", "host", "ast", "dim", "prefix"], "align": ["address", "cmp", "afi", "el", "al", "config", "balance", "rot", "val", "ax", "alias", "rel", "adjust", "ad", "aligned", "loc", "lag", "lace", "offset", "lead", "length", "len", "angle", "arr", "rol", "coord", "pal", "array", "gal", "ign", "aff", "ange", "range", "label", "ref", "cache", "role"], "index": ["find", "address", "gate", "axis", "position", "diff", "id", "show", "sort", "value", "config", "update", "val", "x", "i", "slice", "info", "in", "loc", "image", "route", "ix", "inc", "ion", "offset", "order", "version", "weight", "length", "xxxx", "loop", "match", "active", "number", "len", "action", "size", "example", "path", "coord", "ini", "hop", "work", "array", "input", "xxx", "pos", "fix", "level", "pointer", "ind", "start", "off", "none", "Index", "cache", "host", "dim", "end", "prefix"], "num": ["uni", "position", "bin", "id", "alt", "nn", "config", "ni", "update", "sum", "inn", "loc", "unit", "valid", "inc", "offset", "mon", "nm", "init", "net", "number", "len", "out", "Num", "n", "nom", "NUM", "coord", "nb", "nam", "node", "off", "um", "ref", "no", "min", "max", "dim", "end", "prefix"], "vdev": ["ivdev", " vdata", "svconn", "livedem", "vtdiv", "rdev", "vcdist", " vdes", "ivdem", " verror", "nvrad", "vserv", "vdist", "vdiv", "lvar", "vconn", "evdef", "evfam", "nvserv", "vdes", "vdie", "rconn", "ivdef", " vinfo", "ivdie", " vdem", " vdist", " vdb", " vdef", "nvdata", " vrad", "verror", "vrad", "liverad", "svdem", "ivconf", "nvdev", "vconf", "rvar", "vDev", "vvserv", "svdev", " vDev", "svde", "vvdata", "svdb", "nverror", "vmdist", " vserv", "ivfam", " vvar", " vdiv", "vcinfo", "vfam", "vdef", "vvdev", "vverror", "nvdem", "ldev", "evconf", "vminfo", "livedev", "vinfo", "vde", "vcdev", "vcrad", "vtdev", "vmdev", "vmrad", "svdie", "nvdes", "ivdb", "rde", "vtDev", "vdata", " vde", " vdie", "vtvar", "livedes", "evdev", "lDev", " vconn", "vdb", " vfam", " vconf", "svvar", "vdem", "vvar"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n", "idx": 5099, "substitutes": {"opaque": ["catec", "opque", "compaque", "popacity", "catity", "operoster", "oposter", "oppaque", "operaque", "popaque", "oppec", "cataque", "poposter", "openaque", "opec", "composter", "oppity", "operace", "opity", "popace", "openity", "operacity", "compace", "openque", "catque", "opace", "opacity", "oppque", "openec", "compacity"], "buf": ["buff", "vec", "v", "cur", "rb", "b", "data", "rc", "queue", "loc", "window", "null", "uf", "length", "buffer", "bag", "Buffer", "port", "cmd", "bc", "cb", "fp", "seq", "pool", "batch", "ptr", "alloc", "cap", "fd", "cv", "pb", "src", "img", "msg"], "size": ["address", "name", "time", "SIZE", "large", "block", "sec", "fee", "shape", "send", "data", "rc", "enc", "unit", "null", "capacity", "offset", "length", "small", "Size", "six", "code", "len", "en", "esc", "sized", "empty", "timeout", "scale", "z", "c", "g", "type", "ize"]}}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n", "idx": 5102, "substitutes": {"fs_ctx": ["fsptx", "FS_cb", "fsalcb", "fs_cn", "FS_context", "ts_tx", "ws_cu", "fsdbcrit", "fsprectx", "fspcb", "fs_sem", "cs_conn", "fs__cas", "fs__cl", "fsprecn", "fs__ctx", "ts_git", "fs_scope", "fsdbctx", "fsalgit", "fs32gc", "FS_scope", "ts_gc", "cs_ca", "fs_cor", "fs_cb", "FS_ctx", "fsjctx", "cs_cor", "fs_cl", "ts_ctx", "FS_cn", "FS_la", "ws_conn", "fsaltx", "fs_crit", "fsalcontext", "fs_cu", "FS_sem", "fs_tx", "fsdbconn", "FS_cl", "fs_wcs", "fsjcl", "fs32tx", "fsprecontext", "fs_conn", "fsprewcs", "fs_la", "ws_ctx", "fsjcontext", "cs_ctx", "ws_crit", "fsalctx", "fsalgc", "fs32git", "fs_gc", "fs32ctx", "FS_wcs", "fspctx", "fs_ca", "FS_cas", "fsdbcu", "FS_tx", "fs_context", "fs_cas", "fs_git", "fs__context", "fsjcas", "fspcontext"], "fs_path": ["f_crit", "f_source", "fc_config", "fs___context", "fsscontext", "fsmlpath", "fsmlsource", "fs___crit", "fs___path", "fs_config", "fs_source", "f_context", "fs_crit", "fssobject", "fc_context", "fs_object", "f_path", "fs_context", "fsmlcrit", "fssconfig", "fsmlcontext", "fc_path", "fc_object", "fs___source", "fsspath"], "credp": ["acrdP", "credpa", "credv", "cedl", "credpart", "chedpa", " credpre", "cribP", "ancreaml", "caredP", " credpt", "cronc", "cribv", " creditsp", " creditsc", "critpre", "scredc", "crdpi", "cribpre", "cedpc", "crafpart", "credP", "encredP", "cronh", " credc", "credpi", "creampi", "cachedp", "encdefp", "carpp", "creamp", "creditspa", "acredp", "creampa", "encdefc", "caredpc", " cribp", "encredpart", "acredc", "scribh", "encredc", "credpre", "crafP", "crafc", "cachedP", "cdefP", "crcpre", "cdefc", "caredp", " cprivP", "creditspi", "crcp", "ancreamP", " cprivp", "ancreamp", "scredh", "creampc", "crafp", "scribp", "ancreampc", "creditsp", "scribc", "cprivp", "creamc", "crcpt", "cprivc", " cribpt", " creditspa", " credpi", "credpt", "cribpt", "cachedc", "ancredP", "cdefp", "credpc", "crdP", "cribh", "creamP", " credpc", "scredp", " cribv", "scredpa", "cronp", " credP", "cdefpart", "critp", "acrdpi", "cronpa", "cprivpc", "acrdc", "carpc", "cedp", "carph", " cprivc", "encdefpart", "chedpi", "cribpc", "crcv", "cprivP", "cachedpart", "credh", "caredl", "cedP", "ancredl", "credc", " credv", "critv", "credl", "acredP", "scribpa", " cprivpc", " credpa", "cribpi", "acrdp", "critpt", "cprivpi", "chedc", "acredpi", "encredp", "ancredpc", " creditspi", "cribp", "chedp", "encdefP", "cribpa", "creditsc", " cribpre", "creaml", "crdc", "ancredp", "carppa", "cribc", "crdp"], "buffer": ["writer", "base", "flow", "name", "feed", "buff", "header", "padding", "iter", "block", "count", "b", "uffer", "data", "slice", "abi", "queue", "info", "map", "buf", "null", "fb", "uf", "f", "url", "limit", "length", "byte", "len", "Buffer", " buffers", "binary", " buf", "bytes", "pad", "cb", "str", "source", "array", "batch", "reader", "transfer", "slave", "type", "cache", "reference", "loader", "seed", "size"], "path": ["name", "area", "anc", "id", "parent", "entry", "config", "object", "data", "home", "sync", "enc", "pattern", "uc", "image", "loc", "route", "th", "key", "rh", "content", "child", "url", "Path", "arc", "dir", "part", "uri", "mount", "col", "file", "binary", "port", "container", "loader", "filename", "ith", "source", "p", "temp", "root", "PATH", "ath", "pointer", "node", "txt", "location", "transform", "link", "inner", "text", "ref", "cache", "host", "end", "prefix"]}}
{"project": "qemu", "commit_id": "ff9d38963e55598b40237735426225c35de6c7e5", "target": 0, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *child, *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    child = qdict_get(dst, \"vnc\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    vnc = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(vnc, \"listen\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    listen = qobject_to_qdict(child);\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n", "idx": 5104, "substitutes": {"src": ["sub", "scene", "r", "sr", "sec", "http", "sit", "spec", "s", "gru", "rb", "config", "rc", "sync", "sn", "slice", "dest", "stream", "sys", "uc", "loc", "support", "resource", "https", "href", "url", "sl", "scripts", "gz", "dist", "grad", "sc", "rss", "sb", "uri", "inst", "rect", "lib", "ctx", "go", "cb", "ruby", "nil", "feat", "filename", "source", "rl", "req", "gl", "remote", "iv", "gb", "sup", "supp", "sel", "ssl", "sq", "secure", "desc", "ref", "rs", "rob", "img", "RC", "rec", "pkg"], "dst": ["Dst", "bsc", " dsl", "lst", "fsts", "pdstr", " ddr", "dsc", "Dsts", "lsc", "pdsts", "pdsc", "dsp", "datsts", "dsts", "Dsc", "pdst", "fsc", " dsts", " dsc", "dsl", "dstr", "bsp", " dsp", "bsts", "Dstr", "lstr", "ddr", "Dsl", "zst", "zsc", "zstr", "datst", "datsl", "ldr", "zdr", "bst", "datsc", " dstr", "fst", "fsp"], "rule": ["row", "block", "rr", "parent", "record", "route", "tag", "resource", "Rule", "attr", "url", "roll", "comment", "ule", "rx", "result", "root", "reader", "run", "re", "node", "class", "user", "rol", "r", "ride", "role"], "vnc": ["vNC", "vnt", "vpc", "pcn", " vcn", "vrn", "hnc", "hrn", "Vdc", "Vnt", "svcn", "lnc", "vcn", "vdc", "Vnd", "ldc", "lcn", "svnc", "hcn", "lne", " vdc", "pnc", " vNC", "ppc", "lpc", "lNC", " vnd", "lnd", "svnt", " vne", "prn", "Vcn", " vrn", "pnd", "hpc", "VNC", " vpc", "vne", "svnd", "Vnc", "pnt", "Vpc", "vnd", "Vne"], "acl": ["oc", "anc", "cr", "el", "acc", "ace", "cl", "attr", "ack", "sc", "ol", "arr", "fn", "lib", "ctx", "rx", "exec", "rl", "lr", "ic", "ul", "ssl", "wl", "scl", "il", "asc", "ac", "cache", "rol"], "listen": ["Listan", "listened", "nullen", "Listem", "warden", "cyclan", "Liste", "Listen", "listenum", "Listel", " lister", "listem", " listening", " listener", "warde", "Listening", "diffening", " listened", "cardem", "diffened", "warder", "wardel", "carder", "ler", "listening", "liste", "listan", "listel", "len", "lel", "diffen", "nullan", "lister", " listem", "Listened", "nullening", "listener", "cyclen", "carden", "nullenum", "cyclening", "cyclenum", "Listener", "cardener", "Lister", "Listenum", " listenum", "diffenum", "le"], "child": ["local", "entry", "anch", "ow", "children", "plus", "create", "boy", "code", "col", "kid", "Child", "brother", "sel", "current", "rec", "row", "build", "friend", "id", "cur", "count", "parent", "value", "xml", "content", "leaf", "server", "daughter", "comment", "path", "win", "work", "protected", "remote", "new", "cow", "end", "baby", "feed", "block", "rc", "key", "cl", "cell", "ck", "section", "oy", "global", "cache", "r", "seed", "cel", "sub", "ch", "pull", "session", "ell", "che", "ray", "resource", "rest", "client", "ack", "q", "result", "root", "this", "iv", "request", "gh", "slave", "ew", "inner"], "res": ["gr", "ris", "ret", "reg", "rr", "ress", "pre", "Res", "ros", "rel", "sys", "details", "repl", "resource", "results", "rh", "rest", "cs", "Rs", "ras", "ry", "resolution", "des", "rss", "rez", "error", "rus", "rx", "err", "response", "rev", "result", "pres", "root", "resh", "reader", "remote", "re", "RES", "R", "request", "os", "resources", "resp", "ps", "ref", "cache", "rs", "RS", "r", "rem", "rar", "js"], "rules": ["groups", "Rules", "files", "runs", "plugins", "comments", "rows", "names", "vals", "results", "rights", "args", "scripts", "stars", "ops", "tests", "rx", "lr", "settings", "blocks", "reader", "errors", "resources", "items", "params", "rs", "ras"]}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 5121, "substitutes": {"data": ["writer", "base", "a", "parent", "done", "dat", "config", "ada", "format", "database", "ad", "m", "valid", "f", "media", "d", "DATA", "buffer", "iterator", "parser", "da", "Data", "empty", "self", "result", "p", "input", "temp", "array", "this", "reader", "xxx", "start", "txt", "video", "api", "text", "cache", "test"], "unused": ["Unusable", " Unchecked", "Unuse", " Unused", " Unuse", "unchecked", " unuse", "Unused", "unuse", "Unchecked", " Unusable", "unusable", " unusable", " unchecked"], "tmp": ["verb", "nv", "base", "st", "copy", "vm", "rb", "vt", "b", "kk", "uv", "buf", "f", "mp", "j", "obj", "tv", "cpp", "e", "t", "cu", "result", "p", "array", "temp", "output", "this", "vp", "ptr", "c", "var", "txt", "api", "video", "tp", "vv", "cv", "vc", "pb", "test", "r", "img", "tc"], "v": ["vim", "nv", "o", "vd", "vm", "s", "V", "vt", "b", "i", "m", "uv", "l", "f", "j", "ve", "d", "obj", "tv", "u", "vi", "vs", "e", "ev", "w", "t", "k", "n", "p", "temp", "h", "vp", "sv", "iv", "c", "g", "api", "lv", "vv", "cv", "test"], "err": ["dr", "fr", "er", "cr", "iter", "rr", "aster", "bug", "i", "der", "rh", "tx", "rage", "f", "ler", "order", "acer", "ev", "e", "error", "ar", "oe", "arr", "t", "n", "str", "self", "rev", "p", "temp", "req", "z", "erer", "doc", "ver", "var", "c", "ind", "resp", "Er", "ref", "test", "rs", "fi", "r", "Error"]}}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}", "idx": 5129, "substitutes": {"bs": ["bas", "base", "as", "lb", "block", "ins", "rb", "b", "lbs", "sync", "ses", "bing", "BS", "obs", "fb", "bes", "ns", "state", "ls", "obj", "iss", "bb", "cs", "ss", "vs", "sb", "bis", "ds", "bc", "cb", "ab", "outs", "ubs", "ba", "ec", "blocks", "css", "gb", "fs", "sa", "os", "bos", "bid", "ps", "bl", "pb", "es", "src", "bh", "js"], "s": ["o", "sec", "is", "S", "spec", "sg", "b", "si", "i", "sync", "ses", "services", "f", "ns", "state", "stats", "ls", "sl", "service", "ss", "cs", "e", "sie", "sb", "gs", "bis", "ds", "t", "ts", "su", "p", "sv", "sa", "c", "os", "g", "ssl", "sq", "sym", "y", "site", "es", "ps", "js"], "ret": ["std", "fat", "flag", "reg", "reset", "rt", "mem", "al", "alt", "nt", "pat", "pre", "get", "lt", "val", "rf", "data", "et", "bit", "cat", "format", "art", "num", "fin", "f", "lit", "ext", "att", " Ret", "active", "arg", "res", "len", "mt", "code", "det", "part", "en", "arr", "error", "RET", "t", "plain", "out", "pass", "err", "rev", "result", "end", "Ret", "run", "ft", "fab", "re", "fail", "true", "fun", "ut", "bf", "ct", "gt", "success", "ref", "group", "rets", "af"]}}
{"project": "FFmpeg", "commit_id": "f7cf12b209c3a1ac2d6b797c585b593a5e9a461d", "target": 1, "func": "static int vc1_init_common(VC1Context *v)\n\n{\n\n    static int done = 0;\n\n    int i = 0;\n\n\n\n    v->hrd_rate = v->hrd_buffer = NULL;\n\n\n\n    /* VLC tables */\n\n    if(!done)\n\n    {\n\n        done = 1;\n\n        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,\n\n                 ff_vc1_bfraction_bits, 1, 1,\n\n                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,\n\n                 ff_vc1_norm2_bits, 1, 1,\n\n                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,\n\n                 ff_vc1_norm6_bits, 1, 1,\n\n                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,\n\n                 ff_vc1_imode_bits, 1, 1,\n\n                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        for (i=0; i<3; i++)\n\n        {\n\n            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,\n\n                     ff_vc1_ttmb_bits[i], 1, 1,\n\n                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,\n\n                     ff_vc1_ttblk_bits[i], 1, 1,\n\n                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,\n\n                     ff_vc1_subblkpat_bits[i], 1, 1,\n\n                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<4; i++)\n\n        {\n\n            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n", "idx": 5138, "substitutes": {"v": ["nv", "vd", "vid", "s", "value", "V", "vt", "x", "b", "m", "uv", "l", "f", "conv", "ve", "d", "q", "tv", "u", "vs", "e", "w", "k", "t", "n", "p", "h", "vp", "sv", "iv", "c", "vl", "g", "lv", "vv", "vc"], "i": ["gi", "r", "name", "isi", "o", "ei", "ti", "id", "I", "chi", "di", "s", "ci", "ki", "ji", "ni", "b", "xi", "si", "ani", "x", "slice", "ri", "io", "bi", "info", "m", "qi", "ix", "key", "gu", "num", "l", "yi", "pi", "f", "phi", "d", "j", "ii", "iu", "it", "ai", "cli", "uli", "init", "u", "part", "e", "uri", "field", "multi", "mi", "ski", "ini", "ie", "p", "eni", "sup", "oi", "c", "ip", "g", "y", "api", "hei", "li", "fi", "index", "zi", "idi", "ui"]}}
{"project": "FFmpeg", "commit_id": "73e8e8dbf969b9a0bc1591abcfeba474a42e47bc", "target": 1, "func": "int av_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, i;\n    AVStream *st;\n    for(;;){\n        AVPacketList *pktl = s->raw_packet_buffer;\n        if (pktl) {\n            *pkt = pktl->pkt;\n            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||\n               !s->streams[pkt->stream_index]->probe_packets ||\n               s->raw_packet_buffer_remaining_size < pkt->size){\n                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;\n                av_freep(&pd->buf);\n                pd->buf_size = 0;\n                s->raw_packet_buffer = pktl->next;\n                s->raw_packet_buffer_remaining_size += pkt->size;\n                av_free(pktl);\n                return 0;\n        av_init_packet(pkt);\n        ret= s->iformat->read_packet(s, pkt);\n        if (ret < 0) {\n            if (!pktl || ret == AVERROR(EAGAIN))\n                return ret;\n            for (i = 0; i < s->nb_streams; i++)\n                s->streams[i]->probe_packets = 0;\n        st= s->streams[pkt->stream_index];\n        switch(st->codec->codec_type){\n        case AVMEDIA_TYPE_VIDEO:\n            if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;\n            break;\n        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||\n                     !st->probe_packets))\n            return ret;\n        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);\n        s->raw_packet_buffer_remaining_size -= pkt->size;\n        if(st->codec->codec_id == CODEC_ID_PROBE){\n            AVProbeData *pd = &st->probe_data;\n            av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n            --st->probe_packets;\n            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes\n                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n                if(st->codec->codec_id != CODEC_ID_PROBE){\n                    pd->buf_size=0;\n                    av_freep(&pd->buf);\n                    av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);", "idx": 5146, "substitutes": {"s": ["sf", "S", "b", "f", "parts", "d", "service", "hs", "conf", "self", "h", "aws", "sp", "sa", "g", "sym", "sets", "is", "spec", "services", "its", "states", "server", "sl", "ls", "sc", "sh", "ops", "ds", "ts", "settings", "sv", "fs", "new", "sq", "site", "rs", "events", "uses", "as", "ans", "ins", "sg", "plugins", "comments", "sync", "ses", "ions", "sci", "cs", "u", "vs", "e", "sb", "ks", "qs", "t", "p", "lex", "c", "os", "ssl", "set", "r", "ps", "o", "v", "session", "si", "styles", "sys", "m", "ips", "details", "l", "xs", "side", "ns", "us", "ss", "gs", "se", "su", "this", "params", "es", "js"], "pkt": ["cpkt", "Pck", "melt", "felt", " pwk", " pnt", "pqt", "pkl", "peck", "spnt", "apacket", "apct", "spqt", "spct", "cpwk", "cpacket", " pk", "pk", "cpelt", "tpt", "Pet", "spelt", " piece", "peacket", "pck", "tpkl", "pwk", "spk", "apk", "facket", "tqt", "apkt", "twk", "Packet", "Pelt", "pekt", "fet", "spkt", "tpkt", "rwk", "fkl", "tkt", "Piece", "packet", "pewk", "pelt", "Pqt", "spet", "tpct", "tpacket", "racket", " pet", " pqt", "cpqt", " ppt", "Pk", "ppt", "pet", "Pnt", "peet", " pck", "peiece", "Pwk", "pnt", "fkt", "mkt", "rkt", "Pkt", "piece", "pct", "macket", " pelt", "cppt", " pct", "cpet", "mqt", "Pct", "spacket", "Pkl", "fct", " packet"], "ret": ["flag", "reg", "iter", "rt", "id", "sec", "alt", "cur", "nt", "value", "rb", "val", "data", "rc", "et", "bit", "let", "reply", "sur", "status", " RET", "num", "f", "lit", "fin", "att", " Ret", "pet", "offset", "arg", "res", "bad", "def", "len", "code", "mt", "det", "error", "en", "part", "RET", "t", "err", "str", "rev", "result", "Ret", "ft", "ut", "run", "xt", "re", "fun", "back", "success", "ref", "rep", "r", "rets"], "i": ["gi", "o", "ti", "iter", "v", "id", "I", "chi", "di", "ci", "ki", "ni", "xi", "ri", "si", "io", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "iu", "ii", "it", "init", "ai", "u", "e", "n", "multi", "mi", "ini", "ie", "p", "mini", "eni", "oi", "hi", "ind", "ip", "im", "y", "li", "inner", "fi", "index", "ui"], "st": ["std", "est", "fr", "ste", "cr", "sty", "ost", "nt", "sw", "tmp", "sn", "stack", "ust", "art", "dest", "pt", "sts", "rest", "post", "sl", "St", "us", "ss", "td", "stop", "sc", "sth", "sb", "ist", "inst", "sh", "se", "sd", "t", "ts", "first", "ST", "str", "sta", "stage", "ut", "ft", "trans", "sp", "start", "step", "sa", "ld", "back", "ct", "tt", "src", "set", "ast", "nd", "end", "add"], "pktl": ["pctli", "pntla", "pkgl", "paitl", "pntlc", "pctla", "pwkl", "pntl", "pktli", "packetl", "ipwksl", "pktla", " packetl", "packetrl", "packetr", "cpacketlc", "pttll", "pntL", "puntl", "cktel", "packetln", "packetsl", "plktlp", "pktn", "ipktln", "packetll", "pktsl", "cpacketla", "pktL", "ipktsl", "plwkL", "spacketls", "packetli", "puntn", "cpktlc", "cpktla", "ipktl", "packetL", "pktrl", "spktrl", "packetla", "cktL", "pctL", "plktel", "pctls", "pctl", "cpktl", "plktL", " packetll", "pktls", "spktla", "cettl", "ipwkl", "pkgla", "pettl", "cpktler", "pttl", "petel", "pctrl", "plwkel", "cktr", "pwkls", "cpacketler", " packetls", "packetn", "pwklp", "pettel", "petls", "cpacketl", "ipwkn", "cettL", "pwkn", "pktlp", "plwklp", "pwkrl", "pkglc", "pktll", "pettL", "petr", "pntler", "pwkL", "cettr", "pttls", "paitls", "pntlp", "pktln", "pettr", " packetL", "packetlc", "pwkln", " packetli", "petL", "spktl", "spacketrl", "petlp", "pttL", "cettel", "pntel", " pktL", "packetler", "paitL", " pktli", "pktel", "pwksl", " pktls", "spktls", " pktll", "pwkel", "packetls", "pkgler", "spacketl", "cktl", "pktr", "packetel", "pktler", "plktl", "pktlc", "plwkl", "petll", "ipwkln", "spacketla", "petl", "ipktn", "paitli", "puntln", "puntsl", "pwkla"], "pd": ["std", "pid", "pard", "od", "md", "bd", "vd", "di", "dd", "pa", "po", "pp", "data", "dh", "raf", "wp", "ad", "lp", "d", "pc", "td", "np", "wd", "dp", "da", "ds", "sd", "PD", "df", "dc", "xd", "ant", "p", "vp", "dra", "ld", "ppa", "bf", "fd", "gd", "dl", "tp", "ud", "dt", "pb", "hd", "cd"], "probe_packets": ["probe_packes", "probe_bucksets", "probe_facings", "probe___hookings", "probe_buffets", "probe_statets", "probe___packets", "probe_hookums", "probe___hookums", "probe_buffessions", "probe_hookings", "probe_packsessions", "probe_buckessions", "probe_hookets", "probe_packings", "probe_facets", "probe_packums", "probe_bucket", "probe_packsets", "probe_packset", "probe___packes", "probe___hookes", "probe_buffet", "probe_hookes", "probe_buckets", "probe_packessions", "probe_facums", "probe_statings", "probe_packssets", "probe_packet", "probe___packings", "probe___hookets", "probe___packums", "probe_states", "probe_faces", "probe_statums", "probe_buffsets"]}}
{"project": "qemu", "commit_id": "df8ad9f128c15aa0a0ebc7b24e9a22c9775b67af", "target": 1, "func": "static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n", "idx": 5171, "substitutes": {}}
{"project": "qemu", "commit_id": "b4f72e31b924bec2c18fe0b2a8c6462dbed9dcb2", "target": 1, "func": "static int net_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);\n\n    int rx_copy;\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"tx-ring-ref\",\n\n                             &netdev->tx_ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"rx-ring-ref\",\n\n                             &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n", "idx": 5172, "substitutes": {"xendev": ["xstartow", "xendingow", "crossenderv", "xendingef", "xedgeerv", "exendec", "exendir", "rxendedever", "xenddev", "rxendev", "xendedever", "xendingdev", " xendov", " xendruction", "xendingtr", "xentdev", "longendere", "yenderv", "xndexp", " xENDrib", "tendec", "xndov", "exndore", "exnderv", "lexendstr", " xENDerv", "xendedruction", "tenddev", "xENDrib", "crossendurt", "xendsov", "xenee", "xadore", " xstartev", "exenddev", "xstarterv", "yendexp", "xenev", "xendingere", "xendedev", "yendederv", "xndow", "xtendsov", " xenderv", "xedgeev", " xstartee", "xaddev", "xenef", "xendingee", "xendingurt", "yendedel", "crossendingerv", "xendsdev", "xendef", "lexendserv", "xendingov", "xedgedev", " xENDov", "xendingev", "xestdev", "lexendsev", "exnddev", "xtendserv", " xENDev", "xendingec", "xstartov", " xenddev", "xtendev", "xendov", "xstartdev", "xendedtr", "xENDev", "xendurt", "yendel", "rxendov", "yendedexp", "xendedec", "xendserv", "tendov", "yendedir", "longendingev", "longendee", "yendev", "xendedef", "xndore", "xndir", "xenderv", "exenderv", "xtendsev", "yendir", "xendedexp", "rxendeddev", "xendexp", "xstartev", "xentov", "exendow", "tendeddev", "xedgeexp", "xendel", "rxendedev", "xtenderv", "exndov", "xestec", "exndec", "lexendev", " xendingerv", "xendore", "xendere", "xnderv", "xendsel", "xndee", "xendsef", "xenerv", " xendingruction", "tendedov", "xendever", "exndow", " xendrib", "lexendtr", "xadev", "xndever", "xendsore", "xENDerv", "yendedev", "xadov", "xendtr", "xendruction", " xendee", " xendingov", "xendedel", "lexendef", "xestir", "longendingerv", " xendingev", "xndec", "longendingere", "crossendov", "lexendsef", "xendingel", "xendedere", "xendir", "xendingruction", "crossendev", "crossendingurt", "rxendedov", "exndev", "xendederv", " xstartdev", "xendingerv", "xendedurt", "xENDov", "yendeddev", "xendsir", "xendsec", "xestev", "xendeddev", "longendev", "xendrib", "tendedec", "exendov", "rxendever", "exndir", "xentever", "xendee", "xtendsef", "xendsev", "xstartee", "xendec", "yenddev", "xndev", "xenturt", "xenterv", "exendev", "xendow", "xenruction", "exendore", "longendingee", "xtendef", "tendev", "xenrib", "xendstr", "xendedrib", "xtendov", "rxenddev", "xenere", "xendedee", "crossendingev", "xnddev", "xendingir", "xenov", "longenderv", "crossendingov", "xentev", "lexenderv", "tendedev", " xstartov", "xendedir", "xendedov"], "netdev": ["bootdevelopment", "ntdevice", "webvalid", "networkself", "tundev", "netev", "ortdev", "netapp", "mindevelopment", " netd", "natdevice", "webapp", " netapp", "netdebug", "ntself", " netengine", "natdevelopment", "webDev", "netdiff", "networkd", "fatev", "NETdev", "netblock", "webself", "bootev", "netend", "netdevelopment", "potself", " netDEV", "netpack", "webrad", "natev", "networkend", "nutdiv", "motdiv", "webdevelopment", "enDev", "natdev", "minrad", "motblock", " netbreak", "fatbreak", "fatrad", "networkdevice", "melself", "actdevice", "networkdebug", "actd", "netpub", "netbreak", "networkdiv", "endev", "fatd", "networkdev", "nutdevelopment", "natblock", "userdiv", "networkdevelopment", "weberror", "minev", "fatDEV", "ntDEV", "webdiv", "motconf", "actdiv", "ntpack", "networkver", "networkvalid", "bootvalid", "networkpub", "actdev", "portbreak", " netver", "meldev", "motdev", "networkev", "webd", "webdebug", " netrad", " neterror", "ntev", "end", "networkrad", "networkdiff", "motdevelopment", "netver", "netvalid", "natdiv", "tundiv", "ntdevelopment", "ortend", "netDev", "webdev", "netrad", "netself", "Netdev", "netdevice", "bootdev", "networkDev", " netdevice", "nutprov", "netconf", "portrad", " netblock", "networkpack", "networkflow", " netdiff", "portdev", " netdiv", "portdevice", " netpub", "meldevice", "endevice", "bootpub", "netflow", "fatdevice", "userdev", "webdevice", "fatdev", "natengine", "netprov", "nutdev", "netdiv", "Netapp", "ortdevelopment", "enprov", "networkengine", "neterror", "tunblock", " netflow", "userDEV", "networkapp", " netdevelopment", "networkbreak", " netvalid", "ntdiff", "networkconf", "webdiff", "Netdevice", "motprov", "fatdiv", "tunrad", "networkprov", "motev", "NETdiv", "mindev", "natconf", "userblock", "potdev", "ortev", "webev", "netDEV", "potev", "NETd", "networkerror", "networkblock", "bootrad", "fatblock", "webpack", "networkDEV", "netengine", "webprov", "enerror", " netself", "motend", "ntrad", "netd", "webver", "meldebug", "ntdev", "potdiff", " netev", "webblock", "webflow", "NETver"], "rx_copy": ["rr_copy", " tx_copy", "rxfCopy", "rx_repeat", "rx__cop", "rx__copy", "rx_leave", "rxfslave", "rxlogmatch", " tx_store", "rx_store", " tx_slave", "rx_left", "rx_slave", "rx_Copy", "rr_left", "rx_size", "tx_cop", "rxfcopy", "tx_size", "rx_match", "rxlogleave", "rx_cop", "rxfstore", "tx_copy", "tx_leave", "rxlogcopy", "rx__left", "rr_cop", "tx_match", "tx_repeat", " tx_Copy"]}}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "substitutes": {"env": ["enable", "ah", "fg", "eng", "er", "nw", "ea", "cur", "dat", "scope", "config", "esp", "environment", "exc", "style", "enc", "eu", "buf", "db", "cal", "export", "ext", "server", "obj", "args", "py", "init", "forest", "conf", "ev", "np", "code", "e", "img", "ass", "en", "here", "esc", "estate", "err", "context", "ec", "stage", "settings", "opt", "req", "viron", "txt", "core", "cv", "site", "cache", "age", "forge", "conn", "end", "dict"], "value": ["address", "option", "name", "paid", "v", "complete", "values", "config", "update", "val", "data", "format", "image", "status", "null", "window", "num", "valid", "key", "version", "enabled", "number", "code", "property", "target", "message", "port", "timeout", "result", "Value", "scale", "start", "VALUE", "none", "attribute", "new", "type", "current", "index", "age", "set", "max", "expression", "end", "size"]}}
{"project": "FFmpeg", "commit_id": "9af6abdc17deb95c9b1f1d9242ba49b8b5e0b016", "target": 1, "func": "static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)\n\n{\n\n    int i,j,k,cnt;\n\n    int   components, coding_mode_selector, coding_mode, coded_values_per_component;\n\n    int   sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;\n\n    int   band_flags[4], mantissa[8];\n\n    float  *pCoef;\n\n    float  scalefactor;\n\n    int   component_count = 0;\n\n\n\n    components = get_bits(gb,5);\n\n\n\n    /* no tonal components */\n\n    if (components == 0)\n\n        return 0;\n\n\n\n    coding_mode_selector = get_bits(gb,2);\n\n    if (coding_mode_selector == 2)\n\n\n\n\n    coding_mode = coding_mode_selector & 1;\n\n\n\n    for (i = 0; i < components; i++) {\n\n        for (cnt = 0; cnt <= numBands; cnt++)\n\n            band_flags[cnt] = get_bits1(gb);\n\n\n\n        coded_values_per_component = get_bits(gb,3);\n\n\n\n        quant_step_index = get_bits(gb,3);\n\n        if (quant_step_index <= 1)\n\n\n\n\n        if (coding_mode_selector == 3)\n\n            coding_mode = get_bits1(gb);\n\n\n\n        for (j = 0; j < (numBands + 1) * 4; j++) {\n\n            if (band_flags[j >> 2] == 0)\n\n                continue;\n\n\n\n            coded_components = get_bits(gb,3);\n\n\n\n            for (k=0; k<coded_components; k++) {\n\n                sfIndx = get_bits(gb,6);\n\n\n\n                pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n\n                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n\n                coded_values = coded_values_per_component + 1;\n\n                coded_values = FFMIN(max_coded_values,coded_values);\n\n\n\n                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];\n\n\n\n                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);\n\n\n\n                pComponent[component_count].numCoefs = coded_values;\n\n\n\n                /* inverse quant */\n\n                pCoef = pComponent[component_count].coef;\n\n                for (cnt = 0; cnt < coded_values; cnt++)\n\n                    pCoef[cnt] = mantissa[cnt] * scalefactor;\n\n\n\n                component_count++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return component_count;\n\n}", "idx": 5190, "substitutes": {"gb": ["vg", "_", "rb", "Gb", "bg", "b", "gnu", "bm", "hm", "all", "bc", "GB", "nb", "mb", "g", "gd", "gi", "lb", "count", "s", "gru", "gio", "gz", "eb", "binary", "lib", "gg", "game", "cgi", "phy", "bin", "sg", "db", "wb", "ga", "usb", "gin", "abb", "pc", "py", "xb", "sb", "rg", "gy", "ge", "bo", "src", "gp", "gc", "cfg", "gm", "hub", "bb", "gam", "gs", "storage", "kb", "gh", "bf", "hd"], "pComponent": [" pInstance", "mComponent", "pConnection", " pProcess", "PInstance", "PProcess", "pProcess", "cComp", "ppComp", "mSample", "PComponent", " pComp", "PComp", "ppConnection", "mComp", "ppInstance", "cConnection", " pConnection", "PSample", "pComp", "pInstance", "cComponent", "mProcess", "ppComponent", " pSample", "cInstance", "pSample"], "numBands": ["numChands", "sumBounds", "sumBands", "numbounds", "NumCannels", "numMands", "numCands", "numCannels", "numBannels", "numBounds", "numbases", "numPlands", "nbBands", "nbPlands", "nbBounds", "numbannels", "numBards", "sumMands", "NumBounds", "nbPlases", "numChbands", "numChounds", "numBases", "NumBands", "numChannels", "nbBannels", "NumBannels", "NumBbands", "numCounds", "sumMards", "sumMannels", "numPlounds", "numMards", "sumBannels", "nbBases", "numBbands", "nbPlounds", "numMannels", "numMbands", "sumMounds", "numMounds", "NumCands", "numbands", "nbPlannels", "NumCbands", "sumBards", "numCards", "numPlases", "numPlannels", "NumCounds", "numCbands", "numChases"], "i": ["gi", "ti", "v", "I", "chi", "is", "di", "ci", "ki", "ji", "ni", "b", "x", "si", "ri", "xi", "io", "info", "bi", "m", "qi", "ix", "l", "pi", "phi", "ii", "iu", "d", "ai", "u", "uri", "n", "multi", "mi", "ini", "ie", "p", "z", "c", "ip", "g", "li", "fi", "index", "zi", "ui"], "j": ["jet", "dy", "fr", "o", "ch", "v", "el", "oj", "jl", "note", "ji", "b", "x", "m", "kj", "l", "key", "f", "job", "ijk", "offset", "d", "ii", "ij", "q", "obj", "it", "aj", "length", "u", "jen", "e", "J", "je", "jc", "json", "n", "uj", "jp", "jo", "ie", "p", "jit", "h", "z", "pos", "jj", "c", "off", "g", "y", "ja", "dj", "br", "li", "adj", "bj", "js"], "k": ["ko", "o", "ch", "v", "kn", "ka", "ik", "ki", "kick", "b", "x", "kk", "m", "kj", "key", "K", "sk", "f", "kh", "dk", "d", "q", "it", "u", "e", "ck", "km", "w", "ks", "n", "kid", "work", "kat", "p", "kw", "ky", "h", "z", "c", "ke", "g", "y", "ek", "ku", "uk", "kr", "r", "mk", "ok"], "cnt": ["fnt", " cnc", "ncNT", "count", "CNT", "acnc", "cant", "Cnc", "cov", " cNT", "acst", "scct", "cpt", "ncnt", "Cpt", "scov", "pnc", "cny", "acpt", "pant", "pst", "cst", "fount", "cct", "acct", "cnc", " cst", " cct", "Cny", "Cnt", "cNT", " cny", " cov", " cpt", "fov", "scnt", " cant", "scount", " count", "acnt", "fct", "ncny", "ncant", "pnt", "acNT", "Cct", "Cant", "acant"], "components": ["chones", "commlements", "chonents", "compants", "Compuments", "compones", "scances", "instants", "commances", "scands", "comands", "codes", "compodes", "commants", "commodes", "instlements", "ompances", "compuments", "Compances", "ompuments", "Complements", "comances", "comonents", "omponents", "scones", "conents", " compances", "sconents", "complements", "Components", "commones", "compances", "instonents", "cones", "compands", "instances", "Compants", "cands", "chodes", "commonents", "cances", "chances", "comones", " compuments"], "coding_mode_selector": ["coding_mode_reflective", "coding_mode_Selectore", "coding_mode_reflectors", "coding_mode_reflectively", "coding_mode_elector", "coding_mode_Selectors", "coding_mode_selectors", "coding_mode_lectively", "coding_mode_reflector", "coding_mode_reflectOR", "coding_mode_selectoring", "coding_mode_lective", "coding_mode_SelectOR", "coding_mode_Selectoring", "coding_mode_connector", "coding_mode_lectore", "coding_mode_connective", "coding_mode_selectively", "coding_mode_reflectoring", "coding_mode_connectoring", "coding_mode_selective", "coding_mode_electOR", "coding_mode_Selective", "coding_mode_lectoring", "coding_mode_electors", "coding_mode_Selector", "coding_mode_lectOR", "coding_mode_lectors", "coding_mode_reflectore", "coding_mode_lector", "coding_mode_electoring", "coding_mode_connectors", "coding_mode_selectOR", "coding_mode_connectively", "coding_mode_selectore", "coding_mode_elective", "coding_mode_electore"], "coding_mode": ["coding_lane", "caling_phase", "coding__phase", "casing_type", "caling_mode", "coding__mode", "caling__MODE", "casing_range", "caling__size", "coding_phase", "coding_MODE", "coding_range", "coding__size", "casing_mode", "caling__mode", "coding__MODE", "caling_MODE", "coding_distance", "casing_MODE", "coding_size", "caling__phase", "casing_lane", "casing_distance", "coding_type", "caling_size"], "coded_values_per_component": ["coded_values_per_sample", "coded_values_PER_component", "coded_values_per_section", "coded_values_PER_pixel", "coded_values_perjcomponent", "coded_values_perjsample", "coded_values_PER_comp", "coded_values_perjcomp", "coded_values_perjsection", "coded_values_per_comp", "coded_values_PER_section", "coded_values_PER_sample", "coded_values_per_pixel"], "sfIndx": ["sfInn", "sfImplX", "sfPtrX", "sfIDn", "sfInitex", "sfindxs", "SFIndxs", "fIndex", "sfIndex", "ephIndx", "SFPtrxs", "ephInxs", "findex", "ephIndn", "sfInitx", "sfInitX", "sfIDx", "ephIndindex", "sfPtrx", "sfIDindex", "SFPtrX", "fIndi", "sfIndindex", "SFPtrx", "fIndx", "sfInx", "SFIndex", "findX", "sfIndexn", "findx", "sfInindex", "ephInn", "sfLenxs", "fIndX", "SFIndX", "findi", "sfIndi", "sfIndexxs", "sfInxs", "sfLenx", "sfIndexindex", "sfImplex", "SFPtrex", "ephInindex", "sfindx", "sfindi", "sfImpli", "sfIndexx", "sfLenex", "sfindex", "sfIDxs", "SFIndx", "sfIndxs", "ephInx", "sfPtrex", "sfIndn", "ephIndxs", "sfindX", "sfIndX", "sfLenX", "sfPtrxs", "sfIniti", "sfImplx"], "coded_values": ["coded___vals", " coded_vals", "coded_jobs", "added___vals", "coded67vals", "coded_stores", "coded_members", " coded_Values", "coded___values", "added___values", "coded___settings", "coded_settings", "coded67values", "coded_Values", "added_vals", "coded67settings", "added_members", "ordered_jobs", "coded_value", "coded67members", "added_settings", "codedsvalues", "codedsvals", "added___members", "fed_values", "coded_vals", "coded___members", "codedsValues", "added___settings", "added_values", "fed_stores", "ordered_value", "fed_value", "ordered_values"], "max_coded_values": ["max_oded_results", "max_oded_values", "max_coded_images", "max_coded00frames", "max_coded\u00b7images", "max_coded__values", "max_oded_frames", "max_oded_versions", "max_coded00values", "max_coded__images", "max_coded_Values", "max_coded\u00b7results", "max_coded\u00b7Values", "max_coded_results", "max_coded__versions", "max_coded2Values", "max_coded_frames", "max_oded_images", "max_coded_versions", "max_coded\u00b7versions", "max_coded2results", "max_coded_errors", "max_coded\u00b7values", "max_oded_Values", "max_coded2values", "max_oded_errors", "max_coded00errors"], "quant_step_index": ["quant_group_point", "quant_step___sign", "quant_scale_ind", "quant_group_index", "quant_stepinglabel", "quant_scale_level", "quant_step___index", "quant_step0ind", "quant_step_count", "quant_scale_index", "quant_stepingindex", "quant_step_point", "quant_group_ind", "quant_step0point", "quant_step_diff", "quant_step_position", "quant_step_ind", "quant_data_index", "quant_step_label", "quant_group_sign", "quant_step_sign", "quant_step___count", "quant_group_label", "quant_group_count", "quant_step0level", "quant_step___diff", "quant_data_ind", "quant_step0index", "quant_step_level", "quant_stepingpoint", "quant_group_diff", "quant_stepingind", "quant_data_position", "quant_step_column", "quant_data_column", "quant_scale_point"], "coded_components": ["coded_communitions", "coded_commands", "coded_commuments", "coded_counds", "coded_componentounds", "coded_communounds", "coded_communonents", "coded_quonents", "coded_quounds", "coded_quantonents", "coded_compuments", "coded_compitions", "coded_componentuments", "coded_commounds", "coded_conents", "coded_compands", "coded_quantitions", "coded_cuments", "coded_quantounds", "coded_compounds", "coded_quands", "coded_componentitions", "coded_componentonents", "coded_commonents", "coded_componentands"], "band_flags": ["bands_planes", "band___flags", "band_features", "bit_features", "bandWfeatures", "band2flags", "bandWflag", "band2flag", "band___flag", "bands_codes", "bands_flag", "band___planes", "band_planes", "band_count", "band2bits", "band_flag", "band__codes", "bit_settings", "bit_count", "bit_flag", "band__planes", "bandWsettings", "band__flag", "bands_flags", "band_settings", "band__flags", "bit_flags", "bandWflags", "band2count", "band_codes", "bit_bits", "band___codes", "band_bits"], "mantissa": ["mentica", "Mantilla", "Mantissa", "mentissa", "Mentica", "magnile", "mentilla", "magnilla", "mantica", "mentile", "magnica", "Mentile", "Mentilla", "Mantica", "mktissa", "Mentissa", "mktilla", "mantilla", "mantile", "magnissa", "mktica", "Mantile", "mktile"], "pCoef": ["pcoef", "pReef", "pReff", "Pcoffe", "Pcoef", "pFlff", "pcoffe", "Pcoaf", "PCoffe", "pFlef", "pCoaf", "Pcoff", "pReaf", "PCoaf", "pcoff", "pCoffe", "PCoff", "pCoff", "pReffe", "pFlffe", "PCoef", "pFlaf", "pcoaf"], "scalefactor": ["scalesefactor", "scalephactor", "scalefractor", "scallefactor", "scaldefractor", "scalephact", "scalesepact", "scalesefractor", "scalepact", "scalephractor", "scallefact", "scalesefact", "scalescrator", "scalesepractor", "scalepractor", "scaldefector", "scaleprator", "scalephector", "scallescactor", "scalescractor", "scallescector", "scalefact", "scalecact", "scalefrator", "scaldefactor", "scalepactor", "scallefractor", "scaleseprator", "scalescector", "scalescactor", "scalecactor", "scalesepactor", "scalesefrator", "scallescractor", "scaldefact", "scalecrator", "scalecractor", "scallescact", "scallefector", "scalefector", "scalescact"], "component_count": ["component_order", "sample2coll", "componentIDsize", "component24length", "sample_count", "component24coll", "componentCountorder", "componentCountcount", "component2coll", "threadCountcount", "component_coll", "componentCountsum", "threadCountsum", "sample_length", "threadCountorder", "component_size", "component2count", "componentCountsize", "thread_size", " component_size", "component2length", "component_length", "componentIDcount", "threadCountsize", "thread_order", "component_sum", "componentIDorder", "thread_sum", "componentIDsum", "sample2count", "sample2length", " component_length", "thread_count", "sample_coll", "component24count"]}}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 5191, "substitutes": {"keybuf": ["valuebuf", "kbuff", "kuf", " keybuffer", "charbuff", "rowqueue", "keyblock", "kbase", "keyuf", "charbase", " keybase", "kbuffer", "parentbuff", "valueblock", "rowbuff", "charbuffer", "kblock", "charseq", "valuebuff", " keyuf", " keybuff", "bytebuffer", "rowbuffer", " keyqueue", "keybase", "keybuff", "kcb", "keyseq", "kqueue", "valueuf", "keyqueue", "charcb", "kbuf", " keycb", "bytebuf", "keycb", "bytecb", "charbuf", "charqueue", "rowseq", "valuequeue", "rowcb", "keybuffer", "parentuf", "parentbuffer", " keyblock", " keyseq", "valuebuffer", "rowuf", "rowbuf", "parentbuf", "bytebuff"], "q": ["patch", "P", "ch", "iq", "v", "cur", "id", "qq", "check", "qt", "x", "b", "force", "sync", "pe", "queue", "qi", "key", "l", "f", "dq", "d", "j", "u", "code", "e", "sh", "w", "que", "comment", "k", "Q", "qs", "t", "qu", "qa", "req", "h", "z", "c", "g", "sq", "y", "query", "text", "r"], "keycodes": ["Keylines", "changecode", "kcode", "keyodes", "Keybuf", "switchcodes", "lockcode", "switchcode", " keyodes", "Keycards", "keypath", "maccoded", "kmaps", "charcode", "lockcoded", "changecodes", " keycards", " keymaps", "switchbuf", "changeodes", "keycards", "charpath", " keycoded", "maccodes", "maccode", "charcodes", "Keycodes", "Keypath", "switchcards", "Keycode", "keycoded", "lockcodes", "lockmaps", " keypath", " keylines", "macodes", "keylines", "kcoded", "changecoded", "charlines", "keymaps", "kcodes"], "p": ["patch", "cp", "P", "pid", "o", "python", "v", "pr", "a", "s", "pa", "pat", "pre", "po", "b", "pp", "op", "x", "pe", "ap", "lp", "m", "l", "f", "pi", "at", "pg", "php", "j", "d", "pc", "py", "param", "np", "u", "code", "e", "point", "part", "t", "k", "n", "jp", "fp", "qa", "h", "sp", "pos", "pointer", "c", "ip", "g", "y", "type", "api", "tp", "pair", "pl", "cache", "r", "ps", "prefix"], "nb_keycodes": ["nb_linklines", "nb_datecodes", "nb_Keycodes", "nb_keyodes", "nb_datecards", "nb_switchcod", "nb_linkcards", "nb_keycats", "nb_linkcats", "nb_keycode", "nb_keycards", "nb_keylines", "nb_callmaps", "nb_Keylines", "nb_keychecks", "nb_mycodes", "nb_charcodes", "nb_calllines", "nb_callchecks", "nb_charxes", "nb_keyxes", "nb_macodes", "nb_switchcodes", "nb_callodes", "nb_myxes", "nb_charses", "nb_changecodes", "nb_Keychecks", "nb_callcards", "nb_linkcodes", "nb_keycod", "nb_myses", "nb_callcodes", "nb_Keyses", "nb_changelines", "nb_callcats", "nb_maccodes", "nb_keyses", "nb_callcod", "nb_datecats", "nb_Keymaps", "nb_callcode", "nb_changemaps", "nb_datelines", "nb_Keyxes", "nb_maccode", "nb_switchlines", "nb_keymaps", "nb_changechecks"], "keycode": ["pointcode", "xcoded", "skycode", "skypath", "lockcode", "rycod", "vercod", "keydesc", "rowcod", "opcod", "keypath", "keydef", "rowcoded", " keycod", "rowCode", "wordpath", "pointcod", " keyc", "keycycle", "typedesc", "checkmessage", "lockdef", " keyode", "keyCode", "checkode", "lockCode", "checkc", "levelcode", "rowcodes", "Keycycle", "transferfore", "keyfore", "vercode", "checkdef", "ryode", " keyCode", "keycoded", "pointode", "xcode", "levelfore", "pointmessage", "rycode", "Keycod", "typecodes", "ycod", "rowcode", " keydesc", "keycomment", "wordc", "lockc", "Keyfore", "rycoded", " keydef", "ycode", "typecode", "valuecode", "levelcod", " keycoded", "ycodes", "skycomment", "wordcode", "vercoded", "Keycode", "Keymessage", " keycomment", "keymessage", " keypath", "wordcomment", "ycoded", "callcod", "valueode", "callcodes", "keyode", "valuecoded", "opc", "transfercycle", "checkcode", "keycod", "opcode", "levelcycle", "opcodes", "calldesc", "callcode", "xcod", "lockcod", "typecod", "Keyode", "lockcoded", "skyc", "transfercod", "checkcod", "transfercode", "verc", "valuecod", "lockcodes", "keyc", "xc"], "i": ["gi", "o", "ti", "v", "id", "I", "chi", "a", "di", "s", "ci", "x", "ji", "ni", "b", "xi", "si", "ri", "io", "abi", "slice", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "ii", "iu", "ai", "cli", "init", "u", "e", "uri", "k", "n", "multi", "mi", "ini", "ie", "one", "eni", "start", "oi", "hi", "c", "ip", "g", "y", "api", "li", "inner", "fi", "index", "zi", "mu", "ui"]}}
{"project": "qemu", "commit_id": "5d39c799c3245244ebb1e89da0177dbc089962b2", "target": 0, "func": "void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n", "idx": 5198, "substitutes": {"mon": ["reg", "mem", "prof", "met", "tun", "mat", "bm", "mo", "m", "mos", "emon", "pm", "mn", "mer", "mot", "my", "mod", "man", "mun", "con", "mut", "mi", "monitor", "mr", "am", "Monitor", "util", "mu"], "qdict": ["pdir", "qqobject", "qudf", " qtable", "dqdict", "qobject", "qutable", "qqdict", "pdict", "qdef", "qtable", "pdef", "qqdf", "dqdef", "sqdict", "quobject", "qdf", "qqtable", "sqdom", "sqdef", " qobject", "qdir", "qdom", "qudict", "sqdir", "dqdir", " qdf", "pdom", "dqdom"], "ret_data": ["regblocklist", "reg_class", "retoutclass", "retblockdata", "reg_list", "retblockresults", "reg_results", "regblockclass", "ret_class", "ret0results", "retblocklist", "ret_results", "retblockclass", "retoutresults", "regblockresults", "ret0class", "ret0list", "reg_data", "retoutlist", "ret_list", "retoutdata", "ret0data", "regblockdata"], "d": ["D", "dy", "o", "dim", " dw", "dm", "id", "md", "bd", "dn", "di", "dd", "dat", "dict", " dd", "dos", "x", "dh", "data", "i", "b", " od", " prod", "ad", "pd", "m", "dx", "l", "f", "length", "mod", " p", "u", "delay", "e", "w", "da", "t", "ds", "n", "sd", "dc", "day", "p", "did", "start", "ld", " D", "c", "ind", "fd", "dt", "dl", " dy", "diff", "cd", " delta"], "ptr": ["address", "dy", "dr", "vr", "rt", "pr", "eth", "tmp", "tr", "rd", "inter", "tch", "pt", "dx", "tty", "pointers", "der", "loc", "offset", "attr", "ext", "length", "td", "len", "inst", "arr", "t", "pad", "str", "p", "Ptr", "trace", " pointer", "pert", "pos", "pointer", "tip", "ld", "proc", "fer", "fd", "pair", "src", "ref", "rep", "addr", "r", "dim"], "s": ["stat", "o", "v", "is", "S", "less", "spec", "sg", "session", "single", "b", "socket", "si", "sync", "data", "sys", "ses", "services", "m", "details", "states", "better", "f", "parts", "ns", "state", "stats", "sl", "ls", "args", "server", "service", "cs", "conf", "e", "submit", "sb", "gs", "w", "secondary", "t", "storage", "n", "ds", "su", "p", "south", "settings", "c", "g", "ssl", "sq", "syn", "rs", "r", "js"], "value": ["address", "name", "v", "block", "id", "fee", "values", "val", "object", "data", "format", "m", "key", "num", "null", "content", "version", "description", "property", "w", "message", "json", "str", "result", "p", "start", "VALUE", "type", "text", "element", "current", "test", "r", "min", "Value"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5201, "substitutes": {"ctx": ["cp", "cmp", "gc", "cfg", "anc", "hw", "unc", "ci", "component", "gru", "config", "nc", "rc", "cca", "sync", "cus", "gpu", "loc", "cm", "tx", "cl", "soc", "cc", "ctr", "cs", "sci", "crit", "cli", "ck", "sc", "mc", "que", "cam", "fn", "cmd", "wcs", "bc", "cu", "jp", "Context", "exec", "context", "ctrl", "ca", "qa", "css", "cpu", "kb", "c", "txt", "ct", "cn", "cf", "lc", "fc", "cz", "cv", "src", "vc", "git", "cpp", "cas", "grad", "conn", "pkg", "xc", "tc"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "substitutes": {"ctx": ["cp", "cmp", "cfg", "anc", "hw", "pai", "ci", "gru", "component", "config", "qt", "cus", "rc", "cca", "sync", "sys", "concept", "loc", "cm", "tx", "client", "conv", "JC", "cc", "cli", "cs", "sci", "crit", "kt", "np", "ck", "sc", "mc", "que", "connection", "cam", "cmd", "bc", "cb", "cu", "Context", "cms", "exec", "context", "input", "ctrl", "ca", "qa", "cpu", "kb", "utils", "c", "txt", "cn", "cf", "chan", "cv", "vc", " cx", "git", "src", "cpp", "cas", "conn", "pkg", "tc"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n", "idx": 5222, "substitutes": {"vser": ["evcur", "wcur", " vper", "vserver", "wsr", " vserver", "vg", "vder", "wester", "fserver", "qcer", "fser", "vsg", "evser", " vg", "qser", "wser", "evserver", " vsr", "wper", "vcer", "evper", "vsr", "fester", "qder", "vscer", " vester", "vper", "wserver", " vcer", "qg", "vcur", " vcur", "vsser", "vester", " vder", "fsr", "vsder"], "buf": ["buff", "vec", "v", "box", "rb", "config", "b", "val", "data", "queue", "uc", "fb", "uf", "num", "f", "length", "buffer", "bag", "Buffer", "port", "func", "cmd", "ctx", "bc", "cb", "seq", "pool", "req", "batch", "fd", "ref", "pb", "src", "cas", "ff", "msg"], "len": ["base", "bin", "el", "mem", "v", "alt", "count", "id", "nt", "lan", "val", "data", "elt", "enc", "ll", "l", "fin", "num", "offset", "f", "ler", "fl", "length", " length", "limit", "all", "e", "en", "fn", "lic", "lib", "n", "bytes", "err", "str", "rev", "seq", "un", "z", "pos", "line", "fun", "Len", "ln", "gen", "lc", "li", "zen", "lf", "addr", "lim", "end", "le", "size"], "elem": ["elelem", "eeject", "pelements", "elelement", "elelee", " element", "felement", "elements", "elee", "pelev", "selements", " elements", "Eject", "felem", "Elev", "ele", "eele", " elee", "peject", "selem", "Elem", "elele", "pelem", "Elee", "oelee", "oelements", "Element", "pelement", "selee", "feject", "eject", "eelements", "selement", "felev", "oelement", "eelement", "eleject", "pelee", "elelements", "pele", "elev", "eelem", "element", "oelem", "oeject"], "vq": ["evw", "evbar", "vg", "Vq", "svue", "evque", " vQ", "vqu", "nvQ", "voltquest", "vpque", " vg", " vw", "vquest", "vdqi", "evg", "vvq", "lqu", "vvque", "svquest", "vbar", " vqueue", " vdq", "lq", "vrque", "vrq", "vqueue", "lque", "vQ", "vque", "vdque", "vw", "voltdq", "voltq", "vrqi", "vpqu", " vbar", "Vque", "svq", " vue", "evq", "svdq", "lqi", "vvbar", "nvqu", "vvw", "vpQ", "vue", "vdq", "vdqu", "evqueue", "vpq", "vqi", "Vw", "voltue", "VQ", "nvq", "nvque", " vquest", "evQ", " vque", "Vqueue", "vrqu", "Vg", " vqu"]}}
{"project": "qemu", "commit_id": "9a10bbb4e83b184faef6fa744396a6775283c0aa", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 5229, "substitutes": {"lpc_pci": ["lpc_lcm", "lpc2pcm", "lpc2pmi", "lpc_mki", "lpc_pct", "lpc_pco", "lpc_Pcm", "lpc_pili", "lpc2mca", "lpc_fci", "lpc_Pki", "lpc_fcm", "lpc2mcm", "lpc_pcu", "lpc_ncm", "lpc_lci", "lpc_pca", "lpc_fili", "lpc_lki", "lpc_hcr", "lpc2pci", "lpc_hci", "lpc_pcr", "lpc_hmi", "lpc_mct", "lpc2mmi", "lpc_spcm", "lpc_phpct", "lpc_lmi", "lpc_mca", "lpc_nci", "lpc_lcu", "lpc_hili", "lpc_ncu", "lpc_mcr", "lpc_phpki", "lpc_nco", "lpc_poci", "lpc_hca", "lpc_mci", "lpc_spci", "lpc_phpoci", "lpc_lcr", "lpc_mcm", "lpc_pki", "lpc_mmi", "lpc_lca", "lpc_lco", "lpc_moci", "lpc_pmi", "lpc_spcu", "lpc_lili", "lpc_phpci", "lpc_spco", "lpc_pcm", "lpc_hcm", "lpc_Pcr", "lpc_Pci", "lpc2mci", "lpc2pca", "lpc_fcr"], "pm": ["vim", "om", "bm", "mo", "rm", "pi", "mp", "nm", "service", "hm", "rpm", "pool", "mr", "am", "ym", "ams", "imm", "um", "gram", "pb", "cm", "plugin", "cp", "mand", "vm", "wm", "wp", "module", "pt", "mail", "mon", "mn", "param", "member", "gmail", "em", "nom", "mi", "jp", "fm", "mm", "model", "pl", "rem", "hem", "PM", "pa", "tmp", "po", "sem", "pp", "lp", "px", "ram", "db", "pc", "py", "tm", "mag", "p", "asm", "im", "lv", "gem", "dim", "prem", "gp", "ml", "dm", "gm", "iam", "lam", "pd", "dem", "m", "pg", "period", "km", "manager", "pkg"], "sci_irq": ["sci_pirg", "sci_pirQ", "sci_rce", "sci_mirw", "sci_mirq", "sci_irg", "sci_irw", "sci_mirg", "sci_pircs", "sci_rrcs", "sci_rrq", "sci_irk", "sci_rrg", "sci_rrQ", "sci_pirq", "sci_rq", "sci_IRce", "sci_mircs", "sci_ircs", "sci_irQ", "sci_rw", "sci_rk", "sci_irce", "sci_mirk", "sci_mirQ", "sci_IRw", "sci_mirce", "sci_IRk", "sci_IRq"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n", "idx": 5250, "substitutes": {"opaque": ["Opac", "ipaque", "ipcode", "opgate", "Opaque", "Opcode", "OPcode", "OPac", "Opgate", "ipgate", "opcode", "OPgate", "OPaque", "opac", "ipac"], "addr": ["address", "dr", "afi", "layer", "arm", "rt", "alt", "eth", "device", "config", "Address", "data", "alias", "inter", "ad", "ace", "mac", "offset", "add", "nr", "pc", "align", "byte", "code", "target", "error", "dc", "cmd", "hop", "p", "asm", "boot", "ptr", "pos", "pointer", "start", "node", "proc", "fd", "adr", "amd", "ref", "src", "reference", "host", "grad", "conn", "slot"], "ret": ["base", "flag", "reg", "rt", "mem", "id", "alt", "al", "eth", "nt", "value", "val", "data", "bit", "info", "reply", "valid", "db", " Ret", "lit", "ext", "arg", "res", "byte", "net", "def", "len", "code", "mt", "det", "sb", "arr", "RET", "result", "Ret", "re", "fun", "back", "gt", "success", "ref", "rets"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 5263, "substitutes": {"q": ["quit", "o", "iq", "v", "id", "cur", "qq", "quad", "config", "qt", "sync", "queue", "window", "cl", "f", "client", "pg", "ue", "dq", "d", "u", "que", "qs", "Q", "k", "t", "n", "self", "qu", "p", "qa", "req", "c", "g", "sq", "query", "cache"], "n_IRQ": ["n_REF", "n_REq", "n_RRF", "n_SRQ", "n_IRF", "n_MRq", "n_IRMQ", "n_IRQueue", "n_MRMQ", "n_RRq", "n_RRMQ", "n_REQueue", "n_SRq", "n_irQueue", "n_SRX", "n_RRQueue", "n_irq", "n_RRQ", "n_IRX", "n_RRX", "n_MRX", "n_SRMQ", "n_irF", "n_MRQ", "n_irQ", "n_REQ", "n_IRq"], "pending": ["Pushing", "paging", "ipadding", " pushing", "Paging", "ipending", " paging", "ipushing", "padding", "pushing", " padding", "Pending", "Padding", "ipaging"]}}
{"project": "FFmpeg", "commit_id": "77d2ef13a8fa630e5081f14bde3fd20f84c90aec", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n\n                                  MatroskaTrack *track)\n\n{\n\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n\n    uint8_t* data = *buf;\n\n    int isize = *buf_size;\n\n    uint8_t* pkt_data = NULL;\n\n    int pkt_size = isize;\n\n    int result = 0;\n\n    int olen;\n\n\n\n    if (pkt_size >= 10000000)\n\n        return -1;\n\n\n\n    switch (encodings[0].compression.algo) {\n\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n\n        return encodings[0].compression.settings.size;\n\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n\n        do {\n\n            olen = pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n\n        if (result)\n\n            goto failed;\n\n        pkt_size -= olen;\n\n        break;\n\n#if CONFIG_ZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n\n        z_stream zstream = {0};\n\n        if (inflateInit(&zstream) != Z_OK)\n\n            return -1;\n\n        zstream.next_in = data;\n\n        zstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            zstream.avail_out = pkt_size - zstream.total_out;\n\n            zstream.next_out = pkt_data + zstream.total_out;\n\n            result = inflate(&zstream, Z_NO_FLUSH);\n\n        } while (result==Z_OK && pkt_size<10000000);\n\n        pkt_size = zstream.total_out;\n\n        inflateEnd(&zstream);\n\n        if (result != Z_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n#if CONFIG_BZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n\n        bz_stream bzstream = {0};\n\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n\n            return -1;\n\n        bzstream.next_in = data;\n\n        bzstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n\n            result = BZ2_bzDecompress(&bzstream);\n\n        } while (result==BZ_OK && pkt_size<10000000);\n\n        pkt_size = bzstream.total_out_lo32;\n\n        BZ2_bzDecompressEnd(&bzstream);\n\n        if (result != BZ_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    *buf = pkt_data;\n\n    *buf_size = pkt_size;\n\n    return 0;\n\n failed:\n\n    av_free(pkt_data);\n\n    return -1;\n\n}\n", "idx": 5277, "substitutes": {"buf": ["padding", "buff", "vec", "feed", "Buff", "rb", "tmp", "config", "b", "raf", "rc", "queue", "map", "fb", "uf", "byte", "buffer", "len", "mount", "bag", "Buffer", "port", "cmd", "pad", "bc", "cb", "seq", "array", "input", "batch", "alloc", "br", "board", "addr", "src"], "buf_size": ["file_size", "block_size", "file_range", "block_address", "block_width", "bufksize", "buf_value", "file_Size", "buf_range", "bufkwidth", "buf_Size", "buf_address", "block_value", "file_ize", "bufkaddress", "buf_width", "buf_ize", "bufkvalue"], "track": ["dr", "row", " tracks", "seek", "tracking", "train", "tr", "stream", "record", "tag", "package", "ru", "project", "order", "ack", "tab", "roll", "match", "round", "ACK", "Track", "port", "path", "car", "step", "tracks", "type", "transform", "board", "rack", "trip", "test", "form", "r", "trace", "add"], "encodings": ["ecoding", "encodions", "encodingands", "encodedings", "eccodands", "ecodings", "encodeides", "eccodings", "eccodations", "encodedands", "encording", "ecodides", "encoders", "encodeing", "encodors", "encodeers", "enccodors", "eccoders", "eccodors", "encodedrings", "ecodations", "encodedations", "encordors", "enccodands", "eccoding", "enccodides", "encodinging", "enccodrings", "enccodings", "ecodrings", "enccodions", "encordrings", "encodides", "encodeions", "encodrings", "eccodions", "ecodions", "encodedides", "enccoding", "encodingings", "encodeings", "enccoders", "eccodides", "encodeations", "encoding", "encodeding", "encodingions", "ecoders", "ecodors", "encodedions", "encodands", "ecodands", "enccodations", "encodations", "encodedors", "eccodrings", "encordings", "encodeders"], "data": ["base", "feed", "extra", "la", "parent", "dat", "dd", "config", "database", "body", "window", "valid", "package", "results", "media", "DATA", " DATA", "buffer", "len", "all", "ata", "zip", "raw", "three", "Data", "bytes", "pad", "multi", "response", "str", "empty", "devices", "result", "after", "input", "temp", "batch", "xxx", "zero", "pos", "none", "start", "memory", "new", "api", "board", "sample", "cache", "next"], "pkt_data": ["pkt2size", "pwk_data", "pkt_off", "pwk_body", "pkt2break", "packet_value", "packet_break", "pkt_align", "pwk_size", "pkt_cache", "pkt_dat", "packet_off", "pkt_batch", "pkt_done", "packet_dat", "pwk_cache", "pkg_batch", "packet_done", "pkt_break", "pkt_size", "pkt_body", "packet_bin", "pkg_size", "pkt2off", "packet_body", "pkt2data", "packet_start", "packet_data", "packet_size", "pkt_start", "pkg_data", "pkt_value", "packet_align", "pkt_bin"], "olen": ["serv", "ien", "kn", "less", "nn", "osen", "loss", "oln", "skip", "ellen", "non", "normal", "unit", "legal", "ole", "ele", "valid", "regon", "fin", "lov", "linger", "lim", "foo", "mn", "lins", " len", "sle", "sol", "oven", "numbered", "sid", "liv", "lif", "eno", "len", "olo", "oren", "lo", "what", "little", "won", "broken", "nil", "oin", "temp", " unused", "eni", "lvl", "where", "ln", "oo", "ken", "lost", " leftover", "eden", "uno", "le", "slot"]}}
{"project": "FFmpeg", "commit_id": "63b1866ae1e19ff0d694746a84e2eac859cda462", "target": 0, "func": "static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_coefs; i++) {\n\n        int e;\n\n        int v = abs(coef[i]);\n\n        if (v == 0)\n\n            e = 24;\n\n        else {\n\n            e = 23 - av_log2(v);\n\n            if (e >= 24) {\n\n                e = 24;\n\n                coef[i] = 0;\n\n            }\n\n            av_assert2(e >= 0);\n\n        }\n\n        exp[i] = e;\n\n    }\n\n}\n", "idx": 5281, "substitutes": {"coef": ["COff", "koec", "COf", "codeef", "codeaf", "Coff", "COef", "cof", "Cof", "Coeff", "koeff", "Coef", " coeff", "coff", " coff", "Coefficient", "codeeff", " coefficient", "coec", "koaf", "koef", "COeff", " coaf", "codeefficient", "coefficient", "Coec", " cof", " coec", "coaf", "coeff", "Coaf"], "nb_coefs": ["nb_COefes", "nb_coEFes", "nb_crossefn", "nb_coEFp", "nb_coefficientssets", "nb_coevn", "nb_coefsets", "nb_crossefficientsn", "nb_crossefp", "nb_crossefs", "nb_coeffes", "nb_coevp", "nb_coefp", "nb_crossefsets", "nb_COEFp", "nb_coefes", "nb_COefs", "nb_COefn", "nb_coeffn", "nb_COEFn", "nb_coecn", "nb_coefficientsp", "nb_coeffsets", "nb_crossefficientsp", "nb_coecp", "nb_crossefficientssets", "nb_crossefficientss", "nb_coevs", "nb_COEFes", "nb_coefficientss", "nb_coEFs", "nb_COEFs", "nb_coEFn", "nb_coecs", "nb_coeves", "nb_coecsets", "nb_coefn", "nb_coefficientsn", "nb_coeffp", "nb_coeffs", "nb_COefp"], "i": ["gi", "o", "ei", "ti", "v", "id", "I", "is", "di", "s", "ci", "ni", "x", "b", "si", "io", "xi", "ri", "bi", "m", "qi", "ix", "l", "key", "f", "pi", "j", "ii", "d", "iu", "esi", "ai", "u", "uri", "ori", "t", "n", "multi", "mi", "ini", "ie", "p", "h", "eni", "z", "oi", "hi", "c", "ip", "y", "api", "li", "fi", "index", "r", "zi", "mu", "ui"], "e": ["o", "er", "ei", "ea", "v", "el", "s", "x", "pe", "ae", "m", "ace", "l", "de", "f", "ue", "d", "j", "esi", "ve", "fe", "ce", "u", "eb", "ev", "E", "oe", "se", "en", "je", "n", "ie", "ee", "p", "ne", "ec", "be", "h", "z", "ge", "c", "g", "ke", "y", "element", "ed", "es", "r", "ze", "diff", "le"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void vhost_log_stop(MemoryListener *listener,\n\n                           MemoryRegionSection *section)\n\n{\n\n    /* FIXME: implement */\n\n}\n", "idx": 5283, "substitutes": {"listener": ["linenser", "laterver", "latener", "listeners", "linerver", "latenser", "lateners", "literver", "listerver", "liteners", "litenser", "linener", "listenser", "litener", "lineners"], "section": ["sub", "plugin", "option", "writer", "area", "sec", "except", "entry", "channel", "sect", "environment", "or", "region", "sections", "sector", "child", "server", "vision", "part", " Section", "connection", "division", "sea", "ECTION", "Section", "ment", "protection"]}}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n", "idx": 5298, "substitutes": {"drc": ["lRC", "drec", "brc", "lsrc", "dsrc", "dRC", "bRC", "bsrc", "fpc", "tRC", "lrc", " dsrc", " dpc", "lrec", "trec", "tpc", "frc", "dpc", "fRC", "frec", "trc", "fsrc", " dRC", " drec", "brec"], "hp_action": ["HP_index", "HP_action", "hpfid", "HP_act", "hpfindex", "hp_index", "hp_id", "HP_id", "hpfaction", "hpfact", "hp_act"], "new_hp": ["new_bh", "new___bh", "NEW_hp", "new67gp", "old_gp", "finalFht", "newJhp", "old_hp", "newFgp", "new_hw", "NEW_bh", "new_hap", "newJgp", "new_gp", "NEW_cp", "new___hw", "NEW_hap", "old_cpp", "newFmph", "new_mph", "finalFhp", "new_hy", " new_hop", "final_mph", "final_hp", "newFhp", "new_ht", "final_gp", "newFht", "new67cp", " new_cp", "finalFmph", "new_cpp", "new_ih", "finalFgp", "newJcp", "old_ih", " new_hy", "new___hp", "new___hap", "new_hop", " new_gp", "new_cp", "new_wp", "new67hp", "old_cp", "old_hop", " new_wp", "new67hy", "NEW_gp", "final_ht", "NEW_hw"], "hdr": ["hmdr", " hDR", "hstr", "hmirt", "ahdu", "ohrid", "Hride", "ohder", "bhstr", "hirt", "shride", "enhDR", "dhrid", "ohdr", "hmstr", "hder", "hrt", "hgr", "ghdu", "Hbr", "thdu", "phDR", "shint", "ghder", "bhdr", "chmt", "hhDR", "shDR", "hhrs", "thstr", "shrc", "hrc", " hrt", "hbr", "Hint", " hrs", "shdr", "hegr", "ahder", "shirt", "dhdr", "hride", "ghint", "dhgr", "heder", "ohgr", "dhder", " hrid", "hhbr", "Hrs", "qrid", "hmt", "ghstr", "ahdr", "hrs", "enhdr", "HDR", "hrid", "adhrid", " hint", "phrid", "hrint", "ghirt", "adhDR", "bhirt", "hdu", "hedr", " hmt", "chint", "hhdr", "ghrt", " hirt", "qdr", "enhmt", " hstr", " hbr", "hint", "chdr", "ghdr", "thder", "Hrc", "enhrid", "qmt", "shrid", "shrt", "phrt", "phdr", "adhdr", "Hdr", "hrrc", "chrid", "qint", "hrdr", "hDR", "ahstr", "thdr", "herid", "hrride", "adhmt"], "v6hdr": ["v0hdr", "v6hver", "v6hmrt", "v3bhct", "v6thdr", "v0hld", "v6hydr", "v3bhrid", "v6phr", "v6hlld", "v3hct", "v6hrt", "v8hint", "v6hmr", "v8wver", "v16hDR", "v0hrt", "v6shver", "v6chDR", "v6bhhr", "v6shint", "v8host", "v16hmDR", "v6bhrr", "v16hmhr", "v6phhr", "v6hld", "v6shost", "v6bhld", "v6wint", "v6bhct", "v8wost", "v6hyint", "v6hr", "v6hlrt", "v6bhdr", "v16hhr", "v6hrid", "v16hmr", "v6bhrt", "v3bhdr", "v6hhr", "v6phdr", "v6hldr", "v6hint", "v0hrr", "v6hlrr", "v6thDR", "v6wdr", "v3hDR", "v6hmhr", "v3hrid", "v6hct", "v16hr", "v6chdr", "v6hmrr", "v0hmld", "v6shdr", "v6chct", "v6phDR", "v6bhr", "v8wdr", "v6hrr", "v6thrid", "v6wver", "v8hver", "v6hyver", "v6host", "v6wost", "v0hmdr", "v8hdr", "v6bhrid", "v16hmdr", "v6hmld", "v6hmdr", "v6chrid", "v0hmrr", "v6hmDR", "v6bhDR", "v6hyost", "v3hdr", "v16hdr", "v0hmrt", "v6hDR", "v8wint", "v6thct", "v3bhDR"], "maina": ["Mainaa", "mainc", "minaa", "masteras", " mainc", "minA", " maine", "masteraa", " mainaa", "minas", "mainaa", " mainA", "mainA", "masterb", "minb", "mastera", "masteri", " mainas", "masterc", "Mainb", "maine", "maini", "mastere", "mini", "MainA", "mainas", "mine", "Maina", "Mainc", "mina", " maini"], "mainb": ["primaryb", "Mainbody", "mainobject", "minobject", "defaultc", "centralf", " mainc", "westab", "centralb", "centrala", "defaultb", "minb", " mainobject", "primarya", " maink", " mainbad", "mainas", "mine", "mainf", " mainbody", "Mainc", " mainbar", "publicback", "publick", "minB", " maine", " mainba", "westa", "Mainbar", "masterb", "donbad", "mastera", " mainab", "publicb", "sideobject", "dateas", "Mainb", "maine", "defaulta", "sidebe", "sideb", "primaryas", "Mainab", "primaryba", "mina", "weste", "donk", "donback", "mainB", "masterab", "mainc", "dateb", "centralk", "mainbar", "mainbe", "masterB", "donb", "sidea", "defaultbody", "publicbad", "minbar", "westb", "mainbody", "Mainas", "minbe", "mainba", "mainback", "mink", "masterbar", "maink", " mainB", "minf", "minab", "centralba", "dateba", " mainf", "mainbad", "minba", "mainab", "datea", "Maina", " mainbe", "Mainba", " mainback"], "hp": ["cp", "health", "gp", "hw", "hap", "bp", "imp", "HP", "phy", "pai", "ih", "config", "drm", "dh", "xp", "wm", "ssh", "wp", "lp", "rh", "him", "php", "prot", "cli", "ph", "hs", "np", "hm", "dp", "hh", "hl", "jp", "fp", "hop", "p", "h", "vp", "hy", "ht", "mph", "ip", "ssl", "tp", "adj", "ha", "cpp", "bh", "pkg"], "drck": ["rq", "drcc", "prk", "hrk", "drq", "hrq", "hrcc", " drq", "DRcc", "rck", "hrke", "DRke", " drcc", "DRck", "hrck", " drack", "hrack", "prke", "drk", "rcc", "drack", "prcc", "prck", "DRk", "rack", "drke"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,\n\n                               TCGMemOp s_bits, int which)\n\n{\n\n    const TCGReg r0 = TCG_REG_O0;\n\n    const TCGReg r1 = TCG_REG_O1;\n\n    const TCGReg r2 = TCG_REG_O2;\n\n    int tlb_ofs;\n\n\n\n    /* Shift the page number down.  */\n\n    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);\n\n\n\n    /* Mask out the page offset, except for the required alignment.  */\n\n    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n", "idx": 5304, "substitutes": {"s": ["groups", "stat", "sets", "sf", "v", "is", "S", "a", "http", "spec", "sg", "session", "b", "socket", "si", "i", "sync", "rows", "sys", "ses", "services", "m", "ions", "support", "states", "info", "xs", "l", "f", "client", "details", "ns", "private", "d", "server", "stats", "us", "cs", "conf", "u", "native", "e", "w", "sb", "gs", "secondary", "t", "qs", "ds", "ctx", "n", "self", "p", "settings", "h", "fs", "c", "g", "ssl", "sq", "sym", "site", "current", "r", "js"], "addr": ["address", "dr", "name", "cmp", "layer", "host", "reg", "arm", "rt", "spec", "sg", "config", "Address", "x", "data", "rc", "slice", "xp", "alias", "ace", "mac", "offset", "add", "nr", "ack", "align", "sid", "ar", "ctx", "rx", "nil", "seq", "p", "amp", "asm", "usr", "ptr", "flags", "pointer", "proc", "class", "type", "amd", "ord", "sample", "arch", "ref", "rs", "src", "conn", "pkg", "Error", "size"], "mem_index": ["Mem_Index", "mem_position", "mem_mask", "mem_Index", "mem_slice", "memfIndex", " mem_mask", "memfindex", "memingindex", "Mem_position", "Mem_index", " mem_slice", "memingmask", "memfposition", "memingslice"], "s_bits": ["S_bits", "s2bits", "s5bytes", "num_bytes", "s2flags", "s5length", "s2BIT", "S_BIT", "s5bits", "s_length", "S_bit", "S_flags", "s_flags", "num_length", "s_BIT", "s2bit", "num_bits", "s_bytes", "s_bit", "s_lins", "num_lins", "s5lins"], "which": ["est", "extra", "spec", "config", "rc", "dest", "loc", "mac", "num", "how", " rc", "version", " how", "func", "port", "ctx", " mode", "hift", " unused", "asm", "where", "supp", "proc", "who", "desc", "test", "src", "mode", "shift"], "tlb_ofs": ["tlb_ifp", "tlb_Ofb", "tlb_ifs", "tlb_offs", "tlb_ofn", "tlb_lengths", "tlb_offts", "tlb_offhs", "tlb_OFs", "tlb_ofi", "tlb_lengthd", "tlb_lengthb", "tlb__ofc", "tlb_Ofn", "tlb_effds", "tlb_offds", "tlb_nots", "tlb_lengthts", "tlb_lengthc", "tlb_notits", "tlb__ofd", "tlb_ofp", "tlb_ofds", "tlb_lengthits", "tlb_Ofds", "tlb_OFd", "tlb_effb", "tlb_ofb", "tlb_effs", "tlb_lengthn", "tlb_Ofd", "tlb_Ofc", "tlb_lengthp", "tlb_effhs", "tlb_ifd", "tlb_Ofhs", "tlb__ofs", "tlb_OFb", "tlb_notds", "tlb_offp", "tlb_ofhs", "tlb_offd", "tlb_notts", "tlb__ofb", "tlb_ofits", "tlb_Ofi", "tlb_notd", "tlb_Ofs", "tlb_lengthds", "tlb_notp", "tlb_offb", "tlb_ofd", "tlb_OFds", "tlb_ifts", "tlb_ofts", "tlb_ofc", "tlb_lengthi"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5306, "substitutes": {"curl": [" cur", "Cur", "cURL", "crawl", "CURL", "Crawl", "acURL", "acur", "Curl", "cur", "acurl", " cURL", "acrawl", " crawl"], "fd": ["function", "fen", "feed", "sf", "fw", "md", " FD", "bd", "dd", "dial", "pd", "socket", "data", "pipe", "ad", "stream", "fed", "fax", "fff", "fx", "fb", "db", " sd", "null", "f", "d", "fl", "flo", "fe", "director", "wd", "driver", "func", "dc", "ds", "df", "sd", "fn", "xd", "fp", "cb", "exec", "FD", "nil", " d", "fa", " fid", "fm", "draft", "pointer", "fun", "ld", "ln", "cond", "fs", "handler", "dt", "dl", "fc", "cf", "fi", "nd", "cd"], "action": ["function", "base", "ACTION", "name", "act", "id", "change", "method", "ception", "effect", "sort", "channel", "Action", "val", "data", "i", "style", "ction", "ix", "event", "call", "version", "url", "args", "active", "actions", "error", "what", "func", "path", "sign", "timeout", "xxx", "ault", "filter", "step", "operation", "direction", " act", "type", "class", "handler", "activity", "index", "view"], "s": ["o", "WS", "sf", "v", "S", "sit", "http", "sg", "sw", "socket", "si", "sn", "i", "sync", "sys", "services", "in", "status", "l", "null", "f", "side", "ns", "server", "sl", "d", "ls", "ss", "u", "e", "sb", "w", "t", "sd", "n", "ds", "su", "p", "south", "sv", "fs", "none", "sa", "c", "ssl", "sym", "set", "size"], "sp": ["std", "P", "sf", "sw", "si", "SP", "cl", "pc", " p", "fe", "ss", "e", "sh", "sc", "w", "ds", "ctx", "fp", "p", "amp", "sv", "ptr", "fs", "proc", "ip", "page", "resp", "ps"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)\n\n{\n\n#if defined(HAVE_MMX2) || defined(HAVE_MMX)\n\n    if(c->flags & SWS_CPU_CAPS_MMX2){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX2;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX2;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX2;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX2;\n\n\t}\n\n    }\n\n    if(c->flags & SWS_CPU_CAPS_MMX){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX;\n\n\t}\n\n    }\n\n#endif\n\n#ifdef HAVE_MLIB\n\n    {\n\n\tSwsFunc t= yuv2rgb_init_mlib(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n#ifdef HAVE_ALTIVEC\n\n    if (c->flags & SWS_CPU_CAPS_ALTIVEC)\n\n    {\n\n\tSwsFunc t = yuv2rgb_init_altivec(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n\n\n    av_log(c, AV_LOG_WARNING, \"No accelerated colorspace conversion found\\n\");\n\n\n\n    switch(c->dstFormat){\n\n    case PIX_FMT_BGR32:\n\n    case PIX_FMT_RGB32: return yuv2rgb_c_32;\n\n    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;\n\n    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;\n\n    case PIX_FMT_RGB565:\n\n    case PIX_FMT_BGR565:\n\n    case PIX_FMT_RGB555:\n\n    case PIX_FMT_BGR555: return yuv2rgb_c_16;\n\n    case PIX_FMT_RGB8:\n\n    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;\n\n    case PIX_FMT_RGB4:\n\n    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;\n\n    case PIX_FMT_RGB4_BYTE:\n\n    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;\n\n    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;\n\n    default:\n\n    \tassert(0);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 5308, "substitutes": {"c": ["cp", "ch", "cr", "v", "cur", "s", "ci", "config", "b", "nc", "rc", "x", "com", "cy", "cat", "C", "uc", "m", "l", "cl", "f", "call", "d", "pc", "cc", "cs", "ce", "u", "conf", "center", "e", "mc", "con", "sc", "cont", "cam", "dc", "t", "n", "ctx", "wcs", "bc", "cu", "cb", "k", "self", "exec", "p", "context", "ec", "ca", "h", "g", "ct", "lc", "cf", "cv", "ac", "vc", "cache", "cod", "cm"]}}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n", "idx": 5314, "substitutes": {"vs": ["fg", "views", "verts", "vr", "posts", "vg", "v", "http", "vm", "docs", "s", "alls", "plugins", "va", "values", "vt", "ums", "VS", "wp", "ses", "vas", "services", "obs", "sts", "vals", "sk", "pg", "ns", "state", "stats", "ls", "ports", "bs", "ss", "cs", "net", "sb", "gs", "ks", "ds", "qs", "ts", "oss", "ils", "self", "eps", "vers", "vp", "sv", "Vs", "fs", "ves", "var", "ys", "changes", "utils", "ms", "lv", "ov", "blogs", "env", "cv", "vc", "es", "rs", "versions", "events", "lines", "ps", "flags"], "mode": ["address", "option", "MODE", "name", "dm", "id", "md", "method", "vm", "scope", "Mode", "device", "language", "username", "value", "op", "object", "password", "alias", "module", "m", "map", "status", "route", "key", "de", "project", "mp", "state", "nm", "grade", "mod", "version", "operator", "member", "purpose", "size", "kind", "cmd", "path", "me", "source", "scale", "prop", "mr", "direction", "node", "rule", "slave", "mm", "type", "ms", "move", "manager", "ui", "role"], "mn": ["ml", "nor", "na", "dm", "ann", "md", "nn", "dn", "vm", "pin", "wm", "bm", "m", "rm", "pm", "mp", "ns", "nm", "Mi", "man", "mc", "MN", "mis", "fn", "n", "ains", "mi", "mb", "misc", "fm", "mr", "ln", "mm", "ms", "mx", "cn", "MC", "gn", "cm", "mins"], "vd": ["nv", "vg", "od", "md", "bd", "dn", "vid", "dd", "va", "vt", "pd", "eddy", "uv", "dk", "hov", "adder", "uds", "vision", "wd", "sd", "xd", "ant", "sv", "ld", "gd", "lv", "fd", "dl", "vv", "ud", "cv", "vc", "VD", "hd", "nd"], "num_exclusive": ["num_clusive", "max_external", "number_exclusive", "numAllexclusive", "number_sharing", "numAllshared", "number_clusive", "max_clusive", "numAllsharing", "num_external", "num_seconds", "numwseconds", "max_exclusive", "numwclusive", "numwexclusive", "numAllclusive", "number_shared", "num_shared", "numwexternal", "max_seconds", "num_sharing"]}}
{"project": "FFmpeg", "commit_id": "7cc8d616aab68ba5534e5a74214786ad08aac5ce", "target": 1, "func": "uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)\n\n{\n\n    uint32_t scratch = 0;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n\n\n    for (; buf < buf_end - 3; buf += 4)\n\n        scratch ^= *((const uint32_t*)buf);\n\n\n\n    scratch = xor_32_to_8(scratch);\n\n\n\n    for (; buf < buf_end; buf++)\n\n\n\n\n    return scratch;\n\n}", "idx": 5327, "substitutes": {"buf": ["cp", "cmp", "fam", "feed", "buff", "vec", "block", "fw", "cur", "count", "rb", "config", "plug", "b", "rc", "data", "home", "wa", "queue", "uc", "loc", "fb", "wb", "uf", "num", "offset", "f", "length", "av", "tab", "bb", "buffer", "bag", "port", "func", "cmd", "fac", "ab", "cb", "fp", "bc", "feat", "seq", "begin", "pub", "batch", "usr", "ptr", "alloc", "pos", "proc", "cap", "off", "ul", "bf", "fd", "cf", "br", "um", "cv", "src", "img", "bh", "shift", "ff", "af"], "buf_size": ["buf0size", "buf_name", "buffer_center", "buf0end", "buflenend", "queue_end", "buflencenter", "buf_center", "buffer_end", "queue_size", "queue_name", "buffer_size", "buflensize", "buf0name"], "buf_end": ["buf0size", " buf_ending", "buf0ending", "buf0end", " buf0size", "buf_ends", "buf2start", "uf_End", "buf_last", "cap_start", " buf0ending", "bufsend", "uf_last", "bufllast", "buf2end", "bufsEnd", "buflend", "buf2ending", "buf0start", "cap_ends", "bufsstart", "cap_end", "buf_ending", " buf_start", " buf0start", "bufslast", "uf_start", "buf_stop", "cap_stop", "buflstart", " buf0end", "buf_start", "buf_End", "uf_end", "buf2size", "buflEnd"]}}
{"project": "FFmpeg", "commit_id": "f354f30836a3148275ce60d19bbc581310249ad2", "target": 0, "func": "void ff_er_frame_start(ERContext *s)\n\n{\n\n    if (!s->avctx->err_recognition)\n\n        return;\n\n\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n\n    s->error_count    = 3 * s->mb_num;\n\n    s->error_occurred = 0;\n\n}\n", "idx": 5353, "substitutes": {"s": ["stat", "o", "ans", "sets", "sf", "rates", "v", "ins", "is", "S", "comm", "a", "sg", "als", "comments", "data", "sync", "i", "sys", "ses", "services", "m", "in", "details", "l", "f", "ns", "d", "ls", "ss", "cs", "hs", "e", "sb", "gs", "ks", "ops", "ds", "qs", "t", "ctx", "n", "ts", "self", "p", "settings", "fs", "c", "os", "new", "ssl", "sq", "sym", "ms", "g", "es", "rs", "lines", "ps", "js"]}}
{"project": "FFmpeg", "commit_id": "f98c9fb27de84dc4f6123537b754eb2fe1a80c02", "target": 0, "func": "av_cold int MPV_common_init(MpegEncContext *s)\n\n{\n\n    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads;\n\n\n\n    if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n\n        s->mb_height = (s->height + 31) / 32 * 2;\n\n    else if (s->codec_id != CODEC_ID_H264)\n\n        s->mb_height = (s->height + 15) / 16;\n\n\n\n    if(s->avctx->pix_fmt == PIX_FMT_NONE){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"decoding to PIX_FMT_NONE is not supported.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&\n\n       (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx))\n\n        return -1;\n\n\n\n    dsputil_init(&s->dsp, s->avctx);\n\n    ff_dct_common_init(s);\n\n\n\n    s->flags= s->avctx->flags;\n\n    s->flags2= s->avctx->flags2;\n\n\n\n    if (s->width && s->height) {\n\n        s->mb_width  = (s->width  + 15) / 16;\n\n        s->mb_stride = s->mb_width + 1;\n\n        s->b8_stride = s->mb_width*2 + 1;\n\n        s->b4_stride = s->mb_width*4 + 1;\n\n        mb_array_size= s->mb_height * s->mb_stride;\n\n        mv_table_size= (s->mb_height+2) * s->mb_stride + 1;\n\n\n\n        /* set chroma shifts */\n\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift),\n\n                                      &(s->chroma_y_shift) );\n\n\n\n        /* set default edge pos, will be overriden in decode_header if needed */\n\n        s->h_edge_pos= s->mb_width*16;\n\n        s->v_edge_pos= s->mb_height*16;\n\n\n\n        s->mb_num = s->mb_width * s->mb_height;\n\n\n\n        s->block_wrap[0]=\n\n        s->block_wrap[1]=\n\n        s->block_wrap[2]=\n\n        s->block_wrap[3]= s->b8_stride;\n\n        s->block_wrap[4]=\n\n        s->block_wrap[5]= s->mb_stride;\n\n\n\n        y_size = s->b8_stride * (2 * s->mb_height + 1);\n\n        c_size = s->mb_stride * (s->mb_height + 1);\n\n        yc_size = y_size + 2 * c_size;\n\n\n\n        /* convert fourcc to upper case */\n\n        s->codec_tag = ff_toupper4(s->avctx->codec_tag);\n\n\n\n        s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);\n\n\n\n        s->avctx->coded_frame= (AVFrame*)&s->current_picture;\n\n\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this\n\n        for(y=0; y<s->mb_height; y++){\n\n            for(x=0; x<s->mb_width; x++){\n\n                s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride;\n\n            }\n\n        }\n\n        s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n\n\n\n        if (s->encoding) {\n\n            /* Allocate MV tables */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n\n            s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n\n            s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n\n            s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n\n            s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n\n            s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n\n\n\n            if(s->msmpeg4_version){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);\n\n            }\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail);\n\n\n\n            /* Allocate MB type table */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n\n\n            if(s->avctx->noise_reduction){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)\n\n            }\n\n        }\n\n    }\n\n\n\n    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail)\n\n    for(i = 0; i < s->picture_count; i++) {\n\n        avcodec_get_frame_defaults((AVFrame *)&s->picture[i]);\n\n    }\n\n\n\n    if (s->width && s->height) {\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)\n\n\n\n        if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n\n            /* interlaced direct mode decoding tables */\n\n            for(i=0; i<2; i++){\n\n                int j, k;\n\n                for(j=0; j<2; j++){\n\n                    for(k=0; k<2; k++){\n\n                        FF_ALLOCZ_OR_GOTO(s->avctx,    s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                        s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1;\n\n                    }\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                    s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1;\n\n                }\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n            }\n\n        }\n\n        if (s->out_format == FMT_H263) {\n\n            /* cbp values */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);\n\n            s->coded_block= s->coded_block_base + s->b8_stride + 1;\n\n\n\n            /* cbp, ac_pred, pred_dir */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)\n\n        }\n\n\n\n        if (s->h263_pred || s->h263_plus || !s->encoding) {\n\n            /* dc values */\n\n            //MN: we need these for error resilience of intra-frames\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n\n            s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;\n\n            s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;\n\n            s->dc_val[2] = s->dc_val[1] + c_size;\n\n            for(i=0;i<yc_size;i++)\n\n                s->dc_val_base[i] = 1024;\n\n        }\n\n\n\n        /* which mb is a intra block */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n\n        memset(s->mbintra_table, 1, mb_array_size);\n\n\n\n        /* init macroblock skip table */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);\n\n        //Note the +1 is for a quicker mpeg4 slice_end detection\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);\n\n\n\n        s->parse_context.state= -1;\n\n        if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){\n\n            s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n        }\n\n    }\n\n\n\n    s->context_initialized = 1;\n\n    s->thread_context[0]= s;\n\n\n\n    if (s->width && s->height) {\n\n    if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {\n\n        threads = s->avctx->thread_count;\n\n\n\n        for(i=1; i<threads; i++){\n\n            s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n\n            memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n\n        }\n\n\n\n        for(i=0; i<threads; i++){\n\n            if(init_duplicate_context(s->thread_context[i], s) < 0)\n\n                goto fail;\n\n            s->thread_context[i]->start_mb_y= (s->mb_height*(i  ) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n            s->thread_context[i]->end_mb_y  = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n        }\n\n    } else {\n\n        if(init_duplicate_context(s, s) < 0) goto fail;\n\n        s->start_mb_y = 0;\n\n        s->end_mb_y   = s->mb_height;\n\n    }\n\n    }\n\n\n\n    return 0;\n\n fail:\n\n    MPV_common_end(s);\n\n    return -1;\n\n}\n", "idx": 5356, "substitutes": {"s": ["sf", "S", "a", "features", "b", "results", "f", "parts", "d", "service", "hs", "conf", "sports", "w", "self", "h", "aws", "g", "sym", "sets", "sites", "is", "spec", "sum", "services", "its", "states", "ls", "cons", "ops", "bis", "ds", "ts", "settings", "fs", "new", "sq", "ms", "site", "rs", "uses", "as", "ans", "ins", "sg", "sync", "ses", "cs", "u", "vs", "e", "sb", "ks", "qs", "t", "tests", "p", "c", "os", "ssl", "ims", "r", "ps", "o", "session", "words", "si", "sys", "m", "l", "xs", "ns", "stats", "args", "us", "ss", "uns", "gs", "full", "n", "su", "this", "params", "es", "js"], "y_size": ["y6small", "c6small", "y_small", "y_speed", "y6size", "c_small", "c6size", "c_speed", "c6speed", "y6speed"], "c_size": ["c_shape", "c_offset", "ct7size", "cwloffset", "cwllength", "c7length", "c7shape", "c7offset", "ct7offset", "c_length", "ct_length", "cwlsize", "ct_size", "cwlshape", "ct_shape", "ct_offset", "c7size", "ct7length", "ct7shape"], "yc_size": ["yc_small", "yl_small", "yc_capacity", "yl_capacity", "yl_size", "yl_speed", "yc_speed"], "i": ["axis", "v", "id", "I", "ci", "b", "io", "slice", "si", "m", "in", "f", "pi", "ii", "d", "u", "e", "t", "n", "p", "h", "z", "c", "ip", "index"], "mb_array_size": ["mb_array_capacity", "mb_array_empty", "mb_table_scale", "mb_table_capacity", "mb_table_size", "mb_table_empty", "mb_array_scale"], "mv_table_size": ["mv_table_small", "mv_table0shape", "mv_table0capacity", "mv_col_capacity", "mv_table0width", "mv_table___capacity", "mv_thread_len", "mv_col_size", "mv_thread_size", "mv_thread___small", "mv_thread___size", "mv_thread___capacity", "mv_table___size", "mv_table__shape", "mv_table_capacity", "mv_table_len", "mv_col_width", "mv_col__width", "mv_table__capacity", "mv_table_shape", "mv_table__size", "mv_thread_capacity", "mv_table__width", "mv_col_shape", "mv_col__size", "mv_table_width", "mv_thread_small", "mv_table0size", "mv_col__shape", "mv_table___len", "mv_table___small", "mv_col__capacity", "mv_thread___len"], "x": ["time", "id", "ex", "data", "pixel", "slice", "m", "image", "dx", "xy", "xs", "f", "d", "w", "n", "ctx", "rx", "height", "p", "z", "c", "X", "index", "size"], "y": ["yy", "dy", "o", "v", "Y", "b", "m", "f", "d", "e", "w", "t", "n", "height", "vy", "p", "temp", "h", "z", "c", "g", "type", " dy", "size"], "threads": ["streams", "rounds", "threadls", "threadCount", "streamnum", "colls", "cols", "streamCount", "colnum", "roundnum", "colCount", "roundCount", "streamls", "roundls", "threadnum"]}}
{"project": "FFmpeg", "commit_id": "03847eb8259291b4ff1bd840bd779d0699d71f96", "target": 0, "func": "int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\n\n                          const char *filename, void *logctx,\n\n                          unsigned int offset, unsigned int max_probe_size)\n\n{\n\n    AVProbeData pd = { filename ? filename : \"\", NULL, -offset };\n\n    unsigned char *buf = NULL;\n\n    int ret = 0, probe_size;\n\n\n\n    if (!max_probe_size) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size > PROBE_BUF_MAX) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size < PROBE_BUF_MIN) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (offset >= max_probe_size) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;\n\n        probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {\n\n        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\n\n        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\n\n        void *buftmp;\n\n\n\n        if (probe_size < offset) {\n\n            continue;\n\n        }\n\n\n\n        /* read probe data */\n\n        buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n\n        if(!buftmp){\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        buf=buftmp;\n\n        if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n\n            /* fail if error was not end of file, otherwise, lower score */\n\n            if (ret != AVERROR_EOF) {\n\n                av_free(buf);\n\n                return ret;\n\n            }\n\n            score = 0;\n\n            ret = 0;            /* error was end of file, nothing read */\n\n        }\n\n        pd.buf_size += ret;\n\n        pd.buf = &buf[offset];\n\n\n\n        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n\n\n\n        /* guess file format */\n\n        *fmt = av_probe_input_format2(&pd, 1, &score);\n\n        if(*fmt){\n\n            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration\n\n                av_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n\n            }else\n\n                av_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n\n        }\n\n    }\n\n\n\n    if (!*fmt) {\n\n        av_free(buf);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* rewind. reuse probe buffer to avoid seeking */\n\n    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);\n\n\n\n    return ret;\n\n}\n", "idx": 5357, "substitutes": {"pb": ["bp", "lb", "platform", "pa", "rb", "pd", "wp", "bm", "lp", "fb", "db", "uf", "pm", "wb", "pg", "client", "abb", "pc", "xb", "dp", "sb", "ctx", "ab", "PB", "fp", "bc", "cb", "p", "vp", "apy", "ppa", "bf", "api", "tp", "fc", "pl", "rob", "cpp", "bh", "pkg", "tc"], "fmt": [" fMT", "fnt", "sfformat", "fformat", "Fformat", "cfmt", "fMT", " fnt", "Fnt", "cfMT", "sfMT", "Fmt", "sfmt", "Frt", "cfrt", "frt", "FMT", " frt", "sfnt", " fformat", "cfformat"], "filename": ["name", "files", "header", "open", "method", "word", "rb", "username", "format", "tty", "title", "wb", "null", "f", "attr", "url", "metadata", "length", "enabled", "document", "which", "buffer", "fil", "size", "file", "brush", "fn", "binary", "directory", "jpg", "path", "fp", "dll", "nil", "wav", "kl", "txt", "fd", "utf", "phrase", "Filename", "xff", "prefix"], "logctx": ["debugprefix", "catkb", "debugfn", "logkb", "logprefix", "debugctx", "catctx", "catprefix", "evkb", "catfn", "logfn", "debugkb", "evfn", "evprefix", "evctx"], "offset": ["base", "address", "name", "layer", "area", "position", "padding", "origin", "reset", "o", "alpha", "fee", "skip", "op", "alias", "i", "format", "optional", "Offset", "phase", "loc", "order", "limit", "length", "align", "number", "part", "len", "size", "error", "bound", "timeout", "fp", "prefix", "end", "ptr", "zero", "pos", "pointer", "start", "off", "attribute", "location", "range", "ref", "index", "addr", "mode", "shift", "slot"], "max_probe_size": ["max_prober_width", "max_prove_capacity", "max_prober_storage", "max_prove_size", "max_prober_small", "max_probe_name", "max_probe__size", "max_prober__scale", "max_prober_code", "max_prober_size", "max_probe__scale", "max_prove_scale", "max_probe_num", "max_probe_offset", "max_probe_scale", "max_probe\u00b7name", "max_prober__size", "max_probe_code", "max_probe1small", "max_probe_sized", "max_probe\u00b7storage", "max_probe_storage", "max_probe2size", "max_probe2speed", "max_prober_speed", "max_probe1size", "max_prober_name", "max_probe2storage", "max_probe_width", "max_probe1capacity", "max_probe_capacity", "max_probe_speed", "max_probe__code", "max_prober_scale", "max_probe_small", "max_prober_capacity", "max_probe\u00b7size", "max_prober_offset", "max_prober__code", "max_prove_sized", "max_prove_num"], "buf": ["cp", "fam", "feed", "buff", "vec", "header", "block", "fw", "box", "bd", "uber", "cur", "prof", "Buff", "rb", "tmp", "config", "bg", "fn", "data", "home", "rc", "dest", "queue", "uc", "loc", "fb", "wb", "uf", "ru", "conv", "abb", "img", "buffer", "bag", "Buffer", "port", "func", "cmd", "ctx", "ux", "bc", "fp", "cb", "feat", "result", "seq", "pool", "pub", "output", "font", "batch", "runner", "usr", "prop", "ptr", "alloc", "proc", "cap", "fd", "cf", "br", "comb", "cv", "cache", "fi", "src", "cas", "ctrl", "pkg", "ff", "msg"], "probe_size": ["probe_offset", "procer_storage", "provisionsscale", "prouse_address", "probe_rate", "procel_capacity", "probi\u00b7size", "probe__name", "probe_weight", "prose__size", "provisionssize", "provision_size", "probi_size", "prober_number", "probe_form", "probe_page", "probe_engine", "prober_engine", "prose_size", "prote_name", "probe\u00b7size", "probe__source", "prose_unit", "procel_size", "prose_name", "probe_source", "prob_size", "prouse_scale", "probe_speed", "prote_size", "probe_id", "probe\u00b7shape", "prober_size", "probesscale", "prober_shape", "procel_len", "probe_unit", "probessize", "provisionsize", "procer_ize", "prose__name", "probe\u00b7weight", "prob_scale", "prote_address", "prose__source", "prober_id", "procer_capacity", "probe_len", "probe_capacity", "prose_source", "prose__unit", "probe\u00b7engine", "prob_speed", "probe__size", "provision_scale", "prouse_size", "probe_name", "probe__unit", "prober_offset", "probi\u00b7weight", "procel_source", "procer_size", "procel_weight", "probi_weight", "probe_type", "probesize", "probe_ize", "probi_rate", "prob_form", "probe_number", "procel_speed", "probe_address", "prouse_ize", "probe\u00b7rate", "probe_scale", "probe_shape", "prote_type", "procel_page", "probi\u00b7rate", "probe_storage", "provision_ize"], "buftmp": [" buftcp", "buftcmp", " buftep", " buctyp", "buctep", "buftep", "buctcp", "buftape", "buftap", "bustmp", "buftyp", "fuaftmp", "bufape", "buftcp", "bufortmp", " buftape", "buctyp", "bufcp", "bufortyp", "bufortMP", "buptcmp", "buktcp", "buktyp", "buptmp", "fuaftyp", "buftm", " buctep", "buptcp", "buaftMP", "buaftap", "buctmp", " buctmp", "buctm", "buktape", "buktap", "bufortpl", "fuftMP", "fuaftpl", "fuftmp", "buctape", "buktep", "bufmp", " buftcmp", " buctm", "buktmp", " buctcmp", "buctap", "bustMP", "buktm", " buctape", "buaftmp", "fuftyp", "bustyp", "buktcmp", " buctcp", "fuftpl", " buftm", "buaftep", "buftpl", "buftMP", "bufyp", "buptyp", "fuaftMP", "buctcmp", "buaftyp", "buaftpl", " buftyp", "buaftm", " buctap", "bustpl", " buftap"]}}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 5361, "substitutes": {"s": ["r", "o", "sets", "sites", "is", "S", "http", "less", "spec", "sg", "ins", "session", "b", "si", "sync", "sys", "ses", "services", "m", "states", "l", "xs", "ns", "state", "d", "sl", "stats", "ls", "iss", "service", "us", "ss", "cs", "u", "sis", "e", "sb", "gs", "se", "uns", "full", "ops", "t", "ds", "n", "qs", "ts", "su", "self", "p", "south", "this", "aws", "sv", "fs", "c", "g", "ssl", "sq", "sym", "ims", "y", "site", "es", "rs", "ps", "j", "uses", "js"], "mon": ["pid", "ann", "bin", "mem", "tun", "config", "mid", "mat", "pre", "tom", "non", "Mon", "mo", "module", "m", "unit", "mail", "db", "pm", "emon", "num", "mn", "mer", "sm", "danger", "my", "conf", "man", "mun", "con", "mt", "col", "lo", "en", "den", "conn", "mut", "mag", "mi", "lock", "sun", "mons", "un", "pos", "fun", "ln", "chron", "mm", "sym", "ms", "lin", "type", "month", "MON", "on", "date", "min", "cm", "mode", "mu"], "exported_dir": ["exped_path", "exported_dict", "exped_directory", "exped_mode", "exped_file", "exped_dir", "exported_directory", "exported_path", "exported_file", "exported_mode", "exped_dict"], "vserver_addr": ["vserveraddraddr", "vserveraddrport", "vserver2port", "vserveraddraddress", "vserver2block", "vserveraddrblock", "vserver_block", "vserver2address", "vserver2addr", "vserver_dir", "vserver_address", "vserver2dir", "vserver_port"], "instance": ["master", "ance", "name", "method", "parent", "i", "record", "usage", "fff", "image", "offset", "client", "project", "child", " i", "version", "member", "micro", "error", "section", "inst", "example", "connection", "port", "Instance", "result", "array", "stage", "mode", "node", "thread", "type", "performance", "class", "month", " inst", "index", "trace"], "smb_conf": ["smb_con", "smb_sum", "smbpsum", "samb_sum", "sbb_cmp", "smb__ref", "semb_conf", "smb2Conf", "sbb_conf", "smb_config", "smb_conn", "smb2conf", "smb_dir", "semb_con", "semb__con", "sfb_con", "smb_aff", "smbpconv", "samb_dir", "smbpconf", "sbb_aff", "smb__conf", "smb__dir", "semb_dir", "sbb_con", "semb_ref", "sfb_dir", "smb__aff", "sbb_Conf", "smb_cmp", "smb2conn", "smbpdir", "sbb_conn", "smb__cmp", "semb__conf", "semb__ref", "smb_Conf", "sfb_config", "smb2con", "smb_conv", "smb__con", "samb_conf", "semb__dir", "smb_ref", "smb__Conf", "sfb_def", "samb_conv", "sfb_conf", "smb_def"], "smb_cmdline": ["smb_cmdlin", "smb_shortLine", "smbbcmdlate", "smb_cmdlc", "smb_cmdname", "smb2cmdl", "smb_logl", "smb_msgline", "smb2msgline", "smb_commandLINE", "smb_commandlc", "smb_shortline", "smb_commLINE", "smb_defline", "smb_cmdLINE", "smb_commandl", "smb_logline", "smb_msgLine", "smbbcmdl", "smb_commandLine", "smbbloglate", "smb_cmdstring", "smb_msglate", "smb_cmdlate", "smb_commstring", "smb_deflc", "smb_cmdLine", "smb_commandlin", "smb2msgLine", "smb_cleanline", "smbbcmdline", "smb_commandname", "smb_commandline", "smb_commline", "smbblogl", "smb_commandstring", "smb_cmdl", "smb2msgl", "smb_shortname", "smb_commandlate", "smb_deflin", "smb2msgname", "smb2cmdname", "smb_msgname", "smbblogline", "smb2cmdline", "smb_msgl", "smb_defl", "smb2cmdLine", "smb_loglate", "smb_cleanLINE", "smb_cleanstring", "smb_shortl"], "f": ["fen", "fr", "o", "files", "feed", "sf", "v", "fw", "b", "x", "rf", "i", "info", "m", "fx", "fb", "l", "fu", "d", "j", "fo", "fe", "u", "e", "w", "file", "fn", "t", "df", "xf", "fit", "n", "fp", "of", "fa", "p", "h", "fs", "c", "bf", "g", "fd", "cf", "y", "fc", "fi", "form", "r", "F"]}}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "substitutes": {"env": ["eng", "cfg", "ea", "ep", "kn", "v", "ef", "config", "qt", "environment", "nc", "rc", "exc", "et", "enc", "queue", "eu", "inet", "db", "ext", "gui", "server", "obj", "init", "net", "conf", "ev", "np", "e", "en", "dev", "dc", "ctx", "exec", "ini", "Environment", "context", "ec", "network", "eni", "viron", "console", "global", "proc", "txt", "engine", "loader", "manager", "conn"], "vaddr": ["zaddress", "vadd", "vserver", " vserver", "voffset", "Voffset", " voffset", "vconfig", " vhost", "Vaddr", "zhost", "phost", "wadd", "faddr", "zaddr", " vconfig", "waddr", " vadd", "paddress", "vptr", "foffset", "tvaddr", "pptr", "Vaddress", "pserver", "fdr", "tvconfig", "pconfig", " vdr", "pdr", "qaddress", "tvaddress", "vhost", "zptr", " vaddress", "faddress", "vdr", "qaddr", "Vdr", "padd", "qhost", "qptr", "whost", "tvserver", "vaddress", "fhost", "fptr", "waddress"], "paddr": [" pmode", " poffset", "padded", "pyaddress", "vadd", " palign", "voffset", "vpairs", " voffset", "npaddr", "fadd", " pptr", "pyadded", "fmode", "pmode", "vpoffset", "vpalign", "pyaddr", "vpaddr", "vadded", "pairs", "faddr", "vpaddress", "npoffset", "pyoffset", "vpptr", "paddress", "vptr", "npairs", "valign", "pptr", "npaddress", " vairs", "vmode", " vaddress", "faddress", "palign", "poffset", "padd", " padd", " paddress", "vaddress", " padded"], "prot": ["stat", "fen", "ocol", "reset", "ret", "inf", "phy", "platform", "pro", "eth", " proto", "config", "rot", "rf", "Prot", "typ", "inet", "lit", "conv", "ext", "sil", "thin", "fl", "pri", "cli", "period", "np", "lo", "uri", "bis", "nat", "lat", "rx", "fp", " protocol", "rin", "iol", "prop", "addr", "dim", "prefix"], "mmu_idx": ["mmu_indg", "mmu_indb", "mmu_idf", "mmu_idg", "mmu_indf", "mmu_ridy", "mmu_ridv", "mmu_idy", "mmu_sidy", "mmu_idsxc", "mmu_idv", "mmu_sidv", "mmu_idsx", "mmu_idsy", "mmu_indx", "mmu_sidb", "mmu_idsv", "mmu_sidx", "mmu_sidf", "mmu_sidxc", "mmu_sidg", "mmu_ridx", "mmu_idxc", "mmu_ridxc", "mmu_idb"], "size": ["name", "SIZE", "large", "sec", "count", "fee", "shape", "value", "security", "sum", "data", "password", "sn", "si", "unit", "loc", "capacity", "offset", "limit", "length", "small", "Size", "ffff", "number", "code", "len", "uri", "en", "storage", "sized", "bytes", "empty", "timeout", "scale", "z", "global", "memory", "cap", "c", "class", "page", "desc", "ize", "max"], "p": ["cp", "P", "o", "bp", "python", "v", "pr", "parent", "pa", "pre", "po", "b", "pp", "i", "sync", "pe", "lp", "ap", "l", "pm", "f", "pi", "pg", "d", "j", "pc", "np", "dp", "e", "point", "w", "pn", "t", "n", "fp", "jp", "h", "vp", "sp", "c", "page", "api", "tp", "pb", "r", "ps", "pkg"], "pd": ["pat", "dh", "pins", "pm", "pi", "d", "td", "adh", "sd", "ped", "sha", "ppa", "gd", "dt", "tp", "pb", "mode", "nd", "cd", "plugin", "pid", " dd", "pod", "slice", "pattern", "pe", " rc", "php", "wordpress", "sth", "da", "ds", "xd", "pad", "dra", "ld", "std", "python", "pard", "md", "bd", "vd", "dat", "pa", "po", "pp", " prod", "wa", "lp", "ad", " sd", "att", "pc", "py", "np", "wd", "dp", "lda", "priority", "pos", "dep", "fd", "api", "dl", "dim", " delta", " td", "od", "pr", "dd", "si", "edd", "pg", "delay", " da", "dc", "PD", "hd"], "index": ["base", "position", "bin", "count", "ci", "config", "val", "si", "slice", "pattern", "loc", " indexes", "ion", "length", "pc", "fe", "ffff", "byte", "part", "len", "dc", "pos", "pointer", "type", "Index"], "address": ["area", "position", "entry", "ress", "shape", "Address", "object", "password", "alias", "module", "adjust", "image", "ace", "route", "region", "enter", "resource", "capacity", "package", "offset", "event", "order", "state", "server", "number", "code", "point", "uri", "message", "port", "array", "output", "network", "pointer", "memory", "attribute", "ip", "node", "location", "adr", "pair", "element", "addr", "host", "reference", "prefix"], "code_address": ["cache_number", "cache_reference", "data_address", "code_reference", "codeouthost", "data_addr", "code2address", "code2reference", "codeoutnumber", "code2host", "code_addr", "cache_host", "code_location", "code_number", "code2number", "data_location", "codeoutaddress", "code_host", "cache_address", "codeoutreference"], "addend": ["loadstart", "addstart", "loadending", " addends", " addending", "readest", "readends", "addends", "pushstart", "readend", "addpath", "pushend", "loadend", "addending", "Addends", "Addest", " addstart", "pushending", "Addpath", " addest", "Addend", "pushends", "addest", " addpath", "readpath", "loadends"], "te": ["ep", "inf", "fee", "ite", "ffe", "eu", "de", "ext", "ue", "fe", "ss", "e", "oe", "se", "inst", "tw", "we", "port", "oss", "ee", "ne", "eni", "ta", "slave", "txt", "ette", "pl", "au"], "wp": ["cp", "hp", "plugin", "gp", "hw", "bp", "ep", "fw", "wx", "pp", "op", "pod", "wm", "widget", "wk", "lp", "xp", "wb", "pg", "mp", "php", "arp", "pc", "wordpress", "np", "WP", "dp", "w", "pn", "dc", "ctx", "fp", "jp", "hop", "kw", "iw", "vp", "wu", "ip", "wl", "api", "tp", "pb"], "iotlb": ["iottb", "iottlas", "iotll", "cotlb", "otlas", "youtlp", "ontlp", "iollas", "youtlb", "otlr", "ietlp", "nitrb", "iollab", "iotla", "otrb", "ietlb", "ietb", "ietrb", "iotrb", "iotlab", "bootlas", "iollb", "iotl", "cotl", "otl", "bootlb", "iotlr", "iottlr", "youtl", "otb", "ietlr", "ittlp", "iottlp", "iotlp", "iottlab", "ittl", "nitla", "ittlb", "ietlab", "iottl", "ioll", "otlp", "ietll", "ittll", "iottlb", "ontlb", "nitl", "nitlb", "otlb", "bootl", "ontl", "ontll", "cotlp", "ietla", "iotb", "nitlp", "bootlab", "ietlas", "iotlas", "youtla", "ietl", "cotlas", "otlab"]}}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "func": "void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,\n\n                         const uint32_t *intbit_to_level,\n\n                         qemu_irq **irq, qemu_irq **cpu_irq,\n\n                         unsigned int cputimer)\n\n\n\n{\n\n    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;\n\n    SLAVIO_INTCTLState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->intbit_to_level = intbit_to_level;\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n\tslavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);\n\n\tcpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,\n\n                                     slavio_intctl_io_memory);\n\n    }\n\n\n\n    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);\n\n    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);\n\n\n\n    register_savevm(\"slavio_intctl\", addr, 1, slavio_intctl_save, slavio_intctl_load, s);\n\n    qemu_register_reset(slavio_intctl_reset, s);\n\n    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);\n\n\n\n    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);\n\n    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];\n\n    slavio_intctl_reset(s);\n\n    return s;\n\n}\n", "idx": 5386, "substitutes": {"addr": ["base", "address", "dr", "r", "gate", "afi", "ei", "name", "arm", "id", "device", "config", "Address", "x", "data", "oa", "rc", "nc", "alias", "ad", "ace", "ix", "mac", "offset", "at", "call", "nr", "args", "code", "e", "ar", "cmd", "work", "seq", "p", "sta", "amp", "asm", "eni", "ptr", "pos", "ld", "ip", "node", "g", "c", "mx", "amd", "adr", "ord", "arch", "src", "ref", "index", "host", "ast", "conn", "add"], "addrg": ["aimgp", "addrgi", "addrgp", "ACEG", "addrG", "aimg", "drg", "drgp", "adrgi", "hostG", "adrg", "ACEg", "adrG", "drG", "aimG", "hostg", "addressg", "ACEgp", "addressG", "addressgi", "hostgi"], "intbit_to_level": ["intbit_from_vel", "intbit_from_log", "intbit_to_left", "intbit_to_vel", "intbit_to_layer", "intbit_from_left", "intbit_from_level", "intbit_from_layer", "intbit_to_log"], "irq": ["ierqa", "ireqa", "irv", " irqs", "irqs", " irp", " irv", "irecharge", "arv", "irep", "irquest", "ireq", "ierquest", "irequest", " ircharge", "ireqs", "arp", "irev", " irquest", " irqa", "irp", "arqs", "ierq", "iercharge", "ircharge", "irqa", "arq"], "cpu_irq": ["cpu_arqs", "cpu_iperqs", "cpu_arQ", "cpu_arq", "cpu_iperf", "cpu_IRqs", "cpu_rrqs", "cpu_arf", "cpu_iperq", "cpu_IRf", "cpu_IRq", "cpu_irQ", "cpu_rrq", "cpu_IRQ", "cpu_irqu", "cpu_irf", "cpu_rrqu", "cpu_irquest", "cpu_iperQ", "cpu_irqs", "cpu_IRquest", "cpu_IRqu", "cpu_rrquest"], "cputimer": [" cputim", "cctier", "cptiper", " cPUTer", "cputim", " cputiper", "cperiper", "cctiver", " cpter", "cmultiplimer", "cperimer", "cpter", "cputiver", "cmultiplier", "cmultipler", "cmultipliver", "cptim", "cctimer", " cputier", "cptiver", " cPUTim", "cPUTimer", "cPUTer", "cptier", "cPUTiper", "cptimer", " cptier", " cptimer", " cputer", "cperer", " cPUTiper", "cputer", " cputiver", " cPUTimer", " cptiver", "cputier", "cputiper", "cperim", "ccter", "cPUTim"], "slavio_intctl_io_memory": ["slavio_intctl_io_cache", "slavio_intctl_system_mem", "slavio_intctl_io_mem", "slavio_intctl_auto_cache", "slavio_intctl_storage_mem", "slavio_intctl_storage_write", "slavio_intctl_storage_memory", "slavio_intctl_auto_mem", "slavio_intctl_auto_memory", "slavio_intctl_system_memory", "slavio_intctl_system_cache", "slavio_intctl_system_write", "slavio_intctl_io_write"], "slavio_intctlm_io_memory": ["slavio_intctlm_auto_cache", "slavio_intctlm_auto_memory", "slavio_intctlm_io_mem", "slavio_intctlm_storage_mem", "slavio_intctlm_no_capacity", "slavio_intctlm_storage_memory", "slavio_intctlm_no_mem", "slavio_intctlm_auto_mem", "slavio_intctlm_storage_size", "slavio_intctlm_no_cache", "slavio_intctlm_io_cache", "slavio_intctlm_no_memory", "slavio_intctlm_io_size", "slavio_intctlm_auto_device", "slavio_intctlm_io_capacity", "slavio_intctlm_io_device", "slavio_intctlm_storage_cache"], "i": ["gi", "o", "ti", "v", "id", "I", "di", "ci", "ji", "ni", "b", "x", "si", "xi", "ri", "abi", "slice", "info", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "ii", "d", "iu", "ai", "uli", "u", "e", "uri", "w", "k", "t", "n", "multi", "mi", "ini", "p", "z", "eni", "oi", "c", "ip", "li", "fi", "index", "zi", "dim", "mu", "ui"], "s": ["sf", "S", "a", "b", "socket", "x", "f", "d", "service", "hs", "conf", "sports", "w", "func", "self", "h", "sa", "g", "sym", "sets", "sites", "is", "spec", "sw", "rows", "services", "its", "states", "server", "sl", "ls", "ds", "ts", "south", "settings", "z", "fs", "new", "sq", "site", "rs", "groups", "sg", "sync", "ses", "has", "small", "cs", "u", "e", "sb", "secondary", "t", "p", "c", "os", "ssl", "set", "r", "ps", "o", "v", "less", "http", "scope", "session", "si", "sys", "m", "in", "ips", "l", "xs", "client", "ns", "stats", "args", "us", "ss", "gs", "full", "storage", "n", "su", "sample", "es", "js"]}}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 5408, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "fc5a905a6d0c76d9fb8d838ac83f6219a7a5e20f", "target": 0, "func": "static void start_children(FFStream *feed)\n\n{\n\n    if (no_launch)\n\n        return;\n\n\n\n    for (; feed; feed = feed->next) {\n\n        if (feed->child_argv && !feed->pid) {\n\n            feed->pid_start = time(0);\n\n\n\n            feed->pid = fork();\n\n\n\n            if (feed->pid < 0) {\n\n                http_log(\"Unable to create children\\n\");\n\n                exit(1);\n\n            }\n\n            if (!feed->pid) {\n\n                /* In child */\n\n                char pathname[1024];\n\n                char *slash;\n\n                int i;\n\n\n\n                av_strlcpy(pathname, my_program_name, sizeof(pathname));\n\n\n\n                slash = strrchr(pathname, '/');\n\n                if (!slash)\n\n                    slash = pathname;\n\n                else\n\n                    slash++;\n\n                strcpy(slash, \"ffmpeg\");\n\n\n\n                http_log(\"Launch command line: \");\n\n                http_log(\"%s \", pathname);\n\n                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n\n                    http_log(\"%s \", feed->child_argv[i]);\n\n                http_log(\"\\n\");\n\n\n\n                for (i = 3; i < 256; i++)\n\n                    close(i);\n\n\n\n                if (!ffserver_debug) {\n\n                    i = open(\"/dev/null\", O_RDWR);\n\n                    if (i != -1) {\n\n                        dup2(i, 0);\n\n                        dup2(i, 1);\n\n                        dup2(i, 2);\n\n                        close(i);\n\n                    }\n\n                }\n\n\n\n                /* This is needed to make relative pathnames work */\n\n                chdir(my_program_dir);\n\n\n\n                signal(SIGPIPE, SIG_DFL);\n\n\n\n                execvp(pathname, feed->child_argv);\n\n\n\n                _exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 5416, "substitutes": {"feed": ["cook", "flow", "row", "build", "inf", "hub", "pull", "entry", "parent", "channel", "config", "bug", "skip", "update", "stream", "fed", "circ", "image", "draw", "food", "valid", "event", "f", "insert", "child", "ga", "post", "server", "sl", "url", "wait", "loop", "bb", "connect", "rss", "control", "comment", "file", "zip", "full", "raw", "df", "allow", "pass", "load", "source", "Feed", "input", "pub", "throw", "reader", "run", "follow", "gen", "sel", "read", "page", "report", "fd", "model", "fc", "cf", "blog", "cache", "accept", "form", "feeding", "host", "keep", "end", "add"], "pathname": ["partn", " pathName", "pathnamed", "partpath", "athname", "Pathn", "fulln", "athn", "pathstart", " pathno", " pathstart", "hostName", "pathName", "pitnamed", "pitname", "partName", "pathnam", "Pathnames", " Pathnam", " pathpath", "Pathlen", " pathnam", "Pathname", "Pathno", "filen", "fullstart", "fullname", " Pathno", "Pathpath", " Pathname", "Pathstart", " pathnames", "partname", "athno", " Pathnames", "fileno", "filenamed", "athName", " pathn", "fullName", "filename", "pitn", "pathn", "PathName", "Pathnam", "athnamed", "pathnames", "athpath", "hostlen", " pathlen", "pathpath", "pathlen", "fileName", "fullpath", "hostno", "pathno", "hostname"], "slash": ["plash", "plat", "Slah", "Slug", "splash", "splashed", " slug", "slASH", "splashing", "clashed", "flah", "slah", "flashing", " slitch", "sllash", "Slash", "flat", "Slashes", "clah", "splah", "slashed", "swashed", "splat", "swashing", " sllash", "Slashing", "swash", "Slashed", " slashed", "glug", "glash", "plah", "swug", "glashed", "glashing", "Slitch", "slug", "SLashed", " slashes", "clash", "slat", "clashes", "slashing", "plashed", "Sllash", "splitch", "SLlash", "SLash", "spllash", "clASH", "flash", "SlASH", "SLug", "plashes", " slASH", "plashing", "slitch", "slashes"], "i": ["isi", "I", "a", "di", "ci", "x", "xi", "b", "bi", "iii", "pi", "d", "ii", "code", "connection", "mini", "oi", "g", "y", "li", "fi", "index", "zi", "gi", "name", "ti", "id", "is", "slice", "abi", "info", "ix", "phi", "it", "ai", "uri", "ini", "ie", "one", "z", "ip", "ui", "ni", "ri", "io", "key", "yi", "j", "esi", "cli", "u", "e", "p", "hi", "c", "api", "mu", "o", "ei", "v", "si", "m", "in", "qi", "l", "iu", "init", "split", "n", "multi", "eni", "inner", "diff"]}}
{"project": "FFmpeg", "commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "target": 1, "func": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    int i, j;\n\n\n\n    if (!mov->fragment_index_complete)\n\n        return 0;\n\n\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n\n        if (mov->fragment_index_data[i]->track_id == st->id) {\n\n            MOVFragmentIndex *index = index = mov->fragment_index_data[i];\n\n            for (j = index->item_count - 1; j >= 0; j--) {\n\n                if (index->items[j].time <= timestamp) {\n\n                    if (index->items[j].headers_read)\n\n                        return 0;\n\n\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5429, "substitutes": {"s": ["sets", "v", "sec", "http", "spec", "sg", "sw", "b", "si", "sys", "ses", "services", "m", "support", "states", "f", "ns", "stats", "ls", "sl", "server", "sci", "service", "cs", "ss", "us", "e", "sc", "an", "w", "sb", "ks", "gs", "ops", "se", "ds", "qs", "t", "ctx", "storage", "ts", "su", "self", "p", "south", "sv", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "src", "js"], "st": ["std", "est", "ste", "stable", "cr", "ost", "si", "sn", "stack", "sts", "rest", "sam", "station", "state", "sl", "sm", "St", "td", "ss", "sc", "sth", "sb", "sh", "inst", "sd", "t", "storage", "ST", "str", "sta", "stage", "sv", "sp", "start", "step", "sa", "c", "src", "ast"], "timestamp": ["scheestamp", "imestamp", "timeetime", "timeestamp", "timcast", "timpoint", "imetime", "impoint", "timest", "Timest", "Timetime", "scheest", "schepoint", "imcast", "Timpoint", "timetime", "Timestamp", "timeest", "Timcast", "schecast", "timepoint", "imest"], "mov": ["imev", " mocr", "ymoc", "Mocr", "mouf", "cmoor", "cmov", "mmov", "pood", " movi", " mouf", " mev", "moor", "pouf", "movi", "imov", "Mov", "food", "amoor", "fove", "fouf", "imocr", "cmove", "mev", "Movi", "ymove", " mood", " mrav", "cmev", "amov", "Mrav", "pov", "moc", "imove", "fov", " moor", "ymov", "amove", "mmove", "tmov", "tmrav", "Move", "pove", "mmocr", "mood", "mmev", "ymovi", "tmocr", "amev", "Moc", "move", "mocr", "mrav", " move", " moc", "tmove"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "di", "ci", "ki", "ji", "ni", "b", "x", "si", "ri", "xi", "io", "bi", "m", "qi", "ix", "l", "f", "pi", "yi", "ii", "d", "iu", "ai", "u", "e", "uri", "k", "n", "multi", "mi", "ini", "ie", "p", "h", "eni", "oi", "c", "ind", "ip", "g", "y", "api", "li", "r", "zi", "ui"], "j": ["jet", "dy", "fr", "o", "v", "el", "ci", "jl", "oj", "ji", "x", "xi", "si", "b", "bi", "m", "body", "qi", "kj", "l", "ix", "num", "job", "f", "ij", "aj", "obj", "d", "q", "it", "u", "e", "jen", "J", "section", "je", "jc", "k", "json", "n", "uj", "t", "jp", "jo", "rev", "ie", "p", "ne", "h", "z", "jj", "ld", "ind", "c", "g", "off", "y", "ja", "dj", "br", "li", "adj", "bl", "journal", "bj", "js"], "index": ["master", "pack", "script", "name", "header", "block", "id", "open", "author", "entry", "complete", "alpha", "pull", "value", "sort", "config", "update", "x", "data", "slice", "sync", "style", "module", "info", "body", "image", "inc", "ion", "key", "f", "version", "lead", "url", "document", "table", "match", "connect", "initial", "part", "action", "e", "point", "item", "section", "inst", "full", "connection", "comment", "instance", "n", "search", "context", "input", "output", "run", "fix", "level", "node", "ind", "new", "page", "type", "element", "cache", "Index", "group", "form", "date", "conn", "diff"]}}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5430, "substitutes": {"track": ["agg", "layer", "feed", "play", "rr", "complete", "tracking", "trial", "note", "component", "sort", "config", "gap", "tr", "sync", "token", "edit", "record", "module", "info", "route", "project", "attr", "event", "order", "call", "metadata", "grade", "ack", "toggle", "match", "roll", "round", "comment", "Track", "port", "tm", "sound", "coll", "follow", "step", "node", "txt", "tracks", "type", "report", "transform", "model", "gg", "rack", "tt", "test", "form", "group", "cross", "ride", "trace", "setup"], "pb": ["cp", "plugin", "bp", "lb", "ib", "hub", "platform", "pa", "rb", "bps", "bm", "wp", "lab", "lp", "fb", "buf", "db", "uf", "pm", "wb", "pg", "mp", "prot", "obj", "pc", "loop", "xb", "np", "eb", "buffer", "dp", "sb", "lib", "ctx", "bc", "PB", "ab", "fp", "jp", "p", "pool", "summary", "vp", "proc", "bf", "api", "lc", "tp", "fc", "pl", "rob", "cpp", "bh", "pkg"], "tag": ["patch", "name", "reg", "ag", "block", "method", "word", "bug", "gap", "Tag", "token", "tags", "bit", "image", "loc", "brand", "key", "event", "TAG", "ack", "match", "tick", "round", "code", "category", "comment", "feat", "year", "step", "attribute", "type", "class", "month", "test", "date", "feature"]}}
{"project": "FFmpeg", "commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "target": 1, "func": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n\n{\n\n    int ret = 0;\n\n    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        AVInputFormat *iformat;\n\n\n\n        if (!buf)\n\n            return AVERROR(ENOMEM);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n\n\n        if (!(iformat = av_find_input_format(\"asf\")))\n\n            return AVERROR_DEMUXER_NOT_FOUND;\n\n\n\n        rt->asf_ctx = avformat_alloc_context();\n\n        if (!rt->asf_ctx) {\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n\n\n        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {\n\n            av_dict_free(&opts);\n\n            return ret;\n\n        }\n\n\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0) {\n\n            av_free(buf);\n\n            return ret;\n\n        }\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 5437, "substitutes": {"s": ["o", "serv", "sr", "sf", "v", "a", "S", "http", "spec", "sg", "session", "b", "si", "sys", "ses", "services", "m", "f", "client", "ns", "d", "server", "sl", "ls", "stats", "args", "service", "init", "cs", "ss", "u", "us", "e", "sc", "w", "sb", "gs", "parser", "ops", "t", "ds", "storage", "ctx", "n", "su", "self", "root", "h", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "es", "rs", "r", "ps"], "p": ["cp", "base", "P", "o", "bp", "padding", "v", "pr", "a", "pa", "pat", "pp", "b", "data", "i", "wp", "pe", "lp", "m", "pt", "l", "f", "post", "d", "pc", "q", "np", "u", "e", "t", "n", "ctx", "fp", "jp", "input", "h", "vp", "prop", "sp", "pos", "proc", "c", "api", "tp", "pl", "r", "ps"], "pb": ["abc", "cp", " db", "gp", "bp", "lb", "ib", "buff", "platform", " proto", "rb", "tmp", "username", "b", "pd", "i", "typ", "bm", "lp", "fb", "tx", "uf", "db", "wb", "pg", "mp", " rc", "attr", "prot", "meta", " PB", "pc", "obj", "client", "bs", "TB", "eb", "np", "dp", "buffer", "sb", "ctx", "bc", "PB", "fp", "cb", "ab", "prefix", "mb", "summary", "pool", "root", "vp", "gb", " subp", "kb", "txt", "bf", "api", "tp", " eb", "fc", "pl", "src", "ref", "rob", "r", "bh", "pkg", "tc"], "rt": ["irt", "ot", "rn", "dr", "fr", "vr", "sr", "ret", "rr", "pit", "nt", "dat", "rb", "vt", "rot", "bt", "yt", "qt", "tr", "raf", "rd", "rf", "rc", "typ", "art", "urt", "apt", "pt", "ird", "BT", "rh", "tx", "ru", "att", "kt", "mt", "RT", "t", "ant", "rl", "rin", "boot", "ut", "ft", "Ret", "xt", "ht", "rat", "txt", "ct", "gt", "gd", "dt", "tp", "adr", "ort", "tt", "NT", "rs", "rob", "r", "conn", "nd"], "opts": [" optrs", "OPts", "OPtr", "OPcs", " optr", "defts", "otters", "optionters", "optter", "otuts", "optments", "opttr", "opters", "optionts", "optTS", "optt", "ropts", "optionns", "optr", "opments", "otTS", "otments", "optts", " optts", "opttt", "optcs", "OPns", "defs", "ropters", "opcs", "optters", "ropments", "ops", "OPters", "OPt", "opns", "oputs", "optrs", " optTS", "oprs", "otts", "deft", "otter", "ropter", "opt", "otrs", "opTS", " optuts", "optns", "OPs", "optiont", "optuts", " opcs", "opter", "OPtt", " opt", "deftt"], "buf": ["base", "cp", "bp", "buff", "vec", "lb", "fw", "box", "bd", "la", "Buff", "rb", "tmp", "b", "val", "data", "rc", "queue", "uc", "loc", "fb", "wb", "uf", "conv", "fl", "buffer", "len", "sb", "bag", "Buffer", "func", "cmd", "ctx", "bytes", "bc", "fp", "cb", "ba", "seq", "context", "req", "h", "gb", "alloc", "proc", "cap", "fd", "cf", "br", "cv", "ref", "aux", "fi", "src", "cas", "bh", "pkg"], "iformat": ["olidoat", "ivant", " uniformam", "iplat", "specificarat", "oidant", "olidat", "iformam", "iformant", "olidaton", "pirat", " uniformater", "specificoat", " uniformat", "inylater", "oidAT", "piraton", "ificAT", "inylat", "iformater", "inylam", "pirarat", "ificant", "ivat", "iplant", "iplAT", "specificat", "oidat", "oidaton", "iplaton", "ificaton", "specificaton", "iformAT", "olidarat", "iformoat", "iformaton", "iformarat", "ivam", "inylant", " uniformant", "piroat", "ificat", "ivater"]}}
{"project": "FFmpeg", "commit_id": "9a3f10695a011861dcf5a649e3e72580b1a4eed4", "target": 1, "func": "static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                              int buf_size, void *data)\n\n{\n\n    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};\n\n    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};\n\n    RA144Context *ractx;\n\n    PutBitContext pb;\n\n    int32_t lpc_data[NBLOCKS * BLOCKSIZE];\n\n    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];\n\n    int shift[LPC_ORDER];\n\n    int16_t block_coefs[NBLOCKS][LPC_ORDER];\n\n    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */\n\n    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */\n\n    int energy = 0;\n\n    int i, idx;\n\n\n\n    if (buf_size < FRAMESIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n\n        return 0;\n\n    }\n\n    ractx = avctx->priv_data;\n\n\n\n    /**\n\n     * Since the LPC coefficients are calculated on a frame centered over the\n\n     * fourth subframe, to encode a given frame, data from the next frame is\n\n     * needed. In each call to this function, the previous frame (whose data are\n\n     * saved in the encoder context) is encoded, and data from the current frame\n\n     * are saved in the encoder context to be used in the next function call.\n\n     */\n\n    for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {\n\n        lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) {\n\n        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >>\n\n                      2;\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab,\n\n                                    32)];\n\n\n\n    ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,\n\n                      LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON,\n\n                      0, ORDER_METHOD_EST, 12, 0);\n\n    for (i = 0; i < LPC_ORDER; i++)\n\n        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] <<\n\n                                        (12 - shift[LPC_ORDER - 1]));\n\n\n\n    /**\n\n     * TODO: apply perceptual weighting of the input speech through bandwidth\n\n     * expansion of the LPC filter.\n\n     */\n\n\n\n    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {\n\n        /**\n\n         * The filter is unstable: use the coefficients of the previous frame.\n\n         */\n\n        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]);\n\n        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);\n\n    }\n\n    init_put_bits(&pb, frame, buf_size);\n\n    for (i = 0; i < LPC_ORDER; i++) {\n\n        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);\n\n        put_bits(&pb, bit_sizes[i], idx);\n\n        lpc_refl[i] = ff_lpc_refl_cb[i][idx];\n\n    }\n\n    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);\n\n    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);\n\n    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);\n\n    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,\n\n                            energy <= ractx->old_energy,\n\n                            ff_t_sqrt(energy * ractx->old_energy) >> 12);\n\n    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);\n\n    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);\n\n    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);\n\n    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));\n\n    for (i = 0; i < NBLOCKS; i++)\n\n        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,\n\n                              block_coefs[i], refl_rms[i], &pb);\n\n    flush_put_bits(&pb);\n\n    ractx->old_energy = energy;\n\n    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];\n\n    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);\n\n    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)\n\n        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;\n\n    return FRAMESIZE;\n\n}\n", "idx": 5452, "substitutes": {"avctx": [" avcontext", "AVpkg", "akcontext", "ajcf", "AVcf", "AVtx", "afcu", "AVmac", "avcu", "AVctx", " avmac", "AVcontext", "avcf", "akctx", "aftx", "afctx", "avtx", "avcontext", "afpkg", "ajcu", " avtx", "afconn", "akconn", "avpkg", "afcf", "afcontext", "avmac", "ajctx", "akpkg", "ajcontext", "AVcu", "AVconn", "avconn", "afmac"], "frame": ["base", "flow", "time", "block", "channel", "value", "object", "iframe", "family", "slice", "body", "image", "Frame", "window", "event", "state", "document", "code", "buffer", "message", "fram", "file", "context", "node", "type", "frames", "element"], "buf_size": ["buf_small", "buf_capacity", " buf_SIZE", " buf_capacity", "box_small", "box_SIZE", "box_size", "box_no", "buf_no", " buf_ize", "buf_SIZE", "buf_ize"], "data": ["ei", "o", "ea", "block", "alpha", "a", "parent", "di", "dat", "value", "config", "format", "body", "image", "buf", "window", "draw", "offset", "media", "d", "length", "DATA", "byte", "buffer", "e", "power", "message", "Data", "bytes", "response", "load", "result", "array", "input", "ee", "output", "batch", "memory", "new", "sample", "cache", "next", "ui", "size"], "sizes": ["pizes", "sapes", "pources", "Sources", "scapes", "Sapes", "papes", "scources", "scize", "pize", "sources", "scizes", "Size", "Sizes", "size"], "bit_sizes": ["bit_fumbers", "bit_fizes", "bit_shizes", "bit_figs", "bit_nigs", "bit_sumbers", "bit_shumbers", "bit_numbers", "bit_sigs", "bit_nizes", "bit_shigs", "bit_size", "bit_fize", "bit_nize", "bit_shize"], "ractx": ["latexx", "antex", "ractory", "pullx", "ortxe", "ortx", "appy", "anty", "ractorxs", "pullz", "ractionxe", "ortz", "latez", "pullex", "ractioner", "ortxx", "ortex", "haustx", "ractux", "ractorex", "ractxe", "ractionux", "antx", "pullxx", "hauster", "inctx", "ractz", "ctxe", "incty", "antxs", "ctx", "racter", "racty", "ractex", "ractxx", "ractxs", "lateex", "ctex", "incter", "haustex", "ractionx", "inctex", "latex", "ortux", "hausty", "appex", "appxs", "ctux", "ractorx", "ractiony", "appx", "ractionex"], "pb": [" plugin", " mp", " PL", " proto", " prod", " CT", "tx", " rc", " conf", " PB", "pc", " pl", " dup", " cab", " impl", "PB", " ecc", "p", " app", " macro", " img", " pc", " subp", " pa", " eb", " FC", " bc", " PA", " pu"], "lpc_data": ["lpm1window", " l\n", "lPC_actions", "lfc_data", "lpcallbody", "lfc_body", "lpcsbody", "lpcswindow", "lpcsresults", "lpc_cache", "lpcsdat", "lpc_done", "lpcsbuffer", "lfc_next", "lfc_error", "lfc_dat", "lpc_actions", "lpm1dat", "lpc1dat", "lpcallwindow", "lpc_buffer", "lpm1data", "lpm_block", "lfc_cache", "lpcalldat", "lpc_DATA", "lPC_block", "lpc_block", "lPC_DATA", "lpc_memory", "lpc7memory", "lpcsmemory", "lpc1block", "lpc_next", "lpc_error", "lpc7error", "lpc_window", "lpc7next", "lfc_results", "L\n", "l\n", "lpm_window", "lpm_dat", "lfc_done", "lpc1data", "lPC_data", "lfc_window", "lfc_buffer", "lpc_body", "lpm_data", "lpcsdata", "lpcalldata", "lpcallresults", "lfc_memory", " L\n", "lpc_dat", "lpc1window", "lpcallerror", "lpm1block", "lpc_results", "lpcallcache", "lpc7data"], "lpc_coefs": ["lpc_coffd", "lpc_coeffd", "lpc_coeffn", "lpc_coofd", "lpc_coffs", "lpc_coefd", "lpc_coeffsets", "lpc_coofn", "lpc_coffsets", "lpc_coeffs", "lpc_coofsets", "lpc_coffn", "lpc_coefn", "lpc_coefsets", "lpc_coofs"], "LPC_ORDER": ["LPC_ENTBER", "LPC_ORER", "LPC_ADDER", "LPC_ENDERC", "LPC_ORer", "LPC_ENTer", "LPC_GENERC", "LPC_ENDAR", "LPC_ANDBER", "LPC_GENBER", "LPC_ADDAR", "LPC_ENTR", "LPC_NUMER", "LPC_NUMer", "LPC_ENTER", "LPC_ORBER", "LPC_ENDer", "LPC_ANDR", "LPC_ENDERS", "LPC_ENTAR", "LPC_ORDAR", "LPC_ORDERC", "LPC_ENDR", "LPC_ANDER", "LPC_ORDR", "LPC_GENER", "LPC_ENTERS", "LPC_ORDERS", "LPC_ANDERS", "LPC_ORDBER", "LPC_NUMR", "LPC_NUMERC", "LPC_ENDBER", "LPC_ENDER", "LPC_ORDer", "LPC_ANDer", "LPC_GENer", "LPC_NUMBER", "LPC_ADDBER", "LPC_ORR", "LPC_ADDer"], "shift": ["ress", "offset", "align", "ffff", "len", "raw", "hift", " shifts", "size"], "block_coefs": ["block_coffn", "block_coafs", "block_coefn", "block_coefsets", "block_coefferences", "block_coeffs", "block_coffsets", "block_coeferences", "block_coeffsets", "block_coaferences", "block_coafsets", "block_coffs", "block_coeffn", "block_coafn", "block_cofferences"], "NBLOCKS": ["NPLOCKTS", "NPLANKDS", "NBLACKs", "NBLINKIDS", "NBLACKTS", "NBLANKIDS", "NBLACKSE", "NPLOCKSE", "NPLANKIDS", "NBLACKES", "NPLACKES", "NPLOCKs", "NBLOCKSE", "NBLINKSE", "NPLOCKDS", "NBLOCKDS", "NPLANKs", "NBLANKDS", "NPLANKS", "NBLANKTS", "NBLLOCKIDS", "NPLOCKES", "NBLANKES", "NBLANKSE", "NPLACKs", "NBLINKS", "NBLOCKES", "NBLACKDS", "NBLINKDS", "NBLLOCKs", "NBLOCKIDS", "NBLANKs", "NBLINKES", "NBLLOCKES", "NBLACKS", "NPLACKS", "NBLANKS", "NBLINKTS", "NBLOCKs", "NBLINKs", "NPLOCKS", "NPLACKSE", "NPLOCKIDS", "NBLOCKTS", "NPLACKTS", "NBLLOCKS", "NPLANKES"], "lpc_refl": ["lpc_recfl", "lpc_mbl", "lpc_rebl", "lpc_mll", "lpc_prebl", "lpc_recll", "lpc_prell", "lpc_mfl", "lpc_rell", "lpc_recbl", "lpc_prefl"], "refl_rms": ["refl_ermi", "refl_rmb", "refl_rels", "refl_rtls", "refl_rtmb", "refl_remb", "refl_ermb", "refl_rtmi", "refl_rls", "refl_remi", "refl_rems", "refl_erms", "refl_rtms", "refl_erls", "refl_rmi"], "i": ["gi", "o", "ei", "ti", "v", "id", "I", "di", "ci", "ji", "ni", "x", "xi", "si", "io", "b", "ri", "slice", "info", "bi", "module", "in", "qi", "m", "ix", "l", "key", "f", "pi", "yi", "phi", "j", "iu", "ii", "d", "it", "ai", "my", "cli", "u", "e", "uri", "ori", "n", "field", "multi", "mi", "ini", "me", "ie", "p", "source", "mini", "h", "eni", "z", "iv", "oi", "hi", "c", "ip", "g", "y", "api", "type", "li", "inner", "current", "fi", "index", "zi", "diff", "mu", "ui"], "idx": [" idxs", "idxc", " idex", "idex", "pidex", "pidxs", "sidx", "sidxc", "pidxc", "pidx", "sidex", " idxc", "idxs", "sidxs"]}}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n", "idx": 5457, "substitutes": {"gb": ["gc", "anc", "lb", "hub", "ci", "rb", "bg", "cca", "sync", "bm", "db", "wb", "ga", "usb", "gin", "pc", "gz", "bb", "eb", "sc", "mc", "sb", "gs", "rg", "binary", "storage", "ctx", "bc", "GB", "cb", "gy", "kb", "ub", "bf", "gd", "lc", "gram", "fc", "gg", "vc", "kr", "src", "cd", "ui"], "rc": ["abc", "rn", "dr", "rw", "irc", "anc", "cr", "sr", "rt", "cur", "rr", "roc", "ci", "rb", "config", "nc", "cca", "sync", "auc", "sys", "co", "uc", "loc", "rog", "inc", "ru", "attr", "uci", "ra", "pc", "ack", "cc", "cs", "ck", "sc", "rect", "rg", "inst", "dc", "hl", "ctx", "rx", "bc", "instance", "rl", "ic", "rin", "ec", "usr", "c", "gd", "lc", "asc", "gg", "fc", "ac", "vc", "src", "rs", "rank", "r", "RC", "rec", "isc", "xc"], "cumFreq": [" cumfreue", "cumLeue", "cumFrerequency", "cumFirequency", " cumfreq", "cumLeq", "cumStraference", " cumFreQ", " cumfrequality", "cumStraq", " cumFreference", "cumFreeq", " cumfreqs", "cumLeqs", " cumfreQ", " cumFreqs", " cumFiqs", " cumFirequency", " cumFrerequency", "cumFiqs", "cumFreeqs", "cumFiq", "cumFiference", " cumFrequality", "cumfreq", "cumfrequality", "cumFference", "cumLeQ", "cumFrequency", "cumFrequality", "cumFreequality", "cumFreqs", "cumFreference", " cumFiference", "cumFq", "cumFreeQ", "cumfreqs", "cumfreQ", "cumStrarequency", "cumfreue", " cumFiq", "cumFreue", " cumFreue", "cumFreQ", "cumFqs", "cumStraqs"], "freq": ["luquality", " freQ", "frqs", "freeq", "Frequality", "frquality", "luq", "freece", "faQ", "faquality", "frQ", " frece", "frequality", "Freq", "freequality", "Frece", " frequality", "luQ", "frq", "FreQ", "faq", "faqs", "freeQ", "freQ", "luqs", "frece", "freqs"], "total_freq": ["total_latux", "total_compue", "total_Freance", "total_freeance", "total_Freqs", "total_latf", "total_Freence", "total_freence", "total_freeqs", "total_compq", "total_latq", "total_Frequality", "total_freance", "total_fref", "total_compqs", "total_perf", "total_freux", "total_perq", "total_freeue", "total_freeence", "total_perance", "total_latance", "total_freue", "total_Freue", "total_freeq", "total_freqs", "total_Freq", "total_perux", "total_frequality", "total_freequality", "total_compquality"]}}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static int dmg_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    s->fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (s->fd < 0)\n\n        return -errno;\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    /* read offset of info blocks */\n\n    offset = lseek(s->fd, -0x1d8, SEEK_END);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    info_begin = read_off(s->fd, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(s->fd, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(s->fd, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    /* read offsets */\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(s->fd, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(s->fd, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = qemu_realloc(s->types, new_size/2);\n\n\t    s->offsets = qemu_realloc(s->offsets, new_size);\n\n\t    s->lengths = qemu_realloc(s->lengths, new_size);\n\n\t    s->sectors = qemu_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(s->fd, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = qemu_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    return 0;\n\nfail:\n\n    close(s->fd);\n\n    return -1;\n\n}\n", "idx": 5482, "substitutes": {"bs": ["lb", "bits", "rb", "b", "ses", "bi", "BS", "obs", "fb", "ns", "ls", "bb", "cs", "ss", "us", "vs", "sb", "gs", "ks", "ops", "ds", "qs", "bytes", "bc", "ts", "ab", "cb", "blocks", "aws", "gb", "fs", "os", "ssl", "bos", "ms", "ps", "bl", "es", "rs", "pb", "bh", "js"], "filename": ["name", "files", "rb", "username", "Filename", "data", "arf", "tty", "wb", "f", "dylib", "url", "length", "original", "which", "buffer", "fil", "file", "binary", "fn", "whatever", "path", "fp", "dll", "nil", "source", "kl", "txt", "location", "fd", "wl", "utf", "il", "lf", "phrase", "directory", "prefix"], "flags": ["types", "options", "files", "flag", "bits", "fee", "Flags", "features", "config", "info", "mask", "ips", "vals", "FLAG", "ants", "stats", "args", "ffff", "faces", "ops", "locks", "file", "bytes", "settings", "fs", "lf", "xff"], "s": ["S", "a", "b", "f", "parts", "state", "d", "service", "hs", "conf", "self", "h", "aws", "sa", "g", "sym", "sets", "sites", "is", "services", "its", "states", "server", "ls", "sl", "native", "ops", "bis", "ds", "ts", "outs", "settings", "sv", "fs", "sq", "rs", "stat", "as", "ans", "ins", "plugins", "comments", "sync", "ses", "ions", "cs", "e", "sb", "ks", "qs", "tests", "p", "c", "os", "ssl", "ps", "http", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "args", "us", "ss", "uns", "gs", "full", "storage", "su", "es", "js"], "info_begin": ["info_message", "info_size", "Info_start", "info_information", "inf_begin", "infoJbegin", "infoacpin", "info_mid", "information_begin", "information_enter", "inf_create", " info_create", "infoPbegin", "info_pin", "info__seven", " info_pair", "informationPseven", "info00message", "infoJstart", "information_seven", "informationPenter", " info_enter", "info__information", "info_seven", "info_pair", "info01begin", "infoPenter", "informationPbegin", "info_enter", "info01pair", "infoacmessage", "information_information", " info_size", "infoJenter", "info00enter", "infoJcur", "infoacsize", "info00pin", "info_cur", "inf_enter", "info_start", "info__begin", "info00begin", "inf_pin", "info_create", "inf_pair", "inf_message", " info_mid", " info_initial", "infoacenter", "info__end", "info__enter", "Info_begin", "infoPinformation", "infoacbegin", "infoPseven", "info01enter", "infoacpair", "Info_enter", "info01create", "informationPinformation", "info_initial", "info__mid", "Info_cur"], "info_end": ["off_end", "infoREdate", "information_END", "Info_start", "info_date", "Info_date", "info_length", "info_ending", "off_ending", "info_ended", "information_end", "info_ends", "Info_end", "infoREend", "Info_length", "info_start", "off_ends", "infoRElength", "information_begin", "infoREstart", "information_ended", "info_END"], "last_in_offset": ["last_out_error", "last_out_number", "last_inandoffset", "last_out_Offset", "last_iningprogress", "last_in_Offset", "last_in_error", "last_out_progress", "last_iningoffset", "last_in__Offset", "last_out_entry", "last_inandprogress", "last_in_entry", "last_iningerror", "last_inanderror", "last_in_number", "last_inandnumber", "last_in_progress", "last_in__entry", "last_in__offset", "last_iningnumber"], "last_out_offset": ["last_in_size", "last_outedoffset", "last_out_position", "last_outedsize", "last_out__position", "last_out_Offset", "last_out_size", "last_out__end", "last_in_Offset", "last_out_end", "last_in_position", "last_in_end", "last_out_line", "last_out_entry", "last_in_line", "last_in_entry", "last_outedline", "last_out__offset", "last_outedentry", "last_out__Offset"], "count": ["position", "flag", "large", "check", "weight", "match", "code", "len", "all", "col", "error", "depth", "connection", "catch", "array", "pool", "h", "current", "index", "max", "base", "name", "many", "id", "parent", "list", "sum", "info", "missing", "content", "limit", "number", "high", "allow", "path", "process", "old", "cf", "group", "no", "end", "low", "size", "counter", "act", "key", "num", "timeout", "more", "start", "c", "core", "cache", "total", "get", "skip", "child", "call", "length", "part", "Count", "coll", "seq", "common", "found"], "i": ["ti", "id", "I", "a", "is", "ci", "b", "si", "slice", "io", "abi", "in", "f", "ii", "ai", "init", "split", "n", "ini", "p", "h", "pos", "c", "ip", "ind", "inner", "fi", "index"], "offset": ["position", "padding", "flag", "reset", "entry", "object", "data", "et", "f", "align", "initial", "len", "error", "connection", "amount", "fp", "output", "line", "attribute", "off", "page", "index", "optional", "slot", "function", "base", "option", "append", "extra", "fee", "parent", "layout", "slice", "at", "url", "limit", "enabled", "number", "operation", "ip", "range", "addr", "end", "ui", "size", "address", "area", "seek", "loc", "image", "post", "point", "exclusive", "online", "timeout", "pos", "start", "location", "api", "ref", "next", "set", "o", "skip", "alias", "format", "Offset", "attr", "order", "length", "split", "part", "offer", "seq", "ptr", "pointer", "shift"], "type": ["base", "types", "name", "area", "time", "large", "block", "id", "parent", "http", "total", "value", "TYPE", "bug", "val", "style", "ping", "cat", "info", "pe", "key", "tag", "ty", "like", "post", "state", "weight", "length", "call", "py", "match", "number", "code", "part", "all", "error", "comment", "port", "ype", "year", "p", "rule", "class", "y", "api", "Type", "date", "size"], "new_size": ["new48channel", "new_order", "new_count", "newfcapacity", " new_address", "newfsize", "new48order", "newXrange", "newJaddress", " new_order", "new_address", "new48address", "new_set", "gen_size", "newJchannel", "new\u00b7size", "new_number", "new_channel", "newXsize", "new_range", "gen_capacity", " new_number", "newXscale", "gen_count", "new\u00b7set", "genfsize", "new67range", "new48size", " new_set", "new67number", " new_channel", "newXnumber", "new67size", " new_scale", "genfcapacity", "genfcount", "new_scale", "new67scale", "newJsize", "new_capacity", "newfcount", "new\u00b7address", " new_range", "newJorder"], "chunk_count": ["chunkerlimit", "chunk_c", "chunk2sum", "chunk64name", "chwork_name", "chunk_limit", "chunker_count", "chunkererlimit", "chunk_number", "chunkernumber", "chunkerernumber", "chunk_name", "chunkerweight", "chunker_max", "chunk6count", "chwork_weight", "chunk6max", "chunkercount", "chworkername", "chwork_len", "chworkerlen", "chunk_sum", "chunk_size", "chunkerermax", "chunk2count", "chworkercount", "chunk6limit", "chworkerweight", "chwork_count", "chunk2c", "chunk64count", "chunkerlen", "chunkermax", "chunk64weight", "chunk_len", "chunk_weight", "chunkerercount", "chunk2size", "chunk_max", "chunker_number", "chunk64len", "chunker_limit", "chunk6number", "chunkername"]}}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n", "idx": 5490, "substitutes": {"pkt": ["cpct", "cpkt", "Pkt", " pet", " pwk", "pct", "pkh", "pwk", "spk", "ipkt", "spwk", "ipwk", "pet", "macket", "Packet", "ipkh", "spkt", " pct", "cpet", "mkt", "cpacket", "Pct", " pk", "spacket", "pk", "ipacket", "Pwk", "mwk", " pkh", "Pkh", "packet", "Pet", "mk", " packet"]}}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 5500, "substitutes": {"data": ["na", "builder", "a", "di", "object", "style", "i", "database", "f", "d", "code", "json", "Data", "self", "reader", "g", "li", "view", "base", "id", "parent", "config", "art", "module", "info", "missing", "valid", "media", "it", "DATA", "da", "work", "parse", "and", "new", "type", "model", "class", "test", "command", "end", "ui", "as", "alpha", "change", "dat", "cat", "ad", "wa", "key", "post", "obj", "u", "parser", "p", "input", "start", "api", "cache", "o", "la", "dd", "get", "window", "client", "init", "load", "result", "this", "qa", "first"], "json_string": ["input_length", "json_data", "jsonMatfilename", "input_filename", " json_data", "jsonMatlength", "jsonMatstring", " json_number", "input_object", "json_object", "json_filename", "json_number", "jsonMatobject", "json_str", "input_string", "json_length", " json_str"], "v": ["nv", "o", "vd", "vm", "s", "value", "V", "va", "cover", "x", "vic", "val", "i", "m", "uv", "l", "f", "conv", "j", "ve", "av", "d", "q", "u", "vi", "vs", "e", "ev", "k", "t", "n", "p", "h", "z", "sv", "vp", "iv", "vert", "ver", "c", "var", "g", "y", "lv", "ov", "api", "vv", "cv", "vc", "view"]}}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}", "idx": 5508, "substitutes": {"path": ["base", "address", "r", "name", "id", "open", "method", "parent", "entry", "ex", "data", "home", "enc", "pattern", "loc", "key", "url", "Path", "dir", "code", "uri", "w", "error", "here", "file", "port", "binary", "pass", "ith", "loader", "filename", "work", "p", "context", "temp", "root", "PATH", "ath", "pointer", "c", "location", "handler", "core", "text", "cache", "host", "conn", "prefix"], "sockfd": ["sockfn", "sesockFD", "sesinkfun", "dsockaddr", " swinfn", "socksaddr", "sinkfn", "sockaddr", "sigstream", "sockf", "sinkaddr", "sinkf", "sigfd", " socksaddr", " sockFD", "sockfat", "sbootFD", "swinfd", " swinFD", "sigbuf", " socksf", " socksFD", "scpaddr", "sourceFD", "dsocksFD", "dockstream", "dockfd", "sockerfat", "sesinkFD", "sockeraddr", "socksfd", "dsocksfd", "sckfd", "sockbuf", "sockerFD", "sourcef", " sockfn", "dsocksaddr", " sockf", "scpfat", "dinkstream", "sesinkaddr", "scpFD", "dsockfat", "sockstream", "sesinkfd", " sockfun", "dsocksfat", "dsockFD", "sigFD", "dinkfd", "dinkFD", "sckaddr", "sinkFD", "sbootfd", "sinkfd", "sinkbuf", "sesockaddr", "sinkfun", "sesockfun", "sockFD", "sockfun", "sourceaddr", " swinfd", "swinfn", "sbootfun", " swinfun", "swinFD", "scpfd", "dsockfd", "dockbuf", "sbootfn", "sockerfd", "sourcefd", "dockFD", "socksstream", "socksfat", "dinkbuf", " sockaddr", "sckfun", "sckFD", "socksf", "socksfun", "socksFD", "socksbuf", "swinfun", "sesockfd", " socksfd", "sinkstream"], "size": ["address", "name", "time", "SIZE", "large", "sec", "count", "complete", "fee", "send", "security", "x", "sum", "si", "sync", "sn", "loc", "unit", "speed", "capacity", "content", "offset", "weight", "length", "small", "Size", "fe", "code", "len", "storage", "esc", "sized", "empty", "ey", "scale", "ice", "c", "g", "iz", "ize", "max"], "helper": ["thelber", "Helter", "haped", "schepler", "hport", "perler", "helped", "helpers", " helpers", "waper", " helter", "harler", "halpers", "happer", "haber", "hapers", "hpper", "harper", "hyper", "halper", "Helpert", "wamer", "thelper", "thelped", "hypper", "wapler", "helter", "scheler", "helport", "impropers", "scheper", "perpler", "haport", "haller", "harter", "helber", " heller", "theller", "impropper", " helperpert", "helpert", " helperpper", "helmer", "improper", "helpher", "haler", "hyter", " Helpher", "permer", " helperper", "hapher", " helperter", "perper", "waler", "hypert", "harport", "helpler", " Helpper", "harpers", "harped", "helpper", "Helpper", "hper", "harber", " Helpers", "impropher", "halter", "harpper", "haper", "heller", " Helper", "schemer", "Helper"]}}
{"project": "qemu", "commit_id": "a1c3e4b839f8e7ec7f1792b8a11c63ca845aa021", "target": 1, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n{\n    EHCIState *s = ptr;\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n    uint32_t old = *mmio;\n    int i;\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n        return;\n    if (addr < OPREGBASE) {\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    /* Do any register specific pre-write processing here.  */\n    switch(addr) {\n    case USBCMD:\n        if (val & USBCMD_HCRESET) {\n            ehci_reset(s);\n            val = s->usbcmd;\n            break;\n        /* not supporting dynamic frame list size at the moment */\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);", "idx": 5509, "substitutes": {"ptr": ["address", "dr", "r", "eth", "scope", "tmp", "tr", "si", "inter", "pt", "tty", "buf", "iii", "f", "sl", "ctr", "buffer", "e", "sh", "sth", "sb", "inst", "port", "t", "dll", "ts", "fp", "str", "p", "Ptr", "temp", "pointer", "proc", "fd", "ref", "fi", "src", "tc"], "addr": ["anne", "dr", "rn", "layer", "vr", "padding", "nn", "x", "data", "oa", "xp", "ace", "route", "nm", "align", "sid", "code", "len", "ar", "arr", "nil", "hop", "index", "ast", "conn", "mode", "slot", "base", "aug", "arm", "kn", "intel", "id", "config", "nc", "slice", "fx", "grade", "url", "nr", "mt", "driver", "xd", "ctx", "pad", "str", "ne", "sta", "amp", "ld", "cap", "node", "adr", "amd", "grad", "size", "address", "afi", "hw", "rt", "md", "alt", "rc", "ad", "loc", "db", "ext", "adder", "point", "sb", "rg", "cmd", "hl", "coord", "p", "asm", "frame", "pos", "start", "c", "r", "src", "ea", "od", "rr", "eth", "dd", "rd", "inter", "alias", "mac", "offset", "attr", "bb", "kt", "part", "dc", "rx", "seq", "eni", "lvl", "direction", "pointer", "ord", "host", "pkg"], "val": ["serv", "play", "el", "local", "b", "x", "data", "elt", "unit", "status", "sil", "state", "arg", "byte", "all", "len", "arr", "err", "nil", "var", "sel", "li", "fi", "index", "pol", "slot", "base", "pid", "al", "value", "update", "pt", "valid", "vals", "cal", "ival", "fl", "sl", "sol", "ol", "ee", "old", "ne", "eval", "fail", "new", "vl", "test", "Value", "vol", "stat", "reg", "alt", "db", "key", "num", "VAL", "dev", "p", "prop", "pos", "ind", "bo", "ref", "set", "ret", "v", "store", "pr", "pre", "Val", "live", "ve", "bal", "delay", "aval", "cond", "bl", "role"], "s": ["serv", "sf", "S", "a", "b", "socket", "f", "state", "service", "conf", "w", "self", "h", "g", "sym", "sets", "is", "spec", "slice", "services", "states", "server", "sl", "ls", "sie", "ds", "ts", "settings", "sv", "fs", "new", "sq", "your", "site", "rs", "ins", "sg", "sync", "ses", "cs", "u", "vs", "e", "sb", "secondary", "t", "qs", "instance", "p", "c", "os", "ssl", "r", "ps", "o", "v", "scope", "session", "si", "sys", "m", "l", "ns", "stats", "args", "us", "ss", "gs", "se", "storage", "n", "su", "this", "request", "slave", "es", "js"], "mmio": ["mmiao", "mdiol", "memIO", "mmri", "mpno", "memiol", " mmIO", "memios", "mmcho", "mmo", "memori", "mmori", "mpiao", " mmri", " mmios", " mmori", "mpio", "memri", "mdno", "mmiol", "mdri", "mdios", "memcho", " mmno", "memio", "mmios", " mmiol", "mdiao", "mmno", "mdo", "mdcho", "memo", " mmcho", " mmiao", "mdIO", "mpios", "mdori", "mdio", " mmo", "mmIO"], "i": ["v", "I", "a", "is", "x", "b", "io", "or", "m", "l", "f", "pi", "d", "j", "e", "n", "err", "p", "z", "c", "ed", "r", "end"]}}
{"project": "FFmpeg", "commit_id": "cf7d2f2d2134c0854edf2db91e7436ac2bc9874f", "target": 0, "func": "static av_cold int dnxhd_encode_init(AVCodecContext *avctx)\n\n{\n\n    DNXHDEncContext *ctx = avctx->priv_data;\n\n    int i, index, bit_depth, ret;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV422P:\n\n        bit_depth = 8;\n\n        break;\n\n    case AV_PIX_FMT_YUV422P10:\n\n        bit_depth = 10;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"pixel format is incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);\n\n    if (!ctx->cid) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"video parameters incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"cid %d\\n\", ctx->cid);\n\n\n\n    index = ff_dnxhd_get_cid_table(ctx->cid);\n\n    if (index < 0)\n\n        return index;\n\n    ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n\n\n    ctx->m.avctx    = avctx;\n\n    ctx->m.mb_intra = 1;\n\n    ctx->m.h263_aic = 1;\n\n\n\n    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;\n\n\n\n    ff_blockdsp_init(&ctx->bdsp, avctx);\n\n    ff_fdctdsp_init(&ctx->m.fdsp, avctx);\n\n    ff_mpv_idct_init(&ctx->m);\n\n    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);\n\n    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);\n\n    if (!ctx->m.dct_quantize)\n\n        ctx->m.dct_quantize = ff_dct_quantize_c;\n\n\n\n    if (ctx->cid_table->bit_depth == 10) {\n\n        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;\n\n        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 4;\n\n    } else {\n\n        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 3;\n\n    }\n\n\n\n    if (ARCH_X86)\n\n        ff_dnxhdenc_init_x86(ctx);\n\n\n\n    ctx->m.mb_height = (avctx->height + 15) / 16;\n\n    ctx->m.mb_width  = (avctx->width  + 15) / 16;\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {\n\n        ctx->interlaced   = 1;\n\n        ctx->m.mb_height /= 2;\n\n    }\n\n\n\n    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;\n\n\n\n#if FF_API_QUANT_BIAS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&\n\n        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)\n\n        ctx->intra_quant_bias = avctx->intra_quant_bias;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    // XXX tune lbias/cbias\n\n    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 5539, "substitutes": {"avctx": ["avecv", " avcf", "avercontext", "abcmp", "navcontext", "aveloc", "afxc", "avcb", "afctx", "AVctl", "Avbc", "Avcmp", "AVcb", "aveca", "avkb", "navctx", "AVca", " avcontext", "avca", "AVcv", " avca", "airctx", "avcmd", "avercp", "afloc", "afcmp", "AVloc", "avcmp", "avectl", "abcontext", "avcv", "AVcmd", "avxc", "aircb", "AVcmp", "aveconn", "Avctx", "avecontext", "AVcp", "averpkg", "AVxc", "navcmd", "AVconfig", "AVcu", "AVconn", "averkb", "avbc", "avekb", "Avcu", " avxc", "vercontext", "avcu", "avconfig", "AVcontext", "averctx", "afcmd", "avecp", "afkb", "vercb", "avcontext", "afpkg", "airconn", "avloc", "AVbc", "vercv", "AVkb", "avconn", "abctx", " avcmp", "vercmd", "avctl", "AVcf", "verconn", "averctl", "avectx", "avepkg", "Avcf", "AVctx", "avcf", " avcmd", "avcp", "Avcontext", "verctx", " avctl", "aircontext", "afconn", "avpkg", " avbc", "afcontext", "afconfig", " avconn", "vercmp", "avecmp", "afcu", "navconn", "abconfig"], "ctx": ["cp", "cmp", "hw", "anc", "act", "cfg", "fw", "la", "ci", "component", "config", "nc", "data", "cus", "cca", "rc", "comp", "cat", "co", "concept", "loc", "cm", "support", "tx", "cal", "client", "conv", "media", "pc", "cc", "sci", "cs", "conf", "cli", "ck", "sc", "connection", "cam", "conn", "fn", "cmd", "wcs", "bc", "cu", "cms", "cb", "fp", "instance", "jp", "context", "prefix", "exec", "kw", "ca", "qa", "input", "msg", "kb", "utils", "c", "txt", "sq", "cf", "lc", "cn", "fc", "chan", "cv", "vc", "cas", "ctrl", "pkg", "xc", "tc"], "i": ["base", "ti", "ib", "I", "count", "di", "ci", "x", "ri", "si", "io", "info", "num", "pi", "j", "ii", "iu", "it", "ai", "e", "uri", "k", "c", "ip", "ind", "li", "ui"], "index": ["position", "check", "x", "weight", "active", "connect", "match", "len", "all", "error", "connection", "empty", "zero", "head", "page", "query", "conn", "option", "append", "id", "value", "update", "val", "list", "slice", "info", "office", "null", "ini", "search", "type", "element", "partial", "no", "end", "condition", "address", "sync", "loc", "inc", "key", "num", "action", "e", "point", "section", "out", "instance", "input", "pos", "ind", "include", "find", "cmp", "offset", "insert", "length", "fe", "part", "example", "full", "coll", "result", "inner", "Index", "date", "diff"], "bit_depth": ["bitSdepth", "bit_rate", "bit_len", " bit_deep", " bit_Depth", "bit_size", "bitalllen", "bitStable", "bit2height", " bit2Depth", "bitSdeep", " bit_roots", "bitallsource", "bin_depth", "bit32Depth", "byte_depth", "bin_deep", "bit_height", "byte_length", "bit_Depth", "bit32depth", " bit_count", " bit_size", "bit_table", "bit_roots", "bit64deep", "bit64count", "bitalldepth", "bit_dist", " bit2rate", " bit_height", "bit2depth", "bitalllength", " bit_rate", "bit_source", " bit_dist", "bit64Depth", " bit2depth", " bit2height", "byte_deep", "bin_table", "bit32height", "byte_source", "byte_dist", "bit_count", "bit64depth", "bit32rate", "bit_length", "bit2Depth", "bit2rate", "bit_deep", "byte_len"], "ret": ["abc", "gc", "row", "reg", "mem", "alt", "entry", "val", "rc", "reply", "obj", "arg", "res", "col", "arr", "feat", "rev", "result", "seq", "batch", "orig", "resp", "success", "ref", "aux", "rem"]}}
{"project": "FFmpeg", "commit_id": "ccce723c6d0ea1ea89ea6c47160a07d37cdeeba2", "target": 0, "func": "static int vc1_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size, n_slices = 0, i;\n\n    VC1Context *v = avctx->priv_data;\n\n    MpegEncContext *s = &v->s;\n\n    AVFrame *pict = data;\n\n    uint8_t *buf2 = NULL;\n\n    const uint8_t *buf_start = buf, *buf_start_second_field = NULL;\n\n    int mb_height, n_slices1=-1;\n\n    struct {\n\n        uint8_t *buf;\n\n        GetBitContext gb;\n\n        int mby_start;\n\n    } *slices = NULL, *tmp;\n\n\n\n    v->second_field = 0;\n\n\n\n    if(s->flags & CODEC_FLAG_LOW_DELAY)\n\n        s->low_delay = 1;\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {\n\n        /* special case for last picture */\n\n        if (s->low_delay == 0 && s->next_picture_ptr) {\n\n            *pict = s->next_picture_ptr->f;\n\n            s->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n\n\n        return buf_size;\n\n    }\n\n\n\n    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {\n\n        if (v->profile < PROFILE_ADVANCED)\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1;\n\n    }\n\n\n\n    //for advanced profile we may need to parse and unescape data\n\n    if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n        int buf_size2 = 0;\n\n        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n        if (IS_MARKER(AV_RB32(buf))) { /* frame starts with marker and needs to be parsed */\n\n            const uint8_t *start, *end, *next;\n\n            int size;\n\n\n\n            next = buf;\n\n            for (start = buf, end = buf + buf_size; next < end; start = next) {\n\n                next = find_next_marker(start + 4, end);\n\n                size = next - start - 4;\n\n                if (size <= 0) continue;\n\n                switch (AV_RB32(start)) {\n\n                case VC1_CODE_FRAME:\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start = start;\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    break;\n\n                case VC1_CODE_FIELD: {\n\n                    int buf_size3;\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start_second_field = start;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    /* assuming that the field marker is at the exact middle,\n\n                       hope it's correct */\n\n                    slices[n_slices].mby_start = s->mb_height >> 1;\n\n                    n_slices1 = n_slices - 1; // index of the last slice of the first field\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    init_get_bits(&s->gb, buf2, buf_size2 * 8);\n\n                    ff_vc1_decode_entry_point(avctx, v, &s->gb);\n\n                    break;\n\n                case VC1_CODE_SLICE: {\n\n                    int buf_size3;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                }\n\n            }\n\n        } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { /* WVC1 interlaced stores both fields divided by marker */\n\n            const uint8_t *divider;\n\n            int buf_size3;\n\n\n\n            divider = find_next_marker(buf, buf + buf_size);\n\n            if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Error in WVC1 interlaced frame\\n\");\n\n                goto err;\n\n            } else { // found field marker, unescape second field\n\n                if (avctx->hwaccel ||\n\n                    s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    buf_start_second_field = divider;\n\n                tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                if (!tmp)\n\n                    goto err;\n\n                slices = tmp;\n\n                slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!slices[n_slices].buf)\n\n                    goto err;\n\n                buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf);\n\n                init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                              buf_size3 << 3);\n\n                slices[n_slices].mby_start = s->mb_height >> 1;\n\n                n_slices1 = n_slices - 1;\n\n                n_slices++;\n\n            }\n\n            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);\n\n        } else {\n\n            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);\n\n        }\n\n        init_get_bits(&s->gb, buf2, buf_size2*8);\n\n    } else\n\n        init_get_bits(&s->gb, buf, buf_size*8);\n\n\n\n    if (v->res_sprite) {\n\n        v->new_sprite  = !get_bits1(&s->gb);\n\n        v->two_sprites =  get_bits1(&s->gb);\n\n        /* res_sprite means a Windows Media Image stream, AV_CODEC_ID_*IMAGE means\n\n           we're using the sprite compositor. These are intentionally kept separate\n\n           so you can get the raw sprites by using the wmv3 decoder for WMVP or\n\n           the vc1 one for WVP2 */\n\n        if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n            if (v->new_sprite) {\n\n                // switch AVCodecContext parameters to those of the sprites\n\n                avctx->width  = avctx->coded_width  = v->sprite_width;\n\n                avctx->height = avctx->coded_height = v->sprite_height;\n\n            } else {\n\n                goto image;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->context_initialized &&\n\n        (s->width  != avctx->coded_width ||\n\n         s->height != avctx->coded_height)) {\n\n        ff_vc1_decode_end(avctx);\n\n    }\n\n\n\n    if (!s->context_initialized) {\n\n        if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0)\n\n            goto err;\n\n\n\n        s->low_delay = !avctx->has_b_frames || v->res_sprite;\n\n\n\n        if (v->profile == PROFILE_ADVANCED) {\n\n            s->h_edge_pos = avctx->coded_width;\n\n            s->v_edge_pos = avctx->coded_height;\n\n        }\n\n    }\n\n\n\n    /* We need to set current_picture_ptr before reading the header,\n\n     * otherwise we cannot store anything in there. */\n\n    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {\n\n        int i = ff_find_unused_picture(s, 0);\n\n        if (i < 0)\n\n            goto err;\n\n        s->current_picture_ptr = &s->picture[i];\n\n    }\n\n\n\n    // do parse frame header\n\n    v->pic_header_flag = 0;\n\n    if (v->profile < PROFILE_ADVANCED) {\n\n        if (ff_vc1_parse_frame_header(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    } else {\n\n        if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"pict_type: %c\\n\", av_get_picture_type_char(s->pict_type));\n\n\n\n    if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE)\n\n        && s->pict_type != AV_PICTURE_TYPE_I) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Sprite decoder: expected I-frame\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if ((s->mb_height >> v->field_mode) == 0) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"image too short\\n\");\n\n        goto err;\n\n    }\n\n\n\n    // process pulldown flags\n\n    s->current_picture_ptr->f.repeat_pict = 0;\n\n    // Pulldown flags are only valid when 'broadcast' has been set.\n\n    // So ticks_per_frame will be 2\n\n    if (v->rff) {\n\n        // repeat field\n\n        s->current_picture_ptr->f.repeat_pict = 1;\n\n    } else if (v->rptfrm) {\n\n        // repeat frames\n\n        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;\n\n    }\n\n\n\n    // for skipping the frame\n\n    s->current_picture.f.pict_type = s->pict_type;\n\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    /* skip B-frames if we don't have reference frames */\n\n    if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) {\n\n        goto err;\n\n    }\n\n    if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) ||\n\n        (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||\n\n         avctx->skip_frame >= AVDISCARD_ALL) {\n\n        goto end;\n\n    }\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto end;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (ff_MPV_frame_start(s, avctx) < 0) {\n\n        goto err;\n\n    }\n\n\n\n    v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE);\n\n    v->s.current_picture_ptr->f.top_field_first  = v->tff;\n\n\n\n    s->me.qpel_put = s->dsp.put_qpel_pixels_tab;\n\n    s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab;\n\n\n\n    if ((CONFIG_VC1_VDPAU_DECODER)\n\n        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);\n\n    else if (avctx->hwaccel) {\n\n        if (v->field_mode && buf_start_second_field) {\n\n            // decode first field\n\n            s->picture_structure = PICT_BOTTOM_FIELD - v->tff;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n\n\n            // decode second field\n\n            s->gb = slices[n_slices1 + 1].gb;\n\n            s->picture_structure = PICT_TOP_FIELD + v->tff;\n\n            v->second_field = 1;\n\n            v->pic_header_flag = 0;\n\n            if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"parsing header for second field failed\");\n\n                goto err;\n\n            }\n\n            v->s.current_picture_ptr->f.pict_type = v->s.pict_type;\n\n\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        } else {\n\n            s->picture_structure = PICT_FRAME;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        }\n\n    } else {\n\n        if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err; // This codepath is still incomplete thus it is disabled\n\n\n\n        ff_er_frame_start(s);\n\n\n\n        v->bits = buf_size * 8;\n\n        v->end_mb_x = s->mb_width;\n\n        if (v->field_mode) {\n\n            uint8_t *tmp[2];\n\n            s->current_picture.f.linesize[0] <<= 1;\n\n            s->current_picture.f.linesize[1] <<= 1;\n\n            s->current_picture.f.linesize[2] <<= 1;\n\n            s->linesize                      <<= 1;\n\n            s->uvlinesize                    <<= 1;\n\n            tmp[0]          = v->mv_f_last[0];\n\n            tmp[1]          = v->mv_f_last[1];\n\n            v->mv_f_last[0] = v->mv_f_next[0];\n\n            v->mv_f_last[1] = v->mv_f_next[1];\n\n            v->mv_f_next[0] = v->mv_f[0];\n\n            v->mv_f_next[1] = v->mv_f[1];\n\n            v->mv_f[0] = tmp[0];\n\n            v->mv_f[1] = tmp[1];\n\n        }\n\n        mb_height = s->mb_height >> v->field_mode;\n\n        for (i = 0; i <= n_slices; i++) {\n\n            if (i > 0 &&  slices[i - 1].mby_start >= mb_height) {\n\n                if (v->field_mode <= 0) {\n\n                    av_log(v->s.avctx, AV_LOG_ERROR, \"Slice %d starts beyond \"\n\n                           \"picture boundary (%d >= %d)\\n\", i,\n\n                           slices[i - 1].mby_start, mb_height);\n\n                    continue;\n\n                }\n\n                v->second_field = 1;\n\n                v->blocks_off   = s->mb_width  * s->mb_height << 1;\n\n                v->mb_off       = s->mb_stride * s->mb_height >> 1;\n\n            } else {\n\n                v->second_field = 0;\n\n                v->blocks_off   = 0;\n\n                v->mb_off       = 0;\n\n            }\n\n            if (i) {\n\n                v->pic_header_flag = 0;\n\n                if (v->field_mode && i == n_slices1 + 2) {\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Field header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                } else if (get_bits1(&s->gb)) {\n\n                    v->pic_header_flag = 1;\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Slice header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n            s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height);\n\n            if (!v->field_mode || v->second_field)\n\n                s->end_mb_y = (i == n_slices     ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            else\n\n                s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            if (s->end_mb_y <= s->start_mb_y) {\n\n                av_log(v->s.avctx, AV_LOG_ERROR, \"end mb y %d %d invalid\\n\", s->end_mb_y, s->start_mb_y);\n\n                continue;\n\n            }\n\n            ff_vc1_decode_blocks(v);\n\n            if (i != n_slices)\n\n                s->gb = slices[i].gb;\n\n        }\n\n        if (v->field_mode) {\n\n            v->second_field = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n\n                memcpy(v->mv_f_base, v->mv_f_next_base,\n\n                       2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));\n\n            }\n\n            s->current_picture.f.linesize[0] >>= 1;\n\n            s->current_picture.f.linesize[1] >>= 1;\n\n            s->current_picture.f.linesize[2] >>= 1;\n\n            s->linesize                      >>= 1;\n\n            s->uvlinesize                    >>= 1;\n\n        }\n\n        av_dlog(s->avctx, \"Consumed %i/%i bits\\n\",\n\n                get_bits_count(&s->gb), s->gb.size_in_bits);\n\n//  if (get_bits_count(&s->gb) > buf_size * 8)\n\n//      return -1;\n\n        if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err;\n\n        if(!v->field_mode)\n\n            ff_er_frame_end(s);\n\n    }\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\nimage:\n\n        avctx->width  = avctx->coded_width  = v->output_width;\n\n        avctx->height = avctx->coded_height = v->output_height;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            goto end;\n\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n\n        if (vc1_decode_sprites(v, &s->gb))\n\n            goto err;\n\n#endif\n\n        *pict      = v->sprite_output_frame;\n\n        *data_size = sizeof(AVFrame);\n\n    } else {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            *pict = s->current_picture_ptr->f;\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            *pict = s->last_picture_ptr->f;\n\n        }\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *data_size = sizeof(AVFrame);\n\n            ff_print_debug_info(s, pict);\n\n        }\n\n    }\n\n\n\nend:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return buf_size;\n\n\n\nerr:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return -1;\n\n}\n", "idx": 5567, "substitutes": {"avctx": ["navbc", " avcam", " avctrl", "svcmp", " avcb", "aveqa", "navcam", "abcmp", "navcontext", "avcb", "afctx", "apctx", "ajcb", "avqa", "AVcb", "ajctx", "navctx", " avcontext", "abconfig", "allconn", "aucontext", "avcam", "appconn", "svcam", "AVloc", "afcmp", "avcmp", "akctx", "abcontext", "apconfig", "AVcmp", "akconn", "avchan", "avctrl", "avbc", "avcas", "auchan", "AVcas", "apcmp", "vercontext", "avconfig", "AVcontext", "avcms", "allctx", "avcontext", "ajctrl", "verloc", "aucmp", "afqa", "avloc", "avconn", "abctx", "auloc", "allcms", "AVcam", "auqa", "appctx", "apcontext", "avectx", "svcontext", "aucas", "AVctx", "allcam", "akcms", "AVctrl", "akcam", "avechan", "afbc", "verctx", "appcam", "vercas", "afchan", " avbc", "appcms", "afcontext", "afconfig", "afcam", "ajcontext", "auctx", "avecmp", "svctx"], "data": ["buff", "block", "open", "a", "parent", "dat", "device", "value", "config", "b", "database", "ad", "queue", "body", "image", "window", "picture", "f", "client", "content", "media", "d", "length", "DATA", "buffer", "message", "raw", "Data", "pad", "bytes", "result", "p", "input", "batch", "reader", "frame", "memory", "capt", "video", "sample", "text", "cache", "aux", "current", "src", "img", "audio"], "data_size": ["data2length", "page_type", "data_type", "page_SIZE", " data_address", "data_address", "data_SIZE", " data_string", "data2size", " data_length", "data6length", "page_len", "data6size", "data2address", "data6address", "data_length", "data2string", "data_string", "data_len", "page_size", "data6string"], "avpkt": ["avfacket", "AVfacket", "avejpacket", "avfkt", "avupkt", "avupeth", "avejpki", "avdeth", "avpacket", "avfka", "afckt", "avupacket", "avpunch", "avPki", "avlpkt", "AVpke", "avjpki", "avPkt", "afcacket", "avdkt", "avdunch", "AVpka", "avjpcht", "avdacket", "avbpacket", "avepacket", "avlpacket", "avcunch", "afpeth", "afpkt", "avckt", "avpka", "avepcht", "avpeth", "avejpkt", "afceth", "avjpacket", "avepki", "avlpcht", "avdke", "AVpacket", "avbpka", "afpacket", "avPcht", "avjpkt", "avbpke", "avejpcht", "AVfkt", "AVfka", "avceth", "afpunch", "avlpki", "afcunch", "AVfke", "avbpkt", "avdka", "avpki", "avpcht", "avepkt", "avPacket", "avpke", "avupunch", "avcacket", "avfke", "AVpkt"], "buf": ["cas", "cp", "buff", "vec", "block", "box", "Buff", "rb", "config", "rc", "BU", "queue", "uc", "loc", "fb", "wb", "uf", "window", "lit", "conv", "buffer", "code", "bag", "Buffer", "port", "cmd", "ctx", "pad", "bc", "fp", "cb", "feat", "seq", "context", "batch", "fab", "prop", "alloc", "proc", "cap", "capt", "func", "fd", "cf", "br", "cv", "ref", "pb", "aux", "fi", "src", "img", "ff"], "i": ["ti", "I", "ci", "b", "x", "si", "slice", "m", "image", "l", "f", "pi", "conv", "d", "ii", "j", "ai", "u", "k", "t", "n", "p", "c", "ip", "g", "ind", "li", "ui"], "v": ["nv", "vim", "vg", "vd", "vm", "vid", "V", "va", "vt", "vic", "b", "m", "uv", "l", "f", "conv", "j", "ve", "q", "tv", "vi", "u", "vs", "w", "t", "n", "volt", "p", "vp", "sv", "iv", "vert", "c", "lv", "ov", "video", "vv", "cv", "vc", "vu"], "s": ["serv", "sf", "S", "b", "support", "f", "d", "service", "conf", "w", "self", "h", "sp", "sa", "g", "sym", "sets", "is", "spec", "slice", "services", "server", "sl", "ls", "ops", "ds", "ts", "share", "sv", "fs", "sq", "rs", "summary", "sg", "comments", "sync", "ses", "j", "sci", "cs", "u", "vs", "e", "sb", "ks", "secondary", "t", "qs", "p", "c", "os", "ssl", "sup", "r", "ps", "o", "scope", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "us", "ss", "gs", "storage", "n", "su", "es", "js"], "pict": ["stat", "fat", "pid", "ch", "buff", "asa", "config", "si", "image", "csv", "picture", "obj", "mot", "phot", "sci", "ctr", "conf", "sc", "cam", "ctx", "feat", "Pict", "seq", "pic", "fig", "doc", "proc", "capt", "ct", "sq", "txt", "photo", "fi", "img", "conn", "Pic"], "buf2": ["uf2", "buf3", "uf3", "buffer0", " buf1", "buff3", "buff4", " buf3", "uf4", "buf4", "buff2", "buf0", "uf1", "buff1", "buff0", "buf1", "buffer2", "buffer1", "uf0", " buf4", "buffer4"], "buf_start": ["buf2len", "buf2start", "buf_len", "buf_end", "buf2end", "cv_end", "buf_stop", "cv_start", "buf2stop", "cv_len", "cv_stop"], "buf_start_second_field": ["buf_start_second__flag", "buf_start_second__field", "buf_start_second__fields", "buf_start_second_flag", "buf_start_first_flag", "buf_start_second_fields", "buf_start_first_fields", "buf_start_first_field"], "mb_height": ["mb_last", "buf_last", "mb_size", "buflexwidth", "buflexsize", "buf_height", "buflexheight", "mb_width", "buf_width", "buflexlast", "buf_size"], "slices": ["sifes", "seales", "sslice", "splaye", "ssplayed", "slice", "ssplayions", "sslicions", "sealed", "sliced", "sslices", "seale", "ssplayes", "splayions", "slicions", "splayed", "sifed", "sife", "splayes", "sealions", "ssplaye", "ssliced", "sifions"], "tmp": ["cmp", "st", "mpeg", "etc", "vid", "config", "bg", "fb", "csv", "mp", "conv", "media", "stuff", "obj", "ctr", "cam", "bis", "cb", "temp", "xxx", "proc", "txt", "video", "params", "cv", "cache", "src", "img", "videos"], "size": ["address", "name", "SIZE", "position", "shape", "send", "body", "image", "unit", "capacity", "content", "offset", "length", "small", "gz", "Size", "code", "en", "file", "message", "storage", "sized", "empty", "scale", "ize", "mode"], "n_slices": ["n_seales", "n_slicES", "n_sece", "n_inseales", "n_slinge", "n_secse", "n_slice", "n_inseale", "n_secES", "n_slicse", "n_inslice", "n_insealse", "n_sealse", "n_inslicse", "n_insealES", "n_slingse", "n_slingES", "n_slinges", "n_inslices", "n_seces", "n_sealES", "n_seale", "n_inslicES"]}}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "func": "void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)\n\n{\n\n    bs->detect_zeroes = blk->root_state.detect_zeroes;\n\n}\n", "idx": 5581, "substitutes": {"blk": ["frck", " blkt", "Blb", "blkt", "Blck", " blck", "Blkt", " bldk", "blck", "frdk", "BLkt", "bldk", "Bldk", "BLck", " blb", "BLk", "Blk", "frb", "BLb", "blb", "frk"], "bs": ["bas", "base", "as", "BC", "bits", "plugins", "rb", "bg", "b", "bi", "BS", "obs", "fb", "ns", "ls", "cs", "ss", "vs", "sb", "ops", "gs", "ds", "bytes", "bc", "ba", "blocks", "boot", "gb", "fs", "SB", "os", "bos", "bid", "br", "ps", "bl", "pb", "rs", "bn", "bh"]}}
{"project": "qemu", "commit_id": "42119fa3568dc7e8c82447c861678a5987d06d91", "target": 0, "func": "vcard_emul_mirror_card(VReader *vreader)\n\n{\n\n    /*\n\n     * lookup certs using the C_FindObjects. The Stan Cert handle won't give\n\n     * us the real certs until we log in.\n\n     */\n\n    PK11GenericObject *firstObj, *thisObj;\n\n    int cert_count;\n\n    unsigned char **certs;\n\n    int *cert_len;\n\n    VCardKey **keys;\n\n    PK11SlotInfo *slot;\n\n    VCard *card;\n\n\n\n    slot = vcard_emul_reader_get_slot(vreader);\n\n    if (slot == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    /* count the certs */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    /* allocate the arrays */\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    /* fill in the arrays */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        /* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in */\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); /* key obj still has a reference */\n\n    }\n\n\n\n    /* now create the card */\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n", "idx": 5582, "substitutes": {"firstObj": [" firstOb", "firstPart", "firstExt", "thisExt", "firstPo", " firstVol", "thirdObj", "frontObj", " firstInst", "firstVo", " firstOrg", " firstObject", "prevObj", "firstObject", "frontInd", "firstInst", " firstVo", "prevInd", "thisPtr", "topObj", "firstVal", " firstExt", "thisObject", "thirdInst", "topPart", "firstOb", " firstPart", "firstPtr", "topVo", "thisVo", "FirstVol", "firstVol", "topPtr", "frontOb", "firstInd", "frontOrg", " firstPo", "prevOb", "thisOb", "firstOrg", "prevOrg", "topObject", "topVal", "thirdOb", "thirdObject", "thisVol", " firstInd", " firstPtr", "topPo", "thirdPo", "FirstObj", "topOb", " firstVal", "FirstExt", "FirstObject", "thisInst"], "thisObj": ["transOb", "differentOb", "sharedObj", "firstExt", "differentInd", "theseObj", "THISObj", "THISExt", " thisVol", "selfOb", "firstAct", "thisObject", "ThisObj", "sharedExt", " thisCh", "sharedAct", "oneObj", "thisVol", "currentCh", "oneObject", " thisOb", "ThisInst", "thisExt", " thisobj", "thisInd", "currentObj", "thisAct", "selfExt", "firstVol", "THISObject", "ThisExt", "thisCh", "thisOb", "differentobj", "sharedOb", "primaryExt", "transObject", " thisExt", "differentAct", "primaryObj", "selfObj", "primaryOb", "differentObject", "theseObject", "transInd", "transObj", "theseCh", " thisInd", "ThisObject", " thisAct", "transVol", "THISInst", "oneExt", "primaryInd", " thisObject", "firstObject", "currentObject", "oneOb", " thisInst", "firstOb", "thisobj", "differentObj", "selfObject", "firstInd", "ThisOb", "differentExt", "Thisobj", "thisInst"], "cert_count": ["ver_size", "config_count", "cert6count", "key_length", "configncounter", "file_number", "file_low", "acc6sum", "cert_base", "cert8low", "acc6count", " cert_length", "config_cache", "certacloop", "acc_length", "certxlen", "certIPcount", "certldepth", " cert_width", "certIPnumber", "fileaccount", "certIPoffset", "key_count", "file_count", "certncache", "certIPgroup", " cert_group", "cert_limit", "cert_loop", "acc_counter", "cert0depth", "cert_coll", "cert8size", "confignlen", "certLcoll", "fileacnumber", "certllow", "cert_max", "cert6counter", "certIPCount", "certNCount", "cert0width", "cert0count", "file_loop", "acc_count", "cert8count", "certNoffset", "ver_count", "cert_group", "key_total", "cert_size", " cert_base", "cert_cache", "configncount", "cert_offset", "certIPmax", "certIPcoll", " cert_size", "acc6length", "ver_coll", "cert_total", "acc6counter", "cert_low", "certLcount", "cert6length", "certacnumber", "fileacloop", "certLsize", "cert_width", "certaccount", "config_counter", "cert6sum", "ver_max", "certlwidth", "certIPlength", "certIPsize", "acc_sum", "certlsize", " cert_number", "fileaclow", "cert_sum", "certNcount", " cert_Count", "certnlen", " cert_depth", "certIPtotal", "certaclow", "certNgroup", "certncounter", "certlnumber", "certxlimit", "certxcount", "certlcount", "cert_length", " cert_offset", "cert_Count", " cert_low", "cert0size", "key_limit", "certIPlow", "cert_depth", "certIPloop", "certncount", "cert8number", "configncache", "certLmax", "key_len", "cert_counter", "config_len", "cert_number"], "certs": ["Certd", "clses", "configs", "contractes", "Certsets", "Certerences", "certls", "cles", " certes", "configes", "Certls", " certls", " certabs", "certks", "cld", "Certs", "configses", "reqks", "cls", "contracts", "certses", "reqses", "reqs", "reqabs", "certes", " certerences", "Certabs", "contractd", "Certks", "reqerences", "configabs", "contractses", "certerences", "reqes", " certsets", "Certes", "certd", "reqls", "certabs", "reqsets", "certsets", "Certses", " certks"], "cert_len": ["secret9lan", "cert6count", "key_length", "secret9len", "key_val", "cert\u00b7diff", "cert5count", "cert9Len", "cert_Len", "cert8len", "key_Len", "cert5log", " cert_den", "cert64li", "cert8den", "key_count", "cert5len", "cert9li", "cert\u00b7Len", "cert_den", "cert6val", "cert9lan", "tr5len", "cert\u00b7length", "secret_len", "cert8Len", "cert8count", "tr_log", "tr_len", "tr5count", "secret9li", "key_diff", "cert_fin", "tr_count", "cert5width", "cert_width", "cert64len", "key_fin", "cert_li", "tr_width", "cert_val", "secret_lan", "secret9Len", "tr5log", "cert9len", "cert64lan", "secret_li", "secret_Len", "cert_diff", " cert_Len", "cert_length", "cert6len", "cert64Len", "cert_log", "cert6fin", "cert\u00b7len", "key_len", "tr5width", "cert_lan"], "keys": ["groups", "types", "options", "files", "properties", "owners", "users", "drivers", "values", "rows", "ses", "services", "links", "names", "ips", "cats", "key", "vals", "states", "codes", "parts", "ns", "parents", "windows", "args", "ports", "stars", "cs", "ics", "fields", "ks", "ops", "locks", "ds", "k", "qs", "headers", "chains", "vers", "rings", "ors", "pieces", "trans", "fs", "members", "cards", "letters", "Keys", "items", "errors", "ms", "ids", "params", "lines", "ps", "checks", "lists"], "slot": ["game", "plugin", "option", "vol", "Slot", "host", "bin", "block", "entry", "parent", "trial", "pin", "scope", "channel", "session", "shadow", "layout", "socket", "secret", "object", "slice", "token", "bit", "cat", "module", "loc", "image", "key", "snap", "sl", "tab", "service", "sid", "space", "part", "cell", "zone", "acl", "connection", "lot", "comment", "storage", "lib", "lock", "share", "pool", "spot", "parse", "shot", "pos", "pointer", "location", "type", "oid", "git", "group", "index", "account", "biz", "hole", "role"], "card": ["cmp", "gc", "row", "id", "entry", "parent", "bug", "list", "style", "format", "cat", "record", "circ", "draw", " cards", "mac", "valid", "cart", "event", "letter", "book", "carry", "cc", "match", "arc", "crit", "cont", "cell", "ce", "comment", "ard", "file", "day", "raw", "cube", "pass", "load", "controller", "coll", "result", "parse", "car", "cand", "cards", "Card", "node", "class", "cf", "lc", "board", "cookie", "cache", "index", "host", "ARD"], "derCert": ["DERExt", "derKey", "derTr", "derPriv", "DERServ", "dercert", "DerKey", "derAlt", "oderDoc", "DerVal", "drExt", "derServ", "derFac", "DerDoc", "DERCert", "terAlt", "DerCert", "DerTr", "drFac", "drCert", "derExt", "serFac", "serTr", "DERMult", "drMult", "DerServ", "serAlt", "DerExt", "drKey", " derDoc", "DerAlt", "DerMult", "serCert", " derKey", "derVal", "derDoc", "DERcert", " derVal", "drTr", "oderKey", "DERVal", "serPriv", "DerPriv", "DERKey", " derServ", "terCert", "Dercert", "oderCert", "DerFac", " dercert", "derMult", "terPriv"], "cert": ["cook", "del", "cr", "cur", "alt", "acc", "dat", "config", "val", "tr", "secret", "cat", "compl", "pt", "trust", "enter", "fake", "key", "valid", "html", "ext", "Cert", "att", "url", "order", "call", "ctr", "ert", "conf", "crit", "con", "ce", "sign", "fac", "cb", "str", "result", "pub", "temp", "ca", "font", "req", "opt", "vert", "sp", "cand", "ver", "ind", "txt", "contract", "ssl", "user", "cf", "ct", "pair", "text", "pl", "test", "date", "cot", "cel"], "rv": [" rval", "rp", "Rval", " rb", "rval", " rp", "rb", "vrV", "rf", "vrv", "vrval", "vrf", " rV", "Rb", "srV", "Rp", "srf", "Rf", "rV", " rf", "Rv", "RV", "srv", "srp", "srb"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n", "idx": 5587, "substitutes": {"curtime": ["urtime", " curname", "gusize", "chartime", "schesize", "drtimer", "curuser", "factim", "scheyear", "gucase", "cart", "lattim", "Curuser", " curTime", "urkey", "curtim", "clientm", "clientspace", "factime", "gukey", "cartimes", "drtim", "latvalue", "chevalue", " curclass", "sertimes", "curclass", "urm", "chetim", "cursize", "cardate", " cursize", "chartim", "chetime", "cattime", "urbase", " curbase", " curspace", "urspace", "curmoney", " curtimer", "urcase", "facname", "curspace", "schetime", " curset", " curdef", "gudef", "sertime", "drtime", "uruser", "sert", "scheset", "serdate", " curm", " curuser", "charmoney", " curtim", "cartime", "guyear", "curm", "cattim", "curTime", " curdate", "curkey", "latclass", " curyear", "clientbase", "cattimer", "curcase", "checlass", "lattime", "curset", "curdef", "facmoney", "urTime", "curtimer", "curname", "urdef", " curkey", "gutime", "CurTime", "curvalue", "charname", "curt", "clienttime", "Curtime", "curyear", " curcase", "curdate", " curtimes", " curt", "guset", "curtimes", " curmoney", "curbase", " curvalue"], "bcd_time": ["bcd__time", "bcd__hour", "bnd_Time", "bmd_hour", "bcd_clock", "bmd_rate", "bcd__rate", "bnd_clock", "bnd_hour", "bcd__c", "bcd_Time", "bmd_time", "bmd_c", "bnd_rate", "bcd_rate", "bnd_time", "bcd_hour", "bcd_c"]}}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n", "idx": 5607, "substitutes": {"cookie": ["cook", "gi", "name", "gc", "cfg", "domain", "extra", "qq", "fee", "vid", "ookie", "session", "nc", "data", "secret", "token", "cat", "co", "info", "event", "child", "url", "cc", "sid", "byte", "ce", "conf", "code", "zone", "menu", "path", "timeout", "cb", "container", "ticket", "temp", "cost", "request", "rule", "c", " cookies", "custom", "label", "query", "inner", "cache", "cdn", "conn", "prefix"], "flow": ["progress", "wall", "force", "ow", "fly", "route", "cart", "f", "flows", "create", "flo", "go", "fp", "pool", "front", "view", "base", "row", "ork", "fw", "fee", "parent", "layout", "fx", "grade", "fl", "loop", "comment", "zip", "driver", "allow", "fall", "work", "one", "fail", "fs", "node", "rule", "model", "cf", "Flow", "element", "cow", "form", "account", "low", "game", "feed", "block", "note", "io", "sync", "use", "image", "ga", "ce", "out", "instance", "frame", "ge", "gen", "board", "cache", "balance", "bug", "card", "draw", "client", "child", "call", "control", "full", "forward", "container", "load", "week", "qa", "request", "lane"]}}
{"project": "FFmpeg", "commit_id": "fc9b22dd2e5de851a89245b5357e710b93587278", "target": 0, "func": "static int rtp_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    RTPContext *s;\n\n    int port, is_output, ttl, local_port;\n\n    char hostname[256];\n\n    char buf[1024];\n\n    char path[1024];\n\n    const char *p;\n\n\n\n    is_output = (flags & URL_WRONLY);\n\n\n\n    s = av_mallocz(sizeof(RTPContext));\n\n    if (!s)\n\n        return AVERROR(ENOMEM);\n\n    h->priv_data = s;\n\n\n\n    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,\n\n              path, sizeof(path), uri);\n\n    /* extract parameters */\n\n    ttl = -1;\n\n    local_port = -1;\n\n    p = strchr(uri, '?');\n\n    if (p) {\n\n        if (find_info_tag(buf, sizeof(buf), \"ttl\", p)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (find_info_tag(buf, sizeof(buf), \"localport\", p)) {\n\n            local_port = strtol(buf, NULL, 10);\n\n        }\n\n    }\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port, local_port, ttl);\n\n    if (url_open(&s->rtp_hd, buf, flags) < 0)\n\n        goto fail;\n\n    local_port = udp_get_local_port(s->rtp_hd);\n\n    /* XXX: need to open another connection if the port is not even */\n\n\n\n    /* well, should suppress localport in path */\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port + 1, local_port + 1, ttl);\n\n    if (url_open(&s->rtcp_hd, buf, flags) < 0)\n\n        goto fail;\n\n\n\n    /* just to ease handle access. XXX: need to suppress direct handle\n\n       access */\n\n    s->rtp_fd = udp_get_file_handle(s->rtp_hd);\n\n    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);\n\n\n\n    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);\n\n    h->is_streamed = 1;\n\n    return 0;\n\n\n\n fail:\n\n    if (s->rtp_hd)\n\n        url_close(s->rtp_hd);\n\n    if (s->rtcp_hd)\n\n        url_close(s->rtcp_hd);\n\n    av_free(s);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 5617, "substitutes": {"h": ["H", "hp", "ah", "hw", "ch", "o", "v", "http", "ih", "hand", "x", "b", "oh", "uh", "m", "rh", "l", "cl", "f", "d", "j", "q", "hs", "ph", "hm", "sh", "e", "t", "hh", "hl", "he", "n", "eh", "z", "ht", "c", "gh", "g", "hr", "ha", "host", "bh"], "uri": ["uni", "address", "gi", "base", "iri", "origin", "id", "http", "component", "username", "ri", "data", "io", "i", "format", "slice", "abi", "database", "qi", "route", "resource", "URI", "href", "url", "prot", "cli", "u", "dir", "fp", "mi", "str", "filename", "source", "iv", "ip", "range", "api", "query", "text", "r", " URI", "ui", "prefix"], "flags": ["types", "options", "files", "properties", "flag", "sf", "local", "bits", "caps", "Flags", "features", "atts", "ags", "offs", "ages", "comments", "plugins", "format", "links", "mask", "lag", "ips", "status", "vals", "FLAG", "planes", "ants", "f", "parts", "alf", "prot", "ats", "stats", "args", "fl", "opens", "ffff", " Flags", "linux", "ints", "fields", "faces", "ops", "settings", "fs", "fun", "utils", "errors", "items", "fd", "utf", "orts", "lf", "lines", "reads", "ff"], "s": ["sf", "S", "b", "socket", "i", "sk", "f", "parts", "d", "service", "bs", "hs", "conf", "sports", "w", "aws", "sa", "g", "sym", "y", "sets", "is", "spec", "services", "sl", "ls", "sh", "sc", "ops", "ds", "ctx", "ts", "settings", "sv", "fs", "sq", "site", "rs", "as", "ins", "sg", "sn", "ses", "j", "cs", "u", "e", "sb", "ks", "t", "qs", "source", "c", "os", "ssl", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "xs", "ns", "us", "ss", "gs", "storage", "n", "su", "es", "js"], "port": ["patch", "ure", "address", "mobile", "ocol", "pid", "name", "position", "v", "id", "method", "http", "ress", "PORT", "phone", "component", "username", "password", "slice", "m", "key", "f", "pi", "project", "offset", "post", "version", "url", "length", "sl", "ports", "server", "limit", "select", "code", "target", "col", "file", "hop", "prefix", "pos", "line", "direction", "import", "ip", "type", "page", "ort", "rest", "text", "test", "index", "host", "end", " transport"], "is_output": ["isckoutput", " is_default", " is_out", "is_progress", " is_format", " is_progress", "isckformat", "isckwritten", "is_default", "is_written", "is_format", " is_written", "isckout", "is_out"], "ttl": ["rtlen", "ntl", "ottl", "ottp", "tzd", "ntn", "ttn", "zzol", "ottli", "ottul", "tsol", "ttol", "ettl", "ettp", "ntll", "gylen", "tst", "tzlc", "ettll", "ntt", "gtlc", "rtp", "optt", "gtli", "optn", "ottol", "ettb", "ottlc", "tzl", "gyl", "rttl", "rtt", "ttll", "tsn", "zzl", "optll", "ttp", "rtl", "ottd", "tstl", "ttt", "ttlc", "gtl", "gtd", "tsli", "tttl", "tsl", "gyt", "optl", "ttd", "ottb", "zzul", "zzli", "ttb", "tsll", "gytl", "ttli", "ottll", "ttlen", "rtll", "ttul", "rtb", "tzli", "tsul", "tslen"], "local_port": ["localtheport", "local_value", "localthehost", " local_ports", "localtheports", "localityhost", " local_line", " local_slice", "global_prefix", "localvelhost", "local_prefix", " local_nat", " local_host", "localityport", "global_ports", "local67port", "remote_value", "local_line", "local67host", "local67value", "localvelports", "global_port", "localvelport", "localityslice", "local_address", "localvelnat", "remote_port", "local_ports", "local_nat", "localityline", "global_address", "local_pod", "remote_pod", "localveladdress", "local_slice", "remote_ports", "localtheprefix", "local_host", "remote_host", "global_host", "local67pod"], "hostname": ["serverName", " hostna", "hostnames", "homepath", "Hostname", " hostnam", "servername", "hostName", "homename", " hostpath", "hardline", " hostno", "fullnames", "portpart", "hardno", "hardName", "containername", "fullname", "containerpart", "hardnames", "hostpath", "hardpath", "hostsize", " hostnames", "Hostline", "fullsize", " hostName", " hostsize", "hostnam", "fullName", "hardname", "serverna", "serverno", "hostna", "portnames", " hostpart", "Hostsize", "containernames", "hardnam", "servernames", "hostline", "hostpart", "serverline", "hardna", "portname", "homenam", "hostno", "HostName", "Hostnames"], "buf": ["padding", "rb", "b", "data", "queue", "uc", "f", "buffer", "len", "code", "mount", "bag", "file", "func", "bc", "fp", "callback", "array", "pool", "proc", "front", "pb", "img", "bh", "msg", "base", "cur", "count", "config", "val", "fb", "null", "uf", "loop", "binary", "ctx", "filename", "font", "batch", "txt", "text", "feed", "vec", "block", "box", "rc", "home", "map", "loc", "grab", "wb", "ph", "Buffer", "cmd", "feat", "begin", "prop", "c", "fd", "cache", "ref", "src", "prefix", "buff", "v", "http", "la", "Buff", "window", "bus", "length", "cb", "seq", "context", "br", "cv", "pkg"], "path": ["name", "anc", "bin", "id", "box", "method", "parent", "http", "value", "config", "password", "rc", "data", "alias", "home", "stream", "cat", "loc", "route", "key", "resource", "content", "url", "Path", "ph", "dir", "code", "buffer", "mount", "full", "file", "cmd", "str", "context", "temp", "root", "PATH", "prop", "ath", "pointer", "request", "proc", "type", "board", "text", "desc", "ref", "cache", "host", "prefix"], "p": ["cp", "P", "o", "bp", "padding", "v", "pr", "parent", "pa", "pre", "po", "pp", "b", "data", "i", "op", "wp", "pe", "lp", "ap", "m", "l", "null", "f", "pi", "pc", "py", "param", "np", "u", "part", "e", "parser", "pn", "t", "n", "fp", "jp", "vp", "prop", "sp", "pointer", "proc", "c", "ip", "type", "api", "tp", "params", "pb", "r", "ps", "pkg", "prefix"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n\n                                       PutBitContext *pb, const float *in,\n\n                                       const float *scaled, int size, int scale_idx,\n\n                                       int cb, const float lambda, const float uplim,\n\n                                       int *bits)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    float cost = 0;\n\n    int qc1, qc2, qc3, qc4;\n\n    int curbits = 0;\n\n\n\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    for (i = 0; i < size; i += 4) {\n\n        const float *vec, *vec2;\n\n        int curidx, curidx2, sign1, count1, sign2, count2;\n\n        int   *in_int = (int   *)&in[i];\n\n        float *in_pos = (float *)&in[i];\n\n        float di0, di1, di2, di3;\n\n        int t0, t1, t2, t3, t4;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 8 * qc1;\n\n        curidx += qc2;\n\n\n\n        curidx2 = 8 * qc3;\n\n        curidx2 += qc4;\n\n\n\n        curbits += p_bits[curidx];\n\n        curbits += upair7_sign_bits[curidx];\n\n        vec     = &p_codes[curidx*2];\n\n\n\n        curbits += p_bits[curidx2];\n\n        curbits += upair7_sign_bits[curidx2];\n\n        vec2    = &p_codes[curidx2*2];\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n", "idx": 5621, "substitutes": {"s": ["spec", "session", "b", "sync", "sys", "ses", "f", "ls", "ss", "cs", "e", "sc", "sb", "ops", "gs", "ds", "ts", "p", "sv", "fs", "sa", "c", "proc", "g", "ssl", "ps", "setup"], "pb": ["abc", "cp", "bp", "ib", "rb", "kB", "pd", "bps", "pp", "wp", "lp", "ses", "fb", "pm", "pg", "pc", " p", "sb", "bc", "PB", "PC", "vp", "gb", "ppa", "proc", "ub", "cv", "cpp"], "in": ["login", "complex", "bin", "ins", "pin", "config", "val", "inn", "data", "slice", "din", "image", "m", "inc", "f", "nin", "at", "gin", "d", "IN", "ints", "con", "out", "scan", "isin", "pass", "vin", "str", "In", "source", "input", "again", "ssl", "scl", "lin", "query", "inner", "index", "src", "min", "cm"], "scaled": ["SCalled", "oscraped", "Scaled", "oscaling", "stalled", "Scalled", "configalled", "scaved", "configaped", "Scilled", " Scaled", "oscalled", " Scalled", "scraped", " scaling", "expilled", "scilled", " scaved", " Scale", "SCaved", "SCaling", "expalled", "expaped", "escale", "SCaled", "expaled", " scalled", "oscaled", "escalled", "escaled", " Scaped", "scalled", " scraped", "Scaved", "scaling", "Scaling", "scale", "Scale", "stilled", "staped", "scaped", "configraped", "configaled", "Scraped", "Scaped", "escaped", " scaped", "staled"], "size": ["uni", "SIZE", "sec", "shape", "ci", "crop", "sn", "loc", "ii", "small", "Size", "ffff", "cs", "np", "six", "code", "len", "sh", "scale", "c", "sq", "ize", "cm", "mode"], "scale_idx": ["scale_initb", "scale_indb", "scale_indx", "scale_pidz", "scale_ide", "scale_idxes", "scale_idsv", "scale_nameX", "scale_idced", "scale_namex", "scale_countX", "scale_idg", "scale_idb", "scale_counte", "scale_idex", "scale_indxes", "scale_pidg", "scale_initced", "scale_idsx", "scale_idX", "scale_idz", "scale_indced", "scale_ideced", "scale_countxp", "scale_namee", "scale_idsz", "scale_countx", "scale_initx", "scale_ideb", "scale_idsg", "scale_pidx", "scale_namexp", "scale_idxp", "scale_idv", "scale_pidv", "scale_initxes", "scale_idexes"], "cb": ["abc", "CB", "cmp", "lb", "buff", "obb", "rb", "crop", "ob", "nc", "kk", "repeat", "uc", "uv", "cm", "fb", "db", "wb", "buf", "abb", "bb", "ctr", "loop", "cpp", "sb", "dc", "cor", "ctx", "bc", "nb", "gb", "kb", "bf", "cf", "core", "lc", "fc", "cv", "cod", "src", "ctrl", "cd", "ff", "low"], "lambda": ["abc", "UC", "alpha", "la", "beta", "shape", " disp", "nc", "circ", "appa", " gamma", "cl", "phi", " la", " lam", "da", "func", "dc", "qa", "LA", "mega", " beta", "sq", "igma", " sig", "mu"], "uplim": ["Uplength", "uplims", "usplength", "usplims", "uplength", "Uplim", "uclims", "uclam", "uPLam", "Uclims", "uclim", "Uplims", "usplim", "uPLims", "Uclim", "uplam", "uPLength", "uclength", "usplam", "Uplam", "Uclength", "Uclam", "uPLim"], "bits": ["bands", "features", "b", "bps", "bit", "rows", "its", "ips", "pins", "planes", "forces", "bs", "ints", "units", "ops", "bis", "bytes", "fps", "blocks", "batch", "pieces", "gb", "pos", "ps", "flags"], "i": ["uni", "gi", "ei", "ti", "v", "id", "I", "is", "chi", "a", "di", "ci", "ji", "ni", "xi", "x", "si", "b", "io", "abi", "slice", "info", "bi", "qi", "ix", "l", "f", "pi", "yi", "phi", "adi", "j", "ii", "iu", "ij", "it", "ai", "uli", "my", "u", "e", "uri", "k", "n", "multi", "mi", "vis", "ini", "ie", "p", "mini", "h", "z", "eni", "iv", "sup", "oi", "c", "ip", "ind", "y", "type", "li", "inner", "fi", "index", "zi", "min", "mu", "ui"], "qc1": ["sqc1", " qcone", " qc8", "qcone", "qdc91", "qsc1", "qdc2", "qcs8", "qsc4", "qc91", "qsc2", "sqc2", "qdc4", "ql91", " qdc1", "sqc4", " qdc2", "qcs2", "qdcone", "ql4", "ql2", "qf1", "qc8", " qdc8", "qf2", "sqsc91", "qf8", "qdc8", "sqsc4", "ql1", "sqc91", "qfone", " qdcone", "qcs1", "sqsc1", "sqsc2", "qcsone", "qdc1", "qsc91"], "qc2": ["qcr2", "qsc42", " qc8", "kc32", "qlc32", "qce8", "qrFuture", "qc32", " qrFuture", "klc32", "kc42", "kc8", "qcs8", "qsc2", "qcs182", "qlc2", "qcsFuture", "qlc8", "qc42", "qcs2", "qr182", " qr2", "qlc42", "qceFuture", "klc42", "qc8", "qcr32", " qcFuture", " qc182", "qcr42", "qr8", "klc2", "qr2", "qc182", "qce182", "klc8", "qcFuture", " qr8", " qr182", "kc2", "qsc8", "qce2", "qsc32", "qcr8"], "qc3": ["qsc3", "qr5", "qpc8", " qc8", " qc15", " qsc3", "qp6", " qsc5", "qb8", " qcs23", " qcs6", " qc6", "qr6", "qpc5", "qcs5", "qr3", "qcs6", "qc15", " qcs5", " qcs3", "qp5", " qsc15", "qb3", "qp3", "qp23", "qc23", " qc5", "qc6", "qc5", "qc8", "qcs23", "qb15", "qsc15", "qsc5", "qcs3", "qpc15", "qr23", " qsc8", "qsc8", " qc23", "qb5", "qpc3"], "qc4": ["qvc4", " qcCore", "qf5", "qlc54", "qlcCore", " qfCore", "quc4", "qvc5", " qc7", "quc54", "quc6", " qf4", "qlc7", "quci6", "qC4", "qvc7", "qC6", "qf7", "quci4", "qc54", "qvcCore", "qlc4", "qf4", "qc7", "qci54", "qC04", "qlc04", "qci4", "qlc6", "qfCore", " qf5", "qc6", "qlc5", " qc5", "qc5", "qci6", "qc04", " qf7", "quci54", "qC54", "quci04", "qcCore", "qci04", "quc04"], "p_bits": ["p_ops", "P_flags", "p_flags", "p_bytes", "P_ops", "P_bits", "P_bytes"], "p_codes": ["p_vec", "p_desc", "c_codes", "c_desc", "c_code", "p_code", "c_vec"], "vec": ["spec", "mat", "slice", "cat", "flat", "nec", "circ", "vector", "buf", "tri", "version", "ctr", "crit", "def", "len", "sc", "cube", "feat", "str", "seq", "vert", "ver", "cap", "cv", "norm"], "vec2": ["vert1", "exp5", "exp0", "cv2", "vec1", "vec0", "vert0", "cv1", "vert5", "vert2", "cv0", "exp1", "cv5", "exp2", "vec5"], "curidx": ["curidep", "curridy", " curIdc", "curridp", " curidy", " curIdy", "curridx", "curIdy", " curidp", "curIdc", "curidey", "curidc", " curIdp", "curidp", "curridc", "curIdx", " curidc", "curidex", "curidy", " curIdx", "curidec", "curIdp"], "curidx2": ["curidx1", "curidx32", "curidn1", "curidy32", "curidy2", "curidn32", "curidz1", "curidx4", "curidz32", "curidn4", "curidz2", "curidz4", "curidn2", "curidy4", "curidy1"], "sign1": ["SignA", "Sign2", "Sign1", " signA", "sumA", "sum1", "sum2", "signA"], "count1": [" countone", " count01", "count01", "sign01", "weight01", "signone", "weightone", "weight1", "countone"], "sign2": ["count0", "sum0", "Sign2", "sum4", "Sign1", "Sign4", "sum1", "sign4", "sum2", "Sign0", "sign0", "count4"], "count2": ["patch2", "patchb", "count8", "signb", " countb", "patch8", "patch4", "sign4", "sign8", " count4", " count8", "countb", "count4"], "in_int": ["inc_ind", "inc_int", "in_float", "inc_index", "in_index", "inc_float", "in_ind"], "in_pos": ["in67rot", "in_flo", "in_rot", "in67flo", "in67position", "in67pos", "in_position", " in_flo", " in_position", " in_rot"], "di0": ["di50", "ni50", " di50", " di80", "ti50", "ni1", "di80", "ti0", "ni80", "ni0", "ti1", "ti80"], "di1": ["dim8", "d8", "ni8", "dim0", "d0", "ni1", "di8", "dim1", "dim3", "d3", "d1", "ni0", "ni3"], "di2": ["ini5", "ini4", "i5", "mi0", "ini2", "mi4", "i0", "di5", "mi2", "mi5", "ini0", "i2", "i4", "di4"], "di3": ["Di33", "di15", "bi15", "i15", "di33", "bi33", "bi3", "bi4", "i3", "Di15", "Di4", "i33", "i4", "di4", "Di3"], "t0": ["e0", " t6", "p00", "p6", "t6", "e2", "p0", "t00", "e00", "e6", " t00", "p2"], "t1": ["T2", "T0", "pt1", "pt0", "p1", "T1", "p0", "p2", "pt2"], "t2": ["T2", "T0", "pt4", "pt0", "pt1", "type4", "type0", "T1", "T4", "type2", "type1", "pt2"], "t3": ["T3", "it3", "te15", "T15", "teThree", "itThree", "tThree", "T1", "TThree", "it15", "it1", "te3", "t15", "te1"], "t4": ["it04", "T04", "T2", "T384", " t384", "t04", "it384", " t04", "it2", "T4", "t384", "it4"]}}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n", "idx": 5624, "substitutes": {"tokens": ["tokenos", "targents", "targens", "atokenents", "targets", "toksenos", "toksets", "paken", "pakenos", "token", "atokenens", "pakens", "tokenets", "pakets", "atokents", "pokets", "takens", "poken", "toksens", "atoken", "tokenens", "tokenents", "tokets", "targen", "toksen", "atokets", "toksents", "pokens", "taken", "tokents", "tokenen", "atokenets", "takets", "atokens", "pokenos", "atokenen", "takenos", "tokenenos"], "ap": ["as", "ep", "al", "pa", "gap", "ax", "apt", "AP", "mp", "at", "arp", "aper", "ak", "ar", "ape", "ab", "Ap", "apper", "aps", "jp", "p", "amp", "apy", "tap", "sp", "cap", "ip", " AP", "api", "rap", "apa", "ac", "au", "app", "rep", "ps", "af"], "errp": ["erfp", "erP", "rorpp", "erpp", " errfp", " errlp", "interfp", "errP", " errP", "interP", "err", "errlp", "rorp", "errpp", "interlp", "erlp", "interp", "errr", "erp", "errfp", " errpp", "rorr", "rorfp", " errr"], "working": ["base", "containing", "ing", "reading", "using", "padding", "testing", "workers", "works", "writing", "starting", "setting", "binding", "loading", "data", "ping", "missing", "resource", "Working", "obj", "acting", "moving", "w", "existing", "won", "raw", "calling", "learning", "looking", "ising", "work", "array", "p", "forcing", "running", "checking", "new", "opening", "processing", "packing", "inner", "going", "worker", "prefix"], "result": ["master", "complete", "parent", "value", "object", "data", "final", "valid", "resource", "results", "f", "attr", "order", "obj", "arg", "res", "match", "answer", "comment", "arr", "message", "raw", "json", "func", "df", "instance", "other", "err", "response", "work", "array", "p", "output", "root", "new", "Result", "math", "page", "product", "success", "cache", "element", "current", "next", "r", "date", "found", "dict"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int init_directories(BDRVVVFATState* s,\n\n                            const char *dirname, int heads, int secs,\n\n                            Error **errp)\n\n{\n\n    bootsector_t* bootsector;\n\n    mapping_t* mapping;\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster_buffer=g_malloc(s->cluster_size);\n\n\n\n    /*\n\n     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),\n\n     * where sc is sector_count,\n\n     * spf is sectors_per_fat,\n\n     * spc is sectors_per_clusters, and\n\n     * fat_type = 12, 16 or 32.\n\n     */\n\n    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n\n    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */\n\n\n\n    s->offset_to_fat = s->offset_to_bootsector + 1;\n\n    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;\n\n\n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n\n\n    /* add volume label */\n\n    {\n\n        direntry_t* entry=array_get_next(&(s->directory));\n\n        entry->attributes=0x28; /* archive | volume label */\n\n        memcpy(entry->name, s->volume_label, sizeof(entry->name));\n\n    }\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    s->cluster_count=sector2cluster(s, s->sector_count);\n\n\n\n    mapping = array_get_next(&(s->mapping));\n\n    mapping->begin = 0;\n\n    mapping->dir_index = 0;\n\n    mapping->info.dir.parent_mapping_index = -1;\n\n    mapping->first_mapping_index = -1;\n\n    mapping->path = g_strdup(dirname);\n\n    i = strlen(mapping->path);\n\n    if (i > 0 && mapping->path[i - 1] == '/')\n\n        mapping->path[i - 1] = '\\0';\n\n    mapping->mode = MODE_DIRECTORY;\n\n    mapping->read_only = 0;\n\n    s->path = mapping->path;\n\n\n\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n\n        /* MS-DOS expects the FAT to be 0 for the root directory\n\n         * (except for the media byte). */\n\n        /* LATER TODO: still true for FAT32? */\n\n        int fix_fat = (i != 0);\n\n        mapping = array_get(&(s->mapping), i);\n\n\n\n        if (mapping->mode & MODE_DIRECTORY) {\n\n            mapping->begin = cluster;\n\n            if(read_directory(s, i)) {\n\n                error_setg(errp, \"Could not read directory %s\",\n\n                           mapping->path);\n\n                return -1;\n\n            }\n\n            mapping = array_get(&(s->mapping), i);\n\n        } else {\n\n            assert(mapping->mode == MODE_UNDEFINED);\n\n            mapping->mode=MODE_NORMAL;\n\n            mapping->begin = cluster;\n\n            if (mapping->end > 0) {\n\n                direntry_t* direntry = array_get(&(s->directory),\n\n                        mapping->dir_index);\n\n\n\n                mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;\n\n                set_begin_of_direntry(direntry, mapping->begin);\n\n            } else {\n\n                mapping->end = cluster + 1;\n\n                fix_fat = 0;\n\n            }\n\n        }\n\n\n\n        assert(mapping->begin < mapping->end);\n\n\n\n        /* next free cluster */\n\n        cluster = mapping->end;\n\n\n\n        if(cluster > s->cluster_count) {\n\n            error_setg(errp,\n\n                       \"Directory does not fit in FAT%d (capacity %.2f MB)\",\n\n                       s->fat_type, s->sector_count / 2000.0);\n\n            return -1;\n\n        }\n\n\n\n        /* fix fat for entry */\n\n        if (fix_fat) {\n\n            int j;\n\n            for(j = mapping->begin; j < mapping->end - 1; j++)\n\n                fat_set(s, j, j+1);\n\n            fat_set(s, mapping->end - 1, s->max_fat_value);\n\n        }\n\n    }\n\n\n\n    mapping = array_get(&(s->mapping), 0);\n\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n\n    s->last_cluster_of_root_directory = mapping->end;\n\n\n\n    /* the FAT signature */\n\n    fat_set(s,0,s->max_fat_value);\n\n    fat_set(s,1,s->max_fat_value);\n\n\n\n    s->current_mapping = NULL;\n\n\n\n    bootsector = (bootsector_t *)(s->first_sectors\n\n                                  + s->offset_to_bootsector * 0x200);\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    /* media descriptor: hard disk=0xf8, floppy=0xf0 */\n\n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n\n    bootsector->number_of_heads = cpu_to_le16(heads);\n\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    /* drive_number: fda=0, hda=0x80 */\n\n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n\n           sizeof(bootsector->u.fat16.volume_label));\n\n    memcpy(bootsector->u.fat16.fat_type,\n\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 5630, "substitutes": {"s": ["sf", "S", "a", "b", "status", "private", "f", "parts", "state", "d", "service", "conf", "same", "self", "g", "sym", "current", "sets", "sites", "is", "spec", "services", "its", "states", "server", "ls", "ds", "ts", "south", "settings", "sv", "fs", "new", "sq", "your", "site", "rs", "sg", "single", "setting", "sync", "ses", "cs", "u", "e", "sb", "secondary", "t", "qs", "source", "p", "c", "os", "ssl", "r", "ps", "o", "http", "session", "si", "sys", "m", "in", "l", "xs", "ns", "stats", "us", "ss", "gs", "se", "full", "storage", "n", "this", "params", "es", "js"], "dirname": ["DIRpath", "directorypath", "dirName", "directioname", "DIRname", "fileword", "filenam", "directionsize", "dirpath", "directoryname", "dirword", "foldernam", "foldersize", "directoryame", "directionpath", "dirame", "directionnam", "filesize", "directionName", "foldername", "directoryName", "filename", "dirnam", "directionname", "folderword", "DIRName", "dirsize", "directionword", "DIRame"], "heads": ["files", "header", "bits", "nc", "rc", "rows", "links", "names", "loc", "cycles", "ls", "ints", "ops", "depth", "locks", "tails", "lock", "blocks", "ptr", "fs", "head", "frames", "lines", "rs", "src", "max", "reads", "tail"], "secs": [" secd", "seqseconds", "seqd", "seqsize", "descs", "secsize", "descd", "descseconds", "seqs", " secsize", "secseconds", " secseconds", "descsize", "secd"], "errp": ["errping", "erping", "erp", "errorp", "erps", "irfp", "erfp", "errorping", "irp", "errorfp", "irps", "errfp", "errorps", "irping", "errps"], "bootsector": ["locksection", "lockaddress", "voltsection", " bootaddress", "voltaddress", "voltsector", " bootsection", "bootaddress", "locksector", "bootsection"], "mapping": ["Mashing", "bashing", "dinding", "pashing", "smapper", "nashing", "lording", "Matching", "remapper", "smatching", "lapper", "Mending", "mouting", " mapped", "happer", "Mapper", "smoding", "dapped", "napper", "remapping", "Migration", "napping", "matching", "pappings", "smapping", "lashing", " minding", "smording", "Mapped", "smashing", "laming", "hailing", "happing", "bapped", "mappings", "loding", "lapped", "Mapping", " mouting", "papping", "noding", "dapper", "mapped", "smapped", "latching", "maming", "Moding", "smouting", "smaming", "smappings", "mailing", "Mappings", "tashing", "tapper", " mending", "moding", "smigration", "bapper", "tatching", "mashing", " mailing", " mapper", "bapping", " migration", "rematching", "hinding", "mending", "naming", "smending", " moding", "Minding", "papper", "dapping", " mappings", "smailing", "mording", "minding", "digration", "Mailing", "tapping", "doding", "lapping", "migration", "dappings", "douting", "datching", "mapper", "reminding", "sminding", "nording"], "i": ["gi", "o", "axis", "ti", "v", "id", "I", "count", "parent", "chi", "di", "ci", "ni", "xi", "x", "si", "slice", "b", "abi", "info", "bi", "in", "m", "qi", "l", "f", "pi", "yi", "phi", "ii", "d", "limit", "iu", "ai", "init", "length", "u", "e", "uri", "t", "n", "multi", "mi", "ini", "p", "h", "mini", "z", "eni", "start", "sup", "c", "ip", "type", "lc", "y", "li", "anti", "inner", "fi", "index", "zi", "dim", "mu", "ui", "size"], "cluster": ["clause", "lusters", "loser", "licoser", "licusters", "CLause", "clusters", "closer", "CLuster", "licause", "CLusters", "lause", "licuster", "luster", "CLoser"], "entry": ["archive", "option", "way", "row", "o", "name", "feed", "id", "parent", "nt", "object", "data", "alias", "or", "record", "info", "module", "image", "enter", "key", "ion", "de", "child", "ries", "server", "ry", "the", "cell", "e", "her", "connection", "section", "mission", "file", "ent", "path", "source", "ie", "parse", "reader", "ge", "line", "import", "attribute", "ident", "element", "Entry", "next", "index", "no", "directory"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n", "idx": 5646, "substitutes": {"base": ["bas", "address", "kit", "name", "area", "builder", "id", "scope", "b", "ada", "i", "home", "info", "ace", "f", "server", "py", "buffer", "e", "proxy", "target", "ase", "source", "p", "temp", "scale", "Base", "frame", "gb", "start", "c", "ip", "type", "site", "ases", "addr", "prefix"], "irqs": ["rinqs", "mirqs", "IRqs", "mirviews", "mirq", "mirfs", "irks", "irquest", "rinviews", "ireq", "irq", "irfs", "mirks", "ireqs", "IRquest", " irks", " irquest", "IRq", "IRks", "rinfs", "irviews", "irefs", "ireviews", "rinq", "mirquest", " irq"], "s": ["options", "r", "o", "sf", "v", "S", "spec", "session", "b", "si", "i", "sync", "m", "f", "ns", "d", "server", "service", "ss", "conf", "u", "e", "an", "sb", "w", "secondary", "ds", "t", "n", "ts", "p", "array", "span", "settings", "z", "fs", "c", "g", "ssl", "sym", "sq", "js"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    ram_addr_t sram_base, q2_base;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    /* Core */\n\n    s->mpu_model = omap2420;\n\n    s->env = cpu_init(core ?: \"arm1136-r2\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,\n\n                    (q2_base = qemu_ram_alloc(NULL, \"omap2.dram\",\n\n                                              s->sdram_size)) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,\n\n                    (sram_base = qemu_ram_alloc(NULL, \"omap2.sram\",\n\n                                                s->sram_size)) | IO_MEM_RAM);\n\n\n\n    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);\n\n\n\n    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n\n    cpu_irq = arm_pic_init_cpu(s->env);\n\n    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],\n\n                    cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],\n\n                    omap_findclk(s, \"mpu_intc_fclk\"),\n\n                    omap_findclk(s, \"mpu_intc_iclk\"));\n\n\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i ++)\n\n        dma_irqs[i] =\n\n                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),\n\n                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),\n\n                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),\n\n                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER1],\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER2],\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER3],\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER4],\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER5],\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER6],\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER7],\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER8],\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER9],\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER10],\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER11],\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER12],\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),\n\n                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C1_TX],\n\n                    omap_findclk(s, \"i2c1.fclk\"),\n\n                    omap_findclk(s, \"i2c1.iclk\"));\n\n    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),\n\n                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C2_TX],\n\n                    omap_findclk(s, \"i2c2.fclk\"),\n\n                    omap_findclk(s, \"i2c2.iclk\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = sysbus_from_qdev(s->gpio);\n\n    sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);\n\n    sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);\n\n    sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);\n\n    sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,\n\n                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,\n\n                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n\n                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,\n\n                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],\n\n                    /* Ten consecutive lines */\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    /* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 5670, "substitutes": {"sdram_size": ["sdam_address", "sdram_name", "sdram2address", "sdcam_size", "sdram_small", "sdram_sized", "sdmem_size", "sdram_fee", "sdram_SIZE", "sdam_size", "sdram_address", "sdmem_ize", "sdmem_Size", "sdgram_type", "sdmem_bytes", "sdmem_model", "sdram_type", "sdram_scale", "sdram2SIZE", "sdram_bytes", "sdam_SIZE", "sdgram_sec", "sdram_sec", "sdcam_name", "sdmem_sized", "sdram2size", "sdam_small", "sdcam_fee", "sdram_model", "sdram_Size", "sdmem_scale", "sdram2small", "sdgram_size", "sdram_ize"], "core": ["Core", "cp", "base", "name", "gate", "python", "cr", " Core", "platform", "scope", "channel", "environment", "nc", "rc", "sync", "cy", " cores", "C", "pure", "ram", "resource", "ext", "carry", "ore", "native", "con", "col", "sc", "code", "binary", "k", "path", "score", "processor", "root", "cpu", "global", "node", "c", "ro", "type", "model", "arch", "cm", "mode", "external"], "s": ["S", "a", "features", "b", "status", "f", "state", "d", "service", "hs", "conf", "w", "h", "aws", "sa", "g", "sym", "y", "sets", "sites", "is", "spec", "services", "its", "states", "sl", "ls", "sc", "ops", "ds", "ts", "south", "settings", "fs", "new", "sq", "rs", "ins", "sg", "sync", "ses", "cs", "u", "e", "sb", "ks", "secondary", "t", "qs", "tests", "p", "c", "os", "ssl", "set", "r", "ps", "o", "less", "session", "si", "sys", "m", "l", "xs", "ns", "args", "us", "ss", "uns", "gs", "se", "full", "n", "su", "es", "js"], "sram_base": ["smem_source", "smem_base", "sram4size", "sram_address", "sramnbase", "sram_size", "sram_source", "sramnsource", "smem_area", "sram_type", "sram4type", "sramnarea", "sramftype", "sram4base", "sgram_base", "sgram_size", "sram4address", "sgram_type", "sram_area", "sramfbase", "sramnsize", "smem_size", "sramfsize", "sramfaddress", "sgram_address"], "q2_base": ["qtwo_base", "q2pchannel", "q2pcache", "qtwo_cache", "q2fbase", "q2fcache", "q2_area", "qnet_address", "qtwo_channel", "q2farea", "q2_address", "qtwo_area", "q2_cache", "q2fchannel", "q2_prefix", "qnet_base", "q2_channel", "qnet_prefix", "q2pbase", "q2parea", "qnet_area"], "cpu_irq": ["cpu_iperqs", "cpu_mirQ", "cpu_irp", "cpu_ierj", "cpu_mirqi", "cpu_ireqi", "cpu_pirq", "cpu_irak", "cpu_igrquest", "cpu_iraQ", "cpu_ireqs", "cpu_ireq", "cpu_mirqs", "cpu_nirk", "cpu_nirq", "cpu_igrqi", "cpu_irk", "cpu_irqi", "cpu_mirk", "cpu_mirquest", "cpu_irek", "cpu_IRk", "cpu_iraq", "cpu_irap", "cpu_irquest", "cpu_mirq", "cpu_igrqs", "cpu_IRj", "cpu_iperq", "cpu_pirk", "cpu_IRq", "cpu_igrq", "cpu_irequ", "cpu_irqu", "cpu_nirqu", "cpu_iperqu", "cpu_nrqs", "cpu_irequest", "cpu_nrq", "cpu_mirp", "cpu_ierqs", "cpu_iperk", "cpu_IRqs", "cpu_pirQ", "cpu_irQ", "cpu_ierq", "cpu_nirqs", "cpu_irj", "cpu_pirp", "cpu_nrj", "cpu_nrk", "cpu_irqs", "cpu_ierk"], "dma_irqs": ["dcpu_mirqu", "dcpu_riqs", "dcpu_mirqs", "dcpu_iriq", "dcpu_mirq", "dcpu_iriqu", "dcpu_riqt", "dcpu_iriqs", "dcpu_riq", "dcpu_irq", "dcpu_irqt", "dcpu_irqu", "dcpu_riqu", "dcpu_mirqt", "dcpu_irqs", "dcpu_iriqt"], "dinfo": [" dmi", " dhi", "vdmi", "dirmi", "dmi", "vdhi", "vddef", "ddef", "vdinfo", "dirdef", "dhi", " ddef", "dirinfo", "dirhi"], "i": ["gi", "o", "ti", "v", "I", "is", "a", "b", "ri", " I", "si", "info", "bi", "m", "f", "pi", "d", "ii", "j", "it", "ai", "u", "e", "p", "c", "ip", "li"], "busdev": ["busdef", "boarddev", "Busdef", "boarddi", "busdi", "Busdi", "boarddef", " busdef", " busname", "boardname", "Busname", "Busdev", "busname", " busdi"], "ta": ["ao", "ea", "ti", "na", "beta", "ua", "va", "oa", "wa", "ya", "ma", "ga", "ra", "ora", "da", "ata", "dc", "fa", "ba", "ama", "sta", "ca", "ista", "sha", "tap", "sa", "tta", "ast"]}}
{"project": "qemu", "commit_id": "c878da3b27ceeed953c9f9a1eb002d59e9dcb4c6", "target": 0, "func": "static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)\n\n{\n\n    int s_bits;\n\n    int ir;\n\n    int opc = label->opc;\n\n    int mem_index = label->mem_index;\n\n    int data_reg = label->datalo_reg;\n\n    int data_reg2 = label->datahi_reg;\n\n    int addr_reg = label->addrlo_reg;\n\n    uint8_t *raddr = label->raddr;\n\n    uint8_t **label_ptr = &label->label_ptr[0];\n\n\n\n    s_bits = opc & 3;\n\n\n\n    /* resolve label address */\n\n    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);\n\n\n\n    /* slow path */\n\n    ir = 3;\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);\n\n#if TARGET_LONG_BITS == 32\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#else\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n    ir |= 1;\n\n#endif\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#endif\n\n    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    switch (opc) {\n\n    case 0|4:\n\n        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));\n\n        break;\n\n    case 1|4:\n\n        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));\n\n        break;\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        if (data_reg != 3)\n\n            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);\n\n        break;\n\n    case 3:\n\n        if (data_reg == 3) {\n\n            if (data_reg2 == 4) {\n\n                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);\n\n            }\n\n            else {\n\n                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);\n\n            }\n\n        }\n\n        else {\n\n            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);\n\n            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n        }\n\n        break;\n\n    }\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n", "idx": 5672, "substitutes": {"s": ["local", "S", "a", "b", "x", "private", "f", "d", "service", "conf", "self", "g", "sym", "y", "current", "sets", "is", "spec", "services", "states", "sl", "ls", "native", "sie", "ds", "ils", "south", "settings", "fs", "secure", "sq", "site", "groups", "stat", "sg", "sync", "ses", "cs", "e", "sb", "secondary", "t", "p", "input", "c", "os", "ssl", "sup", "r", "o", "v", "http", "less", "scope", "session", "sys", "m", "l", "xs", "ns", "us", "ss", "gs", "se", "full", "n", "context", "request", "sample", "sing", "es", "js"], "label": ["el", "local", "data", "ll", "route", "align", "Label", "col", "error", "ab", "sym", "li", "tool", "plugin", "unknown", "spec", "config", "layout", "abel", "info", "fb", "els", "cal", "url", "sl", "facebook", "yl", "comment", "target", "binary", "lib", "sign", "field", "pal", "gl", "model", "bool", "cookie", "pl", "group", "summary", "address", "block", "note", "jl", "lab", "bel", "loc", "key", "lead", "cell", "message", "input", "shield", "ind", "dl", "desc", "ref", "loader", "prefix", "session", "ell", "alias", "l", "child", "def", "hide", "lu", "BL", "console", "il", "bl", "role"], "s_bits": ["s___its", " s__its", "s___bits", " s__details", "s_details", " s_its", "xs_locks", "s_locks", "s__details", " s__bits", "d_flags", "s___flags", "s___details", " s__flags", "d_bit", "s_flags", "xs_bits", "s__bits", "s__locks", "s__flags", " s_details", " s_flags", "s_bit", "d_locks", "s_its", "s_vals", "d_bits", "s__bit", "s__its", "xs_vals", "s__vals"], "ir": ["irt", "dr", "ior", "oc", "mir", "iri", "nor", "area", "sr", "cr", "iter", "irc", "pr", "rr", "imp", "http", "ih", "cur", "is", "id", "fr", "iron", "shr", "irs", "x", "rc", "rf", "i", "inter", "rel", "nir", "circ", "IR", "ril", "loc", "in", "inc", "iris", "l", "pir", "dir", "outer", "arin", "ur", "ar", "ira", "vir", "ear", "n", "rx", "lr", "err", "rin", "req", "Ir", "air", "ire", "ner", "iv", "yr", "hr", "br", "adr", "inner", "ref", "r", "min", "isc"], "raddr": ["readdr", "breg", " rlen", "rarr", "reptr", "rdata", "rereg", "paddr", "plen", "wdr", "draddr", "pdata", "rptr", "waddr", "rreg", "baddr", "Rptr", " raddress", " rdata", "readdress", "rdr", "raddress", "bdr", "rlen", " rreg", "Rdr", " rptr", "drdata", "parr", "Raddr", " rarr", "baddress", "drarr", "Raddress", "drlen", "bptr", "wptr", "waddress"], "label_ptr": ["label__pointer", "code_ref", "label__ref", "label_addr", "label_pair", "code_pair", "label_ref", "data_pointer", "label_loc", "label__ptr", "data_ptr", "label__pair", "data_addr", "code_ptr", "label_dr", "label__addr", "data_dr", "data_loc", "label_pointer", "code_pointer", "data_ref"]}}
{"project": "qemu", "commit_id": "46321d6b5f8c880932a6b3d07bd0ff6f892e665c", "target": 0, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,\n\n                                     uint32_t opt, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (length < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    length -= sizeof(namelen);\n\n    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    length -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    length -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != length / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        length -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN,\n\n                                          opt, errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, length, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 5673, "substitutes": {"client": ["plugin", "gi", "irc", "serv", "local", "open", "http", "session", "config", "get", "manager", "Client", "socket", "co", "queue", "image", "project", "cart", "child", "gui", "call", "server", "pc", "q", "cli", "connect", "ce", "net", "cell", "con", "close", "connection", "sim", "public", "cmd", "input", "ic", "remote", "c", "cn", "api", "product", "core", "cod", "cache", "host", "command", "min", "conn", "google", "prefix"], "length": ["position", "large", "shape", "style", "support", "sequence", "letter", "weight", "match", "buffer", "len", "all", "code", "error", "depth", "ength", "view", "build", "available", "id", "count", "value", "list", "slice", "capacity", "url", "limit", "maximum", "duration", "number", "sh", "angle", "zip", "path", "join", "height", "filename", "range", "type", "text", "broad", "form", "command", "library", "end", "tail", "size", "address", "time", "email", "Length", "loc", "th", "key", "ph", "section", "message", "timeout", "character", "level", "supp", "pull", "http", "total", "before", "l", "offset", "child", "q", "delay", "part", "impl", "se", "full", "other", "lock", "load", "seq", "cost", "yet"], "opt": ["option", "options", "time", "open", "method", "session", "config", "op", "socket", "attr", "ext", "url", "server", "all", "port", "allow", "cmd", "path", "timeout", "access", "seq", "settings", "operation", "params", "command", "mode", "optional", "prefix"], "myflags": ["sharedata", "mystats", "mathflags", " sockFlags", "myFlags", " sockflags", "shareflags", "mathFlags", "mathdata", "sharestats", "mydata", " sockdata", "mathstats", " sockstats", "shareFlags"], "errp": ["angerpp", "cryP", "acerp", "aerpi", "Erp", "erfp", " errwp", "herep", "errwp", " errapi", "herepi", "crypc", "errorp", "erwp", "errorpre", " errfp", "errorP", "errP", "aerp", "errpc", "errpi", "hereps", "angerpre", " errP", "errapi", "Erapi", "errorpc", "acerwp", " errpc", "angerpc", " errpi", "irapi", " errps", "errpp", "cryps", "irp", "irpre", "errorps", "errps", "herepre", "acerfp", "erp", "errorpp", "cryp", "aerpre", "Erpre", "aerps", "errfp", " errpre", " errpp", "errpre", "angerp"], "rc": [" ret", " cur", "r", " rec", " pri", "id", " success", " answer", " res", " reply", " conf", " resp", " alloc", " err", " cmd", "code", " enc", " row", " error", " src", " result", " ans", " sc", " rs", " payload", " r", "src", "RC"], "name": ["base", "address", "time", "code", "block", "id", "change", "a", "count", "parent", "word", "list", "data", "info", "mask", "names", "key", "num", "package", "resource", "call", "version", "create", "description", "url", "Name", "number", "len", "NAME", "all", "error", "comment", "connection", "part", "message", "ame", "n", "path", "str", "search", "prefix", "common", "cap", "new", "hello", " names", "type", "desc", "no", "command", "size"], "requests": ["lates", "multests", "quests", "reqresses", "quirements", "questencies", "Requests", "compesters", "resents", "quences", "requients", "multirements", "resests", "requasks", "sequences", "generencies", "reqences", "sequents", "sequencies", "requirements", "sequesters", "Requesters", "commests", "contensions", "requencies", "sequests", "compests", "contares", "requends", "reqensions", "requestests", "contests", "reqares", "questes", "generesters", "requares", " requares", "reqes", "triests", " requresses", "questirements", "requences", "reqesters", "requensions", "requesters", "quresses", " requensions", "sequirements", "questends", "reques", "cencies", "generirements", "reqencies", "requents", "commients", "tests", "compencies", "reqests", "commesters", "requestes", "cests", "multesters", "triasks", "requestends", "Requirements", "compirements", "sequients", "reqasks", "requresses", "reqents", "resences", " requirements", "latests", "seques", "questests", "triirements", "reqirements", "tasks", "ces", "cirements", "tirements", "generests", "compences", "reqients", "latends", "questesters"], "request": ["address", "time", "Request", "header", "friend", "press", "pull", "except", "complete", "progress", "effect", "lease", "session", "config", "require", "object", "data", "use", "record", "queue", "required", "xml", "route", "resource", "event", "attr", "child", "order", "version", "server", "call", "create", "issue", "QUEST", "push", "buffer", "download", "error", "item", "message", "allow", "path", "response", "demand", "callback", "access", "result", "raise", "input", "task", "search", "req", "quest", "transfer", "import", "post", "type", "report", "user", "query", "pair", "reference", "command", "hello"], "namelen": ["nameleener", "amelener", "amelsens", "goldlenien", "namewens", "namllon", "namellened", "samellen", "namlenen", "timllon", "namileng", "namelineens", "namllener", "timelun", "nameleen", "namelens", "namelener", "namelineeno", "samelpen", "namllens", "goldelener", "namelinenc", "namellens", "amelenc", "timelen", "namelien", "namelepen", "namellun", "namilened", "homellener", "samellize", "samllener", "homelen", "namelinpen", "namlenien", "namelleng", "amellener", "timelon", "namielenc", "namewength", "samelens", "namelena", "namewen", "nameleeng", "namielpen", "amelsen", "timilen", "timllener", "namelense", "timelens", "nameltien", "namelsens", "namlleng", "namilize", "namlenener", "namlenisen", "samllen", "nameltisen", "namelisen", "samilen", "namelize", "namellenc", "namillen", "goldlenen", "timllens", "nameleize", "namelun", "timllen", "namelten", "namelinen", "goldelisen", "sameleno", "samlleno", "nameleens", "namlleno", "namellize", "amelength", "namelineener", "nameltpen", "samelen", "namewense", "namelineng", "samilener", "amelen", "amellen", "namelinener", "samellener", "namelength", "namelsen", "namielener", "namllen", "namillener", "samilpen", "timileng", "samilened", "amelened", "namelsength", "amelense", "nameleng", "homelener", "namilun", "namellener", "namellisen", "nameleened", "sameleng", "namewlen", "goldlenener", "namelllen", "timeleng", "amelsense", "namelinelen", "samllens", "namellen", "amelens", "timilener", "goldelen", "namielen", "nameltener", "namilener", "goldlenisen", "namellien", "namillened", "namelsense", "namilen", "namilens", "namelinength", "namileno", "namellena", "samelize", "namelened", "namilleng", "nameleno", "namelineen", "namilon", "samelened", "namewena", "amellened", "homelllen", "namelinens", "namelinense", "namelineena", "amelsength", "namilpen", "amellpen", "samileng", "nameleon", "timelener", "homellen", "homellena", "namewener", "amelpen", "goldelien", "namelpen", "namellpen", "amellenc", "timilun", "samelener", "namelon", "namllpen", "nameltened", "homelena", "samellens", "namelenc", "nameleun"], "sizes": ["outsizes", "samples", "outsize", "setsize", "statize", "statizes", "statamples", "statized", "sized", "setsizes", "outsamples", "outsized", "setsized", "setsamples", "size"], "buf": ["base", "buff", "bin", "block", "mem", "box", " buffer", "b", "data", "queue", "map", "loc", "uf", "buffer", "bag", "Buffer", "bytes", "ba", "seq", "array", "ptr", "alloc", "cap", "var", "br", "desc", "cache", "ref"], "msg": ["lang", "game", "cmp", "fg", "cfg", "header", "ag", "id", "comm", "sg", "bg", "bug", "info", "module", "body", "m", "help", "html", "ma", "mp", "mn", "call", "description", "arg", "reason", "og", "conf", "man", "error", "comment", " message", "gs", "message", "Msg", "sim", "cmd", "Message", "go", "err", "str", "hop", "mess", "gor", "ge", "doc", "global", "gen", "g", "ms", "type", "text", "desc", "command", "pkg"]}}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5676, "substitutes": {"cmd": ["cp", "plugin", "cmp", "cfg", "hw", "clean", "block", "md", "comm", "cdn", "device", "config", "Cmd", "nc", "cat", "module", "cm", "window", "mac", "client", "carry", "child", "call", "add", "cli", "ctr", "cc", "dom", "conf", "code", "ck", "auth", "func", "dc", "ctx", "cb", "input", "ctrl", "req", "mode", "node", "c", "head", "custom", "cf", "cod", "cookie", "vc", "host", "command", "grad", "conn", "pkg", "cd", "msg"], "dev": ["hw", "dm", "block", "v", "md", "nov", "rad", "prof", "mem", "Dev", "dd", "device", "nt", "di", "data", "info", "der", "debug", "valid", "de", "client", "d", "ve", "mod", "server", "conf", "ev", "def", "DEV", "dom", "priv", "wd", "w", "cam", "die", "driver", "pad", " device", "exec", "self", "serial", "root", "reader", "mode", "ver", "proc", "var", "off", "orig", "node", "gd", "engine", "app", "grad", "conn", "diff", "end"], "buf": ["band", "rb", "bg", "b", "data", "queue", "uc", "f", "tab", "buffer", "bag", "func", "bc", "ab", "nb", "array", "proc", "off", "pb", "img", "bh", "msg", "fam", "header", "cur", "config", "fb", "uf", "port", "ctx", "pad", "batch", "doc", "cap", "cf", "text", "bn", "vec", "block", "box", "bd", "exc", "rc", "cat", "loc", "grab", "wb", "db", "conv", "usb", "Buffer", "bound", "feat", "border", "begin", "fab", "gb", "prop", "fd", "bo", "cache", "aux", "app", "src", "buff", "v", "uber", "Buff", "uv", "mac", "bu", "bb", "cb", "result", "seq", "ptr", "alloc", "comb", "br", "utf", "cv", "ha"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)\n\n{\n\n\tint arith_opt, move_opt;\n\n\n\n\t/* TODO: optimize more condition codes.  */\n\n\n\n\t/*\n\n\t * If the flags are live, we've gotta look into the bits of CCS.\n\n\t * Otherwise, if we just did an arithmetic operation we try to\n\n\t * evaluate the condition code faster.\n\n\t *\n\n\t * When this function is done, T0 should be non-zero if the condition\n\n\t * code is true.\n\n\t */\n\n\tarith_opt = arith_cc(dc) && !dc->flags_uptodate;\n\n\tmove_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;\n\n\tswitch (cond) {\n\n\t\tcase CC_EQ:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\t/* If cc_result is zero, T0 should be \n\n\t\t\t\t   non-zero otherwise T0 should be zero.  */\n\n\t\t\t\tint l1;\n\n\t\t\t\tl1 = gen_new_label();\n\n\t\t\t\ttcg_gen_movi_tl(cc, 0);\n\n\t\t\t\ttcg_gen_brcondi_tl(TCG_COND_NE, cc_result, \n\n\t\t\t\t\t\t   0, l1);\n\n\t\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\t\tgen_set_label(l1);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, \n\n\t\t\t\t\t\tcpu_PR[PR_CCS], Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_NE:\n\n\t\t\tif (arith_opt || move_opt)\n\n\t\t\t\ttcg_gen_mov_tl(cc, cc_result);\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tZ_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_CS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_CC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tV_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_PL:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, bits);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cc, 1);\n\n\t\t\t} else {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_MI:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, 31);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_HI:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv tmp;\n\n\n\n\t\t\t\ttmp = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\ttcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\t\t/* Overlay the C flag on top of the Z.  */\n\n\t\t\t\ttcg_gen_shli_tl(cc, tmp, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, tmp, cc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\n\n\t\t\t\ttcg_temp_free(tmp);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_GE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\ttcg_gen_xori_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_LT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_GT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\t\t\t\t/* invert Z.  */\n\n\t\t\t\ttcg_gen_xori_tl(z, z, 2);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_xori_tl(n, n, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_or_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_P:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_A:\n\n\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tBUG();\n\n\t\t\tbreak;\n\n\t};\n\n}\n", "idx": 5694, "substitutes": {"dc": ["oc", " DC", "dr", "anc", "dm", "spec", "dat", "config", "disc", "nc", "rc", "cca", "uc", "enter", "draw", "db", "ga", "cci", "gui", "d", "pc", "director", "center", "dir", "dp", "mc", "sc", "ck", "da", "jc", "ds", "df", "ctx", "cmd", "bc", "cu", "exec", "coll", "context", "input", "ec", "DC", "doc", "c", "du", "ct", "cf", "tk", "lc", "fc", "design", "dt", "ac", "vc", "cdn", "conn", "cd", "tc"], "cc": [" CC", "cmp", "anc", "spec", "acc", "dd", "ci", "ctl", "config", "pp", "nc", "rc", "cca", "kk", "cus", "comp", "co", "uc", "cm", "inc", "cl", "ga", "client", "cci", "ucc", "call", "pc", "ack", "cs", "ce", "code", "ck", "mc", "sc", "cell", "comment", "jc", "ctx", "bc", "coll", "input", "ec", "PC", "cel", "ice", "c", "ct", "cf", "lc", "fc", "gg", "cod", "ac", "vc", "RC", "conn", "cd", "CC", "tc"], "cond": ["condition", "cmp", "red", "cr", "sec", "count", "config", "pre", "fact", "comp", "co", "bit", "format", "prep", "loc", "unit", "cl", "reason", "crit", "def", "cont", "cell", "col", "Cond", "day", "cmd", "ctx", "bc", "cb", "exec", "seq", "c", "ind", "ct", "fd", "lc", "bool", "comb", "ac", "cm", "xc", "tc"], "arith_opt": ["arith__token", "arinth_opt", "arth_opt", "arith__exp", "arith_token", "arith_optim", "arith__opt", "aruth_pot", "arith_oct", "arith_pot", "arinth_option", "arith_exp", "arith__option", "aruth_optim", "arth_option", "arith_option", "arinth_oct", "arith_open", "arith__hop", "aruth_option", "arith__op", "aruth_exp", "arth_token", "aruth_op", "arith_op", "arinth_open", "arth_hop", "arith_hop", "aruth_opt"], "move_opt": ["move_option", " move_tr", " move_mode", "move__option", "moveadoption", "moveaymode", "move__opt", "moveadtest", "move_tr", "movekmode", "move_test", "move_mode", "movekopt", "moveayoption", " move_test", "moveayopt", "moveadort", " move_off", " move_Opt", " move_option", "move_ort", " move_ort", "move__off", "move_err", "move_Opt", "movekoption", " move_orig", "move_orig", "moveayorig", "moveadopt", "move_off", "move__Opt", "move__tr", " move_err", "move__err", "movekorig"], "l1": ["l3", " lone", "L01", "li01", "ul3", "ln2", "lione", "L61", " l3", "l2", "L2", "li1", "L91", "ul1", " l61", " l01", "l01", "ln1", "L1", " l91", " l6", "ln3", "Lone", "l6", "L6", " l2", "l91", "ln91", "l61", "ul2", "li6", "li3", "L3", "ul61", "li2", "lone"]}}
{"project": "qemu", "commit_id": "b4854f1384176d897747de236f426d020668fa3c", "target": 0, "func": "void do_smm_enter(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong sm_state;\n\n    SegmentCache *dt;\n\n    int i, offset;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"SMM: enter\\n\");\n\n    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);\n\n\n\n    env->hflags |= HF_SMM_MASK;\n\n    if (env->hflags2 & HF2_NMI_MASK) {\n\n        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;\n\n    } else {\n\n        env->hflags2 |= HF2_NMI_MASK;\n\n    }\n\n    cpu_smm_update(env);\n\n\n\n    sm_state = env->smbase + 0x8000;\n\n\n\n#ifdef TARGET_X86_64\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        offset = 0x7e00 + i * 16;\n\n        x86_stw_phys(cs, sm_state + offset, dt->selector);\n\n        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stq_phys(cs, sm_state + offset + 8, dt->base);\n\n    }\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);\n\n    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);\n\n    for (i = 8; i < 16; i++) {\n\n        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);\n\n    }\n\n    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);\n\n    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);\n\n#else\n\n    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        if (i < 3) {\n\n            offset = 0x7f84 + i * 12;\n\n        } else {\n\n            offset = 0x7f2c + (i - 3) * 12;\n\n        }\n\n        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);\n\n        x86_stl_phys(cs, sm_state + offset + 8, dt->base);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);\n\n    }\n\n    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);\n\n#endif\n\n    /* init SMM cpu state */\n\n\n\n#ifdef TARGET_X86_64\n\n    cpu_load_efer(env, 0);\n\n#endif\n\n    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n", "idx": 5707, "substitutes": {"cpu": ["cp", "cmp", "bench", "pid", "hw", "cfg", "lb", "chip", "intel", "platform", "pu", "vm", "component", "config", "environment", "nc", "rc", "gpu", "px", "cm", "eu", "num", "server", "pc", "linux", "cli", "net", "np", "cpp", "clock", "dc", "ctx", "kernel", "fp", "jp", "processor", "ec", "boot", "proc", "c", "node", "cn", "core", "lc", "fc", "cache", "loader", "CPU", "conn"], "env": ["energy", "el", "_", "ef", "environment", "inv", "style", "oa", "et", "ace", "gui", "conf", "ev", "code", "all", "her", "here", "den", "func", "bc", "err", "exec", "Environment", "ou", "ec", "output", "g", "engine", "conn", "ass", "ah", "ocr", "extra", "s", "config", "qt", "nc", "eu", "cal", "server", "assets", "iss", "ctx", "ini", "ne", "viron", "doc", "site", "addr", "end", "osc", "eng", "er", "exc", "db", "export", "ext", "org", "py", "cli", "net", "ce", "np", "e", "que", "en", "dev", "global", "het", "core", "cache", "loader", "dict", "fen", "cfg", "anc", "ea", "scope", "enc", "de", "args", "init", "impl", "cb", "context", "req", "eni", "console", "skin", "esm", "cv"], "cs": ["cp", "cmp", "Cs", "ch", "cks", "spec", "ci", "nc", "rc", "cus", "sync", "cells", "sys", "cat", "cing", "js", "ix", "sk", "ns", "ls", "pc", "cc", "bs", "cli", "ce", "tc", "CS", "vs", "sc", "ck", "code", "ks", "ds", "qs", "ctx", "wcs", "bc", "cms", "cb", "ces", "ca", "css", "acks", "gb", "fs", "acs", "c", "ys", "cn", "core", "lc", "cf", "ac", "cache", "vc", "cas", "conn"], "sm_state": ["wp_state", "sm___string", "shappstate", "sm___resource", " sm_size", "sm_store", " sm_string", "sm_context", "sm__config", "sm___shape", "sm_family", "sh_state", "smPvalue", "sm_config", "smkSTATE", "smkfamily", "sm_status", "sm_err", "sm5state", "sm__core", "sb_state", "sm_stat", "sm_STATE", "sm64class", "smPstate", "sm64state", "Sm_model", "Sm_grade", "sh_tag", "smappstate", "sm_model", "sm__stat", "sm_estate", "utm_status", "sm_size", "sm_grade", "si_state", "sm_powered", "shappresource", "sm_value", "SM_state", " sm_value", "sm_shape", "mm_resource", "wp_class", "smkstate", "utm_shape", "SM_core", "shapptag", "sm_tag", "mm_family", "sm_string", "smPstring", "utm_state", " sm_powered", "sm_form", "sb_set", "sm_core", "sb_status", "sm_State", "mm_model", "sm___status", "sh_resource", "wp_store", " sm_context", "utm_resource", "smappform", "smPpowered", "wp_set", "sm_class", "sm_rule", "SM_stat", "Sm_State", "SM_config", "sm___powered", "mm_STATE", "mm_config", "smapptag", "sm___state", " sm_area", "si_resource", "sm64store", "sm5set", "sm__state", "sb_err", "sm5status", "si_estate", "smappresource", "sm5err", "si_rule", "mm_string", "shappform", "smkresource", "sm64set", "sm_set", "Sm_state", "mm_state", "sm_area", "sm___value", "sm_resource", "sh_form"], "dt": ["dr", "tf", "dm", "rt", "gm", "md", "bd", "dn", "di", "dat", "note", "dd", "vt", "bt", "qt", "lt", "pd", "dh", "elt", "wt", "tu", "db", "utt", "tif", "att", "d", "dq", "td", "tick", "kt", "dp", "mt", "tn", "da", "timer", "t", "dc", "tm", "nat", "ds", "ts", "jp", "cb", "cmd", "ee", "ou", "tz", "ut", "DT", "ta", "txt", "gt", "tk", "dl", "tt", "conn", "tc"], "i": ["base", "uni", "gi", "ti", "v", "id", "I", "count", "chi", "di", "s", "ci", "phi", "ji", "ni", "x", "xi", "si", "io", "ri", "abi", "b", "bi", "qi", "ix", "l", "f", "pi", "yi", "adi", "d", "ii", "iu", "j", "it", "ai", "uli", "u", "code", "e", "ami", "udi", "uri", "n", "multi", "mi", "ski", "ini", "ie", "p", "z", "eni", "start", "oi", "c", "ip", "type", "y", "li", "fi", "index", "zi", "ui"], "offset": ["base", "address", "option", "o", "layer", "position", "padding", "origin", "reset", "scroll", "append", "entry", "si", "slice", "shift", "et", "Offset", "phase", "info", "alias", "image", "art", "f", "attr", "ext", "order", "enabled", "ii", "align", "outer", "part", "len", "size", "iterator", "action", "error", "item", "port", "timeout", "fp", "hop", "p", "ptr", "style", "pos", "pointer", "start", "range", "off", "attribute", "api", "iso", "article", "index", "addr", "optional", "ui", "slot"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n", "idx": 5718, "substitutes": {"nd": ["nv", "std", "rn", "nw", "od", "id", "md", "bd", "vd", "dn", "nn", "nov", "nt", "dd", "dat", "wn", "adv", "mid", "ci", "device", "pd", "nc", "inn", "rd", "ND", "idd", "ad", "brand", "de", "ng", "und", "dk", "d", "dist", "init", "td", "np", "kind", "da", "sd", "ds", "dc", "n", "cmd", "nz", "ini", "nb", "zn", "nda", "anda", "mind", "none", "di", "ld", "ind", "node", "gd", "fd", "custom", "cdn", "hd", "cd"], "default_model": ["defaultingmodel", "defaultingtype", "defaultingmodels", "defaultlextype", " default_type", " default_device", " default_language", "defaultingdevice", "default_language", "defaultlexlanguage", "default_type", " default_models", "defaultlexdevice", "default_Model", "defaultlexModel", "defaultlexmodel", " default_Model", "default_device", "default_models", "defaultlexmodels"], "default_devaddr": ["default_deviceref", "default_deviceaddr", "default_devname", "default_devicename", "default_devref", "default_evref", "default_evname", "default_evaddress", "default_evaddr", "default_deviceaddress", "default_devaddress"], "devaddr": ["evaddress", "devattr", "deviceref", "Devaddress", "deviceaddress", "evattr", "deviceaddr", "diskattr", "devaddress", "Devref", "Devaddr", "devicename", "diskaddress", "diskref", " devaddress", "diskaddr", "evname", " devref", "evref", "evaddr", "devname", "deviceattr", " devname", "devref"], "pci_dev": ["pci__conf", "pci_device", "pcu_device", "pcu_conf", "pci_des", "pci_ev", "pcu__device", "pci__def", "pcu_des", "pcu__conf", "pcu__def", "pci__dev", "pci__device", "pcu_dev", "pci__ev", "pcu_ev", "pcu_def", "pci_def", "pcu__dev", "pci_conf", "pcu__ev"], "dev": ["diff", "block", "v", "md", "rad", "id", "di", "Dev", "dd", "adv", "device", "nt", "bug", "data", "ad", "info", "dem", "debug", "gu", "private", "de", "d", "ve", "mod", "dist", "init", "conf", "ev", "def", "DEV", "wd", "priv", "dom", "error", "prom", "die", "sd", "dc", "err", "development", "ver", "var", "develop", "gd", "user", "test", "conn", "cd"], "i": ["gi", "r", "o", "ti", "v", "id", "I", "a", "di", "ni", "xi", "ri", "si", "io", "b", "x", "bi", "in", "m", "qi", "l", "f", "pi", "d", "ii", "j", "iu", "ai", "u", "e", "uri", "t", "k", "n", "ini", "p", "c", "ip", "ind", "type", "y", "li", "index", "zi", "ui"]}}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n", "idx": 5731, "substitutes": {"c": ["cmp", "ch", "cr", "v", "cur", "s", "ci", "config", "nc", "rc", "enc", "C", "m", "cm", "f", "pc", "cc", "cs", "arc", "e", "mc", "sc", "dc", "t", "ctx", "bc", "cb", "self", "context", "p", "ec", "ca", "g", "cf", "lc", "fc", "cv", "ac", "vc", "cpp", "ctrl", "xc", "tc"], "avctx": ["afcontext", "avkb", "afconfig", " avcontext", "avcontext", "AVctx", "AVconfig", "avconfig", "AVcontext", " avconfig", "afkb", " avkb", "AVkb", "afctx"]}}
{"project": "FFmpeg", "commit_id": "295b79b5d8c0cf0a9691f8d6b512aa1e289d528d", "target": 1, "func": "static av_cold int roq_encode_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;", "idx": 5754, "substitutes": {"avctx": ["akcontext", " avcf", "archconn", "archcontext", " avvoc", "avedc", "apscontext", "AVlc", "archctx", "vercu", "navcontext", "aveloc", "aveconfig", "afctx", "avalcu", "Avloc", "vertx", "ajctx", "navctx", "afdc", "avcli", " avcontext", "avcdn", "avalvoc", "avevoc", "Avconn", "afloc", "afcmp", "avcmp", "akctx", "avecli", "apsconn", "avectl", "avalctx", "aveconn", "Avctx", "avecontext", "akconn", "afcf", "avlc", "avalsci", "avecdn", "ajcmp", " avcu", "AVconn", "aksci", "avecu", "avelc", "avalcontext", "afcli", "navconfig", "aflc", "afctl", "vercontext", "avcu", "navcmp", "avconfig", "AVcontext", "afsci", "avcontext", "afcdn", "avvoc", "avsci", "verloc", "apscdn", "avesci", "avloc", "avconn", "avctl", "avdc", "verconn", "avectx", "avetx", "AVctx", "akloc", "avcf", "aftx", "avalconn", "avecf", "avtx", "archctl", "ajcli", "Avcontext", "verctx", "akcu", "afconn", "apsctx", "afcontext", "afvoc", "afconfig", "ajcontext", " avconn", "avaldc", "vercmp", "avecmp", "afcu"], "enc": ["lang", "anne", "el", "oa", "et", "auc", "nec", "uc", "ev", "code", "con", "acl", "bc", "exec", "equ", "ou", "ec", "ver", "ct", "lc", "ac", "conn", "rec", "oc", "pack", "ocr", "build", "unc", "cur", "acc", "nt", "config", "nc", "eu", "sl", "Enc", "lib", "ent", "ctx", "win", "ee", "node", "adr", "util", "env", "bn", "oder", "ENC", "eng", "act", "hw", "ann", "nw", "sec", "rc", "cat", "loc", "kg", "inc", "ext", "pc", "cc", "ce", "e", "en", "oy", "dev", "ant", "ic", "c", "ssl", "adj", "cache", "vc", "app", "cel", "ch", "anc", "emb", "od", "ell", "sys", "ae", "rh", "mac", "client", "dc", "load", "coll", "ang", "eni", "iv", "fc", "ew", "cdn"]}}
{"project": "FFmpeg", "commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "target": 1, "func": "void ff_h264_flush_change(H264Context *h)\n\n{\n\n    int i, j;\n\n\n\n    h->next_outputed_poc = INT_MIN;\n\n    h->prev_interlaced_frame = 1;\n\n    idr(h);\n\n\n\n    h->poc.prev_frame_num = -1;\n\n    if (h->cur_pic_ptr) {\n\n        h->cur_pic_ptr->reference = 0;\n\n        for (j=i=0; h->delayed_pic[i]; i++)\n\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n\n                h->delayed_pic[j++] = h->delayed_pic[i];\n\n        h->delayed_pic[j] = NULL;\n\n    }\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n\n\n    h->first_field = 0;\n\n    ff_h264_sei_uninit(&h->sei);\n\n    h->recovery_frame = -1;\n\n    h->frame_recovered = 0;\n\n    h->current_slice = 0;\n\n    h->mmco_reset = 1;\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        h->slice_ctx[i].list_count = 0;\n\n}\n", "idx": 5755, "substitutes": {"h": ["H", "hp", "ah", "hw", "ch", "o", "v", "http", "ih", "x", "b", "home", "oh", "uh", "m", "th", "rh", "l", "html", "wh", "f", "kh", "how", "him", "n", "d", "q", "ph", "hs", "u", "han", "hm", "sh", "e", "w", "her", "adh", "t", "hh", "hl", "he", "history", "hist", "k", "self", "zh", "eh", "work", "p", "ec", "gh", "c", "hi", "ht", "head", "hr", "hash", "g", "y", "rah", "ha", "beh", "host", "bh", "hd"], "i": ["gi", "r", "o", "ei", "ti", "v", "id", "I", "a", "is", "di", "s", "ci", "ji", "ni", "x", "b", "si", "ri", "xi", "slice", "io", "info", "abi", "m", "in", "qi", "bi", "ix", "l", "yi", "pi", "f", "phi", "iu", "ii", "d", "it", "ai", "u", "e", "uri", "t", "k", "n", "mi", "jp", "ini", "ie", "p", "mini", "eni", "z", "start", "oi", "ind", "ip", "c", "g", "y", "api", "li", "fi", "index", "zi", "ui"], "j": ["fr", "o", "v", "jl", "ji", "xi", "b", "si", "x", "bi", "m", "kj", "l", "key", "ix", "job", "f", "ij", "ii", "obj", "aj", "iu", "u", "e", "J", "je", "jc", "k", "n", "uj", "jp", "jo", "ie", "p", "jit", "z", "eni", "jj", "c", "ind", "dj", "ja", "y", "br", "li", "adj", "r", "js"]}}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)\n\n{\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    void *dst;\n\n    if (o_out)\n\n        *o_out= o;\n\n    if (!o || o->offset<=0)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n\n\n    if (o->max*den < num*intnum || o->min*den > num*intnum) {\n\n        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n\n        return AVERROR(ERANGE);\n\n    }\n\n\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n\n\n    switch (o->type) {\n\n    case FF_OPT_TYPE_FLAGS:\n\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_RATIONAL:\n\n        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n\n        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5762, "substitutes": {"obj": ["act", "objects", "id", "Obj", "nt", "eff", "x", "tmp", "po", "b", "op", "io", "ob", "object", "bm", "val", "oa", "nc", "ad", "image", "orb", "buf", "j", "np", "lo", "len", "e", "out", "en", "bot", "n", "ctx", "ant", "ab", "cb", "jp", "lib", "lock", "Object", "coll", "p", "nb", "str", "ut", "opt", "pos", "oi", "os", "ind", "off", "api", "oid", "lc", "ord", "pl", "ref", "src", "img", "nd", "end", "bj", "js"], "name": ["base", "option", "anc", "time", "id", "parent", "word", "x", "object", "data", "alias", "i", "named", "info", "m", "names", "key", "null", "f", "l", "ext", "nm", "version", "Name", "part", "size", "NAME", "number", "len", "fn", "n", "path", "str", "filename", "old", "nam", "new", "type", "cn", "label", "no", "min", "max", "dim", "prefix"], "num": ["four", "position", "na", "una", "om", "done", "b", "i", "umi", "unit", "f", "nm", "dom", "initial", "con", "len", "gener", "NUM", "nb", "span", "don", "zero", "off", "um", "rum", "index", "id", "min", "sum", "valid", "mon", "uno", "mn", "param", "number", "Num", "nom", "one", "mom", "un", "node", "form", "no", "bn", "size", "uni", "bin", "block", "tun", "sem", "loc", "inc", "u", "np", "an", "en", "coord", "begin", "gen", "du", "im", "ul", "norm", "dim", "mu", "nu", "ten", "m", "offset", "eight", "n", "lon", "su", "nam", "term", "hum", "lim", "hom"], "den": ["uni", "fen", " DEN", "bench", "diff", "una", "min", "dn", "di", "nn", "pen", "wall", "sen", "ni", "sem", "non", "ten", "dem", "de", "mon", "lim", "side", "dan", "version", "limit", "flo", "Den", "nen", "dir", "des", "len", "con", "hen", "en", "die", "ben", "lon", "su", "ne", "begin", "don", "ner", "un", "gen", "none", "ven", "line", "range", "du", "ver", "lin", "plan", "nan", " Den", "zen", "DEN", "norm", "dim", "low"], "intnum": ["intnode", "ntnode", "intum", " intum", "pointnom", "ntlen", "doubleoffset", "interloc", "intmem", "indnode", " intbegin", "Intnu", "Intnum", "indloc", "integernum", "intbegin", "ntnum", "integeren", "integerbegin", "extnumber", "inclen", "integername", "pointnum", "intno", "ntunit", "integernu", "indunit", "extnum", " intno", "indmem", "ntname", "Intnom", "intnom", "indnu", "extname", "indnom", "intoffset", "Intum", "intname", "incnum", "intloc", "stringnum", "intblock", " intblock", "integernom", " intnom", "integerlen", "pointen", "indname", "integerblock", "Intnumber", " intname", "doublenumber", "pointnu", "intername", "incnom", "doubleloc", "intnumber", "ntnom", "intunit", "incnumber", "internum", "intlen", "pointmem", "bitblock", "ntoffset", "indnum", "doublename", "doubleno", "integermem", "pointnumber", "inten", "integernumber", "Intblock", "pointblock", "indnumber", "extlen", "stringnode", "pointbegin", "ntnu", "ntno", " intlen", "bitnum", " intnumber", " intoffset", "bitnumber", " inten", "stringunit", "stringnu", "bitum", "internumber", "doublenum", "ntnumber", "intnu"], "o_out": [" o_in", "s_sync", "o_Out", " o_o", " o_off", " o_Out", "o_off", "s_off", "s_out", "o_sync", "o_o", "o_in", "s_in"], "o": ["option", "options", "ko", "v", "po", "b", "object", "io", "i", "oa", "op", "ob", "mo", "O", "or", "m", "office", "so", "l", "offset", "f", "d", "u", "e", "lo", "oe", "online", "out", "w", "t", "k", "n", "go", "oin", "one", "p", "offer", "ou", "opt", "none", "oi", "os", "off", "oo", "c", "oid", "iso", "bo", "no"], "dst": ["idsts", "isdpush", "Dst", "Dsp", "ldstr", " ddest", "isdste", "dabl", "dbl", " dSt", "dasts", "isdstore", "DSt", "Dste", "xdst", "idste", "idst", "xdsts", "dsc", "ldst", "Dsts", "adST", "nste", "odsts", "nST", "ldste", "dsp", "odste", "dST", "dsts", "indstore", "Dbl", "indpush", "adsts", "ldsc", "Dsc", "dstore", "nst", " dsts", "dast", "adste", "idcr", "dstr", " dstore", " dsc", " dsp", " dcr", " dpush", "adst", "adstr", " dbl", "xdste", "xdST", "dpush", "Dcr", "indste", "daSt", "ddest", " dste", "nsp", "isdst", "dSt", "addest", "oddest", "dcr", "ldST", " dstr", "odst", " dST", "indst", "dste", "DST"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qemu_mutex_init(&qxl->track_lock);\n\n    qemu_mutex_init(&qxl->async_lock);\n\n    qxl->current_async = QXL_UNDEFINED_IO;\n\n    qxl->guest_bug = 0;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        io_size = 8;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        io_size = 16;\n\n        break;\n\n    case 3: /* qxl-3 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V10;\n\n        io_size = 32; /* PCI region size must be pow2 */\n\n        break;\n\n    case 4: /* qxl-4 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V12;\n\n        io_size = pow2ceil(QXL_IO_RANGE_SIZE);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Invalid revision %d for qxl device (max %d)\",\n\n                   qxl->revision, QXL_DEFAULT_REVISION);\n\n        return;\n\n    }\n\n\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), \"qxl.vrom\",\n\n                           qxl->rom_size, &error_abort);\n\n    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);\n\n    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), \"qxl.vram\",\n\n                           qxl->vram_size, &error_abort);\n\n    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);\n\n    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), \"qxl.vram32\",\n\n                             &qxl->vram_bar, 0, qxl->vram32_size);\n\n\n\n    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,\n\n                          \"qxl-ioports\", io_size);\n\n    if (qxl->id == 0) {\n\n        vga_dirty_log_start(&qxl->vga);\n\n    }\n\n    memory_region_set_flush_coalesced(&qxl->io_bar);\n\n\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);\n\n\n\n    if (qxl->vram32_size < qxl->vram_size) {\n\n        /*\n\n         * Make the 64bit vram bar show up only in case it is\n\n         * configured to be larger than the 32bit vram bar.\n\n         */\n\n        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n", "idx": 5767, "substitutes": {"qxl": ["qxxel", "qrexli", "qufxL", "qxtl", "naxli", "Qexli", "quickxel", "qwxel", " qrxlc", "quxlc", "qexlc", "qbylb", "naxl", "qwxl", "qttli", "qrxl", "qXlb", "QexL", "iqxll", "quylc", " qxsl", "qpxlc", "qxli", "Qexel", "qswlc", "qrxll", "qxclb", "qzxll", "sqxl", "qxcll", "iqxl", "qxle", "qlllb", " quxli", "qrexl", "quxtl", "Qexll", "qxel", "quebykl", "qyl", "Qxli", "quexkl", "qswli", "qexlb", "qexla", "qxclc", "iqexl", "qrxrl", "qlexla", "quebyl", "qtxls", "qfxls", "qtxel", "sqwel", "sqaxlc", "Qexl", "qswl", "qxls", "nxlc", "qexli", "qrxla", "qbyl", "sqwl", "qrxlc", "quxli", "qXl", "quickxl", " quxls", "qbykl", "qulexla", "qctll", "qyls", "qtxlc", "qxxlp", "qxcl", "qwlc", "quxll", "qauxl", "qfxel", "quxla", " qrxel", "quexlb", "sqwlc", "qxtli", "qaxdl", "qwdl", "quickaxl", "qxxL", "sqaxle", "qextlb", "quxtlc", "qxtel", "quexl", "iqexll", "qttel", "qaxel", "quxtli", "qxxll", "qctlc", "Qexlc", "qtxL", "Qxlc", "quickaxli", "qaxr", "naxll", "qfxli", "sqxlc", "qyla", "sqxel", "iqxel", "qXel", " quxll", "qexsl", "qexle", " quxlp", "qctli", "qtxdl", "qyli", " qxli", " quxsl", "qlexl", "qrexel", "quxL", "qufxll", "Qxl", "qbyll", "quebyll", "qexrl", "iqexlc", "qxxli", "sqxdl", "qulexrl", "qxxkl", "qXlc", "quxrl", "qlllc", "qlexlc", "qfxll", "qpxle", "qxrl", "qwel", "quxlp", "sqxle", "iqexel", "qxf", "quickaxel", "quxel", "nxll", "qexll", "qswll", "qxtlc", "qrxel", "nxl", "qysl", "Qxel", "qzxlc", "qxdl", " qxel", "qauxf", "qwxlc", "qextll", "qaxf", "qctl", "iqxlb", "Qxll", "qauxel", " qxlc", "qxlb", "qrexlc", "qxxl", "qulexl", "quexll", " qxlp", " qrxl", "qaxli", "qaxll", "qxlp", "qttf", "quyla", "qwl", "qpxl", "quxtel", "quxsl", "quickaxdl", "qauxli", "quyli", "qzxlb", "iqexlb", "qxla", "quickxli", "qttl", "qaxl", "quxdl", "quxl", "qrxli", "qxlc", "qxsl", "iqxlc", "qufxl", " quxl", " qrxll", "qufxls", "quxf", " quxel", "qxll", "qaxle", "qfxL", "sqxr", "quickxdl", "qtxli", "qllel", "qextl", "qxr", "qzxl", "qexl", "qfxlp", " qxls", "qxxlb", "qxL", "qexL", "qtxl", "quebylb", "quxls", "qfxl", "qaxlc", "qrexdl", "qxkl", "qlll", "qexls", "qylc", "nxli", "qtxll", "qpxr", "sqaxr", "qxxf", "qlexrl", "qexr", "quyl", "qexel", "qextkl", "QxL", "qxxlc", "sqaxl", "qulexlc", "naxlc", " qxll", "sqwdl", "qwxdl"], "errp": ["Erp", "erfp", " errjp", "erjp", "Erap", "Ertp", "rarp", "errap", "errb", "Erjp", " errap", " errfp", "errtp", "erb", "rartp", "rarfp", "erap", "errjp", "rarb", "erp", "Erb", "Erfp", "errfp", "ertp"], "config": ["master", "address", "options", "name", "program", "cfg", "ch", "sec", "spec", "component", "channel", "setting", "data", "support", "db", "expl", "cal", "project", "client", "gui", "state", "server", "length", "args", "connect", "param", "conf", "init", "cont", "con", "control", "service", "connection", "driver", "storage", "path", "bc", "ini", "controller", "context", "input", "output", "settings", "ca", "fig", "proc", "c", " Config", "design", "Config", "model", "license", "text", "cache", "current", "set", "host", "conn", "mode"], "pci_device_rev": ["pci_device_prev", "pci_device_rel", "pci_gpu___rel", "pci_device_version", "pci_devicesrev", "pci_gpu_version", "pci_device__rev", "pci_model_tag", "pci_dev_ref", "pci_device_tag", "pci_device__rh", "pci_mode_rh", "pci_device___rel", "pci_dev_version", "pci_gpu___version", "pci_dev_rev", "pci_device_build", "pci_model_re", "pci_mode_rel", "pci_devicesorig", "pci_model_orig", "pci_gpu___ref", "pci_gpu___rev", "pci_device__rel", "pci_model_ctr", "pci_devicestag", "pci_gpu_rev", "pci_device___rev", "pci_gpu_ref", "pci_device__version", "pci_gpu_rel", "pci_mode_prev", "pci_device_orig", "pci_device_ref", "pci_device___ref", "pci_device__prev", "pci_devicesbuild", "pci_device___version", "pci_device_ctr", "pci_device_rh", "pci_device__ref", "pci_dev_id", "pci_model_build", "pci_mode_rev", "pci_dev_orig", "pci_model_rev", "pci_device_re", "pci_device_id"], "io_size": ["ioacvalue", "io6size", "io_loc", "ioamrange", "ioacwidth", " io_value", "system_sign", "io_len", "system_size", "IO_width", "io_shape", "systemamsign", "rioacalign", " io6len", " io6value", "rioacsize", "ioalwidth", " io_len", "io___sized", "io6len", " ioacfee", " ioacshape", "iofstrength", "ioamnumber", "io_cost", "IOfcost", " ioacsized", "ioacalign", "system_number", "io___shape", "ioacsized", "rioacstrength", " io_loc", " io_fee", "ioalstrength", "ioacloc", "ioalsize", "io_sign", "io___size", "io_value", "IOfwidth", "systemamnumber", "IOfsize", "io_sized", "io_align", " io6size", "systemamsize", "rio_align", "io_fee", "ioamsign", "ioacsize", " io6loc", "io_number", "io_width", "ioacshape", "io_strength", "IO_strength", "io___align", "IO_cost", " ioacsize", "rio_size", "io_range", "io___fee", "iofcost", " io_shape", "io___width", "ioalcost", "iofsize", "ioacfee", "IOfstrength", "rioacwidth", "io___strength", "ioamsize", "io6value", " io_sized", "ioaclen", "rio_strength", "system_range", "io6loc", "rio_width", "IO_size", "ioacstrength", "systemamrange", "iofwidth"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 5781, "substitutes": {"dest": ["master", "est", "miss", "done", "shape", "data", "delete", "status", "route", "ctr", "dom", "cont", "die", "Dest", "err", "hop", "access", "stage", "output", "trans", "head", "trip", "img", "mode", "option", "name", "id", "parent", "config", "null", "content", "dist", "table", "member", "target", "path", "usr", "node", "txt", "class", "ident", "text", "test", "end", "ui", "address", "origin", "tmp", "home", "loc", "wb", "db", "cl", "num", "select", "coord", "feat", "source", "temp", "prop", "transfer", "start", "orig", "contract", "west", "desc", "sup", "src", "dim", "sort", "session", "draw", "de", "rest", "lit", "dc", "cb", "result", "opt", "transform", "comb", "ord", "success", "cdn", "shift"], "linesize": [" linesizing", " linessize", "casesization", " linesiz", "nssize", "linesization", "casesize", "nsizing", "linedsize", "linediz", "nsize", "lineship", " lineship", "linship", "casesizing", "linesiz", "linsiz", "linssize", "linsize", "nsization", "linedhip", "linesizing", "casessize", "linedize", "linessize", " linesization"], "block": ["Block", "address", "pack", "row", "name", "clean", "word", "check", "chain", "config", "channel", "list", "object", "map", "unit", "cl", "num", "event", "table", "match", "def", "buffer", "col", "section", "comment", "bc", "lock", "load", "source", "blocks", "line", "none", "node", "contract", "type", "bl", "cache", "ref", "group", "end", "copy"], "i": ["gi", "ti", "v", "I", "count", "di", "ci", "ji", "ni", "x", "b", "io", "xi", "si", "abi", "info", "bi", "qi", "l", "f", "pi", "d", "j", "ii", "iu", "ai", "cli", "u", "e", "ami", "col", "uri", "k", "n", "multi", "mi", "ie", "p", "oi", "hi", "c", "ip", "api", "li", "fi", "index", "zi", "mu", "ui"], "cm": ["cp", "address", "dim", "cr", "dm", "hem", "gm", "rom", "comm", "iam", "vm", "om", "ci", "config", "sem", "com", "wm", "bm", "cy", "co", "module", "dem", "m", "rm", "ram", "pm", "cc", "param", "cum", "man", "center", "cont", "km", "mc", "em", "que", "CM", "cam", "hm", "dc", "cmd", "ctx", "cms", "car", "fm", "ca", "asm", "DC", "don", "am", "c", "im", "mm", "cn", "ym", "lc", "cf", "um", "rem", "ctrl", "mode", "cd", "tc"]}}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n", "idx": 5789, "substitutes": {"src": ["rb", "data", "typ", "dest", "stream", "uc", "support", "buf", "bs", "connect", "func", "hh", "bc", "sound", "proc", "sel", "usc", "upload", "img", "rec", "view", "pack", "build", "st", "aug", "cur", "spec", "s", "config", "upp", "url", "sl", "obl", "dist", "sc", "node", "secure", "text", "reflect", "rs", "grad", "stat", "tmp", "rc", "sync", "loc", "inc", "conv", "rss", "sb", "inst", "hl", "source", "input", "gb", "supp", "ssl", "desc", "sup", "sub", "cmp", "chrom", "http", "sit", "sort", "comp", "uv", "rest", "attr", "split", "impl", "control", "cb", "req", "iv", "transform", "fc", "cv"], "stride": ["instice", "bripe", "strided", "errine", "shride", "yrided", "fide", "rider", "rided", "erider", "ripe", "shrided", "striden", "intided", "eride", "strine", "erided", "rides", "stid", "instided", " strid", " striden", "yrider", " strided", "etrider", "drider", "bride", "yrine", "brise", "frided", "stided", "fise", "brider", "drided", "erides", "shrider", "stider", "etrided", "brine", "brided", "intide", "stipe", "shrice", "fride", "strice", "instide", "erine", "stide", "yride", "strider", "stripe", " strider", "frine", "etriden", "driden", "instider", "intine", "erride", "drine", "dride", "errided", "strides", "fided", "strid", "frider", "fider", "drides", "strise", "etride", "intider", "brice", "stise", "errider", "brid", "ride"], "mode": ["plugin", "MODE", "dim", "ward", "id", "md", "method", "Mode", "config", "guide", "style", "slice", "module", "phase", "m", "ace", "route", "attr", "grade", "mod", "toggle", "def", "dir", "code", "driver", "path", "ode", "source", "theme", "scale", "stage", "operation", "prop", "direction", "range", "slave", "type", "transform", "link", "ride", "role"], "r": ["row", "rw", "er", "o", "sr", "cr", "v", "rr", "a", "rb", "b", "rc", "i", "or", "m", "l", "ir", "f", "ru", "ra", "d", "nr", "u", "e", "ar", "w", "t", "k", "n", "err", "p", "h", "R", "mr", "re", "c", "range", "hr", "br", "rs"]}}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 5797, "substitutes": {"opaque": ["copptr", "opque", "obec", "opsaque", "obptr", "obaque", "opsacity", " opque", "openaques", "operec", "opsaques", "operaque", "openacity", "opptr", "openaque", "obace", "copace", "opec", " opacity", "operace", "copec", "operptr", "opaques", "copaque", "openque", "opsque", "opace", "opacity", " opaques"], "addr": ["address", "r", "name", "dr", "layer", "host", "rt", "md", "eth", "x", "data", "rc", "inter", "enc", "xp", "ad", "oa", "art", "loc", "ace", "fx", "route", "mac", "offset", "ext", "call", "url", "adder", "ack", "align", "bb", "advert", "kt", "size", "part", "code", "en", "arr", "ino", "dc", "hl", "pad", "hop", "str", "work", "p", "sta", "amp", "asm", "ptr", "start", "pointer", "pos", "alloc", "ip", "adr", "amd", "ord", "ref", "src", "grad", "mode", "add"], "len": ["bin", "mem", " clen", "lan", " data", "val", "data", " lib", " bytes", "length", " length", " mem", "code", "en", "lib", "bytes", "str", "seq", " str", "Len", "off", " size", "type", "size"], "opp": ["oc", "cmp", "agg", "append", "od", "ppo", "ost", "obb", "omp", "effect", "eff", "unknown", "kick", "plug", "tmp", "op", "pp", "kk", "odd", "comp", "stick", "rog", "upp", "nick", "ipp", "oop", "pps", "Opp", "org", "obj", "ack", "operator", "advert", "owner", "online", "inst", "cho", "jp", "opers", "own", "coll", "ogg", "iv", "oper", "oi", "ppa", "supp", "off", "ip", "hack", "ov", "oga", "obo", "front", "app", "cpp", "oph", "cop", "lov"], "idx": ["IDx", "intX", " idy", "idz", "IDz", " idv", "idindex", "idn", "IDw", " idxc", "idw", "sidz", "indX", " idwork", " idpe", "idwork", "Idwork", "dx", "IDindex", "IDX", "Idv", "Idx", "pidv", "sidxc", "dindex", "idX", " idindex", "intpe", "Idxc", "Idy", "idv", "Idn", "IDy", "dw", " idX", "IdX", " idz", " idn", " idw", "sidX", "pidx", "indx", "intz", "idy", "intx", "dz", "pidy", "pidX", "idpe", "idxc", "IDn", "indxc", "Idpe", "sidx", "Idz", "indwork"]}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "static void gen_exception_insn(DisasContext *s, int offset, int excp)\n\n{\n\n    gen_a64_set_pc_im(s->pc - offset);\n\n    gen_exception(excp);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n", "idx": 5810, "substitutes": {"s": ["sets", "is", "S", "a", "spec", "sg", "b", "i", "sync", "sys", "ses", "services", "m", "f", "ns", "d", "stats", "args", "server", "service", "ss", "cs", "u", "e", "parser", "gs", "ks", "sb", "t", "ts", "self", "p", "settings", "sup", "fs", "c", "new", "g", "ssl", "sq", "sym", "os", "your", "es", "rs", "src", "ps", "js"], "offset": ["address", "cmp", "padding", "reset", "position", "origin", "count", "parent", "data", "i", "slice", "Offset", "phase", "adjust", "loc", "image", "num", "limit", "length", "align", "error", "port", "pad", "timeout", "fp", "seq", "p", "pos", "pointer", "start", "range", "location", "type", "addr", "ref", "index", "set", "shift", "prefix"], "excp": ["exip", "expcpp", " exbp", "explcpp", "expcp", "essCP", "explCP", "expip", "explcp", "Excpp", "excpp", "esscp", "ExCP", "exbp", " exCP", "Excp", "expCP", "explip", "Exbp", "exCP", "Exip", "essbp"]}}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n", "idx": 5820, "substitutes": {"request": ["patch", "condition", "Request", "id", "complete", "try", "parent", "require", "object", "data", "xml", "resource", "client", "post", "child", "order", "call", "create", "subject", "q", "QUEST", "push", "error", "message", "instance", "path", "response", "self", "result", "context", "input", "req", "frame", "hello", "head", "type", "report", "model", "query", "user", "r", "quest"], "errp": ["rrpre", "Erp", "erpc", "erP", "nerps", "finderc", "errorr", "Erpc", "nerp", "rrP", "erping", "herP", "finderpre", "errorp", "errorpre", "rrp", "herping", "herp", "errP", "errping", "errpc", "ErP", " errP", "finderp", "erps", " errping", "finderping", "errorpc", " errpc", " errc", "lerp", "lerP", "err", "herr", " errps", "nerP", "lerping", "errc", "lerr", "errps", "errr", "erp", " errr", "nerpc", "Erc", "rrpc", " errpre", "rrc", "rrping", "errpre", "erpre"], "ent": ["ENT", "gent", "cent", "anc", "ect", "ch", "od", "sec", "id", "entry", "parent", "ente", "nt", "anch", "elt", "et", "enc", "art", "sett", "pt", "loc", "enter", "inc", "rent", "ict", "cart", "event", "de", "entity", " entry", "ce", "ev", "kt", "sent", "e", "det", "inst", "en", "vent", "se", "conn", "dc", "pent", "ant", "exec", "Ent", "equ", "ents", "ou", " entity", "ec", "ut", "intent", "ind", "ct", "ment", "ident", "query", "inner", "rec", "nd", "end"], "arg_name": ["Arg_Name", "attr_obj", "arg__code", "argument__code", "attracnm", "arg__Name", "enc__value", "argument_key", "enc__obj", "arg__len", "argaccommon", "arg__names", "enc_name", "argSobj", "argument__key", "argacobj", "arg_nm", "argument__name", "arg__obj", "arg_common", "attr_name", "Arg_word", "argument_name", "arg_names", "argacnm", "argument_code", "enc__len", "attracname", "enc_len", " arg_names", "Arg_obj", "arg_word", "attr_common", "enc_value", "enc_obj", "arg__value", "attracobj", "arg__name", "attraccommon", "arg_Name", "arg_len", "arg_key", "enc__name", "arg_code", "arg_value", " arg_Name", "argument_Name", "argument__Name", "argSword", "argSname", "Arg_name", "argacname", "attr_nm", "argSName", "arg__key"], "arg_obj": ["arg__object", "Arg_object", "Arg_xy", "arg_ob", "arg_val", " arg_object", "ar_name", "ar_ob", "ar_obj", "Arg_val", "Arg_obj", "arg__obj", " arg_ob", "arg__name", "ar_object", "arg__ob", "arg_xy", "arg_object"], "dict": ["condition", "dr", "inf", "diff", "count", "entry", "parent", "di", "dat", "nt", "value", "session", "config", "po", "list", "pillar", "object", "data", "rec", "cat", "module", "record", "map", "details", "db", "inc", "ict", "state", "d", "obj", "document", "table", "init", "dir", "dom", "def", "code", "out", "arr", "dev", "da", "dc", "ds", "df", "instance", "file", "full", "err", "response", "str", "lock", "path", "coll", "result", "array", "req", "collection", "doc", "tree", "hash", "ct", "head", "back", "dt", "query", "cache", "index", "set", "conn", "nd"]}}
{"project": "FFmpeg", "commit_id": "7e4fe5162ab94a413e04caae19193c5e7a4c6478", "target": 0, "func": "static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])\n\n{\n\n    uint32_t block[80];\n\n    unsigned int i, a, b, c, d, e;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 80; i++) {\n\n        int t;\n\n        if (i < 16)\n\n            t = AV_RB32(buffer + 4 * i);\n\n        else\n\n            t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1);\n\n        block[i] = t;\n\n        t += e + rol(a, 5);\n\n        if (i < 40) {\n\n            if (i < 20)\n\n                t += ((b&(c^d))^d)     + 0x5A827999;\n\n            else\n\n                t += ( b^c     ^d)     + 0x6ED9EBA1;\n\n        } else {\n\n            if (i < 60)\n\n                t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC;\n\n            else\n\n                t += ( b^c     ^d)     + 0xCA62C1D6;\n\n        }\n\n        e = d;\n\n        d = c;\n\n        c = rol(b, 30);\n\n        b = a;\n\n        a = t;\n\n    }\n\n#else\n\n    for (i = 0; i < 15; i += 5) {\n\n        R0(a, b, c, d, e, 0 + i);\n\n        R0(e, a, b, c, d, 1 + i);\n\n        R0(d, e, a, b, c, 2 + i);\n\n        R0(c, d, e, a, b, 3 + i);\n\n        R0(b, c, d, e, a, 4 + i);\n\n    }\n\n    R0(a, b, c, d, e, 15);\n\n    R1(e, a, b, c, d, 16);\n\n    R1(d, e, a, b, c, 17);\n\n    R1(c, d, e, a, b, 18);\n\n    R1(b, c, d, e, a, 19);\n\n    for (i = 20; i < 40; i += 5) {\n\n        R2(a, b, c, d, e, 0 + i);\n\n        R2(e, a, b, c, d, 1 + i);\n\n        R2(d, e, a, b, c, 2 + i);\n\n        R2(c, d, e, a, b, 3 + i);\n\n        R2(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 60; i += 5) {\n\n        R3(a, b, c, d, e, 0 + i);\n\n        R3(e, a, b, c, d, 1 + i);\n\n        R3(d, e, a, b, c, 2 + i);\n\n        R3(c, d, e, a, b, 3 + i);\n\n        R3(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 80; i += 5) {\n\n        R4(a, b, c, d, e, 0 + i);\n\n        R4(e, a, b, c, d, 1 + i);\n\n        R4(d, e, a, b, c, 2 + i);\n\n        R4(c, d, e, a, b, 3 + i);\n\n        R4(b, c, d, e, a, 4 + i);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n}\n", "idx": 5826, "substitutes": {"state": ["function", "stat", "address", "statement", "layer", "position", "store", "open", "parent", "shape", "scope", "value", "session", "config", "STATE", "list", "update", "object", "style", "data", "sync", "body", "states", "key", "resource", "private", "length", "space", "error", "message", "port", "State", "lock", "source", "context", "transfer", "start", "rule", "back", "g", "range", "type", "model", "element", "set", "index", "manager", "seed", "conn", "size"], "buffer": ["flow", "position", "buff", "header", "v", "I", "shape", "channel", "uffer", "object", "data", "io", "x", "queue", "image", "buf", "window", "null", "offset", "f", "length", "bb", "table", "byte", "code", "Buffer", "binary", "message", "n", "timeout", "p", "batch", "frame", "transfer", "board", "r", "command", "size"], "block": ["condition", "Block", "base", "address", "flow", "pack", "row", "position", "bin", "parent", "channel", "chain", "config", "list", "object", "sync", "bit", "unit", "map", "loc", "buf", "key", "table", "byte", "number", "code", "point", "error", "section", "out", "comment", "lock", "array", "input", "output", "blocks", "batch", "frame", "line", "node", "rule", "ip", "range", "contract", "type", "label", "board", "head", "bl", "ban", "cache", "element", "group", "index", "view"], "i": ["isi", "I", "di", "ci", "x", "xi", "bi", "f", "pi", "ii", "mini", "oi", "y", "li", "fi", "index", "zi", "gi", "ti", "id", "is", "ji", "slice", "abi", "info", "ix", "at", "phi", "it", "ai", "uri", "mi", "ini", "ie", "z", "ip", "anti", "ui", "ni", "ri", "io", "yi", "adi", "j", "cli", "u", "vi", "k", "p", "hi", "api", "r", "mu", "o", "ei", "v", "si", "in", "qi", "l", "iu", "q", "init", "n", "multi", "eni", "diff"], "a": ["as", "o", "area", "na", "ea", "v", "alpha", "s", "va", "aa", "x", "ad", "ae", "wa", "m", "ia", "l", "ma", "f", "at", "j", "ai", "u", "code", "an", "ak", "w", "ar", "da", "n", "A", "ab", "ba", "p", "aaa", "fa", "ie", "ca", "be", "h", "z", "am", "sa", "ta", "g", "y", "api", "ac", "au", "r", "aw"], "b": ["base", "as", "o", "ch", "lb", "ib", "bin", "v", "emb", "el", "s", "rb", "aa", "x", "ob", "ad", "bi", "m", "fb", "l", "db", "wb", "f", "j", "bs", "bb", "u", "eb", "an", "sb", "w", "k", "n", "ab", "bc", "B", "cb", "ba", "p", "ca", "be", "h", "z", "gb", "g", "bf", "y", "bl", "app", "r", "bh", "bar"], "c": ["cp", "o", "ch", "cr", "v", "s", "ci", "x", "cy", "cat", "co", "C", "m", "l", "cl", "f", "q", "cs", "ce", "u", "con", "sc", "w", "k", "dc", "n", "bc", "cu", "p", "ec", "ca", "h", "z", "g", "y", "cf", "cn", "lc", "ac", "r", "cm", "cd"], "d": ["D", "dy", "o", "v", "id", "dn", "di", "s", "dd", "x", "dh", "ad", "m", "db", "l", "f", "j", "q", "u", "w", "da", "ds", "n", "dc", "k", "p", "h", "z", "g", "y", "dt", "r", "cd"], "e": ["o", "ei", "er", "ea", "el", "v", "ef", "s", "x", "pe", "ae", "m", "eu", "l", "de", "f", "j", "fe", "ce", "u", "an", "E", "oe", "w", "en", "se", "k", "n", "ie", "ee", "ne", "p", "ec", "be", "h", "z", "g", "y", "element", "ed", "es", "r", "end"], "t": ["o", "tf", "st", "ti", "te", "v", "id", "s", "nt", "x", "et", "token", "wt", "tu", "m", "pt", "l", "ty", "f", "at", "j", "it", "q", "the", "table", "u", "mt", "w", "k", "n", "tm", "ant", "ts", "p", "h", "ut", "z", "ta", "g", "y", "type", "dt", "tp", "tt", "T", "text", "set", "r"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n", "idx": 5834, "substitutes": {"f": ["fat", "fr", "o", "buff", "fw", "b", "x", "rf", "i", "m", "fx", "l", "d", "j", "fo", "obj", "conf", "e", "w", "file", "t", "df", "ff", "fp", "self", "fa", "p", "h", "fs", "c", "g", "fd", "ref", "lf", "fi", "img", "F"], "pv": ["Pb", " pb", "pp", "pV", "Pp", "cpv", " pf", "pf", "cpf", "PV", " pV", "apf", "apv", " pp", "Pf", "apV", "cpb", "cpV", "Pv", "app", "pb"], "size": ["SIZE", "large", "shape", "value", "V", "val", "data", " V", " sizes", "fff", "l", "Size", "e", "w", " Size", "iv", "z", " n", "c", "g", "ize"], "v": ["nv", "o", "s", "value", "V", "vt", "b", "inv", "val", "i", "x", "data", "m", "uv", "l", "ve", "j", "d", "q", "tv", "u", "vi", "vs", "e", "t", "k", "n", "volume", "p", "vp", "sv", "iv", "c", "g", "lv", "video"]}}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "idx": 5837, "substitutes": {"build_opaque": ["build_iopacity", "build_operacity", "build_opifice", "build_catacity", "build_opque", "build_opsacity", "build_iopifice", "build_opsesc", "build_operaque", "build_opesc", "build_operesc", "build_opsaque", "build_catque", "build_opsque", "build_iopque", "build_cataque", "build_operque", "build_catesc", "build_iopaque", "build_opsifice", "build_opacity", "build_operifice"], "offset": ["base", "address", "ocol", "padding", "count", "ips", "order", "limit", "length", "from", "code", "len", "port", "seq", "end", "array", "scale", "zero", "pos", "pointer", "start", "os", "off", "ip", "initialized", "ref", "set", "index", "shift"], "build_state": ["build_resource", " build_settings", "buildappcontext", "build_context", "work_info", " build_statement", "buildercontext", "build6state", " build_spec", "user_STATE", "builderresource", "update_state", "buildappstruct", "builderinfo", " build_State", "buildappobject", "builterstate", "build_struct", "build_notice", " build_id", "build6states", "buildingconfig", "build_info", "built_State", "build_statement", "build_config", "buildocstate", " build_states", "update_config", "build_id", "clean_states", "builderstart", "buildocspec", "update_states", "user_spec", "buildocstates", "build_start", "builderobject", "build6statement", "workerstate", "built_start", "user_state", "builterresource", "clean_config", "build6notice", "buildingstate", "update_data", "work_object", "buildocsettings", "build_object", "built_state", "buildappinfo", "build_settings", "clean_stat", "build_stat", "build_spec", "builderstate", "buildappstate", "work_context", "work_state", "workercontext", "user_struct", "build_data", "buildappSTATE", "workerinfo", "build_STATE", "build_states", " build_STATE", "buildingstates", "built_resource", "buildappspec", " build_notice", "builterState", "workerobject", "builterstart", "buildingstat", "builderState", "clean_state", "build_State"], "tables": ["fributes", " tips", "Table", "pable", "Teries", "pipes", "qtips", "atas", "atables", "Tables", "tenubs", "atipes", "Tipes", "Tests", "untables", "Tas", "ptables", "tipes", "fests", "tenables", " teries", "qtable", " tamps", "fees", "fipes", "tips", " tubs", "pables", "ateries", "teries", "table", "untributes", "vipes", "tamps", "ptipes", "untipes", "tubs", "tees", "vable", " tas", "ptamps", "tests", " table", "vables", "tas", " tests", "tenable", "qtables", " tipes", "trees", "tributes", "fables", "tenips", " tributes", "untees", "fable", " tees", " trees", "Trees", "Tamps", "ptrees", "qtubs"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_nb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 8000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    avctx->frame_size  = 160;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->enc_state = Encoder_Interface_init(s->enc_dtx);\n\n    if (!s->enc_state) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Encoder_Interface_init error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->enc_bitrate = avctx->bit_rate;\n\n\n\n    return 0;\n\n}", "idx": 5845, "substitutes": {"avctx": ["ajconfig", "akcontext", " avcf", "avedc", "ajctl", "ajdc", "amctx", "vercu", "avecoll", "aveloc", "afxc", "avcb", "avalcoll", "afctx", "ajcb", "amcontext", "aveca", "avkb", "ajctx", "afdc", "ajkb", " avcontext", "avca", "vercn", "verdc", "afcs", "avalsync", "ajca", " avconfig", "airctx", "ajcos", "afcv", "avalctl", "afcb", "avcs", "afloc", "ajbc", "afcmp", "avcmp", "avcos", "akctx", "afcn", "avcv", "avalctx", "avxc", "avec", "ajcu", "aveconn", "avecontext", "afcf", "verca", "avecu", "avbc", "avalcontext", "avsync", "avc", " avxc", "afctl", "vercontext", "ajsync", "avcu", "avconfig", "amsync", "afkb", "afsync", "avcontext", " avcn", "airconn", "ajxc", "afcoll", "amkb", "avloc", "avconn", "ajconn", "afcos", "akcs", "avcn", "avalcos", "avctl", "avdc", "avectx", "avalloc", "ajcs", "ajcv", "avalcmp", "avcoll", "avebc", "avcf", "airc", "afbc", "avalcb", "verctx", "aircontext", "akcu", "afconn", "afcontext", "afconfig", "ajcontext", "avaldc", "akcv", "avecmp", "afc", "afcu", "vercf"], "s": ["r", "o", "sets", "v", "ins", "is", "S", "a", "sg", "session", "b", "data", "si", "sync", "i", "sys", "ses", "services", "m", "its", "l", "xs", "f", "parts", "ns", "d", "ls", "args", "service", "cs", "ss", "hs", "u", "e", "sc", "w", "gs", "ops", "ks", "sb", "bis", "qs", "ds", "t", "ctx", "ts", "self", "p", "h", "acs", "fs", "c", "os", "g", "ssl", "sq", "sym", "es", "ps", "js"]}}
{"project": "FFmpeg", "commit_id": "c6bdc90890250ce351b260eff69ce3c0d0745a62", "target": 1, "func": "void help(void)\n\n{\n\n    printf(\"dct-test [-i] [<test-number>]\\n\"\n\n           \"test-number 0 -> test with random matrixes\\n\"\n\n           \"            1 -> test with random sparse matrixes\\n\"\n\n           \"            2 -> do 3. test from mpeg4 std\\n\"\n\n           \"-i          test IDCT implementations\\n\"\n\n           \"-4          test IDCT248 implementations\\n\");\n\n    exit(1);\n\n}\n", "idx": 5846, "substitutes": {}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "func": "static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n", "idx": 5864, "substitutes": {"pb": ["bp", "lb", "hub", "pit", "platform", "pa", "rb", "tmp", "bt", "plug", "pd", "bps", "pp", "wp", "lp", "fb", "buf", "db", "wb", "pm", "mp", "prot", "abb", "obj", "pc", "xb", "eb", "sb", "ctx", "bc", "PB", "fp", "p", "ppa", "txt", "bf", "api", "tp", "fc", "pl", "cpp", "bh", "pkg", "tc"], "len": ["base", "fat", "layer", "el", "lan", "val", "lt", "elt", "lp", "ll", "body", "l", "lit", "f", "ler", "limit", "length", "fl", "url", "ls", "split", "part", "en", "den", "fn", "lic", "lib", "lon", "seq", "pos", "line", "Len", "ln", "lin", "lc", "dl", "li", "lf", "le", "size"], "n": ["rn", "name", "o", "nor", "na", "ann", "v", "not", "nn", "dn", "s", "nt", "ni", "non", "b", "nc", "i", "sn", "m", "l", "num", "f", "N", "mn", "ns", "d", "nr", "j", "init", "net", "u", "number", "e", "an", "size", "pn", "en", "fn", "t", "k", "nb", "p", "ne", "h", "network", "un", "ner", "ln", "c", "node", "g", "cn", "y", "adj", "next", "gn", "no", "min", "conn", "nu"], "n1": [" napp", "l3", "N3", "nn", "N61", "l8", "ncn", "N1", "Nn", "l2", "ne8", "N2", "n3", "nn1", "N8", "ne3", "nn2", "ncone", "ne1", "l1", "pn", "p1", " nn", "pone", "nc1", "papp", " none", "none", "nn61", "napp", " n2", "ncapp", "ne2", "n2", "n8", "nnn", " n61", "n61"]}}
{"project": "qemu", "commit_id": "e5ba83c53add51796e8ea787d2b7cb1f9c3cb72d", "target": 0, "func": "CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n\n                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],\n\n                        int do_init, const char *cpu_model)\n\n{\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"440-Xilinx\"; // XXX: should be 440EP\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_booke_timers_init(env, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 5875, "substitutes": {"address_space_mem": ["address_sp_mem", "address_space_mc", "address_spaceofmem", "address_spaceofmc", "address_sp_mm", "address_space_mm", "address_spaceofmm", "address_sp_mc"], "ram_size": ["ram_name", "mem_offset", "ram\u00b7name", "ramFaddress", "ramxoffset", "ram_num", "ram_mode", "ramfnum", "ramFoffset", "access_mode", "memory_name", "access_sized", "memory_size", "ram_model", "ramFmemory", "ram\u00b7size", "ramFsize", "mem_size", "mem_memory", "ramxsize", "ram\u00b7num", "ramfname", "ramxmemory", "ram\u00b7offset", "ramfsize", "memory_offset", "memory_num", "ramxaddress", "access_model", "ram_memory", "ram_address", "access_size", "ram_offset", "ramfoffset", "mem_address", "ram_sized"], "pcip": ["pcid", "PCip", "PCipes", "pcips", "PCid", "cipes", "ccid", "cip", "pcipes", "ccips", "cips", "ccip", "cid", "ccipes", "PCips"], "pci_irq_nrs": ["pci_irq_codes", "pci_irq_nls", "pci_irq_cls", "pci_irq_Nls", "pci_irq_nws", "pci_irq_nodes", "pci_irq_cws", "pci_irq_Nrs", "pci_irq_Nws", "pci_irq_Nodes", "pci_irq_crs"], "do_init": ["cpu_init", "do_alloc", "cpu_alloc", "cpu_set", "do_set"], "cpu_model": ["machinejmodels", "cpu_models", "cpupmemory", "machinejlocation", "memory_description", "cpualquery", "cpulexmodel", "cpuallocation", "ram_location", "cpualmodel", "memorylexmodel", "cpupmodels", "cpu_size", "machine_location", "cpujmodels", "machine_memory", " cpu_size", "memory_models", " cpu_store", "cpulexdescription", "cpu_memory", "cpu_store", "memory_model", "cpujlocation", " cpu_source", "memory_size", "machine_models", "cpuplocation", "memorylexsize", "ram_model", "ram_params", "ram_query", "cpu_source", "cpualparams", "cpujmemory", "cpupmodel", "memorylexmodels", "cpu_description", "machinejmodel", "cpulexsize", "machinejmemory", "cpu_location", "cpulexmodels", "cpu_query", "cpu_params", "memorylexdescription", "cpujmodel", "machine_model"], "ram_memories": ["ram_morts", "ram_temores", "ram_temory", "ram_matorts", "ram_memores", "ram_temries", "ram_shories", "ram_mory", "ram_mories", "ram_temories", "ram_monories", "ram_matories", "ram_monory", "ram_processores", "ram_mators", "ram_processries", "ram_memors", "ram_memries", "ram_temorts", "ram_shory", "ram_processories", "ram_matory", "ram_mries", "ram_memory", "ram_processory", "ram_mores", "ram_shorts", "ram_memorts", "ram_shores", "ram_monors", "ram_temors", "ram_monorts"], "ram_bases": ["_", "ram_mbasses", "ram_brases", "ram_buffias", "ram_basses", "ram_nbased", "all", "func", "cpu", "ram_brased", "g", "ram_barases", "ram_baraches", "ram_based", "ram_nbases", "ram_buffasing", "ram_buffases", "ram_nias", "ram_baches", "ram_compases", "ctx", "ram_bias", "ram_nasses", "ram_nbias", "ram_barasses", "ram_buffased", "ram_buffasses", "ram_mbases", "ram_buffonents", "ram_mbias", "ram_brasing", "ram_nases", "r", "ram_bonents", "ram_buffaches", "ram_mbaches", "ram_components", "get", "args", "ram_nonents", "ram_brias", "ram_basing", "ram_nbasing", "ram_compasses", "ram_compias", "ram_barias"], "ram_sizes": ["ram_timesizes", "ram_lizes", "ram_outsize", "ram_bources", "ram_sanguages", "ram_stylesets", "ram_lamples", "ram_stylesizes", "ram_outsizes", "ram_languages", "ram_timesets", "ram_cizes", "ram_lists", "ram_cigs", "ram_lize", "ram_lources", "ram_sifts", "ram_sets", "ram_bize", "ram_bizes", "ram_timesifts", "ram_nosamples", "ram_timesamples", "ram_outsources", "ram_nosigs", "ram_banguages", "ram_outsanguages", "ram_sists", "ram_nosizes", "ram_stylesifts", "ram_nosists", "ram_lets", "ram_camples", "ram_sources", "ram_lifts", "ram_samples", "ram_cists", "ram_stylesamples", "ram_ligs", "ram_sigs"], "env": ["bg", "environment", "style", "gui", "gear", "conf", "ev", "her", "here", "empty", "exec", "err", "equ", "Environment", "enh", "ec", "stage", "pect", "engine", "ku", "img", "conn", "ah", "config", "qt", "nc", "module", "eu", "eye", "ctx", "eval", "viron", "doc", "txt", "cf", "size", "fg", "eng", "dat", "vel", "exc", "rc", "db", "inc", "export", "obj", "net", "np", "vs", "e", "que", "en", "dev", "me", "erv", "shell", "cache", "app", "loader", "dict", "enable", "fen", "anc", "ea", "ig", "v", "scope", "session", "stack", "enc", "window", "event", "args", "init", "dir", "impl", "pec", "lock", "context", "eni", "console", "cv", "manager"], "pic": ["pot", "ig", "bin", "mic", "pin", "config", "xi", "sync", "typ", "enc", "image", "pins", "eric", "mac", "picture", "bus", "cci", "gui", "pc", "mc", "nic", "pict", "lic", "lib", "bc", "ic", "mini", "doc", "fig", "proc", "capt", "lc", "fc", "li", "cache", "fi", "lli", "Pic"], "irqs": ["mirws", "mirqs", "IRqs", "irens", "irws", "mirlocks", "IRrows", "rilocks", "riqs", "mirq", "mirces", "irquest", "ireq", "IRques", "irtq", " irws", "irq", "mirques", "irecs", "riq", "ireqs", " irlocks", "pircs", "irtqs", "IRquest", "IRws", "mircs", " irquest", "irlocks", "IRq", "irces", "pirqs", "irarows", "mirrows", "pirq", "mirns", "irtquest", " ircs", "iraces", "iraq", "pirns", "ircs", "iraqs", "IRcs", "irns", "riquest", "IRces", "irques", "irtques", "mirquest", "irrows", " irq"], "pci_irqs": ["pci_irqa", "pci_arq", "pci_arques", "pci_irques", "pci_pirq", "pci_arqs", "pci_mirq", "pci_pirqs", "pci_pirqa", "pci_mirqa", "pci_pirques", "pci_mirqs", "pci_arqa", "pci_irq", "pci_mirques"]}}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n", "idx": 5899, "substitutes": {"dev": ["v", "block", "mem", "rad", "di", "Dev", "dd", "device", "adv", "config", "bug", "data", "info", "dem", "module", "der", "debug", "gu", "state", "mod", "init", "dist", "conf", "ev", "def", "DEV", "dom", "wd", " Dev", "w", "prom", "inst", "die", "error", "dc", "kind", "comment", "err", "self", "serial", "req", "development", "start", "ver", "push", "develop", "engine", "desc", "app", "grad", "conn", "diff", "end"], "d": ["D", "dr", "del", "dm", "v", "id", "md", "a", "ded", "dn", "di", "bd", "dd", "dat", "device", "config", "b", "pd", "dh", "i", "ad", "m", "draw", "l", "db", "f", "u", "dom", "e", "w", "da", "driver", "dc", "sd", "n", "ds", "t", "p", "z", "ld", "c", "ind", "g", "fd", "gd", "dt", "dl", "r", "diff", "cd", "dict"], "pci_conf": ["pcin_conf", "pci5conf", "pci_con", "pki_const", "pci_conn", "pci_Conf", "pcm_conf", "pki_config", "pci5fam", "pki_conn", "pci_gate", "pii_conf", "pci_fam", "pci_config", "pci_cf", "pii_config", "pci_sum", "pci5gate", "pcm_gate", "pii_Conf", "pki_def", "pcm_fam", "pii_con", "pcin_config", "pki_conf", "pcm_config", "pcin_sum", "pci_def", "pci5config", "pki_Conf", "pci_const", "pcin_cf"]}}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n", "idx": 5905, "substitutes": {"_dst": ["_duost", "_hsc", "_dusts", "_dST", "_dost", "_inct", "_dsts", "_dust", "_dct", "_hrc", "_duct", "_inst", "_hST", "_inost", "_delct", "_lrc", "_dssc", "_hst", "_dsst", "_lst", "_dsrc", "_delsts", "_drc", "_insts", "_dsc", "_dsST", "_delst", "_delost", "_lST", "_lsc"], "_src": ["_sl", "_source", "psource", "__sl", "_const", "_rc", "pconst", " _const", "__rc", " _dist", "__src", "_dist", " _rc", "__source", " _source", "prc", "psrc", " _sl"], "stride": ["spid", "stides", "spided", "striding", "stiding", "spide", "strided", " strid", "brided", "shride", "shrance", "Strid", " strance", " strided", "shrice", " striding", "spides", " strice", "strance", "bride", "brance", "triding", "tride", "strides", "trided", " strides", "strid", "strice", "brice", "trides", "Strided", "shrided", "stided", "Strides", "stide", "Stride"], "i": ["gi", "ali", "r", "o", "ti", "v", "id", "I", "a", "di", "ci", "ji", "ni", "pixel", "b", "x", "io", "si", "xi", "ri", "bi", "in", "qi", "ix", "l", "f", "pi", "adi", "d", "ii", "j", "iu", "ai", "u", "e", "col", "k", "n", "multi", "p", "z", "oi", "c", "ip", "y", "api", "li", "fi", "index", "zi", "ui"], "dst": ["ndsts", "dedst", "Dst", "drc", "lst", "ddsc", "rdsc", "fdst", "dssc", "madst", "dest", "dedct", "dssts", "madset", "dstart", "dedconst", "lct", "nst", "dsste", "ndost", "dsst", " dct", "Dest", "dset", "idptr", "rdsts", "dste", "fptr", "dsc", " dest", "ldst", "ldset", "lconst", "rst", "madput", " dset", "ddstart", "rdset", "lsts", " dput", " dsts", "idstart", "rsts", "fdost", "madost", "fdsth", "nsts", "dct", "dconst", "fsts", "idst", "ndset", "dsp", " drc", "fsc", "ddsp", "dsth", "nrc", "madsts", "rsc", "idsc", " dste", "rdput", "fst", "dssth", "idsts", "fdste", "dput", "dsest", "ldost", "Dost", " dost", "Dsts", "dsost", "dedsts", "rdconst", " dstart", "dsts", "rptr", "dptr", "rdst", "ddst", "Dsc", " dsc", " dsp", "ldsts", "idsp", "ndst", " dconst", "dost", " dsth", "madsc", "nsc", "ldconst", "dsrc"], "src": ["stat", "chrom", "pack", "st", "sec", "cur", "sit", "spec", "s", "component", "sort", "rb", "config", "b", "rc", "use", "sn", "sync", "comp", "rel", "dest", "uc", "loc", "image", "support", "status", "sur", "rest", "attr", "url", "sl", "dist", "bb", "sci", "ser", "low", "sc", "uri", "sb", "rect", "inst", "rss", "cont", "lib", "bc", "cb", "sound", "feat", "filename", "source", "uint", "req", "gl", "gb", "iv", "start", "supp", "usc", "ssl", "sq", "secure", "fc", "text", "desc", "site", "rob", "sup", "img", "size"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n\n{\n\n    int i;\n\n    int ret = av_frame_ref(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!h->sps.crop)\n\n        return 0;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n\n        dst->data[i] += off;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5908, "substitutes": {"h": ["H", "hp", "FH", "ah", "hw", "header", "v", "http", "ih", "s", "b", "x", "oh", "uh", "m", "rh", "tx", "l", "f", "d", "ph", "hs", "u", "hm", "sh", "e", "w", "adh", "t", "hh", "hl", "ctx", "he", "self", "eh", "enh", "p", "ht", "c", "gh", "hi", "head", "hr", "g", "ha", "r", "bh", "hd"], "dst": ["datST", "Dst", "drc", "Dconst", "Dsrc", "edsth", "ssth", "Dost", "adsc", "dsc", " dost", "Dsts", "edsts", "ssrc", "edst", "dST", "dsts", "edost", "sst", " dsrc", "sconst", " drc", "Dsc", " dsts", " dsc", "sdost", "sdst", "adst", "sost", "dsth", "adost", "sdsth", " dconst", "datst", "sdsc", "adsth", "ssts", "Dsth", "dost", " dsth", "datsc", "datrc", " dST", "dconst", "DST", "dsrc", "Drc"], "src": ["r", "st", "sr", "inf", "rt", "cur", "roc", "rb", "config", "b", "rc", "sn", "dest", "stream", "image", "loc", "rh", "url", "sh", "sc", "sb", "rect", "inst", "sth", "ctx", "cb", "rl", "source", "req", "iv", "gb", "sel", "ref", "img", "RC"], "i": ["base", "gi", "ib", "ret", "ti", "v", "id", "I", "a", "count", "chi", "di", "s", "ci", "ni", "b", "ri", "io", "val", "si", "x", "xi", "info", "bi", "in", "qi", "ix", "l", "f", "pi", "adi", "j", "ii", "iu", "d", "it", "init", "ai", "cli", "u", "vi", "e", "ami", "uri", "n", "multi", "mi", "ini", "ie", "p", "mini", "eni", "z", "start", "line", "oi", "hi", "c", "api", "li", "fi", "index", "r", "zi", "ui"]}}
{"project": "qemu", "commit_id": "100f8f26086ad85a9361f2883edd55bc337ce594", "target": 1, "func": "void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n", "idx": 5920, "substitutes": {"ts": ["types", "options", "tes", "te", "ers", "lets", "docs", "s", "atts", "als", "asts", "tr", "services", "ters", "js", "sts", "states", "xs", "tx", "Ts", "ns", "ats", "ls", "TS", "tips", "args", "bs", "stats", "cs", "ss", "mods", "ics", "cons", "ops", "ks", "gs", "ds", "t", "qs", "tests", "outs", "ents", "arts", "css", "trans", "acs", "fs", "ta", "ys", "ms", "ims", "uts", "tp", "tt", "rs", "times", "ps", "tc"], "is_write": ["ispubwrite", "as_write", "as_control", "ispubcontrol", "ispubexternal", "is_writer", "is_external", "is\u00b7control", "as_external", "ispubwriting", "is\u00b7writing", "is_written", "is_control", "as_writer", "is\u00b7external", "is\u00b7write", "as_writing", "is_writing", "as_written"], "size": ["address", "name", "time", "SIZE", "position", "large", "count", "fee", "parent", "shape", "value", "security", "grow", "city", "password", "style", "si", "sync", " sizes", "loc", "unit", "speed", "capacity", "offset", "izer", "content", "money", "grade", "small", "Size", "number", "six", "len", "huge", "code", "low", "units", "second", "storage", "sized", "bytes", "timeout", "empty", "izes", "scale", "settings", "zero", "c", "ize", "form", "general", "needed"]}}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n", "idx": 5931, "substitutes": {"bs": ["bas", "base", "bp", "lb", "http", "bt", "bg", "b", "bm", "bi", "BS", "fb", "bes", "bus", "ns", "ls", "iss", "bb", "cs", "ss", "us", "vs", "sb", "ops", "banks", "bis", "ds", "bc", "ab", "ba", "blocks", "gb", "fs", "sa", "bos", "bid", "ps", "bay", "pb", "rs", "bn", "cas", "bh"], "attached_aio_context": ["attached_aios_context", "attached_aios_channel", "attached_aio2config", "attached_aios_ctx", "attached_aio2ctx", "attached_aios_config", "attached_aio_channel", "attached_aio2context", "attached_aio_connection", "attached_aio_address", "attached_aio_config", "attached_aios_connection", "attached_aio_ctx", "attached_aios_address", "attached_aio2channel"], "detach_aio_context": ["detach_aio2resource", "detach_aio_center", "detach_aio_resource", "detach_aios_resource", "detach_aios_config", "detach_aios_center", "detach_aio_config", "detach_aio2ctx", "detach_aio2context", "detach_aios_ctx", "detach_aio_ctx", "detach_aios_connection", "detach_aio_connection", "detach_aios_context", "detach_aio2config"], "opaque": ["opula", " opula", "ocaque", "oconymous", "copac", "oponymous", "ophole", "operaques", "Opaque", "operonymous", "Opacho", "cophole", "ocacity", "Opaques", "operac", "operaque", "opac", " ophole", "operhole", " oponymous", "Opacity", " opacity", " opac", "ocula", "opacho", "opaques", "operacity", "copaque", "opacity", "operacho", " opaques", " opacho", "operula", "copacity"], "ban": ["base", "stat", "fen", "gate", "anc", "kin", "ork", "pan", "ann", "bin", "block", "author", "anan", "pin", "pa", "wan", "anon", "lan", "bug", "cat", "card", "tag", "ga", "kan", "bat", "AN", "bon", "man", "han", "native", "an", "con", "auth", "comment", "Ban", "scan", "fn", "go", "ticket", "bridge", "fa", "ang", "span", "batch", "un", "ana", "don", "bank", "fan", "iban", "ver", "can", "rule", "bid", "plan", "bo", "bay", "bn", "cas", "gan", "feature"], "ban_next": ["ban_first", " ban2last", "ban2next", "ban_handle", "ban_last", " ban_last", "bn_next", "bn_prev", "bn_sec", "bn_handle", " ban_first", "ban2last", "ban_sec", "ban_prev", " ban2next", "ban2first", " ban2first"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n", "idx": 5962, "substitutes": {"s": ["sets", "sf", "sec", "v", "is", "S", "sg", "session", "i", "sync", "sys", "ses", "services", "m", "support", "f", "ns", "service", "cs", "conf", "e", "sb", "gs", "secondary", "t", "storage", "ds", "ctx", "p", "south", "settings", "h", "sv", "fs", "c", "g", "ssl", "scl", "es", "app", "ps", "js"], "val": ["base", "stat", "serv", "reg", "el", "mem", "al", "v", "value", "pre", "expr", "data", "x", "b", "enc", "i", "Val", "pt", "loc", "buf", "valid", "vals", "cal", "tx", "f", "VAL", "sl", "d", "def", "u", "all", "arr", "err", "exec", "seq", "p", "eval", "prop", "xxx", "ind", "sel", "util", "ref", "test", "grad"], "rlow": [" rhigh", "rhigh", "Rhigh", "Rflow", "rchigh", " rrow", "dLow", " rflow", "Rrow", "dhigh", " rLow", "drow", "RLow", "rflow", "Rlow", "dlow", "rclow", "rcLow", "rrow", "rLow", "rcflow"], "tmp": ["pot", "cp", "cmp", "buff", "v", "qq", "beta", "rb", "vt", "tem", "b", "kk", "data", "slice", "cro", "buf", "fake", "wb", "db", "mp", "stuff", "obj", "tab", "bb", "py", "tc", "np", "TB", "img", "sb", "storage", "t", "ctx", "fp", "jp", "result", "p", "temp", "amp", "pty", "emp", "ptr", "xxx", "pointer", "ppa", "txt", "fd", "api", "tp", "tt", "sample", "cache", "pb", "app", "cpp", "test", "Temp", "copy"], "tmp2": [" tmp0", "temp2", "bag2", "tmp4", "vt0", "emp2", " tmp4", "vt1", "tmp1", "temp0", " tmpTwo", "vt2", "txtTwo", "mp2", "emp52", "temp4", "bagTwo", " tmp52", "bag4", "emp1", "tmp52", "emp4", "tmp0", " tmp1", "tmpTwo", "temp52", "mp1", "txt2", "temp1", "mp4", "txt4"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963, "substitutes": {"dev": ["ch", "hw", "mem", "v", "md", "rad", "pu", "pro", "di", "Dev", "block", "device", "bug", "data", "home", "ad", "info", "dem", "der", "valid", "gu", "bus", "f", "d", "ve", "mod", "server", "dist", "conf", "ev", "def", "DEV", "prom", "w", "cam", "error", "driver", "dc", "lib", "comment", "go", "exec", "self", "devices", "pub", "temp", "serial", "this", "fail", "pos", "ver", "du", "g", "off", "gd", "api", "engine", "cache", "app", "loader", "img", "grad", "conn", "diff", "google"], "bmdma_base": ["bmdma__base", "bmdma_bin", "bmdta_base", "bmdda_server", "bmdma2bin", "bmdta__base", "bmdma2Base", "bmdma2base", "bmdta__area", "bmdma_area", "bmdma2server", "bmdda_bin", "bmdta_ridge", "bmdta__bas", "bmdta_bas", "bmdma__bas", "bmdda_base", "bmdda_Base", "bmdma_bas", "bmdma_ridge", "bmdta__ridge", "bmdma__area", "bmdta_area", "bmdma__ridge", "bmdma_server", "bmdma_Base"], "ide_base": ["idexBase", "ideenbased", "IDE_source", "ideambase", "IDE_format", "IDExname", "idekbased", "ideappformat", "ided_based", "ideghome", "ideappsource", "ide_Base", "ide_system", "ince_based", "ideambasic", "ideknormal", "ideembase", "ide__based", "idedkbased", "ideemsource", "ide_format", "ideenbase", "ideappsystem", "idedkstable", "IDExbase", "ideappbase", "idexbase", "ideccstable", "ince__base", "ideccnormal", "ided_normal", "ide_home", "IDEkformat", "idegbase", "ide__la", "remote_basic", "ideksource", "ideksystem", "ide_based", "remote_prefix", "ince_la", "ide_stable", "IDEksource", "IDE_base", "ide___la", "idegroot", "ide_basic", "ide__name", "ideamhome", "ince__name", "idekstable", "idedknormal", "ide___based", "idexroot", "idexname", "IDExBase", "IDE_system", "ideenstable", "idegbasic", "ideccbase", "ide_normal", "remote_base", "IDE_name", "IDEkbase", "remote_home", "ideennormal", "ide_name", "IDE_Base", "ide_la", "ince_base", "idegname", "ideccbased", "ideamprefix", "IDE_root", "idedkbase", "IDEksystem", "ide_root", "ince__based", "ideemsystem", "ide___name", "ide_prefix", "ide__base", "ince__la", "ide_source", "idekbase", "ince_name", "ided_base", "idegprefix", "idegBase", "ide___base", "ideemformat", "IDExroot", "ided_stable", "idekformat"], "status": ["serv", "flag", "progress", "ex", "data", "style", "unit", "speed", "state", "weight", "magic", "active", "service", "code", "buffer", "error", "json", "bc", "err", "pass", "stage", "sp", "g", "notice", "resp", "current", "index", "cas", "msg", "name", "id", "count", "spec", "update", "sum", "info", "valid", "html", "standard", "comment", "sign", "str", "score", "ity", "fail", "stat", "note", "security", "rc", "sync", "debug", "num", "version", "cli", "reason", "action", "source", "css", "pos", "gen", "ssl", "api", "cache", "login", "gc", "complete", "session", "si", "wait", "stats", "full", "su", "result", "seq", "Status", "success", "date", "flags", "js"], "buf": ["base", "cmp", "buff", "vec", "lb", "mem", "block", "box", "la", "rb", "config", "b", "data", "rc", "home", "dest", "queue", "uc", "loc", "fb", "wb", "uf", "f", "lit", "fl", "buffer", "len", "que", "bag", "port", "cmd", "ctx", "bc", "cb", "coord", "fp", "filename", "feat", "result", "seq", "pool", "output", "alloc", "bh", "bf", "fd", "cf", "br", "cv", "bl", "cache", "fi", "text", "aux", "src", "cas", "lim", "pkg", "ff"], "cmpbuf": ["ackbuf", "seqbuffer", "diffbuffer", "seqbuff", "ctxbuff", "ctxfile", "diffbuf", "tmpbuff", "ackbuff", "cmpfile", "compbuff", "procbuff", "cmpimg", "ctxcb", "cmpbuff", "procbuf", "tmpbuf", "cmpbuffer", "compcb", "procimg", "ctxbuf", "ctxbuffer", "compimg", "cmpcb", "diffbuff", "tmpbuffer", "proccb", "ctximg", "seqbuf", "compbuf", "ackfile", "ackbuffer"], "prdt": ["sprdist", "frdat", "prt", "grdat", " prkt", "prds", "grtz", "PRt", "brdh", "brdt", "grdt", "strdh", "strtz", "grdl", "strdt", "protd", "revdt", "trdl", "revtd", "brkt", "prdat", "brdl", "brdm", "krdt", "krdm", "PRtd", "grdc", "prdh", "prkt", " prtd", " prdat", "prtd", "frdc", "pulldt", " prqt", "prodc", " prdh", "prodm", "prot", "prdm", "PRdt", "krdc", "brqt", " prds", "trqt", "revqt", "frdh", "prdl", "krdh", "frdl", "prtz", " prdc", "PRds", "frqt", "pulldh", "frdt", "prqt", " prt", "pullqt", "frrt", "sprtd", "prods", "prodt", " prdl", "strdl", "prdc", " prrt", "revdist", "sprqt", "pulldl", "brdc", "brtz", "prrt", " prdist", "prdist", "prodh", "grrt", "trkt", "trdt", "grdh", "sprdt"]}}
{"project": "FFmpeg", "commit_id": "33f58c3616d2870d3861da68217ef9d05cc5047a", "target": 1, "func": "static int idcin_read_packet(AVFormatContext *s,\n\n                             AVPacket *pkt)\n\n{\n\n    int ret;\n\n    unsigned int command;\n\n    unsigned int chunk_size;\n\n    IdcinDemuxContext *idcin = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n    int palette_scale;\n\n    unsigned char r, g, b;\n\n    unsigned char palette_buffer[768];\n\n    uint32_t palette[256];\n\n\n\n    if (s->pb->eof_reached)\n\n        return AVERROR(EIO);\n\n\n\n    if (idcin->next_chunk_is_video) {\n\n        command = avio_rl32(pb);\n\n        if (command == 2) {\n\n            return AVERROR(EIO);\n\n        } else if (command == 1) {\n\n            /* trigger a palette change */\n\n            if (avio_read(pb, palette_buffer, 768) != 768)\n\n                return AVERROR(EIO);\n\n            /* scale the palette as necessary */\n\n            palette_scale = 2;\n\n            for (i = 0; i < 768; i++)\n\n                if (palette_buffer[i] > 63) {\n\n                    palette_scale = 0;\n\n                    break;\n\n\n\n\n            for (i = 0; i < 256; i++) {\n\n                r = palette_buffer[i * 3    ] << palette_scale;\n\n                g = palette_buffer[i * 3 + 1] << palette_scale;\n\n                b = palette_buffer[i * 3 + 2] << palette_scale;\n\n                palette[i] = (r << 16) | (g << 8) | (b);\n\n\n\n\n\n        chunk_size = avio_rl32(pb);\n\n\n\n\n\n        /* skip the number of decoded bytes (always equal to width * height) */\n\n        avio_skip(pb, 4);\n\n        chunk_size -= 4;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (command == 1) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n            memcpy(pal, palette, AVPALETTE_SIZE);\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n        pkt->stream_index = idcin->video_stream_index;\n\n        pkt->duration     = 1;\n\n    } else {\n\n        /* send out the audio chunk */\n\n        if (idcin->current_audio_chunk)\n\n            chunk_size = idcin->audio_chunk_size2;\n\n        else\n\n            chunk_size = idcin->audio_chunk_size1;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        pkt->stream_index = idcin->audio_stream_index;\n\n        pkt->duration     = chunk_size / idcin->block_align;\n\n\n\n        idcin->current_audio_chunk ^= 1;\n\n\n\n\n    if (idcin->audio_present)\n\n        idcin->next_chunk_is_video ^= 1;\n\n\n\n    return ret;\n", "idx": 5965, "substitutes": {"s": ["sets", "sf", "S", "spec", "sg", "si", "sync", "ses", "services", "support", "sk", "f", "ns", "stats", "ls", "sl", "sci", "service", "cs", "ss", "sports", "conf", "sis", "submit", "sc", "sb", "gs", "ks", "se", "secondary", "bis", "t", "qs", "ds", "ctx", "ts", "su", "p", "south", "settings", "aws", "sv", "sa", "c", "ssl", "sq", "scl", "sym", "rs"], "pkt": ["Pkt", "plkt", "pct", "bkt", "btk", " pnt", " peth", "hkg", "Ptk", "pldt", "apkt", "Pnt", " pdt", "Packet", "apacket", "wacket", "apeth", " ptk", "wnt", "apkg", " pct", "wkt", "hacket", "backet", "wct", "peth", "Pct", "hnt", "placket", "Pkg", "Peth", "bkg", "hct", " pkg", "hkt", "pdt", "ptk", "pnt", "packet", "plct", "Pdt", "pkg", " packet"], "ret": ["base", "flag", "reg", "reset", "rt", "al", "sr", "alt", "open", "value", "nt", "session", "get", "rot", "val", "last", "rc", "data", "final", "format", "bit", "cat", "info", "reply", "real", "rf", "lag", "repl", "db", "lit", "att", "url", "arg", "res", "active", "match", "def", "buffer", "len", "code", "mt", "det", "error", "out", "arr", "RET", "after", "pass", "err", "str", "rev", "result", "end", "Ret", "opt", "run", "ft", "re", "fun", "back", "hash", "resp", "success", "ref", "rep", "rets", "msg"], "command": ["function", "option", "communication", "md", "method", "count", "comm", "total", "qq", "channel", "send", "session", "config", "sudo", "bug", "force", "last", "final", "password", "format", "pattern", "info", "reply", "image", "Command", "lag", "resource", "argument", "event", "child", "media", "length", "magic", "active", "service", "which", "conf", "buffer", "action", "error", "comment", "random", "connection", "message", "three", "power", "directory", "cmd", "timeout", "response", "input", "batch", "operation", "direction", "request", "attribute", "slave", "class", "type", "handler", "clear", "model", "move", "git", "group", "mode"], "chunk_size": ["chunks_sized", "chet_size", "chunknsize", "chacket_size", "chacket_length", "chatchnpos", "chunkingsize", "chunks_size", "chunknlength", "chunk_address", "chunk_sized", "chatchnaddress", "chunk8count", "chunk64size", "chunk_data", "chunknpos", "chunk64ize", "chunks_scale", "chunkingize", "chunk__pos", "chunk64cache", "chatch_length", "chunkinglength", "chunk_scale", "chunk_length", "chacket_count", "chunk_cache", "chunk8ize", "chunk8length", "chunkedscale", "chunk_mode", "chunk__size", "chatchnlength", "chatchnsize", "chunk__address", "chet_mode", "chunks_data", "chatch_pos", "chunk8size", "chunk_ize", "chunkeddata", "chunkedsized", "chatch_size", "chunk_pos", "chacket_ize", "chunk__length", "chunk64mode", "chet_ize", "chet_cache", "chunkedsize", "chunkingcount", "chunk_count", "chunknaddress", "chatch_address"], "idcin": ["adcs", " idcu", "midcn", "idvin", "advin", "dcin", "idcit", " idxc", "midvin", "adxc", "itvin", "idci", "bidvin", "dcit", "bidcs", "idcu", "midcin", "idcn", "adcn", "itcit", "invin", "itcin", "idcs", "bidcn", "incin", "dci", "dvin", "inxc", "adcit", "idxc", "bidcin", "itci", "midcs", " idvin", "adci", "adcu", "incu", "adcin"], "pb": ["abc", "cp", "plugin", "bp", "lb", "buff", "hub", "pit", "platform", "vm", "pa", "rb", "pd", "pp", "bps", "raf", "bm", "typ", "wp", "lp", "pt", "fb", "wb", "db", "pm", "pg", "usb", "prot", "phrase", "pc", "bb", "xb", "np", "eb", "buffer", "dp", "acl", "kt", "sb", "bot", "ctx", "bc", "PB", "fp", "jp", "cb", "nb", "ab", "p", "summary", "vp", "prop", "primary", "ppa", "ub", "utils", "bf", "proc", "txt", "api", "tp", "fc", "pl", "rob", "cpp", "bh", "pkg"], "i": ["base", "gi", "ti", "diff", "v", "id", "I", "is", "di", "ci", "ji", "ni", "x", "io", "si", "xi", "ri", "slice", "info", "bi", "m", "image", "qi", "in", "ix", "l", "key", "f", "pi", "yi", "phi", "j", "ii", "d", "iu", "it", "ai", "init", "my", "u", "e", "uri", "n", "field", "multi", "mi", "ini", "ie", "p", "source", "mini", "z", "eni", "hi", "c", "ip", "y", "type", "api", "lc", "li", "inner", "fi", "index", "zi", "ui"], "palette_scale": ["palette_scope", "paletteersize", "pallete_scale", "pallette_scale", "pallette_size", "palette__fill", "palette\u00b7size", "pallete_size", "pallette_fill", "palettes_size", "palette_fill", "palettes_scope", "palette_cale", "palette_rate", "pallete_rate", "paletteerscale", "paletteertotal", "palettes_scale", "palette\u00b7scale", "palettes_scan", "palette\u00b7span", "palette\u00b7scan", "pallete_total", "palettes_span", "palette_scan", "pallette_min", "palette_size", "palette__min", "palette_margin", "palette\u00b7unit", "palettes_unit", "palette\u00b7cale", "paletteerrate", "pallete_margin", "palette__scale", "palette_unit", "palette_min", "palette_span", "palette__size", "palette_total", "palettes_cale"], "r": ["dr", "gr", "fr", "er", "vr", "sr", "reg", "v", "rr", "a", "rb", "x", "rc", "m", "l", "G", "rh", "ru", "f", "ga", "d", "nr", "u", "e", "w", "rg", "k", "n", "err", "p", "h", "R", "re", "mr", "c", "range", "ro", "hr", "br", "rs"], "g": ["gi", "gr", "gp", "fg", "gc", "ig", "reg", "vg", "gm", "v", "sg", "bg", "x", "m", "l", "G", "ga", "pg", "f", "gin", "d", "q", "gre", "u", "mg", "e", "w", "gs", "rg", "gam", "k", "n", "p", "gb", "ge", "gen", "gh", "c", "y", "gg", "gn", "group"], "b": ["o", "lb", "ib", "v", "a", "bd", "rb", "x", "ob", "fb", "l", "wb", "db", "f", "abb", "d", "bs", "xb", "bb", "u", "eb", "e", "sb", "w", "t", "bot", "n", "k", "ab", "B", "p", "mb", "be", "h", "z", "c", "y", "bo", "bh", "bar"], "palette_buffer": ["palette__buffer", "paletteOdevice", "paletteedpause", "paletteingreader", "palizeablequeue", "palette_device", "palette_slice", "paletteingbatch", "palotationObuffer", "paletteObuffer", "paletteedlist", "pallette_buffer", "palizeablebatch", "paletteablereader", "palette2buffer", "pallette_queue", "palotationOlist", "palettealbuffer", "pallette2queue", "paletteablebuffer", "palette__surface", "palette_surface", "palette_buff", "palette2buf", "palotation_buffer", "palette_pause", "paletteingbuffer", "palette_buf", "pallette2header", "palotationOdevice", "paletteablebatch", "pallette2buff", "paletteedbuffer", "palette__buff", "palettes_queue", "palotation_pause", "pallette2buffer", "paletteOlist", "palettes_slice", "palette_list", "palizeablebuffer", "paletteablequeue", "paletteOpause", "palettealqueue", "palizeablereader", "palotation_device", "palette__buf", "palette2buff", "palette2surface", "palette2header", "palette_reader", "palettes_buffer", "palettealstore", "palotation_list", "palettes_buff", "palette_header", "palotationOpause", "palettes_surface", "palize_buffer", "palettes_buf", "palette2queue", "paletteingqueue", "palette_queue", "palize_queue", "pallette_buff", "palette_batch", "palize_reader", "palette_store", "palize_batch", "paletteeddevice", "palettealslice", "pallette_header", "palettes_store"], "palette": ["alettes", "Palettes", "Palble", "pallette", " palettes", "calette", "alet", "Palet", "paletta", "caletta", "Palenge", "aletta", "alble", "plenge", "plet", "palenge", "palble", "palet", "pilletta", "pillette", " palble", "calettes", "pilllette", "Palette", "plettes", "alette", " palenge", "allette", "plette", "pillettes", " palet", "callette", "palettes"], "pal": ["fat", "nl", "pid", "ch", "pan", "bin", "el", "local", "al", "chi", "pat", "plug", "stal", "socket", "real", "lab", "bel", "pel", "cal", "sk", "Pal", "ijk", "bat", "att", "sil", "py", "pac", "tab", "align", "conf", "ph", "cell", "apple", "pad", "ab", "ask", "ill", "ne", "isal", "wal", "boot", "nav", "ind", "panel", "chal", "li", "skin", "bl", "pl", "cache", "app", "opal", "cel"]}}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,\n\n                                        const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                        const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                        const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                        const uint16_t *abuf1, uint8_t *dest,\n\n                                        int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    x86_reg uv_off = c->uv_off << 1;\n\n\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2RGB(%%REGBP, %5, %6)\n\n        \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n        \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n        \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n        \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n        WRITERGB15(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither), \"m\"(uv_off)\n\n    );\n\n}\n", "idx": 5981, "substitutes": {"c": ["oc", "v", "cur", "a", "s", "ci", "config", "b", "cy", "enc", "C", "m", "l", "f", "call", "d", "ce", "cs", "u", "conf", "e", "con", "mc", "w", "t", "dc", "n", "ctx", "exec", "cu", "self", "cb", "p", "ctrl", "ca", "ec", "h", "this", "z", "cit", "g", "ct", "lc", "cf", "cv", "ac", "cache", "r", "cm"], "buf0": ["uf10", "uf2", "port3", "buf00", "buf3", "uf3", "uf00", "buff3", "buff2", "buff00", "uf1", "buf2", " buf10", "buff1", "buff0", "port0", "port00", "buff10", "uf0", "port2", "buf10"], "buf1": [" buf2", "uf2", "seq1", "seq2", "cvb", "buf01", "cv1", "cv0", "uf1", "buf2", " buf01", " bufb", "seq0", "ufb", "cv2", "bufb", "uf0", "seq01", "uf01"], "ubuf0": ["ubbuf0", "ubef0", "ubufk", "ubuc3", "ubbuf1", "abbuf1", "abufk", "ubbuff0", "abuf2", "abuf00", "ubbuf3", "ubuf00", "ubef1", "ubbufk", "abbuf2", "ubbuf00", "ubbuff1", "ubbuff3", "ubbuff2", "ubbuf2", "abbufk", "ubbuff00", "ubuf2", "abbuf3", "ubuf3", "ubefk", "ubbuffk", "abuf3", "ubuc00", "ubuc1", "abbuf0", "ubuc0", "abbuf00", "ubef2"], "ubuf1": ["ubbuf0", "ubef0", "ubuff0", "ubuffn", "ubbuf1", "abbuf1", "ubbuff0", "abuf2", "abufn", "ubef1", "abbuf2", "abbufn", "ubbufn", "ubbuff1", "ubbuff2", "ubbuf2", "ubuf2", "ubufn", "ubbuffn", "ubefn", "abbuf0", "ubuff1", "ubef2"], "vbuf0": ["vmem2", "bufn", "bbuf1", "vuf1", "vmemn", "vbuff0", "vbuf2", "bbuf2", "vufn", "bbuf0", "vuf2", "vbuff2", "buf2", "vbuff1", "vmem1", "vuf0", "bbufn", "vmem0", "vbufn", "vbuffn"], "vbuf1": ["vab1", "bbuf1", "vufb", "vuf1", "bbufb", "vmemon", "vabon", "bbuf0", "vbufon", "vufon", "vab0", "bbufon", "vbufb", "vmemb", "vmem1", "bufon", "vuf0", "vabb", "vmem0", "bufb"], "abuf0": ["abuf4", "abaf0", "bbuf1", "abbuf1", "bbuf4", "abuf2", "abaf4", "bbuf2", "abbuf2", "buf4", "bbuf0", "abf2", "abbuf4", "buf2", "abf4", "abaf1", "abbuf0", "abaf2", "abf1", "abf0"], "abuf1": ["abbuff0", "abucone", "bbuf11", "bbuf1", "bufone", "abuc1", "abbuf1", "abbuffone", "bbuf0", "abuf11", "abbuff1", "abufone", "abbufone", "abbuf11", "buf11", "abbuff11", "abbuf0", "abuc0", "bbufone", "abuc11"], "dest": ["origin", "mem", "di", "shape", "neg", "home", "loc", "route", "wb", "rest", "attr", "dist", "ctr", "dir", "cont", "target", "dev", "dc", "Dest", "feat", "coord", "source", "opt", "trans", "prop", "gen", "orig", "dep", "transform", "comb", "desc", "trip", "src", "img", "grad", "norm", "dim", "shift"], "dstW": [" dstw", "dconstW", "dscw", "dconstw", "dstB", "dstw", "dconstB", " dblw", "dstA", "dblW", "dblB", "dscB", " dstA", " dblA", "dscW", " dstB", "dblw", " dblW", "dblA", " dblB", "dconstA", "dscA"], "yalpha": ["syalpha", " ybeta", " ylambda", "syAlpha", "xAlpha", "ylambda", "xbeta", "sylambda", "sybeta", " yAlpha", "xalpha", "ybeta", "yAlpha", "xlambda"], "uvalpha": ["uvalappa", "unvalpa", "unvalpha", "uvaluepha", "ubalappa", "unvalueappa", "unvaluepa", "uavalpa", "ubalpha", "uvalueappa", "uvallambda", "uvaluelambda", "unvallambda", "ubalpa", "uvalpa", "uavalappa", "uballambda", "uavallambda", "uvaluepa", "unvaluelambda", "unvaluepha", "uavalpha", "unvalappa"], "y": ["yy", "o", "Y", "b", "x", "i", "cy", "ya", "yi", "f", "d", "ry", "u", "ay", "e", "w", "yl", "oy", "t", "vy", "ey", "p", "ye", "h", "z", "ys", "ym"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n", "idx": 6007, "substitutes": {"s": ["r", "o", "serv", "sf", "v", "sec", "is", "S", "less", "a", "spec", "sg", "b", "si", "sync", "ses", "services", "m", "f", "ns", "server", "d", "args", "q", "service", "ss", "cs", "conf", "e", "sb", "gs", "ops", "qs", "ds", "p", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "ps", "js"], "req": ["gr", "fr", "er", "sr", "iq", "cur", "pull", "rr", "pr", "spec", "progress", "qt", "require", "op", "tr", "rf", "comp", "wa", "rh", "f", "ext", "org", "dq", "j", "call", "arg", "q", "res", "obj", "def", "e", "ar", "w", "rx", "err", "jp", "str", "fp", "cb", " request", "p", "seq", "temp", "load", "ec", "z", "mr", "request", "proc", "sq", "hr", "resp", "cf", "desc", "ref", "cache", "rs", "r", "requ", "next", "rec", "quest"]}}
{"project": "FFmpeg", "commit_id": "f7a02d5d694bcef993b0229c9e57f22421fed637", "target": 0, "func": "static int output_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n\n\n    AVPacket avpkt;\n\n    if (!ist->saw_first_ts) {\n\n        ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;\n\n        ist->pts = 0;\n\n        if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {\n\n            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong\n\n        }\n\n        ist->saw_first_ts = 1;\n\n    }\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = ist->dts;\n\n    }\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6008, "substitutes": {"ist": ["isi", "dr", "est", "et", "sett", "ace", "state", "pop", "isd", "ard", "exist", "fp", "hop", "ft", "pect", "ht", "ess", "ast", "nd", "pick", "irst", "st", "irc", "gest", "nt", "osi", "ism", "list", "edit", "wp", "art", "pt", "ird", "at", "lect", "mot", "it", "dist", "mt", "ait", "oss", "work", "old", "sta", "iste", "ide", "ld", "isc", "end", "nant", "std", "istor", "act", "er", "rt", "esp", "op", "dit", "ust", "ad", "post", "ext", "att", "adder", "wd", "inst", "past", "ant", "feat", "p", "ic", "start", "ind", "IST", "tt", "set", "add", "pull", "dd", "best", "aint", "ists", "ict", "rest", "kt", "part", "asp", "erd", "artist", "xt", "ort", "ord", "alist", "empt"], "pkt": [" p\n", "cpkt", "tet", "melt", "prwk", "P\n", " pwk", "met", "bkt", "apet", "opkt", "spinch", " pnt", "opcht", "pqt", "spwk", "td", "apcht", "spqt", "cpft", "apelt", "cpacket", " pk", "praser", "pk", "princh", "tpaser", "t\n", "punt", "cpelt", "spelt", "bunt", "mft", "telt", "pwk", "npacket", "npk", "fft", "tacket", "prcht", "facket", "tqt", "apkt", "Packet", " pd", "prkt", " pft", "spkt", "tpkt", " pcht", "mwk", "tkt", "packet", "tpwk", "pelt", "mcht", "npcht", "maser", "p\n", " pet", " pqt", "spunt", "cpcht", "ipkt", "pet", "Pnt", "cpk", "Pd", "opwk", "tft", "prunt", "paser", "ipacket", "bwk", "pnt", "pinch", "fkt", "spcht", "mkt", "ipct", "npkt", "Pkt", "pft", "pct", "pd", "macket", " pelt", "pcht", "tpcht", " pct", "ipnt", "opacket", "binch", "fqt", "cpet", "Pct", "apqt", " packet"], "i": ["ti", "I", "di", "ci", "ni", "si", "io", "slice", "f", "pi", "j", "ii", "d", "iu", "it", "t", "n", "mi", "p", "h", "hi", "c", "ip", "ind", "li", "inner", "fi", "ui"], "got_output": ["got_version", " got_response", " got_out", "gotwoutput", "gotwresponse", "got2output", "got_out", "got2out", "got_response", "got2response", "lost_version", "lost_output", "gotwversion", "lost_response"], "avpkt": ["avpetsk", "compacket", "avmwk", "avprkt", "evcpkt", "varpkt", "avppt", "avlpkt", "compelt", "avapwk", "varspkt", "avopelt", "avepwk", "akpitter", "evpet", "avcpacket", "avpitter", "akpritter", "evpkt", "avpqt", "avlpet", "avtpkt", "AVcpcht", "avopacket", "compkt", "AVpcht", "varpft", "avcomput", "AVcpet", "avcpwk", "avfcht", "navpkt", "akprft", "AVpkt", "avopkt", "avcpkh", "navnpkt", "avcpet", "avfkt", "avspft", "varpdt", "avepqt", "avtpcht", "akpke", "AVpet", "avlppt", "avtpft", "avcompft", "navpdt", "evcpet", "avspitter", "svcpcht", "evpcht", "avecpqt", "avpet", "varspdt", "avsput", "avddt", "evcpcht", "avpcft", "svcpacket", "avlpcht", "avpinch", "evppt", "avcppt", "avtinch", "akprkt", "navnpelt", "avpcdt", "avspdt", "AVpinch", "avmnt", "avtpitter", "avtpke", "varspft", "evcppt", "navnpnt", "avfacket", "avnpnt", "avlpkh", "avdnt", "avpcut", "svpcht", "avtkt", "avpwk", "avecpwk", "avbpacket", "avcpinch", "avlpacket", "avmqt", "avpkh", "avapqt", "comopacket", "comopetsk", "navpnt", "avbppt", "avopdt", "avcpcht", "avnpdt", "svpacket", "avcompdt", "navpelt", "avcompkt", "avtcht", "avecpkt", "avbpkt", "competsk", "avtpet", "avpdt", "avtet", "avprke", "avecpnt", "avpelt", "AVcpinch", "AVcpkt", "akprke", "avpacket", "avtpinch", "navnpdt", "avbpcht", "avprft", "avpft", "avspke", "avbpelt", "comopkt", "akpkt", "svcpkh", "avdkt", "comopelt", "avfelt", "avbpetsk", "svcpkt", "avcpqt", "avfetsk", "avpritter", "avpnt", "avpckt", "avapnt", "avnpkt", "varput", "avspkt", "avopetsk", "avput", "avcpkt", "avepnt", "svpkt", "avapkt", "avnpelt", "avfkh", "akpft", "avopnt", "varsput", "avbpet", "avpcht", "avmkt", "avepkt", "avcpnt", "avpke", "avdelt", "svpkh"], "duration": ["sec", "id", "done", "total", "sg", "gap", "debug", "f", "wait", "d", "obj", "loop", "fe", "res", "code", "len", "err", "result", " result", "start", "gen", "fun", "g", "resp", "desc", "group"]}}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}", "idx": 6025, "substitutes": {"re": ["rer", "row", "bre", "reset", "reg", "ret", "change", "entry", "pre", "get", "com", "rc", "real", "rel", "record", "sys", "resource", "rex", "ru", "de", "ra", "RE", "server", "res", "ree", "gre", "Re", "ry", "e", "per", "se", "ren", "response", "rev", "result", "parse", "root", "run", "rule", "ro", "release", "resp", "c", "rew", "ref", "cache", "r", "rem", "rec", "replace"], "nre": ["lcre", "lre", " nRE", "Ncre", "necre", "nres", "Nre", "Nrec", " nres", "Nres", "nerec", "nRE", " ncre", "lres", " nrec", "lrec", "neRE", "ncre", "NRE", "nere", "nrec"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n", "idx": 6032, "substitutes": {"sd": ["std", "dy", "tf", "dm", "sf", "od", "diff", "md", "bd", "vd", "di", "s", "dd", "sg", "dis", "ci", "dat", " dd", "sem", "pd", "ze", "si", "dh", "sn", "ad", "ses", "eddy", "dem", "db", "nd", "sk", "sam", "dk", "d", "sl", "ls", "dist", "td", "cs", "des", "sh", "sb", "se", "sim", "dev", "ds", "df", "dc", "su", "ic", "sv", "gb", "ld", "g", "gd", "fd", "dl", "lc", "ud", "dt", "li", "SD", "cod", "ed", "zi", "hd", "dal", "cd"], "bdrv": ["Bdrk", "bstrh", "Bdrv", "bdrc", "bDrf", "bgrv", "bstrv", "bDrv", " bdriv", "byrvin", "dderk", "ddrh", "bdrf", "bDRv", "brvd", "bstrk", "brdb", "bderv", "bdrva", "bcrvs", "bsrV", "Bsrv", "ddrk", "crdw", " bDrV", "bcrva", "bderw", "brc", "brdv", "bhrva", "bhrb", "bsrv", " bdrvs", "bgrc", "bDrb", "cdrp", "Bdrc", "brdp", "bhrw", "bderiv", "BdrV", "bcrv", "bderh", "bdrh", "bstrV", "bsrk", "bgrw", "bdrk", "crdv", " bdrc", "bstrc", "brdw", "bDRb", "bhrv", "BsrV", "dderv", "bdrvin", "bDrvd", " bdrV", "crdb", " bDrvd", "bdrp", "ddrvin", " bsrvs", "bsrf", "bdriv", "dderh", "byrv", "bsrva", " bdrw", " bsrc", "bhrk", "bhrvd", "bDrV", "ddervin", "cdrb", "bdrb", " bsrva", " bDrv", "bdrvs", " bsrw", "bsrw", "bdrvd", "ddrv", "bderc", " bdrf", "bDrc", "bhrp", "bsrc", "bcrw", "bsrvs", "bDRw", "bderk", "bdrV", "Bsrc", "bsrb", "bhrV", "bhrc", "Bsrk", "bsriv", " bdrvd", "bdrw", " bDrc", "byrk", "byrh", " bsriv", " bdrb", "brv", "bgriv", "bstrvin", "cdrv", "brV", "cdrw", "bDRp", "bhrvs", " bsrv", "bdervin", " bdrva", "crdp"], "size": ["position", "shape", "password", "speed", "weight", "code", "len", "esc", "empty", "equ", "ec", "engine", "iz", "max", "conn", "mode", "name", "SIZE", "fee", "sw", "send", "config", "see", "sum", "ix", "capacity", "content", "grade", "server", "six", "sc", "sh", "zip", "sized", "ey", "ie", "scale", "z", "secure", "sq", "zen", "form", "test", "group", "address", "cess", "ect", "sec", "security", "sn", "sex", "loc", "cl", "version", "small", "Size", "cc", "e", "section", "en", "c", "desc", "set", "complete", "total", "body", "offset", "length", "se", "storage", "n", "term", "ize", "shift"], "sect": ["patch", "sub", "fat", "act", "ect", "ection", "sec", "scroll", "except", "fts", "sw", "config", "vel", "crop", "edge", "pattern", "sex", "ECT", "offset", "sections", "sector", "length", "subject", "cc", "connect", "select", "round", "six", "len", "part", "det", "section", "zip", "pass", "feat", "own", "equ", "access", "seq", "array", "ec", "ign", "qa", "ft", "ctor", "pect", "aff", "filter", "ct", "sq", "iz", "test", "form", "zen", "cross", "conn", "ff"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 6033, "substitutes": {"d": ["D", "dy", "dm", "od", "md", "bd", "ded", "dn", "dd", "dat", "dos", "pd", "dh", "ad", "dx", "dad", "db", "e", "dp", "da", "driver", "ds", "dc", "df", "xd", "t", "p", "did", "ld", "c", "ind", "fd", "gd", "dl", "dt", "cd", "dict"], "index": ["base", "address", "axis", "position", "iter", "block", "bin", "id", "count", "fee", "note", "config", "i", "info", "loc", "route", "inc", "num", "offset", "f", "url", "loop", "byte", "len", "part", "uri", "depth", "batch", "pos", "start", "level", "node", "ind", "ln", "ld", "Index", "ref", "addr", "end", "prefix"], "nb": ["uni", "base", "bp", "lb", "buff", "ib", "bin", "bd", "nn", "fee", "nob", "note", "quad", "rb", "b", "bm", "bi", "wb", "db", "abb", "bb", "split", "eb", "sb", "lib", "timeout", "bc", "cb", "batch", "gb", "kb", "aff", "node", "bf", "NB", "bn", "seed", "nd", "slot"], "leaf": ["abc", "layer", "lb", "flag", "inf", "parent", "nn", "quad", "ignore", "pattern", "children", "fff", "offset", "f", "child", "abb", " Leaf", "cc", "loop", "split", "lib", "kid", "bc", "nil", "urse", "root", "batch", "level", "node", "ld", "tree", "bf", "lv", "lc", "slot", "ref", "lf", "af"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n\n                              const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        if (check_fit_tl(args[0], 13)) {\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);\n\n        } else {\n\n            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,\n\n                           args[0] & 0x3ff, ARITH_OR);\n\n        }\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n            uint32_t old_insn = *(uint32_t *)s->code_ptr;\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            /* Make sure to preserve links during retranslation.  */\n\n            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));\n\n        } else {\n\n            /* indirect jump method */\n\n            tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0]));\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL);\n\n        }\n\n        tcg_out_nop(s);\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_call:\n\n        if (const_args[0]) {\n\n            tcg_out_calli(s, args[0]);\n\n        } else {\n\n            tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL);\n\n        }\n\n        /* delay slot */\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_br:\n\n        tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]);\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n\n        break;\n\n\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32):    \\\n\n        glue(glue(case INDEX_op_, x), _i64)\n\n\n\n    OP_32_64(ld8u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n\n        break;\n\n    OP_32_64(ld8s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n\n        break;\n\n    OP_32_64(ld16u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n\n        break;\n\n    OP_32_64(ld16s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n\n        break;\n\n    OP_32_64(st8):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STB);\n\n        break;\n\n    OP_32_64(st16):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STH);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STW);\n\n        break;\n\n    OP_32_64(add):\n\n        c = ARITH_ADD;\n\n        goto gen_arith;\n\n    OP_32_64(sub):\n\n        c = ARITH_SUB;\n\n        goto gen_arith;\n\n    OP_32_64(and):\n\n        c = ARITH_AND;\n\n        goto gen_arith;\n\n    OP_32_64(andc):\n\n        c = ARITH_ANDN;\n\n        goto gen_arith;\n\n    OP_32_64(or):\n\n        c = ARITH_OR;\n\n        goto gen_arith;\n\n    OP_32_64(orc):\n\n        c = ARITH_ORN;\n\n        goto gen_arith;\n\n    OP_32_64(xor):\n\n        c = ARITH_XOR;\n\n        goto gen_arith;\n\n    case INDEX_op_shl_i32:\n\n        c = SHIFT_SLL;\n\n    do_shift32:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        c = SHIFT_SRL;\n\n        goto do_shift32;\n\n    case INDEX_op_sar_i32:\n\n        c = SHIFT_SRA;\n\n        goto do_shift32;\n\n    case INDEX_op_mul_i32:\n\n        c = ARITH_UMUL;\n\n        goto gen_arith;\n\n\n\n    OP_32_64(neg):\n\n\tc = ARITH_SUB;\n\n\tgoto gen_arith1;\n\n    OP_32_64(not):\n\n\tc = ARITH_ORN;\n\n\tgoto gen_arith1;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);\n\n        break;\n\n    case INDEX_op_divu_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i32:\n\n        tcg_out_setcond_i32(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i32:\n\n        tcg_out_movcond_i32(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    case INDEX_op_add2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_ADDCC, ARITH_ADDX);\n\n        break;\n\n    case INDEX_op_sub2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_SUBCC, ARITH_SUBX);\n\n        break;\n\n    case INDEX_op_mulu2_i32:\n\n        c = ARITH_UMUL;\n\n        goto do_mul2;\n\n    case INDEX_op_muls2_i32:\n\n        c = ARITH_SMUL;\n\n    do_mul2:\n\n        /* The 32-bit multiply insns produce a full 64-bit result.  If the\n\n           destination register can hold it, we can avoid the slower RDY.  */\n\n        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c);\n\n        if (SPARC64 || args[0] <= TCG_REG_O7) {\n\n            tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX);\n\n        } else {\n\n            tcg_out_rdy(s, args[1]);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld_i32:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], false);\n\n        break;\n\n    case INDEX_op_qemu_ld_i64:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], true);\n\n        break;\n\n    case INDEX_op_qemu_st_i32:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n    case INDEX_op_qemu_st_i64:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STX);\n\n        break;\n\n    case INDEX_op_shl_i64:\n\n        c = SHIFT_SLLX;\n\n    do_shift64:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        c = SHIFT_SRLX;\n\n        goto do_shift64;\n\n    case INDEX_op_sar_i64:\n\n        c = SHIFT_SRAX;\n\n        goto do_shift64;\n\n    case INDEX_op_mul_i64:\n\n        c = ARITH_MULX;\n\n        goto gen_arith;\n\n    case INDEX_op_div_i64:\n\n        c = ARITH_SDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_divu_i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_ext32s_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        break;\n\n    case INDEX_op_trunc_shr_i32:\n\n        if (args[2] == 0) {\n\n            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i64:\n\n        tcg_out_movcond_i64(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 6043, "substitutes": {"s": ["ches", "sf", "local", "S", "a", "b", "i", "private", "f", "d", "service", "hs", "conf", "w", "self", "h", "g", "sym", "sets", "sites", "is", "spec", "services", "its", "states", "native", "ds", "ts", "south", "fs", "sq", "your", "site", "rs", "groups", "stat", "sg", "sync", "ses", "ions", "cs", "u", "e", "an", "sb", "ks", "en", "secondary", "t", "qs", "p", "os", "ssl", "r", "ps", "o", "v", "http", "scope", "session", "si", "sys", "m", "l", "xs", "client", "ns", "stats", "us", "ss", "uns", "gs", "se", "n", "su", "this", "es", "js"], "opc": ["ipct", "iopci", "ipc", "Ope", "iopc", " opci", "optct", "Opct", " opnc", "optf", "opnc", "operf", "optc", "opere", "iopnc", "ipci", "ipnc", "operct", "opct", "operc", "Opc", "opte", "opci", "ope", "iopct", "Opf", " opct", "opf"], "args": ["limits", "arms", "features", "atts", "x", "grades", "data", "ants", "parts", "arg", "ay", "w", "arr", "empty", "pres", "aws", "members", "changes", "g", "ams", "ass", "points", "axis", "is", "spec", "config", "Args", "ix", "gas", "uments", "ds", "ts", "Arg", "mm", "ms", "lines", "ras", "size", "groups", "as", "days", "sec", "ins", "ages", "py", "cs", "fields", "ks", "headers", "p", "ims", "ids", "ig", " arg", "v", "alls", "words", "bug", "dates", "enc", "m", "xs", "argument", "ns", "call", "stats", "init", "res", "gs", "result", "kw", "ys", "items", "params", "flags", "js"], "const_args": ["const_parts", "param_args", "param_parts", " const_Args", "const_keys", "const_Args", "param_bits", "const_bits", "const_flags", "param_keys", " const_flags"], "c": ["unc", "a", "ci", "b", "nc", "i", "C", "l", "f", " rc", "pc", "cs", "e", "dc", "n", "ctx", "cu", "p", "h", "lc", "fc", "ac", "r", "end", "xc"]}}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    EightSvxContext *esc = avctx->priv_data;\n\n    int n, out_data_size;\n\n    int ch, ret;\n\n    uint8_t *src;\n\n\n\n    /* decode and interleave the first packet */\n\n    if (!esc->samples && avpkt) {\n\n        int packet_size = avpkt->size;\n\n\n\n        if (packet_size % avctx->channels) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");\n\n            if (packet_size < avctx->channels)\n\n                return packet_size;\n\n            packet_size -= packet_size % avctx->channels;\n\n        }\n\n        esc->samples_size = !esc->table ?\n\n            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;\n\n        if (!(esc->samples = av_malloc(esc->samples_size)))\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* decompress */\n\n        if (esc->table) {\n\n            const uint8_t *buf = avpkt->data;\n\n            uint8_t *dst;\n\n            int buf_size = avpkt->size;\n\n            int i, n = esc->samples_size;\n\n\n\n            if (buf_size < 2) {\n\n                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            /* the uncompressed starting value is contained in the first byte */\n\n            dst = esc->samples;\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *(dst++) = buf[0]+128;\n\n                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);\n\n                buf += buf_size / avctx->channels;\n\n                dst += n / avctx->channels - 1;\n\n            }\n\n        } else {\n\n            raw_decode(esc->samples, avpkt->data, esc->samples_size);\n\n        }\n\n    }\n\n\n\n    /* get output buffer */\n\n    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n\n    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;\n\n    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = esc->frame;\n\n\n\n    out_data_size = esc->frame.nb_samples;\n\n    for (ch = 0; ch<avctx->channels; ch++) {\n\n        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;\n\n        memcpy(esc->frame.data[ch], src, out_data_size);\n\n    }\n\n    out_data_size *= avctx->channels;\n\n    esc->samples_idx += out_data_size;\n\n\n\n    return esc->table ?\n\n        (avctx->frame_number == 0)*2 + out_data_size / 2 :\n\n        out_data_size;\n\n}\n", "idx": 6063, "substitutes": {"avctx": ["ajconfig", "avecb", "avalhw", "avalctrl", "versci", "avalconfig", "ajlc", "verpkg", "alcb", " avctrl", "evcontext", "avalxc", " avcb", "ajcp", "alctx", "navcontext", "afxc", "avcb", "aveconfig", "afctx", "afclient", "Avcmp", "avalcu", "avclient", "vertx", "ajctx", "navctx", "avecup", "avutils", "afwcs", "avcli", " avcontext", "evcmp", "avcmd", "evcf", "avhw", "afloc", "afcmp", "avcmp", "ajutils", "ajcmd", "navcu", "avalctx", "avxc", "aveconn", "avewcs", "Avctx", "avecontext", "afcf", "avlc", "avalsci", "avctrl", "AVcu", "avexc", "ajwcs", " avcli", "avecu", "avelc", "avalcontext", "afcli", "afhw", "aveutils", "varcli", "verconfig", " avxc", "navconfig", "aflc", "ajclient", "afctl", "avectrl", "vercontext", "avcu", "avconfig", "AVcontext", "afsci", "ajpkg", "afcmd", "avecp", "navcf", "varctl", "avcontext", "afpkg", "Avconfig", "avalcp", "ajctrl", "avsci", "avecmd", "AVutils", "avalutils", "avloc", "alxc", "avconn", "ajconn", "evctx", "avctl", "alctrl", "avectx", "avalloc", "verclient", "avetx", "AVctx", "avalcmp", "afutils", "avcf", "verhw", "varcontext", "aftx", "avecf", "avtx", " avloc", "avcp", "Avcontext", "verctx", "ajcup", "avwcs", " avctl", "avcup", "afconn", "avpkg", "afcontext", "afconfig", "avalcup", "ajcontext", "varctx", "avecmp", "afcu", "navconn"], "data": ["address", "bin", "block", "a", "parent", "dat", "channel", "device", "value", "config", "rc", "slice", "final", "ad", "module", "queue", "body", "image", "in", "window", "results", "content", "media", "call", "d", "length", "DATA", "def", "code", "buffer", "da", "ata", "Data", "after", "empty", "bytes", "response", "devices", "result", "input", "batch", "reader", "start", "memory", "read", "video", "next", "cache", "index", "addr", "ui", "size"], "got_frame_ptr": ["got_fram_pointer", "got_fram_buffer", "got_frame_buffer", "got_fram_alloc", "got_frame_pointer", "got_fram_ptr", "got_frame_alloc"], "avpkt": ["avfeth", "afcke", "afckt", "avwacket", "avlpkt", "avlptch", " avpacket", "avmect", "avPkt", "AVptch", "avcpacket", "afpect", "afpacket", "avptch", "AVpptch", "avcpck", "avpck", "AVppiece", "avfcht", "avPacket", "AVpkt", "avopkt", "avfkt", "avsptch", "avspiece", "avefpeth", "avwpkt", "avnpect", "avnpck", "avspct", "avefpacket", "affkt", " avpbnt", " avpkh", "avppct", "avckt", "avmke", "avpect", "avcke", "avlpcht", "avfpacket", "avfnt", "avPnt", "avcct", " avlpcht", "avmck", "AVppkt", " avlpkt", "afpnt", "avfacket", "avwptch", "avlpkh", " avlpkh", "avfck", "avcect", "avlpiece", " avpeth", "avoptch", "avefpkt", "avpct", "avppiece", "avpbtch", "avfpct", "avpiece", "avppkt", "avfpeth", "avepacket", "avlpacket", "avefpct", "avpkh", "avpke", "avpbkt", "avceth", "avPck", "avepct", "avpbeth", " avpbkt", "avcck", " avlpacket", "avwkt", "avpbnt", "avcacket", "avwpnt", "avfpkt", "avwcht", "AVpct", "affnt", "avpacket", "afcect", "avepeth", " avptch", "AVppct", "avlpct", " avpbtch", "avopeth", "avpnt", "avnpkt", "afcck", "afpke", "avspkt", "avwpeth", "avnpke", "afpkt", "afpck", "avcpkt", "avpeth", "AVpiece", "avwkh", "avfkh", "avopnt", " avpcht", "avpptch", "avpcht", "affck", "avmkt", "avepkt", "avfct", "avcpnt", " avpbeth", "affacket", " avpnt"], "esc": ["imp", "ep", "ef", "ex", "auc", "nec", "uc", "ace", "ctr", "ev", "code", "exec", "equ", "access", "ec", "usc", "lc", "Esc", "tc", "abc", "oc", "egal", "irc", "unc", "acc", "nc", "ese", "https", "escape", "six", "sc", "ctx", "eval", "cf", "env", "isc", "osc", "eng", "ect", "sec", "election", "ecd", "esp", "EC", "exc", "rc", "ssh", "loc", "cl", "ext", "org", "esi", "cc", "ASC", "ce", "Desc", "eg", "e", "que", "oe", "css", "DC", "ssl", "ek", "desc", "SC", "LC", "ea", "cr", "eca", "complete", "enc", "ae", "pg", "dc", "context", "ega", "qa", "decl", "asc", "fc", "cv", "xc"], "n": ["name", "o", "na", "v", "count", "s", "nt", "ni", "b", "nc", "x", "sn", "m", "l", "num", "f", "N", "ns", "nm", "j", "d", "nr", "net", "np", "u", "number", "e", "w", "pn", "en", "t", "k", "fn", "nb", "p", "ne", "network", "z", "c", "g", "y", "cn", "r", "conn", "nu"], "out_data_size": ["out_buffer_len", "out_buffer_name", "out_data64size", "out_data64len", "out_buffer_size", "out_data64name", "out_data_name", "out_data_len"], "ch": ["name", "nt", "nc", "sn", "th", "l", "f", "q", "res", "ry", "conf", "code", "ck", "col", "cho", "k", "cor", "err", "qu", "h", "batch", "z", "ver", "c", "chan", "ach", "conn"], "ret": ["na", "ann", "mem", "val", "rc", "enc", "res", "code", "len", "arr", "rx", "nz", "cb", "err", "result", "seq", "ne", "batch", "sel", "back", "resp", "ref", "aux", "no", "img", "rem", "rec"], "src": ["sub", "rb", "config", "tmp", "bg", "rc", "sync", "dest", "stream", "loc", "attr", "url", "buffer", "sc", "inst", "func", "fn", "port", "cb", "rl", "source", "seq", "gb", "sel", "cv", "rs", "img", "rec"], "buf": ["cp", "band", "feed", "buff", "vec", "header", "block", "cur", "box", "bd", "wave", "Buff", "rb", "config", "b", "rc", "auc", "queue", "map", "loc", "grab", "uc", "fb", "wb", "uf", "bus", "f", "buffer", "code", "que", "bag", "Buffer", "port", "cmd", "pad", "cube", "bc", "cb", "ab", "ba", "seq", "pool", "batch", "h", "wav", "cap", "off", "fd", "comb", "br", "cf", "cv", "text", "ha", "pb", "fi", "img", "uno", "ff"], "dst": ["ndsts", "idsts", "dedst", "dstal", "Dst", "dedstage", " dstage", "lst", "dbl", "Dste", "idst", "ldst", "Dsts", "ndbl", "dstage", "ldste", "dedsts", "instage", "lST", "sdST", "dST", "dsts", "sdste", "lstal", "idbl", "ndST", "lsts", " dsts", "inST", "dedST", "inst", "sdst", "ldsts", " dbl", "ndst", "sdsts", "insts", "idST", "idstal", "dedste", " dste", " dstal", "ldST", " dST", "dste", "DST"], "i": ["gi", "o", "ti", "I", "chi", "di", "ci", "ki", "ji", "ni", "b", "x", "xi", "si", "io", "bi", "in", "qi", "ix", "f", "pi", "phi", "d", "ii", "j", "iu", "ai", "u", "e", "uri", "w", "ori", "k", "multi", "ini", "ie", "p", "h", "z", "eni", "oi", "c", "ip", "li", "fi", "index", "zi", "ui"]}}
{"project": "qemu", "commit_id": "80dcfb8532ae76343109a48f12ba8ca1c505c179", "target": 0, "func": "static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n    int ret;\n\n\n\n    if (version_id > 3) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* The virtio device */\n\n    ret = virtio_load(&s->vdev, f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n    }\n\n\n\n    /* The config space */\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    tswap32s(&max_nr_ports);\n\n    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {\n\n        /* Source could have had more ports than us. Fail migration. */\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6069, "substitutes": {"f": ["function", "fen", "fr", "fish", "tf", "feed", "buff", "sf", "inf", "v", "fw", "b", "rf", "fed", "m", "fx", "fb", "l", "uf", "d", "fo", "fe", "e", "fore", "file", "t", "fn", "df", "fac", "k", "xf", "fp", "ff", "framework", "fa", "p", "fm", "h", "fs", "c", "g", "bf", "fd", "cf", "fc", "ref", "fi", "form", "r", "F", "af"], "opaque": ["opacs", "Opacs", "oplaque", "oaque", "oplacity", "Opaque", "operaco", "copca", "operac", "operaque", "opac", "oacity", "oca", " opacs", "Opaco", " opaco", "opaco", "operacs", "Opac", "oplca", "copaque", "opacity", "opca", " opac", "copacity"], "version_id": ["versionFid", "version_ids", " version_desc", "versionFname", "vert_id", "ver_name", "ver_i", "versionadname", "versionadfor", "version_desc", "versionFfor", "versionOno", "version_iden", "versionOid", "version_type", "ver_id", "versionerids", "version_no", "versionFstatus", "versionertype", "versionadid", "ver_status", "versionerid", "versioneri", "versionOname", "version_i", "vert_name", "version_status", "versionOiden", " version_name", "ver_for", "version_for", " version_ids", "versioningid", "versioningi", "ver_ids", "versionadstatus", "vert_iden", "versioningtype", "ver_type", "vert_no", "versioningids", "version_name"], "s": ["r", "o", "feed", "sf", "v", "is", "S", "http", "spec", "sg", "session", "b", "socket", "si", "sync", "slice", "ses", "services", "m", "info", "details", "l", "side", "parts", "ns", "j", "sl", "ls", "d", "server", "service", "ss", "conf", "u", "e", "sb", "ops", "gs", "se", "sim", "bis", "ds", "t", "ts", "su", "self", "source", "p", "south", "settings", "sv", "sp", "fs", "sa", "c", "os", "g", "ssl", "sq", "sym", "site", "es", "form", "sup", "ps", "js"], "port": ["function", "patch", "address", "machine", "gp", "cp", "plugin", "o", "feed", "v", "parent", "ported", "component", "PORT", "device", "config", "bug", "op", "object", "data", "m", "route", "tag", "ion", "Port", "project", "export", "post", "child", "state", "server", "sl", "j", "ports", "client", "service", "table", "match", "part", "point", "proxy", "target", "connection", "plane", "t", "nat", "public", "driver", "bridge", "source", "p", "trans", "import", "rule", "ip", "slave", "type", "model", "report", "ort", "text", "test", "form", "host", "manager", "end"], "max_nr_ports": ["max_nr68orts", "max_nr_times", "max_nor_rows", "max_nr_items", "max_num_planes", "max_nr__ports", "max_nr_players", "max_nr68players", "max_nr75rows", "max_nr_port", "max_nr_devices", "max_num_port", "max_nor_ports", "max_nr_planes", "max_nr_services", "max_nor_port", "max_nr67players", "max_nr00orts", "max_nr33ports", "max_nr__items", "max_nr_images", "max_num_images", "max_num_players", "max_nr75images", "max_num_orts", "max_nr00devices", "max_nr33services", "max_num_rows", "max_nr_points", "max_num_points", "max_nr_rows", "max_num_times", "max_num_pins", "max_nr67ports", "max_nr__pins", "max_nr_pins", "max_nr2ports", "max_nr33orts", "max_nr__rows", "max_nr2rows", "max_num_ports", "max_nr_orts", "max_nr75ports", "max_nr__times", "max_nr2images", "max_nr33devices", "max_nr__port", "max_nr00ports", "max_nr68planes", "max_nr00items", "max_nr__devices", "max_num_devices", "max_nr00port", "max_nr00rows", "max_nr67planes", "max_nor_items", "max_nr__points", "max_num_services", "max_nr00services", "max_nr2devices", "max_nr75devices", "max_nr68ports", "max_nr67orts"], "nr_active_ports": ["nr_active_guards", "nr_active23guards", "nr_active___ports", "nr_nr_parts", "nr_active__orts", "nr_active__modules", "nr_active___devices", "nr_active23port", "nr_active23ports", "nr_nr_orts", "nr_active___orts", "nr_nr_modules", "nr_active_modules", "nr_active_devices", "nr_active_port", "nr_nr_devices", "nr_active_orts", "nr_active__devices", "nr_active__parts", "nr_active__ports", "nr_nr_port", "nr_active__port", "nr_active_parts", "nr_active___modules", "nr_nr_ports"], "ports_map": ["export_map", "portsingmap", "orts_maps", "export_app", "ports_maps", "services_default", "portsinglist", "services_dict", "services_maps", "orts_map", "ports_default", "ports_dict", "exportinglist", "services_map", "exportingmaps", "export_maps", "export_list", "exportingmap", "services_data", "exportingapp", "ports_data", "portsingapp", "ports2maps", "ports2list", "ports2dict", "services_list", "ports2map", "orts_dict", "orts_list", "ports_app", "portsingmaps", "ports_list"], "i": ["gi", "ti", "v", "is", "I", "count", "di", "nt", "ci", "ni", "x", "b", "io", "si", "xi", "ri", "slice", "info", "bi", "m", "qi", "ix", "l", "pi", "yi", "phi", "d", "j", "ii", "iu", "it", "ai", "init", "net", "u", "e", "len", "uri", "out", "t", "n", "multi", "mi", " j", "ini", "ie", "p", "mini", "z", "eni", "oi", "hi", "c", "ip", "ind", "type", "y", "li", "inner", "fi", "index", "r", "zi", "mu", "ui"], "ret": ["flag", "reg", "reset", "rt", "_", "alt", "al", "nt", "get", "val", "x", "rc", "b", "art", "reply", "status", "valid", " RET", "num", "fin", "lit", " Ret", "att", "j", "obj", "res", "match", "def", "part", "len", "det", "mt", "out", "en", "RET", "t", "ben", "pass", "result", "red", " result", "Ret", "fab", "ft", "re", "fun", "back", "bf", "bl", "success", "ref", "r", "rets"], "id": ["ID", "aid", "address", "pid", "name", "uid", "act", "rid", "parent", "entry", "vid", "mid", "x", "ad", "info", "in", "image", "key", "like", "lit", "child", "url", "sid", "code", "proxy", "connection", "path", "kid", "ider", "p", "root", "ide", "gen", "import", "ip", "Id", "type", "bid", "oid", "ids", "api", "ident", "index"], "host_connected": ["host_conn", "hostfulcontrolled", "hostalconn", " host_available", "host_called", "host_controlled", " host_called", "hostfulconnected", "port_connected", "hostingupdated", "hostalconnected", "host_selected", "hostalselected", "host_connection", " host_connect", "port_closed", "objectlexlinked", "host_linked", "hostfullinked", "hostingopened", "hostalopened", "hostinglinked", "hostalconnect", "hostallavailable", "host_updated", "hostalcalled", "port_opened", "hostingselected", "hostallconn", "port_selected", "hostlexcontact", "host_opened", "objectlexconnected", "object_linked", "hostalavailable", " host_updated", "object_connected", "objectlexcontrolled", " host_conn", "port_connect", "hostallupdated", "hostalllinked", " host_linked", "hostallcalled", "host_contact", "hostlexlinked", "hostingconnected", "hostallconnect", "hostallconnected", "hostlexconnected", "host_connect", "object_contact", "hostingconnect", "port_connection", "hostfulcontact", "hostlexcontrolled", "object_controlled", "host_closed", "objectlexcontact", "host_available"], "elem_popped": ["elem_popping", "elem_dropping", "elem_dropped", "elem_dropper", "_", "elem_croipped", "device", "elem_mopped", "elem_popper", "elem_cropped", "elem_Popped", "elem_cropper", "elem_coiped", "elem_copped", "elem_coipped", "elem_moipped", "elem_cropping", "linux", "elem_poipped", "elem_droipped", "elem_croiped", "elem_Popping", "elem_Poipped", "elem_mopping", "elem_copping", "this", "elem_moiped", "new", "g", "addr", "elem_Popper", "elem_poiped"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n", "idx": 6092, "substitutes": {"id": ["ID", "pid", "uid", "parent", "data", "info", "in", "url", "create", "q", "sid", "def", "path", "kid", "cb", "root", "start", "fs", "Id", "ip", "head", "bid", "ident", "ids", "oid", "type", "desc", "ref"], "backend": ["udender", "backender", "backward", " backdn", "frontends", "frontward", "frontend", "backdn", "udend", "uden", "Backender", "BACKends", "fronten", "Backen", " backen", "frontdn", "BACKend", "Backward", "udward", "backen", "BACKdn", "BACKen", " backends", "backends", "Backend", "frontender"], "ret": ["gr", "gc", "reg", "mem", "urn", "eth", "val", "tr", "rc", "sys", "reply", "att", "res", "def", "RET", "result", "Ret", "re", "fs", "sa", "resp", "ref", "fi", "rs", "conn", "rets"], "errp": ["ersp", "errr", "erp", "strsp", "errsp", "strp", "erP", "strP", "err", "errP", " errsp", "strr", " errr", " errP"], "name": ["base", "option", "o", "na", "a", "parent", "dn", "word", "x", "b", "data", "alias", "i", "named", "sn", "info", "m", "names", "key", "f", "client", "version", "d", "Name", "part", "e", "NAME", "size", "code", "connection", "ame", "n", "path", "pass", "self", "filename", "p", "nam", "none", "c", "new", "g", "type", "prefix"], "chr": [" chra", "cherl", "ochp", "clr", "anchrc", "chrc", "ochra", "Chrb", " chrc", " chrr", "shr", "chrl", "chp", "schp", "anchr", "chsr", "schr", "shrl", "chrg", "schc", "Chrn", "anchrn", "clsr", " chc", "cher", "CHrc", "Chr", "clrl", "shsr", "CHrg", "Chrg", "chesr", "CHrb", "ochr", "cllr", " chrg", "chc", "chrn", "Chrc", "chrb", " chrn", "CHr", " chrb", "chrr", "anchrr", "shlr", "Chrr", "ochc", "chra", "schra", "chelr", " chp", "chlr"], "s": ["o", "sf", "S", "spec", "sg", "session", "b", "socket", "si", "sys", "ses", "m", "l", "f", "ns", "server", "ls", "sl", "ss", "cs", "sie", "sb", "gs", "ops", "ds", "n", "ts", "su", "p", "south", "h", "fs", "sa", "c", "os", "ssl", "sq", "sym", "es", "rs", "r", "ps", "js"]}}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n", "idx": 6098, "substitutes": {"cpu": ["cp", "flow", "bench", "gc", "cmp", "pid", "CP", "lb", "chip", "pu", "vm", "roc", "component", "gru", "config", "nc", "auc", " CPU", "gpu", "comp", "uc", "px", "mac", "uci", "pc", "linux", "np", "proxy", "clock", "instance", "ctx", "processor", "ctrl", "boot", "frame", "uca", "pointer", "proc", "node", "c", "GPU", "cn", "core", "lc", "CU", "cache", "android", "loader", "CPU", "conn"], "breakpoint": [" breakpointer", "breakpointer", "Breakart", "breakdown", "breakerPoint", " breakpt", "Breakpointer", "Breakpoint", "breakingart", "breakpt", "breakingpointer", "breakingargument", "breakingframe", "breakframe", " breakade", " breakargument", "breakingPoint", "breakart", "breakerframe", "breakerpoint", "breakingpoint", "breakerpt", " breakdown", "breakingdown", "breakerargument", " breakframe", "breakPoint", "breakingade", " breakart", "breakerdown", "breakargument", "breakade", "BreakPoint", "Breakade", " breakPoint", "breakingpt"]}}
{"project": "FFmpeg", "commit_id": "1eaff98c8320d9ba48fbaec2a558f31f4104de98", "target": 1, "func": "static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n", "idx": 6103, "substitutes": {"s": ["sets", "v", "ins", "is", "a", "S", "spec", "sg", "single", "comments", "b", "si", "sync", "ses", "services", "in", "support", "l", "xs", "f", "ns", "d", "ls", "sl", "series", "service", "ss", "cs", "sports", "e", "submit", "sb", "gs", "ks", "w", "rss", "se", "qs", "ds", "t", "ctx", "n", "ts", "su", "p", "settings", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "sup", "js"], "file_size": ["file_number", "data_ize", "file_scale", " file_sum", "file_name", "file64ize", " file_data", "file_count", "file_ize", "file__sum", "file__data", "file64time", "file_sum", "filexcount", "file_Size", "image_size", "file_time", "filextime", "file64size", "data_count", "filexize", "file__Size", "image_speed", "block_rate", "file_speed", "image_number", " file_Size", "data_time", "file64count", "block_size", "file__size", "data_size", "file_data", "block_scale", "block_name", "file_rate", "filexsize"], "pb": ["verb", "cp", "plugin", "bp", "lb", "hub", "platform", "pa", "rb", "plug", "b", "bps", "pd", "wp", "typ", "bm", "lp", "queue", "lab", "loc", "library", "fb", "db", "wb", "uf", "pm", "pg", "prot", "pc", "bs", "xb", "eb", "dp", "sb", "parser", "ctx", "bc", "PB", "fp", "cb", "jp", "ab", "p", "mb", "summary", "vp", "gb", "ppa", "ub", "ld", "bf", "lc", "dl", "orp", "tp", "fc", "api", "cv", "pl", "um", "rob", "cpp", "bh", "pkg"], "flv": ["elb", "elf", "flV", " flV", "FLf", "elc", " flb", "llp", " flp", "flb", " flvs", "flp", "wlvs", "flvs", "llv", "flc", "wlv", "slv", "wlV", "FLc", " flc", "elv", "flf", "slc", "FLb", "wlc", "elp", "slV", "slvs", "llb", "FLv", " flf", "llf"], "i": ["gi", "o", "ti", "v", "I", "chi", "di", "ci", "ni", "xi", "x", "si", "ri", "b", "io", "slice", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "iu", "ii", "d", "ai", "u", "e", "uri", "ori", "n", "multi", "mi", "jp", "ini", "ie", "p", "eni", "iv", "oi", "hi", "ip", "g", "y", "li", "inner", "fi", "index", "zi", "mu", "ui"], "enc": ["oc", "eng", "anc", "ENC", "ch", "emb", "sec", "spec", "acc", "nc", "et", "sys", "nec", "loc", "inc", "cl", "ext", "sl", "pc", "sci", "cc", "cs", "ev", "code", "con", "e", "acl", "en", "Enc", "dc", "ctx", "ant", "bc", "ent", "equ", "ou", "ic", "ec", "iv", "c", "ssl", "lc", "core", "fc", "env", "cod", "ac", "vc", "cv", "oder", "conn", "cel"], "sc": ["sub", "osc", "ch", "anc", "cr", "spec", "sw", "sem", "nc", "rc", "uc", "cl", "ga", "soc", "Sc", "pc", "cc", "sci", "cs", "ss", "mc", "sb", "cam", "dc", "esc", "ctx", "bc", "cms", "ec", "ca", "sa", "c", "sq", "lc", "cv", "pl", "SC", "src", "tc"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 6108, "substitutes": {"opaque": ["uppaques", "uppaque", "ropayne", "OPayne", "oaque", "OPacity", "ropaque", "obaque", "ropaques", "ropacity", "opayne", "OPaque", "obacity", "oacity", "OPaques", "uppayne", "uppacity", "opaques", "copaques", "copaque", "opacity", "obaques", "oaques", "copacity"], "fdt_orig": ["fdtn_orig", "fdt_ctr", "fdt__original", "fdtt_src", "fdtm_new", "fdt_new", "fdtn_slice", "fdt_src", "fdtn_real", "fdt_slice", "fdtm_original", "fdt_original", "fdt_ext", "fdt__ctr", "fdtt_ext", "fdt__new", "fdt_real", "fdt__orig", "fdtt_origin", "fdt_origin", "fdtm_orig", "fdtm_ctr", "fdtt_orig"], "match_data": ["match1data", "test_def", "test_data", "match_buffer", "match1buffer", "match_def", "test_buffer", "match1def"], "load_addr": ["loaduregrad", "load_order", "loadureaddress", "loadureaddr", "load_data", "load67addr", "loader_address", "load67grad", "loader_coord", "loader_addr", "load67order", "load_address", "load67address", "loader_data", "loader_order", "loader_grad", "load_grad", "loadureorder", "load_coord"], "s": ["o", "is", "S", "spec", "sg", "session", "b", "si", "sync", "sys", "ses", "services", "m", "f", "ns", "state", "d", "sl", "server", "space", "service", "cs", "ss", "u", "sis", "e", "sc", "sie", "sb", "ops", "se", "sh", "secondary", "second", "storage", "gs", "n", "sea", "su", "self", "sch", "source", "p", "south", "sa", "c", "os", "g", "ssl", "sq", "rs", "r", "ps"], "machine": ["game", "base", "vm", "di", "note", "component", "session", "config", "M", "bug", "b", "object", "home", "bm", "database", "template", "module", "info", "m", "image", "office", "ram", "mac", "private", "ma", "project", "player", "state", "server", "sm", "service", "man", "part", "interface", "mc", "command", "mage", "connection", "message", "storage", "instance", "volume", "Machine", "kernel", "self", "controller", "source", "p", "computer", "mom", "mini", "node", "shell", "slave", "memory", "model", "core", "jam", "engine", "element", "loader", "manager", "mode", "hard"], "cmdline": ["mdstring", "CmdLine", "mdline", "cmdLINE", "hostLine", "hostLINE", " cmdl", " cmdlines", "mdLINE", " cmdLINE", "Cmdline", "mdLine", "msgline", "msgLINE", "commandlines", "Cmdl", "cmdl", "cmdLine", "hoststring", "commandl", " cmdstring", "commandline", "commandLine", " cmdLine", "cmdlines", "msgl", "msgLine", "commandLINE", "hostline", "Cmdlines", "cmdstring"], "err": ["dr", "dy", "aer", "iter", "rag", "orr", "ise", "ace", "f", "magic", "ctr", "len", "error", "ar", "die", "arr", "cor", "self", "mr", "ver", "proc", "var", "fer", "resp", "Er", "kr", "ah", "arm", "count", "aster", "cry", "rage", "eor", "nr", "str", "raise", "runner", "yr", "test", "fr", "er", "act", "sr", "loc", "ler", "acer", "me", " Err", "ner", "ind", "orig", "cache", "r", "Error", "nor", "cr", "pr", "rr", "bug", "der", "rh", "ir", "attr", "order", "call", "init", "ry", "n", "cb", "lr", "result", "wr", "req", "br", "inner", "rar"], "fdt": ["fdd", "fcdt", "fcd", "dfts", "dfte", "dayd", "dtt", "dldt", "dlt", "fdts", "fdT", "debdt", "dt", "dbts", "dlT", "vdtt", "fdout", "fedtm", "fdtr", "fdtm", "dbt", "FDte", "fft", "fcout", "dltf", "fedt", "fdwt", "debtt", "dlwt", "sde", "dltr", "dlte", "fctm", "fxt", "dltm", "vdt", "cftt", "wdtt", "dle", "fdte", "dfnt", "ldt", "fxta", "debnt", "ldts", "wdt", "FDtm", "dlta", "ldc", "dfta", "fdtt", "dfout", "dfg", "daydt", "fedte", "FDnt", "sdnt", "ffta", "ffte", "fdc", "dlout", "fddt", "sdtf", "fctf", "dftf", "fdtf", "FDT", "wdta", "cfg", "cft", "fftt", "dlnt", "dfc", "FDt", "dftm", "dftt", "fdg", "vddt", "fdta", "cftm", "dbc", "dfe", "dfwt", "dld", "fxte", "dft", "dg", "fedtt", "dbtf", "dtm", "dayt", "fde", "vdnt", "fdnt", "dltt", "ldtf", "sdt", "debt", "wdtr", "daytm", "dfT", "fxtt", "FDtt", "dftr", "fct", "fcwt"], "fdt_sz": ["fdt__dzen", "fdt_wsiz", "fdt__sgd", "fdt_szi", "fdt_nosgd", "fdt_bci", "fdt_timesze", "fdt_sinci", "fdt_bst", "fdt_dce", "fdt_wzi", "fdt_dz", "fdt_sst", "fdt_bzn", "fdt_sci", "fdt_lsze", "fdt_scz", "fdt_sce", "fdt_dsst", "fdt_drc", "fdt_iszn", "fdt_siz", "fdt_dzip", "fdt_timesci", "fdt_sze", "fdt_sgd", "fdt__dgd", "fdt_isst", "fdt_sincz", "fdt_dzen", "fdt__dz", "fdt__sze", "fdt_szn", "fdt_dsci", "fdt_lsz", "fdt_wsz", "fdt_lsgd", "fdt__sz", "fdt_nosze", "fdt_wz", "fdt_szen", "fdt_dgd", "fdt_sinze", "fdt_bz", "fdt__sci", "fdt_wsrc", "fdt_wce", "fdt_dze", "fdt__szen", "fdt__scz", "fdt_timescz", "fdt_wiz", "fdt__dze", "fdt_wzip", "fdt_szip", "fdt_timesz", "fdt_wrc", "fdt_nosz", "fdt_sinz", "fdt_isci", "fdt_dszn", "fdt_src", "fdt_wszi", "fdt_dzi", "fdt_lszen", "fdt_diz", "fdt_isz", "fdt_dsz", "fdt_noszen"], "ram_low_sz": ["ram_low_aszo", "ram_low_psz", "ram_low_dz", "ram_low_siz", "ram_low_timeszi", "ram_low_asz", "ram_low_psiz", "ram_low_szi", "ram_low_sze", "ram_low_dfl", "ram_low_fz", "ram_low_szek", "ram_low_Siz", "ram_low_sfl", "ram_low_aszi", "ram_low_timesiz", "ram_low_Sz", "ram_low_fiz", "ram_low_Sx", "ram_low_dzi", "ram_low_aszek", "ram_low_psze", "ram_low_timesz", "ram_low_timesze", "ram_low_fze", "ram_low_asx", "ram_low_timesfl", "ram_low_asze", "ram_low_sx", "ram_low_szo", "ram_low_timeszek", "ram_low_asfl", "ram_low_Sze", "ram_low_diz", "ram_low_asiz", "ram_low_pszo", "ram_low_Szo", "ram_low_fx"], "ram_high_sz": ["ram_high_ssz", "ram_high_asz", "ram_high_asiz", "ram_high_sidz", "ram_high_szo", "ram_high_szi", "ram_high_fzip", "ram_high_Siz", "ram_high_ssze", "ram_high_siz", "ram_high_sze", "ram_high_aszen", "ram_high_fiz", "ram_high_Sz", "ram_high_szip", "ram_high_fz", "ram_high_aszo", "ram_high_Szo", "ram_high_sszo", "ram_high_szen", "ram_high_sszi", "ram_high_aszi", "ram_high_fzi", "ram_high_Sze", "ram_high_sidzen", "ram_high_Szip", "ram_high_sidiz", "ram_high_ssiz", "ram_high_Szi", "ram_high_asze", "ram_high_sidzi", "ram_high_sszip"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n#if CONFIG_ZLIB\n\n    AVIOContext ctx;\n\n    uint8_t *cmov_data;\n\n    uint8_t *moov_data; /* uncompressed data */\n\n    long cmov_len, moov_len;\n\n    int ret = -1;\n\n\n\n    avio_rb32(pb); /* dcom atom */\n\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n\n        return AVERROR_INVALIDDATA;\n\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_rb32(pb); /* cmvd atom */\n\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n\n        return AVERROR_INVALIDDATA;\n\n    moov_len = avio_rb32(pb); /* uncompressed size */\n\n    cmov_len = atom.size - 6 * 4;\n\n\n\n    cmov_data = av_malloc(cmov_len);\n\n    if (!cmov_data)\n\n        return AVERROR(ENOMEM);\n\n    moov_data = av_malloc(moov_len);\n\n    if (!moov_data) {\n\n        av_free(cmov_data);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    avio_read(pb, cmov_data, cmov_len);\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n\n        goto free_and_return;\n\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n\n        goto free_and_return;\n\n    atom.type = MKTAG('m','o','o','v');\n\n    atom.size = moov_len;\n\n    ret = mov_read_default(c, &ctx, atom);\n\nfree_and_return:\n\n    av_free(moov_data);\n\n    av_free(cmov_data);\n\n    return ret;\n\n#else\n\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n\n    return AVERROR(ENOSYS);\n\n#endif\n\n}\n", "idx": 6112, "substitutes": {"c": ["icc", "cp", "cmp", "ch", "cr", "ci", "config", "b", "cy", "C", "m", "uc", "cm", "l", "f", "client", "pc", "cc", "cs", "con", "mc", "e", "dc", "k", "bc", "context", "p", "ca", "ec", "h", "cit", "g", "ct", "cn", "lc", "cf", "fc", "cv", "ac", "vc", "ctrl", "cd", "xc", "tc"], "pb": ["cp", "plugin", "bp", "lb", "hub", "platform", "http", "pa", "rb", "tmp", "pd", "bps", "b", "typ", "bm", "wp", "lp", "lab", "fb", "wb", "db", "mp", "pg", "prot", "pc", "bb", "xb", "np", "eb", "dp", "sb", "bc", "PB", "fp", "cb", "jp", "ab", "p", "apy", "gb", "kb", "ppa", "proc", "bf", "lc", "api", "tp", "fc", "pl", "rob", "cpp", "bh", "cm", "pkg", "tc"], "atom": ["base", "chem", "external", "ann", "om", "spec", "acc", "config", "tmp", "b", "com", "data", "op", "x", "tom", "object", "module", "xml", "m", "unit", "cat", "orb", "bn", "tag", "num", "attr", "at", "material", "att", "obj", "atomic", "document", "bb", "cell", "acl", "sb", "t", "instance", "tm", "mag", "kernel", "container", "bc", " Atom", "p", "temp", "mom", "ctrl", "asm", "fab", "prop", "node", "sym", "type", "class", "mol", "term", "article", "ac", "cache", "app", "element", "cm", "orbit", "tc"], "ctx": ["cp", "cmp", "gc", "ci", "config", "nc", "rc", "cca", "loc", "cm", "tx", "conv", " rc", "pc", "cc", "sci", "mc", "sc", "acl", "cam", "conn", "dc", "wcs", "bc", "cb", "cu", "fp", "exec", "context", "ca", " context", "qa", "kb", "acs", "utils", "ct", "cn", "lc", "cf", "cv", " cx", "aux", "cas", "ctrl", "pkg", "xc", "tc"], "cmov_data": ["cmoodsdata", "cmov_la", "cmove_data", "cmove_la", "cmovsad", "cmovo_data", "cmoodslen", "cmood_data", "cmov_Data", "cmav_len", "cmovspos", "cmood_empty", "cmovsdat", "cmove_len", "cmovacstyle", "cmovtdata", "cmovsempty", "cmovo_len", "cmove_style", "cmovtempty", "cmov_size", "cmovo_dat", "cmoodsempty", "cmav_style", "cmovo_pos", "cmav_data", "cmovacdata", "cmav_size", "cmovsdata", "cmov_dat", "cmood_len", "cmovacsize", "cmovtlen", "cmov_style", "cmoodsdat", "cmov_pos", "cmove_pos", "cmov_empty", "cmovslen", "cmovaclen", "cmovo_Data", "cmovtdat", "cmov__pos", "cmov_ad", "cmovsData", "cmov__len", "cmood_dat", "cmov__data", "cmovo_ad"], "moov_data": ["moovo_size", "moovo_len", "moovsdata", "moova__body", "moovoend", "moova_body", "moove_data", "moov__data", "moovacbody", "moovsdat", "moovaclength", "moov_length", "loovo\n", "moovksize", "moova_data", "moov__size", "moant_data", "moovacdata", "moov\n", "moovend", "moova__data", "moova__size", "moant_last", "moant_size", "loovend", "moovo_slice", "moovospos", "moov_pos", "moovosdata", "moantklast", "moove\n", "moant_len", "moova_size", "moove_len", "moov_la", "moova_length", "moove_bin", "moovssize", "mooveend", "moov_slice", "moovkdata", "loovoend", "moov_bin", "moovo_pos", "moova\n", "moovo_dat", "moovossize", "moovacsize", "moovklen", "loov\n", "moov_break", "moov__length", "moantksize", "moova__length", "moovo_break", "moantklen", "moovaend", "moove_la", "moov_size", "moov_dat", "moov_body", "moovo\n", "moov_last", "moovspos", "moovklast", "moovosdat", "moov__body", "moovo_data", "moantkdata"], "cmov_len": ["cmove_depth", "cmov11Len", "cmovdlen", "cmosh64lan", "cmov0size", "cmood_size", "cmov64length", "cmove_data", "cmov__length", "cmov_lan", "cmovdsize", "cmovo_data", "cmov_depth", "cmov0pos", "cmosh64length", "cmosh_lon", "cmov_lim", "cmosh_length", "cmov_lon", "cmovddata", "cmove_len", "cmov11data", "cmosh64len", "cmovo_len", "cmova_data", "cmovaslength", "cmov_size", "cmovdpos", "cmovdlim", "cmov64lon", "cmosh64lon", "cmov__lan", "cmovo_pos", "cmosh_len", "cmov__lon", "cmov_Len", "cmovsdata", "cmood_len", "cmood_pos", "cmovaslen", "cmova_len", "cmove_Len", "cmovasdata", "cmovassize", "cmov0lim", "cmovslength", "cmov_pos", "cmood_lim", "cmovslen", "cmovssize", "cmov64lan", "cmov0len", "cmovdlength", "cmov11len", "cmova_size", "cmov__len", "cmov64len", "cmov_length", "cmova_length", "cmosh_lan", "cmov11depth"], "moov_len": ["moov0lim", "moovtpos", "moov_val", "moov_limit", "mooy1size", "moove_data", "mooy_len", "moova_fin", "moova_pos", "moov64val", "moom_len", "moov_lon", "moov_length", "moov0size", "moom_size", "moovksize", "moova_id", "moov__size", "moov_en", "moom0lim", "moovParval", "moov1size", "moov64size", "moovklim", "moova_lim", "moov1lon", "moov__len", "moove_val", "moov_pos", "moovnfin", "moovtid", "moov0len", "moov_l", "moove_len", "moova_length", "mooy_lon", "mooy_den", "mooy_l", "moom_lim", "moov_fin", "moovken", "moovatlen", "moovtlength", "mooy_val", "moovnbin", "moovnlim", "mooy1l", "moov_bin", "moova_bin", "moov_id", "moovatpos", "moom0size", "moom_en", "moovatid", "moovPardata", "moov64den", "moov1len", "moov0en", "moov__val", "moom0len", "moov__den", "moovklen", "moom0en", "mooy1len", "moov1l", "moovParlimit", "moov_den", "moove_limit", "moova_len", "mooy_size", "moov_size", "moovtlen", "moovatlength", "moovParlen", "moov_lim", "moov64len", "mooy1lon", "moovnlen"]}}
{"project": "FFmpeg", "commit_id": "170870b77c8c71304f9eae946d49aa5e30a464bc", "target": 1, "func": "static int sdp_parse_rtpmap(AVFormatContext *s,\n\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n\n                            int payload_type, const char *p)\n\n{\n\n    char buf[256];\n\n    int i;\n\n    AVCodec *c;\n\n    const char *c_name;\n\n\n\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n\n     * see if we can handle this kind of payload.\n\n     * The space should normally not be there but some Real streams or\n\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n\n     * have a trailing space. */\n\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n\n    if (payload_type >= RTP_PT_PRIVATE) {\n\n        RTPDynamicProtocolHandler *handler;\n\n        for (handler = RTPFirstDynamicPayloadHandler;\n\n             handler; handler = handler->next) {\n\n            if (!strcasecmp(buf, handler->enc_name) &&\n\n                codec->codec_type == handler->codec_type) {\n\n                codec->codec_id          = handler->codec_id;\n\n                rtsp_st->dynamic_handler = handler;\n\n                if (handler->open)\n\n                    rtsp_st->dynamic_protocol_context = handler->open();\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* We are in a standard case\n\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n\n        /* search into AVRtpPayloadTypes[] */\n\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n\n    }\n\n\n\n    c = avcodec_find_decoder(codec->codec_id);\n\n    if (c && c->name)\n\n        c_name = c->name;\n\n    else\n\n        c_name = (char *) NULL;\n\n\n\n    if (c_name) {\n\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n        i = atoi(buf);\n\n        switch (codec->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n\n            if (i > 0) {\n\n                codec->sample_rate = i;\n\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n                i = atoi(buf);\n\n                if (i > 0)\n\n                    codec->channels = i;\n\n                // TODO: there is a bug here; if it is a mono stream, and\n\n                // less than 22000Hz, faad upconverts to stereo and twice\n\n                // the frequency.  No problem, but the sample rate is being\n\n                // set here by the sdp line. Patch on its way. (rdm)\n\n            }\n\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n\n                   codec->sample_rate);\n\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n\n                   codec->channels);\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 6125, "substitutes": {"s": ["sets", "http", "spec", "session", "b", "sys", "ses", "services", "m", "tools", "f", "client", "ns", "stats", "server", "cli", "us", "cs", "service", "sports", "conf", "e", "sc", "parser", "gs", "sb", "bis", "t", "ds", "lex", "aws", "fs", "os", "g", "ssl", "sq", "rs", "r", "ps", "setup", "js"], "codec": ["codroc", "codeocol", "codocol", "codeef", "taxesc", "codentity", "codeus", " codrec", " codeco", "oddec", "CodEC", "modec", "codenc", "metesc", "coderc", "codeenc", "copesc", "libec", " codect", "codeEC", "genesc", "Codesc", " codentity", "codeac", "libEC", "odec", "codefc", "equec", "codeco", "validec", "Codef", "predef", "predrec", "codeca", "Codect", "codeeca", "moduc", "codex", "odeca", "metex", "odex", "codeuc", "Coduc", "taxeco", "coddec", " codocol", "modeus", "predEC", "libesc", " codroc", "codedec", "libef", "metdec", "odocol", "codac", " codEC", "odrec", "oduc", "genroc", "copac", "codeex", "codfc", "defesc", "taxentity", "defec", "odEC", "metec", "genec", "predeca", "Codex", "codrec", " coderc", "Codec", " codef", " coduc", "metenc", "copec", "odenc", "validentity", "odef", "defef", "codEC", "codesc", "codeec", "predec", "codef", "codeeus", "codeesc", "taxec", "odroc", "odesc", " codeus", "coduc", "modfc", "equuc", " codesc", "codeect", "metuc", " codeca", "validesc", " codfc", "copef", "codect", "defac", "valideco", "equeca", "codeerc", "Coderc", "equex", "preduc"], "rtsp_st": ["rtsv_sts", "rtsv_sta", "rtsp_sth", "rtsv_st", "rtsfp_st", "rtsp1stream", "rtspfst", "rtspJst", "rtsp2st", "rtsv_stream", "rtsfp_sth", "rtsv_sth", "rtsp1sth", "rtsp2sta", "rtsp1ST", "rtsp_ST", "rtsp_inst", "rtspfstream", "rtspfsth", "rtspJsth", "rtsfp_stream", "rtspJinst", "rtsp_sts", "rtsp2stream", "rtsp_stream", "rtsp1st", "rtsp2sts", "rtspJstream", "rtsp_sta", "rtsv_inst", "rtsfp_ST", "rtspfinst"], "payload_type": ["payload_number", "payec_id", "payloadaltype", "payload_types", "payec_type", "payloadalnumber", "payload_name", "payec_number", "payloadalid", "payec_types", "payec_name", "payload_id"], "p": ["P", "o", "bp", "padding", "v", "pa", "b", "op", "format", "wp", "ap", "lp", "pe", "m", "l", "f", "pi", "at", "d", "j", "pc", "q", "param", "np", "e", "point", "port", "t", "n", "ctx", "fp", "h", "vp", "sp", "ip", "g", "type", "api", "tp", "params", "r", "ps"], "buf": ["rb", "b", "data", "auc", "queue", "bi", "uc", "f", "buffer", "bag", "func", "bc", "ab", "pool", "proc", "pb", "img", "bh", "msg", "bed", "fam", "lb", "cur", "config", "fb", "uf", "ru", "binary", "received", "ctx", "filename", "font", "batch", "wav", "bags", "cap", "txt", "text", "addr", "ff", "brace", "feed", "vec", "block", "box", "bd", "rc", "exc", "map", "grab", "db", "wb", "conv", "que", "Buffer", "cmd", "feat", "input", "prop", "orig", "fd", "desc", "cache", "src", " b", "buff", "la", "Buff", " buffer", "bus", "cb", "result", "seq", "bf", "br", "cv", "pkg"], "i": ["gi", "ri", "area", "ti", "v", "wei", "I", "is", "alpha", "count", "di", "ci", "ki", "ji", "ni", "xi", "b", "si", "io", "slice", "abi", "x", "info", "bi", "m", "qi", "l", "f", "pi", "phi", "adi", "j", "iu", "ii", "d", "esi", "ai", "cli", "init", "length", "u", "it", "e", "ami", "uri", "ori", "t", "n", "multi", "mi", "ini", "ie", "mini", "eni", "hi", "ip", "type", "api", "y", "li", "anti", "index", "zi", "diff", "mu", "ui"], "c": ["cmp", "oc", "ch", "anc", "o", "v", "ci", "chain", "b", "nc", "rec", "rc", "cy", "enc", "co", "C", "m", "uc", "in", "cm", "l", "cl", "f", "client", "d", "pc", "cc", "cs", "ce", "u", "arc", "code", "con", "e", "mc", "col", "dc", "k", "n", "ctx", "t", "bc", "cu", "coll", "ca", "ec", "h", "g", "ct", "cn", "lc", "cf", "fc", "ac", "cache", "r", "ctrl", "cd", "xc", "tc"], "c_name": [" c_data", "c_la", "c_num", "c___key", " c_prefix", "c___id", "c_NAME", "p_name", " c_value", "C_block", "enc_name", "cJsize", "c__prefix", "c_prefix", "cJprefix", "cJno", "c___name", "c_key", "c2num", " c_no", "enc_type", "C_name", "c_size", "c__data", "cJvalue", "c__size", "c_data", "c_value", "C_id", "enc_num", "c2type", "p_la", "c___block", "c_block", "cJNAME", "p_id", "cJname", "C_key", "c_id", " c_NAME", "c2name", "cJdata", "c__name", " c_size", "c_no", "c_type", "c2key", "enc_key"], "handler": ["writer", "layer", "band", "entry", "hand", "object", "handled", "route", "f", "job", "magic", "service", "code", "error", "connection", "file", "callback", "controller", "reader", "h", "filter", "page", "folder", "function", "plugin", "name", "channel", "config", "slice", "widget", "server", "cher", "loop", "later", "man", "definition", "item", "driver", "lib", "path", "field", "application", "ctx", "response", "runner", "type", "model", "cookie", "command", "end", "address", "area", "er", "feed", "or", "phase", "holder", "key", "package", "guard", "parser", "message", "fd", "api", "core", "loader", "wrapper", "event", "client", "player", "child", "handle", "lr", "result", "Handler", "pointer", "inner", "manager", "worker"]}}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n", "idx": 6140, "substitutes": {"s": ["o", "sets", "sf", "sec", "is", "S", "spec", "sg", "b", "si", "i", "sync", "sys", "ses", "services", "m", "in", "support", "l", "f", "client", "ns", "j", "ls", "sl", "service", "us", "ss", "cs", "sports", "u", "e", "w", "gs", "sb", "se", "bis", "ks", "qs", "t", "n", "ctx", "ds", "ts", "storage", "self", "p", "fs", "c", "os", "g", "ssl", "sq", "es", "rs", "src", "ps", "js"], "xvmc_acceleration": ["xvmc_accelation", "xvmc_accelator", "xvmc_encceleration", "xvmc_accelering", "xvmc_enccentation", "xvmc_enccenting", "xvmc_enccelerator", "xvmc_accenting", "xvmc_enccentator", "xvmc_accelerations", "xvmc_acveration", "xvmc_accelations", "xvmc_accentation", "xvmc_accentator", "xvmc_acverator", "xvmc_acceling", "xvmc_enccelerations", "xvmc_accelerator", "xvmc_enccelering", "xvmc_enccentations", "xvmc_acverations", "xvmc_accentations", "xvmc_acvering"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARES", "FF_ENABLE_DEPRECATION_ERRORs", "FF_ENABLE_DEPRECATION_ERRORES", "FF_ENABLE_DEPRECATION_WARNINGDS", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_WARNINGES", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_ERRORS", "FF_ENABLE_DEPRECATION_WARDS", "FF_ENABLE_DEPRECATION_ERRORDS"]}}
{"project": "FFmpeg", "commit_id": "b67f3d65757e9b08a797f584ee818ad7cfe7b303", "target": 1, "func": "static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n\n{\n\n    int i, err;\n\n    AVFormatContext *ic;\n\n    int nopts = 0;\n\n\n\n    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);\n\n    if (err < 0)\n\n        return err;\n\n    /* copy stream format */\n\n    s->nb_streams = ic->nb_streams;\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st;\n\n        AVCodec *codec;\n\n\n\n        // FIXME: a more elegant solution is needed\n\n        st = av_mallocz(sizeof(AVStream));\n\n        memcpy(st, ic->streams[i], sizeof(AVStream));\n\n        st->codec = avcodec_alloc_context();\n\n        if (!st->codec) {\n\n            print_error(filename, AVERROR(ENOMEM));\n\n            ffmpeg_exit(1);\n\n        }\n\n        avcodec_copy_context(st->codec, ic->streams[i]->codec);\n\n        s->streams[i] = st;\n\n\n\n        codec = avcodec_find_encoder(st->codec->codec_id);\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_sample_fmt(st, codec);\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (video_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_pixel_fmt(st, codec);\n\n        }\n\n\n\n        if(!st->codec->thread_count)\n\n            st->codec->thread_count = 1;\n\n        if(st->codec->thread_count>1)\n\n            avcodec_thread_init(st->codec, st->codec->thread_count);\n\n\n\n        if(st->codec->flags & CODEC_FLAG_BITEXACT)\n\n            nopts = 1;\n\n    }\n\n\n\n    if (!nopts)\n\n        s->timestamp = av_gettime();\n\n\n\n    av_close_input_file(ic);\n\n    return 0;\n\n}\n", "idx": 6160, "substitutes": {"s": ["sets", "ins", "is", "sac", "S", "spec", "sg", "plugins", "session", "x", "cus", "si", "ex", "sn", "sys", "ses", "services", "its", "ix", "l", "xs", "f", "ns", "icing", "ls", "sl", "bs", "us", "cs", "ss", "service", "ics", "gs", "se", "ops", "ks", "qs", "ds", "ts", "p", "aws", "acs", "fs", "sa", "c", "os", "g", "ssl", "sq", "ms", "ess", "ac", "es", "rs", "ps"], "filename": ["IL", "name", "nl", "files", "sf", "word", "username", "Filename", "password", "File", "title", "wb", "l", "f", "url", "document", "ename", "buffer", "fil", "uri", "SourceFile", "file", "binary", "fn", "message", "path", "fp", "dll", "rl", "nil", "msg", "kl", "txt", "location", "fd", "wl", "utf", "il", "phrase", "directory", "prefix"], "i": ["gi", "o", "ti", "v", "id", "I", "a", "ih", "ik", "di", "ci", "ni", "b", "ri", "si", "io", "xi", "x", "info", "bi", "m", "ace", "qi", "ix", "l", "f", "pi", "yi", "j", "ii", "iu", "it", "ai", "u", "e", "uri", "multi", "mi", "ini", "ie", "p", "h", "eni", "z", "start", "oi", "ind", "ip", "c", "g", "y", "li", "fi", "index", "zi", "mu", "ui"], "err": ["gr", "rn", "dr", "dy", "er", "nor", "cr", "sr", "iter", "arm", "pr", "rr", "aster", "bug", "ise", "in", "der", "ace", "rh", "ir", "phi", "order", "call", "nr", "ler", "it", "init", "fe", "ry", "rar", "code", "e", "error", "ar", "out", "arr", "dev", "cor", "cb", "str", "ini", "lr", "ie", "ee", " Err", "req", "h", "ner", "mr", "ver", "ind", "yr", "orig", "c", "core", "Er", "fi", "test", "r", "min", "Error", "size"], "ic": ["icc", "oc", "gc", "anc", "irc", "ig", "ico", "mic", "ik", "wic", "ci", "icer", "x", "ex", "exc", "enc", "sys", "ia", "ace", "ix", "inc", "cl", "cci", "ican", "aci", "icing", "pc", "sci", "ai", "cc", "cli", "u", "ics", "aic", "IC", "mc", "nic", "acl", "ck", "dc", "lic", "iac", "ctx", "ici", "bc", "cu", "exec", "p", "ec", "pic", "xt", "acs", "c", "cit", "ip", "ct", "lc", "fc", "ac", "vc", "fi", "rec", "isc", "xc", "tc"], "st": ["est", "dr", "play", "style", "et", "stream", "f", "St", "td", "sd", "public", "stage", "ft", "sp", "sa", "ct", "lc", "ess", "ast", "nd", "sty", "nt", "sw", "lt", "art", "pt", " est", "sl", "sc", "sth", "sh", "mt", "ts", "str", "sta", "ut", "ld", "back", "test", "end", "std", "fr", "ste", "sr", "ost", "sn", "ust", "ad", "th", "cl", "post", "sb", "ist", "inst", "stem", "t", "p", "be", "start", "c", "tt", "put", "set", "src", "cr", "rd", "stack", "sts", "de", "rest", "fe", "us", "ss", "kt", "stop", "se", "ST", "bl", "stall", "first"], "codec": [" codic", " codenc", "contec", "cheect", "legerc", "codeus", " codrec", " codeco", "contcode", "modac", "oddec", "CodEC", " coderer", "pedeco", "modec", "codenc", "celec", "modcode", "cheec", "coderc", "codeenc", "oxyEC", " codect", "dependenc", " coddec", "Codesc", "codeEC", "codeac", "codeeco", "layec", "logeco", "congenc", "codaque", "congeus", "odec", "codeco", " coder", "codeaque", "codeerer", " codaque", "coderer", "dependec", "codeca", "contac", "coderec", "logoc", "layeus", "Codect", "casteus", "logeus", "cheuc", "codeer", "odeus", "codeeca", "pedesc", "coder", "castec", "odeca", "odoc", "legec", "codeuc", "Coduc", "coddec", "modeus", "predect", "projectac", "casteco", "oxyec", "layuc", "oder", "codeoc", "codedec", "Codoc", "codac", " codEC", "oduc", "odac", "odEC", "logec", "codrec", "projectec", " coderc", "pedec", "Codec", "consterer", "celic", " coduc", "legoc", "pedEC", "codoc", "layoc", "codeic", "odenc", "celEC", "codEC", "oxyesc", "predeus", "codesc", "Codac", "congac", "Codeca", "projectect", "codeec", "predec", "odeco", "predenc", "Coddec", "codeeus", "codeesc", "constec", " codeus", "odesc", "coduc", "constesc", " codesc", "codeect", "castoc", " codac", " codeca", "legrec", "oxyeco", "cheEC", "codcode", "conteus", "odect", "logect", "codect", "Codenc", "congec", " codcode", "celeco", "logaque", "codeerc", "dependeus", "codic", " codoc", "Codeus", "dependac"]}}
{"project": "FFmpeg", "commit_id": "ff763351e74550df3b9a0465634d1ec48b15b043", "target": 1, "func": "static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}", "idx": 6165, "substitutes": {"ctx": ["cp", "cmp", "anc", "ci", "scope", "rc", "cca", "tx", "pc", "cc", "init", "cs", "np", "sc", "cam", "conn", "bc", "cms", "fp", "Context", "context", "ca", "c", "ct", "sq", "cf", "lc", "cv", "src", "cpp", "cas", "cm", "pkg", "xc", "tc"], "s": ["o", "ans", "sets", "sr", "is", "S", "spec", "sg", "scope", "si", "i", "sync", "sys", "ses", "services", "xs", "f", "ns", "sl", "ls", "cs", "ss", "e", "sc", "sb", "gs", "se", "ks", "ops", "qs", "ds", "n", "ts", "self", "context", "p", "this", "sv", "fs", "sa", "c", "os", "g", "sym", "sq", "ssl", "src", "rs", "ps", "js"]}}
{"project": "qemu", "commit_id": "47e04430ed3e6ab835f023a5c84381ca2ce9f4d8", "target": 0, "func": "static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,\n\n                                             DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t off10;\n\n    int32_t r1, r2;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_BO_S1D(ctx->opcode);\n\n    r2  = MASK_OP_BO_S2(ctx->opcode);\n\n    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);\n\n    op2 = MASK_OP_BO_OP2(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_BO_CACHEA_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_W_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_I_SHORTOFF:\n\n        /* instruction to access the cache */\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_POSTINC:\n\n    case OPC2_32_BO_CACHEA_W_POSTINC:\n\n    case OPC2_32_BO_CACHEA_I_POSTINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_PREINC:\n\n    case OPC2_32_BO_CACHEA_W_PREINC:\n\n    case OPC2_32_BO_CACHEA_I_PREINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEI_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEI_W_SHORTOFF:\n\n        /* TODO: Raise illegal opcode trap,\n\n                 if tricore_feature(TRICORE_FEATURE_13) */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_POSTINC:\n\n    case OPC2_32_BO_CACHEI_WI_POSTINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_PREINC:\n\n    case OPC2_32_BO_CACHEI_WI_PREINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_ST_A_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_A_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LESL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_A_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_B_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_B_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_UB);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_B_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_D_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_D_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_D_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_H_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_H_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_H_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_SHORTOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_POSTINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_W_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    case OPC2_32_BO_ST_W_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_W_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    }\n\n}\n", "idx": 6186, "substitutes": {"env": ["eng", "cfg", "ea", "vm", "config", "environment", "exc", "style", "stack", "enc", "queue", "eu", "buf", "db", "tx", "iss", "cli", "ev", "np", "impl", "e", "priv", "que", "en", "inst", "dev", "cb", "loader", "enh", "context", "ec", "req", "viron", "iv", "console", "erv", "dep", "chal", "engine", "prov", "conn"], "ctx": ["std", "cmp", "hw", "anc", "kn", "wx", "ci", "scope", "config", "nc", "rc", "exc", "cca", "sync", "loc", "tx", "mac", "sk", "conv", "obj", "cc", "cli", "sci", "conf", "cs", "ck", "sc", "cam", "func", "cmd", "wcs", "exec", "cb", "Context", "cu", "context", "kw", "ca", "ctrl", "qa", "this", "kb", "utils", "c", "sq", "cf", "cn", "lc", "cv", "vc", "src", "cas", "conn", "pkg"], "op2": ["op02", "OP3", "op0", "option3", "oper3", "oper32", "hop1", "oper1", "oper20", "OP0", "OP2", " op10", "op10", "hop0", "oper02", "OP20", "option02", "OP1", " op20", "op32", "option10", "op3", "option2", " op02", " op32", "hop3", "op20", "op1", "oper0", "oper2", "OP32", "oper10", " op3", "hop2"], "off10": ["down50", "out30", "off50", " off20", " off110", "down10", "out10", " off40", "OFF20", "out50", "ext10", "down40", "out40", " off15", "down110", "off110", "off40", "OFF090", "OFF40", " off30", "off090", "OFF110", "down30", " off090", "OFF30", "ext090", "OFF15", "off20", "off30", "down15", "OFF10", " off50", "down20", "ext30", "off15"], "r1": ["p2", " r8", "R2", "p8", "p11", " r3", "r8", "r3", "R3", "r11", "R11", "R8", "R1", "p1", "p3", " r11"], "r2": ["p02", "r02", " rtwo", "errtwo", "rc5", "rc0", "rTwo", "p2", "rcall", "hrall", "rc1", "l2", "dr2", "l62", " r5", "vr2", "R2", "rc62", "r62", "rall", " r3", "RTwo", "r3", "vrTwo", "R3", "l1", " rTwo", "R0", "r5", "hrtwo", "err62", "hr62", "R1", "l5", "p1", "errall", "vr5", "drtwo", "dr02", "rc2", "R02", "rtwo", "R62", "R5", " r0", "p3", " r02", "r0", "rctwo", "dr1", "err2", " r62", "Rtwo", "vr1", "hr2"], "temp": [" ret", "gi", " v", "gc", "cfg", " generator", "v", "tmp", "vt", " buffer", "data", "buf", "null", " vec", "buffer", "w", "out", " output", " gp", "output", "gb", "var", "tk", "vv", "vc", " tmp", "Temp"]}}
{"project": "qemu", "commit_id": "bee62662a312b99b4418b558a99b3963a4cbff07", "target": 0, "func": "static int kvm_mips_get_fpu_registers(CPUState *cs)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int err, ret = 0;\n\n    unsigned int i;\n\n\n\n    /* Only get FPU state if we're emulating a CPU with an FPU */\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        /* FPU Control Registers */\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,\n\n                                    &env->active_fpu.fcr0);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_IR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        }\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,\n\n                                    &env->active_fpu.fcr31);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_CSR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        } else {\n\n            restore_fp_status(env);\n\n        }\n\n\n\n        /* Floating point registers */\n\n        for (i = 0; i < 32; ++i) {\n\n            if (env->CP0_Status & (1 << CP0St_FR)) {\n\n                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),\n\n                                              &env->active_fpu.fpr[i].d);\n\n            } else {\n\n                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),\n\n                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);\n\n            }\n\n            if (err < 0) {\n\n                DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", __func__, i, err);\n\n                ret = err;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 6189, "substitutes": {"cs": ["cp", "cks", "spec", "ci", "nc", "rc", "cus", "sync", "ced", "cells", "sys", "cing", "ace", "js", "ix", "sk", "ns", "ls", "pc", "cc", "bs", "cons", "CS", "vs", "sc", "code", "gs", "ks", "ds", "qs", "cer", "ctx", "ces", "cms", "cb", "wcs", "ec", "css", "fs", "acs", "c", "ys", "cn", "lc", "core", "cf", "ms", "vc", "cache", "rs", "ras", "cas", "conn"], "cpu": ["cp", "bench", "cfg", "CP", "chip", "platform", "pu", "vm", "component", "config", "sys", "gpu", "cm", "uci", "pc", "cli", "np", " cp", "instance", "ctx", "pec", "processor", "ec", "boot", "css", "fs", "proc", "c", "node", "cn", "lc", "core", "cf", "fc", "cache", "fi", "CPU", "conn"], "env": ["energy", "el", "eff", "environment", "oa", "ace", "gu", "gui", "state", "conf", "ev", "zone", "her", "exec", "equ", "Environment", "ou", "ec", "engine", "conn", "vm", "spec", "config", "edge", "nc", "module", "eu", "inet", "server", "iss", "eb", "em", "ctx", "ee", "ne", "settings", "viron", "cf", "site", " environment", "eng", "er", "hw", "esp", "exc", "agent", "db", "export", "ext", "obj", "cli", "net", "ce", "np", "vs", "e", "oe", "que", "en", "dev", "c", "core", "lv", "cache", "loader", "dict", "cfg", "anc", "ea", "v", "scope", "session", "enc", "args", "priv", "estate", "pec", "context", "req", "eni", "console", "skin"], "err": ["dr", "irm", "iter", "orr", "ise", "ll", "status", "better", "magic", "code", "len", "error", "ar", "arr", "here", "good", "nil", "orer", "finder", "mr", "ver", "var", "off", "g", "resp", "Er", "kr", "ah", "arm", "try", "aster", "val", "rage", "eor", "grade", "nr", "later", "ait", " error", "str", "work", "usr", "runner", "yr", "type", "end", "er", "rt", "op", "rc", "erg", "ler", "j", "acer", "out", " Err", "more", "asm", "ner", "erer", "ind", "orig", "hr", " r", "r", "Error", "gr", " er", "nor", "far", "rr", "bug", "der", "rh", "ir", "attr", "order", "res", "init", "ry", "lr", "result", "wr", " result", "req", "br", "inner", "rar"], "i": ["gi", "r", "o", "er", "ti", "ret", "ui", "v", "I", "is", "id", "di", "ci", "ni", "b", "xi", "si", "io", "x", "ri", "slice", "info", "module", "in", "m", "qi", "bi", "ix", "l", "key", "f", "pi", "yi", "phi", "adi", "d", "ii", "iu", "j", "it", "ai", "esi", "init", "u", "e", "code", "uri", "t", "n", "multi", "ini", "ie", "p", "source", "temp", "mini", "eni", "z", "start", "c", "ip", "ind", "y", "api", "li", "anti", "fi", "index", "zi", "end"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,\n\n                                 int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson\";\n\n    TCGv t0, t1;\n\n\n\n    if (rd == 0) {\n\n        /* Treat as NOP. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n#endif\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"mult.g\";\n\n        break;\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n        tcg_gen_ext32u_tl(t0, t0);\n\n        tcg_gen_ext32u_tl(t1, t1);\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"multu.g\";\n\n        break;\n\n    case OPC_DIV_G_2E:\n\n    case OPC_DIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"div.g\";\n\n        break;\n\n    case OPC_DIVU_G_2E:\n\n    case OPC_DIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"divu.g\";\n\n        break;\n\n    case OPC_MOD_G_2E:\n\n    case OPC_MOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"mod.g\";\n\n        break;\n\n    case OPC_MODU_G_2E:\n\n    case OPC_MODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"modu.g\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmult.g\";\n\n        break;\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmultu.g\";\n\n        break;\n\n    case OPC_DDIV_G_2E:\n\n    case OPC_DDIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"ddiv.g\";\n\n        break;\n\n    case OPC_DDIVU_G_2E:\n\n    case OPC_DDIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"ddivu.g\";\n\n        break;\n\n    case OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 6193, "substitutes": {"ctx": ["abc", "cp", "cmp", "ci", "rc", "loc", "cm", "tx", "conv", "sci", "cc", "ck", "cam", "rx", "cb", "Context", "context", "ctrl", " context", "ca", "kb", "alloc", "txt", "cv", " cx", "cas", "grad", "conn", "xc"], "opc": ["OPcs", "ipc", "OPf", "ripn", "ipf", " opnc", "opnc", "ripc", " opC", "opb", "copn", "copnc", "ipcs", "opC", "OPc", "opcs", "ripf", "OPn", "copc", "opernc", "operc", " opf", " opb", "OPC", "operb", "ipC", " opcs", "ripC", "copb", "opern", "opf"], "rd": ["dr", "rn", "rw", "fr", "vr", "red", "sr", "aug", "od", "rr", "rid", "la", "dd", "dat", "RF", "rb", "rod", "aa", "lt", "ri", "rc", "rf", "pt", "rm", "loc", "rh", "db", "wb", "ru", "ra", "cd", "d", "rax", "td", "rost", "wd", "rect", "rg", "ren", "ds", "xd", "rx", "lr", "rl", "ha", "rin", "dra", "fail", "ld", "ind", "rat", "ct", "hr", "fd", "RR", "cn", "adr", "ud", "ord", "pl", "src", "ARR", "RS", "r", "lf", "bh", "rob", "nd", "RD"], "rs": ["dr", "rw", "vr", "cr", "sr", "pr", "rr", "ins", "sw", "rb", "RC", "tr", "rc", "rows", "rf", "rm", "xs", "ru", "ra", "ls", "res", "cs", "Rs", "ras", "ints", "rss", "ars", "rg", "ds", "rx", "lr", "rl", "rings", "mr", "src", "RS", "r", "ps"], "rt": ["irt", "dr", "rn", "fr", "vr", "ret", "rr", "rid", "nt", "rb", "vt", "rot", "lt", "tr", "rc", "rf", "ri", "art", "wt", "pt", "rm", "rh", "ru", "mt", "rss", "RT", "t", "rx", "rl", "rin", "ft", "ptr", "ct", "gt", "adr", "addr", "r", "RC", "rec", "nd"], "opn": [" opcn", "opN", "opr", "operns", "optN", " opN", "ropr", "opercn", "Opn", "opert", "optr", "optc", "optn", "Opns", " opr", "ropn", "opns", "operc", "Opc", "opcn", " opns", "operr", "opt", "ropc", "Opcn", "ropt", " opt", "opern", "operN"], "t0": ["ret0", "T2", " t000", "pt0", " mt0", "pt3", "t9", "T050", " t4", "l0", "te50", " mt1", "te1", " t8", " tau", "te00", "t50", "T0", " mt50", "ret1", "t4", "tt50", "tau", "ret00", "nt0", "ta50", "T1", "te0", "t3", "nt1", "tt9", " mt9", "T50", "nt050", " t050", "l1", "T3", "tt1", "t2", "pt8", "tty0", "f2", "tt0", "nt50", " t9", "l000", "te3", "f4", "T00", "ttyau", "T4", "tty00", "f0", "t050", " t2", "ta0", "l50", "pt1", "tty1", "ta000", "T8", "t000", " t3", "ta1", "f1", "t00", "t8", " t50", " t00", "retau"], "t1": ["pt0", "t100", " t4", "wt1", "wt001", "tie4", "ntONE", "unt81", "t151", "nt1", " t100", "tt1", "pt8", "Tone", "tty100", "tty1", "taone", "kt0", "ta1", "it0", "Tapp", "tty127", "t110", "t121", "tie0", "dtapp", "tie1", "T121", "unt1", "ta2", "nt0", "T1", "pt4", "ptarg", "wt81", "TONE", "pone", "p0", "T4", "unt001", "wt127", "dt0", "pt1", "T8", "t2", "t001", "tt110", "unt127", "tONE", "itONE", "p1", "tiearg", "t81", "tapp", "ta0", " t151", "kt1", "tty001", "ttyapp", "tty81", "t8", "Targ", "tty110", "T2", "dt1", "targ", "it121", "T151", "kt4", "ttyONE", "kt151", "p2", "T0", "t4", "pt5", "t127", "dtONE", "tty0", "nt121", "it1", "t5", "tt100", " t110", " t5", "tone", "T5", " t8"]}}
{"project": "qemu", "commit_id": "7d489dcdf5fd71b5052ffd401b869a627e1c751f", "target": 0, "func": "static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6196, "substitutes": {"vdev": ["lev", "vdd", " vdata", "vecase", "svconn", "nvdevice", "vdc", "pdev", "lver", "wdev", " verror", "navprivate", "avdevice", "pver", "ndie", " vver", "lconn", " vdi", "lconf", "avdev", "vself", "Vdef", "vtr", "gdev", "vconn", "vdie", "lde", "veerror", "Vev", " vtr", "vdi", " vdevelopment", "vdiff", "tvdebug", "vver", "vapp", "ldevelopment", "avdd", " vdebug", "ltr", "svver", "evver", "svdd", "ldef", "ldevice", "lself", "svdiff", "verror", "ldie", " vself", "nvdev", "nev", "tvdevice", "vconf", "lapp", "lerror", "svdev", "Vconf", "svde", "tvdevelopment", "svdi", "gdevice", "navdev", "vdevice", "ndevice", "svdc", "tvdev", "gapp", "ldc", "pev", "ldiff", "svdata", "ldebug", " vev", "svev", "vdevelopment", "gde", "evvar", "nvvar", "vdef", "svdevice", "vev", "ldev", "mdevice", "vde", "Vdev", "wdevice", "mdev", "vedev", "avde", "pprivate", "navev", "Vdd", "Verror", "lcase", "ldi", "evdc", "ldata", "vdata", "vedef", " vde", "wev", "mvar", " vdie", "Vdevice", "Vde", " vdevice", "ndev", "wtr", "evdev", " vapp", "evev", " vdiff", "evdevice", "navver", " vconn", "Vcase", "Vver", " vconf", "vdebug", "svself", "Vprivate", "mver", "vprivate", "nvver", "vcase", "vvar"], "size": ["position", "large", "ci", "shape", "data", "i", "oa", "unit", "speed", "sector", "code", "len", "empty", "zero", "g", "max", "cm", "mode", "function", "name", "SIZE", "count", "fee", "value", "sum", "slice", "capacity", "member", "six", "sized", "scale", "range", "type", "false", "address", "area", "time", "sec", "use", "sync", "now", "loc", "num", "small", "Size", "cs", "e", "timeout", "network", "pos", "global", "c", "core", "complete", "si", "offset", "length", "args", "handle", "storage", "n", "memory", "ize", "needed"], "bytes": ["nos", "tes", "files", "gets", "sec", "les", "rules", "count", "bits", "fee", "total", "s", "users", "runs", "nets", "abytes", "values", "allows", "io", "data", "bps", "rows", "cells", "Bytes", "ones", "ips", "offset", "codes", "parts", "ns", "cycles", "used", "flows", "forces", "args", "ls", "bs", "byte", "cs", "vs", "len", "units", "classes", "ops", "out", "seconds", "full", "raw", "pages", "zip", "ks", "steps", "outs", "ipes", "eps", "blocks", "boot", "css", "pieces", "charges", "settings", "os", "errors", "loads", "items", "es", "lines", "reads"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "substitutes": {"ctx": ["cp", "cmp", "gc", "anc", "cr", "fw", "ci", "config", "nc", "rc", "cca", "sync", "cus", "comp", "loc", "cm", "support", "tx", "cl", "event", "client", "ga", "call", "pc", "cc", "cli", "cs", "ck", "sc", "connection", "conn", "cmd", "instance", "bc", "cb", "cms", "Context", "cu", "jp", "context", "kw", "ca", "qa", "css", "req", "c", "ct", "cn", "cf", "lc", "thread", "util", "fc", "cv", "vc", "cas", "grad", "ctrl", "pkg", "xc", "tc"], "blocking": ["padding", "using", "regular", "block", "testing", "http", "complete", "starting", "including", "loading", "successful", "rolling", "ocking", "cl", "client", "background", "enabled", "cli", "locking", "buffer", "exclusive", "full", "calling", "bc", "working", "exec", "interrupted", "running", "blocks", "restricted", "protected", "locked", "ssl", "bl", "partial", "quiet", "prefix"]}}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "substitutes": {"data": ["pack", "append", "a", "parent", "done", "di", "dat", "device", "dd", "config", "val", "sync", "info", "buf", "window", "valid", "package", "d", "init", "DATA", " DATA", "def", "buffer", "connection", "ops", "da", "Data", "timeout", "exec", "multi", "devices", "result", "array", "input", "p", "reader", "batch", "proc", "cache", "next"], "dev": ["hw", "reg", "od", "v", "prof", "id", "rad", "pu", "pro", "di", "Dev", "dd", "device", "adv", "md", "config", "plug", "bug", "tr", "rc", "ow", "enc", "ad", "info", "debug", "der", "valid", "gu", "package", "d", "ve", "mod", "fo", "dist", "conf", "ev", "def", "DEV", "wd", "priv", "prom", "w", "error", "da", "dc", "driver", "self", "pub", "serial", "req", "boot", "ver", "gh", "var", "off", "node", "api", "engine", "cache", "app", "vc", "prov", "grad", "conn", "diff"], "bus": ["plugin", "base", "cmp", "build", "feed", "block", "hub", "local", "http", "pu", "BUS", "device", "config", "plug", "bug", "b", "io", "sync", "bit", "cat", "Bus", "buf", "db", "usb", "book", "us", "def", "mount", "connection", "driver", "port", "lib", "path", "ux", "bc", "pass", "self", "bridge", "pub", "serial", "this", "boot", "proc", "os", "class", "board", "pl", "cache", "test", "index", "fi", "conn"], "tx": ["rw", "ti", "pull", "wx", "trial", "device", "x", "tr", "ax", "raf", "sync", "rc", "rel", "co", "pt", "TX", "fx", "loc", "der", "ty", "ix", "ran", "ra", "pc", "q", "def", "ck", "mc", "w", "auth", "t", "ctx", "ux", "bc", "Tx", "context", "temp", "ca", "req", "reader", "trans", "gh", "ta", "txt", "cf", "ac", "cache", "test", "cross", "cas", "worker", "tc"], "rx": ["rw", "vr", "rt", "fw", "rr", "wx", "eth", "rb", "x", "ri", "rc", "raf", "rd", "rf", "ax", "rel", "wa", "co", "sync", "loc", "fx", "rh", "ru", "ra", "rou", "nr", "pc", "ry", "wd", "ck", "rss", "rg", "ctx", "ux", "lr", "rl", "rin", "req", "lex", "reader", "mr", "src", "rs", "r", "xc"], "alloc": ["vol", "oc", "cmp", "afi", "hw", "anc", "pack", "mem", "wx", "pu", "fee", "config", "rac", "rc", "raf", "enc", "auc", "uc", "loc", "buf", "valid", "mac", "capacity", "ga", "attr", "soc", "org", "win", "pc", "ack", "init", "oca", "conf", "acl", "sc", "random", "ctx", "ux", "exec", "cu", "bc", "voc", "go", "coll", "nil", "pool", "access", "ec", "req", "gen", "toc", "c", "addr", "util", "asc", "ac", "isc", "aux", "au", "cache", "loader", "vc", "conn", "pkg", "aw"], "func": ["function", "unc", " function", "wrapper", "rb", "val", "nc", "sync", "lambda", "sys", "module", "buf", "package", "f", "call", "obj", "pc", "cc", "loop", "code", "fn", "lib", "Function", "bc", "cb", "dll", "exec", "callback", "work", "self", "fun", "proc", "class", "cf", "lc", "fc", "addr", "src", "conn", "worker"], "rvq": ["rpw", "rpq", "RvQ", "Rvw", "rvw", "Rpw", "rvvQ", "rvvflow", "rpflow", "Rpq", "rvvw", "rvvq", "rww", "rwflow", "Rvflow", "RpQ", "rvflow", "Rpflow", "rwQ", "rvQ", "Rvq", "rwq", "rpQ"], "tvq": ["voltq", "tvqueue", "voltqa", "vuq", "uvqueue", "voltqs", "uvqs", "tvqs", "vuqs", "uvqa", "vuqa", "uvq", "tvqa", "vuqueue", "voltqueue"], "socket": ["sf", "channel", "config", "ockets", "ocket", " sock", "sync", "sn", "stream", "buf", "server", "sl", "ss", "port", " sockets", "timeout", "seq", "pool", "cpu", "proc", "ssl", "sq", "src", "conn", "Socket", "slot"], "sv": ["nv", "ipt", "serv", "sf", "v", "s", "vt", "si", "sn", "sys", "services", "vector", "uv", "status", "isl", "db", "csv", "null", " SV", "sk", "support", "sl", "sm", "series", "av", "service", "ss", "vi", "vs", "sh", "via", "sb", "sql", "zip", "sd", "ds", "timeout", "su", "temp", "ft", "sp", "iv", "vl", "ssl", "sq", "lv", "api", "ov", "vv", "cv", "vc"], "ret": ["flag", "reg", "no", "mem", "rt", "cur", "alt", "nt", "pin", "val", "rc", "inter", "bit", "reply", "status", "valid", "fin", "f", "lit", "att", "arg", "res", "len", "code", "det", "en", "RET", "ben", "pass", "result", "Ret", "ft", "re", "fun", "success", "ref", "fi", "addr", "r", "rets"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n", "idx": 6241, "substitutes": {"str": ["dr", "fr", "ocr", "er", "st", "sr", "cr", "iter", "pr", "rr", "s", "tr", "style", "enc", "obj", "res", "ctr", "arr", "empty", "exec", "Str", "doc", "txt", "hr", "STR", "br", "inner", "text", "test", "kr", "rs", "r", "stri"], "err": ["dr", "gr", "fr", "er", "cr", "iter", "pr", "rr", "count", "aster", "bug", "rc", "der", "valid", "rh", "ler", "order", "nr", "res", "later", "code", "e", "error", "ar", "arr", "good", "lr", "rev", "result", "req", "ner", "ver", "ind", "var", "resp", "br", "Er", "r", "Error", "msg"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_validate_certificate(struct VncState *vs)\n\n{\n\n    int ret;\n\n    unsigned int status;\n\n    const gnutls_datum_t *certs;\n\n    unsigned int nCerts, i;\n\n    time_t now;\n\n\n\n    VNC_DEBUG(\"Validating client certificate\\n\");\n\n    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {\n\n\tVNC_DEBUG(\"Verify failed %s\\n\", gnutls_strerror(ret));\n\n\treturn -1;\n\n    }\n\n\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n\n\treturn -1;\n\n    }\n\n\n\n    if (status != 0) {\n\n\tif (status & GNUTLS_CERT_INVALID)\n\n\t    VNC_DEBUG(\"The certificate is not trusted.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\n\t    VNC_DEBUG(\"The certificate hasn't got a known issuer.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_REVOKED)\n\n\t    VNC_DEBUG(\"The certificate has been revoked.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6243, "substitutes": {"vs": ["verts", "v", "http", "s", "alls", "va", "session", "vt", "ums", "VS", "ses", "services", "sts", "xs", "vals", "sk", "ants", "ns", "server", "ls", "iss", "bs", "ss", "cs", "hs", "sb", "gs", "ks", "ops", "ds", "qs", "ts", "ils", "settings", "vers", "vp", "sv", "fs", "changes", "os", "ms", "env", "vc", "es", "rs", "versions", "manager", "ps"], "ret": ["stat", "base", "er", "flag", "sr", "reg", "mem", "al", " success", "alt", "iter", "rt", "progress", "value", "pre", "val", "tr", "rc", "info", "reply", "ll", "pret", "repl", "f", "lit", "job", "att", "pet", " resp", "obj", "res", "len", "det", "RET", "rev", "result", " result", "Ret", "ft", "ut", "re", "fail", "fun", " fut", "detail", "back", "resp", "Status", "success", "ref", " r", "r", "rets"], "status": ["stat", "login", "name", "gc", "flag", "sr", "sec", "id", "complete", "spec", "progress", "note", "security", "session", "update", "skip", "si", "sync", "style", "sys", "info", "speed", "html", "content", "f", "state", "server", "wait", "version", "active", "grade", "service", "stats", "match", "reason", "confirmed", "code", "error", "sb", "comment", "message", "received", "sign", "err", "str", "score", "result", "seq", "source", "temp", "rate", "ity", "settings", "stage", "sp", "fs", "ssl", "type", "Status", "success", "current", "git", "index", "site", "date", "summary", "flags", "msg"], "certs": ["Certd", "privp", "privs", "signp", "certls", "Certb", "Certp", " certes", "Certi", "Certls", " certls", "certb", "Certs", "signb", "certp", "signls", "reqs", "certes", "signes", "privd", "prives", "reqp", "reqd", "reqes", "reqb", "signi", "Certes", "signs", "certd", " certi", "certi"], "nCerts": [" nCertd", "pCertis", "nCertis", " nCuri", "nCookis", "pcertes", "pcertp", "nSigni", "nCookes", "ncertes", "nCurc", "pCertp", "nCookp", "nSignn", " nCurd", "nCertn", "pCertes", " nCertc", "ncertd", "pCerts", "nCerti", "nCertes", "ncerti", "nSignp", " nCurs", "ncerts", "nCuri", " nCertns", "nSignes", "nCertc", "nLogd", "ncertis", " nCerti", "ncertp", "nCooks", "nLogs", "nSignns", "ncertn", "pcertis", "nSigns", "nLogi", "pcerts", "nCertp", " nCurc", "nSignis", "nCertd", "nCurd", "ncertc", "nCertns", "nCurs", "ncertns", " nCertn", "nLogc"], "i": ["gi", "ti", "v", "id", "I", "di", "ci", "ni", "xi", "ri", "si", "io", "slice", "b", "info", "bi", "qi", "ix", "inc", "l", "yi", "pi", "f", "phi", "j", "ii", "iu", "d", "it", "ai", "u", "e", "t", "n", "multi", "mi", "ini", "ie", "p", "mini", "h", "eni", "z", "sup", "ind", "ip", "c", "g", "y", "type", "li", "fi", "index", "zi", "ui"], "now": ["function", "time", "st", "no", "gm", "id", "md", "not", "parent", "v", "since", "omp", "session", "get", " current", "or", "comp", "NOW", "night", "today", "at", "wait", "j", "length", " NOW", "create", "from", "Now", "low", "created", "func", "day", "df", "after", "ctx", " Now", "self", "result", "old", "this", "start", "import", "new", "mm", "off", "type", "current", "next", "form", "age", "date", "max", "size"], "cert": ["cp", "name", "ch", "cur", "alt", "pr", "dat", "chain", "config", "val", "non", "secret", "ificate", "cat", "dest", "pt", "trust", "key", " Cert", "resource", "cl", "valid", "ext", "Cert", "order", "url", "j", "sl", "ctr", "ert", "ce", "crit", "priv", "sign", "fac", "err", "str", "pub", "temp", "ca", "req", "font", "opt", "sp", "ver", "gen", "ind", "cand", "ssl", "class", "type", "cf", "user", "br", "pair", "pl", "cot", "cel"]}}
{"project": "qemu", "commit_id": "85df0de4cfe54fd64df7e37448cd152d0c9199a4", "target": 0, "func": "int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n", "idx": 6251, "substitutes": {"opaque": [" opec", "defaques", "ophole", " opoch", "defaque", "oaque", "Ophole", "defec", "Opaque", "oec", "operaque", "oacity", "defacity", " ophole", "operhole", "opec", "Opacity", "operoch", " opacity", "opaques", "operacity", "opoch", "Opoch", "opacity", " opaques", "oaques"], "key": ["play", "entry", "x", "token", "ace", "trust", "sk", "match", "code", "kind", "any", "connection", "col", "error", "here", "cor", "kid", "hop", "ver", "lc", "query", "ac", "max", "conn", "mode", "base", "name", "row", "mix", "id", "count", "fee", "parent", "channel", "value", "pe", "url", "ak", "close", "ctx", "sign", "ask", "work", "ie", "ee", "ke", "ip", "hash", "rule", "type", "Key", "element", "no", "patch", "act", "block", "sec", "change", "op", "keys", "ce", "ck", "oy", "ame", "k", "year", "ye", "start", "core", "ek", "cache", "seed", "prefix", "air", "lease", "secret", "enc", "cy", "mac", "order", "call", "length", "ack", "ry", "KEY", "part", "ype", "lock", "coll", "seq", "kw", "req", "pair", "date"], "callback": ["function", "CB", "cmp", "Callback", "buff", "method", "wrapper", "future", "value", "progress", "config", "consumer", "object", "sync", "token", "rc", "queue", "buf", "fb", "f", "client", "attr", "background", "call", "loop", "delay", "native", "buffer", "parser", "connection", "error", "message", "func", "fn", "forward", "timeout", "cb", "result", "array", "collection", "batch", "fun", "back", "closure", "handler", "class", "type", "success", "cache", "next", "conn", "worker"], "callback_opaque": ["callback_oaco", "callback_operacity", "callback_offacity", "callback_openacity", "callback_opaco", "callback_opque", "callback_oppaque", "callback_opacity", "callback_oppque", "callback_opity", "callback_copaque", "callback_operaco", "callback_paques", "callback_oity", "callback_oppity", "callback_paque", "callback_copity", "callback_operity", "callback_paco", "callback_oaques", "callback_operaque", "callback_offaques", "callback_offaco", "callback_oaque", "callback_openaco", "callback_copque", "callback_operaques", "callback_openaques", "callback_opaques", "callback_copaques", "callback_openaque", "callback_offaque", "callback_oppaques", "callback_pity"], "data": ["base", "open", "entry", "done", "dat", "value", "val", "ada", "format", "queue", "info", "body", "buf", "offset", "content", "media", "length", "DATA", "delay", "buffer", "size", "part", "arr", "message", "ata", "Data", "bytes", "cb", "response", "result", "seq", "input", "batch", "frame", "pos", "start", "read", "api", "cache", "next", "addr", "msg"], "len": ["lang", "base", "stat", "bin", "el", "mem", "block", "count", "fee", "lan", "list", "val", "enc", "loc", "buf", "l", "db", "fin", "offset", "lit", "f", "ler", "limit", "length", " length", "ls", "byte", "split", "delay", "buffer", "all", "lo", "part", "low", "en", "fn", "n", "err", "lon", "lock", "load", "seq", "msg", "z", "pos", "line", "fun", "Len", "ln", "lc", "lin", "li", "cache", "lf", "partial", "min", "conn", "size"], "s": ["o", "v", "is", "S", "a", "spec", "b", "si", "i", "sys", "ses", "services", "m", "states", "l", "f", "client", "ns", "d", "sl", "ls", "service", "ss", "cs", "u", "conf", "e", "sb", "gs", "ks", "ds", "qs", "n", "ts", "su", "p", "this", "settings", "h", "fs", "sa", "c", "os", "g", "ssl", "new", "es", "rs", "r", "ps", "js"]}}
{"project": "FFmpeg", "commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "target": 1, "func": "static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],\n\n                                   int order, int qlevel, int len, int bps)\n\n{\n\n    int i, j;\n\n    int ebps = 1 << (bps-1);\n\n    unsigned sigma = 0;\n\n\n\n    for (i = order; i < len; i++)\n\n        sigma |= decoded[i] + ebps;\n\n\n\n    if (sigma < 2*ebps)\n\n        return;\n\n\n\n    for (i = len - 1; i >= order; i--) {\n\n        int64_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (int64_t)decoded[i-order+j];\n\n        decoded[i] -= p >> qlevel;\n\n    }\n\n    for (i = order; i < len; i++, decoded++) {\n\n        int32_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (uint32_t)decoded[j];\n\n        decoded[j] += p >> qlevel;\n\n    }\n\n}\n", "idx": 6272, "substitutes": {"decoded": [" decrypted", "decloder", " decored", "ecoding", "collrypted", "ecored", "deccoded", "recoded", "eccoded", "decated", "declrypted", "decloded", "descoded", "DECcoded", " deccoded", "DECided", "enccoded", "encoder", "descored", " decoding", "declached", "collated", "reccoded", " decided", "encrypted", "declored", "declcoded", "recided", "DECrypted", "ecided", "decoder", "ecached", "encored", "DECoded", "decached", "desccoded", " decoder", "decored", "encated", "collided", "encoding", "encoded", "decided", "ecoder", "recrypted", "descached", "decrypted", "encided", "ecrypted", "decoding", "ecoded", " decated", "colloded"], "coeffs": ["coefficientsps", "cosss", " coeffses", "coeffp", " coefds", " coefes", "coeffices", "cossp", "coeffps", " coefs", "coefficures", "coefficientsds", "coefficses", "coEFFes", "coefficientss", " coffments", "cossps", "coeffures", "coefes", " coeffes", "coEFFps", "coeffics", " coffses", " coefps", " coeffps", "coefments", " coeffments", "coEFFures", "coefds", "coeffments", "coffs", "cossds", " coefp", "coEFFs", "coffments", "coeffds", " coeffures", "coefses", "coffes", "coefs", "coefp", "coefps", "coeffes", "coffses", "coefficientsp", " coeffds", "coefficps", " coeffp", "coeffses", "coefures", "coefficments", " coefures", " coffs", " coffes"], "order": ["base", "address", "row", "layer", "er", "position", "Order", "block", "id", "count", "alt", "shape", "sort", "pre", "ell", "style", "now", "record", "info", "der", "db", "offset", "player", "version", "limit", "length", "ordering", "ii", "grade", "ai", "dir", "rar", "code", "orders", "all", "degree", "error", "en", "random", "err", "rate", "p", "scale", "priority", "ORD", "vert", "start", "direction", "level", "rule", "off", "page", "ordered", "user", "asc", "ord", "rank", "test", "index", "r", "seed", "mode", "end", "size"], "qlevel": ["pplevel", "quval", "ppscale", "qval", "qlength", " qlength", "Qlevels", "Qwl", "qscale", "sqval", "qdepth", "qulevels", " qval", " qwl", "quvalue", "qindex", "qulength", "sqlevel", "quindex", "pdepth", "Qlevel", "pindex", "qwl", " qscale", "ppwl", "qlevels", "qvalue", "qulevel", "plevels", "qudepth", "pplevels", " qvalue", " qdepth", " qlevels", " qindex", "sqvalue", "plevel", "sqlength", "Qscale"], "len": ["base", "layer", "bin", "el", "iter", "count", "pre", "ell", "lt", "val", "elt", "lp", "ll", "l", "limit", "length", "ls", "fl", "split", "part", "all", "code", "en", "den", "n", "lon", "lock", "seq", "p", "z", "lvl", "pos", "line", "Len", "ln", "lin", "dl", "lc", "li", "lv", "bl", "pl", "lf", "lim"], "bps": ["points", "limits", "bp", "hops", "bits", "s", "offs", "pre", "hz", "b", "pp", "lp", "ips", "pins", "planes", "parts", "pps", "lins", "ns", "limit", "ls", "tips", "ops", "steps", "pages", "bis", "bytes", "pad", "ipes", "fps", "eps", "p", "blocks", "pieces", "items", "params", "lines", "ps"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "a", "di", "s", "ci", "ki", "ik", "ji", "ni", "x", "b", "si", "xi", "io", "ri", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "ii", "d", "iu", "my", "ai", "it", "u", "e", "part", "uri", "ori", "k", "n", "multi", "mi", "ini", "ie", "p", "eni", "z", "oi", "ind", "ip", "c", "y", "api", "li", "fi", "index", "zi", "ui"], "j": ["jet", "o", "v", "pr", "el", "a", "oj", "jl", "ju", "ji", "x", "b", "si", "bi", "m", "pt", "qi", "ix", "l", "bj", "key", "job", "f", "ij", "aj", "ii", "q", "it", "obj", "u", "e", "jen", "J", "je", "jc", "k", "t", "n", "uj", "jp", "jo", "ie", "p", "jit", "z", "jj", "g", "y", "ja", "br", "li", "ui", "js"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static int read_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic = NULL;\n\n    int err, i, ret;\n\n    int st_index[AVMEDIA_TYPE_NB];\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int eof = 0;\n\n    int pkt_in_play_range = 0;\n\n    AVDictionaryEntry *t;\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;\n\n    SDL_mutex *wait_mutex = SDL_CreateMutex();\n\n\n\n    memset(st_index, -1, sizeof(st_index));\n\n    is->last_video_stream = is->video_stream = -1;\n\n    is->last_audio_stream = is->audio_stream = -1;\n\n    is->last_subtitle_stream = is->subtitle_stream = -1;\n\n\n\n    ic = avformat_alloc_context();\n\n    ic->interrupt_callback.callback = decode_interrupt_cb;\n\n    ic->interrupt_callback.opaque = is;\n\n    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret = AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if (genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    err = avformat_find_stream_info(ic, opts);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    if (ic->pb)\n\n        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    if (seek_by_bytes < 0)\n\n        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT);\n\n\n\n    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    is->realtime = is_realtime(ic);\n\n\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_VIDEO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n\n                                wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n\n    if (!audio_disable)\n\n        st_index[AVMEDIA_TYPE_AUDIO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n\n                                wanted_stream[AVMEDIA_TYPE_AUDIO],\n\n                                st_index[AVMEDIA_TYPE_VIDEO],\n\n                                NULL, 0);\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n\n                                wanted_stream[AVMEDIA_TYPE_SUBTITLE],\n\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n\n                                NULL, 0);\n\n    if (show_status) {\n\n        av_dump_format(ic, 0, is->filename, 0);\n\n    }\n\n\n\n    is->show_mode = show_mode;\n\n\n\n    /* open the streams */\n\n    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n\n    }\n\n\n\n    ret = -1;\n\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n\n        ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n\n    }\n\n    if (is->show_mode == SHOW_MODE_NONE)\n\n        is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;\n\n\n\n    is->refresh_tid = SDL_CreateThread(refresh_thread, is);\n\n\n\n    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    if (infinite_buffer < 0 && is->realtime)\n\n        infinite_buffer = 1;\n\n\n\n    for (;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                is->read_pause_return = av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL\n\n        if (is->paused &&\n\n                (!strcmp(ic->iformat->name, \"rtsp\") ||\n\n                 (ic->pb && !strncmp(input_filename, \"mmsh:\", 5)))) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int64_t seek_target = is->seek_pos;\n\n            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n\n            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n\n//      of the seek_pos/seek_rel variables\n\n\n\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            } else {\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n                if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n\n                   //FIXME: use a cleaner way to signal obsolete external clock...\n\n                   update_external_clock_pts(is, (double)AV_NOPTS_VALUE);\n\n                } else {\n\n                   update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n            eof = 0;\n\n            if (is->paused)\n\n                step_to_next_frame(is);\n\n        }\n\n        if (is->queue_attachments_req) {\n\n            avformat_queue_attached_pictures(ic);\n\n            is->queue_attachments_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (infinite_buffer<1 &&\n\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n\n            || (   (is->audioq   .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)\n\n                && (is->videoq   .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request)\n\n                && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) {\n\n            /* wait 10 ms */\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        if (eof) {\n\n            if (is->video_stream >= 0) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->video_stream;\n\n                packet_queue_put(&is->videoq, pkt);\n\n            }\n\n            if (is->audio_stream >= 0 &&\n\n                is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->audio_stream;\n\n                packet_queue_put(&is->audioq, pkt);\n\n            }\n\n            SDL_Delay(10);\n\n            if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) {\n\n                if (loop != 1 && (!loop || --loop)) {\n\n                    stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n\n                } else if (autoexit) {\n\n                    ret = AVERROR_EOF;\n\n                    goto fail;\n\n                }\n\n            }\n\n            eof=0;\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret == AVERROR_EOF || url_feof(ic->pb))\n\n                eof = 1;\n\n            if (ic->pb && ic->pb->error)\n\n                break;\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n\n                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *\n\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n\n                <= ((double)duration / 1000000);\n\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        avformat_close_input(&is->ic);\n\n    }\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    SDL_DestroyMutex(wait_mutex);\n\n    return 0;\n\n}\n", "idx": 6277, "substitutes": {"arg": ["lang", "abc", "ig", "play", "ag", "Ar", "AT", "val", "rc", "inter", "enc", "or", "ad", "loc", "ace", "API", "BB", "inc", "mac", "argument", "call", "args", "pc", "param", "arc", "ar", "arr", "ang", "parse", "AR", "Arg", "var", "g", "lc", "util", "ac", "fi", "par", "rec"], "is": ["isi", "ris", "ib", "ik", "ci", "x", "IS", "bi", "iris", "pi", "bs", "ar", "any", "self", "ac", "oc", "irc", "id", "parent", "s", "info", "its", "was", "ls", "it", "iss", "uri", "bis", "mi", "ini", "ie", "ais", "ip", "iso", "isc", "ui", "as", "kit", "act", "lis", "ri", "or", "isl", "has", "isu", "esi", "isa", "cs", "ics", "sis", "mis", "ist", "instance", "p", "css", "os", "can", "im", "api", "ish", "cache", "app", "next", "Is", "http", "get", "si", "sys", "in", "ists", "init", "us", "iv", "pic", "es"], "ic": ["icc", "oc", "script", "gc", "ch", "irc", "act", "ig", "mic", "ik", "icer", "ci", "wic", "x", "op", "rc", "sync", "cy", "enc", "co", "bi", "ia", "ix", "inc", "cl", "ict", "pi", "cci", "ican", "aci", "pc", "ai", "init", "cli", "sci", "ics", "aic", "IC", "nic", "acl", "ck", "mc", "lic", "iac", "lib", "ici", "ctx", "cu", "exec", "ini", "voc", "bc", "ec", "pic", "bank", "ht", "c", "ip", "cit", "ct", "im", "lc", "fc", "ac", "vc", "fi", "isc", "xc", "tc"], "err": ["dr", "gr", "fr", " er", "er", "ch", "sr", "iter", "arm", "pr", "rr", "try", "aster", "bug", "val", "exc", "ise", "loc", "status", "der", "rh", "ir", "attr", "ler", "order", "call", "nr", "magic", "init", "res", "acer", "conf", "rar", "code", "len", "e", "error", "ar", "die", "arr", "dev", " error", "here", "rx", "cb", "str", "lr", "result", "end", "wr", "req", "usr", "runner", "ner", "mr", "doc", "erer", "ver", "ind", "yr", "orig", "resp", "br", "inner", "Er", "test", "kr", "r", "Error", "msg"], "i": ["gi", "r", "ti", "iter", "v", "id", "chi", "I", "ik", "di", "ci", "ki", "ni", "xi", "ri", "si", "b", "x", "abi", "info", "bi", "in", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "ii", "iu", "it", "ai", "init", "u", "e", "ami", "uri", "n", "multi", "mi", "ini", "p", "h", "eni", "z", "oi", "hi", "ind", "ip", "g", "c", "y", "lc", "li", "inner", "fi", "index", "zi", "mu", "ui"], "ret": ["fat", "flag", "reg", "iter", "rt", "alt", "nt", "pat", "rot", "lt", "val", "et", "bit", "cat", "let", "reply", "status", "num", "fin", "lit", " Ret", "att", "res", "def", "len", "mt", "part", "det", "arr", "RET", "sat", "bc", "str", "rev", "result", "Ret", "ft", "ut", "ver", "fun", "resp", "gt", "success", "ref", "rets"], "st_index": ["stallindex", "stlexind", "stipoffset", "storage_data", "storage_offset", "stream_thread", "storage_index", "storagelexdata", "stream_index", "stayoffset", "storagelexoffset", "storagelexindex", "stalloffset", "stream_id", "St_body", "stayindex", "staybody", "st1index", "stipind", "stlexoffset", "st_thread", "storage_ind", "st1thread", "st_body", "st_ind", "St_offset", "stipdata", "st_connection", "stayconnection", "stipindex", "St_index", "st1position", "st_data", "st_position", "stallbody", "st_offset", "storagelexind", "stlexdata", "stlexindex", "st_id", "St_connection", "st1id", "stallconnection", "stream_position"], "pkt1": ["pce0", "packet0", "Pkt3", "pct1", "pkg2", "Pkt2", "pce3", "pct3", "pkt0", "pkg4", " pkt0", "Packet0", " packet4", "packet3", "pct2", "packet2", " packet1", "Packet3", "pct0", " packet2", "packet4", "packet1", "pce2", " pkt2", "pce1", "pkt4", " pkt4", "pct4", "Pkt0", "Packet1", "pkg1", "pkg0", "pkt3", "pkt2", "Pkt1", " packet0", "Packet2"], "pkt": ["Pkt", "Pck", " pct", "ppkt", "pct", "ppacket", "packet", " pck", "ppck", "pck", "Packet", "ppct", "Pct", " packet"], "t": ["ot", "o", "tf", "st", "ti", "v", "rt", "dat", "tmp", "qt", "template", "tu", "pt", "m", "f", "att", "d", "j", "u", "e", "tn", "tm", "n", "ant", "ts", "p", "tz", "h", "ut", "c", "ta", "txt", "ct", "type", "g", "dt", "tp", "y", "tt", "T", "text", "test", "r", "tc"], "opts": ["opls", "OPts", " opTS", "optter", "operts", "optls", "opters", "precs", "OPter", "optionts", "optTS", "optt", " opte", "operters", "opert", "opttes", "optts", "optcs", "prets", "optte", "opcs", "optters", "ops", "copts", "OPters", "OPt", "copTS", "opte", "coptes", "optionls", "optionTS", "opTS", "opt", "optionte", "cops", " opls", " opcs", "preters", "optes", "opter", " optes", "pretes", " ops", "operter", " opters"], "orig_nb_streams": ["orig_nb_threads", "orig_nb_lengthS", "orig_nb_contries", "orig_nb_rounds", "orig_nb_threadflows", "orig_nbofstreamds", "orig_nb_threadS", "orig_nb_streamries", "orig_nb_lengthries", "orig_nb_roundings", "orig_nb_pathflows", "orig_nb_streamds", "orig_nbofthreadds", "orig_nb_pathd", "orig_nb_streamd", "orig_nbofthreadd", "orig_nb_threadings", "orig_nb_streamflows", "orig_nb_conts", "orig_nb_roundds", "orig_nbofstreamings", "orig_nbofthreads", "orig_nb_paths", "orig_nb_lengthd", "orig_nb_lengths", "orig_nb_streamS", "orig_nb_streamings", "orig_nb_contd", "orig_nb_lengthings", "orig_nb_threadds", "orig_nb_roundd", "orig_nbofthreadings", "orig_nb_pathds", "orig_nb_lengthflows", "orig_nb_lengthds", "orig_nb_threadries", "orig_nbofstreamd", "orig_nbofstreams", "orig_nb_contS", "orig_nb_threadd"], "wait_mutex": ["wait_condout", "wait_mutru", "wait_condx", "wait_condex", "wait_utex", "wait_motx", "wait_motru", "wait_motout", "wait_motex", "wait_mutout", "wait_utout", "wait_utru", "wait_utx", "wait_mutx", "wait_condru"]}}
{"project": "FFmpeg", "commit_id": "859bb3cfee28efff9c965d4c9320c7837b85849e", "target": 0, "func": "int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2];\n\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n\n\n    assert(avctx);\n\n    if (!render || render->xvmc_id != AV_XVMC_ID ||\n\n        !render->data_blocks || !render->mv_blocks) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Render token doesn't look as expected.\\n\");\n\n        return -1; // make sure that this is a render packet\n\n    }\n\n\n\n    if (render->filled_mv_blocks_num) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n\n               render->filled_mv_blocks_num);\n\n        return -1;\n\n    }\n\n    if (render->allocated_mv_blocks   < 1 ||\n\n        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||\n\n        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||\n\n        render->next_free_data_block_num >\n\n                        render->allocated_data_blocks -\n\n                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    render->picture_structure = s->picture_structure;\n\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n\n    render->p_future_surface  = NULL;\n\n    render->p_past_surface    = NULL;\n\n\n\n    switch(s->pict_type) {\n\n        case  FF_I_TYPE:\n\n            return 0; // no prediction from other frames\n\n        case  FF_B_TYPE:\n\n            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];\n\n            if (!next)\n\n                return -1;\n\n            if (next->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_future_surface = next->p_surface;\n\n            // no return here, going to set forward prediction\n\n        case  FF_P_TYPE:\n\n            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];\n\n            if (!last)\n\n                last = render; // predict second field from the first\n\n            if (last->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_past_surface = last->p_surface;\n\n            return 0;\n\n    }\n\n\n\nreturn -1;\n\n}\n", "idx": 6293, "substitutes": {"s": ["options", "sets", "sf", "v", "is", "S", "a", "http", "spec", "prev", "save", "send", "comments", "si", "styles", "i", "sync", "ses", "services", "m", "details", "states", "f", "parts", "ns", "server", "ls", "sl", "series", "service", "init", "ss", "cs", "sports", "ser", "conf", "e", "sc", "submit", "sb", "gs", "se", "ds", "qs", "t", "storage", "ts", "su", "self", "source", "p", "parse", "south", "settings", "aws", "sv", "fs", "c", "os", "g", "ssl", "sq", "sym", "params", "your", "es", "rs", "set", "seed", "js"], "avctx": ["AVpkg", " avcontext", "AVqa", "avconn", "wavcrit", "navqa", "awctx", "apcontext", "Avpkg", "AVlc", "aflc", "avalconfig", "AVcrit", "avalcontext", "AVctx", "avcrit", "afcmp", "avconfig", "AVcontext", "avcmp", "abcmp", "navcontext", "awconfig", "afctx", "AVci", "avalconn", "apconn", "apqa", "apctx", "wavctx", "abcontext", "avcontext", "avalctx", "avqa", "Avcontext", "AVcmp", "Avctx", "Avci", "awcontext", "afconn", "avpkg", "avlc", " avci", "afcontext", "afconfig", "afcrit", "wavcontext", "navctx", " avpkg", "AVconn", "avci", "wavlc", "ablc", "awconn", "navconn", "abctx"], "last": ["replace", "name", "fr", "build", "middle", "cur", "prev", "show", "parent", "future", "send", "final", "style", "tr", "data", "use", "bottom", "reverse", "draw", "later", "Last", "code", "size", "full", "latest", "after", "first", "err", "rev", "result", " first", "runner", "start", "flash", "li", "cache", "max", "nd", "end", "worst"], "next": ["then", "er", "feed", "middle", "open", "prev", "future", "below", "value", "config", "lower", "data", "now", "reply", "missing", "valid", "dot", "job", "child", "obj", "handle", "later", "code", "Next", "bis", "second", "latest", "after", "other", "first", "response", "result", "more", "respond", "output", "mini", "business", "follow", "be", "again", "start", "doc", "primary", "new", "head", "page", "design", "li", "adj", "inner", "front", "current", "success", "big", "max", "end"], "render": ["master", "dr", "rendered", "play", "author", "component", "style", "plot", "reverse", "make", "material", "document", "match", "display", "gener", "theme", "output", "head", "user", "replace", "view", "build", "header", "aster", "send", "layout", "update", "template", "later", "driver", "consider", "response", "parse", "respond", "represent", "apply", "reflect", "end", "show", "save", "flower", "cover", "require", "use", "download", "begin", "Render", "run", "nder", "follow", "design", "rend", "r", "cook", "rr", "http", "trigger", "draw", "child", "player", "order", "handle", "ser", "hide", "after", "load", "result", "request", "write", "report", "transform", "flash"]}}
{"project": "FFmpeg", "commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "target": 1, "func": "static int calculate_bitrate(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    int i, j;\n\n    int64_t lensum = 0;\n\n    int64_t maxpos = 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n\n\n        if (!st->nb_index_entries)\n\n            continue;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n\n        lensum += len;\n\n    }\n\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n\n        return 0;\n\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n\n        return 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n        int64_t duration;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n\n            continue;\n\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n\n        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n\n    }\n\n    return 1;\n\n}\n", "idx": 6307, "substitutes": {"s": ["r", "o", "sf", "v", "is", "S", "a", "spec", "sg", "b", "si", "sync", "sys", "ses", "services", "m", "in", "l", "xs", "f", "ns", "ls", "service", "ss", "cs", "u", "sis", "e", "sh", "sc", "w", "gs", "sb", "sim", "se", "ks", "ds", "qs", "n", "t", "ops", "ts", "su", "p", "this", "settings", "sv", "fs", "sa", "c", "os", "txt", "ssl", "sq", "sym", "g", "rs", "sup", "ps", "js"], "avi": ["vim", "afi", "mic", "di", "vid", "aa", "si", "rc", "ani", "umi", "wp", "co", "bi", "pi", "adi", "wi", "av", "aj", "ii", "ai", "cli", "iti", "vi", "aic", "ami", "ava", "bis", "bc", "mi", "ini", "audi", "ic", "ave", "ahi", "iv", "wav", "sa", "oga", "api", "video", "oci", "fi", "ati", "audio", "ui"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "ik", "di", "ci", "ki", "ji", "ni", "x", "ri", "si", "b", "io", "xi", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "ij", "d", "iu", "ii", "ai", "it", "my", "init", "u", "e", "ami", "uri", "ori", "k", "n", "multi", "mi", "ini", "ie", "p", "h", "eni", "z", "oi", "c", "ind", "ip", "g", "y", "li", "anti", "inner", "fi", "index", "r", "zi", "mu", "ui"], "j": ["jet", "fr", "o", "ch", "jon", "v", "el", "pr", "ui", "oj", "jl", "ji", "b", "x", "si", "oh", "m", "pt", "kj", "l", "key", "ix", "f", "job", "ng", "ii", "ij", "d", "q", "obj", "aj", "u", "part", "e", "jen", "w", "J", "section", "je", "jc", "k", "json", "n", "uj", "other", "jp", "jo", "ie", "p", "jit", "h", "z", "pos", "jj", "ld", "ind", "g", "y", "ja", "br", "dj", "li", "adj", "bl", "index", "bj", "js"], "st": ["std", "est", "dr", "fr", "ste", "stri", "ost", "nt", "dd", "style", "rd", "sn", "ust", "dest", "pe", "sett", "pt", "stress", "stab", "sts", "l", "cl", "rest", "d", "sl", "obj", "St", "iss", "fe", "td", "ss", "stop", "sc", "sth", "sb", "sh", "ist", "se", "inst", "mt", "sd", "t", "ds", "ts", "ST", "str", "p", "sta", "stage", "be", "ft", "sp", "start", "step", "sa", "ld", "ct", "dt", "tta", "bl", "ast", "nd", "end"], "duration": ["dy", "time", "vr", "days", "frequency", "uration", "count", "fee", "vid", "distance", "mult", "gap", "loss", "style", "repeat", "unit", "uv", "lag", "db", "version", "url", "length", "d", "description", "series", "period", "dist", "delay", "number", "len", "dp", "depth", "angle", "volume", "pad", "timeout", "rate", "elta", "span", "urations", "doc", "cost", "fun", "Duration", "range", "video", "dt", "date", "diff"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335, "substitutes": {"val": ["base", "pid", "play", "reg", "bin", "el", "v", "pr", "rt", "parent", "value", "rb", "x", "data", "Val", "pt", "fb", "valid", "vals", "call", "VAL", "obj", "pc", "arg", "py", "def", "arr", "aval", "func", "lib", "rx", "empty", "exec", "p", "old", "temp", "eval", "this", "prop", "fail", "gen", "rule", "sel", "var", "ind", "ref", "grad"], "addr": ["base", "address", "dr", "name", "arm", "md", "dd", "x", "ad", "holder", "offset", "attr", "adder", "obj", "arg", "align", "part", "wd", "point", "ard", "func", "pad", "rx", "str", "callback", "work", "prefix", "amp", "frame", "ptr", "pos", "pointer", "node", "amd", "adr", "ord", "ref", "src", "host", "grad", "add"], "index": ["find", "address", "name", "position", "id", "value", "x", "i", "slice", "loc", "image", "inc", "ion", "num", "offset", "call", "weight", "length", "number", "action", "point", "part", "pos", "pointer", "level", "ind", "type", "element", "Index", "ref", "diff", "end"]}}
{"project": "qemu", "commit_id": "2f295167e0c429cec233aef7dc8e9fd6f90376df", "target": 1, "func": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n", "idx": 6346, "substitutes": {"klass": ["Kclass", "Klass", "oklass", "klasses", "iklass", "ikclass", " klasses", "sklass", "sklasses", " kclass", "skass", " kazz", "skcl", "kass", "okazz", "iklasses", "kazz", "Kcl", "kclass", " kass", "okass", "Klasses", "ikcl", "kcl", "skclass", "oklasses", "skazz", " kcl"], "data": ["parent", "di", "dat", "dd", "device", "config", "rc", "info", "d", "DATA", "def", "da", "ds", "Data", "ctx", "bc", "load", "result", "array", "input", "dt", "params", "ac", "cache", "rec"], "dc": ["abc", "dr", " DC", "gc", "oc", "di", "config", "disc", "nc", "rc", "cca", "enter", "db", "ga", "dk", "d", "pc", "cc", "mc", "sc", "da", "jc", "conn", "df", "bc", "controller", "deck", "ec", "DC", "doc", "c", "ct", "cf", "design", "dt", "fc", "lc", "ac", "vc", "cdn", "cm", "cd", "xc", "tc"], "hc": ["hscs", "pci", " hci", "hfc", "plc", " hpc", "hspc", "Hpc", "hcs", "hci", "htlc", "pc", "htfc", "hlc", " hfc", "Hcs", " hcs", "hsc", " hlc", "htc", "hpc", "hsdc", "Hdc", "Hc", "pfc", "hdc", " hdc", "htci"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n", "idx": 6374, "substitutes": {"saddr": ["symaddress", "sesnode", "dsadd", "shipaddress", "sesaddress", "fha", "sord", "shipord", "spaddr", " spad", "lsadr", "sadr", "symvr", " sadder", " sord", "taddr", "dord", "lspad", "sha", " shost", "faddress", "tpad", "sesaddr", "skyaddr", " sadd", "daddress", "sadder", "thost", "Saddr", "saddress", "waddr", "taddress", "symolver", "dadd", "wadder", " saper", "tadr", "saper", "symaddr", "fnode", "sadd", "opensadder", "sad", "Sconn", "lsaddr", "spaddress", "shipaddr", "Saddress", "dsaddr", "opensaddress", "dhost", "safi", "paddr", "spha", "shipaper", "sconn", "faddr", " sadr", "spnode", "pvr", "spad", "soder", "sesha", " safi", " sad", "tafi", "tad", "shost", "skyafi", " sha", "dshost", "opensoder", "lsaddress", "dsaddress", "daper", " svr", "solver", " saddress", "snode", "skyhost", "opensaddr", "woder", "skyad", "paddress", " sconn", " solver", " soder", "daddr", "Sha", "polver", "svr", "waddress"], "errp": ["rrpre", "Erp", "erfp", "erP", "errpre", " errf", "errorp", "errorpre", "rrp", " errfp", "rrf", "rrr", "errP", "errorP", "Erpr", "aerp", " errP", "ErP", "errpr", "errorfp", "errr", "erp", "errf", "rrfp", "Erpre", "aerpre", "aerP", "aerpr", "errfp", " errpre", " errpr", " errr", "erpre", "erf"], "ai": ["abc", "address", "as", "afi", "aii", "ei", "aud", "air", "iri", "na", "pai", "a", " AI", " api", "ci", " bi", "config", "aa", "ni", "si", "i", "abi", "AU", "info", "ae", "bi", "ia", "qi", "aim", "wa", "ru", "attr", " mi", "adi", " ca", "an", "ami", "ay", "ait", "uri", "AI", "jp", "mi", "ini", "agi", "fa", "ee", "ais", "aaa", "qa", "ca", "eni", "sa", "api", "hai", "iat", "oci", "ac", "au", "fi", "ha", "conn", "ui", "af"], "res": ["gr", "rn", "ret", "reg", "rr", "s", "ress", "Res", "ros", "rows", "rel", "sys", "reply", "details", "rh", "resource", "results", "rest", "RE", "cs", "ras", "rss", "rez", "arr", "func", "rx", "response", "rev", "result", "resh", "req", "re", "RES", "mr", "R", "os", "errors", "resp", "ps", "ref", "rs", "addr", "r", "cas", "rem", "rec", "rar"], "rc": ["rn", "dr", "r", "anc", "irc", " RC", " rec", "ann", "irm", "rt", " reg", "rr", "cr", " succ", "sr", "cur", "roc", "rb", "nc", " rac", "exc", "auc", "co", "uc", "loc", "rh", "inc", "pc", "ack", "cc", "ror", "tc", "ras", "code", "ck", "sc", "error", "dc", "rx", "bc", "cb", "rl", "result", " src", "req", "c", " sc", "lc", "fc", " exc", " r", "vc", "src", "RC", "rec", "rar", "ok"], "err": ["gr", "dr", "fr", "rn", "er", "fam", " er", "cr", "pr", "rr", "fee", "aster", "bug", "exc", "ise", "sys", "reply", "der", "rm", "ace", "inc", "tx", "rh", "ir", "rage", "attr", "ra", "ler", "order", "ctr", "conf", "acer", "ev", "ras", "e", "error", "ar", "arr", " error", "Error", "cer", "rl", "cb", "lr", "result", "raise", "aaa", "req", "reader", "ner", "mr", "ind", "errors", "resp", "Er", "fi", "rs", "r", "rar", "msg"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void bamboo_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    PCIBus *pcibus;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr loadaddr = 0;\n\n    target_long initrd_size = 0;\n\n    DeviceState *dev;\n\n    int success;\n\n    int i;\n\n\n\n    /* Setup CPU. */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"440EP\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    if (env->mmu_model != POWERPC_MMU_BOOKE) {\n\n        fprintf(stderr, \"MMU model %i not supported by this machine.\\n\",\n\n            env->mmu_model);\n\n        exit(1);\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n    ppc_booke_timers_init(cpu, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                   ram_memories,\n\n                                   ram_bases, ram_sizes,\n\n                                   ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, 1);\n\n\n\n    /* PCI */\n\n    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,\n\n                                PPC440EP_PCI_CONFIG,\n\n                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],\n\n                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],\n\n                                NULL);\n\n    pcibus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pcibus) {\n\n        fprintf(stderr, \"couldn't create PCI controller!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, PPC440EP_PCI_IOLEN);\n\n    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 6385, "substitutes": {"machine": ["game", "base", "mobile", "program", "plugin", "host", "vm", "note", "device", "component", "session", "config", "bug", "environment", "object", "data", "database", "template", "module", "info", "m", "image", "normal", "profile", "mac", "project", "state", "server", "linux", "space", "service", "part", "interface", "cell", "connection", "comment", "message", "storage", "instance", "Machine", "kernel", "process", "controller", "source", "computer", "mom", "processor", "boot", "node", "proc", "slave", "model", "core", "engine", "cache", "loader", "manager", "mode", "hard"], "kernel_filename": ["kernel2prefix", "system_directory", "kernel_software", "system_prefix", "kernel_description", "kernel2location", "kernellogfilename", "kernellogsoftware", "system_software", "system_filename", "kernel_directory", "system_location", "kernel_location", "system_description", "kernellogdescription", "kernel_username", "kernel2username", "kernel_prefix", "kernellogdirectory", "system_username", "kernel2filename"], "kernel_cmdline": ["kernel__cmdle", "kernel_commandle", "kernel_hostline", "kernel__cmdlines", "kernel__hostle", "kernel__cmdname", "kernel_deflines", "kernel_hostlines", "kernel_defline", "kernel__cmdline", "kernel_mdlines", "kernel_cmdl", "kernel_cmdle", "kernel_hostname", "kernel_commandname", "kernel_mdline", "kernel_defl", "kernel_hostl", "kernel_cmdname", "kernel_mdname", "kernel__hostname", "kernel_commandl", "kernel_mdle", "kernel_commandlines", "kernel_cmdlines", "kernel__hostlines", "kernel_commandline", "kernel_hostle", "kernel__hostline"], "initrd_filename": ["initrd_initial", "initrdsfile", "initrn_filename", "initrt_bytes", "initrt_filename", "initrdsprefix", "initrd_bytes", "initrd_url", "initrd_file", "initrt_Filename", "initrd_Filename", "initrdsurl", "initrn_file", "initrn_url", "initrd_prefix", "initrn_prefix", "initrt_initial", "initrdsfilename"], "pci_irq_nrs": ["pci_irq_crd", "pci_irq_codes", "pci_irq_numrs", "pci_irq_Nros", "pci_irq_nodes", "pci_irq_nrd", "pci_irq_numrd", "pci_irq_numodes", "pci_irq_Nrs", "pci_irq_Nrd", "pci_irq_nros", "pci_irq_cros", "pci_irq_numros", "pci_irq_Nodes", "pci_irq_crs"], "address_space_mem": ["address_area_memory", "address_space_memory", "address_area_mem", "address_space_ram", "address_area_lim", "address_area_ram", "address_space_lim"], "isa": ["irc", "asu", "pai", "ISA", "iam", "va", "imi", "aa", "xi", "cca", "ani", "asi", "cci", "aci", "ai", "ami", "esa", "agi", "ini", "ina", "ang", "mini", "eni", "acs", "oci", "adr", "anti", "fi", "isc"], "ram_memories": ["ram_temores", "ram_amory", "ram_temages", "ram_messages", "ram_messories", "ram_matores", "ram_memores", "ram_mources", "ram_amources", "ram_mories", "ram_matages", "ram_memages", "ram_temories", "ram_matories", "ram_mions", "ram_matources", "ram_memions", "ram_messores", "ram_mators", "ram_memors", "ram_amions", "ram_matory", "ram_mations", "ram_memory", "ram_amories", "ram_memources", "ram_mory", "ram_temors", "ram_messors"], "ram_bases": ["ram_vase", "ram_base", "ram_vias", "ram_brases", "ram_lases", "ram_vuses", "ram_buses", "ram_lias", "ram_bruses", "ram_luses", "ram_brias", "ram_bias", "ram_vases", "ram_lase", "ram_brase"], "ram_sizes": ["ram_setsizes", "ram_ciz", "ram_offsizes", "ram_sides", "ram_setsists", "ram_offsists", "ram_cizes", "ram_setsiz", "ram_offsiz", "ram_siz", "ram_setsides", "ram_sists", "ram_cists", "ram_offsides", "ram_cides"], "pic": ["oc", "pid", "anc", "ig", "bin", "mic", "pin", "quad", "xi", "sync", "module", "pins", "mac", "pc", "py", "cc", "mc", "nic", "lib", "bc", "mi", "agi", "ic", "mini", "doc", "proc", "lc", "fc", "fi"], "irqs": ["rinqs", "mirqs", "IRqs", "IRqa", "rincs", "mirq", "irks", "IRcks", " irques", "IRques", "mirques", "irq", "mirks", "mircs", "iraks", "ircks", " irqa", "IRq", "IRks", "rincks", " ircs", "iraq", "ircs", "iraqs", "IRcs", "iracs", "rinq", "irqa", "irques", " ircks", "mirqa", " irq"], "pcibus": ["puus", "pdopus", "pcubis", "puubis", "incibus", "pdubis", "pdibus", "pdus", "incubis", "puibus", "incopus", "incus", "pcopus", "pcus", "puopus"], "cpu": ["cp", "hp", "gp", "bench", "pid", "hw", "gc", "cmp", "cfg", "lb", "chip", "mem", "platform", "pu", "vm", "gru", "consumer", "nc", " CPU", "gpu", "queue", "px", "chu", "pc", "linux", "net", "np", "nic", "que", "clock", "proxy", "instance", "ctx", "kernel", "jp", "process", "pool", "ne", "computer", "processor", "boot", "runner", "eni", "none", "console", "proc", "node", "GPU", "cn", "core", "ilo", "performance", "lc", "cache", "cow", "loader", "CPU", "uno", "conn"], "env": ["energy", "el", "environment", "password", "object", "queue", "gui", "state", "conf", "ev", "zone", "err", "exec", "equ", "Environment", "enh", "theme", "ec", "engine", "conn", "extra", "vm", "config", "eu", "server", "ne", "viron", "cookie", "site", " environment", "end", "eng", "device", "vel", "exc", "image", "agent", "db", "profile", "export", "ext", "exe", "net", "np", "e", "que", "en", "network", "global", "shell", "dep", "core", "api", "cache", "loader", "ea", "v", "scope", "session", "enc", "de", "attr", "args", "priv", "devices", "context", "opt", "eni", "console", "agents", "skin", "manager", "cdn"], "elf_entry": ["elf__entry", "elf__mac", "elope_cmp", "elope_port", "elf___cmp", "elf___entry", "elf___mac", "elf_port", "elf_cmp", "elope_mac", "elf_mac", "elf__cmp", "elf__port", "elf___port", "elope_entry"], "elf_lowaddr": ["elf_oldaddress", "elf_lowattr", "elf_loadaddr", "elf_highaddress", "elf_highaddr", "elf_highattr", "elf_oldAddress", "elf_loadAddress", "elf_oldaddr", "elf_loadaddress", "elf_lowAddress", "elf_lowaddress", "elf_highAddress", "elf_oldattr", "elf_loadattr"], "dev": ["mem", "Dev", "device", "data", "debug", "bus", "de", "conf", "ev", "DEV", "priv", "error", "disk", "exec", "serial", "boot", "iv", "pos", "ver", "node", "proc", "slave", "ip", "user", "cache", "app", "loader", "conn"], "success": [" ret", "ea", " pri", " test", " succ", "device", "va", " e", " res", " cores", " code", " rc", " unit", "code", "error", " error", "err", " j", " h", " num", " d", " status", " result", " vi", " r", " b"], "i": ["id", "I", "s", "ci", "ni", "b", "xi", "io", "si", "info", "num", "pi", "d", "ii", "j", "cli", "init", "e", "n", "p", "start", "line", "c", "ip", "type", "mode", "ui"]}}
{"project": "qemu", "commit_id": "6476615d385eb249105b25873ef30ba4b9c808dc", "target": 0, "func": "void HELPER(stpq)(CPUS390XState *env, uint64_t addr,\n\n                  uint64_t low, uint64_t high)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    if (parallel_cpus) {\n\n#ifndef CONFIG_ATOMIC128\n\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n#else\n\n        int mem_idx = cpu_mmu_index(env, false);\n\n        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);\n\n\n\n        Int128 v = int128_make128(low, high);\n\n        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);\n\n#endif\n\n    } else {\n\n        check_alignment(env, addr, 16, ra);\n\n\n\n        cpu_stq_data_ra(env, addr + 0, high, ra);\n\n        cpu_stq_data_ra(env, addr + 8, low, ra);\n\n    }\n\n}\n", "idx": 6408, "substitutes": {"env": ["anne", "ah", "eng", "er", "energy", "ea", "ep", "ef", "vm", "dat", "config", "qt", "esp", "environment", "ex", "exc", "nc", "enc", "queue", "eu", "buf", "db", "ext", "state", "server", "org", "args", "init", "net", "conf", "np", "ev", "code", "e", "priv", "vs", "que", "en", "here", "esc", "ctx", "path", "err", "exec", "Environment", "enh", "context", "ec", "req", "qa", "eni", "viron", "console", "erv", "proc", "txt", "chal", "engine", "vag", "cache", "loader", "conn", "worker", "end"], "addr": ["base", "address", "anne", "dr", "cmp", "hw", "ea", "arm", "id", "rr", "alt", "la", "alpha", "ady", "dd", "device", "gru", "osi", "config", "edge", "x", "nc", "oa", "ad", "loc", "ace", "mac", "offset", "attr", "ext", "org", "adder", "nr", "align", "dist", "worker", "len", "uri", "ar", "ctx", "pad", "coord", "access", "work", "seq", "sta", "amp", "usr", "eni", "ptr", "cpu", "pos", "pointer", "ip", "amd", "adr", "ord", "arch", "src", "ha", "index", "host", "grad", "pkg", "ass"], "low": ["address", "flow", "quick", "open", "mid", "up", "lower", "last", "loc", "slow", "l", "offset", "lim", "ra", "Low", "server", "small", "from", "lo", "size", "len", "little", "good", "old", "scale", "zero", "start", "pos", "level", "hi", "off", "range", "new", "lc", "light", "next", "min", "end", "le"], "high": ["master", "name", "top", "large", "open", "alt", "pen", "mid", "up", "last", "High", "pe", "inc", "lim", "limit", "maximum", "highest", "upper", "pop", "round", "close", "full", "bound", "path", "p", "h", "remote", "higher", "hi", "range", "release", "asc", "index", "r", "big", "min", "max", "diff", "end", "peak"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n", "idx": 6432, "substitutes": {"dstU": ["dsrcM", "fstU", "dspU", "dspV", "destU", "dspUV", "dSTM", "dstO", "DestO", "DestCU", "DestU", "fstV", "dstUR", "DestM", "dsrcV", "dspM", "DestA", "ddestCU", "fspM", "dstdU", "DstO", "destA", "dstCU", "ddestUR", "dSTUV", "dstA", "DstA", "destCU", "fspV", "fspU", "dstM", "fstUV", "dsrcUV", "destO", "destM", "dSTU", "dstUV", "dSTV", "DstUR", "dstdA", "DstM", "dsrcU", "ddestM", "fspUV", "DstU", "dstdUR", "ddestU", "DstCU", "ddestO", "dSTO", "fstM", "ddestA", "dstdCU", "DestUR", "destUR", "dSTUR"], "dstV": ["dconstVB", "destU", "dSTv", "DestU", "DstVI", "dsrcV", "dconstv", "destVI", "dstsL", "DstI", "dblV", "dsrcVI", "dconstU", "dstsVB", "dconstI", "Dsrcv", "dstVB", "DstV", "dconstL", "dblL", "dSTI", "DestV", "dblVB", "dsrcv", "dstL", "destV", "dstv", "dstVI", "dstI", "dblUV", "dSTVI", "dconstUV", "dSTU", "dsrcI", "dstsUV", "DsrcVI", "dSTV", "dstUV", "dstsV", "DstU", "Destv", "destI", "dconstV", "DsrcV", "DestI", "destv", "Dstv", "DsrcI"], "src1": ["url2", "src3", " srcA", " srcN", "gb3", "sourceOne", "rcU", "rc3", " src0", "url1", "rc0", "loc1", "gbU", "source1", "rc1", " srcOne", "src01", " srcU", "rcN", "srcA", "rc01", "sourceA", "source3", "url0", "loc0", "rcA", "srcU", "srcN", "source2", "url01", "rc2", " src01", "rcOne", "gb1", "gb2", "locOne", "sourceN", " src3", "src0", "srcOne", "source0", "loc2"], "src2": ["src3", "rc3", " src0", "rc0", "rib2", "source1", "rc1", "ribV", " srcV", "source3", "rcV", "srcV", "rib0", "source2", "rc2", "rib1", " src3", "src0", "source0"], "i": ["gi", "o", "ti", "v", "id", "I", "count", "di", "ci", "ji", "xi", "x", "si", "slice", "b", "abi", "ri", "info", "bi", "m", "io", "qi", "l", "key", "pi", "phi", "adi", "j", "length", "ii", "d", "it", "ai", "u", "vi", "e", "uri", "n", "multi", "ini", "p", "temp", "z", "eni", "start", "line", "oi", "hi", "var", "ip", "c", "page", "lc", "li", "fi", "index", "zi", "diff", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){\n\n    int i,j,xy,yz;\n\n    int res;\n\n    for(i=0; i<8; i++){\n\n        for(j=1; j<7; j++){\n\n            xy = j * stride + i;\n\n            yz = j * 8 + i;\n\n            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];\n\n            res +=2;\n\n            res >>=2;\n\n            dest[xy] = (uint8_t)res;\n\n        }\n\n    }\n\n}\n", "idx": 6452, "substitutes": {"dest": ["master", "destroy", "parent", "done", "sort", "tr", "data", "slice", "flat", "route", "wb", "rest", "d", " Dest", "dist", "later", "outer", "cont", "target", "die", "dc", "Dest", "coord", "source", "output", "usr", "opt", "trans", "gen", "proc", "dep", "class", "comb", "desc", "test", "img", "cdn", "end", "super"], "src": ["sub", "st", "sr", "inf", "bin", "cur", "spec", "sort", "rb", "config", "b", "rc", "data", "slice", "stack", "stream", "comp", "loc", "image", "support", "reverse", "rest", "attr", "conv", "url", "sl", "gz", "init", "dist", "split", "impl", "sc", "sb", "inst", "cb", "source", "seq", "trans", "gb", "start", "sup", "supp", "ssl", "desc", "rob", "img", "grad", "size"], "stride": ["Strider", "STRider", "etrid", "Strision", " strider", "striding", "STRide", "STRision", "strange", "Strid", "striange", "constange", "striide", "constiding", "etrider", " striding", "strision", "etrision", "striiding", "strid", " strange", "STRid", "etride", "striider", "constider", "constide", "strider", "Stride"], "i": ["v", "id", "I", "a", "is", "ik", "ci", "ji", "ni", "b", "x", "si", "ri", "xi", "bi", "m", "qi", "l", "f", "pi", "phi", "iu", "ii", "d", "ai", "u", "e", "ori", "mi", "jp", "ini", "ie", "p", "jit", "h", "z", "eni", "start", "oi", "ind", "ip", "im", "y", "c", "li", "index", "r", "zi", "ui"], "j": ["jet", "dy", "o", "v", "oj", "jl", "ji", "ni", "b", "x", "m", "qi", "l", "f", "job", "ii", "ij", "aj", "py", "q", "it", "u", "e", "jen", "J", "zip", "jc", "k", "ori", "n", "uj", "jp", "jo", "ie", "p", "z", "jj", "g", "y", "ja", "dj", "li", "js"], "xy": ["yy", "dy", "vec", "zy", "phy", "id", "qq", "wx", "quad", "zx", "yt", "ji", "val", "x", "data", "comp", "info", "loc", "px", "fx", "wy", "f", "phi", "ii", "exe", "py", "gz", "xxxxxxxx", "code", "e", "rez", "zip", "ori", "rx", "xe", "nz", "coord", "ie", "p", "seq", "z", "xxx", "gb", "pos", "orig", "dj", "xx", "XY", "syn", "biz", "index", "zi", "pick"], "yz": ["yy", "dy", "isi", "zy", "yx", "rt", "wx", "qq", "ez", "zx", "yt", "ji", "ny", "sky", "info", "eddy", "flat", "loc", "qi", "ix", "xs", "rh", "iaz", "yi", "obj", "ii", "gz", "des", "resolution", "jing", "rez", "zip", "ori", "zz", "uj", "rx", "kid", "nz", "err", "zh", "score", "zon", "ie", "req", "z", "xxx", "eni", "resp", "dj", "y", "sq", "cz", "axy", "xx", "iz", "rep", "fi", "biz", "zi", "dim", "az", "js"], "res": ["nos", "powers", "ris", "ret", "reg", "vec", "rates", "cr", "ress", "Res", "x", "val", "rows", "vals", "results", "rex", "ries", "cs", "Rs", "des", "ras", "resolution", "len", "rss", "rez", "cons", "ops", "vs", "arr", "rx", "err", "rev", "eps", "pres", "result", "seq", "rem", "req", "css", "z", "re", "RES", "pos", "ver", "os", "ms", "resp", "ps", "rep", "rs", "es", "r", "min", "js"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                  %0, %%\"REG_a\"         \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq  (%1, %%\"REG_a\",2), %%mm0             \\n\\t\"\n\n        \"movq 8(%1, %%\"REG_a\",2), %%mm1             \\n\\t\"\n\n        \"psrlw                $8, %%mm0             \\n\\t\"\n\n        \"psrlw                $8, %%mm1             \\n\\t\"\n\n        \"packuswb          %%mm1, %%mm0             \\n\\t\"\n\n        \"movq              %%mm0, (%2, %%\"REG_a\")   \\n\\t\"\n\n        \"add                  $8, %%\"REG_a\"         \\n\\t\"\n\n        \" js                  1b                    \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src+width*2), \"r\" (dst+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++)\n\n        dst[i]= src[2*i+1];\n\n#endif\n\n}\n", "idx": 6455, "substitutes": {"dst": ["dsST", "ssp", "idsts", "lsrc", "lst", "dbl", "fsts", "dsbl", "dssc", "idst", "adsc", "dsc", "sST", "adST", "dsp", "fST", "dST", "dsts", "sst", "lsts", " dsts", " dsc", "dsst", " dsp", "adst", "idsrc", "idsp", " dbl", "ssts", "fsrc", "lsp", " dST", "fst", "adbl", "fsp", "dsrc"], "src": ["sub", "st", "sr", "ins", "rb", "config", "rc", "sync", "slice", "dest", "loc", "sur", "support", "rib", "rest", "attr", "url", "sl", "scripts", "gz", "dist", "bs", "sc", "sth", "sb", "rect", "inst", "sh", "lib", "ctx", "cb", "ruby", "rl", "filename", "source", "gl", "gb", "sup", "sel", "ssl", "sq", "secure", "reflect", "img", "grad"], "unused": ["unsusing", "munusing", " unusing", "unschecked", "unchecked", "unusing", "unsprotected", "unprotected", " unprotected", "munprotected", "munused", " unchecked", "munchecked", "unsused"], "i": ["gi", "o", "ti", "v", "id", "I", "count", "di", "ci", "ni", "x", "xi", "si", "b", "ri", "io", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "phi", "j", "ii", "length", "d", "it", "ai", "iu", "init", "u", "vi", "e", "w", "t", "k", "n", "multi", "ini", "p", "h", "z", "start", "oi", "hi", "c", "ip", "page", "hei", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n", "idx": 6486, "substitutes": {"i": ["gi", "o", "ti", "v", "id", "I", "di", "s", "ci", "x", "ni", "xi", "b", "si", "io", "slice", "abi", "ri", "module", "bi", "m", "in", "qi", "info", "ix", "l", "f", "pi", "yi", "j", "ii", "d", "iu", "it", "ai", "init", "u", "e", "uri", "ori", "n", "multi", "mi", "ski", "ini", "ie", "p", "eni", "iv", "oi", "c", "ip", "y", "lc", "li", "inner", "fi", "index", "ui"], "encoded": ["enoding", "inccoded", "engcoded", "deccoded", "incoded", "coded", "incoding", "engoder", "Encoded", "Encoding", "enccoded", "enoded", "encoder", "coder", "enoder", "Encoder", "Enccoded", "Encored", "engoded", "engoding", "incored", "decoder", "Encode", "enode", "encored", "encoding", "decored", "coding", "encode", "decoded", "enored", "ccoded", "decoding", "decode"], "test_cases": ["example67cases", "test__codes", "test_tests", "case_tests", "testplescripts", "testenases", "testslines", "example67comments", "testalllines", "test_comments", "testscase", "testing_ases", "testalltests", "casestests", "test___errors", "testingstimes", "test__cases", "example_scripts", "test67cases", "testing_errors", "testing_cases", "test___case", "testing_tests", "test__case", "testallcases", "testingstests", "casescase", "example_comments", "testplecases", "testingslines", "test_errors", "casescases", "test67case", "test___cases", "test_scripts", "case_case", "teststimes", "test_times", "test___tests", "testing_times", "test_codes", "testing_codes", "testalltimes", "example67scripts", "testencases", "test67scripts", "test_lines", "testing_lines", "test_case", "test67comments", "example_case", "teststests", "test__ases", "example_cases", "testing_case", "example67case", "case_times", "casestimes", "testencase", "testingscases", "testplecomments", "testscases", "case_cases", "testencodes", "test_ases", "testplecase"], "qint": ["shobject", "qunt", "qqinc", "questaddress", "qext", "queryobject", "questpoint", "requINT", "qin", "qinteger", "qpoint", "qainter", "quinc", "qualint", "qashort", "qx", "qux", " qobject", "qaddress", "sqinteger", "qualpoint", " qvert", "shint", "qualaddress", "questint", "eqshort", "qvert", "xinc", "quin", "queryshort", "qinter", "qqnt", "quaddress", " qstr", "sqINT", "queryinter", "qualin", "qnt", "qqint", " qinc", "qqx", "eqint", " qinteger", "qINT", "qaint", "qaext", "qqind", " qx", "qshort", "requvert", "queryINT", "requint", "sqint", "xind", "requinteger", "queryext", "qqstr", "xstr", "questin", "qupoint", "xint", " qINT", " qort", "qobject", "eqinter", "qort", "eqext", "qinc", "qind", " qind", "queryort", "quint", " qnt", "qstr", "sqvert", "shINT", "queryint"], "str": ["dr", "name", "fr", "er", "st", "sr", "cr", "iter", "id", "pr", "cur", "spec", "s", "val", "tr", "style", "data", "enc", "obj", "sl", "strip", "cs", "code", "sc", "arr", "pass", "err", "voc", "coll", "strike", "Str", "sp", "doc", "c", "txt", "type", "hr", "br", "STR", "text", "kr", "rs", "r", "stri", "dict"]}}
{"project": "FFmpeg", "commit_id": "951e715cebfaffced7f13c1525771ff917fe1d38", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489, "substitutes": {"arg": ["abc", "as", "ig", "play", "ag", "emb", "Ar", "val", "rc", "inter", "enc", "Args", "ray", "ad", "or", "ace", "inc", "argument", "like", "args", "param", "arc", "ar", "arr", "ang", "p", "array", "parse", "amp", "asm", "AR", "Arg", "var", "g", "util", "ref", "fi", "mor", "par"], "is": ["isi", "serv", "ris", "rid", "i", "IS", "obs", "iris", "ii", "active", "bs", "ar", "any", "nis", "iz", "irc", "id", "bits", "s", "see", "info", "its", "ls", "iss", "ai", "it", "uri", "ops", "bis", "vis", "ini", "ie", "ais", "parse", "his", "ip", "ms", "iso", "isc", "ui", "as", "kit", "are", "lis", "op", "ri", "or", "ses", "image", "isl", "has", "esi", "isa", "the", "ics", "sis", "vs", "mis", "ist", "inst", "isin", "ic", "css", "os", "im", "api", "app", "Is", "http", "mes", "get", "si", "sys", "in", "ir", "init", "us", "ss", "full", "ori", "eni", "il", "es"], "frame": ["game", "base", "flow", "fr", "block", "parent", "note", "session", "config", "layout", "force", "feature", "iframe", "slice", "za", "image", "Frame", "draw", "live", "fb", " Frame", "window", "f", "fake", "picture", "rame", "state", "series", "document", "fe", "part", "point", "file", "fram", "plane", "cycle", "framework", "boot", "fab", "shot", "line", "node", "setup", "thread", "video", "model", "frames", "element", "ref", "fi", "host", "ze", "view"], "pts_int": ["pts_bit", "PT\n", "pts_str", "pts1bit", "pt\n", "ptts_inter", "ct\n", "point\n", "pts1int", "pts_full", "ptsets_full", "ptsets_int", "ptts_long", "pts_inter", "ptts_int", "pts_long", "ptts_str", "ptsets_bit", "pts1full"], "pts": ["periods", "ctsets", "ptcount", "ptsets", "ctcount", "PTs", "ctls", "ptS", "periodcount", "PTcount", "ctsi", " ptsets", "cts", "PTS", " prefsi", " prefs", "periodS", " prefsets", "ctS", "ctd", "PTd", "ptd", "periodd", " prefls", "ptsi", " ptsi", " ptls", "ptls"], "ret": ["reg", "mem", "rt", "id", "alt", "nt", "rot", "val", "cat", "let", "reply", "status", " RET", "fin", " Ret", "lit", "att", "obj", "res", "match", "def", "part", "len", "mt", "det", "arr", "RET", "feat", "rev", "result", "seq", "Ret", "ft", "ut", "opt", "re", "fun", "back", "hash", "resp", "gt", "ref", "conn", "rets"], "graph": ["flow", "gp", "complex", "feed", "hub", "parent", "shadow", "shape", "scope", "session", "edge", "layout", "config", "stack", "growth", "stream", "widget", "module", "gpu", "image", "draw", "dot", "pg", "document", "connect", "man", "facebook", "proxy", "connection", "gener", "path", "hou", "go", "ghost", "container", "bridge", "context", "pool", "h", "network", "gen", "hog", "raph", "node", "tree", "g", "closure", "Graph", "gd", "model", "query", "gh", "ha", "cache", "group", "grad", "conn", "google", "view"], "filt_out": ["flt_work", "failJout", "facet_in", "fft_out", "filt_string", "failJstring", "filterexternal", "filt_Out", "fail_out", "fail_in", "filterout", "fail_string", "failJin", "filt_work", "flt_in", "filterstring", "fft_string", "flt_out", "facet_out", "failJref", "facet_list", "fft_external", "filt_ref", "filtJin", "filtJstring", "filt_list", "filtJout", "flt_Out", "filt_external", "filt_in", "filtJref", "fail_ref"], "pos": ["points", "base", "pid", "axis", "position", "padding", "block", "count", "alt", "spec", "channel", "po", "rot", "val", "sum", "data", "style", "bit", "rel", "body", "pt", "vals", "offset", "obj", "args", "pc", "POS", "conf", "Pos", "part", "len", "code", "col", "depth", "port", "lat", "vis", "str", "seq", "prop", "start", "fs", "pose", "os", "doc", "pointer", "cap", "type", "bl", "cache", "ref", "index", "src", "neg", "slot"], "pkt": ["pbct", "Pkt", "bct", "pbacket", "pbft", "pft", "pct", "packet", "Pct", "bkt", "bft", "Pft", "pbkt", "Packet", "backet"], "picref": ["picre", "synRef", "fcref", "nicREF", "cusreference", " picrel", "icRef", "pictREF", "picrel", "chatref", "PicRef", "icror", "pcrel", "synreference", "Picalt", "licRef", "chatror", "synrel", "icreference", " picalt", "pcalt", "PicREF", "pictref", "chatreference", "fcrel", "picalt", "pictalt", "licreference", "picreference", "picREF", "cusref", "pcref", "pinrel", "licrel", "pinror", "picRef", " picREF", "nicref", "Picref", "chatrel", "fcreference", "pinreference", "pcreference", "icref", "picror", "pictreference", " picreference", "cusre", "Picreference", "fcRef", "nicreference", "cusREF", "icrel", "synref", "pcRef", "nicre", "pinalt", "licref", "pinref", "Picrel", "Picre"], "tb": ["ptbm", " ptbm", "tbm", "btz", "tzb", "ptbs", "btb", " tbl", "itp", "ctbs", " ptbs", "ptb", "itbs", "ctp", " tbs", "tbs", " ptb", "atb", "btbs", "btzb", "itbl", " tbm", "atzb", "tz", "ttbs", "ttz", "ttb", "ctb", " tp", "atz", "ctbl", "tp", "itb", "ttzb", "tbl", "atbs"]}}
{"project": "qemu", "commit_id": "e13e973eedba0a52b4b8b079c4b85cdc68b7b4f0", "target": 1, "func": "static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n", "idx": 6500, "substitutes": {"dev": ["game", "pack", "hw", "serv", "o", "ch", "dm", "v", "Device", "md", "rad", "local", "dn", "di", "Dev", "dd", "device", "plug", "data", "home", "ad", "info", "dem", "m", "der", "debug", "gu", "de", "bus", "usb", "d", "ve", "mod", "av", "conf", "ev", "def", "DEV", "dom", "des", "w", "comment", "die", "driver", "ds", "dc", "block", " device", "self", "pub", "temp", "serial", "req", "development", "ver", "engine", "test", "app", "grad", "conn", "mode"], "s": ["r", "o", "sets", "sf", "v", "is", "S", "a", "http", "spec", "sg", "plugins", "session", "b", "si", "i", "sync", "sys", "ses", "services", "m", "its", "in", "states", "l", "f", "ns", "d", "sl", "ls", "server", "service", "us", "ss", "cs", "conf", "u", "native", "e", "vs", "an", "sb", "gs", "w", "ds", "qs", "n", "ts", "su", "self", "p", "south", "settings", "h", "sv", "fs", "c", "os", "g", "ssl", "sq", "sym", "site", "es", "rs", "ps", "js"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n", "idx": 6507, "substitutes": {"opaque": ["opacre", "opque", "OPque", "Opaque", " opcache", " opque", " opacre", "ipaques", "openaques", "ipque", "Opaques", "openacity", "OPaque", "ipaque", "Opcache", "openaque", "Opacity", "OPaques", " opacity", "opaques", "opcache", "opencache", "opacity", "OPacre", " opaques", "ipacre"], "pob": ["Poo", "spib", "Pib", "ipab", "psob", " pOB", "spoo", "pib", "tOB", "spab", "pore", " pore", " pib", "psemb", "pemb", "tab", "tob", "opOB", " pub", "opib", "POB", "opob", "Pob", "opab", "pab", " pab", "pub", "ipore", "opub", "Pab", "psab", "opoo", "Pemb", "spob", "psOB", "Pore", "pOB", " pemb", "poo", "ipib", "ipob", "tib", "Pub"]}}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n\n{\n\n    int i, j, t, rconpointer = 0;\n\n    uint8_t tk[8][4];\n\n    int KC = key_bits >> 5;\n\n    int rounds = KC + 6;\n\n    uint8_t log8[256];\n\n    uint8_t alog8[512];\n\n\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n\n        j = 1;\n\n        for (i = 0; i < 255; i++) {\n\n            alog8[i] = alog8[i + 255] = j;\n\n            log8[j] = i;\n\n            j ^= j + j;\n\n            if (j > 255)\n\n                j ^= 0x11B;\n\n        }\n\n        for (i = 0; i < 256; i++) {\n\n            j = i ? alog8[255 - log8[i]] : 0;\n\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n\n            j = (j ^ (j >> 8) ^ 99) & 255;\n\n            inv_sbox[j] = i;\n\n            sbox[i] = j;\n\n        }\n\n        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n\n                     log8, alog8, inv_sbox);\n\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n\n                     log8, alog8, sbox);\n\n    }\n\n\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n\n        return -1;\n\n\n\n    a->rounds = rounds;\n\n\n\n    memcpy(tk, key, KC * 4);\n\n\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n\n        t += KC * 4;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n\n        tk[0][0] ^= rcon[rconpointer++];\n\n\n\n        for (j = 1; j < KC; j++) {\n\n            if (KC != 8 || j != KC >> 1)\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= tk[j - 1][i];\n\n            else\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n\n        }\n\n    }\n\n\n\n    if (decrypt) {\n\n        for (i = 1; i < rounds; i++) {\n\n            av_aes_block tmp[3];\n\n            tmp[2] = a->round_key[i];\n\n            subshift(&tmp[1], 0, sbox);\n\n            mix(tmp, dec_multbl, 1, 3);\n\n            a->round_key[i] = tmp[0];\n\n        }\n\n    } else {\n\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6509, "substitutes": {"a": ["as", "na", "ea", "alpha", "ka", "aka", "la", "va", "asa", "aa", "b", "ap", "ad", "wa", "ae", "ia", "ace", "cha", "window", "ga", "f", "at", "att", "aj", "ack", "ai", "an", "e", "ak", "ar", "ata", "A", "ab", "access", "p", "ama", "aaa", "sta", "ca", "qa", "am", "acs", "sa", "c", "ta", "api", "ac", "au", "app", "aux", "img"], "key": ["row", "mix", "v", "entry", "fee", "ik", "channel", "ki", "enc", "ace", "mac", "q", "keys", "table", "ce", "code", "e", "ak", "w", "zip", "k", "sign", "self", "p", "ee", "temp", "input", "kw", "crypt", "ke", "ip", "Key", "pair", "ek", "text", "cache", "uk", "seed", "conn", "ok"], "key_bits": ["key_flags", "enc_bytes", "key_values", " key_bit", "key_nos", "Key_locks", "key64ops", "keydbits", "key_locks", "key___nos", "keyingflags", "Key_flags", "keyinglocks", "key64bytes", "key64pieces", "key_bit", " key_values", "keyingbytes", "keydbytes", "enc___boot", "keyingbits", "enc___bit", " key_pieces", "enc___bits", "key64bits", "enc_bit", "enc___nos", "key_ops", "enc_boot", "enc_nos", "keydvalues", "keydbit", "key___bits", "key_bytes", "key___bit", "key___boot", "key_pieces", "Key_bits", "enc_bits", "enc_flags", " key_bytes", "key_boot", " key_ops", "Key_bytes"], "decrypt": ["descenc", "deccrypt", "desccrypt", "dcenc", " decenc", "dccrypt", " dectext", "descrypt", "desctext", "dcrypt", " deccrypt", "decenc", "dectext", "dctext"], "i": ["gi", "ri", "o", "ti", "v", "id", "I", "ik", "di", "ci", "ji", "ni", "b", "x", "si", "io", "xi", "ani", "info", "bi", "m", "in", "qi", "ia", "ix", "l", "f", "pi", "yi", "phi", "d", "iu", "ii", "it", "ai", "ij", "u", "vi", "e", "ami", "uri", "ori", "k", "n", "multi", "mi", "ini", "ie", "p", "z", "eni", "oi", "ip", "g", "c", "y", "api", "li", "fi", "index", "zi", "ui"], "j": ["jet", "fr", "o", "ch", "v", "pr", "oj", "jl", "note", "ji", "ni", "b", "x", "si", "op", "data", "m", "body", "kj", "l", "f", "job", "d", "ii", "ij", "q", "aj", "obj", "e", "jen", "w", "J", "json", "jc", "k", "n", "uj", "jp", "jo", "ie", "p", "jit", "h", "z", "jj", "g", "y", "ja", "dj", "li", "adj", "syn", "bj", "js"], "t": ["ot", "o", "tf", "time", "ti", "te", "v", "s", "qt", "b", "x", "wt", "m", "pt", "l", "f", "offset", "at", "d", "tips", "u", "tim", "e", "w", "tn", "k", "n", "bot", "tm", "ts", "p", "temp", "tz", "h", "z", "c", "ta", "y", "dt", "tp", "tt", "T", "test", "r", "tc"], "tk": ["kit", "cut", "tek", "tf", "kin", "ti", "kn", "ik", "obb", "spec", "sw", "qt", "kk", "tr", "wt", "tu", "tty", "loc", "window", "tx", "sk", "K", "ijk", "awk", "dk", "oks", "it", "table", "ss", "kt", "unk", "km", "sc", "ak", "zip", "tw", "dc", "k", "tm", "ask", "su", "temp", "kw", "tz", "DC", "tile", "tip", "ta", "c", "txt", "tg", "cf", "tp", "ek", "tt", "text", "uk", "kr", "inch", "mk", "tc"], "log8": ["core88", "alog84", "Log8", "logor", " log88", "limor", "log32", "lim8", " log7", "Log32", " log32", "Log9", "alog16", "core2", "log9", "alog32", " log2", "Log16", "Log5", " log6", " log84", "alog7", "alogor", "log88", "alog08", " log08", "LOG8", "alog0", "LOG7", "log2", "LOG2", "lim08", " log16", " log5", " logor", " log9", " log4", "LOG9", "log16", "log6", "LOG84", "LOG88", "Log0", " log0", "log7", "log84", "log08", "core6", "core8", "LOG5", "Log4", "LOG6", "log4", "log5", "LOG4", "lim32", "log0"], "alog8": ["alogoo", "af08", "acloo", "LOGoo", " analog8", "alog7", " analog88", "aug18", "config7", "alog9", "og08", "config8", "LOG9", " catalog9", "afoo", " catalog8", " analogoy", "lang08", "lang9", "alg08", "LOG48", "og8", "core9", "LOG8", "aug08", "algoo", " catalogoy", "acl8", " analog9", " analog84", "ogoo", "imgoo", "acl18", "core8", "acl08", "abcoo", "ologoo", "acl9", " analog08", "acl88", "core88", "alog84", "core08", "og4", "aug88", "acl48", "lang88", "config08", "img8", "af4", "alog18", "img9", "olog8", "alogoy", "aug8", "alog88", "af8", "alog4", "ateg18", " catalog84", "ateg8", "alog08", "alog48", "abc08", "ateg88", "ateg08", "olog4", "olog08", "abc7", "img48", "alg8", "aphoy", "aph9", "aph84", "aph8", "configoo", "abc8", "alg7", "lang8"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n", "idx": 6519, "substitutes": {"ysrc": ["mysource", "yscur", "dsrs", "dsrt", "mysrt", "ysrt", "iesrc", "dssrc", "iessrc", "umsrc", "mysrc", "umsource", "ysource", "umscur", "yssrc", "iescur", "umssrc", "ysrs", "iesrt", "iesrs", "mysrs", "iesource", "myscur", "myssrc", "dsrc"], "usrc": ["aussrc", "urc", " usra", "vsra", "umsrc", " usource", "ausra", "umsource", "ausrc", "uource", "ussrc", "umssrc", "usra", "usource", "umsra", "ausource", "vsource", "vssrc", "ura", " ussrc"], "vsrc": ["lsrc", " vrb", "lst", "urc", "vrb", "fstat", "vsrb", " vstat", "ust", "vst", "sdest", "vstat", "ssrc", "lrc", "sst", "vsstat", "vdest", "udest", "ldest", "frc", "frb", "vrc", "fsrc", "vssrc", " vrc", "src"], "dst": ["Dst", "Dsrc", "adsrc", "adsc", "dsc", "ldst", "Dsts", "cdsc", "dsts", " dsrc", "adsts", "ldsc", "Dsc", "cdsrc", " dsts", " dsc", "ldsrc", "ldsts", "adst", "cdst", "cdsts", "dsrc"], "height": ["Height", "padding", "id", "alpha", "shape", "distance", "layout", "inches", "x", "data", "crop", "gap", "rows", "bottom", "image", "ty", "window", "d", "length", "dist", "align", "duration", "resolution", "high", "deep", "depth", "angle", "above", "pad", "border", "stroke", "density", "img", "hd", "dim", "size"], "lumStride": ["lumSTride", "lnumStrite", "lumStro", "lumEstride", "lumStyride", "lumStyerve", "lnumStro", "lumStyrip", "lnumSTrite", "lumaSterve", "lumsterve", "lumSTrip", "lumaStrip", "lumaStride", "lumEstro", "lumaStro", "lumStrip", "lumstrip", "lumSTrite", "lumaSTrip", "lumaSTride", "lumstrite", "lnumSTride", "lumstro", "lumaSTro", "lumEstrite", "lumSTerve", "lnumSTro", "lumSTro", "lumstride", "lumStyro", "lumSterve", "lumStrite", "lumaSTerve", "lnumStride"], "chromStride": ["pixelSTro", "chromSTro", "pixelSTide", "pixelSTride", "chromStrrip", "opalSTide", "chromstro", "opalStide", "chromSTide", "chromStrride", "opalStrip", "chromStro", "pixelStide", "pixelSTrite", "chromStrite", "chromSTrite", "chromSTrip", "opalSTrite", "opalStride", "opalStrite", "pixelStrite", "opalSTrip", "pixelStro", "chromstide", "chromstride", "chromStide", "opalSTride", "chromStrip", "chromStrrite", "chromSTride", "pixelStride", "chromstrite"], "dstStride": ["dscStide", "dscSTride", "dstStrr", "dstRestro", "dstRestrip", "dstRestride", "dostStride", "dstStrride", "dststr", "dstRestr", "dstRestri", "dscStro", "dostStrr", "dststro", "dscStrip", "dstRestide", "dostStri", "dstStrro", "dostStro", "dscSTro", "dstSTro", "dstStrri", "dstStri", "dstSTide", "dstSTrip", "dstStro", "dstStide", "dscSTide", "dstStrip", "dscStride", "dststride", "dscSTrip", "dostStr", "dstSTride", "dostStrro", "dostStrri", "dostStrride", "dststri", "dstStr"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);\n\n    if (drc) {\n\n        drc_index = spapr_drc_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset, false);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));\n\n    }\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 6524, "substitutes": {"cs": ["spec", "ci", "nc", "cus", "sync", "ced", "sys", "cing", "ix", "sk", "ns", "ls", "pc", "cc", "ce", "ics", "CS", "cons", "sc", "vs", "ck", "ks", "qs", "ds", "ces", "wcs", "cms", "ctx", "ec", "ca", "css", "gb", "acs", "fs", "c", "cn", "core", "lc", "cf", "vc", "cache", "ras", "cas", "ps"], "fdt": ["ldt", "ffn", "gradtt", "dfts", "ldts", "vdn", "FDn", "FDt", "iddte", "fednt", "iddtt", "gradt", "fdn", "iddt", "dfp", "fedp", "fdtt", "fft", "ebT", "dfn", "ldtn", "ffp", "vdts", "ebt", "ldte", "fdts", "fedt", "ffnt", "fdp", "fxte", "dft", "ebtt", "fedn", "fdT", "ldtt", "gradT", "fxtn", "fdnt", "vdT", "fdtn", "fxt", "ldT", "ebts", "fdte", "vdt", "dfT", "fxtt", "FDts", "iddtn", "FDT", "gradts", "dfnt"], "offset": ["address", "append", "o", "position", "padding", "reset", "origin", "axis", "open", "annot", "parent", "unknown", "starting", "rot", "layout", "alias", "sync", "slice", "shift", "Offset", "phase", "loc", "missing", "limit", "length", "align", "outer", "initial", "part", "exclusive", "error", "online", "timeout", "fp", "prefix", "output", "operation", "pos", "start", "off", "location", "addr", "iso", "include", "index", "set", "seed", "trace", "optional", "slot"], "spapr": ["spappr", "spAPrs", "spamprs", "spaxc", "spapsc", " spapsnr", "spaxnr", "instamprs", "spapprs", "spappnr", "spappc", "spappbr", "spaprs", "spAPbr", "spapsR", "instampR", "instampbr", "spaxr", "spaxR", "spampR", " spapsc", "instapR", "instampr", "spappR", "spampbr", "spapsr", " spapsR", "instapbr", "spAPr", "spAPR", " spapsr", " spapR", "spapsnr", "instapr", " spapnr", "spapR", "spapbr", "spampr", " spapc", "spapc", "instaprs", "spapnr"], "cpu": ["cp", "prem", "gp", "cmp", "hw", "CP", "lb", "chip", "mem", "pai", "platform", "pu", "vm", "component", "device", "config", "nc", "socket", " CPU", "gpu", "unit", "px", "uci", "pc", "linux", "cc", "np", "nic", "proxy", "clock", "dc", "instance", "ctx", "bc", "cu", "process", "processor", "boot", "frame", "node", "c", "GPU", "proc", "cn", "core", "lc", "thread", "fc", "cow", "cache", "loader", "CPU", "conn"], "env": ["energy", "ea", "ef", "scope", "config", "esp", "environment", "exc", "style", "oa", "enc", "eu", "profile", "export", "ext", "gui", "exe", "args", "conf", "ev", "dir", "np", "e", "en", "path", "visor", "estate", "err", "equ", "ec", "opt", "eni", "viron", "shell", "core", "skin", "desc"], "pcc": ["Pcc", "ccc", "cpCC", "cpcc", "pcm", "ccca", "PCC", "cCC", "cpcca", "cpcm", "pCC", "Pcca", "Pcm", "ccm", "pcca"], "segs": ["peg", "pegm", "persegs", "pegs", "pegments", "megs", "megments", "persegm", "meg", "segm", "perseg", "segments", "megm", "seg", "persegments"], "page_sizes_prop": ["page_size_pro", "page_sizes_part", "page_size_prop", "page_sizes_property", "page_size_part", "page_size_property", "page_sizes_pro"], "page_sizes_prop_size": ["page_sizes_prop_g", "page_sizes_prop_2", "page_sizes_by_size", "page_sizes_by_g", "page_sizes_by_2", "page_sizes_prop_len", "page_sizes_by_len"], "pft_size_prop": ["pft_size__cp", "pft_size_list", "pft_sec_property", "pft_size__list", "pft_size__property", "pft_sec_prop", "pft_size_cp", "pft_sec_cp", "pft_size_property", "pft_sec_list", "pft_size__prop"], "drc": ["drec", "sdpc", "ldRC", "drs", "Dsrc", "sdRC", "dssrc", "madRC", "bdrc", "dRC", "dsRC", "pRC", "madrc", "bdsrc", " dsrc", "sdrs", "bdrec", "bdRC", " dpc", "psrc", "ldsrc", "Dpc", "ldrc", "madrec", "ldpc", "Drs", "sdrc", "dpc", "DRC", "madsrc", "dspc", " dRC", "prc", "Drec", "dsrc", " drs", "Drc"], "drc_index": ["drc_Index", "duc_index", "dfc_index", "drc_len", "dfc_len", "drc2index", "dfc_Index", "duc_id", "dfc_name", "drc2name", "drc_ini", "drc_id", "drc_name", "dfc_offset", "drc_length", "dfc_ini", "drc2value", "drc_value", "drc2offset", "dfc_value", "duc_length", "drc_offset"], "radix_AP_encodings": ["radix_page_encodINGS", "radix_page_ENCoders", "radix_page_encODINGS", "radix_page_encodesINGS", "radix_page_encodesing", "radix_page_encoding", "radix_page_ENCodings", "radix_page_ENCoding", "radix_page_ENCodINGS", "radix_page_encoderINGS", "radix_page_encoderers", "radix_page_encoders", "radix_page_encodings", "radix_page_ENCODings", "radix_page_encodesers", "radix_page_encODings", "radix_page_ENCODers", "radix_page_ENCODINGS", "radix_page_ENCODing", "radix_page_encODers", "radix_page_encoderings", "radix_page_encodesings", "radix_page_encODing", "radix_page_encodering"], "i": ["ti", "v", "id", "I", "is", "a", "data", "io", "si", "bi", "in", "qi", "l", "f", "j", "ii", "iu", "it", "u", "e", "interface", "n", "multi", "p", "z", "c", "ip", "ui"]}}
{"project": "qemu", "commit_id": "f94d18d6c6df388fde196d3ab252f57e33843a8b", "target": 0, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        xhci_ep_free_xfer(epctx->retry);\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 6532, "substitutes": {"epctx": ["eptx", "epcoll", "pplc", "epslc", "mpchan", "Epctx", "ipctx", "ekcontext", "epsctx", "mpcf", "epscmp", " epctr", "ppctx", "ppcb", "mpconfig", " eprc", " epcmp", "epsconfig", "ekcoll", "epchan", "epcf", "ppcontext", "epscontext", "evcb", "evcontext", "epcache", "ypcmp", "mpcoll", "mpctr", "epcmp", "epscb", "epconfig", "ekctr", "ypctx", "mprc", "mpctx", "ekctx", "mplc", "eprc", "mpcb", "ppcache", "Epcontext", "mpcache", "ypconfig", "ipcontext", "ekchan", "epctr", "ypcontext", "epcontext", "mptx", "eplc", "epsrc", "eklc", "ekcache", "ypcb", "pptx", "epstx", "evtx", "ipcb", "epcb", "ekcf", " epcoll", "yptx", "mpcmp", "ipcmp", "Epcf", "ppcmp", "Epchan", "evctx", "mpcontext", " epcontext"], "streamid": [" streamtype", "reamname", "reamId", "pooltype", "streamtype", " streamID", "poolId", "poolname", " streamId", "streamID", "streamId", "poolid", " streamname", "reamID", "reamtype", "streamname", "reamid", "poolID"], "xhci": ["xehdi", "workhlc", "xhlc", "exhoci", "xhdci", "xhdcli", "xhsci", "xhoci", "xhldi", "workhscit", "exhsi", "xhdcin", "workhci", "xmcycle", "wxhco", "xhcci", "xxhsco", "xhdc", "xhcu", "xhscci", "workhni", "ixhcin", "xhai", "wxhsci", "wxhsni", "xahcit", "xrhci", "xehoci", "xhloci", "xhddi", "workhsai", "workhslc", "xhcm", "ixhcycle", "wxhsco", "ixhdcycle", "xehsi", "xbhcu", "xhmci", "xhcit", "xehcu", "xhni", "xvcm", "xxhsci", "wxhni", "xehci", "ixhci", "xhsdc", "yehcci", "xhcli", "xhmcli", "xvcci", "ixhdcin", "xhsi", "exehci", "xrhni", "workhsdi", "ixhcli", "ixhdci", "xbhcci", "yhcit", "workhdi", "xhdcycle", "xxhci", "xhllc", "xahco", "xhcycle", "xvcu", "workhai", "xvcit", "xmcin", "xmcli", "xvco", "yhcu", "xrhcit", "xhdsi", "xehni", "wxhscci", "xvlc", "xhdoci", "xehco", "xehcci", "xxhscm", "workhsci", "xhsdi", "yehcu", "xmci", "yehci", "xhmcin", "xvdi", "xhlsi", "xhldc", "xxhcm", "exehsi", "xehcm", "exehdi", "exhdi", "xhscit", "xrhai", "xhmcycle", "workhdc", "xhdi", "workhcit", "yhcci", "xbhci", "xhsni", "xhslc", "xbhcit", "xvci", "exehoci", "wxhcci", "xvdc", "xxhco", "xahcci", "workhsni", "xahai", "xhsco", "xhlci", "ixhdcli", "workhsdc", "xxhscci", "xahni", "yehcit", "exhci", "xhscm", "xhsai", "xxhcci", "xahci", "xhco", "wxhci", "yhci", "xehcit", "xhcin"], "stctx": ["artcontext", "epconf", "crcontext", "crconf", "crctx", "stconf", "artctx", "stcontext", "crconn", "artconn", "artconf", "epcontext", "stconn", "epconn"], "xfer": ["yter", "sexfr", "interper", "ytransfer", "yclude", "swfr", "fuelFER", " xper", "yher", " xcer", "crossper", "Xher", "axmer", "axFER", "fxporter", "axporter", "crossferred", "xper", "hardfort", "workger", "interpper", "xxFER", "Xfar", "wxpire", "yfort", "xxfar", "xxception", "crossmer", "sexporter", "axcer", "xpire", "lexf", " xception", "fxper", "crossger", "axher", " xmor", "axferred", "lexference", "helcer", "xyference", "xcer", "swper", "swger", "wxf", "yfr", "axpper", "Xporter", " xber", "xher", "crossFER", "workfr", " xclude", "xporter", "xxferred", "broadfer", "broadpper", "fxference", "xxpire", "xyfar", "xxter", "helference", "xfr", "sexfer", "crossporter", "fxferred", "xger", "lexporter", "swfer", "fuelfer", "crosspper", "Xter", " xter", "helfer", "fuelporter", " xf", "infer", "xxher", " xporter", "xpper", "Xcer", "Xfer", "Xfr", " xtransfer", "inference", "yper", "wxference", " xpper", "wxfr", "crosscer", "hardference", "Xference", "xtransfer", "axference", "broadferred", "lexher", "interfer", "fxfer", "xter", "yfer", "crossfer", "axfr", "XFER", "xyfer", "xfar", "xf", "crossference", "lexber", "wxfer", "lexmer", "xxper", " xpire", "yporter", "xclude", "fxFER", "lexfer", "lexfr", "xxporter", "workference", "workcer", "xxfer", "helpire", "xfort", "xception", " xher", " xfr", "ypire", "workf", "xxference", "workception", "sexfort", "xxmor", "interference", "workporter", "xber", "workfer", "hardfer", "Xpire", "xmor", "xference", "wxcer", "Xtransfer", "inFER", "sexference", "xferred", "axpire", "axclude", "crossfr", "fuelferred", "xFER", "broadcer", "ymor", "xmer", "xxger", "crosspire", "hardporter", "yference", "axber", "fxpper", "crossher", " xger", "axper", "inporter", "axfer", " xFER", "xxtransfer", "xyter", "yger", " xference"], "ring": ["rw", "ig", "reg", "rr", "Ring", "spec", "chain", "binding", "RW", "ING", "ng", "rss", "file", "path", "RP", "str", "amp", "root", "rings", "remote", "range", "orig", "RR", "link", "pair", "ref", "rs", "prefix"], "ep": ["cp", "yp", "gp", "eng", "imp", "elf", "ever", "ef", "channel", "plug", "gap", "pp", "wp", "pipe", "ap", "lp", "enc", "peer", "EP", "package", "mp", "ext", "eq", "ream", "Ep", "ev", "e", "dp", "eg", "dc", "exec", "fp", "eps", "p", "ee", "amp", "ec", "vp", "sp", "cap", "ip", "dep", "env", "pkg"], "mfindex": [" mfopen", "mfopen", "mfpIndex", "mdfindex", "umvindex", "mfwIndex", "MFname", "mFname", "mfwindex", " mrfopen", "mfnumber", "mfwname", "mfpid", "Mfname", "MfIndex", "mflevel", " mrfid", "mFIndex", "mfIndex", " mrfindex", "mvlevel", "Mfnumber", " mfid", "mrfopen", "mfpinc", "umfindex", "umvinc", "mdfinc", "mfpindex", "umfdate", "MFnumber", "mfid", "mvindex", "mvdate", "umvlevel", "mvinc", "mFopen", "MFIndex", "mfwnumber", "mfdate", "mrfid", "umfinc", "mfpopen", "mdfdate", "mFindex", "mfpdate", "MFindex", "umflevel", " mfIndex", "mFid", "mdflevel", "Mfindex", "mrfIndex", "umvdate", "mfname", "mfinc", " mrfIndex", "mrfindex", "mfplevel", "mFnumber"], "length": ["padding", "count", "total", "shape", " lengths", "style", "Length", "loc", "sequence", "weight", "match", "duration", "impl", "len", "path", "load", "ptr", "ength", "size"], "i": ["o", "id", "I", "is", "a", "s", "list", "b", "io", "or", "info", "l", "f", "pi", "d", "code", "e", "n", "p", "h", "z", "start", "c", "ip", "ed", "end"]}}
{"project": "FFmpeg", "commit_id": "b04665ac028d26747396eaf4dbf9188225a6f2a1", "target": 0, "func": "static int opt_preset(const char *opt, const char *arg)\n\n{\n\n    FILE *f=NULL;\n\n    char filename[1000], tmp[1000], tmp2[1000], line[1000];\n\n    int i;\n\n    const char *base[3]= { getenv(\"HOME\"),\n\n                           \"/usr/local/share\",\n\n                           \"/usr/share\",\n\n                         };\n\n\n\n    for(i=!base[0]; i<3 && !f; i++){\n\n        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);\n\n        f= fopen(filename, \"r\");\n\n        if(!f){\n\n            char *codec_name= *opt == 'v' ? video_codec_name :\n\n                              *opt == 'a' ? audio_codec_name :\n\n                                            subtitle_codec_name;\n\n            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i],  i ? \"\" : \".\", codec_name, arg);\n\n            f= fopen(filename, \"r\");\n\n        }\n\n    }\n\n    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n\n              is_dos_path(arg))){\n\n        snprintf(filename, sizeof(filename), arg);\n\n        f= fopen(filename, \"r\");\n\n    }\n\n\n\n    if(!f){\n\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n\n        av_exit(1);\n\n    }\n\n\n\n    while(!feof(f)){\n\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n\n        if(line[0] == '#' && !e)\n\n            continue;\n\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n\n        if(e){\n\n            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);\n\n            av_exit(1);\n\n        }\n\n        if(!strcmp(tmp, \"acodec\")){\n\n            opt_audio_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"vcodec\")){\n\n            opt_video_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"scodec\")){\n\n            opt_subtitle_codec(tmp2);\n\n        }else if(opt_default(tmp, tmp2) < 0){\n\n            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);\n\n            av_exit(1);\n\n        }\n\n    }\n\n\n\n    fclose(f);\n\n\n\n    return 0;\n\n}\n", "idx": 6535, "substitutes": {"opt": ["pot", "option", "options", "oc", "o", "iter", "alt", "parent", "config", "op", "expr", "token", "format", "enc", "cat", "loc", "altern", "tag", "optim", "ott", "key", "attr", "ext", "url", "prot", "sl", "obj", "init", "param", "Opt", "cho", "path", "oss", "feat", "temp", "usr", "prop", "iv", "pos", "proc", "orig", "type", "comb", "term", "fi", "optional", "prefix"], "arg": ["option", "name", "extra", "flag", "ig", "ag", "sec", "al", "entry", " argument", "word", "config", "val", "op", "use", "ax", "inter", "enc", "cat", "ad", "slice", "image", "loc", "ace", "key", "mac", "valid", "argument", "inc", "ext", "call", "url", "args", "param", "arc", "match", "ar", "item", "target", "arr", "file", "en", "rg", "path", "other", "pass", "exec", "p", "input", "parse", "amp", "star", "Arg", "gen", "doc", "var", "ge", "g", "lc", "ac", "par", "neg", "end"], "f": ["fen", "full", "fr", "o", "tf", "feed", "sf", "inf", "v", "ef", "b", "rf", "info", "m", "fb", "l", "uf", "found", "d", "j", "fl", "q", "fe", "u", "e", "w", "file", "func", "t", "fn", "df", "n", "ff", "xf", "fp", "field", "fa", "p", "fm", "h", "z", "fs", "fun", "c", "g", "fd", "cf", "y", "bf", "fc", "handler", "fi", "form", "lf", "r", "F"], "filename": ["sf", "rb", "password", "database", "buf", "job", "nm", "phrase", "sheet", "document", "len", "addin", "connection", "file", "json", "fp", "nil", "theme", "upload", "audio", "folder", "msg", "verb", "name", "kn", "word", "config", "Filename", "fb", "url", "which", "fil", "uri", "binary", "path", "font", "txt", "type", "size", "archive", "nl", "mpeg", "username", "loc", "image", "title", "profile", "wb", "lace", "package", "metadata", "cli", "download", "message", "whatever", "dll", "feat", "source", "frame", "shell", "location", "fd", "loader", "prefix", "session", "length", "fn", "jpg", "lvl", "ln", "kl", "bf", "il", "figure", "skin", "dyl", "sample", "generic", "directory"], "tmp": ["appy", "rb", "mobi", "data", "perm", "buf", "mp", "tab", "buffer", "file", "fp", "output", "sp", "proc", "ppa", "page", "tp", "upload", "img", "folder", "cp", "name", "config", "kk", "slice", "tty", "fake", "fb", "param", "duration", "zip", "path", "txt", "mm", "video", "text", "test", "cpp", "area", "time", "md", "username", "now", "home", "image", "loc", "csv", "package", "metadata", "obj", "stuff", "py", "cli", "source", "temp", "pos", "start", "c", "api", "cache", "src", "seed", "prefix", "cmp", "v", "pre", "tem", "space", "dir", "pty", "sample", "cdn", "diff", "mk"], "tmp2": ["mpall", "tmp5", "temp2", "temp8", "tmp8", " tmp5", "tmp4", " tmpout", "tmpall", "fake2", "mpout", " tmp4", "tmp1", "tempTwo", "address2", "tmpout", "cppTwo", "mp2", " tmp8", "cpp1", "temp4", "fake1", "address1", "mp8", "fakeTwo", "cpp2", " tmpall", "mp5", " tmp1", "txt1", "tmpTwo", "mpTwo", "mp1", "addressTwo", "txt2", "temp1", "tempout", "txt5", "mp4", "fake8", "txtall", "txt4"], "line": ["LINE", "name", "nl", "row", "time", "block", "v", "el", "entry", "word", "co", "m", "loc", "l", "call", "url", "d", "j", "match", "Line", "ine", "code", "len", "cell", "e", "error", "buffer", "out", "file", "n", "err", "source", "p", "ne", "temp", "run", "frame", "pos", "ln", "c", "range", "page", "lin", "lc", "fd", "link", "user", "lines", "lf", "r", "end"], "i": ["gi", "name", "o", "ti", "v", "id", "I", "count", "a", "di", "s", "ci", "ni", "x", "xi", "b", "io", "si", "slice", "abi", "ri", "bi", "m", "qi", "ix", "l", "key", "pi", "yi", "phi", "j", "ii", "iu", "d", "it", "ai", "u", "part", "e", "uri", "t", "k", "n", "multi", "ini", "ie", "p", "start", "oi", "hi", "c", "ip", "page", "y", "type", "li", "fi", "index", "zi", "mu", "ui"], "base": ["bas", "name", "absolute", "area", "extra", "bin", "block", "store", "v", "http", "id", "chain", "config", "pre", "list", "b", "home", "cat", "bi", "body", "ace", "null", "l", "key", "ma", "url", "space", "param", "buffer", "part", "se", "file", "pad", "ase", "nb", "fa", "source", "p", "temp", "array", "root", "Base", "run", "frame", "based", "start", "tree", "handler", "core", "api", "ac", "cache", "index", "prefix"], "codec_name": ["codecskey", "codenc_anc", "codecstype", "codenc_key", "codecsname", "codec2key", "codef_name", "codef_key", "codec2type", "codec2name", "codec_id", "codef_type", "codec_type", "codecsanc", "codec2id", "codenc_type", "codenc_name", "codec_anc", "codec_key", "codef_id"]}}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n", "idx": 6543, "substitutes": {"s": ["types", "o", "sf", "v", "a", "S", "spec", "sg", "b", "si", "sys", "ses", "services", "m", "l", "xs", "f", "ns", "sl", "ls", "service", "bs", "cs", "ss", "us", "sis", "e", "sc", "sb", "gs", "se", "w", "t", "ds", "n", "ctx", "qs", "ts", "su", "self", "p", "aws", "sv", "sp", "sa", "c", "os", "ssl", "sq", "es", "rs", "r", "ps"], "g": ["groups", "gp", "gc", "cfg", "ig", "reg", "vg", "gm", "al", "sg", "m", "G", "gu", "ga", "pg", "org", "e", "mc", "w", "gs", "rg", "p", "gb", "ge", "tg", "gd", "gg", "group"], "asf": [" asF", "asfs", "ASF", "ASfm", " ascf", "Asfs", "asF", "assf", "ASf", "nascf", "psF", "nasfs", " asfs", "assF", "asfm", "assfm", "AsF", "ASfs", "nasF", "nasf", "Ascf", "psfs", "assfs", "psf", "Asf", "psfm", "ascf"], "pb": ["hp", "cp", "gp", "bp", "lb", "ib", "hub", "platform", "pa", "rb", "b", "pd", "pp", "bps", "wp", "bm", "typ", "lp", "uc", "fb", "db", "wb", "uf", "pm", "pg", "mp", "meta", "prot", "metadata", "obj", "pc", "py", "xb", "np", "eb", "dp", "sb", "parser", "ctx", "bc", "PB", "fp", "jp", "cb", "ab", "p", "summary", "asm", "vp", "prop", "gb", "primary", "ppa", "ub", "proc", "bf", "lc", "api", "tp", "fc", "cv", "pl", "ref", "rob", "cpp", "bh", "pkg"], "i": ["uni", "gi", "ti", "v", "id", "I", "count", "chi", "di", "ci", "ki", "ji", "ni", "b", "x", "xi", "si", "ri", "bi", "in", "qi", "l", "gu", "f", "pi", "phi", "d", "ii", "j", "iu", "ai", "e", "len", "ami", "uri", "en", "k", "t", "n", "multi", "mi", "ini", "p", "h", "z", "oi", "hi", "c", "ind", "ip", "li", "fi", "index", "r", "zi", "mu", "ui"], "ret": ["flag", "reg", "mem", "rt", "alt", "val", "rc", "data", "bit", "info", "reply", "status", "lit", "job", "att", "j", "obj", "arg", "bad", "res", "match", "def", "code", "len", "det", "error", "out", "en", "RET", "str", "result", "Ret", "ft", "usr", "re", "fun", "back", "resp", "utf", "success", "ref", "rep", "r", "rets"], "name_len": ["key_val", "ni_pos", "name___pos", "name_pos", "name_length", "pass_len", "name_Len", "niJsize", "Name_val", "Name_pos", "name_size", "nameJLen", "ni_Len", "named_ln", "name_val", "nameIPlength", "namevval", "passIPlen", "name2val", "niJlen", "niJpos", "Name_Len", "nameJsize", "passIPlength", "named___length", "nameJpos", "nameIPln", "key_pos", "name_ln", "name___length", "Name_len", "named_pos", "named_len", "ni_size", "name___ln", "namevpos", "niJLen", "Name_length", "name2len", "key_ln", "nameIPlen", "nameIPval", "named_length", "named___pos", "pass_length", "name2Len", "passIPval", "Name_lf", "pass_val", "name2pos", "namevln", "passIPln", "ni_len", "named___ln", "nameJlen", "name_lf", "named___len", "namevlen", "key_len", "name___len", "pass_ln"], "type": ["types", "o", "time", "id", "shape", "value", "sort", "pre", "single", "TYPE", "val", "op", "style", "typ", "format", "rel", "info", "pe", "unit", "key", "ty", "like", "null", "attr", "order", "url", "weight", "length", "py", "part", "kind", "col", "comment", "t", "ype", "field", "other", "p", "none", "class", "label", "y", "ref", "Type", "size"], "val_len": ["valinglength", "valnlan", "val_lin", "val_lf", " val_lin", " name_lin", "val2len", "val_size", "val5lin", " nameingl", "valinglin", "val8len", "valnlen", "valinglen", "val5span", "val2length", "val5lf", " val_lf", "val_length", "Val_len", "val2lin", " nameinglength", "Val_lan", "val8lf", " nameinglen", "val8span", " val_span", " name_length", "val2l", "val_span", "valingl", " nameinglin", " name_l", "val_lan", "valnsize", "Val_size", "val8lin", "val_l", "val5len"], "name": ["base", "option", "address", "o", "time", "anc", "id", "parent", "value", "word", "ni", "x", "val", "data", "alias", "named", "info", "image", "names", "missing", "key", "null", "meta", "version", "call", "nm", "description", "member", "def", "Name", "part", "size", "NAME", "number", "comment", "ame", "n", "path", "instance", "pass", "common", "none", "new", "label", "no", "prefix"]}}
{"project": "qemu", "commit_id": "3f910692c287e1c611c00e763ebeb95ed0e017f8", "target": 1, "func": "static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n\n                          void *data, uint32_t length, uint64_t offset)\n\n{\n\n    int ret = 0;\n\n    void *buffer = NULL;\n\n    void *merged_sector = NULL;\n\n    void *data_tmp, *sector_write;\n\n    unsigned int i;\n\n    int sector_offset;\n\n    uint32_t desc_sectors, sectors, total_length;\n\n    uint32_t sectors_written = 0;\n\n    uint32_t aligned_length;\n\n    uint32_t leading_length = 0;\n\n    uint32_t trailing_length = 0;\n\n    uint32_t partial_sectors = 0;\n\n    uint32_t bytes_written = 0;\n\n    uint64_t file_offset;\n\n    VHDXHeader *header;\n\n    VHDXLogEntryHeader new_hdr;\n\n    VHDXLogDescriptor *new_desc = NULL;\n\n    VHDXLogDataSector *data_sector = NULL;\n\n    MSGUID new_guid = { 0 };\n\n\n\n    header = s->headers[s->curr_header];\n\n\n\n    /* need to have offset read data, and be on 4096 byte boundary */\n\n\n\n    if (length > header->log_length) {\n\n        /* no log present.  we could create a log here instead of failing */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    if (guid_eq(header->log_guid, zero_guid)) {\n\n        vhdx_guid_generate(&new_guid);\n\n        vhdx_update_headers(bs, s, false, &new_guid);\n\n    } else {\n\n        /* currently, we require that the log be flushed after\n\n         * every write. */\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n\n\n    /* 0 is an invalid sequence number, but may also represent the first\n\n     * log write (or a wrapped seq) */\n\n    if (s->log.sequence == 0) {\n\n        s->log.sequence = 1;\n\n    }\n\n\n\n    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n\n    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;\n\n\n\n    aligned_length = length;\n\n\n\n    /* add in the unaligned head and tail bytes */\n\n    if (sector_offset) {\n\n        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n\n        leading_length = leading_length > length ? length : leading_length;\n\n        aligned_length -= leading_length;\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;\n\n    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);\n\n    if (trailing_length) {\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors += partial_sectors;\n\n\n\n    /* sectors is now how many sectors the data itself takes, not\n\n     * including the header and descriptor metadata */\n\n\n\n    new_hdr = (VHDXLogEntryHeader) {\n\n                .signature           = VHDX_LOG_SIGNATURE,\n\n                .tail                = s->log.tail,\n\n                .sequence_number     = s->log.sequence,\n\n                .descriptor_count    = sectors,\n\n                .reserved            = 0,\n\n                .flushed_file_offset = bdrv_getlength(bs->file->bs),\n\n                .last_file_offset    = bdrv_getlength(bs->file->bs),\n\n              };\n\n\n\n    new_hdr.log_guid = header->log_guid;\n\n\n\n    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n\n\n\n    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;\n\n    new_hdr.entry_length = total_length;\n\n\n\n    vhdx_log_entry_hdr_le_export(&new_hdr);\n\n\n\n    buffer = qemu_blockalign(bs, total_length);\n\n    memcpy(buffer, &new_hdr, sizeof(new_hdr));\n\n\n\n    new_desc = buffer + sizeof(new_hdr);\n\n    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n\n    data_tmp = data;\n\n\n\n    /* All log sectors are 4KB, so for any partial sectors we must\n\n     * merge the data with preexisting data from the final file\n\n     * destination */\n\n    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n\n\n\n    for (i = 0; i < sectors; i++) {\n\n        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;\n\n        new_desc->sequence_number = s->log.sequence;\n\n        new_desc->file_offset     = file_offset;\n\n\n\n        if (i == 0 && leading_length) {\n\n            /* partial sector at the front of the buffer */\n\n            ret = bdrv_pread(bs->file, file_offset, merged_sector,\n\n                             VHDX_LOG_SECTOR_SIZE);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n\n            bytes_written = leading_length;\n\n            sector_write = merged_sector;\n\n        } else if (i == sectors - 1 && trailing_length) {\n\n            /* partial sector at the end of the buffer */\n\n            ret = bdrv_pread(bs->file,\n\n                            file_offset,\n\n                            merged_sector + trailing_length,\n\n                            VHDX_LOG_SECTOR_SIZE - trailing_length);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector, data_tmp, trailing_length);\n\n            bytes_written = trailing_length;\n\n            sector_write = merged_sector;\n\n        } else {\n\n            bytes_written = VHDX_LOG_SECTOR_SIZE;\n\n            sector_write = data_tmp;\n\n        }\n\n\n\n        /* populate the raw sector data into the proper structures,\n\n         * as well as update the descriptor, and convert to proper\n\n         * endianness */\n\n        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,\n\n                                  s->log.sequence);\n\n\n\n        data_tmp += bytes_written;\n\n        data_sector++;\n\n        new_desc++;\n\n        file_offset += VHDX_LOG_SECTOR_SIZE;\n\n    }\n\n\n\n    /* checksum covers entire entry, from the log header through the\n\n     * last data sector */\n\n    vhdx_update_checksum(buffer, total_length,\n\n                         offsetof(VHDXLogEntryHeader, checksum));\n\n\n\n    /* now write to the log */\n\n    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,\n\n                                 desc_sectors + sectors);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    if (sectors_written != desc_sectors + sectors) {\n\n        /* instead of failing, we could flush the log here */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->log.sequence++;\n\n    /* write new tail */\n\n    s->log.tail = s->log.write;\n\n\n\nexit:\n\n    qemu_vfree(buffer);\n\n    qemu_vfree(merged_sector);\n\n    return ret;\n\n}\n", "idx": 6545, "substitutes": {"bs": ["bas", "base", "as", "ins", "b", "ses", "bi", "BS", "fb", "db", "ns", "ls", "bb", "cs", "ss", "us", "vs", "sb", "gs", "ks", "ds", "qs", "bc", "ts", "blocks", "fs", "utils", "os", "bos", "bid", "bl", "es", "rs", "pb", "ps", "js"], "s": ["stat", "sets", "sf", "v", "is", "S", "http", "spec", "sg", "session", "comments", "b", "socket", "si", "sync", "sys", "ses", "services", "status", "states", "f", "client", "ns", "state", "stats", "sl", "server", "d", "space", "service", "ss", "cs", "conf", "sis", "e", "sie", "sb", "gs", "ds", "storage", "n", "qs", "su", "self", "p", "summary", "settings", "aws", "sv", "fs", "c", "os", "g", "ssl", "sq", "sym", "site", "rs", "r", "manager", "ps", "js"], "data": ["base", "block", "entry", "dat", "session", "config", "slice", "database", "body", "buf", "state", "d", "DATA", "def", "ops", "message", "Data", "bytes", "response", "source", "p", "reader", "batch", "partial", "next", "size"], "length": ["base", "address", "build", "position", "padding", "available", "block", "count", "total", "shape", "distance", "value", "style", "slice", "Length", "specified", "support", "l", "url", "limit", "maximum", "ph", "duration", "delay", "len", "number", "match", "section", "depth", "angle", "message", "full", "path", "join", "filename", "lock", "load", "end", "range", "type", "ength", "partial", "tail", "size"], "offset": ["base", "address", "afi", "o", "position", "padding", "origin", "reset", "alpha", "entry", "fee", "gap", "slice", "format", "Offset", "phase", "loc", "limit", "align", "delay", "initial", "number", "size", "part", "exclusive", "error", "online", "pad", "timeout", "operation", "pos", "pointer", "start", "attribute", "off", "range", "location", "iso", "slot", "index", "set", "seed", "end", "prefix"], "buffer": ["writer", "buff", "iter", "block", "bin", "entry", "channel", "uffer", "queue", "body", "buf", "window", "f", "byte", "Buffer", "message", "binary", "bc", "source", "input", "output", "reader", "batch", "transfer", "memory", "read", "summary"], "merged_sector": ["merged_section", "merger_component", "merged_channel", "merged_component", "merger_sector", "merger_channel", "merger_section"], "data_tmp": ["data_dest", "data_rb", "data_temp", " data_rb", " data_temp", " data_dest"], "sector_write": ["sector___set", "sector_data", "sector___only", "sector_set", "sector___data", " sector_only", " sector_data", "sector_only", " sector_set", "sector___write"], "i": ["id", "I", "a", "count", "b", "x", "io", "or", "info", "l", "f", "d", "j", "e", "len", "n", "p", "type", "end"], "sector_offset": ["sector__offset", "sectoringno", "sector8pad", "headeralangle", "header_angle", "sectoringaddress", "reader_set", "sector_addr", "sector_pos", "headeralpad", "sector___size", "sector64pad", "system_address", "system_offset", "sector64no", "sector_size", "sector_no", "sector8area", " section_pos", "sectoralpad", "sectoringlocation", "sector6address", "sector8angle", "sector_set", "sector_area", "header_offset", "sector_address", "sector8offset", " section_offset", "systemingaddress", " section_size", "reader_addr", "sector___offset", "sector6no", "sector_pad", "reader_offset", "sector64angle", "header_area", "header_pad", "sector_location", "sectoringoffset", "sector6offset", "system_location", "sector64area", "sector6location", "sector___pos", "reader_position", "sector_angle", "sector64address", "sectoralarea", "sectoralangle", "sector64offset", "systemingoffset", "headeralarea", "systemingno", "sector___Offset", " section_Offset", "sector64location", "sector_position", "sectoraloffset", "sector__addr", "headeraloffset", "sector_Offset", "sector__set", "sector__position", "systeminglocation", "system_no"], "desc_sectors": ["desc_gections", "desc_gegments", "desc_psegment", "desc_psegments", "desc_psections", "desc_sections", "desc_gectors", "desc_segments", "desc_pectors", "desc_pegment", "desc_pegments", "desc_gegment", "desc_pections", "desc_psectors", "desc_segment"], "sectors": [" segments", "psections", "siellers", " Segments", "psevers", "psegments", "severs", "tections", " sections", "texes", " sellers", "sections", " Sections", "siegments", "pellers", "siectors", " Severs", "sellers", " Sectors", "pevers", "psectors", "tectors", " sexes", "siections", "psexes", "pegments", "tegments", "sexes", "segments", "pections", "pectors"], "total_length": ["totalaccount", "totalaclength", "aligned_tail", "alignedaclength", "aligned_count", "total_sequence", "totalactail", "total_count", "totalacsequence", "alignedacsequence", "alignedaccount", "alignedactail", "total_tail", "aligned_sequence"], "aligned_length": ["sized_size", "aligned___size", "sized___distance", "aligned2capacity", "alignedingdistance", "sized___size", "aligned_capacity", "leading_capacity", "aligned_distance", "sized___length", "aligned67angle", "aligned67child", "aligned___length", "aligned67distance", "alignedingduration", "aligned54cost", "aligned54length", "aligned_depth", "sized___duration", "aped_length", "joined_angle", "aligned2length", "aped_depth", "aligned64length", "sized_distance", "joined_child", "signed_length", "aligned2distance", "leading_distance", "aped_part", "aped54depth", "aligned___duration", "joined_distance", "aligned2size", "aligned67length", "signed_size", "aligned64depth", "aligned_cost", "signed_angle", "aligned_child", "signed_count", "sized_length", "aligned54depth", "aligned_part", "aligned64cost", "alignedinglength", "alignedingsize", "aligned54part", "leading_length", "aped54part", "aligned_duration", "aligned_size", "aligned_angle", "sized_duration", "aligned_count", "aped_cost", "aligned___distance", "leading_count", "aligned64part", "joined_length", "aligned2count", "aped54cost", "aligned2angle", "aped54length"], "file_offset": ["block_order", "file___offset", "file__order", "file_size", "block__order", "file_number", "block_offset", "file_loc", "file___order", "file___off", "block__number", "file__off", "file__offset", "sector_loc", "block_off", "sector_location", "block_number", "block__off", "file_off", "block__offset", "file__number", "file___number", "file_location", "file_order", "sector_size"], "header": ["writer", "master", "dr", "layer", "journal", "entry", "spec", "shadow", "channel", "config", "cover", "pillar", "final", "record", "image", "content", "client", "event", "meta", "version", "metadata", "server", "description", "document", "init", "later", "initial", "definition", "her", "parser", "section", "Header", "connection", "message", "driver", "secondary", "error", "comment", "headers", "response", "bridge", "character", "reader", "h", "head", "ssl", "handler", "core", "cookie", "index", "general", "manager", "summary"], "new_hdr": ["new_thdr", "new_hld", "new_hds", "new_chds", "new_chld", "new_thds", "new_shr", "new_hr", "new_thr", "new_chdr", "new_thld", "new_shds", "new_shdr", "new_chr", "new_shld"], "new_desc": [" new_text", "new2Desc", "new2text", "newamtext", "new_text", " new_Desc", " new_sc", "new_Desc", "newamsc", "new2desc", "new2sc", "newamDesc", "new_sc", "newamdesc"], "data_sector": ["data___section", "data_order", "data___tier", "data___sector", "data_tier", " data_order", "data_section", "data___order", " data_tier", " data_section"], "partial_sectors": ["partial_gectors", "partial_persectors", "partial_gexes", "partial_perselements", "partial_psegments", "partial_geivers", "partial_psections", "partial_persexes", "partial_veivers", "partial_gelements", "partial_vectors", "partial_persegments", "partial_cectors", "partial_gegments", "partial_seivers", "partial_vegments", "partial_gections", "partial_vections", "partial_sexes", "partial_celements", "partial_cegments", "partial_cexes", "partial_psectors", "partial_segments", "partial_selements", "partial_pseivers", "partial_sections"], "sequence": ["append", "position", "future", "note", "component", "secret", "repeat", "family", "queue", "unit", "letter", "protein", "grade", "version", "series", "numbered", "period", "duration", "section", "character", "seq", "source", "serial", "sequ", "scale", "frame", "multiple", "ence", "sample", "element", "generic", "command", "prefix"]}}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n", "idx": 6547, "substitutes": {"s": ["as", "o", "sec", "is", "S", "http", "a", "spec", "sg", "session", "si", "sync", "i", "sys", "ses", "services", "status", "states", "f", "ns", "state", "d", "sl", "service", "us", "ss", "cs", "e", "an", "sb", "gs", "ks", "ds", "qs", "t", "ts", "p", "south", "settings", "fs", "c", "os", "ssl", "sq", "sym", "es", "rs", "js"]}}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "static int http_prepare_data(HTTPContext *c)\n\n{\n\n    int i;\n\n\n\n    switch(c->state) {\n\n    case HTTPSTATE_SEND_DATA_HEADER:\n\n        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n\n        if (c->stream->feed) {\n\n            /* open output stream by using specified codecs */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->stream->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                if (c->stream->feed == c->stream)\n\n                    memcpy(st, c->stream->streams[i], sizeof(AVStream));\n\n                else\n\n                    memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));\n\n\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        } else {\n\n            /* open output stream by using codecs in specified file */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->fmt_in->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        }\n\n        init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE,\n\n                      1, c, NULL, http_write_packet, NULL);\n\n        c->fmt_ctx.pb.is_streamed = 1;\n\n        /* prepare header */\n\n        av_write_header(&c->fmt_ctx);\n\n        c->state = HTTPSTATE_SEND_DATA;\n\n        c->last_packet_sent = 0;\n\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n\n        /* find a new packet */\n\n#if 0\n\n        fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count;\n\n        if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) {\n\n            /* overflow : resync. We suppose that wptr is at this\n\n               point a pointer to a valid packet */\n\n            c->rptr = http_fifo.wptr;\n\n            c->got_key_frame = 0;\n\n        }\n\n        \n\n        start_rptr = c->rptr;\n\n        if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0)\n\n            return 0;\n\n        payload_size = ntohs(hdr.payload_size);\n\n        payload = av_malloc(payload_size);\n\n        if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) {\n\n            /* cannot read all the payload */\n\n            av_free(payload);\n\n            c->rptr = start_rptr;\n\n            return 0;\n\n        }\n\n        \n\n        c->last_http_fifo_write_count = http_fifo_write_count - \n\n            fifo_size(&http_fifo, c->rptr);\n\n        \n\n        if (c->stream->stream_type != STREAM_TYPE_MASTER) {\n\n            /* test if the packet can be handled by this format */\n\n            ret = 0;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st = c->fmt_ctx.streams[i];\n\n                if (test_header(&hdr, &st->codec)) {\n\n                    /* only begin sending when got a key frame */\n\n                    if (st->codec.key_frame)\n\n                        c->got_key_frame |= 1 << i;\n\n                    if (c->got_key_frame & (1 << i)) {\n\n                        ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i,\n\n                                                                   payload, payload_size);\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            if (ret) {\n\n                /* must send trailer now */\n\n                c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n            }\n\n        } else {\n\n            /* master case : send everything */\n\n            char *q;\n\n            q = c->buffer;\n\n            memcpy(q, &hdr, sizeof(hdr));\n\n            q += sizeof(hdr);\n\n            memcpy(q, payload, payload_size);\n\n            q += payload_size;\n\n            c->buffer_ptr = c->buffer;\n\n            c->buffer_end = q;\n\n        }\n\n        av_free(payload);\n\n#endif\n\n        {\n\n            AVPacket pkt;\n\n\n\n            /* read a packet from the input stream */\n\n            if (c->stream->feed) {\n\n                ffm_set_write_index(c->fmt_in, \n\n                                    c->stream->feed->feed_write_index,\n\n                                    c->stream->feed->feed_size);\n\n            }\n\n            \n\n            if (av_read_packet(c->fmt_in, &pkt) < 0) {\n\n                if (c->stream->feed && c->stream->feed->feed_opened) {\n\n                    /* if coming from feed, it means we reached the end of the\n\n                       ffm file, so must wait for more data */\n\n                    c->state = HTTPSTATE_WAIT_FEED;\n\n                    return 1; /* state changed */\n\n                } else {\n\n                    /* must send trailer now because eof or error */\n\n                    c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n                }\n\n            } else {\n\n                /* send it to the appropriate stream */\n\n                if (c->stream->feed) {\n\n                    /* if coming from a feed, select the right stream */\n\n                    for(i=0;i<c->stream->nb_streams;i++) {\n\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n\n                            pkt.stream_index = i;\n\n                            if (pkt.flags & PKT_FLAG_KEY) {\n\n                                c->got_key_frame |= 1 << i;\n\n                            }\n\n                            /* See if we have all the key frames, then \n\n                             * we start to send. This logic is not quite\n\n                             * right, but it works for the case of a \n\n                             * single video stream with one or more\n\n                             * audio streams (for which every frame is \n\n                             * typically a key frame). \n\n                             */\n\n                            if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) {\n\n                                goto send_it;\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    AVCodecContext *codec;\n\n                send_it:\n\n                    /* Fudge here */\n\n                    codec = &c->fmt_ctx.streams[pkt.stream_index]->codec;\n\n\n\n                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);\n\n\n\n#ifdef PJSG\n\n                    if (codec->codec_type == CODEC_TYPE_AUDIO) {\n\n                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;\n\n                        /* printf(\"Calculated size %d, from sr %d, duration %d\\n\", codec->frame_size, codec->sample_rate, pkt.duration); */\n\n                    }\n\n#endif\n\n\n\n                    if (av_write_packet(&c->fmt_ctx, &pkt, 0))\n\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n\n\n                    codec->frame_number++;\n\n                }\n\n\n\n                av_free_packet(&pkt);\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n    case HTTPSTATE_SEND_DATA_TRAILER:\n\n        /* last packet test ? */\n\n        if (c->last_packet_sent)\n\n            return -1;\n\n        /* prepare header */\n\n        av_write_trailer(&c->fmt_ctx);\n\n        c->last_packet_sent = 1;\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6556, "substitutes": {"c": ["icc", "cp", "cmp", "oc", "ch", "cr", "v", "cur", "s", "ci", "config", "b", "nc", "rec", "rc", "cy", "enc", "co", "C", "x", "uc", "com", "m", "l", "cl", "f", "client", "content", "call", "d", "pc", "cc", "cs", "ce", "conf", "u", "arc", "con", "mc", "sc", "e", "w", "dc", "t", "k", "ctx", "n", "bc", "cu", "cb", "self", "exec", "coll", "p", "ic", "ctrl", "ec", "ca", "h", "cit", "g", "ct", "lc", "cf", "fc", "cv", "ac", "vc", "cache", "cm", "xc", "tc"], "i": ["I", "a", "di", "ci", "x", "b", "xi", "bi", "f", "pi", "d", "ii", "my", "code", "ski", "h", "oi", "g", "y", "lc", "li", "fi", "index", "zi", "gi", "name", "ti", "id", "count", "ji", "slice", "info", "ix", "phi", "it", "ai", "uri", "mi", "ini", "ie", "ip", "type", "ui", "counter", "block", "ni", "ri", "io", "key", "yi", "adi", "j", "u", "e", "isin", "p", "start", "hi", "r", "mu", "v", "si", "m", "qi", "l", "ij", "iu", "full", "ori", "n", "multi", "eni", "iv", "inner"], "st": ["std", "est", "r", "fr", "ste", "sr", "cr", "store", "cur", "la", "ost", "sw", "style", "rd", "sn", "stack", "ust", "dest", "sync", "pt", "uc", "stress", "sts", "spect", "cl", "rest", "f", "post", "sl", "St", "ss", "push", "stop", "sh", "sth", "sc", "sb", "ist", "inst", "se", "t", "storage", "sign", "ST", "str", "p", "sta", "stage", "be", "usr", "ft", "ptr", "sp", "start", "step", "sa", "ld", "back", "g", "ct", "bl", "put", "src", "set", "ast", "nd", "end"], "codec": ["labenc", "logEC", "labec", "condcc", "dependec", "conddec", "pedcc", "dependdec", "dependpc", "logec", "codeect", "condec", "codpc", "pedec", "logenc", "codenc", "labEC", "peddec", "codeenc", "dependcc", "logect", "codect", "condpc", "coddec", "pedpc", "codeEC", "labect", "codEC", "codcc", "codeec"], "frame_number": ["frame_counter", "frameflownumber", "fram_counter", "frame_no", "frame_num", "fram_number", "frame_sn", "fram_no", "fram_num", " frame_multiple", " frame_num", "frameflowmultiple", "frameflownum", " frame_sn", "frame_multiple", "frameflowsn"]}}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)\n\n{\n\n    if (!buffer->cmd) {\n\n        AVBufferRef *buf = buffer->user_data;\n\n        av_buffer_unref(&buf);\n\n    }\n\n    mmal_buffer_header_release(buffer);\n\n}\n", "idx": 6575, "substitutes": {"port": ["cp", "address", "air", "http", "PORT", "config", "mac", "Port", "export", "post", "length", "ports", "target", "allow", "path", "pad", "source", "p", "pos", "pointer", "ip", "type", "ort", "pair", "test", "host", "end", " transport"], "buffer": ["writer", "er", "feed", "buff", "header", "iter", "block", "builder", "ker", "uffer", "object", "b", "data", "queue", "texture", "image", "holder", "resource", "window", "null", "uf", "f", "server", "bb", "table", "interface", "comment", "Buffer", "message", "pad", "timeout", "container", "bridge", "source", "border", "context", "FFER", "reader", "ptr", "transfer", "pointer", "slave", "cache", "pb", "reference", "ref"], "buf": ["feed", "buff", "vec", "cur", "bd", "Buff", "rb", "plug", "b", "ob", "data", "rc", "BU", "queue", "db", "fb", "uf", "f", "av", "bu", "bag", "Buffer", "func", "ab", "cb", "fp", "bc", "fab", "ptr", "var", "cap", "bf", "cf", "cv", "ref", "pb", "cache", "src", "img", "bh"]}}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 6577, "substitutes": {"env": ["ah", "cfg", "eng", "ea", "extra", "ep", "v", "entry", "vm", "config", "qt", "esp", "environment", "exc", "enc", "eu", "inet", "db", "ext", "obj", "args", "exe", "net", "conf", "ev", "eb", "vs", "e", "priv", "np", "en", "path", "ctx", "err", "equ", "Environment", "context", "ec", "eni", "viron", "erv", "eve", "cache", "next", " environment", "loader", "conn", "dict"], "cpu": ["cp", "hp", "gp", "bench", "cmp", "hw", "program", "python", "CP", "lb", "mpeg", "gc", "platform", "pu", "vm", "roc", "component", "colo", "config", "nc", "gpu", "lp", "unit", "uci", "pc", "cli", "np", "clock", "conn", "instance", "ctx", "bc", "fp", "loader", "kernel", "process", "framework", "processor", "computer", "css", "boot", "console", "proc", "GPU", "node", "utils", "cn", "core", "lc", "performance", "cache", "pb", "cpp", "CPU", "cm"], "new_cpu": ["new_processor", " new_processor", "new__cpu", "old_processor", " new_core", "old_pu", "old_core", "newKgpu", "new__processor", " new_cache", "new_cache", "new_gpu", " new_vm", "newjcore", "new_pu", "old_gpu", "newjcpu", "new__clock", "newKpu", "new_vm", "new__vm", " new_clock", "new__core", "old_process", "new_process", "new_clock", "newKprocess", "newKcpu", "newjvm", "newjclock", "old_cpu", "new__gpu", "new_core"], "new_env": ["new__env", "newmemenvironment", "newamcache", " new_environment", "newamenvironment", "newamnetwork", " new_context", " new_cache", " new_conn", "new__conn", "new__environment", "newfdb", "new_cache", "new__context", " new_exc", "newmemcontext", "new_network", " new_db", "new_exc", "new_db", "new_conn", "new__exc", "newfenvironment", "newmemconn", "new_environment", "newfexc", "new__db", "newfenv", "newamenv", "new_context", "newmemenv", " new_network"], "bp": ["cp", "hp", "gp", "cmp", "lb", "vm", "po", "pp", "pd", "bps", "b", "ap", "lp", "NP", "px", "fb", "wb", "pg", "usb", "php", "pc", "arp", "cli", "bb", "np", "eb", "dp", "sb", "bsp", "pn", "bc", "jp", "fp", "nb", "BP", "p", "vp", "sp", "kb", "bf", "lc", "tp", "pb", "cpp", "prefix"], "wp": ["hp", "cp", "gp", "rw", "hw", "python", "fw", "wx", "sw", "wn", "pp", "xp", "wm", "ap", "lp", "NP", "wk", "px", "wb", "pg", "php", "wi", "pc", "wordpress", "bb", "np", "WP", "dp", "w", "bsp", "fp", "jp", "hop", "BP", "p", "kw", "web", "iw", "vp", "sp", "wu", "ip", "tp", "pb", "pkg", "prefix"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                               int32_t src_stride,\n\n                                               uint8_t *dst, int32_t dst_stride)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16i8 filt0, filt1, filt2;\n\n    v16u8 res0, res1, res2, res3;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = 4; loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n        AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3,\n\n                    res0, res1, res2, res3);\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 6580, "substitutes": {"src": ["st", "sr", "cur", "spec", "rb", "config", "tmp", "bg", "rc", "slice", "dest", "comp", "stream", "loc", "sur", "rest", "href", "sil", "url", "sl", "dist", "ctr", "cont", "sc", "sth", "sb", "rect", "inst", "rx", "bc", "cb", "source", "seq", "req", "gl", "gb", "sup", "supp", "sel", "ssl", "scl", "secure", "cv", "desc", "pl", "rs", "rob", "img", "RC", "ctrl", "low"], "src_stride": ["src_arrides", "src_strided", "src_brided", "src_striide", "src_divide", "src_divider", "src_arrider", "src_Strride", "src_strider", "src_stide", "src_striider", "src_Strides", "src_arrride", "src_Strider", "src_striides", "src_arride", "src_arrided", "src_strride", "src_brides", "src_brider", "src_divided", "src_stides", "src_striided", "src_Strided", "src_strides", "src_bride", "src_divides", "src_stided", "src_Stride", "src_stider"], "dst": ["Dsts", " dsts", "Dst", "bst", "bsts", "Dsrc", "bST", "dST", "dsts", " dST", " dsrc", "DST", "dsrc", "bsrc"], "dst_stride": ["dst_brider", "dst_blider", "dst_strider", "dst_stided", "dst_strride", "dst_brided", "dst_strided", "dst_stider", "dst_stide", "dst_brride", "dst_blide", "dst_blided", "dst_blride", "dst_bride"], "loop_cnt": ["loop_fcnt", "loop_acnc", "loop_fcnc", "loop_fct", "loop_ccount", "loop_fnc", "loop_cnc", "loop_cct", "loop_fnt", "loop_account", "loop_fccount", "loop_fcct", "loop_fcount", "loop_acnt", "loop_acct"], "dst0": ["dost0", "dest2", " dest1", "dost1", "dst4", "dost4", "dast4", "dost2", "dast1", " dst4", "dast2", "dast0", "dest1", " dest0", "dest0", " dest2", "dest4", " dest4"], "dst1": ["dinst0", "dost0", "dinst2", "dsrc4", "madsrc2", "dinst4", "dost1", "dost4", "dst4", "dost2", "madsrc4", "madsrc1", "madsrc0", "madst0", "madst4", "madst2", "madst1", "dsrc1", "dsrc2", "dsrc0", "dinst1"], "dst2": ["Dst42", "Dost2", "dst42", "dsc02", "Dost42", "dst4", "dost4", "dost2", "Dost02", "dst02", "drc4", "dost42", "drc2", "Dst02", "Dst4", "dsc4", "dsc2", "drc42", "dsc42", "Dost4", "dost02", "Dst2", "drc02"], "dst3": ["dcast3", "dcast8", "ddest2", "dst6", " dsc8", " dst6", " dsc2", "dsc3", " dsc3", " dsc6", "dsc8", "dcast2", "dsc6", " dst8", "dsc2", "dst8", "ddest3", "dcast6", "ddest8", "ddest6"], "src0": ["dist8", "dest3", "rc3", "dest2", "source4", "sl0", "rc0", "loc1", "dest8", "rc5", "sl8", " src50", "source1", "img2", "rc1", "loc4", "img0", "sl1", "loc0", "img5", "dist0", "dest1", "dest0", "source2", "img8", "sl50", "dest50", "rc2", "dist2", "rc8", "dest4", "dist5", "rc4", "src50", "source0", "loc2"], "src1": ["dist01", "dist8", "dest3", "rc3", "dest2", "rc0", "source1", "rc1", "sc01", "src01", "rc4", "source01", "dest01", "sc2", "rc01", "sc3", "img1", "img4", "dest1", "dist4", "dest0", "sr01", "source2", "img8", "rc2", " src01", "sr2", "img01", "sr3", "dist1", "rc8", "dest4", "sr1", "source0", "sc1"], "src2": ["sort3", "dest3", "rc3", "dest2", "source4", "rc5", "rc0", "sort4", "reflect1", "source1", "rc1", "src02", "rc02", "sort2", "source3", "reflect5", "reflect2", "dest0", "source2", "source02", " src02", "rc2", "reflect02", "sort5", "dest4", "rc4", "source0"], "src3": ["rc03", "src53", "rc3", "source4", "source5", "src33", "source03", "rc5", "rc0", "inst2", "rc23", "rc53", "sur03", "rc1", "src23", "src03", "source3", " src03", "rc33", "inst03", " src23", "dist53", "inst23", "inst3", "sur3", "dist4", "sur33", "reflect03", "rc2", "sur4", " src53", "dist1", "reflect3", "reflect33", "dist3", "rc4", "reflect4", "source0"], "src4": ["dest04", "dest2", "source4", "source5", "rc5", "img6", "img2", "source1", "rc1", "dest5", "src04", "rc6", "dest44", "rc44", "img4", "dest1", "dist4", "source8", "source2", "source44", "rc2", "dist04", "rc04", "source6", "src44", "dist2", "dist1", "rc8", "dest4", "rc4", "source04", "img04"], "src5": ["reflect53", "reflect50", "source50", "rc50", "src53", "source53", "source4", "source5", "rc5", "rc4", "src50", "reflect5", "reflect4", "rc53"], "src6": ["sc6", " src66", "loc76", "sc76", "sc8", "src76", "src66", "loc6", "sc66", "loc66", " src76", "loc8"], "src7": ["reflect77", "src73", "rc73", "reflect07", "rc07", "source77", "reflect73", "reflect7", "source73", "src07", "src77", "source7", "source07", "rc77", "rc7"], "src8": ["src88", "img88", "img7", "img9", "rc9", "src9", "rc8", "rc88", " src88", "img8", " src9", "rc7"], "src10_r": ["src8_sr", "src8_R", "src10_rf", "src10_p", "src8_l", "src8_r", "src90_l", "src90_p", "src10_R", "src10_sr", "src90_rf", "src90_r"], "src32_r": ["src21mmt", "src32_rs", "src32_right", "src21_rs", "src32_t", "src21mmrs", "src32mmrs", "src32ingright", "src32ingrs", "src21_right", "src21mmright", "src32mmt", "src32mmr", "src32mmright", "src32ingr", "src21_t", "src21mmr", "src32ingt"], "src54_r": ["src54_pr", "src54_rs", "src52_r", "src52_pr", "src52_rs", "src52_l"], "src76_r": ["src76acr", "src74_nr", "src74_rs", "src76acrs", "src76acnr", "src74_r", "src76_err", "src76acerr", "src76_rs", "src74_err", "src76_nr"], "src21_r": ["src21_rs", "src64_mr", "src64_hr", "src21_mr", "src64_r", "src64_rs", "src21_hr"], "src43_r": ["src73_rr", "src43_pr", "src73_rs", "src43_rs", "src73_r", "src73_pr", "src43_rr"], "src65_r": ["src65_rs", "src57_r", "src57_rs", "src65_sr", "src65_rb", "src57_rb", "src57_sr"], "src87_r": ["src7_x", "src87_x", "src87_w", "src875w", "src7_l", "src7_w", "src7_r", "src875l", "src875r", "src875x"], "src10_l": ["src10_kl", "src10_lc", "src00_kl", "src00_lc", "src00_l", "src00_r"], "src32_l": ["src32_lc", "src32ccl", "src32ccline", "src52_r", "src32_line", "src32cclc", "src32ccr", "src52_lc", "src52_line", "src52_l"], "src54_l": ["src52_m", "src54_ll", "src54_m", "src52_ll", "src54_lc", "src52_lc", "src52_l"], "src76_l": ["src56_lc", "src76riptbl", "src56_ll", "src76riptlc", "src56_bl", "src76_lc", "src56_l", "src76_bl", "src76riptll", "src76riptl", "src76_ll"], "src21_l": ["src43_lc", "src21_lp", "src43_ll", "src21_lc", "src21_ll", "src43_lp"], "src43_l": ["src43_lc", "src73_n", "src73_lc", "src73_r", "src73_l", "src43_n"], "src65_l": ["src65_lc", "src65_b", "src73_lc", "src73_b", "src73_r", "src73_l"], "src87_l": ["src87_x", "src87mmo", "src87mml", "src87mmx", "src87mmr", "src73_o", "src73_x", "src73_r", "src73_l", "src87_o"], "out0_r": ["out0_d", "out0_rb", "out0__l", "out0__r", "out0__rb", "out0__d"], "out1_r": ["out1_p", "out0_p", "out1_b", "out0_b"], "out2_r": ["out4_p", "out2_b", "out2_p", "out4_b", "out4_l", "out4_r"], "out3_r": ["out3_b", "out2_b", "out3_w", "out2_w"], "out0_l": ["out10_l", "out10_L", "out0_fl", "out10_b", "out0_L", "out10_fl", "out0_b"], "out1_l": ["out2_fl", "out1__r", "out1__d", "out1_d", "out1__fl", "out1__l", "out1_fl", "out2_d"], "out2_l": ["out2_fl", "out2_b", "out0_fl", "out0_b"], "out3_l": ["out3_b", "out2_b", "out3_ll", "out2_ll"], "filt0": ["Filt6", "flt0", "falt2", "fil2", "fil1", "flt1", "flt3", " filt3", "falt1", "filit6", "filit1", "filit0", "fil0", "filt3", "Falt6", " falt2", "falt0", "filit2", "Filt2", "Filt0", "flt6", "flt2", "filt6", "Falt2", "Falt1", "falt3", "fil3", " falt1", " falt0", " falt3", "falt6", "Filt1", "Falt0"], "filt1": ["fird4", "fill1", "flict2", "vilt1", "flt1", "vilt4", "vilt3", "flt3", " filt3", "fird3", "fill4", "firm1", "filt4", "fill2", " filt4", "filt3", "firm3", "flt4", "fird1", "vill1", "vilt2", "flt2", "fird2", "fill3", "flict1", " flt3", " flt1", "firm4", "vill3", "vill4", "flict4", "flict3", " flt4", "firm2", " flt2", "vill2"], "filt2": ["fill1", "mill4", "flt5", "fil2", "fil1", " flt52", "flt1", "mill2", "filt5", "milt5", "mill5", "fill4", "felt1", "filt4", "fill2", "flt52", "fill5", "flt4", "felt52", "flt2", "fil4", "mill1", " flt1", "fesh1", "fesh2", " filt52", "fesh52", "fil5", "milt4", "milt1", "felt2", "milt2", " flt2", "filt52"], "res0": ["Res1", "Res2", "res00", "ps00", "ps1", "ps0", "ps2", "Res00", "Res0", " res00"], "res1": ["pres4", "Res2", "Res1", "pres0", "ras0", "pres2", "pres1", "Res4", "ras2", "ras1", "ras4", "res4", "Res0"], "res2": ["pres4", "Res2", "Res1", "pres2", "Restwo", "pres1", "RES1", "Res4", "REStwo", "RES4", "restwo", "prestwo", "RES2", "res4"], "res3": ["Res1", "Res2", "ras15", "Res3", "res15", "ras2", "ras1", " res15", "ras3", "Res15"]}}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 6594, "substitutes": {"opaque": ["opa", "opera", "copac", "copa", "iopacity", "pacity", "operac", "operaque", "opac", "space", "spaques", "iopa", "spaque", " opacity", " opace", "opaques", "paque", "pace", "operacity", "copaque", "iopac", "opace", "opacity", "spacity", " opaques", "iopaque", "copacity", "paques"], "s": ["o", "sf", "sec", "S", "a", "spec", "sg", "scope", "socket", "si", "sync", "sys", "ses", "services", "m", "states", "f", "ns", "server", "sl", "stats", "ss", "u", "e", "sie", "sb", "ops", "secondary", "ds", "n", "p", "fs", "sa", "c", "g", "ssl", "sq", "sym"]}}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "static void ppc_prep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    char *filename;\n\n    nvram_t nvram;\n\n    M48t59State *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_prep.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_prep.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size > 0 && bios_size <= BIOS_SIZE) {\n\n        target_phys_addr_t bios_addr;\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        bios_addr = (uint32_t)(-bios_size);\n\n        cpu_register_physical_memory(bios_addr, bios_size,\n\n                                     bios_offset | IO_MEM_ROM);\n\n        bios_size = load_image_targphys(filename, bios_addr, bios_size);\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PPC PREP bios '%s'\\n\", bios_name);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    /* Hmm, prep has no pci-isa bridge ??? */\n\n    isa_bus_new(NULL);\n\n    isa_bus_irqs(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(2000, NULL);\n\n\n\n    if (serial_hds[0])\n\n        serial_isa_init(0, serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = qemu_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(\"i8042\");\n\n\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(1, cpu_exit_irq);\n\n\n\n    //    SB16_init();\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(fd);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL, DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 6605, "substitutes": {"ram_size": ["ramsoffset", "ram67size", "ram_name", "ram67capacity", "ram67offset", "amd_size", "amdallposition", "block_size", "block_location", "ram_number", "block_offset", "ram_capacity", "block67offset", "amd_name", "ramssize", "ramFlen", "ramslength", "ram_source", "block_length", "ramslocation", "amdallsize", "amd_number", "ramFsize", "ram_len", "block67size", "ram67len", "ram67source", "amd_position", "ramallname", "ramallnumber", "ram_location", "amdallname", "amdallnumber", "block67location", "ramFcapacity", "ram_position", "block67length", "ramallposition", "ram67location", "gram_size", "ramFsource", "gram_len", "ramallsize", "gram_capacity", "ram67length", "gram_source", "ram_length"], "boot_device": ["kernel_dir", "boot_dev", "boot_mode", "boot_dir", "kernel_mode", "kernel_dev", "kernel_device"], "kernel_filename": ["kernelblockplatform", "kernel_file", " kernel_mode", "kernelblockfilename", "kernelblockmode", "kernel_platform", "kernel_mode", " kernel_name", "cpu_name", "kernel_fil", "kernel_name", "kernelblockname", "cpu_fil", "cpu_filename", " kernel_platform", "cpu_file"], "kernel_cmdline": ["kernel_commandspace", "kernel_requestline", "kernel_requestspace", "kernel_commandcode", "kernel_cmdcode", "kernel_cmdspace", "kernel_bindline", "kernel_requestcode", "kernel_commandline", "kernel_bindcode", "kernel_bindspace"], "initrd_filename": ["initrd2processor", "initrd2filename", "initrt_file", "initrd2file", "initrt_filename", "initrt_processor", "initrd_processor", "initrd_file", "initrd_name", "initrd2name", "initrt_name"], "cpu_model": ["gpu_type", "cpu_control", "core_serial", "gpu_model", "gpu_spec", "gpu_mode", "processor_model", "processor_label", "processor_sleep", "cpu_Model", "core_model", " cpu_mode", "core_mode", "cpu_serial", "cpu_type", "cpu_name", "cpu_spec", "cpu_mode", "processor_name", " cpu_Model", " cpu_control", "cpu_label", "cpu_sleep", "core_name"], "env": ["energy", "el", "entry", "environment", "inv", "style", "password", "oa", "gui", "state", "conf", "ev", "her", "here", "esc", "bc", "err", "empty", "exec", "Environment", "rev", "enh", "ec", "h", "engine", "conn", "ass", "ah", "config", "qt", "nc", "eu", "cal", "ctx", "viron", "txt", "chal", " environment", "end", "eng", "act", "dat", "vel", "exc", "db", "profile", "export", "ext", "obj", "net", "np", "vs", "e", "en", "dev", "me", "global", "shell", "app", "dict", "enable", "ea", "v", "scope", "session", "stack", "enc", "window", "args", "init", "dir", "lock", "context", "eni", "console"], "filename": ["name", "files", "username", "Filename", "alias", "tty", "File", "l", "f", "url", "fil", "NAME", "acl", "uri", "SourceFile", "download", "file", "binary", "fn", "path", "application", "dll", "fp", "FIL", "nil", "source", "output", "memory", "location", "utf", "il", "loader", "directory", "summary", "prefix"], "nvram": ["vrom", "ncro", "qtram", "vram", "ncmem", "ncram", "qtrom", "ncrom", "nvrom", "nvmem", "qtro", "nvro", "vmem", "qtmem", "vro"], "m48t59": ["m28t58", "m48t64", "m48T59", "m48t56", "m48l58", "m48t58", "m48l59", "m48n56", "m48n58", "m28t59", "m28T56", "m48n59", "m48l56", "m28T64", "m48T58", "m28t56", "m48n64", "m28T58", "m48l64", "m28T59", "m28t64", "m48T64", "m48T56"], "PPC_io_memory": ["PPC_io_alloc", "PPC_IO_alloc", "PPC_io_space", "PPC_io_mem", "PPC_IO_mem", "PPC_IO_memory", "PPC_IO_space"], "linux_boot": ["linux_write", "linux___write", "kernel_launch", " linux_write", "linux_bit", "linux___boot", "linux_launch", "linux___launch", " linux_bit", "kernel_config", "linux_config", "linux___bit", "kernel_boot", " linux_config", "linux___config"], "i": ["gi", "ei", "ti", "v", "id", "I", "chi", "di", "ci", "ni", "xi", "x", "si", "io", "ri", "info", "in", "qi", "ix", "f", "yi", "pi", "phi", "d", "ii", "iu", "j", "ai", "cli", "uli", "u", "udi", "ami", "uri", "t", "n", "multi", "mi", "ini", "ie", "p", "h", "network", "mini", "eni", "hi", "c", "ip", "type", "li", "fi", "index", "r", "mu", "ui"], "nb_nics1": ["nb_nuics0", "nb_numsone", "nb_nigh1", "nb_nuics1", "nb_nuicsone", "nb_nii1", "nb_nics5", "nb_nuigh1", "nb_nii5", "nb_nighone", "nb_nicsone", "nb_nigh5", "nb_nuigh5", "nb_nics0", "nb_nuigh0", "nb_niione", "nb_nuighone", "nb_nums1", "nb_nums0", "nb_nii0", "nb_nuics5", "nb_nigh0", "nb_nums5"], "bios_size": ["bins_size", "bins_ize", "bios_loc", "bins_ui", "bios_ui", "bins_loc", "bios2ui", "bios_ize", "bios2ize", "bios2loc", "bios2size"], "ram_offset": [" ram_balance", "mem_offset", "ram_balance", " ram_origin", "ram_base", "mem_addr", "ram_origin", "ramEaddr", "ream_size", "ream_base", "ram\u00b7size", "ramEslot", "mem_size", "mem_slot", "ram\u00b7base", "ram_addr", "ram\u00b7offset", "ram_slot", "ream_pointer", "ram_pointer", "ream_offset", "ramEsize", "ram\u00b7pointer", "ramEoffset"], "bios_offset": ["bos_size", "bos_offset", "bos_area", "bits_Offset", "bos_start", "bits_size", "bits_offset", "bios_area", "bios_Offset", "bios_len", "bits_len", "bios_start"], "kernel_base": ["kernel_len", "cpu_len", "cpu_base", "cpu_name", "kernel_name", "cpu_size"], "initrd_base": ["initrt_len", "initrt_length", "initrd_weight", "initrd_len", "initrd_length", "initrt_base", "initrt_weight"], "kernel_size": ["kernelacset", "processor_capacity", "processor_size", "processor_range", "processor_set", "kernel_range", "kernel_set", "kernelacsize", "kernelacrange", "kernelaccapacity", "kernel_capacity"], "initrd_size": ["initrm_len", "initrdssize", "initrd_weight", "initrmscapacity", "initrd_len", "initrdscapacity", "initrmsweight", "initrd_capacity", "initrmslen", "initrdslen", "initrm_weight", "initrm_capacity", "initrm_size", "initrdsweight", "initrmssize"], "pci_bus": ["pcm_boot", "pcm_BUS", "pci_boot", "pcm_class", "pci_class", "pcm_bus", "pci_BUS"], "i8259": ["i8257", "m8259", "m8ka", "i64ka", "m8257", "i8288", "i64259", "i48259", "m8288", "i8ka", "i48257", "i64257", "i48288", "i48ka", "i64288"], "cpu_exit_irq": ["cpu_exit_irce", "cpu_exit_IRch", "cpu_exit_pirce", "cpu_exit_IRq", "cpu_exit_pirch", "cpu_exit_irg", "cpu_exit_pirq", "cpu_exit_IRg", "cpu_exit_irch", "cpu_exit_pirg", "cpu_exit_IRce"], "ppc_boot_device": ["ppc_mount_status", "ppc_mount_device", "ppc_mount_model", "ppc_boot_model", "ppc_bootxmode", "ppc_mount_mode", "ppc_boot_status", "ppc_bootxstatus", "ppc_bootxmodel", "ppc_boot_mode", "ppc_bootxdevice"], "hd": ["dri", "hp", "dr", "hw", "md", "bd", "vd", "dn", "di", "dd", "HD", "pd", "dh", "ad", "rh", "hs", "wd", "hm", "da", "sd", "xd", "ht", "ld", "du", "gd", "ud", "ha", "nd", "cd"], "MAX_IDE_BUS": ["MAX_IDEADUSER", "MAX_IDEADUSB", "MAX_IDEADBUS", "MAX_IDE__USB", "MAX_IDE__USER", "MAX_IDE_USB", "MAX_IDE__BUS", "MAX_IDES_USER", "MAX_IDES_BUS", "MAX_IDES_USB", "MAX_IDE_USER"], "MAX_IDE_DEVS": ["MAX_IDE_ADVS", "MAX_IDE_DVER", "MAX_IDE_ADVER", "MAX_IDE_DEVER", "MAX_IDE_ADVs", "MAX_IDE_DIVICE", "MAX_IDE_DEVs", "MAX_IDE_ADVICE", "MAX_IDE_DVICE", "MAX_IDE_DIVs", "MAX_IDE_DIVS", "MAX_IDE_DVs", "MAX_IDE_DEVICE", "MAX_IDE_DIVER", "MAX_IDE_DVS"], "fd": ["pid", "fr", "sf", "v", "bd", "vd", "dn", "di", "b", "fx", "fb", "db", "f", "d", "fl", "dir", "wd", "dev", "dc", "ds", "df", "sd", "fp", "FD", "fs", "bf", "cf", "dl", "fc"], "MAX_FD": ["PER__HD", "PER__DF", "PER_FD", "MAXIDDF", "MAXIDFD", "MAX_DF", "MAX_HD", "PER_ND", "MAX__FD", "MAX__ND", "MAX__DF", "PER_DF", "MAXIDHD", "MAX__HD", "PER__ND", "MAXIDND", "PER__FD", "MAX_ND", "PER_HD"]}}
{"project": "FFmpeg", "commit_id": "15ea222778caaec0877b3f9938140b707c931d96", "target": 0, "func": "static void copy_picture_field(InterlaceContext *s,\n\n                               AVFrame *src_frame, AVFrame *dst_frame,\n\n                               AVFilterLink *inlink, enum FieldType field_type,\n\n                               int lowpass)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n\n    int hsub = desc->log2_chroma_w;\n\n    int vsub = desc->log2_chroma_h;\n\n    int plane, j;\n\n\n\n    for (plane = 0; plane < desc->nb_components; plane++) {\n\n        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;\n\n        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;\n\n        uint8_t *dstp = dst_frame->data[plane];\n\n        const uint8_t *srcp = src_frame->data[plane];\n\n\n\n        av_assert0(cols >= 0 || lines >= 0);\n\n\n\n        lines = (lines + (field_type == FIELD_UPPER)) / 2;\n\n        if (field_type == FIELD_LOWER)\n\n            srcp += src_frame->linesize[plane];\n\n        if (field_type == FIELD_LOWER)\n\n            dstp += dst_frame->linesize[plane];\n\n        if (lowpass) {\n\n            int srcp_linesize = src_frame->linesize[plane] * 2;\n\n            int dstp_linesize = dst_frame->linesize[plane] * 2;\n\n            for (j = lines; j > 0; j--) {\n\n                const uint8_t *srcp_above = srcp - src_frame->linesize[plane];\n\n                const uint8_t *srcp_below = srcp + src_frame->linesize[plane];\n\n                if (j == lines)\n\n                    srcp_above = srcp; // there is no line above\n\n                if (j == 1)\n\n                    srcp_below = srcp; // there is no line below\n\n                s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below);\n\n                dstp += dstp_linesize;\n\n                srcp += srcp_linesize;\n\n            }\n\n        } else {\n\n            av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2,\n\n                                srcp, src_frame->linesize[plane] * 2,\n\n                                cols, lines);\n\n        }\n\n    }\n\n}\n", "idx": 6622, "substitutes": {"s": ["S", "spec", "sg", "session", "b", "sys", "ses", "services", "sk", "f", "client", "ns", "ls", "sl", "space", "service", "cs", "conf", "ss", "gs", "ops", "ds", "n", "ts", "self", "p", "south", "acks", "aws", "fs", "utils", "c", "os", "g", "ssl", "sq", "rs", "js"], "src_frame": ["srcdingframes", "srcglayer", "srcamstroke", "src_panel", "rc_image", "rc_fram", "rc_colour", "rc2frame", "src_range", "src_stroke", "srcamtime", "src_scene", "src2frames", "srckscope", "cmp_element", "srclanemachine", "srcACpanel", "srcrettygroup", "src2colour", "urg_panel", "src_element", "src_machine", "cmpkelement", "src_layer", "srcCcenter", "srcrettyscope", "rc2frames", "src_image", " src_center", "srckframe", "src_group", "srcpyfram", "sort_stroke", "srcackframe", "srcpyframe", "srclaneframe", "srcACtime", " src_image", "src_fram", "urg_machine", "srckelement", "srcpycolour", "cmpkscope", "srcCframe", "srcackgroup", "urgACpanel", "srcClayer", "rc_frames", "srcdingframe", "srcpyscene", "rc_range", "src_time", "src_frames", "src2scene", "rc2image", "srcgimage", "srcamframe", "rc_frame", "urg_time", "src_data", "srcACmachine", "rc_scene", "srclanepanel", "srcrettyelement", "srcCimage", "src_colour", "srcamdata", "src_center", "sortrettydata", "sort_frame", "cmpkframe", "src2range", "srcampanel", "cmp_group", "srcrettystroke", "urgACframe", "srcrettyframe", "src_scope", "srcammachine", "urgACtime", "srcackscope", "urg_frame", "cmp_scope", "sort_data", "srcgframe", "srcdingimage", "rc2range", "sortrettyframe", " src_layer", "srclanetime", "srcackelement", "src2frame", "srcrettydata", "srckgroup", "src2fram", "srcACframe", "sortrettystroke", "cmp_frame", "urgACmachine", "srcdingrange", "cmpkgroup", "src2image", "srcgcenter"], "dst_frame": ["dst_element", "dst2frame", "ddistkframe", "dst2struct", "dst_struct", "ddist_frame", "ddistkimage", "drc_image", "dstackimage", "dst_slice", "dstfelement", "dstffram", "dstkframe", "drc_struct", "dst2image", "drc_element", "dstfframe", "dst_layout", "dst_fram", "drc_slice", "drc_fram", "dstackframe", "dstfimage", "drc_Frame", "drc_frame", "ddist_cycle", "ddistkline", "ddist_image", "dstackslice", "ddist_line", "dst_line", "dst2Frame", "dst_image", "dst_Frame", "dstacklayout", "dst_cycle", "ddistkcycle", "dstkcycle", "dstkimage", "dstkline", "drc_layout"], "inlink": ["INload", "outLink", "INlink", "outline", "insline", "incline", " inload", "inLink", "inink", "inlinked", "inccomplete", "outband", " inink", " inLink", "inscomplete", "innlink", " infer", "insload", " inlinked", "inclink", "INink", "insLink", "INline", "inband", "INfer", "incfer", "inload", "incink", " incomplete", "inslinked", "insband", "innlinked", "incomplete", "outlink", "incband", "incload", "insink", "infer", "innload", "inslink", "INLink", "innink", "outload", " inband"], "field_type": ["field_level", " field_name", "field_tag", " field_key", " field_class", " field_tag", "field_object", "field_key", " field_status", "function_type", "fieldgstatus", " field_index", "fieldgtype", "function_level", "field_index", "fieldtypeindex", "fieldtypetype", "field_class", "field_status", "function_tag", "fieldtypename", "function_format", " field_object", "fieldgname", "field_format", "field_name", "fieldgclass"], "lowpass": ["LowPass", "LowPASS", "highswitch", "highfail", " lowfail", "secondPASS", "lowerPASS", "secondcross", "lowcross", "lowstrip", "highPass", "Lowstrip", "lowfail", "Lowcross", "secondpass", "Lowpass", "lowerpass", "highpass", "Lowswitch", " lowswitch", " lowPass", "secondstrip", "Lowfail", "lowerstrip", "lowPASS", "lowercross", "lowswitch", "lowPass"], "desc": ["sub", "anc", "sec", "acc", "config", "disc", "rec", "enc", "comp", "info", "uc", "loc", "de", "ext", "meta", "org", "description", "dist", "init", "def", "Desc", "des", "dir", "sc", "code", "comment", "dc", "esc", "ec", "doc", "gen", "ind", "dep", "txt", "decl", "asc", "cod", "text", "cv", "src", "summary", "conn"], "plane": ["flow", "band", "position", "component", "force", "fly", "style", "ane", "unit", "plot", "planes", "letter", "f", "weight", "flo", "code", "zone", "connection", "den", "file", "kat", "line", "page", "user", "mode", "jet", "axis", "slice", "pe", "module", "plate", "drive", "grade", "fl", "limit", "port", "sea", "cycle", "flight", "scale", "rule", "type", "lin", "pl", "site", "lines", "group", "size", "gate", "pin", "note", "gap", "flat", "key", "ion", "cell", "character", "p", "source", "clip", "network", "frame", "pos", "ge", "level", "pose", "charge", "core", "age", "pen", "scope", "pixel", "card", "drop", "side", "period", "category", "day", "n", "car", "qa", "fle", "direction", "plan", "sample", "date", "lane"], "j": ["jet", "ali", "fr", "o", "axis", "position", "jon", "v", "note", "jl", "oj", "ji", "b", "x", "i", "sync", "bi", "kj", "l", "key", "job", "f", "ij", "aj", "fl", "it", "jen", "e", "J", "section", "jc", "k", "t", "n", "uj", "jp", "jo", "p", "jit", "span", "h", "z", "pos", "line", "jj", "c", "range", "g", "dj", "ja", "y", "li", "adj", "jam", "syn", "js"], "dstp": ["dstpr", "dostlp", "dostpr", "_", "dftfp", " dostp", "Dstnp", "all", "dshp", "dscpr", " dscp", "dscl", "dstnp", "dstrp", "dstrc", "Dostc", "dscp", "img", " dsthp", "dscc", "dessp", "dshlp", "dsthp", "Dostpr", "Dstc", "Dstp", "Dstl", "dostP", "dftP", "dstlp", "Dostfp", "slice", "dessfp", " dostlp", " dstlp", "dstel", "dshc", "Dostl", "dstc", "dftc", "Dstpr", "Dostp", "dftp", "dessl", "dstep", "feed", "dostl", "dessc", "dstl", "dstfp", "dstehp", "dosthp", "dostc", "dostnp", "dstrnp", "dostfp", "dshP", " dostP", " dostc", "dstP", "dftl", "dftlp", " dscc", "dscnp", "pixel", "dstec", "Dostnp", "dstrpr", "full", " dstl", " dstP", "Dstfp", " dschp", " dstc", "dostp", " dscl", "dschp"], "srcp": ["ostc", " srcpr", "sortpr", "srcv", "rcb", "stpc", "srcn", "sslp", "rcv", "srcapi", "stb", "ostb", "rsspart", "syncn", "srcpe", "rcpart", "sourceP", "rcpc", "rssf", "srcpr", "syncapi", "surP", "stp", "rssn", "rcapi", " srcc", "ostp", "sourcef", " srcn", "sourcep", " srcpe", "sslapi", "stc", "sslpr", " srcpart", "surnp", "rssr", " srcP", "serpe", "serP", "srcP", "srcnp", " srcv", "srcpc", "sortc", "serf", "surpre", "srcf", "surp", "srcb", "rcf", "rcc", "rsspre", "rcpr", "sourcer", "rssv", "srcpart", "rcpre", "rssp", "syncpr", " srcf", "srcpre", "syncp", "rssnp", "sortp", "rcn", "rssP", "ssln", "rcnp", "rcp", "srcr", "srcc", "rcpe", "rcP", "serp", "ostpc", "rcr"], "srcp_above": ["srcp_rising", "srctp_bottom", "srcp_breaking", "srcpacbreaking", "srcpAbelow", "srcp_inside", "srcp_around", "srctp_above", "srctp_upper", "srcp_bottom", "srcpacupper", "srcP_around", "srcpAupper", "srcP_above", "srcpAaround", "srcpacabove", "srcpacbottom", "srcP_below", "srcP_upper", "srctp_breaking", "srcp_upper", "srcpAabove"], "srcp_below": ["srcc_behind", "srcp_secondary", "srcp_running", "srcp_sharing", "srcc_bottom", "srcpacsecondary", "srcp_Below", "srcp_bottom", "srcP_above", "srcp_behind", "srcP_secondary", "srcc_sharing", "srcP_below", "srcpacabove", "srcpacbelow", "srcc_below", "srcP_Below", "srcpacBelow"]}}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n", "idx": 6628, "substitutes": {"env": ["enable", "cp", "ah", "eng", "er", "ea", "v", "entry", "done", "vm", "scope", "config", "environment", "exc", "style", "et", "enc", "data", "db", "event", "ext", "state", "server", "obj", "net", "conf", "ev", "np", "code", "e", "vs", "target", "en", "here", "inst", "ctx", "err", "context", "ec", "stage", "output", "viron", "iv", "ptr", "erv", "c", "cf", "core", "manager", "conn", "end"]}}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n", "idx": 6635, "substitutes": {"errp": ["Erp", "erc", "irpc", "erpc", "irc", "erP", "aerip", "Erpc", "errpre", "irr", " errcp", " errip", "errP", "errip", "aerr", "aerp", "errpc", "ErP", " errP", " errpc", " errc", "erip", "err", "irp", "ercp", "errc", "errr", "erp", "Erpre", "aercp", "errcp", " errpre", " errr", "erpre"], "cs": ["Cs", "cks", "cases", "cr", "spec", "cus", "ced", "rc", "sync", "cells", "sys", "cing", "js", "sk", "ns", "ls", "pc", "cc", "bs", "ce", "ics", "CS", "ck", "cons", "sc", "ks", "ds", "qs", "ctx", "ces", "cms", "wcs", "cb", "ec", "ca", "css", "acs", "fs", "c", "ct", "cn", "core", "cf", "lc", "ac", "vc", "cache", "ras", "cas", "ps", "conn", "tc"], "cpu": ["cp", "gp", "bench", "gc", "hw", "cmp", "lb", "chip", "pai", "platform", "pu", "vm", "roc", "coe", "aco", "colo", "lan", "clus", "cus", "sync", "cca", "auc", " CPU", "gpu", "unit", "px", "uu", "num", "chu", "uci", "pc", "cli", "np", "uo", "cpp", "ck", "nic", "proxy", "clock", "que", "ctx", "lu", "bc", "cu", "kernel", "fps", "processor", "computer", "ca", "css", "runner", "uca", "eni", "console", "proc", "c", "node", "cn", "core", "lc", "fc", "cache", "loader", "CPU", "uno", "conn"]}}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n", "idx": 6641, "substitutes": {"env": ["eng", "er", "nw", "ea", "ep", "v", "el", "vm", "dat", "scope", "config", "environment", "exc", "style", "et", "enc", "oa", "eu", "buf", "db", "event", "export", "ext", "state", "server", "obj", "args", "gear", "conf", "ev", "np", "code", "e", "vs", "her", "en", "here", "dev", "ctx", "err", "context", "ec", "viron", "console", "c", "core", "cache", "loader", "grad", "conn", "dict"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter(uint8_t *src,\n\n                                                   const int step,\n\n                                                   const int stride,\n\n                                                   const int filter_p1,\n\n                                                   const int filter_q1,\n\n                                                   const int alpha,\n\n                                                   const int beta,\n\n                                                   const int lim_p0q0,\n\n                                                   const int lim_q1,\n\n                                                   const int lim_p1)\n\n{\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int i, t, u, diff;\n\n\n\n    for (i = 0; i < 4; i++, src += stride) {\n\n        int diff_p1p0 = src[-2*step] - src[-1*step];\n\n        int diff_q1q0 = src[ 1*step] - src[ 0*step];\n\n        int diff_p1p2 = src[-2*step] - src[-3*step];\n\n        int diff_q1q2 = src[ 1*step] - src[ 2*step];\n\n\n\n        t = src[0*step] - src[-1*step];\n\n        if (!t)\n\n            continue;\n\n\n\n        u = (alpha * FFABS(t)) >> 7;\n\n        if (u > 3 - (filter_p1 && filter_q1))\n\n            continue;\n\n\n\n        t <<= 2;\n\n        if (filter_p1 && filter_q1)\n\n            t += src[-2*step] - src[1*step];\n\n\n\n        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n\n        src[-1*step] = cm[src[-1*step] + diff];\n\n        src[ 0*step] = cm[src[ 0*step] - diff];\n\n\n\n        if (filter_p1 && FFABS(diff_p1p2) <= beta) {\n\n            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n\n            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n\n        }\n\n\n\n        if (filter_q1 && FFABS(diff_q1q2) <= beta) {\n\n            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n\n            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n\n        }\n\n    }\n\n}\n", "idx": 6646, "substitutes": {"src": ["files", "_", "rb", "bg", "data", "dest", "stream", "uc", "reverse", "support", "d", "cont", "rect", "go", "bc", "sound", "proc", "sel", "g", "img", "view", "pack", "st", "cur", "sites", "spec", "s", "send", "config", "slice", "upp", "https", "url", "sl", "obl", "gz", "dist", "sc", "lib", "ctx", "usr", "gl", "remote", "txt", "secure", "sq", "site", "text", "rob", "ui", "size", "stat", "sr", "sec", "tmp", "rc", "sync", "sn", "loc", "conv", "sci", "download", "rss", "sb", "inst", "hl", "feat", "source", "input", "gb", "supp", "ind", "c", "ssl", "sup", "r", "chrom", "pull", "sit", "http", "scope", "stack", "comp", "sys", "selected", "rest", "attr", "length", "bb", "us", "impl", "gs", "fn", "cb", "req", "iv", "console", "transform", "fc", "cv", "host"], "step": ["flow", "layer", "band", "progress", "shape", "route", "d", "weight", "push", "depth", "STEP", "steps", "pass", "Step", "access", "stage", "page", "mode", "name", "mix", "id", "config", "slice", "grade", "loop", "walk", "path", "pad", "sign", "scale", "amp", "sleep", "batch", "ip", "test", "form", "group", "grad", "patch", "ste", "sec", "block", "change", "sync", "repeat", "dash", "phase", "key", "version", "input", "run", "frame", "prop", "start", "move", "set", "seed", "dim", "store", "piece", "trial", "skip", "drop", "wait", "length", "space", "split", "delay", "part", "stop", "dc", "load", "lock", "direction", "pointer", "transform", "sample"], "stride": ["Striding", "striding", "stiding", "STRide", "strided", "slange", "strange", "STRange", "striide", "slides", "striided", "strIDE", "strides", "striiding", "slince", " strides", " strange", "stIDE", "StrIDE", "slide", "strince", "STRince", "striIDE", " strince", "Strided", "stided", "stide", "Stride", "STRides"], "filter_p1": ["filter_p01", "filter_param50", "filter_p61", "filter_c3", "filter_ps1", "filter_q2", "filter_p7", "filter_v01", "filter_q50", "filter_ps0", "filter_ps2", "filter_P0", "filter_q7", "filter_P3", "filter_pc2", "filter_k2", "filter_ps91", "filter_c91", "filter_q3", "filter_v1", "filter_k50", "filter_q0", "filter_pc1", "filter_P1", "filter_q61", "filter_c2", "filter_p3", "filter_c1", "filter_param2", "filter_k1", "filter_P2", "filter_q91", "filter_p2", "filter_pc01", "filter_c0", "filter_v2", "filter_param61", "filter_q01", "filter_pc7", "filter_k61", "filter_param1", "filter_p50", "filter_p0", "filter_p91", "filter_v7"], "filter_q1": ["filter_p9", "filter_c3", "filter_pb", "filter_pone", "filter_q2", "filter_k2", "filter_q3", "filter_v1", "filter_p8", "filter_q0", "filter_dq0", "filter_qa1", "filter_v3", "filter_kone", "filter_h1", "filter_dq8", "filter_qone", "filter_dq2", "filter_c2", "filter_q9", "filter_qa2", "filter_p3", "filter_c1", "filter_k1", "filter_dq9", "filter_q8", "filter_dq1", "filter_qab", "filter_p2", "filter_v0", "filter_qb", "filter_c0", "filter_qa8", "filter_v2", "filter_cone", "filter_dqb", "filter_p0", "filter_h9", "filter_h2", "filter_k0", "filter_h0"], "alpha": ["\u03b1", "area", "a", "la", "aa", "x", "si", "appa", "inc", "ma", "offset", "attr", "pi", "phi", "Beta", "margin", "acl", "error", "da", "pha", "Alpha", "p", "scale", "amp", "qa", "filter", "sup", "ho", "ta", "hi", "c", "asc", "igma", "ac", "lambda", "audio", "mu"], "beta": ["eta", "acc", "pa", "config", "tmp", "gap", "b", "sum", "si", "bi", "unit", "negative", "offset", "phi", "ii", "Beta", "margin", "sc", "error", "bis", "binary", "pha", "Alpha", "bc", "ba", "\u03b2", "scale", "qa", "zero", "ta", "params", "ac", "pb", "lambda", "neg", "mu", "tc"], "lim_p0q0": ["lim_p0c10", "lim_p1pi", "lim_p0dqi", "lim_p1p6", "lim_p0Q2", "lim_p0p0", "lim_p0qa10", "lim_p0p2", "lim_p0qa6", "lim_p1qi", "lim_p0c1", "lim_p1q2", "lim_p1q6", "lim_p1q1", "lim_p0dq1", "lim_p0dq0", "lim_p0c0", "lim_p0c6", "lim_p0q2", "lim_p1q10", "lim_p0qa0", "lim_p1p2", "lim_p0q6", "lim_p1q0", "lim_p0pi", "lim_p0dq2", "lim_p0q10", "lim_p1p10", "lim_p1p0", "lim_p0qi", "lim_p1p1", "lim_p0Q1", "lim_p0p1", "lim_p0qa1", "lim_p0q1", "lim_p0p6", "lim_p0Q0", "lim_p0p10", "lim_p0Qi"], "lim_q1": ["lim_p2", "lim_qa2", "lim_qa01", "lim_p01", "lim_Q01", "lim_Q1", "lim_q0", "lim_p0", "lim_Q0", "lim_q2", "lim_qa1", "lim_q01", "lim_qa0", "lim_Q2"], "lim_p1": ["lim1p1", "lim1q1", "lim_p2", "lim1q2", "lim1q0", "lim_P2", "lim_qa2", "lim_q86", "lim_q4", "lim_qa86", "lim_P0", "lim_q0", "lim_p0", "lim1p2", "lim_n4", "lim_q2", "lim_qa1", "lim_n2", "lim_p4", "lim_qa0", "lim_P4", "lim_p86", "lim_P86", "lim_P1", "lim1p86", "lim_n0", "lim1q86", "lim1p0", "lim_n1"], "cm": ["cp", "gc", "cr", "gm", "rom", "comm", "iam", "ci", "config", "sem", "com", "rc", "wm", "bm", "co", "module", "dem", "m", "rm", "cl", "client", "nm", "url", "sm", "cc", "ctr", "cs", "conf", "cons", "con", "acl", "mc", "km", "CM", "cam", "cmd", "ctx", "tm", "bc", "fp", "cb", "fm", "ca", "asm", "c", "im", "cn", "cf", "lc", "ym", "fc", "core", "ctrl", "msg"], "i": ["o", "ti", "v", "I", "chi", "di", "ci", "ni", "b", "x", "si", "io", "xi", "bi", "m", "qi", "l", "f", "pi", "at", "phi", "d", "ii", "j", "iu", "it", "ai", "e", "k", "n", "mi", "ini", "ie", "p", "h", "hi", "c", "ip", "im", "y", "li", "fi", "index", "zi", "mu", "ui"], "t": ["ot", "o", "tf", "ti", "ret", "te", "v", "a", "total", "nt", "tmp", "qt", "b", "x", "tr", "template", "wt", "tu", "m", "pt", "l", "f", "at", "d", "j", "q", "it", "e", "w", "out", "tw", "port", "n", "tm", "ts", "p", "temp", "h", "z", "ta", "c", "g", "tg", "y", "type", "dt", "tp", "txt", "tt", "T", "text", "test", "r", "tc"], "u": ["o", "U", "uid", "v", "pu", "total", "b", "x", "up", "flat", "tu", "m", "unit", "uv", "l", "f", "ue", "d", "q", "tc", "e", "w", "ur", "k", "n", "su", "p", "ou", "ut", "h", "c", "ta", "ul", "y", "r", "mu", "ui", "nu"], "diff": ["patch", "cmp", "del", "mix", "change", "md", "changed", "progress", "distance", "eff", " difference", "config", "sect", "update", "edge", "x", "iff", "shift", "slice", "edit", "comp", "dx", "help", "null", "l", "different", "f", "version", "d", "add", "dist", "split", "def", "conf", "part", "e", "low", "error", "comment", "dev", "err", "load", "ie", "end", "temp", "qa", "fail", "ge", "charge", "range", "new", "desc", "ref", "test", "form", "mu", "Diff", " delta"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650, "substitutes": {"xendev": ["xEndow", "xendingow", "xenddev", "xendedever", "xendingdev", "xEnderv", "xentdev", "xendr", "ystartep", "xndown", "xentown", "exenddev", "xendsep", "xendedev", "wxentown", "xendown", "xendep", "xendedr", "xendingr", "xendsdev", "xendingev", "xestdev", "exnddev", "txendingow", "exendee", " xenddev", "exndever", "xndove", "xstartdev", "xentee", "ystartev", "yendev", "xenderv", "Xendedev", " xestee", "exndee", "txendr", "xstartev", "txendingev", "exendever", "yendoc", "xstartoc", "xinddev", "xnderv", "txenderv", "xndee", "xestever", "ystartoc", "xendever", "Xendove", "yendep", "xndever", "xendedown", "Xendedove", " xendee", "xendedove", "wxentev", " xendever", "xentep", "xendove", " xestdev", "exndev", "xindever", "Xendeddev", "xendsoc", "xendederv", "txendingr", "xendingerv", "wxendev", "xEndr", "xestev", "xendeddev", "Xendederv", "txendow", "xentever", "xendee", "xenterv", "xendsev", "Xendev", " xestev", "yenddev", "xndev", "xentoc", "exendev", "wxenderv", "xendow", "xendedow", "xendingove", " xestever", "wxenterv", "xstartep", "wxendown", "xendoc", "Xenderv", "ystartdev", "xendedee", "wxenddev", "txendev", "txendingerv", "xnddev", "xestee", "xindev", "xentev", "wxentdev", "Xenddev", "xEndev", "xindee"], "con": ["fat", "Con", "cr", "pan", "ann", "sec", "open", "pen", "pin", "wan", "non", "cat", "co", "canon", "uc", "CON", "ran", "hel", "cm", "cl", "client", "conv", "ain", "gin", "pc", "cc", "connect", "conf", "cons", "acon", "col", "close", "connection", "en", "an", "scan", "func", "fn", "ocon", "fac", "exec", "container", "fa", "common", "ctrl", "ca", "ec", "run", "un", "don", "fun", "c", "can", "cn", "cf", "core", "fc", "ban", "ac", "cache", "syn", "bn", "conn"]}}
{"project": "FFmpeg", "commit_id": "8772d2511a4ac45f275eaef2b4b6b1ef132c993b", "target": 1, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n", "idx": 6670, "substitutes": {"num": ["uni", "name", "hom", "inf", "bin", "id", "mult", "gnu", "sum", "i", "umi", "typ", "unit", "loc", "uu", "valid", "inc", "offset", "lim", "mn", "nm", "init", "ctr", "param", "split", "np", "number", "dom", "len", "con", "u", "en", "Num", "fn", "n", "nom", "NUM", "multi", "coord", "nb", "prefix", "one", "common", "temp", "mom", "nam", "zero", "pos", "node", "off", "ul", "um", "term", "test", "index", "no", "on", "min", "max", "dim", "end", "nu"]}}
{"project": "qemu", "commit_id": "2e63eb2becc228232f12a1ea30a91b2aa8c5cecd", "target": 1, "func": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};", "idx": 6674, "substitutes": {"klass": ["cll", "cass", "oklass", "sklass", "cclass", " kclass", " kll", "skass", "skla", " kazz", "kla", "okcl", "skll", "skcl", "okazz", "kass", "kazz", "okclass", "kclass", " kass", "kela", " kla", "keass", "kcl", "class", "skclass", "kelass", "keclass", "kll", "skazz", " kcl"], "data": ["parent", "dat", "dd", "device", "config", "i", "info", "m", "d", "DATA", "def", "da", "ata", "raw", "Data", "ctx", "result", "p", "context", "array", "input", "reader", "new", "params", "rec"], "dc": ["writer", "dr", " DC", "di", "dd", "acc", "dat", "config", "disc", "nc", "cca", "enter", "draw", "db", "ga", "dk", "d", "cc", "director", "dir", "mc", "sc", "da", "df", "ds", "bc", "deck", "ec", "DC", "doc", "c", "cf", "design", "tk", "fc", "lc", "dt", "ac", "desc", "cdn", "cd", "tc"], "k": ["ko", "o", "kin", "kn", "ka", "ik", "ki", "kick", "kk", "i", "wk", "ad", "m", "key", "sk", "K", "ijk", "f", "dk", "d", "j", "q", "it", "cc", "u", "kt", "ck", "e", "ak", "w", "ks", "kid", "self", "work", "p", "kw", "ke", "c", "g", "tk", "ku", "uk", "kr", "mk", "ok"]}}
{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n", "idx": 6685, "substitutes": {"ohci": ["ahcu", "ohca", "ahci", "ohlc", "hsci", "hcu", "bhsci", "ahdi", "ehdi", "ehlc", "ovc", "bhlc", "ohdi", "ehsci", "ohki", "ehc", "ihki", "hc", "bhci", "ehcu", "ahki", "ehki", "hci", "ihc", "ihlc", " ohsci", "ehcci", " ohlc", "ehci", "ohc", " ohcu", "ohsci", "ohcu", "ohcci", "ovci", "hlc", "ihcci", "ihdi", "ihca", "hcci", "ovcci", "ihci", "bhcu", "ahcci", "ahca", "ovcu", "ihcu", "ahc", "ihsci", "ehca"]}}
{"project": "qemu", "commit_id": "3ac2f2f765a0bc18dfb18c38a522e6123289ffc1", "target": 1, "func": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}", "idx": 6699, "substitutes": {"func_fprintf": ["func_tfold", "func_ufprintf", "func_sfprintln", "func_fold", "func_tfriter", "func_tfursive", "func_cprintln", "func_ufriter", "func_cprintf", "func_cold", "func_fursive", "func_tfprintln", "func_fprint", "func_Fwrite", "func_ufwrite", "func_Fursive", "func_tfwrite", "func_tfprint", "func_fwrite", "func_fprintln", "func_Friter", "func_sfold", "func_Fprintf", "func_tfprintf", "func_ufursive", "func_friter", "func_cprint", "func_sfprintf", "func_sfprint"], "f": ["function", "fr", "o", "tf", "sf", "b", "x", "i", "m", "fx", "l", "d", "j", "fl", "u", "e", "func", "t", "fn", "df", "n", "fp", "self", "p", "fm", "h", "fs", "c", "new", "g", "fd", "cf", "fi", "F"], "info_spec": ["info_Spec", " info_SPEC", "info_complete", " info_parse", " info_Spec", " info_complete", "info_SPEC", "info_parse"], "obj": ["name", "o", "act", "objects", "id", "parent", "Obj", "obb", "eff", "tmp", "po", "b", "ob", "val", "object", "i", "oa", "art", "info", "x", "pt", "url", "j", "fl", "init", "u", "w", "arr", "bis", "fn", "bot", "n", "ctx", "Object", "cb", "self", "rev", "nb", "result", "p", "coll", "temp", "str", "boot", "iv", "pos", "oi", "os", "txt", "g", "orig", "api", "adj", "img", "ass", "bj", "js"], "data": ["name", "o", "id", "alpha", "di", "dat", "value", "dd", "val", "object", "style", "i", "rel", "info", "body", "image", "key", "results", "attr", "media", "d", "j", "args", "DATA", "def", "len", "error", "da", "json", "ata", "ds", "raw", "n", "Data", "response", "result", "p", "array", "pos", "type", "api", "class", "li", "cache", "dict"], "v": ["function", "vol", "vim", "verb", "o", "vm", "V", "va", "vt", "b", "x", "i", "m", "uv", "l", "gu", "conv", "ve", "ii", "d", "j", "q", "tv", "vi", "ev", "vs", "u", "e", "w", "k", "t", "self", "p", "h", "vp", "sv", "z", "iv", "ver", "c", "g", "y", "ov", "lv", "api", "vv", "cv", "vc", "view"]}}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 6708, "substitutes": {"avctx": [" avcontext", " avcmp", " avcv", "evconn", " avcoll", "AVcv", "evcmp", "AVcoll", "afcv", "AVctx", "evcontext", "afcmp", "AVcontext", "avcmp", "avcoll", "afctx", "avcv", "avcontext", "AVcmp", "afcoll", "afconn", "afcontext", "AVconn", "avconn", "evctx"], "data": ["base", "address", "as", "name", "append", "feed", "header", "block", "id", "a", "parent", "dat", "value", "device", "object", "slice", "format", "ad", "record", "body", "image", "map", "buf", "window", "draw", "package", "content", "parts", "media", "d", "DATA", "code", "da", "message", "raw", "ata", "Data", "pad", "empty", "exec", "str", "load", "result", "input", "reader", "start", "pos", "primary", "sample", "inner", "cache", "next", "rec", "first", "ui"], "got_sub_ptr": ["got_subfptr", "got_sub_rect", "got_subqdesc", "got_subuchar", "got_subftr", "got_subvalchar", "got_subqtr", "got_subqrect", "got_sub_tr", "got_sub_pointer", "got_sub_desc", "got_subulength", "got_reg2desc", "got_subvalptr", "got_subvallength", "got_reg_ptr", "got_reg2rect", "got_sub2rect", "got_subqptr", "got_reg_tr", "got_subfdesc", "got_sub2tr", "got_subfrect", "got_subvalpointer", "got_subuptr", "got_reg2ptr", "got_reg_rect", "got_reg_desc", "got_sub2desc", "got_reg2tr", "got_subupointer", "got_sub_char", "got_sub_length", "got_sub2ptr"], "avpkt": ["awwpacket", "affett", "awwpcht", "avPkt", "AVcpacket", "avcpacket", "AVcpct", "afpacket", "avpedt", "avcpck", "avspki", "avespdt", "avpck", "avopacket", "avprent", "avprekt", "avcpkg", "avpett", "avPacket", "avfcht", "avepft", "affki", "AVpkt", "avopkt", "avfkt", "avwpacket", "avespcht", "avwpkt", "avpredt", "AVcpkg", "avPct", "awpcht", "avepreft", "avppft", "affkt", "aveprent", "avfdt", "avppnt", "avfki", "avwpcht", "avfpacket", "afpett", "avspdt", "avpki", "avespacket", "avfacket", "avfpkg", "avwpck", "awpacket", "avespkt", "avpct", "avfpct", "avppkt", "avbpacket", "avepacket", "avfett", "avcpct", "AVpacket", "avopdt", "avcpcht", "awwpkt", "avPck", "afpki", "avbpdt", "avbpkt", "awpck", "awwpck", "avpdt", "avopett", "AVpkg", "avfpkt", "AVpct", "avepredt", "avepdt", "AVcpkt", "avpacket", "avpekt", "avbpcht", "avpft", "avpreft", "avpnt", "avpeacket", "avspkt", "afpkt", "avcpkt", "avpeki", "aveprekt", "avspacket", "avepcht", "avepnt", "avPkg", "avPcht", "afpdt", "avpkg", "awpkt", "avppdt", "avpcht", "avcpdt", "avspett", "avepkt", "affdt", "avspcht", "avcpnt", "avcpft", "affacket"], "sub": ["name", "sec", "builder", "pre", "config", "b", "slice", "rc", "info", "uc", "buf", "job", "child", "j", "sl", "small", "match", "member", "split", "part", "sc", "per", "section", "func", "ab", "sp", "sup", "sa", "ub", "sel", "type", "Sub", "text", "pl", "pb", "desc", "form", "r", "summary", "rec", "super"], "buffer": ["writer", "base", "row", "position", "buff", "header", "iter", "v", " Buffer", "builder", "seek", "uffer", "b", "slice", "stream", "record", "queue", "m", "buf", "window", "uf", "null", "f", "server", "table", "byte", "sc", "parser", "file", "Buffer", "message", "binary", "pad", "bc", "fp", "str", "source", "context", "input", "processor", "surface", "FFER", "reader", "array", "batch", "ptr", "transfer", "pointer", "read", "result", "text", "cache", "ref", "reference", "summary", "copy"], "size": ["position", "large", "shape", "ci", "x", "password", "unit", "f", "original", "code", "len", "any", "esc", "empty", "g", "page", "general", "max", "scene", "name", "SIZE", "extra", "count", "channel", "send", "sum", "last", "capacity", "grade", "member", "number", "sized", "scale", "type", "form", "ui", "external", "uni", "address", "sec", "rc", "use", "sn", "loc", "small", "Size", "from", "e", "en", "source", "year", "pos", "c", "core", "cache", "body", "offset", "length", "args", "storage", "ize"], "ret": ["std", "base", "flag", "reg", "rt", "al", "id", "alt", "nt", "tmp", "val", "last", "rc", "reply", "valid", "db", "num", "lit", "ext", "att", "url", "obj", "arg", "res", "match", "def", "code", "len", "mt", "det", "error", "en", "full", "RET", "err", "str", "rev", "result", "Ret", "ft", "re", "fun", "back", "resp", "success", "ref", "no", "r", "rem", "rets"], "p": ["cp", "P", "o", "bp", "v", "pa", "x", "pre", "po", "b", "pp", "i", "op", "wp", "up", "pe", "lp", "ap", "m", "l", "f", "pi", "at", "post", "j", "d", "pc", "py", "np", "u", "e", "point", "part", "w", "per", "port", "t", "n", "ctx", "pad", "h", "sp", "pointer", "c", "ip", "g", "api", "tp", "current", "r"], "s": ["sf", "sec", "v", "is", "S", "spec", "sg", "b", "si", "sys", "ses", "m", "f", "ns", "server", "space", "service", "cs", "ss", "sc", "parser", "gs", "ops", "sb", "qs", "storage", "ctx", "su", "self", "context", "sv", "fs", "c", "g", "ssl", "sq", "api", "r", "ps"]}}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n\n{\n\n    YADIFContext *s = ctx->priv;\n\n    ThreadData *td  = arg;\n\n    int refs = s->cur->linesize[td->plane];\n\n    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;\n\n    int pix_3 = 3 * df;\n\n    int slice_h = td->h / nb_jobs;\n\n    int slice_start = jobnr * slice_h;\n\n    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;\n\n    int y;\n\n\n\n    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,\n\n     * we need to call the c variant which avoids this for border pixels\n\n     */\n\n    for (y = slice_start; y < slice_end; y++) {\n\n        if ((y ^ td->parity) & 1) {\n\n            uint8_t *prev = &s->prev->data[td->plane][y * refs];\n\n            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];\n\n            uint8_t *next = &s->next->data[td->plane][y * refs];\n\n            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n\n            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;\n\n            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,\n\n                           next + pix_3, td->w - 6,\n\n                           y + 1 < td->h ? refs : -refs,\n\n                           y ? -refs : refs,\n\n                           td->parity ^ td->tff, mode);\n\n            s->filter_edges(dst, prev, cur, next, td->w,\n\n                            y + 1 < td->h ? refs : -refs,\n\n                            y ? -refs : refs,\n\n                            td->parity ^ td->tff, mode);\n\n        } else {\n\n            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n\n                   &s->cur->data[td->plane][y * refs], td->w * df);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6727, "substitutes": {"ctx": ["cp", "cmp", "gc", "ci", "config", "bt", "rc", "cca", "tx", "cal", "pc", "cc", "sci", "cs", "sc", "mc", "conn", "ds", "cmd", "bc", "cb", "Context", "context", "ctrl", "ca", "kb", "c", "ct", "sq", "cf", "lc", "fc", "cv", "ref", "cas", "cm", "pkg", "xc", "tc"], "arg": ["anc", "ig", "arm", "ag", "ann", "val", "inter", "Args", "enc", "ray", "ad", "ace", "mac", "argument", "att", "call", "obj", "args", "arp", "ai", "pc", "param", "arc", "cell", "ar", "arr", "exec", "ang", "p", "input", "array", "amp", "Arg", "cand", "g", "ac", "ref"], "jobnr": ["bugnu", "magnr", "layernu", "worknu", "jobnl", "magnw", " jobrn", "pluginrn", " jobnl", "jobnu", "Jobrn", "bugNR", "queuenr", "magrn", "workNR", "queuenu", " jobNR", "casenr", "bugnw", "pluginnw", "jobNR", "pluginnr", "jobrn", "worknr", "casern", "JobNR", "casenumber", " jobnu", "jobnw", "pluginnom", " jobnumber", "jobnom", "magnom", "layernr", "Jobnr", "bugnr", "layernl", "queuenw", "layernw", "worknw", "queuenl", " jobnom", "jobnumber", " jobnw", "Jobnumber", "caseNR"], "nb_jobs": ["nrofimages", "nbwlines", "num_pages", "nr_jobs", "nb__pages", "nb__blocks", "nbOfpages", "nbOfdates", "nr_pieces", "nbofpieces", "np_steps", "np_jobs", "nb__jobs", "nbwsteps", "nb_pieces", "np_blocks", "nbjjobs", "nbjimages", "nbwblocks", "np_lines", "nb__steps", "nbOfjobs", "nb_images", "num_lines", "nb_points", "nb__lines", "nr_points", "nbofpoints", "nbwjobs", "nb_steps", "nb_lines", "nb_pages", "num_dates", "nrofpoints", "nb_blocks", "nbofjobs", "nr_images", "nbjpieces", "nbjpoints", "nb_dates", "num_jobs", "nbOflines", "nb__dates", "nbofimages", "nrofpieces", "nrofjobs"], "s": ["ans", "st", "sf", "S", "a", "spec", "sg", "session", "b", "si", "sync", "i", "sys", "ses", "services", "m", "so", "l", "sk", "f", "sam", "ns", "d", "sl", "ls", "sm", "args", "bs", "service", "cs", "ss", "sci", "conf", "sis", "e", "sc", "sh", "sb", "gs", "ks", "se", "t", "sd", "ds", "qs", "ts", "n", "su", "self", "p", "south", "this", "h", "sv", "fs", "sa", "c", "utils", "g", "ssl", "sq", "os", "u", "rs", "ps", "js"], "td": ["di", "dh", "elt", "data", "style", "typ", "dad", "d", "det", "sd", "span", "ft", "ht", "tg", "tk", "dt", "li", "pb", "lf", "nd", "dal", "cd", "tf", "dn", "nt", "ctl", "lt", "pod", "wp", "pt", "tif", "table", "butt", "ds", "zh", "ts", "direct", "south", "ld", "ud", "cod", "pl", "pdf", "ff", "std", "phy", "rt", "md", "bd", "vd", "dat", "dial", "ad", "BT", "th", "tl", "att", "metadata", "pc", "wd", "sb", "tn", "dev", "t", "tm", "gb", "ind", "ssl", "fd", "gt", "dl", "lv", "tt", "SD", "dim", "TD", "od", "dd", "pd", "rd", "edd", "kt", "chart", "kernel", "ta", "cz", "cdn", "hd"], "y": ["yy", "dy", "ory", "yd", "yer", "python", "zy", "fy", "sy", "id", "ady", "Y", "yo", "yt", "ny", "x", "iy", "b", "i", "iny", "cy", "sky", "sys", "m", "yn", "ya", "yu", "ty", "key", "wy", "yi", "j", "d", "ii", "my", "py", "ry", "ay", "e", "yl", "w", "uy", "oy", "t", "n", "vy", "ey", "year", "p", "yan", "idy", "ye", "ky", "h", "z", "gy", "hy", "yr", "ys", "ind", "c", "ym", "icy", "type", " Y", "isy"], "prev": ["cp", "cmp", "r", "header", "iter", "v", "pre", "b", "last", "data", "rc", "inter", "pred", "up", "rel", "info", "loc", "reverse", "before", "f", "post", "original", "upper", "Prev", "ur", "per", "dev", "k", "history", "jp", "self", "rev", "sav", "pres", "p", "old", "pub", "h", "frame", "vert", "start", "gen", "nav", "back", "vious", "orig", "head", "adr", "adj", "front", "cv", "current", "desc", "src", "rec", "first", "view"], "cur": ["dr", "cmp", "fr", "row", "ch", "serv", "er", "sr", "cour", "iter", "cr", "pr", "open", "mid", "up", "tr", "rc", "inter", "enc", "cat", "uc", "der", "sur", "loc", "th", "inc", "tri", "rest", "conv", "pri", "ctr", "ser", "tra", "con", "Cur", "ur", "per", "se", "cer", "chart", "rev", "coll", "pub", "car", "req", "usr", "frame", "vert", "tur", "start", "ver", "ub", "sel", "fer", "back", "ind", "var", "head", "cv", "desc", "cache", "keep", "src", "r", "end"], "next": ["gov", "sec", "open", "done", "future", "nt", "pre", "mid", "pos", "skip", "last", "data", "non", "now", "inc", "post", "child", "state", "Next", "all", "dev", "latest", "path", "other", "self", "rev", "p", "end", "more", "ne", "follow", "ner", "z", "start", "gen", "frame", "vert", "line", "new", "head", "vious", "doc", "c", "front", "desc", "current", "min", "max", "nd", "first"], "dst": ["Dst", "vdsts", "drc", "vdst", "Dost", "adsc", "dsc", " dest", " dost", "Dsts", "adST", "dest", "sdest", "dST", "dsts", "adrc", "adsts", " drc", "Dsc", " dsts", "vdST", " dsc", "sdost", "sdst", "adst", "Dest", "sdsts", "adost", "vdsc", "dost", " dST", "Drc"]}}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n", "idx": 6753, "substitutes": {"cpu": ["cp", "hp", "gp", "cmp", "ocr", "hw", "chip", "pai", "platform", "pu", "roc", "coe", "vm", "component", "colo", "plug", "rc", " CPU", "gpu", "px", "mac", "dylib", "pc", "linux", "cli", "np", "cpp", "clock", "kernel", "jp", "process", "processor", "computer", "pty", "boot", "css", "proc", "c", "GPU", "cn", "core", "lc", "cache", "loader", "CPU"], "eaddr": ["ewDR", "awDR", "ADdr", "ADder", "eadDR", "eadDr", "addDr", "abDr", "adddr", "awrd", "addrd", "eadrd", "abdr", "ewder", "eadder", "aceder", "ADDr", "ewdr", "abrd", "acedr", "awDr", "addDR", "aceDr", "ADDR", "aceDR", "ewDr", "awdr", "abDR"], "rwx": ["rawxs", "ewf", "ewxx", "rawxx", "rawf", "ewx", "RWx", "rwf", "RWex", "rwlex", "rrx", "rrxx", "rrlex", "wrx", "rrex", "rwex", "RWlex", "wrex", "rawx", "RWf", "rwxx", "RWxx", "RWxs", "wrlex", "wrxx", "ewxs", "rwxs"], "mmu_idx": ["mmu_itb", "mmu_idxs", "mmu_itv", "mmu_ridv", "mmu_idv", "mmu_ridX", "mmu_Idx", "mmu_IdX", "mmu_Idb", "mmu_Idxs", "mmu_itx", "mmu_itxs", "mmu_idX", "mmu_ridb", "mmu_ridx", "mmu_Idv", "mmu_idb"]}}
{"project": "FFmpeg", "commit_id": "1f361124d97cf8b8ce6d3aacb10cdc53706470de", "target": 1, "func": "int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]           = { 0 }, ret[3] = { 0 };\n\n    AVIOContext *f[3]     = { NULL };\n\n    AVCodecContext *codec = s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path,\n\n                                  s->img_number) < 0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for (i = 0; i < 3; i++) {\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if (i >= 1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",\n\n                       filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i] = avio_size(f[i]);\n\n\n\n            if (!s->split_planes)\n\n                break;\n\n            filename[strlen(filename) - 1] = 'U' + i;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_NONE) {\n\n            AVProbeData pd;\n\n            AVInputFormat *ifmt;\n\n            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];\n\n            int ret;\n\n            int score = 0;\n\n\n\n            ret = avio_read(f[0], header, PROBE_BUF_MIN);\n\n            if (ret < 0)\n\n                return ret;\n\n\n            avio_skip(f[0], -ret);\n\n            pd.buf = header;\n\n            pd.buf_size = ret;\n\n            pd.filename = filename;\n\n\n\n            ifmt = av_probe_input_format3(&pd, 1, &score);\n\n            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)\n\n                codec->codec_id = ifmt->raw_codec_id;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        if (s->frame_size > 0) {\n\n            size[0] = s->frame_size;\n\n        } else {\n\n            size[0] = 4096;\n\n        }\n\n    }\n\n\n\n    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)\n\n        return AVERROR(ENOMEM);\n\n    pkt->stream_index = 0;\n\n    pkt->flags       |= AV_PKT_FLAG_KEY;\n\n    if (s->ts_from_file) {\n\n        struct stat img_stat;\n\n        if (stat(filename, &img_stat))\n\n            return AVERROR(EIO);\n\n        pkt->pts = (int64_t)img_stat.st_mtime;\n\n        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);\n\n    } else if (!s->is_pipe) {\n\n        pkt->pts      = s->pts;\n\n    }\n\n\n\n    pkt->size = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        if (f[i]) {\n\n            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if (ret[i] > 0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        s->pts++;\n\n        return 0;\n\n    }\n\n}", "idx": 6763, "substitutes": {"s1": ["fs81", "cs1", "s81", "cone", "sone", "c2", "ds3", "c1", "sons", "sys1", "jsfirst", "e2", "sysons", "js81", "sfirst", "sc7", "ns11", "f3", "s2", "csone", " s81", "e1", "fs1", "dsone", "s7", " sfirst", "js1", "eone", "fone", "dsons", "ds11", "sc11", " s7", "fsfirst", "ds1", " s11", "s3", "sysrc", " sons", " src", "ns7", "cs2", "sys11", "s11", "ns1", "f1", "src", "dsrc", "c3", "sc1"], "pkt": [" ppt", "dpkt", "Ppt", "Pkt", "dpct", "ppt", " pct", "dppt", "pct", "packet", "Pct", "dpacket", "Packet", " packet"], "s": ["S", "a", "b", "data", "sk", "parts", "d", "service", "conf", "w", "self", "h", "aws", "g", "sym", "y", "tp", "sets", "is", "spec", "services", "its", "states", "server", "ls", "sc", "ds", "ctx", "ts", "settings", "sv", "fs", "new", "sq", "ms", "site", "rs", "as", "sec", "ins", "sg", "comments", "sync", "ses", "cs", "u", "vs", "e", "sb", "ks", "t", "qs", "p", "c", "os", "ssl", "ims", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "args", "us", "ss", "gs", "storage", "n", "this", "es", "js"], "filename_bytes": ["Filename_Bytes", "filename6length", "filename_tes", "filename2Bytes", "Filename_bits", "filename_seconds", "sound_lines", "filename_Bytes", " filename_lines", "filename2seconds", "filename_parts", "sound_Bytes", "filename6lines", "filename_bits", "filename6bytes", "sound_bytes", "filename2bytes", "filename_groups", "sound_tes", " filename_length", "filename_lines", "Filename_parts", "Filename_bytes", "Filename_seconds", "filename_length", "filename2parts", "Filename_groups"], "filename": ["name", "files", "sf", "kn", "word", "username", "STDOUT", "whatever", "data", "final", "sn", "slice", "image", "status", "sequence", "wb", "content", "url", "metadata", "phrase", "sheet", "nm", "length", "document", "gz", "subject", "which", "ename", "buffer", "fil", "uri", "download", "file", "message", "fn", "binary", "json", "jpg", "directory", "fp", "dll", "nil", "feat", "suff", "source", "output", "memory", "kl", "txt", "bf", "sym", "utf", "il", "fd", "sword", "src", "Filename", "summary", "prefix"], "i": ["gi", "layer", "ti", "v", "id", "I", "count", "chi", "di", "ci", "ki", "ni", "x", "xi", "si", "ri", "slice", "abi", "b", "io", "bi", "m", "qi", "ix", "l", "num", "pi", "yi", "phi", "j", "ii", "iu", "d", "it", "cli", "ai", "split", "u", "vi", "part", "len", "e", "uri", "n", "multi", "mi", "ini", "ie", "p", "mini", "eni", "z", "start", "oi", "hi", "c", "ip", "y", "lc", "li", "inner", "fi", "index", "zi", "diff", "mu", "ui"], "size": ["fat", "name", "ch", "time", "SIZE", "extra", "sec", "el", "shape", "value", "x", "sum", "data", "final", "sn", "enc", "si", " sizes", "body", "unit", "status", "loc", "offset", "content", "j", "length", "fl", "small", "Size", "member", "code", "len", "buffer", "e", "en", "message", "file", "sized", "empty", "z", "g", "fd", "desc", "ize", "form"], "ret": ["flag", "reg", "mem", "el", "rt", "alt", "id", "nt", "lt", "val", "rc", "data", "sn", "enc", "final", "cat", "info", "reply", "let", "flat", "status", "valid", "uf", " Ret", "lit", "offset", "ext", "att", "pet", "res", "match", "def", "buffer", "len", "part", "det", "error", "out", "en", "RET", "fn", "feat", "response", "rl", "result", "temp", "Ret", "opt", "ft", "re", "fun", "back", "detail", "bf", "resp", "gt", "txt", "success", "ref", "rep", "test", "group", "desc", "rets"], "f": ["fen", "fr", "feed", "sf", "v", "b", "x", "rf", "info", "m", "fb", "l", "d", "fl", "j", "q", "fe", "u", "def", "e", "w", "file", "full", "fn", "t", "df", "xf", "fp", "self", "of", "fa", "p", "h", "z", "frame", "fs", "c", "g", "fd", "cf", "fc", "lf", "r", "F"], "codec": ["predec", "Codoc", "codroc", "codef", "Codef", "labec", " codric", "predoc", "labef", "odroc", "laboc", "predef", "codeca", "Codroc", "Coditor", "odric", "coditor", "calroc", "pedeca", "pedef", "CodEC", "calitor", " codeca", "pedec", "odeca", "Codec", " codef", "labEC", "oditor", "codoc", "calec", "odef", "predEC", "pedric", "codEC", "codric", "odec"], "pd": [" dw", " rec", " td", " cd", " dd", " board", "data", " buff", " obj", " det", " ad", " sd", " rc", " dc", "d", " din", " parser", " enc", " da", " device", " d", " cc", " dev", " gp", " structure", " dst", " props", " def", " coding"], "ifmt": [" ifm", "ifvt", "ifdr", " ifdr", "itvt", "iffvt", "itmt", "ifm", "itm", "iffmt", "iffm", "iffdr", "itdr", " ifvt"], "header": ["master", "writer", "dr", "name", "layer", "bin", "block", "channel", "tail", "cover", "data", "token", "body", "mask", "holder", "null", "offset", "content", "event", "player", "meta", "version", "metadata", "server", "document", "table", "byte", "buffer", "len", "Header", "secondary", "df", "headers", "h", "cap", "head", "type", "handler", "index", "flags"], "img_number": ["imgIdwork", "imgsno", "img_work", "imgIPnext", "imglnumber", "imgqno", "imgsnumber", "imgkno", "image_next", "image_no", "imgIPclass", "imgqnumber", "image_numbered", "imglnum", "img_address", "img_source", "imag_work", "image_last", "image_num", "image_class", "imgsfirst", "imgqclass", "imgIdnom", "img_last", "img_type", "imgknumber", "imgqnext", "image_address", "imgIdnum", "imgIdnumber", "imag_nom", "imgslast", "imgladdress", "img_numbered", "image_first", "img_no", "imag_num", "imgknumbered", "image_number", "imgIPnumber", "imgIPno", "image_type", "imgknext", "img_next", "img_class", "image_source", "img_nom", "img_num", "img_first", "imag_number", "imgltype"]}}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 6775, "substitutes": {"opaque": ["defaques", "oppaques", "opque", "defaque", "oppace", "operaques", "ipaques", "oppaque", "ipque", "operac", "operaque", "ipace", "opac", "hopace", "ipaque", "osaques", "defac", "hopaque", "hopque", "osac", "opaques", "opace", "oppque", "hopaques", "osaque"], "addr": ["address", "dr", "host", "reg", "device", "nc", "data", "ad", "ace", "tx", "offset", "add", "pc", "arg", "part", "len", "arr", "port", "pad", "seq", "pos", "pointer", "alloc", "ip", "ac", "ref", "src", "prefix"], "val": ["stat", "base", "address", "pid", "ret", "reg", "v", "al", "block", "mem", "alt", "el", "value", "pre", "x", "data", "b", "slice", "Val", "pt", "valid", "vals", "f", "VAL", "sl", "pc", "arg", "def", "buffer", "len", "all", "arr", "pal", "eval", "pos", "bl", "ref", "cache", "slot"], "bus": ["plugin", "o", "feed", "block", "hub", "local", "http", "BUS", "config", "plug", "io", "sync", "cat", "Bus", "drive", "usb", "loop", "us", "service", "mount", "driver", "lib", "pass", "bc", "lock", "bridge", "boot", "proc", "os", "c", "board", "cache", "host", "hole"], "s": ["as", "r", "o", "sf", "v", "ins", "is", "S", "less", "spec", "scope", "b", "si", "i", "sync", "sys", "ses", "services", "m", "states", "l", "xs", "f", "parts", "ns", "state", "d", "ls", "sl", "stats", "args", "service", "us", "ss", "cs", "u", "hs", "bs", "e", "space", "w", "gs", "ks", "se", "ops", "t", "ds", "n", "ts", "su", "self", "settings", "fs", "c", "os", "g", "ssl", "sym", "params", "es", "rs", "ps", "js"], "p": ["cp", "P", "pid", "o", "bp", "v", "pr", "pu", "pa", "pat", "pre", "po", "pp", "data", "i", "b", "x", "pe", "lp", "ap", "m", "l", "f", "pi", "at", "j", "d", "pc", "py", "q", "u", "np", "e", "point", "dp", "per", "t", "n", "fp", "ptr", "sp", "pointer", "c", "ip", "y", "api", "tp", "pl", "pb", "ps"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,\n\n                                                     PutBitContext *pb, const float *in, float *out,\n\n                                                     const float *scaled, int size, int scale_idx,\n\n                                                     int cb, const float lambda, const float uplim,\n\n                                                     int *bits, const float ROUNDING)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    int qc1, qc2, qc3, qc4;\n\n\n\n    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];\n\n    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];\n\n    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    abs_pow34_v(s->scoefs, in, size);\n\n    scaled = s->scoefs;\n\n    for (i = 0; i < size; i += 4) {\n\n        int curidx, curidx2;\n\n        int *in_int = (int *)&in[i];\n\n        uint8_t v_bits;\n\n        unsigned int v_codes;\n\n        int t0, t1, t2, t3, t4, t5, t6, t7;\n\n        const float *vec1, *vec2;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                      \\n\\t\"\n\n            \".set noreorder                 \\n\\t\"\n\n\n\n            \"ori    %[t4],  $zero,  4       \\n\\t\"\n\n            \"slt    %[t0],  %[t4],  %[qc1]  \\n\\t\"\n\n            \"slt    %[t1],  %[t4],  %[qc2]  \\n\\t\"\n\n            \"slt    %[t2],  %[t4],  %[qc3]  \\n\\t\"\n\n            \"slt    %[t3],  %[t4],  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t4],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t4],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t4],  %[t3]   \\n\\t\"\n\n            \"lw     %[t0],  0(%[in_int])    \\n\\t\"\n\n            \"lw     %[t1],  4(%[in_int])    \\n\\t\"\n\n            \"lw     %[t2],  8(%[in_int])    \\n\\t\"\n\n            \"lw     %[t3],  12(%[in_int])   \\n\\t\"\n\n            \"srl    %[t0],  %[t0],  31      \\n\\t\"\n\n            \"srl    %[t1],  %[t1],  31      \\n\\t\"\n\n            \"srl    %[t2],  %[t2],  31      \\n\\t\"\n\n            \"srl    %[t3],  %[t3],  31      \\n\\t\"\n\n            \"subu   %[t4],  $zero,  %[qc1]  \\n\\t\"\n\n            \"subu   %[t5],  $zero,  %[qc2]  \\n\\t\"\n\n            \"subu   %[t6],  $zero,  %[qc3]  \\n\\t\"\n\n            \"subu   %[t7],  $zero,  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n", "idx": 6778, "substitutes": {"s": ["sets", "sed", "v", "is", "S", "a", "spec", "sg", "scope", "session", "b", "si", "sync", "sys", "ses", "services", "f", "ns", "stats", "sl", "ls", "service", "cs", "ss", "conf", "sc", "sb", "ops", "gs", "ts", "su", "self", "p", "south", "settings", "this", "sv", "utils", "c", "os", "g", "ssl", "sq", "sa", "new", "src", "rs", "sup", "ps", "js"], "pb": ["abc", "cp", "bp", "rb", "kB", "pd", "bps", "pp", "rc", "wp", "bm", "lp", "fb", "pm", "pg", "mp", "prot", "pc", "sb", "bc", "PB", "amp", "PC", "gb", "proc", "cv", "pl", "cpp"], "in": ["login", "inf", "bin", "ins", "id", "pin", "config", "x", "inn", "data", "rec", "din", "circ", "image", "m", "inc", "f", "nin", "gin", "init", "IN", "con", "scan", "win", "isin", "err", "vin", "ini", "pass", "In", "source", "input", "into", "again", "c", "lin", "query", "inner", "src", "img", "conn"], "out": ["OUT", "o", "bin", "b", "data", "bit", "image", "m", "inc", "f", "at", "call", "init", "w", "cmd", "outs", "result", "source", "temp", "output", "doc", "Out", "new", "g", "r", "external"], "scaled": ["SCalled", "Scaled", "oscaling", "Scalled", "captaling", "escured", "oscalled", " scaling", "scraped", "SCaling", "SCaled", "oscaled", " scalled", "captaled", "escalled", "escaled", "escared", "scared", "scalled", "descaled", "SCraped", " scraped", "scaling", "Scaling", "escaling", "SCured", "descalled", "SCaped", "captured", "scaped", "Scared", "descaped", "Scraped", "oscaped", "escaped", "descared", "Scaped", "scured", " scaped", "captalled"], "size": ["uni", "ch", "SIZE", "sec", "shape", "sum", "sn", "co", "loc", "ix", "grade", "small", "Size", "q", "cs", "six", "code", "len", "sc", "sh", "dc", "sized", "ctx", "bc", "scale", "z", "c", "sq", "iz", "ize", "cm", "shift"], "scale_idx": ["scale_sidn", "scale_fdxx", "scale_idxx", "scale_mainx", "scale_ridX", "scale_fdced", "scale_idsn", "scale_sidg", "scale_idced", "scale_ridct", "scale_headz", "scale_idg", "scale_headced", "scale_mainct", "scale_idsced", "scale_sidz", "scale_idsx", "scale_headx", "scale_idX", "scale_idz", "scale_fdx", "scale_idp", "scale_mainp", "scale_ridx", "scale_idsz", "scale_idsxx", "scale_idsg", "scale_fdz", "scale_idn", "scale_ridp", "scale_sidx", "scale_headxx", "scale_idct", "scale_mainX"], "cb": ["CB", "cp", "cmp", "cgi", "buff", "cr", "fee", "obb", "ci", "rb", "crop", "ob", "nc", "com", "repeat", "sync", "kk", "loc", "cm", "buf", "db", "wb", "fb", "job", "abb", "call", "bb", "ctr", "conf", "cpp", "code", "sb", "dc", "cor", "lib", "ctx", "hh", "bc", "nb", "callback", "seq", "btn", "gb", "bf", "cf", "core", "lc", "cv", "cod", "desc", "src", "ctrl", "cd", "ff"], "lambda": ["abc", " mu", "alpha", "la", "beta", " dim", " disp", "nc", "inv", "appa", " gamma", "phi", " la", " lam", "da", "func", "dc", "bc", " omega", "DEF", "qa", "LA", "igma", " sig", "aux", "mu", " delta"], "uplim": ["uplike", "Uplib", "ulabib", "Uplim", "Uclen", "uclen", "Uplen", "ulaben", "uclim", "Uclib", "ublen", "ublib", "Uclim", "Uclike", "Uplike", "ublim", "uclike", "ublike", "ulabike", "uplen", "uclib", "uplib", "ulabim"], "bits": ["bands", "features", "config", "bps", "bit", "rows", "its", "ips", "details", "pins", "hours", "codes", "parts", "forces", "cycles", "bs", "ints", "ops", "bis", "bytes", "jobs", "fps", "blocks", "pieces", "gb", "pos", "flags"], "ROUNDING": ["ROUNDED", "Brounding", "BOUND32", "RUN32", "Rrounding", "RUNing", "RroundED", "BOUNDING", "BOUNDED", "RoundingED", "Rounding32", "ROUNDing", "Roundinging", "BroundING", "RUNING", "Rround32", "RroundING", "BOUNDing", "Bround32", "RoundingING", "BroundED", "ROUND32", "RUNED"], "i": ["gi", "ei", "ti", "iq", "id", "I", "chi", "is", "min", "di", "a", "ci", "ni", "xi", "x", "si", "slice", "io", "abi", "info", "bi", "qi", "ix", "l", "key", "f", "pi", "yi", "phi", "j", "ii", "iu", "ij", "it", "ai", "my", "e", "uri", "k", "n", "multi", "mi", "ini", "ie", "p", "jit", "mini", "z", "eni", "iv", "oi", "c", "ip", "ind", "g", "y", "type", "li", "inner", "fi", "index", "zi", "idi", "mu", "ui"], "qc1": ["qf0", "qc11", "qe11", "qdc6", " qdc0", "qsc6", "qe2", "qsc1", "qdc11", " qc0", "qdc0", "qdc2", "qpc5", "Qdc6", "qsc2", "Qdc5", "qpc2", "qf11", " qdc1", "Qc6", "Qc2", " qdc2", "qc6", "qpc1", "qe0", "qc5", "qdc5", "qpc6", "qf1", " qdc11", "qf2", "Qc5", "qsc5", " qc11", "qe1", "Qc1", "Qdc1", "Qdc2", "qdc1", "qc0"], "qc2": ["qac92", "qc92", "ph2", "Qc92", "qe2", "qcc2", "pc2", "qdc2", "ph4", "qac2", "qe62", "pc62", "qdc4", "pc0", "qh0", "Qc2", "Qdc92", "qv2", "qc62", "qac4", "qv0", "qdc92", "qv4", "pc4", "qcc02", "qh62", "Qdc4", "qh2", "Qc4", "ph62", "Qdc02", "ph0", "qh4", "Qc02", "qcc92", "qac02", "qe4", "qdc02", "Qdc2", "qc02", "qcc4", "qe0", "qc0", "qv62"], "qc3": [" qe3", " qc7", "qe8", "qp21", " qc8", " qe7", " qc13", "qe7", "qc13", "qp4", "qc43", "qlc43", "qcenter13", "qp8", "qlc7", "qe3", " qe13", " qe8", "qcenter21", " qe43", " qc21", "qlc4", "qp3", "qc7", "qcenter8", "qc21", "qe21", " qc43", "qp43", "qp7", "qc8", "qlc3", "qp13", " qe4", "qe43", "qe4", "qe13", "qcenter3", " qe21"], "qc4": ["qcr4", "qxc6", "qf0", "qrc8", "dqrc0", "qh7", " qc7", "dqrc44", "qh6", "qrc44", "qrc0", "dqc44", "dqrc8", "qc44", "qxc5", "dqc8", "qh5", " qc6", "dqc4", "qcr5", "qxc7", " qxc7", "qf4", "qlc4", "dqrc4", "qlc0", "qc7", "qlc8", " qc5", "qc6", "qcr6", "qc5", "qlc44", "qc8", " qxc4", " qxc5", "qf8", "qh4", " qxc6", "qf44", "dqc0", "qxc4", "qrc4", "qc0", "qcr7"], "p_bits": [" p_bit", " p_vals", "p_bit", " p_ints", "p_ints", "p_vals"], "p_codes": ["v_code", "p_seq", "p_code", "p_flags", "v_flags", "v_seq"], "p_vec": ["c_verts", "pvverts", "c_buf", "c_norm", "pvbuf", "pvvec", "p_verts", "p_norm", "pvnorm", "c_vec", "p_buf"], "curidx": ["Curridz", "Curidex", "Curidz", "curIDz", "curidz", "curridx", "curridX", "curIDx", "Curidx", "curridex", "CuridX", "curIDX", "curIDex", "Curridx", "curidX", "curridz", "Curridex", "CurridX", "curidex"], "curidx2": ["curIdf2", "curIdx2", "curidv1", "curidx1", "curIdfii", "curidv2", "curidyii", "curIdx1", "curIdxii", "curidfii", "curidy2", "curidf1", "curIdf1", "curidy1", "curidvii", "curidf2", "curidxii"], "in_int": ["in_bit", " in_long", " in_bit", "in_long", " in_ind", "in_ind"], "v_bits": ["v__bits", "v__codes", "v__bytes", "v_bytes", "v_vals", "v__vals", "p_bytes", "p_vals"], "v_codes": [" v_cats", "v_code", " v_code", "v_cats", "v_seq", " v_seq"], "t0": ["v00", "ta0", "ta00", "v3", "ta3", "v0", "ta1", "t00", "v1", " t00"], "t1": ["T3", "T2", "v3", "v7", "T1", "v2", "v1", "T7"], "t2": ["T2", "t22", "v4", "T22", " t22", "v2", "T4", "v22"], "t3": ["T3", " tthree", "it03", "it3", "itthree", "T03", "t03", " t03", "Tthree", "tthree"], "t4": ["T3", "T2", "T8", " t8", "v3", "v4", "v8", "v2", "T4", "t8"], "t5": ["T2", "v4", "v7", "T5", "v5", "v2", "T4", "T7"], "t6": ["T6", "t06", "T8", "ta7", "ta8", " t8", "ta6", " t06", "ta06", "t8", "T06", "T7"], "t7": ["ta07", "at07", " t77", "at729", "t77", "at7", "ta7", " t729", "at77", "ta77", "t729", "ta729", "t07", " t07"], "vec1": ["cv3", " vec3", "ven1", "ven2", "cv2", "vec3", "cv1", "ven3"], "vec2": ["vec4", " vec4", "vector4", "cv2", "cv4", "vector2", "vector1", "cv1"]}}
{"project": "FFmpeg", "commit_id": "eef9f06508354d1c7d5624c1c18997e7974288f1", "target": 0, "func": "static int stream_component_open(PlayerState *is, int stream_index)\n\n{\n\n    AVFormatContext *ic = is->ic;\n\n    AVCodecContext *avctx;\n\n    AVCodec *codec;\n\n    SDL_AudioSpec wanted_spec, spec;\n\n    AVDictionary *opts;\n\n    AVDictionaryEntry *t = NULL;\n\n    int ret = 0;\n\n\n\n    if (stream_index < 0 || stream_index >= ic->nb_streams)\n\n        return -1;\n\n    avctx = ic->streams[stream_index]->codec;\n\n\n\n    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);\n\n\n\n    codec = avcodec_find_decoder(avctx->codec_id);\n\n    avctx->workaround_bugs   = workaround_bugs;\n\n    avctx->idct_algo         = idct;\n\n    avctx->skip_frame        = skip_frame;\n\n    avctx->skip_idct         = skip_idct;\n\n    avctx->skip_loop_filter  = skip_loop_filter;\n\n    avctx->error_concealment = error_concealment;\n\n\n\n    if (fast)\n\n        avctx->flags2 |= AV_CODEC_FLAG2_FAST;\n\n\n\n    if (!av_dict_get(opts, \"threads\", NULL, 0))\n\n        av_dict_set(&opts, \"threads\", \"auto\", 0);\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        av_dict_set(&opts, \"refcounted_frames\", \"1\", 0);\n\n    if (!codec ||\n\n        (ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret =  AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n\n\n    /* prepare audio output */\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        is->sdl_sample_rate = avctx->sample_rate;\n\n\n\n        if (!avctx->channel_layout)\n\n            avctx->channel_layout = av_get_default_channel_layout(avctx->channels);\n\n        if (!avctx->channel_layout) {\n\n            fprintf(stderr, \"unable to guess channel layout\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n        if (avctx->channels == 1)\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_MONO;\n\n        else\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_STEREO;\n\n        is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);\n\n\n\n        wanted_spec.format = AUDIO_S16SYS;\n\n        wanted_spec.freq = is->sdl_sample_rate;\n\n        wanted_spec.channels = is->sdl_channels;\n\n        wanted_spec.silence = 0;\n\n        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;\n\n        wanted_spec.callback = sdl_audio_callback;\n\n        wanted_spec.userdata = is;\n\n        if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n\n            fprintf(stderr, \"SDL_OpenAudio: %s\\n\", SDL_GetError());\n\n            ret = AVERROR_UNKNOWN;\n\n            goto fail;\n\n        }\n\n        is->audio_hw_buf_size = spec.size;\n\n        is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;\n\n        is->resample_sample_fmt     = is->sdl_sample_fmt;\n\n        is->resample_channel_layout = avctx->channel_layout;\n\n        is->resample_sample_rate    = avctx->sample_rate;\n\n    }\n\n\n\n    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n\n    switch (avctx->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        is->audio_stream = stream_index;\n\n        is->audio_st = ic->streams[stream_index];\n\n        is->audio_buf_size  = 0;\n\n        is->audio_buf_index = 0;\n\n\n\n        /* init averaging filter */\n\n        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n\n        is->audio_diff_avg_count = 0;\n\n        /* since we do not have a precise anough audio fifo fullness,\n\n           we correct audio sync only if larger than this threshold */\n\n        is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;\n\n\n\n        memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));\n\n        packet_queue_init(&is->audioq);\n\n        SDL_PauseAudio(0);\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        is->video_stream = stream_index;\n\n        is->video_st = ic->streams[stream_index];\n\n\n\n        packet_queue_init(&is->videoq);\n\n        is->video_tid = SDL_CreateThread(video_thread, is);\n\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n        is->subtitle_stream = stream_index;\n\n        is->subtitle_st = ic->streams[stream_index];\n\n        packet_queue_init(&is->subtitleq);\n\n\n\n        is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    av_dict_free(&opts);\n\n\n\n    return ret;\n\n}\n", "idx": 6801, "substitutes": {"is": ["as", "isi", "oc", "act", "st", "ib", "serv", "id", "lis", "ik", "s", "si", "i", "IS", "or", "sys", "info", "in", "its", "ia", "ace", "isl", "ir", "pi", "sil", "isu", "ls", "isa", "iss", "bs", "it", "cs", "ics", "aic", "sc", "ist", "bis", "cms", "ais", "iv", "os", "ip", "can", "api", "il", "iso", "ish", "fi", "src", "isc"], "stream_index": ["streamingpath", " streamxnum", "streamChandle", "steamCname", "steam_index", "streamxindex", "hostOpath", "streamerindex", "hostOkey", "streamnamenum", "streamCposition", "steam_handle", "streamingref", "streamsposition", "streamnameindex", "streamername", "host_key", "streamsindex", " stream_level", "stream_num", "streamedlevel", " stream_ind", "streamIdindex", "streamCindex", "stream_id", "sound_id", "steam_name", " streamxindex", "streamxlevel", "streamerid", "streamerposition", "streamsvalue", "streamPhandle", "sound_index", "streamxind", " streamxlevel", "streamIdkey", "stream_ind", "stream_path", "steam_position", " stream_num", "steamCindex", "streamCname", "host_index", "host_path", "hostOref", "stream_key", "steamCposition", "streamedind", "streamPposition", "streamerhandle", "streamsid", "sound_value", "streamingindex", "streamPname", "streamOindex", "stream_handle", "streamIdref", " streamxind", "streamingkey", "streamnameref", "stream_value", "streamOpath", "steamChandle", "streamedindex", "host_ref", "stream_ref", "stream_position", "streamIdpath", "stream_level", "streamOkey", "hostOindex", "sound_position", " stream_ref", "streamPindex", "streamxnum", "streamednum", "streamervalue", "stream_name", "streamOref"], "ic": ["abc", "icc", "oc", "gc", "irc", "anc", "ti", "mic", "ik", "icer", "ci", "config", "cus", "rc", "i", "enc", "uc", "ia", "bi", "ix", "inc", "VC", "cl", "pi", "cci", "ican", "aci", "icing", "pc", "ai", "sci", "cs", "cli", "cc", "ics", "aic", "IC", "nic", "ck", "acl", "lic", "iac", "ici", "ctx", "bc", "cu", "exec", "voc", "ec", "pic", "c", "cit", "ct", "lc", "fc", "ac", "vc", "fi", "isc", "xc", "tc"], "avctx": ["akcontext", " avcf", "akcc", "avehw", "navcn", "afcas", "avecas", " avcca", " avcas", "evcontext", "abcmp", "navcontext", "mpctx", "aveconfig", "afctx", "AVwcs", "aveca", " avwcs", "navctx", "AVca", "ovcu", "abcf", " avcontext", "avca", "evcmp", " avca", "airctx", "airtx", "mpcf", "avcmd", "evcf", "avhw", "avcmp", "akctx", "afcn", "abcontext", "AVcmp", "avewcs", "ovcontext", "aveconn", "Avctx", "avecontext", "afcf", " avcc", "avlc", "AVcu", " avcu", "AVconn", "mpcmp", "avecu", "avelc", "Avcu", "afhw", "abconn", "akctl", "navconfig", "aflc", "avcas", "afctl", "avecn", "avcu", " avhw", "avconfig", "AVcontext", "afcmd", "avcca", "navconn", "navcf", "avcontext", "airconn", "AVcca", "avecmd", "ovcmp", "mpcontext", "avconn", "evctx", "abctx", "avcn", "AVcf", "avctl", "akconfig", "Avcf", "avectx", "afcc", "ovctx", "avetx", "AVctx", "avcf", " avcmd", "aftx", "akcn", "avecf", "avtx", "Avcontext", "avwcs", " avctl", "aircontext", "akcu", "afconn", "afcontext", "afconfig", " avlc", " avconn", "avcc", "afcca", "avecmp", "afcu", "abcu", "abconfig"], "codec": ["predec", "coderoc", "codroc", "cedbc", "codef", "codebc", "casterc", "catec", "codac", "cbesc", "oduc", "cedec", "odroc", "predcf", "odbc", "coduc", "codeca", "defesc", "defec", "cbec", " codrec", "odEC", " codesc", "ctesc", "preduc", "cedroc", "predeca", " codac", "codrec", "ctec", " coderc", " codeca", "typoc", "castec", "odeca", " codef", " coduc", "typect", "catect", "cedEC", "coderc", "cbrec", "codoc", "codect", "castrec", "defac", "catoc", " codect", "codbc", "castesc", "codeEC", "odcf", "typec", "defef", "caterc", "ctef", "codEC", " codoc", "ctac", "codesc", "cberc", "typerc", "codcf", "odec", "codeec", " codcf"], "spec": ["cmp", "vec", "acc", "security", "config", "si", "sync", "comp", "stream", "sk", " specs", "spe", "sci", "Spec", "conf", "sc", "pec", "feat", "source", "seq", "parse", "settings", "sel", "ssl", "custom", "params", "rs", " Spec"], "opts": ["OPcs", "Opments", "copt", "copter", "opttes", "optcs", "optte", "OPt", "protd", "optps", "optuts", "opter", "ottes", "OPts", "OPtes", "optgs", "operts", "opertd", "opters", "optt", " opte", "hoptes", "otcs", "opcs", "ops", "copts", "opers", "coptes", "otts", " opgs", "optes", "opttd", "pros", "opergs", "prots", "coputs", "optTS", "operters", "opert", "opments", " optips", "opps", "ipcs", "opertes", " opments", "hopt", "oputs", "otter", "opTS", "props", "Opters", " optes", "hoputs", "ipTS", "ipt", "copte", "optd", "opertips", "OPter", "optips", "Opts", "optts", "copcs", "ipts", "operments", "opte", "opgs", "opt", "Optips", " opcs", "operps", " opt", "hopts", "OPTS", " opters"], "t": ["ot", "tool", "o", "tf", "ret", "te", "v", "not", "rt", "total", "nt", "unt", "tmp", "bt", "qt", "i", "token", "et", "template", "wt", "pt", "m", "f", "post", "at", "d", "j", "e", "mt", "w", "target", "bot", "tm", "n", "ant", "ts", "p", "h", "ut", "tip", "c", "ta", "g", "txt", "type", "dt", "tp", "tt", "T", "test", "r", "trace"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void keyword_literal(void)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QObject *null;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", false));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n    QDECREF(qbool);\n\n\n\n    /* Test that non-zero values other than 1 get collapsed to true */\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", 2));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"null\", NULL);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QNULL);\n\n\n\n    null = qnull();\n\n    g_assert(null == obj);\n\n\n\n    qobject_decref(obj);\n\n    qobject_decref(null);\n\n}\n", "idx": 6816, "substitutes": {"obj": ["dr", "el", "eff", "rb", "b", "object", "elt", "x", "oa", "ex", "rel", "__", "active", "original", "bs", "code", "arr", "empty", "err", "current", "img", "ass", "ocr", "st", "parent", "nt", "value", "val", "art", "pt", "ject", "so", "ol", "lib", "Object", "ctx", "ie", "old", "amp", "ut", "fail", "oo", "txt", "bj", "ok", "act", "er", "block", "alt", "tmp", "po", "ob", "op", "now", "sync", "sn", "ext", "j", "out", "inst", "t", "instance", "p", "pos", "os", "ind", "orig", "api", "bo", "adj", "ref", "r", "ot", "o", "pr", "Obj", "args", "full", "fn", "n", "other", "coll", "result", "opt", "iv", "oid", "br", "inner", "bl", "js"], "qbool": ["qnote", "calnot", "queryfloat", "playbo", "querybool", "queryacl", "eqnumber", "qualval", "qval", "quallabel", "qaswitch", "qunumber", "qualbb", "hbean", "queryobject", " qctor", "qbit", "queststring", "calbo", "eqnote", "qchild", "querynot", "qacl", "hbool", "quforce", "qulib", "calbool", "qualfloat", "questlib", "hunit", " qforce", " qobject", "sqbool", "corebool", "qualnote", "qfloat", "qualbel", "qufail", "qbits", "qbl", "quchild", " qrole", "qubytes", "eqval", "quval", "qfail", "qualchild", "qolean", "querybyte", "eqoptional", "sqnumber", " qbel", "qushort", "quolean", "eqbb", "qabo", "qelement", " qbb", "questoptional", "qunote", "eqbyte", "qloop", "eqnot", "queryshort", "qubl", "qulabel", "querystring", "qnumber", "queryolean", "corebo", "queryval", "qubits", "queger", "ggunit", "qunot", "playbit", "qswitch", "callabel", "qforce", "qanumber", "qabyte", "qlabel", "kobject", "qbytes", " qnumber", "qbean", "qlib", "holean", "ayolean", "qanote", "kshort", "qrole", "eqlabel", "querylabel", "eqfail", "playeger", "qabl", "qaval", "qabits", "qualfail", "quloop", " qlib", "kbool", " qelement", "requforce", "playnot", "qshort", "qualbl", "qunit", "aybool", " qbytes", "qbo", "qualbool", "qualnot", "qustring", "questctor", "quoptional", "eqbo", "qubit", "qaeger", "qbyte", "queryloop", "qubo", "requbytes", "playbool", "requbel", "corenot", "qarole", "querybo", "qufloat", "qubyte", "sqoptional", "eqloop", "qabit", "quswitch", "qubool", "qabool", "qubel", "requbool", "questnot", " qnot", "qualrole", "qualbits", "qbb", "ayunit", "ggbean", "questacl", "sqlabel", "qubb", "qobject", "qualswitch", "queryoptional", "ggbool", "querychild", "playbyte", "eqbool", "querybb", "qualnumber", "corelabel", "qbel", "quobject", "qanot", "questobject", "queryelement", "qctor", "questbb", "aybean", "ggolean", "playlabel", "questbool", "qalabel", "quctor", "qeger", "qstring", "qoptional", "kolean", "qabel", "qnot", "quacl", "questelement"], "null": ["o", "person", "block", "id", "alt", "parent", "Null", "value", "list", "ob", "object", "lt", "b", "val", "negative", "status", "valid", "resource", "call", "bs", "comment", "n", "other", "empty", "nil", "err", "result", "seq", "array", "collection", "zero", "fail", "none", "node", "new", "type", "bool", "il", "oid", "lc", "model", "bo", "bl", "ref", "ok"], "str": ["dr", "name", "fr", "er", "st", "serv", "sr", "cr", "act", "pr", "iter", "id", "spec", "s", "tr", "style", "elt", "sn", "enc", "pt", "cl", "ns", "url", "j", "sl", "res", "ctr", "ss", "code", "sc", "out", "arr", "n", "err", "coll", "seq", "Str", "sp", "pos", "doc", "c", "txt", "STR", "br", "bl", "text", "inner", "rs", "r", "stri", "dict"]}}
{"project": "qemu", "commit_id": "093209cd681fe9fb65bd8a1c2ff711b8168bbfcd", "target": 0, "func": "static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;\n\n    int ide_mem_index[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.vbios\", VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000, 1);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        /* 970 gets a U3 bus */\n\n        pci_bus = pci_pmac_u3_init(pic);\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic);\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n\n\n    /* We only emulate 2 out of 3 IDE controllers for now */\n\n    ide_mem_index[0] = -1;\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    /* cuda also initialize ADB */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    /* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 6829, "substitutes": {"ram_size": ["mem_offset", "mem_source", "gram_type", "ramlsize", " ram_speed", "ramloffset", " ram_width", "ram_source", "ram_length", "ram_bytes", "ram_center", "mem_size", "gram_offset", "ramlcenter", "gram_length", "mem_center", " ram_bytes", "ram_speed", "ramlsource", "gram_size", "ram_type", "ram_width"], "boot_device": ["bootalmode", "boot_server", "bootaldevice", "boot_dev", "boot_mode", "kernel_server", "kernel_mode", "kernel_dev", "bootaldev", "kernel_device", "bootalserver"], "kernel_filename": ["cpu_memory", "kernel__memory", "kernel_file", "kernelfusername", " kernel_location", "kernel__name", "kernel__filename", " kernel_name", "kernel__username", "cpu_name", "kernel_location", "kernel_name", "kernelfmemory", "kernel_username", "cpu_username", " kernel_file", "cpu_filename", "kernel_memory", "kernelfname", "kernelffilename"], "kernel_cmdline": ["kernel_commandle", "kernel_commle", "kernel_commlink", "kernel_cmdle", "kernel_bootle", "kernel_commandlink", "kernel_bootline", "kernel_bootlink", "kernel_commandline", "kernel_cmdlink", "kernel_commline"], "initrd_filename": ["initrd_memory", "initrt_file", "initrdmfile", "initrt_filename", "initrt_memory", "initrd_file", "initrt_size", "initrdmsize", "initrdmfilename", "initrdmmemory"], "cpu_model": ["cpu_field", "cpu_models", "cpu64mode", "cpu_rule", "cpu_slave", " cpu_models", "gpu_field", "cpu_device", "gpu_rule", "gpu_model", "cpu__mode", "CPU_model", "cpujmode", "processor_model", "cpu_Model", "gpu_Model", " cpu_mode", "CPU_format", "cpu__model", "CPU_mode", "cpu_module", "cpu64model", " cpu_type", "cpu_format", "cpu_type", "cpu64format", "cpu_function", "cpu_name", "cpu__device", "cpu_mode", "processor_name", "CPU_device", " cpu_slave", "processor_function", "processor_mode", "cpujfunction", "cpu__format", " cpu_module", "cpu64device", "cpujmodel", "cpujname"], "env": ["enable", "ah", "fg", "act", "ea", "v", "el", "dat", "scope", "session", "config", "vel", "environment", "inv", "exc", "style", "et", "enc", "nc", "in", "loc", "eu", "inet", "db", "export", "gui", "state", "obj", "args", "assets", "py", "cli", "net", "conf", "ev", "dir", "impl", "code", "np", "init", "e", "vs", "en", "here", "dev", "ctx", "bc", "err", "exec", "ini", "Environment", "lock", "equ", "context", "end", "ne", "eval", "stage", "ec", "h", "output", "eni", "iv", "viron", "pect", "global", "opt", "engine", "cache", "img", "conn", "ass", "dict"], "envs": ["Enfs", " environments", "ENvs", "Env", " enums", "ENfs", "ENv", " enfs", "ENums", "ENns", "Enns", "ENvironments", "environments", "Environments", " enns", "Enums", "enums", "enfs", "enns", "Envs"], "MAX_CPUS": ["MAX_MPUS", "MAX_CFUS", "MAX_MPU", "MAX_CPUs", "MAXNcpU", "MAXNCPU", "MAXNCPUS", "MAX_CPUI", "MAX_CPU", "MAX_CFUs", "MAX_cpUS", "MAXNcpUS", "MAX_CFU", "MAX_cpUI", "MAXNcpUI", "MAX_CFUI", "MAX_cpUs", "MAXNCPUs", "MAX_cpU", "MAX_MPUs", "MAXNCPUI", "MAX_MPUI", "MAXNcpUs"], "filename": ["name", "files", "username", "Filename", "b", "tty", "File", "f", "fil", "uri", "file", "binary", "fn", "path", "fp", "dll", "nil", "processor", "output", "wav", "memory", "kl", "fd", "directory", "prefix"], "pic": ["pot", "ig", "bin", "mic", "pin", "quad", "config", "xi", "sync", "image", "pins", "mac", "drive", "bus", "pi", "pc", "cli", "nic", "disk", "lib", "ic", "cpu", "fs", "proc", "lc", "fc", "vc", "fi", "cache"], "openpic_irqs": ["openpic_irsqs", "openpic_irqq", "openpic_irks", "openpic_rinks", "openpic_rinqs", "openpic_irsks", "openpic_rinq", "openpic_mirq", "openpic_irq", "openpic_mirqs", "openpic_irsqq", "openpic_mirks", "openpic_mirqq", "openpic_rinqq", "openpic_irsq"], "unin_memory": ["cpu_memory", "cpu00master", "cpualbase", "vidia_usage", "vidia_base", "vidia_master", "cpu00usage", "cpualmemory", "cpu_base", "cpualusage", "cpualmaster", "cpu_master", "cpu00memory", "cpu_usage", "vidia_memory", "cpu00base"], "linux_boot": ["linux68setup", "linux_host", "physical_Boot", "linux68boot", " linux_host", "linux_base", "linux68host", " linux_Boot", "physical_base", "linux68Boot", "physical_boot", "linux_Boot", "linux_run", "linux_setup", " linux_setup", "physical_run"], "i": ["gi", "ei", "ti", "v", "I", "chi", "di", "ci", "ni", "xi", "ri", "si", "io", "slice", "info", "m", "image", "in", "qi", "ix", "l", "gu", "f", "yi", "pi", "phi", "adi", "j", "ii", "iu", "linux", "ij", "ai", "cli", "uli", "d", "u", "udi", "ami", "uri", "k", "n", "multi", "mi", "ski", "ini", "ie", "p", "h", "mini", "eni", "hi", "c", "ip", "li", "anti", "fi", "index", "ui"], "ram_offset": ["ram67index", "ram67size", "ram67offset", "ram_base", "ream_size", "ream_base", "ram_format", "ramFoffset", "ramFposition", "ram_reset", "gram_index", "ramFsize", "gram_offset", "ramlexshift", "ramlexreset", "ream_format", "ramlexsize", "ram_position", "ream_offset", "gram_reset", "ram_index", "gram_size", "ram67position", "ramlexoffset", "ram_shift", "gram_position", "ramFindex", "gram_shift"], "bios_offset": ["bio_len", "bio_base", "bio_error", "bios_len", "bio_size", "bios_error", "bios_base", "bio_offset"], "vga_bios_offset": ["vga_bios_position", "vga_bio_position", "vga_bio_index", "vga_bio_offset", "vga_bio_size", "vga_bios_index"], "kernel_base": ["kernel_file", "kernel__base", "kernel__size", "kernel_range", " kernel_range", "kernel__file", "kernel__range", " kernel_file"], "kernel_size": ["kernel_speed", " kernel_speed", " kernel_name", "kernel_name"], "initrd_base": ["initrt_core", "initrd_core", "initrd_offset", "initrt_size", "initrt_base", "initrt_offset"], "initrd_size": ["initrt_scale", "initrd_loc", "initrd_name", "initrt_size", "initrd_scale", "initrt_loc", "initrt_name"], "pci_bus": ["pci_usb", "pci_boot", "pki_BUS", "pki_usb", "pki_bus", "pki_boot", "pci_BUS"], "nvr": ["NVR", "nmr", "nVR", "rnvm", "rnvr", "rnVR", "nvm", "Nmr", "Nvr", "rnmr", " nvm", " nVR", " nmr", "Nvm"], "nvram_mem_index": ["nvram_memxlength", "nvram_ram_size", "nvram_mem_size", "nvram_memxindex", "nvram_memxsize", "nvram_ram_loc", "nvram_memxloc", "nvram_mem_loc", "nvram_ram_index", "nvram_ram_length", "nvram_mem_length"], "vga_bios_size": ["vga_bios_loc", "vga_bio_loc", "vga_bios_count", "vga_bio_size", "vga_bio_count"], "bios_size": ["bios_index", "biol_capacity", "biol_index", "bios6size", "biol6capacity", "biol6size", "bios_capacity", "bios6offset", "bios6capacity", "biol_size", "biol6offset", "bios6index", "biol6index", "biol_offset"], "pic_mem_index": ["pic_mem_size", "pic_mem_set", "pic_thread_num", "pic_mempset", "pic_thread_index", "pic_mem_num", "pic_thread_set", "pic_mempindex", "pic_thread_size", "pic_mempsize", "pic_mempnum"], "dbdma_mem_index": ["dbdma_thread_index", "dbdma_thread_size", "dbdma_mem_id", "dbdma_thread_id", "dbdma_mem_size"], "cuda_mem_index": ["cuda_memxnum", "cuda_memxindex", "cuda_mem_ind", "cuda_lif_num", "cuda_lif_align", "cuda_mem_num", "cuda_memxind", "cuda_lif_ind", "cuda_lif_index", "cuda_mem_align", "cuda_memxalign"], "escc_mem_index": ["escc_memory_count", "escc_mem_count", "escc_memory_index", "escc_memgindex", "escc_memgcount", "escc_memory_ind", "escc_memgind", "escc_mem_ind"], "ide_mem_index": ["ide_memxslice", "ide_disk_slice", "ide_disk_index", "ide_diskxmin", "ide_memxindex", "ide_mem_min", "ide_diskxslice", "ide_mem_slice", "ide_memxmin", "ide_diskxindex", "ide_disk_min"], "ppc_boot_device": ["ppc_bus2unit", "ppc_boot_model", "ppc_boot_unit", "ppc_boot2device", "ppc_bus2device", "ppc_boot2model", "ppc_bus_dev", "ppc_boot_dev", "ppc_bus_model", "ppc_bus_device", "ppc_boot2unit", "ppc_bus2model", "ppc_boot2dev", "ppc_bus_unit", "ppc_bus2dev"], "hd": ["hp", "dri", "dr", "gc", "hw", "md", "vd", "di", "dd", "HD", "pd", "hid", "rh", "hs", "wd", "udi", "hm", "da", "xd", "eni", "ht", "ld", "du", "gd", "lv", "dt", "ha", "nd", "cd"], "MAX_IDE_BUS": ["MAX_DIPOUS", "MAX_IDEADUS", "MAX_DI_PATH", "MAX_IDE_USE", "MAX_IDEPOUSE", "MAX_IDEADPATH", "MAX_IDEADBUS", "MAX_DIPOPATH", "MAX_IDE_US", "MAX_DI_US", "MAX_IDEPOPATH", "MAX_IDEPOBUS", "MAX_DI_BUS", "MAX_DIPOUSE", "MAX_DI_USE", "MAX_DIPOBUS", "MAX_IDEPOUS", "MAX_IDEADUSE", "MAX_IDE_PATH"], "MAX_IDE_DEVS": ["MAX_IDE_DEFS", "MAX_IDE_TEFS", "MAX_IDE_DEV", "MAX_IDE_TEVS", "MAX_IDE_DIVICE", "MAX_IDE_DIV", "MAX_IDE_TEVICE", "MAX_IDE_TEV", "MAX_IDE_DVICE", "MAX_IDE_DIVS", "MAX_IDE_DFS", "MAX_IDE_DEVICE", "MAX_IDE_DV", "MAX_IDE_DIFS", "MAX_IDE_DVS"], "fw_cfg": ["fw_cow", "fw__cow", "fw_cf", "fw__config", "hw_cf", "fw_config", "hw_cow", "hw_cfg", "hw_config", "fw__cf", "fw__cfg"], "dbdma": ["dbnna", "dbhna", " dbnmm", "dbnpa", " dbdmm", "dbnmm", " dbnna", "dbdsna", "dbdmm", " dbdna", "dbhmm", "dbdsmm", "dbdpa", " dbnma", "dbdspa", "dbhpa", "dbnma", "dbhma", " dbdpa", " dbnpa", "dbdsma", "dbdna"], "vga_bios_ptr": ["vga_bios_pointer", "vga_bias_offset", "vga_bias_addr", "vga_bias_pointer", "vga_bias_ptr", "vga_bios_addr"], "machine_arch": ["machine__version", "usb_platform", "machine__platform", "machine_brand", "usb_brand", "machine_platform", "machine__brand", "usb_arch", "machine_version", "machine__arch", "usb_version"]}}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "func": "void DMA_run(void)\n\n{\n\n    /* XXXXX */\n\n}\n", "idx": 6838, "substitutes": {}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n", "idx": 6844, "substitutes": {"a": ["abc", "as", "area", "ea", "na", "alpha", "la", "pa", "va", "value", "aa", "b", "x", "data", "i", "ae", "m", "ia", "l", "ma", "ga", "f", "u", "an", "e", "da", "A", "ab", "ba", "p", "input", "ca", "h", "sup", "sa", "c", "ac", "aux", "r"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 6852, "substitutes": {"a": ["as", "area", "ea", "na", "alpha", "xa", "la", "s", "pa", "va", "asa", "aa", "i", "wa", "ae", "ia", "ma", "f", "ra", "ai", "e", "an", "ar", "da", "n", "A", "ba", "aaa", "ama", "p", "ca", "sta", "ana", "sa", "c", "ac", "au", "af"], "b": ["base", "lb", "buff", "v", "s", "rb", "ob", "i", "or", "ad", "bi", "l", "wb", "db", "f", "d", "bb", "bs", "xb", "e", "sb", "k", "n", "ab", "cb", "B", "ba", "p", "z", "bf", "y", "pb", "r", "end"], "fa": ["base", "fat", "afi", "ao", "ea", "ifi", "fw", "xa", "pa", "va", "asa", "aa", "osa", "oa", "cca", "wa", "ae", "ia", "ma", "f", "ga", "ra", "fe", " ta", "hea", "FA", "da", "ifa", "A", "ba", "aaa", "ca", "fal", "sa", "ta", "ppa", "bf", "Fa", "cf", " ba", "afa", "tta", "fc", "au", "fi", "af"], "fb": ["abc", "fen", "FH", "uff", "fg", "fam", "afi", "buff", "ib", "lb", "fw", "BF", "rb", "bg", "raf", "rf", "fx", "BB", "wb", "db", "f", "alf", "fe", "xb", "bb", "bs", "eb", "facebook", "sb", "xf", "ab", "cb", "FF", "fab", "fs", "bf", "fd", "Fa", "deb", "cf", "fc", "FB", "fi", "pb", "ff", "af"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n", "idx": 6867, "substitutes": {"s": ["as", "o", "sets", "v", "is", "S", "a", "spec", "b", "si", "i", "or", "sys", "ses", "services", "m", "its", "ions", "details", "states", "f", "state", "d", "sl", "args", "ls", "stats", "ss", "cs", "u", "e", "an", "sb", "gs", "ops", "w", "ds", "t", "qs", "n", "ts", "p", "south", "settings", "fs", "request", "c", "os", "g", "sym", "sq", "ssl", "es", "rs", "r", "ps", "js"], "options": ["groups", "points", "option", "o", "rules", "http", "features", "plugins", "config", "pre", "als", "op", "object", "io", "i", "or", "style", "data", "info", "its", "ips", "details", "ions", "vals", "results", "ns", "stats", "obj", "args", "opens", "cs", "e", "ops", "steps", "full", "ts", "eps", "Options", "p", "temp", "settings", "css", "ors", "changes", "os", "errors", "params", "es", "times", "rs", "ps", "flags", "js"]}}
{"project": "FFmpeg", "commit_id": "7a206eb32f624171a35235f714d44ee9dec9abcb", "target": 0, "func": "static int alac_set_info(ALACContext *alac)\n\n{\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, alac->avctx->extradata,\n\n                     alac->avctx->extradata_size);\n\n\n\n    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4\n\n\n\n    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);\n\n    if (alac->max_samples_per_frame >= UINT_MAX/4){\n\n        av_log(alac->avctx, AV_LOG_ERROR,\n\n               \"max_samples_per_frame too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    bytestream2_skipu(&gb, 1);  // compatible version\n\n    alac->sample_size          = bytestream2_get_byteu(&gb);\n\n    alac->rice_history_mult    = bytestream2_get_byteu(&gb);\n\n    alac->rice_initial_history = bytestream2_get_byteu(&gb);\n\n    alac->rice_limit           = bytestream2_get_byteu(&gb);\n\n    alac->channels             = bytestream2_get_byteu(&gb);\n\n    bytestream2_get_be16u(&gb); // maxRun\n\n    bytestream2_get_be32u(&gb); // max coded frame size\n\n    bytestream2_get_be32u(&gb); // average bitrate\n\n    bytestream2_get_be32u(&gb); // samplerate\n\n\n\n    return 0;\n\n}\n", "idx": 6879, "substitutes": {"alac": ["aliac", "plmac", "aloc", "alfac", "alsac", "alacc", " alanc", "alphanc", "paliac", "ALacs", "palac", "plAC", " alacl", "elacc", "plac", " alfac", "eliac", " alas", "elanc", "alAC", "AlAC", "ALac", " alack", "elAC", "alphas", "allacs", "Alac", "allang", "alas", "malAC", "palacs", "malec", "elacs", "alsacs", "placs", " alAC", "alack", "calanc", "calec", "alsmac", "altac", "alphec", "alacl", "ALAC", "alifac", "malac", "elac", "aliacs", "alec", " alec", "alang", "calacc", "aliAC", "palacc", "alacs", "malang", "malack", " alacs", "alphac", "malacs", "almac", "malanc", "altAC", "altacl", "allacc", "alsAC", "malas", " aliac", " aloc", " almac", "altack", "allac", "ALoc", "malacc", " alang", " alacc", "Alacc", "Alacs", "Aloc", "alsfac", "calac", "malacl", "alanc"], "gb": ["gi", " db", "gp", "gc", "cgi", "cfg", " rgb", "phy", "gm", " region", "hub", " eg", "sg", "gru", "rb", " pg", "Gb", "bg", "vt", "bm", "gpu", "gae", "kg", "db", "gu", "gio", "ga", " storage", "gow", " rc", "greg", "gin", "pc", "gz", "bb", "byte", "eb", " addr", "eg", "sb", "gs", "gam", "rg", "lib", " rg", "bc", "GB", "cb", "nb", "mb", "gal", " cc", " gcc", "gl", "gy", "kb", "gh", "g", "tg", "gd", "bf", " gy", "gram", "fc", "gg", " ig", " cod", " GB", "gn", "yg", "gom"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891, "substitutes": {"s": ["sf", "S", "a", "b", "i", "status", "private", "f", "d", "service", "hs", "conf", "w", "self", "h", "aws", "g", "sym", "y", "sets", "is", "spec", "services", "its", "states", "server", "ls", "ops", "ds", "ts", "settings", "fs", "sq", "site", "rs", "ins", "sg", "sync", "ses", "cs", "u", "submit", "e", "sb", "ks", "secondary", "t", "qs", "p", "c", "os", "ssl", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "xs", "side", "ns", "stats", "args", "us", "ss", "gs", "n", "su", "params", "es", "js"], "request": ["condition", "er", "Request", "method", "complete", "http", "requ", "session", "config", "consumer", "object", "data", "password", "wa", "info", "reply", "xml", "status", "enter", "resource", "argument", "event", "client", "child", "order", "call", "server", "create", "QUEST", "q", "subject", "initial", "e", "submit", "error", "message", "instance", "join", "application", "work", "result", "p", "input", "parse", "question", "output", "req", "quest", "re", "transfer", "type", "report", "sq", "query", "user", "test", "command", "worker", "hello"], "response": ["four", "position", "successful", "environment", "object", "data", "database", "status", "sequence", "document", "service", "initial", "error", "connection", "json", "array", "output", "resp", "page", "current", "index", "onse", "view", "function", "value", "ception", "update", "Response", "server", "subject", "description", "received", "application", "respond", "remote", "operation", "model", "product", "site", "account", "python", "block", "change", "image", "profile", "version", "e", "message", "p", "collection", "location", "api", "r", "hello", "o", "v", "complete", "wave", "session", "get", "reply", "body", "resource", "event", "client", "args", "res", "answer", "respons", "example", "when", "other", "result", "report", "success"], "rlen": ["hrlen", "rrlen", "frlength", "llength", "rden", " rren", "rbl", "Rlength", "bLen", "rrlon", "blon", "hrren", "blen", "rlon", "srden", " rden", " rlon", "Ren", "rlength", "frden", "cren", "hrbl", "llen", " rlength", " rLen", "len", "RLen", "ren", "Rlen", "srlength", "frlen", "rLen", "frLen", "rrlength", "crlength", "rren", "crlen", "crLen", "blength", "lLen", "hrLen", "srren", "srbl", "srLen", "rrLen", " rbl", "srlen"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n", "idx": 6919, "substitutes": {"ud1test": ["ud1server", "ud19set", "ud91test", "ud6test", "udonetest", "udoneresult", "aud6match", "ub11train", "ub1cross", "ud11match", "ud11cross", "ud4test", "ud19train", "uidoneconst", "uc11test", "udd1est", "ub1const", "ut1testing", "ud1est", "ud86cross", "ud21server", "ud1cross", "aud1match", "ud11set", "uc11set", "ut1config", "udd21class", "udonedesc", "ud21test", "ud19store", "ud86test", "aud1result", "ub1test", "ud11store", "aud1testing", "ud3case", "udd1server", "uc11store", "ud1class", "ud81const", "uidonecase", "ud11train", "udonetrain", "ud01test", "ud1testing", "udd21test", "udoneset", "ud6match", "ud01train", "ud1config", "ud21class", "ud4server", "aud6testing", "ud1case", "ud1result", "udonecase", "ud4class", "ud86train", "utonetest", "ud91testing", "ud01const", "udd1test", "ud4est", "udoneconfig", "ub1train", "ud6testing", "uid1testing", "ud6result", "ud10class", "utonetesting", "udonematch", "ud86const", "udd1class", "ud3test", "aud6result", "uid1case", "ud11result", "ub11cross", "ud10test", "ud81testing", "ud91desc", "ud1train", "udonestore", "ut1test", "aud1test", "ud3const", "uid1test", "udd21server", "ud91config", "ud21est", "ud81case", "uc1test", "ub11const", "ud1set", "ud81test", "uidonetesting", "uc1train", "ud11const", "ud3testing", "ud19test", "uc1set", "ud10est", "ud11testing", "uc11train", "udd21est", "ut1desc", "utonedesc", "aud6test", "uidonetest", "ud1match", "ud11config", "ub11test", "ud1store", "uc1store", "ud11test", "udonetesting", "ud1const", "ud1desc", "ud01cross", "udoneconst", "uid1const", "ud10server", "utoneconfig", "ud11desc"], "ud1a": ["ud1aa", "udd1sa", "aud1ab", "ut1an", "bb0a", "udonesa", "uddoneas", "ud17sa", "ud2a", "ud01b", "ub81am", "aud10ab", "ud5a", "bb0b", "ub1ca", "ud81b", "ud17a", "bb0an", "bb1b", "ud10sa", "ud1ada", "utoneb", "ud1alpha", "ud0ab", "aud1c", "udd1as", "udoneb", "ub1b", "ud10as", "ud1ab", "ud10c", "aud1app", "ud11am", "aud1a", "bb1an", "ud10k", "ud100aa", "ud1app", "aud5ada", "ud11a", "udonea", "ut1a", "ud0as", "uddonesa", "ud0b", "udonek", "ud9a", "udonean", "ud5ada", "ud1k", "aud1aa", "ud0ca", "ud01as", "ud81a", "bb0as", "ud11ca", "uddonek", "ud0c", "ut1b", "utonean", "ud10ca", "ud10a", "ut1alpha", "aud1ca", "ud1an", "ud1sa", "udd1k", "ud0a", "ud11alpha", "udoneas", "ub81a", "ud9ca", "ud17k", "ud5app", "ud001aa", "ud9c", "ud1as", "ub1a", "ud001a", "ud0an", "ud10ab", "ud1am", "ud5aa", "aud10c", "aud5a", "aud5app", "utonea", "ud2am", "ud001app", "utonealpha", "ud100ada", "ud1c", "aud5aa", "ud81am", "ud01an", "ub81ca", "ud01a", "bb1a", "ud2alpha", "ud2as", "aud1ada", "ud001ada", "aud10ca", "ud11b", "ud17as", "ud9ab", "ud100a", "ub1am", "ud100app", "ud2an", "udonealpha", "ub81b", "ud2b", "uddonea", "ud1ca", "ud81ca", "aud10a", "udd1a", "bb1as", "ud2ca", "ud11an"], "ud1b": ["du0l", "utonep", "ud11n", "udd1c", "ud01b", "udoned", "du0base", "ud11c", "ud3base", "udOned", "ut1db", "utonebin", "ud01abc", "ut1d", "uc1c", "ud81b", "ud5c", "ud001base", "ud1bin", "du1base", "udd10b", "ut1bin", "uc1p", "utoneb", "ud8z", "ud01c", "udoneb", "ud3n", "du11f", "ud1ab", "ud10c", "ud11ab", "ud8p", "ut1p", "du1b", "du11ab", "ud11a", "ud1n", "ud001l", "ud1z", "ud8db", "utoned", "udonedb", "ud0b", "ud81p", "ud3l", "ud1d", "udonebody", "ud001be", "du11b", "ud11f", "ud1p", "uc81c", "du11n", "du1n", "udonebin", "du0b", "ud5bb", "ud1be", "du0be", "ud11bin", "ut1b", "udonez", "ud10a", "udd10c", "ud0l", "udonef", "ud1abc", "utonez", "du1be", "ud81bb", "ud3b", "udonen", "ud3be", "udd1b", "ud10b", "udoneab", "ud3ab", "ud11abc", "ud11body", "du1f", "ud11d", "ud1body", "uc81bb", "ud1db", "ut1body", "udd10abc", "uc1b", "udOnedb", "du1l", "ud0be", "uc81b", "ud10abc", "ud11p", "ud8b", "udOnebody", "du1ab", "ud81c", "ud11bb", "ud1c", "udonep", "ud1f", "ud0base", "utonedb", "utonebody", "udOneb", "ud1l", "ud01a", "ud1base", "ud3f", "ut1z", "udOnez", "ud11b", "udOnebin", "uc81p", "udd10a", "udOnep", "uc1bb", "udd1abc", "ud5p", "ud001b", "ud5b", "ud1bb", "udd1a"], "ud1list": ["ug91f", "ud31list", "vd1list", "upp1list", "ud2l", "ud3pl", "udd01f", "udd1list", "ud91s", "udonebe", "udronlist", "udoneList", "udOneList", "ud01list", "udronnext", "upp151list", "upp1next", "upp1int", "udOnelist", "ud1main", "ud3bl", "ud11int", "ug001list", "udd1f", "ug91be", "ug001string", "ud31List", "ud91be", "ud9list", "ud1part", "udonelist", "ud1pl", "ud11be", "uidonebl", "vdOnelist", "upp1main", "uid1pl", "ug91list", "ud01f", "ud151list", "ud2list", "upp151int", "ud6main", "ud11f", "ud1p", "ud11bl", "udd01l", "ud001int", "ug001s", "ud6next", "udones", "upp151main", "ud11l", "udd1l", "ud1s", "ud1be", "ud001s", "ug1be", "vdOnep", "ud151next", "udd01bl", "ud3list", "udd01list", "udonef", "ud001list", "udOnepart", "uidonepl", "ud2bl", "ud151main", "ud9s", "ud31p", "ug1string", "ud1next", "ud6list", "vd1List", "uid1list", "ud1bl", "ud001string", "ug91s", "ud1int", "ud9pl", "uidonelist", "vdOnepart", "udd1bl", "udronint", "ud01l", "ud6int", "udronmain", "ud9string", "ud2f", "ud11list", "ud11s", "vdOneList", "ud151int", "ud11string", "udonepart", "ud1string", "udonebl", "ug001int", "udonep", "ud1f", "ud1List", "upp151next", "ud1l", "ud01bl", "ud31part", "ud9int", "ud9bl", "udOnep", "vd1p", "uid1bl", "vd1part", "udonepl", "ug1f", "ug1int", "ug1list", "ug1s", "ud91list", "ud91f"]}}
{"project": "qemu", "commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "target": 0, "func": "void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n", "idx": 6927, "substitutes": {"data": ["master", "a", "done", "progress", "object", "style", "i", "buf", "results", "d", "align", "match", "buffer", "code", "error", "arr", "Data", "empty", "pass", "output", "zero", "li", "index", "pack", "header", "value", "send", "update", "val", "slice", "info", "module", "missing", "valid", "DATA", "number", "ops", "da", "raw", "pad", "response", "ee", "batch", "read", "end", "ui", "size", "bin", "block", "alpha", "change", "dat", "wa", "image", "post", "u", "message", "bytes", "p", "input", "frame", "start", "ul", "cache", "next", "mu", "open", "la", "complete", "dd", "final", "body", "window", "split", "ata", "load", "result", "memory", "sample", "date", "first"], "length": ["pack", " lengths", "Length", "enc", " len", "code", "len", "message", "type", "end", "size"], "hlen": ["HHlength", "hlong", "kh12", " hval", "bhlan", "hval", "Hlength", "hhlf", "wlength", "dhlen", "pLen", "hsval", "hLen", "dhden", "hlimit", "HHlen", "uhlen", "hlin", "hlan", "chlf", "uhlimit", "hh12", "hden", "Hmin", "hslength", "khlen", "dhlf", "hslen", " hLen", "thlong", "chlen", " h12", "hsmin", "hrlan", "hmlan", " hden", "hrlon", " hlan", "thlimit", "hmin", "ahlength", "phlon", "bhlen", "Hlin", "hhlon", "hlf", "hrlen", "hlength", "phlen", "chlan", "Hlan", "hrlin", "phLen", "khlf", "h12", "ahlimit", "Hval", " hlf", "wlon", "Hlf", "wLen", "ahlen", "wlen", "thlength", "dhlan", "khlon", "bhlin", "phlength", "HHlon", "hlon", "hmlon", "ahlong", "plength", " hlon", "thlen", " hlength", "hmlf", "hhlen", "plon", "chden", "uhlength", "Hlen", "bhlon", " hmin", "Hlon", "HHLen", "hmlen", "uhlong"], "plen": ["pelend", " plend", " pllen", "pallen", "palum", " plens", "blen", "pllen", "ipllen", "clener", "pellen", "plens", "plend", "pelenth", "plum", "palens", " plener", "ppn", "clens", "pln", "palen", "ppen", " plum", " pln", "clen", "cln", "iplen", "blend", "bllen", "iplens", "ppens", " plenth", "plener", "plenth", "iplener", "blenth", "pplen", "iplum", "pelen", "cllen"], "proto": ["perocol", "procto", "perdo", "protf", "compo", "progo", "compdo", " probe", "propo", "produtto", "prof", "prodo", "proo", "produco", "compto", "protdo", "protto", "pero", "Probo", "perto", "probo", "compocol", "proocol", "Proocol", "Propo", " protto", "procbo", "produocol", "Probe", "Prof", "proco", "procbe", "procpo", "Progo", "produto", "protgo", " propo", "protocol", " prof", " progo", "probe", "Proto", " probo", "perco", "pertto", " proco", " proocol"], "csum_offset": ["csum__len", "csum_entry", "csum___entry", "csum_end", "csum_align", "csuba_operation", "csum_start", "csum_count", "csumi_slot", "csum___origin", "csum___slice", "csum_origin", "csav_offset", "csm__offset", "csav_entry", "csum67offset", "csum_len", "csuba_count", "csav___entry", "csum_operation", "csav___offset", "csum__align", "csmission_width", "csm__off", "cssum_length", "csum67item", "csumi_layer", "csumi_order", "csum_length", "csum67operation", "csm_off", "csuba_offset", "csum67width", "csum_size", "csm_entry", "csum__start", "csum__end", "csav___slice", "csumm_align", "csum_width", "csum_item", "csum__entry", "cssum_len", "cssum_off", "csav_slice", "csumm_end", "csumm_offset", "cssum_start", "csum_slot", "csum__offset", "csum_off", "csav_origin", "csum_no", "csum__off", "csm__length", "csum_layer", "csum__count", "csum_slice", "csm__entry", "csumm_count", "cssum_offset", "csmission_operation", "csm_length", "cssum_size", "csuba_no", "csumi_offset", "csum_order", "csav___origin", "csmission_offset", "csmission_item", "csum___offset", "csm_offset", "csum__length"], "csum": [" scumber", "upsumb", "cssumb", "csend", "csumber", "upssum", "cfend", "csums", "cul", " scum", "cumb", "csup", "cssac", "csumm", " csums", "cfums", "cssup", "cssumber", "cum", " csup", "cums", "ccac", " csul", "cfum", "upsend", "cfsum", "upsum", " scumm", " csumm", "ccumb", "csumb", " csumb", "cssum", "cfumb", "cssumm", " csac", " csend", "cssums", "csac", " scums", "cful", "ccup", "ccum", " csumber", " cssum", "csul"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void x86_cpu_parse_featurestr(const char *typename, char *features,\n\n                                     Error **errp)\n\n{\n\n    char *featurestr; /* Single 'key=value\" string being parsed */\n\n    static bool cpu_globals_initialized;\n\n    bool ambiguous = false;\n\n\n\n    if (cpu_globals_initialized) {\n\n        return;\n\n    }\n\n    cpu_globals_initialized = true;\n\n\n\n    if (!features) {\n\n        return;\n\n    }\n\n\n\n    for (featurestr = strtok(features, \",\");\n\n         featurestr;\n\n         featurestr = strtok(NULL, \",\")) {\n\n        const char *name;\n\n        const char *val = NULL;\n\n        char *eq = NULL;\n\n        char num[32];\n\n        GlobalProperty *prop;\n\n\n\n        /* Compatibility syntax: */\n\n        if (featurestr[0] == '+') {\n\n            plus_features = g_list_append(plus_features,\n\n                                          g_strdup(featurestr + 1));\n\n            continue;\n\n        } else if (featurestr[0] == '-') {\n\n            minus_features = g_list_append(minus_features,\n\n                                           g_strdup(featurestr + 1));\n\n            continue;\n\n        }\n\n\n\n        eq = strchr(featurestr, '=');\n\n        if (eq) {\n\n            *eq++ = 0;\n\n            val = eq;\n\n        } else {\n\n            val = \"on\";\n\n        }\n\n\n\n        feat2prop(featurestr);\n\n        name = featurestr;\n\n\n\n        if (g_list_find_custom(plus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n        if (g_list_find_custom(minus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n\n\n        /* Special case: */\n\n        if (!strcmp(name, \"tsc-freq\")) {\n\n            int64_t tsc_freq;\n\n\n\n            tsc_freq = qemu_strtosz_metric(val, NULL);\n\n            if (tsc_freq < 0) {\n\n                error_setg(errp, \"bad numerical value %s\", val);\n\n                return;\n\n            }\n\n            snprintf(num, sizeof(num), \"%\" PRId64, tsc_freq);\n\n            val = num;\n\n            name = \"tsc-frequency\";\n\n        }\n\n\n\n        prop = g_new0(typeof(*prop), 1);\n\n        prop->driver = typename;\n\n        prop->property = g_strdup(name);\n\n        prop->value = g_strdup(val);\n\n        prop->errp = &error_fatal;\n\n        qdev_prop_register_global(prop);\n\n    }\n\n\n\n    if (ambiguous) {\n\n        error_report(\"warning: Compatibility of ambiguous CPU model \"\n\n                     \"strings won't be kept on future QEMU versions\");\n\n    }\n\n}\n", "idx": 6935, "substitutes": {"typename": ["typenef", "typenames", "typenename", "tylenef", "tyrenename", "tyonenname", "cypenename", "sypenename", "tylenename", "cypename", "tyonenename", "sylenename", "cyonenames", "sypename", "typeef", "tyonenames", "tyrenname", "cyonenename", "tylename", "typeename", "typeame", "tylenames", "cypenname", "typerename", "tyrename", "cyonename", "sypenames", "tyrenef", "sylenef", "sylename", "sylenames", "typername", "tyonename", "tyrenames", "typerames", "sypenef", "cyonenname", "typenname", "typerame", "typeames", "cypenames"], "features": ["forms", "types", "strings", "properties", "files", "objects", "bits", "spec", "s", "plugins", "config", "words", "facts", "modules", "data", "format", "services", "names", "details", "xs", "results", "vals", "parts", "effects", "args", "ports", "series", "cs", "fields", "classes", "faces", "tests", "fn", "bytes", "reports", "feat", "devices", "Features", " Features", "settings", "products", "items", "includes", "frames", "params", "events", "reads", "flags", "feature"], "errp": ["Erp", "erpc", "errorr", "Erpc", "errorf", " errf", "errb", "errorp", "erb", "errpc", "errorb", " errpc", "err", "Erf", "errr", "Err", "erp", "Erb", "errf", " errr", "erf"], "featurestr": ["wordStr", "vartext", "conceptfr", "featuresst", "attributest", "Featurebr", "fieldfr", "featuretext", " featurest", "fieldStr", "feattext", "sharest", "conceptbr", " featurefr", "attributestream", "featureStr", "shareinst", "attributestring", "varstr", "featuresner", "attributebr", "imageinst", "conceptstri", "FeatureStr", "Featurestring", " featureStr", "featurener", "shareSTR", "resultStr", "featfr", "imagestr", "wordstring", "featurest", "featuresStr", "wordst", "varfr", "featurestream", "sharestr", "featst", " featurener", "attributener", "functionstring", "Featurestr", "featurebr", "imagest", "conceptstr", " featurestri", "wordinst", "fieldstr", "functionst", "featStr", "featstring", "featurestri", "featurestring", "featstr", "featureSTR", "featbr", "wordstr", "fieldstri", "imageSTR", "featurefr", "varStr", "functionStr", " featurebr", " featurestream", "resultstri", "featstream", "attributeStr", "conceptStr", "featureinst", "featstri", "concepttext", "functionstr", "attributestr", "featuresstr", "functionbr", "resultstr", "resultfr", "wordSTR", " featurestring"], "cpu_globals_initialized": ["cpu_globals_init", "cpu_globalls_init", "cpu_globalls_Initialized", "cpu_globals_known", "cpu_globals_enabled", "cpu_globals_Initialized", "cpu_globalls_known", "cpu_globals_loaded", "cpu_globalls_enabled", "cpu_globalls_initialized", "cpu_globalls_loaded"], "name": ["na", "large", "x", "data", "names", "create", "active", "code", "all", "pass", "self", "span", "am", "var", "label", "on", "base", "option", "id", "parent", "word", "value", "named", "info", "missing", "null", "url", "member", "Name", "comment", "field", "str", "filename", "search", "old", "node", "cap", "new", "type", "model", "text", "test", "no", "size", "time", "change", "image", "title", "key", "inc", "version", "action", "NAME", "feat", "start", "desc", "prefix", "anc", "mem", "scope", "up", "alias", "live", "call", "part", "n", "common", "nam", "none", "nice"], "val": ["serv", "play", "el", "local", "data", "rel", "pret", "unit", "arg", "property", "code", "len", "col", "var", "sel", "index", "base", "pid", "id", "al", "count", "value", "list", "valid", "vals", "null", "cal", "lib", "ctx", "str", "eval", "scale", "doc", "util", "text", "test", "par", "grad", "Value", "vol", "vec", "reg", "op", "loc", "key", "inc", "VAL", "mod", "py", "p", "pos", "ind", "ref", "dim", "ret", "v", "pr", "mem", "pre", "format", "comp", "Val", "live", "lit", "call", "split", "def", "part", "seq", "opt"], "eq": ["sub", "abc", "cmp", "ch", "act", "extra", "iq", "rt", "id", "alpha", "qq", "change", "rr", "quad", "adv", "value", "op", "rc", "alias", "exc", "enc", "comp", "sum", "info", "co", "loc", "quant", "fx", "valid", "inc", "cl", "offset", "xy", "equal", "ext", "call", "q", "col", "error", "comment", "depth", "ctx", "equ", "hop", "seq", "quality", "qu", "scale", "ne", "req", "sq", "query", "util", "desc", "ref", "element", "ac", "diff", "qual", "prefix"], "num": ["uni", "norm", " number", "dim", "na", "bin", "mem", "count", " dim", "nt", "mult", "sum", "gnu", "umi", "cat", "info", "loc", "unit", "inc", "valid", " coord", "offset", "mon", "frac", "init", "param", "np", "number", "dom", "len", "con", "col", "Num", "n", "NUM", "multi", "coord", "nb", "seq", " inc", "pos", "gen", "proc", "node", "orig", "um", "desc", "text", "index", "no", " NUM", "max", " numeric", "end", "nu"], "prop": ["cp", "option", "cmp", "properties", "Prop", "pr", "prev", "parent", "pro", "rop", "config", "tmp", "op", "data", "pred", "comp", "cat", "key", "lit", "attr", "mp", "project", "prot", "j", "obj", "param", "def", "property", "part", "conf", "priv", "col", "target", "dev", "lib", "field", "feat", "jp", "p", "root", "opt", "pos", "doc", "proc", "dep", "type", "class", "api", "ps", "term", "ref", "pb", "test", "par", "grad"], "tsc_freq": ["tsc_Frez", "tsc_Freity", "tsc_rez", "tsc_frequencyq", "tsc_freeq", "tsc_lenq", "tsc_Frequal", "tsc_freeqs", "tsc_rotquality", "tsc_lenp", "tsc_perq", "tsc_fq", "tsc_perity", "tsc_requal", "tsc_frequencyQ", "tsc_rotqual", "tsc_perquality", "tsc_Frequality", "tsc_frequal", "tsc_req", "tsc_frequencyiq", "tsc_freQ", "tsc_FreQ", "tsc_leniq", "tsc_Freqs", "tsc_Freiq", "tsc_freiq", "tsc_freity", "tsc_Frep", "tsc_frequencyqs", "tsc_freqs", "tsc_lenQ", "tsc_rotQ", "tsc_rotz", "tsc_Freq", "tsc_fp", "tsc_rotq", "tsc_frep", "tsc_freeQ", "tsc_perQ", "tsc_frequality", "tsc_rotity", "tsc_requality", "tsc_freeiq", "tsc_frez", "tsc_fiq", "tsc_fQ"]}}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n", "idx": 6946, "substitutes": {"s": ["o", "er", "sets", "v", "local", "is", "S", "less", "http", "spec", "scope", "session", "b", "si", "i", "sync", "sys", "ses", "services", "m", "xs", "f", "client", "ns", "d", "server", "sl", "q", "service", "us", "ss", "u", "sis", "e", "sh", "w", "gs", "se", "ds", "tests", "storage", "qs", "t", "self", "p", "south", "settings", "z", "c", "os", "g", "ssl", "sym", "sq", "y", "es", "js"], "vq": ["Vdq", "bq", "vg", "Vq", "svg", "fdq", "fqs", "svque", " vqs", "qudq", "quqs", " vg", "quue", "fue", " vdq", "bdq", "quq", "sviq", "vque", "bqi", "svq", " vue", "viq", "svqi", "bque", " viq", "svdq", "vqs", "fq", "vue", "vdq", "vqi", " vque", "Vg", " vqi", "Viq"], "handler": ["function", "er", "wrapper", "hand", "channel", "rb", "or", "info", "handled", "route", "event", "f", "job", "cher", "handle", "service", "ph", "sth", "parser", "error", "w", "func", "fn", "path", "ctx", "cb", "response", "self", "callback", "controller", "parse", "reader", "h", "Handler", "gen", "c", "type", "host", "manager"], "n": ["nl", "name", "o", "nn", "nt", "config", "b", "nc", "x", "i", "sn", "m", "in", "l", " N", "num", "f", "N", "ns", "d", "nr", "j", "net", "u", "all", "w", "en", "t", "fn", "nb", "p", "ne", "network", "z", "c", "g", "y"], "qbus": ["qtbus", "viewbus", "vdev", "qcache", "sqplug", "vbus", "sqcache", "qtplug", " qusb", "qplug", "Qplug", " qdev", "vusb", "qusb", "qboot", " qcat", "vcat", "Qus", "viewcat", "Qboot", "qqboot", "qqplug", "viewdev", "Qbus", "sqbus", "viewusb", "sqboot", "qcat", "Qcache", "qqBus", "qus", "qqbus", "QBus", "squs", "qtcache", "qdev", "qtus", "qBus", "sqBus"], "k": ["ko", "o", "kin", "v", "ka", "ik", "ki", "get", "b", "m", "K", "sk", "ijk", "dk", "d", "j", "q", "u", "unk", "ck", "w", "ks", "ctx", "kernel", "self", "p", "kw", "ky", "h", "kb", "ke", "c", "g", "tk", "ku", "uk", "ok"], "r": ["gr", "dr", "fr", "rw", "er", "sr", "ret", "cr", "v", "rt", "rr", "pr", "rb", "b", "ri", "i", "rd", "rf", "or", " res", "m", "rh", "l", "ru", "f", "d", "nr", "q", "res", "u", "e", "rus", "ar", "w", "rg", "err", "rl", "self", "rev", "str", "result", "p", "lr", "root", " result", "h", "ner", "R", "re", "mr", "c", "g", "ro", "hr", "br", "rs", "kr", "rar"], "rc": ["ource", "abc", "rn", "irc", "anc", " RC", "cr", "rt", "cur", "rr", "wx", "roc", "rb", "nc", " rac", "auc", "uc", "inc", "rh", "pg", "ra", "pc", "ack", "cc", "ry", "tc", "ras", "arc", "ck", "sc", "error", "dc", "rx", "bc", "err", "result", "misc", " src", "back", "RR", "lc", "fc", "ac", "success", "rs", "ref", "src", "RC", "rec", "xc", "ok"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}", "idx": 6951, "substitutes": {"queue": ["flow", "feed", "entry", "complete", "channel", "config", "list", "manager", "database", "module", "route", "sequence", "buf", "client", "ue", "gui", "server", "q", "loop", "Queue", "buffer", "que", "connection", "forward", "port", "file", "lib", "menu", "question", "seq", "pool", "p", "context", "qa", "collection", "console", "global", "cache", "set", "group", "command"], "from": ["as", "fr", "to", "origin", "sec", "cur", "since", "component", "or", "resource", "with", "offset", "at", "pri", "ce", "via", "about", "se", "after", "source", "without", "start", "From", "c", "range", "slave", "new", "user", "who", "cf", "link", "form", "conn", "end"], "packet": ["compset", "compel", "packel", "compacket", "pkt", "compinet", "Packacket", "packeting", "pluget", "packinet", "pette", "plugacket", "asset", "plugette", "compette", "Packinet", "plugart", "assacket", "pet", "plugett", "passel", "packette", "Packet", "passet", "Packset", "competter", "packart", "compart", "plugetter", "competing", "packetter", "passett", "assette", "packkt", "compett", "packset", "plugel", "compkt", "plugkt", "Packetter", "packett", "packacket", "plugset", "Packette", "Packart", "compet", "Packeting", "passacket", "assinet", "plugeting"], "next": [" Next", "then", "open", "prev", "entry", "done", "future", "last", "now", "data", "reply", "sequence", "f", " entry", "later", "code", "Next", "iterator", "error", "forward", "second", "path", "first", "EXT", "seq", "again", "ner", "start", "line", "step", "new", "page", "success", "nd", "end"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6953, "substitutes": {"session": ["bind", "bin", "mem", "open", "parent", "ESSION", "channel", "save", "config", "socket", "use", "token", "secret", "database", "window", "resource", "event", "client", "child", "gui", "server", "subject", "connect", "sid", "connection", "port", "lock", "input", "batch", "Session", "ession", "request", "ssl", "cache", "conn", "view"], "data": ["base", "open", "a", "entry", "done", "dat", "ada", "slice", "database", "body", "image", "window", "results", "content", "client", "d", "server", "DATA", "buffer", "len", "da", "message", "Data", "bytes", "timeout", "response", "result", "array", "input", "batch", "start", "memory", "read", "api", "cache", "next", "size"], "datalen": [" daclen", "dacheleng", "datalength", " daclener", "dalens", " dallen", "dalleng", "dachelen", "davaln", " dataln", "datallen", "dallength", " dalleng", "dallen", "davalens", "datalener", "dacln", "dachelength", "dalllen", "dstaleng", "daln", "davalen", " dacln", "dstalength", " datalength", " datalens", "datalens", " dallength", "dataln", "dstallen", " datallen", "daclens", " dataleng", "dalener", " datalener", "dachellen", " dalllen", "davalener", "daclen", "dstalen", " daclens", "dataleng", "dalen", "daclener"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int slice_end(AVCodecContext *avctx, AVFrame *pict)\n\n{\n\n    Mpeg1Context *s1  = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n\n\n    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)\n\n        return 0;\n\n\n\n    if (s->avctx->hwaccel) {\n\n        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)\n\n        ff_xvmc_field_end(s);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    /* end of slice reached */\n\n    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {\n\n        /* end of image */\n\n\n\n        ff_er_frame_end(&s->er);\n\n\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else {\n\n            if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n                s->picture_number++;\n\n            /* latency of 1 frame for I- and P-frames */\n\n            /* XXX: use another variable than picture_number */\n\n            if (s->last_picture_ptr != NULL) {\n\n                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);\n\n                if (ret < 0)\n\n                    return ret;\n\n                ff_print_debug_info(s, s->last_picture_ptr);\n\n            }\n\n        }\n\n\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 6956, "substitutes": {"avctx": ["akcontext", "avconn", "avelib", "awctx", "avctl", "afctrl", "aflib", "aimctx", "avcam", "avecam", "AVcoll", "averctl", "avectx", "AVlib", "avcmd", "aflc", "avercontext", "aimctrl", "afctl", "avcu", "AVctx", "afcmp", "AVcontext", "averctx", "avcmp", "avcoll", "afcmd", "avlib", "avcf", "akctx", "afctx", "AVctrl", "AVctl", "avecf", "awcu", "avcontext", "AVcmp", "ajcu", "afcoll", "verctx", "aveconn", "aimcoll", "awcontext", "avecontext", "akcmd", "ajctrl", "vercam", "afconn", "afcf", "avlc", "afcontext", "avecmd", "ajctx", "aklc", "afcam", "ajcontext", "avelc", "ajcmp", "avctrl", "vercmp", "AVconn", "awcmp", "aimcontext", "avecmp", "avercmp", "afcu", "vercf"], "pict": ["game", "screen", "fat", "ch", "serv", "vec", "gif", "pai", "asa", "config", "pas", "cat", "sys", "image", "imag", "picture", "obj", "mot", "phot", "sci", "cli", "init", "sc", "cam", "bis", "plain", "ctx", "jpg", "feat", "oss", "Pict", "p", "ic", "photos", "pty", "xxx", "pic", "fig", "doc", "proc", "c", "capt", "txt", "ct", "sq", "photo", "png", "fi", " pic", "gross", "img", "conn", "Pic"], "s1": ["ss1", "c91", "c5", "cs1", "cone", "sone", "c2", "sgone", "c1", "cs6", "cs91", "ss5", "sg1", "s2", "v1", "c6", "s1001", "ssone", "sg5", "p1", "pone", "s91", "ss2", "cs2", "s6", "s5", "v1001", "p1001", "sg2", "vone"], "s": ["sf", "S", "comm", "a", "features", "b", "i", "f", "d", "service", "conf", "w", "self", "aws", "g", "sym", "y", "sets", "is", "spec", "services", "its", "server", "sl", "ls", "ops", "bis", "ds", "ctx", "ts", "south", "settings", "fs", "sq", "ms", "rs", "stat", "as", "sg", "plugins", "comments", "sync", "ses", "ions", "j", "cs", "sis", "e", "an", "vs", "sb", "ks", "qs", "t", "p", "c", "os", "ssl", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "details", "l", "xs", "ns", "stats", "args", "us", "ss", "gs", "se", "n", "this", "request", "es", "js"], "xvmc_acceleration": ["xvmc_macoderration", "xvmc_macoderator", "xvmc_accelation", "xvmc_accelerated", "xvmc_maccelerration", "xvmc_macceleration", "xvmc_accelator", "xvmc_accelerration", "xvmc_acoderation", "xvmc_acoderated", "xvmc_macoderated", "xvmc_macoderation", "xvmc_acoderration", "xvmc_acveration", "xvmc_acverration", "xvmc_acverator", "xvmc_accelerator", "xvmc_maccelerated", "xvmc_maccelerator", "xvmc_acoderator", "xvmc_acverated", "xvmc_accelated", "xvmc_accelration"], "picture_number": ["picture_index", "image_version", "picturealindex", "image_num", "picturealversion", "picture64number", "picture_num", "image_index", "picturealnumber", "picture64version", "picture64index", "picturealnum", "picture64num", "image_number", "picture_version"]}}
{"project": "FFmpeg", "commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972, "substitutes": {"s": ["serv", "sf", "S", "b", "f", "d", "service", "conf", "w", "same", "h", "aws", "sa", "g", "sym", "sets", "is", "services", "its", "states", "server", "sl", "ls", "sie", "ops", "ds", "ts", "settings", "sv", "fs", "sq", "ms", "site", "rs", "sr", "sec", "sg", "sche", "sync", "ses", "cs", "u", "e", "sb", "qs", "t", "p", "re", "ges", "c", "os", "ssl", "sup", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "side", "ns", "space", "res", "ss", "gs", "su", "sample", "es", "js"], "block": ["Block", "base", "row", "layer", "bin", "box", "channel", "chain", "session", "list", "b", "object", "bit", "record", "unit", "buffer", "clock", "section", "lock", "coll", "array", "blocks", "batch", "frame", "un", "re", "BL", "line", "node", "rule", "range", "type", "bl", "ref", "cache", "group", "r", "rec", "view"], "n": ["nl", "nn", "b", "nc", "l", " N", "num", "N", "ns", "d", "len", "e", "all", "w", "en", "k", "nat", "nb", "p", "ne", "z", "ner", "ln", "c", "g", "r", "rec"], "level": ["layer", "local", "ll", "unit", "letter", "f", "weight", "d", "code", "len", "all", "col", "depth", "file", "pass", "stage", "where", "line", "lc", "index", "mode", "le", "row", "build", "id", "count", "value", "val", "url", "limit", "sol", "loop", "round", "lo", "sc", "path", "str", "scale", "fail", "ld", "rule", "type", "model", "rol", "low", "size", "clean", "vel", "loc", "inc", "key", "cl", "Level", "temp", "global", "ul", "location", "wl", "VEL", "set", "levels", "la", "total", "ell", "l", "child", "call", "length", "roll", "full", "day", "lock", "coll", "lvl", "cost", "step"], "i": ["uni", "gi", "layer", "o", "position", "ti", "v", "id", "I", "is", "di", "ci", "ni", "x", "b", "si", "io", "xi", "slice", "ri", "info", "bi", "in", "qi", "l", "f", "pi", "yi", "phi", "iu", "ii", "it", "ai", "init", "u", "e", "uri", "ori", "k", "mi", "ini", "ie", "p", "z", "start", "hi", "c", "ip", "ind", "y", "li", "index", "r", "ui"], "j": ["jet", "o", "el", "v", "note", "jl", "jump", "ji", "op", "b", "ani", "rel", "m", "kj", "l", "job", "ij", "aj", "q", "J", "jc", "k", "uj", "jp", "err", "str", "jo", "p", "jit", "un", "z", "pos", "jj", "ind", "g", "dj", "ja", "br", "li", "adj", "syn", "r", "js"], "run": ["base", "name", "row", "layer", "clean", "build", "reg", "play", "runs", "nn", "config", "update", "val", "skip", "use", "sync", "vel", "unit", "ran", "inc", "num", "ru", "job", "child", "order", "call", "weight", "limit", "version", "mod", "loop", "round", "len", "con", "Run", "day", "win", "pass", "go", "exec", "running", "output", "runner", "un", "batch", "pos", "step", "fun", "type", "thread", "UN", "index", "set", "r", "min", "max", "end", "add"], "rl": ["nl", "fr", "vr", "lb", "sr", "rt", "el", "rr", "rb", "rc", "rel", "lp", "ll", "l", "repl", "ru", "tl", "fl", "ls", "sl", "sb", "rg", "lr", "ruby", "gb", "mr", "sel", "bf", "ssl", "ro", "lc", "lv", "dl", "il", "fc", "pl", "rs", "rol", "r", "ctrl"], "scantable": ["scandor", "Scandiable", "scentiable", "Scantiable", "Scandor", "scantsiable", "scaptables", "Scaptable", "scactables", "scaptor", "scantible", "Scantables", "scentible", "scentables", "scactable", "scantsable", "scandables", "scaptable", "Scandables", "Scaptables", "scantsables", "scactiable", "scantables", "Scantible", "scantor", "scactible", "scantiable", "scantsible", "Scantable", "scentable", "Scaptible", "Scaptiable", "Scandible", "scandible", "scaptible", "scantsor", "scaptiable", "scandable", "Scandable", "Scantor", "scandiable"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n", "idx": 6997, "substitutes": {"is": ["isi", "ris", "ib", "does", "IS", "iris", "parts", "ii", "ois", "las", "bs", "ar", "cms", "self", "nis", "irc", "id", "s", "config", "info", "its", "was", "ls", "iss", "it", "uri", "ops", "bis", "ils", "ie", "ais", "ip", "ms", "iso", "isc", "ui", "as", "act", "are", "ins", "lis", "ri", "use", "or", "ses", "isl", "has", "isu", "esi", "isa", "cs", "ics", "sis", "mis", "ist", "isin", "ic", "css", "os", "can", "api", "core", "ish", "app", "Is", "http", "get", "in", "init", "us", "full", "this", "iv", "il", "es", "js"], "vp": ["nv", "plugin", "gp", "hw", "vr", "bp", "vg", "v", "pr", "qv", "vm", "va", "vt", "tmp", "esp", "pp", "pd", "xp", "wp", "lp", "avi", "uv", "px", "uf", "pm", "mp", "pg", "pps", "np", "vs", "vP", "fp", "jp", "fps", "p", "sv", "sp", "iv", "ppa", "vl", "eve", "lv", "ov", "tp", "vv", "VP", "api", "PF", "cv", "vc", "pb", "adr", "pkg"], "i": ["gi", "r", "o", "ti", "v", "I", "di", "s", "ci", "ji", "ni", "xi", "ri", "si", "rc", "b", "abi", "io", "x", "bi", "m", "qi", "ix", "l", "yi", "pi", "f", "phi", "j", "iu", "ii", "d", "ai", "cli", "u", "vi", "e", "uri", "t", "k", "multi", "ini", "p", "h", "eni", "z", "oi", "c", "ip", "g", "api", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "560b10a6c3627cccf6735170d370cf9e3d38e805", "target": 1, "func": "static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n", "idx": 6999, "substitutes": {"q": ["iq", "v", "cur", "qq", "quad", "config", "qt", "x", "sync", "co", "queue", "m", "quant", "qi", "l", "cal", "cl", "f", "event", "client", "ue", "call", "dq", "d", "ce", "conf", "u", "ck", "e", "que", "comment", "qs", "Q", "k", "t", "self", "work", "question", "qu", "p", "context", "input", "qa", "req", "this", "z", "request", "charge", "c", "g", "sq", "core", "cf", "query", "cache", "requ", "quest"], "i": ["gi", "o", "ti", "v", "id", "I", "count", "a", "chi", "di", "ci", "ni", "b", "x", "si", "xi", "io", "abi", "ri", "info", "bi", "in", "qi", "l", "f", "pi", "yi", "phi", "d", "ii", "j", "length", "iu", "ai", "uli", "it", "u", "e", "uri", "k", "n", "multi", "ini", "ie", "p", "z", "eni", "start", "oi", "hi", "c", "ip", "li", "fi", "index", "r", "zi", "mu", "ui"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004, "substitutes": {"hw": ["hp", "gp", "rw", "nw", "fw", "wx", "qq", "sw", "ow", "wm", "wa", "wk", "wb", "wy", "wo", "wd", "hm", "w", "we", "tw", "hh", "ctx", "zh", "hop", "voc", "work", "ou", "kw", "iw", "h", "vp", "wu", "ht", "ha", "pkg"], "ret": ["reg", "rt", "mem", "al", "alt", "pin", "pat", "value", "vt", "val", "data", "et", "art", "reply", " RET", "fin", " Ret", "att", "sil", "res", "match", "def", "len", "det", "RET", "func", "ben", "lib", "pass", "result", "seq", "lex", "Ret", "ft", "re", "fun", "Return", "ref", "rep", "aux", "fi", "rets"], "pa": ["opa", "gp", "bp", "na", "pan", "python", "arta", "pai", "pr", "a", "ka", "PA", "la", "ua", "va", "pre", "po", "pse", "pas", "oa", "cca", "pe", "lp", "ena", "ya", "appa", "lia", "pm", "ma", " Pa", "pi", "ga", "pc", "per", "pn", "SPA", "pha", "sea", "jp", "ba", "p", "ama", "qua", "Pa", "ca", "qa", "ampa", "fa", "ista", "ana", "bank", "ppa", "ta", "sa", "ja", "tta", "apa", " PA", "pb", "au", "audio"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_device_init(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->init) {\n\n        return sc->init(s);\n\n    }\n\n    return 0;\n\n}\n", "idx": 7017, "substitutes": {"s": ["o", "sets", "is", "S", "a", "spec", "scope", "b", "si", "i", "sync", "sys", "ses", "services", "m", "f", "server", "d", "args", "service", "cs", "e", "sie", "an", "gs", "sb", "t", "ds", "ts", "self", "p", "south", "settings", "c", "os", "g", "ssl", "sq", "sym", "es", "r", "js"], "sc": ["osc", "anc", "cr", "spec", "ci", "scope", "acc", "cle", "cus", "si", "rc", "sync", "comp", "uc", "cl", "Sc", "pc", "sci", "cc", "ss", "cs", "code", "se", "dc", "esc", "cer", " SC", "bc", "ec", "ca", "sp", "c", "usc", "ct", "sq", "lc", "core", "contract", "fc", "asc", "SC", "src", "super", "tc"]}}
{"project": "qemu", "commit_id": "aaa0eb75e2e56d483c89731a447c999985713b43", "target": 0, "func": "static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int dirty)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bs->dirty_bitmap[idx];\n\n        if (dirty) {\n\n            val |= 1 << bit;\n\n        } else {\n\n            val &= ~(1 << bit);\n\n        }\n\n        bs->dirty_bitmap[idx] = val;\n\n    }\n\n}\n", "idx": 7019, "substitutes": {"bs": ["bas", "lb", "ins", "bits", "als", "b", "lbs", "bps", "asts", "ros", "ses", "BS", "obs", "bes", "ns", "ls", "iss", "las", "ss", "cs", "vs", "sb", "gs", "ks", "banks", "bis", "locks", "ds", "bc", "outs", "ils", "fps", "ubs", "ba", "blocks", "css", "gb", "fs", "utils", "os", "bos", "bid", "ps", "pb", "rs", "ras", "bh", "boxes", "js"], "sector_num": ["sectorxgener", "sectorityNum", " sector_number", " sector_Num", "section_name", "section_gener", "sector00sum", " sector_sum", " sector_two", "sector_mu", "sector00two", "sector_name", "sector_Num", "sector00num", "sector_two", "sectorxnumber", "sectoritymu", "sectoritynumber", "section_num", "sectoritynum", "sector_gener", " sector_mu", "sectorxname", "section_number", "sector_sum", "sector_number", "sectorxnum", "sector00number"], "nb_sectors": ["nb_psevers", "nb_psevisors", "nb_spevers", "nb_clectors", "nb_spegments", "nb_sevisors", "nb_spectors", "nb_clegments", "nb_soctors", "nb_cleitors", "nb_servers", "nb_seivers", "nb_pseitors", "nb_psectors", "nb_segments", "nb_serivers", "nb_pseivers", "nb_severs", "nb_clevisors", "nb_sovisors", "nb_speivers", "nb_seitors", "nb_soitors", "nb_sergments", "nb_psegments", "nb_serctors", "nb_sogments"], "dirty": ["stable", "flag", "extra", "paid", "done", "di", " force", "pretty", "shadow", "ny", "force", "bug", "fff", "negative", "fake", "valid", "db", "null", "foo", "background", "visible", " strict", "magic", "confirmed", "irty", "uri", "deep", "field", "bare", "old", "virtual", "want", "remote", "biased", "zero", "fix", "primary", "write", "initialized", "know", "ish", "quiet", "diff", "prefix"], "start": ["base", "name", "st", "id", "is", "count", "try", "check", "mid", "get", "pre", "force", "x", "use", "style", "sync", "last", "art", "info", "ad", "in", "ix", "key", "like", "offset", "rest", "state", "d", "grade", "length", "it", "init", "from", "part", "stop", "size", "Start", "pad", "work", "ie", "p", "old", "source", "boot", "step", "pos", "ind", "cost", "front", "next", "set", "no", "index", "min", "max", "add"], "end": ["END", "est", "then", "append", "id", "eff", "send", "edge", "mid", "update", "x", "last", "use", "or", "ending", "ion", "rest", "post", "offset", "event", "add", "length", "ended", "stop", "e", "size", "len", " End", "en", "k", "after", "path", "ent", "until", "run", "ide", "range", "ind", "inner", "set", "index", "min", "max", "nd", "End"], "val": ["base", "stat", "vol", " v", "pid", "bin", "v", "id", "el", "count", "al", "pr", "change", "value", "pa", "pre", "b", "data", " data", "x", "Val", "pt", "unit", " value", "buf", "valid", "vals", "live", "key", "cal", "prop", "VAL", "sl", "fl", "py", "bal", "net", "part", "len", " var", "aval", "lib", "pal", "p", "ee", "eval", "gb", "pos", "fail", "ver", "doc", "ind", "sel", "il", "bl", "pl", "ref", "grad", " Val", "slot"], "idx": [" idy", "idz", " idv", "indy", "indz", " idc", "idxp", "idc", "Idv", "Idx", "indf", "indxp", "Idy", "idv", "idf", " idxp", "Idf", " idz", "indx", "idy", "indc", "Idc", "indv", "Idxp", "Idz", " idf"], "bit": ["patch", "base", "option", "band", "bin", "block", "id", "not", "alt", "count", "parent", "quad", "value", "word", "bits", "bug", "op", "b", "cat", "Bit", "unit", "BIT", "key", "tag", "num", "offset", "it", "byte", "part", "col", "day", "field", "hop", "year", "character", "boot", "pos", "fix", "ind", "ct", "type", "ort", "ac", "index", "no", "slot"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n\n{\n\n    size_t fetched = 0;\n\n    struct iovec *src = pkt->vec;\n\n\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n\n\n    while (fetched < pkt->virt_hdr.gso_size) {\n\n\n\n        /* no more place in fragment iov */\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n\n            break;\n\n        }\n\n\n\n        /* no more data in iovec */\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n\n            break;\n\n        }\n\n\n\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n\n            pkt->virt_hdr.gso_size - fetched);\n\n\n\n        *src_offset += dst[*dst_idx].iov_len;\n\n        fetched += dst[*dst_idx].iov_len;\n\n\n\n        if (*src_offset == src[*src_idx].iov_len) {\n\n            *src_offset = 0;\n\n            (*src_idx)++;\n\n        }\n\n\n\n        (*dst_idx)++;\n\n    }\n\n\n\n    return fetched;\n\n}\n", "idx": 7027, "substitutes": {"pkt": ["Pkt", "Pck", "pett", "opelt", "pct", "spunt", "opkt", "pdu", "pck", "Punt", "fkg", "opkg", " pkk", "spkk", "facket", " pelt", "Packet", "Pdu", "Pelt", "hett", "kkt", "spkt", "spct", "spett", " pct", " pett", "kdu", "pkk", "opacket", "hacket", " pck", " punt", "kacket", "hkk", "Pct", "spacket", "Pkg", " pkg", "kck", "hkt", "packet", "punt", "fct", "fkt", " pdu", "pkg", "pelt", " packet"], "src_idx": ["src_idsxs", "src_iterz", "src_aidn", "src_Idc", "src_sidxc", "src_Idxs", "src_idele", "src_idz", "srcerlitxx", "src_idey", "src_litx", "src_idsc", "src_aidz", "src_idecent", "src_aidx", "src_Idy", "src_idsxc", "srcerlitx", "src_idxc", "src_sidb", "src_Idn", "src_idle", "src_idxs", "src_lity", "src_itercent", "src_litxx", "src_idex", "src_sidc", "srceridz", "src_iden", "srcerlity", "src_idn", "srceridx", "src_idez", "src_Idxx", "srceridy", "src_sidx", "src_Idx", "src_idcent", "src_litz", "src_idsb", "src_Idz", "src_idy", "src_ideny", "src_idb", "src_aidxs", "src_idenle", "src_idxx", "src_idc", "src_idexs", "src_itery", "src_idsx", "srceridxx", "src_iterx", "src_idenx", "src_idsy", "src_idenz", "srcerlitz"], "src_offset": [" src_loc", "src_length", "src_off", " src_off", "src_layer", " src_length", "src_limit", " src_len", "src_len", "src_base", "rc_offset", "rc_base", "src_origin", "rc_off", "src_loc", "rc_limit", "rc_len", " src_base", " src_origin", " src_layer"], "dst": ["idsts", "dput", "Dst", "edsrc", "drc", " dstage", "Dsrc", "dbl", "dssrc", "edput", "idst", "Dsts", "dconst", "edsts", "dstage", "dssts", "edst", "ssrc", "dsts", " dsrc", "sst", "sconst", "adsts", " drc", " dput", " dsts", "dsst", "bsts", "Dput", "adst", "adstage", " dbl", "idconst", "bstage", " dconst", "ssts", "bst", "bbl", "adbl", "dsrc", "idrc", "Drc"], "dst_idx": ["dst_dxs", "dst_indl", "dst_idl", "dst_Idxs", "dst_idc", "dst_Idxb", "dst_Idy", "dst_idsc", "dst__indz", "dst_idxe", "dst_dx", "dst__idxe", "dst__indx", "dst_idsxs", "dst_idcy", "dst__indxe", "dst_errorc", "dst_ridg", "dst_errorx", "dst_Idx", "dst_IDx", "dst_ridx", "dst_idy", "dst__idz", "dst_idced", "dst_Idl", "dst_indx", "dst_indX", "dst__idl", "dst_IDxs", "dst_Idced", "dst__idx", "dst_dcy", "dst_aidn", "dst_errorxb", "dst_dX", "dst_idey", "dst_IDn", "dst_idz", "dst_infoxe", "dst_errorced", "dst_indxs", "dst_infox", "dst_infol", "dst_idX", "dst_indc", "dst_Idxe", "dst_ideX", "dst_indced", "dst_aidxs", "dst_idsg", "dst_idb", "dst_iterxs", "dst_idex", "dst__indl", "dst_infoz", "dst_ridxs", "dst_indxb", "dst_ridc", "dst_idsx", "dst_Idg", "dst_indz", "dst_idg", "dst_idez", "dst_IDb", "dst_idec", "dst_idxb", "dst_aidb", "dst_Idz", "dst_idxs", "dst_aidx", "dst_indcy", "dst_iterX", "dst_Idc", "dst_indxe", "dst_idn", "dst_iterx", "dst_IdX", "dst_itercy"], "src": ["sub", "host", "st", "sec", "spec", "rb", "config", "kk", "rc", "sync", "dest", "uc", "loc", "sur", "support", "rib", "upp", "rest", "attr", "url", "grad", "dist", "sci", "rss", "sc", "sb", "control", "inst", "lib", "ctx", "cb", "feat", "source", "seq", "btn", "gb", "sup", "proc", "supp", "sel", "usc", "ssl", "sq", "secure", "cv", "desc", "upload", "img", "RC"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n", "idx": 7033, "substitutes": {"opaque": ["opacle", "opsacle", "opsaque", "Opaque", "opsacity", "ospacity", "ospaque", "Opca", "opsifice", "openacity", "opac", " opifice", " opca", "openca", "openaque", "ospifice", "opifice", "Opacity", " opacle", " opacity", "ospacle", "Opac", "opacity", "opca", "openac", " opac"], "addr": ["base", "address", "dr", "cmp", "layer", "host", "padding", "md", "alpha", "shape", "edge", "x", "data", "xp", "slice", "enc", "oa", "ad", "adjust", "ace", "ix", "offset", "ext", "adder", "nr", "ack", "align", "np", "part", "point", "len", "ar", "code", "cmd", "ctx", "pad", "coord", "hop", "work", "scale", "amp", "ptr", "pos", "pointer", "node", "amd", "adr", "ord", "slot", "site", "ref", "index", "src", "grad", "mode"], "val": ["vol", "base", "bin", "v", "el", "al", "block", "value", "va", "mult", "b", "data", "x", "slice", "sum", "bit", "Val", "buf", "valid", "vals", "tx", "VAL", "sl", "fl", "arg", "def", "all", "len", "arr", "aval", "seq", "p", "eval", "scale", "alloc", "pos", "sel", "ul", "bl", "slot"], "size": ["address", "SIZE", "large", "sec", "v", "count", "fee", "shape", "x", "sum", "data", "i", "slice", "enc", "loc", "ix", "l", "offset", "weight", "length", " length", "small", "Size", "align", "len", "e", "depth", " Size", "bytes", "ctx", "sized", "p", "scale", "z", "pos", "g", "ize", "big", "mode"], "s": ["r", "o", "is", "S", "spec", "sg", "scope", "session", "b", "socket", "i", "sync", "slice", "sys", "ses", "services", "m", "private", "f", "ns", "state", "sl", "service", "ss", "conf", "hs", "e", "sie", "sb", "gs", "secondary", "n", "p", "aws", "fs", "sa", "c", "os", "g", "ssl", "sq", "sym", "es", "rs"], "newval": [" newvals", "oldval", " newv", "raweval", " newvalue", "NewVal", "newVal", "NewVAL", "rawvalue", "nextval", "oldVal", "nexteval", "newvals", "nextvalue", "Newval", "rawval", " newVal", " neweval", "newv", "NEWval", "newvalue", "oldvals", "Newvals", "Newvalue", "nextvals", "NEWVAL", "NEWVal", "neweval", "nextVal", "newVAL", "oldvalue", "Newv", " newVAL", "nextv"], "mask": ["patch", "sub", "pack", "ch", "flag", "count", "shadow", "shape", "skip", "sum", "x", "bit", "map", "ace", "window", "sk", "Mask", "carry", "weight", "q", "conf", "delay", "len", "sh", "comment", "depth", "per", "allow", "sign", "pad", "field", "ask", "lock", "scale", "qa", "z", "flags", "fix", "filter", "cost", "cap", "hash", "max"], "shift": ["patch", "flow", "pack", " push", "shake", " shifted", "mix", "pull", "count", "Shift", "shape", "shr", "force", "slice", "ace", "reverse", "ix", "window", "offset", "length", "ffff", "align", "dist", "pop", "push", "part", "sh", "depth", "pad", "field", "ask", "hift", "scale", "z", "zero", "fix", "cost", " offset", "step", "pos", "off", "ind", "sq", "start", " scale", "set", "sup", "hole", "diff"]}}
{"project": "FFmpeg", "commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "target": 1, "func": "static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n", "idx": 7048, "substitutes": {"s": ["as", "r", "sets", "sec", "ins", "is", "S", "http", "a", "spec", "session", "si", "sync", "sys", "services", "m", "ses", "its", "l", "xs", "f", "parts", "ns", "d", "ls", "space", "service", "us", "cs", "ss", "u", "conf", "e", "facebook", "gs", "se", "ks", "bis", "ops", "ds", "t", "n", "ctx", "ts", "self", "coll", "p", "share", "this", "sup", "c", "os", "g", "ssl", "sq", "sym", "y", "your", "site", "es", "rs", "ps", "setup", "js"], "frame": ["flow", "dy", "layer", "position", "el", "builder", "component", "object", "iframe", "data", "style", "ace", "sequence", "f", "rame", "flo", "document", "buffer", "zone", "die", "file", "fram", "motion", "framework", "line", "setup", "view", "scene", "base", "header", "layout", "update", "slice", "module", "fx", "fb", "fake", "fl", "interface", "target", "ctx", "cycle", "scale", "node", "video", "element", "ze", "feature", "game", "block", "show", "flower", "image", "Frame", "e", "point", "source", "p", "fab", "c", "thread", "fd", "frames", "board", "panel", "za", "m", "draw", "window", "series", "kt", "part", "hide", "plane", "full", "coll", "figure"], "sps": ["ssms", "csPS", "ssPS", "Sfs", "sms", "pms", "sas", "wsas", "csms", "sfs", "pps", "Sps", "sspa", "pPS", "wsfs", "wsps", "Spa", "sPS", "csps", "ppa", "wspa", "spa", "Sas", "ssps", "cspa"], "ret": ["base", "flag", "reg", "inf", "rt", "id", "alt", "nt", "get", "rot", "val", "data", "rc", "bit", "art", "reply", "status", "fin", "num", "f", "lit", "att", "ext", "arg", "res", "match", "def", "len", "code", "det", "en", "arr", "bis", "RET", "empty", "result", "end", "Ret", "re", "fun", "back", "resp", "success", "ref", "rep", "fi", "rets"], "i": ["gi", "o", "ti", "v", "I", "di", "ci", "ji", "ni", "b", "ri", "si", "io", "x", "xi", "data", "info", "m", "in", "qi", "ix", "l", "f", "pi", "j", "ii", "d", "iu", "length", "ai", "init", "cli", "u", "e", "ami", "uri", "ori", "t", "n", "mi", "ini", "ie", "p", "h", "eni", "start", "oi", "c", "ip", "y", "api", "li", "inner", "fi", "index", "min", "shift", "ui"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16u8 res0, res1, res2, res3;\n\n    v16i8 filt0, filt1, filt2;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 7066, "substitutes": {"src": ["scene", "sub", "cmp", "st", "sr", "sec", "cur", "sit", "spec", "send", "rb", "config", "tmp", "rc", "sync", "slice", "dest", "stream", "comp", "uc", "loc", "sur", "rib", "https", "href", "sil", "url", "sl", "gz", "dist", "ctr", "sc", "sb", "rect", "inst", "rx", "cb", "source", "seq", "req", "gl", "iv", "sup", "sel", "ssl", "scl", "sq", "secure", "desc", "pl", "rs", "rob", "img", "RC"], "src_stride": ["src_strided", "src_brided", "src_striide", "src_Strade", "src_STRides", "src_stide", "src_Strides", "src_strade", "src_strine", "src_stid", "src_Strine", "src_striides", "src_brid", "src_stine", "src_brides", "src_STRided", "src_stides", "src_striid", "src_strid", "src_dride", "src_Strided", "src_strides", "src_drade", "src_stided", "src_drides", "src_STRide", "src_Stride", "src_drided", "src_brine", "src_STRade", "src_bride", "src_striided"], "dst": ["wsc", "dsl", "wdest", "wst", "Dst", "wsl", "dndest", "Dsl", "dnsc", "dnst", "dnsl", "Ddest", "dsc", "ddest", "Dsc"], "dst_stride": ["dst_arride", "dst_arrided", "dst_strid", "dst_stided", "dst_strride", "dst_arrid", "dst_strided", "dst_stid", "dst_stide", "dst_arrride", "dst_collride", "dst_collided", "dst_collide", "dst_collid"], "height": ["std", "Height", "padding", "diff", "block", "count", "shape", "bg", "crop", "data", "style", "repeat", "bottom", "window", "length", "ctr", "def", "resolution", "buffer", "depth", "dc", "wcs", "z", "img", "max", "dim"], "loop_cnt": ["loop_cNT", "loop_lcNT", "loop_Count", "loop_ncount", "loop_nccount", "loop_Cnt", "loop_Ccount", "loop_ncNT", "loop_ccount", "loop_lcnt", "loop_lcount", "loop_count", "loop_lccount", "loop_CNT", "loop_ncnt"], "src0": ["const2", "source4", " src00", "source00", "rc0", "const0", "img2", "source1", "rc1", "rc00", "img0", "img1", "const1", "source8", "source2", "img8", "rc2", "src00", "const8", "rc8", "rc4", "source0"], "src1": ["rc3", "source4", "filename1", "src81", "source5", "rc5", "rc0", "loc1", "source1", "rc1", "src01", "source01", "obl1", "loc4", "rc01", "source3", "obl81", "obl01", "loc0", " src81", "rc81", "obl5", " src01", "rc2", "filename0", "filename5", "loc01", "rc4", "source0", "loc2"], "src2": ["rc32", "dest2", "source5", "rc5", "inst2", "rc0", "loc1", "img2", "rc1", "img32", "src02", "inst8", "rc62", "loc4", "rc02", "inst02", "src32", "dist02", "loc0", "img4", "dest1", "inst5", "dist4", "dest02", "source8", "source2", "img8", "source02", " src02", "rc2", " src32", " src62", "dist2", "dist62", "src62", "rc8", "dest4", "rc4", "loc2"], "src3": ["source53", "rc03", "src53", "rc3", "dest3", "srcThree", "source4", "source03", " srcThree", "rc0", "rc5", "rc23", "source1", "rc53", "destThree", "rc1", "src23", "src03", "source3", " src23", " src03", "img4", "source23", "sup1", "sup3", "img03", "dest03", "rc2", "sup5", " src53", "imgThree", "img3", "sup2", "dest4", "rc4", "source0"], "src4": ["src54", "dest3", "rc3", "source4", "img7", "reflect1", "img2", "source1", "rc1", "dest40", "source3", "src04", "source7", "img4", "src40", "dest54", "rc40", " src40", "source2", "rc2", "rc54", "rc04", "reflect40", "reflect3", "img40", "reflect54", "dest4", "reflect7", "rc4", "reflect4", "source04", " src04", "rc7"], "src5": ["src25", " src50", "source25", "source50", "rc50", "source4", " src25", "source5", "rc5", "rc4", "src50", "rc25"], "src6": [" src66", "src56", "source76", "rc66", "source6", "rc76", "source66", "src76", "src66", "source56", " src56", "rc6", " src76", "rc56"], "src7": ["src73", "rc73", "src87", "sup73", "sup87", "sup77", "sup7", "source77", "source87", "source73", "src77", "source7", "rc87", "rc77", "rc7"], "src8": ["src85", "source08", "rc85", " src08", "src88", "rc8", " src85", "rc88", "source8", " src88", "source88", "source85", "rc08", "src08"], "src10_r": ["src110_r", "src10_ru", "src10_b", "src10_p", "src110_p", "src16_r", "src16_u", "src110_ru", "src10_ra", "src16_rs", "src10_u", "src16_ra", "src110_b", "src10_rs"], "src32_r": ["src32_pr", "src32__rs", "src52_rg", "src32__l", "src52_br", "src32_rs", "src43_pr", "src32_br", "src43_rs", "src52_r", "src52_b", "src32_rg", "src32__pr", "src32__r", "src32_b"], "src54_r": ["src76xl", "src54xl", "src76xr", "src54xrs", "src76xrs", "src54_rs", "src54_rw", "src76_rw", "src54xr", "src54xrw", "src76xrw", "src76_rs"], "src76_r": ["src76_ra", "src75_t", "src75_r", "src75_rs", "src75_ra", "src76_rs", "src76_t"], "src21_r": ["src21_p", "src21_rs", "src21_rg", "src43_b", "src43_rg", "src43_p", "src31_l", "src21_b", "src31_r", "src31_rg", "src31_rs"], "src43_r": ["src43_d", "src43_w", "src43_cr", "src43_sr", "src73_sr", "src73_rs", "src73_w", "src43_rs", "src73_r", "src73_cr", "src73_l", "src73_d"], "src65_r": ["src65_rs", "src67_ir", "src67_rr", "src65_rr", "src67_r", "src65_ir", "src67_rs"], "src87_r": ["src87_ra", "src87ixl", "src7_l", "src7_pr", "src7_r", "src87ixr", "src7_ra", "src87ixra", "src87ixpr", "src87_pr"], "src10_l": ["src10amrl", "src10_lc", "src30_url", "src10amlc", "src10amurl", "src10_rl", "src10aml", "src10_url", "src30_l", "src30_rl", "src30_lc"], "src32_l": ["src32__l", "src31_u", "src32_rl", "src32__rl", "src32__u", "src32_u", "src31_l", "src31_rl", "src31_r", "src32__r"], "src54_l": ["src53_r", "src54_ll", "src53_ll", "src53_lc", "src54_lc", "src53_l"], "src76_l": ["src56_lc", "src76__lc", "src56_kl", "src76__r", "src76_kl", "src76_lc", "src76__kl", "src56_l", "src56_r", "src76__l"], "src21_l": ["src21_d", "src71_d", "src21_lc", "src71_lc", "src71_r", "src71_l"], "src43_l": ["src43_lc", "src73_lr", "src73_lc", "src73_r", "src73_l", "src43_lr"], "src65_l": ["src5_r", "src5_l", "src5_b", "src65_b", "src5_m", "src65_m"], "src87_l": ["src87_d", "src57_l", "src57_r", "src57_rl", "src57_d", "src87_rl"], "out0_r": ["out0xer", "out0_m", "out1_er", "out0_er", "out1_m", "out0xl", "out0xr", "out0xm"], "out1_r": ["out32_l", "out1__r", "out1_n", "out32_mr", "out1__mr", "out1__l", "out1__n", "out32_n", "out1_mr", "out32_r"], "out2_r": ["out3_rs", "out2_rs", "out2_rd", "out3_rd"], "out3_r": ["out1_p", "out3_p", "out1_lr", "out3_lr"], "out0_l": ["out0_v", "out1_b", "out1_v", "out0_b"], "out1_l": ["out1_p", "out2_b", "out2_p", "out1_b"], "out2_l": ["out2_b", "out1_b", "out1_sl", "out2_sl"], "out3_l": ["out3_b", "out2_b", "out3_f", "out2_f"], "res0": ["Res1", "resolution50", "Res50", " res50", "Res4", "resolution1", " res4", "res50", "res4", "resolution4", "Res0", "resolution0"], "res1": ["Res1", "Res2", "pt1", "pt0", "Res3", "pt3", "ps1", "ps0", "ps2", "Res0", "ps3", "pt2"], "res2": ["rem0", "Res2", "Res1", "pres0", "rem2", "pres2", "rem3", "Res3", "pres1", "rem1", "Res0", "pres3"], "res3": ["out23", "res23", "vecThird", "pres23", "out3", "out03", "vec23", "outThird", "vec3", "res03", "vec03", "pres03", "presThird", "resThird", "pres3"], "filt0": ["fill1", "fract2", "falt2", "falt150", "ifilt0", "falt1", "felt1", "ifelt1", "ifelt2", "fill2", " falt150", "ifelt0", "font150", " falt2", "falt0", "font0", "felt0", "fract0", "ifilt1", "font1", " falt1", "fract1", "filt150", " filt150", " falt0", "felt2", "ifilt2", "fill150", "font2", "fill0"], "filt1": ["filOne", " filtOne", "fil2", "fil1", "falt2", "fail100", "firm0", "fiddle0", "fail1", "fail0", "fiddle1", "filtOne", "fail3", " filt3", "firmOne", "fil100", "falt1", " fil1", "firm1", "fil0", "filt3", "faltOne", " falt2", "fiddle100", "falt0", " fil100", " filt100", "fiddle3", "fil3", " falt1", "filt100", " falt0", " fil0", "firm2", " fil3", " faltOne"], "filt2": ["flt0", "ffilter2", "fil2", "firm0", "flt1", "Filt4", "firm2", " fil02", "ffit0", " filt4", "filt4", "ffit1", "fil0", "ffilter1", "Flt4", "ffilter4", "Filt2", "flt4", " fil2", "Flt0", "Filt0", "flt2", "felt0", "ffit2", "fil4", "Flt2", "firm02", "fil02", "Flt1", "ffit4", " fil4", "felt02", " filt02", "firm4", "filt02", "felt4", "ffilter0", "felt2", " fil0", "Filt1"]}}
{"project": "qemu", "commit_id": "6b33f3ae8b79726ef0812597b8a83c3e82d31514", "target": 0, "func": "static int img_commit(int argc, char **argv)\n\n{\n\n    int c, ret, flags;\n\n    const char *filename, *fmt, *cache, *base;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs, *base_bs;\n\n    bool progress = false, quiet = false, drop = false;\n\n    bool writethrough;\n\n    Error *local_err = NULL;\n\n    CommonBlockJobCBInfo cbi;\n\n    bool image_opts = false;\n\n    AioContext *aio_context;\n\n\n\n    fmt = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    base = NULL;\n\n    for(;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:ht:b:dpq\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 't':\n\n            cache = optarg;\n\n            break;\n\n        case 'b':\n\n            base = optarg;\n\n            /* -b implies -d */\n\n            drop = true;\n\n            break;\n\n        case 'd':\n\n            drop = true;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                return 1;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        return 1;\n\n    }\n\n\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    qemu_progress_init(progress, 1.f);\n\n    qemu_progress_print(0.f, 100);\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, QERR_BASE_NOT_FOUND, base);\n\n            goto done;\n\n        }\n\n    } else {\n\n        /* This is different from QMP, which by default uses the deepest file in\n\n         * the backing chain (i.e., the very base); however, the traditional\n\n         * behavior of qemu-img commit is using the immediate backing file. */\n\n        base_bs = backing_bs(bs);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, \"Image does not have a backing file\");\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    cbi = (CommonBlockJobCBInfo){\n\n        .errp = &local_err,\n\n        .bs   = bs,\n\n    };\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n\n                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,\n\n                        &local_err, false);\n\n    aio_context_release(aio_context);\n\n    if (local_err) {\n\n        goto done;\n\n    }\n\n\n\n    /* When the block job completes, the BlockBackend reference will point to\n\n     * the old backing file. In order to avoid that the top image is already\n\n     * deleted, so we can still empty it afterwards, increment the reference\n\n     * counter here preemptively. */\n\n    if (!drop) {\n\n        bdrv_ref(bs);\n\n    }\n\n\n\n    run_block_job(bs->job, &local_err);\n\n    if (local_err) {\n\n        goto unref_backing;\n\n    }\n\n\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n\n        ret = bs->drv->bdrv_make_empty(bs);\n\n        if (ret) {\n\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n\n                             filename);\n\n            goto unref_backing;\n\n        }\n\n    }\n\n\n\nunref_backing:\n\n    if (!drop) {\n\n        bdrv_unref(bs);\n\n    }\n\n\n\ndone:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        return 1;\n\n    }\n\n\n\n    qprintf(quiet, \"Image committed.\\n\");\n\n    return 0;\n\n}\n", "idx": 7069, "substitutes": {"argc": ["argC", "argcount", "numf", "genc", "argdc", "numcount", "genn", "arkc", "agcat", " argC", "agv", " argcat", "ortc", " argdc", "arkdc", " argf", "gendc", " argcount", "incv", "agp", "inccount", " argp", "numv", "argp", "argn", "ortp", "arkn", "argf", "ortcat", "arkC", "numc", "agc", "genC", "ortv", "incc", "argcat", "incf", " argn"], "argv": ["argsv", " argb", "arb", " argV", "agv", " argval", "arv", "argsV", "Argval", "argval", "arp", " argf", "argsc", "arc", "Argv", "argb", "argV", "ArgV", " argp", "argsf", "Argf", "argp", "agf", "argf", "agval", "argsp", "agc", "argsb", "Argc"], "c": ["ch", "anc", "unc", "cr", "v", "cur", "count", "s", "ci", "b", "nc", "rec", "i", "rc", "cy", "C", "m", "uc", "l", "cl", "f", " rc", "d", "cc", "ce", "cs", "arc", "u", "code", "con", "mc", "e", "sc", "col", "dc", "t", "n", "k", "ctx", "cb", "p", "ctrl", "ca", "ec", "h", "g", "ct", "cn", "lc", "cf", "fc", "orc", "ac", "r", "cm", "cd", "xc"], "ret": ["gc", "flag", "count", "val", "rc", "final", "enc", "cat", "reply", "ll", "status", "fl", "buffer", "len", "fn", "lib", "bc", "exec", "result", "re", "fs", "fd", "fi", "rec", "rets"], "flags": ["options", "fg", "files", "flag", "bits", "plugins", "features", "Flags", "comments", "mask", "status", "details", "ips", "vals", "FLAG", "parts", "forces", "stats", "fl", "args", " Flags", "cs", "ints", "fields", "ops", "locks", "ils", "fps", "settings", "fs", "utils", "changes", "fd", "lf", "reads"], "filename": ["abl", "options", "name", "files", "unc", "rb", "config", "username", "tmp", "Filename", "STDOUT", "password", "wb", "f", "url", "length", "document", "original", "which", "buffer", "acl", "file", "binary", "fn", "path", "fp", "dll", "rl", "output", "root", "txt", "fd", "il", "utf", "aml", "directory", "prefix"], "fmt": [" fMT", "fnt", "ffamily", "familyformat", "fformat", "Fformat", "fmd", "lmd", "filt", "lfilt", "fMT", "Ffamily", "lformat", "familyMT", " fnt", "rfMT", "Fnt", "Fmt", "rfnt", "lfmt", "lilt", " ffamily", "Filt", "rfmt", "FMT", "familyfamily", "familymt", "lfmd", " fformat", "Fmd", "lfformat", "rfformat", "lmt"], "cache": ["options", "cmp", "position", "play", "local", "store", "http", "chain", "config", "session", "pre", "sync", "enc", "cat", "comp", "queue", "bm", "ache", "cal", "f", "client", "table", "buffer", "acl", "file", "storage", "lib", "timeout", "lock", "coll", "p", "pool", "temp", "AC", "ca", "Cache", "ver", "memory", "lc", "clear", "cookie", "ac", "keep", "cas", "cdn", "prefix"], "base": ["bas", "name", "layer", "build", "clean", "position", "padding", "stable", "bin", "area", "builder", "local", "http", "store", "parent", "layout", "b", "object", "sync", "real", "stack", "print", "normal", "queue", "database", "body", "image", "format", "offset", "bat", "background", "url", "server", "state", "extra", "service", "buffer", "file", "lib", "bare", "source", "temp", "scale", "root", "Base", "batch", "shell", "tree", "api", "core", "board", "prefix"], "blk": ["flg", "flb", "Blks", "flk", "blg", "blb", " blb", " blks", "blks", "Blb", " blg", "Blg", "Blk", "flks"], "bs": ["bas", "BC", "lb", "ros", "BS", "ns", "ls", "bal", "cs", "ss", "ds", "bc", "ils", "fps", "ba", "Bs", "css", "gb", "fs", "SB", "bos", "bid", "bl", "aos", "pb", "rs", "ps"], "base_bs": ["server_ds", "base_bits", "server_bits", "server_bs", "base_ds", "server_fs", "base_fs"], "writethrough": ["Writethill", "writohrust", "Writetyill", "writetrill", "writetrrite", "writohrite", "writetyrite", "writetyill", "writetyrough", "Writetyrust", "writetyrust", "Writethrough", "writethill", "writohill", "Writethrite", "writohrough", "Writethrust", "writetrrust", "writethrust", "Writetyrite", "writethrite", "Writetyrough", "writetrrough"], "local_err": ["local_exc", "global_errors", "global_err", "global_exc", "global_error", "local_error", "local_errors"], "cbi": ["bcbi", "cBI", "cbf", "pcbi", "pcBI", "cfi", "lcBI", "bcfi", "lcfi", "lcbi", "bcbf", "bcBI", "pcbf", "lcbf", "pcfi"], "aio_context": ["aio_ctx", "aios_config", "aiodstorage", "aio_storage", "aiodconfig", "aiodcontext", "aiodctx", "aios_ctx", "aios_context", "aios_storage", "aio_config"], "long_options": ["short_option", "short_opt", "longcopyoptions", "long_opt", "short_options", "longcopyoption", "short_flags", "long_option", "longcopyflags", "long_config", "short_config", "long_flags", "longcopyconfig"], "opts": ["OPts", "OPcs", " opps", "operts", " opals", "opters", "optt", "opments", "operals", "opals", "optts", "optcs", "opps", " opks", "optks", " ops", "opcs", "optters", "operments", "ops", " opments", "OPters", "OPt", "opers", "opt", "OPments", "OPs", "optps", "OPks", " opcs", "OPps", " opt", "OPals", "opks", " opters"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)\n\n{\n\n    unsigned long stack_base, error, size;\n\n    int i;\n\n    int * stack;\n\n    int argc, envc;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = stack_size;\n\n\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1)\n\n        qerror(\"stk mmap\");\n\n\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size;\n\n    stack = (void*)stack_base;\n\n/*\n\n *    | STRING AREA |\n\n *    +-------------+\n\n *    |      0      |\n\n*    +-------------+\n\n *    |  apple[n]   |\n\n *    +-------------+\n\n *           :\n\n *    +-------------+\n\n *    |  apple[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    |    env[n]   |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    env[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    | arg[argc-1] |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    arg[0]   |\n\n *    +-------------+\n\n *    |     argc    |\n\n *    +-------------+\n\n * sp->    |      mh     | address of where the a.out's file offset 0 is in memory\n\n *    +-------------+\n\n*/\n\n    /* Construct the stack Stack grows down */\n\n    stack--;\n\n\n\n    /* XXX: string should go up there */\n\n\n\n    *stack = 0;\n\n    stack--;\n\n\n\n    /* Push the absolute path of our executable */\n\n    DPRINTF(\"pushing apple %s (0x%x)\\n\", (char*)argv[0], (int)argv[0]);\n\n    stl(stack, (int) argv[0]);\n\n\n\n    stack--;\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get envc */\n\n    for(envc = 0; env[envc]; envc++);\n\n\n\n    for(i = envc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing env %s (0x%x)\\n\", (char*)env[i], (int)env[i]);\n\n        stl(stack, (int)env[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    /* Add on the stack the interp_prefix choosen if so */\n\n    if(interp_prefix[0])\n\n    {\n\n        char *dyld_root;\n\n        asprintf(&dyld_root, \"DYLD_ROOT_PATH=%s\", interp_prefix);\n\n        page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)dyld_root);\n\n        stack--;\n\n    }\n\n\n\n#ifdef DONT_USE_DYLD_SHARED_MAP\n\n    {\n\n        char *shared_map_mode;\n\n        asprintf(&shared_map_mode, \"DYLD_SHARED_REGION=avoid\");\n\n        page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)shared_map_mode);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n#ifdef ACTIVATE_DYLD_TRACE\n\n    char * extra_env_static[] = {\"DYLD_DEBUG_TRACE=yes\",\n\n    \"DYLD_PREBIND_DEBUG=3\", \"DYLD_UNKNOW_TRACE=yes\",\n\n    \"DYLD_PRINT_INITIALIZERS=yes\",\n\n    \"DYLD_PRINT_SEGMENTS=yes\", \"DYLD_PRINT_REBASINGS=yes\", \"DYLD_PRINT_BINDINGS=yes\", \"DYLD_PRINT_INITIALIZERS=yes\", \"DYLD_PRINT_WARNINGS=yes\" };\n\n\n\n    char ** extra_env = malloc(sizeof(extra_env_static));\n\n    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));\n\n    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);\n\n\n\n    for(i = 0; i<9; i++)\n\n    {\n\n        DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extra_env[i], (int)extra_env[i]);\n\n        stl(stack, (int) extra_env[i]);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get argc */\n\n    for(argc = 0; argv[argc]; argc++);\n\n\n\n    for(i = argc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]);\n\n        stl(stack, (int) argv[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    DPRINTF(\"pushing argc %d \\n\", argc);\n\n    stl(stack, argc);\n\n    stack--;\n\n\n\n    DPRINTF(\"pushing mh 0x%x \\n\", (int)mh);\n\n    stl(stack, (int) mh);\n\n\n\n    /* Stack points on the mh */\n\n    return (unsigned long)stack;\n\n}\n", "idx": 7099, "substitutes": {"mh": [" mhs", "mhs", "mmhs", "mw", " mw", "tmH", "mmw", "tmw", "mmH", " mH", "tmhs", "mH", "mmh", "tmh"], "argv": [" argvin", "tagv", "axc", "argvin", "tagp", "Argp", " argV", "igV", "argh", "arv", "igf", "axp", " argh", "Argvs", " argl", "arp", "igv", "tagvin", " argf", "igvs", "Argv", "igp", " argvs", "argl", "argV", "Argl", "ArgV", "argvs", " argp", "igc", "arvin", "Argf", "argp", "tagh", "arh", "argf", "axl", "axv", "Argc"], "env": ["extra", "ea", "v", "el", "dat", "scope", "config", "qt", "edge", "vel", "environment", "password", "exc", "po", "enc", "style", "esp", "queue", "loc", "uv", "inet", "db", "inc", "export", "event", "ext", "bat", "server", "sl", "args", "eq", "net", "ss", "ev", "vs", "e", "code", "target", "que", "en", "inst", "dev", "file", "json", "esc", "path", "exec", "equ", "Environment", "context", "p", "ne", "ec", "stage", "vert", "iv", "sv", "doc", "console", "erv", "shell", "eni", "txt", "params", "cv", "app", "img", "conn", "end"], "stack_base": ["scale_length", " stack_orig", "scale_base", " stack_Base", " stack_b", "stack_root", "stack_b", "Stack_Base", "stack__base", "stack67length", "Stack_prefix", "stack_prefix", "stack_fixed", "stack_Base", "stack67base", "stack67root", "stack67origin", "Stack_base", "stack__b", "stack_origin", "stack__Base", "Stack_fixed", "stack__orig", "stack_length", "stack_orig", "scale_root", "scale_origin"], "error": ["patch", "address", "layer", "o", "large", "count", "parent", "unknown", "progress", "channel", "ception", "bug", "object", "exc", "or", "slice", "info", "debug", "status", "ERROR", "ace", "image", "resource", "rage", "event", "offset", "order", "call", "grade", "ack", "danger", "original", "ror", "number", "code", "e", "rss", "comment", "message", "err", "catch", "result", "raise", "scale", "root", "throw", "node", "back", "range", "errors", "notice", "type", "core", "oid", "success", "element", "index", "no", "trace", "Error", "warning"], "size": ["address", "fat", "name", "time", "SIZE", "large", "complete", "fee", "done", "shape", "send", "security", "ci", "edge", "grow", "sum", "si", "sn", "sync", "loc", "unit", "speed", "capacity", "offset", "grade", "weight", "call", "small", "Size", "align", "args", "len", "storage", "sized", "empty", "timeout", "ey", "scale", "ice", "global", "c", "range", "core", "iz", "cache", "ize", "form", "needed", "shift"], "i": ["base", "gi", "ti", "v", "id", "I", "count", "chi", "di", "ci", "ji", "ni", "x", "xi", "si", "io", "ri", "b", "abi", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "aci", "j", "ii", "iu", "my", "it", "ai", "init", "cli", "u", "vi", "e", "uri", "k", "n", "bc", "err", "mi", "ini", "multi", "ie", "p", "mini", "eni", "iv", "start", "oi", "hi", "c", "ip", "g", "y", "lc", "api", "li", "inner", "fi", "index", "r", "zi", "ui"], "stack": ["layer", "play", "shape", "progress", "check", "data", "stream", "queue", "ace", "reverse", "weight", "pop", "push", "buffer", "len", "code", "depth", "file", "history", "self", "array", "stage", "line", "tree", "index", "view", "tc", "function", "base", "pack", "st", "header", "count", "channel", "config", "layout", "list", "slice", "null", "Stack", "sl", "loop", "table", "ctx", "cycle", "str", "scale", "batch", "back", "site", "counter", "fr", "change", "box", "loc", "inc", "cl", "package", "cli", "wrap", "input", "pos", "level", "shell", "ul", "thread", "cache", "set", "trace", "pull", "store", "wrapper", "scope", "chain", "window", "offset", "wait", "call", "args", "ack", "roll", "forward", "load", "context", "console", "cv", "shift"], "argc": ["argci", "fileci", "argr", "filer", "envr", " argp", " argci", "filec", " argr", "envp", "argp", "envci", "filep"], "envc": ["arglc", "environmentc", "envdc", "ternct", "ecc", "argdc", "envv", "envcr", "espc", "endc", "envrc", "environmentrc", "encr", "envp", "environmentp", "envn", "ecl", "envcc", "enc", "environmentci", " envn", "argct", "ternc", " envv", " envl", "enn", "eccy", "envcy", "environmentct", "envl", "ternlc", "enrc", "environmentlc", "espcr", "ternn", "environmentr", "environmentv", "environmentcy", "environmentl", "argrc", "argn", "enp", "envct", "espp", " envcy", " envr", "environmentn", "ecv", "environmentdc", "enci", "encc", " envcc", "environmentcr", "envlc", "argcr", "envr", "espci", "environmentcc", "envci", "enr"], "dyld_root": ["dyld_prefix", "dyll_prefix", "dyld_leaf", "dyldalprefix", "dynd_prefix", "dyldapproot", "dyldaltheme", "dyll_root", "dyld00prefix", "dyld54roots", "dyld_start", "dyld54prefix", "dyld54root", "dyldalroot", "dyll_range", "dynd_theme", "dynd_roots", "dynd_root", "dyld54home", "dynd_home", "dyld_theme", "dyld00roots", "dyld_roots", "dyll_start", "dyld_home", "dyldapproots", "dyred_roots", "dyld_range", "dyldappstart", "dyldalroots", "dyll_roots", "dyld00range", "dyred_leaf", "dyldappprefix", "dyred_prefix", "dyred_root", "dyld00root"], "shared_map_mode": ["shared_maps\n", "shared_map\n", "shared_maps_mod", "shared_class\n", "shared_mapsget", "shared_mapget", "shared_map_mod", "shared_class\t", "shared_classget", "shared_table\t", "shared_maps_type", "shared_tableget", "shared_map\t", "shared_maps_settings", "shared_map_settings", "shared_maps_mode", "shared_maps\t", "shared_table\n", "shared_map_type"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status |= COM_CRC_ERROR;\n\n        rtype = sd_illegal;\n\n        goto send_response;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            rtype = sd_illegal;\n\n            goto send_response;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    if (rtype == sd_illegal) {\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n    }\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\nsend_response:\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    case sd_illegal:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 7105, "substitutes": {"sd": ["sf", "di", "ci", "sk", "d", "service", "td", "ay", "df", "sp", "sa", "gd", "lc", "dt", "li", "cm", "conn", "nd", "cd", "ti", "sed", "dn", "s", "dis", "sw", "sl", "dist", "sh", "sie", "sc", "sim", "ds", "lib", "sta", "south", "sv", "ld", "cod", "site", "std", "sec", "sy", "md", "bd", "vd", "sg", "dat", "sem", "sn", "ad", "ses", "ga", "sam", "esi", "des", "wd", "sb", "dev", "ic", "gb", "ind", "fd", "dl", "SD", "vc", "ed", "dm", "od", "dd", "pd", "si", "de", "dk", "sm", "ss", "se", "su", "report", "hd"], "req": ["gr", "cmp", "fr", "serv", "Request", "sr", "reg", "rt", "rr", "http", "qq", "pro", "spec", "progress", "rb", "config", "require", "sem", "ri", "rf", "required", "rh", "resource", "ru", "f", "client", "ra", "org", "dq", "call", "q", "res", "ctr", "ry", "conf", "def", "cmd", "ctx", "rx", "err", "exec", "loader", "cb", "str", " request", "request", "proc", "range", "ro", "resp", "sq", "report", "query", "hr", "desc", "ref", "src", "r", "requ", "rec", "worker", "view", "quest"], "response": ["o", "serv", "ret", "v", "Resp", "sw", "session", "object", "data", "Response", "reply", "image", "status", " responses", "resource", "server", " resp", "description", "res", "service", "answer", "document", "def", "e", "error", "connection", "respons", "en", "message", "json", "application", "err", "su", "result", "offer", "respond", "sp", "request", "given", "resp", "report", "model", "api", "success", "r", "onse", "view"], "rtype": ["rblock", "srpe", "rval", "prtype", "crset", "erblock", "rrblock", "lrtypes", "srval", "rtypes", "prstyle", "ertype", "nrtype", "artyp", "nrvalue", "nrtyp", "lrpe", "rpe", "rpy", "arclass", "nrbid", " rpe", "rvalid", "rarpe", "rrpy", "rsym", "rstyle", "rrvalue", "srsym", "rgtype", "rgsym", "rlTYPE", "srpart", "nrvalid", "rowner", "arpy", "rartype", "arpe", "rtyp", "rrtyp", "nrstyle", "rlstyle", "prbid", "rpart", "rrvalid", "erpy", "lrtyp", "prvalid", "nrpe", "crsym", "srset", "rlpe", "rset", "lrtype", "rTYPE", "artype", "crval", "rgset", "rltype", "arvalue", " rtyp", "rrclass", "crtype", " rTYPE", "artypes", "rclass", "arblock", "rgval", "rrbid", "srowner", "rvalue", "rarowner", "rbid", "srtype", " rpart", " rtypes", "rrstyle", "erclass", "nrTYPE", "arbid", " rowner", "rrtype", " rstyle", "rarpart"], "rsplen": ["rsquun", "rspeink", "rsplenn", "rssplenn", "rsclien", "rspallen", "wsplien", "rsperenn", "arssploen", "raspalen", "rsperink", "rsPlenc", "rspaline", "rspllen", "rsPlen", "arssplun", "rssleng", "rsiplen", "rsPln", "rssplens", "rssperz", "rspeenn", "rsiplens", " rspln", " rsplenc", "rsquice", "rssplink", "rsperen", "rspalenc", "rasplun", "rssplien", "rsplz", "rsspllen", "rsplink", " rspllen", "rsquenc", "rsplun", "rsiplun", "rasplen", "arspline", "rsslien", "rsprine", "rsspline", " rsblenc", "rsprlen", "rsbllen", "raspalun", "rssplz", "arsplun", "rsplens", " rsbllen", "rslen", "rsperz", "rspln", "arssplen", "rssperen", "rsploen", "raspalice", "rscelz", " rsblen", "rspren", "rsblen", "rsspleng", "rslens", "rspleng", "rssploen", "wspleng", "rasplenc", "rscln", "rssperenn", "rsPllen", "arsspllen", "rssperink", "arsplens", "rssplun", "rscelenn", "rsblenc", "rsplenc", "rsproen", "rslun", "rsspln", "rspalun", "arsspline", "rssplenc", "arspllen", "wssplien", "rssplen", "wspln", "rsslen", "wssplen", "rspalen", "rspaloen", "rsplice", "rsclenc", "arsplen", "rsplien", "rsllen", "rspline", "rscelen", "wsspleng", "rsipllen", " rsbln", "wsplen", "rspeen", "rsquen", "rspalice", "rscllen", "arsploen", "rssplice", "raspalenc", "rssln", "rsbln", "wsspln", "rspez", "rsclen", "rasplice", "rscleng", "arssplens", "rscelink"]}}
{"project": "qemu", "commit_id": "9646f4927faf68e8690588c2fd6dc9834c440b58", "target": 0, "func": "void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,\n\n                   uint32_t *eax, uint32_t *ebx,\n\n                   uint32_t *ecx, uint32_t *edx)\n\n{\n\n    X86CPU *cpu = x86_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t pkg_offset;\n\n\n\n    /* test if maximum index reached */\n\n    if (index & 0x80000000) {\n\n        if (index > env->cpuid_xlevel) {\n\n            if (env->cpuid_xlevel2 > 0) {\n\n                /* Handle the Centaur's CPUID instruction. */\n\n                if (index > env->cpuid_xlevel2) {\n\n                    index = env->cpuid_xlevel2;\n\n                } else if (index < 0xC0000000) {\n\n                    index = env->cpuid_xlevel;\n\n                }\n\n            } else {\n\n                /* Intel documentation states that invalid EAX input will\n\n                 * return the same information as EAX=cpuid_level\n\n                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)\n\n                 */\n\n                index =  env->cpuid_level;\n\n            }\n\n        }\n\n    } else {\n\n        if (index > env->cpuid_level)\n\n            index = env->cpuid_level;\n\n    }\n\n\n\n    switch(index) {\n\n    case 0:\n\n        *eax = env->cpuid_level;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 1:\n\n        *eax = env->cpuid_version;\n\n        *ebx = (cpu->apic_id << 24) |\n\n               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */\n\n        *ecx = env->features[FEAT_1_ECX];\n\n        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {\n\n            *ecx |= CPUID_EXT_OSXSAVE;\n\n        }\n\n        *edx = env->features[FEAT_1_EDX];\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;\n\n            *edx |= CPUID_HT;\n\n        }\n\n        break;\n\n    case 2:\n\n        /* cache info: needed for Pentium Pro compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = 1; /* Number of CPUID[EAX=2] calls required */\n\n        *ebx = 0;\n\n        if (!cpu->enable_l3_cache) {\n\n            *ecx = 0;\n\n        } else {\n\n            *ecx = L3_N_DESCRIPTOR;\n\n        }\n\n        *edx = (L1D_DESCRIPTOR << 16) | \\\n\n               (L1I_DESCRIPTOR <<  8) | \\\n\n               (L2_DESCRIPTOR);\n\n        break;\n\n    case 4:\n\n        /* cache info: needed for Core compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, count, eax, ebx, ecx, edx);\n\n            *eax &= ~0xFC000000;\n\n        } else {\n\n            *eax = 0;\n\n            switch (count) {\n\n            case 0: /* L1 dcache info */\n\n                *eax |= CPUID_4_TYPE_DCACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1D_LINE_SIZE - 1) | \\\n\n                       ((L1D_PARTITIONS - 1) << 12) | \\\n\n                       ((L1D_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1D_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 1: /* L1 icache info */\n\n                *eax |= CPUID_4_TYPE_ICACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1I_LINE_SIZE - 1) | \\\n\n                       ((L1I_PARTITIONS - 1) << 12) | \\\n\n                       ((L1I_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1I_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 2: /* L2 cache info */\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(2) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                if (cs->nr_threads > 1) {\n\n                    *eax |= (cs->nr_threads - 1) << 14;\n\n                }\n\n                *ebx = (L2_LINE_SIZE - 1) | \\\n\n                       ((L2_PARTITIONS - 1) << 12) | \\\n\n                       ((L2_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L2_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 3: /* L3 cache info */\n\n                if (!cpu->enable_l3_cache) {\n\n                    *eax = 0;\n\n                    *ebx = 0;\n\n                    *ecx = 0;\n\n                    *edx = 0;\n\n                    break;\n\n                }\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(3) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n                *eax |= ((1 << pkg_offset) - 1) << 14;\n\n                *ebx = (L3_N_LINE_SIZE - 1) | \\\n\n                       ((L3_N_PARTITIONS - 1) << 12) | \\\n\n                       ((L3_N_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L3_N_SETS - 1;\n\n                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;\n\n                break;\n\n            default: /* end of info */\n\n                *eax = 0;\n\n                *ebx = 0;\n\n                *ecx = 0;\n\n                *edx = 0;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */\n\n        if ((*eax & 31) && cs->nr_cores > 1) {\n\n            *eax |= (cs->nr_cores - 1) << 26;\n\n        }\n\n        break;\n\n    case 5:\n\n        /* mwait info: needed for Core compatibility */\n\n        *eax = 0; /* Smallest monitor-line size in bytes */\n\n        *ebx = 0; /* Largest monitor-line size in bytes */\n\n        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;\n\n        *edx = 0;\n\n        break;\n\n    case 6:\n\n        /* Thermal and Power Leaf */\n\n        *eax = env->features[FEAT_6_EAX];\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 7:\n\n        /* Structured Extended Feature Flags Enumeration Leaf */\n\n        if (count == 0) {\n\n            *eax = 0; /* Maximum ECX value for sub-leaves */\n\n            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */\n\n            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */\n\n            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {\n\n                *ecx |= CPUID_7_0_ECX_OSPKE;\n\n            }\n\n            *edx = 0; /* Reserved */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 9:\n\n        /* Direct Cache Access Information Leaf */\n\n        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xA:\n\n        /* Architectural Performance Monitoring Leaf */\n\n        if (kvm_enabled() && cpu->enable_pmu) {\n\n            KVMState *s = cs->kvm_state;\n\n\n\n            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);\n\n            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);\n\n            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);\n\n            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xB:\n\n        /* Extended Topology Enumeration Leaf */\n\n        if (!cpu->enable_cpuid_0xb) {\n\n                *eax = *ebx = *ecx = *edx = 0;\n\n                break;\n\n        }\n\n\n\n        *ecx = count & 0xff;\n\n        *edx = cpu->apic_id;\n\n\n\n        switch (count) {\n\n        case 0:\n\n            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;\n\n            break;\n\n        case 1:\n\n            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_cores * cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;\n\n            break;\n\n        default:\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;\n\n        }\n\n\n\n        assert(!(*eax & ~0x1f));\n\n        *ebx &= 0xffff; /* The count doesn't need to be reliable. */\n\n        break;\n\n    case 0xD: {\n\n        KVMState *s = cs->kvm_state;\n\n        uint64_t ena_mask;\n\n        int i;\n\n\n\n        /* Processor Extended State */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n            break;\n\n        }\n\n        if (kvm_enabled()) {\n\n            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n            ena_mask <<= 32;\n\n            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        } else {\n\n            ena_mask = -1;\n\n        }\n\n\n\n        if (count == 0) {\n\n            *ecx = 0x240;\n\n            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n                const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n                if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                    && ((ena_mask >> i) & 1) != 0) {\n\n                    if (i < 32) {\n\n                        *eax |= 1u << i;\n\n                    } else {\n\n                        *edx |= 1u << (i - 32);\n\n                    }\n\n                    *ecx = MAX(*ecx, esa->offset + esa->size);\n\n                }\n\n            }\n\n            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n            *ebx = *ecx;\n\n        } else if (count == 1) {\n\n            *eax = env->features[FEAT_XSAVE];\n\n        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {\n\n            const ExtSaveArea *esa = &x86_ext_save_areas[count];\n\n            if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                && ((ena_mask >> count) & 1) != 0) {\n\n                *eax = esa->size;\n\n                *ebx = esa->offset;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case 0x80000000:\n\n        *eax = env->cpuid_xlevel;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 0x80000001:\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = env->features[FEAT_8000_0001_ECX];\n\n        *edx = env->features[FEAT_8000_0001_EDX];\n\n\n\n        /* The Linux kernel checks for the CMPLegacy bit and\n\n         * discards multiple thread information if it is set.\n\n         * So don't set it here for Intel to make Linux guests happy.\n\n         */\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||\n\n                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||\n\n                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {\n\n                *ecx |= 1 << 1;    /* CmpLegacy bit */\n\n            }\n\n        }\n\n        break;\n\n    case 0x80000002:\n\n    case 0x80000003:\n\n    case 0x80000004:\n\n        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];\n\n        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];\n\n        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];\n\n        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];\n\n        break;\n\n    case 0x80000005:\n\n        /* cache info (L1 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \\\n\n               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);\n\n        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \\\n\n               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);\n\n        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);\n\n        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);\n\n        break;\n\n    case 0x80000006:\n\n        /* cache info (L2 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \\\n\n               (L2_DTLB_2M_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \\\n\n               (L2_ITLB_2M_ENTRIES);\n\n        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \\\n\n               (L2_DTLB_4K_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \\\n\n               (L2_ITLB_4K_ENTRIES);\n\n        *ecx = (L2_SIZE_KB_AMD << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \\\n\n               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);\n\n        if (!cpu->enable_l3_cache) {\n\n            *edx = ((L3_SIZE_KB / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);\n\n        } else {\n\n            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);\n\n        }\n\n        break;\n\n    case 0x80000007:\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_8000_0007_EDX];\n\n        break;\n\n    case 0x80000008:\n\n        /* virtual & phys address size in low 2 bytes. */\n\n        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n            /* 64 bit processor, 48 bits virtual, configurable\n\n             * physical bits.\n\n             */\n\n            *eax = 0x00003000 + cpu->phys_bits;\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n", "idx": 7109, "substitutes": {"env": ["energy", "el", "environment", "oa", "et", "queue", "gui", "ench", "conf", "ev", "code", "zone", "her", "exec", "err", "equ", "Environment", "ec", "output", "stage", "vert", "dt", "engine", "conn", "vm", "config", "qt", "edge", "nc", "inet", "eu", "cal", "eye", "server", "assets", "ctx", "ini", "ne", "viron", "doc", "eve", "txt", "essential", "site", "end", "external", "eng", "exc", "db", "ext", "org", "obj", "net", "ce", "np", "vs", "e", "que", "en", "network", "global", "erv", "het", "eur", "cache", "app", "loader", "enable", "fen", "ea", "v", "scope", "enc", "uv", "event", "args", "init", "kernel", "context", "eni", "console", "cv", "host", "manager", "cdn"], "index": ["position", "x", "object", "localhost", "queue", "unit", "weight", "active", "match", "code", "len", "error", "depth", "connection", "output", "page", "engine", "current", "expression", "axis", "header", "id", "fee", "value", "list", "val", "update", "slice", "pattern", "info", "office", "url", "table", "number", "path", "ini", "ticket", "search", "node", "type", "element", "site", "tail", "end", "size", "condition", "address", "image", "loc", "inc", "key", "num", "version", "action", "instance", "timeout", "input", "pos", "level", "ind", "thread", "cache", "prefix", "find", "offset", "length", "example", "context", "pointer", "Index", "host", "date", "diff"], "count": ["cmp", "append", "last", "child", "call", "weight", "length", "cc", "code", "len", "col", "depth", "path", "empty", "Count", "seq", "batch", "start", "head", "core", "cache", "current", "max", "found", "counter"], "eax": ["ieac", " eAx", "ebase", "eix", "eag", "ebax", "oeax", "Eaj", "oexa", "oeas", "ebak", "iease", "ieaz", "eAx", "ceaped", " eass", "eeax", "eaped", " ease", "eeau", "ieau", "eaz", " eaj", "eas", " exa", " eac", " eAX", "eaag", "enass", "ieAx", "eeix", "enap", "oeaped", "eak", "ieAX", " eap", "eeaz", "exa", "ease", "EAX", "eaj", "Eac", "ieaj", "eass", "eac", "Eax", "eAX", "eap", " eak", " eag", "eaass", " eaz", " eas", "ieix", "ieax", "ceas", "ceax", " eix", "ebAx", "eaax", "cexa", "enax", "eau", " eau", " eaped", "ieak", "enag", "eaap"], "ebx": ["debux", "ecf", "ecg", " ebxx", "ebax", "egy", "ebux", "egx", " ebw", "ekw", "egz", "egX", "debX", "debg", "edX", "debx", "ekx", " ebis", "ebz", "ebw", "egb", " eby", "ebX", "edis", "ecb", "ecX", "edb", "ecax", "edex", "edax", "ebg", "ecy", "ecxx", "ebex", "egex", "ekux", "edz", "ecex", "ekX", "ecz", "ebxx", "egxx", "egf", "ebf", "ecux", "edf", "edy", "edw", "ebb", "ekz", "egax", "ebis", "ekg", "ekis", " ebz", "eby"], "ecx": ["ECx", "ecg", " ecid", "egv", "ECxi", "ect", "esclex", "egx", " ecz", "ebp", "eqex", "execz", " ecxx", "evg", "evp", "edX", "egg", "evx", "ebz", "execex", " ecv", "ebX", "eclex", "ECax", "ecX", "esct", "ecax", "edex", "eqx", "ecid", "efv", "edax", "edid", "eqt", "ebg", "escv", " ect", "edxi", "efz", "ecxx", "execX", "eqxi", "efx", "efxx", " ecX", "edz", "ecex", "ecxi", "ecz", "ebex", "ebxx", "eqlex", " eclex", "eqax", "execxx", "evv", "eqv", "ecv", "ecp", "execx", "escx", "ebv", "ECex", "egp", "execv", "edxx", "ebid"], "edx": ["EDex", "endedX", "ecn", "nedex", "nedX", "edix", "egx", "dedz", "egX", "aedz", "evex", " edex", "dedx", "edX", "endedx", "evx", "egix", "idX", "ebX", "aedx", "ecX", "EDX", "EDx", "nedany", "edex", "idax", "ecax", "edax", "idx", "idex", " edany", "endedax", "aedtx", "edtx", "dedex", "edn", "ebex", "evz", "edz", "ecex", "EDn", "egex", "nedx", " edix", " edX", "endedex", "ecix", "ebn", "edany", "ecany", "evtx", "dedtx", "aedex"], "cpu": ["cp", "cmp", "pid", "cfg", "hw", "python", "chip", "intel", "pu", "vm", "component", "config", "nc", "gpu", "module", "uu", "px", "cm", "unit", "obj", "pc", "linux", "net", "np", "nic", "proxy", "clock", "n", "ctx", "instance", "bc", "kernel", "loader", "process", "pool", "processor", "css", "boot", "eni", "console", "node", "c", "utils", "proc", "GPU", "cn", "core", "lc", "fc", "cache", "cpp", "CPU", "conn"], "cs": ["cp", "cmp", "Cs", "act", "cks", "spec", "ci", "nc", "rc", "cus", "cells", "sys", "co", "cross", "js", "sk", "ns", "stats", "ls", "pc", "args", "cc", "bs", "cons", "CS", "vs", "sc", "ics", "ops", "ks", "ds", "qs", "ctx", "wcs", "bc", "ts", "ces", "ils", "coll", "ec", "ca", "css", "acks", "fs", "acs", "utils", "c", "os", "ys", "cn", "lc", "cf", "core", "vc", "rs", "ras", "cas", "ps", "conn"], "pkg_offset": ["work2sort", "work_num", "pkg2num", "work2offset", "pkg__num", "work_sort", "pkg_length", "pkglnum", "work_offset", "pkgloffset", "pkg__offset", "pkg2length", "pkgllength", "pkg2sort", "pkg__length", "work2num", "pkg__sort", "work2length", "pkglsort", "work_length", "pkg2offset", "pkg_num", "pkg_sort"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)\n\n{\n\n    char *argstr_flat;\n\n    wchar_t **argv_w;\n\n    int i, buffsize = 0, offset = 0;\n\n\n\n    if (win32_argv_utf8) {\n\n        *argc_ptr = win32_argc;\n\n        *argv_ptr = win32_argv_utf8;\n\n        return;\n\n    }\n\n\n\n    win32_argc = 0;\n\n    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);\n\n    if (win32_argc <= 0 || !argv_w)\n\n        return;\n\n\n\n    /* determine the UTF-8 buffer size (including NULL-termination symbols) */\n\n    for (i = 0; i < win32_argc; i++)\n\n        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                        NULL, 0, NULL, NULL);\n\n\n\n    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);\n\n    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);\n\n    if (win32_argv_utf8 == NULL) {\n\n        LocalFree(argv_w);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < win32_argc; i++) {\n\n        win32_argv_utf8[i] = &argstr_flat[offset];\n\n        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                      &argstr_flat[offset],\n\n                                      buffsize - offset, NULL, NULL);\n\n    }\n\n    win32_argv_utf8[i] = NULL;\n\n    LocalFree(argv_w);\n\n\n\n    *argc_ptr = win32_argc;\n\n    *argv_ptr = win32_argv_utf8;\n\n}\n", "idx": 7111, "substitutes": {"argc_ptr": ["argv_tr", "argv_dep", "argc_dra", "argc__ptr", "argv_Ptr", "argc__dra", "argc_ref", "argc_Ptr", "argv_pointer", "argv_dra", "argc__dr", "argc_dr", "argv_ref", "argc_pointer", "argc_tr", "argc__pointer", "argc_dep", "argv_dr"], "argv_ptr": ["argv___wr", "argv___eth", "argc_priv", "argc_eth", "argv_rot", "argc_pt", "argv_loc", "argc_loc", "argv___ptr", "argv_pointer", "argv_eth", "argv___pointer", "argv___rot", "argv___pt", "argv_priv", "argc_pointer", "argc_wr", "argc_rot", "argv_pt", "argv_wr"], "argstr_flat": ["argc_flat", "argstr__fast", "argc_fl", "argstr_fast", "argstr_atten", "argstr__fl", "argv_fl", "argv_full", "argstr_layout", "argstr_thin", "argv_fast", "argstr__full", "argv_thin", "argstr__thin", "argstr_fl", "argstr__flat", "argstr__layout", "argstr_pat", "argstr_full", "argc_atten", "argc_pat", "argv_flat", "argv_layout"], "argv_w": ["argv_hw", "argv25w", "argc2y", "argc_raw", "argv_y", "argc_W", "argv__r", "argc_r", "argv_r", "argv2v", "argv_v", "argv25hw", "argvadws", "argv_wa", "argc2ws", "argv_orig", "argv25ws", "argv__ws", "argv__wan", "argvPwx", "argv_ws", "argc2w", "argv__wb", "argc_hw", "argc_orig", "argv_W", "argv2w", "argc_ws", "argv2ws", "argc_v", "argv__v", "argc_w", "argv__y", "argv_wx", "argv_wb", "argc_wa", "argvadwa", "argv25wan", "argv_tw", "argv_wan", "argvPw", "argc_y", "argv_raw", "argc_tw", "argc2v", "argv25r", "argc_wx", "argvadtw", "argvPhw", "argvadw", "argv__w", "argv__W", "argvPws", "argv2y", "argc_wb", "argv25wx", "argc_wan"], "i": ["gi", "name", "o", "ti", "v", "id", "I", "a", "di", "ci", "phi", "ni", "x", "b", "io", "si", "ri", "xi", "slice", "info", "bi", "m", "abi", "qi", "in", "ix", "key", "l", "offset", "pi", "at", "f", "yi", "j", "ii", "d", "it", "iu", "ai", "init", "q", "u", "cli", "e", "part", "uri", "t", "n", "field", "multi", "mi", "ini", "ie", "p", "source", "h", "z", "start", "oi", "hi", "c", "ip", "g", "y", "lc", "li", "inner", "fi", "index", "ui"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 7119, "substitutes": {"op0": ["ip2", "opt0", "op_", " op_", "hop1", "pop0", "op00", "oper1", "opt2", " op90", "oc8", " op6", " op8", "opt1", "oper00", "op2", "hop0", "option0", "mp8", "mp6", "op90", "op6", "oc0", "oc00", " op5", "hop90", "option1", "option2", " op2", "mp00", "mp0", "op8", "op5", "pop90", "oper0", "option00", "ip_", "ip0", "pop5", "pop1", "ip1", "oper2", "hop_", "hop00", "hop5", "oc6", " op00", "hop2"], "op1": ["ip2", "opt0", "hop1", "ip8", "hop8", "OP0", "opt2", "opt1", "OP2", "apOne", " op01", "op2", "hop0", "ip01", "opOne", " opOne", "opt8", "OP1", "OP8", " op2", "op8", "ip0", "ip1", "ap0", "op01", "ap1", "ap01", "ipOne", " op8", "hop2"], "size": ["address", "name", "SIZE", "large", "sec", "fee", "shape", "style", "sync", "use", "enc", "loc", "capacity", "call", "weight", "small", "Size", "align", "number", "code", "six", "out", "n", "sized", "timeout", "empty", "scale", "c", "g", "type", "core", "cache", "ize", "form"]}}
{"project": "FFmpeg", "commit_id": "2f996b8397ee0e646a824f3dfcbd291a114af348", "target": 0, "func": "int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n", "idx": 7122, "substitutes": {"avctx": [" avcontext", "ajconfig", "avca", "afca", " avconfig", "apcontext", "afcb", "acca", " avcca", "avconfig", "avcca", "avcb", "afctx", "apctx", "apcb", "avcontext", "ajcca", "acctx", "accontext", "afcontext", "afconfig", "ajctx", "ajcontext", "afcca", "apca", "accb"], "frame": ["scene", "base", "game", "flow", "dy", "time", "position", "header", "channel", "iframe", "family", "format", "face", "slice", "image", "Frame", "draw", "window", "fake", "f", "event", "series", "document", "property", "code", "buffer", "point", "part", "message", "fram", "file", "cycle", "source", "scale", "line", "setup", "type", "video", "frames", "board", "sample", "element", "fi", "stroke", "feature"], "buf_size": ["buf0size", "window_type", "bufingstring", "buf_sized", "queue_sized", "buf0scale", " buf_string", " buf_SIZE", "window_size", "buf_len", "buf_level", "bufftype", "bufingcode", "queue_source", "window_len", "buf_type", "buf_code", "buf0source", "windowflen", "windowftype", "windowflevel", "windowfsize", "queue_size", "bufingsize", "queue_scale", "buf_scale", " buf_code", "buf_SIZE", "buf0sized", "bufflen", "buf_string", "bufflevel", "window_level", "buffsize", "bufingSIZE", "buf_source"], "data": ["base", "o", "block", "id", "a", "parent", "done", "dat", "device", "final", "family", "format", "database", "info", "m", "image", "body", "missing", "draw", "window", "package", "f", "content", "media", "d", "DATA", "buffer", "e", "message", "Data", "empty", "source", "p", "input", "result", "scale", "xxx", "zero", "start", "none", "api", "video", "board", "sample", "cache", "next", "partial", "size"], "s": ["as", "o", "sec", "is", "S", "a", "comm", "spec", "scope", "session", "com", "si", "sync", "enc", "sys", "ses", "services", "m", "xs", "private", "f", "client", "parts", "ns", "d", "ls", "space", "service", "cs", "ss", "u", "e", "sc", "an", "w", "sb", "bis", "ds", "t", "n", "ctx", "p", "aws", "fs", "sup", "sa", "c", "ssl", "sq", "sym", "ps", "js"], "num": ["uni", "o", "na", "iter", "bin", "id", "count", "ni", "val", "sum", "b", "x", "umi", "update", "info", "unit", "loc", "uu", "inc", "f", "offset", "nr", "init", "u", "number", "len", "con", "en", "Num", "fn", "n", "NUM", "multi", "su", "result", "pos", "gen", "off", "orig", "ul", "um", "mu", "index", "no", "dim", "end", "ui", "nu"], "i": ["ti", "id", "I", "ci", "b", "si", "io", "umi", "m", "in", "f", "pi", "j", "ii", "it", "ai", "init", "u", "n", "mi", "p", "c", "ip", "ind", "li", "inner", "index", "ui"]}}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125, "substitutes": {"s": ["o", "serv", "sf", "v", "S", "http", "spec", "session", "b", "socket", "si", "i", "sync", "sys", "ses", "services", "m", "l", "f", "side", "ns", "usb", "state", "d", "ls", "sl", "space", "service", "ss", "conf", "sports", "u", "sis", "e", "sie", "sb", "gs", "sim", "se", "secondary", "ds", "t", "n", "storage", "ts", "su", "self", "p", "south", "sv", "c", "os", "g", "ssl", "sq", "sym", "site", "src", "es", "r", "ps", "js"], "buf": ["cmp", "feed", "buff", "vec", "header", "bd", "rb", "config", "b", "data", "rc", "queue", "uc", "fb", "db", "uf", "wb", "f", "lim", "num", "bb", "img", "buffer", "que", "bag", "Buffer", "port", "cmd", "ctx", "path", "bc", "cb", "fp", "loader", "coord", "seq", "req", "batch", "msg", "prop", "alloc", "bf", "fd", "cf", "br", "pb", "src", "cas", "bh", "ff", "prefix"], "len": ["base", "block", "el", "count", "list", "val", "data", "lt", "lan", "ll", "in", "l", "num", "offset", "f", "fin", "limit", "length", "fl", "all", "en", "fn", "n", "lon", "seq", "pos", "line", "Len", "ln", "lc", "lin", "li", "cache", "lf", "lim", "end", "size"], "res": ["gr", "nos", "row", "ris", "reset", "reg", "red", "cr", "ret", "id", "rr", "sr", "block", "ress", "progress", "pre", "Res", "val", "x", "rc", "rec", "rel", "details", "rh", "results", "rest", "ries", "ras", "des", "resolution", "e", "rss", "rez", "error", "rus", "arr", "rx", "err", "response", "rev", "result", "pres", "seq", "resh", "req", "css", "re", "pos", "mr", "ver", "os", "RES", "resp", "ms", "ps", "hr", "rs", "no", "r", "rem", "max", "rar"], "counter": ["master", "cmp", "row", "fr", "Counter", "er", "iter", "count", "entry", "parent", "total", "prev", "race", "num", "order", "server", "length", "nr", "loop", "ctr", "outer", "number", "code", "per", "clock", "arr", "timer", "field", "loader", "result", "seq", "ounter", "ner", "sp", "pointer", "ver", "c", "page", "inner", "cache", "r", "trace"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_b_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status;\n\n\n\n    bitplane_decoding(&v->skip_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    if (v->mv_mode == MV_PMODE_MIXED_MV)\n\n    {\n\n        status = bitplane_decoding(&v->mv_type_mb_plane, v);\n\n        if (status < 0)\n\n            return -1;\n\n#if TRACE\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n    }\n\n\n\n    //bitplane\n\n    status = bitplane_decoding(&v->direct_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"Skip MB plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    /* FIXME: what is actually chosen for B frames ? */\n\n    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables\n\n    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];\n\n\n\n    if (v->dquant)\n\n    {\n\n        vop_dquant_decoding(v);\n\n    }\n\n\n\n    if (v->vstransform)\n\n    {\n\n        v->ttmbf = get_bits(gb, 1);\n\n        if (v->ttmbf)\n\n        {\n\n            v->ttfrm = get_bits(gb, 2);\n\n            av_log(v->s.avctx, AV_LOG_INFO, \"Transform used: %ix%i\\n\",\n\n                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);\n\n        }\n\n    }\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return 0;\n\n}\n", "idx": 7130, "substitutes": {"v": ["nv", "vol", "ch", "serv", "vr", "o", "a", "vd", "vm", "s", "value", "V", "va", "vt", "b", "vic", "inv", "i", "x", "m", "uv", "l", "gu", "f", "conv", "version", "j", "av", "ve", "ii", "q", "server", "d", "tv", "ev", "vi", "vs", "e", "u", "w", "dev", "k", "t", "n", "vin", "volt", "rev", "p", "temp", "this", "h", "vp", "sv", "iv", "vert", "ver", "c", "var", "g", "lv", "ov", "video", "vv", "cv", "vc", "r", "view"], "gb": ["game", "gp", "gc", "hw", "cfg", "cgi", "lb", "dm", "vg", "phy", "gm", "hub", "vd", "ci", "rb", "Gb", "bg", "b", "bps", "rc", "bm", "ko", "gom", "uv", "db", "xy", "pm", "ga", "abb", "gin", "pc", "gz", "py", "eb", "sb", "gs", "rg", "bis", "storage", "lib", "ctx", "bc", "GB", "cb", "nb", "bridge", "mb", "gy", "kb", "ge", "gh", "g", "bf", "gd", "lv", "gt", "lc", "gg", "cv", "vc", "git", "mode", "ui"], "status": ["progress", "check", "x", "ex", "style", "data", "unit", "speed", "job", "state", "weight", "used", "magic", "active", "service", "code", "error", "pass", "err", "stage", "output", "sp", "current", "git", "index", "msg", "name", "header", "id", "count", "spec", "s", "update", "val", "info", "xml", "ix", " Status", "content", "url", "enabled", "sc", "comment", "str", "score", "ity", "settings", "type", "class", "text", "summary", "ui", "size", "uses", "stat", "days", "sr", "plugins", "security", "use", "sync", "num", "source", "temp", "css", "level", "ssl", "api", "prefix", "login", "options", "gc", "complete", "skip", "si", "details", "order", "wait", "stats", "sql", "full", "result", "seq", "step", "Status", "success", "date", "min", "js"]}}
{"project": "FFmpeg", "commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "target": 1, "func": "static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        MXFTrack *track = s->streams[i]->priv_data;\n\n        /* SMPTE 379M 7.3 */\n\n        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n\n            return i;\n\n    }\n\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n\n    return s->nb_streams == 1 ? 0 : -1;\n\n}\n", "idx": 7150, "substitutes": {"s": ["o", "sf", "S", "less", "http", "spec", "a", "ows", "als", "b", "si", "events", "rows", "ses", "services", "m", "its", "ions", "support", "l", "f", "ns", "d", "sl", "ls", "args", "service", "cs", "ss", "u", "e", "sc", "sb", "gs", "ks", "ops", "ds", "qs", "n", "ctx", "t", "ts", "su", "self", "ings", "p", "south", "acks", "fs", "c", "os", "g", "ssl", "sq", "es", "lines", "rs", "src", "ps", "js"], "klv": ["okvl", "cknv", "kvl", "ksvl", "Klf", "gnv", "ckvl", "kslv", "kLV", "oklv", "Kvl", "ckLV", "klf", "sknv", "skLV", "Klv", "oklf", "skvl", "okwl", "glv", "kswl", "knv", "gLV", "Kwl", "gvl", "sklv", "kwl", "kslf", "cklv"], "i": ["gi", "r", "o", "ti", "v", "id", "I", "a", "di", "ci", "x", "ni", "xi", "ri", "si", "io", "slice", "abi", "b", "info", "bi", "m", "in", "qi", "ix", "l", "key", "gu", "f", "pi", "phi", "j", "ii", "d", "iu", "it", "ai", "u", "e", "ami", "uri", "k", "t", "n", "field", "multi", "mi", "ini", "ie", "p", "one", "h", "mini", "eni", "z", "start", "sup", "oi", "c", "ip", "li", "ed", "fi", "index", "zi", "mu", "ui"], "track": ["dr", "cmp", "row", "acc", "check", "jump", "sort", "pp", "tr", "data", "sync", "token", "stream", "record", "info", "m", "draw", "event", "post", "project", "call", "ack", "match", "roll", "round", "ck", "Track", "t", "tm", "step", "node", "tracks", "type", "report", "transform", "rack", "tt", "rank", "test", "form", "index", "group", "app", "rec", "trace"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_mc_1mv(VC1Context *v, int dir)\n\n{\n\n    MpegEncContext *s = &v->s;\n\n    H264ChromaContext *h264chroma = &v->h264chroma;\n\n    uint8_t *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int v_edge_pos = s->v_edge_pos >> v->field_mode;\n\n    int i;\n\n    uint8_t (*luty)[256], (*lutuv)[256];\n\n    int use_ic;\n\n\n\n    if ((!v->field_mode ||\n\n         (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) &&\n\n        !v->s.last_picture.f.data[0])\n\n        return;\n\n\n\n    mx = s->mv[dir][0][0];\n\n    my = s->mv[dir][0][1];\n\n\n\n    // store motion vectors for further use in B frames\n\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n\n        for (i = 0; i < 4; i++) {\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx;\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my;\n\n        }\n\n    }\n\n\n\n    uvmx = (mx + ((mx & 3) == 3)) >> 1;\n\n    uvmy = (my + ((my & 3) == 3)) >> 1;\n\n    v->luma_mv[s->mb_x][0] = uvmx;\n\n    v->luma_mv[s->mb_x][1] = uvmy;\n\n\n\n    if (v->field_mode &&\n\n        v->cur_field_type != v->ref_field_type[dir]) {\n\n        my   = my   - 2 + 4 * v->cur_field_type;\n\n        uvmy = uvmy - 2 + 4 * v->cur_field_type;\n\n    }\n\n\n\n    // fastuvmc shall be ignored for interlaced frame picture\n\n    if (v->fastuvmc && (v->fcm != ILACE_FRAME)) {\n\n        uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1));\n\n        uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1));\n\n    }\n\n    if (!dir) {\n\n        if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) {\n\n            srcY = s->current_picture.f.data[0];\n\n            srcU = s->current_picture.f.data[1];\n\n            srcV = s->current_picture.f.data[2];\n\n            luty  = v->curr_luty;\n\n            lutuv = v->curr_lutuv;\n\n            use_ic = v->curr_use_ic;\n\n        } else {\n\n            srcY = s->last_picture.f.data[0];\n\n            srcU = s->last_picture.f.data[1];\n\n            srcV = s->last_picture.f.data[2];\n\n            luty  = v->last_luty;\n\n            lutuv = v->last_lutuv;\n\n            use_ic = v->last_use_ic;\n\n        }\n\n    } else {\n\n        srcY = s->next_picture.f.data[0];\n\n        srcU = s->next_picture.f.data[1];\n\n        srcV = s->next_picture.f.data[2];\n\n        luty  = v->next_luty;\n\n        lutuv = v->next_lutuv;\n\n        use_ic = v->next_use_ic;\n\n    }\n\n\n\n    if (!srcY || !srcU) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Referenced frame missing.\\n\");\n\n        return;\n\n    }\n\n\n\n    src_x   = s->mb_x * 16 + (mx   >> 2);\n\n    src_y   = s->mb_y * 16 + (my   >> 2);\n\n    uvsrc_x = s->mb_x *  8 + (uvmx >> 2);\n\n    uvsrc_y = s->mb_y *  8 + (uvmy >> 2);\n\n\n\n    if (v->profile != PROFILE_ADVANCED) {\n\n        src_x   = av_clip(  src_x, -16, s->mb_width  * 16);\n\n        src_y   = av_clip(  src_y, -16, s->mb_height * 16);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->mb_width  *  8);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->mb_height *  8);\n\n    } else {\n\n        src_x   = av_clip(  src_x, -17, s->avctx->coded_width);\n\n        src_y   = av_clip(  src_y, -18, s->avctx->coded_height + 1);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->avctx->coded_width  >> 1);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->avctx->coded_height >> 1);\n\n    }\n\n\n\n    srcY += src_y   * s->linesize   + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n\n\n    if (v->field_mode && v->ref_field_type[dir]) {\n\n        srcY += s->current_picture_ptr->f.linesize[0];\n\n        srcU += s->current_picture_ptr->f.linesize[1];\n\n        srcV += s->current_picture_ptr->f.linesize[2];\n\n    }\n\n\n\n    /* for grayscale we should not try to read from unknown area */\n\n    if (s->flags & CODEC_FLAG_GRAY) {\n\n        srcU = s->edge_emu_buffer + 18 * s->linesize;\n\n        srcV = s->edge_emu_buffer + 18 * s->linesize;\n\n    }\n\n\n\n    if (v->rangeredfrm || use_ic\n\n        || s->h_edge_pos < 22 || v_edge_pos < 22\n\n        || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3\n\n        || (unsigned)(src_y - 1)        > v_edge_pos    - (my&3) - 16 - 3) {\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize;\n\n\n\n        srcY -= s->mspel * (1 + s->linesize);\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY,\n\n                                 s->linesize, s->linesize,\n\n                                 17 + s->mspel * 2, 17 + s->mspel * 2,\n\n                                 src_x - s->mspel, src_y - s->mspel,\n\n                                 s->h_edge_pos, v_edge_pos);\n\n        srcY = s->edge_emu_buffer;\n\n        s->vdsp.emulated_edge_mc(uvbuf, srcU,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        s->vdsp.emulated_edge_mc(uvbuf + 16, srcV,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n        /* if we deal with range reduction we need to scale source blocks */\n\n        if (v->rangeredfrm) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = ((src[i] - 128) >> 1) + 128;\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = ((src[i]  - 128) >> 1) + 128;\n\n                    src2[i] = ((src2[i] - 128) >> 1) + 128;\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        /* if we deal with intensity compensation we need to scale source blocks */\n\n        if (use_ic) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ;\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = luty[f][src[i]];\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1);\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = lutuv[f][src[i]];\n\n                    src2[i] = lutuv[f][src2[i]];\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        srcY += s->mspel * (1 + s->linesize);\n\n    }\n\n\n\n    if (s->mspel) {\n\n        dxy = ((my & 3) << 2) | (mx & 3);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0]    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd);\n\n        srcY += s->linesize * 8;\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd);\n\n    } else { // hpel mc - always used for luma\n\n        dxy = (my & 2) | ((mx & 2) >> 1);\n\n        if (!v->rnd)\n\n            s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n        else\n\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n    }\n\n\n\n    if (s->flags & CODEC_FLAG_GRAY) return;\n\n    /* Chroma MC always uses qpel bilinear */\n\n    uvmx = (uvmx & 3) << 1;\n\n    uvmy = (uvmy & 3) << 1;\n\n    if (!v->rnd) {\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    } else {\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    }\n\n}\n", "idx": 7168, "substitutes": {"v": ["nv", "vim", "vol", "o", "vg", "vd", "vm", "V", "va", "vt", "vic", "b", "x", "inv", "m", "uv", "l", "f", "conv", "version", "ve", "av", "ii", "service", "tv", "vi", "u", "vs", "ev", "e", "w", "en", "dev", "t", "k", "n", "vin", "volt", "rev", "p", "h", "vp", "sv", "iv", "vert", "ver", "c", "g", "lv", "ov", "video", "vv", "cv", "vc", "vu"], "dir": ["dy", "dr", "Dir", "diff", "block", "id", "cur", "md", "dn", "di", "spec", "device", "sort", "config", "manager", "or", "rel", "dest", "DIR", "circ", "module", "m", "loc", "db", "ir", "f", "attr", "ext", "order", "url", "d", "iver", "ii", "dist", "def", "wd", "uri", "file", "dc", "directory", "lib", "path", "direct", "lock", "source", "coll", "req", "draft", "direction", "doc", "ind", "c", "dep", "orient", "desc", "group", "img", "grad", "rec", "dim"], "s": ["serv", "sf", "S", "a", "b", "f", "d", "service", "conf", "w", "sound", "self", "g", "sym", "is", "spec", "services", "server", "sl", "ls", "sc", "sh", "sim", "ds", "ts", "share", "settings", "sv", "fs", "sq", "site", "rs", "summary", "sync", "ses", "conv", "cs", "u", "vs", "e", "submit", "sb", "ks", "secondary", "t", "qs", "p", "network", "c", "os", "ssl", "sup", "r", "ps", "o", "http", "scope", "session", "com", "si", "sys", "m", "in", "l", "ns", "ve", "series", "us", "ss", "gs", "se", "storage", "n", "su", "es", "js"], "h264chroma": ["h164chroman", "h264capba", "h264comba", "h264gena", "h264comama", "hwmcomb", "h264pixela", "h264capb", "h264chromama", "h164chromi", "h264cssa", "h164pixela", "h164chroma", "h264comb", "h264pixelan", "h264chromi", "hwmchromba", "h264pixelca", "h264chromca", "h164pixeli", "hwmcoma", "hwmchromama", "h264chromba", "h264pixeli", "h264capama", "h164chromca", "hwmchromb", "h164pixelca", "h264cssca", "hwmcomama", "hwmcomba", "h264cssi", "hwmchroma", "h264genca", "h264capa", "h264geni", "h264genan", "h264coma", "h164pixelan", "h264cssan", "h264chroman", "h264chromb"], "srcY": ["srcX", "srcN", "sourceX", "rcY", "destXY", "rcN", "destX", "srcXY", "sourceY", "rcXY", "sourceN", "sourceXY", "destN", "rcX", "destY"], "srcU": ["secureV", "sourceV", "srcM", "sourceF", "secureM", "secureU", " srcM", "sourceM", "secureF", "sourceU", " srcF", "srcF"], "srcV": ["locI", "locN", " srcN", " srcW", "srcN", "srcI", "rcV", "rcN", "rcW", "rcI", " srcI", "srcW", "locV", "locW"], "dxy": ["nwy", "dwy", " dwy", "pwy", "ngb", " dgb", "npy", " dpy", "nxy", "dgb", "ppy", "dpy", "pgb", "pxy"], "mx": ["ml", "dm", "yx", "md", "wx", "vm", "mic", "sem", "x", "wm", "bm", "module", "xml", "m", "px", "xy", "tx", "mac", "pm", "mos", "mp", "ma", "mn", "py", "np", "km", "mc", "mis", "mean", "micro", "MX", "rx", "mag", "mi", "nz", "yahoo", "me", "mb", "fm", "mr", "memory", "mine", "mm", "ms", "y", "ym", "dj", "mie", "mus", "cm", "mu"], "my": ["dy", "ody", "mia", "phy", "mem", "mmm", "md", "wx", "qq", "mic", "zy", "ady", "mand", "id", "ny", "x", "cy", "module", "m", "ya", "ix", "mys", "pm", "ma", "make", "sam", "mn", "meta", "gray", "Mi", "money", "mos", "py", "ph", "mis", "ami", "med", "any", "rx", "mag", "mi", "vy", "yahoo", "me", "ey", "ky", "mini", "gy", "am", "amy", "memory", "mine", "hi", "mm", "sym", "y", "ms", "why", "custom", "axy", "MY", "mie", "My", "google", "ui"], "uvmx": ["uuvw", "cucvx", "ucvh", "cucvxes", "suvmw", "suvmpx", "uvimx", "ufmxp", "cuvmh", " ufmy", "sufmw", "suvmx", "uvgxx", "uuvx", "uVMwx", "uvmxp", "sufmz", " ufmxp", "uvimh", "ucvxx", "uvmxx", "ufmw", "ufmx", " uvmwx", "uvmpx", " ufmwx", "cucvh", "uvpw", "ufmy", "cucvxx", "uVMx", "uVMy", "sufmx", "uvpxp", "uvpwx", "cuvmxx", "uvmz", "uvpx", "sufmpx", "uvpy", "uvimxx", "cuvmxes", "uvpz", "ufmwx", "uvgh", "uvppx", "ucvxes", " ufmx", "ufmz", "uvgxes", "ufmpx", "uVMxp", "uuvz", "suvmz", " uvmxp", "uvmh", "cuvmx", "uvmxes", "uvgx", "uvmw", "ucvx", "uuvpx", "uvimxes", "uvmwx"], "uvmy": ["vpml", "imgmy", "vvmi", "imgmid", "cvmy", "vvmain", "lvmm", "uumn", "csvmn", "nvmm", "uvmn", "lvmis", "uumain", "imgcy", "envmi", "cvcy", "uumm", "lvmi", "vvmy", "uvmain", "vmmi", "uvmon", "nvmy", "vpmid", "uvcy", "cvmid", "uvmi", "uzmy", "imgny", "uumi", "lvml", "vpcy", "uumy", "vmmm", "nvmn", "csvny", "lvmy", "cvml", "uvmid", "uvml", "uzmx", "lvmn", "vmmain", "uzmi", "imgml", "vpmy", "envmx", "csvmon", "vmmy", "uuml", "vvmn", "uvny", "lvmx", "uvmis", "nvml", "vvmon", "imgmon", "vvny", "envmis", "uvmm", "imgmn", "vvmm", "envmy", "uzmis", "csvmy"], "src_x": ["src_w", " src_X", "src_X", " src_w"], "src_y": ["src_Y", " src_Y"], "uvsrc_x": ["uvdest_id", "uvdest_xy", "uvsrc_xy", "uvsrc_id", "uvdest_y", "uvdest_x"], "uvsrc_y": ["uvsrc2i", "uvsrc2py", "uvsrc2y", "uvsrc2x", "uvsrc_py", "uvsrc_i"], "i": ["gi", "o", "ti", "id", "I", "chi", "di", "ci", "ji", "ni", "xi", "b", "io", "si", "x", "ri", "abi", "info", "bi", "m", "qi", "ix", "key", "l", "f", "pi", "yi", "phi", "ii", "iu", "d", "it", "ai", "u", "e", "ami", "uri", "n", "multi", "mi", "ini", "ie", "p", "mini", "z", "eni", "oi", "hi", "c", "ip", "y", "li", "fi", "index", "zi", "ui"], "luty": ["Lumen", "Luo", "luti", "nluti", "sluti", "lut", "slut", "nluo", "Luti", "lumen", "Lut", "slumen", "nlumen", "luo", "sluo", "nlut"], "lutuv": ["lutov", " lUTui", " lUTv", "lUTui", " lutv", "lUTuv", "luvv", "luteov", "lUTov", "lutv", "luvuv", "luvui", "lutev", " lUTuv", " lUTov", "lUTv", "luvov", " lutov", "lutui", " lutui", "luteuv", "luteui"], "use_ic": ["usebc", "usebic", "use_c", "use_i", "use_ac", " use_c", " use_i", "usebac", "usebi", " use_ac"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"movq (%2, %%\"REG_a\",4), %%mm2\t\\n\\t\"\n\n\t\t\"movq 8(%2, %%\"REG_a\",4), %%mm3\t\\n\\t\"\n\n\t\tPAVGB(%%mm2, %%mm0)\n\n\t\tPAVGB(%%mm3, %%mm1)\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%4, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;\n\n\t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;\n\n\t}\n\n#endif\n\n}\n", "idx": 7174, "substitutes": {"dstU": ["DSTV", "dsrcUR", "dstsP", "dstsD", "DSTU", "dstUR", "dstsU", " dSTUV", "DSTI", "dsrcP", " dSTP", "dblU", "dblV", "DstI", "dstD", "dSTP", "dstaP", " dSTD", "DstUU", "dsteU", "dstUU", "dSTUV", "dsteI", "dblI", "dstaD", "DstV", " dstD", "dSTI", "dsrcUV", " dSTUR", "dSTD", "dstsUR", "dblUU", "dsteV", "dstI", " dstP", "dSTU", "dstsUV", "dstUV", "dSTV", "DSTUU", "dstaU", "dstsV", "dSTUU", "dsrcU", "dsteUU", " dSTV", "dstaV", "DstU", " dstUV", " dstUR", " dSTU", "dSTUR", "dstP"], "dstV": [" dSTI", "DSTV", "drcV", "dspV", " dstI", "dspUV", "dSTv", "DSTU", "dstB", " dSTUV", "DSTI", "dsrcV", "DSTVB", "dblU", "DstI", "dblV", " dstv", "drcB", "DSTB", "dstsVB", "dSTVB", "dSTUV", "dstVB", "dSTB", "DstV", "drcUV", "DstVB", "dSTI", "dsrcUV", "DstUV", "DSTUV", "drcU", "dsrcv", "dblB", "dstv", "dstI", "dblUV", "dSTU", "dsrcI", "dstUV", "dSTV", "dstsV", "DstB", " dSTV", "DSTv", "dstsI", " dstUV", "DstU", "dsrcVB", "dspv", " dSTv", "dstsv", "Dstv", "dspI"], "src1": ["sc5", "locN", " srcN", "src3", "rc3", " src0", "rc5", "loc1", "rc0", "img2", "source1", "rc1", "src01", "source01", "sc2", "sc3", "img1", "cv1", "cvOne", "loc0", "imgOne", "srcN", "loc3", "source2", " src01", "rc2", "src5", "loc01", "loc5", "cv2", "locOne", "sourceN", "srcOne", "src0", " src3", "loc2", "sc1"], "src2": ["url2", "src3", "url8", "src8", "src4", "rc3", "source4", " src0", "st4", "rc0", "loc1", "url1", "rc1", "src02", "st2", "rc62", "loc4", "rc02", "st1", "url3", " src4", "loc3", "source2", "source02", " src02", "rc2", "st62", " src8", "src62", "rc8", " src3", "src0", "loc62", "rc4", "source0", "loc2"], "i": ["I", "chi", "di", "ci", "xi", "x", "bi", "gu", "pi", "d", "ii", "my", "col", "mini", "line", "oi", "var", "y", "lc", "li", "fi", "index", "zi", "gi", "ti", "id", "count", "ji", "list", "slice", "abi", "info", "phi", "it", "ai", "uri", "ini", "ie", "z", "ip", "ui", "area", "ni", "ri", "io", "key", "yi", "adi", "j", "cli", "u", "vi", "e", "p", "hi", "ind", "idi", "mu", "o", "ei", "v", "si", "m", "qi", "l", "iu", "init", "uli", "ori", "n", "multi", "eni", "inner", "diff"]}}
{"project": "FFmpeg", "commit_id": "ba15aab4a4a296c632bd8d3428b002055109c7d1", "target": 0, "func": "static int mtv_read_header(AVFormatContext *s)\n\n{\n\n    MTVDemuxContext *mtv = s->priv_data;\n\n    AVIOContext   *pb  = s->pb;\n\n    AVStream        *st;\n\n    unsigned int    audio_subsegments;\n\n\n\n    avio_skip(pb, 3);\n\n    mtv->file_size         = avio_rl32(pb);\n\n    mtv->segments          = avio_rl32(pb);\n\n    avio_skip(pb, 32);\n\n    mtv->audio_identifier  = avio_rl24(pb);\n\n    mtv->audio_br          = avio_rl16(pb);\n\n    mtv->img_colorfmt      = avio_rl24(pb);\n\n    mtv->img_bpp           = avio_r8(pb);\n\n    mtv->img_width         = avio_rl16(pb);\n\n    mtv->img_height        = avio_rl16(pb);\n\n    mtv->img_segment_size  = avio_rl16(pb);\n\n\n\n    /* Calculate width and height if missing from header */\n\n\n\n    if(mtv->img_bpp>>3){\n\n    if(!mtv->img_width && mtv->img_height)\n\n        mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_height;\n\n\n\n    if(!mtv->img_height && mtv->img_width)\n\n        mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_width;\n\n    }\n\n    if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){\n\n        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    audio_subsegments = avio_rl16(pb);\n\n\n\n    if (audio_subsegments == 0) {\n\n        avpriv_request_sample(s, \"MTV files without audio\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    mtv->full_segment_size =\n\n        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +\n\n        mtv->img_segment_size;\n\n    mtv->video_fps         = (mtv->audio_br / 4) / audio_subsegments;\n\n\n\n    // FIXME Add sanity check here\n\n\n\n    // all systems go! init decoders\n\n\n\n    // video - raw rgb565\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id        = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->pix_fmt         = AV_PIX_FMT_RGB565BE;\n\n    st->codec->width           = mtv->img_width;\n\n    st->codec->height          = mtv->img_height;\n\n    st->codec->sample_rate     = mtv->video_fps;\n\n    st->codec->extradata       = av_strdup(\"BottomUp\");\n\n    st->codec->extradata_size  = 9;\n\n\n\n    // audio - mp3\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n\n    st->codec->codec_id        = AV_CODEC_ID_MP3;\n\n    st->codec->bit_rate        = mtv->audio_br;\n\n    st->need_parsing           = AVSTREAM_PARSE_FULL;\n\n\n\n    // Jump over header\n\n\n\n    if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 7177, "substitutes": {"s": ["o", "sets", "sf", "S", "spec", "sg", "session", "single", "b", "si", "sync", "i", "sys", "ses", "services", "m", "support", "details", "conf", "f", "client", "ns", "server", "ls", "sl", "series", "stats", "sci", "service", "cs", "ss", "sports", "us", "sis", "e", "sc", "an", "sb", "parser", "gs", "sim", "bis", "submit", "ds", "t", "storage", "ts", "su", "self", "p", "south", "sv", "fs", "sa", "c", "os", "txt", "ssl", "sq", "sym", "g", "tp", "es", "r", "setup"], "mtv": ["cmvent", "gtu", "umov", "mtd", "mvent", "mserv", "amconfig", " mvent", "mopt", "amcf", "mtt", "cmtv", "tmnt", "mTV", "imtd", "gmtr", "rov", "amott", "mesh", "tmtr", "omov", "emtv", "Mov", "cmhtml", "nmnt", "emctr", "dimtd", "vserv", "imvent", " mqt", "paramtw", "bwt", "ymtd", "mmconfig", "emtd", "fmtv", "mhtml", "cmuv", "rtd", "ltxt", "imqt", "rctr", "tmtt", " mconfig", "pmov", "cmesh", "anood", "omott", "mood", "hmtv", "dimctr", "paramcf", "amctr", "mtch", "ntd", "emtt", "gmqt", " mwt", "ltw", "tmtv", "tmood", "vnt", "mtw", "nov", "nmtch", " mtz", "ntk", " mtd", "tmtch", "dimov", "dimtv", "Mott", "mov", "umvent", "rvalid", "rott", " mtk", "duv", "gmtz", "mtu", "nmtt", " mtch", "imtr", "imott", "cmcf", "omtd", "smtd", "paramtk", "omserv", "gmtd", "imaxy", "immtv", "maxy", "ymaxy", "vqt", "omtv", "dood", "omhtml", "ltg", "smtv", "cmvalid", "gmtt", "ymott", "mconfig", "fmtd", "mtg", "mctr", "hmtxt", " mtg", " mTV", "mtz", "tmqt", "ymtv", "gmconfig", "ntt", "cmtd", "amtv", "gaxy", "tmaxy", "vtv", "immqt", "mott", "emott", " maxy", " mtxt", "nmtv", "paramtv", "mvalid", " mopt", "imtt", "rtt", "rtv", "tmtd", "amov", " mtw", "mmtv", "hmqt", "nmserv", "gmtv", "imtw", "pmtt", " mnt", "omqt", "immtu", "gtd", "tmuv", "umvalid", "lctr", "pmtd", "pmtv", "mdtd", "anuv", "btd", "nott", "umtv", "bserv", " mctr", "muv", "ltd", "mtr", "amtw", " mov", "dimtg", "dtv", "tmtu", "cmfont", "raxy", "amserv", "amtd", "gmtg", "imcf", "imtv", "mwt", "antv", "Mtv", "nmfont", "cmov", " mtt", "cmtt", "emesh", " mtu", "mdtv", "btv", "ntv", "ntw", "mmtd", "ymtu", "mtk", "omuv", "mcf", "mdopt", "mdtxt", "nmwt", "nmtd", "tmesh", "nmcf", "umtt", "tmhtml", "smvent", "fmtt", "hmtu", "anaxy", "emTV", " mserv", "mnt", "smtt", "nmvent", "amtt", "immtxt", " mcf", "emtz", "ncf", "dimtw", "omtu", "mqt", "mfont", "gmTV", "omnt", "mtxt", "fmvent", "ltv", " mfont", "tmvent", "daxy", "mmtg", "lopt", " mott", "gtv", "umtd", "lconfig", "Mserv", "omtt", "lov"], "pb": ["cp", "plugin", "pid", "bp", "lb", "ib", "sf", "hub", "platform", "pit", "pa", "rb", "pd", "bps", "b", "wp", "bm", "lp", "pt", "fb", "db", "wb", "uf", "pm", "pg", "prot", "pc", "bs", "xb", "eb", "dp", "sb", "rpm", "bc", "PB", "cb", "fp", "ab", "jp", "p", "summary", "asm", "vp", "gb", "ppa", "ub", "bf", "txt", "lc", "dl", "tp", "fc", "lv", "cv", "pl", "api", "rob", "cpp", "bh", "pkg"], "st": ["std", "est", "ste", "cr", "sf", "ost", "sw", "sts", "rest", "sl", "St", "fe", "ss", "rss", "sth", "ist", "sc", "inst", "se", "ts", "ST", "sta", "ft", "sp", "sa", "bl", "ast", "stim"], "audio_subsegments": ["audio_subpegements", "audio_partbegments", "audio_subsectors", "audio_partbements", "audio_subbegment", "audio_partseges", "audio_sublegments", "audio_subtegments", "audio_subpegment", "audio_partbegment", "audio_partsectors", "audio_subtegements", "audio_subpersegments", "audio_subsegment", "audio_subpegments", "audio_subgegements", "audio_subsements", "audio_subgegment", "audio_sublegements", "audio_subpeges", "audio_partsegment", "audio_subpersegements", "audio_partsegements", "audio_subpersegment", "audio_subsegements", "audio_subseges", "audio_partbectors", "audio_partbeges", "audio_partsegments", "audio_partsements", "audio_sublements", "audio_subtements", "audio_subpements", "audio_subteges", "audio_subgegments", "audio_subbements", "audio_subbegments", "audio_subgements", "audio_subpersements", "audio_subbectors", "audio_subbegements", "audio_partbegements", "audio_sublectors", "audio_subbeges", "audio_subpectors"]}}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191, "substitutes": {"ht": ["H", "hp", "hw", "ch", "http", "bt", "mat", "bm", "rh", "att", "hs", "hm", "sh", "hh", "cmd", "h", "hold", "gh", "bf", "ct", "hip", "ac", "cache", "ha", "host", "bh", "hard", "dict"], "map": ["master", "address", "header", "block", "change", "open", "parent", "scope", "config", "pre", "op", "sche", "data", "use", "ap", "co", "module", "m", "holder", "cl", "mp", "maps", "meta", "MAP", "table", "code", "file", "apper", "self", "lock", "work", "bridge", "node", "cap", "rule", "link", "bl", "pl", "cache", "app", "ref", "Map"], "head": ["master", "hook", "name", "Head", "header", "block", "id", "parent", "check", "tail", "config", "op", "ad", "body", "commit", "holder", "before", "client", "foot", "post", "heads", "d", "ack", "ck", "da", "HEAD", "path", "first", "self", "load", "root", "h", "run", "start", "fix", "back", "c", "off", "link", "front", "cache", "next", "set", "index", "host", "src", "conn", "end", "view", "dict"], "p": ["patch", "cp", "P", "o", "bp", "padding", "v", "pin", "pa", "pre", "pp", "ping", "ap", "m", "before", "f", "pg", "d", "j", "pc", "q", "e", "point", "w", "port", "t", "n", "pad", "fp", "jp", "pool", "h", "sp", "pos", "pointer", "c", "ip", "tp", "pair", "pb", "r"], "hash": ["base", "address", "cmp", "header", "block", "al", "change", "count", "id", "Hash", "final", "oh", "ap", "image", "rh", "key", "num", "kh", "version", "number", "depth", "height", " h", "prefix", "array", "pool", "sha", "h", "prop", "pointer", "memory", "node", "ip", "bf", "ash", "cache", "ashes", "ref", "index", "pkg", "shift", "ashing", "ump"], "needs_resize": ["needs_hardizing", "needs_resiz", "needs_hesizing", "needs_realizer", "needs_realize", "needs_hesiz", "needs_reiz", "needs_realizing", "needs_normalizer", "needs_resizer", "needs_reample", "needs_normaliz", "needs_normalize", "needs_resizing", "needs_reize", "needs_hardize", "needs_resetizing", "needs_hardiz", "needs_resample", "needs_rescale", "needs_reizing", "needs_hesize", "needs_realiz", "needs_hardcale", "needs_realcale", "needs_normalcale", "needs_resetiz", "needs_realample", "needs_resetize", "needs_hescale", "needs_resetample", "needs_hesizer"], "b": ["base", "o", "bp", "lb", "buff", "ib", "emb", "v", "bin", "block", "a", "bd", "http", "s", "rb", "bt", "ob", "bi", "m", "body", "orb", "fb", "l", "db", "wb", "f", "abb", "d", "obj", "bu", "bs", "bb", "e", "sb", "w", "k", "lib", "n", "ab", "cb", "B", "bc", "nb", "ba", "mb", "old", "this", "be", "h", "boot", "gb", "c", "g", "bf", "y", "br", "bl", "next", "pb", "app", "r", "bh", "bar"], "prev": ["cmp", "bp", "header", "bin", "v", "cur", "block", "parent", "rb", "pre", "op", "record", "rel", "loc", "reverse", "before", "buf", "mp", "post", "book", "original", "bb", "Prev", "existing", "cb", "self", "rev", "pres", "old", "root", "h", "batch", "iv", "re", "nav", "var", "vious", "orig", "back", "next", "current", "pb", "ref", "r", "rec", "first"], "new": ["base", "name", "row", "o", "v", "block", "a", "NEW", "update", "bug", "now", "normal", "fresh", "New", "m", "missing", "before", "valid", "known", "f", "make", "d", "j", "create", "w", "raw", "n", "other", "self", "old", "end", "root", "h", "un", "re", "gen", "node", "c", "g", "ew", "next", "r", "big", "diff", "first", "add"], "i": ["base", "gi", "o", "ti", "v", "id", "I", "a", "di", "s", "ci", "ji", "ni", "x", "xi", "si", "io", "ri", "slice", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "d", "ii", "j", "iu", "it", "ai", "u", "e", "ami", "uri", "k", "t", "n", "multi", "ini", "ie", "z", "eni", "start", "oi", "hi", "ind", "ip", "c", "y", "api", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "6e1b1a27a4034c578018d5042b3c8228278c4cd6", "target": 1, "func": "static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)\n\n{\n\n    pkt->data      = NULL;\n\n    pkt->side_data = NULL;\n\n    if (pkt->buf) {\n\n        AVBufferRef *ref = av_buffer_ref(src->buf);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n        pkt->buf  = ref;\n\n        pkt->data = ref->data;\n\n    } else {\n\n        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);\n\n    }\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    pkt->destruct = dummy_destruct_packet;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (pkt->side_data_elems && dup)\n\n        pkt->side_data = src->side_data;\n\n    if (pkt->side_data_elems && !dup) {\n\n        return av_copy_packet_side_data(pkt, src);\n\n    }\n\n    return 0;\n\n\n\nfailed_alloc:\n\n    av_destruct_packet(pkt);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 7204, "substitutes": {"pkt": ["petsk", "cpkt", "Pait", "tpelt", "plkt", "Pka", "bnt", "bkt", "tpdt", "opkt", "psacket", " pnt", "Pcht", "fetsk", "ppnt", "gacket", " packet", " pka", "pitter", "opdt", "cpacket", "psct", "jpnt", "ipetsk", "Pet", "spelt", "opelt", "gkg", "pwk", "opet", "opkg", "ppacket", "facket", "Packet", "ppwk", "Pelt", "fet", "spkt", "tpkt", "placket", "packacket", " pcht", "Pkg", "Piece", "packka", "plct", "packet", "tpwk", "pelt", "spet", " pait", " pet", "plnt", "ppkt", "fkg", "Pitter", "ipkt", "pet", "ipet", "ppdt", "fiece", "Pnt", "jpacket", "opwk", "gkt", "pscht", "ipitter", "bet", "pskt", "ipacket", "pdt", "pnt", "jpet", "pait", "fkt", "spiece", "jpkt", "Petsk", "ipct", "Pkt", "ppelt", "pka", "piece", "pct", "packct", "ppct", " pitter", " pelt", "gait", "pcht", " pct", "packkt", "opacket", "cpet", "cpnt", "Pct", "spacket", " pkg", "pkg", "backet"], "src": ["sub", "plugin", "ch", "sr", "socket", "sec", "sit", "spec", "rb", "tmp", "config", "kk", "rc", "data", "sn", "slice", "dest", "sys", "sync", "SOURCE", "loc", "grab", "support", "buf", "uc", "selected", "seed", "url", "prot", "sl", "ack", "grad", "sci", "split", "sc", "sb", "target", "inst", "func", "ctx", "bc", "cb", "ruby", "fp", "nil", "feat", "source", "rin", "req", "ptr", "gb", "iv", "sup", "proc", "sel", "ssl", "secure", "rob", "img", "RC", "pkg", "super"], "dup": ["cepc", "adeper", "Dups", "depp", "duf", "deps", "daper", "cept", "dupp", " doupp", "dulp", " dupc", " dupi", "corp", "dupc", " doups", "dupt", "dups", "dupi", " dups", "daf", "adep", "adef", "corps", "corpc", "duper", "delp", " duper", "cep", " dupt", "Dulp", " doup", " doulp", "ceps", "Dupp", " duf", "adepi", "dep", "dapi", "dap", "Dup", "corpt"], "ref": ["cmp", "flow", "act", "block", "id", "mem", "alt", "ef", "b", "object", "rc", "ob", "fact", "comp", "rel", "info", "Ref", "rf", "loc", "buf", "db", "null", "uf", "f", "offset", "url", "obj", " reference", "bb", "fe", "conf", "def", "buffer", "part", "col", "per", "lib", "cb", "self", "rev", "p", "req", "re", "aff", "c", "ind", "bf", "val", "cache", "reference", "index", "r", "REF", "lf", "rec", "diff", "af"]}}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n", "idx": 7213, "substitutes": {"obj": ["o", "act", "objects", "emb", "parent", "Obj", "obb", "nt", "config", "po", "tmp", "op", "ob", "object", "b", "cat", "module", "orb", "so", "attr", "org", "j", "init", "conf", "kt", "inst", "bot", "instance", "Object", "n", "ctx", "jp", "cb", "coll", "boot", "prop", "node", "os", "class", "api", "src", "img", "bh", "conn", "pkg", "bj", "js"], "vcrypto": ["vccrypto", "vcprotode", "vcrimto", "vcryptor", "vcryptode", "vcryptionos", "VCryptto", "vccryptode", "VCcryptos", "vconto", "vcCryptos", "vccryptor", "vcritor", "vccryptoa", "vcryptionor", "vcritio", "VCcrypto", "vcprotto", "fcrito", "vccryptio", "fcryptio", "vcCryptoa", "vcrimos", "vcrito", "VCryptos", "fcryptor", "vcryptoa", "VCcrypta", "vcrimode", "fcritio", "vcCrypto", "vcryptio", "vcCrypta", "vcryptos", "vccryptos", "VCcryptode", "vcrimo", "vcontoa", "fcritor", "vcproto", "fcryptos", "fcritos", "vconta", "VCryptode", "vcrypta", "VCcryptoa", "VCrypta", "vcontos", "vcryptto", "vcryptiono", "vcprotos", "vccrypta", "vcryptionio", "fcrypto", "VCcryptto", "vccryptto", "VCrypto", "VCryptoa", "vcritos"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,\n\n\t\t\t     int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong physical;\n\n    int prot, ret, access_type;\n\n\n\n    access_type = ACCESS_INT;\n\n    ret =\n\n\tget_physical_address(env, &physical, &prot, address, rw,\n\n\t\t\t     access_type);\n\n\n\n    if (ret != MMU_OK) {\n\n\tenv->tea = address;\n\n\tswitch (ret) {\n\n\tcase MMU_ITLB_MISS:\n\n\tcase MMU_DTLB_MISS_READ:\n\n\t    env->exception_index = 0x040;\n\n\t    break;\n\n\tcase MMU_DTLB_MULTIPLE:\n\n\tcase MMU_ITLB_MULTIPLE:\n\n\t    env->exception_index = 0x140;\n\n\t    break;\n\n\tcase MMU_ITLB_VIOLATION:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_MISS_WRITE:\n\n\t    env->exception_index = 0x060;\n\n\t    break;\n\n\tcase MMU_DTLB_INITIAL_WRITE:\n\n\t    env->exception_index = 0x080;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_READ:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_WRITE:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_IADDR_ERROR:\n\n\tcase MMU_DADDR_ERROR_READ:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_DADDR_ERROR_WRITE:\n\n\t    env->exception_index = 0x100;\n\n\t    break;\n\n\tdefault:\n\n\t    assert(0);\n\n\t}\n\n\treturn 1;\n\n    }\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    physical &= TARGET_PAGE_MASK;\n\n\n\n    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);\n\n}\n", "idx": 7222, "substitutes": {"env": ["enable", "fen", "osc", "ah", "eng", "energy", "ea", "extra", "ef", "vm", "config", "qt", "edge", "environment", "nc", "exc", "et", "enc", "enter", "eu", "inet", "db", "export", "event", "ext", "eye", "server", "esi", "init", "net", "conf", "ev", "np", "vs", "e", "her", "que", "en", "dev", "ctx", "err", "equ", "Environment", "exec", "enh", "context", "ne", "ec", "output", "network", "eni", "viron", "console", "erv", "eve", "txt", "het", "core", "dt", "chal", "ette", "engine", "site", "esm", "forge", "conn", "end"], "address": ["master", "area", "position", "uration", "block", "shape", "channel", "config", "Address", "object", "image", "enter", "ace", "inet", "route", "resource", "offset", "event", "order", "state", "server", "service", "table", "number", "buffer", "interface", "e", "code", "target", "en", "message", "port", "path", "response", "result", "array", "p", "network", "remote", "eni", "pointer", "memory", "attribute", "ip", "location", "type", "contact", "contract", "element", "cache", "test", "reference", "addr", "host", "index", "mode", "end", "size"], "rw": ["writer", "rn", "hw", "nw", "fw", "rr", "sw", "wn", "rb", "password", "rf", "wp", "RW", "wa", "route", "wb", "rh", "wh", "rou", "nr", "rss", "w", "tw", "raw", "rx", "working", "fp", "rl", "access", "ww", "work", "wr", "iw", "ptr", "wl", "rack", "src", "r", "worker"], "mmu_idx": ["mmu_idf", "mmu_idz", "mmu_Idz", "mmu_midf", "mmu_idex", "mmu_idy", "mmu_aidx", "mmu_idef", "mmu_idv", "mmu_Idx", "mmu_ideb", "mmu_Idb", "mmu_midx", "mmu_midb", "mmu_aidz", "mmu_aidv", "mmu_idey", "mmu_aidb", "mmu_midy", "mmu_Idv", "mmu_idb"], "is_softmmu": ["is_softMMU", "is_softMMru", "is_softmmU", "is_softMMu", "is_softmmus", "is_softmmru", "is_hardmmuit", "is_softmlus", "is_softmmuit", "is_hardmmU", "is_softmluit", "is_softmlru", "is_hardmmru", "is_hardmmu", "is_softmlcu", "is_softmlu", "is_softmlU", "is_hardmmus", "is_softMMcu", "is_softmmcu", "is_softMMus", "is_softMMuit", "is_hardmmcu"], "physical": ["ocol", "python", "intel", "http", "platform", "config", "single", "pixel", "password", "data", "database", "vector", "route", "inet", "null", "resource", "php", "server", "net", "byte", "number", "native", "interface", "target", "secondary", "binary", "port", "public", "phys", "prefix", "p", "virtual", "temp", "serial", "output", "boot", "network", "integer", "cpu", "protected", "remote", "pointer", "Physical", "proc", "primary", "params", "text", "ref", "reference", "index", "host", "hard", "external"], "prot": ["ocol", "reset", "platform", "pro", "eth", " proto", "pat", "channel", "dat", "config", "rot", "data", "io", "rf", "Prot", "format", "protect", "route", "inet", "ext", "att", "server", " protocols", "len", "col", "target", "secondary", "fp", "phys", " protocol", "seq", "virtual", "temp", "protected", "ptr", "prop", "pointer", "primary", "aff", "pos", "dt", "ref", "reference", "addr", "dim", "prefix"], "ret": ["reset", "flag", "reg", "rt", "al", "alt", "nt", "val", "rf", "data", "inter", "format", "bit", "art", "info", "reply", "rc", "status", "route", "db", "job", "ext", "att", "res", "net", "match", "len", "part", "code", "det", "error", "en", "mt", "RET", "ben", "bc", "response", "rl", "result", "array", "input", "ne", "pub", "Ret", "ft", "ptr", "re", "fail", "fun", "hash", "resp", "ash", "success", "ref", "fi", "addr", "conn", "rets"], "access_type": [" access_value", "accessingmethod", "access_types", " access_level", "access_method", "access_level", "access_value", "accessalvalue", "accessingtypes", "accessaltype", "access_key", " access_key", "accessalkey", "accessingvalue", "accessaltypes", " access_method", " access_types", "accessingtype"]}}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 7243, "substitutes": {"dev": ["ch", "dm", "diff", "block", "v", "md", "nov", "rad", "pro", "di", "Dev", "spec", "device", "data", "info", "dem", "der", "debug", "gu", "de", "sk", "state", "d", "mod", "conf", "ev", "def", "dom", "DEV", "priv", "kind", "error", "w", "prom", "sh", "dc", "driver", "cmd", "err", "p", "req", "development", "ver", "var", "test", "app", "grad", "conn", "mode"], "vdev": ["VDev", "vprof", "evw", "vDev", "vmprof", "wdevice", "vmdevelopment", " vDev", "evdiv", " vdevelopment", "vdevice", " vw", "wdiv", " vprof", "wdev", " vdiv", "vw", "vdevelopment", " vdevice", "vdiv", "evdev", "ww", "vmDev", "evdevice", "Vprof", "Vdev", "vmdev", "Vdevelopment"], "s": ["r", "o", "v", "is", "S", "a", "spec", "sg", "session", "b", "si", "sync", "data", "sys", "ses", "services", "m", "l", "f", "ns", "server", "sl", "d", "args", "service", "ss", "cs", "u", "e", "sh", "w", "gs", "sb", "ds", "storage", "n", "t", "su", "self", "p", "settings", "sup", "fs", "changes", "c", "new", "g", "ssl", "sq", "sym", "y", "os", "params", "rs", "ps", "js"]}}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n", "idx": 7267, "substitutes": {"obj": ["o", "act", "objects", "emb", "Obj", "obb", "nt", "tmp", "po", "ob", "object", "oa", "module", "m", "orb", "so", "attr", "org", "j", "aj", "ev", "code", "inst", "bot", "lib", "Object", "ctx", "jp", "self", "nb", "p", "boot", "opt", "xxx", "oi", "os", "txt", "api", "src", "img", "bj", "js"], "v": ["o", "vm", "s", "V", "x", "b", "object", "i", "val", "m", "uv", "l", "f", "conv", "d", "j", "q", "u", "vs", "e", "w", "t", "k", "n", "p", "z", "vp", "sv", "iv", "c", "g", "class", "api", "lv", "env", "vc", "vu"], "name": ["base", "o", "time", "word", "x", "object", "data", "alias", "b", "named", "info", "m", "image", "names", "key", "f", "attr", "space", "Name", "part", "size", "NAME", "len", "w", "ame", "n", "path", "filename", "nam", "cap", "type", "label", "min", "prefix"], "opaque": ["Opac", "ipaque", "Opaque", "ipacity", "ponymous", "pacity", "iponymous", "opacity", "Opacity", "Oponymous", "oponymous", "opac", "pac", "ipac", "paque"], "errp": ["rrpre", "Erp", "iterP", "erP", "iterp", "rrP", "Erlp", "rrp", " errfp", " errlp", "iterfp", "rrr", "errP", "ErP", " errP", "err", "errlp", "errr", "erp", " errr", "Erfp", "iterlp", "errfp", " errpre", "errpre", "erpre"], "value": ["function", "flow", "fee", "total", "values", "val", "data", "format", "info", "image", "unit", "null", "valid", "job", "media", "version", "weight", "length", "member", "number", "part", "message", "json", "response", "score", "result", "array", "scale", "VALUE", "memory", "range", "type", "index", "r", "min", "max", "Value", "feature", "size"], "mr": ["dr", "gr", "fr", "er", "vr", "ml", "sr", "cr", "dm", "rt", "pr", "rr", "rb", "shr", "MR", "rf", "wm", "bm", "igr", "wk", "m", "rm", "rh", "ir", "pm", "ru", "mn", "mer", "nr", "hm", "mt", "mc", "Mr", "km", "rg", "dc", "lr", "wr", "fm", "mm", "RR", "mx", "hr", "lc", "adr", "kr", "rs", "r", "mor"], "dimm": ["ddim", "Dcm", "mimm", "mImm", " dim", " dirm", "dImm", "mirm", " damm", "dirm", "Dimm", " dcm", " dpm", "dcm", "dpm", "Dim", "mpm", "ddcm", "damm", "Damm", "ddamm", "dim", " dImm", "ddimm"], "ddc": ["ddd", "hdcc", " ddd", " ddcc", "ddcc", "hdd", " ddpc", "ldc", "ldi", "ldd", "ddec", " ddec", " ddi", "gdpc", "ddpc", "gdc", "uddec", "uddc", "uddb", "hdi", " ddb", "gdb", "uddpc", "ldcc", "ddb", "ddi", "hdc", "gdec"]}}
{"project": "qemu", "commit_id": "821303f59b63ab832f0921f070db55e95bb21858", "target": 1, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;", "idx": 7269, "substitutes": {"spapr": ["spappr", "spmprar", "SpAPrar", "sapsri", "sapsr", "spraprc", "spappri", "spaptR", "spapri", "spapsR", "SpAPri", "sapri", "spmprc", "spapsrar", "spapprar", "SpAPrc", "spaptri", "sapR", "spAPri", "spappR", "spmpri", "spapsr", "Spaprc", "spaprar", "spAPr", "Spapri", "sapr", "spAPrar", "spapsri", "sapsrar", "spaptrar", "spaptr", "SpAPr", "saprar", "spmpr", "spraprar", "spapR", "spaprc", "sprapri", "spAPrc", "Spapr", "sprapr", "Spaprar", "sapsR"], "token": ["function", "option", "name", "o", "trial", "note", "shadow", "channel", "session", "future", "username", "scope", "password", "socket", "secret", "ok", "sync", "format", "wt", "fake", "key", "tag", "argument", "offset", "event", "foo", "version", "length", "limit", "url", "byte", "tick", "duration", "number", "len", "uri", "target", "random", "auth", "fn", "Token", "path", "timeout", "pass", "character", "year", "KEN", "stage", "mini", "eni", "oken", "variable", "column", "request", "node", "rule", "notice", "type", "api", "cookie", "element", "date", "seed", "prefix"], "nargs": ["Nvar", "Nargs", "targ", "tparams", "tArgs", "targs", "nvar", " narg", " nArgs", "narg", "NArgs", "cargs", "cArgs", "Narg", "carg", "Nparams", "nArgs", "cvar", " nparams", "nparams", " nvar"], "args": ["ans", "unc", "ig", "ret", "extra", "sec", "s", "config", "data", "secret", "Args", "reply", "vals", "results", "argument", "ants", "stats", "arg", "res", "init", "cs", "ints", "fields", "len", "arr", "func", "cmd", "err", "response", "seq", "Ret", "aws", "fun", "var", "params", "cache", "aux", "rs", "conn", "flags", "size"], "nret": ["nRet", "nreturn", "natret", "lresult", "nnRET", "lreturn", " nRet", "ncat", "lRET", "nbcat", "nbret", "nnret", "Nret", " nrets", "natresult", "nbrets", "nresult", "natRET", "NRet", "nbRet", "Ncat", "nRET", "lret", "nrets", "Nrets", "natreturn", "nnreturn", " ncat", "nnresult"], "rets": ["types", "options", "files", "red", "ret", "reset", "runs", "alt", "bits", "vt", "values", "pillar", "secret", "data", "events", "rows", "info", "reply", "details", "vals", "results", "urses", "ats", "uds", "uments", "res", "def", "ints", "fields", "des", "urs", "auth", "RET", " secrets", "tests", "tails", "seq", "Ret", "flags", "fs", "utils", "errors", "items", "tracks", "params", "aux", "rs", "ras", "cas"], "call": ["function", "name", "build", "o", "play", "mix", "block", "v", "complete", "send", "use", "sync", "cat", "Call", "key", "null", "cal", "f", "make", "event", "client", "kill", "create", "ack", "q", "roll", "push", "code", "cell", "close", "conn", "n", "pass", "exec", "self", "work", "p", "parse", "eval", "ca", "throw", "run", "c", "can", "g", "ac", "cache", "max"]}}
{"project": "qemu", "commit_id": "afa46c468acc18914c2773538f1b088c507766ee", "target": 0, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);\n\n    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n\n    int ret;\n\n\n\n    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(&r->req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (-1 == scsi_req_parse(&r->req, cmd)) {\n\n        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n    scsi_req_fixup(&r->req);\n\n\n\n    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,\n\n            r->req.cmd.xfer, cmd[0]);\n\n\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", cmd[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (r->req.cmd.xfer == 0) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buflen = 0;\n\n        r->buf = NULL;\n\n        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);\n\n        if (ret < 0) {\n\n            scsi_command_complete(r, ret);\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (r->buflen != r->req.cmd.xfer) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buf = qemu_malloc(r->req.cmd.xfer);\n\n        r->buflen = r->req.cmd.xfer;\n\n    }\n\n\n\n    memset(r->buf, 0, r->buflen);\n\n    r->len = r->req.cmd.xfer;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        r->len = 0;\n\n        return -r->req.cmd.xfer;\n\n    } else {\n\n        return r->req.cmd.xfer;\n\n    }\n\n}\n", "idx": 7315, "substitutes": {"req": ["serv", "comm", "progress", "rb", "tr", "queue", "f", "ctr", "conf", "w", "err", "exec", "rev", "ec", "reader", "mr", "ver", "head", "query", "rec", "conn", "msg", "cur", "id", "spec", "config", "qt", "rf", "art", "module", "xml", "ru", "dq", "ctx", "jp", "str", "pub", "ro", "sq", "rs", "grad", "low", "fr", "er", "sr", "reg", "rt", "pro", "require", "sem", "wa", "cl", "ext", "ra", "org", "crit", "e", "dev", "p", "input", "run", "re", "c", "hr", "desc", "ref", "cache", "requ", "loader", "gr", "cmp", "Request", "cr", "pull", "rr", "http", "com", "comp", "tar", "rh", "ir", "client", "call", "urg", "q", "res", "def", "rx", "seq", "request", "pkg"], "cmd": ["comm", "roc", "Cmd", "data", "buf", "d", "arg", "ctr", "conf", "dom", "code", "query", "ctrl", "mode", "conn", "cd", "msg", "cp", "name", "domain", "id", "cur", "parent", "config", "nc", "module", "dq", "atom", "gz", "ctx", "path", "cf", "cod", "cookie", "command", "grad", "clean", "act", "block", "md", "method", "qq", "op", "sync", "cat", "cl", "obj", "cc", "cli", "crit", "ck", "input", "c", "custom", "vc", "dict", "bind", "cmp", "cfg", "bug", "com", "comp", "mac", "client", "call", "args", "q", "def", "cb", "seq", "request", "chan", "host", "pkg", "hard"], "s": ["serv", "sr", "sf", "v", "S", "http", "spec", "session", "b", "si", "sys", "ses", "m", "ns", "server", "ls", "sl", "d", "q", "service", "sci", "ss", "cs", "sc", "sb", "gs", "w", "se", "t", "ds", "su", "search", "p", "z", "sv", "sp", "sa", "c", "os", "g", "ssl", "sq", "y", "sym", "rs"], "r": ["gr", "dr", "fr", "rw", "er", "sr", "cr", "rt", "v", "pr", "rr", "rb", "b", "tr", "rf", "rc", "or", "m", "rh", "l", "ru", "f", "ir", "d", "nr", "j", "q", "res", "u", "e", "w", "ar", "rg", "ur", "k", "t", "rx", "err", "lr", "str", "rev", "self", "result", "p", "this", "h", "usr", "z", "wr", "R", "mr", "re", "c", "g", "ro", "hr", "br", "rs", "kr"], "ret": ["flag", "reg", "red", "id", "alt", "count", "nt", "pat", "val", "last", "rc", "bit", "cat", "reply", "sur", "key", "num", " Ret", "lit", "ext", "att", "url", "obj", "arg", "res", "match", "def", "code", "len", "mt", "det", "part", "error", "out", "arr", "RET", "pass", "str", "rev", "result", "run", "Ret", "ft", "re", "fail", "fun", "back", "resp", "success", "ref", "no", "rets"], "i": ["gi", "ti", "v", "id", "I", "count", "chi", "di", "ci", "ji", "ni", "x", "xi", "ri", "slice", "si", "abi", "info", "bi", "m", "qi", "ix", "key", "num", "pi", "phi", "j", "ii", "my", "ai", "init", "u", "len", "e", "code", "uri", "part", "k", "n", "multi", "mi", "ini", "p", "mini", "z", "start", "oi", "hi", "ind", "ip", "type", "y", "li", "inner", "fi", "index", "zi", "mu", "ui", "counter"]}}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n", "idx": 7324, "substitutes": {"m": ["machine", "o", "dm", "v", "gm", "md", "a", "M", "b", "x", "data", "i", "bm", "mo", "module", "l", "f", "mn", "nm", "d", "sm", "mod", "u", "man", "em", "e", "mc", "mt", "hm", "w", "en", "an", "message", "t", "n", "tm", "mut", "mi", "me", "source", "p", "fm", "this", "h", "mr", "am", "c", "mm", "g", "ms", "im", "y", "um", "r", "cm", "mu"], "ip6": ["ip06", "ip613", "p6", "p06", " ip8", "mp36", "cp16", "upsix", "ip16", " ip3", "up612", "op76", " ip4", "ip4", "ip8", "cp616", "ip3", "IPsix", "IP3", "clip16", " ip06", "up76", "ipsix", "mp613", "op4", "IP8", "mop16", "clip6", " ip36", "p8", " ipape", "IP6", "ipape", "mpape", " ipse", "p16", " ip16", "op612", "mp8", "mp3", "ip76", "up6", "IP76", "mp6", "op6", "IPape", "clipsix", " ip616", "mpsix", "IP613", "ip616", "mopse", "ip36", "cp36", "mopsix", "clip613", "mp06", "op8", "IP612", "IP16", "opsix", "IPse", "cp6", "mp16", "mp616", " ipsix", "ip612", "mop6", "mp4", "ipse"]}}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n", "idx": 7326, "substitutes": {}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static int write_dump_pages(DumpState *s)\n\n{\n\n    int ret = 0;\n\n    DataCache page_desc, page_data;\n\n    size_t len_buf_out, size_out;\n\n#ifdef CONFIG_LZO\n\n    lzo_bytep wrkmem = NULL;\n\n#endif\n\n    uint8_t *buf_out = NULL;\n\n    off_t offset_desc, offset_data;\n\n    PageDescriptor pd, pd_zero;\n\n    uint8_t *buf;\n\n    int endian = s->dump_info.d_endian;\n\n    GuestPhysBlock *block_iter = NULL;\n\n    uint64_t pfn_iter;\n\n\n\n    /* get offset of page_desc and page_data in dump file */\n\n    offset_desc = s->offset_page;\n\n    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;\n\n\n\n    prepare_data_cache(&page_desc, s, offset_desc);\n\n    prepare_data_cache(&page_data, s, offset_data);\n\n\n\n    /* prepare buffer to store compressed data */\n\n    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);\n\n    if (len_buf_out == 0) {\n\n        dump_error(s, \"dump: failed to get length of output buffer.\\n\");\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_LZO\n\n    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);\n\n#endif\n\n\n\n    buf_out = g_malloc(len_buf_out);\n\n\n\n    /*\n\n     * init zero page's page_desc and page_data, because every zero page\n\n     * uses the same page_data\n\n     */\n\n    pd_zero.size = cpu_convert_to_target32(s->page_size, endian);\n\n    pd_zero.flags = cpu_convert_to_target32(0, endian);\n\n    pd_zero.offset = cpu_convert_to_target64(offset_data, endian);\n\n    pd_zero.page_flags = cpu_convert_to_target64(0, endian);\n\n    buf = g_malloc0(s->page_size);\n\n    ret = write_cache(&page_data, buf, s->page_size, false);\n\n    g_free(buf);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write page data(zero page).\\n\");\n\n        goto out;\n\n    }\n\n\n\n    offset_data += s->page_size;\n\n\n\n    /*\n\n     * dump memory to vmcore page by page. zero page will all be resided in the\n\n     * first page of page section\n\n     */\n\n    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {\n\n        /* check zero page */\n\n        if (is_zero_page(buf, s->page_size)) {\n\n            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),\n\n                              false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        } else {\n\n            /*\n\n             * not zero page, then:\n\n             * 1. compress the page\n\n             * 2. write the compressed page into the cache of page_data\n\n             * 3. get page desc of the compressed page and write it into the\n\n             *    cache of page_desc\n\n             *\n\n             * only one compression format will be used here, for\n\n             * s->flag_compress is set. But when compression fails to work,\n\n             * we fall back to save in plaintext.\n\n             */\n\n             size_out = len_buf_out;\n\n             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&\n\n                    (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size,\n\n                    Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#ifdef CONFIG_LZO\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&\n\n                    (lzo1x_1_compress(buf, s->page_size, buf_out,\n\n                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n#ifdef CONFIG_SNAPPY\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&\n\n                    (snappy_compress((char *)buf, s->page_size,\n\n                    (char *)buf_out, &size_out) == SNAPPY_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(\n\n                                        DUMP_DH_COMPRESSED_SNAPPY, endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n            } else {\n\n                /*\n\n                 * fall back to save in plaintext, size_out should be\n\n                 * assigned to s->page_size\n\n                 */\n\n                pd.flags = cpu_convert_to_target32(0, endian);\n\n                size_out = s->page_size;\n\n                pd.size = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf, s->page_size, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /* get and write page desc here */\n\n            pd.page_flags = cpu_convert_to_target64(0, endian);\n\n            pd.offset = cpu_convert_to_target64(offset_data, endian);\n\n            offset_data += size_out;\n\n\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_desc.\\n\");\n\n        goto out;\n\n    }\n\n    ret = write_cache(&page_data, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_data.\\n\");\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    free_data_cache(&page_desc);\n\n    free_data_cache(&page_data);\n\n\n\n#ifdef CONFIG_LZO\n\n    g_free(wrkmem);\n\n#endif\n\n\n\n    g_free(buf_out);\n\n\n\n    return ret;\n\n}\n", "idx": 7327, "substitutes": {"s": ["sf", "_", "S", "a", "b", "i", "status", "f", "parts", "state", "d", "service", "conf", "buffer", "all", "aws", "proc", "g", "sym", "y", "sets", "sites", "is", "spec", "slice", "info", "services", "its", "states", "server", "ls", "sie", "ops", "ds", "south", "settings", "sv", "fs", "sq", "site", "rs", "stat", "block", "ins", "sg", "comments", "sync", "ses", "obj", "cs", "sis", "submit", "e", "an", "sb", "secondary", "qs", "t", "p", "pos", "c", "ssl", "r", "ps", "v", "http", "less", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "series", "us", "ss", "gs", "se", "n", "su", "request", "write", "params", "es", "js"], "page_desc": ["page_design", "page_Desc", "pageJdesc", " page_description", "pageJdat", " page_des", " page_Desc", "page_des", "page_description", "pageJdesign", "pageJdes", " page_design", " page_dat", "page_dat"], "page_data": ["page_memory", "pageallda", "page9desc", "block_size", "block_desc", " page_memory", " page_page", "page2def", "page2memory", "block_content", "page2data", "pageallpage", "page_page", "block_data", "pagesdesc", "pagealldesc", "page9memory", " page_da", "page2desc", "pagescontent", "pagealldata", "page9data", "pagesdata", "page_content", "pagessize", "page_def", "page9def", " page_def", "page_size", "page_da"], "len_buf_out": ["len_uf_out", "len_uf_size", "len_buf_in", "len_buff_int", "len_buf_again", "len_bufsdesc", "len_buff_OUT", "len_buf_OUT", "len_bufsinner", "len_bufsint", "len_buf_desc", "len_uf_Out", "len_buf_off", "len_buff_desc", "len_buf_Out", "len_buf_inner", "len_uf_in", "len_buff_inner", "len_buff_again", "len_buff_out", "len_buf_int", "len_bufsout", "len_buff_Out", "len_uf_off", "len_buf_size"], "size_out": ["size0desc", " size_inner", " size_desc", "size0out", "size0inner", "size0in", "size_inner", "size_in", " size_in", "size_desc"], "buf_out": ["block_inner", "block_out", "block_in", " buf_in", " buf_output", "buf_in", " buf_size", "buf_cache", "buf_size", "buf_output", "buf_inner", "block_cache"], "offset_desc": ["offset64description", "offset9desc", " offset_Desc", "offset_ext", "offset9size", " offset_ext", "offset9description", " offset_sc", " offset64desc", "offset64size", "offset24description", " offset_size", " offset64description", " offset64data", "offset64data", " offset_doc", "offset_description", " offset64size", " offset_page", "offsetCDesc", "offset_Desc", " offset_description", "offset_size", "offset9data", "offset64dec", " offset_dec", "offsetCdesc", "offsetNext", "offset_page", "offsetCext", "offset64sc", "offset_dec", "offsetNdoc", "offsetNDesc", "offsetNdesc", "offset64Desc", "offset_sc", "offsetCdoc", "offset24desc", "offset24page", "offset64desc", "offset24Desc", "offset_doc"], "offset_data": ["position_data", "offsetndata", "offsetingdesc", "offsetCdata", "offset_off", "offsetingstart", "offsetCdescription", "position_desc", "Offset_description", "size_dat", "size_data", "offset_description", "offsetingdata", "Offset_desc", "page_len", "offset__data", "offset_def", "offset6data", "offset__off", "offset__desc", "page_dat", "position__off", "offsetCdat", "offsetndescription", "position__length", "offsetCdesc", "offset6def", "position__data", " offset_start", "position_off", "offset6dat", "offset6len", "size_description", "Offset_data", "size_desc", "offset_length", "offset_dat", "offsetndesc", "offset_start", "offset_len", "offset__length", "position_length", "position__desc", "page_def"], "pd": [" cf", " param", " plugin", " DP", " td", " FD", " dim", " proto", " disp", " dd", " dir", " su", " obj", " proc", " sd", " rc", " dc", " DF", " stats", " da", " cp", " mode", " o", " def", " backend", " sl", " std", " layout", " fs"], "pd_zero": ["dp_one", "pdfamfour", "pd2scale", "pdamnegative", "pdfamzero", "pdjzero", "pd__scale", "dc_none", "pd_token", "pd_error", "pdf_four", "dpjzero", "dc_zero", "pdf_zero", "pdf_slice", "pdjscale", "pd2one", "pd___low", "pd_slice", "pd_empty", "pd___small", "dpjone", "dc_scope", "hd_zero", "pd_negative", "pd_small", "pd__negative", "pdfamslice", "pd__zero", "dc_eight", "dd_empty", "pdjerror", "dp_zero", "pdfamnegative", "pd_low", "pd_none", "pd_four", "pdamzero", "hd_error", "pd__four", "pd__error", "pd_eight", "dd_six", "dd_zero", "pd_one", "dpjerror", "pd2error", "pd_scope", "pd_six", "dp_error", "pd___zero", "dd_token", "pd_scale", "pdf_negative", "pd__slice", "pdamslice", "dp_scale", "pd2zero", "pdjone", "dpjscale", "hd_low", "pdamfour", "pd__one", "hd_small", "pd___error"], "buf": ["cas", "header", "buff", "vec", "mem", "block", "box", "bd", "fw", "Buff", "rb", "config", "tmp", "b", "data", "home", "dest", "queue", "uc", "fb", "wb", "uf", "ru", "f", "conv", "fl", "bb", "buffer", "bag", "Buffer", "port", "func", "cmd", "nat", "pad", "bc", "cb", "fp", "ctx", "callback", "result", "seq", "pool", "context", "output", "batch", "runner", "alloc", "proc", "c", "fd", "cf", "br", "comb", "bo", "cv", "bl", "cache", "pb", "fi", "aux", "src", "img", "bh", "ff"], "block_iter": ["block_inner", "blockSinner", "blockSstack", " block_sort", " block_it", "block2info", "block__iterator", "block2sort", " block_stack", "block_sort", "block_stack", "block__iter", "blockSiter", " block_iterator", " block_info", "blockSiterator", "block2iter", "block_it", "block_iterator", "block__inner", "block2it", " block_inner", "block__stack", "block_info"], "pfn_iter": ["pfn_data", "pfn_inner", "pgn_err", "pgn_iter", "pfn_err", "pgn_inner", "pfn_enter"]}}
{"project": "qemu", "commit_id": "d516f74c99b1a2c289cfba0bacf125cbc9b681e3", "target": 0, "func": "static void do_ext_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    ExtQueue *q;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_EXT)) {\n\n        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;\n\n    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;\n\n    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {\n\n        g_assert(env->ext_index >= 0);\n\n        /*\n\n         * FIXME: floating IRQs should be considered by all CPUs and\n\n         *        shuld not get cleared by CPU reset.\n\n         */\n\n        q = &env->ext_queue[env->ext_index];\n\n        lowcore->ext_int_code = cpu_to_be16(q->code);\n\n        lowcore->ext_params = cpu_to_be32(q->param);\n\n        lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);\n\n        env->ext_index--;\n\n        if (env->ext_index == -1) {\n\n            env->pending_int &= ~INTERRUPT_EXT_SERVICE;\n\n        }\n\n    } else {\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 7332, "substitutes": {"env": ["energy", "reset", "ep", "press", "environment", "style", "oa", "et", "queue", "gui", "state", "ench", "gear", "conf", "ev", "code", "zone", "her", "here", "bc", "err", "exec", "equ", "Environment", "enh", "ou", "ec", "stage", "output", "dt", "engine", "conn", "ass", "vm", "config", "qt", "nc", "eu", "cal", "server", "ne", "viron", "eve", "cf", "site", " environment", "end", "eng", "er", "dat", "po", "exc", "db", "eq", "net", "ce", "np", "e", "que", "en", "dev", "erv", "global", "shell", "core", "cache", "app", "loader", "enable", "fen", "ea", "v", "qv", "scope", "session", "enc", "event", "args", "init", "context", "qa", "eni", "console", "cv", "manager", "cdn"], "cpu": ["cp", "cmp", "bench", "pid", "hw", "chip", "platform", "pu", "vm", "roc", "component", "nc", "sys", "gpu", "pc", "linux", "cli", "net", "np", "clock", "ctx", "bc", "process", "p", "pool", "processor", "boot", "eni", "proc", "c", "cn", "core", "mx", "lc", "hu", "cache", "loader", "CPU", "conn", "nu"], "mask": ["patch", "cmp", "pack", "pid", "flag", "header", "iq", "block", "id", "count", "bits", "spec", "shape", "channel", "bug", "skip", "sum", "data", "bit", "cat", "pattern", "info", "map", "max", "key", "mac", "window", "sk", "Mask", "carry", "mn", "weight", "ack", "conf", "delay", "code", "unk", "acl", "ck", "random", "depth", "comment", "scan", "allow", "sign", "kernel", "ask", "pass", "lock", "mark", "seq", "qa", "zero", "fix", "filter", "ip", "ban", "arch", "cache", "group", "index", "conn", "mode", "flags"], "addr": ["address", "dr", "area", "layer", "arm", "ag", "ann", "rt", "id", "md", "alt", "aa", "oa", "slice", "stack", "ad", "ace", "mac", "offset", "attr", "url", "nr", "ack", "align", "dist", "delay", "len", "part", "target", "depth", "code", "arr", "pad", "coord", "hop", "seq", "amp", "asm", "ptr", "pos", "node", "mx", "amd", "adr", "slot", "arch", "au", "ref", "index", "host", "src", "conn", "pkg", "az", "prefix"], "lowcore": ["lowermodel", "controlcenter", "fullcore", "hardsystem", "slowsystem", "libscore", "lowerscore", "lowerore", "slowobject", "controlcore", "flowsupport", "smallcore", "lowprocessor", " lowcode", "nowcp", " lowprocessor", "smallbase", "globalcache", " lowure", "lowsupport", " lowcp", "slowore", "hardcenter", "Lowbase", "controlsystem", "flowcode", "slowcontroller", "ledconn", "livecore", " lownode", "nowcore", "libore", "libcode", "longcore", "livecode", "lowcode", "ledcore", "ledcode", "flowore", "lowcomponent", "slowcenter", "globalore", "lowcenter", "libcomponent", "Lowcache", "Lowore", "lowercenter", "longsupport", "flowcore", "longprocessor", " lowcache", "nowcenter", "fullprocessor", "lowerobject", "Lowcore", "slowcache", "lowerprocessor", "lowure", "slowprocessor", "locache", "smallcenter", "lowcache", "flowure", "hardcore", " lowcontroller", "controlcase", "feedmodel", "locenter", "smallcode", "livecenter", "feedscore", "lowercomponent", "feedcore", "slowcomponent", "fullcenter", "smallprocessor", "longcenter", "libcore", " lowcenter", "nowprocessor", "lowobject", "liveconn", "lowsystem", "smallcp", "slowcore", "globalcore", "lowcase", "globalcenter", " lowconn", "libmodel", "Lowcenter", "locore", "lowscore", "Lowcode", "lowernode", "lowcontroller", "smallcache", "lowcp", "hardcase", "lowercore", "longbase", " lowbase", "fullcode", "slownode", "lownode", "ledcenter", "feedore", " lowsupport", "locontroller", " lowobject", "libcenter", "longcode", "lowore", "slowcase", "lowmodel", "lowbase", "libure", "flowcenter", "lowconn", " lowore"], "q": ["ch", "iq", "v", "id", "qq", "progress", "config", "qt", "sync", "queue", "qi", "quant", "cal", "f", "client", "ue", "dq", "j", "d", "eq", "cc", "ry", "u", "ck", "sh", "w", "que", "qs", "Q", "cmd", "k", "t", "question", "qu", "p", "seq", "qa", "req", "z", "c", "g", "sq", "query", "cache", "requ", "view", "quest"], "ext_index": ["xt_Index", "dist_size", "ext_Index", " ext_offset", "ext_offset", "dist_ind", "ext_level", "txt_index", "ext_count", "ext_ind", "txt_level", "xt_offset", "extsindex", " ext_id", " extsindex", "ext_size", "ext_position", "ext_address", "extsoffset", " extscount", "extscount", " extsoffset", "xt_index", "dist_level", "xt_ind", "extsid", "ext_id", " ext_count", "dist_index", " extsid", "txt_position", "txt_address"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n", "idx": 7334, "substitutes": {"machine": ["base", "mem", "vm", "device", "session", "config", "M", "gpu", "m", "image", "mac", "state", "linux", "service", "net", "connection", "instance", "Machine", "process", "computer", "boot", "node", "proc", "slave", "model", "cache", "loader", "manager", "mode"], "cpu_model": ["pixel_spec", "gpu_model", "pixel_model", "cpu_models", "cpu67location", "cpu__model", "cpu67spec", "cpuidmodel", "cpu_scale", "gpu_scale", "cpuworkmode", "cpu67model", "cpuablesize", "cpuablemodel", "pixel_size", "gpu_mode", "pixel__location", "pixel_location", "cpu_location", "cpuidmode", "gpu_space", "cpuworkspace", "cpu67size", "cpuworkmodel", "cpuidscale", "cpu__size", "cpu__location", "cpu_spec", "cpuablelocation", "cpuablespec", "cpu_mode", "cpu_space", " cpu_models", "pixel__spec", "cpuworkscale", "cpu__spec", "cpuidspace", "pixel__model", " cpu_mode", "pixel__size", "cpu_size"], "cpu": ["cp", "cmp", "bench", "gc", "hw", "chip", "mem", "platform", "pu", "vm", "io", " CPU", "gpu", "module", "uu", "unit", "ram", "pc", "linux", "net", "proxy", "clock", "instance", "kernel", "fps", "process", "result", "computer", "processor", "boot", "eni", "node", "memory", "proc", "GPU", "mx", "performance", "ilo", "lc", "core", "cache", "loader", "CPU", "conn", "copy"], "dinfo": ["pinfo", "dconfig", "finf", "pinf", "adinfo", "dbinfo", "dinf", "vdconf", "dfo", " dfi", "dbconfig", "dINFO", "ffo", "dInfo", "bfo", "ldinfo", "ldinf", "pfo", "pInfo", "dedinfo", "ldconf", "ffi", "fInfo", "vdfo", "dedconf", "dedInfo", " dconfig", "bconf", "dbINFO", "adINFO", "dbinf", "ldfi", " dinf", "dconf", " dfo", "finfo", " dInfo", "vdInfo", "binf", "ldfo", "adconfig", "vdinfo", "dedfo", "adinf", " dconf", " dINFO", "dfi", "binfo"], "be": ["replace", "enable", "nl", "BE", "bre", "ere", "le", "te", "are", "is", "Be", "b", "see", "use", "ignore", "ate", "bi", "ae", "ace", "ome", "ble", "bes", "de", "abe", "bee", "ve", "by", "fe", "ce", "byte", "eb", "ine", "e", " Be", "stop", "sb", "se", "we", "bis", "fore", "allow", "leave", "ape", " BE", "me", "ba", "ee", "ne", "scale", "ke", "range", "bf", "ro", "comb", "bl", "obe", "ze", "trace"], "address_space_mem": ["address_system_lim", "address_range_memory", "address_system_mem", "address_system_ram", "address_space_memory", "address_range_mem", "address_space_ram", "address_range_ram", "address_space_lim"]}}
{"project": "qemu", "commit_id": "e3737b820b45e54b059656dc3f914f895ac7a88b", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n    bs->read_only = 1; // no write support yet\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;", "idx": 7347, "substitutes": {"bs": ["bas", "base", "lb", "ins", "http", "bits", "mes", "bt", "als", "b", "ob", "lbs", "ros", "ses", "bi", "bing", "BS", "obs", "fb", "vals", "bes", "xs", "ns", "org", "ls", "iss", "bb", "ss", "cs", "bu", "las", "vs", "hs", "sb", "gs", "ks", "ops", "bis", "ds", "qs", "bytes", "bc", "ts", "ab", "outs", "ubs", "ec", "blocks", "css", "gb", "fs", "sa", "os", "utils", "bos", "ms", "ps", "bl", "pb", "rs", "bh", "js"], "options": ["option", "o", "bits", "config", "op", "io", "info", "details", "buf", "f", "stats", "obj", "args", "opens", "q", "ops", "lib", "ts", "outs", "Options", "settings", "opt", "fs", "os", "c", "params"], "flags": ["files", "flag", "reg", "bits", "features", "Flags", "format", "mask", "ips", "lag", "status", "details", "vals", "ants", "parts", "stats", "ats", "args", "opens", "ints", "ops", "bytes", "ents", "settings", " bits", "errors", "reads"], "errp": ["erfp", "erP", "aserp", "errorp", "evp", "errorpre", " errfp", "evjp", "errper", "aserpb", "errP", "errorper", "erpb", "evper", " errP", "evpre", "aserfp", "irper", " errpb", "errjp", "irp", "irpre", "erp", "errpb", "errorjp", "aserP", "errfp", "irjp", "errpre"], "s": ["_", "S", "b", "obs", "f", "parts", "state", "d", "hs", "all", "w", "h", "aws", "sa", "proc", "g", "sym", "sets", "is", "spec", "config", "rows", "services", "its", "states", "sl", "ls", "ops", "bis", "ds", "ts", "settings", "sv", "fs", "ms", "rs", "groups", "ins", "sg", "als", "sync", "ses", "cs", "vs", "e", "sb", "ks", "t", "qs", "ubs", "p", "css", "c", "ssl", "ps", "o", "http", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "args", "ss", "uns", "gs", "full", "n", "su", "utils", "es", "js"], "i": ["gi", "ri", "ti", "v", "id", "is", "I", "chi", "a", "di", "ci", "ki", "x", "ji", "ni", "b", "val", "si", "io", "bit", "abi", "xi", "info", "bi", "m", "qi", "ix", "key", "l", "f", "pi", "phi", "d", "ii", "j", "iu", "it", "ai", "uli", "u", "e", "out", "t", "k", "n", "multi", "ski", "ini", "p", "mini", "z", "c", "ip", "y", "il", "li", "inner", "fi", "index", "zi", "mu", "ui"], "bochs": ["Boichs", "crochls", "boachrs", "bovertains", "boochls", "bodefins", "bopathps", " boChn", "bochns", "boverts", " boChs", "bodefps", "bondefins", "bocountns", "bopathes", "wochs", "bochides", "cochs", "bochss", "boochses", "boichis", "bochnls", "bochnides", "Boichses", " bochses", "ouchls", "bacords", "ouchts", "bochards", "bochtts", "bochnss", "bochaops", "hochos", "coichis", "brochds", "bochtses", "boichos", "ooachs", "bochars", "boochs", "bacors", "boichts", "boichd", "bochots", "boichides", "crochns", " bochts", "bovertts", "Boichos", "boochos", " bochn", "woochts", "bochanls", "cochis", "bochops", "bocountls", "Boichd", "woochss", "bochys", "oochts", "bochts", "broachs", "wochains", "boochss", "bochyds", "boichns", "boachps", "Bochd", "bachls", "bondefsin", "bochtains", "hochoses", "Bochses", "ooachts", "hochses", "bopathts", "bocharts", "oochnls", "bochyses", "bochets", "boghs", "bochyts", "wochts", "boches", "oochnses", "crocounts", " boches", "bochds", "boctrs", "oochds", " boChrs", "oupaths", "Bochs", "bocheos", "bochan", "woochains", "boarches", "bocils", " bochets", "bocords", "bopaths", "bochtss", "bochps", "crocountns", "broachps", "bocharps", "bonchps", "broachds", "boChn", "bochess", "bonchsin", "bochet", "bochsin", "coichs", "oochns", "oupathts", "bochanns", "Bochos", "boarchls", " boichses", "boched", "bochnns", "bocountts", "boarchps", "bochses", "boChops", "cocht", "bocharsin", " bochns", "boctrses", "bachs", "hochots", "boichses", " bochis", " bochrs", "bochoses", "bacorls", "ouchs", "bocilis", "bocht", "bochnes", "boarchds", "ouches", "bochis", "bocheis", "boachds", "boochd", "oupathes", "bochnis", "boarchs", "bochn", "bondefps", "boochains", "bodefsin", "bopathls", " boichns", "hochts", " boichides", "crocountls", "boachn", " bochds", "bochas", " bocheis", "boichs", "oochls", "oupathls", "bochains", "oochs", "bochls", "bopathins", "brochps", "crochts", "bochnses", "hochs", "boght", "boochts", " boichds", "brochs", "boarchts", "bocheses", "boChrs", "boctrls", "bocharins", "bochos", "oochses", " boichts", "bopathsin", "bonchins", "boichds", "bochyns", " bochops", "crochs", "bochd", "bochnts", "boachops", "bochnds", "bochrs", "boachs", "bocorls", "boachts", "bodefs", "boicht", "bovertss", "crocountts", "bochants", "boChs", "wochss", "woochs", "bochins", "bocilss", "bocors", "bonchs", "bondefs", "bocounts", "bocharides", "coicht", " boChops", "ooachds", "bocilts", " bochss", "boghis", " bochess", "bachds", " boichs", "bochans", " bochides"], "ret": ["flag", "reg", "ag", "rt", "al", "sr", "count", "alt", "try", "nt", "val", "rc", "bit", "format", "art", "let", "reply", "pt", "part", " RET", "num", "lit", " Ret", "f", "att", "bad", "res", "arg", "match", "def", "len", "mt", "code", "det", "error", "out", "arr", "en", "RET", "t", "after", "pass", "feat", "err", "str", "result", "end", "Ret", "ft", "run", "re", "fail", "fun", "back", "g", "bf", "gt", "hash", "success", "ref", "group", "no", "r", "rets"]}}
{"project": "FFmpeg", "commit_id": "3b9a913db4d303a0305a80de496b1933cba8980f", "target": 1, "func": "offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)\n\n{\n\n    offset_t offset1;\n\n    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return -EINVAL;\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else {\n\n        if (!s->seek)\n\n            return -EPIPE;\n\n\n\n#ifdef CONFIG_MUXERS\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        } else\n\n#endif //CONFIG_MUXERS\n\n        {\n\n            s->buf_end = s->buffer;\n\n        }\n\n        s->buf_ptr = s->buffer;\n\n        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)\n\n            return -EPIPE;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}\n", "idx": 7351, "substitutes": {"s": ["serv", "S", "a", "b", "socket", "data", "i", "f", "d", "service", "conf", "self", "h", "aws", "g", "sym", "sets", "is", "spec", "services", "its", "server", "ls", "native", "ops", "ds", "ts", "outs", "south", "settings", "fs", "new", "sq", "ms", "your", "site", "rs", "as", "strings", "ins", "sg", "comments", "op", "sync", "ses", "conv", "esi", "cs", "u", "e", "sb", "t", "qs", "p", "css", "c", "os", "ssl", "ps", "o", "less", "http", "session", "si", "sys", "m", "in", "l", "xs", "side", "client", "ns", "args", "us", "ss", "uns", "gs", "se", "n", "su", "this", "es", "js"], "offset": ["base", "address", "o", "area", "position", "padding", "reset", "origin", "count", "fee", "skip", "data", "alias", "slice", "format", "i", "optional", "Offset", "queue", "adjust", "missing", "loc", "aligned", "url", "limit", "length", "order", "align", "number", "buffer", "len", "acl", "size", "error", "connection", "abyte", "point", "online", "bytes", "timeout", "fp", "offer", "seq", "p", "end", "ptr", "pos", "pointer", "alloc", "start", "off", "location", "type", "page", "api", "adjusted", "cache", "current", "index", "addr", "set", "shift", "slot"], "whence": ["iconcing", "whenced", "whences", "whenCE", "iconce", "Whencing", "arences", "arencer", "Whenced", " whencing", "whencing", "foreces", "arence", " whences", "thence", "WhenCE", "Whence", " whencer", "duringace", "arencing", "duringce", "arenace", "Whenace", "iconced", "arenced", "foreCE", "forece", "Whenke", "whencer", " whenced", "whenace", "duringke", " whenace", "Whences", "thenke", "thencing", "forecer", "whenke", "iconces", "thenace", "Whencer", "duringcing", " whenCE"], "offset1": [" offset2", "lengthOne", " offset_", "length0", "Offset01", "adjustOne", "off1", "Offset0", "align7", "OffsetOnce", "optionOne", "off_", "addr2", " offsetX", "pointer2", "adjust1", " offsetone", "adjust2", "length71", "offer71", "offer0", "align2", " offset01", "offset71", "align1", "offsetone", "option0", "Offset_", " offsetOne", "offsetOnce", "optionone", "offsetX", "adjustOnce", " offsetOnce", "offset_", " offset0", " offset7", "option1", "offOne", "off7", "Offset1", "off0", "OffsetOne", "offset2", "addrX", "offer1", "align01", " offset71", "OffsetX", "offset7", "align0", "addr1", "offsetOne", "offset01", "offset0", "pointer1", "off2", "lengthone", "length1", "offerone", "pointerOne", "Offset2"]}}
{"project": "qemu", "commit_id": "18b21a2f83a26c3d6a9e7f0bdc4e8eb2b177e8f6", "target": 0, "func": "void ppc_translate_init(void)\n\n{\n\n    int i;\n\n    char* p;\n\n    size_t cpu_reg_names_size;\n\n    static int done_init = 0;\n\n\n\n    if (done_init)\n\n        return;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    p = cpu_reg_names;\n\n    cpu_reg_names_size = sizeof(cpu_reg_names);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"crf%d\", i);\n\n        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                            offsetof(CPUState, crf[i]), p);\n\n        p += 5;\n\n        cpu_reg_names_size -= 5;\n\n    }\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"r%d\", i);\n\n        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,\n\n                                        offsetof(CPUState, gpr[i]), p);\n\n        p += (i < 10) ? 3 : 4;\n\n        cpu_reg_names_size -= (i < 10) ? 3 : 4;\n\n#if !defined(TARGET_PPC64)\n\n        snprintf(p, cpu_reg_names_size, \"r%dH\", i);\n\n        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, gprh[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n#endif\n\n\n\n        snprintf(p, cpu_reg_names_size, \"fp%d\", i);\n\n        cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                            offsetof(CPUState, fpr[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dH\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#else\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dL\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#else\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n    }\n\n\n\n    cpu_nip = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, nip), \"nip\");\n\n\n\n    cpu_msr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, msr), \"msr\");\n\n\n\n    cpu_ctr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, ctr), \"ctr\");\n\n\n\n    cpu_lr = tcg_global_mem_new(TCG_AREG0,\n\n                                offsetof(CPUState, lr), \"lr\");\n\n\n\n    cpu_xer = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, xer), \"xer\");\n\n\n\n    cpu_reserve = tcg_global_mem_new(TCG_AREG0,\n\n                                     offsetof(CPUState, reserve), \"reserve\");\n\n\n\n    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                       offsetof(CPUState, fpscr), \"fpscr\");\n\n\n\n    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, access_type), \"access_type\");\n\n\n\n    /* register helpers */\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    done_init = 1;\n\n}\n", "idx": 7360, "substitutes": {"i": ["isi", "I", "chi", "di", "ci", "xi", "b", "x", "bi", "iii", "f", "pi", "d", "ii", "code", "oi", "g", "y", "lc", "li", "fi", "index", "zi", "gi", "ti", "id", "ji", "slice", "abi", "info", "module", "ix", "phi", "it", "ai", "uri", "field", "mi", "jp", "ini", "ie", "z", "ip", "type", "anti", "ui", "fr", "ni", "ri", "io", "yi", "j", "cli", "u", "vi", "e", "t", "isin", "source", "ic", "hi", "c", "api", "mu", "ei", "o", "v", "si", "m", "ia", "qi", "l", "iu", "q", "init", "ori", "n", "multi", "eni", "inner"], "p": ["hp", "local", "a", "progress", "b", "x", "private", "f", "pi", "mp", "code", "per", "fp", "exec", "h", "vp", "sp", "g", "y", "tp", "current", "pb", "cp", "P", "wp", "ap", "pe", "at", "param", "port", "path", "jp", "z", "ip", "patch", "bp", "python", "pa", "po", "pp", "op", "lp", "like", "post", "j", "pc", "py", "np", "u", "e", "point", "dp", "t", "c", "api", "cache", "r", "ps", "o", "v", "prev", "pre", "up", "m", "l", "pg", "q", "part", "n", "after", "pointer", "br", "pair", "rep"], "cpu_reg_names_size": ["cpu_reg_name_address", "cpu_reg_name_size", "cpu_reg_codes_name", "cpu_reg_namespsize", "cpu_reg_codes_small", "cpu_reg_names_code", "cpu_reg_codes_size", "cpu_reg_names_scale", "cpu_reg_namespextra", "cpu_reg_codes_address", "cpu_reg_namespscale", "cpu_reg_name_large", "cpu_reg_names_type", "cpu_reg_names_large", "cpu_reg_names_extra", "cpu_reg_names_length", "cpu_reg_name_small", "cpu_reg_names_speed", "cpu_reg_name_ize", "cpu_reg_name_capacity", "cpu_reg_name_extra", "cpu_reg_names_ize", "cpu_reg_codes_length", "cpu_reg_codes_capacity", "cpu_reg_names_small", "cpu_reg_codes_code", "cpu_reg_codes_type", "cpu_reg_names_capacity", "cpu_reg_codes_scale", "cpu_reg_name_scale", "cpu_reg_namespcapacity", "cpu_reg_names_name", "cpu_reg_codes_speed", "cpu_reg_names_address"]}}
{"project": "qemu", "commit_id": "7d08d85645def18eac2a9d672c1868a35e0bcf79", "target": 0, "func": "static void gen_mtfsfi(DisasContext *ctx)\n\n{\n\n    int bf, sh;\n\n    TCGv_i64 t0;\n\n    TCGv_i32 t1;\n\n\n\n    if (unlikely(!ctx->fpu_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_FPU);\n\n        return;\n\n    }\n\n    bf = crbD(ctx->opcode) >> 2;\n\n    sh = 7 - bf;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_reset_fpstatus();\n\n    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));\n\n    t1 = tcg_const_i32(1 << sh);\n\n    gen_helper_store_fpscr(cpu_env, t0, t1);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0)) {\n\n        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);\n\n        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);\n\n    }\n\n    /* We can raise a differed exception */\n\n    gen_helper_float_check_status(cpu_env);\n\n}\n", "idx": 7380, "substitutes": {"ctx": ["cp", "cmp", "cgi", "hw", "anc", "cfg", "cr", "fw", "comm", "ci", "component", "config", "cus", "rc", "sync", "cca", "gpu", "loc", "cm", "tx", "client", "conv", "obj", "pc", "linux", "cc", "cli", "cs", "sci", "np", "kt", "sc", "que", "connection", "cam", "conn", "cmd", "cms", "cu", "exec", "Context", "cb", "bc", "jp", "context", "fp", "ca", "qa", "cpu", "kb", "utils", "c", "ct", "cn", "cf", "lc", "cv", "vc", "git", "cas", "ctrl", "pkg", "xc", "tc"], "bf": ["base", "FH", "buff", "sf", "kn", "BF", "bd", "fee", "rb", "bt", "b", " kb", "ffield", "fff", "fx", "fb", "uf", "f", "offset", "fl", "fe", "bb", "xb", "eb", "len", "sb", "hl", "xf", "bc", "fp", "cb", "nb", "mb", "ft", "fab", "gb", "kb", "sq", "fd", "cf", "fc", "bl", "ref", "lf", "pb", "lambda", "bh", "ff", "af"], "sh": ["ch", "eth", "square", "Sh", "sw", "s", "shi", "sync", "sn", "ssh", "loc", "hel", "ix", "cl", "sk", "wh", "kh", "f", "sl", "small", "q", "ffff", "ph", "ss", "sc", "SH", "sth", "se", "sb", "sd", "hl", "ff", "zh", "sch", "qu", "sha", "h", "ft", "resh", "sv", "sp", "gh", "ht", "sq", "bl", "iz", "ush", "bh", "shift", "osh", "size"], "t0": ["ta00", "te50", "Tii", "te25", "te1", " t25", "te00", "T0", "ttii", "tt50", "T1", "T10", "t3", "te0", "tii", "T3", "tt1", "t10", "tt0", "p1", "te8", "tt8", "p0", "tt00", "T00", "ta0", "T8", "p3", "t25", " t3", "tt25", "p10", "t00", "ta1", "t8", " t50", " t00", "t50", "teii", " t10"], "t1": [" t64", "T2", "tb", "i64", "t61", "tt01", "ttone", "ot1", "v01", "i2", "v1", "T01", "type01", "ot0", "T0", "ta2", " tone", "ti2", "T1", "i1", "v2", "i01", "type1", "ti64", "ta01", "tt1", " t61", "otb", "ti01", "tt61", "Tb", "T64", " t01", "ti1", " tb", "t64", "type61", "ot64", "tone", "t01", "ta1", "typeone", "t2"]}}
{"project": "qemu", "commit_id": "1e356fc14beaa3ece6c0e961bd479af58be3198b", "target": 1, "func": "void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n", "idx": 7393, "substitutes": {"fd": ["sf", " fa", "bd", "ef", " dir", "fff", "db", " sd", "f", " dc", " f", "d", "dir", " df", " da", "da", "ds", "dc", "df", " buf", "FD", " d", "fa", " fid", " def", "handler", "fc", "ff"], "area": ["base", "address", "ea", "large", "alpha", "a", "radius", " Area", "va", "aa", "data", "alias", "oa", "Area", "ia", "region", "image", "paper", "offset", " areas", "ra", "space", "dir", "zone", "section", "storage", "sea", "ba", "array", "aaa", "ATA", "ca", "qa", "rea", "aria", "ha", "folder", "prefix"], "memory": ["knowledge", "address", "time", "padding", "large", "uration", "mem", "count", "complete", "total", "wave", "shape", "cover", "medium", "data", "usage", "record", "queue", "m", "image", "region", "resource", "capacity", "media", "order", "metadata", "length", "maximum", "space", "duration", "margin", "buffer", "size", "number", "message", "storage", "mi", "array", "scale", "mini", "network", "write", "mm", "page", "mx", "performance", "cache", "activity", "age", "Memory", "external"], "errp": ["errr", "erp", "errorp", "erpc", "errorpc", "erfp", " errfp", " errpc", "err", "errorr", "errorfp", "errfp", "errpc", " errr"], "i": ["base", "gi", "ti", "id", "I", "a", "di", "ci", "ji", "ni", "x", "b", "si", "io", "data", "xi", "ri", "info", "bi", "m", "image", "qi", "ix", "l", "f", "pi", "phi", "j", "ii", "iu", "ai", "u", "number", "e", "ami", "uri", "n", "multi", "ini", "p", "mini", "z", "eni", "start", "oi", "hi", "c", "page", "li", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "4029f05c8b0943a5446f254142d5e2bfedb50a0d", "target": 1, "func": "static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    CuvidContext *ctx = avctx->priv_data;\n\n    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data;\n\n    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;\n\n    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;\n\n    AVFrame *frame = data;\n\n    CUVIDSOURCEDATAPACKET cupkt;\n\n    AVPacket filter_packet = { 0 };\n\n    AVPacket filtered_packet = { 0 };\n\n    CUdeviceptr mapped_frame = 0;\n\n    int ret = 0, eret = 0;\n\n\n\n    if (ctx->bsf && avpkt->size) {\n\n        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_packet_ref failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_send_packet failed\\n\");\n\n            av_packet_unref(&filter_packet);\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_receive_packet failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        avpkt = &filtered_packet;\n\n    }\n\n\n\n    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));\n\n    if (ret < 0) {\n\n        av_packet_unref(&filtered_packet);\n\n        return ret;\n\n    }\n\n\n\n    memset(&cupkt, 0, sizeof(cupkt));\n\n\n\n    if (avpkt->size) {\n\n        cupkt.payload_size = avpkt->size;\n\n        cupkt.payload = avpkt->data;\n\n\n\n        if (avpkt->pts != AV_NOPTS_VALUE) {\n\n            cupkt.flags = CUVID_PKT_TIMESTAMP;\n\n            if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n                cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000});\n\n            else\n\n                cupkt.timestamp = avpkt->pts;\n\n        }\n\n    } else {\n\n        cupkt.flags = CUVID_PKT_ENDOFSTREAM;\n\n    }\n\n\n\n    ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));\n\n\n\n    av_packet_unref(&filtered_packet);\n\n\n\n    if (ret < 0) {\n\n        if (ctx->internal_error)\n\n            ret = ctx->internal_error;\n\n        goto error;\n\n    }\n\n\n\n    if (av_fifo_size(ctx->frame_queue)) {\n\n        CUVIDPARSERDISPINFO dispinfo;\n\n        CUVIDPROCPARAMS params;\n\n        unsigned int pitch = 0;\n\n        int offset = 0;\n\n        int i;\n\n\n\n        av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL);\n\n\n\n        memset(&params, 0, sizeof(params));\n\n        params.progressive_frame = dispinfo.progressive_frame;\n\n        params.second_field = 0;\n\n        params.top_field_first = dispinfo.top_field_first;\n\n\n\n        ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params));\n\n        if (ret < 0)\n\n            goto error;\n\n\n\n        if (avctx->pix_fmt == AV_PIX_FMT_CUDA) {\n\n            ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_get_buffer failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            ret = ff_decode_frame_props(avctx, frame);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_decode_frame_props failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            for (i = 0; i < 2; i++) {\n\n                CUDA_MEMCPY2D cpy = {\n\n                    .srcMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .dstMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .srcDevice     = mapped_frame,\n\n                    .dstDevice     = (CUdeviceptr)frame->data[i],\n\n                    .srcPitch      = pitch,\n\n                    .dstPitch      = frame->linesize[i],\n\n                    .srcY          = offset,\n\n                    .WidthInBytes  = FFMIN(pitch, frame->linesize[i]),\n\n                    .Height        = avctx->coded_height >> (i ? 1 : 0),\n\n                };\n\n\n\n                ret = CHECK_CU(cuMemcpy2D(&cpy));\n\n                if (ret < 0)\n\n                    goto error;\n\n\n\n                offset += avctx->coded_height;\n\n            }\n\n        } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) {\n\n            AVFrame *tmp_frame = av_frame_alloc();\n\n            if (!tmp_frame) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\");\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n\n\n            tmp_frame->format        = AV_PIX_FMT_CUDA;\n\n            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);\n\n            tmp_frame->data[0]       = (uint8_t*)mapped_frame;\n\n            tmp_frame->linesize[0]   = pitch;\n\n            tmp_frame->data[1]       = (uint8_t*)(mapped_frame + avctx->coded_height * pitch);\n\n            tmp_frame->linesize[1]   = pitch;\n\n            tmp_frame->width         = avctx->width;\n\n            tmp_frame->height        = avctx->height;\n\n\n\n            ret = ff_get_buffer(avctx, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);\n\n            if (ret) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            av_frame_free(&tmp_frame);\n\n        } else {\n\n            ret = AVERROR_BUG;\n\n            goto error;\n\n        }\n\n\n\n        frame->width = avctx->width;\n\n        frame->height = avctx->height;\n\n        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n            frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);\n\n        else\n\n            frame->pts = dispinfo.timestamp;\n\n\n\n        /* CUVIDs opaque reordering breaks the internal pkt logic.\n\n         * So set pkt_pts and clear all the other pkt_ fields.\n\n         */\n\n        frame->pkt_pts = frame->pts;\n\n        av_frame_set_pkt_pos(frame, -1);\n\n        av_frame_set_pkt_duration(frame, 0);\n\n        av_frame_set_pkt_size(frame, -1);\n\n\n\n        frame->interlaced_frame = !dispinfo.progressive_frame;\n\n\n\n        if (!dispinfo.progressive_frame)\n\n            frame->top_field_first = dispinfo.top_field_first;\n\n\n\n        *got_frame = 1;\n\n    } else {\n\n        *got_frame = 0;\n\n    }\n\n\n\nerror:\n\n    if (mapped_frame)\n\n        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));\n\n\n\n    eret = CHECK_CU(cuCtxPopCurrent(&dummy));\n\n\n\n    if (eret < 0)\n\n        return eret;\n\n    else\n\n        return ret;\n\n}\n", "idx": 7398, "substitutes": {"avctx": ["versync", "avfw", "avctl", "avsync", "manctx", "Avkb", "averbc", "varcca", "AVlc", "avectx", "aflc", "navfw", "avercontext", "afctl", "manlc", "vercontext", "AVctx", "AVcontext", "averctx", "avesync", "avbc", "avecp", "avcca", "navcontext", "vercp", "varcontext", "afctx", "affw", "AVctl", "afsync", "afcp", "avcontext", "avcp", "Avbc", "mancontext", "Avcontext", "varfw", "verctx", "Avctx", "avecontext", "AVcp", "avlc", "avkb", "afcontext", "navctx", "avelc", "navcca", "afcca", "manctl", "varctx", "AVbc", "averkb", "AVkb"], "data": ["slice", "base", "as", "name", "block", "open", "a", "parent", "dat", "device", "value", "scope", "config", "channel", "val", "style", "family", "format", "database", "ad", "module", "record", "image", "missing", "body", "buf", "window", "package", "content", "client", "post", "offset", "media", "call", "length", "DATA", "def", "buffer", "da", "raw", "storage", "received", "message", "Data", "after", "pad", "volume", "response", "load", "result", "context", "input", "root", "reader", "batch", "start", "new", "read", "video", "sample", "desc", "next", "cache", "addr", "loader", "first", "ui", "size"], "got_frame": ["filter_frame", "filtervalname", "get_name", "filter__frame", "filtervalframe", "get_data", "filter__data", "filter_name", "get_frame", "get_time", "filtervaltime", "filter_data", "filter__name", "filter_time", "filter__time", "filtervaldata"], "avpkt": [" avcpke", "avfce", "avpce", "avlpkt", "avppt", " avpacket", "avlpke", "avnpct", "afpkh", "avPkt", "avciece", "ovpwk", "avcpacket", "aveppkt", "avckg", "avjpck", "avpqt", "avupka", "avpece", "afpacket", "avpck", "avpbqt", "avcpwk", "avlpkg", "avcpkg", "avpett", "avPacket", "ovpacket", "avnppt", "avfkt", "affkg", "ovpbqt", "avPke", "affkh", "avnpck", "ovpbwk", "avfiece", "avjpett", "ajpce", "avfwk", "avepck", "ajpka", "affkt", "avckt", "avfdt", "avppnt", "avjpacket", " avpke", "afpiece", "avjpkt", "avppett", "avnqt", "avpbacket", "avparamiece", "ajpeacket", "afpwk", "avfacket", "avnpnt", "avlpkh", "avupkt", "ajpece", "avupacket", "avlpiece", "avefett", "avcompwk", "ovpbacket", " avcpkg", "ovpbkt", "avpct", "avupce", "avpwk", "avpiece", "avppkt", "avlpacket", "avpeka", " avcpkt", "aveppck", "avpkh", "avppck", "avfett", "avpka", "afpkg", "avbppt", "ajpeka", "avpbkt", "avnacket", "ajpacket", "avcompdt", " avcpacket", "affwk", "aveppett", "avepct", "avcompkt", "avbpkt", "avjpnt", " avpkg", "avpdt", "ovpqt", "avnwk", "avparamacket", "avcacket", "avnkt", "avefct", "ajpekt", "avpacket", "avpekt", "avfka", "avbpett", "aveppt", "aveppnt", "avparamkh", "ovpkt", "avefpt", "avpnt", "ajpkt", "avcompacket", "avnpkt", "avpeacket", "avjpiece", "avfpt", "afpkt", "avcpkt", "avfqt", "avnpett", "avepett", "avepnt", "avfkh", "avPkg", "afpdt", "avpkg", "affiece", "avefkt", "avparamkt", "avpbwk", "avcpdt", "avcpke", "avjpkg", "avepkt", "avfct", "avbpct", "affdt", "avpke", "affacket", "avfkg"], "ctx": ["cp", "cmp", "hw", "anc", "cfg", "hub", "ci", "nt", "component", "scope", "config", "qt", "cus", "cca", "nc", "sync", "concept", "loc", "window", "tx", "mac", "event", "client", "conv", "pc", "cc", "sci", "conf", "np", "ck", "sc", "connection", "cam", "conn", "cmd", "wcs", "bc", "instance", "cms", "Context", "lib", "cu", "prefix", "context", "kw", " context", "ca", "ctrl", "qa", "kb", "c", "ct", "sq", "cf", "lc", "cn", "cv", "vc", "ha", "cas", "cm", "pkg", "xc", "tc"], "device_ctx": ["dev_tx", "dev_context", "device__loc", "device_conn", "dev_loc", "dev_conn", "device_loc", "device_tx", "device_context", "device_pkg", "device__conn", "device__ctx", "dev_pkg", "device__tx", "device__pkg", "device__context", "dev_ctx"], "device_hwctx": ["device_bootconfig", "device_hawcontext", "device_bootcmp", "device_hwcontext", "device_fwcmp", "device_bootcontext", "device_hwcmp", "device_fwconn", "device_hawconfig", "device_wcontext", "device_hwconn", "device_wconfig", "device_hawconn", "device_fwctx", "device_hwconfig", "device_bootconn", "device_wcmp", "device_bootctx", "device_hawctx", "device_fwcontext", "device_fwconfig", "device_wctx"], "dummy": ["dao", "ndao", "dnp", "summies", "summy", "odummies", "odao", "odnp", "dummies", "ndummies", "ndnp", "snp", "sao", "ndummy", "odummy"], "frame": ["flow", "block", "component", "channel", "session", "config", "object", "iframe", "slice", "family", "module", "image", "ace", "Frame", "window", "event", "document", "part", "buffer", "point", "fram", "instance", "seq", "shot", "board", "frames", "element", "setup"], "cupkt": ["supett", "cupacket", "cpkt", "cppkt", "cfett", "copcht", "cmpacket", " cupKT", " cupett", " cupcht", "rupcht", "supnt", " cuptxt", " cupnt", "copkt", "appcht", "supacket", "cmpKT", "rupett", "appelt", "rupnt", "cppcht", " cupacket", "copdt", "upacket", "cppdt", "upkt", "cfkt", " cupelt", "cupKT", "uptKT", "rupkid", "cmpkt", "cfcht", "cupnt", "cupdt", "upttxt", "uptacket", "copacket", "uptnt", "supkt", "upnt", "cuptxt", "rupkt", "cpnt", "appkt", "cupett", "cpacket", " cupkid", "cmpett", "uptxt", "rupacket", "uptkt", "rupdt", "cfelt", "cppacket", "cupcht", "cupelt", "cpkid", "appett", "cupkid", "cmpnt"]}}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n", "idx": 7420, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)\n\n{\n\n    __asm__ volatile(\n\n        \"movdqa   0x10(%1), %%xmm1 \\n\"\n\n        \"movdqa   0x20(%1), %%xmm2 \\n\"\n\n        \"movdqa   0x30(%1), %%xmm3 \\n\"\n\n        \"movdqa   0x50(%1), %%xmm5 \\n\"\n\n        \"movdqa   0x60(%1), %%xmm6 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm7 \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)\n\n        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))\n\n        \"paddw          %4, %%xmm4 \\n\"\n\n        \"movdqa     %%xmm4, 0x00(%1) \\n\"\n\n        \"movdqa     %%xmm2, 0x40(%1) \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)\n\n        \"movdqa     %%xmm6, 0x60(%1) \\n\"\n\n        \"movdqa     %%xmm7, 0x70(%1) \\n\"\n\n        \"pxor       %%xmm7, %%xmm7 \\n\"\n\n        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)\n\n        \"lea     (%0,%2,4), %0 \\n\"\n\n        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)\n\n        \"movdqa   0x60(%1), %%xmm0 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm1 \\n\"\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)\n\n        :\"+r\"(dst)\n\n        :\"r\"(block), \"r\"((x86_reg)stride), \"r\"((x86_reg)3L*stride), \"m\"(ff_pw_32)\n\n    );\n\n}\n", "idx": 7428, "substitutes": {"dst": [" dsc", "Dst", " dfe", "fbl", "Dfe", "dbl", " dbl", "Dsc", "fst", "Dbl", "ffe", "dfe", "dsc", "fsc"], "block": ["Block", "name", "row", "prev", "device", "pre", "unit", "buf", "num", "def", "buffer", "stop", "len", "w", "out", "self", "lock", "blocks", "batch", "frame", "none", "off", "ip", "orig", "type", "no", "end"], "stride": ["estiding", "Striding", "Strider", "strides", " strides", " strider", "Strides", "striding", " striding", "estide", "estides", "estider", "strider", "Stride"]}}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n    unsigned int oldsize;\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    stw(p + 0, 0x0040);\n\n    stw(p + 1, s->cylinders); \n\n    stw(p + 3, s->heads);\n\n    stw(p + 4, 512 * s->sectors); /* sectors */\n\n    stw(p + 5, 512); /* sector size */\n\n    stw(p + 6, s->sectors); \n\n    stw(p + 20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n", "idx": 7430, "substitutes": {"s": ["sf", "S", "a", "comm", "b", "data", "i", "f", "parts", "state", "d", "service", "hs", "conf", "w", "h", "aws", "sa", "g", "sym", "y", "tp", "sets", "is", "spec", "services", "its", "states", "ls", "sl", "sie", "ds", "ts", "settings", "sv", "fs", "sq", "site", "lines", "rs", "as", "ans", "ins", "sg", "sync", "ses", "ions", "j", "cs", "sis", "e", "sb", "t", "qs", "c", "os", "ssl", "r", "ps", "o", "v", "session", "words", "si", "sys", "m", "l", "xs", "side", "ns", "us", "ss", "gs", "n", "params", "es", "js"], "p": ["hp", "press", "a", "progress", "pat", "b", "x", "data", "i", "f", "pi", "mp", "d", "pop", "per", "fp", "vp", "sp", "proc", "g", "y", "page", "tp", "current", "pb", "cp", "P", "wp", "pe", "ap", "at", "it", "port", "jp", "z", "ip", "pl", "patch", "er", "bp", "pro", "pa", "tmp", "po", "pp", "op", "or", "lp", "post", "j", "pc", "ph", "np", "u", "e", "dp", "point", "t", "k", "c", "api", "r", "ps", "o", "v", "pr", "prev", "pre", "up", "m", "l", "pg", "q", "part", "n", "pointer", "br"], "oldsize": ["olderweight", " oldSize", "OLDSize", "lowsmall", " oldweight", "lowloc", "oldaddress", "oldsmall", " oldsmall", "oldscale", "OLDsize", "prevscale", "prevSIZE", "lowaddress", " oldaddress", "lowsize", "oldloc", "oldweight", " oldscale", "oldSIZE", "olderaddress", "OldSize", " oldSIZE", " oldloc", "OLDscale", "OLDsmall", "OLDloc", "OLDaddress", "Oldsmall", "Oldsize", "OLDweight", "OLDSIZE", "oldersmall", "oldersize", "prevsize", "prevshape", "oldshape", "Oldaddress", "oldSize", "OLDshape", " oldshape"]}}
{"project": "FFmpeg", "commit_id": "7ec9c5ce8a753175244da971fed9f1e25aef7971", "target": 0, "func": "static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n\n                       const AVFrame *pict, int *got_packet)\n\n{\n\n    PNGEncContext *s = avctx->priv_data;\n\n    int ret;\n\n    int enc_row_size;\n\n    size_t max_packet_size;\n\n    APNGFctlChunk fctl_chunk = {0};\n\n\n\n    if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));\n\n\n\n        if (avctx->frame_number == 0) {\n\n            s->palette_checksum = checksum;\n\n        } else if (checksum != s->palette_checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input contains more than one unique palette. APNG does not support multiple palettes.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);\n\n    max_packet_size =\n\n        AV_INPUT_BUFFER_MIN_SIZE + // headers\n\n        avctx->height * (\n\n            enc_row_size +\n\n            (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)\n\n        );\n\n    if (max_packet_size > INT_MAX)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (avctx->frame_number == 0) {\n\n        if (!pict)\n\n            return AVERROR(EINVAL);\n\n\n\n        s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);\n\n        if (!avctx->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = encode_headers(avctx, pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avctx->extradata_size = s->bytestream - avctx->extradata;\n\n\n\n        s->last_frame_packet = av_malloc(max_packet_size);\n\n        if (!s->last_frame_packet)\n\n            return AVERROR(ENOMEM);\n\n    } else if (s->last_frame) {\n\n        ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n\n        pkt->size = s->last_frame_packet_size;\n\n        pkt->pts = pkt->dts = s->last_frame->pts;\n\n    }\n\n\n\n    if (pict) {\n\n        s->bytestream_start =\n\n        s->bytestream       = s->last_frame_packet;\n\n        s->bytestream_end   = s->bytestream + max_packet_size;\n\n\n\n        // We're encoding the frame first, so we have to do a bit of shuffling around\n\n        // to have the image data write to the correct place in the buffer\n\n        fctl_chunk.sequence_number = s->sequence_number;\n\n        ++s->sequence_number;\n\n        s->bytestream += 26 + 12;\n\n\n\n        ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        fctl_chunk.delay_num = 0; // delay filled in during muxing\n\n        fctl_chunk.delay_den = 0;\n\n    } else {\n\n        s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;\n\n    }\n\n\n\n    if (s->last_frame) {\n\n        uint8_t* last_fctl_chunk_start = pkt->data;\n\n        uint8_t buf[26];\n\n\n\n        AV_WB32(buf + 0, s->last_frame_fctl.sequence_number);\n\n        AV_WB32(buf + 4, s->last_frame_fctl.width);\n\n        AV_WB32(buf + 8, s->last_frame_fctl.height);\n\n        AV_WB32(buf + 12, s->last_frame_fctl.x_offset);\n\n        AV_WB32(buf + 16, s->last_frame_fctl.y_offset);\n\n        AV_WB16(buf + 20, s->last_frame_fctl.delay_num);\n\n        AV_WB16(buf + 22, s->last_frame_fctl.delay_den);\n\n        buf[24] = s->last_frame_fctl.dispose_op;\n\n        buf[25] = s->last_frame_fctl.blend_op;\n\n        png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);\n\n\n\n        *got_packet = 1;\n\n    }\n\n\n\n    if (pict) {\n\n        if (!s->last_frame) {\n\n            s->last_frame = av_frame_alloc();\n\n            if (!s->last_frame)\n\n                return AVERROR(ENOMEM);\n\n        } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            if (!s->prev_frame) {\n\n                s->prev_frame = av_frame_alloc();\n\n                if (!s->prev_frame)\n\n                    return AVERROR(ENOMEM);\n\n\n\n                s->prev_frame->format = pict->format;\n\n                s->prev_frame->width = pict->width;\n\n                s->prev_frame->height = pict->height;\n\n                if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n\n                    return ret;\n\n            }\n\n\n\n            // Do disposal, but not blending\n\n            memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n\n                   s->last_frame->linesize[0] * s->last_frame->height);\n\n            if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {\n\n                uint32_t y;\n\n                uint8_t bpp = (s->bits_per_pixel + 7) >> 3;\n\n                for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n\n                    size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n\n                    memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);\n\n                }\n\n            }\n\n        }\n\n\n\n        av_frame_unref(s->last_frame);\n\n        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        s->last_frame_fctl = fctl_chunk;\n\n        s->last_frame_packet_size = s->bytestream - s->bytestream_start;\n\n    } else {\n\n        av_frame_free(&s->last_frame);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7448, "substitutes": {"avctx": ["verctl", "avecb", "afctrl", "ivcdn", "versci", "avercontext", "verpkg", "averwindow", " avcb", "avecoll", "ivcontext", "navcontext", "ivctx", "avcb", "afctx", "auconn", "AVctl", "avwindow", "umcontext", "navctx", " avcontext", "afcit", "vercoll", "avecit", "avcdn", "aucontext", "auctrl", "afcb", "aucu", "afloc", "afcmp", "aucca", "avcmp", "avalctx", "AVcmp", "avecontext", "navloc", "afcf", "avlc", "navcdn", "AVconfig", "avctrl", " avcu", "avecu", "avelc", "avalcontext", "ivcu", "averlc", "verconfig", "avalcit", "aflc", "afctl", "vercontext", "avectrl", "afwindow", "avcu", "avconfig", "AVcontext", "afsci", "averctx", "avcms", "avcca", "umctx", "umctrl", "avcontext", "afpkg", "afcoll", "afcdn", "avsci", "avesci", " avpkg", "avloc", "avconn", "AVpkg", "auloc", "avctl", "afcms", "vercca", "avectx", "avepkg", "AVctx", "avcoll", "avcf", "ivconn", "umcms", "aucms", "avewindow", "verctx", "ivctrl", "avcit", "avalcb", "aupkg", "aucf", "afconn", "avpkg", "afcontext", "afconfig", "afcca", "auctx", "vercmp", " avsci", "afcu", "navconn", "vercf"], "pkt": ["jpkt", "jpacket", "Pkt", "jpnt", " pqt", " pnt", "pqt", "pnt", "packet", "jpqt", "Pnt", "Pqt", "Packet", " packet"], "pict": ["stat", "cp", "fat", "ch", "act", "gif", "sec", "scroll", "prev", "qq", "asa", "config", "qt", "tmp", "enc", "cat", "image", "quant", "imag", "csv", "picture", "lit", "client", "gui", "obj", "mot", "phot", " pictures", "sci", "cli", "conf", "cam", "bis", "ctx", "chart", "feat", "Pict", "pty", "qa", " img", "pic", "fig", "doc", "proc", "capt", "txt", "ct", "photo", "next", "png", "fi", "aux", "chat", "img", "cot", "conn", " picture", " pic", "Pic"], "got_packet": ["got_paramets", "got_parampoint", "got_classed", "got_packpoint", "got_duets", "got_dupoint", "got_dued", "got_classpoint", "got_duet", "got_classets", "got_classet", "got_paramet", "got_packed", "got_paramed", "got_packets"], "s": ["r", "o", "sets", "v", "is", "S", "a", "spec", "sg", "session", "b", "data", "si", "sync", "sys", "ses", "services", "m", "l", "xs", "f", "parts", "ns", "d", "stats", "ls", "space", "service", "cs", "ss", "u", "hs", "conf", "e", "sc", "w", "gs", "sb", "ks", "uns", "ops", "qs", "t", "n", "ds", "storage", "ts", "p", "settings", "css", "h", "aws", "sv", "utils", "c", "g", "ssl", "sq", "sym", "your", "params", "es", "rs", "ps", "js"], "ret": ["std", "flag", "reg", "sr", "rt", "id", "mem", "alt", "al", "nt", "lt", "val", "last", "rc", "bit", "cat", "format", "let", "reply", " RET", "num", " Ret", "fin", "lit", "ext", "att", "pet", "arg", "res", "bad", "match", "def", "part", "len", "mt", "code", "det", "en", "arr", "error", "RET", "t", "pass", "feat", "result", "Ret", "ft", "ut", "re", "fun", "back", "bf", "gt", "success", "ref", "max", "rets"], "enc_row_size": ["enc_row_sum", "enc_row64size", "enc_rows_number", "enc_rows_rate", "enc_row1number", "enc_rows_offset", "enc_col_width", "enc_row2time", "enc_row_number", "enc_row_capacity", "enc_row2width", "enc_row64time", "enc_row_offset", "enc_rows_width", "enc_row1offset", "enc_row32size", "enc_row_time", "enc_row2size", "enc_rows_size", "enc_row64capacity", "enc_col_time", "enc_row32number", "enc_col_capacity", "enc_rows_shift", "enc_row_shift", "enc_row1size", "enc_row_rate", "enc_row32offset", "enc_row64width", "enc_rows_sum", "enc_row_width", "enc_col_size", "enc_row2capacity"], "max_packet_size": ["_", "buffer", "g", "max_packet_scale", "max_packacket_clean", "feed", "max_packacket_address", "max_packet_length", "max_packet_clean", "max_packet_sized", "r", "max_packacket_size", "max_packet_number", "max_packacket_length", "max_packacket_sized", "max_packacket_scale", "max_packacket_number", "max_packet_address"]}}
{"project": "qemu", "commit_id": "d62b5dea30284eacd88055bb08db7c295655945f", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                                 QEMUIOVector *qiov, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,\n\n                              cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->rd_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7449, "substitutes": {"bs": ["base", "bas", "lb", "ins", "is", "bits", "nas", "s", "plugins", "b", "ob", "bps", "sync", "abi", "sys", "ses", "bing", "BS", "obs", "fb", "db", "bes", "ns", "ls", "obj", "iss", "las", "cs", "bu", "ss", "eb", "vs", "us", "sb", "gs", "ks", "banks", "bis", "ds", "bytes", "bc", "ts", "outs", "fps", "ubs", "blocks", "css", "fs", "os", "bos", "bid", "lc", "pb", "ps", "js"], "sector_num": [" sector_number", "sector_no", "section_id", "section_name", "sector_id", "sector_range", "section_range", "sector2num", " sector_name", "sector_name", "sector2name", "section_num", "sector2no", "sector2number", "section_sum", "section_number", "sector_sum", " sector_no", "sector_number"], "qiov": ["dovi", "qliv", "diov", "qiop", "rliv", "Qiol", "Qicho", " qicho", "qicho", "diop", " qiol", "adregor", "qregor", "dliv", " qregor", "riov", "adicho", "adiov", "qovi", " qiop", "adiol", " qliv", "Qiov", "rovi", "riop", "Qregor", "qiol", " qovi"], "nb_sectors": ["nb_SEors", "nbjsectors", "nb_veors", "nbjsemvers", "nb_vectors", "nb_sigments", "nb_geriers", "nb_gectors", "nb_veriers", "nbjsevers", "nbjseves", "nb_geors", "nb_vearers", "nb_spections", "nb_serctor", "nb_sictors", "nb_sefs", "nb_gearers", "nbjsemctors", "nb_semctors", "nb_vector", "nb_vegments", "nb_vections", "nb_seivers", "nb_segments", "nb_searers", "nb_seriers", "nb_semvers", "nb_seves", "nb_serctors", "nb_SEriers", "nbjsemves", "nb_sector", "nbjsegments", "nb_SEgments", "nb_pectors", "nbjsemgments", "nb_spegments", "nb_pector", "nb_spectors", "nb_spefs", "nb_servers", "nb_secctors", "nb_gegments", "nb_secctions", "nb_sections", "nb_pegments", "nb_severs", "nb_sives", "nb_secgments", "nb_sergments", "nb_peivers", "nb_serves", "nb_semves", "nb_vefs", "nb_semgments", "nb_seors", "nb_serivers", "nb_veivers", "nb_SEctors", "nb_sivers", "nb_gections", "nb_spearers", "nb_secfs"], "cb": ["abc", "CB", "gc", "cfg", "unc", "obb", "rb", "ob", "nc", "kk", "orb", "fb", "db", "buf", "abb", "pc", "bb", "xb", "eb", "sb", "func", "fn", "cmd", "ctx", "bc", "callback", "ec", "fun", "c", "bf", "cf", "lc", "fc", "cv", "cod", "pb", "library", "cd"], "opaque": [" opec", "uppaque", "opatile", "opque", "opusaque", " opesc", "iopesc", "iopacity", "iopity", " opque", "ospacity", "ospaque", "uppque", " opity", "opusacity", "octacity", "opusaques", "ospatile", "octaque", "opec", "opesc", " opacity", "octity", "copec", "uppacity", " opatile", "opaques", "octesc", "opusatile", "ospaques", "copaque", "uppec", "opacity", "copque", " opaques", "iopaque", "opity", "copacity"], "drv": ["hrm", "srm", "hrk", "hrv", "drb", "drc", "hrf", "Drv", "drm", " drm", " drf", "hrc", "drV", " drc", "Drb", "Drf", "srk", "hrV", "drk", "DrV", "srf", " drk", "drf", " drV", "hrb", "srv", " drb", "srb", "Drc"], "ret": ["fire", "base", "gc", "ig", "reg", "flag", "mem", "rt", "cur", "alt", "bd", "nt", "rb", "val", "rc", "secret", "real", "bit", "cat", "data", "info", "reply", "sys", "valid", "db", "job", "f", "lit", "att", "obj", "arg", "res", "match", "def", "part", "len", "det", "out", "secondary", "RET", "bot", "ben", "feat", "str", "rev", "bare", "result", "ut", "Ret", "ft", "re", "fun", "back", "bf", "resp", "gt", "utf", "desc", "ref", "fi", "rets"], "rd_ops": ["rs_bits", "rs_ops", "rd_bytes", "rs_ips", "rd_bits", "rs_bytes", "rd_ips"]}}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n", "idx": 7458, "substitutes": {"who": ["whose", "name", "someone", "cgi", "ko", "la", "eth", "san", "home", "wa", "nick", "wh", "how", "foo", "wo", "gob", "which", "cli", "organ", "from", "gmail", "lo", "que", "what", "da", "woman", "har", "hou", "wife", " Who", "ou", "whe", "staff", "where", "Who", "WHO", "hi", "gh", "gram", "bo", "ha", " wo", "hello"], "value": ["function", "name", "time", "v", "change", "entry", "values", "update", "val", "password", "data", "style", "place", "format", "unit", "key", "null", "valid", "content", "how", "money", "state", "server", "property", "w", "message", "Value", "VALUE", "range", "new", "type", "set", "index", "command", "end"], "rsp": ["Rsp", "yrp", "rso", "Rsc", "rp", "srps", " rps", "srsl", " rp", "nrso", "rst", "nrsp", "Rso", "yrsp", "nrp", "srsp", "risp", " rmp", "srst", "srmp", " rst", " rsl", "yrmp", "rsl", "Rp", "srisp", " risp", "rsc", "srp", "rrsl", "Risp", "srsc", "rrsp", "yrps", "rrst", " rsc", " rso", "rps", "nrsc", "rmp"], "cmd": ["bind", "cp", "cmp", "name", "cfg", "id", "md", "method", "dict", "config", "Cmd", "comp", "help", "draw", "buf", "cl", "attr", "client", "call", "obj", "args", "arg", "gz", "cli", "cc", "ack", "reason", "code", "ck", "col", "func", "ctx", "path", "cb", "prefix", "ctrl", "req", "c", "ind", "cf", "cod", "cookie", "gn", "addr", "src", "command", "grad", "conn", "cd", "msg"]}}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "func": "target_ulong do_arm_semihosting(CPUARMState *env)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong args;\n\n    target_ulong arg0, arg1, arg2, arg3;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = cs->opaque;\n\n#else\n\n    CPUARMState *ts = env;\n\n#endif\n\n\n\n    if (is_a64(env)) {\n\n        /* Note that the syscall number is in W0, not X0 */\n\n        nr = env->xregs[0] & 0xffffffffU;\n\n        args = env->xregs[1];\n\n    } else {\n\n        nr = env->regs[0];\n\n        args = env->regs[1];\n\n    }\n\n\n\n    switch (nr) {\n\n    case TARGET_SYS_OPEN:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        s = lock_user_string(arg0);\n\n        if (!s) {\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        }\n\n        if (arg1 >= 12) {\n\n            unlock_user(s, arg0, 0);\n\n            return (uint32_t)-1;\n\n        }\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n\n            unlock_user(s, arg0, 0);\n\n            return result_fileno;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,\n\n                                  (int)arg2+1, gdb_open_modeflags[arg1]);\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n\n        }\n\n        unlock_user(s, arg0, 0);\n\n        return ret;\n\n    case TARGET_SYS_CLOSE:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);\n\n        } else {\n\n            return set_swi_errno(ts, close(arg0));\n\n        }\n\n    case TARGET_SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case TARGET_SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",\n\n                                   args, len);\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case TARGET_SYS_WRITE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_READ, arg1, len, 1);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, write(arg0, s, len));\n\n            unlock_user(s, arg1, 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READ:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_WRITE, arg1, len, 0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            do {\n\n                ret = set_swi_errno(ts, read(arg0, s, len));\n\n            } while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, arg1, len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READC:\n\n       /* XXX: Read from debug console. Not implemented.  */\n\n        return 0;\n\n    case TARGET_SYS_ISTTY:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);\n\n        } else {\n\n            return isatty(arg0);\n\n        }\n\n    case TARGET_SYS_SEEK:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",\n\n                                   arg0, arg1);\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_FLEN:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",\n\n                                   arg0, arm_flen_buf(cpu));\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(arg0, &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case TARGET_SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case TARGET_SYS_REMOVE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",\n\n                                  arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, arg0, 0);\n\n        }\n\n        return ret;\n\n    case TARGET_SYS_RENAME:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        GET_ARG(3);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",\n\n                                   arg0, (int)arg1+1, arg2, (int)arg3+1);\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(arg0);\n\n            s2 = lock_user_string(arg2);\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, arg2, 0);\n\n            if (s)\n\n                unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case TARGET_SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case TARGET_SYS_SYSTEM:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",\n\n                                   arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case TARGET_SYS_GET_CMDLINE:\n\n        {\n\n            /* Build a command-line from the original argv.\n\n             *\n\n             * The inputs are:\n\n             *     * arg0, pointer to a buffer of at least the size\n\n             *               specified in arg1.\n\n             *     * arg1, size of the buffer pointed to by arg0 in\n\n             *               bytes.\n\n             *\n\n             * The outputs are:\n\n             *     * arg0, pointer to null-terminated string of the\n\n             *               command line.\n\n             *     * arg1, length of the string pointed to by arg0.\n\n             */\n\n\n\n            char *output_buffer;\n\n            size_t input_size;\n\n            size_t output_size;\n\n            int status = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n            const char *cmdline;\n\n#endif\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n            input_size = arg1;\n\n            /* Compute the size of the output string.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            cmdline = semihosting_get_cmdline();\n\n            if (cmdline == NULL) {\n\n                cmdline = \"\"; /* Default to an empty line. */\n\n            }\n\n            output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n\n#else\n\n            unsigned int i;\n\n\n\n            output_size = ts->info->arg_end - ts->info->arg_start;\n\n            if (!output_size) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                output_size = 1;\n\n            }\n\n#endif\n\n\n\n            if (output_size > input_size) {\n\n                 /* Not enough space to store command-line arguments.  */\n\n                return -1;\n\n            }\n\n\n\n            /* Adjust the command-line length.  */\n\n            if (SET_ARG(1, output_size - 1)) {\n\n                /* Couldn't write back to argument block */\n\n                return -1;\n\n            }\n\n\n\n            /* Lock the buffer on the ARM side.  */\n\n            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);\n\n            if (!output_buffer) {\n\n                return -1;\n\n            }\n\n\n\n            /* Copy the command-line arguments.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            pstrcpy(output_buffer, output_size, cmdline);\n\n#else\n\n            if (output_size == 1) {\n\n                /* Empty command-line.  */\n\n                output_buffer[0] = '\\0';\n\n                goto out;\n\n            }\n\n\n\n            if (copy_from_user(output_buffer, ts->info->arg_start,\n\n                               output_size)) {\n\n                status = -1;\n\n                goto out;\n\n            }\n\n\n\n            /* Separate arguments by white spaces.  */\n\n            for (i = 0; i < output_size - 1; i++) {\n\n                if (output_buffer[i] == 0) {\n\n                    output_buffer[i] = ' ';\n\n                }\n\n            }\n\n        out:\n\n#endif\n\n            /* Unlock the buffer on the ARM side.  */\n\n            unlock_user(output_buffer, arg0, output_size);\n\n\n\n            return status;\n\n        }\n\n    case TARGET_SYS_HEAPINFO:\n\n        {\n\n            target_ulong retvals[4];\n\n            uint32_t limit;\n\n            int i;\n\n\n\n            GET_ARG(0);\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                abi_ulong ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret >= limit) {\n\n                        break;\n\n                    }\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            retvals[0] = ts->heap_base;\n\n            retvals[1] = ts->heap_limit;\n\n            retvals[2] = ts->stack_base;\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#else\n\n            limit = ram_size;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            retvals[0] = limit / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 7462, "substitutes": {"env": ["osc", "eng", "ch", "nw", "ea", "python", "serv", "er", "v", "vm", "scope", "config", "qt", "environment", "exc", "oa", "et", "enc", "ace", "eu", "inet", "db", "event", "ext", "state", "server", "exe", "iss", "init", "conf", "ev", "net", "vs", "e", "np", "que", "code", "en", "inst", "dev", "her", "ctx", "bc", "err", "loader", "exec", "context", "ne", "ec", "settings", "stage", "opt", "eni", "console", "proc", "eve", "txt", "shell", "cf", "engine", "site", "cache", "host", "manager", "conn", "end", "dict"], "cpu": ["cp", "hp", "gp", "bench", "pid", "hw", "gc", "anc", "python", "cr", "chip", "phy", "intel", "platform", "pu", "vm", "roc", "device", "config", "nc", "cat", "sys", "gpu", "px", "ips", "mac", "uci", "pc", "linux", "net", "np", "ck", "nic", "rpm", "conn", "ctx", "bc", "cu", "jp", "processor", "computer", "sta", "css", "boot", "proc", "os", "node", "cn", "lc", "core", "fc", "cow", "CPU", "cm"], "cs": ["cp", "Cs", "spec", "ci", "cus", "nc", "sync", "sys", "ants", "ns", "ls", "pc", "TS", "cc", "tc", "ss", "CS", "vs", "sc", "ars", "gs", "ks", "ds", "ctx", "bc", "ec", "css", "acs", "utils", "vc", "rs", "cas", "conn"], "args": ["stat", "name", "strings", "afi", "aug", "extra", "ig", "sec", "ins", "count", "alls", "arms", "data", "Args", "enc", "vals", "results", "ants", "parts", "ns", "ext", "call", "stats", "obj", "arg", "py", "uments", "pc", "active", "actions", "ints", "code", "all", "ars", "gs", "arr", "binary", "cmd", "bytes", "outs", "seq", "array", "asm", "blocks", "alloc", "ids", "params", "aux", "ras", "max", "flags"], "arg0": ["param2", " arg6", " arg11", "argsname", "argument1", "argname", "ag1", "Arg8", "Arg11", "val1", "ax6", "argument2", "arg4", "param0", "ag2", "param8", "Arg0", "ax1", "ag90", "args1", "Arg90", "ag0", " arg4", "args2", "argument0", "val11", "paramname", "args0", " arg90", "Arg6", "ax2", "arg11", " arg8", "arg8", " argname", "arg90", "args4", "argument4", "val0", "arg6", "Arg1", "Arg2", "val2", "ax0", "param1"], "arg1": ["param2", "ax01", "args3", "ar3", "ar1", "argument1", "param5", "ag1", "argument2", " arg5", "ag2", "param0", "argument5", "ar0", "arg01", " arg01", "arg5", "Arg0", "ax1", "args1", "Arg01", "ag0", "args2", " argX", "argument0", "ar2", "argsX", "args0", "ax2", "agX", "Arg3", "Arg1", "Arg2", "argX", "ax0", "param1"], "arg2": ["argument8", "argument1", "argument2", "args8", "arg4", "argument3", "Arg0", "args1", " arg4", "args2", "argument0", " arg8", "arg8", "args4", "argument4", "Arg3", "Arg1", "Arg2"], "arg3": ["param3", "param2", " arg63", "param63", "argument3", "argument2", "argument63", "argument1", "arg63", "param1"], "s": ["sf", "S", "b", "socket", "status", "f", "service", "sid", "hs", "h", "aws", "sp", "sa", "g", "sym", "y", "sets", "is", "spec", "services", "states", "server", "sl", "ls", "sie", "ds", "str", "settings", "sv", "fs", "sq", "your", "site", "rs", "strings", "sr", "ins", "sg", "sync", "sn", "ses", "opens", "u", "e", "submit", "sb", "ks", "secondary", "t", "ruby", "p", "input", "shell", "os", "ssl", "r", "ps", "o", "session", "si", "sys", "m", "l", "ns", "stats", "ss", "uns", "gs", "n", "su", "js"], "nr": ["rn", "nl", "gr", "nos", "nor", "nw", "vr", "sr", "NR", "rr", "radius", "rb", "chain", "ni", "nc", "rf", "inv", "sn", "rel", "nir", "loc", "num", "ru", "ng", "attr", "np", "arin", "number", "nic", "rg", "n", " sr", "rx", "lr", "cb", "nz", "nb", "rl", "result", "rev", "rin", "wr", "nar", "usr", "ner", "mr", "yr", "addr", "cn", "adr", " ni", "next", "kr", "rob", "r", "nu"], "ret": ["std", "flag", " arg", "sr", "rt", "id", "mem", "alt", "reg", "nt", "value", "rb", "val", "sum", " res", "cat", "info", "reply", " ar", "status", "num", "lit", "job", " reply", "obj", "arg", "active", "res", "det", "out", "arr", "RET", "fit", " sr", "feat", "str", "rev", "result", "sun", " result", "Ret", "run", "re", "fun", "back", "resp", "addr", "br", "success", "ref", " flags", " returns", "rets", " arr"], "len": ["lang", "base", "flag", "bin", "mem", "sec", "alt", "rot", "val", "enc", "loc", "length", "arg", "obj", "all", "arr", "bytes", "str", "rev", "lock", "seq", "pos", "gen", "ln", "Len", "resp"], "ts": ["as", "options", "te", "ins", "fts", "alls", "ets", "scope", "tr", "sys", "ses", "tty", "states", "tx", "xs", "Ts", "ns", "ats", "ls", "TS", "pc", "stats", "us", "ss", "hs", "ics", "vs", "mt", "ars", "gs", "ops", "ks", "t", "ds", "qs", "tz", "acs", "fs", "ta", "ms", "uts", "tp", "tt", "rs", "times", "ps", "rets", "tc"]}}
{"project": "FFmpeg", "commit_id": "1f28a991effadc64acd6915805b989ab43500f08", "target": 0, "func": "static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n\n                                         void *logctx, int size)\n\n{\n\n    uint8_t *user_data;\n\n    int e, build, i;\n\n\n\n    if (size < 16 || size >= INT_MAX - 16)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    user_data = av_malloc(16 + size + 1);\n\n    if (!user_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < size + 16; i++)\n\n        user_data[i] = get_bits(gb, 8);\n\n\n\n    user_data[i] = 0;\n\n    e = sscanf(user_data + 16, \"x264 - core %d\", &build);\n\n    if (e == 1 && build > 0)\n\n        h->x264_build = build;\n\n    if (e == 1 && build == 1 && !strncmp(user_data+16, \"x264 - core 0000\", 16))\n\n        h->x264_build = 67;\n\n\n\n    if (strlen(user_data + 16) > 0)\n\n        av_log(logctx, AV_LOG_DEBUG, \"user data:\\\"%s\\\"\\n\", user_data + 16);\n\n\n\n    av_free(user_data);\n\n    return 0;\n\n}\n", "idx": 7471, "substitutes": {"h": ["H", "hp", "ah", "hw", "o", "v", "hub", "http", "ih", "b", "oh", "uh", "m", "rh", "f", "him", "ph", "u", "hm", "hh", "hl", "he", "self", "eh", "p", "ht", "hi", "gh", "g", "c", "hr", "hu", "ha", "host", "bh", "hd"], "gb": ["gi", "gp", "cgi", "gc", "cfg", "buff", "gm", "hub", "bg", "bm", "uu", "db", "gu", "ga", "usb", "abb", "gin", "pc", "py", "bb", "sc", "gam", "sb", "rg", "gs", "storage", "lib", "bc", "GB", "cb", "mb", "gl", "kb", "bf", "g", "gd", "gram", "gg", "ui"], "logctx": ["LOGContext", "LOGloc", "signconn", "debugconn", " logContext", "plugctx", "logtx", "debugctx", "signtx", " logcontext", " logloc", "logconn", "logloc", "plugcontext", "logcontext", "plugContext", "LOGcontext", "debugtx", " logtx", "debugcontext", " logconn", "signcontext", "plugloc", "logContext", "LOGctx", "signctx"], "size": ["address", "name", "time", "SIZE", "large", "count", "fee", "s", "shape", "ci", "security", "si", "sn", "sync", "use", "loc", "capacity", "length", "small", "Size", "six", "code", "len", "en", "esc", "sized", "n", "empty", "year", "p", "scale", "z", "c", "g", "core", "ize", "max"], "user_data": ["custom_config", "user_alpha", "user_dat", "custom_div", "user_body", "custom_data", "user_div", " user_Data", " user_keys", " user_batch", "user_keys", "user_parent", "user__data", " user_space", "human_data", "human_name", "user__DATA", "user_space", "user_entry", " user_alpha", "user_name", "user_message", "user_config", "user_DATA", " user_body", " user_parent", "user_shift", "user_Data", " user_scale", "user_scale", "user_batch", "custom_name", " user_shift", " user_entry", " user_DATA", "human_Data", " user_image", "human_dat", " user_message", "user_image", " user_dat", "user__alpha", "user__dat"], "e": ["anne", "er", "o", "eng", "ea", "el", "v", "ef", "edge", "ell", "b", "x", "pe", "ae", "ace", "ele", "l", "f", "d", "j", "fe", "ce", "u", "ev", "code", "len", "E", "oe", "en", "se", "n", " E", "ie", "ee", "p", "ne", "ec", "be", "ge", "c", "g", "element", "ed", "es", "r", "ze"], "build": ["dy", "builder", "shape", "b", "style", "unit", "ace", "f", "d", "create", "code", "all", "hold", "g", "max", "replace", "row", "count", "building", "update", "pe", "grade", "round", "win", "work", "scale", "fail", "range", "ro", "test", "clean", "built", "use", "image", "loc", "u", "Build", "uild", "run", "start", "ind", "c", "core", "r", "add", "o", "v", "pull", "get", "bug", "enc", "l", "rh", "length", "se", "n", "other", "lock", "release", "disable", "ride"], "i": ["gi", "o", "ti", "v", "id", "I", "di", "ci", "ni", "b", "x", "si", "xi", "io", "bi", "m", "in", "qi", "l", "f", "yi", "pi", "phi", "adi", "j", "ii", "iu", "d", "it", "ai", "cli", "u", "vi", "uri", "ori", "k", "t", "n", "multi", "mi", "ini", "ie", "p", "eni", "z", "oi", "c", "ip", "y", "api", "li", "fi", "index", "r", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "ae21776207e8a2bbe268e7c9e203f7599dd87ddb", "target": 0, "func": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    int i;\n\n\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_samples = dst->filter_samples))\n\n        filter_samples = avfilter_default_filter_samples;\n\n\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n\n        dst->rej_perms & samplesref->perms) {\n\n\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n\n                                                          samplesref->audio->nb_samples);\n\n        link->cur_buf->pts                = samplesref->pts;\n\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n\n\n        /* Copy actual data into new samples buffer */\n\n        for (i = 0; samplesref->data[i]; i++)\n\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n\n\n        avfilter_unref_buffer(samplesref);\n\n    } else\n\n        link->cur_buf = samplesref;\n\n\n\n    filter_samples(link, link->cur_buf);\n\n}\n", "idx": 7472, "substitutes": {"link": ["lang", "flow", "band", "play", "local", "entry", "di", "ci", "check", "style", "ace", "arg", "service", "match", "code", "connection", "self", "line", "head", "user", "hip", "li", "lf", "msg", "plugin", "pack", "friend", "channel", "plug", "kick", "list", "slice", "info", "mail", "url", "loop", "linked", "comment", "zip", "lib", "path", "bridge", "rock", "back", "ip", "mm", "hack", "contact", "type", "model", "light", "group", "low", "address", "feed", "block", "lan", "sync", "ad", "co", "image", "loc", "lag", "key", "like", "post", "cell", "ck", "e", "dev", "source", "network", "Link", "frame", "set", "add", "dd", "bug", "ink", "links", "tag", "l", "call", "ack", "lock", "load", "ln", "slave"], "samplesref": ["samplesREF", "sannelsREF", "sifiersREF", "damplesdiff", "sourcesrel", " sampleslf", "tamplespart", "dampsrel", "sampsREF", "sacksref", "dampsre", "sourcesref", "sessionsref", "sampsdiff", "tampsreference", " samplesrel", "smodelsREF", " sagesRef", "sessionsreference", "sanceshard", "sampsRef", "tamplesRef", "lampsob", "simsdiff", "samplesre", " sannelshard", "tampsREF", "sampleREF", "sacksdiff", "simensreference", "damplesREF", "samplelf", " sampleshard", "sificationsrel", "sampsre", "tamplesREF", "simenslf", " samplesREF", "sificationsref", " sampsreference", "sessionsREF", "damplesre", "tampsref", " sagesREF", "dampsREF", "lampsalt", "sancesrel", "lamplesob", " sampsref", " samplesreference", "sampsrec", "saleslf", "damplesreference", "tamplesrel", "sizesRef", "samplesRef", "sipesreference", "salesref", "sourcesRef", "sessionsob", "sagesRef", "samplerel", "samplere", " salesRef", "samplespart", "dampsRef", "sipsRef", "tampleslf", "sampleob", "sipsreference", "sacksRef", "sifiersrel", "sipsREF", "lamplesRef", "sampleref", "sagesREF", "sampleshard", "tampsrel", "simsreference", "sessionsrel", "samplepart", "lamplesalt", " saleslf", "sampspart", "sipesRef", "lamplesref", " samplesRef", "damplesref", "sancesref", "samplesob", "tamplesreference", "sifiersRef", "samplesrec", " salesref", "smodelsref", " sampsREF", "salesRef", "damplesRef", "sacksrel", "lampsref", "sacksreference", "sipesREF", "dampsdiff", "sacksrec", "samplealt", "sificationsre", "sannelshard", "sampsreference", "sizesref", " sampsRef", "sifiersdiff", "sampleRef", "sourcesREF", "sampsalt", "sancesREF", "sannelsrel", "samplesreference", "sampsrel", "simsRef", " sannelsREF", "sipesref", "tampsrec", "sampleslf", "sagesref", "sipsref", "damplesrel", "sampsref", "samplereference", "tampsRef", "smodelsRef", " sannelsrel", "sifiersreference", "sessionsRef", "simenspart", "simensref", "lampsRef", " sagesref", "dampsref", "tamplesref", "sizeslf", "simsref", "sampsob", "sessionsrec", "samplesalt", " sannelsref", "smodelsrel", "sifiersref", "sannelsref", "samplesdiff", "sifiershard", "tampspart", "tampslf", "sificationsreference", "sessionsalt", "dampsreference", "tamplesrec", "sampslf", "samplesrel"], "filter_samples": ["filter_samps", "filter_golutions", "filter_pources", "filter_servicesamps", "filter_saves", "filter_vipes", "filter_pamples", "filter_sounds", "filter_symample", "filter_gages", "filter_solutions", "filter_bamps", "filter_scaves", "filter_hamps", "filter_nones", "filter_tamples", "filter_tages", "filter_nources", "filter_vamps", "filter_bones", "filter_haves", "filter_bamples", "filter_sample", "filter_panguages", "filter_insanguages", "filter_servicesolutions", "filter_insamps", "filter_namples", "filter_bipes", "filter_tolutions", "filter_insamples", "filter_symamps", "filter_servicesages", "filter_pipes", "filter_pounds", "filter_symanguages", "filter_bamp", "filter_namp", "filter_sones", "filter_paves", "filter_scamps", "filter_lamp", "filter_nipes", "filter_sipes", "filter_gamples", "filter_pamps", "filter_asources", "filter_hounds", "filter_asamples", "filter_vamples", "filter_lamps", "filter_lipes", "filter_scamples", "filter_sanguages", "filter_lamples", "filter_symamples", "filter_asipes", "filter_hamples", "filter_sources", "filter_asamps", "filter_pample", "filter_vones", "filter_gamps", "filter_scounds", "filter_namps", "filter_sages", "filter_insample", "filter_tamps", "filter_servicesamples", "filter_samp"], "dst": ["mdsts", "adsp", "dput", "Dst", "drct", "drbl", "dtd", "dbl", "fsts", "madtd", "fdst", "nost", "Dost", "mdsp", "adsc", "dsc", "sdput", " dost", "madst", "fput", "nnd", "Dnd", "Dsts", "pdST", "pdsts", "madput", "dsp", "fST", "dnd", "dST", "dsts", "datct", "mdst", " dnd", "adsts", "pdst", " dput", "fst", " dsts", "nst", " dsc", " dsp", "bsts", "dft", "sdst", "sdost", " dft", "adst", "mdsc", "sdtd", "drst", " dct", " dbl", "sdsts", "fdost", "pdput", "madsts", "datput", "datst", "fdft", "bput", "sdsc", "fdsc", "sdft", "dost", "bst", "btd", "sdbl", "datsc", "bST", "nsts", "dct", "drsts", "sdct"], "i": ["gi", "ti", "v", "id", "I", "a", "di", "ci", "ji", "ni", "xi", "b", "si", "io", "x", "ri", "info", "bi", "m", "image", "qi", "in", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "iu", "j", "loop", "ai", "init", "u", "e", "uri", "t", "k", "n", "multi", "mi", "ini", "ie", "p", "h", "mini", "z", "line", "oi", "hi", "c", "ip", "y", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "qemu", "commit_id": "d85937e683f6ff4d68293cb24c780fb1f6820d2c", "target": 0, "func": "static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    qemu_irq *mpic;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    int i, j, k;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n    dev = qdev_create(NULL, \"openpic\");\n\n    qdev_prop_set_uint32(dev, \"nb_cpus\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"model\", params->mpic_version);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n\n\n    k = 0;\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_connect_irq(s, k++, irqs[i][j]);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n", "idx": 7480, "substitutes": {"params": ["master", "options", "cmp", "pro", "spec", "config", "tmp", "data", "lp", "services", "ips", "details", "ram", "mac", "names", "args", "res", "param", "conf", "ops", "cam", "Param", "gs", "ds", "ctx", "cms", "phys", "coll", "settings", "Par", "proc", "mm", "api", "ams", "par", "ps", "conn", "js"], "ccsr": ["cfrs", "ccrs", "pcsu", "pctr", "ncsu", "rcsr", "cfSR", " ccsw", "cfsr", " ccsu", "ncsw", "cctr", "ucrs", "nctr", "rcSR", "rcrs", "ucsr", "cftr", "rctr", "ncsr", "ccsw", "pcsr", "ccsu", "ucSR", "ccSR", "pcsw", "uctr", " cctr"], "irqs": ["mirqs", "IRqs", "ierasks", "ierqs", "irasks", " irqi", "mirq", "mirows", "mirqi", " irasks", "irq", "ierqi", "mircs", "IRq", " ircs", "irows", "ircs", "IRows", " irows", "ierq", "IRcs", "irqi", "mirasks", " irq"], "mpic": ["mpIC", "compic", "compics", "ompIC", "cmpIC", "ompic", "ompric", "ompics", "compac", "mbic", "Mpik", "mpik", "ompik", "cmpik", "ppics", "mbac", "mbics", "mpics", "mpric", " mpric", "compice", "Mpric", " mpIC", "ppik", "mbice", "cmpics", "pmic", "pmice", "Mpic", "pmics", "MpIC", "pmac", "ppric", "ppic", "mpac", " mpics", " mpik", "mpice", "cmpic"], "dev": ["hw", "ch", "od", "v", "md", "rad", "dn", "di", "Dev", "dd", "device", "adv", "nt", "pro", "spec", "bug", "data", "ad", "info", "dem", "der", "valid", "gu", "de", "sk", "d", "ve", "mod", "google", "dist", "conf", "ev", "def", "DEV", "des", "sh", "priv", "w", "prom", "cam", "error", "sd", "dc", "driver", "p", "serial", "temp", "development", "ver", "var", "c", "g", "gd", "test", "app", "grad", "conn", "diff", "cd"], "s": ["o", "v", "is", "S", "spec", "sg", "device", "session", "b", "sync", "sys", "services", "m", "private", "sk", "f", "ns", "d", "server", "sl", "service", "cs", "conf", "u", "ss", "e", "sh", "w", "gs", "sb", "ds", "sd", "n", "t", "storage", "su", "self", "p", "h", "aws", "fs", "c", "os", "g", "ssl", "es", "r", "ps", "js"], "i": ["gi", "name", "o", "v", "id", "I", "is", "a", "ik", "ci", "ki", "di", "ji", "ni", "x", "b", "si", "ri", "xi", "io", "abi", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "iu", "it", "ai", "init", "u", "e", "uri", "t", "n", "multi", "mi", "ini", "ie", "p", "h", "z", "eni", "oi", "c", "ip", "y", "api", "lc", "li", "inner", "fi", "index", "zi", "ui"], "j": ["jet", "name", "fr", "o", "ch", "v", "oj", "jl", "ji", "x", "b", "si", "xi", "m", "qi", "kj", "l", "bj", "key", "f", "job", "ii", "d", "aj", "q", "ij", "obj", "u", "e", "J", "je", "jc", "t", "n", "uj", "jp", "jo", "err", "ie", "p", "z", "jj", "c", "g", "y", "ja", "br", "dj", "li", "r", "ui", "js"], "k": ["o", "v", "kn", "id", "ik", "ki", "spec", "kick", "b", "kk", "m", "key", "l", "K", "sk", "kh", "dk", "q", "u", "ck", "sc", "km", "w", "e", "ks", "n", "kid", "work", "p", "kw", "ky", "z", "c", "ke", "g", "y", "ek", "uk", "mk", "ok"]}}
{"project": "qemu", "commit_id": "33577b47c64435fcc2a1bc01c7e82534256f1fc3", "target": 0, "func": "CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n", "idx": 7481, "substitutes": {"label": ["plugin", "address", "name", "position", "config", "username", "abel", "alias", "lab", "format", "lp", "concept", "loc", "title", "l", "key", "package", "f", "url", "description", "property", "code", "Label", "col", "file", "message", "binary", "path", "fp", "bool", "il", "bl", "text", "desc", "summary", "prefix"], "filename": ["name", "nl", "files", "sf", "username", "actual", "Filename", "format", "queue", "lp", "title", "buf", "fb", "l", "f", "url", "metadata", "phrase", "document", "initial", "fil", "uri", "file", "binary", "fn", "path", "fp", "nil", "dll", "rl", "source", "seq", "kl", "txt", "fd", "il", "utf", "params", "bl", "loader", "directory", "prefix"], "init": ["stat", "cfg", "reset", "id", "open", "done", "ci", "config", "op", "use", "sync", "i", "format", "info", "help", "ix", "state", "create", "it", "cli", "Init", "initial", "auth", "storage", "n", "ctx", "empty", "cb", "load", "ic", "sleep", "boot", "opt", "start", "transfer", "gen", "alloc", "c", "os", "orig", "initialized", "inner", "set", "seed", "setup"], "p": ["patch", "cp", "P", "pid", "o", "bp", "a", "pat", "pre", "b", "pp", "op", "i", "data", "wp", "pe", "lp", "m", "l", "f", "j", "pc", "args", "param", "np", "part", "e", "parser", "t", "n", "path", "fp", "jp", "array", "vp", "prop", "pos", "pointer", "primary", "c", "ip", "type", "tp", "params", "pair", "pb", "r", "ps", "prefix"], "chr": ["CHcr", "cheru", "gyr", "achr", "ichru", "anchrc", "chcr", "chrc", "ichar", "Chrb", " chrc", "chrl", "schsr", "ichrl", "chrt", "schcr", "anchru", "anchr", "chru", "grr", "chsr", "achcr", "schr", " chru", "chrg", "CHR", "cher", "achsr", "achrb", "Chr", "CHrc", "anchrg", "cherr", "candrr", "chesr", "CHrb", "candr", "cherg", "cherb", " chrg", "chert", "checr", "Chru", "cheR", "ChR", "candrc", "gyrc", "Chrc", "gyrr", "grrl", "chrb", "CHr", "Chcr", "schrb", "candrt", "CHru", "chrr", " chrl", "chR", "grar", "grru", "gyrt", "ichr", "cherc"], "opts": ["optstr", "ppps", " opps", " optstr", "opttr", "opters", " opws", "optt", "optr", "opttes", "optts", "iopps", "iopts", " optts", "optcs", "ottr", "opps", " optws", "ppters", "optks", " opks", "ioptes", "copcs", "copks", "opws", "copns", "opcs", "optters", "ops", "optws", "copts", "ppcs", "opns", "iops", "ots", "ppts", "otts", "copters", "opstr", "opt", " opstr", " optt", "coptr", "optns", "optps", "cops", " opcs", "optes", " optes", "otns", " opt", " ops", "opks", " opters"], "err": ["gr", "dr", "fr", "rn", "er", "cr", "arm", "iter", "fy", "pr", "rr", "fee", "aster", "bug", "ise", "der", "rh", "tx", "rage", "ir", "ler", "order", "magic", "res", "ctr", "acer", "rar", "e", "error", "ar", "arr", "here", "n", "cb", "str", "lr", "result", "raise", "ee", "req", "runner", "finder", "mr", "erer", "ver", "g", "orig", "resp", "br", "Er", "cache", "ref", "rs", "r", "Error", "msg"]}}
{"project": "qemu", "commit_id": "7873df408dd44eb92840b108211d5aa5db7db526", "target": 0, "func": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n\n                            const char *model, const char *name,\n\n                            const char *ifname, const char *script,\n\n                            const char *downscript, const char *vhostfdname,\n\n                            int vnet_hdr, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7490, "substitutes": {"tap": ["tr", "data", "raf", "typ", "wt", "mp", "snap", "td", "pn", "json", "kat", "span", "sp", "ppa", "tk", "tp", "trip", "pb", "setup", "tc", "cp", "tool", "tf", "config", "pod", "wp", "ap", "apt", "xml", "tu", "tif", "php", "spl", "tick", "tw", "ts", "jp", "tin", "amp", "tip", "cap", "capt", "form", "opa", "bp", "python", "pin", "pa", "tun", "gap", "wa", "num", "att", "pc", "np", "submit", "t", "tm", "p", "input", "temp", "wal", "prop", "TP", "api", "tta", "png", "trace", "session", "pd", "skip", "pipe", "tar", "window", "project", "tim", "request", "ta", "oga", "Tap"], "peer": ["address", "gp", "pid", "er", "friend", "ep", "parent", "pro", "device", "scope", "channel", "rb", "pp", "socket", "enc", "pipe", "sys", "pe", "player", "state", "server", "pc", "e", "port", "eps", "p", "reader", "ptr", "request", "pointer", "node", "proc", "slave", "ppa", "ssl", "type", "tp", "pair", "pb", "seed", "mode"], "model": ["base", "address", "plugin", "models", "layer", "dm", "parent", "scope", "channel", "config", "pe", "module", "xml", "m", "image", "cm", "db", "package", "client", "pri", "prot", "server", "param", "owner", "zip", "instance", "ctx", "fp", "controller", "source", "stage", "reader", "slave", "ssl", "handler", "location", "sym", "lc", "Model", "mode"], "name": ["base", "time", "na", "id", "parent", "word", "data", "alias", "family", "named", "info", "image", "names", "key", "profile", "package", "client", "version", "vision", "Name", "part", "action", "NAME", "size", "path", "filename", "nam", "mini", "new", "type", "label", "term", "host", "nice", "prefix"], "ifname": ["switchName", " ifno", "Ifsize", " ifName", "switchsize", "tifname", "iffname", "Ifno", "switchnames", "ifnames", "ifsize", "Ifname", "IFnames", "tifsize", "ifno", "ifName", "tifnames", "iftype", "Ifnames", "IFtype", " ifnames", "Iftype", "switchname", "iffsize", " ifsize", "ifftype", "tifno", "iffnames", "IFsize", "IFname", "tifName"], "script": ["writer", "sec", "fee", "scope", "config", "password", "data", "secret", "slice", "image", "tx", "media", "scripts", "code", "control", "sc", "proxy", "file", "sd", "esc", "cript", "sign", "lib", "timeout", "exec", "javascript", "fn", "pass", "source", "input", "ip", "ssl", "desc", "test", "src", "command", "Script", "prefix"], "downscript": [" downsh", " downScript", " downtext", "ownscripts", "crossscript", "downScript", "upcode", "ownscript", "ownScript", "upScript", " downstyle", "crosssh", "downsh", "subscripts", "dropscript", "dropScript", "droptext", " downcript", "upscript", "ownstyle", "subscript", "upcript", "uptext", " downcode", "downcode", " downscripts", "downscripts", "downstyle", "downcript", "subcode", "crossscripts", "upscripts", "upstyle", "crosscript", "dropscripts", "upsh", "downtext"], "vhostfdname": ["vhostFDname", "vhomefname", "vhostdfname", "vhostdfnm", "vhostfdno", "vHostfdnames", "vhostdfdef", "vhostfdnumber", "vhostdnames", "vhostfdnames", "vhostFDName", "vhostfname", "vhostfnumber", "vhostdnumber", "vhostddnumber", "vhosthandlernm", "vhostfdnm", "vhostdname", "vhosthandlername", "vHostdnumber", "vhostddno", "vhostFDnm", "vhomefno", "vhostdName", "vhostFDdef", "vHostfdnumber", "vhostdfName", "vHostdnames", "vHostfdName", "vHostdname", "vhostddnames", "vhostfName", "vhomefnames", "vhostfnnames", "vhostfnname", "vhomefdnames", "vHostfdname", "vhostfdName", "vhostfnno", "vhosthandlerdef", "vhostfno", "vhostddName", "vhostddname", "vhosthandlerName", "vhomefdno", "vhomefdname", "vhostfddef", "vhostfnames", "vHostdName"], "vnet_hdr": ["vnetxvst", "vnetxhrt", "vnet_wbr", "vnet_bhdr", "vnetxhbr", "vnet_vst", "vnetxvbr", "vnet_shrt", "vnetxhdr", "vnet_vdr", "vnetxhst", "vnetxvdr", "vnet_hicit", "vnet_wdr", "vnet_wst", "vnet_bhrt", "vnet_frt", "vnet_hbr", "vnet_shicit", "vnet_ficit", "vnet_vrt", "vnet_vbr", "vnet_wrt", "vnet_bhicit", "vnet_hst", "vnetxvrt", "vnet_hrt", "vnet_shdr", "vnet_fdr"], "fd": ["writer", "function", "std", "fen", "flow", "pid", "feed", "nw", "sf", "fw", "bd", "dn", "dat", "dd", "config", "pd", "socket", "format", "pipe", "stream", "fed", "fx", "fb", "db", "wb", "fin", "f", "client", "d", "fl", "fe", "director", "td", "dir", "connection", "file", "dc", "fn", "df", "sd", "ds", "fp", "cb", "FD", "fa", "input", "temp", " fid", "fm", "pointer", "fs", "ln", "cond", "fun", "write", "handler", "dl", "fc", "cf", "dt", "fi", "form", "nd", "ff", "af"], "s": ["sf", "S", "b", "socket", "i", "f", "service", "conf", "self", "h", "aws", "sp", "sa", "g", "sym", "y", "sets", "sites", "is", "spec", "fts", "sw", "services", "https", "server", "sl", "ls", "native", "ops", "ts", "settings", "sv", "fs", "new", "sq", "your", "site", "rs", "python", "sg", "comments", "sync", "sn", "ses", "cs", "u", "an", "e", "submit", "sb", "secondary", "t", "qs", "tests", "p", "c", "os", "ssl", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "ns", "us", "ss", "gs", "se", "n", "su", "es", "js"], "vhostfd": [" vhostdd", "vhostpd", "vhopda", "vhardfe", "vportf", "vworkfd", "vhomefe", "vHostdd", "vhostfp", "vhostda", "svhostdc", " vHostfd", " vhomedl", "vfrontpd", "svhostpd", "vhardf", " vhostda", "svhostfe", "vhardfd", " vhostfp", "vformatfc", "vhostfe", "vfrontfd", " vhostdl", "vvisfd", "vvisFD", "vhomedraft", "vconnectfc", "vworkd", "vhopfd", "svhardf", "svhardfd", "vhostdc", "vserverfd", "vconnectdl", "vhardff", "vvisdd", "vhostff", " vhostfc", "vconnectdraft", " vhomefd", " vhostff", "vhomepd", " vhostdraft", "vhostdl", "vfrontfc", "vportdc", "vhardd", " vworkff", "vHostda", "vserverfx", " vhomedraft", "vpoold", "vhomefx", " vHostdd", "vportfd", "vserverfc", "vhostd", "vhostdd", " vHostda", "vhomefc", "vformatdl", "vhostfx", " vworkfp", "vHostfd", "svhostf", " vhostFD", "vformatdraft", " vworkd", "vworkff", "vhopdd", "vhomedc", "vhomedl", "vworkfp", "svhostfc", "vserverpd", "svhostfd", "svserverfd", "vfrontfx", " vhomefc", "svhostfx", "vpoolfd", "vhostFD", "vhostfc", "vharddc", "vformatfd", "vhopFD", "vconnectfd", "vhostf", "vhomef", "vpoolff", "vportfe", " vHostFD", "svhardfe", "svserverfx", "svserverfc", "vHostFD", " vworkfd", "vhostdraft", "vhomefd", "svserverpd", "vpoolfp", "vvisda", " vhostd", "vhardfp", "svharddc"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 7491, "substitutes": {"l": ["nl", "o", "lb", "el", "v", "la", "s", "jl", "ell", "list", "b", "i", "ll", "loc", "f", "lit", "ler", "fl", "ls", "sl", "j", "u", "lo", "e", "all", "L", "ol", "t", "n", "lu", "rl", "p", " L", "iol", "ln", "ld", "kl", "ul", "los", "wl", "c", "il", "dl", "li", "lin", "g", "lc", "pl", "lf", "r", "le"], "prop": ["pot", "plugin", "cp", "option", "properties", "Prop", "pr", "method", "parent", "pro", "rop", "config", "tmp", "op", "val", "data", "b", "pred", "comp", "typ", "lp", "info", "loc", "unit", "fb", "key", "tag", "lit", "f", "attr", "mp", "project", "prot", "j", "obj", "post", "arg", "service", "property", "part", "def", "priv", "col", "target", "owner", "lot", "ops", "dev", "fit", "ctx", "field", "jp", "feat", "p", "np", "root", "this", "opt", "pos", "proc", "type", "api", "dt", "class", "term", "pl", "pb", "test", "manager", "ps", "role"], "oc": ["osc", "ocr", "o", "anc", "unc", "cr", "roc", "om", "acc", "aco", "config", "op", "nc", "rc", "cca", "OC", "ob", "enc", "co", "uc", "loc", "soc", "org", "obj", "pc", "cc", "oca", "og", "mc", "acl", "oe", "oco", "sc", "bc", "cu", "voc", "coll", "ic", "ec", "root", "toc", "doc", "c", "os", "oo", "oci", "cf", "oid", "fc", "ac", "vc", "ok"], "dc": [" DC", "anc", "dn", "di", "acc", "device", "disc", "nc", "rc", "cca", "co", "uc", "loc", "db", "ga", "dk", "d", "pc", "cc", "director", "dp", "mc", "da", "driver", "jc", "ds", "df", "bc", "ec", "DC", "doc", "c", "ct", "cf", "lc", "dt", "fc", "design", "ac", "vc", "cdn", "rec", "cd", "tc"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    ESDVoiceOut *esd = (ESDVoiceOut *) hw;\n\n    audsettings_t obt_as = *as;\n\n    int esdfmt = ESD_STREAM | ESD_PLAY;\n\n    int err;\n\n    sigset_t set, old_set;\n\n\n\n    sigfillset (&set);\n\n\n\n    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        esdfmt |= ESD_BITS8;\n\n        obt_as.fmt = AUD_FMT_U8;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"Will use 16 instead of 32 bit samples\\n\");\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n    deffmt:\n\n        esdfmt |= ESD_BITS16;\n\n        obt_as.fmt = AUD_FMT_S16;\n\n        break;\n\n\n\n    default:\n\n        dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt);\n\n        goto deffmt;\n\n\n\n    }\n\n    obt_as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n", "idx": 7498, "substitutes": {"hw": ["hp", "nv", "gp", "rw", " HW", "nw", "eng", "fw", "wei", "wx", "nas", "sw", "wan", "hz", "ow", "wm", "hhh", "wp", "umi", "wk", "gpu", "wa", "haw", "rh", "wb", "wy", "him", "wo", "usb", "dq", "np", "wd", "hm", "w", "ohm", "tw", "hh", "ctx", "zh", "wcs", "cu", "hop", "voc", "ww", "ou", "kw", "ogg", "wire", "h", "iw", "vp", "war", "wav", "wu", "aff", "ht", "gh", "mm", "lv", "gg", "vc", "cow", "conn", "pkg", "aw"], "as": ["bas", "ch", "act", "asu", "is", "a", "nas", "s", "sw", "asa", "mas", "session", "pas", "ow", "or", "ap", "sys", "AS", "mac", "was", "ga", "ns", "has", "av", "res", "from", "us", "ss", "conf", "cs", "ay", "sh", "ars", "ar", "auth", "gs", "As", "an", "instance", "ase", "ask", "self", "asm", "asha", "aws", "pos", "am", "acs", "sa", "os", "mm", "ms", "ams", "asc", "ach", "inas", "ac", "aus", "rs", "ras", "ast", "ass", "aw"], "esd": ["lesdl", "esdl", "asdb", "etsd", "lsds", "eesd", "sesdn", " esds", "gesd", "gesds", "owsdk", "zesds", " esdb", "ossdk", "asd", "essds", "sesd", "lssd", "openspd", "sesds", "lsd", "essdk", "essd", "eesdb", "essdb", "lsdb", "usd", "ossds", "gesdk", "essdn", "sesdk", "opensdk", "esds", "asdk", "opensds", "asds", "eesdl", "espd", "owsdl", "ossd", "esdb", "zessd", "lesdb", "usdb", "lesds", "owsds", "esssd", "zesd", "usds", "etspd", "esspd", "lesd", "gesdn", " esdk", "essdl", "esdn", "esdk", "zesdb", "eesds", "usdk", "owsd", "ossdl", "etsdk", "etsds", "opensd"], "err": ["gr", "dr", "fg", "fam", "er", "act", "yer", "aer", "fr", "iter", "fy", "id", "rr", "pr", "fee", "rag", "icer", "bug", "rc", "ise", "loc", "der", "rh", "rage", "eor", "ir", "f", "attr", "ler", "order", "call", "nr", "magic", "res", "acer", "rar", "e", "error", "ar", "die", "arr", " error", "lr", "str", "result", "ec", "req", "wr", "finder", "ner", "erer", "mr", "ver", "ind", "fer", "errors", "g", "resp", "y", "orig", "yr", "Er", "test", "kr", "r", "Error", "found", "msg"], "set": ["base", "sets", "reset", "sec", "store", "id", "not", "dat", "send", "check", "ets", "get", "setting", "sort", "update", "use", "SET", "sync", "et", "sett", "valid", "client", "Set", "server", "mod", "init", "match", "sent", "sc", "mit", "sign", "str", "parse", "ut", "vert", "zero", "start", "gen", "cast", "write", "type", "read", "clear", "util", "end", "setup", "size"], "old_set": ["objvalreset", "objvalsets", "oldvalreset", " old_sets", "obj_sc", "old_start", "obj_set", "objvalset", "oldvalset", "objvalsc", "oldvalsc", "old_sc", " old_start", " old_settings", "old_sets", "oldvalsets", "obj_reset", "obj_sets", "old_settings", "old_reset"]}}
{"project": "qemu", "commit_id": "03a63484a6978f68caff087bbaabcd1d383563af", "target": 1, "func": "static void monitor_find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    const mon_cmd_t *cmd;\n\n    const KeyDef *key;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = next_arg_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype += 2;\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 7521, "substitutes": {"cmdline": ["mdstring", "mdname", "callLine", "commandlin", "commandle", "mdline", "cmdlin", "commandstring", "mdLine", "mdle", "commandlines", "mdlin", "commle", "commlin", "commandname", "commname", "cmdle", "commlines", "cmdLine", " cmdstring", "commandline", "commandLine", " cmdLine", "cmdlines", "callline", "calllines", "commline", "mdlines", "cmdstring", "callname"], "cmdname": ["mdname", "cfname", "commName", "msgnamed", "commandpath", "mdline", "mdnamed", " cmdn", "msgnames", "msgno", "commnamed", "cmdnames", "commandname", "msgname", "commname", "commpath", "cmdn", "cmdnamed", " cmdName", "cmdno", "cfnames", " cmdnames", "commandline", "commn", "cmdpath", "commandName", "commandno", "commline", " cmdno", "cfline", "cfno", "mdpath", "cfnamed", "cfn", "mdno", "commno", "cmdName", "mdnames", " cmdnamed"], "args": ["limits", "arms", "values", "atts", "grades", "data", "help", "results", "parts", "arg", "my", "actions", "all", "ay", "arr", "exec", " arguments", "pres", "array", "aws", "changes", "g", "ams", "points", "extra", "s", "config", "Args", "xml", "states", "vals", "uments", "param", "ds", "parse", "doc", "ms", "lines", "rs", "groups", "strings", "ins", "md", "obj", "py", "keys", "cs", "vs", "fields", "qs", "headers", "p", "input", "pos", "ids", "options", "ig", "alls", "words", "enc", "links", "mac", "argument", "ns", "call", "stats", "ars", "gs", "items", "params", "flags", "js"], "MAX_ARGS": ["MAX_RATS", "MAX_RAGS", "MAX_RAYS", "MAX_CARGS", "MAX_PARGV", "MAX_CARTS", "MAX_PARG", "MAX_CARGV", "MAX_CARYS", "MAX_ARTS", "MAX_WARGS", "MAX_ARYS", "MAX_WARYS", "MAX_WARTS", "MAX_WARG", "MAX_CARG", "MAX_ARGV", "MAX_RAG", "MAX_ARG", "MAX_PARTS", "MAX_PARGS"], "nb_args": ["nbXaux", "nn_axis", "wb_arr", "wb_args", "cb_actions", "nb00axis", "cb_arg", "nb67strings", "nb67params", "nr_args", "nn_modules", "nb_flags", "nb_parts", "nb__actions", "nb_arms", "nb_axis", "NB64items", "nb00plugins", "nb_actions", "NB_args", "nb67arg", "nb_strings", "NB64strings", "nb64fields", "nb__params", "nb00items", "nb67items", "nn67ds", "num_fields", "num_words", "nbXfields", "wb_plugins", "kb_args", "nn67args", "nb_words", "nb64items", "nb2args", "nb67keys", "nn_ds", "nb2flags", "nb_atts", "nb_ds", "nb48params", "nb67arr", "nr_flags", "nb64args", "nbJargs", "num_aux", "kb_arg", "nb64params", "nb__args", "wb_keys", "nbJfields", "nb_items", "nn67axis", "nb48strings", "nb_params", "nb67atts", "nb_aux", "nb67flags", "nb00arr", "nd67arms", "NB64params", "nb00modules", "NB_strings", "nb__parts", "nb48items", "nd67items", "nb67axis", "nb__arg", "nb_groups", "nb48args", "NB_items", "nb67modules", "nd_arms", "NB_params", "cb_params", "nb_plugins", "nd_groups", "kb_parts", "nb00arms", "nb_arr", "nb_keys", "nb67fields", "nbJwords", "nr_params", "nb64strings", "nb2params", "nd_args", "nb00groups", "nb67ds", "nb64arg", "nn67modules", "nb_fields", "nbJarg", "nb_arg", "kb_params", "nb_modules", "nb00args", "nbXargs", "nbXarg", "nb67words", "nb64aux", "nd_items", "num_arg", "NB64args", "nb67plugins", "nb00keys", "num_args", "nb67arms", "nn_args", "nb67groups", "nd67groups", "nb67args", "cb_args", "nd67args", "nb00ds", "nb2atts", "nr_atts"], "i": ["uni", "gi", "name", "ti", "v", "id", "I", "di", "ci", "ni", "x", "xi", "si", "io", "slice", "b", "info", "bi", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "ii", "iu", "d", "it", "ai", "cli", "init", "u", "e", "uri", "ami", "t", "n", "multi", "mi", "ini", "ie", "p", "h", "eni", "sp", "start", "oi", "hi", "ind", "c", "ip", "y", "li", "inner", "fi", "index", "zi", "mu", "ui"], "len": ["el", "count", "min", "nt", "ni", "val", " lang", "list", "elt", "lt", "non", "lan", "inn", "ll", "l", "num", "fin", "f", "limit", "length", "sl", " length", "ls", "fl", "split", "e", " el", "part", "en", "ol", "L", "full", "n", "err", "lon", "lock", "seq", "z", "sp", "pos", "line", " Len", "ln", "Len", "lc", "lin", "il", "li", "dl", "lv", "bl", "pl", "lf", "lim", " l", "le", "size"], "ptype": ["ppype", "PTrace", "pectype", "portype", " ptope", "ipttype", "ptetime", "PTyp", "prtype", "ctope", "PType", "xtoe", "ptime", " ptime", "iptype", "prype", "cttype", "prake", "patyp", "xtype", "ptake", "iptity", "ntypes", "pecttype", "pliny", "ptick", "istyle", "ptitle", "PTyle", "portiny", "pitickle", "xtyle", "pattype", " ptick", "pectickle", "pittype", " pttype", "eptype", "pype", "iptyp", "ntype", "ctyp", "ctake", "pectopic", "patetime", "nttype", "pitype", "eptope", "patiny", " ptike", " ptoe", "ypope", "ptickle", "ptyp", "portopy", "ypyp", "istoe", "plope", "PTypes", "pttype", "pprace", "patopy", "plyp", "ypype", "plype", "plime", "ctape", "ppyle", "patape", "ppike", " ptity", "pptype", "pltype", "xtitle", "ptike", "ptopy", "PTtype", "iptake", "pypes", "ptopic", " ptitle", "iptickle", "pyp", "porttype", "patity", "PTike", "ptape", "ptope", "iptopic", "ptrace", "ptypes", "patype", "ptyle", " ptrace", "istype", "ctime", "ypick", "iptypes", "pitopic", "prime", "prape", " ptyle", "eptyp", "eptick", "plopy", "iptetime", "ptoe", "pryp", " ptetime", "ppyp", "ctypes", "ctyle", "ntyle", "ctetime", "ntyp", "ptity", "pime", "iptime", "ctype", " ptyp", "pretime", "istitle", "ptiny"], "str": ["dr", "name", "fr", "strings", "st", "iter", "sec", "pr", "expr", "style", "sync", "data", "enc", "tr", "cl", "f", "j", "sl", "d", "res", "code", "arr", "pass", "err", "exec", "Str", "input", "sp", "doc", "pos", "ld", "read", "hr", "br", "STR", "inner", "text", "bl", "r", "stri", "dict"], "cmd": ["bind", "cp", "oc", "name", "cmp", "cfg", "act", "ch", "header", "clean", "domain", "bin", "block", "id", "md", "comm", "method", "qq", "dict", "config", "Cmd", "mid", "op", "pipe", "cat", "module", "uc", "help", "buf", "mac", "cl", "num", "f", "client", "content", "call", "mod", "magic", "cli", "cc", "init", "dom", "ctr", "code", "target", "w", "dc", "ctx", "win", "go", "cb", "ctrl", "req", "css", "gen", "node", "c", "proc", "cf", "cod", "cookie", "vc", "host", "command", "grad", "conn", "pkg", "cd", "msg"], "key": ["name", "row", "id", "parent", "entry", "value", "dict", "val", "data", "enc", "call", "obj", "arg", "keys", "param", "def", "code", "k", "kw", "gen", "type", "Key", "conn", "msg"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n", "idx": 7556, "substitutes": {"sd": ["std", "sf", "od", "sy", "md", "bd", "vd", "s", "sg", "dd", "pd", "si", "data", "sn", "ad", "so", "db", "sk", "sam", "state", "d", "sl", "sm", "ss", "td", "sie", "sb", "se", "ds", "settings", "sv", "sa", "ld", "ind", "gd", "dl", "SD", "cd"], "response": ["position", "header", "http", "parent", "wave", "value", "update", "object", "data", "sync", "Response", "reply", "body", "image", "route", "sequence", "content", "version", "server", "description", "document", "service", "answer", "match", "error", "connection", "respons", "message", "json", "received", "application", "result", "array", "output", "respond", "settings", "request", "tree", "write", "resp", "model", "page", "api", "success", "site", "next", "index"], "last_status": ["last_state", " last_date", " last_state", "last_stat", "last_date", "last__stat", " last_stat", "last__date", "last__status", "last__state"], "status": ["stat", "login", "flag", "id", "complete", "s", "progress", "security", "session", "update", "date", "data", "sync", "style", "xml", "sex", "speed", "content", "state", "server", "stats", "version", "description", "active", "modified", "service", "match", "reason", "code", "sc", "error", "comment", "message", "full", "json", "received", "str", "score", "su", "result", "seq", "prefix", "source", "output", "settings", "stage", "request", "model", "Status", "success", "site", "index", "command", "summary", "msg"]}}
{"project": "FFmpeg", "commit_id": "5674d4b0a35a34b75e3533a8580e0b5a0a8895a7", "target": 0, "func": "static int mpc8_decode_frame(AVCodecContext * avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb2, *gb = &gb2;\n\n    int i, j, k, ch, cnt, res, t;\n\n    Band *bands = c->bands;\n\n    int off;\n\n    int maxband, keyframe;\n\n    int last[2];\n\n\n\n    keyframe = c->cur_frame == 0;\n\n\n\n    if(keyframe){\n\n        memset(c->Q, 0, sizeof(c->Q));\n\n        c->last_bits_used = 0;\n\n    }\n\n    init_get_bits(gb, buf, buf_size * 8);\n\n    skip_bits(gb, c->last_bits_used & 7);\n\n\n\n    if(keyframe)\n\n        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);\n\n    else{\n\n        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);\n\n        if(maxband > 32) maxband -= 33;\n\n    }\n\n    c->last_max_band = maxband;\n\n\n\n    /* read subband indexes */\n\n    if(maxband){\n\n        last[0] = last[1] = 0;\n\n        for(i = maxband - 1; i >= 0; i--){\n\n            for(ch = 0; ch < 2; ch++){\n\n                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];\n\n                if(last[ch] > 15) last[ch] -= 17;\n\n                bands[i].res[ch] = last[ch];\n\n            }\n\n        }\n\n        if(c->MSS){\n\n            int mask;\n\n\n\n            cnt = 0;\n\n            for(i = 0; i < maxband; i++)\n\n                if(bands[i].res[0] || bands[i].res[1])\n\n                    cnt++;\n\n            t = mpc8_get_mod_golomb(gb, cnt);\n\n            mask = mpc8_get_mask(gb, cnt, t);\n\n            for(i = maxband - 1; i >= 0; i--)\n\n                if(bands[i].res[0] || bands[i].res[1]){\n\n                    bands[i].msf = mask & 1;\n\n                    mask >>= 1;\n\n                }\n\n        }\n\n    }\n\n    for(i = maxband; i < c->maxbands; i++)\n\n        bands[i].res[0] = bands[i].res[1] = 0;\n\n\n\n    if(keyframe){\n\n        for(i = 0; i < 32; i++)\n\n            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;\n\n            if(cnt >= 0){\n\n                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);\n\n                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);\n\n                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(!bands[i].res[ch]) continue;\n\n\n\n            if(c->oldDSCF[ch][i]){\n\n                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;\n\n                c->oldDSCF[ch][i] = 0;\n\n            }else{\n\n                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);\n\n                if(t == 64)\n\n                    t += get_bits(gb, 6);\n\n                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;\n\n            }\n\n            for(j = 0; j < 2; j++){\n\n                if((bands[i].scfi[ch] << j) & 2)\n\n                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];\n\n                else{\n\n                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);\n\n                    if(t == 31)\n\n                        t = 64 + get_bits(gb, 6);\n\n                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){\n\n        for(ch = 0; ch < 2; ch++){\n\n            res = bands[i].res[ch];\n\n            switch(res){\n\n            case -1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++)\n\n                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;\n\n                break;\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){\n\n                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);\n\n                    t = mpc8_get_mask(gb, 18, cnt);\n\n                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)\n\n                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;\n\n                }\n\n                break;\n\n            case 2:\n\n                cnt = 6;//2*mpc8_thres[res]\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 3){\n\n                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);\n\n                    c->Q[ch][off + j + 0] = mpc8_idx50[t];\n\n                    c->Q[ch][off + j + 1] = mpc8_idx51[t];\n\n                    c->Q[ch][off + j + 2] = mpc8_idx52[t];\n\n                    cnt = (cnt >> 1) + mpc8_huffq2[t];\n\n                }\n\n                break;\n\n            case 3:\n\n            case 4:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 2){\n\n                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];\n\n                    c->Q[ch][off + j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n", "idx": 7558, "substitutes": {"avctx": [" avcontext", "afcli", " avcv", "Avcli", "abcp", "Avpkg", "afcv", "ajpkg", "afctx", "abcontext", "afcp", "afpkg", "avcontext", "avcv", "ajcli", "avcp", "Avcontext", " avcp", "Avctx", "avpkg", "afcontext", "ajctx", "ajcontext", "abcv", "abctx", "avcli"], "data": ["base", "pack", "buff", "bin", "block", "dat", "channel", "config", "val", "queue", "body", "image", "m", "in", "window", "uf", "content", "client", "media", "d", "DATA", "buffer", "code", "connection", "da", "message", "Data", "bytes", "response", "load", "result", "p", "input", "batch", "reader", "frame", "memory", "read", "board", "cache", "next", "size"], "data_size": ["data\u00b7grow", "data\u00b7timeout", "dataflowsize", "dataflowgrow", "dataflowlen", "buffer_len", "buffer_timeout", "dataflowtimeout", "buffer_grow", "data\u00b7size", "data\u00b7len", "data_len", "data_grow", "data_timeout", "buffer_size"], "avpkt": ["avfacket", "abpct", "avfpkt", " avvpki", "avfkt", " avpki", "avfpkg", "abpck", "avfck", "avpacket", "avwpck", "avwpkt", "avbpcht", "abpkg", "avpct", "abcpacket", "avfpct", " avvpck", "avcpacket", "avvpkt", "avckt", "avcpkt", "avcpct", "abcpkg", "abcpct", "avcpck", "avvpki", "avwpcht", "abcpck", "avpck", " avvpcht", " avpcht", "avvpcht", "avpkg", "avfpacket", "avvpck", "avbpki", "avbpkt", "avpki", " avvpkt", "avwpki", "avpcht", "abpacket", "abpkt", "avcct", "avcpkg", "avcck", " avpck", "avfct", "avbpck", "avfkg", "avcacket", "abcpkt"], "buf": ["cas", "buff", "vec", "mem", "block", "box", "cur", "v", "rb", "config", " buffer", "rc", "queue", "map", "uc", "fb", "uf", "buffer", "code", "bag", "raw", "port", "cmd", "pad", "bc", "cb", "seq", "array", "p", "batch", "alloc", "cf", "br", "board", "cv", "cache", "pb", "src", "img"], "c": ["cp", "icc", "cmp", "cr", "v", "cur", "s", "ci", "component", "config", "b", "nc", "com", "sync", "rc", "enc", "cat", "co", "C", "uc", "cy", "m", "l", "f", "client", "d", "pc", "cc", "cs", "ce", "u", "conf", "arc", "con", "mc", "sc", "e", "dc", "conn", "ctx", "n", "bc", "cu", "coll", "p", "ctrl", "ec", "ca", "h", "cit", "g", "ct", "cn", "cf", "lc", "fc", "ac", "vc", "cache", "r", "cm", "cd", "xc"], "gb2": ["cvv", "gb4", "gb3", "GB2", "c2", "GB1", "GB4", "gbTwo", "pc2", "GBv", " rc3", "cTwo", "cv1", "gg2", " rcTwo", "pcTwo", "ggv", "cv4", "gbv", "pc3", "c3", "gb1", "cv2", "gg4", "gg1", " rc2"], "gb": ["gp", "agg", "cgi", "cfg", "band", "buff", "bp", "bin", "gm", "hub", "ci", "gru", "rb", "config", "bg", "b", "rc", "bm", "db", "gu", "uf", "ga", "pg", "usb", "gin", "pc", "gz", "bb", "py", "eb", "sb", "gs", "gam", "rg", "banks", "binary", "storage", "lib", "ctx", "bc", "GB", "cb", "go", "nb", "gold", "mb", "boot", "gy", "kb", "g", "bf", "gd", "lc", "gt", "gg", "bo", "yg"], "i": ["gi", "o", "ti", "v", "id", "I", "chi", "ih", "di", "ik", "ci", "ki", "ji", "ni", "b", "x", "si", "xi", "io", "ri", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "iu", "it", "ai", "u", "e", "sh", "uri", "ami", "ori", "n", "multi", "mi", "ini", "ie", "p", "h", "z", "eni", "oi", "hi", "ind", "ip", "y", "api", "li", "fi", "r", "zi", "ui"], "j": ["o", "v", "ji", "b", "si", "m", "l", "f", "ij", "ii", "d", "q", "u", "J", "n", "jp", "ie", "p", "h", "z", "pos", "ind", "g", "y", "r"], "k": ["o", "v", "ik", "ki", "x", "kk", "m", "key", "K", "sk", "f", "d", "q", "u", "ck", "e", "w", "ks", "n", "p", "kw", "h", "z", "ke", "g", "y"], "ch": ["chi", "ci", "x", "b", "ich", "sk", "f", "conf", "code", "col", "cho", "cor", "cham", "h", "chn", "ver", "y", "CH", "bh", "conn", "cm", "cp", "cur", "try", "channel", "cry", "cher", "Ch", "sh", "sc", "zh", "sch", "work", "batch", "z", "cht", "arch", "form", "fr", "change", "cha", "th", "cl", "ph", "u", "dev", "p", "hr", "ach", "app", "cel", "chy", "chip", "v", "pr", "pull", "che", "cy", "qi", "child", "q", "chart", "qu", "ky", "gh", "chan", "och"], "cnt": ["lcno", " cn", " cnc", " cnd", "count", "cnd", "CNT", "ecnc", "ecNT", "cno", "lcnc", "Cno", "Cnc", "acno", "lcn", " cNT", "ecnt", "lcct", "cct", "cnc", " cct", "ecct", "Cnt", "cNT", "lcNT", "Count", "ecnd", " count", "acn", "acnt", "ecount", " cno", "cn", "lcnt", "Cnd", "acNT", "Cct"], "res": ["gr", "reset", "ret", "reg", "press", "block", "prev", "spec", "total", "ress", "values", "Res", "ex", "real", "rh", "vals", "results", "rest", "ras", "des", "resolution", "def", "rss", "sc", "arr", "rx", "ts", "err", "response", "rev", "pres", "result", "rem", "req", "blocks", "remote", "re", "mr", "sp", "RES", "pos", "os", "range", "ms", "resp", "rep", "rs", "r", "ps", "max"], "t": ["ot", "o", "tf", "v", "rt", "total", "nt", "unt", "qt", "token", "template", "wt", "m", "pt", "l", "f", "at", "it", "e", "mt", "det", "tn", "port", "n", "tm", "ts", "p", "tz", "ut", "ta", "g", "y", "type", "dt", "tp", "tt", "T", "r", "tc"], "bands": ["groups", "points", "types", "models", "bass", "band", "files", "books", "objects", "rules", "balls", "bits", "plugins", "words", "b", "modules", "cells", "services", "ogs", "cats", "pins", "planes", "states", "girls", "codes", "parts", "images", "cycles", "heads", "stores", "rooms", "archs", "orders", "classes", "sb", "banks", "ks", "steps", "pages", "ds", "bys", "jobs", "devices", "chains", "players", "blocks", "rings", "pieces", "products", "tops", "bags", "cards", "g", "tracks", "ands", "amps", "bones", "frames", "ids", "lines", "versions", "bows", "charges", "lists"], "off": ["o", "reset", "ef", "total", "offs", "op", "offset", "obj", "loop", "def", "low", "error", "out", "one", "opt", "Off", " offset", "ip", "orig", "on", "mode", "shift", "ff", "ok"], "maxband": ["maxhard", "xBand", "mincell", "scaleband", "modbridge", "maxchannel", " maxbit", "maxblock", "scalebit", "modbit", "maxbroad", "Maxband", "axboot", "axbridge", "righthard", "maxgroup", " maxbroad", "workline", " maxgroup", "workbit", "lastbit", "taxpage", "lastline", "maxBand", "totalband", "rightbit", "axblock", "rightblock", "xbit", "rightband", "axpage", "minchannel", "taxhard", "axbroad", "lastband", "totalline", "minbit", "taxband", " maxline", "axBand", "axbit", "workband", "MaxBand", "minline", "totalbit", "mingroup", "modpage", "xband", "axline", " maxblock", "minband", "maxcell", " maxBand", " maxchannel", "maxbit", "Maxboot", "taxbit", "rightbridge", "maxline", "maxbridge", " maxpage", "scalecell", "lastBand", "rightpage", "axframe", "workframe", "scalegroup", "totalBand", "maxboot", " maxcell", "axband", "modband", "maxframe", "rightbroad", " maxboot", " maxframe", "maxpage", "axchannel", " maxhard"], "keyframe": ["maxFrame", "Keyline", "khole", " keyframes", "rowframe", "rowcode", " keyhole", "skycode", "keyfram", "Keyframe", "Keyiframe", "keycode", "skyfram", "keyframes", "kframe", "skyframe", " keyiframe", "keyline", "skyiframe", "rowfram", "maxframe", "KeyFrame", "maxline", "Keyfram", "Keyframes", "rowframes", "kframes", "Keycode", "keyhole", " keyfram", "skyframes", "Keyhole", "maxframes", "keyiframe", " keyFrame", " keyline", "keyFrame"], "last": ["master", "base", "est", "recent", "build", "extra", "id", "not", "prev", "parent", "total", "count", "since", "scope", "best", "list", "final", "style", "tr", "or", "now", "bottom", "use", "valid", "cle", "private", "child", "used", "active", "Last", "pop", "push", "code", "all", "any", "full", "latest", "always", "history", "empty", "first", "cycle", "str", "self", "one", "old", "eval", "this", "shared", "cost", "range", "pull", "new", "worst", "only", "desc", "next", "cache", "current", "max", "end", "size"], "mask": ["id", "count", "bits", "total", " tr", "tr", " masks", "bit", "info", "m", "th", "sk", "offset", "Mask", "tl", "all", "depth", "black", "ts", "ask", "p", "qa", "batch", "tile", "ta", "type", "max"], "cur_frame": ["curopchannel", "latestopelement", "curfelement", "curfchannel", "cur_channel", "cur_bit", "cur__bit", "latestopbit", "latest_bit", "curopframe", "curopbit", "curfframe", "latest_frame", "latest_element", "latestopchannel", "latestopframe", "cur__channel", "cur__frame", "cur_element", "curopelement", "latest_channel", "curfbit", "cur__element"]}}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "substitutes": {"bus": ["vol", "base", "plugin", "ch", "block", "hub", "local", "http", "id", "parent", "BUS", "device", "config", "plug", "bug", "io", "home", "use", "lab", "cat", "sync", "Bus", "loc", "db", "f", "book", "usb", "state", "loop", "us", "kind", "mount", "se", "driver", "lib", "bc", "pass", "self", "lock", "bridge", "controller", "serial", "root", "boot", "pos", "os", "class", "cache", "host", "ass"], "name": ["base", "address", "id", "parent", "unknown", "device", "word", "object", "data", "alias", "named", "info", "names", "key", "package", "null", "version", "Name", "part", "code", "NAME", "size", "connection", "ame", "n", "path", "self", "str", "nam", "none", "new", "type", "class", "prefix"], "dev": ["ch", "od", "local", "rad", "di", "Dev", "dd", "device", "adv", "bug", "val", "data", "enc", "ad", "dem", "der", "debug", "valid", "gu", "private", "de", "d", "ve", "mod", "obj", "dist", "conf", "ev", "def", "DEV", "wd", "priv", " Dev", "kind", "error", "inst", "die", "driver", "sd", "dc", "comment", "instance", "err", "self", "result", "p", "pub", "serial", "h", "prop", "development", "ver", "var", "gd", "cache", "fi", "app", "test", "prov", "grad", "conn", "diff", "cd"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n", "idx": 7590, "substitutes": {"obj": ["base", "o", "objects", "parent", "Obj", "po", "ob", "object", "data", "x", "val", "b", "op", "f", "j", "q", "e", "fn", "k", "instance", "Object", "n", "ctx", "bot", "t", "self", "p", "xxx", "os", "c", "bo", "ref", "pb", "src"], "v": ["nv", "vim", "vol", "o", "qv", "vm", "s", "value", "V", "va", "vic", "b", "data", "i", "x", "val", "m", "uv", "l", "gu", "f", "conv", "version", "ve", "j", "av", "d", "q", "tv", "ev", "vi", "u", "e", "vs", "w", "k", "t", "n", "self", "rev", "p", "vers", "h", "vert", "sv", "iv", "ver", "erv", "var", "c", "g", "ov", "lv", "vv", "cv", "view"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 7596, "substitutes": {"base": ["bas", "address", "as", "name", "area", "padding", "origin", "bin", "v", "id", "a", "pa", "scope", "b", "x", "io", "i", "bit", "abi", "bi", "body", "unit", "support", "f", "offset", "state", "server", "length", "u", "buffer", "code", "len", "size", "e", "proxy", "native", "binary", "k", "storage", "n", "bytes", "path", "bare", "source", "p", "scale", "root", "Base", "gb", "kb", "fs", "start", "c", "os", "type", "core", "y", "cache", "index", "prefix"], "irq": ["rinqs", "rinqu", "mirqs", "drq", " irqs", "irqs", " irqu", " irp", "iperq", "earqu", "iperqs", "mirq", "earq", "drp", "drqu", "earqi", "mirqi", "rinqi", "drqs", "irtq", "irtqs", "iperqu", "mirqu", "arqu", "iperqi", "irp", "arqi", "irtqu", "arqs", "irtp", "irqi", "rinq", "irqu", "arq", "earqs"], "nchannels": ["nachares", " nChares", "nchanords", "nChannels", "nchanannels", "nchores", " nChores", "nChores", "ncharares", "nchars", "nchanans", "numchans", " nChannels", "nChords", "numchords", "numarchords", "nChars", "nchares", " nchares", " nchars", " nChans", "nachans", "nchans", "nquores", " nChances", "numarchans", "nachannels", "nchanars", "nchances", "ncharannels", "nChares", "narchans", "numchars", "nquannels", "nquars", "nchanores", "numarchars", "ncharans", " nchores", "narchannels", "nchords", "nChances", "nquans", " nChars", "nChans", " nchans", "numarchannels", "nachances", "numchannels", "narchords", "ncharances", " nchances", "narchars"], "iomemtype": ["ymemtypes", "lynemtype", "iomemintype", "iomearlen", "iom\u00e8ype", "lyn\u00e8tag", "iomemlike", "iomEMtype", "iomemslike", "iomemlen", "iomEMlike", "mopemintag", "iomhemresource", "iomemsweight", "iomemintag", "ymemtype", "iomommap", "iomomtag", "iomemweight", "iom\u00e8type", "ymommap", "iom\u00e8tag", "iomhemmap", "iomeartag", "iomemresource", "iomeminlike", "iomimresource", "lyn\u00e8len", "iomomype", "mopeminlike", "ymomtypes", "iomomtype", "iomemstype", "mopeminweight", "iomeminweight", "iomhemtypes", "lynemtag", "ymemmap", "iom\u00e8len", "iomomtypes", "ymemresource", "iomomlen", "iomimmap", "ymomresource", "lynemype", "iomemtypes", "iomearype", "mopemweight", "iomemype", "iomemtag", "iomEMtag", "iomemmap", "iomimtype", "iomemstag", "ymomtype", "lyn\u00e8type", "iomimtypes", "lyn\u00e8ype", "mopemtag", "iomhemtype", "iomEMweight", "mopemlike", "lynemlen", "mopemtype", "iomomresource", "iomeartype", "mopemintype"], "s": ["o", "ches", "sf", "v", "is", "S", "a", "spec", "sg", "ows", "session", "b", "socket", "si", "i", "x", "sync", "sys", "ses", "services", "m", "rows", "ips", "support", "states", "l", "its", "f", "ns", "state", "stats", "sl", "d", "server", "service", "ls", "ss", "cs", "u", "conf", "e", "us", "native", "w", "sb", "gs", "secondary", "t", "storage", "n", "ds", " shares", "ts", "ings", "p", "settings", "fs", "c", "os", "g", "ssl", "new", "sym", "es", "rs", "r", "ps", "js"]}}
{"project": "FFmpeg", "commit_id": "596b5c488fa1d40f114a64d3b73e1863cab073fb", "target": 0, "func": "static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,\n\n                                  float **plevel_table, uint16_t **pint_table,\n\n                                  const CoefVLCTable *vlc_table)\n\n{\n\n    int n                        = vlc_table->n;\n\n    const uint8_t  *table_bits   = vlc_table->huffbits;\n\n    const uint32_t *table_codes  = vlc_table->huffcodes;\n\n    const uint16_t *levels_table = vlc_table->levels;\n\n    uint16_t *run_table, *level_table, *int_table;\n\n    float *flevel_table;\n\n    int i, l, j, k, level;\n\n\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);\n\n\n\n    run_table    = av_malloc(n * sizeof(uint16_t));\n\n    level_table  = av_malloc(n * sizeof(uint16_t));\n\n    flevel_table = av_malloc(n * sizeof(*flevel_table));\n\n    int_table    = av_malloc(n * sizeof(uint16_t));\n\n    i            = 2;\n\n    level        = 1;\n\n    k            = 0;\n\n    while (i < n) {\n\n        int_table[k] = i;\n\n        l            = levels_table[k++];\n\n        for (j = 0; j < l; j++) {\n\n            run_table[i]    = j;\n\n            level_table[i]  = level;\n\n            flevel_table[i] = level;\n\n            i++;\n\n        }\n\n        level++;\n\n    }\n\n    *prun_table   = run_table;\n\n    *plevel_table = flevel_table;\n\n    *pint_table   = int_table;\n\n    av_free(level_table);\n\n}\n", "idx": 7598, "substitutes": {"vlc": ["dlc", "wlf", "lllc", "wllc", "vlct", "vlcs", "nlcs", "vllc", "dlpc", "dlcs", "vlpc", "vlv", "llv", "llpc", "llct", "dlct", "tlv", "nlpc", "wlv", "tlf", "llcs", "nlc", "nlct", "vlf", "tllc", "llc", "wlc", "tlc", "llf"], "prun_table": ["prune_TABLE", "prunt_TABLE", "prune_total", "prunalltotal", "prunt_table", "prunallcache", "prune_cache", "prun_TABLE", "prun_code", "prunt_code", "prune_table", "prunallTABLE", "prun_cache", "prun_total", "prunalltable"], "plevel_table": ["pleveningtype", "plevel__tab", "pleven_type", "plevel_tab", "plevel__tree", "plecl_code", "plevelentree", "plecl_tree", "plevel_body", "plevel_code", "plevelentype", "pleven_tree", "plecl_body", "plevelingtype", "pleveningtab", "pleven_tab", "plevelentab", "plevelingtree", "plevelingtable", "plevelentable", "plevel__table", "pleven_table", "pleveningtable", "plevel__type", "plevel_type", "plecl_table", "pleveningtree", "plevelingtab", "plevel_tree"], "pint_table": ["pbyte_tree", "pbyte_code", "pint8table", "pint8tree", "pint_cache", "pintallsource", "pint8code", "pintallcache", "pint_tree", "pint_interface", "pint_source", "pinner_count", "pint8interface", "pinner_source", "pintalltable", "pbyte_interface", "pintallcount", "pint_code", "pinner_table", "pint_count", "pinner_cache", "pbyte_table"], "vlc_table": ["vlc__database", "vlcs_TABLE", "vlc2TABLE", "vlc_TABLE", "vlf_TABLE", "vll_database", "vlc2database", "vlc_cache", "vlf_database", "vll_table", "vlg_container", "vlc_tree", "vlg_tree", "vlf_stable", "vll_cache", "vlc2tab", "vlc2cache", "vlc_database", "vlc__stable", "vlc2module", "vlf_cache", "vlc_container", "vlc2table", "vlg_database", "vlc__TABLE", "vlcs_tab", "vlc__cache", "vlcs_table", "vlc_stable", "vlcs_module", "vlc_module", "vlg_table", "vlf_table", "vlc_tab", "vll_stable", "vlc__table"], "table_bits": ["table__codes", "table__files", "tableaccodes", "table_files", "tableacfields", "tableacbits", " table_files", "table__bits", "table_bytes", " table_fields", "table_fields", "table__bytes", "tableacbytes", " table_bytes"], "table_codes": ["table___codes", "tableaccode", "table___items", "tableaccodes", "table_code", " table_items", "table_items", "tableacbits", " table_code", " table_devices", "tableactypes", " table_types", "table___code", "table_types", "table_devices", "table___devices"], "levels_table": ["levels_stable", "vel_code", "levels__tree", "vals_database", "levels_code", "vals_table", "levelsamstable", "velalltree", "levels__code", "levelsamdatabase", "levels_tree", "velalltable", "levelsamtree", "vals_stable", "levels_database", "levelsalltab", "levelsalltable", "levelsamtable", "vals_tree", "levels__tab", "levels_tab", "velalltab", "vel_tree", "levelsalltree", "levels__table", "velallcode", "vel_tab", "vel_table", "levelsallcode"], "run_table": [" runaltest", "runningtree", "runttree", " run_test", "arrayerbuffer", "runstable", " run_data", "array_type", "runalinterface", "run64table", "run64buffer", "run__data", "run_type", "runttest", "build_table", "run_range", "build_session", "run_data", "runningtype", "arrayertype", "run_tree", "runningbuffer", "buildaldatabase", " runaltable", "array_tree", "arrayertable", "runersession", "buildaltable", "runertree", "run_database", "build_interface", "run64range", "runsbuffer", "run__table", "runtdata", "run_session", "runsrange", "runertable", "runalrange", "run__tree", "runttable", "runningtable", "array_table", " run_range", "run_buffer", "run64tree", "run__test", "runerinterface", "runalbuffer", " runaldata", "buildalsession", "runalsession", "runerdatabase", "runaldatabase", "runaltable", " run64tree", " run64table", "runaldata", "runstree", "runertype", " run64range", "arrayertree", " run_buffer", "buildalinterface", " runaltree", "run_test", "runaltree", " run_tree", "runaltest", "build_database", " run64buffer", "runerbuffer", "array_buffer", "run_interface"], "level_table": ["levelscourse", "level___list", "line_tree", "wl_store", "levelsmode", "wl_mode", "levelallcourse", "level2database", "line_table", "bit_tab", "level_mode", "levelsstore", "level_store", "run_tree", "bit_course", "levelptree", "level___tree", "bitalltab", "bitallcache", "run_database", "bit_cache", "levelpdatabase", "level_tab", "levelstable", "level_database", "wl_table", "bitallcourse", "bit_table", "wl_course", "line_code", "line_list", "levelallcache", "level___code", "bitalltable", "level2tree", "level_cache", "level_list", "run2table", "level2stable", "run2stable", "level_stable", "levelalltable", "run2database", "level2table", "levelptable", "run2tree", "levelpstable", "level_code", "levelalltab", "run_stable", "level___table", "level_tree", "level_course"], "int_table": ["int7table", "valalltab", "int24tab", "intltable", "int_tree", "int8stable", "intlmodule", "intltree", "intallmodule", "int24tree", " int_tab", "valalltable", "run_tree", "run_bottom", "int_database", "int_stable", "valalltree", "run_TABLE", "int8body", "int7TABLE", "intalltree", "int_TABLE", "run_session", "int_tab", "intltab", "run_body", "intalltab", "intalltable", "valallmodule", "int7session", "int24database", "int8tree", "val_tree", "val_module", "int8bottom", "int_session", "int24table", "int8TABLE", "int8table", "val_tab", "int_body", "int8session", "val_table", "int7bottom", "int_bottom", "run_stable", "int_module", " int_database", " int_tree"], "flevel_table": ["flvl32table", "fall_table", "flevel32code", "flevel2mode", "flevel_root", "flvl_window", "flevelstable", "fvel_view", "fall_mode", "flevelalltable", "flvlerrule", "flevel2root", "flvl_root", "flevel_code", "flvlertree", "flvlerlatest", "flevelerrule", "fvel_bar", "flevel_window", "flevel_range", "flvl_latest", "flevel_latest", "flvl_table", "flevelslatest", "flvl32range", "fall_cache", "flvl32window", "flvl32code", "fvel_table", "flevelertable", "fall_tree", "flvl_range", "flevel_tab", "flevel_tree", "flevelalllatest", "flevel2cache", "flevel32range", "flevel_view", "flevel2tab", "flevel_mode", "flevel_bar", "flevel_cache", "flevelalltree", "flvl_code", "flevel2tree", "flevel2bar", "flevelstree", "flevelsrule", "flevelallrule", "flvl_cache", "flevel32table", "flvlertable", "flevelerlatest", "flevelertree", "flvl_rule", "flevel32window", "flevel_rule", "fvel_tab", "flvl_tree", "flevel2view", "flevel2table"], "i": ["o", "v", "id", "I", "a", "di", "ci", "ki", "ji", "ni", "b", "x", "si", "xi", "io", "ri", "m", "qi", "key", "f", "pi", "phi", "d", "ii", "iu", "q", "u", "e", "uri", "ori", "t", "n", "mi", "ini", "ie", "p", "mini", "z", "line", "oi", "c", "g", "ind", "y", "lc", "li", "r", "zi", "ui"], "l": ["nl", "o", "v", "el", "la", "jl", "ji", "b", "ll", "m", "f", "ii", "sl", "d", "fl", "ls", "u", "e", "L", "ol", "n", "lu", "p", "h", "z", "ln", "c", "kl", "g", "wl", "lc", "lin", "dl", "li", "il", "pl", "r"], "j": ["jet", "fr", "o", "ch", "v", "el", "oj", "jl", "ji", "b", "x", "si", "m", "key", "f", "job", "d", "ii", "aj", "q", "ij", "it", "fl", "u", "e", "point", "w", "J", "ol", "jc", "n", "uj", "other", "jp", "jo", "ie", "p", "h", "z", "jj", "line", "c", "g", "y", "ja", "dj", "br", "li", "r", "ui", "js"], "k": ["ko", "o", "v", "ik", "s", "ki", "kick", "x", "kk", "key", "K", "f", "sk", "dk", "d", "q", "u", "unk", "e", "ck", "ak", "w", "km", "ks", "t", "n", "kid", "ask", "work", "p", "kw", "ky", "z", "ke", "kl", "c", "y", "tk", "ek", "uk", "r", "ok"], "level": ["levels", "gi", "layer", "o", "position", "iter", "id", "local", "parent", "vel", "val", "update", "list", "slice", "pe", "loc", "inc", "cl", "Level", "f", "key", "letter", "child", "length", "fl", "d", "loop", "e", "sc", "lo", "w", "depth", "section", "L", "n", "pass", "jo", "p", "temp", "scale", "h", "z", "lvl", "where", "line", "hi", "ld", "ul", "g", "wl", "lc", "li", "index"]}}
{"project": "FFmpeg", "commit_id": "d7b2bb5391bf55e8f9421bff7feb4c1fddfac4bf", "target": 0, "func": "static inline int parse_nal_units(AVCodecParserContext *s,\n\n                                  AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    H264ParseContext *p = s->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    H2645NAL nal = { NULL };\n\n\n\n    unsigned int pps_id;\n\n    unsigned int slice_type;\n\n    int state = -1, got_reset = 0;\n\n    int field_poc[2];\n\n    int ret;\n\n\n\n    /* set some sane default values */\n\n    s->pict_type         = AV_PICTURE_TYPE_I;\n\n    s->key_frame         = 0;\n\n    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;\n\n\n\n    ff_h264_sei_uninit(&p->sei);\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    for (;;) {\n\n        const SPS *sps;\n\n        int src_length, consumed;\n\n        buf = avpriv_find_start_code(buf, buf_end, &state);\n\n        if (buf >= buf_end)\n\n            break;\n\n        --buf;\n\n        src_length = buf_end - buf;\n\n        switch (state & 0x1f) {\n\n        case H264_NAL_SLICE:\n\n        case H264_NAL_IDR_SLICE:\n\n            // Do not walk the whole buffer just to decode slice header\n\n            if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) {\n\n                /* IDR or disposable slice\n\n                 * No need to decode many bytes because MMCOs shall not be present. */\n\n                if (src_length > 60)\n\n                    src_length = 60;\n\n            } else {\n\n                /* To decode up to MMCOs */\n\n                if (src_length > 1000)\n\n                    src_length = 1000;\n\n            }\n\n            break;\n\n        }\n\n\n\n        consumed = ff_h2645_extract_rbsp(buf, src_length, &nal);\n\n        if (consumed < 0)\n\n            break;\n\n\n\n        ret = init_get_bits(&nal.gb, nal.data, nal.size * 8);\n\n        if (ret < 0)\n\n            goto fail;\n\n        get_bits1(&nal.gb);\n\n        nal.ref_idc = get_bits(&nal.gb, 2);\n\n        nal.type    = get_bits(&nal.gb, 5);\n\n\n\n        switch (nal.type) {\n\n        case H264_NAL_SPS:\n\n            ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps);\n\n            break;\n\n        case H264_NAL_PPS:\n\n            ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps,\n\n                                                 nal.size_bits);\n\n            break;\n\n        case H264_NAL_SEI:\n\n            ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx);\n\n            break;\n\n        case H264_NAL_IDR_SLICE:\n\n            s->key_frame = 1;\n\n\n\n            p->poc.prev_frame_num        = 0;\n\n            p->poc.prev_frame_num_offset = 0;\n\n            p->poc.prev_poc_msb          =\n\n            p->poc.prev_poc_lsb          = 0;\n\n        /* fall through */\n\n        case H264_NAL_SLICE:\n\n            get_ue_golomb(&nal.gb);  // skip first_mb_in_slice\n\n            slice_type   = get_ue_golomb_31(&nal.gb);\n\n            s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5];\n\n            if (p->sei.recovery_point.recovery_frame_cnt >= 0) {\n\n                /* key frame, since recovery_frame_cnt is set */\n\n                s->key_frame = 1;\n\n            }\n\n            pps_id = get_ue_golomb(&nal.gb);\n\n            if (pps_id >= MAX_PPS_COUNT) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"pps_id %u out of range\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            if (!p->ps.pps_list[pps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing PPS %u referenced\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data;\n\n            if (!p->ps.sps_list[p->ps.pps->sps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing SPS %u referenced\\n\", p->ps.pps->sps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data;\n\n\n\n            sps = p->ps.sps;\n\n\n\n            p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num);\n\n\n\n            s->coded_width  = 16 * sps->mb_width;\n\n            s->coded_height = 16 * sps->mb_height;\n\n            s->width        = s->coded_width  - (sps->crop_right + sps->crop_left);\n\n            s->height       = s->coded_height - (sps->crop_top   + sps->crop_bottom);\n\n            if (s->width <= 0 || s->height <= 0) {\n\n                s->width  = s->coded_width;\n\n                s->height = s->coded_height;\n\n            }\n\n\n\n            switch (sps->bit_depth_luma) {\n\n            case 9:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P9;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P9;\n\n                break;\n\n            case 10:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P10;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P10;\n\n                break;\n\n            case 8:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P;\n\n                break;\n\n            default:\n\n                s->format = AV_PIX_FMT_NONE;\n\n            }\n\n\n\n            avctx->profile = ff_h264_get_profile(sps);\n\n            avctx->level   = sps->level_idc;\n\n\n\n            if (sps->frame_mbs_only_flag) {\n\n                p->picture_structure = PICT_FRAME;\n\n            } else {\n\n                if (get_bits1(&nal.gb)) { // field_pic_flag\n\n                    p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); // bottom_field_flag\n\n                } else {\n\n                    p->picture_structure = PICT_FRAME;\n\n                }\n\n            }\n\n\n\n            if (nal.type == H264_NAL_IDR_SLICE)\n\n                get_ue_golomb(&nal.gb); /* idr_pic_id */\n\n            if (sps->poc_type == 0) {\n\n                p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc_bottom = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            if (sps->poc_type == 1 &&\n\n                !sps->delta_pic_order_always_zero_flag) {\n\n                p->poc.delta_poc[0] = get_se_golomb(&nal.gb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc[1] = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            /* Decode POC of this picture.\n\n             * The prev_ values needed for decoding POC of the next picture are not set here. */\n\n            field_poc[0] = field_poc[1] = INT_MAX;\n\n            ff_h264_init_poc(field_poc, &s->output_picture_number, sps,\n\n                             &p->poc, p->picture_structure, nal.ref_idc);\n\n\n\n            /* Continue parsing to check if MMCO_RESET is present.\n\n             * FIXME: MMCO_RESET could appear in non-first slice.\n\n             *        Maybe, we should parse all undisposable non-IDR slice of this\n\n             *        picture until encountering MMCO_RESET in a slice of it. */\n\n            if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) {\n\n                got_reset = scan_mmco_reset(s, &nal.gb, avctx);\n\n                if (got_reset < 0)\n\n                    goto fail;\n\n            }\n\n\n\n            /* Set up the prev_ values for decoding POC of the next picture. */\n\n            p->poc.prev_frame_num        = got_reset ? 0 : p->poc.frame_num;\n\n            p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset;\n\n            if (nal.ref_idc != 0) {\n\n                if (!got_reset) {\n\n                    p->poc.prev_poc_msb = p->poc.poc_msb;\n\n                    p->poc.prev_poc_lsb = p->poc.poc_lsb;\n\n                } else {\n\n                    p->poc.prev_poc_msb = 0;\n\n                    p->poc.prev_poc_lsb =\n\n                        p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];\n\n                }\n\n            }\n\n\n\n            if (sps->pic_struct_present_flag) {\n\n                switch (p->sei.picture_timing.pic_struct) {\n\n                case SEI_PIC_STRUCT_TOP_FIELD:\n\n                case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n                    s->repeat_pict = 0;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME:\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    s->repeat_pict = 1;\n\n                    break;\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                    s->repeat_pict = 2;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n                    s->repeat_pict = 3;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n                    s->repeat_pict = 5;\n\n                    break;\n\n                default:\n\n                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n                    break;\n\n                }\n\n            } else {\n\n                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n            }\n\n\n\n            if (p->picture_structure == PICT_FRAME) {\n\n                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;\n\n                if (sps->pic_struct_present_flag) {\n\n                    switch (p->sei.picture_timing.pic_struct) {\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                        s->field_order = AV_FIELD_TT;\n\n                        break;\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                        s->field_order = AV_FIELD_BB;\n\n                        break;\n\n                    default:\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                        break;\n\n                    }\n\n                } else {\n\n                    if (field_poc[0] < field_poc[1])\n\n                        s->field_order = AV_FIELD_TT;\n\n                    else if (field_poc[0] > field_poc[1])\n\n                        s->field_order = AV_FIELD_BB;\n\n                    else\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                }\n\n            } else {\n\n                if (p->picture_structure == PICT_TOP_FIELD)\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;\n\n                else\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;\n\n                s->field_order = AV_FIELD_UNKNOWN;\n\n            }\n\n\n\n            av_freep(&nal.rbsp_buffer);\n\n            return 0; /* no need to evaluate the rest */\n\n        }\n\n        buf += consumed;\n\n    }\n\n    /* didn't find a picture! */\n\n    av_log(avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n\nfail:\n\n    av_freep(&nal.rbsp_buffer);\n\n    return -1;\n\n}\n", "idx": 7609, "substitutes": {"s": ["sets", "sf", "v", "S", "http", "spec", "sg", "b", "si", "sync", "i", "sys", "ses", "services", "m", "l", "xs", "f", "parts", "ns", "d", "sl", "ls", "stats", "space", "service", "sci", "cs", "ss", "conf", "u", "e", "sc", "parser", "sb", "se", "gs", "ds", "t", "n", "ctx", "qs", "ts", "su", "self", "sv", "fs", "sa", "c", "utils", "ssl", "sq", "rs", "ps", "js"], "avctx": ["avecmd", "autctx", "autcmd", "autconfig", "avcontext", "AVcmd", "AVctx", "AVconfig", "avconfig", "AVcontext", "autcontext", "avecontext", "avectx", "avcmd", "aveconfig"], "buf": ["rb", "bg", "b", "data", "auc", "dest", "queue", "uc", "f", "buffer", "len", "code", "bag", "func", "bc", "ab", "pool", "off", "front", "pb", "img", "bh", "header", "cur", "count", "config", "fb", "uf", "port", "ctx", "batch", "doc", "cf", "text", "ff", "feed", "vec", "block", "box", "rc", "home", "wa", "loc", "wb", "num", "sb", "cmd", "feat", "input", "gb", "pos", "orig", "fd", "bo", "ref", "cache", "src", "buff", "v", "window", "offset", "length", "cb", "result", "seq", "context", "alloc", "br", "cv", "lim", "pkg"], "buf_size": ["buf_sized", " buf_width", " buf_sized", "buf_ize", "proc_ize", "buflexwidth", "buflexsized", "proc_start", "proc_size", "buflexsize", "proc_limit", "buf_limit", " buf_form", "buf_start", "buf_width", "buflexend", "buf_form"], "p": ["P", "bp", "press", "v", "pa", "pre", "pp", "b", "op", "i", "ap", "lp", "m", "l", "f", "pi", "mp", "d", "j", "pc", "q", "np", "u", "e", "parser", "port", "t", "n", "ctx", "fp", "jp", "h", "vp", "sp", "c", "g", "api", "tp", "pb", "ps", "pkg"], "buf_end": ["uc_ended", "buf2start", "buf_ending", "buf_stop", "buf2stop", "img_length", "uc_end", "img_start", "queue_ending", "buff00offset", "buf_length", "buf00start", "buf2end", "img00ent", "buf00end", "buf2ending", "img_end", "buff_offset", "queue_start", "img00end", "buf_ended", "buf00length", "img_ent", "img00length", "buf_clean", "buff_start", "uc_start", "buf_ent", "buff00start", "buff00end", "buf_start", "queue_stop", "buff00ent", "queue_end", "buff_end", "buf_offset", "buff_ent", "img00start", "buf00ent", "buf00offset", "uc_clean"], "pps_id": [" seq_sid", " seqessionkey", " img_key", " seq_num", " seqessionid", " img_sid", " seqessionsid", " seq_key", " img_id", " seqessionnum", " img_num", " seq_id"], "slice_type": ["slice___types", "slice_types", "slice___id", "slice___width", "slice_width", "proc_width", "slice_id", "proc_type", "proc_types", "proc_id", "slice___type"], "field_poc": ["field2piv", "field_copics", "field_copocol", "field_pocol", "field2pics", "field2div", "field2pocol", "field2poc", "field_toc", "field_piv", "field_pics", "field_copoc", "field2docol", "field_docol", "field2doc", "field_div", "field_tiv", "field_tocol", "field2dics", "field_tics", "field_copiv", "field_dics", "field_doc"], "ret": ["gc", "flag", "reg", "mem", "rt", "alt", "count", "nt", "value", "val", "data", "bit", "reply", "status", " RET", "num", " Ret", "lit", "att", "arg", "match", "def", "len", "mt", "det", "arr", "RET", "sat", "feat", "result", "seq", "Ret", "ft", "re", "fun", "back", "bf", "hash", "resp", "gt", "success", "ref", "rep", "no", "conn", "rets"], "sps": ["sPS", " spp", " sPS", "sspps", " spps", "ssPS", "SPS", "Spps", "sspp", "spp", "Sps", "ssps", "spps", "Spp"], "src_length": ["srcenwidth", "src_distance", "rc_path", "rc_width", "src64full", "src___shape", "source_length", "proc64length", "src_path", "src_off", "src___var", "proc_width", "src___length", " src_size", "src_width", "srcencost", "proc64full", "src00height", "src00width", "srcsposition", "proc64off", "src00limit", "src_var", "src_cost", "src64off", "proc_full", "src_limit", "src_len", "rc_length", "rc_var", "srcenpath", "srcslen", "proc_off", "rc_height", "rc_cost", "src64length", "src2size", "src64width", "srcenlength", "srcsdistance", "src_shape", "src_height", "src2width", "proc_length", "source_position", " src_width", "rc_shape", "rc_limit", "src00length", " src_path", "src_full", "src_position", "srcslength", "src___width", "proc64width", "src_size", "src2path", "src2length", "source_distance", "source_len"], "consumed": ["continumption", "conerved", " conserved", "conume", "preserved", "Conserved", "continumed", "conum", "consum", " consumption", "Consumed", "presumed", "resumption", "Consum", "consuming", "coume", "resuming", "coerved", "continerved", "resumed", "coumed", "coumption", "continume", "reserved", "Consuming", "consume", " consuming", "presume", "Consume", "conumed", "consumption", "Consumption", "conserved", "presum"]}}
{"project": "FFmpeg", "commit_id": "c94326c1fc2fb5719c6f28fe1b95c0c74417998b", "target": 1, "func": "static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,\n\n                                              int log2_size, int c_idx)\n\n{\n\n#define PU(x) \\\n\n    ((x) >> s->ps.sps->log2_min_pu_size)\n\n#define MVF(x, y) \\\n\n    (s->ref->tab_mvf[(x) + (y) * min_pu_width])\n\n#define MVF_PU(x, y) \\\n\n    MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift)))\n\n#define IS_INTRA(x, y) \\\n\n    (MVF_PU(x, y).pred_flag == PF_INTRA)\n\n#define MIN_TB_ADDR_ZS(x, y) \\\n\n    s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)]\n\n#define EXTEND(ptr, val, len)         \\\n\ndo {                                  \\\n\n    pixel4 pix = PIXEL_SPLAT_X4(val); \\\n\n    for (i = 0; i < (len); i += 4)    \\\n\n        AV_WN4P(ptr + i, pix);        \\\n\n} while (0)\n\n\n\n#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(i, -1))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i+3])\n\n#define EXTEND_LEFT_CIP(ptr, start, length) \\\n\n        for (i = start; i > (start) - (length); i--) \\\n\n            if (!IS_INTRA(i - 1, -1)) \\\n\n                ptr[i - 1] = ptr[i]\n\n#define EXTEND_UP_CIP(ptr, start, length)                                      \\\n\n        for (i = (start); i > (start) - (length); i -= 4)                      \\\n\n            if (!IS_INTRA(-1, i - 3))                                          \\\n\n                AV_WN4P(&ptr[i - 3], a);                                       \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i - 3])\n\n#define EXTEND_DOWN_CIP(ptr, start, length)                                    \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(-1, i))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i + 3])\n\n\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int i;\n\n    int hshift = s->ps.sps->hshift[c_idx];\n\n    int vshift = s->ps.sps->vshift[c_idx];\n\n    int size = (1 << log2_size);\n\n    int size_in_luma_h = size << hshift;\n\n    int size_in_tbs_h  = size_in_luma_h >> s->ps.sps->log2_min_tb_size;\n\n    int size_in_luma_v = size << vshift;\n\n    int size_in_tbs_v  = size_in_luma_v >> s->ps.sps->log2_min_tb_size;\n\n    int x = x0 >> hshift;\n\n    int y = y0 >> vshift;\n\n    int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n    int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n\n\n    int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb);\n\n\n\n    ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel);\n\n    pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride;\n\n\n\n    int min_pu_width = s->ps.sps->min_pu_width;\n\n\n\n    enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c :\n\n                              lc->tu.intra_pred_mode;\n\n    pixel4 a;\n\n    pixel  left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  top_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_top_array[2 * MAX_TB_SIZE + 1];\n\n\n\n    pixel  *left          = left_array + 1;\n\n    pixel  *top           = top_array  + 1;\n\n    pixel  *filtered_left = filtered_left_array + 1;\n\n    pixel  *filtered_top  = filtered_top_array  + 1;\n\n    int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask);\n\n    int cand_left        = lc->na.cand_left;\n\n    int cand_up_left     = lc->na.cand_up_left;\n\n    int cand_up          = lc->na.cand_up;\n\n    int cand_up_right    = lc->na.cand_up_right    && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1);\n\n\n\n    int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) -\n\n                           (y0 + size_in_luma_v)) >> vshift;\n\n    int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) -\n\n                           (x0 + size_in_luma_h)) >> hshift;\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        int size_in_luma_pu_v = PU(size_in_luma_v);\n\n        int size_in_luma_pu_h = PU(size_in_luma_h);\n\n        int on_pu_edge_x    = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size);\n\n        int on_pu_edge_y    = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size);\n\n        if (!size_in_luma_pu_h)\n\n            size_in_luma_pu_h++;\n\n        if (cand_bottom_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_bottom_pu = PU(y0 + size_in_luma_v);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu);\n\n            cand_bottom_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_left_pu   = PU(y0);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu);\n\n            cand_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_left == 1) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA;\n\n        }\n\n        if (cand_up == 1 && on_pu_edge_y) {\n\n            int x_top_pu    = PU(x0);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu);\n\n            cand_up = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_right == 1 && on_pu_edge_y) {\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int x_right_pu  = PU(x0 + size_in_luma_h);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu);\n\n            cand_up_right = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        top[-1] = 128;\n\n    }\n\n    if (cand_up_left) {\n\n        left[-1] = POS(-1, -1);\n\n        top[-1]  = left[-1];\n\n    }\n\n    if (cand_up)\n\n        memcpy(top, src - stride, size * sizeof(pixel));\n\n    if (cand_up_right) {\n\n        memcpy(top + size, src - stride + size, size * sizeof(pixel));\n\n        EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1),\n\n               size - top_right_size);\n\n    }\n\n    if (cand_left)\n\n        for (i = 0; i < size; i++)\n\n            left[i] = POS(-1, i);\n\n    if (cand_bottom_left) {\n\n        for (i = size; i < size + bottom_left_size; i++)\n\n            left[i] = POS(-1, i);\n\n        EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1),\n\n               size - bottom_left_size);\n\n    }\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) {\n\n            int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ?\n\n                                    2 * size : (s->ps.sps->width - x0) >> hshift;\n\n            int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ?\n\n                                    2 * size : (s->ps.sps->height - y0) >> vshift;\n\n            int j = size + (cand_bottom_left? bottom_left_size: 0) -1;\n\n            if (!cand_up_right) {\n\n                size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ?\n\n                                                    size : (s->ps.sps->width - x0) >> hshift;\n\n            }\n\n            if (!cand_bottom_left) {\n\n                size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ?\n\n                                                     size : (s->ps.sps->height - y0) >> vshift;\n\n            }\n\n            if (cand_bottom_left || cand_left || cand_up_left) {\n\n                while (j > -1 && !IS_INTRA(-1, j))\n\n                    j--;\n\n                if (!IS_INTRA(-1, j)) {\n\n                    j = 0;\n\n                    while (j < size_max_x && !IS_INTRA(j, -1))\n\n                        j++;\n\n                    EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    left[-1] = top[-1];\n\n                }\n\n            } else {\n\n                j = 0;\n\n                while (j < size_max_x && !IS_INTRA(j, -1))\n\n                    j++;\n\n                if (j > 0)\n\n                    if (x0 > 0) {\n\n                        EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    } else {\n\n                        EXTEND_LEFT_CIP(top, j, j);\n\n                        top[-1] = top[0];\n\n                    }\n\n                left[-1] = top[-1];\n\n            }\n\n            left[-1] = top[-1];\n\n            if (cand_bottom_left || cand_left) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_DOWN_CIP(left, 0, size_max_y);\n\n            }\n\n            if (!cand_left)\n\n                EXTEND(left, left[-1], size);\n\n            if (!cand_bottom_left)\n\n                EXTEND(left + size, left[size - 1], size);\n\n            if (x0 != 0 && y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n                if (!IS_INTRA(-1, - 1))\n\n                    left[-1] = left[0];\n\n            } else if (x0 == 0) {\n\n                EXTEND(left, 0, size_max_y);\n\n            } else {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n            }\n\n            top[-1] = left[-1];\n\n            if (y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_RIGHT_CIP(top, 0, size_max_x);\n\n            }\n\n        }\n\n    }\n\n    // Infer the unavailable samples\n\n    if (!cand_bottom_left) {\n\n        if (cand_left) {\n\n            EXTEND(left + size, left[size - 1], size);\n\n        } else if (cand_up_left) {\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_left = 1;\n\n        } else if (cand_up) {\n\n            left[-1] = top[0];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else if (cand_up_right) {\n\n            EXTEND(top, top[size], size);\n\n            left[-1] = top[size];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up      = 1;\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else { // No samples available\n\n            left[-1] = (1 << (BIT_DEPTH - 1));\n\n            EXTEND(top,  left[-1], 2 * size);\n\n            EXTEND(left, left[-1], 2 * size);\n\n        }\n\n    }\n\n\n\n    if (!cand_left)\n\n        EXTEND(left, left[size], size);\n\n    if (!cand_up_left) {\n\n        left[-1] = left[0];\n\n    }\n\n    if (!cand_up)\n\n        EXTEND(top, left[-1], size);\n\n    if (!cand_up_right)\n\n        EXTEND(top + size, top[size - 1], size);\n\n\n\n    top[-1] = left[-1];\n\n\n\n    // Filtering process\n\n    if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0  || s->ps.sps->chroma_format_idc == 3)) {\n\n        if (mode != INTRA_DC && size != 4){\n\n            int intra_hor_ver_dist_thresh[] = { 7, 1, 0 };\n\n            int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)),\n\n                                          FFABS((int)(mode - 10U)));\n\n            if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) {\n\n                int threshold = 1 << (BIT_DEPTH - 5);\n\n                if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 &&\n\n                    log2_size == 5 &&\n\n                    FFABS(top[-1]  + top[63]  - 2 * top[31])  < threshold &&\n\n                    FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) {\n\n                    // We can't just overwrite values in top because it could be\n\n                    // a pointer into src\n\n                    filtered_top[-1] = top[-1];\n\n                    filtered_top[63] = top[63];\n\n                    for (i = 0; i < 63; i++)\n\n                        filtered_top[i] = ((64 - (i + 1)) * top[-1] +\n\n                                           (i + 1)  * top[63] + 32) >> 6;\n\n                    for (i = 0; i < 63; i++)\n\n                        left[i] = ((64 - (i + 1)) * left[-1] +\n\n                                   (i + 1)  * left[63] + 32) >> 6;\n\n                    top = filtered_top;\n\n                } else {\n\n                    filtered_left[2 * size - 1] = left[2 * size - 1];\n\n                    filtered_top[2 * size - 1]  = top[2 * size - 1];\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_left[i] = (left[i + 1] + 2 * left[i] +\n\n                                            left[i - 1] + 2) >> 2;\n\n                    filtered_top[-1]  =\n\n                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2;\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_top[i] = (top[i + 1] + 2 * top[i] +\n\n                                           top[i - 1] + 2) >> 2;\n\n                    left = filtered_left;\n\n                    top  = filtered_top;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (mode) {\n\n    case INTRA_PLANAR:\n\n        s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                          (uint8_t *)left, stride);\n\n        break;\n\n    case INTRA_DC:\n\n        s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top,\n\n                       (uint8_t *)left, stride, log2_size, c_idx);\n\n        break;\n\n    default:\n\n        s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                           (uint8_t *)left, stride, c_idx,\n\n                                           mode);\n\n        break;\n\n    }\n\n}\n", "idx": 7622, "substitutes": {"s": ["S", "spec", "session", "b", "sys", "ses", "services", "m", "f", "ns", "ls", "cs", "e", "w", "ops", "gs", "qs", "n", "ctx", "p", "context", "fs", "c", "g", "ssl", "sq", "ps", "js"], "x0": ["f10", "f2", "x2", "X10", "X0", "X2", " x2", "x10", "f0", " x10"], "y0": ["dy00", "dy2", "y00", "dy0", "x2", "Y2", "x00", "Y0", "y2", "Y00"], "log2_size": ["log1_size", "log1_width", "log2logwidth", "log2_depth", "log1_count", "log1_depth", "log2logdepth", "log2_count", "log2_width", "log2logcount", "log2logsize"], "c_idx": ["c_idy", "c_ridv", "c_midv", "c_ridy", "c_ridg", "c_oidv", "c_midy", "c_midg", "c_oidy", "c_oidg", "c_ridx", "c_oidx", "c_idv", "c_idg", "c_midx"], "i": ["gi", "o", "ti", "id", "I", "di", "ci", "ni", "xi", "ri", "si", "slice", "io", "abi", "info", "bi", "m", "in", "qi", "ix", "l", "yi", "pi", "phi", "adi", "iu", "ii", "my", "d", "init", "ai", "e", "uri", "t", "n", "multi", "mi", "ini", "me", "ie", "p", "mini", "z", "eni", "start", "hi", "ip", "g", "api", "li", "anti", "inner", "fi", "index", "sup", "zi", "mu", "ui"], "a": ["as", "area", "na", "alpha", "la", "xa", "pa", "va", "aa", "b", "ad", "ace", "ra", "e", "an", "ar", "da", "ata", "A", "ab", "ba", "p", "span", "sta", "ca", "sa", "ta", "c"]}}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n", "idx": 7649, "substitutes": {"ctx": ["cp", "cmp", "anc", "fw", "ci", "component", "config", "cus", "rc", "cca", "concept", "loc", "px", "cm", "tx", "sk", "client", "conv", "obj", "cc", "ctr", "cs", "cli", "sci", "kt", "conf", "ck", "sc", "cam", "cmd", "wcs", "bc", "cb", "exec", "Context", "cu", "context", "ctrl", "ca", "kb", "c", "ct", "cn", "cf", "tk", "lc", "fc", "cv", "vc", "src", "cas", "conn", "pkg", "xc", "tc"], "tile": ["tool", "cp", "lane", "tf", "layer", "chip", "phy", "rt", "coe", "component", "ci", "qt", "kick", "update", "pixel", "crop", "tto", "race", "slice", "module", "texture", "tu", "grid", "plate", "ace", "px", "tif", "so", "image", "Tile", "sk", "late", "grade", "cli", "ctr", "kt", "uri", "target", "oe", "zip", "file", "plane", "fit", "tm", "cu", "ski", "task", "coll", "context", "ne", "ie", "scale", "ptr", "frame", "oi", "txt", "thread", "tk", "cf", "ilo", "dt", "tt", "cache", "conn", "feature", "tc"], "outlink": ["outstyle", "uplike", "apploop", "outhide", "inlink", "outlinked", "outLink", "outline", "againlink", "upline", "againstyle", "outputstyle", "pointlock", "inLink", "offloop", "libstyle", "outputlink", "outerhide", "instyle", "outerloop", "inlinked", "applink", "outlock", "offlink", "offlinked", "appload", "uppath", "inloop", "pointline", "liblink", "pointLink", " outline", "offload", "outputlike", "inload", "outlike", "againload", "inlock", " outlinked", "libline", "liblinked", "outerload", "outputpath", "applinked", "againloop", " outload", " outlock", "againhide", " outloop", "againpath", "pointlink", "uploop", " outstyle", "againlike", "outloop", "uplink", "upstyle", " outLink", " outhide", "upload", "outerlink", "outload", "outpath"], "out_buf": ["outdbuf", "in_buf", "outFbuf", "outPuf", "out_cache", "outingbuff", " out_bag", "outAcbuff", "out2buffer", "out_buff", "outdbuffer", " out_block", "out_uf", "outfbuf", "outdqueue", " outPbuffer", "out2cb", "outfref", "in_buffer", "outingbuf", "outIPblock", "outFbag", "outFuf", "out2block", "out_ref", "out_queue", "outfqueue", "outAcbuffer", "outPbag", "in_queue", "outingcache", " outPbag", "outIPbuf", "outPbuf", "outIPbuff", "outdbuff", "out_bag", " out_buffer", " out_buff", "outAcbuf", "out_cb", "out_buffer", "outfbuffer", "out2buf", " out_cache", "in_buff", " outPuf", " outPbuf", "outingbuffer", " out_uf", "outPbuffer", "outFbuffer", "out_block", "out2buff", "in_cb", "outfbuff", "outAccache", "in_ref"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = &first_oformat;\n\n\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n\n\n    *p = format;\n\n    format->next = NULL;\n\n}\n", "idx": 7651, "substitutes": {"format": ["writer", "plugin", "option", "method", "parent", "pretty", "pat", "pre", "layout", "op", "data", "style", "edit", "template", "pattern", "ap", "record", "xml", "print", "before", "package", "f", "post", "at", "export", "Format", "document", "operator", "point", "parser", "t", "after", "ant", "fp", "array", "temp", "output", "primary", "attribute", "type", "transform", "api", "model", "pair", "form", "set", "first", "prefix"], "p": ["patch", "cp", "P", "o", "bp", "python", "v", "pr", "a", "parent", "pa", "pat", "pre", "b", "op", "data", "i", "template", "pe", "lp", "ap", "m", "before", "l", "f", "pi", "php", "j", "d", "pc", "q", "np", "u", "part", "e", "point", "parser", "port", "t", "k", "n", "after", "jp", "fp", "c", "g", "tp", "ps"]}}
{"project": "qemu", "commit_id": "d5de7839d78b08c7bd14b03dac0413699b90da67", "target": 1, "func": "static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int op1;\n\n    int32_t r1, r2, r3;\n\n    int32_t address, const16;\n\n    int8_t b, const4;\n\n    int32_t bpos;\n\n    TCGv temp, temp2, temp3;\n\n\n\n    op1 = MASK_OP_MAJOR(ctx->opcode);\n\n\n\n    /* handle JNZ.T opcode only being 7 bit long */\n\n    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {\n\n        op1 = OPCM_32_BRN_JTT;\n\n    }\n\n\n\n    switch (op1) {\n\n/* ABS-format */\n\n    case OPCM_32_ABS_LDW:\n\n        decode_abs_ldw(env, ctx);\n\n\n    case OPCM_32_ABS_LDB:\n\n        decode_abs_ldb(env, ctx);\n\n\n    case OPCM_32_ABS_LDMST_SWAP:\n\n        decode_abs_ldst_swap(env, ctx);\n\n\n    case OPCM_32_ABS_LDST_CONTEXT:\n\n        decode_abs_ldst_context(env, ctx);\n\n\n    case OPCM_32_ABS_STORE:\n\n        decode_abs_store(env, ctx);\n\n\n    case OPCM_32_ABS_STOREB_H:\n\n        decode_abs_storeb_h(env, ctx);\n\n\n    case OPC1_32_ABS_STOREQ:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_LEUW);\n\n\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LD_Q:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUW);\n\n        tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16);\n\n\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LEA:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address));\n\n\n/* ABSB-format */\n\n    case OPC1_32_ABSB_ST_T:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        b = MASK_OP_ABSB_B(ctx->opcode);\n\n        bpos = MASK_OP_ABSB_BPOS(ctx->opcode);\n\n\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_qemu_ld_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos));\n\n        tcg_gen_ori_tl(temp2, temp2, (b << bpos));\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n\n/* B-format */\n\n    case OPC1_32_B_CALL:\n\n    case OPC1_32_B_CALLA:\n\n    case OPC1_32_B_J:\n\n    case OPC1_32_B_JA:\n\n    case OPC1_32_B_JL:\n\n    case OPC1_32_B_JLA:\n\n        address = MASK_OP_B_DISP24(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, 0, 0, 0, address);\n\n\n/* Bit-format */\n\n    case OPCM_32_BIT_ANDACC:\n\n        decode_bit_andacc(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T1:\n\n        decode_bit_logical_t(env, ctx);\n\n\n    case OPCM_32_BIT_INSERT:\n\n        decode_bit_insert(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T2:\n\n        decode_bit_logical_t2(env, ctx);\n\n\n    case OPCM_32_BIT_ORAND:\n\n        decode_bit_orand(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC1:\n\n        decode_bit_sh_logic1(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC2:\n\n        decode_bit_sh_logic2(env, ctx);\n\n\n    /* BO Format */\n\n    case OPCM_32_BO_ADDRMODE_POST_PRE_BASE:\n\n        decode_bo_addrmode_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE:\n\n        decode_bo_addrmode_ld_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ld_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE:\n\n        decode_bo_addrmode_stctx_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ldmst_bitreverse_circular(env, ctx);\n\n\n/* BOL-format */\n\n    case OPC1_32_BOL_LD_A_LONGOFF:\n\n    case OPC1_32_BOL_LD_W_LONGOFF:\n\n    case OPC1_32_BOL_LEA_LONGOFF:\n\n    case OPC1_32_BOL_ST_W_LONGOFF:\n\n    case OPC1_32_BOL_ST_A_LONGOFF:\n\n        decode_bol_opc(env, ctx, op1);\n\n\n/* BRC Format */\n\n    case OPCM_32_BRC_EQ_NEQ:\n\n    case OPCM_32_BRC_GE:\n\n    case OPCM_32_BRC_JLT:\n\n    case OPCM_32_BRC_JNE:\n\n        const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode);\n\n        address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRC_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, const4, address);\n\n\n/* BRN Format */\n\n    case OPCM_32_BRN_JTT:\n\n        address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRN_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, 0, address);\n\n\n/* BRR Format */\n\n    case OPCM_32_BRR_EQ_NEQ:\n\n    case OPCM_32_BRR_ADDR_EQ_NEQ:\n\n    case OPCM_32_BRR_GE:\n\n    case OPCM_32_BRR_JLT:\n\n    case OPCM_32_BRR_JNE:\n\n    case OPCM_32_BRR_JNZ:\n\n    case OPCM_32_BRR_LOOP:\n\n        address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode);\n\n        r2 = MASK_OP_BRR_S2(ctx->opcode);\n\n        r1 = MASK_OP_BRR_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, r2, 0, address);\n\n\n/* RC Format */\n\n    case OPCM_32_RC_LOGICAL_SHIFT:\n\n        decode_rc_logical_shift(env, ctx);\n\n\n    case OPCM_32_RC_ACCUMULATOR:\n\n        decode_rc_accumulator(env, ctx);\n\n\n    case OPCM_32_RC_SERVICEROUTINE:\n\n        decode_rc_serviceroutine(env, ctx);\n\n\n    case OPCM_32_RC_MUL:\n\n        decode_rc_mul(env, ctx);\n\n\n/* RCPW Format */\n\n    case OPCM_32_RCPW_MASK_INSERT:\n\n        decode_rcpw_insert(env, ctx);\n\n\n/* RCRR Format */\n\n    case OPC1_32_RCRR_INSERT:\n\n        r1 = MASK_OP_RCRR_S1(ctx->opcode);\n\n        r2 = MASK_OP_RCRR_S3(ctx->opcode);\n\n        r3 = MASK_OP_RCRR_D(ctx->opcode);\n\n        const16 = MASK_OP_RCRR_CONST4(ctx->opcode);\n\n        temp = tcg_const_i32(const16);\n\n        temp2 = tcg_temp_new(); /* width*/\n\n        temp3 = tcg_temp_new(); /* pos */\n\n\n\n        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);\n\n        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);\n\n\n\n        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp3);\n\n\n/* RCRW Format */\n\n    case OPCM_32_RCRW_MASK_INSERT:\n\n        decode_rcrw_insert(env, ctx);\n\n\n/* RCR Format */\n\n    case OPCM_32_RCR_COND_SELECT:\n\n        decode_rcr_cond_select(env, ctx);\n\n\n    case OPCM_32_RCR_MADD:\n\n        decode_rcr_madd(env, ctx);\n\n\n    case OPCM_32_RCR_MSUB:\n\n        decode_rcr_msub(env, ctx);\n\n\n/* RLC Format */\n\n    case OPC1_32_RLC_ADDI:\n\n    case OPC1_32_RLC_ADDIH:\n\n    case OPC1_32_RLC_ADDIH_A:\n\n    case OPC1_32_RLC_MFCR:\n\n    case OPC1_32_RLC_MOV:\n\n    case OPC1_32_RLC_MOV_64:\n\n    case OPC1_32_RLC_MOV_U:\n\n    case OPC1_32_RLC_MOV_H:\n\n    case OPC1_32_RLC_MOVH_A:\n\n    case OPC1_32_RLC_MTCR:\n\n        decode_rlc_opc(env, ctx, op1);\n\n\n\n\n\n\n    }\n\n}", "idx": 7654, "substitutes": {"env": ["nw", "ea", "kn", "v", "cur", "entry", "scope", "config", "qt", "environment", "inv", "exc", "rc", "enc", "loc", "eu", "buf", "db", "tx", "event", "esi", "iss", "cli", "init", "ev", "np", "vs", "impl", "priv", "que", "en", "inst", "cb", "err", "loader", "enh", "context", "ec", "req", "eni", "viron", "erv", "c", "txt", "cf", "chev", "cv", "vc", "fi", "src", "cdn", "conn", "pkg"], "ctx": ["ci", "conf", "cor", "history", "wcs", "bc", "exec", "fp", "Context", "cu", " context", "ca", "lc", "git", "cas", "cm", "ctrl", "conn", "tc", "cp", "kn", "fw", "config", "nc", "concept", "sc", "jp", "txt", "cn", "cf", "handler", "sq", "util", "hw", "cases", "rc", "sync", "cca", "exc", "loc", "cl", "conv", "obj", "pc", "cli", "sci", "cs", "cc", "np", "ce", "ck", "cmd", "c", "vc", " cx", "cmp", "ch", "anc", "cfg", "wx", "scope", "sys", "tx", "event", "client", "linux", "rx", "cb", "context", "kw", "qa", "kb", "utils", "cv", "ha", "pkg", "xc"], "op1": ["mod3", "optOne", "copone", "ops2", "op0", "opt3", "comp01", "opt81", "oper1", "oct1", "OP0", "opt2", "oct01", "cop1", "opt1", "ipOne", "oper01", "OP2", " op01", "opone", "op2", "copn", "ops0", "operone", "ip01", " op81", "octone", "opOne", "octn", " opOne", "opt8", "operOne", "OP1", "ops1", " opone", "op3", "mod2", "mod8", "comp1", "mod1", "oper81", " op2", "op8", "op81", "compOne", "cop01", "opsone", "opern", " op0", "ip1", "opn", "op01", "OPone", " op3", " op8"], "r1": ["sr8", "p2", "rr2", " r5", "R2", "p8", "rr5", "r8", "R3", "r5", "R8", "R1", "p1", "rr3", "sr2", "R5", "sr3", "sr1", "rr1"], "r2": ["r4", "p4", "R02", "p02", "R2", "r02", "R1", "R4", "p1", " r02", "p2", " r4"], "r3": ["r4", " r15", " r03", "r03", "rar15", "R4", "R03", "rar4", "r15", " r4", "rar03", "rar3", "R15", "R3"], "address": ["base", "cp", "r", "layer", "position", "header", "block", "ACE", "ress", "shape", "device", "channel", "config", "balance", "Address", "password", "x", "i", "repeat", "m", "map", "ace", "route", "image", "resource", "capacity", "argument", "offset", "order", "grade", "state", "length", "ai", "service", "byte", "tc", "number", "code", "interface", "uri", "target", " Address", "error", "message", "port", "dc", "path", "source", "array", "output", "h", "network", "ptr", "pointer", "attribute", "ip", "slave", "location", "type", "contract", "pair", "element", "activity", "index", "addr", "host", "reference", "account", "cm", "mode", "size"], "const16": ["const33", "const18", "float33", "esc18", "esc33", "float16", " const18", " const33", "const32", "esc32", "float18", "esc16", "float32", " const32"], "b": ["base", "lb", "ib", "v", "bd", "a", "bm", "bi", "buf", "wb", "f", "bb", "xb", "sb", "k", "n", "cb", "B", "nb", "ba", "p", "mb", "be", "h", "c", "bf", "br", "bl", "r"], "const4": ["contract40", " const8", "const8", "const40", " const10", "const10", "contract10", "con8", " const40", "contract8", "con10", "con40", "con4", "contract4"], "bpos": ["lbval", "bbindex", "blpos", "lbindex", "bbcol", "bbval", "blval", "lbpos", "blindex", "bcol", "blcol", "bbpos", "bval", "bindex", "lbcol"], "temp": ["base", "cp", "stable", "iter", "mem", "store", "v", "local", "wrapper", "session", "config", "tmp", "get", "tem", "ex", "data", "style", "now", "template", "flat", "pt", "loc", "fake", "wait", "buffer", "col", "bag", "zip", "tm", "wrap", "timeout", "empty", "result", "context", "input", "output", "emp", "mini", "pointer", "txt", "wl", "lc", "model", "comb", "adj", "cache", "test", "form", "current", "seed", "ctrl", "Temp", "cel", "tc"], "temp2": ["Temp1", "result1", "resultTwo", "wrap5", "Temp4", "fake2", "tem1", " temp1", " temp5", "tempTwo", "buff3", "tem2", "Temp2", "Temp3", " tempTwo", "buff2", "wrap1", " temp4", "temp4", "TempTwo", "fake1", "tem200", "fakeTwo", "result4", "temp5", "result2", "buff1", "Temp5", "temp200", "wrap4", "tem4", "Temp200", "temp1", " temp200", "wrap2"], "temp3": ["current3", "tem23", "tem6", "temp1", "current23", " temp23", " temp6", "tem3", "current1", "temp6", "temp23", "current6", "tem1", " temp1"]}}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n", "idx": 7659, "substitutes": {"frame": ["game", "base", "scene", "flow", "fr", "row", "build", "feed", "position", "el", "component", "flower", "config", "layout", "update", "object", "iframe", "data", "slice", "style", "module", "za", "image", "Frame", "draw", "window", "fb", "live", "rame", "state", "series", "fe", "property", "buffer", "e", "point", "part", "file", "fram", "motion", "view", "plane", "feat", "framework", "filename", "coll", "parse", "scale", "ground", "line", "filter", "node", "setup", "video", "model", "frames", "figure", "cf", "element", "panel", "feature"], "perms": ["PERmissions", " perm", "percs", "arm", " permm", "arms", "Perm", "arps", " perps", "perm", " percs", "Perps", "perfs", "Percs", "Perms", "perps", " perfs", "arfs", "Permm", " permissions", "permm", "Permissions", "PERcs", "PERms", "PERmm", "Perfs", "permissions"], "picref": ["fcref", "picurl", "icRef", "lcRef", "fcurl", " picbf", "icreference", "picval", " picurl", "lcreference", "picreference", "fcval", "icurl", "pcref", "fcbf", "picRef", "camref", "fcdef", "fcreference", "cambf", "pcreference", "icref", "icdef", "picdef", " picval", " picdef", "lcval", " picreference", "camRef", " picRef", "fcRef", "picbf", "pcRef", "pcdef", "lcref", "camreference"]}}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n", "idx": 7662, "substitutes": {"ptr": ["cp", "address", "cmp", "dr", "cur", "parent", "shape", "ci", "tmp", "pre", "tr", "i", "inter", "slice", "loc", "tty", "offset", "mp", "ext", "attr", "call", "length", "pc", "py", "ffff", "ctr", "push", "code", "buffer", "priv", "sh", "len", "inst", "point", "esc", "err", "bc", "p", "Ptr", "uint", "temp", "req", "xt", "alloc", "pointer", "transfer", "pos", "c", "type", "br", "ref", "addr", "src", "dim", "shift"], "size": ["address", "name", "SIZE", "large", "sec", "fee", "shape", "last", "now", "si", "sn", "sync", "adjust", "loc", "capacity", "offset", "call", "length", "args", "small", "Size", "fe", "cs", "six", "code", "len", "here", "esc", "sized", "n", "empty", "self", "p", "scale", "z", "zero", "pointer", "c", "new", "type", "ize", "shift"], "old_size": [" old_ize", "old_ptr", "old_ize", "old_scale", "old_capacity", " old_ptr", " old_width", " old_capacity", "old_length", " old_scale", "old_width", " old_length", "old_address", " old_address"], "copy": ["replace", "cp", "cmp", "parent", "skip", "use", "repeat", "slice", "ignore", "sync", "co", "pe", "delete", "rc", "i", "opy", "null", "like", "offset", "call", "create", "py", "ce", "code", "ck", "buffer", "hide", "oe", "Copy", "empty", "coll", "scale", "clip", "lex", "transfer", "pos", "ge", "clone", "cap", "new", "write", "type", "core", "move", "test", "ize", "min", "cop", "shift", "le"], "new_ptr": ["new_length", "old_ptr", "new_alloc", "new_size", " new_pointer", " new_addr", " new_size", "new_handle", " new_alloc", "new__addr", "new_pointer", "old_addr", "old_length", "new_addr", "new__size", "new__ptr", " new_handle", "new__pointer", "old_pointer"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n", "idx": 7666, "substitutes": {"o": ["ot", "ocol", "ko", "options", "od", "s", "po", "ob", "op", "io", "ow", "OC", "oa", "or", "O", "m", "so", "f", "d", "og", "e", "oco", "ops", "t", "k", "n", "p", "ou", "oper", "oi", "os", "c", "oo", "oci", "oid", "r"], "oc": ["osc", "ocol", "ocr", "anc", "unc", "irc", "roc", "mic", "ci", "config", "op", "rc", "OC", "enc", "co", "ocl", "uc", "loc", "inc", "ict", "soc", "org", "pc", "cc", "oca", "mc", "oco", "dc", "bc", "cu", "voc", "ic", "ec", "ogg", "iv", "toc", "oper", "c", "os", "ct", "oci", "oid", "lc", "asc", "fc", "ac", "cot", "isc"], "st": ["std", "osc", "est", "ste", "cr", "od", "store", "sw", "ob", "et", "sn", "stream", "ust", "art", "stack", "pt", "uc", "loc", "sts", "cl", "rest", "sl", "St", "fe", "ss", "kt", "stop", "sc", "sth", "sb", "ist", "inst", "storage", "sign", "ST", "str", "sta", "stage", "ut", "ft", "ptr", "sp", "start", "step", "ld", "os", "c", "ct", "put", "src", "ast", "nd", "stim"], "ost": ["ot", "osc", "ocol", "ocr", "est", "od", "om", "nt", "omp", "sw", "osi", "tmp", "ob", "op", "object", "pod", "tto", "or", "ust", "art", "oh", "stream", "rog", "so", "ott", "rest", "OST", "post", "oop", "org", "oster", "osta", "bb", "fe", "rost", "ood", "sth", "ist", "inst", "ado", "oss", "\u00f3", "iol", "sta", "opt", "pos", "oper", "ld", "os", "oid", "ort", "tt", "src", "host", "ast", "omm"], "audio_enc": ["audio_sys", "video_enz", "audio_inc", "picture_rec", "audio_enz", "audio__enc", "audioappenc", "audio__eng", "audio_config", "audioaccoll", "audioappdec", "audio__rec", "audio_rec", "audioacsys", "video_sys", "picture_anc", "video_rec", "video_anc", "video_enc", "audioappec", "audio__ec", "picture_enc", "audio_ec", "video_coll", "media_enc", "audio__conn", "audio_dec", "video_dec", "audio_coll", "video_ec", "picture_config", "media_inc", "media_ec", "media_eng", "audio_conn", "video_conn", "audioappenz", "audio_eng", "audioacec", "audio_anc", "audioacenc", "audio__inc"], "sample_fmt": ["sample_sfrt", "sample_pmt", "sample_Fnt", "sample_Farm", "sample_Ftm", "sample_rfma", "sample_rfformat", "sample64fmnd", "sample_fformat", "sample_cfmt", "sample_formct", "sample_frt", "sample_ptm", "sample_rfMT", "sample_farm", "sample_formt", "sample_pld", "sample_forformat", "sample_sfct", "sample_sfMT", "sample_FMT", "sample_fmm", "sample_fmMT", "sample_gmt", "sample_garm", "sample_cfm", "sample64fmmd", "sample_vmt", "sample_fct", "sample_vct", "sample64fmformat", "sample_dmt", "sample_vnt", "sample_fnt", "sample64fformat", "sample_dformat", "sample64fnd", "sample64fmd", "sample_fmma", "sample_varm", "sample_fMT", "sample_forarm", "sample_rfmd", "sample64fmt", "sample_gnt", "sample_pformat", "sample_fxmt", "sample_form", "sample64fmmt", "sample_Fmt", "sample_formMT", "sample_dnd", "sample_fxld", "sample_fma", "sample_cfarm", "sample_ftm", "sample_gMT", "sample_fxformat", "sample_fnd", "sample_vrt", "sample_sfmt", "sample_cfformat", "sample_Fformat", "sample_formmt", "sample_fmmt", "sample_Fld", "sample_fmformat", "sample_formrt", "sample_fxtm", "sample_fld", "sample_rfmt", "sample_rfnd", "sample_fmmd", "sample_formma", "sample_fmnd", "sample_formformat", "sample_fmarm", "sample_fmd", "sample_vMT", "sample_fm", "sample_dmd"]}}
{"project": "FFmpeg", "commit_id": "221402c1c88b9d12130c6f5834029b535ee0e0c5", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    AVFrame *const p   = data;\n    int compressed, xmin, ymin, xmax, ymax;\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n                 bytes_per_scanline;\n    uint8_t *ptr;\n    const uint8_t *buf_end = buf + buf_size;\n    const uint8_t *bufstart = buf;\n    uint8_t *scanline;\n    int ret = -1;\n    if (buf[0] != 0x0a || buf[1] > 5) {\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n    compressed = buf[2];\n    xmin       = AV_RL16(buf + 4);\n    ymin       = AV_RL16(buf + 6);\n    xmax       = AV_RL16(buf + 8);\n    ymax       = AV_RL16(buf + 10);\n    if (xmax < xmin || ymax < ymin) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n    w = xmax - xmin + 1;\n    h = ymax - ymin + 1;\n    bits_per_pixel     = buf[3];\n    bytes_per_line     = AV_RL16(buf + 66);\n    nplanes            = buf[65];\n    bytes_per_scanline = nplanes * bytes_per_line;\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||\n        (!compressed && bytes_per_scanline > buf_size / h)) {\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n    switch ((nplanes << 8) + bits_per_pixel) {\n    case 0x0308:\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 0x0108:\n    case 0x0104:\n    case 0x0102:\n    case 0x0101:\n    case 0x0401:\n    case 0x0301:\n    case 0x0201:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n    buf += 128;\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!scanline)\n        return AVERROR(ENOMEM);\n    if (nplanes == 3 && bits_per_pixel == 8) {\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                ptr[3 * x]     = scanline[x];\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n            ptr += stride;\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n        const uint8_t *palstart = bufstart + buf_size - 769;\n        if (buf_size < 769) {\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n        for (y = 0; y < h; y++, ptr += stride) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            memcpy(ptr, scanline, w);\n        if (buf != palstart) {\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n            buf = palstart;\n        if (*buf++ != 12) {\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n        GetBitContext s;\n        for (y = 0; y < h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n    } else {    /* planar, 4, 8 or 16 colors */\n        int i;\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                int m = 0x80 >> (x & 7), v = 0;\n                for (i = nplanes - 1; i >= 0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n                ptr[x] = v;\n            ptr += stride;\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart + 16;\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n    *got_frame = 1;\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;", "idx": 7670, "substitutes": {"avctx": [" avcontext", "AVqa", "avalctrl", "avctl", "afctrl", "airctx", "averctl", "AVlc", "aflc", "avercontext", "avalcontext", "afctl", "vercontext", "AVctx", "navcmp", "afcmp", "AVcontext", "averctx", "avcmp", "avcca", "navcontext", "vercp", "verqa", "afctx", "AVctrl", "AVctl", "airctl", "avcontext", "avalctx", "afcp", "avcp", "avqa", "AVcmp", "verctx", " avctl", "aircontext", "AVcca", "averconn", "AVcp", "avlc", "afcontext", " avconn", "navctx", "navcca", "afcca", "avctrl", "avallc", "aircmp", "afqa", "AVconn", "avconn"], "data": ["base", "buff", "bin", "block", "open", "a", "parent", "dat", "value", "config", "tmp", "val", "database", "stream", "queue", "body", "image", "map", "ad", "window", "content", "f", "media", "d", "DATA", "buffer", "da", "raw", "Data", "pad", "bytes", "load", "result", "array", "input", "reader", "batch", "frame", "start", "pos", "memory", "proc", "write", "read", "video", "sample", "cache", "next", "size"], "got_frame": ["av_frame", "av_block", "avroimage", "av_image", "avrorange", "av_range", "af_block", "avroblock", "af_frame", "avroframe", "af_range", "af_image"], "avpkt": ["avfacket", " avpct", "avfft", "avfkt", "affkg", "avpacket", " avppkt", "afpft", "avppkg", "avppeth", " avpeth", "afpct", "avpft", " avppeth", "avPkt", "avPct", "avPeth", "avpct", "avcpeth", "affkt", "avppkt", "avcpacket", "avckg", "avppct", "afpkt", "avckt", "avcpkt", "afpkg", "avpeth", "avcpct", " avppkg", "afpacket", "avcft", " avppct", "avPkg", "avpkg", " avpkg", "avcct", "avcpkg", "affct", "avfct", "avPacket", "avcpft", "affacket", "avfkg", "avcacket", "affft"], "buf": ["rb", "b", "dest", "queue", "uc", "buffer", "bag", "func", "nat", "bc", "fp", "ab", "pool", "proc", "pb", "cas", "img", "fam", "header", "cur", "config", "plug", "fb", "uf", "ru", "port", "ctx", "pad", "pub", "batch", "usr", "wav", "cap", "cf", "text", "brace", "bp", "vec", "block", "box", "tmp", "rc", "home", "exc", "cat", "grab", "loc", "wb", "num", "conv", "Buffer", "cmd", "feat", "coord", "begin", "prop", "fd", "aux", "src", "chrom", "buff", "uber", "aka", "Buff", "uv", "window", "bu", "cb", "seq", "context", "uint", "alloc", "br", "utf", "cv", "pkg"], "p": ["P", "o", "v", "a", "b", "m", "pt", "l", "f", "d", "pc", "q", "py", "u", "e", "file", "port", "t", "n", "fp", "array", "c", "g", "r", "ps"], "compressed": ["suppressor", "expression", " uncompressed", " uncompacted", "compoded", "recoded", "compression", "extoded", "suppiled", " compiled", "expressor", "Compress", "express", "suppression", "suppress", "Compression", "recressed", "reciled", "compacted", "extression", "compress", "compressor", "Compressor", " uncompiled", "compiled", " uncompression", "extiled", " decompacted", " decompressed", "expressed", "suppoded", " decompiled", "extressed", "recression", " compacted", " decompression", "suppressed", " compression", "Compressed"], "xmin": ["wmed", "xMin", "aymin", "xstart", "xxmin", "aymax", "yinit", " xmini", "ayinit", "Xmax", "xinit", "yMin", " xin", "xin", "ixmin", "wmin", "yskip", "winit", "ymini", "wmax", "aymed", "ymed", "Xin", "XMin", "xskip", "ixmax", "xxstart", "Xstart", " xMin", "xmed", "Xmin", " xstart", "Xmini", "xmini", "xxmax", "Xskip", "xxin", "ixskip"], "ymin": [" ystep", "xMin", "wpri", " ymini", "ypri", "YMin", "ypos", "sypos", "Ymax", "xpri", "zymax", "xstep", "wmin", "yMin", "zymin", "yskip", "yversion", "y1", "ymini", "Ymin", "wmax", "symin", " y1", " ypos", "x1", "xskip", " ypri", " yversion", " yskip", "sy1", "Ystep", "ystep", "xversion", "wversion", "zymini", "zyskip", "symax", "xpos", "xmini", " yMin"], "xmax": ["wend", "axend", "rxmax", "rxMAX", "rxmin", " xMAX", "rxend", "yend", "Xmax", "wmin", "xMAX", "yMax", "Xlast", " xlast", "axax", " xmed", "axmax", "lexmax", "lexmin", "ymed", "wmax", "axmin", "xlast", "Xax", "lexmed", "xax", "lexMax", " xMax", " xend", "yMAX", "xmed", "Xend", "xend", "Xmin", "xMax", " xax", "wlast"], "ymax": ["ammax", "yanmax", "pmass", "ymmaxy", "ypax", "yahax", "symoe", "ymazon", "ymmmax", "ymension", "ammake", "ammame", "ymail", "ymass", "symak", "yrak", "ymmame", "ypaxy", "yahazon", "symazon", "ymmail", "yanax", "tmoe", "symake", "ymak", "ymmak", "ymoe", "yahoe", "ammaxy", "ymake", "yanension", "ypame", "ymmension", "yrax", "yahak", "ymame", "pmmax", "ymaxy", "ymmake", "ymmass", "yrake", "tmazon", "symax", "symail", "yanass", "ypake", "yrail", "tmak", "ymmax", "pmax", "pmension", "tmax"], "w": ["hw", "v", "fw", "W", "wx", "wave", "sw", "wn", "b", "ow", "wp", "wa", "wt", "m", " W", "l", "window", "wh", "f", "d", "weight", "q", "u", "wd", "we", "n", "win", "work", "kw", "wal", "z", "c", "g", "r", "max", "end"], "h": ["H", "o", "ch", "hw", "v", "ih", "b", "dh", "m", "th", "l", "rh", "f", "d", "j", "q", "hs", "ph", "u", "e", "sh", "hm", "t", "hh", "n", "height", "z", "ht", "c", "hi", "g", "gh", "ul", "ha", "r", "max", "shift"], "bits_per_pixel": ["bits_per\u00b7channel", "bits_per_second", "bits_per_channel", "bits_per_byte", "bits_per\u00b7nice", "bits_per_character", "bits_per_line", "bits_per_bit", "bits_per\u00b7pixel", "bits_per_nice"], "bytes_per_line": ["bytes_per_lin", "bytes_perjlin", "bytes_per_byte", "bytes_per24line", "bytes_per_pixel", "bytes_per24slice", "bytes_perjpixel", "bytes_perjline", "bytes_perjword", "bytes_per24lines", "bytes_per_word", "bytes_per_cell", "bytes_per_slice", "bytes_per24pixel", "bytes_per_lines"], "nplanes": ["numplanes", "dlines", "nliners", "Nplanes", " nflows", "nbbands", " nliners", "numrows", " nrows", "numframes", "nbands", " nbands", "nrows", "nflows", "dplanes", "Nbands", " nlines", "nbframes", "numlines", "Nrows", "nblines", "dbands", "Nframes", "nbpages", " npages", "nframes", "nlines", "Nlines", "numbands", "dframes", "Npages", "nbliners", "numflows", "nbplanes", "nbflows", "Nliners", "numpages", " nframes", "npages", "numliners"], "stride": ["tride", "arrision", "trides", "slider", "strides", "arrider", "trider", "strision", "slision", "slides", "arride", "trision", "strider", "slide", "arrides"], "y": ["yy", "dy", "padding", "Y", "yt", "b", "cy", "m", "l", "f", "d", "t", "n", "height", "lon", "vy", "ey", "z", "start", "pos", "c", "type", "min"], "x": ["time", "v", "b", "ex", "image", "l", "f", "d", "weight", "t", "n", "win", "height", "z", "step", "c", "g", "xx", "X", "index", "max", "xc"], "bytes_per_scanline": ["bytes_per_binner", "bytes_per_canner", "bytes_per_winline", "bytes_per_readment", "bytes_per_scanl", "bytes_per_binlin", "bytes_per_pixelment", "bytes_per_scancase", "bytes_per_readlin", "bytes_per_pixell", "bytes_per_Scanner", "bytes_per_verner", "bytes_per_canl", "bytes_per_scanner", "bytes_per_pixelline", "bytes_per_verlines", "bytes_per_binment", "bytes_per_pixelcase", "bytes_per_verline", "bytes_per_readner", "bytes_per_cancase", "bytes_per_pixelner", "bytes_per_pixelband", "bytes_per_imagement", "bytes_per_imageband", "bytes_per_Scanl", "bytes_per_scanment", "bytes_per_imagel", "bytes_per_scanband", "bytes_per_scanlin", "bytes_per_verl", "bytes_per_canline", "bytes_per_Scancase", "bytes_per_imageline", "bytes_per_winment", "bytes_per_pixellin", "bytes_per_Scanline", "bytes_per_winl", "bytes_per_scanlines", "bytes_per_binline", "bytes_per_readline", "bytes_per_winband", "bytes_per_pixellines"], "ptr": ["dr", "rw", "buff", "vec", "bd", "tmp", "tr", "xp", "pt", "loc", "fl", "obj", "fe", "ctr", "code", "port", "seq", "pty", "alloc", "pointer", "proc", "fd", "br", "fi", "addr", "src", "trace", "ff"], "buf_end": ["buf__ad", "buf__end", "buf__start", "buffer_len", "buf_len", "buffer_end", "buf_ad", "buffer_start", "buffer_ad", "buf_start", "buf__len"], "bufstart": ["cvpos", "ufstart", "bufid", "ufpos", "buffstart", "buffrom", "cvstart", "cvid", "cvfrom", "bufpos", "buffid", "uffrom", "buffpos", "ufid", "bufffrom"], "scanline": ["readcode", "synpos", "readpos", "readline", "scancode", "scanpos", "macline", "macpos", "synframe", "scanframe", "maccode", "syncode", "readframe", "synline", "macframe"]}}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIQXLDevice *d = opaque;\n\n    uint32_t io_port = addr - d->io_base;\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_RESET:\n\n    case QXL_IO_SET_MODE:\n\n    case QXL_IO_MEMSLOT_ADD:\n\n    case QXL_IO_MEMSLOT_DEL:\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        break;\n\n    default:\n\n        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)\n\n            break;\n\n        dprint(d, 1, \"%s: unexpected port 0x%x in vga mode\\n\", __FUNCTION__, io_port);\n\n        return;\n\n    }\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_UPDATE_AREA:\n\n    {\n\n        QXLRect update = d->ram->update_area;\n\n        qemu_mutex_unlock_iothread();\n\n        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,\n\n                                   &update, NULL, 0, 0);\n\n        qemu_mutex_lock_iothread();\n\n        break;\n\n    }\n\n    case QXL_IO_NOTIFY_CMD:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_NOTIFY_CURSOR:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_UPDATE_IRQ:\n\n        qxl_set_irq(d);\n\n        break;\n\n    case QXL_IO_NOTIFY_OOM:\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        pthread_yield();\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        d->oom_running = 1;\n\n        d->ssd.worker->oom(d->ssd.worker);\n\n        d->oom_running = 0;\n\n        break;\n\n    case QXL_IO_SET_MODE:\n\n        dprint(d, 1, \"QXL_SET_MODE %d\\n\", val);\n\n        qxl_set_mode(d, val, 0);\n\n        break;\n\n    case QXL_IO_LOG:\n\n        if (d->guestdebug) {\n\n            fprintf(stderr, \"qxl/guest: %s\", d->ram->log_buf);\n\n        }\n\n        break;\n\n    case QXL_IO_RESET:\n\n        dprint(d, 1, \"QXL_IO_RESET\\n\");\n\n        qxl_hard_reset(d, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_ADD:\n\n        PANIC_ON(val >= NUM_MEMSLOTS);\n\n        PANIC_ON(d->guest_slots[val].active);\n\n        d->guest_slots[val].slot = d->ram->mem_slot;\n\n        qxl_add_memslot(d, val, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_DEL:\n\n        qxl_del_memslot(d, val);\n\n        break;\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_CREATE_PRIMARY\\n\");\n\n        d->guest_primary.surface = d->ram->create_surface;\n\n        qxl_create_guest_primary(d, 0);\n\n        break;\n\n    case QXL_IO_DESTROY_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_DESTROY_PRIMARY\\n\");\n\n        qxl_destroy_primary(d);\n\n        break;\n\n    case QXL_IO_DESTROY_SURFACE_WAIT:\n\n        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);\n\n        break;\n\n    case QXL_IO_DESTROY_ALL_SURFACES:\n\n        d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", __FUNCTION__, io_port);\n\n        abort();\n\n    }\n\n}\n", "idx": 7696, "substitutes": {"opaque": ["Opec", "OPac", "opacs", "osponymous", "Oponymous", "ospacs", "Opacs", "OPonymous", "oponymous", "OPec", "Opaque", "operonymous", "ospacity", "ospaque", "operec", "operac", "operaque", "OPaque", "opac", "opec", "Opacity", "operacs", "Opac", "operacity", "opacity"], "addr": ["address", "dr", "host", "ea", "od", "rt", "eth", "dd", "device", "config", "lan", "data", "oa", "xp", "rc", "ad", "ace", "ix", "offset", "add", "align", "ar", "da", "xd", "pad", "coord", "p", "sta", "ptr", "pos", "pointer", "alloc", "node", "cap", "ip", "amd", "adr", "ord", "ref", "src", "conn", "prefix"], "val": ["ret", "reg", "v", "al", "mem", "alt", "value", "rot", "x", "data", "expr", "bit", "unit", "valid", "vals", "num", "mac", "key", "VAL", "arg", "res", "def", "buffer", "len", "arr", "func", "rx", "nil", "exec", "eval", "opt", "sel", "ref", "grad", "dim", "slot"], "d": ["D", "std", "plugin", "dr", "o", "dim", "del", "od", "id", "md", "bd", "vd", "dn", "di", "done", "dat", "dd", "s", "dos", "b", "dh", "data", "pd", "rd", "i", "sync", "ad", "module", "m", "dad", "db", "l", "draw", "de", "f", "mad", "j", "td", "u", "dom", "wd", "e", "die", "da", "ds", "dc", "t", "sd", "n", "xd", "k", "cmd", "p", "did", "h", "z", "ld", "c", "du", "g", "ind", "fd", "dj", "dt", "dl", "gd", "ud", "y", "nd", "cd", "dict"]}}
{"project": "FFmpeg", "commit_id": "4cec43a9eeb58eb9e581a2d9d25f78e5bfbb0960", "target": 0, "func": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    unsigned int first_mb_in_slice;\n\n    unsigned int pps_id;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int last_pic_structure, last_pic_droppable;\n\n    int needs_reinit = 0;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    first_mb_in_slice = get_ue_golomb(&sl->gb);\n\n\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, first_mb_in_slice);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (h->nal_unit_type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    pps_id = get_ue_golomb(&sl->gb);\n\n    if (pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;\n\n    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!h->ps.sps_list[h->ps.pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\",\n\n               h->ps.pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {\n\n        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;\n\n\n\n        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||\n\n            h->chroma_format_idc != h->ps.sps->chroma_format_idc)\n\n            needs_reinit         = 1;\n\n    }\n\n\n\n    pps = h->ps.pps;\n\n    sps = h->ps.sps;\n\n\n\n    if (!h->setup_finished) {\n\n        h->avctx->profile = ff_h264_get_profile(sps);\n\n        h->avctx->level   = sps->level_idc;\n\n        h->avctx->refs    = sps->ref_frame_count;\n\n\n\n        if (h->mb_width  != sps->mb_width ||\n\n            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))\n\n            needs_reinit = 1;\n\n\n\n        h->mb_width  = sps->mb_width;\n\n        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);\n\n        h->mb_num    = h->mb_width * h->mb_height;\n\n        h->mb_stride = h->mb_width + 1;\n\n\n\n        h->b_stride = h->mb_width * 4;\n\n\n\n        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p\n\n\n\n        h->width  = 16 * h->mb_width;\n\n        h->height = 16 * h->mb_height;\n\n\n\n        ret = init_dimensions(h);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (sps->video_signal_type_present_flag) {\n\n            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG\n\n                : AVCOL_RANGE_MPEG;\n\n            if (sps->colour_description_present_flag) {\n\n                if (h->avctx->colorspace != sps->colorspace)\n\n                    needs_reinit = 1;\n\n                h->avctx->color_primaries = sps->color_primaries;\n\n                h->avctx->color_trc       = sps->color_trc;\n\n                h->avctx->colorspace      = sps->colorspace;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (h->context_initialized && needs_reinit) {\n\n        h->context_initialized = 0;\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"changing width %d -> %d / height %d -> %d on \"\n\n                   \"slice %d\\n\",\n\n                   h->width, h->avctx->coded_width,\n\n                   h->height, h->avctx->coded_height,\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        ff_h264_flush_change(h);\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n\n               \"pix_fmt: %d\\n\", h->width, h->height, h->avctx->pix_fmt);\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    if (!h->context_initialized) {\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    last_pic_structure = h->picture_structure;\n\n    last_pic_droppable = h->droppable;\n\n\n\n    droppable = h->nal_ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->droppable         = droppable;\n\n        h->picture_structure = picture_structure;\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (last_pic_structure != picture_structure ||\n\n            last_pic_droppable != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   last_pic_structure, h->picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        /* Shorten frame num gaps so we don't have to allocate reference\n\n         * frames just to throw them away */\n\n        if (h->poc.frame_num != h->poc.prev_frame_num) {\n\n            int unwrap_prev_frame_num = h->poc.prev_frame_num;\n\n            int max_frame_num         = 1 << sps->log2_max_frame_num;\n\n\n\n            if (unwrap_prev_frame_num > h->poc.frame_num)\n\n                unwrap_prev_frame_num -= max_frame_num;\n\n\n\n            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {\n\n                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;\n\n                if (unwrap_prev_frame_num < 0)\n\n                    unwrap_prev_frame_num += max_frame_num;\n\n\n\n                h->poc.prev_frame_num = unwrap_prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * Here, we're using that to see if we should mark previously\n\n         * decode frames as \"finished\".\n\n         * We have to do that before the \"dummy\" in-between frame allocation,\n\n         * since that can modify s->current_picture_ptr. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                              last_pic_structure == PICT_TOP_FIELD);\n\n                }\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and previous field were reference, but had\n\n                     * different frame_nums. Consider this field first in\n\n                     * pair. Throw away previous field except for reference\n\n                     * purposes. */\n\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                                  last_pic_structure == PICT_TOP_FIELD);\n\n                    }\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n\n                           h->picture_structure == PICT_TOP_FIELD))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"Invalid field mode combination %d/%d\\n\",\n\n                               last_pic_structure, h->picture_structure);\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_INVALIDDATA;\n\n                    } else if (last_pic_droppable != h->droppable) {\n\n                        avpriv_request_sample(h->avctx,\n\n                                              \"Found reference and non-reference fields in the same frame, which\");\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_PATCHWELCOME;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        while (h->poc.frame_num != h->poc.prev_frame_num &&\n\n               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {\n\n            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n\n                   h->poc.frame_num, h->poc.prev_frame_num);\n\n            ret = initialize_cur_frame(h);\n\n            if (ret < 0) {\n\n                h->first_field = 0;\n\n                return ret;\n\n            }\n\n\n\n            h->poc.prev_frame_num++;\n\n            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;\n\n            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            /* Error concealment: If a ref is missing, copy the previous ref\n\n             * in its place.\n\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n\n             * many assumptions about there being no actual duplicates.\n\n             * FIXME: This does not copy padding for out-of-frame motion\n\n             * vectors.  Given we are concealing a lost frame, this probably\n\n             * is not noticeable by comparison, but it should be fixed. */\n\n            if (h->short_ref_count) {\n\n                if (prev &&\n\n                    h->short_ref[0]->f->width == prev->f->width &&\n\n                    h->short_ref[0]->f->height == prev->f->height &&\n\n                    h->short_ref[0]->f->format == prev->f->format) {\n\n                    av_image_copy(h->short_ref[0]->f->data,\n\n                                  h->short_ref[0]->f->linesize,\n\n                                  (const uint8_t **)prev->f->data,\n\n                                  prev->f->linesize,\n\n                                  prev->f->format,\n\n                                  h->mb_width  * 16,\n\n                                  h->mb_height * 16);\n\n                    h->short_ref[0]->poc = prev->poc + 2;\n\n                }\n\n                h->short_ref[0]->frame_num = h->poc.prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * We're using that to see whether to continue decoding in that\n\n         * frame, or to allocate a new one. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                h->cur_pic_ptr = NULL;\n\n                h->first_field = FIELD_PICTURE(h);\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and the previous field had different frame_nums.\n\n                     * Consider this field first in pair. Throw away previous\n\n                     * one except for reference purposes. */\n\n                    h->first_field = 1;\n\n                    h->cur_pic_ptr = NULL;\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    h->first_field = 0;\n\n                }\n\n            }\n\n        } else {\n\n            /* Frame or first field in a potentially complementary pair */\n\n            h->first_field = FIELD_PICTURE(h);\n\n        }\n\n\n\n        if (!FIELD_PICTURE(h) || h->first_field) {\n\n            if (h264_frame_start(h) < 0) {\n\n                h->first_field = 0;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            release_unused_pictures(h, 0);\n\n        }\n\n    }\n\n\n\n    assert(h->mb_num == h->mb_width * h->mb_height);\n\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n\n        first_mb_in_slice >= h->mb_num) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;\n\n    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<\n\n                                 FIELD_OR_MBAFF_PICTURE(h);\n\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n\n        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;\n\n    assert(sl->mb_y < h->mb_height);\n\n\n\n    if (h->picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); /* idr_pic_id */\n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (!h->setup_finished)\n\n        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,\n\n                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  h->picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n\n    // further down the line. This may break decoding if the first slice is\n\n    // corrupt, thus we only do this if frame-mt is enabled.\n\n    if (h->nal_ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,\n\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                                             h->current_slice == 0);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7716, "substitutes": {"h": ["H", "FH", "hp", "ah", "hw", "ch", "header", "v", "http", "ih", "s", "b", "hhh", "home", "ssh", "oh", "uh", "m", "image", "hel", "l", "rh", "html", "f", "j", "q", "hs", "ph", "u", "e", "sh", "hm", "w", "adh", "en", "t", "hh", "hl", "ctx", "he", "n", "k", "hist", "zh", "eh", "work", "p", "self", "this", "history", "ht", "c", "gh", "g", "hi", "hr", "hash", "ha", "host", "img", "bh", "hd"], "sl": ["fr", "ml", "serv", "sf", "el", "al", "la", "spec", "s", "sw", "ell", "val", "si", "sn", "slice", "ll", "loc", "isl", "l", "cl", "sk", "SL", "tl", "sil", "fl", "ls", "sm", "service", "ph", "kel", "sh", "sth", "sc", "sb", "her", "se", "acl", "hl", "ctx", "zh", "lib", "lr", "rl", "su", "Sl", "gl", "gb", "sp", "sv", "ld", "sa", "sel", "kl", "ssl", "ul", "lc", "dl", "chal", "lv", "il", "li", "pl", "g", "bl", "ess", "api", "cel"], "sps": ["sPS", "psps", "psds", "Sds", " sPS", "pspps", " spps", "SPS", "psPS", "Spps", "Sps", " sds", "sds", "spps"], "pps": ["cp", "hops", "pp", "bps", "wp", "ups", "lp", "ips", "ppers", "px", "xs", "mp", "pg", "drops", "forces", "hs", "ops", "fps", "eps", "ppa", "amps", "ssl", "params", "ppy", "PP", "pb", "cpp", "ps", "pkg"], "first_mb_in_slice": ["first_mb_inside_layer", "first_mb_in64video", "first_mb_inside_slice", "first_mb_in_source", "first_mb_inside_sequence", "first_mb_inside_video", "first_mb_inside_ice", "first_mb_in64slice", "first_mb_in_video", "first_mb_inside_slot", "first_mb_in_slot", "first_mb_in64ice", "first_mb_in_layer", "first_mb_in_image", "first_mb_in_ice", "first_mb_inside_image", "first_mb_in64source", "first_mb_in_sequence"], "pps_id": ["pps_sid", "ps_bit", "pps_ids", "pps_bit", "ps_sid", "ps_id", "ps_ids"], "ret": ["mem", "alt", "complete", "nt", "skip", "val", "rc", "info", "details", "res", "match", "def", "bis", "RET", "mi", "rev", "result", "seq", "Ret", "batch", "proc", "resp", "success", "rep", "quiet", "rets"], "slice_type": ["slicexlike", "slice_info", "split_val", "slice_class", "slice_ty", " slice_like", "slice_types", "slice_address", "sectioningshape", "slice_Type", "slice_unit", "sectioningpy", "sliceflevel", "slicealtype", "slice64index", "slice67length", "image_info", "section_block", "cell67type", "slice_length", "slicexType", "slice_format", "sliceFunit", "slicealformat", "slice_val", "slice_key", "cell67length", " slice_class", " slice_ty", "slice_day", "slice67type", " slice_kind", " slice_size", "slice__types", "slice_shape", " slice_level", "sliceftype", "slice_block", "sliceTypetype", "slice67address", "slice__ty", "split_format", "sliceTypelevel", " slice_index", "slice_kind", "slice_name", " slice_key", "slice8type", "slice64type", "slice__type", "cell_type", "slicextype", "slice_width", "slicealkey", "slice8source", "slicealwidth", "slice__size", "image_name", "single_width", "slice_like", "sliceingtype", "sectioningblock", "slice_level", "slice7level", "sliceingshape", "cell67unit", "cell67address", "slicealtypes", "single_format", "slice67unit", " slice8unit", "sliceTypekind", " slice_no", "slicefblock", "slice64level", "cell_length", "slicealunit", "slice_index", "slice7type", "sliceingblock", " slice_source", " slice_unit", "slice_source", "slice7ty", "section_shape", " slice8type", "slicealindex", "slicefkind", "slicealsource", "slice7index", "slice_no", " slice_Type", "sliceingpy", "slice_style", "slicealno", "cell_unit", "image_style", "image_type", "split_day", "slice64ty", "slice_size", "section_type", "slicealclass", "section_py", "slice8key", "single_index", " slice_types", "single_type", "split_type", "sliceTypeblock", " slice_length", " slice8key", "sliceFlength", "sliceFtype", "slice_py", " slice_block", "slicexlength", "sliceFaddress", "cell_address", "sectioningtype", " slice8source", "slice8unit"], "tmp": ["cp", "cmp", "rb", "config", "pixel", "pp", "kk", "slice", "mp", "meta", "obj", "ii", "cpp", "zip", "fp", "cb", "source", "temp", "amp", "proc", "ip", "mm", "txt", "params", "cache", "src", "sup", "img"], "i": ["ti", "I", "di", "ci", "ki", "ni", "si", "io", "info", "pi", "phi", "iu", "ii", "it", "cli", "ai", "init", "ori", "mi", "ini", "p", "mini", "ip", "oci", "li", "inner", "index", "ui"], "last_pic_structure": ["last_pic_instructure", "last_pic_restruction", "last_pic_instruction", "last_pic_resturation", "last_pic_estructure", "last_pic_restructure", "last_pic_institute", "last_pic_sturation", "last_pic_estitute", "last_pic_insturation", "last_pic_estruction", "last_pic_struction", "last_pic_esturation", "last_pic_restitute", "last_pic_stitute"], "last_pic_droppable": ["last_pic_croppables", "last_pic_droptability", "last_pic_droptible", "last_pic_droppible", "last_pic_droplable", "last_pic_droplability", "last_pic_droappible", "last_pic_croplible", "last_pic_croppable", "last_pic_droplible", "last_pic_droptables", "last_pic_droappable", "last_pic_croplability", "last_pic_croppible", "last_pic_droplables", "last_pic_droppables", "last_pic_droppability", "last_pic_croplable", "last_pic_croppability", "last_pic_droappables", "last_pic_droappability", "last_pic_croplables", "last_pic_droptable"], "field_pic_flag": ["field_picture_mode", "field_pic0flags", "field_pic_count", "field_pic_mode", "field_pic0mode", "field_pic_flags", "field_picture_flag", "field_pic0count", "field_picture_flags", "field_picture_count", "field_pic0flag"], "bottom_field_flag": ["bottom_line_flag", "bottom_line_flags", "bottom_field_class", "bottom_line_count", "bottom_field_count", "bottom_line_class", "bottom_field_flags"], "frame_num": ["frame_seq", " frame_number", " frame_seq", " frame_nb", "frame_nb", "frame_number"], "droppable": ["cropper", "droposables", "droppsable", "droposability", " droposability", "dropped", "croappable", "croapper", "croppables", "droippable", " droppiable", " droposable", " droposiable", "droppsables", "droipped", "droappables", "droapped", "croappables", " droposables", " droppability", "droppables", "droperables", "droposiable", "droppsed", "croppable", "droipper", "droappiable", "droperiable", "cropped", "droippables", "droposable", "droppiable", "droperability", "droappability", "droperable", "droapper", "droppability", "droppser", " droppables", "droappable", "croapped", "dropper"], "picture_structure": ["picture_estatter", "picture_contruction", "picture_structribution", "picture_destatter", "picture_struction", "picture_gestructure", "picture_stribution", "picture_structruction", "picture_estruction", "picture_structatter", "picture_esture", "picture_sture", "picture_estructure", "picture_gestribution", "picture_estribution", "picture_contructure", "picture_gesture", "picture_destribution", "picture_gestruction", "picture_destructure", "picture_contribution", "picture_destruction", "picture_structructure", "picture_conture", "picture_statter"]}}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_shutdown(URLContext *h, int flags)\n\n{\n\n    if (!h->prot->url_shutdown)\n\n        return AVERROR(EINVAL);\n\n    return h->prot->url_shutdown(h, flags);\n\n}\n", "idx": 7729, "substitutes": {"h": ["H", "hp", "FH", "ah", "r", "ch", "hw", "v", "http", "ih", "ssh", "oh", "uh", "m", "help", "rh", "l", "f", "php", "d", "ph", "hs", "u", "hm", "sh", "e", "t", "hh", "hl", "he", "ctx", "eh", "enh", "p", "context", "hi", "ht", "gh", "c", "g", "hr", "ha", "beh", "host", "bh", "hd"], "flags": ["types", "options", "fg", "files", "flag", "bits", "alls", "features", "Flags", "ags", "atts", "styles", "mask", "fx", "lag", "vals", "FLAG", "ants", "forces", "stats", "fl", "magic", "args", "opens", "linux", "fo", "ss", "fields", "vs", "faces", "ts", "ils", "ents", "fps", "settings", "pect", "friends", "fs", "fun", "fd", "lf", " Flags"]}}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n", "idx": 7732, "substitutes": {"dev": ["hw", "serv", "ch", "rad", "pro", "spec", "Dev", "device", "bug", "data", "info", "dem", "der", "bus", "de", "f", "d", "ve", "mod", "conf", "ev", "def", "dom", "des", "priv", "w", "prom", "cam", "die", "ds", "dc", "self", "p", "serial", "req", "ver", "g", "gd", "app", "grad", "conn"], "s": ["o", "sf", "v", "is", "S", "spec", "sg", "session", "b", "si", "i", "sync", "sys", "ses", "services", "in", "its", "l", "f", "parts", "ns", "state", "server", "d", "sl", "ls", "stats", "service", "init", "ss", "cs", "u", "conf", "args", "e", "sc", "w", "gs", "sb", "out", "bis", "t", "ds", "n", "sd", "su", "p", "south", "settings", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "rs", "r", "ps", "js"], "isabus": ["itabs", "isacs", "issab", "servalis", "areacs", "Isabi", "risabi", "itsibus", "iabi", "ialog", "areabs", "isiab", "idabo", "issabus", "risabo", "isiabi", "areibus", "misabs", "isabo", "itsacs", "hopabi", "issalis", "hopabo", "lisabal", "Isabs", "risabs", "issalog", "issabi", " isabs", "itsabs", "misabus", "lisalog", "risabus", "Isab", "areabus", "servab", "iabus", "isabi", "isubs", "misabi", " isibus", "lisabi", " isabi", "Isabus", "isabal", " isab", " isalis", "idubs", "iabal", "issabal", "hopubs", "isibus", "isabs", "isiabus", "idabi", "idabus", "misab", "isiabs", "itsabus", "itabus", " isacs", "itab", "isalog", "risubs", "isalis", "isab", "servabi", "servabus", "hopabus", "lisabus", "risab", "itabi"], "pit": ["pot", "plugin", "kit", "serv", "bp", "rt", "pai", "piece", "sit", "pin", "pa", "qt", "bt", "val", "itty", "sn", "itter", "lp", "pt", "its", "lit", "at", "sil", "prot", "pet", "sl", "pc", "it", "net", "np", "sb", "nit", "bis", "t", "sat", "fit", "nat", "bot", "bc", "jp", "kat", "p", "ut", "bet", "sp", "sa", "cit", "ct", "pl", "cot"], "out0_irq": ["out0_pirqs", "out0_mirquest", "out0_irp", "out0_irQ", "out0_mirQ", "out0_IRp", "out0_ireq", "out0_ireqs", "out0_IRquest", "out0_ironQ", "out0_ironq", "out0_irquest", "out0_iraqs", "out0_mirq", "out0_irqq", "out0_pirq", "out0_iraQ", "out0_iraqq", "out0_pirQ", "out0_mirqq", "out0_ironqs", "out0_IRQ", "out0_IRqs", "out0_mirp", "out0_ironquest", "out0_pirqq", "out0_irep", "out0_IRq", "out0_ireQ", "out0_mirqs", "out0_irqs", "out0_iraq"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int ncpu;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    /* FIXME: obey smp_cpus.  */\n\n    if (strcmp(cpu_model, \"arm11mpcore\") == 0) {\n\n        ncpu = 4;\n\n    } else {\n\n        ncpu = 1;\n\n    }\n\n\n\n    for (n = 0; n < ncpu; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        pic = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\n\n        if (n > 0) {\n\n            /* Set entry point for secondary CPUs.  This assumes we're using\n\n               the init code from arm_boot.c.  Real hardware resets all CPUs\n\n               the same.  */\n\n            env->regs[15] = 0x80000000;\n\n        }\n\n    }\n\n\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0xc1400400);\n\n\n\n    if (ncpu == 1) {\n\n        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n\n           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n\n           GIC1 to be nIRQ and ignores all the others, so do that for now.  */\n\n        pic = realview_gic_init(0x10040000, cpu_irq[0]);\n\n    } else {\n\n        pic = mpcore_irq_init(cpu_irq);\n\n    }\n\n\n\n    pl050_init(0x10006000, pic[20], 0);\n\n    pl050_init(0x10007000, pic[21], 1);\n\n\n\n    pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    pl080_init(0x10030000, pic[24], 2);\n\n\n\n    sp804_init(0x10011000, pic[4]);\n\n    sp804_init(0x10012000, pic[5]);\n\n\n\n    pl110_init(ds, 0x10020000, pic[23], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\n\n\n\n    pl031_init(0x10017000, pic[10]);\n\n\n\n    pci_bus = pci_vpb_init(pic, 48, 1);\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x4e000000, pic[28]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /*  0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD.  */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /* 0x10016000 Reserved.  */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1.  */\n\n    /* 0x10050000 GIC2.  */\n\n    /* 0x10060000 GIC3.  */\n\n    /* 0x10070000 GIC4.  */\n\n    /*  0x10080000 SMC.  */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n\n}\n", "idx": 7749, "substitutes": {"ram_size": ["ram2scale", "ram1size", "ramingscale", "ramingshape", "cpu_scale", "ram_mode", "rams_address", "ram_scale", "ramingsize", "ram64address", "rams_size", "rams_shape", "ramingaddress", "ram64scale", "cpu_address", "ramsingsize", "cpu_mode", "ramsingshape", "ram_shape", "ram64shape", "ram64size", "ram1scale", "ram_address", "ramsingaddress", "ramsingscale", "ram2shape", "ram2address", "ram64mode", "ram1mode", "cpu_size", "rams_scale", "ram2size", "ram1address"], "vga_ram_size": ["vga_rambsize", "vga_machinebmode", "vga_machine_size", "vga_rambmode", "vga_ram_weight", "vga_rambweight", "vga_ram64mode", "vga_machinebweight", "vga_rambcapacity", "vga_ram64capacity", "vga_ram_capacity", "vga_machine_capacity", "vga_machine_weight", "vga_machinebsize", "vga_ram64weight", "vga_machinebcapacity", "vga_machine_mode", "vga_ram64size", "vga_ram_mode"], "boot_device": ["bootalmode", "bootaldevice", "kernel_address", "boot_mode", "bootermode", "bootalsystem", "boot_system", "kernel_system", "booterdevice", "kernel_mode", "kernel_device", "boot_address", "bootaladdress", "bootersystem", "booteraddress"], "ds": ["dm", "ded", "nas", "dd", "pd", "dh", "der", "DS", "db", "tx", "ls", "iss", "ss", "cs", "des", "vs", "ks", "da", "df", "dds", "ils", "ye", "fs", "ld", "ys", "dt", "ps", "rs", "cdn"], "kernel_filename": ["kernel_fn", "kernel_file", "kernel__fn", "config_file", "kernel_files", "kernel__filename", "config_files", "config_filename", "kernel__file", "kernel__files", "config_fn"], "kernel_cmdline": ["kernel_pathname", "kernel_pathline", "kernel_pathl", "kernel_commandrule", "kernel_cmdrule", "kernel_pathrule", "kernel_cmdl", "kernel_programrule", "kernel_commandname", "kernel_cmdname", "kernel_commandl", "kernel_programl", "kernel_commandline", "kernel_programname", "kernel_programline"], "initrd_filename": ["initrdocmessage", "initrdocfp", "initrdocfilename", "initrd_title", "initrdoctitle", "initrd_message", "initrd1message", "initstruct_message", "initrd1title", "initrd1filename", "initrd_fp", "initstruct_fp", "initstruct_title", "initrd1fp", "initstruct_filename"], "cpu_model": [" cpu_path", "cpuamclass", "cpu_models", "CPU_service", "processor_block", "cpuamModel", "cpu_block", "cpu67mode", " cpu_models", "cpu_size", "cpu_file", "CPU_model", "cpuamline", "processor_model", "cpu_Model", "CPU_name", " cpu_mode", "machine_Model", "cpu67service", "cpu_path", " cpu_file", "machine_line", "CPU_mode", "machine_class", "cpuammodel", " cpu_type", "cpu_service", " cpu_location", "cpu_type", "cpu_name", "cpu67name", "cpu_mode", "cpu_line", "cpu67model", "cpu_class", "processor_size", "cpu_location", "processor_models", "machine_model"], "env": ["enable", "fen", "osc", "ah", "fg", "anc", "nw", "ea", "ig", "kn", "el", "v", "qv", "scope", "session", "config", "qt", "environment", "nc", "exc", "style", "enc", "sys", "pe", "eu", "db", "export", "ext", "obj", "args", "iss", "init", "net", "conf", "ev", "np", "vs", "e", "priv", "her", "en", "dev", "ctx", "pec", "cycle", "bc", "equ", "Environment", "lock", "err", "context", "ne", "ini", "ec", "network", "eni", "ner", "doc", "console", "txt", "cf", "cache", "loader", "img", "fe", "conn"], "pic": ["pot", "plugin", "kit", "fat", "oc", "pid", "kin", "ig", "play", "sec", "pull", "piece", "mic", "pin", "pa", "config", "pse", "xi", "cus", "style", "sync", "enc", "typ", "sys", "loc", "qi", "pins", "picture", "pi", "cci", "gui", "pc", "mot", "py", "cli", "sci", "init", "tick", "cons", "action", "mc", "nic", "jc", "pict", "lib", "study", "bc", "jp", "cycle", "feat", "pres", "seq", "ic", "parse", "mini", "doc", "fig", "proc", "txt", "capt", "lc", "product", "lin", "fc", "ku", "cache", "vc", "fi", "chat", "img", "pick", "feature", "Pic"], "scsi_hba": ["scsi_psa", "scsi_phba", "scsi_hsa", "scsi_hca", "scsi_phsa", "scsi_pba", "scsi_pca", "scsi_bsa", "scsi_bca", "scsi_bba", "scsi_phca", "scsi_hbi", "scsi_bbi", "scsi_phbi", "scsi_pbi"], "pci_bus": ["pci2boot", "pdi_BUS", "pci_usb", "pci_boot", "pci2usb", "pci2BUS", "pdi_bus", "pdi_boot", "pci2bus", "pdi_usb", "pci_BUS"], "nd": ["nv", "NV", "nl", "nw", "na", "ann", "nn", "dn", "vd", "NG", "dd", "nt", "NN", "ni", "inn", "nc", "ND", "ani", "ng", "nm", "nz", "nb", "nih", "ld", "ind", "ln", "gd", "fd", "nu"], "n": ["rn", "nl", "name", "o", "nor", "nw", "v", "not", "nn", "dn", "nt", "ni", "b", "nc", "inn", "i", "sn", "x", "m", "l", "num", "f", "ng", "N", "mn", "ns", "d", "j", "init", "net", "number", "e", "len", "pn", "en", "nit", "t", "nat", "fn", "k", "nb", "p", "ne", "network", "un", "c", "g", "cn", "y", "adj", "no", "r", "conn", "nu"], "cpu_irq": ["cpu_pirquest", "cpu_iriq", "cpu_arqs", "cpu_iperqs", "cpu_iriquest", "cpu_mirQ", "cpu_arQ", "cpu_mirq", "cpu_mirp", "cpu_irp", "cpu_arq", "cpu_rinq", "cpu_ironq", "cpu_ironp", "cpu_IRqs", "cpu_pirq", "cpu_pirQ", "cpu_iperq", "cpu_arqu", "cpu_ironqs", "cpu_IRq", "cpu_iriqs", "cpu_irQ", "cpu_ireqs", "cpu_ireQ", "cpu_IRQ", "cpu_ireq", "cpu_IRp", "cpu_mirqs", "cpu_irequest", "cpu_rinqs", "cpu_rinp", "cpu_rinQ", "cpu_irqu", "cpu_pirqs", "cpu_iperqu", "cpu_iriQ", "cpu_irquest", "cpu_ironQ", "cpu_iperQ", "cpu_irqs", "cpu_IRqu"], "ncpu": ["mccpu", "dccore", "cpc", "ntcpu", "cuda", "mccore", "scpu", "sccpu", "scgpu", "ncroc", "npu", "ncpc", "dccpu", "lccpu", "lcroc", "lcpc", "dcroc", "uncpu", "mcpc", "nccpu", "dcpu", "cgpu", "unccpu", "uncpc", "ntpu", "ntpc", "dcgpu", " ngpu", "nccore", "uncroc", "ntgpu", "ncuda", " nuda", "ccpu", "ngpu", "ncgpu", "npc", "dcpc", "cpu", "mcpu", "lcpu", " npu", "ccore", "scuda"], "index": ["name", "position", "na", "count", "nn", "nt", "x", "nc", "si", "sync", "sn", "i", "num", "ng", "loop", "fe", "net", "len", "pn", "nb", "run", "network", "pos", "node", "ind", "ln", "Index", "no"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n", "idx": 7754, "substitutes": {"str": ["est", "name", "fr", "ch", "er", "st", "cr", "iter", "sec", "cur", "prev", "id", "x", "tr", "enc", "in", "ext", "ctr", "arr", "err", "exec", "Str", "pos", "step", "ind", "STR", "br", "inner", "text", "next", "r", "stri", "max"], "start": ["base", "started", "name", "st", "origin", "id", "count", "starting", "pre", "x", "i", "shift", "art", "in", "offset", "rest", "d", "init", "from", "stop", "part", "Start", "se", "pad", "first", "source", "p", "ie", "begin", "pos", "step", "ind", "range", "c", "read", "next", "set", "r", "min", "max", "size"], "end": ["END", "append", "id", "send", "last", "i", "ending", "rest", "offset", "limit", "length", "ended", "from", "e", "len", "stop", "size", "en", "bound", "n", "after", "p", "begin", "line", "pos", "ind", "range", "c", " extend", "ize", "set", "ension", "index", "max", "nd", "End"], "qstring": ["aystring", "quickstring", "eqclass", "viewstream", "eqnumber", " qring", "qastrings", " qstream", "qastream", "questr", "qastring", "queststring", "qduration", "questarray", "qustr", "sqresource", "aystr", "quickstr", "viewstring", "qarray", "qaclass", "qslice", "reqfile", "ayring", " qobject", "qdate", "qvalue", "sqbinary", "chduration", "sqvalue", "ayduration", "viewarray", " qslice", "sqnumber", "eqiterator", "qadate", "querynumber", "reqstring", "qaslice", "viewring", "eqslice", "queryarray", "quering", "querystring", "eqfile", "qnumber", "reqservice", "quickring", "quvalue", "qstream", "qaarray", "qanumber", "quicksource", "qring", "eqduration", "eqdatabase", " qnumber", " qresource", " qbinary", "quefilename", "qaresource", "qastr", "qstrings", "qfile", "qaring", "eqstr", "sqservice", "sqslice", "sqarray", " qarray", "qclass", "eqfunction", "eqsource", "eqring", "quiterator", "eqservice", "sqfile", "chstr", "chring", "qustring", "qdatabase", "reqstr", "qbinary", "eqstream", "sqfilename", "qqstr", "sqstream", "qfilename", "eqdate", "eqstring", "quickclass", "sqstrings", " qclass", "eqarray", "qsource", "sqsource", "sqstr", "qaobject", "queslice", "eqfilename", "chstring", "qobject", "sqobject", "quefile", "quickfile", "qqstring", " qsource", "sqfunction", "eqvalue", "qfunction", "sqiterator", "qqiterator", "qiterator", "qqslice", "quslice", "sqdatabase", "questdate", "sqring", "questring", "qabinary", " qstrings", "querysource", "quedatabase", "qservice", "qresource", "qstr", "queservice", "qufunction", "sqstring", "quesource"]}}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 7761, "substitutes": {}}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n", "idx": 7762, "substitutes": {"top": ["master", "as", "block", "http", "parent", "prev", "best", "pre", "up", "bottom", "support", "null", "job", "client", "state", "TOP", "Top", "space", "upper", "initial", "super", "part", "high", "above", "file", "bot", "path", "p", "root", "tops", "start", "higher", "primary", "new", "central", "front", "site", "current", "next", "first", "prefix"], "base": ["bas", "area", "layer", "stable", "extra", "copy", "local", "change", "http", "parent", "ite", "pre", "b", "stack", "bottom", "status", "fake", "state", "init", "part", "basic", "full", "bot", "bare", "source", "old", "based", "root", "Base", "start", "core", "inner", "site", "cache", "front", "max", "super", "prefix"], "sector_num": [" sector_number", "sector_no", "section_no", " sector_sum", " sector_ident", " sector_name", "sector_name", " sector_prefix", "section_num", "sector_four", "sector_ident", "sector_prefix", "section_number", "sector_sum", "sector_number", "section_four"], "nb_sectors": ["nb_psevers", "nb_specsec", "nb_specivers", "nb_tesections", "nb_sesections", "nb_specgments", "nb_spevers", "nb_desrets", "nb_spegments", "nb_tegments", "nb_tections", "nb_vesec", "nb_gectors", "nb_spectors", "nb_sperets", "nb_vegments", "nb_specctors", "nb_seivers", "nb_vections", "nb_gegments", "nb_desvers", "nb_sections", "nb_psectors", "nb_gections", "nb_spesec", "nb_tectors", "nb_segments", "nb_desgments", "nb_serets", "nb_veivers", "nb_severs", "nb_speivers", "nb_vesections", "nb_desctors", "nb_psegments", "nb_pserets", "nb_vectors", "nb_gesections", "nb_sesec"], "pnum": ["rnumption", "panman", "pcumb", "pinum", "pnuman", "snumm", "pinumi", "pinuman", "pnumm", "pnman", "panenum", "rnenum", "panuc", "pronenum", "pronman", "pronum", "pnumi", "pnumb", "pinumer", "snumer", "panumi", "pnumption", "atanum", "pronumb", "pinumption", "pnuc", "pinumb", "pnenum", "snum", "rnman", "pcuman", "panumer", "snuc", "atanenum", "pnumer", "panumb", "atanumm", "rnum", "pinuc", "panum", "pcumption", "pcum", "snumb", "snenum", "pronumm", "rnuman", "atanumb", "snumi", "rnumb"], "intermediate": ["extference", "internmedi", "interfinal", "INTERiguous", "INTERior", "transference", "imfinal", "indruction", "internmediate", " interior", "transmediate", "investior", "interplementation", "interporal", "itermedi", "intmedi", "instmediate", "INTERmediately", "prommediate", "adparent", "overior", "implementation", "adior", "exference", " interfinal", "intermediately", "INTERruction", "extplementation", "indmediate", "intersvious", "explementation", " interplementation", "interiguous", "investmediate", "intermedi", "transplementation", "indporal", "intvious", "instiguous", "intior", "internparent", "iterior", "interruction", "INTERplementation", "investmediately", "admedi", "INTERfinal", "promporal", "investiguous", "itervious", "instior", "indior", "intervious", "promior", "imior", "intmediate", "extmediate", "promruction", "overparent", "INTERmediate", "admediate", "itermediate", "instmediately", "exior", "transior", "interference", "interparent", "interior", "overmedi", "immediate", "intersior", "internior", "intersmedi", "extior", "INTERporal", "exmediate", "overmediate", "intersmediate"], "ret": ["flag", "reset", "iter", "tr", "real", "status", "nm", "arg", "active", "match", "code", "len", "det", "error", "RET", "nat", "pass", "err", "rl", "rev", "ft", "fun", "id", "al", "nt", "value", "val", "rf", "art", "mn", "ne", "back", "nl", "reg", "rt", "alt", "rot", "rc", "bit", "cat", "repl", "num", "fin", "ext", "att", "obj", "py", "out", "t", "Ret", "fab", "run", "ner", "re", "gt", "ref", "rets", "mem", "pre", "inter", "reply", "res", "init", "ry", "def", "part", "fn", "result", "req", "opt", "bf", "br", "success", "hard"], "n": ["rn", "nl", "o", "nor", "na", "v", "nn", "dn", "s", "nt", "ni", "x", "b", "nc", "i", "sn", "non", "m", "l", "num", "f", "ng", "N", "ns", "mn", "nm", "j", "d", "nr", "net", "number", "len", "e", "pn", "en", "out", "t", "nat", "nb", "p", "ne", "network", "un", "none", "node", "c", "new", "y", "cn", "adj", "no", "r", "conn"], "pnum_inter": ["pnUM_cur", "pnum_iter", "pnum_pre", "pnum_INTER", "pnuma_inf", "pnumer_cur", "pnum_inf", "pnum_cur", "pnUM_inter", "pnum_pointer", "pnumer_inter", "pnumer_ext", "pnumm_INTER", "pnum_ext", "pnumm_ar", "pnum_inc", "pnuma_pointer", "pnum_rev", "pnumm_inter", "pnum_ar", "pnum__inter", "pnuma_rev", "pnumm_Inter", "pnuma_inter", "pnum__pre", "pnum_Inter", "pnum__cur", "pnUM_inc", "pnum_ref", "pnum__inc", "pnuma_ext", "pnumer_iter", "pnUM_pre", "pnuma_ref"]}}
{"project": "qemu", "commit_id": "c6bf0f7ffa90c720377eb6bddd27037041acbc5b", "target": 0, "func": "static DisplayType select_display(const char *p)\n\n{\n\n    Error *err = NULL;\n\n    const char *opts;\n\n    DisplayType display = DT_DEFAULT;\n\n\n\n    if (strstart(p, \"sdl\", &opts)) {\n\n#ifdef CONFIG_SDL\n\n        display = DT_SDL;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",frame=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_frame = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_frame = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",alt_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    alt_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    alt_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",ctrl_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    ctrl_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    ctrl_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",window_close=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_quit = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_quit = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else {\n\n            invalid_sdl_args:\n\n                fprintf(stderr, \"Invalid SDL option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"SDL support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"vnc\", &opts)) {\n\n#ifdef CONFIG_VNC\n\n        if (*opts == '=') {\n\n            if (vnc_parse(opts + 1, &err) == NULL) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr, \"VNC support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"curses\", &opts)) {\n\n#ifdef CONFIG_CURSES\n\n        display = DT_CURSES;\n\n#else\n\n        fprintf(stderr, \"Curses support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"gtk\", &opts)) {\n\n#ifdef CONFIG_GTK\n\n        display = DT_GTK;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    grab_on_hover = true;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    grab_on_hover = false;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else {\n\n            invalid_gtk_args:\n\n                fprintf(stderr, \"Invalid GTK option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"GTK support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"none\", &opts)) {\n\n        display = DT_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Unknown display type: %s\\n\", p);\n\n        exit(1);\n\n    }\n\n\n\n    return display;\n\n}\n", "idx": 7766, "substitutes": {"p": ["cp", "P", "o", "bp", "pr", "s", "pat", "pp", "op", "data", "i", "b", "wp", "m", "f", "j", "d", "pc", "py", "np", "e", "parser", "t", "n", "path", "fp", "jp", "vp", "sp", "proc", "c", "g", "tp", "pl", "pb", "r", "ps"], "err": ["gr", "fg", "ch", "er", "cr", "iter", "pr", "rr", "sys", "der", "rh", "tx", "e", "error", "go", "cb", "str", " Err", "req", "usr", "proc", "resp", "Er", "rs", "r", "Error", "msg"], "opts": ["opls", " opTS", "OPcs", "Opments", "itps", "appters", "offt", "atts", "operTS", "optls", "itters", "copt", "sett", "opttes", "otments", "iopts", "OPted", "optcs", "offts", "catls", "roptips", "ipters", "Opouts", "OPt", "ropouts", "opns", "oprs", "roputs", "hopters", "opercs", "OPuts", "hopplets", "optps", "opths", "optuts", "OPps", "opter", "ipps", "promths", "expter", "oplets", "latts", "catts", "OPts", " copters", "OPtes", " optr", "opsts", "offted", "operts", "opters", "iplets", "optt", "ropts", "optr", "opttics", "expts", "poprs", " copplets", "opws", "setts", "otps", "ropters", "opcs", "ropments", "optsts", "copts", "setsts", " oputs", "latTS", "otts", "opouts", "optes", "expt", "OPws", "OPtr", "expert", "popts", "iopws", " opps", "catte", "ioputs", "optics", "OPtips", "appts", "optments", "exptics", "opted", "operuts", "OPouts", "optTS", "catuts", "operters", "opert", "opments", "Opsts", "promts", "opps", "OPte", "opertes", "catps", " opments", "OPters", "oputs", "iopters", "optrs", "atns", "latuts", "setted", "opplets", "itts", "hoplets", "lattr", "OPsts", "setuts", "OPths", "experts", "opTS", "hopTS", "optplets", "OPments", "opertons", "itte", "Opters", "optons", "promt", "OPtons", "promtons", "hoptr", "hoputs", "operter", "OPls", "exptips", "otters", "operws", "poptics", "Opted", "hopns", "OPter", "expertics", "expertips", "optips", "cattips", "Opts", "catters", "optts", "apputs", "apptr", "ipts", "opersts", "optters", "OPrs", "ipns", "atlets", "copTS", "setters", " coputs", " copts", "exputs", "operted", "opte", "offuts", "copters", "opt", "iputs", "catt", "expters", "opertr", " opcs", "popt", "atuts", "operls", "operths", "OPtics", "hopts", "OPTS", " opters"], "nextopt": ["successoption", "headoptim", " nexttemp", "nextOpt", "successopt", "openalt", "dotoptim", "goingOpt", "goingloop", "headopt", "futureOpt", "nowoption", "decopt", "newort", "forwardopt", "headoption", "primaryoption", "futureoptim", "seenOpt", "successoptim", " nextOpt", "primaryhop", "workingoptim", "seenpot", "Nextort", "styleoption", "mainopted", "styleoptim", "prevopt", "prevalt", "newopted", "dotOpt", "nextoct", " nextoptim", "decoption", "otheroption", "dotalt", "nextoption", "forwardoption", "morehop", "nextpot", " nextloop", "mainOpt", "newoff", "serveroptim", "mainop", "lastoct", "stylealt", "mainopt", " nextoct", "dottemp", "workingopt", "nexttemp", "lastoption", "Nextpot", "newoptim", "changeoption", "moreoption", "nextoff", "forwardalt", "nextop", "workingoption", "seenopt", "nextoptim", "decoptim", "goingopt", "NextOpt", "nowoptim", "changeoptim", "dotopt", "frontalt", "firstop", "moreoptim", "frontopt", "frontoption", "openoption", "nextloop", " nextpot", "newloop", "prevoption", " nextoption", "changeopt", "lastOpt", "newoct", "newopt", "serveropt", "workingOpt", "nowort", "successop", "openopt", " nextopted", "otheroptim", "Nextoptim", " nexthop", "futureopt", "nowopt", "newOpt", "Nextoption", "styleopt", "firstoptim", "serverop", "firstopt", "otherOpt", "frontopted", "mainoption", "forwardopted", "serveroption", " nextort", "dotoption", "moreopt", "nextopted", " nextop", " nextalt", "nextalt", "headtemp", "decoff", "futureoption", "moreoct", "nowop", "moreop", " nextoff", "changeop", "firstoption", "prevOpt", "newoption", "otheropt", "primaryoct", "goingoption", "nextort", "primaryopt", "nexthop", "seenoption", "otheralt", "lastopt", "openoptim", "mainoptim", "Nextopt"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)\n\n{\n\n    int64_t start, size, last_size;\n\n    start= url_ftell(bc) - prefix_length;\n\n\n\n    if(start != nut->packet_start + nut->written_packet_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"get_packetheader called at weird position\\n\");\n\n        return -1;\n\n    }\n\n    \n\n    if(calculate_checksum)\n\n        init_checksum(bc, update_adler32, 0);\n\n\n\n    size= get_v(bc);\n\n    last_size= get_v(bc);\n\n    if(nut->written_packet_size != last_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->written_packet_size, last_size, start);\n\n        return -1;\n\n    }\n\n\n\n    nut->last_packet_start = nut->packet_start;\n\n    nut->packet_start = start;\n\n    nut->written_packet_size= size;\n\n\n\n    return size;\n\n}\n", "idx": 7777, "substitutes": {"nut": ["bolt", "cro", "utt", "cart", "stone", "cot", "gob", "ore", "ctr", "error", "nat", "ou", "boot", "ft", "nav", "ct", "dt", "uts", "conn", "pot", "ocr", "aug", "nuts", "nov", "nt", "config", "gat", "art", "missing", "orb", "dist", "oren", "nova", "nit", "lib", "ut", "node", "cn", "adr", "cod", "text", "nv", "cut", "nw", "rt", "bd", "note", "rot", "cat", "knife", "winner", "ext", "obj", "oven", "np", "fit", "feat", "ox", "transfer", "cit", "creator", "contract", "gt", "core", "ot", "fat", "od", "Nut", "piece", "bt", "kt", "category", "dc", "n", "cb", "root", "cdn", "orn"], "bc": ["oc", "BC", "gc", "cgi", "anc", "ocr", "cr", "bd", "rb", "config", "bt", "com", "nc", "rc", "cca", "uc", "loc", "orb", "fb", "db", "mac", "cl", "BBC", "ucc", "soc", "org", "pc", "sc", "mc", "dc", "lib", "ctx", "cb", "cms", "exec", "context", "ec", "gb", "c", "bf", "ct", "lc", "fc", "CBC", "bitcoin", "src", "cot", "cm", "tc"], "prefix_length": ["padding_offset", "prefixallen", "prefixlenlen", "prefix_offset", " prefix_size", "prefixlensize", "prefixalrequired", "padding_length", "padding_required", "prefixallength", " prefix_len", "padding_len", "prefix_len", "prefixlenlength", "prefix_size", "prefixaloffset", "prefix_required"], "calculate_checksum": ["calculate_hsup", "calculate_cksums", "calculate_cksam", "calculate_ckssum", "calculate_checksup", "calculate_cksum", "calculate_csum", "calculate_cksup", "calculate_hssum", "calculate_checksums", "calculate_csam", "calculate_csums", "calculate_cssum", "calculate_hsum", "calculate_checksam", "calculate_checkssum", "calculate_hsam"], "start": ["base", "address", "started", "name", "st", "store", "change", "id", "count", "try", "open", "send", "check", "config", "get", "starting", "skip", "sum", "style", "use", "shift", "i", "ad", "info", "art", "ate", "slice", "ace", "offset", "grade", "add", "length", "state", "init", "from", "ce", "it", "len", "stop", "part", "Start", "error", "se", "pad", "load", "ie", "source", "parse", "p", "scale", "step", "pos", "ind", "c", "read", "type", "set", "index", "min", "end", "seed"], "size": ["false", "address", "give", "name", "clean", "SIZE", "extra", "time", "large", "sec", "count", "fee", "shape", "send", "grow", "ny", "sum", "data", "si", "sync", "use", "last", "i", "loc", "unit", "speed", "capacity", "offset", "length", "small", "Size", "from", "number", "code", "len", "se", "en", "full", "storage", "sized", "day", "bytes", "empty", "n", "ey", "source", "ie", "scale", "ice", "range", "new", "ize", "set", "form", "end"], "last_size": ["last_len", " last_sized", "last24length", "last_length", "last_start", "last24start", "last_sized", "last24address", " last_address", " last_length", " last_len", "last24size", " last_scale", "last_address", "last_scale", " last_start"]}}
{"project": "qemu", "commit_id": "75f19f8c3006970632303b49043b075dc4fe922e", "target": 0, "func": "static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n", "idx": 7779, "substitutes": {"s": ["o", "sf", "S", "comm", "a", "spec", "sg", "b", "si", "sys", "ses", "services", "m", "ips", "states", "f", "client", "ns", "d", "server", "ls", "args", "service", "cs", "ss", "conf", "e", "sb", "gs", "ks", "secondary", "t", "ds", "ctx", "qs", "phys", "south", "settings", "aws", "fs", "c", "os", "g", "sym", "sq", "ssl", "params", "es", "rs", "ps"], "cmd": ["cp", "dr", "cfg", "clean", "host", "id", "md", "comm", "method", "sg", "send", "config", "Cmd", "ctl", "op", "cat", "m", "buf", "draw", "mac", "cl", "content", "client", "pg", "call", "d", "gz", "cc", "cli", "cs", "code", "ck", "acl", "target", "gs", "conn", "dc", "ctx", "ds", "cb", "input", "ctrl", "req", "h", "c", "g", "ct", "cf", "cod", "vc", "gn", "cpp", "command", "cm", "pkg", "cd", "msg"], "p": ["cp", "hp", "gp", "P", "o", "bp", "v", "a", "po", "pp", "pd", "op", "i", "b", "wp", "pe", "lp", "ap", "m", "f", "pi", "d", "pc", "py", "np", "e", "t", "n", "fp", "jp", "vp", "sp", "pointer", "c", "ip", "g", "api", "tp", "r", "ps"]}}
{"project": "qemu", "commit_id": "02cb7f3a256517cbf3136caff2863fbafc57b540", "target": 0, "func": "int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 7780, "substitutes": {"s": ["o", "sets", "is", "S", "spec", "sg", "session", "b", "si", "i", "sys", "ses", "services", "m", "f", "ns", "stats", "sl", "server", "d", "service", "ss", "cs", "e", "sie", "sb", "ops", "gs", "ds", "storage", "n", "t", "ts", "su", "self", "p", "south", "aws", "sv", "fs", "c", "os", "g", "ssl", "sq", "es", "rs", "ps", "js"], "fidp": ["foidl", "fydpad", " fidr", " fidpre", "fidr", "fidf", "affidpy", "fydpy", "fydps", "fitp", "fedp", " fidsP", " ffdp", " fitp", "foidr", "fpidd", "fidsp", " fidl", " ffdl", "foidp", "ffdp", "fIdf", "fidd", "affedpy", "fitf", "foidd", "fidps", "affedP", "fippy", "fidsP", "fedpad", " ffdr", "affidP", " fitb", "ffdr", "frodb", "fydf", "fIdP", "ffdd", "ffdl", "fidpre", " fitf", "fidpy", "fedpy", "fidP", " fidsp", "fipp", " fidP", "fidpad", " fitpre", "fidl", "frodpre", "fipP", " fidsps", "fitb", " fidf", " ffdd", "affedpad", "frodf", "fedP", "fippad", "fidsb", "frodp", "fidsf", "fitpre", "fydP", " fidps", "fpidl", "fidspre", " fidd", "affidpad", "fpidr", "affidp", "affedp", "fydp", "fIdp", "fidsps", "fpidp", " fidsf", "fidb", " fidb", "fIdps"], "fullname": ["realnames", " fulllabel", "shortlabel", "shortpath", "realname", "fullnames", "longnames", "fullypath", "fullylabel", "shortName", "fullyname", "realName", "fullyName", "fullpath", "fullName", "longname", " fullpath", "shortname", "longName", " fullnames", " fullName", "fulllabel"], "gid": ["sgtype", "pid", "igids", "sgID", "genname", "igname", "gname", "igid", "uuip", "sgid", "sgip", "genids", "uutype", " gID", "genid", "uuid", "gids", "pip", "genID", " gname", "gID", "gip", "uuID", "igID", "gtype", "pID", "ptype", " gids"], "flags": ["groups", "types", "options", "files", "flag", "missions", "bits", "fee", "Flags", "features", "bit", "format", "mask", "ips", "lag", "status", "mac", "stats", "args", "mods", "len", "acl", "ops", "locks", "ds", "bytes", "feat", "settings", "lvl", "fs", "fun", " bits", "fd", "ms", "lines", "lf", "reads"], "mode": [" perm", "base", " modes", "MODE", "name", "uid", "time", "flag", "ward", "missions", "mem", "id", "md", "device", "Mode", "force", "format", "perm", "m", "mask", "status", "mac", "mod", "ffff", "sid", "owner", "code", "size", "acl", "kind", "mission", "func", "dc", "driver", "cmd", "path", " magic", "own", "none", "fun", "node", "slave", "type", "fd", "user", "command", "role"], "err": ["dy", "dr", "gr", "er", "cr", "iter", "fy", "id", "rr", "count", "rag", "bug", "val", "rc", "i", "ise", "ok", "loc", "der", "ace", "status", "rh", "rage", "ir", "attr", "order", "call", "nr", "init", "ctr", "fe", "code", "e", "error", "ar", "arr", "cb", "lr", "str", "nil", "result", " Err", "ie", "raise", "req", "runner", "ner", "mr", "ind", "var", "c", "orig", "resp", "type", "y", "inner", "Er", "fi", "r", "Error", "msg"], "cred": [" ecrd", "ecredit", "dcrib", " ecrowd", "dcred", "rcredit", "rcrd", "fcrd", "grypt", " acredit", "acrypt", "acram", "Crib", "lcRED", " cram", "rcrib", "Credits", "ccRED", "crd", "fcrowd", "ecrib", "acred", "encred", " credits", "acredits", "encredit", "Cred", " acrd", "rcred", "fcredit", "ccredit", "dcredit", "Credit", "lcrib", "lcred", " crypt", " ecred", " acred", "dcRED", "Crypt", "fcred", "gred", " ecredit", "encrowd", "ecred", "acredit", " acrowd", "ccred", "cRED", "Crd", " crowd", "lcredit", "crypt", "credit", "encrypt", "gram", "crib", "crowd", "cram", "gredit", "ecrd", "credits", "ccrib", "acrowd", " credit"], "total_open_fd": ["total_open64FD", "total_close_FD", "total_open64dc", "total_open_fc", "total_close_fd", "total_open64fd", "total_open64dd", "total_open_FD", "total_close_fc", "total_open_dc", "total_open_dd", "total_close_dd", "total_open64fc", "total_close_dc"]}}
{"project": "qemu", "commit_id": "bbe2f399b222f1f2fcf5cd2ea78e4f5c9a66c64e", "target": 0, "func": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7782, "substitutes": {"n": ["nv", "rn", "nl", "o", "nor", "nw", "na", "v", "nn", "dn", "s", "nt", "b", "nc", "non", "sn", "enc", "m", "in", "yn", "l", "num", "f", "ng", "N", "ns", "mn", "nm", "d", "j", "net", "u", "np", "e", "an", "en", "pn", "t", "fn", "nat", "nb", "p", "ne", "network", "z", "un", "none", "node", "c", "ln", "g", "cn", "adj", "conn", "nu"], "buf": ["buff", "vec", "mem", "v", "eth", "nt", "rb", "b", "tr", "rc", "data", "queue", "uf", "offset", "f", "buffer", "Buffer", "port", "ctx", "pad", "bc", "fp", "cb", "ab", "seq", "pool", "p", "alloc", "cap", "fd", "cv", "ref", "pb", "src"], "size": ["address", "name", "SIZE", "sec", "s", "shape", "nc", "rc", "enc", "loc", "max", "offset", "small", "Size", "len", "e", "empty", "scale", "z", "pos", "c", "g", "desc", "ize", "end"], "bcast": [" baddr", " bcasting", "mcast", "pCAST", " bcasts", " bast", " bpad", "rbace", "abcast", "abast", "vast", "pcasting", "rbcasting", "face", " bace", "fCAST", "maddr", "faddr", "abace", "mcasting", "vcast", "baddr", "bpad", "pcast", "rbcast", "vace", "fcasting", "bcasts", "bace", "bCAST", "bast", "vcasts", "pace", "rbCAST", "bcasting", "abcasts", "mpad", "fcast", "fpad"], "vlan": ["svda", "vrn", "vrda", "plc", "vnic", "Vlan", "hrn", "glc", "pla", " vnic", "svann", "vda", " vlen", "pnic", "vlc", "Vlen", "VLAN", "hlen", " vla", "gnic", "vrlan", "hLAN", " vlc", "Vrn", "vrlc", " vLAN", "vrann", "vlen", " vrn", "hlan", "svlc", "svlan", "vann", "gla", "plan", "vLAN", "glan", " vann", " vda", "vla"], "ptr": ["dr", "tr", "data", "ctr", "td", "ev", "push", "buffer", "code", "mount", "arr", "fp", "bc", "sp", "proc", "cur", "nt", "plug", "slice", "pt", "tty", "pri", "sth", "port", "ctx", "pad", "str", "adr", "addr", "grad", "end", "address", "hw", "dat", "tmp", "rot", "pp", "rc", "loc", "prot", "pc", "inst", "p", "Ptr", "prop", "pos", "fd", "ref", "r", "src", "trace", "cmp", "eger", "ch", "buff", "inter", "offset", "attr", "length", "priv", "context", "pty", "req", "wr", "iv", "alloc", "pointer", "br", "pair", "cv", "shift"], "i": ["gi", "r", "o", "ti", "v", "id", "I", "a", "vid", "di", "ci", "ji", "ni", "b", "xi", "si", "io", "ri", "x", "info", "bi", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "adi", "j", "iu", "ii", "d", "ai", "uli", "u", "e", "ami", "uri", "k", "mi", "ini", "p", "z", "eni", "oi", "hi", "c", "ip", "y", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "4bb0b31f762c422ad15bee68da7bcf76940cc9fa", "target": 0, "func": "static int output_packet(InputStream *ist, int ist_index,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    AVFormatContext *os;\n\n    OutputStream *ost;\n\n    int ret, i;\n\n    int got_output;\n\n    void *buffer_to_free = NULL;\n\n    static unsigned int samples_size= 0;\n\n    AVSubtitle subtitle, *subtitle_to_free;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n#if CONFIG_AVFILTER\n\n    int frame_available;\n\n#endif\n\n    float quality;\n\n\n\n    AVPacket avpkt;\n\n    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);\n\n\n\n    if(ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts= ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if(pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    //while we have more to decode or while the decoder did output something on EOF\n\n    while (avpkt.size > 0 || (!pkt && got_output)) {\n\n        uint8_t *data_buf, *decoded_data_buf;\n\n        int data_size, decoded_data_size;\n\n        AVFrame *decoded_frame, *filtered_frame;\n\n    handle_eof:\n\n        ist->pts= ist->next_pts;\n\n\n\n        if(avpkt.size && avpkt.size != pkt->size)\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning=1;\n\n\n\n        /* decode the packet if needed */\n\n        decoded_frame    = filtered_frame = NULL;\n\n        decoded_data_buf = NULL; /* fail safe */\n\n        decoded_data_size= 0;\n\n        data_buf  = avpkt.data;\n\n        data_size = avpkt.size;\n\n        subtitle_to_free = NULL;\n\n        if (ist->decoding_needed) {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:{\n\n                if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) {\n\n                    samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE);\n\n                    av_free(samples);\n\n                    samples= av_malloc(samples_size);\n\n                }\n\n                decoded_data_size= samples_size;\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size,\n\n                                            &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                avpkt.data += ret;\n\n                avpkt.size -= ret;\n\n                data_size   = ret;\n\n                got_output  = decoded_data_size > 0;\n\n                /* Some bug in mpeg audio decoder gives */\n\n                /* decoded_data_size < 0, it seems they are overflows */\n\n                if (!got_output) {\n\n                    /* no audio frame */\n\n                    continue;\n\n                }\n\n                decoded_data_buf = (uint8_t *)samples;\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) /\n\n                    (ist->st->codec->sample_rate * ist->st->codec->channels);\n\n                break;}\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                    decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2;\n\n                    if (!(decoded_frame = avcodec_alloc_frame()))\n\n                        return AVERROR(ENOMEM);\n\n                    avpkt.pts = pkt_pts;\n\n                    avpkt.dts = ist->pts;\n\n                    pkt_pts = AV_NOPTS_VALUE;\n\n\n\n                    ret = avcodec_decode_video2(ist->st->codec,\n\n                                                decoded_frame, &got_output, &avpkt);\n\n                    quality = same_quant ? decoded_frame->quality : 0;\n\n                    if (ret < 0)\n\n                        goto fail;\n\n                    if (!got_output) {\n\n                        /* no picture yet */\n\n                        av_freep(&decoded_frame);\n\n                        goto discard_packet;\n\n                    }\n\n                    ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts,\n\n                                                                 decoded_frame->pkt_dts);\n\n                    if (ist->st->codec->time_base.num != 0) {\n\n                        int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                        ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                          ist->st->codec->time_base.num * ticks) /\n\n                            ist->st->codec->time_base.den;\n\n                    }\n\n                    avpkt.size = 0;\n\n                    buffer_to_free = NULL;\n\n                    pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free);\n\n                    break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ret = avcodec_decode_subtitle2(ist->st->codec,\n\n                                               &subtitle, &got_output, &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                if (!got_output) {\n\n                    goto discard_packet;\n\n                }\n\n                subtitle_to_free = &subtitle;\n\n                avpkt.size = 0;\n\n                break;\n\n            default:\n\n                return -1;\n\n            }\n\n        } else {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                    ist->st->codec->sample_rate;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (ist->st->codec->time_base.num != 0) {\n\n                    int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                    ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                      ist->st->codec->time_base.num * ticks) /\n\n                        ist->st->codec->time_base.den;\n\n                }\n\n                break;\n\n            }\n\n            avpkt.size = 0;\n\n        }\n\n\n\n        // preprocess audio (volume)\n\n        if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_volume != 256) {\n\n                switch (ist->st->codec->sample_fmt) {\n\n                case AV_SAMPLE_FMT_U8:\n\n                {\n\n                    uint8_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128;\n\n                        *volp++ = av_clip_uint8(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_S16:\n\n                {\n\n                short *volp;\n\n                volp = samples;\n\n                for(i=0;i<(decoded_data_size / sizeof(short));i++) {\n\n                    int v = ((*volp) * audio_volume + 128) >> 8;\n\n                    *volp++ = av_clip_int16(v);\n\n                }\n\n                break;\n\n                }\n\n                case AV_SAMPLE_FMT_S32:\n\n                {\n\n                    int32_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8);\n\n                        *volp++ = av_clipl_int32(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_FLT:\n\n                {\n\n                    float *volp = samples;\n\n                    float scale = audio_volume / 256.f;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_DBL:\n\n                {\n\n                    double *volp = samples;\n\n                    double scale = audio_volume / 256.;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL,\n\n                           \"Audio volume adjustment on sample format %s is not supported.\\n\",\n\n                           av_get_sample_fmt_name(ist->st->codec->sample_fmt));\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* frame rate emulation */\n\n        if (input_files[ist->file_index].rate_emu) {\n\n            int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE);\n\n            int64_t now = av_gettime() - ist->start;\n\n            if (pts > now)\n\n                usleep(pts - now);\n\n        }\n\n        /* if output time reached then transcode raw format,\n\n           encode packets and output them */\n\n        for (i = 0; i < nb_ostreams; i++) {\n\n            OutputFile *of = &output_files[ost_table[i].file_index];\n\n            int frame_size;\n\n\n\n            ost = &ost_table[i];\n\n            if (ost->source_index != ist_index)\n\n                continue;\n\n\n\n            if (of->start_time && ist->pts < of->start_time)\n\n                continue;\n\n\n\n            if (of->recording_time != INT64_MAX &&\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time,\n\n                              (AVRational){1, 1000000}) >= 0) {\n\n                ost->is_past_recording_time = 1;\n\n                continue;\n\n            }\n\n\n\n#if CONFIG_AVFILTER\n\n            if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                ost->input_video_filter) {\n\n                AVRational sar;\n\n                if (ist->st->sample_aspect_ratio.num)\n\n                    sar = ist->st->sample_aspect_ratio;\n\n                else\n\n                    sar = ist->st->codec->sample_aspect_ratio;\n\n                av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar);\n\n                if (!(filtered_frame = avcodec_alloc_frame())) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto fail;\n\n                }\n\n            }\n\n            frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||\n\n                !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n            while (frame_available) {\n\n                AVRational ist_pts_tb;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter)\n\n                    get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb);\n\n                if (ost->picref)\n\n                    ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q);\n\n#else\n\n                filtered_frame = decoded_frame;\n\n#endif\n\n                os = output_files[ost->file_index].ctx;\n\n\n\n                /* set the input output pts pairs */\n\n                //ost->sync_ipts = (double)(ist->pts + input_files[ist->file_index].ts_offset - start_time)/ AV_TIME_BASE;\n\n\n\n                if (ost->encoding_needed) {\n\n                    av_assert0(ist->decoding_needed);\n\n                    switch(ost->st->codec->codec_type) {\n\n                    case AVMEDIA_TYPE_AUDIO:\n\n                        do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_VIDEO:\n\n#if CONFIG_AVFILTER\n\n                        if (ost->picref->video && !ost->frame_aspect_ratio)\n\n                            ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect;\n\n#endif\n\n                        do_video_out(os, ost, ist, filtered_frame, &frame_size,\n\n                                     same_quant ? quality : ost->st->codec->global_quality);\n\n                        if (vstats_filename && frame_size)\n\n                            do_video_stats(os, ost, frame_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_SUBTITLE:\n\n                        do_subtitle_out(os, ost, ist, &subtitle,\n\n                                        pkt->pts);\n\n                        break;\n\n                    default:\n\n                        abort();\n\n                    }\n\n                } else {\n\n                    AVPacket opkt;\n\n                    int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);\n\n\n\n                    av_init_packet(&opkt);\n\n\n\n                    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes)\n\n#if !CONFIG_AVFILTER\n\n                        continue;\n\n#else\n\n                        goto cont;\n\n#endif\n\n\n\n                    /* no reencoding needed : output the packet directly */\n\n                    /* force the input stream PTS */\n\n\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                        audio_size += data_size;\n\n                    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                        video_size += data_size;\n\n                        ost->sync_opts++;\n\n                    }\n\n\n\n                    opkt.stream_index= ost->index;\n\n                    if(pkt->pts != AV_NOPTS_VALUE)\n\n                        opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;\n\n                    else\n\n                        opkt.pts= AV_NOPTS_VALUE;\n\n\n\n                    if (pkt->dts == AV_NOPTS_VALUE)\n\n                        opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base);\n\n                    else\n\n                        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);\n\n                    opkt.dts -= ost_tb_start_time;\n\n\n\n                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n\n                    opkt.flags= pkt->flags;\n\n\n\n                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n\n                    if(   ost->st->codec->codec_id != CODEC_ID_H264\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO\n\n                       ) {\n\n                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))\n\n                            opkt.destruct= av_destruct_packet;\n\n                    } else {\n\n                        opkt.data = data_buf;\n\n                        opkt.size = data_size;\n\n                    }\n\n\n\n                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);\n\n                    ost->st->codec->frame_number++;\n\n                    ost->frame_number++;\n\n                    av_free_packet(&opkt);\n\n                }\n\n#if CONFIG_AVFILTER\n\n                cont:\n\n                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n\n                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n                if (ost->picref)\n\n                    avfilter_unref_buffer(ost->picref);\n\n            }\n\n            av_freep(&filtered_frame);\n\n#endif\n\n            }\n\n\n\nfail:\n\n        av_free(buffer_to_free);\n\n        /* XXX: allocate the subtitles in the codec ? */\n\n        if (subtitle_to_free) {\n\n            avsubtitle_free(subtitle_to_free);\n\n            subtitle_to_free = NULL;\n\n        }\n\n        av_freep(&decoded_frame);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n discard_packet:\n\n\n\n    return 0;\n\n}\n", "idx": 7808, "substitutes": {"ist": ["isi", "dr", "est", "et", "sett", "ace", "pop", "isd", "ard", "ski", "ft", "pect", "ht", "ick", "gd", "ess", "ast", "nd", "pick", "irst", "irc", "gest", "nt", "osi", "ism", "edit", "art", "pt", "at", "mot", "it", "dist", "sth", "ait", "ctx", "work", "sta", "iste", "ld", "istor", "er", "act", "dit", "ad", "ext", "att", "adder", "wd", "imet", "rss", "lda", "inst", "ant", "feat", "ic", "start", "ind", "IST", "tt", "set", "ush", "add", "aint", "ists", "ict", "rest", "kt", "part", "uss", "artist", "xt", "alist", "empt"], "ist_index": ["est_type", "est_Index", "est_index", "est_address", "ist_Index", "ist_type", "ist_address"], "ost_table": ["ast_stream", "ast_table", "ost_stream", "ast_db", "ast_cache", "ost_cache", "ost_db"], "nb_ostreams": ["nb_ostields", "nb_oststreams", "nb_octstreamses", "nb_ostucs", "nb_ostieldd", "nb_ostieldses", "nb_octstreamb", "nb_oststreamb", "nb_octreamb", "nb_octstreamd", "nb_ostucses", "nb_ostreamb", "nb_oststreamd", "nb_octreamses", "nb_ostieldb", "nb_ostreamses", "nb_oststreamses", "nb_octstreams", "nb_octreams", "nb_ostucd", "nb_ostucb", "nb_octreamd", "nb_ostreamd"], "pkt": ["compacket", "cpkt", " pwk", "perdt", "punct", " pnt", "Pcht", "opcht", "pernt", "pqt", "spnt", "apacket", " pdt", "cpunct", "apeth", "apcht", "spqt", "opdt", "spct", "compcht", "apelt", "perkt", "cpacket", "compkt", "peth", "dpct", " punct", "cpelt", "spelt", "fnt", "dpkt", " peth", "pwk", "npacket", "facket", "apkt", "Packet", "Pelt", "spkt", "apnt", "apunct", "tpkt", " pcht", "packet", "pelt", "mcht", "Pqt", "npcht", "tpacket", " pqt", "opnt", "percht", "Pnt", "fcht", "tpnt", "Pwk", "compqt", "pdt", "pnt", "fkt", "feth", "mkt", "npkt", "Pkt", "fwk", "pct", "dpacket", "dpcht", "macket", " pelt", "npnt", "mnt", "pcht", "tpcht", " pct", "fqt", "Pct", "spacket", "fct", " packet"], "os": ["ot", "as", "osc", "ocr", "o", "is", "osi", "oS", "op", "io", "sys", "pc", "us", "cs", "ops", "ol", "ds", "OS", "oss", "ox", "pos", "fs", "acs", "bos", "ms", "oid", "oos"], "ost": ["ot", "oc", "irst", "aud", "od", "nt", "osi", "op", "opp", "ott", "OST", "org", "ont", "mot", "mt", "sth", "oss", "opt", "oper", "proc", "oid", "tt", "ast", "osp"], "ret": ["stat", "gc", "flag", "reg", "mem", "val", "nc", "final", "rc", "reply", " RET", "fin", " resp", "res", "sent", "mt", "RET", "cb", "result", "seq", "Ret", "fun", "resp", "success", "rep"], "i": ["ei", "ti", "id", "I", "ci", "ni", "b", "si", "slice", "abi", "info", "qi", "f", "j", "ii", "iu", "it", "cli", "n", "mi", "ini", "p", "c", "ip", "li", "inner", "index", "ui"], "got_output": ["gotamvideo", " got_information", "gotamoutput", "got_image", "gotaminformation", "gotayoutput", "sent_image", "sent_output", "got_input", "got_video", " got_video", "gotayvideo", "gotayinformation", "got_information", "sent_input"], "buffer_to_free": ["buffer_to_zero", "buffer_from_size", "buffer_from_zero", "buffer_to_size", "buffer_from_free", "buffer_to_used", "buffer_from_used"], "subtitle": ["Subscript", "SubTitle", "subscript", " subscriptionTitle", " subscriptiontitle", " subTitle", "subTitle", "Subtitle", " subscriptionscript", " subscript"], "subtitle_to_free": ["subtitle_from_used", "subtitle_from_free", "subtitle_to_Free", "subtitle_to_used", "subtitle_from_Free"], "frame_available": [" frame_supported", "frame__available", " frame_length", "frame_length", "frame__supported", "frame__length", "frame_supported", "frame__info", "frame_info", " frame_info"], "quality": [" qual", " fps", " fa", " quiet", " gain", " disp", " gamma", " progress", " quota", "f", " rc", " resolution", " resp", "q", " fl", "len", " reliability", " error", " compression", "fps", "scale", "qa", " Quality", " clip", "Quality", " scale", " seq"], "avpkt": ["avipsk", "avipkt", "avfce", "avpce", "avPunt", "avcpdr", "avppte", "avlpkt", " avpacket", "avecpdr", "avPkt", "avfte", "avgunch", "avcpacket", "AVPct", "afpsk", "avbiece", "avpqt", " avppacket", "afpacket", "avtpkt", " avtpkat", "avppsk", "avopacket", "avgacket", "affce", "affcht", "avncht", "avnpcht", "avbct", "avfcht", "avPacket", "AVpkt", "avopkt", "avnpacket", "avfdr", "avfkt", " avppkt", " avppnt", "avtpcht", "avPct", " avtpkt", " avpunch", "affkt", "avpect", "avppnt", "avlpunt", "avtpkat", "avpunt", "avpsk", "avgnt", "afpce", "avfnt", "avpdr", "avpeiece", "afpnt", "avfacket", "avnpnt", "avecpacket", "avopqt", "AVPkg", "AVPunt", "avopdr", "AVPkt", "avpekg", "AVpunt", "avfunt", "avpct", "avfsk", "avpiece", "avppkt", " avtpqt", "avnpce", "avepacket", "avlpacket", "AVpacket", "AVPiece", "avcpcht", "avpunch", "avnacket", "avopcht", "avpte", "avecpkt", "affsk", "avPiece", "AVpkg", "avecpnt", "avnkt", "avipte", " avtpcht", "AVpct", "affnt", "afpcht", "avpacket", "avpekt", "avppunch", "avbkt", "avopkat", "affte", "afpte", "avipacket", "avlpct", "avcpqt", "avpnt", "avnpkt", "AVPacket", "avcpce", "avgkt", "afpkt", "avcpkt", " avpqt", "avpkat", "AVpiece", "avepdr", "avbkg", "avepnt", "avPkg", "avtpqt", "avopnt", " avpcht", "avpkg", "avnnt", " avppunch", "avfunch", "avpcht", "avcpkat", "avppacket", " avpkat", "avfct", "avepkt", "avcpnt", "affacket", " avpnt"], "data_buf": [" data_buff", " data_length", "data_buffer", "data_length", "data_buff", "datasbuf", "datasbuff", " data_buffer", "datasbuffer", "dataslength"], "decoded_data_buf": ["decoded_data_uf", "decoded_data_buffer", "decoded_data_buff"], "data_size": ["data__sized", "data96small", "parent__size", "parent_size", "data_sent", "parent__sized", "data_sized", "data__size", "data__small", "data96sent", "data96size", "parent__small", "data_small", "data96sized", "parent_sized", "parent_small", "parent__sent", "data__sent", "parent_sent"], "decoded_data_size": ["decoded_window_type", "decoded_window_size", "decoded_window_len", "decoded_data_type", "decoded_data_len"], "decoded_frame": ["decoded_position", "decoded_fram", "decoded___frame", "decoded___fram", "decrypted_fram", "decrypted_frame", "decrypted_position", "decoded___position"], "filtered_frame": ["filoded_frames", "filteredbylive", "filoded_frame", "filteredbyframes", "filteredbyframe", "filtered_channel", "filteredbychannel", "filoded_live", "filoded_channel", "filtered_live", "filtered_frames"], "st": ["std", "dr", "est", "fr", "ste", "irst", "gest", "store", "sty", "stack", "stream", "ust", "stress", "sts", "spect", "cl", "rest", "sm", "sl", "St", "ce", "stand", "sc", "inst", "stem", "sd", "ST", "str", "sta", "stage", "start", "step", "ld", "ast", "ct", "put", "src", "set", "stri", "nd", "stim"], "codec": ["predec", "codedc", "Codocol", "Coddc", "codeEC", "codeocol", "predEC", "codocol", "codEC", "CodEC", "coddc", "preddc", "predocol", "codeec", "Codec"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        int l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 7814, "substitutes": {"ctx": ["cp", "cmp", "cgi", "gc", "anc", "hw", "ocr", "cfg", "la", "component", "ci", "gru", "config", "qt", "nc", "rc", "cca", "sync", "cus", "concept", "gpu", "loc", "cm", "tx", "mac", "cl", "client", "conv", "pc", "cc", "sci", "cs", "cli", "crit", "kt", "ck", "sc", "connection", "cam", "conn", "dc", "cmd", "wcs", "bc", "cu", "cms", "Context", "cb", "exec", "fp", "context", "input", "jp", "kw", "ca", "qa", "req", "kb", "c", "ct", "cn", "cf", "fc", "cv", "vc", "git", "cpp", "cas", "ctrl", "pkg", "xc", "tc"], "t0": ["T2", "p6", "l4", "i0", "tf1", "type0", "ti0", "i00", "l0", " t4", "TZero", " t8", "p2", "l2", "T0", "T6", "t4", " t1", "ti00", "T1", "i1", "type1", "l1", " T00", " t6", "tf0", "tf2", "p1", "t1", "p0", "T00", "T4", "tfZero", "ti1", " t2", " tZero", "t6", "tZero", "ti8", " T1", "i8", " T0", " t00", "t00", "type00", "t2", "t8"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n", "idx": 7828, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)\n\n{\n\n    int i;\n\n    uint32_t state= pc->state;\n\n\n\n    /* EOF considered as end of frame */\n\n    if (buf_size == 0)\n\n        return 0;\n\n\n\n/*\n\n 0  frame start         -> 1/4\n\n 1  first_SEQEXT        -> 0/2\n\n 2  first field start   -> 3/0\n\n 3  second_SEQEXT       -> 2/0\n\n 4  searching end\n\n*/\n\n\n\n    for(i=0; i<buf_size; i++){\n\n        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);\n\n        if(pc->frame_start_found&1){\n\n            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n\n                pc->frame_start_found--;\n\n            else if(state == EXT_START_CODE+2){\n\n                if((buf[i]&3) == 3) pc->frame_start_found= 0;\n\n                else                pc->frame_start_found= (pc->frame_start_found+1)&3;\n\n            }\n\n            state++;\n\n        }else{\n\n            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;\n\n            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n\n                i++;\n\n                pc->frame_start_found=4;\n\n            }\n\n            if(state == SEQ_END_CODE){\n\n                pc->state=-1;\n\n                return i+1;\n\n            }\n\n            if(pc->frame_start_found==2 && state == SEQ_START_CODE)\n\n                pc->frame_start_found= 0;\n\n            if(pc->frame_start_found<4 && state == EXT_START_CODE)\n\n                pc->frame_start_found++;\n\n            if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n\n                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 7834, "substitutes": {"pc": ["roc", "uc", "pm", "mp", "pac", "con", "func", "bc", "cu", "cms", "ec", "PC", "ca", "proc", "ct", "lc", "ac", "pb", "conn", "tc", "cp", "icc", "plugin", "cur", "spec", "config", "nc", "wp", "server", "mc", "sc", "cam", "ctx", "parse", "amp", "cf", "cod", "pl", "bp", "sec", "rc", "sync", "cca", "co", "px", "inc", "cl", "post", "py", "cc", "cs", "ck", "p", "ic", "gb", "c", "can", "api", "vc", "cache", "anc", "cr", "pd", "cus", "enc", "comp", "sys", "mac", "client", "arc", "jc", "dc", "fc", "cz", "xc"], "buf": ["base", "feed", "buff", "vec", "header", "block", "v", "box", "Buff", "rb", "config", "b", "data", "rc", "queue", "bi", "map", "loc", "grab", "uc", "fb", "uf", "num", "offset", "f", "conv", "ucc", "length", "buffer", "len", "que", "bag", "port", "cmd", "ctx", "bc", "cb", "feat", "ab", "context", "seq", "pool", "border", "batch", "frame", "gb", "alloc", "pos", "proc", "off", "head", "fd", "cf", "br", "cv", "text", "pb", "fi", "src", "img", "bh", "ff"], "buf_size": ["bufxlen", "bufxoffset", "buf8ize", "buf_sized", "uf_sized", "buf_len", "bufallsize", "buffer_ize", "buffer_size", "buflensize", " buf_width", "buflencode", "flowlencode", "flow_len", "buffer_shape", "flow_code", "uf_loc", "buf8scale", "buf_code", " buf_ize", "buf_scale", "bufqize", "flow_size", "flowlenlen", "bufxsize", "buflenlen", "buf8shape", "bufqsize", "bufqscale", "buffer_scale", "flowlensize", "uf_scale", "buf_width", "bufxcode", "bufallwidth", "buflenoffset", "uf_size", "flowlenoffset", "buf_offset", "buf8size", "buf_shape", "bufallize", "buf_loc", "flow_offset", "buf_ize", "bufqshape"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "chi", "di", "ci", "ni", "x", "b", "si", "io", "xi", "ri", "slice", "info", "bi", "m", "abi", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "iu", "ii", "esi", "it", "ai", "cli", "u", "e", "ami", "uri", "n", "multi", "mi", "ini", "ie", "p", "h", "eni", "start", "hi", "ind", "ip", "c", "li", "inner", "fi", "index", "zi", "ui"], "frame_start_found": ["frame_start__new", "frame_baseenprinted", "frame_start_left", "frame_startsfound", "frame_startAcof", "frame_startPbound", "frame_end_finding", "frame_scaleernew", "frame_starternew", "frame_startAllmissing", "frame_start_Found", "frame_end_given", "frame_startFbroken", "frame_start__to", "frame_end_find", "frame_end_missing", "frame_startAcfound", "frame_end_used", "frame_starting_matched", "frame_size_broken", "frame_scale_found", "frame_start_old", "frame_base_found", "frame_start___loaded", "frame_end_found", "frame_base_called", "frame_starting_of", "frame_startMfound", "frame_scaleerto", "frame_end_length", "frame_start__finder", "frame_startPfound", "frame_size_find", "frame_start_built", "frame_start_find", "frame_start_printed", "frame_start___found", "frame_startPold", "frame_starterfound", "frame_startedbuilt", "frame_start_finding", "frame_end_old", "frame_size_found", "frame_end_Found", "frame_base_printed", "frame_end_matched", "frame_startencalled", "frame_startNfind", "frame_size_Found", "frame_startAcmatched", "frame_start_loaded", "frame_end_finder", "frame_start_finished", "frame_startenfound", "frame_start_new", "frame_startxFound", "frame_startingFmatched", "frame_starting_found", "frame_startFFound", "frame_startNfound", "frame_startNlength", "frame_base_finder", "frame_start_bound", "frame_start_length", "frame_baseenfound", "frame_sizeFFound", "frame_scale_used", "frame_startMgiven", "frame_start__used", "frame_start__left", "frame_scaleerused", "frame_sizeFfound", "frame_starterused", "frame_startxfound", "frame_end_sent", "frame_starterto", "frame_start_to", "frame_startingFof", "frame_start_available", "frame_end_left", "frame_startqgiven", "frame_start___old", "frame_startFfind", "frame_baseenfinder", "frame_startqfound", "frame_startMfinding", "frame_startNFound", "frame_start_broken", "frame_end_loaded", "frame_start_missing", "frame_startFof", "frame_startingFfound", "frame_startqfinding", "frame_start_given", "frame_baseencalled", "frame_startenprinted", "frame_scaleerfound", "frame_sizeFfind", "frame_startPFound", "frame_start_of", "frame_startxmatched", "frame_startAllFound", "frame_start_finder", "frame_scale_to", "frame_start_matched", "frame_startscreated", "frame_start_called", "frame_sizeFbroken", "frame_end_available", "frame_end_finished", "frame_scale_new", "frame_startFmatched", "frame_startedfound", "frame_startedused", "frame_start_sent", "frame_startFfound", "frame_start_created", "frame_startAllfound", "frame_start_used", "frame_startenfinder", "frame_startsFound", "frame_start__found", "frame_end_bound", "frame_startPfinding", "frame_start___Found", "frame_end_built", "frame_startPloaded"], "state": ["statement", "position", "ci", "shape", "force", "style", "unit", "status", "ace", "region", "private", "pi", "code", "via", "error", "any", "err", "self", "color", "head", "ct", "g", "current", "index", "mode", "name", "st", "cur", "id", "count", "parent", "spec", "shadow", "value", "config", "update", "val", "see", "slice", "pe", "ate", "states", "cal", "grade", "port", "State", "str", "old", "scale", "un", "rule", "back", "range", "new", "type", "addr", "size", "patch", "stat", "address", "area", "reg", "STATE", "rc", "use", "sync", "wa", "loc", "key", "version", "j", "e", "sb", "message", "instance", "me", "source", "p", "run", "start", "pos", "pose", "c", "ind", "cache", "next", "set", "r", "seed", "trace", "ch", "o", "pr", "scope", "session", "si", "body", "in", "tag", "l", "resource", "order", "call", "length", "handle", "part", "direction", "none", "step", "inner"]}}
{"project": "FFmpeg", "commit_id": "0f8d3d8a462c0152ac489dbb013f6df027edd6c4", "target": 0, "func": "static av_cold int encode_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    int i, j, k, m, ret;\n\n\n\n    if ((ret = ff_ffv1_common_init(avctx)) < 0)\n\n        return ret;\n\n\n\n    s->version = 0;\n\n\n\n    if ((avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||\n\n        avctx->slices > 1)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability\n\n    if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    if (avctx->level <= 0 && s->version == 2) {\n\n        s->version = 3;\n\n    }\n\n    if (avctx->level >= 0 && avctx->level <= 4) {\n\n        if (avctx->level < s->version) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Version %d needed for requested features but %d requested\\n\", s->version, avctx->level);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        s->version = avctx->level;\n\n    }\n\n\n\n    if (s->ec < 0) {\n\n        s->ec = (s->version >= 3);\n\n    }\n\n\n\n    if ((s->version == 2 || s->version>3) && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n#if FF_API_CODER_TYPE\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->coder_type != -1)\n\n        s->ac = avctx->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE;\n\n    else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (s->ac == 1) // Compatbility with common command line usage\n\n        s->ac = AC_RANGE_CUSTOM_TAB;\n\n    else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE)\n\n        s->ac = AC_RANGE_DEFAULT_TAB;\n\n\n\n    s->plane_count = 3;\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV420P9:\n\n    case AV_PIX_FMT_YUVA444P9:\n\n    case AV_PIX_FMT_YUVA422P9:\n\n    case AV_PIX_FMT_YUVA420P9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GRAY10:\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n    case AV_PIX_FMT_YUVA444P10:\n\n    case AV_PIX_FMT_YUVA422P10:\n\n    case AV_PIX_FMT_YUVA420P10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GRAY12:\n\n    case AV_PIX_FMT_YUV444P12:\n\n    case AV_PIX_FMT_YUV420P12:\n\n    case AV_PIX_FMT_YUV422P12:\n\n        s->packed_at_lsb = 1;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n    case AV_PIX_FMT_YUVA444P16:\n\n    case AV_PIX_FMT_YUVA422P16:\n\n    case AV_PIX_FMT_YUVA420P16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = 16;\n\n        } else if (!s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        }\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YA8:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV410P:\n\n    case AV_PIX_FMT_YUVA444P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;\n\n        s->colorspace = 0;\n\n        s->transparency = desc->nb_components == 4 || desc->nb_components == 2;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB32:\n\n        s->colorspace = 1;\n\n        s->transparency = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB48:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 16;\n\n        s->use32bit = 1;\n\n        s->version = FFMAX(s->version, 1);\n\n        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n            av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n    case AV_PIX_FMT_0RGB32:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_GBRP9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GBRP10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GBRP12:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GBRP14:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 14;\n\n    case AV_PIX_FMT_GBRP16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 16;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        if (s->bits_per_raw_sample >= 16) {\n\n            s->use32bit = 1;\n\n            if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n                av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n    av_assert0(s->bits_per_raw_sample >= 8);\n\n\n\n    if (s->bits_per_raw_sample > 8) {\n\n        if (s->ac == AC_GOLOMB_RICE) {\n\n            av_log(avctx, AV_LOG_INFO,\n\n                    \"bits_per_raw_sample > 8, forcing range coder\\n\");\n\n            s->ac = AC_RANGE_CUSTOM_TAB;\n\n        }\n\n    }\n\n    if (s->transparency) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");\n\n    }\n\n#if FF_API_PRIVATE_OPT\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->context_model)\n\n        s->context_model = avctx->context_model;\n\n    if (avctx->context_model > 1U) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->context_model);\n\n        return AVERROR(EINVAL);\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (s->ac == AC_RANGE_CUSTOM_TAB) {\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = ver2_state[i];\n\n    } else {\n\n        RangeCoder c;\n\n        ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8);\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = c.one_state[i];\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        s->quant_table_count = 2;\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            s->quant_tables[0][0][i]=           quant11[i];\n\n            s->quant_tables[0][1][i]=        11*quant11[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant11[i];\n\n            s->quant_tables[1][0][i]=           quant11[i];\n\n            s->quant_tables[1][1][i]=        11*quant11[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5 [i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5 [i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];\n\n        } else {\n\n            s->quant_tables[0][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[0][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];\n\n            s->quant_tables[1][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[1][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];\n\n        }\n\n    }\n\n    s->context_count[0] = (11 * 11 * 11        + 1) / 2;\n\n    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;\n\n    memcpy(s->quant_table, s->quant_tables[s->context_model],\n\n           sizeof(s->quant_table));\n\n\n\n    for (i = 0; i < s->plane_count; i++) {\n\n        PlaneContext *const p = &s->plane[i];\n\n\n\n        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));\n\n        p->quant_table_index = s->context_model;\n\n        p->context_count     = s->context_count[p->quant_table_index];\n\n    }\n\n\n\n    if ((ret = ff_ffv1_allocate_initial_states(s)) < 0)\n\n        return ret;\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (!s->transparency)\n\n        s->plane_count = 2;\n\n    if (!s->chroma_planes && s->version > 3)\n\n        s->plane_count--;\n\n\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);\n\n    s->picture_number = 0;\n\n\n\n    if (avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) {\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            s->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                        sizeof(*s->rc_stat2[i]));\n\n            if (!s->rc_stat2[i])\n\n                return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    if (avctx->stats_in) {\n\n        char *p = avctx->stats_in;\n\n        uint8_t (*best_state)[256] = av_malloc_array(256, 256);\n\n        int gob_count = 0;\n\n        char *next;\n\n        if (!best_state)\n\n            return AVERROR(ENOMEM);\n\n\n\n        av_assert0(s->version >= 2);\n\n\n\n        for (;;) {\n\n            for (j = 0; j < 256; j++)\n\n                for (i = 0; i < 2; i++) {\n\n                    s->rc_stat[j][i] = strtol(p, &next, 0);\n\n                    if (next == p) {\n\n                        av_log(avctx, AV_LOG_ERROR,\n\n                               \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);\n\n                        av_freep(&best_state);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    p = next;\n\n                }\n\n            for (i = 0; i < s->quant_table_count; i++)\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    for (k = 0; k < 32; k++)\n\n                        for (m = 0; m < 2; m++) {\n\n                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);\n\n                            if (next == p) {\n\n                                av_log(avctx, AV_LOG_ERROR,\n\n                                       \"2Pass file invalid at %d %d %d %d [%s]\\n\",\n\n                                       i, j, k, m, p);\n\n                                av_freep(&best_state);\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            p = next;\n\n                        }\n\n                }\n\n            gob_count = strtol(p, &next, 0);\n\n            if (next == p || gob_count <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");\n\n                av_freep(&best_state);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            p = next;\n\n            while (*p == '\\n' || *p == ' ')\n\n                p++;\n\n            if (p[0] == 0)\n\n                break;\n\n        }\n\n        if (s->ac == AC_RANGE_CUSTOM_TAB)\n\n            sort_stt(s, s->state_transition);\n\n\n\n        find_best_state(best_state, s->state_transition);\n\n\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            for (k = 0; k < 32; k++) {\n\n                double a=0, b=0;\n\n                int jp = 0;\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    double p = 128;\n\n                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) {\n\n                        if (a+b)\n\n                            p = 256.0 * b / (a + b);\n\n                        s->initial_states[i][jp][k] =\n\n                            best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                        for(jp++; jp<j; jp++)\n\n                            s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k];\n\n                        a=b=0;\n\n                    }\n\n                    a += s->rc_stat2[i][j][k][0];\n\n                    b += s->rc_stat2[i][j][k][1];\n\n                    if (a+b) {\n\n                        p = 256.0 * b / (a + b);\n\n                    }\n\n                    s->initial_states[i][j][k] =\n\n                        best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                }\n\n            }\n\n        }\n\n        av_freep(&best_state);\n\n    }\n\n\n\n    if (s->version > 1) {\n\n        int plane_count = 1 + 2*s->chroma_planes + s->transparency;\n\n        s->num_v_slices = (avctx->width > 352 || avctx->height > 288 || !avctx->slices) ? 2 : 1;\n\n\n\n        if (avctx->height < 5)\n\n            s->num_v_slices = 1;\n\n\n\n        for (; s->num_v_slices < 32; s->num_v_slices++) {\n\n            for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {\n\n                int maxw = (avctx->width  + s->num_h_slices - 1) / s->num_h_slices;\n\n                int maxh = (avctx->height + s->num_v_slices - 1) / s->num_v_slices;\n\n                if (s->num_h_slices > avctx->width || s->num_v_slices > avctx->height)\n\n                    continue;\n\n                if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24)\n\n                    continue;\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= MAX_SLICES || !avctx->slices)\n\n                    goto slices_ok;\n\n            }\n\n        }\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        if ((ret = write_extradata(s)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if ((ret = ff_ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    s->slice_count = s->max_slice_count;\n\n    if ((ret = ff_ffv1_init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & AV_CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        if (!avctx->stats_out)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->max_slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7852, "substitutes": {"avctx": ["avecv", " avcf", "avalctrl", " avcoll", "avalwcs", "avehw", "afctrl", "afca", "avercontext", "avecoll", "vercu", "alctx", "avalcoll", "aveconfig", "afctx", "AVctl", "afclient", "avclient", "aveca", "ajctx", "averchan", "afwcs", "avconv", " avcontext", "afcit", "avca", "avecit", "avalsync", " avca", " avconfig", "airctx", "afcv", "avcmd", "avhw", "avecus", "afcmp", " avchan", "avcmp", "avecca", "aircf", "ajcmd", "avcv", "avalpkg", "avalctx", "AVcmp", "ajcu", "avewcs", "aveconn", "avecontext", "afcf", "avlc", "avchan", "AVconfig", "avctrl", "AVcu", "ajwcs", "avecu", "avbc", "avelc", "avalcontext", "afhw", "ajcf", "avsync", "avalclient", "ajconv", "aflc", "ajclient", "afctl", " avcus", "vercontext", "ajsync", "avcu", " avhw", "avconfig", "AVcontext", "averctx", "ajpkg", "ajcit", "afcmd", "aveconv", "avcca", "afsync", "avcontext", "afpkg", "afcoll", "avcus", "AVcca", "ajctrl", "verlc", "averconn", "avecmd", "avallc", " avpkg", "alctl", "avconn", "ajconn", "alcontext", "avctl", "afconv", "verconn", "avectx", "avepkg", "ajcv", "AVctx", "avcoll", "avebc", "avcf", "airca", "afcus", "avecf", "afbc", "avcit", "verctx", "avwcs", "aircontext", "afconn", "avpkg", "afchan", "afcontext", "alcmp", "afconfig", "ajcontext", " avconn", "avalbc", "afcca", "afcu"], "s": ["S", "b", "f", "d", "service", "hs", "w", "self", "aws", "sa", "g", "sym", "y", "sets", "sites", "is", "spec", "services", "its", "sl", "ls", "sc", "ops", "bis", "ds", "ts", "settings", "fs", "new", "sq", "ms", "site", "rs", "ins", "sg", "sync", "ses", "cs", "e", "sb", "secondary", "t", "qs", "css", "os", "ssl", "ims", "sup", "ps", "o", "v", "less", "session", "si", "sys", "l", "xs", "ns", "stats", "args", "us", "ss", "gs", "full", "storage", "n", "su", "es", "js"], "desc": ["sub", "name", "sec", "acc", " Desc", "rc", "enc", "info", "de", "meta", "description", " description", "def", "Desc", "des", "dir", "sc", "en", "dc", "esc", "path", "ca", "doc", "asc", "text", "summary", "rec"], "i": ["v", "I", "a", "is", "ci", "ni", "x", "b", "si", "info", "l", "f", "pi", "d", "ii", "ai", "n", "mi", "z", "ip", "index", "r"], "j": ["o", "v", "ji", "b", "si", "kj", "l", "ij", "ii", "d", "q", "J", "n", "uj", "ie", "h", "z", "pos", "g", "im", "y", "r"], "k": ["o", "v", "ik", "ki", "kk", "key", "sk", "K", "f", "dk", "q", "u", "km", "e", "ak", "w", "ks", "n", "kw", "h", "z", "ke", "y"], "m": ["o", "dm", "v", "gm", "md", "M", "l", "f", "mp", "d", "u", "e", "mt", "mc", "t", "n", "mi", "fm", "h", "mr", "mm", "g", "y", "ms", "r", "cm"], "ret": ["dr", "red", "reg", "mem", "al", "cur", "alt", "nt", "value", "val", "tr", "rc", "bit", "cat", "reply", " RET", "num", " Ret", "f", "lit", "att", "obj", "arg", "res", "bad", "match", "def", "len", "mt", "det", "arr", "RET", "t", "mi", "result", "Ret", "re", "fun", "back", "utf", "success", "ref", "aux", "no", "r", "rec", "rets"], "coder_type": ["coder_num", "coding_count", "coder_id", "coding_style", "coding_num", "coder_count", "coding_id", "coder_style", "coding_type"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARSS", "FF_ENABLE_DEPRECATION_WARES", "FF_ENABLE_DEPRECATION_ERRORs", "FF_ENABLE_DEPRECATION_ERRORES", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNINGES", "FF_ENABLE_DEPRECATION_WARNINGSS", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_ERRORS", "FF_ENABLE_DEPRECATION_ERRORSS"]}}
{"project": "FFmpeg", "commit_id": "d85aa76115214183e7e3b7d65e950da61474959a", "target": 0, "func": "static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)\n\n{\n\n    const uint8_t *data = nal->data;\n\n    int length          = nal->size;\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int64_t offset;\n\n    int startheader, cmpt = 0;\n\n    int i, j, res = 0;\n\n\n\n    if (!ret || !arg) {\n\n        av_free(ret);\n\n        av_free(arg);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n\n\n    if (!s->sList[1]) {\n\n        ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);\n\n\n\n\n\n        for (i = 1; i < s->threads_number; i++) {\n\n            s->sList[i] = av_malloc(sizeof(HEVCContext));\n\n            memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));\n\n            s->sList[i]->HEVClc = s->HEVClcList[i];\n\n        }\n\n    }\n\n\n\n    offset = (lc->gb.index >> 3);\n\n\n\n    for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) {\n\n        if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n            startheader--;\n\n            cmpt++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < s->sh.num_entry_point_offsets; i++) {\n\n        offset += (s->sh.entry_point_offset[i - 1] - cmpt);\n\n        for (j = 0, cmpt = 0, startheader = offset\n\n             + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) {\n\n            if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n                startheader--;\n\n                cmpt++;\n\n            }\n\n        }\n\n        s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt;\n\n        s->sh.offset[i - 1] = offset;\n\n\n\n    }\n\n    if (s->sh.num_entry_point_offsets != 0) {\n\n        offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;\n\n        if (length < offset) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"entry_point_offset table is corrupted\\n\");\n\n            res = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;\n\n        s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;\n\n\n\n    }\n\n    s->data = data;\n\n\n\n    for (i = 1; i < s->threads_number; i++) {\n\n        s->sList[i]->HEVClc->first_qp_group = 1;\n\n        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;\n\n        memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n        s->sList[i]->HEVClc = s->HEVClcList[i];\n\n    }\n\n\n\n    avpriv_atomic_int_set(&s->wpp_err, 0);\n\n    ff_reset_entries(s->avctx);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {\n\n        arg[i] = i;\n\n        ret[i] = 0;\n\n    }\n\n\n\n    if (s->ps.pps->entropy_coding_sync_enabled_flag)\n\n        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++)\n\n        res += ret[i];\n\nerror:\n\n    av_free(ret);\n\n    av_free(arg);\n\n    return res;\n\n}\n", "idx": 7854, "substitutes": {"s": ["sf", "S", "a", "b", "f", "parts", "d", "service", "bs", "conf", "w", "self", "h", "aws", "sa", "g", "sym", "sets", "sites", "is", "spec", "services", "its", "states", "https", "server", "sl", "ls", "sh", "sc", "sie", "ops", "ds", "ctx", "ts", "outs", "south", "settings", "sv", "fs", "sq", "site", "rs", "size", "strings", "sr", "ins", "nas", "sg", "comments", "sync", "ses", "ions", "sci", "cs", "u", "sis", "e", "an", "sb", "ks", "qs", "t", "p", "c", "os", "ssl", "r", "ps", "o", "v", "session", "si", "sys", "m", "in", "l", "xs", "ns", "stats", "us", "ss", "gs", "full", "su", "this", "es", "js"], "nal": ["neal", "wals", "NAL", " naf", "nanals", "anals", " nali", "unal", "Nul", " nals", "Nali", "nul", " neal", "signals", "naler", "nanal", "Neal", "wAL", "Nale", " naler", "unals", "naf", " nul", "signal", "Nal", "naneal", "nanul", "analer", "nAL", "signAL", "Naler", "signul", "unale", "Nals", "waf", "nals", " nale", "anul", "wal", "signali", "unali", "nali", "nale", "anal", "Naf", " nAL"], "data": ["address", "padding", "buff", "mem", "block", "a", "dat", "device", "val", "sum", "wa", "queue", "info", "m", "image", "body", "map", "buf", "window", "capacity", "results", "f", "content", "d", "length", "DATA", "buffer", "len", "all", "ops", "arr", "da", "Data", "bytes", "result", "p", "array", "input", "batch", "frame", "start", "pointer", "pos", "memory", "new", "cache", "next", "index", "rec"], "lc": ["LC", "lb", "la", "ci", "lan", "cus", "nc", "si", "sys", "lp", "l", "cl", "ls", "pc", "cli", "cs", "acl", "mc", "sb", "sc", "jc", "dc", "lic", "lib", "lu", "ctx", "bc", "ctrl", "gb", "ln", "c", "kl", "sa", "wl", "lv", "fc", "cow", "lf", "cm"], "ret": ["red", "reg", "flag", "rt", "mem", "alt", "nt", "val", "tr", "rc", "rf", "cat", "art", "info", "reply", "valid", "lit", "ext", "att", "length", "args", "obj", "res", "def", "part", "len", "det", "arr", "RET", "feat", "rev", "result", "seq", "pub", "req", "Ret", "ft", "re", "fun", "bf", "desc", "ref", "fi", "success", "r", "rets", "af"], "arg": ["aug", "flag", "reg", "sec", "ann", "arm", "ag", "config", "bug", "val", "b", "ax", "enc", "bit", "ad", "art", "cat", "ray", "loc", "ace", "inc", "mac", "argument", "weight", "args", "ack", "param", "arc", "len", "ar", "target", "error", "arr", "pass", "feat", "amp", "ark", "Arg", "doc", "var", "g", "ac", "ref", "au", "addr", "par", "conn"], "offset": ["position", "padding", "reset", "a", "entry", "f", "align", "byte", "len", "error", "elta", "array", "off", "index", "optional", "slot", "base", "row", "axis", "header", "count", "value", "val", "slice", "info", "office", "url", "limit", "range", "type", "addr", "end", "size", "address", "area", "alpha", "offs", "gap", "loc", "image", "olerance", "uple", "section", "online", "timeout", "start", "pos", "location", "api", "ref", "set", "o", "skip", "Offset", "length", "margin", "part", "ptr", "pointer", "shift"], "startheader": ["endheader", "startpadding", "middleheader", "startoffset", "setheaders", " startmessage", "openlayer", "midheaders", "Startvector", "endlayer", "setpadding", "endpadding", "middlevector", "midoffset", "openheaders", "openmessage", " startoffset", "midheader", " startHeader", "endmargin", "startHeader", "startmargin", "Startmaster", " startmaster", " startvector", "startingmargin", "startingchannel", "startmessage", "startmaster", "middlelayer", "Startlayer", "setheader", "endoffset", "midlayer", "startvector", " startheaders", "midmaster", "setoffset", "midmargin", " startlayer", "endmessage", "Startheaders", "StartHeader", "endchannel", "startheaders", "startchannel", "startingoffset", "endheaders", "middleHeader", "startingheader", "openheader", "startlayer", "midchannel", "Startheader", " startpadding"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "di", "ci", "ji", "ni", "b", "x", "si", "xi", "ri", "io", "ani", "info", "bi", "in", "qi", "ix", "l", "f", "yi", "pi", "phi", "ii", "iu", "d", "my", "ai", "cli", "it", "u", "e", "ami", "uri", "ori", "n", "multi", "mi", "ini", "ie", "p", "jit", "z", "eni", "iv", "start", "oi", "c", "ind", "ip", "g", "y", "api", "li", "inner", "fi", "index", "r", "zi", "ui"], "j": ["jet", "o", "ch", "v", "el", "note", "jl", "ju", "jump", "ji", "b", "x", "m", "kj", "l", "key", "f", "job", "d", "ii", "q", "ij", "aj", "it", "e", "jen", "J", "je", "jc", "k", "n", "uj", "jp", "jo", "ie", "p", "jit", "z", "pos", "jj", "ind", "g", "y", "ja", "dj", "li", "adj", "index", "r", "bj", "js"], "cmpt": ["CMpp", " cmpp", "pmptr", "fmpl", "pmnt", "cmnt", " cmnt", "CMptr", "qunt", "cmptr", "mmpx", "cmpr", "CMnt", "qupx", "cmpp", "CMpt", "kmpl", "ympt", "umpr", "cmpc", "umpp", "cmpl", "fmpt", "ymnt", "umnt", " cmpton", "cmpx", "cmpton", "qupt", "umpc", " cmptr", "umpt", " cmpx", " cmpr", "pmpp", "fmpp", "fmpr", "ympp", " cmpc", "mmnt", "qupton", "kmpr", "mmpton", "kmnt", "kmpt", "fmnt", " cmpl", "mmpt", "pmpt", "ympc"]}}
{"project": "qemu", "commit_id": "c1076c3e13a86140cc2ba29866512df8460cc7c2", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n", "idx": 7866, "substitutes": {"s": ["sf", "S", "a", "b", "i", "status", "results", "f", "state", "d", "service", "conf", "sports", "self", "h", "aws", "g", "sym", "y", "sets", "sites", "is", "spec", "services", "its", "states", "sl", "ls", "sie", "sim", "ds", "ts", "settings", "sv", "fs", "new", "sq", "ms", "site", "rs", "as", "ins", "sg", "comments", "sync", "ses", "cs", "u", "e", "sb", "t", "qs", "p", "c", "os", "ssl", "ims", "r", "ps", "v", "session", "si", "sys", "m", "details", "l", "xs", "ns", "args", "us", "ss", "uns", "gs", "se", "storage", "n", "su", "this", "params", "es", "js"], "addr": ["base", "address", "dr", "r", "name", "layer", "host", "a", "Address", "x", "rc", "data", "nc", "ad", "ace", "mac", "offset", "attr", "url", "nm", "nr", "res", "sid", "len", "e", "sb", "ar", "pad", "hop", "sta", "amp", "ptr", "start", "pos", "gen", "proc", "ip", "ref", "rs", "src", "conn", "mode", "add"], "miny": ["rainey", "Minx", "minY", " miney", "minx", "Minw", "posY", "posw", "miney", "maxY", "rainy", "maxx", "useY", "posy", "minp", "latey", "usex", "Miny", " minx", "lateY", "minw", "posx", "latex", " minY", "rainY", "usey", "maxp", "usep", " minp", "lateey", "rainx", " minw", "MinY"], "maxy": ["laga", "smaga", "paxy", "leth", "daja", "dagic", "smeth", "dium", "mium", "maga", "Maja", "lagic", "magic", "smaxy", "laxy", "Mium", " magic", "maja", "smagic", "pagic", "peth", " mium", "Maxy", "Magic", "daxy", "paga", "meth", " maja"], "surface": ["layer", "sr", "sf", "prof", "wrapper", "aster", "pse", "slice", "face", "sys", "vas", "m", "sur", "draw", "client", "sm", "sl", "fe", "ser", "buffer", "sc", "faces", "sb", "sim", "rect", "func", "storage", "su", "ils", "source", "sta", "ptr", "console", "shell", "node", "ssl", "sym", "core", "skin", "src", "cel", "setup"], "src_width": ["src_flow", "srcacwidth", "src\u00b7radius", "src_length", "src__weight", "src\u00b7height", "dest_fall", "srcacweight", " src_length", "dest_height", "src\u00b7length", " src_weight", "src_area", "src__width", "srcacflow", "dest_work", "dest_length", "dest_radius", "srcacheight", "src_work", " src_area", "dest_size", "src_height", "srcacfall", "dest_flow", "src\u00b7width", "src_weight", "srcacsize", "dest_weight", "srcaclength", "src_fall", "src_radius", "src_size", "src__work"], "dest_width": ["src_flow", "dest_wide", "src_length", "destinglength", "destingwidth", " src_length", " src_wide", "dest_height", "src_depth", "dest_strength", "dest__strength", "destingheight", "dest_length", "dest_depth", "destingweight", "dest__flow", "src_height", "dest__width", "dest__length", "dest_flow", "src_weight", "dest_weight", "src_strength"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dmar_q35(GArray *table_data, GArray *linker)\n\n{\n\n    int dmar_start = table_data->len;\n\n\n\n    AcpiTableDmar *dmar;\n\n    AcpiDmarHardwareUnit *drhd;\n\n\n\n    dmar = acpi_data_push(table_data, sizeof(*dmar));\n\n    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;\n\n    dmar->flags = 0;    /* No intr_remap for now */\n\n\n\n    /* DMAR Remapping Hardware Unit Definition structure */\n\n    drhd = acpi_data_push(table_data, sizeof(*drhd));\n\n    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);\n\n    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */\n\n    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;\n\n    drhd->pci_segment = cpu_to_le16(0);\n\n    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);\n\n\n\n    build_header(linker, table_data, (void *)(table_data->data + dmar_start),\n\n                 \"DMAR\", table_data->len - dmar_start, 1, NULL);\n\n}\n", "idx": 7869, "substitutes": {"dmar": ["sdmar", "dmr", "Dmer", " dara", "sdma", "damar", " damar", "dmer", "ldmer", " dma", "pdmar", "dara", "Dma", "nara", "ldamar", "pdaml", "adara", " daml", "admer", "ldpar", "adgar", " dpar", "Dmar", "dmor", "daml", "adpar", "dgar", "admar", " dmr", "dpar", "sdmr", "nmar", "namar", "Dmr", "dma", "pdmor", "pdamar", "sdgar", "admor", "adaml", "sdamar", " dgar", "sdmer", "sdpar", " dmer", "pdpar", "pdmer", " dmor", "adamar", "ldmar", "nmer"], "drhd": ["rdxd", "arrdd", "DRhd", "hrrh", "adrxd", "dervd", "dradh", " drbd", " drdd", " dradh", "DRcd", "drrh", "drbd", "rrhard", "hrcd", "rradh", "rrcd", "DRrh", "derdd", "fradh", "hrhard", "yrvd", "hrhd", "adrhd", "rdcd", "frcd", " drhid", "arrxd", "adrdd", "srgd", "gradh", "hrmd", "yrdd", "drmd", "arrhd", "arrhid", "derxd", "DRadh", "DRvd", "rrbd", "rrvd", "grhd", "srhd", "drgd", " drcd", "drdd", "deradh", "hradh", "rrmd", "drcd", "grcd", "derhd", "hrbd", " drrh", "derhard", "rrxd", " drmd", "srcd", "hrxd", "drhid", "drxd", "rdvd", "DRdd", " drxd", " drpd", "hrdd", "yrpd", "frhd", " drvd", "hrvd", "rdhd", "adrhid", "drhard", "hrpd", "rddd", "yrhd", "sradh", "rrhd", "drvd", "frgd", "grgd", "drpd"]}}
{"project": "qemu", "commit_id": "db1da1f2b5f3a2383030438553988f0734a97dbe", "target": 0, "func": "static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)\n\n{\n\n    GtkWidget *machine_menu;\n\n    GtkWidget *separator;\n\n\n\n    machine_menu = gtk_menu_new();\n\n    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);\n\n\n\n    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(\"_Pause\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->reset_item = gtk_menu_item_new_with_mnemonic(_(\"_Reset\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);\n\n\n\n    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(\"Power _Down\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->quit_item = gtk_menu_item_new_with_mnemonic(_(\"_Quit\"));\n\n    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),\n\n                                 \"<QEMU>/Machine/Quit\");\n\n    gtk_accel_map_add_entry(\"<QEMU>/Machine/Quit\",\n\n                            GDK_KEY_q, GDK_CONTROL_MASK);\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);\n\n\n\n    return machine_menu;\n\n}\n", "idx": 7873, "substitutes": {"s": ["as", "r", "o", "sets", "sf", "v", "ins", "is", "S", "a", "spec", "sg", "session", "comments", "b", "si", "i", "sys", "ses", "services", "its", "details", "states", "l", "xs", "private", "f", "ns", "d", "ls", "sl", "args", "service", "us", "ss", "cs", "conf", "hs", "sis", "e", "sie", "sb", "gs", "se", "ks", "secondary", "ops", "ds", "qs", "t", "ts", "p", "south", "settings", "h", "sv", "fs", "c", "os", "g", "ssl", "y", "sym", "ess", "es", "rs", "ps", "js"], "accel_group": ["accell_size", "accel_name", "acptionamgroup", "accelermanager", "accelsg", "accelersize", "accelergroup", "acption_group", "accelsmanager", "accellsname", "accelssize", "accelamgroup", "accelamcap", "accelamg", "acption_g", "acptionamcap", "acption_cap", "acption_name", "accellsgroup", "accel_cap", "accelamname", "acptionamg", "accel_size", "accel_manager", "accell_manager", "accelsgroup", "accelsname", "accellssize", "acptionamname", "accelscap", "accell_group", "accelername", "accel_g", "accell_name", "accellsmanager"], "machine_menu": ["theme_sequence", "machineacrule", "machine_image", "menu_mouse", "machine_consumer", " machine_cache", "machine\u00b7image", "element_menu", "theme_menu", "model_menu", "menu_item", "machine_bar", "model_ui", "menu_query", "machinekrule", "machine__cache", "machinekquery", " machine__cache", "machine_server", "elementacmenu", " machine_image", "machine_block", " machine_server", "machineADui", "elementacmode", "element_mode", "machineacitem", " machine_block", " machine_bar", "machineacchain", "machinekui", "model_size", "theme_chain", "mobile_family", "machineacsize", "theme_team", "machine_mouse", "machinekmouse", "mobile_menu", "machine_group", "machine\u00b7server", "machine_cache", "model_item", "machinekconsumer", "machine_family", " machine_ui", "machineacmode", "menu_group", "machineksequence", "machine_size", "menu_ui", "machinekteam", "element_rule", "machinekfamily", " machine__block", "machine_chain", "machine\u00b7menu", "machineacteam", "machineacui", "elementacui", "machine__block", " machine__menu", "machine_ui", "machine_query", "machine_view", "machine_mode", "mobile_sequence", "mobile_consumer", "element_ui", "machinekchain", "machine_mu", "machine\u00b7ui", "machineacsequence", "menu_mu", "machineADitem", "machine_item", "menu_menu", "machine_license", "machine__menu", " machine__bar", "machine_rule", " machine_view", "machine_sequence", "machinekmenu", "menu_license", "machine_team", "machine__bar", "elementacrule", "machineADgroup", "machinekmode", "machineacmenu", "machineADmenu"], "separator": [" separinator", "terminaser", " separulator", "separation", "termininator", "separrator", "separinator", "separcer", "perner", "alterncer", "termination", "terminater", "celerner", "alternater", "separaser", "percer", " separner", " separcer", "terminulator", "alternation", "perater", "termincer", "iterer", "iterator", "separulator", " separaser", "iteraser", " separatter", "perrator", "iterrator", "celeratter", " separater", "perinator", " separrator", "terminator", "separater", "terminatter", "celerinator", "perulator", "terminrator", "terminer", "perator", "separner", " separer", "separatter", "separer", "celerator", "alternator", "terminner", " separation"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n", "idx": 7874, "substitutes": {"opaque": ["opatile", "osphalf", "osphole", "ophole", "operaques", " opaques", "ospacity", "ospaque", "operaque", "optaque", "ospatile", " ophole", "operhalf", "hopaque", "optatile", " opatile", "opaques", "operacity", "ospaques", "opthole", "opacity", "optaques", "hophalf", "hopacity", "hopaques", "ophalf"], "offset": ["address", "o", "padding", "position", "origin", "reset", "seek", "entry", "parent", "rot", "data", "sync", "slice", "alias", "Offset", "length", "align", "len", "target", "error", "secondary", "port", "bound", "timeout", "fp", "prefix", "operation", "ptr", "pos", "pointer", "start", "attribute", "range", "off", "location", "reference", "addr", "set", "index", "slot"], "value": ["address", "flow", "name", "padding", "v", "block", "entry", "fee", "values", "update", "val", "data", "format", "image", "unit", "key", "child", "server", "length", "service", "number", "buffer", "property", "w", "message", "port", "timeout", "array", "scale", "VALUE", "memory", "range", "type", "slot", "set", "index", "max", "Value"], "size": ["address", "name", "SIZE", "count", "fee", "data", "f", "length", " length", "Size", "buffer", "len", "bytes", " mode", "timeout", " address", "type", "ize", "set"], "s": ["o", "S", "a", "spec", "sg", "scope", "session", "b", "socket", "si", "sync", "i", "sys", "ses", "m", "status", "f", "sl", "service", "ss", "u", "e", "submit", "sb", "ops", "secondary", "t", "n", "instance", "p", "h", "c", "slave", "g", "ssl", "sq", "sym", "r"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n", "idx": 7881, "substitutes": {"opaque": ["popaques", "opque", "popaqu", "operque", "popque", "oaque", "opsaque", "operaques", "opsacity", " opque", "opaqu", "opsaques", "operaque", "popaque", "oacity", " opaqu", "hopaqu", "oque", "hopaque", "hopque", "opaques", "operacity", "opsque", "opacity", " opaques", "hopaques", "oaques"], "rfile": ["rama", "erfiles", "krfiles", " rchannel", "krchannel", "rbook", "rofile", "roama", "rfiles", "rFile", "robook", "srbook", "erchannel", " rfiles", " rFile", "srfile", "srname", "krFile", " rama", "erfile", "krfile", "erFile", "rname", "roname", "srama", " rname", "rchannel", " rbook"], "rdma": ["rdha", "rcfa", "rhra", "rhwa", "rnwa", "drm", "ldca", "rnra", "udmas", "rhfa", "udha", "rdpa", "ratca", "rhma", "drca", "rtmas", "rcma", "rdca", "rtpa", "ratma", "ratm", "rnma", "rdmas", "ldm", "rdme", "udma", "drme", "ratmas", "rcwa", "rdra", "rcra", "rtha", "udpa", "ldme", "rtma", "ratpa", "ldma", "ratme", "rdwa", "rdfa", "rnfa", "rdm", "drma", "ratha"]}}
{"project": "qemu", "commit_id": "323ad19bcc601d3ec9cb6f0f5b4d67b602fc519e", "target": 1, "func": "static void dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    const char *p, *q;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;\n\n                            opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            /* Special hack to properly dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7882, "substitutes": {"env": ["address", "er", "host", "ea", "header", "el", "ef", "scope", "config", "environment", "exc", "data", "style", "enc", "queue", "enter", "db", "profile", "package", "event", "export", "ext", "server", "obj", "args", "operator", "conf", "ev", "dir", "def", "vs", "e", "her", "que", "code", "en", "dev", "err", "exec", "context", "ec", "stage", "eni", "viron", "console", "engine", "loader", "manager", "conn", "end", "dict"], "table": ["master", "function", "address", "machine", "base", "Table", "row", "stable", "v", "store", "block", "show", "parent", "session", "tmp", "list", "che", "object", "TABLE", "style", "tr", "see", "database", "normal", "queue", "module", "body", "part", "db", "key", "package", "f", "event", "how", "player", "child", "state", "server", "thin", "cher", "entity", "tab", "the", "buffer", "code", "interface", "col", "error", "section", "fore", "connection", "file", "port", "point", "container", "source", "array", "root", "stage", "where", "rule", "tree", "can", "model", "type", "query", "transform", "cache", "test", "index", "bar", "view"], "handler": ["writer", "master", "hook", "layer", "position", "hand", "object", "password", "queue", "handled", "route", "f", "magic", "service", "code", "error", "connection", "file", "callback", "controller", "reader", "h", "filter", "function", "plugin", "name", "parent", "channel", "slice", "widget", "pattern", "server", "cher", "man", "definition", "uri", "target", "item", "driver", "lib", "ctx", "path", "field", "response", "parse", "rule", "type", "model", "cookie", "command", "end", "patch", "address", "change", "or", "phase", "package", "ph", "parser", "message", "menu", "based", "location", "fd", "api", "management", "loader", "machine", "wrapper", "format", "event", "client", "player", "child", "handle", "delay", "control", "processor", "Handler", "pointer", "inner", "host", "manager", "worker"], "p": ["_", "b", "x", "i", "f", "d", "code", "all", "w", "per", "func", "Q", "h", "vp", "sp", "proc", "g", "y", "user", "tp", "cp", "P", "s", "wp", "pe", "ap", "php", "jp", "ip", "type", "bp", "python", "pa", "po", "pp", "op", "lp", "post", "j", "pc", "py", "np", "u", "e", "dp", "t", "k", "c", "api", "r", "ps", "o", "v", "pr", "http", "pre", "m", "l", "n", "qa"], "q": ["patch", "complex", "ch", "o", "iq", "v", "id", "qq", "check", "qt", "b", "x", "i", "queue", "m", "qi", "quant", "f", "dq", "d", "eq", "u", "sh", "w", "qs", "Q", "k", "t", "str", "question", "qu", "qa", "req", "h", "z", "request", "c", "g", "sq", "y", "ip", "query", "text", "form", "r", "quest"], "opc1": ["oppc4", "ipc3", "optlc3", "optlc1", "hopc2", "opcu2", " opc9", "hoplc4", "opcu3", "optlc2", "optlc4", "oprc0", "optc0", "ipf5", "oplc2", "hopsc1", " opc0", "opcu0", "opf2", "optf5", "opk5", "opsc3", "opf0", "hopsc81", "oplc5", "opdc4", "opsc1", "opn3", "oppc71", "opac3", "opcu71", "opc71", " opc71", "operc2", "opac1", "oprc81", "optc4", "opdc81", "hopsc3", "opdc1", "optc1", "hopc81", "ipc5", "ipf2", "opk1", "opc81", " oprc1", "optrc3", "opsc2", " oprc0", " opc4", "hopsc2", "opf1", " oplc71", " opc81", "opdc5", "optrc1", "opcu9", "opf4", "opk2", "opcuOne", "optc5", "oprc5", "opf81", "opdc0", "opsc81", "opf3", "operc11", "opn1", "oppc1", "oplcOne", "operf1", " oprc2", "opcOne", "oplc71", "opn2", "optrc4", "hoplc2", "oppcOne", "ipc1", "oppc0", "optrc0", "opn4", "oppc5", "opdc3", "opdc2", "opc11", "opac5", "optf1", "oprc2", "opf5", "hoplc3", "opac81", "oprc3", " opcOne", "opc5", "ipc2", "oplc3", "opk3", "opppc1", "operc1", "ipf1", " oplc1", "opf11", "oplc4", "oprc1", "operf2", "operf3", "hopc3", "operc3", " oplcOne", "opac4", "opac2", "opc9", "hoplc1", "opcu1", "ipf3", "operf11", "oprc4", "opppc4", "opc4", "opppc5", "opcu81", "oplc9", " oplc9", "opsc11", "opac11", "hopc4", "optc2", "oppc9", "hopc1", "optf0", " oprc81", "optc3", "opcu5", "optf3", "oplc1", "opppc0", "opc0", "oplc0"], "opc2": ["opcr12", "hopc2", "opac10", "optf2", "opac12", "coplc3", " oprcSecond", "copc3", "copc4", "ipcTwo", "opc32", " oplc2", "opc02", "oplc2", "opdc12", "opf2", " opcSecond", " opc22", "opsc3", "operc12", "opcTwo", "opercr4", "opcr02", "optf6", "coplc9", "hoprc4", "copc2", "opci1", "opdc4", "hopc32", "oplc5", " opcTwo", "copac10", "opl4", "opac3", "opcr4", "operc2", "opac1", "opfSecond", "optc4", "opercr12", "opc6", "opvc2", "opercr02", "opdc1", "optc1", "opvc9", "ipf2", "hopc22", "oprc6", "oprc32", "optrc3", "opdc22", "opsc2", "optrc2", "opc10", " oprc22", " opc4", "opf1", " oplc6", "copac2", "optrc5", "copc10", "opdc5", "opf4", "opl02", "optc5", "oprc5", "opf6", "opdc10", "opnTwo", "opf22", "copac4", "opl10", "oprc22", "oprcSecond", "opf3", "oplcTwo", "opn1", "operdc3", "oplc12", " oprc2", "copac5", "optrc4", "opn2", " oplc3", "operdc1", "opci3", "ipc1", "copc9", "opac02", "operdc2", "opl12", "hoprc22", "opn4", "opdc2", "opdc3", "oprc9", "optf1", "opac5", "oprc2", "ipfTwo", "opc12", "opci2", "operdc12", "oprc3", "opci6", "opc5", "oprc12", "opl2", "ipc2", "oplc3", "coplc4", "copc1", "ipf1", "operc1", "opcrSecond", "opercr2", "oplc6", "opsc5", "oplc4", "opvc1", "copc5", "oprc1", "hoprc2", "operc02", "opsc4", "opcr22", "opc22", "opdc32", "opac4", "opac2", "opc9", " oprcTwo", "operc3", "opcr2", "opfTwo", "oprc4", "opcSecond", "opc4", "ipf4", "opf32", "oplc9", "opcrTwo", "hopc4", "hoprc32", "oprcTwo", " oplc4", "optc2", "optc6", " opc6", "coplc2", "operc4", "optc3", "ipc4", "optf3", "opvc4", "oplc1", "coplc1", "opl5"], "opc3": ["uppc3", "uppcin2", " opl3", "hopf3", "opl8", " oplc30", "copc8", "oplc7", "copl1", "OPc2", "opl1", "copc53", "opcacheThird", "copc3", "optcThird", "oprc0", "opk53", "opdc8", "opc03", "oplc2", "opf2", "OPc3", "opk5", "opsc3", "uppc03", "opcin2", "copf03", "oprc03", "expc3", "copf53", "oplc53", "operc0", "oplc5", "operk0", "opl4", "OPlc2", "operc2", "OPlc4", "oprc30", "opf7", "operc6", " opl53", "optc4", "opc48", "opc6", "oplc8", "opct03", "oprc15", "oppc03", "opdc1", "hopf53", "opf53", "uppc48", "opk1", "oppc3", "oprc6", "opc39", "exppc03", "opdc53", "opcache4", "optrc3", "opsc2", " opl4", "optrcThird", "operc7", "optrc2", " opc4", "opk30", "operk2", "opc30", "uppcin48", "opf48", "opdc5", "opf4", "opk2", "opsc53", "OPlc3", "copl8", "oprc5", "opf6", "hopf4", " opl03", "opl03", "exppcThird", "oplc03", "uppcin03", "opl53", "opf3", "opcin3", "oprc53", "opersc6", "opcThird", "copl3", "operk5", "operk3", "copf3", "opdc39", "opsc13", "optrc4", "oplc30", " oplc3", "oplcThird", "opcache2", "opf03", "expcThird", "opcache3", "opcin48", "opc15", "opdc3", " opc53", "opl5", "oprc2", "OPc6", "uppc2", "oprcThird", "hopf5", "opcin03", "opsc7", "opl3", "opct53", "oprc48", "opc13", "opf5", "opk15", "oprc3", "opf39", "opc5", "opct3", "oplc3", "operc5", "opk3", "copc1", "opsc0", "copf39", " oplc1", "oplc6", "opsc5", "opersc2", "OPlc6", "oplc4", "copc5", "oprc1", "copc39", "opsc4", "hopc3", "operc3", "opersc3", "opscThird", "oplc15", "hopc53", "opsc6", "exppc3", "oprc13", "opsc03", "oprc4", "opk0", "opc4", "opc7", " oplc15", " opc03", "hopc4", "opersc7", "uppcin3", "hopc5", "expc03", "opk4", "OPc4", "optc2", "oppcThird", "expc13", "optc3", " opc30", "opc8", "copc03", "exppc13", "oplc1", "copl5", "opc53", "oppc13", "opc0", "opdc03", " opc15", "opct39"]}}
{"project": "FFmpeg", "commit_id": "bf2cba453244a74331238a472fe0e309f116f4d9", "target": 1, "func": "yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        int A1, A2;\n\n        const void *r =  c->table_rV[V],\n\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n\n                   *b =  c->table_bU[U];\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n\n        }\n\n\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                      r, g, b, y, target, hasAlpha);\n\n    }\n\n}\n", "idx": 7885, "substitutes": {"buf0": ["buf00", "buf3", "uf3", "uf00", "buffer0", "buff3", "uf50", " buf3", "buff00", "uf1", "buf50", "buff1", "buff0", " buf50", "buffer1", " buf00", "uf0", "buff50", "buffer50"], "buf1": [" buf2", "aux2", "buffOne", "bufone", "buf3", "uf3", "bufferone", "buff3", "bufferOne", " buf3", "ufOne", "buffer3", "buff2", "queueOne", "auxOne", "queue3", "uf1", "buf2", "buffone", "buff1", " bufOne", "buff0", "queueone", "buffer1", "queue1", "uf0", "bufOne", "aux1"], "ubuf0": ["abbuff0", "ubbuf0", "ubuff0", "abbuff2", "abuf25", "abuff00", "ubbuf1", "abuf00", "ubbuff0", "ubimg0", "abuf2", "ubuf10", "ubuf00", "abbuff25", "ubbuf00", "ubbuff1", "ubbuff2", "abbuff1", "ubbuf2", "ubuff10", "ubimg25", "ubbuff00", "ubbuff10", "abuff10", "ubuf2", "ubuf25", "abuf10", "ubimg2", "ubbuf25", "abuff0", "abuff1", "ubuff1", "ubuff00", "ubbuff25", "ubbuf10", "ubimg1"], "ubuf1": ["ubbuf0", "rubuf101", "abbuf01", "ubf101", "ubf01", "ubbuf1", "ubum2", "abbuf1", "ubbuff0", "abuf2", "ubef101", "ubbf1", "ubef1", "abbuf2", "ubbuff1", "ubbuff2", "ubbuf2", "ubbuf01", "ubef01", "ubuf2", "ubbf01", "ubuf01", "ubbf101", "ubum01", "abuf01", "rubef1", "rubuf01", "ubum0", "abbuf0", "ubbuff01", "ubuf101", "rubef01", "ubum1", "ubf1", "rubuf1", "rubef101"], "vbuf0": ["vfameu", "lbuf8", "vbuffee", "vfamio", "vuf1", "vbuff8", "vbuff0", "lbuf1", "vvecee", "lbuffio", "lbuffee", "vfam0", "lbuffeu", "vbufee", "vbuf2", "vbuffer0", "lbufeu", "vbufeu", "vuf2", "vuf8", "luf0", "vbuff2", "vvec0", "vfamee", "lbuff0", "vbuffeu", "lbufio", "luf1", "vbuffer1", "vbuffer2", "luf2", "lbufee", "vbuf8", "vbuff1", "lbuf2", "luf8", "lbuf0", "vuf0", "vbuffer8", "vveceu", "vbufio", "vvecio", "vbuffio"], "vbuf1": ["hbuff2", "vconfigOne", "vuf1", "vufOne", "vbuff0", "hbuf0", "ubufOne", "vbuf2", "vbuffer0", "vuf2", "hbuffOne", "hbuf1", "vbufOne", "vbuffOne", "vbuff2", "vconfig1", "vbuffer1", "hbuff0", "vbuffer2", "vbuff1", "hbuff1", "vuf0", "hbuf2", "ubuff1", "hbufOne", "ubuffOne", "vbufferOne"], "abuf0": ["abbuff0", "abimg2", "abuf4", "absuff1", "abuc00", "bbuf1", "abbuff4", "abbuff2", "abuc1", "absuf00", "abuff00", "abbuf1", "abuf00", "bbuf4", "abuf2", "bbuf2", "absbuff2", "abbuf2", "absbuff8", "buf4", "bbuf0", "abbuff1", "absbuff0", "absuff0", "abbuf4", "absuff00", "absuf2", "absbuff1", "buf2", "abbuff8", "abimg1", "absuf1", "abuff4", "abuf8", "absuf8", "abuff2", "abbuf0", "abbuf8", "abuc0", "abuff0", "abuff1", "abbuf00", "abimg0", "absuf0", "abimg8", "abuc2", "absuff2"], "abuf1": ["abbuff0", "abcf01", "abbufOne", "abuc3", "ubuf11", "abbuff2", "tabuf3", "abbuf01", "abuc1", "abbuf1", "ubbuff0", "fabuf1", "abuf2", "abcfOne", "abcf0", "fabbuf01", "abuu11", "fabbuf0", "fabbuf1", "abbuf2", "abuu1", "abucOne", "tabufOne", "ubbuff1", "tabuc1", "abuf11", "ubbuff2", "abbuff1", "abuff01", "abcf1", "tabuc3", "ubuf2", "abbuf3", "abufOne", "abuffOne", "ubbuff11", "tabuc0", "abuf3", "fabuf0", "fabuf01", "abef3", "abbuf11", "abuu2", "fabbufOne", "abefOne", "abuf01", "abef0", "tabucOne", "abbuff11", "abbuf0", "fabufOne", "tabuf0", "abuc0", "abuff0", "abuff1", "abef1", "abuu0", "tabuf1"], "i": ["isi", "I", "a", "chi", "di", "ci", "x", "xi", "bi", "f", "pi", "d", "ii", "my", "err", "mini", "oi", "y", "page", "li", "fi", "index", "zi", "gi", "ti", "id", "is", "slice", "info", "ix", "phi", "\u0438", "it", "ai", "ami", "uri", "mi", "ini", "ie", "z", "ip", "anti", "ui", "ni", "ri", "io", "key", "yi", "j", "cli", "u", "e", "t", "k", "p", "start", "c", "ind", "api", "idi", "mu", "v", "si", "m", "in", "qi", "l", "ij", "iu", "uli", "n", "multi", "eni", "iv"], "A1": ["AOne", "A001", "a2", "Yone", "a001", "a1", "AA4", " AOne", "AA1", "A4", "Y1", "aOne", "YOne", "AA001", "AAOne", "AAone", "AA2", " A001", " A4", " Aone", "Y4", "Aone"], "A2": ["a2", " A0", "atwo", "LA0", "LA2", "AUsecond", "AATwo", "AASecond", "AU2", "ASecond", "AAsecond", "Asecond", "APITwo", "AUSecond", "LAtwo", "A0", "APISecond", "ATwo", "Atwo", " Atwo", "AA2", "AUTwo", "APIsecond", "a0", "API2"], "r": ["o", "er", "sr", "rb", "rc", "m", "l", "ru", "f", "d", "q", "e", "w", "rg", "k", "t", "n", "rl", "p", "h", "z", "R", "re", "br", "rs"], "g": ["v", "s", "x", "m", "l", "G", "f", "ga", "d", "q", "u", "e", "w", "gs", "k", "t", "n", "go", "p", "h", "gl", "z", "gb", "c", "y", "ac", "group"], "b": ["o", "ib", "v", "a", "s", "rb", "x", "ob", "l", "f", "d", "u", "e", "w", "sb", "t", "k", "n", "B", "p", "be", "h", "boot", "z", "y"]}}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n", "idx": 7892, "substitutes": {"s": ["o", "sets", "sf", "v", "S", "a", "http", "spec", "sg", "session", "b", "com", "si", "i", "sync", "ses", "services", "m", "l", "xs", "sk", "f", "client", "parts", "ns", "stats", "d", "ls", "space", "service", "us", "cs", "ss", "conf", "u", "e", "sc", "sb", "gs", "ops", "qs", "t", "n", "ds", "ts", "same", "self", "p", "south", "settings", "h", "gb", "sv", "sup", "c", "os", "g", "ssl", "sq", "sym", "site", "es", "rs", "js"], "slice_x": ["slice_ey", "sliceamed", "slice_ex", "slice6x", "sliceIDy", "slice11y", " slice_u", "sliceameex", "slice6ey", " slice_xp", "slice08x", " slice_xs", "slice08u", "sliceIdd", "sliceamex", "sliceamey", "sliceIDx", "slice11ey", "slice11x", " slice_xy", "slice08fx", " slice_ex", "sliceingx", " slice_z", "slice_z", "slice_xp", "sliceIdx", "slice_xs", "sliceingy", "sliceIDu", "sliceIdy", "sliceingxp", "sliceingz", "slice_xy", "slice08y", "slice_u", " slice_d", "slice6y", "slice6xs", "slice_fx", "slice_d", " slice_ey", "sliceIdex", "slice11xy", "sliceIDfx", " slice_fx"], "slice_y": ["slicePsy", "sliceDx", "slice08wy", "slice_ny", " slice_ye", "slice_ady", "player08ny", "slice_asy", "slicePwy", "scale_x", " slice_z", "slicePny", "slice_z", "sliceDn", "slice_ye", "scale_asy", "scale_y", "scale_n", "slice_wy", "sliceIdy", "slice08ny", "player08wy", "sliceJy", "player08sy", "sliceIdny", "player_wy", "slice08sy", " slice_ny", "sliceIdya", "slice08y", "sliceDy", "player_ny", "player_sy", "slice_vy", " slice_ya", " slice_vy", "sliceIdady", "sliceJny", "slice_n", "slice_sy", "slice_ya", "sliceJady", "sliceJya", "slicePy", " slice_ady", "player_y", "player08y", "sliceDasy"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n", "idx": 7893, "substitutes": {"opaque": [" opec", "opula", "octula", "opsaque", "opsacity", " opaques", "pacity", "ospacity", "ospaque", "pula", "openaques", "opsaques", "openacity", "octacity", "openaque", "opsec", "opec", "octaques", " opacity", "ospula", "opaques", "paque", "ospaques", "opacity", "openec", "octaque", "paques"], "data": ["writer", "o", "alpha", "a", "entry", "change", "open", "dat", "config", "aa", "layout", "ada", "ad", "info", "image", "missing", "draw", "window", "valid", "event", "client", "media", "init", "DATA", "code", "buffer", "parser", "da", "ata", "Data", "empty", "exec", "result", "input", "this", "reader", "start", "new", "handler", "api", "cookie", "inner", "next", "cache"]}}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 7916, "substitutes": {"opaque": ["opbuffer", "uppaques", "opacle", "compaco", "uppaque", "pya", "oppac", "compaque", "Opga", "ipaco", "opya", "obec", "splane", "iopaques", "ipsaque", "oaque", "iopec", "obaque", " opga", "Opaque", "ipsec", "iopca", "uppacle", "operaques", "oppaca", "opga", "spac", "pacity", "oppaque", "operaque", "Opya", "compbuffer", "obuffer", "oacity", "opac", "ipaque", "pga", "opplane", "ipsaques", "opec", "spaque", "Opacity", " opacle", " opacity", "opaco", "spaca", " opya", "uppacity", "oaco", "opaques", "paque", "operacle", "operacity", "ipacity", "opaca", "ipsca", "ipbuffer", " oplane", "opacity", "oplane", "obca", "opca", "obaques", " opaques", "iopaque", " opac", "compacity", " opaca"], "ret": ["gc", "red", "reg", "mem", "rt", "alt", "hard", "nt", "pat", "get", "rot", "val", "final", "rc", "bit", "cat", "let", "reply", "valid", " RET", "num", " Ret", "lit", "job", "att", "prot", "arg", "res", "match", "def", "len", "mt", "part", "det", "RET", "sat", "feat", "nil", "result", "seq", "Ret", "ft", "ut", "re", "fun", "back", "gt", "desc", "ref", "success", "no", "rets"], "acb": ["accbase", "aclemb", "macfb", "accgb", "ACba", "acemb", "acllb", "ACbot", "acfb", "icbb", "macsb", " acbb", "acway", "accbr", "ocfb", " acrb", "agbb", "ecbb", "iclb", "macmb", "acl", "icbf", "aclbase", "macf", "accrb", "acxb", "aclob", "acB", "aca", "ackbd", "ecmb", "acsb", "akf", " acfb", "agbf", "ecbd", "acgb", "acssb", " acbar", " acbase", "acbr", "akba", "icl", "ocb", "ucfb", "ocbase", "ecsb", "Acba", "ocl", "aclxb", "ucbb", "akfb", "ocob", "aclb", "aclbc", "aclbf", "agl", "ACl", "acbb", "icb", "acll", "acclb", "ucb", "ancxb", "axbb", "acbase", "aclf", "aksb", "acbf", " acsb", "agf", "maclb", "ancbot", "accB", "acbd", " acwb", "akemb", "akb", "ACbb", " aca", "AcB", "accbar", "ocbb", "acsbot", "acbc", "ecbr", "macbd", "acwb", "acba", "acbar", "akbr", "macb", "acbot", "akgb", "Acb", "ocba", "akrb", "acob", "ecb", "ecwb", "ACsb", "macway", "icf", "ecgb", "axb", "acf", "ocxb", "accbf", "akbb", "ancob", "ucf", "axf", "icbc", "aclfb", "aclrb", " acl", "accb", "ecf", "akl", "acrb", "accl", "acurl", "aclbb", "accfb", "ocf", "ocway", "ackmb", "ecl", "ocsb", "acca", "accbb", "accwb", "ackb", "ancb", "ecrb", "ecfb", "icurl", "macbb", "accba", "aclway", "ancbb", " aclb", " acgb", "accsb", "accf", "acsbb", "ACB", "maca", "agbc", "acmb", " acf", "ucbf", "ancsb", "ackfb", "aclurl", "Acsb", " acurl", "axbar", "agbase", "ucgb", "ACb", "ecbf", "accemb", "agb"], "bs": ["abc", "bas", "base", "as", "lb", "platform", "bits", "rb", "b", "ob", "bm", "sys", "ses", "bi", "BS", "obs", "fb", "db", "buf", "wb", "bes", "ns", "ls", "iss", "bb", "cs", "ss", "bal", "eb", "las", "sb", "ops", "bis", "ds", "bytes", "bc", "cb", "ab", "ubs", "ba", "Bs", "ec", "blocks", "acks", "gb", "fs", "os", "bos", "bid", "bo", "bl", "pb", "aos", "account", "cas", "bh"], "s": ["sub", "stat", "o", "sets", "sf", "v", "is", "S", "a", "http", "spec", "sg", "session", "b", "si", "sync", "i", "sys", "ses", "services", "m", "details", "states", "l", "f", "parts", "ns", "state", "stats", "sl", "ls", "args", "d", "service", "cs", "ss", "server", "e", "sc", "sb", "gs", "secondary", "bis", "ds", "t", "n", "full", "ts", "multi", "self", "p", "settings", "blocks", "sa", "c", "new", "g", "ssl", "sym", "os", "sq", "params", "rs", "r", "ps", "js"], "index_in_cluster": ["index_in_blusters", "index_in_scuster", "index_in_chuster", "index_in_CLorer", "index_in_scusters", "index_in_cedrome", "index_in_Clica", "index_in_cedusters", "index_in_blosion", "index_in_clrome", "index_in_choser", "index_in_scorer", "index_in_closion", "index_in_sclusters", "index_in_scluster", "index_in_explosion", "index_in_scloser", "index_in_CLuster", "index_in_clorer", "index_in_Cluster", "index_in_clusters", "index_in_Clusters", "index_in_closer", "index_in_explusters", "index_in_Clorer", "index_in_ceduster", "index_in_bloser", "index_in_sclica", "index_in_Closer", "index_in_CLusters", "index_in_Closion", "index_in_clica", "index_in_exploser", "index_in_Clrome", "index_in_CLrome", "index_in_expluster", "index_in_bluster", "index_in_chica", "index_in_chusters"], "cluster_offset": ["clusterfend", "clusters_len", "cluster2data", "clisk_size", "clusterfoffset", "clusterFsize", "clusters_location", "cliskFset", "clusters_num", "clacofoffset", "cluster_limit", "cliskFoffset", "cluster_location", "claco_data", "clust_limit", "clacofend", "clisk_width", "clust2limit", "claco_end", "cluster\u00b7len", "clust2data", "cluster_rot", "clusterFset", "clusterFwidth", "cluster_position", "cluster\u00b7num", "claco_rot", "clust_data", "clusterfdata", "clust_offset", "cliskFsize", "clacofrot", "cluster_end", "cluster_len", "clisk_set", "cluster_num", "clusters_offset", "cluster_set", "cluster2offset", "cluster\u00b7offset", "clisk_offset", "clust_position", "clust2offset", "cluster_width", "clusterfrot", "cluster\u00b7location", "clust2position", "clusterFoffset", "cluster2limit", "cluster2position", "cluster_data", "clacofdata", "cluster_size", "claco_offset", "cliskFwidth"], "src_buf": [" src_mem", "src2mem", " src_buffer", "src2buffer", "src_mem", "src2buf", "src_buffer", "src_buff", "src2buff", " src_buff"], "n_end": [" n_ends", "n_END", "num_start", "n67open", "nJenter", "n64start", "rn_ended", "n__ended", "n64post", "n_ended", "n00open", "nworkend", "n_dev", "nJset", "num00enter", "num_END", " n_dev", "rn__start", "n_ends", "num_set", " n_END", "nJend", "n_enter", "n00END", "n64ended", " n_open", "num00set", "n00set", "rn_start", "numworkended", "n67start", "n00enter", "nworkended", "numworkend", "n00ending", "rn__end", "n00end", "n64end", "n_open", "rn__ended", "n67end", "num_post", " n_ending", "num00end", "rn_end", "num00END", "numworkpost", "nworkpost", "n_start", "n__open", "n__start", "num_enter", "nJEND", "num_ended", "numworkstart", "rn__open", "n67ended", "nworkstart", "n__end", "n_ending", "num_end", "n_set", "rn_open", "n_post"]}}
{"project": "FFmpeg", "commit_id": "08d2cee49c323715b66df0e4ff45ec0e07aaea7b", "target": 0, "func": "static int opt_input_file(const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret, rfps, rfps_base;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (last_asked_format) {\n\n        if (!(file_iformat = av_find_input_format(last_asked_format))) {\n\n            fprintf(stderr, \"Unknown input format: '%s'\\n\", last_asked_format);\n\n            ffmpeg_exit(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        ffmpeg_exit(1);\n\n    }\n\n    if (audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_sample_rate);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_channels);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (frame_rate.num) {\n\n        snprintf(buf, sizeof(buf), \"%d/%d\", frame_rate.num, frame_rate.den);\n\n        av_dict_set(&format_opts, \"framerate\", buf, 0);\n\n    }\n\n    if (frame_width && frame_height) {\n\n        snprintf(buf, sizeof(buf), \"%dx%d\", frame_width, frame_height);\n\n        av_dict_set(&format_opts, \"video_size\", buf, 0);\n\n    }\n\n    if (frame_pix_fmt != PIX_FMT_NONE)\n\n        av_dict_set(&format_opts, \"pixel_format\", av_get_pix_fmt_name(frame_pix_fmt), 0);\n\n\n\n    ic->video_codec_id   =\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);\n\n    ic->audio_codec_id   =\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);\n\n    ic->subtitle_codec_id=\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* open the input file with generic libav function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        ffmpeg_exit(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    if(opt_programid) {\n\n        int i, j;\n\n        int found=0;\n\n        for(i=0; i<ic->nb_streams; i++){\n\n            ic->streams[i]->discard= AVDISCARD_ALL;\n\n        }\n\n        for(i=0; i<ic->nb_programs; i++){\n\n            AVProgram *p= ic->programs[i];\n\n            if(p->id != opt_programid){\n\n                p->discard = AVDISCARD_ALL;\n\n            }else{\n\n                found=1;\n\n                for(j=0; j<p->nb_stream_indexes; j++){\n\n                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n\n                }\n\n            }\n\n        }\n\n        if(!found){\n\n            fprintf(stderr, \"Specified program id not found\\n\");\n\n            ffmpeg_exit(1);\n\n        }\n\n        opt_programid=0;\n\n    }\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0 && verbose >= 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    timestamp = start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n        /* reset seek info */\n\n        start_time = 0;\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st = ic->streams[i];\n\n        AVCodecContext *dec = st->codec;\n\n        InputStream *ist;\n\n\n\n        dec->thread_count = thread_count;\n\n\n\n        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);\n\n        ist = &input_streams[nb_input_streams - 1];\n\n        ist->st = st;\n\n        ist->file_index = nb_input_files;\n\n        ist->discard = 1;\n\n        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);\n\n\n\n        if (i < nb_ts_scale)\n\n            ist->ts_scale = ts_scale[i];\n\n\n\n        switch (dec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(audio_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ist->dec= avcodec_find_decoder_by_name(video_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            rfps      = ic->streams[i]->r_frame_rate.num;\n\n            rfps_base = ic->streams[i]->r_frame_rate.den;\n\n            if (dec->lowres) {\n\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n\n            }\n\n            if(me_threshold)\n\n                dec->debug |= FF_DEBUG_MV;\n\n\n\n            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n\n\n\n                if (verbose >= 0)\n\n                    fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\",\n\n                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n\n\n\n                    (float)rfps / rfps_base, rfps, rfps_base);\n\n            }\n\n\n\n            if(video_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            else if(video_discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n\n\n    top_field_first = -1;\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_pix_fmt = PIX_FMT_NONE;\n\n    frame_height = 0;\n\n    frame_width  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    av_freep(&ts_scale);\n\n    nb_ts_scale = 0;\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n    uninit_opts();\n\n    init_opts();\n\n    return 0;\n\n}\n", "idx": 7925, "substitutes": {"opt": ["option", "options", "oc", "open", "config", "op", "expr", "cat", "loc", "attr", "ext", "url", "obj", "Opt", "fn", "cmd", "path", "timeout", "feat", "temp", "wav", "prop", "alloc", "term", "text", "command", "prefix"], "filename": ["abl", "login", "name", "files", "python", "sf", "mpeg", "kn", "method", "provided", "config", "username", "tmp", "Filename", "println", "password", "format", "nuclear", "fax", "title", "f", "href", "url", "lua", "phrase", "subject", "description", "length", "document", "sheet", "ename", "fil", "download", "uri", "addin", "file", "binary", "fn", "json", "whatever", "path", "jpg", "fp", "nil", "dll", "source", "output", "msg", "wav", "microsoft", "kl", "txt", "location", "fd", "utf", "il", "blast", "png", "src", "directory", "prefix"], "ic": ["abc", "icc", "oc", "ig", "mic", "ik", "CI", "ci", "icer", "inc", "ican", "aci", "icing", "pc", "ai", "cc", "ics", "aic", "IC", "mc", "nic", "lic", "iac", "ici", "bc", "cu", "voc", "ec", "pic", "c", "cit", "ct", "lc", "fc", "ac", "vc", "fi", "au", "cm", "isc", "xc"], "file_iformat": ["file_ionicac", "file_icolat", "file_ilart", "file_iformac", "file_ionicar", "file_iolar", "file_iplt", "file_ilt", "file_ionict", "file_iplart", "file_ionicat", "file_iformar", "file_icolar", "file_iolart", "file_iolat", "file_ilat", "file_iplat", "file_ilac", "file_iolt", "file_icolac", "file_iformt", "file_icolt", "file_iplac", "file_iolac", "file_iformart"], "err": ["stat", "er", "header", "iter", "rr", "progress", "info", "loc", "attr", "all", "e", "error", "out", " error", "str", "seq", "output", "req", "reader", "ptr", "ver", "proc", "var", "ln", "resp", "r"], "i": ["id", "I", "ni", "b", "io", "abi", "info", "ir", "f", "pi", "attr", "ii", "iu", "it", "cli", "ai", "init", "t", "n", "ini", "h", "c", "ip", "ind", "ati", "ui"], "ret": ["gc", "ib", "mem", "rt", "I", "alt", "progress", "nt", "val", "rc", "info", "status", "q", "res", "buffer", "len", "out", "timeout", "exec", "cb", "result", "temp", "back", "aux", "rs", "fi"], "rfps": ["Rfps", "Rframes", "Rbps", "rdframes", "rbits", "rdbps", "rbps", "rdbits", "nfps", "Rbits", "rdfps", "nframes", "nbps", "rframes", "nbits"], "rfps_base": ["rfps_buffer", "rfps_bit", "rips_base", "rfps6length", "rfps_length", "rfps6bit", "rfps6base", "rips_bit", "rips_length", "rips_buffer", "rfps6buffer"], "timestamp": ["stimeline", "imestamp", "imend", "timeest", "timeeline", "stimend", "imeline", "timest", "timeend", "timeestamp", "timend", "stimestamp", "stimest", "imest", "timeline"], "buf": ["rb", "bg", "b", "raf", "auc", "queue", "uc", "buffer", "bag", "file", "func", "bc", "fp", "ab", "pool", "output", "proc", "pb", "img", "bh", "bed", "fam", "header", "extra", "lb", "prof", "config", "fb", "uf", "raw", "port", "ctx", "pad", "font", "batch", "usr", "wav", "doc", "cap", "text", "bn", "ff", "vec", "block", "box", "bd", "tmp", "rc", "cat", "loc", "grab", "wb", "db", "conv", "Buffer", "cmd", "feat", "fab", "prop", "fd", "bo", "desc", "aux", "src", "buff", "mem", "la", "Buff", "bt", "window", "bus", "bb", "ux", "cb", "result", "context", "seq", "alloc", "bf", "comb", "br", "cv", "pkg"], "opts": ["optionts", " opttes", "opertes", "operters", "optionns", "opns", " optts", "optionters", " optns", "optes", "optiontes", "operns", "operts", "opters", " optters"], "orig_nb_streams": [" orig_nb_threaded", " orig_nb_inputd", " orig_nb_threadd", " orig_nb_inputed", " orig_nb_streamd", " orig_nb_rawed", " orig_nb_rawpoints", " orig_nb_inputs", " orig_nb_threads", " orig_nb_raws", " orig_nb_threadpoints", " orig_nb_streamed", " orig_nb_inputpoints", " orig_nb_rawd", " orig_nb_streampoints"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        return ret;\n\n    }\n\n\n\n    switch(request) {\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == 0 && index != 0x81) { /* clear ep halt */\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceRequest | USB_REQ_GET_INTERFACE:\n\n        data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\n        ret = 0;\n\n        break;\n\n        /* usb specific requests */\n\n    case GetHubStatus:\n\n        data[0] = 0;\n\n        data[1] = 0;\n\n        data[2] = 0;\n\n        data[3] = 0;\n\n        ret = 4;\n\n        break;\n\n    case GetPortStatus:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            data[0] = port->wPortStatus;\n\n            data[1] = port->wPortStatus >> 8;\n\n            data[2] = port->wPortChange;\n\n            data[3] = port->wPortChange >> 8;\n\n            ret = 4;\n\n        }\n\n        break;\n\n    case SetHubFeature:\n\n    case ClearHubFeature:\n\n        if (value == 0 || value == 1) {\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case SetPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            USBDevice *dev;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            dev = port->port.dev;\n\n            switch(value) {\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus |= PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_RESET:\n\n                if (dev) {\n\n                    usb_send_msg(dev, USB_MSG_RESET);\n\n                    port->wPortChange |= PORT_STAT_C_RESET;\n\n                    /* set enable bit */\n\n                    port->wPortStatus |= PORT_STAT_ENABLE;\n\n                }\n\n                break;\n\n            case PORT_POWER:\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case ClearPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            switch(value) {\n\n            case PORT_ENABLE:\n\n                port->wPortStatus &= ~PORT_STAT_ENABLE;\n\n                break;\n\n            case PORT_C_ENABLE:\n\n                port->wPortChange &= ~PORT_STAT_C_ENABLE;\n\n                break;\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus &= ~PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_C_SUSPEND:\n\n                port->wPortChange &= ~PORT_STAT_C_SUSPEND;\n\n                break;\n\n            case PORT_C_CONNECTION:\n\n                port->wPortChange &= ~PORT_STAT_C_CONNECTION;\n\n                break;\n\n            case PORT_C_OVERCURRENT:\n\n                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;\n\n                break;\n\n            case PORT_C_RESET:\n\n                port->wPortChange &= ~PORT_STAT_C_RESET;\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case GetHubDescriptor:\n\n        {\n\n            unsigned int n, limit, var_hub_size = 0;\n\n            memcpy(data, qemu_hub_hub_descriptor,\n\n                   sizeof(qemu_hub_hub_descriptor));\n\n            data[2] = NUM_PORTS;\n\n\n\n            /* fill DeviceRemovable bits */\n\n            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;\n\n            for (n = 7; n < limit; n++) {\n\n                data[n] = 0x00;\n\n                var_hub_size++;\n\n            }\n\n\n\n            /* fill PortPwrCtrlMask bits */\n\n            limit = limit + ((NUM_PORTS + 7) / 8);\n\n            for (;n < limit; n++) {\n\n                data[n] = 0xff;\n\n                var_hub_size++;\n\n            }\n\n\n\n            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;\n\n            data[0] = ret;\n\n            break;\n\n        }\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7936, "substitutes": {"dev": ["pu", "di", "Dev", "gu", "private", "d", "conf", "ev", "dom", "w", "connection", "error", "die", "prom", "sd", " device", "ver", "proc", "var", "off", "user", "engine", "conn", "pack", "rad", "dn", "plug", "info", "valid", "server", "dist", "sh", "comment", "cam", "driver", "pad", "pub", "test", "end", "hw", "reg", "block", "md", "pro", "device", "home", "ad", "normal", "debug", "mod", "DEV", "serial", "temp", "development", "api", "app", "o", "ch", "od", "dd", "mid", "bug", "m", "de", "bus", "client", "ve", "def", "priv", "br", "diff"], "p": ["cp", "P", "o", "v", "pa", "po", "pp", "b", "i", "wp", "pe", "m", "f", "pi", "d", "pc", "q", "py", "np", "e", "w", "t", "fp", "jp", "h", "vp", "c", "ip", "g", "tp", "pb", "r"], "request": ["condition", "address", "name", "time", "Request", "header", "pull", "id", "method", "complete", "requ", "device", "effect", "config", "rf", "queue", "xml", "key", "resource", "rest", "event", "order", "version", "q", "param", "buffer", "message", "raw", "rx", "response", "result", "array", "input", "req", "frame", "re", "direction", "du", "attribute", "type", "report", "model", "query", "pair", "current", "reference", "r", "command", "mode"], "value": ["function", "address", "option", "name", "position", "v", "id", "change", "show", "fee", "device", "values", "balance", "update", "val", "feature", "style", "format", "unit", "key", "null", "valid", "content", "event", "version", "server", "service", "number", "size", "message", "driver", "response", "search", "result", "Value", "input", "scale", "mode", "start", "VALUE", "none", "off", "write", "type", "query", "test", "set", "command", "max", "expression", "end", "view", "age"], "index": ["position", "shape", "x", "object", "i", "token", "weight", "connect", "match", "initial", "connection", "array", "current", "expression", "view", "option", "name", "axis", "id", "list", "update", "val", "slice", "info", "valid", "number", "path", "height", "response", "ini", "operation", "node", "type", "element", "test", "tail", "end", "address", "alpha", "sync", "image", "inc", "key", "ion", "num", "version", "action", "timeout", "input", "network", "start", "pos", "level", "ind", "dim", "prefix", "open", "body", "in", "offset", "insert", "part", "context", "column", "Index", "diff"], "length": ["row", "build", "position", "padding", "id", "pull", "count", "shape", "tail", "val", "slice", "Length", "info", "loc", "sequence", "l", "offset", "duration", "number", "part", "len", "depth", "section", "level", "type", "library", "end", "view", "size"], "data": ["na", "a", "done", "di", "object", "i", "style", "status", "buf", "results", "state", "d", "actions", "buffer", "len", "error", "Data", "array", "output", "zero", "id", "config", "list", "val", "sum", "last", "info", "it", "DATA", "ops", "pad", "response", "batch", "fail", "new", "type", "end", "ui", "size", "bin", "block", "change", "alpha", "dat", "device", "ad", "wa", "map", "image", "key", "keys", "message", "timeout", "input", "start", "pos", "api", "cache", "next", "options", "o", "final", "format", "body", "window", "resource", "args", "part", "ata", "result", "none", "memory", "params", "first"], "s": ["o", "v", "is", "S", "http", "spec", "sg", "session", "b", "si", "sync", "i", "sys", "ses", "services", "m", "private", "f", "ns", "usb", "state", "server", "stats", "sl", "d", "service", "ss", "cs", "e", "w", "gs", "t", "ds", "self", "this", "h", "sp", "fs", "sa", "c", "g", "ssl", "r", "ps", "js"], "ret": ["flag", "reg", "rt", "al", "cur", "alt", "count", "id", "nt", "pat", "rot", "val", "last", "rc", "bit", "cat", "art", "let", "reply", "status", "valid", "num", " Ret", "fin", "lit", "att", "obj", "arg", "bad", "res", "match", "def", "len", "mt", "det", "error", "arr", "full", "RET", "fit", "pass", "feat", "rev", "result", "Ret", "run", "ft", "opt", "re", "usr", "fun", "back", "bf", "resp", "gt", "success", "ref", "rets"], "port": ["band", "serv", "component", "object", "Port", "pi", "state", "service", "document", "match", "proxy", "connection", "mount", "nat", "public", "pool", "import", "ver", "user", "plugin", "option", "cp", "pid", "id", "parent", "config", "pod", "slice", "module", "pt", "rib", "server", "table", "target", "driver", "pad", "rule", "ip", "type", "model", "class", "pl", "test", "group", "end", "patch", "address", "pin", "PORT", "tun", "device", "image", "key", "ion", "export", "post", "mod", "ports", "select", "point", "t", "source", "contract", "api", "app", "machine", "od", "v", "ported", "session", "pipe", "m", "tag", "project", "client", "rest", "child", "ve", "part", "plane", "report", "ort", "pair", "host", "manager"], "n": ["r", "name", "o", "v", "not", "nn", "nt", "x", "b", "nc", "i", "sn", "sync", "m", "in", "l", "num", "f", "N", "ns", "d", "j", "init", "net", "u", "len", "all", "e", "en", "out", "t", "k", "fn", "nb", "ne", "network", "z", "un", "none", "node", "c", "ln", "g", "ind", "y", "br", "current", "no", "on", "min", "conn"]}}
{"project": "FFmpeg", "commit_id": "7684a36113fa12c88ba80b5498f05849a6b58632", "target": 0, "func": "static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st = s->streams[pkt->stream_index];\n\n    MXFStreamContext *sc = st->priv_data;\n\n    MXFIndexEntry ie = {0};\n\n\n\n    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {\n\n        mxf->index_entries = av_realloc(mxf->index_entries,\n\n            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));\n\n        if (!mxf->index_entries) {\n\n            av_log(s, AV_LOG_ERROR, \"could not allocate index entries\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) {\n\n            av_log(s, AV_LOG_ERROR, \"could not get mpeg2 profile and level\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (!mxf->header_written) {\n\n        if (mxf->edit_unit_byte_count) {\n\n            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        } else {\n\n            mxf_write_partition(s, 0, 0, header_open_partition_key, 1);\n\n        }\n\n        mxf->header_written = 1;\n\n    }\n\n\n\n    if (st->index == 0) {\n\n        if (!mxf->edit_unit_byte_count &&\n\n            (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) &&\n\n            !(ie.flags & 0x33)) { // I frame, Gop start\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_partition(s, 1, 2, body_partition_key, 0);\n\n\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        }\n\n\n\n        mxf_write_klv_fill(s);\n\n        mxf_write_system_item(s);\n\n\n\n        if (!mxf->edit_unit_byte_count) {\n\n            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;\n\n            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;\n\n            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;\n\n            mxf->body_offset += KAG_SIZE; // size of system element\n\n        }\n\n        mxf->edit_units_count++;\n\n    } else if (!mxf->edit_unit_byte_count && st->index == 1) {\n\n        mxf->index_entries[mxf->edit_units_count-1].slice_offset =\n\n            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;\n\n    }\n\n\n\n    mxf_write_klv_fill(s);\n\n    avio_write(pb, sc->track_essence_element_key, 16); // write key\n\n    if (s->oformat == &ff_mxf_d10_muxer) {\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            mxf_write_d10_video_packet(s, st, pkt);\n\n        else\n\n            mxf_write_d10_audio_packet(s, st, pkt);\n\n    } else {\n\n        klv_encode_ber4_length(pb, pkt->size); // write length\n\n        avio_write(pb, pkt->data, pkt->size);\n\n        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);\n\n    }\n\n\n\n    avio_flush(pb);\n\n\n\n    return 0;\n\n}\n", "idx": 7967, "substitutes": {"s": ["S", "a", "b", "status", "support", "f", "d", "service", "conf", "w", "self", "h", "aws", "sa", "g", "sym", "sets", "is", "spec", "slice", "services", "states", "server", "sl", "ls", "native", "sie", "ops", "bis", "ds", "ts", "settings", "sv", "fs", "sq", "site", "rs", "stat", "as", "sg", "plugins", "comments", "sync", "ses", "opens", "cs", "e", "an", "sb", "t", "qs", "tests", "p", "c", "os", "ssl", "set", "r", "ps", "o", "v", "http", "less", "session", "si", "sys", "m", "details", "l", "client", "ns", "stats", "space", "us", "ss", "gs", "storage", "n", "su", "request", "es", "js"], "pkt": ["tkg", "Pkt", "pct", " pwk", "pwk", " peth", "fk", "Pk", "spwk", "tacket", "facket", "Packet", "teth", "spkt", "spct", " pct", "peth", "Pct", " pk", "spacket", "pk", "Peth", "Pwk", "Pkg", "tkt", " pkg", "packet", "fct", "fkt", "pkg", " packet"], "mxf": ["Mfc", "tmxe", "nxd", "pxe", "pxd", "dcf", "pmxf", "fmcf", "tmxd", " mxc", "tmcf", "cmxb", "mxc", "pmxe", "Mxc", "cmxd", " mxd", "pcf", "pxb", "mcf", " mfc", " mffe", "pmxc", "nfc", "Mxf", "dxf", "cmxe", "cmxc", "fmxc", "gxd", "dxa", "pxf", "pmxa", "cmcf", " mxe", "mxa", "mxb", " mxb", "mffe", " mcf", "Mxd", "fmxe", "ncf", "tmxf", "pxc", "cmxf", "fmxf", "cmxa", "fmxb", "mxd", "Mxe", "fmxd", "nxa", "Mffe", "cmffe", " mxa", "Mxb", "Mcf", "Mxa", "mxe", "fmxa", "mfc", "cmfc", "nxf", "dxc", "gfc", "gxf", "gxc", "nxc"], "pb": ["cp", "bp", "hub", "platform", "pa", "rb", "typ", "wp", "lp", "stab", "fb", "db", "wb", "uf", "pm", "buf", "pg", "mp", "soc", "prot", "pc", "sb", "ctx", "bc", "PB", "cb", "fp", "pool", "amp", "vp", "gb", "ppa", "ub", "utils", "tp", "fc", "cv", "pl", "rob", "cpp", "summary", "tc"], "st": ["std", "est", "fr", "ste", "store", "ost", "sw", "pp", "si", "style", "sn", "typ", "pt", "ace", "stab", "sts", "sk", "rest", "f", "d", "sl", "pc", "service", "td", "e", "sth", "sb", "ist", "inst", "se", "sh", "sd", "t", "ts", "ST", "str", "ie", "p", "sta", "stage", "ft", "sp", "start", "step", "sa", "c", "ct", "src", "set", "ast", "nd"], "sc": ["osc", "ch", "anc", "cr", "sw", "cus", "rc", "uc", "cl", "soc", "pc", "cc", "sci", "ss", "cs", "mc", "esc", "cer", "bc", "ca", "sp", "sa", "capt", "sq", "lc", "cv", "SC", "src"], "edit_units_count": ["edit_units_total", "edit_units_number", "edit_unit_sum", "edit_units_content", "edit_units2number", "edit_units_length", "edit_units2field", "edit_unit_count", "edit_units_field", "edit_unit_total", "edit_units_sum", "edit_unitsdaycontent", "edit_unitsdaycount", "edit_unitsdaysum", "edit_unit_code", "edit_unit_content", "edit_units_part", "edit_units_code", "edit_units2code", "edit_unit_number", "edit_units2count", "edit_unit_field", "edit_unit_length"]}}
{"project": "qemu", "commit_id": "3ad493fc5ea38c005670adc5933058a28ccabdd4", "target": 0, "func": "int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,\n\n                              int access_type, int mmu_idx, int is_softmmu)\n\n{\n\n    uint32_t phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,\n\n                        &page_size);\n\n    if (ret == 0) {\n\n        /* Map a single [sub]page.  */\n\n        phys_addr &= ~(uint32_t)0x3ff;\n\n        address &= ~(uint32_t)0x3ff;\n\n        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,\n\n                      page_size);\n\n        return 0;\n\n    }\n\n\n\n    if (access_type == 2) {\n\n        env->cp15.c5_insn = ret;\n\n        env->cp15.c6_insn = address;\n\n        env->exception_index = EXCP_PREFETCH_ABORT;\n\n    } else {\n\n        env->cp15.c5_data = ret;\n\n        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))\n\n            env->cp15.c5_data |= (1 << 11);\n\n        env->cp15.c6_data = address;\n\n        env->exception_index = EXCP_DATA_ABORT;\n\n    }\n\n    return 1;\n\n}\n", "idx": 7972, "substitutes": {"env": ["energy", "el", "ef", "environment", "inv", "et", "enter", "ace", "state", "conf", "ev", "err", "exec", "equ", "Environment", "ec", "output", "proc", "engine", "conn", "ah", "extra", "vm", "config", "qt", "edge", "nc", "eu", "inet", "server", "iss", "ctx", "ne", "viron", "eve", "txt", "site", " environment", "forge", "end", "osc", "eng", "er", "po", "exc", "db", "export", "ext", "esi", "ce", "net", "np", "e", "que", "en", "dev", "erv", "global", "loader", "enable", "etr", "ea", "session", "vt", "enc", "event", "estate", "context", "qa", "eni", "console", "cv", "host", "manager"], "address": ["name", "area", "host", "email", "entry", "ress", "device", "config", "Address", "socket", "object", "password", "data", "alias", "database", "image", "enter", "ace", "inet", "route", "resource", "holder", "offset", "event", "at", "order", "state", "server", "url", "phrase", "number", "code", "interface", "buffer", "uri", "target", "connection", "en", "error", "message", "port", "path", "array", "context", "output", "asm", "network", "eni", "pointer", "memory", "attribute", "ip", "location", "type", "site", "ref", "test", "reference", "addr", "index", "keep", "ast", "mode", "end", "size"], "access_type": ["accessalcode", "access_types", "accessalinfo", " accessalformat", "accessOinfo", "access_code", "accessOcode", "access_info", "access_py", " accessalsize", "accessalpy", "accessalstate", " accessaltype", "access_state", " access_info", "accessaltype", "accessOstate", " access_py", " access_format", "accessalname", " accessalinfo", "ace_info", " access_name", "accessaltypes", "ace_state", "ace_code", "access_name", " access_types", "accessOtype", "accessalformat", "accessalsize", "access_size", " access_state", " access_size", "access_format", "ace_type"], "mmu_idx": ["mmu_idev", "mmu_idg", "mmu__namect", "mmu_iqxes", "mmu_namexes", "mmu_idz", "mmu_idn", "mmu_inc", "mmu_namex", "mmu_iqx", "mmu__idz", "mmu_inv", "mmu_idxes", "mmu_IDc", "mmu_idex", "mmu_Idc", "mmu_idct", "mmu_namez", "mmu_ipct", "mmu_idv", "mmu_iqct", "mmu_Idx", "mmu_namect", "mmu__namex", "mmu_idc", "mmu_ideg", "mmu_inx", "mmu_Idg", "mmu_IDg", "mmu__idx", "mmu__namez", "mmu_idec", "mmu__idct", "mmu_ipxes", "mmu__namexes", "mmu_ipz", "mmu_Idn", "mmu_ing", "mmu_IDx", "mmu_ipx", "mmu__idxes", "mmu_iqz", "mmu_IDn"], "is_softmmu": ["is_hardmmi", "is_softMMtu", "is_softmmi", "is_softMMu", "is_hardmmtu", "is_softmmmcu", "is_hardmmu", "is_softmmmu", "is_softmmtu", "is_softmmmi", "is_softmmmtu", "is_softMMcu", "is_softmmcu", "is_hardmmcu", "is_softMMi"], "phys_addr": ["phys_work", "phys2work", "physfack", "phys_data", "phys2address", "phys_add", "physnaddr", "physnwork", "physical_work", "physfaddress", "phys_align", "physical_ack", "physfalign", "phys_amp", "physical_data", "physical_add", "physical_ad", "physical_align", "physnaddress", "physnamp", "physical_addr", "phys_ack", "physical_address", "physical_amp", "physical_info", "phys2amp", "phys2addr", "phys_address", "phys_ad", "physfaddr", "phys_info"], "page_size": ["page1size", "row_size", "server___address", "page_type", "page_address", " page_content", "server_size", "page___size", "page___type", "page1limit", "row1limit", "page1scale", "server___size", "page_pos", "server_address", "server___type", "server_type", "row1size", "row1scale", "row1count", " page_pos", "row_count", "row_scale", "page1count", "page_content", "page___address", "page_scale", "page_count", "page_limit", "row_limit"], "prot": ["stat", "afi", "layer", "padding", "reset", "notes", "platform", "pro", "eth", "pat", "pre", "rot", "config", "password", "rf", "token", "Prot", "format", "pattern", "status", "offset", "lit", "ext", "att", "server", "dist", "cli", "def", "cert", "len", "col", "policy", "seq", "mode", "prop", "pos", "pointer", "primary", "proc", "fun", "type", "ref", "rep", "test", "addr", "conn", "dim", "prefix"], "ret": ["std", "flag", "reg", "reset", "rt", "mem", "alt", "hard", "nt", "pat", "val", "data", "rc", "et", "bit", "inter", "art", "reply", "valid", "lit", "ext", "att", "pet", "obj", "arg", "res", "match", "def", "code", "len", "det", "error", "out", "arr", "RET", "nat", "ben", "feat", "rl", "err", "rev", "result", "Ret", "ft", "re", "fail", "fun", "txt", "resp", "success", "ref", "rep", "addr", "phrase", "rets"], "is_user": ["is_ver", "is__user", "isalusr", " is__owner", "is_use", "isrettyusers", "is___users", "is___user", "is_owner", "isaluser", "is__ver", "isalusers", "is__use", "isrettyuser", " is_use", "is__users", " is_ver", " is_users", " is_owner", "isrettyuse", "is___use", " is__use", " is_usr", "isaluse", "is_users", "is__owner", "isrettyowner", " is__user", " is__users", "is___ver", "is_usr"]}}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n\n    return h->pps.chroma_qp_table[t][qscale];\n\n}\n", "idx": 7977, "substitutes": {"h": ["H", "hp", "ah", "hw", "v", "http", "ih", "b", "hhh", "i", "oh", "m", "image", "rh", "him", "php", "q", "hs", "ph", "hm", "mc", "w", "hh", "n", "ctx", "hl", "he", "self", "eh", "p", "context", "temp", "ahi", "ht", "c", "gh", "hr", "ha", "cache", "cpp", "img", "bh", "hd"], "t": ["ot", "name", "o", "axis", "tf", "ti", "v", "total", "i", "wt", "m", "pt", "title", "window", "tif", "f", "offset", "at", "d", "j", " T", "u", "e", "target", "out", "k", "n", "ant", "ts", "p", "tz", "pointer", "ta", "c", "g", "ct", "type", "transform", "dt", "tp", "tt", "T", "test"], "qscale": ["kcale", "quickgrade", "Qphase", "qcale", "wsize", "qrate", "qphase", "quickcale", "Qsize", "qsize", "quickrate", " qrate", "quickscale", "kscale", "qgrade", "ctphase", "wrate", "wphase", "ctsize", "Qrate", " qcale", "krate", "ctrate", "ctscale", " qgrade", "kgrade", "wscale", "Qscale"]}}
{"project": "FFmpeg", "commit_id": "fd92dafaff8844b5fedf94679b93d953939a7f7b", "target": 0, "func": "static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,\n\n                              int plane_idx, int is_key, int is_chroma)\n\n{\n\n    int blk, ret;\n\n    int i, j, bx, by;\n\n    uint8_t *dst, *ref, *ref_start, *ref_end;\n\n    int v, col[2];\n\n    const uint8_t *scan;\n\n    int xoff, yoff;\n\n    LOCAL_ALIGNED_16(int16_t, block, [64]);\n\n    LOCAL_ALIGNED_16(int32_t, dctblock, [64]);\n\n    int coordmap[64];\n\n    int ybias = is_key ? -15 : 0;\n\n    int qp;\n\n\n\n    const int stride = frame->linesize[plane_idx];\n\n    int bw = is_chroma ? (c->avctx->width  + 15) >> 4 : (c->avctx->width  + 7) >> 3;\n\n    int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3;\n\n\n\n    binkb_init_bundles(c);\n\n    ref_start = frame->data[plane_idx];\n\n    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;\n\n\n\n    for (i = 0; i < 64; i++)\n\n        coordmap[i] = (i & 7) + (i >> 3) * stride;\n\n\n\n    for (by = 0; by < bh; by++) {\n\n        for (i = 0; i < BINKB_NB_SRC; i++) {\n\n            if ((ret = binkb_read_bundle(c, bc, i)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        dst  = frame->data[plane_idx]  + 8*by*stride;\n\n        for (bx = 0; bx < bw; bx++, dst += 8) {\n\n            blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES);\n\n            switch (blk) {\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                scan = bink_patterns[bitstream_read(bc, 4)];\n\n                i = 0;\n\n                do {\n\n                    int mode = bitstream_read_bit(bc);\n\n                    int run  = bitstream_read(bc, binkb_runbits[i]) + 1;\n\n\n\n                    i += run;\n\n                    if (i > 64) {\n\n                        av_log(c->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    if (mode) {\n\n                        v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = v;\n\n                    } else {\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                    }\n\n                } while (i < 63);\n\n                if (i == 63)\n\n                    dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                break;\n\n            case 2:\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTRA_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp);\n\n                c->binkdsp.idct_put(dst, stride, dctblock);\n\n                break;\n\n            case 3:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8*stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                c->bdsp.clear_block(block);\n\n                v = binkb_get_value(c, BINKB_SRC_INTER_COEFS);\n\n                read_residue(bc, block, v);\n\n                c->binkdsp.add_pixels8(dst, block, stride);\n\n                break;\n\n            case 4:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTER_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp);\n\n                c->binkdsp.idct_add(dst, stride, dctblock);\n\n                break;\n\n            case 5:\n\n                v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                c->bdsp.fill_block_tab[1](dst, v, stride, 8);\n\n                break;\n\n            case 6:\n\n                for (i = 0; i < 2; i++)\n\n                    col[i] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                for (i = 0; i < 8; i++) {\n\n                    v = binkb_get_value(c, BINKB_SRC_PATTERN);\n\n                    for (j = 0; j < 8; j++, v >>= 1)\n\n                        dst[i*stride + j] = col[v & 1];\n\n                }\n\n                break;\n\n            case 7:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                break;\n\n            case 8:\n\n                for (i = 0; i < 8; i++)\n\n                    memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);\n\n                c->bundle[BINKB_SRC_COLORS].cur_ptr += 64;\n\n                break;\n\n            default:\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Unknown block type %d\\n\", blk);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (bitstream_tell(bc) & 0x1F) // next plane data starts at 32-bit boundary\n\n        bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F));\n\n\n\n    return 0;\n\n}\n", "idx": 7980, "substitutes": {"c": ["cp", "ch", "cr", "cur", "ci", "config", "b", "com", "nc", "rc", "cy", "cat", "co", "C", "uc", "m", "l", "cl", "f", "d", "pc", "cc", "cs", "ce", "arc", "center", "u", "con", "mc", "e", "code", "dc", "t", "k", "ctx", "cu", "cb", "self", "coll", "context", "p", "ctrl", "ca", "ec", "cit", "g", "ct", "cf", "lc", "ac", "vc", "cache", "r", "cm", "cd", "tc"], "frame": ["game", "base", "scene", "flow", "fr", "position", "block", "component", "flower", "scope", "config", "bug", "b", "ze", "object", "force", "slice", "module", "m", "image", "Frame", "sequence", "db", "draw", "f", "state", "d", "series", "q", "document", "service", "ce", "code", "e", "zone", "cell", "que", "plane", "fram", "file", "df", "ctx", "cycle", "framework", "lock", "load", "coll", "p", "context", "parse", "scale", "range", "setup", "cf", "core", "frames", "model", "element", "set", "cm", "panel", "feature"], "bc": ["oc", "BC", "gc", "anc", "cr", "config", "nc", "rc", "cca", "uc", "db", "mac", "cl", "pc", "cc", "cs", "con", "mc", "sc", "dc", "lib", "ctx", "cms", "cb", "context", "ec", "ca", "lc", "cf", "fc", "CBC", "ac", "vc", "cm", "xc", "tc"], "plane_idx": ["plane_ipx", "plane_idz", "plane_timey", "plane_Idc", "plane_idc", "plane_indxe", "plane___idh", "plane___indxe", "plane_aidxes", "plane_ende", "plane_identx", "plane_adc", "plane_miny", "plane_pidz", "plane_endx", "plane_idxx", "plane_Idx", "plane_Idz", "plane_idh", "plane_idez", "plane_minx", "plane_kidz", "plane_adx", "plane_idced", "plane___ide", "plane_idente", "plane_idy", "plane_idexes", "plane___indx", "plane_aidx", "plane_aidpe", "plane_endxe", "plane_idv", "plane_pidxe", "plane_Idxx", "plane_pidx", "plane_ridxe", "plane_ipz", "plane_ridced", "plane_idex", "plane_idxe", "plane_pidxx", "plane_timexe", "plane_endh", "plane_inde", "plane_kidxes", "plane_minxes", "plane___indh", "plane_indh", "plane_indx", "plane_idpe", "plane_kidx", "plane___idxe", "plane_adv", "plane_Idxe", "plane_ipxe", "plane_identh", "plane_ide", "plane_minpe", "plane___inde", "plane_kidX", "plane_idxes", "plane___idx", "plane_idev", "plane_idec", "plane_ridy", "plane_ideX", "plane_Idv", "plane_timex", "plane_ipxx", "plane_timeced", "plane_ridx", "plane_idX", "plane_adz", "plane_aidy", "plane_identxe"], "is_key": ["ispubrow", "is_row", "IS_switch", " is_loop", "isLogloop", "IS__switch", "is_root", " is_row", "is_loop", "is2key", "is__key", "IS__keys", "ispubroot", "is2keys", "IS_key", "isLogrow", "is__switch", "is2switch", "is_keys", "IS__char", "ispubloop", "ispubkey", "is_switch", "is2char", "is__char", "isLogkey", "IS__key", "isLogroot", "IS_char", " is_root", "is_char", "is__keys", "IS_keys"], "is_chroma": ["is_portA", "is_opera", "is_opersa", "is_cyclA", "is_cyclsa", "is_chromA", "is_relb", "is_chromas", "is_porta", "is_servas", "is_porto", "is_chromaa", "is_operaf", "is_chromaf", "is_chromb", "is_romo", "is_relA", "is_romb", "is_operA", "is_serva", "is_cycla", "is_relas", "is_romas", "is_romA", "is_roma", "is_portaa", "is_romaa", "is_chromsa", "is_rela", "is_cyclaf", "is_chromo", "is_servb", "is_servA"], "blk": ["blok", "silok", "silak", "BLks", "brok", "plck", " blkk", "Blck", " blck", "plok", "plkk", "Blks", "blkk", "plch", " blks", "blck", "plk", "BLck", "blch", "silk", "brak", " blok", "BLok", "blks", "brk", "BLk", "Blk", "plak", "Blok", "blak", "Blkk", "plks", "silch", "brch"], "ret": ["miss", "flag", "reg", "mem", "rt", "alt", "pin", "nt", "value", "vt", "get", "val", "data", "info", "reply", "status", "fin", "ru", "lit", "job", "res", "match", "def", "len", "det", "error", "out", "arr", "sb", "RET", "pass", "mi", "feat", "err", "rev", "result", "mini", "Ret", "re", "fail", "fun", "txt", "bl", "success", "fi", "cache", "r", "replace", "rets"], "i": ["gi", "ti", "id", "I", "is", "chi", "di", "ik", "ci", "ki", "ji", "ni", "b", "x", "si", "io", "xi", "slice", "ri", "info", "bi", "m", "abi", "qi", "ix", "l", "f", "pi", "yi", "phi", "iu", "ii", "d", "it", "ai", "u", "e", "ami", "uri", "ori", "n", "multi", "mi", "ini", "ie", "p", "jit", "h", "mini", "eni", "start", "oi", "hi", "ip", "im", "y", "api", "li", "fi", "index", "zi", "ui"], "j": ["ot", "ch", "note", "jump", "ji", "ni", "xi", "si", "m", "key", "ij", "it", "py", "J", "je", "jc", "k", "n", "jp", "p", "span", "z", "pos", "ind", "g", "y", "adj", "r"], "bx": ["dy", "dbx", "fz", "fy", "fw", "dbX", "dbz", "dx", "px", "fx", "dv", " bX", "bw", "bX", "py", " bw", "dX", "dw", "dz", " bz", " bv", "bz", "dby", "dbw", "bv", "dbv", "pw", "pX"], "by": ["row", "to", "serv", "reg", "bin", "not", "count", "s", "acc", "device", "browser", "b", "ri", "use", "si", "or", "io", "x", "rel", "ray", "bi", "in", "ber", "before", "key", "db", "with", "at", "how", "it", "service", "from", "ry", "us", "BY", "u", "the", "byn", "via", "per", "about", "port", "By", "mi", "bys", "of", "be", "re", "range", "g", "type", "report", "br", "query", "y", "ly", "app", "index", "no", "r"], "dst": ["idsts", "dedst", "gbl", "dbl", "gsc", "idst", "adsc", "dsc", "dedx", "dx", "dedsts", "pdsts", "dnd", "dsts", "pdrest", "idbl", " dnd", "adnd", "pdst", " dsts", " dsc", "gnd", "drest", "bsts", "adst", " drest", " dbl", " dct", "pdx", " dx", "gst", "dedrest", "bst", "bbl", "bct", "idct", "dct", "adbl"], "ref": ["base", "reg", "block", "mem", "count", "config", "val", "x", "Ref", "rel", "loc", "f", "offset", "def", "buffer", "source", "re", "pos", "ind", "range", "cache", "reference", "index", "src", "rec", "diff"], "ref_start": ["ref_stop", "REF_first", "reference_stop", "REF_start", "REF_change", "reference_end", "ref_change", "reference_step", "ref_first", "reference_start", "REF_end", "ref_step"], "ref_end": ["refsset", "refsstart", "reflexstart", "reflexmax", "cachelexmax", "refsmax", "refxend", "ref_set", "cache_start", "refxuntil", "cachelexstart", "cachelexend", "refxstart", "reference_end", "cache_max", "reflexend", "reflexset", "reference_start", "ref_max", "cache_end", "ref_until", "cache_set", "reference_until", "refsend", "cachelexset"], "v": ["V", "vt", "val", "b", "m", "uv", "l", "f", "conv", "q", "u", "vi", "vs", "w", "n", "p", "h", "z", "vert", "sv", "g", "y", "lv", "cv", "vc"], "col": ["cp", "row", "ch", "ann", "reg", "el", "channel", "rot", "sect", "val", "bit", "cat", "co", "Col", "unit", "loc", "key", "cl", "fl", "cell", "con", "win", "coll", "seq", "column", "pos", "dim"], "scan": ["stat", "find", "look", "row", "ann", "reg", "bin", "block", "config", "skip", "sync", "slice", "ignore", "cat", "info", "sn", "mask", "loc", "call", "align", "match", "split", "conf", "sc", "path", "search", "parse", "span", " scanner", "batch", "gen", "ver", "Scan", "can", "range", "read", "query", "chan", "cache", "syn", "test", "index"], "xoff": [" xOFF", "exOff", "exOFF", "xOff", "Xoff", " xOff", "XOff", "XOFF", "exoff", "xOFF"], "yoff": ["yOFF", "yOff", "yshift", "Yshift", " yOff", "Yoff", " yOFF", "vyoff", "vyOFF", " yshift", "vyshift", "YOFF", "vyOff", "YOff"], "coordmap": ["ordmap", "ordgroup", "ordMap", "pixelmap", "pixelMap", "pixelblock", "coordmaps", "pixelgroup", "catMap", "coordblock", "catmaps", "ordmaps", "coordMap", " coordblock", "coordgroup", "catmap", "catblock", " coordgroup", "pixelmaps", "ordblock"], "qp": [" qP", " ql", "iql", "Ql", "ql", "qP", "iqP", "iqp", "Qp", "QP"]}}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7982, "substitutes": {"f": ["fr", "tf", "elf", "buff", "sf", "v", "fw", "b", "io", "i", "m", "fx", "l", "d", "fe", "e", "file", "t", "fn", "df", "fac", "fp", "fa", "p", "fm", "h", "fs", "c", "g", "fd", "bf", "fc", "ref", "fi", "F"], "opaque": [" opec", "opula", "ospxc", "ospquire", "opque", "ocaque", "oula", "ospec", "oaque", "ocque", "ipec", "ospaque", "ospque", "ipaque", "oque", "opec", "ocaques", "ospula", " opxc", "opxc", "ocula", "opaques", "opquire", "ospaques", " opquire", "ipquire", "ipxc", "oaques"], "size": ["sec", "_", "value", "val", "data", "enc", "unit", "vals", "Size", "code", "len", "ctx", "empty", "eval", "z", "iv", "alloc", "pos", "g", "fi"], "cpu": ["cp", "fat", "hw", "platform", "pu", "vm", "config", "val", "socket", "fork", "auc", "gpu", "pc", "linux", "net", "np", "clock", "instance", "kernel", "p", "pool", "processor", "ec", "pty", "boot", "eni", "proc", "c", "node", "core", "fc", "cache", "fi", "cow", "loader", "CPU", "conn"], "env": ["est", "energy", "el", "ef", "rb", "environment", "style", "oa", "et", "buf", "conf", "ev", "bc", "exec", "err", "equ", "Environment", "ec", "stage", "proc", "engine", "fi", "conn", "ah", "vm", "config", "edge", "eu", "inet", "fb", "assets", "eb", "ctx", "ne", "eval", "viron", "essential", "cf", "chal", "cookie", "fg", "eng", "vel", "exc", "agent", "export", "obj", "exe", "cli", "net", "np", "vs", "e", "que", "en", "inst", "dev", "erv", "global", "core", "cache", "loader", "fen", "ea", "v", "scope", "enc", "uv", "attr", "args", "fe", "priv", "estate", "context", "eni", "iv", "console", "skin", "cv"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_handle_byte(int ch)\n\n{\n\n    switch(term_esc_state) {\n\n    case IS_NORM:\n\n        switch(ch) {\n\n        case 1:\n\n            term_bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n", "idx": 7992, "substitutes": {"ch": ["cp", "quit", "cr", "chin", "cur", "count", "Char", "ech", "chi", "change", "channel", "prev", "kick", "che", "quote", "last", "i", "enc", "cy", "tch", "cha", "ich", "th", "cl", "chu", "state", "length", "cher", "q", "u", "code", "Ch", "cell", "col", "sh", "power", "cho", "k", "cor", "cmd", "ctx", "zh", "sch", "character", "qu", "p", "chn", "h", "cht", "c", "range", "y", "utf", "chan", "ach", "CH", "cod", "text", "command", "och", "inch"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)\n\n{\n\n    struct omap_l4_s *bus = g_malloc0(\n\n                    sizeof(*bus) + ta_num * sizeof(*bus->ta));\n\n\n\n    bus->ta_num = ta_num;\n\n    bus->base = base;\n\n\n\n#ifdef L4_MUX_HACK\n\n    omap_l4_io_entries = 1;\n\n    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));\n\n\n\n    omap_cpu_io_entry =\n\n            cpu_register_io_memory(omap_l4_io_readfn,\n\n                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);\n\n# define L4_PAGES\t(0xb4000 / TARGET_PAGE_SIZE)\n\n    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);\n\n#endif\n\n\n\n    return bus;\n\n}\n", "idx": 8010, "substitutes": {"base": ["bas", "address", "kit", "name", "area", "axis", "stable", "padding", "extra", "block", "id", "store", "count", "entry", "la", "beta", "pa", "balance", "b", "ada", "alias", "home", "bi", "unit", "status", "null", "db", "ma", "offset", "pi", "length", "byte", "buffer", "out", "pad", "ase", "rate", "prefix", "array", "p", "scale", "ca", "Base", "boot", "gb", "zero", "start", "bf", "type", "cache", "ases", "ref", "addr", "index", "size"], "ta_num": ["tta_len", "sa_num", "ta_nom", "ta_len", "taNtun", "taNsum", "sa_number", "ta1Num", "ta__number", "ta1fn", "ta_sum", "sa_nom", " ta_pos", "ta2Num", " ta_id", " ta_tun", "ta_n", "sa_n", "ta1len", "ta2number", "taNpos", "tta_num", "ta1number", "ta_tun", "taNnum", "tta_Num", "ta_con", "ta_number", "ta__len", "tta2number", "ta__Num", "ta1con", "ta_fn", "ta2num", "ta_id", "ta_Num", " ta_con", "ta1id", "tta2num", "ta__num", "ta1num", "tta2Num", " ta_fn", "tta_number", "ta2len", "tta2len", "ta_pos", " ta_sum"], "bus": ["plugin", "machine", "pack", "feed", "block", "hub", "http", "bits", "BUS", "device", "config", "plug", "bug", "b", "object", "data", "use", "sync", "bit", "io", "abi", "gpu", "queue", "Bus", "i", "route", "buf", "usb", "length", "obj", "las", "service", "us", "select", "def", "mount", "connection", "out", "proxy", "driver", "port", "clock", "dev", "lib", "pass", "phys", "bc", "str", "bridge", "controller", "result", "input", "serial", "boot", "cpu", "proc", "os", "back", "class", "board", "cache", "fi", "prefix"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n", "idx": 8018, "substitutes": {"dev": ["ch", "od", "block", "md", "rad", "di", "Dev", "dd", "device", "adv", "nt", "plug", "data", "ani", "enc", "ad", "info", "dem", "der", "debug", "gu", "bus", "client", "d", "obj", "mod", "dist", "conf", "ev", "def", "dom", "wd", "priv", "w", "comment", "die", "da", "sd", "dc", "lib", "oy", "kid", "self", "pub", "development", "ver", "node", "user", "model", "engine", "desc", "app", "test", "grad", "conn", "diff", "cd"], "dest": ["append", "del", "iter", "done", "disabled", "home", "pipe", "loc", "buf", "wh", "lit", "dist", "des", "dir", "wd", "priv", "target", "die", "dc", "ds", "suff", "Dest", "coord", "feat", "source", "seq", "temp", "opt", "trans", "prop", "pos", "gen", "sup", "head", "decl", "front", "desc", "text", "test", "src", "seed", "dim", "end"], "len": ["fat", "vec", "ann", "el", "count", "alt", "la", "nt", "pre", "ell", "val", "non", "enc", "ll", "in", "body", "ix", "fin", "lit", "length", " length", "ls", "part", "en", "fn", "lib", "win", "err", "lon", "str", "seq", "span", "un", "sp", "pos", "line", "fun", "Len", "ln", "fail", "lc", "lin", "li", "pl", "syn", "lf", "min", "size"], "child": ["sub", "row", "ch", "build", "feed", "friend", "block", "cur", "id", "count", "parent", "local", "device", "ell", "last", "data", "enc", "children", "l", "plus", "f", "client", "leaf", "sl", "server", "boy", "code", "comment", "lib", "kid", "root", "draft", "Child", "node", "slave", "new", "sel", "fd", "inner", "desc", "current", "app", "end", "add"], "sep": ["sepc", "lept", "sept", "sepr", " sepc", "sem", " sept", "semp", "sempr", "lep", "psepa", "psep", " sepr", " sem", "psept", "psepr", "lepa", " seg", "psem", "peg", "pseg", "pepc", "pem", "sempc", "pepr", "pep", " sepa", "pepa", "seg", "sepa", "lepr", "semm"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    direntry_t* direntry;\n\n    const char* dirname = mapping->path;\n\n    int first_cluster = mapping->begin;\n\n    int parent_index = mapping->info.dir.parent_mapping_index;\n\n    mapping_t* parent_mapping = (mapping_t*)\n\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n\n\n\n    DIR* dir=opendir(dirname);\n\n    struct dirent* entry;\n\n    int i;\n\n\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n\n\n    if(!dir) {\n\n        mapping->end = mapping->begin;\n\n        return -1;\n\n    }\n\n\n\n    i = mapping->info.dir.first_dir_index =\n\n            first_cluster == 0 ? 0 : s->directory.next;\n\n\n\n    if (first_cluster != 0) {\n\n        /* create the top entries of a subdirectory */\n\n        (void)create_short_and_long_name(s, i, \".\", 1);\n\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n\n    }\n\n\n\n    /* actually read the directory, and allocate the mappings */\n\n    while((entry=readdir(dir))) {\n\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n\n        char* buffer;\n\n        direntry_t* direntry;\n\n        struct stat st;\n\n        int is_dot=!strcmp(entry->d_name,\".\");\n\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n\n\n\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n\n            continue;\n\n\n\n        buffer = g_malloc(length);\n\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n\n\n\n        if(stat(buffer,&st)<0) {\n\n            g_free(buffer);\n\n            continue;\n\n        }\n\n\n\n        /* create directory entry for this file */\n\n        if (!is_dot && !is_dotdot) {\n\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n\n        } else {\n\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n\n        }\n\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n\n        direntry->reserved[0]=direntry->reserved[1]=0;\n\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n\n        direntry->adate=fat_datetime(st.st_atime,0);\n\n        direntry->begin_hi=0;\n\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n\n        if(is_dotdot)\n\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n\n        else if(is_dot)\n\n            set_begin_of_direntry(direntry, first_cluster);\n\n        else\n\n            direntry->begin=0; /* do that later */\n\n        if (st.st_size > 0x7fffffff) {\n\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n\n            g_free(buffer);\n\n            closedir(dir);\n\n            return -2;\n\n        }\n\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n\n\n\n        /* create mapping for this file */\n\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n\n            s->current_mapping = array_get_next(&(s->mapping));\n\n            s->current_mapping->begin=0;\n\n            s->current_mapping->end=st.st_size;\n\n            /*\n\n             * we get the direntry of the most recent direntry, which\n\n             * contains the short name and all the relevant information.\n\n             */\n\n            s->current_mapping->dir_index=s->directory.next-1;\n\n            s->current_mapping->first_mapping_index = -1;\n\n            if (S_ISDIR(st.st_mode)) {\n\n                s->current_mapping->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n", "idx": 8021, "substitutes": {"s": ["address", "strings", "o", "serv", "sets", "sf", "is", "S", "http", "spec", "single", "b", "si", "sync", "sys", "ses", "services", "m", "status", "states", "side", "f", "ns", "state", "stats", "server", "ls", "d", "service", "space", "ss", "us", "u", "e", "sb", "gs", "secondary", "t", "storage", "ds", "su", "self", "source", "p", "south", "settings", "sv", "fs", "sa", "os", "c", "g", "ssl", "sq", "sym", "y", "your", "site", "es", "rs", "r"], "mapping_index": ["mapping_i", "mappingIDname", "matching_id", "matching_weight", "mappingAindex", "mapping_id", "matching_i", "matching_name", "mappingAweight", "mappingAname", "matching_Index", "mapping_Index", "mapping_name", "mappingAi", "mappingIDindex", "mapping_weight", "mappingIDweight", "mappingIDi", "matching_index"], "mapping": ["napping", "matching", "amapped", "Mashing", "pappings", "mapped", "smapping", "smapped", "dinding", "Minding", "smapper", "tmapper", "papper", "maming", "dapping", "smouting", "nigration", "ymutation", "Matching", " mappings", "Mapped", "Mutation", "minding", "smashing", "natching", "digration", "mmashing", "lapper", "smatching", "smappings", "tmatching", "map", "fapper", "mappings", "mouting", "Mappings", "lappings", "tmappings", "ymapping", "mmapping", "lapping", "amapping", "Mapper", "migration", "mmapped", "faming", "mashing", "Mapping", "datching", "finding", "mapper", "papped", "fapping", "amapper", "ymapper", "papping", " mapper", "daming", "tmigration", "Maming", "mmappings", "amappings", "napper", "tmutation", "Mouting", " map", "ymigration", "louting", "pap", "mutation", "dapper", "tmapping", "Map", "Migration"], "direntry": ["dIREncry", "direrentrys", "dorentry", "direntrie", "direrentri", "dIREntrys", "direndrie", "direrentry", "direndRY", "dIREntries", "direntries", "directrys", "dorerentrie", "diregentries", "dIREncrys", "dIREntRY", "direndry", "dpirerentr", "dorentrys", "direncRY", "direncries", "dpirentri", "direrentr", "direrentrie", "direntr", "directries", "direntrys", "dpirentries", "dIREntry", "direndrys", "dpirentr", "direncrys", "dorerentry", "direndries", "dpirentry", "direntRY", "dorentrie", "directrie", "dorerentries", "dpirerentries", "diregentr", "direndri", "dIREncRY", "dpirerentri", "direncry", "direndr", "direntri", "directRY", "dorerentrys", "dIREncries", "directry", "dorentries", "diregentry", "diregentri", "direrentries", "dpirerentry"], "dirname": ["directorypath", "dirName", "dirpart", "directiontype", "directorytype", "dirpath", "filepath", "filetype", "filepart", "directoryname", "dbresource", " dirfile", "folderpath", " dirpart", "directorynm", "dirnm", "directionpath", "modulepath", "dirtype", " dirpath", " directoryresource", " directorypath", "foldernm", " dirresource", "modulename", "dbname", "foldername", "directionName", "filenm", "directoryName", " directoryname", "filename", "directionname", "dirfile", "dirresource", "folderName", "modulepart", " directoryfile", "fileName", "dbpath", "dbfile"], "parent_mapping": ["parent_mashing", "parent_papped", "parent_Mapper", "parent_amapper", "parent__mapping", "parent_Mapping", "parent_papping", "parent_Mashing", "parent_Maming", "parent_pashing", "parent_amapping", "parent_papper", "parent_amashing", "parent__smashing", "parent__mashing", "parent_mmapping", "parent_smapper", "parent_dapping", "parent__smapped", "parent_mmashing", "parent_amapped", "parent_smapped", "parent_smaming", "parent__smapper", "parent_maming", "parent_mapped", "parent__mapped", "parent__mapper", "parent_dapper", "parent_dapped", "parent_mapper", "parent_mmapper", "parent_mmapped", "parent__smapping", "parent_smashing", "parent_daming", "parent_smapping", "parent_Mapped"], "dir": ["dy", "dr", "iter", "di", "data", "dest", "record", "rel", "f", "d", "service", "match", "file", "finder", "tree", "folder", "rec", "mode", "name", "Dir", "id", "cur", "parent", "dn", "config", "module", "info", "DIR", "sl", "dist", "da", "zip", "lib", "path", "direct", "work", "doc", "group", "block", "io", "home", "map", "loc", "db", "inc", "director", "wd", "source", "global", "c", "ind", "desc", "cache", "r", "dict", "sub", "sort", "alias", " directory", "m", "ir", "attr", "init", "dc", "directory", "root", "req", "draft", "direction", "inner", "manager", "diff"], "entry": ["archive", "dr", "row", "feed", "id", "try", "object", "data", "inter", "or", "si", "record", "info", "image", "enter", "key", "inc", "letter", "ga", "insert", "event", "post", "ries", "d", "server", "sl", "j", "escape", "service", "match", "ry", "e", "cell", "uri", "error", "connection", "se", "comment", "action", "her", "item", "ent", "ie", "source", "result", "parse", "reader", "ner", "ge", "line", "import", "start", "ident", "engine", "inner", "element", "Entry", "index", "no", "directory", "end", "view", "add"], "i": ["gi", "ti", "id", "I", "di", "ci", "ni", "xi", "ri", "si", "io", "x", "abi", "info", "bi", "m", "qi", "l", "yi", "pi", "phi", "j", "ii", "iu", "d", "it", "ai", "e", "uri", "multi", "ini", "ie", "p", "mini", "eni", "oi", "hi", "ind", "ip", "c", "li", "inner", "fi", "index", "ui"], "buffer": ["writer", "base", "address", "fr", "row", "feed", "buff", "header", "position", "iter", "block", "count", "channel", "value", "uffer", "b", "data", "stack", "stream", "queue", "buf", "window", "resource", "uf", "f", "fb", "null", "capacity", "url", "server", "length", "document", "table", "byte", "bb", "size", "comment", "message", "binary", "Buffer", "file", "pad", "result", "source", "input", "array", "output", "reader", "ptr", "transfer", "line", "shell", "memory", "read", "flash", "text", "cache", "reference", "copy"], "st": ["std", "est", "ste", "cr", "store", "b", "stack", "stream", "ace", "sts", "rest", "d", "sl", "St", "fe", "e", "sc", "sth", "sb", "stop", "se", "inst", "t", "storage", "ST", "str", " str", "ptr", "start", "step", "ct", "STR", "put", " r", "r", "nd"]}}
{"project": "FFmpeg", "commit_id": "dc5d1515681b57a257443ba72bb81fb3e6e6621b", "target": 0, "func": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n\n{\n\n    const char *p;\n\n    char *q, buf1[20], c;\n\n    int nd, len, addchar_count;\n\n    int found_count = 0;\n\n\n\n    q = buf;\n\n    p = filename;\n\n    for (;;) {\n\n        c = *p;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '%' && *(p+1) == '%')  // %%\n\n            addchar_count = 2;\n\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n\n            nd = 0;\n\n            addchar_count = 1;\n\n            while (av_isdigit(*(p + addchar_count))) {\n\n                nd = nd * 10 + *(p + addchar_count) - '0';\n\n                addchar_count++;\n\n            }\n\n\n\n            if (*(p + addchar_count) == placeholder) {\n\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n\n                if (len < 1)  // returned error or empty buf1\n\n                    goto fail;\n\n                if ((q - buf + len) > buf_size - 1)\n\n                    goto fail;\n\n                memcpy(q, buf1, len);\n\n                q += len;\n\n                p += (addchar_count + 1);\n\n                addchar_count = 0;\n\n                found_count++;\n\n            }\n\n\n\n        } else\n\n            addchar_count = 1;\n\n\n\n        while (addchar_count--)\n\n            if ((q - buf) < buf_size - 1)\n\n                *q++ = *p++;\n\n            else\n\n                goto fail;\n\n    }\n\n    *q = '\\0';\n\n    return found_count;\n\nfail:\n\n    *q = '\\0';\n\n    return -1;\n\n}\n", "idx": 8046, "substitutes": {"buf": ["cp", "cas", "buff", "vec", "header", "box", "qq", "rb", "config", "b", "data", "rc", "queue", "uc", "uu", "loc", "fb", "wb", "uf", "ru", "f", "lit", "length", "bu", "buffer", "que", "bag", "file", "port", "Buffer", "cmd", "ctx", "bc", "fp", "cb", "seq", "pool", "array", "context", "h", "back", "cf", "br", "cv", "text", "ref", "pb", "cache", "aux", "front", "fi", "ff", "prefix"], "buf_size": ["buf_sized", "uf_size", "buf6number", "bag_sized", " buf_SIZE", "bag_size", "buf_rate", "buf6sized", "bag6size", "bag_number", "uf_scale", "buf_number", "bag6sized", "buf_SIZE", "buf_scale", "uf_rate", "bag6number", "buf6size", " buf_scale"], "filename": ["r", "files", "bp", "buff", "sf", "config", "b", "nc", "xp", "queue", "m", "l", "uf", "f", "original", "np", "initial", "buffer", "fil", "w", "file", "binary", "fn", "directory", "ctx", "path", "fp", "source", "seq", "kl", "txt", "bf", "fd", "il", "fc", "phrase", "Filename", "prefix"], "placeholder": ["Placepoint", "Placeparent", "Placehold", "Placeolder", "hideholders", "paceholder", "replacehold", "Placeholder", "placesholder", "placeholders", "fallholder", "pacehold", "fallholders", "placesholders", "placeparent", "paceholders", "hideolder", " placeolder", " placeparent", "placeolder", "placehold", "fallhold", "fallpoint", "replaceholder", "placepoint", "pacepoint", "hideholder", "replaceholders", " placehold", "placeshold", "Placeholders", " placeholders", "hideparent"], "number": ["function", "name", "position", "v", "not", "change", "count", "id", "nn", "note", "value", "even", "non", "object", "final", "data", "b", "i", "x", "sn", "nc", "digit", "umbers", "num", "null", "inc", "umeric", "N", "length", "nr", "numbered", "byte", "e", "en", "pn", "day", "fn", "n", "result", "one", "year", "z", "zero", "line", "ln", "class", "umber", " Number", "reference", "no", "r", "Number", "external"], "p": ["cp", "P", "pid", "o", "bp", "v", "pr", "a", "parent", "s", "pin", "pa", "x", "pat", "pre", "po", "b", "pp", "op", "i", "up", "wp", "pipe", "pe", "lp", "ap", "m", "pt", "l", "f", "pi", "post", "pg", "d", "j", "pc", "py", "param", "ph", "np", "u", "part", "e", "point", "dp", "pn", "port", "t", "k", "n", "fp", "jp", "h", "vp", "sp", "pos", "ip", "g", "y", "api", "tp", "pl", "pb", "r", "ps"], "q": ["cp", "ch", "quick", "buff", "iq", "v", "cur", "id", "qq", "count", "s", "qt", "b", "x", "i", "pe", "queue", "m", "qi", "quant", "ix", "cl", "f", "ue", "dq", "d", "fl", "u", "buffer", "e", "sh", "code", "w", "que", "comment", "port", "qs", "Q", "t", "n", "ctx", "k", "question", "qu", "qa", "req", "h", "z", "g", "back", "sq", "y", "query", "cache", "r", "quest"], "buf1": [" buf2", "uf2", "bufn", " bufone", "bufone", "buffer0", "bufferb", "buffern", "buff2", "buf0", "ufone", "uf1", "buf2", "buffone", "buff1", "bagone", "buff0", "buffn", "buffer2", " bufb", "bag0", "ufb", "buffer1", "ufn", "bag1", " buf0", "bufb", "uf0", "bag2"], "c": ["cp", "ch", "o", "unc", "cr", "v", "count", "s", "ci", "b", "nc", "exc", "i", "cy", "enc", "C", "uc", "l", "f", "d", "cc", "cs", "ce", "u", "code", "con", "e", "col", "w", "comment", "sc", "mc", "k", "t", "n", "ctx", "dc", "cu", "coll", "ec", "z", "g", "ct", "cn", "lc", "cf", "ac", "vc", "r", "cd", "xc"], "nd": ["std", "rn", "nl", "yd", "nw", " nu", "od", "md", "bd", "nn", "dn", "dd", "nt", "wn", " dd", "pp", "nc", "inn", "odd", "sn", "ND", "pd", "ad", "rd", " ad", "inc", "edd", "ng", "und", "dk", "d", " gn", "nr", " ng", "nu", "td", "np", "pn", "da", "dev", "sd", "n", "nz", "nb", " d", "ne", "old", "z", "ld", "ind", " ne", "ln", "unn", "gd", "gn", " en", "cd", " delta"], "len": ["lang", "v", "kn", "el", "count", "nn", "la", "nt", "lt", "val", "b", "nc", "lan", "sn", "ll", "l", "num", "fin", "f", "lit", "ler", "lim", "limit", "length", "fl", "sl", "ls", "e", "en", "L", "n", "lu", "lib", "led", "lon", "err", "rl", "nb", "coll", "ie", "z", "ner", "sp", "pos", "line", "ln", "ind", "Len", "ld", "lin", "lc", "dl", "li", "lf", "no", "min", "le", "size"], "addchar_count": ["addChar_Count", "addchar_size", "addchar_Count", "addcharacter_limit", "addChar_count", "addchar__size", "addchar_name", "addchar_ref", "addcharacter_Count", "addchar_c", "addchar_limit", "addcharacter_size", "addChar_c", "addbyte_count", "addcharacter_length", "addchar__ref", "addchar_code", "addcharacter_count", "addcharacter_ref", "addcharacter_cache", "addChar_size", "addbyte_offset", "addchar\u00b7count", "addchar\u00b7ref", "addcharacter_c", "addchar__count", "addchar_offset", "addchar_length", "addbyte_c", "addchar\u00b7size", "addchar_cache", "addcharacter_code"], "found_count": ["found_counter", "found_number", "found\u00b7info", "foundancetotal", " found_code", "foundianparent", "foundiantotal", " found_parent", " found_number", "found_code", " found_counter", "foundiancount", "found_info", "foundancecount", " found_info", "found_parent", "found\u00b7counter", "found_total", "foundanceparent", "found\u00b7count", "foundoutnumber", "foundoutcount", "foundoutcode", " found_total"]}}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "func": "static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n", "idx": 8049, "substitutes": {"args": ["lang", "GS", "gr", "limits", "ig", "ins", "spec", "arms", "sg", "alls", "atts", "config", "words", "ages", "Args", "enc", "xml", "states", "ants", "parts", "ns", "arg", "py", "init", "cs", "conf", "np", "actions", "fields", "ass", "parser", "gs", "ks", "arr", "ds", "qs", "ts", "same", "pres", "parse", "asm", "aws", "Arg", "am", "fs", "g", "ms", "ams", "ids", "params", "ras", "conn", "flags", "js"], "s": ["r", "o", "serv", "sf", "v", "is", "S", "spec", "sg", "session", "b", "si", "sync", "i", "sys", "ses", "services", "m", "states", "so", "f", "ns", "state", "stats", "sl", "ls", "d", "service", "cs", "ss", "conf", "hs", "u", "e", "sb", "gs", "uns", "ks", "t", "ds", "n", "qs", "ts", "su", "p", "south", "h", "aws", "fs", "sup", "c", "g", "ssl", "sq", "y", "rs", "ps", "js"], "err": ["ah", "dr", "gr", "fr", "rn", "er", "fg", "cr", "pr", "rr", "aster", "bug", "ise", "sys", "der", "rh", "tx", "rage", "ir", "f", "ler", "magic", "res", "ev", "code", "e", "error", "ar", "arr", "dev", "good", "lr", "cb", "str", "result", "aaa", "req", "h", "mr", "doc", "var", "ind", "txt", "orig", "resp", "lc", "y", "Er", "pl", "fi", "rs", "kr", "r", "conn", "Error", "msg"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n", "idx": 8071, "substitutes": {"espaddr": ["ispaddress", "osparm", "lpaddress", "spaddress", "ispaddr", "spreq", "espAddress", "ospaddress", "spaddr", " espaddress", "espconfig", "espreq", "ospaddr", "esparm", "espaddress", "lpaddr", "lpAddress", " espconfig", "lparm", "spconfig", "ispconfig", "ispreq", " espreq", "spAddress", "ospAddress", "sparm"], "it_shift": ["it_set", "itfwrite", "it__size", "it__shift", "lit_size", "itfpush", "it_size", "it_dist", "lit_offset", "its_push", "it_offset", "it2size", "lit_shift", "it2shift", "itfset", "itwshift", "it2dist", "its_write", "bit_count", "bit_shift", "itwset", "itfshift", "itwpush", "it__count", "it_write", "bit_length", "its_shift", "its_set", "it_push", "it__length", "bit_size", "it2offset", "it_length", "it1size", "itwwrite", "it1dist", "lit_dist", "it_count", "it1offset", "it1shift"], "dma_memory_read": ["dma_memoryxend", "dma_memory_end", "dma_memoryxread", "dma_mem_end", "dma_memoryingload", "dma_mem_read", "dma_memoryingread", "dma_memoryxwrite", "dma_memoryxload", "dma_memory_load", "dma_memoryingupdate", "dma_mem_update", "dma_mem_write", "dma_memory_update", "dma_mem_add", "dma_mem_load", "dma_memory_add", "dma_memoryingwrite"], "dma_memory_write": ["dma_memory2read", "dma_memoryqwrite", "dma_mem_only", "dma_memoryqsend", "dma_memory\u00b7only", "dma_memory\u00b7value", "dma_memory_send", "dma_mem_read", "dma_memoryqread", "dma_memory_writer", "dma_memory\u00b7write", "dma_mem_write", "dma_memoryqvalue", "dma_memory\u00b7send", "dma_mem_value", "dma_mem_writer", "dma_mem_send", "dma_memory_only", "dma_memory\u00b7read", "dma_memory_value", "dma_memory2write", "dma_memory2writer"], "dma_opaque": ["dma_copity", "dma_topause", "dma_ipity", "dma_compac", "dma_ipause", "dma_compaco", "dma_topity", "dma_opause", "dma_operacity", "dma_copause", "dma_ipaque", "dma_ospaque", "dma_ipacity", "dma_opacity", "dma_compacity", "dma_ipgate", "dma_opaco", "dma_topaque", "dma_ipac", "dma_copaque", "dma_operac", "dma_compaque", "dma_ipaco", "dma_topacity", "dma_copac", "dma_opity", "dma_ospac", "dma_copacity", "dma_copgate", "dma_opgate", "dma_ospacity", "dma_operaco", "dma_operaque", "dma_opac", "dma_ospgate"], "irq": ["rq", "rw", "rp", "irqs", " irqs", " irp", "ierqs", "iperq", "iperqs", " irw", "irquest", "ierquest", "ierk", "pirk", " irquest", "irp", "pirq", "pirp", "ierq", "irk", "rk", "irw", "pirw", "iperquest", " irk", "iperk"], "reset": ["master", "base", "destroy", "rot", "sync", "et", "format", "token", "protect", "unit", "offset", "at", "prot", "kill", "init", "res", "push", "initial", "stop", "det", "clock", "pad", "timeout", "nil", "response", "sleep", "req", "zero", "start", "pos", "primary", "none", "type", "clear", "destruct", "disable", "apply", "set", "index", "hard", "setup", "prefix"], "dma_enable": ["dma_update", "dma__adjust", "dma_adjust", "dma___enable", "dma_enabled", "dma__enable", "dga_enabled", "dma___enabled", "dga_adjust", "dma__online", "dma___update", "dma_online", "dma__enabled", "dga_update", "dga_enable", "dga_online"], "dev": ["hw", "ch", "dm", "od", "v", "md", "rad", "vd", "pro", "di", "Dev", "dd", "device", "spec", " dd", "bug", "error", "data", "ad", "dem", "m", "der", "debug", "gu", "bus", "de", "sk", "f", "d", "ve", "mod", "fo", "dist", "conf", "ev", "def", "DEV", "dom", "priv", "sh", "kind", " Dev", "w", "comment", "driver", "dc", "sd", "ds", " device", "cmd", "self", "devices", "temp", "serial", "req", "DC", "development", "ver", "c", "g", "gd", "engine", "app", "prov", "grad", "conn", "diff", "cd"], "s": ["r", "o", "serv", "sf", "v", "S", "spec", "sg", "si", "ssh", "sync", "sys", "ses", "services", "m", "sk", "f", "ns", "stats", "d", "ls", "sl", "service", "cs", "ss", "u", "vs", "e", "sh", "sc", "w", "sb", "gs", "se", "ds", "sd", "tests", "t", "n", "su", "self", "p", "south", "sp", "fs", "os", "c", "g", "ssl", "sym", "es", "rs", "sup", "ps", "js"], "sysbus": ["ysstate", "systemdef", "darself", "Sysdef", "ysbus", " sysdef", "sysbit", "Sysboot", "darbus", "ysbit", "sysBus", "systemboot", "sysstate", "systemself", " sysself", "systemstate", "sysusb", "darusb", "systemBus", "SysBus", "darboot", "Sysbus", " sysBus", " sysbit", " sysusb", "systemusb", "systembit", "sysdef", "ysBus", "ysboot", "systembus", " sysboot", "sysboot", "sysself", " sysstate"], "esp": ["cp", "hp", "gp", "cfg", "imp", "elf", "ep", "v", "ef", "sg", "eff", "ez", "pp", "si", "sync", "eph", "pe", "lp", "sn", "esh", "ssh", "ace", "wp", "sk", "soc", "esi", "py", "cli", "sci", "ss", "ev", "eb", "vs", "np", "cpp", "asp", "rpm", "jp", "ipes", "eps", "p", "ee", "eval", "amp", "vp", "ptr", "sp", "eve", "ssl", "resp", "lv", "api", "tp", "adr", "env", "PF", "ess", "esm", "es", "fi", "addr", "sup", "news", "ps", "isp"]}}
{"project": "FFmpeg", "commit_id": "aa6aa2ef091818c2669c48051286ce361401f31b", "target": 0, "func": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    float **audio      = (float **) frame->extended_data;\n\n    int len            = frame->nb_samples;\n\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n\n    int ch;\n\n    const float *win   = s->windows[window_index];\n\n    int window_len     = 1 << s->block_len_bits;\n\n    float n            = 2.0 * 32768.0 / window_len;\n\n\n\n    for (ch = 0; ch < avctx->channels; ch++) {\n\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n\n                                    win, len);\n\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n\n    }\n\n}\n", "idx": 8085, "substitutes": {"avctx": [" avcontext", " avcf", "avecb", "AVcf", "avectx", "Avconn", "afcb", "AVctx", "AVcontext", "avcca", "avcf", "avcb", "afctx", "avcal", "avecf", "avcontext", "ajcca", "Avcontext", "AVcb", "Avctx", "Avcca", "avecontext", "afconn", "afcf", "AVcal", "afcontext", "ajctx", "afcal", "ajcontext", "afcca", "avconn", "ajconn", " avcal"], "frame": ["game", "flow", "fr", "sf", "config", "b", "object", "data", "iframe", "slice", "i", "m", "image", "Frame", "sequence", "window", "f", "rame", "state", "j", "call", "d", "series", "document", "fe", "e", "w", "file", "fram", "motion", "voice", "ctx", "fp", "p", "z", "request", "c", "video", "cf", "frames", "board", "fi", "setup"], "s": ["sf", "S", "a", "b", "data", "i", "support", "f", "d", "service", "hs", "conf", "w", "self", "h", "aws", "g", "sym", "y", "is", "spec", "slice", "services", "ls", "sl", "native", "sim", "ds", "ctx", "ts", "settings", "sv", "fs", "sq", "your", "site", "rs", "stat", "as", "sg", "sync", "ses", "conv", "cs", "u", "vs", "e", "sb", "ks", "secondary", "t", "qs", "p", "c", "os", "ssl", "r", "ps", "o", "v", "scope", "session", "si", "sys", "m", "l", "xs", "side", "ns", "series", "us", "ss", "uns", "gs", "se", "full", "n", "su", "this", "sample", "es", "js"], "audio": ["archive", "address", "area", "aud", "mpeg", "alpha", "Audio", "a", "wave", "channel", "config", "ada", "data", "io", "analysis", "avi", "image", "library", "window", "mac", "picture", "media", "ai", "buffer", "binary", "volume", "voice", "application", "sound", "array", "input", "ca", "wav", "memory", "video", "api", "ac", "cm"], "mdct": [" mdCT", "mect", "mmcf", "hdect", "mmct", "mpcf", "hdct", "hdcf", "MDCT", " mdect", "MDc", "mdant", "mandct", "mcf", "mdnt", " mdnt", "mandect", "mdect", "MDant", "MDct", "mc", " mdcf", "mandnt", "MDcf", "mmnt", "mmect", "mpCT", "mpant", "MDect", "mdc", " mdant", "mdCT", "mdcf", "mandcf", "mpct", "hdc", "mct"], "ch": ["el", "chi", " chunk", "b", "i", "tch", "ich", "sk", "f", "conf", "code", "col", "cho", "cor", " Ch", "chn", "h", "ver", "y", "CH", "bh", "conn", " cs", "cp", "cur", "nt", "channel", "cher", "mot", "Ch", "sh", "zh", "sch", "work", "batch", "z", "cht", "arch", " chip", "pl", "fr", "change", "cha", "th", "cl", " col", "j", "ph", "oy", "k", "p", "c", "ach", "vc", "cel", "chrom", "chip", "pr", "ech", "che", "enc", "cy", " channel", "chu", "child", "q", "chart", "coll", "qu", "gh", "br", "chan", "och"], "win": ["screen", "bin", "v", "nn", "wave", "nt", "wan", "x", "inn", "data", "rec", "sn", "enc", "widget", "wa", "ll", "image", "in", "max", "window", "client", "gui", "windows", "net", "margin", "len", "con", "col", "w", "en", "scan", "won", "k", "n", "vin", "work", "p", "Win", "gen", "ln", "c", "y", "nan", "gn", "conn"]}}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,\n\n                                const uint8_t *s2, int stride)\n\n{\n\n    int i;\n\n    vec_u8 perm1 = vec_lvsl(0, s1);\n\n    vec_u8 perm2 = vec_lvsl(0, s2);\n\n    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);\n\n    vec_s16 shorts1, shorts2;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        vec_u8 pixl  = vec_ld(0,  s1);\n\n        vec_u8 pixr  = vec_ld(15, s1);\n\n        vec_u8 bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n", "idx": 8103, "substitutes": {"block": ["Block", "base", "name", "row", "pack", "time", "clean", "header", "position", "large", "bin", "copy", "square", "channel", "check", "word", "device", "blocking", "inv", "style", "pixel", "sync", "bit", "image", "mask", "unit", "window", "cl", "num", "offset", "version", "length", "byte", "number", "buffer", "all", "len", "col", "random", "clock", "section", "error", "full", "lock", "blocks", "batch", "frame", "pos", "line", "level", "none", "off", "ip", "range", "type", "page", "label", "user", "bl", "broad", "cache", "size"], "s1": ["ks101", "sone", "S127", "ses1", "ss4", "s101", "ks2", "S11", "gs1", "ps2", "sesONE", "gs2", "fone", "sin001", "ssone", "s127", " s11", "ses11", "f4", "s91", "ss2", "f1", "ss11", "f101", "sinONE", "ses2", "sp2", "fONE", "ss1", "ks001", "s001", "S2", "ss127", "sp5", "ss81", "ss91", "ses001", "rs1", "ps1", "pone", "site11", "s5", "S81", "S001", " s91", "s4", "s15", "s81", "S15", "ss01", " sA", "rs01", "sin1", "site127", "p4", "sp15", "S5", "f001", "p1", "gs001", "site1", "gs4", " s15", "s11", "SA", "rs91", "sA", "S4", "sONE", "ps101", "p2", " s5", "S1", "f2", "ps001", "sesA", "site81", "sp1", "ks1", "sin2", " s01", "rs2", "s01"], "s2": ["c5", "s20", " svec", "d2", "ks2", "d14", "south14", "S02", "Svec", "gs2", "inII", "size2", "ctwo", "s02", "gs\n", " s92", "p5", "size7", "d72", "sII", "in2", " s\n", "f1", "s92", "ksTwo", "p02", "s14", "cs72", "S2", "s72", "f7", " s0", "s7", "in02", " sTwo", "s56", "S\n", " s14", "size82", "f82", "south2", "f0", "cs2", "d22", "s5", "sTwo", "south1", "ptwo", " s82", "s4", " s22", "p62", "ks20", " s20", "d92", "c4", " s72", " sII", "svec", "stwo", "in56", "p4", "s62", "gsvec", "p1", " s4", " s56", "fTwo", " s62", " s02", "cs22", "south92", "cs1", "c2", "s82", "p2", "size0", "s\n", "s0", " s5", "S1", "s22", "S62", "f20", " s7", "f2", "d1", " stwo", "ks1"], "stride": ["drided", "arrided", "STRider", "STRidi", "shrider", "sprided", "striding", " strider", " strite", "privides", "STRide", "strided", "strider", "privise", "prividing", "STRip", "brided", "spriding", "sprince", "shride", "dividing", "arrince", " strance", "drance", " strided", " striding", "privide", "briding", "stridi", "arride", "strip", "bride", "strance", "brance", "dride", "strides", "divides", " stridi", " strides", " strip", "shridi", "spride", "brite", "strise", "strince", "shrip", "brince", "strite", "divide", "drite", "arriding", "divise", " strise"], "i": ["uni", "gi", "o", "ti", "v", "wei", "I", "a", "chi", "di", "ci", "ji", "ni", "x", "xi", "si", "io", "b", "ri", "abi", "info", "bi", "qi", "l", "f", "pi", "yi", "phi", "adi", "j", "iu", "ii", "d", "cli", "ai", "u", "e", "ami", "uri", "ori", "k", "n", "mi", "ini", "ie", "p", "eni", "pos", "oi", "hi", "c", "ip", "li", "fi", "index", "zi", "mu", "ui"], "shorts1": ["ghapes2", "shocksOne", "shocks1", "shortsOne", "shorter2", "shorts01", "short81", "howorters2", "ghorts9", " shorters2", " shorts31", "shortsone", "phapes0", "horts81", "hortsOne", "shints1", "shessions01", "hort1", "cliftsOnce", "shintsone", "shifts100", "shorts9", "shorter1", "shorters2", "shorts81", "hintsone", " shports1", "shocks81", "shorters1", "short4", "hints2", "clifts01", " shorts4", "phorts0", "shortsOnce", "ghapes9", "shores2", " shorters4", "shports01", "shports0", "shapesone", "shorter9", "shportsOnce", "ghapes1", " shorts100", "hortsone", "horts0", "phorts1", "howorts2", "shresses1", "hort81", "shresses31", "shports100", "shportsone", "clortsOnce", "clorts1", "shports2", "shapes1", "shoresOne", "ghorts1", "shores81", "shorts4", " shports31", "hortOne", "shorterone", "shresses100", "horts2", "howorts4", "hints1", "shifts01", "phorts2", "ghortsone", "shessions1", "howorters1", "shapes2", "shports1", "shortone", "shints2", "horts1", "hort0", "shorts31", "ghapesone", "howorts1", "shiftsOnce", "howorters4", "shorters4", "clifts1", "phapes2", "shifts1", "shports4", "shapes9", "shortOne", "shapes0", "hort2", "shocks2", "phapes1", "shores1", "short1", "clorts01", "short0", "ghorts2", "shports31", "short2", "shifts31", "shessionsOnce", "shorters0", " shports100", " shorters1", "shorts0", "shorts100", "short9"], "shorts2": ["shresses0", "chorts2", "shordsTwo", "shorter2", " shorttwo", " shortstwo", "swirts4", "chports22", "shports02", "horts02", "shifts2", "hort1", "shorter1", "chorts1", "shorters2", "swirts52", "shportsTwo", "shresses4", "shops4", "shorters1", "short4", "swirts2", "shresses22", "shords2", "shirts52", "shresses2", "shorts6", "short02", "sworts4", " shortsTwo", "hort4", "shorttwo", "shports0", "shapes4", "sworts52", "chports6", "shops2", "shirts2", "shports2", "shops1", "shortsTwo", "chports0", "shiftstwo", "shorts4", "shiftsTwo", "horts2", "hort02", "shports22", "sworts2", "shapes2", "shports1", "horts1", "chorts4", "horts4", "shords52", "shords4", "shorters4", " short2", "shorts52", "shifts1", "shports4", "shortTwo", "shapes0", "shirts4", "shortertwo", "hort2", "shorts22", "shports6", "shops02", "shorterTwo", "shports52", "short1", "chports4", "shapes22", "chports1", "chorts0", "short2", " short1", "short6", "swortsTwo", "chports2", "shortstwo", " shortTwo", "shorters6", "shorts02", "chorts6", "chorts22", "shorts0", "swirtsTwo", "shirtsTwo"]}}
{"project": "FFmpeg", "commit_id": "199d4478de102ca7987adb97f2e66a1820a98ebd", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n", "idx": 8105, "substitutes": {"avctx": ["ajconfig", "evconn", "avesys", "aveci", "auxc", "ajctl", "macconn", "navcn", "evcontext", "aveqa", "aulc", "avcomponent", "abcmp", "navcontext", "afxc", "aveconfig", "afctx", "afsc", "avqa", "afsys", "vertx", "ajctx", "navctx", "ausys", "abcf", "avconv", "avsys", " avcontext", "verxc", "attctx", "evcmp", "aucontext", "avescope", "afci", "afcmp", "avcmp", "afcn", "avectl", "abcontext", "navcu", "avalctx", "avxc", "ajcu", "aveconn", "AVcmp", "avecontext", "afcf", "avlc", "attcontext", "AVcu", "AVconn", "avecu", "avelc", "avalcontext", "ajconv", "aflc", "attcmp", "afctl", "vercontext", "avcu", "navcmp", "avconfig", "AVcontext", "aveconv", "macctx", "avalcomponent", "navcf", "avcontext", " avcn", "attcf", "afqa", "ajqa", "navsc", "avconn", "autx", "evctx", "abctx", "ajconn", "avcn", "AVcf", "avctl", "afconv", "auci", "avectx", " avsc", "avetx", "AVctx", "avalcmp", "afscope", "avcf", "maccf", "aftx", "avalconn", "avscope", "avecf", "avtx", "avsc", "avecomponent", "verctx", "maccontext", "afconn", "afcontext", "afconfig", "afcomponent", "ajcontext", "avalscope", "auctx", "avci", "avecmp", "afcu"], "f": ["fen", "flow", "fr", "tf", "feed", "sf", "v", "fw", "parent", "b", "x", "rf", "i", "info", "m", "fx", "fb", "l", "j", "d", "fl", "q", "fe", "conf", "u", "e", "per", "file", "t", "fn", "ff", "n", "fac", "df", "fp", "k", "framework", "fa", "h", "frame", "z", "fs", "c", "bf", "fd", "g", "cf", "fc", "ref", "fi", "form", "lf", "F"], "p": ["patch", "cp", "plugin", "P", "o", "bp", "v", "a", "parent", "s", "pa", "pre", "pp", "b", "op", "i", "up", "wp", "ap", "lp", "pe", "m", "l", "pm", "pi", "client", "post", "php", "j", "d", "pc", "py", "q", "param", "np", "u", "part", "e", "point", "per", "port", "t", "k", "n", "ctx", "fp", "jp", "exec", "this", "h", "vp", "sp", "proc", "c", "ip", "g", "y", "api", "br", "tp", "cache", "pb", "r"], "progress": ["patch", "flow", "gr", "cmp", "recent", "imp", "act", "area", "diff", "press", "id", "complete", "done", "parent", "scope", "update", "Progress", "data", "xp", "queue", "debug", "status", "track", "resource", "content", "order", "grade", "wait", "dist", "cli", "push", "error", "depth", "history", "path", "feat", "exec", "callback", "process", "result", "scale", "qa", "stage", "mode", "step", "range", "resp", "asc", "move", "desc", "success", "activity", "cache", "next", "max", "dim"], "err": ["dr", "gr", "fr", "ch", "er", "cr", "iter", "id", "rr", "count", "fee", "pre", "bug", "exc", "rc", "or", "i", "in", "ace", "status", "rh", "rage", "l", "attr", "phi", "order", "grade", "bar", "res", "ctr", "acer", "code", "e", "all", "error", "comment", "out", "arr", "dev", " error", "n", "cb", "lr", "str", "nil", "result", "raise", "req", "h", "runner", "mr", "var", "ind", "errors", "orig", "resp", "y", "br", "c", "inner", "cache", "test", "r", "diff", "Error", "msg"]}}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "substitutes": {"task": ["patch", "game", "master", "pack", "clean", "complete", "parent", "device", "scope", "config", "kick", "object", "module", "tty", "asks", "tag", "tx", "resource", "event", "project", "content", "call", "ack", "target", "item", "error", "message", "instance", "empty", "ask", "exec", "process", "result", "theme", "work", "load", "source", "this", "tile", "level", "rule", "slave", "contract", "type", "thread", "Task", "test", "app", "command", "worker"], "errp": ["errvp", "rp", " errvp", "erP", "resultp", "resultP", "rvp", " errcp", "errP", "irvp", " errP", "resultps", "erps", "rP", " errps", "irp", "irps", "ercp", "errps", "resultcp", "erp", "rps", "errcp", "irP"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n", "idx": 8112, "substitutes": {"s": ["o", "sets", "v", "is", "S", "spec", "sg", "b", "si", "sys", "ses", "services", "l", "xs", "f", "ns", "ls", "bs", "ss", "cs", "sis", "e", "sc", "sb", "ops", "ks", "gs", "ds", "t", "n", "ctx", "qs", "ts", "su", "p", "css", "fs", "ssl", "sq", "sym", "es", "rs", "ps", "js"], "c": ["cp", "oc", "ch", "o", "cr", "ci", "config", "b", "co", "C", "uc", "cm", "l", "cl", "f", "d", "pc", "cc", "cs", "ce", "u", "con", "mc", "e", "dc", "k", "n", "ctx", "t", "bc", "cu", "p", "ic", "ca", "ec", "h", "acs", "g", "lc", "cf", "ac", "vc", "conn", "cd", "tc"], "i": ["gi", "o", "ti", "v", "id", "I", "di", "ik", "ci", "ki", "ji", "ni", "b", "x", "si", "xi", "ri", "io", "info", "bi", "qi", "ix", "l", "f", "pi", "yi", "d", "ii", "iu", "it", "ai", "u", "e", "ori", "k", "n", "mi", "ini", "p", "h", "eni", "z", "oi", "hi", "ind", "ip", "y", "li", "index", "r", "zi", "ui"], "j": ["jet", "dy", "fr", "o", "v", "pr", "el", "a", "oj", "jl", "ji", "b", "xi", "x", "bi", "m", "qi", "kj", "l", "key", "f", "job", "ij", "d", "aj", "it", "q", "ii", "u", "e", "jen", "w", "J", "je", "jc", "k", "t", "n", "json", "uj", "jp", "jo", "err", "p", "z", "jj", "off", "g", "y", "ja", "dj", "br", "li", "adj", "bj", "js"], "os": ["ot", "as", "oc", "nos", "options", "o", "ans", "oses", "is", "osi", "oS", "dos", "po", "op", "object", "osa", "io", "oa", "ow", "ros", "et", "sys", "or", "ok", "obs", "so", "mos", "ols", "ns", "org", "obj", "mot", "ls", "bs", "us", "cs", "u", "des", "vs", "e", "rss", "ops", "ks", "ol", "ds", "OS", "oes", "oss", "of", "p", "ou", "css", "pos", "fs", "oi", "acs", "los", "bos", "iso", "oid", "Os", "aos", "es", "oos", "js"]}}
{"project": "FFmpeg", "commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "target": 1, "func": "yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n", "idx": 8124, "substitutes": {"buf0": ["bag250", " buf2", "uf2", "uf50", "buff250", "buff2", "uf1", "buf2", "buf50", "buffk", "ufk", "buff1", "uf250", "buff0", "bufk", " bufk", "buf250", "bag0", " buf50", "bag1", "uf0", "buff50"], "buf1": [" buf2", "uf2", "bufn", "auc1", "cf1", "uf11", "ufOne", "uf1", "buf2", "cfOne", "buff1", " bufOne", "buff0", "auc11", "buf11", "buffn", "cf2", "buff11", "ufn", "auc0", "uf0", "bufOne", "aucn"], "abuf0": ["abbuff0", "bbuf5", "bbuf1", "abuf5", "abbuff2", "fabuf3", "abbuf1", "fabuf1", "abbuff5", "abuf2", "bbuf2", "abbuf2", "abbuf5", "bbuf0", "fabef0", "abbuff1", "fabef1", "buf2", "abuff5", "abbuf3", "abuf3", "fabuf0", "buf5", "abef3", "abef0", "abuff2", "abbuf0", "abuff0", "abuff1", "abef1", "abbuff3", "fabef3"], "abuf1": ["abbuff0", "abaf0", "buf100", "bbuf1", "abbuf100", "abbuf1", "abuch0", "abafn", "abuf2", "bbuf2", "abufn", "bbuf100", "abbuffn", "abbuf2", "abbufn", "ebufn", "ebbuff0", "bbuf0", "abuf100", "abbuff1", "abuch1", "ebbuffn", "ebuf1", "buf2", "ebbuff1", "abuch100", "abuff100", "abuch2", "abuff2", "abaf1", "abbuf0", "abuff0", "abuff1", "ebuf0"], "i": ["isi", "I", "a", "chi", "di", "ci", "x", "b", "xi", "bi", "f", "pi", "d", "ii", "my", "w", "h", "line", "oi", "g", "y", "li", "fi", "index", "zi", "gi", "ti", "id", "is", "slice", "info", "module", "ix", "phi", "\u0438", "it", "ai", "uri", "field", "mi", "ini", "ie", "z", "ip", "type", "anti", "ui", "ni", "io", "key", "adi", "j", "cli", "u", "e", "k", "t", "source", "p", "start", "c", "r", "mu", "o", "v", "si", "m", "in", "qi", "l", "iu", "init", "part", "n", "multi", "eni", "inner"], "A": ["H", "D", "BA", "P", "U", "AA", "An", "Ac", "alpha", "a", "I", "W", "S", "AY", "Y", "V", "Ca", "M", "Am", "C", "O", "Offset", "HA", "API", "AS", "G", "CA", "AP", "K", "N", "AM", "MA", "E", "L", "As", "NA", "Q", "Alpha", "AI", "B", "AC", "LA", "GA", "R", "ACA", "IA", "SA", "X", "T", "Z", "mA", "Ang", "AF", "F", "TA"]}}
{"project": "qemu", "commit_id": "f7b879e072ae6839b1b1d1312f48fa7f256397e2", "target": 1, "func": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n", "idx": 8130, "substitutes": {"obj": ["o", "act", "objects", "id", "parent", "Obj", "nt", "tmp", "po", "ob", "object", "ex", "data", "b", "module", "pt", "db", "att", "org", "j", "conf", "dom", "ops", "inst", "bot", "instance", "ctx", "cmd", "cb", "jp", "self", "nb", "coll", "boot", "prop", "pos", "node", "os", "api", "bo", "cache", "conn", "js"], "dev": ["di", "Dev", "adv", "object", "data", "gu", "d", "conf", "ev", "dom", "error", "w", "die", "sd", " device", "err", "self", "ver", "var", "off", "g", "gd", "user", "conn", "cd", "del", "id", "rad", "dn", "plug", "kick", "info", "valid", "av", "dist", "comment", "driver", "ds", "pub", "fail", "node", "new", "test", "prov", "end", "hw", "block", "md", "device", "ad", "debug", "db", "mod", "wd", "DEV", "oy", "app", "ch", "dm", "od", "v", "dd", "bug", "dem", "der", "de", "client", "event", "child", "ve", "def", "priv", "dc", "gh", "diff"], "bus": ["base", "ch", "block", "store", "hub", "id", "pull", "parent", "BUS", "session", "plug", "bug", "val", "object", "io", "home", "sync", "cat", "stick", "Bus", "unit", "db", "tx", "cart", "f", "usb", "book", "state", "child", "bs", "us", "dir", "mount", "usa", "driver", "lib", "bc", "pass", "lock", "bridge", "controller", "coll", "serial", "boot", "proc", "board", "front", "cache", "host", "ass"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n", "idx": 8134, "substitutes": {"value": ["function", "base", "option", "name", "v", "block", "parent", "fee", "word", "values", "val", "object", "data", "style", "b", "bit", "image", "unit", "valid", "key", "null", "job", "media", "state", "enabled", "weight", "number", "w", "error", "comment", "depth", "message", "result", "source", "end", "scale", "prefix", "variable", "start", "VALUE", "rule", "type", "element", "index", "reference", "mode", "Value", "feature", "size"], "qb": ["sqfb", "qabe", "qxb", "quba", "queryb", "qbe", "Qrb", "querycb", "sqb", "Qbb", "qbb", "qfb", "Qfb", "iqxb", " qcb", "Qb", "qubb", "iqba", "iqbb", "qacb", "eqlb", "dqba", "quxb", "eqbb", "quf", " qfb", " qbb", "sqbb", " qlb", "sqB", "qbs", "qab", " qrb", "querybe", "qufb", "dqbb", "qub", "qlb", "qrb", "iqb", "qbase", "QB", " qbe", "qba", "qcb", "Qbs", "qf", "qubi", "querybase", "eqbi", " qbs", "Qf", " qbase", "sqbs", "qulb", " qB", "eqb", " qbi", "dqb", "qabase", "qbi", "dqxb", " qf", "qB", "sqrb"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n", "idx": 8145, "substitutes": {"usig": ["usigma", "rusigen", " usigen", "versigma", "usigs", " usigh", "usigh", "usesig", "usiger", " usiger", "rusig", "usesigen", "usigen", "rusigh", "usesigma", "usesigh", "usesiger", "versigs", " usigs", "versiger", "rusiger", "usesigs", "versig", " usigma"], "ka": ["ko", "KA", "ea", "na", "java", "ker", "aka", "ket", "a", "oka", "ua", "ki", "la", "channel", "config", "che", "ada", "oa", "wa", "ae", "market", "ia", "ya", "ma", "ga", "ra", "ema", "ai", "sc", "en", "da", "fram", "ctx", "sea", "ba", "ama", "qua", "context", "ca", "qa", "eni", "kee", "sa", "ta", "ke", "ja", "jam", "ku", "au", "ha", "ok"], "info": ["stat", "name", "area", "ret", "inf", "diff", "ui", "id", "http", "INFO", "ci", "config", "information", "si", "i", "alias", "inter", "abi", "raf", "image", "loc", "ir", "f", " inf", "isu", "ii", "fo", "py", "init", "ai", "conf", "code", "uri", "error", "mi", "ini", "where", "start", "hi", "txt", "api", "iso", "util", "desc", "fi", "index", "isf", "summary", "conn", "Info", "setup"], "set": ["stat", "base", "kit", "ch", "act", "sets", "reset", "build", "block", "not", "is", "spec", "dat", "send", "chain", "config", "setting", "get", "sem", "ex", "see", "sche", "use", "et", "SET", "update", "sys", "export", "Set", "state", "call", "init", "net", "match", "e", "sh", "sc", "section", "en", "se", "exec", "context", "parse", "ne", "ec", "settings", "ut", "run", "vert", "start", "gen", "ind", "sel", "c", "clear", "site", " en", "end", "setup"], "env": ["enable", "fen", "osc", "eng", "act", "ea", "ect", "ep", "v", "el", "ef", "vm", "dat", "scope", "config", "qt", "environment", "exc", "et", "enc", "eu", "inet", "db", "inc", "export", "ext", "state", "org", "obj", "esi", "server", "init", "net", "conf", "ev", "np", "e", "her", "que", "en", "dev", "ctx", "ini", "ey", "equ", "me", "context", "ne", "Environment", "ec", "req", "chn", "eni", "ner", "vert", "viron", "ind", "enos", "dt", "core", "ette", "cv", "manager", " en", "conn", "end", "dict"], "frame": ["flow", "layer", "position", "el", "component", "force", "object", "iframe", "style", "data", "ise", "invoke", "sequence", "f", "state", "flo", "code", "zone", "error", "connection", "file", "fram", "motion", "err", "framework", "boot", "cpu", "line", "fi", "view", "setup", "function", "base", "fire", "row", "build", "channel", "config", "update", "slice", "module", "fb", "fake", "driver", "ctx", "raise", "parse", "scale", "runner", "node", "ke", "class", "cf", "element", "ze", "feature", "game", "fr", "block", "show", "sche", "image", "Frame", "db", "profile", "version", "e", "point", "que", "message", "run", "ind", "cast", "thread", "core", "frames", "trace", "cfg", "coe", "scope", "session", "fact", "za", "event", "call", "fe", "init", "part", "plane", "load", "lock", "result", "context", "processor", "figure", "fc", "sample", "role"]}}
{"project": "qemu", "commit_id": "25e6a11832bcd0715068f0cc24fb46ec03de676e", "target": 1, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio,\n\n                                hwaddr *mmio32, hwaddr *mmio64,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    /*\n\n     * New-style PHB window placement.\n\n     *\n\n     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window\n\n     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO\n\n     * windows.\n\n     *\n\n     * Some guest kernels can't work with MMIO windows above 1<<46\n\n     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB\n\n     *\n\n     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each\n\n     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the\n\n     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the\n\n     * 1TiB 64-bit MMIO windows for each PHB.\n\n     */\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const int max_phbs =\n\n        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;\n\n    int i;\n\n\n\n    /* Sanity check natural alignments */\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);\n\n    /* Sanity check bounds */\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);\n\n\n\n    if (index >= max_phbs) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_phbs - 1);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;\n\n    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;\n\n    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;\n\n}\n", "idx": 8154, "substitutes": {"spapr": ["spAPrs", "spamprs", "spapsrc", "spapro", "spampro", "spAPro", "SpAPrs", "spaprs", "SpAPrc", "SpAPro", "Spaprs", "Spapro", "spapsr", "Spaprc", "spAPr", "SpAPr", "spapsro", "spapsrs", "spampr", "spaprc", "spAPrc", "Spapr", "spamprc"], "index": ["condition", "base", "address", "find", "expression", "name", "append", "position", "header", "id", "alpha", "value", "config", "x", "style", "slice", "pattern", "image", "fff", "ix", "inc", "num", "ion", "offset", "f", "key", "version", "weight", "length", "xxxx", "original", "match", "number", "all", "action", "size", "connection", "example", "path", "multi", "bridge", "search", "context", "input", "old", "batch", "integer", "start", "pointer", "ind", "type", "inner", "Index", "cache", "partial", "diff", "end", "prefix"], "buid": ["bufId", "bufID", " buids", "uuids", "buId", " buId", "basids", "uuid", "bufid", "uuId", " buID", "basid", "buID", "uuID", "buids", "bufids", "basID"], "pio": ["pci", "lpci", "mpix", "cpios", "cpio", "cpIO", "pios", "cpix", "cpci", "mpio", "mpIO", "Pio", " pIO", "Pios", "pIO", "PIO", "Pci", " pix", "lpio", "lpios", " pios", "mpios", "pix", "lpIO"], "mmio32": ["mlui32", "mmui40", "mmtu32", "mmtu82", "mlui82", "mmui82", "mmdi32", "mlui64", "mmdi64", "mmdi82", "mmio82", "mlio40", "mmtu64", "mlio82", "mmui64", "mmtu40", "mlio64", "mmio40", "mlui40", "mmui32", "mmdi40", "mlio32"], "mmio64": ["mpui64", "mmio864", "mpui32", "mpui128", "mmios32", "mmui864", "mpio128", "mmIO128", "mpio32", "mmui128", "mmui64", "mmIO32", "mmios128", "mmios64", "mmui32", "mpio864", "mmio128", "mpui864", "mmIO864", "mmIO64", "mmios864", "mpio64"], "n_dma": ["n_sdwa", "n_sdda", "n_sdmas", "n_dsmas", "n_Dmas", "n_Dda", "n_lta", "n_dda", "n_Dwa", "n_lla", "n_dta", "n_Dma", "n_dwa", "n_dsta", "n_lmas", "n_lma", "n_dmas", "n_dsma", "n_dla", "n_sdma", "n_dsla"], "liobns": ["cliObn", "liOBn", "cliobcs", "liobcs", "liobnas", "liObnames", "liObNs", "liObns", "liObn", "liObcs", "cliobn", "lobnas", "cliObns", "liibcs", "cliObcs", "lobcs", "lobns", "liibnames", "liObnas", "liOBns", "liobn", "lObns", "lObnas", "lObcs", "liOBnas", "liabns", "liabnas", "liibn", "liobnames", "cliObnames", "liibns", "liabNs", "liOBNs", "liabcs", "lobNs", "liOBnames", "cliobns", "cliobnames", "liobNs", "liOBcs", "lObNs"], "errp": ["Erp", "erfp", "erP", " errf", " errfp", "errP", "aerp", "erpb", " errP", "ErP", " errpb", "Erf", "erp", "errf", "errpb", "aerpb", "Erfp", "aerP", "errfp", "aerfp", "erf"], "i": ["gi", "o", "ti", "v", "id", "I", "count", "di", "ci", "ji", "ni", "x", "xi", "si", "slice", "ri", "info", "bi", "qi", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "j", "iu", "it", "ai", "uli", "init", "split", "u", "e", "uri", "n", "multi", "mi", "ini", "p", "end", "mini", "eni", "z", "start", "c", "ip", "ind", "y", "li", "fi", "zi", "mu", "ui"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)\n\n{\n\n    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;\n\n    uint32_t UART0_clk, UART1_clk;\n\n    uint64_t VCO_out, PLL_out;\n\n    int M, D;\n\n\n\n    VCO_out = 0;\n\n    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {\n\n        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FBMUL %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 20) & 0xF, M);\n\n#endif\n\n        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FWDA %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 16) & 0x7, D);\n\n#endif\n\n        VCO_out = cpc->sysclk * M * D;\n\n        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {\n\n            /* Error - unlock the PLL */\n\n            printf(\"VCO out of range %\" PRIu64 \"\\n\", VCO_out);\n\n#if 0\n\n            cpc->pllmr[1] &= ~0x80000000;\n\n            goto pll_bypass;\n\n#endif\n\n        }\n\n        PLL_out = VCO_out / D;\n\n        /* Pretend the PLL is locked */\n\n        cpc->boot |= 0x00000001;\n\n    } else {\n\n#if 0\n\n    pll_bypass:\n\n#endif\n\n        PLL_out = cpc->sysclk;\n\n        if (cpc->pllmr[1] & 0x40000000) {\n\n            /* Pretend the PLL is not locked */\n\n            cpc->boot &= ~0x00000001;\n\n        }\n\n    }\n\n    /* Now, compute all other clocks */\n\n    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CCDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 20) & 0x3, D);\n\n#endif\n\n    CPU_clk = PLL_out / D;\n\n    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CBDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 16) & 0x3, D);\n\n#endif\n\n    PLB_clk = CPU_clk / D;\n\n    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"OPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 12) & 0x3, D);\n\n#endif\n\n    OPB_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"EPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 8) & 0x3, D);\n\n#endif\n\n    EBC_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"MPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 4) & 0x3, D);\n\n#endif\n\n    MAL_clk = PLB_clk / D;\n\n    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"PPDV %01\" PRIx32 \" %d\\n\", cpc->pllmr[0] & 0x3, D);\n\n#endif\n\n    PCI_clk = PLB_clk / D;\n\n    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U0DIV %01\" PRIx32 \" %d\\n\", cpc->ucr & 0x7F, D);\n\n#endif\n\n    UART0_clk = PLL_out / D;\n\n    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U1DIV %01\" PRIx32 \" %d\\n\", (cpc->ucr >> 8) & 0x7F, D);\n\n#endif\n\n    UART1_clk = PLL_out / D;\n\n#ifdef DEBUG_CLOCKS\n\n    printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64\n\n           \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCO_out, PLL_out);\n\n    printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32\n\n           \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32\n\n           \" UART1 %\" PRIu32 \"\\n\",\n\n           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,\n\n           UART0_clk, UART1_clk);\n\n#endif\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);\n\n    /* Setup MAL clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);\n\n    /* Setup PCI clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);\n\n    /* Setup UART0 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);\n\n    /* Setup UART1 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);\n\n}\n", "idx": 8155, "substitutes": {"cpc": ["copk", "cpcr", "pgrec", "cppcc", "pkgl", "wpcs", "ppci", " cpnc", "pkgct", "pkgfc", "pppc", "pprc", "mpl", "cmpct", "pm", "cpsc", " cpl", "pgcf", "hopc", "cppsc", " cpbc", "pscs", "ppf", "pkgrc", "cppdc", "tpc", "skec", "ppx", "appc", "pkgcs", "cpspec", "copm", "copcr", "epce", "pb", "mpct", "privcf", " cprc", "cpcc", "cpe", "pgci", "psl", "pgcr", "arpc", "cpconfig", "ppcc", "gpcache", "wpk", "wpcr", "cpcs", "pkgconfig", "cppspec", "epc", "ppsc", "cpec", "ppc", "skdc", "ppcf", "pgcache", "cppx", "appsc", "skce", "ppcs", " cpconfig", "pkgc", "copl", "cpnc", "CPc", "pgconfig", "privc", "cpcache", "arpfc", "privcc", "CPrec", "cpct", "cppec", "ppb", "ppnc", " cpci", "pgpc", "skc", "pkgbc", "ppce", "pce", "psbc", "ppbc", "pgbc", "pgl", "privx", "pkgci", "mpci", "arprc", "mpc", "skm", "pc", "hope", "cpk", "appdc", "cppcf", "cmpe", "appec", "hopxc", " cpf", "psc", "gpcc", "cpb", "eppc", "cpfc", "pkgrec", "cppl", "epcs", "copsc", "pgspec", "cppm", "cprec", "pgcc", "mpcs", "tpl", "skb", "cpdc", "pprec", "ppct", "tpf", "cpci", "CPrc", "pgcs", "cprc", "cmpc", "pgc", "ppm", "cpce", "ppl", "pkgcf", "gpc", "pgce", "CPfc", "copcs", "mprc", "cpx", "cpf", "copc", "sksc", "cppcache", "cmpxc", "cpxc", "cpcf", "ppxc", "cpbc", "wpc", "tpnc", "arprec", "cpl", "cpm", "ppe", " cpcs", "gpspec", "cppc", "hopct", "pgk"], "CPU_clk": ["CPU_plk", "CPU_plck", "CPU_plkt", "CPU_clkt", "CPU_CLks", "CPU_logks", "CPU_logck", "CPU_CLck", "CPU_logkt", "CPU_clck", "CPU_CLkt", "CPU_logk", "CPU_plks", "CPU_CLk", "CPU_clks"], "PLB_clk": ["PLB_wlk", "PLB_clck", "PLB_wlks", "PLB_CLks", "PLB_CLause", "PLB_CLk", "PLB_clks", "PLB_plause", "PLB_plks", "PLB_plk", "PLB_wlause", "PLB_wlck", "PLB_CLck", "PLB_plck", "PLB_clause"], "OPB_clk": ["OPB_plf", "OPB_plq", "OPB_plck", "OPB_Clck", "OPB_clf", "OPB_Clf", "OPB_colf", "OPB_clq", "OPB_colq", "OPB_colck", "OPB_Clq", "OPB_plk", "OPB_clck", "OPB_Clk", "OPB_colk"], "EBC_clk": ["EBC_plck", "EBC_rlk", "EBC_plK", "EBC_clky", "EBC_clck", "EBC_rlck", "EBC_plky", "EBC_rlky", "EBC_lick", "EBC_rlK", "EBC_clK", "EBC_licK", "EBC_licck", "EBC_licky", "EBC_plk"], "MAL_clk": ["AMD_licok", "AMD_licck", "AMD_blck", "AMD_blk", "AMD_licke", "AMD_blke", "AMD_plck", "AMD_clk", "AMD_clke", "AMD_clck", "AMD_plk", "AMD_clok", "AMD_blok", "AMD_plke", "AMD_lick", "AMD_plok"], "PCI_clk": ["PCI_clck", "PCI_hlck", "PCI_hlok", "PCI_plck", "PCI_hlk", "PCI_hlker", "PCI_clok", "PCI_plker", "PCI_blk", "PCI_clker", "PCI_plk", "PCI_blck", "PCI_blker", "PCI_blok", "PCI_plok"], "UART0_clk": ["UART0_CLck", "UART0_plok", "UART0_CLk", "UART0_plks", "UART0_clok", "UART0_plck", "UART0_plk", "UART0_clck", "UART0_blok", "UART0_CLks", "UART0_blck", "UART0_CLok", "UART0_clks", "UART0_blk", "UART0_blks"], "UART1_clk": ["UART1_plok", "UART1_clok", "UART1_blok", "UART1_allk", "UART1_allK", "UART1_allok", "UART1_blK", "UART1_blks", "UART1_plk", "UART1_allks", "UART1_clks", "UART1_clK", "UART1_plK", "UART1_plks", "UART1_blk"], "VCO_out": ["VCO__out", "VCO_output", "VCO_new", "VCOxn", "VCO_Out", "VGO_Out", "VGO_OUT", "VCL_in", "VCO_result", "VCOLogerror", "VCO_n", "VCO64in", "VCO_m", "VGO_in", "VCE_id", "VCOLogin", "VCO64OUT", "VGO_result", "VCO_again", "VCO__in", "VCOxin", "VCO_OUT", "VCL_out", "VCE_out", "VCL_again", "VGO_error", "VCO__id", "VCOxm", "VCE_size", "VCO__output", "VGO_out", "VCO_size", "VCOLogresult", "VGO_m", "VCOLogout", "VCO_in", "VCOxout", "VCL_copy", "VCO64out", "VCO64new", "VCE_OUT", "VCO_id", "VGO_new", "VCO_copy", "VCO_error", "VGO_n", "VCE_in", "VCE_output"], "PLL_out": ["PLL_in", "PLS_OUT", "PLS_in", "PCL_version", "PLLFileboot", "PLLFileOut", "PLS_error", "PLL_error", "PLL_version", "PCL_in", "PLL_Out", "PLL_OUT", "PLLFileout", "PCL_Out", "PLL_boot", "PLS_out", "PCL_boot", "PCL_out"], "M": ["H", "ID", "P", "DM", "DI", "U", "I", "S", "W", "RM", "MM", "V", "Y", "O", "C", "m", "G", "K", "NM", "N", "MI", "MA", "E", "MN", "J", "L", "MX", "Q", "A", "B", "R", "MT", "MF", "X", "T", "MD", "MON", "MU", "Z", "LM", "F"], "D": ["H", "P", "DM", "DI", "U", "ENT", "I", "W", "S", "V", "DX", "Y", "Do", "DF", "C", "O", "DIR", "DD", "DH", "DS", "G", "K", "N", "d", "DB", "E", "J", "L", "DL", "Q", "A", "JD", "B", "DA", "DC", "DT", "R", "DO", "DOM", "Ds", "X", "MD", "T", "LD", "Z", "F"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "av_cold void ff_wmv2_common_init(Wmv2Context * w){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);\n\n}\n", "idx": 8157, "substitutes": {"w": ["writer", "rw", "o", "eng", "hw", "v", "fw", "W", "a", "sw", "wan", "ow", "wp", "wa", "wt", "m", "window", "wb", "cl", "wh", "f", "wo", "d", "u", "e", "we", "tw", "k", "t", "n", "ctx", "wcs", "self", "work", "ww", "p", "temp", "kw", "wal", "web", "iw", "wu", "c", "g", "west", "ew", "aw"], "s": ["groups", "address", "sf", "S", "a", "scope", "sw", "session", "words", "ages", "b", "si", "i", "sync", "sys", "ses", "services", "m", "ions", "support", "f", "client", "ns", "d", "sl", "server", "stats", "service", "ss", "conf", "e", "submit", "an", "sb", "gs", "ops", "secondary", "ances", "t", "n", "ts", "erences", "self", "share", "p", "south", "settings", "h", "opt", "aws", "fs", "sup", "request", "c", "g", "ssl", "sq", "y", "sym", "es", "js"]}}
{"project": "qemu", "commit_id": "2e50326c44c802ca9b9d591341085e49208927be", "target": 1, "func": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));", "idx": 8158, "substitutes": {"fd": ["fat", "flow", "pid", "feed", "sf", "fw", "md", "bd", "ctl", "pd", "stream", "pipe", "fed", "tty", "fx", "fb", "db", "f", "d", "flo", "director", "dir", "wd", "file", "func", "dc", "fn", "df", "sd", "fp", "cb", "exec", "FD", "temp", "draft", "fs", "cond", "proc", "c", "handler", "dl", "dt", "fc", "lf", "form", "fi", "ff"], "csum": ["tsUM", "chesume", "rsumb", "scUM", "gsUM", "rsum", "tsume", "arsum", "tsum", "gsumption", "gsum", "rsUM", "arsUM", "rssum", "scum", "scsum", "csumb", "cssum", "chesum", "csumption", "csUM", "chesUM", "scumb", "chesumption", "tsumption", "arssum", "arsumb", "gsume", "csume"], "tso4": ["tsc4", "fso16", "tpo6", "fsc04", "Tso6", "tSo4", "Tsa6", "Tsa8", "fso04", "tsa4", "tSofour", "tsc8", "Tso16", "tscfour", "tpo4", "tbo4", "Tso4", "Tsa4", "tse04", "Tsa16", "fsc4", "tso04", "fso84", "tse4", "tso16", "tto84", "tsc6", "fso4", "tbofour", "fsofour", "tsa16", "tpo16", "fbofour", "fscfour", "tsefour", "tto16", "tsa6", "tpo8", "tso84", "tbo84", "tse16", "fbo84", "tsofour", "tsc04", "ttofour", "tsc16", "tsa8", "tso8", "tto04", "fbo4", "tto4", "Tso8", "tSo84", "fsc16"], "tso6": [" tla4", "Tso6", "xto60", "xso60", "Tco7", "tao6", "tco60", "tsa4", "tla6", "tco6", " tla76", "tbi76", " tso3", "tbo60", "tco7", "tso3", "tbo4", " tso76", "xto6", "Tso4", "tso60", "tco3", "tso613", "tbo3", "Tco4", "tao613", "tsh6", "tsa76", "xso3", "xto3", "tsh7", "tbi4", "Tco6", "tla76", "xto4", "tsa3", "tao4", "tco613", "tbo6", "tto6", "tto60", " tla3", "tco4", "Tso7", "xso4", "tsh613", "tsa6", "tsh4", "tso7", " tla6", "tbi3", "Tso613", "tbi6", "tto4", "tso76", "tto3", "tao7", "Tco613", "tla4", "xso6", "tla3"], "ecn": ["ecc", "ECn", "ecl", "escn", "ECN", "Ecn", " ecN", "ecb", "escb", "Ecb", "ECb", "escN", "escc", "ECc", " ecc", "EcN", "ecN", "Ecl", " ecl", " ecb", "ECl"], "ufo": ["efO", "umos", "umd", "uchO", "ffO", "ufoo", "uchos", "efo", "ffo", "efos", "uppon", "ucho", "ufon", "umO", "ffoo", "uppo", "ufd", "ffon", "ufos", "efon", "uppO", "efoo", "ufO", "umo", "uppoo", "uchd", "efd"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_mpeg1_encode_init(MpegEncContext *s)\n\n{\n\n    static int done=0;\n\n\n\n    common_init(s);\n\n\n\n    if(!done){\n\n        int f_code;\n\n        int mv;\n\n\tint i;\n\n\n\n        done=1;\n\n        init_rl(&rl_mpeg1);\n\n\n\n\tfor(i=0; i<64; i++)\n\n\t{\n\n\t\tmpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];\n\n\t\tmpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];\n\n\t}\n\n        \n\n        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);\n\n\n\n\t/* build unified dc encoding tables */\n\n\tfor(i=-255; i<256; i++)\n\n\t{\n\n\t\tint adiff, index;\n\n\t\tint bits, code;\n\n\t\tint diff=i;\n\n\n\n\t\tadiff = ABS(diff);\n\n\t\tif(diff<0) diff--;\n\n\t\tindex = av_log2(2*adiff);\n\n\n\n\t\tbits= vlc_dc_lum_bits[index] + index;\n\n\t\tcode= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_lum_dc_uni[i+255]= bits + (code<<8);\n\n\t\t\n\n\t\tbits= vlc_dc_chroma_bits[index] + index;\n\n\t\tcode= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_chr_dc_uni[i+255]= bits + (code<<8);\n\n\t}\n\n\n\n        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );\n\n\n\n        for(f_code=1; f_code<=MAX_FCODE; f_code++){\n\n            for(mv=-MAX_MV; mv<=MAX_MV; mv++){\n\n                int len;\n\n\n\n                if(mv==0) len= mbMotionVectorTable[0][1];\n\n                else{\n\n                    int val, bit_size, range, code;\n\n\n\n                    bit_size = f_code - 1;\n\n                    range = 1 << bit_size;\n\n\n\n                    val=mv;\n\n                    if (val < 0) \n\n                        val = -val;\n\n                    val--;\n\n                    code = (val >> bit_size) + 1;\n\n                    if(code<17){\n\n                        len= mbMotionVectorTable[code][1] + 1 + bit_size;\n\n                    }else{\n\n                        len= mbMotionVectorTable[16][1] + 2 + bit_size;\n\n                    }\n\n                }\n\n\n\n                mv_penalty[f_code][mv+MAX_MV]= len;\n\n            }\n\n        }\n\n        \n\n\n\n        for(f_code=MAX_FCODE; f_code>0; f_code--){\n\n            for(mv=-(8<<f_code); mv<(8<<f_code); mv++){\n\n                fcode_tab[mv+MAX_MV]= f_code;\n\n            }\n\n        }\n\n    }\n\n    s->me.mv_penalty= mv_penalty;\n\n    s->fcode_tab= fcode_tab;\n\n    if(s->codec_id == CODEC_ID_MPEG1VIDEO){\n\n        s->min_qcoeff=-255;\n\n        s->max_qcoeff= 255;\n\n    }else{\n\n        s->min_qcoeff=-2047;\n\n        s->max_qcoeff= 2047;\n\n    }\n\n    s->intra_ac_vlc_length=\n\n    s->inter_ac_vlc_length=\n\n    s->intra_ac_vlc_last_length=\n\n    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;\n\n}\n", "idx": 8169, "substitutes": {"s": ["o", "sets", "sf", "caps", "sg", "comments", "si", "sys", "ses", "services", "m", "ions", "ns", "opens", "ss", "cs", "sports", "u", "e", "gs", "ks", "ops", "qs", "ds", "ts", "p", "settings", "c", "os", "ssl", "sq", "ms", "es", "rs", "js"], "f_code": [" f_count", "g_code", "dflockzone", "dflockkey", "f__Code", "dflockcode", "fckcreate", "fckkey", " f_Code", "f__co", "flockcode", "flockcreate", "g_size", " f__use", "fJuse", " f__code", "f_codes", "fIPcount", "f_create", "f_count", "df_create", "flockkey", "flockzone", "f_cc", "f__use", "fJCode", " f_co", "f_zone", "f_name", "fIPcode", " f_name", "dflockcreate", "fJco", "g_mode", "df_zone", "fIPname", "f_size", "f__code", "df_key", " f_codes", "f_co", "fIPcodes", "f_Code", "f_key", "fckzone", "f_use", "f_mode", "df_code", " f__Code", "fckcode", " f_use", "fJcode", "g_cc", " f__co"], "mv": ["Mf", "Mvc", "Mva", "bmv", "Mh", "mV", " mva", "dv", " mc", "bmf", "dV", "Mvi", "pc", "mvc", "pf", "mc", "Mb", " mV", "pvc", "Mv", "df", "mh", "bmc", "mb", "MV", "mf", "dva", "wmf", "wmv", " mf", " mh", "wmh", "pv", "mva", " mvi", "bmvi", "wmV", " mvc", "Mc", "mvi", "pb", " mb"], "i": ["I", "chi", "di", "ci", "b", "x", "xi", "bi", "f", "pi", "d", "ii", "h", "mini", "oi", "y", "li", "current", "fi", "zi", "gi", "name", "ti", "id", "is", "ki", "ji", "list", "slice", "info", "ix", "phi", "it", "ai", "uri", "mi", "ini", "ie", "z", "ip", "type", "anti", "site", "ui", "ni", "ri", "io", "image", "key", "yi", "adi", "j", "cli", "u", "e", "p", "hi", "c", "ind", "api", "dim", "mu", "v", "si", "m", "in", "qi", "l", "attr", "iu", "init", "ori", "n", "multi", "eni", "inner"], "adiff": ["Adip", "madef", " adx", "eddef", "ddip", "adisk", " adise", "ddiff", "AdIFF", "eddise", "diffs", "ddiffs", "adef", "eddisk", "ddIFF", " adison", "adison", "adise", "Adiffs", "adx", "madx", " adisk", "eddison", "eddx", "madise", "madisk", "adiffs", "adip", "madiff", " adef", "Adiff", "dIFF", "adIFF", "eddiff", "madison", "dip"], "index": ["position", "ci", "x", "style", "bi", "unit", "weight", "active", "connect", "byte", "match", "initial", "error", "pass", "zero", "page", "current", "name", "id", "count", "value", "config", "edge", "update", "list", "slice", "info", "module", "ix", "loop", "comment", "lib", "ini", "search", "batch", "type", "element", "site", "end", "patch", "area", "inf", "bin", "block", "change", "sync", "bit", "loc", "mask", "inc", "key", "num", "ion", "version", "action", "e", "coord", "source", "input", "pos", "start", "level", "ind", "design", "ref", "cache", "prefix", "find", "pull", "open", "bug", "draw", "offset", "insert", "length", "fe", "init", "eight", "part", "example", "full", "multi", "qa", "fix", "none", "inner", "success", "Index"], "bits": ["groups", "points", "limits", "files", "notes", "fixes", "ins", "bands", "features", "config", "words", "bug", "bit", "cells", "its", "ips", "details", "pins", "cats", "vals", "planes", "codes", "parts", "lins", "ls", "bs", "ints", "fields", "classes", "ops", "issues", "bis", "lib", "bytes", "amples", "bugs", "settings", "blocks", "batch", "pieces", "changes", "utils", "errors", "items", "frames", "board", "lines", "checks", " bugs", "flags"], "code": ["layer", "_", "component", "ci", "check", "status", "create", "all", "error", "line", "g", "name", "id", "count", "value", "config", "info", "content", "url", "description", "comment", "zip", "score", "type", "cod", "text", "test", "Code", "size", "patch", "low", "address", "block", "change", "use", "sync", "bit", "co", "loc", "key", "codes", "version", "message", "bytes", "pos", "charge", "core", "desc", "cache", "r", "complete", "bug", "comp", "call", "length", "init", "hide", "example", "seq", "fix", "comb"], "diff": ["patch", "cmp", " differences", "extra", "mix", "id", "change", "alpha", "count", "show", "spec", "progress", "distance", " difference", "config", "bug", "update", "iff", "data", "ignore", "comp", "info", "missing", "inc", "different", "f", "version", "d", "length", "dust", "frac", "dist", "split", "def", "between", "part", "conf", "error", "comment", "hide", "dev", "multi", "err", "scale", "qa", "fail", "pos", "none", "fix", "changes", "new", "desc", "ref", "changed", "shift", "Diff", "low"], "len": ["lang", "dy", "dim", "ann", "bin", "el", "count", "la", "pre", "lan", "data", "elt", "slice", "loc", "live", "valid", "l", "lit", "length", "sl", "split", "en", "lib", "lon", "err", "str", "rev", "seq", "span", "vert", "line", "Len", "ln", "lin", "li", "bl", "lim"], "val": ["vol", "base", "reg", "bin", "al", "value", "data", "elt", "Val", "live", "valid", "vals", "conv", "VAL", "split", "def", "str", "rev", "seq", "eval", "pos", "sel", "bl", "dim"], "bit_size": ["bit64scale", "int_size", "bit64sized", "int_count", "int_scale", "int_sized", "bit_count", "bit64size", "bit_scale", "bit64count", "bit_sized"], "range": ["base", "bin", "block", "gap", "slice", "loc", "mask", "unit", "vals", "num", "arr", "err", "feat", "str", "rev", "seq", "scale", "frame", "pos", "line", "orig", "label", "r", "lim", "end"]}}
{"project": "FFmpeg", "commit_id": "c9f6eab184cac379c7a44d5899979165798d45d4", "target": 1, "func": "static av_cold int ac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    AC3DecodeContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    ff_ac3_common_init();\n\n    ac3_tables_init();\n\n    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);\n\n    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);\n\n    ff_kbd_window_init(s->window, 5.0, 256);\n\n    dsputil_init(&s->dsp, avctx);\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    av_lfg_init(&s->dith_state, 0);\n\n\n\n    /* set scale value for float to int16 conversion */\n\n    s->mul_bias = 32767.0f;\n\n\n\n    /* allow downmixing to stereo or mono */\n\n    if (avctx->channels > 0 && avctx->request_channels > 0 &&\n\n            avctx->request_channels < avctx->channels &&\n\n            avctx->request_channels <= 2) {\n\n        avctx->channels = avctx->request_channels;\n\n    }\n\n    s->downmixed = 1;\n\n\n\n    /* allocate context input buffer */\n\n    if (avctx->error_recognition >= FF_ER_CAREFUL) {\n\n        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!s->input_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n    return 0;\n\n}\n", "idx": 8171, "substitutes": {"avctx": ["akcontext", "verctl", " avcf", " avctr", "awctx", "afca", "ovtx", "evcontext", "afctr", "avecoll", "abcmp", "vercu", "afxc", "avalcoll", "aveconfig", "afctx", "AVctl", "awcontext", "aveca", "ajctx", "evtx", "devctx", "ovcu", " avcit", "avcli", " avcontext", "afcit", "vercit", "avca", " avcv", "ajca", "avevoc", "afcv", "avcmd", "Avconn", "vercf", "afcmp", "avcmp", "abcli", "akctx", "abcontext", "ajcmd", "avcv", "avalctx", "avxc", "AVcmd", "ajcu", "aveconn", "AVcmp", "ovcontext", "Avctx", "avecontext", "akxc", "afcf", "ajcmp", "evcu", "AVcu", " avcu", "AVconn", "awcmp", "avecu", "devcontext", "Avcu", "afcli", "ajcf", "awctl", "akcit", "afctl", "vercontext", "avcu", "avconfig", "AVcontext", "afsci", "ajcit", "afcmd", "avcontext", "ajxc", "afcoll", "ajvoc", "avvoc", "avsci", "ajctr", "avesci", "avconn", "evctx", "abctx", "devconfig", "avctl", "avectx", "ovctx", "ajcv", "AVctx", "avalcmp", "avcoll", "avcf", "aftx", "avalconn", "avecf", "avtx", "ajcli", "Avcontext", "avcit", "verctx", " avctl", "afconn", "afcontext", "afvoc", "afconfig", "ajcontext", "avctr", " avsci", "avecmp", "devcf", "afcu", "abcu", "abconfig"], "s": ["o", "sets", "sf", "v", "sec", "is", "S", "a", "spec", "sg", "session", "b", "data", "i", "sync", "si", "sys", "ses", "services", "so", "states", "xs", "l", "f", "ns", "d", "ls", "args", "service", "cs", "ss", "u", "e", "sc", "w", "ops", "gs", "sb", "ks", "se", "ds", "qs", "n", "ctx", "t", "ts", "storage", "su", "self", "p", "this", "h", "aws", "fs", "sup", "sa", "c", "os", "g", "ssl", "sq", "sym", "utils", "es", "rs", "ps", "js"]}}
