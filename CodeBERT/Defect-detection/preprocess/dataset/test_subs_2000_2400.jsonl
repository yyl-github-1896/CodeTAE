{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         void **refcount_table,\n\n                         int64_t *refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k, refcount;\n\n    int ret;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= *refcount_table_size) {\n\n            ret = realloc_refcount_array(s, refcount_table,\n\n                                         refcount_table_size, k + 1);\n\n            if (ret < 0) {\n\n                res->check_errors++;\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        refcount = s->get_refcount(*refcount_table, k);\n\n        if (refcount == s->refcount_max) {\n\n            fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n            fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \"\n\n                    \"width or qemu-img convert to create a clean copy if the \"\n\n                    \"image cannot be opened for writing\\n\");\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n        s->set_refcount(*refcount_table, k, refcount + 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20248, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "outs", "qs", "es", "bis", "fs", "ses", "als", "bytes", "css", "ds", "bl", "ils", "os", "vs", "cs", "ts", "abi", "ls", "js", "cb", "b", "bits", "aws", "ms", "blocks", "ns", "BS", "iss", "ps", "rs", "ins", "gs", "ss", "gb"], "res": ["ras", "def", "response", "obj", "err", "rows", "cons", "fs", "result", "ress", "RES", "rem", "css", "results", "rez", "sys", "r", "ex", "ros", "args", "pers", "ares", "os", "Res", "cs", "vals", "rus", "js", "rc", "spec", "des", "pres", "ms", "rev", "re", "gr", "rss", "req", "ps", "rs", "conf", "ers", "resolution", "resp", "nos"], "refcount_table": ["refCount_range", "refcount_state", "refcount64course", "refcount__total", "refcount__table", "refcount2list", "refCount2TABLE", "refcount_stable", "refcomp_TABLE", "refcomp_table", "refCount_array", "refcount_total", "refCount2total", "refcountPstable", "refcount2course", "refcheck_course", "refcount_list", "refcount_range", "refcheck_table", "refcount__TABLE", "refcheck2table", "refCount_stable", "refcount_course", "refcount64table", "refCount_total", "refcountPtable", "refcheck_list", "refcount2TABLE", "refcheck2list", "refcheck2course", "refcomp_Table", "refCount_table", "refcountPrange", "refcount2table", "refCount2array", "refCount2table", "refcount__array", "refcount64count", "refCount_TABLE", "refcount2total", "refcount_Table", "refcheck2count", "refcheck_count", "refcount2count", "refcount_count", "refcount2array", "refcountPTABLE", "refcount64list", "refcount_TABLE", "refcount_array", "refcomp_state"], "refcount_table_size": ["refcount_table_small", "refcount_table_capacity", "refcount_cache_size", "refcount_window_last", "refcount_cache_max", "refcount_window_capacity", "refcount_table_scale", "refcount_table_last", "refcount_table_max", "refcount_table_SIZE", "refcount_cache_SIZE", "refcount_cache_scale", "refcount_cache_capacity", "refcount_window_size", "refcount_cache_small"], "offset": ["limit", "started", "end", "off", "ref", "starting", "next", "part", "origin", "extra", "initialized", "site", "align", "pos", "address", "entry", "activity", "number", "prefix", "slot", "addr", "initial", "o", "shift", "timeout", "ace", "index", "edge", "set", "location", "first", "online", "alias", "error", "Offset", "length", "iterator", "slice", "loc", "element", "len", "reset", "range", "pointer", "position", "base", "padding", "zero"], "size": ["member", "name", "e", "en", "end", "send", "scale", "extra", "sized", "Size", "ize", "ey", "ish", "address", "use", "args", "storage", "score", "sum", "p", "code", "grow", "sync", "shift", "timeout", "c", "small", "capacity", "form", "second", "set", "value", "se", "n", "length", "any", "len", "loc", "range", "ce", "SIZE", "sec", "from", "empty", "max", "count"], "s": ["ions", "sv", "i", "bis", "es", "xs", "ds", "sys", "os", "ssl", "ts", "cs", "us", "stats", "js", "S", "ns", "iss", "rs", "http", "ans", "conf", "ing", "ss", "sb", "outs", "g", "ses", "d", "sets", "services", "u", "state", "stat", "o", "c", "self", "spec", "a", "blocks", "e", "sym", "qs", "tests", "fs", "rates", "f", "less", "p", "si", "b", "parts", "ps", "gs", "sq", "sl", "ops", "plugins", "ks", "its", "ls", "sync", "is", "sa", "settings", "se", "comments", "south", "server", "states"], "start": ["step", "next", "starting", "end", "ind", "scale", "off", "part", "stop", "art", "pos", "op", "pre", "info", "ish", "address", "init", "ad", "p", "ace", "id", "count", "mid", "work", "sync", "shift", "open", "index", "set", "first", "se", "error", "min", "length", "grade", "skip", "back", "st", "range", "from", "old", "empty", "Start", "base", "max", "type"], "last": ["after", "est", "prev", "next", "end", "ast", "ort", "scale", "cost", "latest", "style", "before", "cur", "so", "no", "j", "full", "final", "nd", "cycle", "ace", "close", "small", "low", "ending", "needed", "first", "se", "length", "total", "loc", "since", "parent", "st", "range", "from", "old", "empty", "scope", "bottom", "base", "max", "count"], "cluster_offset": ["clusteringoffset", "clause_error", "clust_address", "cluster_error", "clusterlexoption", "cluster_entry", "clusterlexoffset", "cluster_off", "clusterlexpost", "cluster___slot", "cluster67offset", "cluster2name", "clorum_offset", "clanch_location", "clanch___location", "cluster_address", "clusterlexentry", "clanch_slot", "clusteringlocation", "clorumlexoffset", "clusterlexstart", "cluster___offset", "clause_offset", "clanch_size", "clust_slice", "clust_index", "cluster67location", "cler_error", "clorum_name", "clion_location", "cluster2post", "cluster2offset", "cler_off", "cluster_slot", "clust_offset", "cluster_index", "cluster_size", "clion_slice", "clanch_offset", "cluster_option", "cluster_start", "clause_option", "clorum_entry", "cluster67slice", "clusterlexerror", "clorumlexentry", "clanch___size", "cluster_post", "cler_start", "cluster___size", "cler_offset", "clorum_post", "clause_start", "cluster2entry", "clanch___slot", "clusteringslot", "cluster_name", "clion67offset", "cluster67off", "clusteringsize", "clorumlexname", "clion67location", "clusterlexname", "clion_off", "clanch___offset", "cluster_location", "cluster___location", "clorumlexpost", "clion67slice", "cluster_slice", "clion_offset", "clion67off"], "k": ["i", "kick", "ik", "sk", "end", "kid", "g", "kt", "key", "ki", "ack", "d", "ks", "f", "wk", "y", "r", "u", "ok", "j", "it", "m", "p", "ka", "id", "o", "work", "K", "q", "kn", "ek", "kk", "c", "b", "n", "ku", "uk", "ko", "v", "z", "ke", "kw", "ck", "mk", "x", "max"], "refcount": ["affCount", "refCount", "compount", "affcount", "afflen", "colcount", "affdepth", "refdepth", "colref", "affount", " refdepth", "complen", "refcode", "reflen", "affcheck", " refcheck", "relcount", " refCount", "referencecode", "referenceref", " refcode", "refref", "arccount", "reldepth", "reftype", "refcheck", "refsum", "relsum", " refsum", "afftype", "relCount", "affsum", "compcount", "referencecount", "refount", " refref", "arcref", " refount", "affref", "arctype", " reftype", " reflen", "compcheck", "colcode"], "ret": ["reg", "red", "def", "en", "fail", "ref", "err", "obj", "hard", "pet", "result", "val", "part", "ber", "arg", "det", "Ret", "rf", "f", "bad", "info", "bit", "data", "cat", "job", "count", "fun", "success", "rc", "ext", "cb", "num", "complete", "pass", "RET", "rt", " Ret", "rl", "flag", "rev", "error", "re", "length", "len", "total", "iter", "bf", "alt", "reset", "nt", "lit", "att", "url", "rets"], "check_errors": ["check2details", "checkuperror", "checkinguperrors", "checkupdetails", "checking_errors", "checking_issues", "check2error", "checkingupdetails", "check_details", "check2errors", "checkingupissues", "checkupissues", "checking_details", "checkinguperror", "check_issues", "check_error", "check2issues", "checkuperrors", "checking_error"], "corruptions": ["corruptance", "corruptuations", "orruptance", "corruptionuations", "orruptuations", "corredion", "corruptionions", "corruption", "orruptionions", "correduations", "orruption", "corconnection", "corconnections", "orruptionuations", "corredions", "corredance", "corconnectance", "corruptionion", "orruptionance", "orruptionion", "corconnectuations", "corruptionance", "orruptions"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n", "idx": 20257, "substitutes": {"opaque": ["OPaque", "opaques", "ospque", "opca", " opca", "OPaques", "ospca", "oppaque", " opaques", "Opace", "opace", "Opacity", "opacity", "OPacity", " opque", " opacity", "Opaque", " opace", "opque", "Opaques", "OPace", "ospaque", "oppca", "oppque"], "addr": ["md", "port", "target", "ref", "val", "mode", "ord", "pad", "host", "node", "device", "layer", "pos", "cmd", "address", "ad", "data", "ip", "p", "id", "point", "ace", "slot", "mid", "dr", "rc", "nr", "index", "oid", " address", "ptr", "vr", "Address", "alias", "src", "fd", "sid", "pointer", "offset", "x", "attr", "inter"], "value": ["port", "name", "target", "Value", "valid", "scale", "age", "wa", "val", "message", "type", "function", "buffer", "write", "address", "fee", "data", "version", "id", "number", "buf", "memory", "index", "values", "set", "length", "flow", "reference", "range", "v", "array", "image", "server", "offset", "VALUE", "format"], "size": ["name", "class", "shape", " bytes", "Size", "bytes", "ize", "address", "data", "args", " buffer", "capacity", "mem", "w", " mem", "length", " length", "fd", "len", "SIZE", "offset", "type"], "backref": ["buffref", "buffreference", "frontef", "baseref", "Backreference", "frontpointer", " backreference", " backpointer", "Backpointer", "BackREF", "basepointer", "frontreference", "baseREF", "backpointer", "BackRef", "backREF", " backRef", "backRef", "backef", "buffef", " backef", "frontref", "buffRef", "Backref", "frontRef", "baseRef", " backREF", "backreference"], "s": ["i", "sb", "ips", "e", "sym", "sl", "g", "ses", "d", "ops", "f", "t", "r", "u", "m", "socket", "state", "ssl", "os", "p", "o", "sync", "is", "ss", "c", "settings", "spec", "source", "si", "a", "b", "w", "session", "S", "ns", "src", "sf", "side", "h", "secondary", "scope", "l", "sq", "states"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "substitutes": {"addr": ["target", "ref", "adr", "config", "kt", "arg", "eth", "amd", "align", "host", "pc", "node", "device", "layer", "ld", "pos", "address", "data", "ad", "p", "ace", "point", "slot", "index", "ar", "cpu", "rt", " address", "ptr", "x", "src", "slice", "mx", "pointer", "offset", "base", "attr", "inter"], "val": ["grad", "sel", "ee", "fail", "ref", "sl", "valid", "ind", "db", "arg", "key", "cond", "tx", "bin", "al", "pre", "data", "p", "arr", "vals", "unit", "count", "slot", "py", "el", "index", "aval", "cal", "b", "pid", "mem", "vol", "fl", "len", "test", "loc", "VAL", "base", "Val", "lib", "v", "eval", "all", "pt", "x", "value"]}}
{"project": "qemu", "commit_id": "9f2130f58d5dd4e1fcb435cca08bf77e7c32e6c6", "target": 0, "func": "static int fb_initialise(struct XenDevice *xendev)\n\n{\n\n    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);\n\n    struct xenfb_page *fb_page;\n\n    int videoram;\n\n    int rc;\n\n\n\n    if (xenstore_read_fe_int(xendev, \"videoram\", &videoram) == -1)\n\n\tvideoram = 0;\n\n\n\n    rc = common_bind(&fb->c);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    fb_page = fb->c.page;\n\n    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,\n\n\t\t\t    fb_page->width, fb_page->height, fb_page->depth,\n\n\t\t\t    fb_page->mem_length, 0, fb_page->line_length);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    rc = xenfb_map_fb(fb);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n#if 0  /* handled in xen_init_display() for now */\n\n    if (!fb->have_console) {\n\n        fb->c.ds = graphic_console_init(xenfb_update,\n\n                                        xenfb_invalidate,\n\n                                        NULL,\n\n                                        NULL,\n\n                                        fb);\n\n        fb->have_console = 1;\n\n    }\n\n#endif\n\n\n\n    if (xenstore_read_fe_int(xendev, \"feature-update\", &fb->feature_update) == -1)\n\n\tfb->feature_update = 0;\n\n    if (fb->feature_update)\n\n\txenstore_write_be_int(xendev, \"request-update\", 1);\n\n\n\n    xen_pv_printf(xendev, 1, \"feature-update=%d, videoram=%d\\n\",\n\n\t\t  fb->feature_update, videoram);\n\n    return 0;\n\n}\n", "idx": 20283, "substitutes": {"xendev": ["xENDruction", "exendev", "exnddev", "xenown", "Xestev", "xestown", "xideerv", "inENDee", "exndem", "xenedect", "xenarget", "inENDarget", "wxendew", "xENDem", "xopenev", "Xenderv", "xenterv", "xendedtr", " xendtr", "xentdev", "xendedruction", "wxendev", "inendee", "xesterv", "Xendever", " xendedov", "xndee", "xenddevice", " xenddev", "xenddev", "rxendown", "xndem", "xendsdev", "Xendev", "xendtr", "xendedeva", "inendarget", "xstarttr", "Xesterv", "xideev", "Xestown", "inENDev", "inenddev", "xestev", "xenev", "xndarget", "xopeneva", "xenderv", "xendem", "xenedem", "xENDarget", "exendect", "xendew", " xendeddev", "rxenddev", "xendown", "xideever", "xendect", "xendedev", "xstartov", "xendee", "xenedev", "exndev", "wxendevice", " xendedtr", "xopenov", "rxenderv", " xendruction", "xndev", "xendsew", "inendev", "xENDect", " xendedev", "xendedov", "Xestever", "xendedew", "xopendev", "wxenev", "wxenddevice", "xendarget", "inENDdev", "exndect", "wxenew", "xendedown", "xeneddev", "xENDee", "xideown", "xstartruction", " xendedeva", "xndect", "xENDdev", "xstartev", " xendov", "xstartdev", "xendederv", "xendedever", "xendevice", "xENDtr", "xendeddev", "xendsev", "xenerv", "rxenown", "xenee", "xendever", "exendem", "xenew", "xendov", "xENDev", "xendeva", "wxenddev", " xendeva", "xestever", "xendsdevice", "xendeddevice", "xnddev", " xendedruction", "rxenev", "Xendown", "xstarteva", "xendruction", "rxenerv", "exenddev", "rxendev", "xentown", "xentev"], "fb": ["fa", "bc", "pb", "fc", "sb", "deb", "lb", "bj", "usb", "fs", "db", "mb", "FB", "bb", "rf", "uber", "fp", "f", "blog", "df", "eb", "fg", "lab", "bg", "raf", "fx", "facebook", "abc", "wb", "buf", "af", "c", "cb", "fe", "kk", "wp", "tf", "b", "tmp", "fm", "ff", "fd", "fw", "ab", "buff", "bf", "fen", "bs", "rb", "fn", "xb", "fi", "fab"], "fb_page": ["fb_load", "fb_config", "fbdbpage", "fb_session", "fb_line", "fbidsite", "fd_view", "deb_page", "fab_site", "facebook_edge", "fbkpage", "fbidpage", "fd_config", "debappsession", "fbpubpage", "deb_session", "fbkedge", "debappstep", "fbapppage", "fb_write", "fbappco", "fbpubpool", "fbidaverage", "fbappsite", "debappco", "fb_pool", "debapppage", "facebook_large", "fb_site", "fb_center", "fc_page", "fc_line", "facebook_load", "fd_page", "fab_page", "fbpubview", "fbappsession", "facebook_write", "fbkload", "fb_view", "fbksite", "fb_large", "facebook_page", "facebook_center", "facebook_average", "fbappcenter", "fb_edge", "fab_account", "deb_step", "fbappstep", "fd_pool", "fab_inc", "fb_inc", "fbdbstep", "deb_co", "fc_site", "facebook_site", "fbdbco", "fb_co", "fb_average", "fb_account", "fb_step", "fbidlarge", "fbappwrite", "fbpubconfig", "fbdbsession"], "videoram": ["viderarama", "videoramy", "videarama", "videoream", "videorAM", "videraramy", "vantorAM", "videarram", "videodam", "videorrAM", "vridearample", "videorableam", "videsoram", "vendorsAM", "videorableAM", "videoorama", "videourum", "videorram", "vendorAM", "videouram", "videorrama", "videostam", "videostamy", "videoreample", "vendorab", "vantoram", "vantodam", "videorsab", "videourram", "videorrac", "videourac", "vendorsab", "videodamd", "vrideorample", "vantorum", "vridearam", "videorsac", "vantodamd", "vridearama", "videourAM", "videsorAM", "videoreram", "viderarample", "videoriac", "videooram", "videorsram", "videoriram", "videsoriac", "vridearram", "videaram", "videorableamd", "videostample", "videorac", "vantodAM", "vendorsam", "vantoramd", "videorample", "videodAM", "videorrram", "videorsAM", "videarample", "videoreAM", "videoramd", "videsoriram", "videoorample", "videsoriam", "videoreama", "vrideoram", "vendoram", "vendorsac", "vrideorama", "videorum", "videorableum", "videorab", "videroramy", "videoriam", "videorsam", "videsorac", "videostama", "videorrample", "videorama", "vantodum", "videoreac", "videsoriAM", "videraram", "videaramy", "vendorac", "videooramy", "viderorama", "videorrab", "videodum", "viderorample", "videsorram", "videoriAM", "vrideorram", "videroram", "videouramd", "videoreab"], "rc": [" rec", "bc", "lc", "ras", "ra", "ror", "reg", "cc", "rd", "uc", " r", "irc", "fc", "err", "ct", "ride", "result", "coll", "ack", "rx", "rec", "rr", "cur", "pc", "anc", "gd", "ci", "isc", "sys", "nc", "ac", "risk", "id", "rh", "abc", "rw", "sync", "success", "rac", "rn", "cb", "dr", "irm", "c", "roc", "sc", "RC", "rt", "dc", "rl", "sr", "ann", "hl", " sc", "auc", "cr", "error", "src", "vc", "core", " src", "loc", "gc", "co", "rs", " RC", "ry", "rb", "ck", "rg"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_exts(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8s_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16s_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32s_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20299, "substitutes": {"ot": ["oted", "iot", "ut", "lot", "gt", "ort", "mot", "prot", "ott", "ol", "yt", "art", "t", "op", "oi", "oy", "oting", "opt", "otype", "o", "ant", "rot", "ocl", "et", "oter", "dt", "rt", "OT", "pot", "pol", "boot", "ote", "bot", "nt", "dot", "cot", "ots", "pt", "oc"], "reg": ["port", "grad", "org", "ig", "obj", "conn", "ort", "config", "pred", "valid", "err", "thread", "val", "lex", "arg", "region", "rem", "eng", "mor", "rec", "rig", "dist", "ro", "pre", "exec", "gre", "ram", "rest", "data", "res", "greg", "stat", "leg", "ret", "aug", "mod", "fun", "abc", "comment", "rc", "dr", "tag", "num", "run", "form", "roc", "mem", "go", "REG", "gc", "Reg", "re", "core", "gr", "loc", "comb", "debug", "proc", "sec", "eg", "disc", "mn", "rg"]}}
{"project": "qemu", "commit_id": "c0462f6d75fa481f7660c15a5ca3a60205aa4eca", "target": 0, "func": "bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n", "idx": 20301, "substitutes": {"param": ["member", "package", "request", "name", "property", "ref", "config", "item", "option", "part", "arg", "cm", "pm", "temp", "Param", "buffer", "path", "m", "address", "ram", "params", "prefix", "number", "am", "comment", "c", "ctx", "num", "single", "arm", "prom", "channel", "error", "meter", "par", "keep", "reference", "aram", "parent", "pair", "array", "image", "Parameter", "prop", "type"], "buf": ["bc", "pb", "port", "uf", "uc", "brace", "ref", "config", "result", "text", "cv", "fb", "queue", "func", "bp", "cur", "temp", "fp", "f", "buffer", "cas", "front", "cmd", "cp", "data", "prefix", "que", "context", "rc", "c", "cb", "ctx", "b", "tmp", "ff", "fd", "loc", "br", "foo", "cap", "ab", "batch", "buff", "proc", "v", "bh", "array", "bag", "vec", "rb", "h", "fi", "prop"], "p": ["i", "e", "prop", "ap", "jp", "g", "part", "pe", "d", "P", "bp", "pc", "l", "fp", "f", "pos", "po", "t", "op", "r", "u", "m", "cp", "y", "data", "j", "tp", "pre", "patch", "point", "params", "o", "np", "q", "c", "pr", "a", "b", "pid", "w", "x", "par", "pat", "n", "ps", "v", "z", "pointer", "vp", "sp", "pt", "pi", "dp", "k", "pa", "value"]}}
{"project": "FFmpeg", "commit_id": "099d6813c27faf95257a529aa2c65dfde816a487", "target": 1, "func": "int ff_h264_alloc_tables(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int big_mb_num= s->mb_stride * (s->mb_height+1);\n\n    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;\n\n    int x,y;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)\n\n\n\n    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n\n    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);\n\n    for(y=0; y<s->mb_height; y++){\n\n        for(x=0; x<s->mb_width; x++){\n\n            const int mb_xy= x + y*s->mb_stride;\n\n            const int b_xy = 4*x + 4*y*h->b_stride;\n\n\n\n            h->mb2b_xy [mb_xy]= b_xy;\n\n            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));\n\n        }\n\n    }\n\n\n\n    s->obmc_scratchpad = NULL;\n\n\n\n    if(!h->dequant4_coeff[0])\n\n        init_dequant_tables(h);\n\n\n\n    return 0;\n\nfail:\n\n    free_tables(h, 1);\n\n    return -1;\n\n}\n", "idx": 20305, "substitutes": {"h": ["hp", "i", "dh", "oh", "ho", "j", "hd", "H", "header", "hl", "gh", "http", "v", "l", "hm", "end", "g", "han", "d", "ah", "u", "kh", "rh", "auth", "q", "o", "uh", "c", "hash", "history", "bh", "ph", "k", "ih", "e", "hs", "host", "f", "t", "adh", "p", "hr", "b", "zh", "th", "html", "hw", "hist", "ht", "hh", "hy", "en", "ha", "_", "eh", "m", "sh", "ch", "he", "hi", "all"], "s": ["i", "es", "ds", "sys", "r", "ssl", "us", "stats", "js", "submit", "aws", "n", "S", "ns", "rs", "http", "v", "conf", "l", "this", "ss", "sb", "support", "g", "ses", "sports", "d", "site", "services", "res", "screen", "o", "sg", "c", "self", "spec", "sc", "sf", "su", "e", "ess", "qs", "hs", "fs", "f", "t", "p", "cli", "si", "b", "service", "sup", "side", "ps", "gs", "secondary", "sq", "port", "sci", "sl", "m", "storage", "shared", "ls", "sync", "is", "sh", "in", "w", "session", "server", "share"], "x": ["col", "i", "row", "ix", "g", "d", "rx", "f", "t", "m", "j", "p", "c", "index", "num", "X", "dim", "b", "w", "n", "z", "v", "l", "k"], "y": ["col", "i", "e", "vy", "yy", "d", "height", "f", "t", "m", "j", "p", "o", "dy", "c", "a", "b", "ii", "Y", "w", "cy", "n", "z", "l", "k", "type"]}}
{"project": "FFmpeg", "commit_id": "3583eb93410a73cac8ddf291baa405005ff4c405", "target": 0, "func": "static inline CopyRet copy_frame(AVCodecContext *avctx,\n\n                                 BC_DTS_PROC_OUT *output,\n\n                                 void *data, int *data_size,\n\n                                 uint8_t second_field)\n\n{\n\n    BC_STATUS ret;\n\n    BC_DTS_STATUS decoder_status;\n\n    uint8_t is_paff;\n\n    uint8_t next_frame_same;\n\n    uint8_t interlaced;\n\n\n\n    CHDContext *priv = avctx->priv_data;\n\n\n\n    uint8_t bottom_field = (output->PicInfo.flags & VDEC_FLAG_BOTTOMFIELD) ==\n\n                           VDEC_FLAG_BOTTOMFIELD;\n\n    uint8_t bottom_first = !!(output->PicInfo.flags & VDEC_FLAG_BOTTOM_FIRST);\n\n\n\n    int width    = output->PicInfo.width;\n\n    int height   = output->PicInfo.height;\n\n    int bwidth;\n\n    uint8_t *src = output->Ybuff;\n\n    int sStride;\n\n    uint8_t *dst;\n\n    int dStride;\n\n\n\n    ret = DtsGetDriverStatus(priv->dev, &decoder_status);\n\n    if (ret != BC_STS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"CrystalHD: GetDriverStatus failed: %u\\n\", ret);\n\n       return RET_ERROR;\n\n    }\n\n\n\n    is_paff           = ASSUME_PAFF_OVER_MBAFF ||\n\n                        !(output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC);\n\n    next_frame_same   = output->PicInfo.picture_number ==\n\n                        (decoder_status.picNumFlags & ~0x40000000);\n\n    interlaced        = ((output->PicInfo.flags &\n\n                          VDEC_FLAG_INTERLACED_SRC) && is_paff) ||\n\n                         next_frame_same || bottom_field || second_field;\n\n\n\n    av_log(avctx, AV_LOG_VERBOSE, \"CrystalHD: next_frame_same: %u | %u | %u\\n\",\n\n           next_frame_same, output->PicInfo.picture_number,\n\n           decoder_status.picNumFlags & ~0x40000000);\n\n\n\n    if (priv->pic.data[0] && !priv->need_second_field)\n\n        avctx->release_buffer(avctx, &priv->pic);\n\n\n\n    priv->need_second_field = interlaced && !priv->need_second_field;\n\n\n\n    priv->pic.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE |\n\n                             FF_BUFFER_HINTS_REUSABLE;\n\n    if (!priv->pic.data[0]) {\n\n        if (avctx->get_buffer(avctx, &priv->pic) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return RET_ERROR;\n\n        }\n\n    }\n\n\n\n    bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n\n    if (priv->is_70012) {\n\n        int pStride;\n\n\n\n        if (width <= 720)\n\n            pStride = 720;\n\n        else if (width <= 1280)\n\n            pStride = 1280;\n\n        else if (width <= 1080)\n\n            pStride = 1080;\n\n        sStride = av_image_get_linesize(avctx->pix_fmt, pStride, 0);\n\n    } else {\n\n        sStride = bwidth;\n\n    }\n\n\n\n    dStride = priv->pic.linesize[0];\n\n    dst     = priv->pic.data[0];\n\n\n\n    av_log(priv->avctx, AV_LOG_VERBOSE, \"CrystalHD: Copying out frame\\n\");\n\n\n\n    if (interlaced) {\n\n        int dY = 0;\n\n        int sY = 0;\n\n\n\n        height /= 2;\n\n        if (bottom_field) {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: bottom field\\n\");\n\n            dY = 1;\n\n        } else {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: top field\\n\");\n\n            dY = 0;\n\n        }\n\n\n\n        for (sY = 0; sY < height; dY++, sY++) {\n\n            memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);\n\n            if (interlaced)\n\n                dY++;\n\n        }\n\n    } else {\n\n        av_image_copy_plane(dst, dStride, src, sStride, bwidth, height);\n\n    }\n\n\n\n    priv->pic.interlaced_frame = interlaced;\n\n    if (interlaced)\n\n        priv->pic.top_field_first = !bottom_first;\n\n\n\n    if (output->PicInfo.timeStamp != 0) {\n\n        priv->pic.pkt_pts = opaque_list_pop(priv, output->PicInfo.timeStamp);\n\n        av_log(avctx, AV_LOG_VERBOSE, \"output \\\"pts\\\": %\"PRIu64\"\\n\",\n\n               priv->pic.pkt_pts);\n\n    }\n\n\n\n    if (!priv->need_second_field) {\n\n        *data_size       = sizeof(AVFrame);\n\n        *(AVFrame *)data = priv->pic;\n\n    }\n\n\n\n    if (ASSUME_TWO_INPUTS_ONE_OUTPUT &&\n\n        output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) {\n\n        av_log(priv->avctx, AV_LOG_VERBOSE, \"Fieldpair from two packets.\\n\");\n\n        return RET_SKIP_NEXT_COPY;\n\n    }\n\n\n\n    return RET_OK;\n\n}\n", "idx": 20320, "substitutes": {"avctx": [" avctrl", "avesync", "AVcf", "evcf", "AVcmp", "afcf", "vercontext", "afsync", "avsync", "avectrl", "avsc", "airctx", "Avconn", "verctx", "afcmp", "avconn", "evconn", "AVctrl", "AVcontext", "afctx", "evcontext", "avcf", "Avloc", "akcontext", "Avcontext", "akctx", "avecontext", "versync", "aircmp", "avcontext", "afna", "AVconn", "akconn", "afsc", " avconn", "avalctx", "versc", "avena", "avalconn", "akcf", "evctx", "avectx", "avcmp", "Avctx", "aircf", "aircontext", "AVctx", "afcontext", "afconn", "avalcontext", "avctrl", " avcontext", " avna", "AVloc", "aveconn", "avna", "avalloc", "avloc", "avesc"], "output": ["io", "application", "after", "public", "name", "summary", "target", "external", "generated", "response", "object", "conn", "oe", "config", "event", "option", "result", "input", "connection", "ou", "control", "export", "generation", "product", "model", "write", "outer", "exec", "address", "information", "Output", "OU", "version", "current", "oper", "unit", "o", "context", "operation", "client", "module", "source", "document", "run", "profile", "date", "error", "console", "PUT", "page", "reference", "update", "parent", "stage", "fn", "resource", "protected", "image", "production", "environment", "sort", "note", "type"], "data": ["binary", "start", "response", "next", "config", "ui", "result", "input", "message", "Data", "extra", "bin", "style", "align", "picture", "buffer", "done", "results", "fee", "size", "da", "cache", "body", "open", "memory", "background", "source", "DATA", "window", "tmp", "channel", "read", "media", "slice", "batch", "parent", "buff", "dat", "resource", "image", "block", "video", "value"], "data_size": ["data_SIZE", "window_capacity", "window_needed", "window_size", "data_capacity", "data_needed", "window_SIZE"], "second_field": ["first_field", "first_fields", "second_match", "second_margin", "secondfullmatch", "secondOffdiff", " second_diff", "secondfulldiff", "first_diff", "first_margin", " second_match", "secondOfffield", "secondfullfields", "secondOffmargin", "secondOfffields", "second_diff", "second_fields", "secondfullfield", " second_fields"], "ret": ["status", "reg", "sb", "ut", "red", "def", "fi", "fail", "ref", "err", "valid", "std", "result", "val", "db", "ft", "det", "rep", "tr", "Ret", "mt", "cur", "no", "rf", "r", "info", "res", "cat", "final", "stat", "fin", " RET", "code", "fun", "detail", "success", "rc", "ext", "RET", "rt", "mem", "flag", "hash", "reply", "rev", "re", "len", "rs", "back", "bf", "alt", "nt", "bot", "lit", "att", "feat", "rets"], "decoder_status": ["decoder_result", "decoderallmagic", "decoderingstatus", "decoderallstatus", "decryption_date", "decryption_status", "decoder_Status", "decensoringsum", "decensoringresult", "decoderfstate", "decryptionallstat", "decoderfstatus", "decoded_options", "decensor_status", "decode_status", "decoder_data", "decoder_state", "decensoringstate", "decode_data", "decoder_date", "decryptionallstatus", "decoderingresult", "decoded_Status", "decode_stat", "decoderingsum", "decoderfsum", "decryption_stat", "decryption_magic", "decryptionalldate", "decensoringstatus", "decoder_sum", "decoderingstate", "decensor_result", "decensor_sum", "decoderfresult", "decoded_status", "decoder_stat", "decoderallstat", "decoder_options", "decryptionallmagic", "decensor_state", "decoderalldate", "decoder_magic"], "is_paff": ["is_pff", "is__pAff", "is__Pff", "is_Paux", "is_npaf", "is___pff", "is__paff", "is_pAff", "is_rff", "is__paf", "is__Paf", "is_paux", "is___puff", "is_apaux", "is_Pff", "is___raf", "is_baff", "is_Paf", "is__PAff", "is_paaff", "is_baf", "is_npff", "is_paaux", "is___rff", "is_bAff", "is_preaff", "is_raf", "is__Paff", "is_preuff", "is___raff", "is_npAff", "is_apff", "is_preff", "is_puff", "is_pauff", "is_bff", "is___ruff", "is___paf", "is___paff", "is_paaf", "is_paf", "is_PAff", "is_ruff", "is_raff", "is_npaff", "is__pff", "is_apaff", "is_apaf", "is_preaf", "is_Paff"], "next_frame_same": ["next_frame_both", "next_frame__different", "next_frame\u00b7square", "next_frame_one", "next_line_equal", "next_frame_different", "next_frame_present", "next_frame__same", "next_frame_less", "next_frame\u00b7equal", "next_frame__equal", "next_frame_equal", "next_line_same", "next_frame__less", "next_frame_square", "next_frame\u00b7both", "next_frame\u00b7same", "next_line_different", "next_line_less", "next_frame_shared"], "interlaced": [" interlated", "Interplace", "interflaid", "interranged", "interflaced", "interlacial", "interraid", "interolated", " interrated", "interslacing", "interLacial", "interLaid", "Interplaced", "Interlaid", "Interplaid", " interlaid", "interLaced", "Interlace", " interflanged", "interranded", "interLacer", " interlacial", " interlanged", " interflacial", "interlanged", "interslaced", " interraced", " interranded", " interracing", "interlacing", "interplace", "interlaid", " interflaid", " interflaced", "interlace", "interracing", "interpolace", "interpolaid", "interracial", "interLanged", "interpolaced", "interslated", "interpolacer", "interlacer", " interlacing", "Interlacer", "interrated", "interlated", "interslanded", "interLace", "interplacer", "Interlaced", "interlanded", " interlanded", "interflacial", "interolanded", "interolacing", "interplaid", "Interplacer", "interplaced", "interraced", "interolaced", "interflanged"], "priv": ["bc", "ee", "config", "progress", "mini", "Priv", "temp", "pdf", "info", "cp", "pri", "mem", "reader", "proc", "conf", "dest", "attr", "pub", "str", "txt", "org", "password", "conn", "prof", "usa", "text", "private", "cookie", "anc", "fee", "dev", "state", "stat", "enc", "auth", "rc", "spec", "cert", "utils", "lib", "li", "typ", "ie", "public", "reg", "uc", "err", "prot", "impl", "rec", "access", "exec", "ocr", "ptr", "tmp", "service", "prom", "req", "sec", "resource", "api", "ec", "gb", "fac", "obj", "input", "env", "cache", "storage", "inner", "client", "pro", "riv", "ch", "rib", "contract"], "bwidth": ["bWidth", "nlength", "lwidth", "llength", " blength", "nwidth", " bWidth", "nWidth", "lWidth", "blength"], "src": ["view", "config", "scene", "sl", "origin", "uri", "img", "dist", "bg", "pic", "crop", "buf", "rc", "filename", "cb", "source", "sc", "sub", "tmp", "desc", "slice", "loc", "dest", "rb", "stream", "image", "attr", "url"], "sStride": ["sSTride", "mStridden", "sUrip", "mStrip", "mStrow", "sVerrow", "sStrow", "sUrow", "sVerridden", "mVerride", "sSTrow", "mStride", "mVerridden", "mVerrow", "sStridden", "sSTridden", "sStrip", "sUride", "sSTrip", "sUridden", "sVerrip", "sVerride", "mVerrip"], "dst": ["dbl", "dcr", "pste", "dste", " dbl", "pcr", "hste", "hcr", "pbl", " dste", "pst", "hbl", "hst", " dcr"], "dStride": ["dStflow", "dStri", "dScflow", "dRestrite", "dScrite", "fRestride", "dShflow", "fRestri", "dRestri", "dShrite", "dScride", "dShri", "fRestrite", "fStri", "fRestflow", "dRestride", "dRestflow", "fStflow", "fStrite", "dScri", "dShride", "fStride", "dStrite"]}}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n", "idx": 20327, "substitutes": {"nc": ["lc", "bc", "fc", "sb", "cc", "e", "conn", "ct", "config", "g", "kt", "cv", "unc", "cm", "pc", "anc", "node", "ci", "nec", "nd", "enc", "cs", "mc", "cf", "sync", "ng", "rc", "c", "rn", "ctx", "cn", "nr", "sc", "nw", "dc", "n", "NC", "ns", "cdn", "cus", "cms", "ne", "nt", "sn", "ec", "nm"], "s": ["request", "sb", "e", "sym", "qs", "es", "bis", "send", "sie", "sl", "hs", "fs", "ses", "an", "g", "xs", "your", "d", "ops", "ks", "ds", "services", "f", "sys", "t", "u", "m", "args", "its", "ssl", "ys", "p", "ts", "cs", "enc", "os", "o", "sync", "is", "ss", "ls", "sg", "c", "js", "settings", "spec", "si", "sc", "sr", "w", "service", "se", "core", "n", "S", "session", "ns", "src", "sf", "new", "south", "rs", "gs", "conf", "sec", "sn", "su", "sq", "states"]}}
{"project": "qemu", "commit_id": "79d5ca5617cfc9be13a4f314ed800fca1267d903", "target": 1, "func": "static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 20328, "substitutes": {"fd": ["fa", " FD", "fc", "name", "fff", "cd", "rd", "fs", "fb", "wd", "d", "func", "ffff", "hid", "draft", "pd", "handler", "ln", "ds", "fp", "f", "dn", "FD", "df", "pipe", "weight", "dir", "fee", "size", "nd", "xf", "fin", "fx", "dy", "filename", "fe", " fid", "du", "pid", "lvl", "fed", "dl", "fl", "length", "fw", "len", "sf", "fen", "wat", "fn", "lf", "frequency", "fi", "fun"], "node": ["remote", "route", "native", "name", "e", "nav", "object", "ref", "event", "valid", "nn", "result", "none", "tree", "post", "null", "card", "uri", "anch", "handler", "leaf", "host", "type", "local", "f", "path", "op", "slave", "one", "ode", "new", "component", "id", "Node", "od", "load", "inner", "open", "content", "live", "gen", "self", "edge", "num", "source", "document", "dom", "add", "missing", "core", "error", "n", "child", "cdn", "root", "parent", "fn", "instance", "empty", "this", "value"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,\n\n                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    int i;\n\n#if COMPILE_TEMPLATE_MMX\n\n    if(!(c->flags & SWS_BITEXACT)) {\n\n        long p= 4;\n\n        const int16_t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW};\n\n        uint8_t *dst[4]= {aDest, dest, uDest, vDest};\n\n        x86_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};\n\n\n\n        if (c->flags & SWS_ACCURATE_RND) {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121_ACCURATE\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        }\n\n        return;\n\n    }\n\n#endif\n\n    for (i=0; i<dstW; i++) {\n\n        int val= (lumSrc[i]+64)>>7;\n\n\n\n        if (val&256) {\n\n            if (val<0) val=0;\n\n            else       val=255;\n\n        }\n\n\n\n        dest[i]= val;\n\n    }\n\n\n\n    if (uDest)\n\n        for (i=0; i<chrDstW; i++) {\n\n            int u=(chrSrc[i       ]+64)>>7;\n\n            int v=(chrSrc[i + VOFW]+64)>>7;\n\n\n\n            if ((u|v)&256) {\n\n                if (u<0)        u=0;\n\n                else if (u>255) u=255;\n\n                if (v<0)        v=0;\n\n                else if (v>255) v=255;\n\n            }\n\n\n\n            uDest[i]= u;\n\n            vDest[i]= v;\n\n        }\n\n\n\n    if (CONFIG_SWSCALE_ALPHA && aDest)\n\n        for (i=0; i<dstW; i++) {\n\n            int val= (alpSrc[i]+64)>>7;\n\n            aDest[i]= av_clip_uint8(val);\n\n        }\n\n}\n", "idx": 20338, "substitutes": {"c": ["lc", "bc", "e", "cd", "cc", "conn", "ct", "config", "g", "coll", "cm", "d", "con", "pc", "l", "cur", "cu", "f", "ci", "t", "ac", "u", "m", "s", "cp", "r", "cs", "xc", "mc", "ctrl", "enc", "ctx", "cn", "ch", "sc", "comp", "b", "dc", "w", "cy", "n", "C", "ce", "conf", "cit", "oc", "ec", "vc"], "lumSrc": ["lumEsdr", "lumaSr", "lnumAsRC", "lumEsrc", "lpSRC", "lpEsrc", "lumSloc", "lnumAsdc", "lpSsrc", "lumEsRC", "lpSrc", "lpEsdr", "lumAsdr", "lumAsdc", "lumaAsdc", "lumEssrc", "lnumAsrc", "lpSdr", "lumSRC", "lpEsRC", "lumPsloc", "lumAssrc", "lnumSrc", "lnumAsloc", "lumaAsr", "lpEssrc", "lumPsdc", "lumEsloc", "lumEsdc", "lumAsrc", "lumSdc", "lumaSdc", "lumAsloc", "lumPsrc", "lumAsr", "lumPsRC", "lumSdr", "lumEsr", "lumAsRC", "lumaSrc", "lumaSRC", "lnumSdc", "lnumSRC", "lumSr", "lnumSloc", "lumSsrc", "lumaAsRC", "lumaAsrc"], "chrSrc": ["chrrSumrc", "chpPsRC", "chpSource", "chrSuc", "chranIsdr", "chrrSumirc", "chrPsri", "chrSri", "chrrSRC", "chrDgd", "chrPsrc", "chpSrt", "chrEsri", "chrSst", "chrIsource", "chrGgd", "chrrSrc", "chrDrc", "chrPsrec", "chrGource", "chrtSetrc", "chrAsrt", "chrAsrc", "chrtSetuc", "chrSirc", "chpDrc", "chrIsRC", "chrSdr", "chrAsuc", "chrSetRC", "chranSource", "chpDrt", "chrIsuc", "chrEsrc", "chrInsgd", "chranIsrc", "chrPsRC", "chrInsource", "chrSRC", "chrIsrc", "chrEsource", "chrSetrc", "chrInsrc", "chrAsource", "chrDrt", "chrGrt", "chrEsRC", "chrSumrc", "chrIsdr", "chpPsrc", "chrIsst", "chrtSrc", "chrtSst", "chranSdr", "chrGrc", "chrrSirc", "chpSgd", "chrEsdr", "chrDource", "chrSrec", "chrtSRC", "chrSetuc", "chrAsdr", "chrtSuc", "chpSrec", "chrrSumri", "chrPsirc", "chrSource", "chranSRC", "chrDrec", "chrrSumRC", "chpDource", "chpPsrec", "chrAsst", "chranSrc", "chrAsrec", "chrrSri", "chrSumRC", "chrInsrt", "chrAsRC", "chpSRC", "chrSrt", "chrEsirc", "chrSgd", "chrtSetRC", "chranIsource", "chrDRC", "chrPsrt", "chrSetst", "chpSrc", "chpPsrt", "chranIsRC", "chrtSetst", "chpDgd", "chrSumri", "chrSumirc"], "alpSrc": ["alpSgd", "alrNdr", "alcSgd", "alrNrc", "alcSdr", "alrSdr", "alrSrc", "alpNdr", "alpNrc", "alcAsdr", "alpAsgd", "alpSdr", "alrNRC", "alpAsRC", "alpAsdr", "alcAsRC", "alcSrc", "alrNsrc", "alpSRC", "alcAsrc", "alpAsrc", "alpNsrc", "alcAsgd", "alcSRC", "alpNRC", "alrSRC", "alpAssrc", "alpSsrc", "alrSsrc"], "dest": ["route", "transform", "target", "flat", "uc", " destination", "send", "config", "asc", "decl", "de", "img", "path", "dist", "dep", "cont", "done", "coord", "rest", "data", "dev", "opt", "diff", "trans", "wb", " Dest", "gen", "destroy", "Dest", "source", "sc", "dim", "dc", "usr", "desc", "cdn", "loc", "comb", "dat", "orig", "sort", "output", "prop"], "uDest": ["nDist", "nDesc", "vDist", "udest", "aDist", "UDest", "oDest", "oDist", "adest", " uDist", "Udest", " uDesc", "aSource", "aNeg", "uSource", "vdest", "ndest", "oSource", "odest", "uDist", "UNeg", "uNeg", "UDesc", "vDesc", "UDist", "nDest", "aDesc", "vSource", "uDesc", " uNeg"], "vDest": ["uDep", " vTrans", "vDist", "hDist", "hDesc", "hDep", " vDist", "cDist", "bDist", "bTrans", "cDest", "hDest", "bDest", "uDist", "uTrans", "vDesc", "cDep", "cDesc", "vTrans", "vDep", "uDesc"], "aDest": ["sDesc", "bSource", "sDist", "aDist", "ASc", "aSource", " aSc", "bDist", "saDest", "ADest", " aSource", "ADist", "bSc", "ASource", "sDest", " aDist", "ADesc", "bDest", "aSc", "saDesc", "saDist", "aDesc"], "dstW": ["dSTC", "dstsVW", "dstaR", "dstM", "dstC", "dstsW", "destV", "DestH", "DstR", "drcW", "dastH", "DstM", "dstH", "dstsH", "dndW", "dstVW", "dostw", "DestU", "destU", "dstsw", "DSTL", "DndW", "dastC", "DndC", "dndM", "dstaM", "DestC", "dSTG", "dndV", "DestVW", "dstaW", "dSTU", "dStWe", "DestG", "destG", "DndV", "DstC", "destC", "destR", "destM", "dndWe", "dstV", "dostVW", "Destw", "drcV", "dSTR", "dstsU", "DestWe", "DestW", "dStL", "DestM", "drcC", "dastV", "Dstw", "dostW", "DstVW", "DSTM", "destw", "dSTW", "dndH", "DstL", "dndC", "DstH", "destW", "dstw", "dstG", "dstsV", "DstU", "dndL", "DstWe", "dstU", "dStW", "dostC", "dSTH", "dstWe", "dStM", "DstG", "DstV", "dstsG", "DstW", "dstL", "destVW", "dostH", "dostM", "dstR", "destH", "DndH", "dstaL", "drcH", "dSTM", "DestV", "DSTR", "destWe", "dostV", "destL", "DSTW", "dastW", "dSTL", "DestL"], "chrDstW": ["chrdstaW", "chrDdrV", "chrdstaX", "chrInstW", "chrDsstM", "chrDstaC", "chrDssnY", "chrSstW", "chrDSTV", "chrDstM", "chrDstGW", "chrdstL", "chrDsnY", "chrdntW", "chrDStF", "chrDstF", "chrDestM", "chrDdrGW", "chrDSTL", "chrDestL", "chrDStC", "chrSestW", "chrInstH", "chrDntV", "chrSestV", "chrDsnL", "chrdstV", "chrSstV", "chrSestH", "chrNSTW", "chrDrcW", "chrdstaC", "chrDSTX", "chrDestY", "chrInntH", "chrDdrW", "chrDsstL", "chrDntL", "chrDestC", "chrDestW", "chrDSTC", "chrdstX", "chrSstL", "chrDrcL", "chrInntGW", "chrdstM", "chrDstC", "chrDstX", "chrDsnW", "chrNstM", "chrDssnL", "chrdstH", "chrNstC", "chrDdrH", "chrDrcM", "chrDSTF", "chrDrcV", "chrSestL", "chrNSTM", "chrDstV", "chrDsstW", "chrdstC", "chrDSTH", "chrInstV", "chrDssnM", "chrNSTF", "chrDSTW", "chrInntW", "chrDStW", "chrDstH", "chrDestH", "chrInstGW", "chrDstaH", "chrDstY", "chrDrcX", "chrDSTM", "chrNstF", "chrDntGW", "chrdntV", "chrNSTC", "chrDrcH", "chrNstW", "chrDstL", "chrInntV", "chrSstH", "chrDsnM", "chrDrcC", "chrDssnW", "chrdntM", "chrDstaW", "chrDntH", "chrDsstY", "chrdstW", "chrdstaH", "chrDntW", "chrDSTGW", "chrDestV", "chrDestF", "chrDntM", "chrDStM", "chrdntL", "chrDSTY", "chrDstaX"], "i": ["io", "ali", "uli", "e", "ix", "ie", "fi", "qi", "jp", "ri", "ui", "eni", "gi", "d", "uri", "P", "ti", "I", "l", "f", "pos", "ci", "t", "y", "u", "phi", "m", "ini", "it", "j", "info", "init", "data", "oi", "ip", "abi", "id", "ori", "bi", "inner", "is", "mi", "mu", "index", "si", "a", "ii", "b", "in", "n", "iu", "ai", "xi", "di", "v", "multi", "yi", "li", "z", "pi", "x", "k", "ni", "type"], "src": ["uc", "config", "gl", "rec", "bin", "img", "gb", "opt", "buf", "rc", "cb", "source", "sc", "comp", "rl", "dc", "sub", "sur", "desc", "inst", "loc", "req", "proc", "sec", "rb", "stream", "url"], "dst": ["DST", " dST", "Dst", "sst", "ssts", "fsc", "dsc", "Dsc", " dsc", "dsp", "fsp", "dST", "fst", "idst", "ssp", "fsts", "dsts", "idsc", "idST", "Dsp", "sST", "Dsts", " dsts", "idsp", "idsts", " dsp"], "counter": ["name", "class", "table", "obj", "ger", "map", "tr", "processor", "buffer", "names", "entry", "alog", "cache", "arr", "currency", "list", "uments", "comp", "mem", "loader", "seq", "desc", "inst", "mask", "trace", "proc", "array", "record", "count"], "p": ["pb", "port", "hp", "e", "ap", "jp", "lp", "g", "progress", "pe", "part", "pi", "post", "pm", "P", "bp", "pc", "f", "po", "per", "t", "op", "r", "u", "m", "pre", "j", "tp", "pp", "patch", "ip", "current", "point", "o", "np", "q", "body", "pr", "wp", "a", "b", "pid", "pat", "n", "pn", "br", "ps", "parent", " P", "v", "pointer", "sp", "h", "l", "api", "pu", "ph", "pa"]}}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n            env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        } else if (n < CPU_NB_REGS32) {\n\n            n = gpr_map32[n];\n\n            env->regs[n] &= ~0xffffffffUL;\n\n            env->regs[n] |= (uint32_t)ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        if (n < CPU_NB_REGS32 ||\n\n            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {\n\n            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n            return 16;\n\n        }\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n                env->eip = ldq_p(mem_buf);\n\n                return 8;\n\n            } else {\n\n                env->eip &= ~0xffffffffUL;\n\n                env->eip |= (uint32_t)ldl_p(mem_buf);\n\n                return 4;\n\n            }\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 20345, "substitutes": {"cs": ["lc", "cc", "ix", "qs", "sk", "conn", "fs", "cons", "ks", "css", "pc", "ds", "CS", "ci", "sys", "nc", "cp", "vs", "cf", "ls", "rc", "c", "ctx", "js", "spec", "cn", "cfg", "sc", "core", "ns", "cus", "ps", "rs", "gs", "ck", "ips", "ec", "acs"], "mem_buf": ["ram_uf", "mem_seq", "ram_bur", "access64home", "memllbuf", "access_pub", "memlexbuf", "memlexqueue", "ram_queue", "Mem_buffer", "ram_buf", "memxbuff", "mem_bur", "memllbur", "memllbatch", "memfqueue", "access_buf", "mem_home", "memxuf", "mem64home", "memllbuff", "process_buf", "ram_buff", "memfbuffer", "mem2bur", "access64buf", "mem2queue", "ram_seq", "Mem_comb", "memlexuf", "mem_buff", "mem_queue", "Mem_buf", "process_uf", "mem_buffer", "Mem_queue", "mem64buf", "process_batch", "memfbuf", "access64pub", "memlluf", "mem_batch", "mem_comb", "access_home", "memxbuf", "memfuf", "memlexseq", "mem2uf", "mem64pub", "mem2buff", "process_buffer", "Mem_buff", "memllbuffer", "Mem_uf", "mem_pub", "memxcomb", "mem2buf", "mem_uf"], "n": [" N", "i", "name", "net", "native", "un", "e", "en", "nat", "conn", "yn", "adj", "nn", "g", "non", "none", "d", "mn", "not", "node", "no", "f", "dn", "t", "y", "N", "nc", "m", "u", "j", "init", "s", "r", "p", "current", "number", "o", "np", "ng", "network", "c", "rn", "nr", "num", "cn", "a", "b", "in", "min", "ns", "len", "br", "nb", "z", "v", "nt", "sn", "fn", "nor", "all", "nu", "l", "x", "pn", "ne", "k", "nm", "ni"], "cpu": ["lc", "platform", "bench", "net", "gpu", "conn", "nn", "g", "eni", "cm", " cp", "processor", "pc", "CPU", "node", "ea", "nc", "cp", "socket", "cache", "cf", "np", "c", "rn", "ctx", "num", "cn", "cfg", "cal", "mem", "python", "core", "pn", "proc", "vm", "instance", "clock", "pu", "ec"], "env": ["config", "event", "eur", "eni", "extra", "eff", "exc", "fg", "que", "context", " environments", "cdn", "global", "conf", "ev", "inet", "output", "org", "end", "conn", "db", "cv", "oa", "eng", "site", "ef", "enc", "assets", "code", "ext", "et", "cfg", "equ", " environment", "desc", "utils", "fen", "erv", "scope", "stack", "net", "e", "err", "eu", "kernel", "esp", "ea", "exec", "her", "uv", "cf", "cli", "Environment", "el", "enable", "gui", "loader", "core", "ne", "ec", "en", "obj", "energy", "export", "engine", "esi", "nc", "args", "cache", "vs", "dict", "np", "settings", "ctx", "cal", "viron", "session", "console", "estate", "server", "environment"], "tmp": [" v", " temp", " proc", "_", "temp", "img", " len", " c", "cp", "cache", " args", "np", " buf", "buf", " dest", " p", "mp", " src", "nb", "proc", "v", " ff", " result", " np", "max", " dst"]}}
{"project": "FFmpeg", "commit_id": "70b1dcef2d859ae6b3e21d61de928c3dd0cf1aa4", "target": 0, "func": "int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n\n                                     H264ParamSets *ps)\n\n{\n\n    AVBufferRef *sps_buf;\n\n    int profile_idc, level_idc, constraint_set_flags = 0;\n\n    unsigned int sps_id;\n\n    int i, log2_max_frame_num_minus4;\n\n    SPS *sps;\n\n\n\n    profile_idc           = get_bits(gb, 8);\n\n    constraint_set_flags |= get_bits1(gb) << 0;   // constraint_set0_flag\n\n    constraint_set_flags |= get_bits1(gb) << 1;   // constraint_set1_flag\n\n    constraint_set_flags |= get_bits1(gb) << 2;   // constraint_set2_flag\n\n    constraint_set_flags |= get_bits1(gb) << 3;   // constraint_set3_flag\n\n    constraint_set_flags |= get_bits1(gb) << 4;   // constraint_set4_flag\n\n    constraint_set_flags |= get_bits1(gb) << 5;   // constraint_set5_flag\n\n    skip_bits(gb, 2);                             // reserved_zero_2bits\n\n    level_idc = get_bits(gb, 8);\n\n    sps_id    = get_ue_golomb_31(gb);\n\n\n\n    if (sps_id >= MAX_SPS_COUNT) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sps_buf = av_buffer_allocz(sizeof(*sps));\n\n    if (!sps_buf)\n\n        return AVERROR(ENOMEM);\n\n    sps = (SPS*)sps_buf->data;\n\n\n\n    sps->sps_id               = sps_id;\n\n    sps->time_offset_length   = 24;\n\n    sps->profile_idc          = profile_idc;\n\n    sps->constraint_set_flags = constraint_set_flags;\n\n    sps->level_idc            = level_idc;\n\n\n\n    memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n\n    memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n\n    sps->scaling_matrix_present = 0;\n\n\n\n    if (sps->profile_idc == 100 ||  // High profile\n\n        sps->profile_idc == 110 ||  // High10 profile\n\n        sps->profile_idc == 122 ||  // High422 profile\n\n        sps->profile_idc == 244 ||  // High444 Predictive profile\n\n        sps->profile_idc ==  44 ||  // Cavlc444 profile\n\n        sps->profile_idc ==  83 ||  // Scalable Constrained High profile (SVC)\n\n        sps->profile_idc ==  86 ||  // Scalable High Intra profile (SVC)\n\n        sps->profile_idc == 118 ||  // Stereo High profile (MVC)\n\n        sps->profile_idc == 128 ||  // Multiview High profile (MVC)\n\n        sps->profile_idc == 138 ||  // Multiview Depth High profile (MVCD)\n\n        sps->profile_idc == 144) {  // old High444 profile\n\n        sps->chroma_format_idc = get_ue_golomb_31(gb);\n\n        if (sps->chroma_format_idc > 3) {\n\n            avpriv_request_sample(avctx, \"chroma_format_idc %u\",\n\n                                  sps->chroma_format_idc);\n\n            goto fail;\n\n        } else if (sps->chroma_format_idc == 3) {\n\n            sps->residual_color_transform_flag = get_bits1(gb);\n\n        }\n\n        sps->bit_depth_luma   = get_ue_golomb(gb) + 8;\n\n        sps->bit_depth_chroma = get_ue_golomb(gb) + 8;\n\n        if (sps->bit_depth_chroma != sps->bit_depth_luma) {\n\n            avpriv_request_sample(avctx,\n\n                                  \"Different chroma and luma bit depth\");\n\n            goto fail;\n\n        }\n\n        sps->transform_bypass = get_bits1(gb);\n\n        decode_scaling_matrices(gb, sps, NULL, 1,\n\n                                sps->scaling_matrix4, sps->scaling_matrix8);\n\n    } else {\n\n        sps->chroma_format_idc = 1;\n\n        sps->bit_depth_luma    = 8;\n\n        sps->bit_depth_chroma  = 8;\n\n    }\n\n\n\n    log2_max_frame_num_minus4 = get_ue_golomb(gb);\n\n    if (log2_max_frame_num_minus4 < MIN_LOG2_MAX_FRAME_NUM - 4 ||\n\n        log2_max_frame_num_minus4 > MAX_LOG2_MAX_FRAME_NUM - 4) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"log2_max_frame_num_minus4 out of range (0-12): %d\\n\",\n\n               log2_max_frame_num_minus4);\n\n        goto fail;\n\n    }\n\n    sps->log2_max_frame_num = log2_max_frame_num_minus4 + 4;\n\n\n\n    sps->poc_type = get_ue_golomb_31(gb);\n\n\n\n    if (sps->poc_type == 0) { // FIXME #define\n\n        sps->log2_max_poc_lsb = get_ue_golomb(gb) + 4;\n\n    } else if (sps->poc_type == 1) { // FIXME #define\n\n        sps->delta_pic_order_always_zero_flag = get_bits1(gb);\n\n        sps->offset_for_non_ref_pic           = get_se_golomb(gb);\n\n        sps->offset_for_top_to_bottom_field   = get_se_golomb(gb);\n\n        sps->poc_cycle_length                 = get_ue_golomb(gb);\n\n\n\n        if ((unsigned)sps->poc_cycle_length >=\n\n            FF_ARRAY_ELEMS(sps->offset_for_ref_frame)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"poc_cycle_length overflow %d\\n\", sps->poc_cycle_length);\n\n            goto fail;\n\n        }\n\n\n\n        for (i = 0; i < sps->poc_cycle_length; i++)\n\n            sps->offset_for_ref_frame[i] = get_se_golomb(gb);\n\n    } else if (sps->poc_type != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"illegal POC type %d\\n\", sps->poc_type);\n\n        goto fail;\n\n    }\n\n\n\n    sps->ref_frame_count = get_ue_golomb_31(gb);\n\n    if (sps->ref_frame_count > H264_MAX_PICTURE_COUNT - 2 ||\n\n        sps->ref_frame_count >= 32U) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"too many reference frames %d\\n\", sps->ref_frame_count);\n\n        goto fail;\n\n    }\n\n    sps->gaps_in_frame_num_allowed_flag = get_bits1(gb);\n\n    sps->mb_width                       = get_ue_golomb(gb) + 1;\n\n    sps->mb_height                      = get_ue_golomb(gb) + 1;\n\n    if ((unsigned)sps->mb_width  >= INT_MAX / 16 ||\n\n        (unsigned)sps->mb_height >= INT_MAX / 16 ||\n\n        av_image_check_size(16 * sps->mb_width,\n\n                            16 * sps->mb_height, 0, avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"mb_width/height overflow\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    sps->frame_mbs_only_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag)\n\n        sps->mb_aff = get_bits1(gb);\n\n    else\n\n        sps->mb_aff = 0;\n\n\n\n    sps->direct_8x8_inference_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag && !sps->direct_8x8_inference_flag) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n\n        goto fail;\n\n    }\n\n\n\n#ifndef ALLOW_INTERLACE\n\n    if (sps->mb_aff)\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MBAFF support not included; enable it at compile-time.\\n\");\n\n#endif\n\n    sps->crop = get_bits1(gb);\n\n    if (sps->crop) {\n\n        unsigned int crop_left   = get_ue_golomb(gb);\n\n        unsigned int crop_right  = get_ue_golomb(gb);\n\n        unsigned int crop_top    = get_ue_golomb(gb);\n\n        unsigned int crop_bottom = get_ue_golomb(gb);\n\n\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP) {\n\n            av_log(avctx, AV_LOG_DEBUG, \"discarding sps cropping, original \"\n\n                                           \"values are l:%d r:%d t:%d b:%d\\n\",\n\n                   crop_left, crop_right, crop_top, crop_bottom);\n\n\n\n            sps->crop_left   =\n\n            sps->crop_right  =\n\n            sps->crop_top    =\n\n            sps->crop_bottom = 0;\n\n        } else {\n\n            int vsub   = (sps->chroma_format_idc == 1) ? 1 : 0;\n\n            int hsub   = (sps->chroma_format_idc == 1 ||\n\n                          sps->chroma_format_idc == 2) ? 1 : 0;\n\n            int step_x = 1 << hsub;\n\n            int step_y = (2 - sps->frame_mbs_only_flag) << vsub;\n\n\n\n            if (crop_left & (0x1F >> (sps->bit_depth_luma > 8)) &&\n\n                !(avctx->flags & AV_CODEC_FLAG_UNALIGNED)) {\n\n                crop_left &= ~(0x1F >> (sps->bit_depth_luma > 8));\n\n                av_log(avctx, AV_LOG_WARNING,\n\n                       \"Reducing left cropping to %d \"\n\n                       \"chroma samples to preserve alignment.\\n\",\n\n                       crop_left);\n\n            }\n\n\n\n            if (INT_MAX / step_x             <= crop_left               ||\n\n                INT_MAX / step_x - crop_left <= crop_right              ||\n\n                16 * sps->mb_width <= step_x * (crop_left + crop_right) ||\n\n                INT_MAX / step_y             <= crop_top                ||\n\n                INT_MAX / step_y - crop_top  <= crop_bottom             ||\n\n                16 * sps->mb_height <= step_y * (crop_top + crop_bottom)) {\n\n                av_log(avctx, AV_LOG_WARNING, \"Invalid crop parameters\\n\");\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    goto fail;\n\n                crop_left = crop_right = crop_top = crop_bottom = 0;\n\n            }\n\n\n\n            sps->crop_left   = crop_left   * step_x;\n\n            sps->crop_right  = crop_right  * step_x;\n\n            sps->crop_top    = crop_top    * step_y;\n\n            sps->crop_bottom = crop_bottom * step_y;\n\n        }\n\n    } else {\n\n        sps->crop_left   =\n\n        sps->crop_right  =\n\n        sps->crop_top    =\n\n        sps->crop_bottom =\n\n        sps->crop        = 0;\n\n    }\n\n\n\n    sps->vui_parameters_present_flag = get_bits1(gb);\n\n    if (sps->vui_parameters_present_flag) {\n\n        int ret = decode_vui_parameters(gb, avctx, sps);\n\n        if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE)\n\n            goto fail;\n\n    }\n\n\n\n    /* if the maximum delay is not stored in the SPS, derive it based on the\n\n     * level */\n\n    if (!sps->bitstream_restriction_flag &&\n\n        (sps->ref_frame_count || avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT)) {\n\n        sps->num_reorder_frames = MAX_DELAYED_PIC_COUNT - 1;\n\n        for (i = 0; i < FF_ARRAY_ELEMS(level_max_dpb_mbs); i++) {\n\n            if (level_max_dpb_mbs[i][0] == sps->level_idc) {\n\n                sps->num_reorder_frames = FFMIN(level_max_dpb_mbs[i][1] / (sps->mb_width * sps->mb_height),\n\n                                                sps->num_reorder_frames);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!sps->sar.den)\n\n        sps->sar.den = 1;\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n\n        static const char csp[4][5] = { \"Gray\", \"420\", \"422\", \"444\" };\n\n        av_log(avctx, AV_LOG_DEBUG,\n\n               \"sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %\"PRId32\"/%\"PRId32\"\\n\",\n\n               sps_id, sps->profile_idc, sps->level_idc,\n\n               sps->poc_type,\n\n               sps->ref_frame_count,\n\n               sps->mb_width, sps->mb_height,\n\n               sps->frame_mbs_only_flag ? \"FRM\" : (sps->mb_aff ? \"MB-AFF\" : \"PIC-AFF\"),\n\n               sps->direct_8x8_inference_flag ? \"8B8\" : \"\",\n\n               sps->crop_left, sps->crop_right,\n\n               sps->crop_top, sps->crop_bottom,\n\n               sps->vui_parameters_present_flag ? \"VUI\" : \"\",\n\n               csp[sps->chroma_format_idc],\n\n               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,\n\n               sps->timing_info_present_flag ? sps->time_scale : 0);\n\n    }\n\n\n\n    /* check if this is a repeat of an already parsed SPS, then keep the\n\n     * original one.\n\n     * otherwise drop all PPSes that depend on it */\n\n    if (ps->sps_list[sps_id] &&\n\n        !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n\n        av_buffer_unref(&sps_buf);\n\n    } else {\n\n        remove_sps(ps, sps_id);\n\n        ps->sps_list[sps_id] = sps_buf;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&sps_buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 20352, "substitutes": {"gb": ["bc", "git", "sb", "lb", "gpu", "gt", "usb", "sl", "gram", "g", "gal", "gn", "mb", "db", "gnu", "boot", "bb", "vg", "gin", "bp", "bridge", "pc", "che", "gd", "ga", "eb", "phy", "bg", "storage", "hd", "agg", "tg", "gy", "kb", "gg", "wb", "gz", "ges", "cb", "cfg", "gp", "du", "b", "bo", "hub", "gc", "src", "bm", "gh", "cca", "game", "gs", "buff", "lib", "bf", "gam", "ko", "gom", "GB", "rb", "gm", "cgi", "ge", "tm", "abb", "rg"], "avctx": ["vercontext", "verconn", "verctx", "avconn", "AVcli", "avconfig", "AVcontext", "afctx", "avercontext", "avercas", "avcas", "verconfig", "averctx", "camconfig", "avalcas", "camconn", "avercli", "avcontext", "camctx", "camcontext", "avalctx", "avalcli", "afconfig", "afcontext", "AVctx", "afconn", "avalcontext", "avcli", "AVcas"], "ps": ["Ps", "ap", "pps", "aps", "pe", "ops", "ars", "ds", "ams", "cp", "pers", "pp", "p", "PS", "cs", "params", "bps", "pse", "pr", "mp", "ms", "ns", "sp", "pt", "ips", "ppa", "eps", "pa"], "sps_buf": ["sips_buf", "spps_buf", "sPS_fw", "spe_buf", "sps__buf", "sps_queue", "sps__fw", "sps__buffer", "sps_bag", "sips_buff", "sps___bag", "spe_buff", "sps__uf", "sps_opt", "spps_queue", "sps_cf", "sPS_buf", "sps_buff", "sPS_uf", "sps__buff", "sPS_bag", "sps_buffer", "sps___buf", "sps__bag", "spe_cf", "spps_opt", "sips_buffer", "sips_bag", "sps_uf", "sps___uf", "sps___fw", "sps_fw"], "profile_idc": ["profile_idp", "profile_Idn", "profile_numo", "profileOidn", "profile__idec", "profile_idscode", "profile_ipc", "profile_bitdc", "profile_idx", "profile_Idx", "profile_ipn", "profile_bitb", "profile_idso", "profile_numc", "profile_identb", "profile_idece", "profile_lengthcode", "profile__idce", "profileOnumcode", "profile_bitn", "profile_Idk", "profile_idk", "profile_lengthc", "profile_idcode", "profile__idece", "profileOiddc", "profile_Idc", "profileOidc", "profileOnumc", "profile__idc", "profileObitb", "profileObitc", "profileOnume", "profileOide", "profile_indp", "profile_dux", "profile_idn", "profile_bitc", "profileOidcode", "profileOnumo", "profile_idb", "profile_idce", "profile_indc", "profile__idep", "profileOido", "profile_numcode", "profile_nume", "profile_indx", "profileObitdc", "profile_idec", "profile_ipb", "profile_identdc", "profile_iddc", "profile_duk", "profile_lengtho", "profileObitn", "profile_dun", "profile__idx", "profile_duc", "profile__idex", "profile_idep", "profile_ipdc", "profile_idex", "profile_identn", "profileOidb", "profile_indce", "profile_ide", "profile_lengthe", "profile__idp", "profile_idse", "profile_ido", "profile_identc", "profile_idsc"], "level_idc": ["levelallindexcm", "level_lend", "level_typecs", "level_idsz", "level_Idc", "levelallindexce", "level_indexp", "level_uidxc", "levelalidc", "level_idce", "levelalidp", "levelvidy", "level_andc", "level_indexce", "level_idp", "level_andxc", "level_idsd", "level_indexc", "levelallidc", "level_andcm", "level_typed", "level_ipe", "level_ide2", "level_lencs", "level_intl", "levelallindexxc", "levelalide", "level_idw", "level_idscs", "level_Idy", "levelalindexp", "level_idcm", "level_indexe", "level_lenc", "level_IDl", "level_idl", "level_idep", "level_lenz", "level_idxc", "level_ipc", "levelallidxc", "level_indexxc", "levelvinty", "levelvintl", "level_uidc", "levelvidl", "levelvidc", "level_idsc", "level_intw", "level_idec", "level_andce", "levelvintw", "level_inty", "level_id2", "level_uidcm", "level_uidce", "level_idee", "level_IDw", "levelvidw", "level_IDc", "level_idd", "level_indexcm", "level_idcs", "level_IDy", "level_Idw", "levelallindexc", "level_idy", "level_intc", "level_ipp", "level_typec", "levelallidce", "level_typez", "levelalindexc", "level_idz", "levelalid2", "level_Idl", "levelalindexe", "levelallidcm", "level_index2", "level_ide", "level_ip2", "levelalindex2", "levelvintc"], "sps_id": ["sPS_ref", "sps_type", "sps2num", "spsappID", "spsappid", "sps_ref", "smsappmid", "sps_ids", "spsOid", "sps_set", "sPS_ids", "sms_name", "sps_num", "spsappdb", "sps2ref", "spspoids", "sPS_mid", "sms_id", "spspoid", "spsappversion", "sPS_type", "smsappid", "sPS_id", "sps_mid", "smsappnum", "sps_ID", "spsappmid", "sps_hash", "spsuserid", "sss_ID", "smsappname", "spsOids", "sps_name", "spsOset", "spsuserids", "spspohash", "sPS_hash", "spsappnum", "sPS_num", "spsusermid", "sss_db", "sms_num", "sps_version", "spps_id", "spsappname", "sms_mid", "sss_version", "sss_id", "spps_set", "sps_db", "spps_ids", "sps2id", "spspotype"], "i": ["e", "ui", "pi", "ed", "d", "I", "f", "ci", "r", "u", "j", "ip", "p", "o", "is", "c", "si", "a", "ii", "b", "n", "iu", "v", "h", "l", "k"], "log2_max_frame_num_minus4": ["log2_max_frame_num_plus4", "log2_max_frame_num_plus2", "log2_max_frame_num_plus1", "log2_max_frame_num_mod4", "log2_max_frame_num_mod1", "log2_max_frame_num_plus6", "log2_max_frame_num_minus1", "log2_max_frame_num_mod6", "log2_max_frame_num_minus2", "log2_max_frame_num_minus6", "log2_max_frame_num_mod2"], "sps": ["sple", "asPS", "yple", "sinops", "gPS", "asamps", " spe", " samps", "ansips", "aspa", " sple", "pops", "aspe", "gpps", "spr", "sips", "inps", "ineps", "esPS", "asls", "asps", " sls", "rps", "spe", "esips", "esamples", "nsPS", "cspr", "csps", "isPS", "isips", "pps", "wsples", "reps", " seps", "gsPS", "gsps", "Sops", "yops", "rips", "rPS", "sinamples", "sports", " spa", "peps", "wsps", "scheips", "asips", "asrs", "isops", "inPS", "inips", "gps", " spes", "isports", "aspos", "gsops", "nsops", " svs", "asvs", "isps", "isrs", "anspos", "ansps", "pPS", "Spps", "gamps", "wsips", "seps", "pple", " srs", "sbs", "tsps", "sinps", "aseps", " sops", "isamps", "yamples", " spps", "dPS", "sls", "wsbs", " spr", "Sps", " sPS", " sports", "tsbs", "samps", "pips", "samples", "spes", "sinple", "asops", "svs", "esps", "scheps", "spps", "gspps", "cspes", " sples", "ispa", "ispr", "SPS", "dpr", "esops", " sips", "srs", "ispe", "anseps", "isls", "sops", "sPS", "spa", "dips", "nseps", "isvs", "spos", "csPS", "yps", "esple", "scheeps", "asports", "tsips", "schepos", "sples", "tsples", "nsps", "eseps", "dps", " sbs"]}}
{"project": "qemu", "commit_id": "424ad8388f89f4202a7836d003273f23ebe04b09", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t oldval, newval;\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 20365, "substitutes": {"opaque": ["OPaque", "operaque", "ospacity", "oplcoe", "opcoe", "oplrice", " opac", "copaque", "copace", "oplaque", "opace", "OPrice", "ospcoe", "operque", "operace", "opacity", "OPacity", " opque", "opac", "oplacity", " opace", "opque", "copque", "osprice", "ospaque", "operac", "oprice", "copac", "OPcoe"], "addr": ["name", "asm", "ino", "ref", "config", "hop", "acl", "eth", "mode", "ord", "pad", "host", "align", "device", "xff", "cmp", "r", "cmd", "address", "socket", "ad", "data", "p", "ace", "slot", "mac", "code", "dr", "rc", "cb", "ctx", "frame", "ext", "ptr", "channel", "src", "fd", "len", "sid", "pointer", "offset", "x", "type"], "val": ["ival", "reg", "grad", "sel", "serv", "fail", "ref", "sl", "valid", "item", "ind", "arg", "db", "cond", "part", "trial", "ol", "bl", "local", "pal", "split", "sol", "exec", "al", "alloc", "pos", "fee", "data", "rel", "ret", "p", "arr", "vals", "unit", "slot", "count", "elt", "rot", "el", "index", "pl", "aval", "dim", "cal", "pid", "ann", "x", "vol", "fl", "len", "loc", "slice", "VAL", "update", "Val", "doc", "v", "alt", "eval", "all", "block", "lit", "base", "value"], "size": [" error", " bytes", "Size", "bytes", " len", " arg", "data", " slot", "unit", "buf", " data", "ctx", "mem", " n", " mem", " length", "length", "len", " num", "v", "SIZE", " res", "type"], "s": ["sb", "e", "sym", "qs", "es", "sie", "sl", "g", "ses", "fs", "d", "sets", "ops", "site", "l", "ds", "services", "f", "sys", "t", "u", "m", "socket", "state", "ssl", "os", "p", "ts", "us", "o", "ls", "sync", "is", "ss", "sg", "c", "js", "settings", "self", "si", "b", "service", "aws", "session", "n", "S", "ns", "sup", "sf", "side", "south", "rs", "gs", "ps", "conf", "h", "secondary", "server", "su", "sq", "states"], "oldval": ["newVAL", "lowval", "lowvalid", "lowVal", "oldVAL", "newVal", "origVal", "newvalid", "origval", "oldeval", "olderval", " oldeval", " oldvalid", "origvalue", " oldVal", "neweval", "oldvalid", "origeval", " oldvalue", "oldvalue", "oldVal", "lowvalue", "olderVAL", "newvalue", "olderVal", "oldervalue", " oldVAL"], "newval": ["currentvalue", "newpol", "currentVal", "currentfb", "Newval", "newVal", "longVal", "oldvals", "NEWvalue", "newvalid", "fvalue", "NEWeval", "Newvals", "longvalid", "newvals", "longval", " neweval", "rawval", "raweval", "nextvalue", "oldeval", "Neweval", " newvalue", "nextVal", " newVal", "NewVal", "freshval", "nextvalid", "Newpol", "currenteval", "nextvals", "neweval", " newvals", "fval", "currentvalid", "longvalue", "oldvalid", "fresheval", "Newvalue", "fvals", "NEWval", "currentval", "oldvalue", "NEWvalid", "newfb", " newfb", "nexteval", "oldVal", "nextpol", "newvalue", "nextval", "Newvalid", "rawvalue", "freshvalue", "freshfb", " newpol", "fVal", "longeval", "rawvalid"], "i": ["io", "udi", "uli", "e", "anti", "ix", "ie", "qi", "ri", "ui", "eni", "mini", "gi", "uri", "ti", "I", "l", "f", "ci", "y", "u", "adi", "m", "ini", "it", "j", "info", "phi", "ip", "p", "id", "o", "bi", "vi", "cli", "c", "index", "si", "a", "ii", "b", "x", "n", "child", "iu", "slice", "ai", "xi", "hi", "di", "v", "multi", "yi", "li", "pi", "fi", "zi", "isin", "ni"], "cpu": ["monitor", "lc", "platform", "bench", "computer", "hp", "net", "fc", "lb", "gpu", "linux", "config", "GPU", "nic", "eni", "consumer", "cm", "pit", "processor", "process", "pc", "CPU", "css", "device", "host", "intel", "ci", "cmp", "node", "proxy", "nc", "phy", "cp", "ram", "cache", "program", "lu", "p", "component", "currency", "machine", "uci", "np", "memory", "pse", "px", "c", "cn", "frame", "module", "roc", "gp", "comp", "dim", "uca", "uu", "core", "auc", "chip", "pai", "prem", "proc", "vm", " CPU", "clock", "ips", "pu", "ilo"], "cs": ["lc", "bc", "cc", "ces", "qs", "conn", "cing", "fs", "cons", "ks", "pc", "css", "ds", "cas", "CS", "ci", "sys", "ac", "cp", "codes", "cache", "cases", "cells", "vs", "cf", "ls", "sync", "ss", "rc", "c", "ctx", "cn", "sc", "cks", "ics", "core", "cers", "ns", "cus", "ps", "gs", "cms", "bs", "ips", "ec", "acs", "gb"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset,\n\n        uint64_t val, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (reg_n > 1) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n        hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                TARGET_FMT_plx \"offset\\n\", offset);\n\n    }\n\n    s->reg_set[offset >> 2] = val;\n\n\n\n    switch (reg_n) {\n\n    /* IIESR */\n\n    case 0:\n\n        /* FIXME: what if irq is pending, allowed by mask, and we allow it\n\n         * again. Interrupt will rise again! */\n\n\n\n        DPRINTF(\"%s enable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Enable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask |= val & 0xFF;\n\n        s->group[grp_quad_base_n + 1].src_mask |= (val & 0xFF00) >> 8;\n\n        s->group[grp_quad_base_n + 2].src_mask |= (val & 0xFF0000) >> 16;\n\n        s->group[grp_quad_base_n + 3].src_mask |= (val & 0xFF000000) >> 24;\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n        /* IIECR */\n\n    case 1:\n\n        DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Disable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask &= ~(val & 0xFF);\n\n        s->group[grp_quad_base_n + 1].src_mask &= ~((val & 0xFF00) >> 8);\n\n        s->group[grp_quad_base_n + 2].src_mask &= ~((val & 0xFF0000) >> 16);\n\n        s->group[grp_quad_base_n + 3].src_mask &= ~((val & 0xFF000000) >> 24);\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n    default:\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n", "idx": 20368, "substitutes": {"opaque": ["openaque", "OPaque", "opec", " opbuf", "Opbuf", "OPbuf", "opatile", "Opac", "openacity", " opac", "OPatile", "openec", " opatile", "Opacity", "openatile", "opacity", "OPec", "OPacity", "OPac", "opac", " opacity", "Opaque", " opec", "opbuf"], "offset": ["attribute", "next", "off", "part", "pos", "order", "alloc", "enabled", "address", "seed", "ip", "prefix", "url", "operation", "initial", "shift", "alias", "slice", "alpha", "pointer", "image", "delay", "bound", "phase", "end", "option", "origin", "null", "style", "align", "fee", "o", "filename", "et", "set", "online", "Offset", "iso", "reset", "alt", "position", "ref", "layer", "f", "p", "addr", "rot", "error", "length", "loc", "reference", "limit", "start", "layout", "disabled", "optional", "axis", "entry", "id", "slot", "timeout", "index", "location", "seq", "len", "skip", "parent", "range", "server", "base", "padding", "value"], "val": ["ival", "reg", "ut", "def", "sel", "Value", "serv", "ul", "ref", "sl", "valid", "il", "ol", "bl", "local", "pal", "sol", "al", "bit", "data", "stat", "ret", "arr", "vals", "slot", "addr", "elt", "rot", "pr", "el", "pl", "aval", "cal", "x", "seq", "vol", "fl", "oval", "len", "loc", "pol", "VAL", "Val", "util", "v", "alt", "eval", "pt", "all", "lit", "base", "value"], "size": ["e", "g", "Size", "bytes", "ize", "f", "fee", "data", "count", "mem", " mem", "length", " length", " sizes", "len", "v", "sec", "SIZE", "value"], "s": ["status", "sv", "sb", "i", "e", "sym", "es", "sl", "fs", "g", "ses", "private", "d", "sets", "site", "l", "ds", "services", "f", "sys", "t", "r", "u", "m", "socket", "info", "ssl", "os", "p", "ts", "us", "cs", "ls", "o", "sync", "is", "stats", "ss", "sg", "c", "js", "self", "spec", "settings", "si", "a", "b", "w", "service", "aws", "se", "session", "S", "ns", "n", "details", "sf", "ps", "rs", "gs", "south", "conf", "sid", "secondary", "server", "su", "sq", "states"], "req_quad_base_n": ["req_quad_bas_p", "req_quad_base_num", "req_quad_base_k", "req_quad_bas_c", "req_quad_base2l", "req_quad_base_N", "req_quad_bas_l", "req_quad_bas_t", "req_quad_base2p", "req_quad_base2n", "req_quad_base_l", "req_quad_bas_n", "req_quad_base_c", "req_quad_bas_N", "req_quad_base_p", "req_quad_base2N", "req_quad_base_t"], "grp_quad_base_n": ["grp_quad_base_m", "grp_quad_base__n", "grp_quad_base_4", "grp_quad_type_N", "grp_quad_base_p", "grp_quad_base_en", "grp_quad_part_en", "grp_quad_base00sn", "grp_quad_part_p", "grp_quad_base_nb", "grp_quad_type_n", "grp_quad_base_part", "grp_quad_base_num", "grp_quad_Base_N", "grp_quad_base2n", "grp_quad_baseqn", "grp_quad_part_nn", "grp_quad_baseqen", "grp_quad_base00p", "grp_quad_base00n", "grp_quad_base23nn", "grp_quad_base_name", "grp_quad_base23n", "grp_quad_base2p", "grp_quad_part_c", "grp_quad_base2m", "grp_quad_base23c", "grp_quad_base_nn", "grp_quad_base67c", "grp_quad_type_4", "grp_quad_base23en", "grp_quad_part_num", "grp_quad_base_dn", "grp_quad_base__p", "grp_quad_part_n", "grp_quad_base001", "grp_quad_Base_n", "grp_quad_base67nn", "grp_quad_base_t", "grp_quad_baseqN", "grp_quad_base67en", "grp_quad_base_sn", "grp_quad_part_N", "grp_quad_base_N", "grp_quad_part_part", "grp_quad_base_1", "grp_quad_base67n", "grp_quad_type_nb", "grp_quad_base_d", "grp_quad_baseqp", "grp_quad_base_c", "grp_quad_Base_c", "grp_quad_base67init", "grp_quad_base67dn", "grp_quad_base__m", "grp_quad_base_init", "grp_quad_base2name"], "reg_n": ["register_number", "reg_sn", "reg_size", "reg___k", "reg_t", "rec_1", "reg___o", "register_n", "Reg_nr", "reg_1", "reg_num", "reg_ns", "reg1d", "reg_k", "reg_fn", "res_n", "res_size", "register_fn", "res_d", "rec_n", "Reg_o", "reg_nr", "reg_number", "reg_d", "register_ns", "rec_num", "reg1sn", "rec_t", "reg___n", "Reg_n", "reg_o", "reg1n", "Reg_k", "reg1size", "reg___nr", "res_sn"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_submit_acl(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t handle;\n\n    int datalen, flags;\n\n    struct bt_link_s *link;\n\n\n\n    if (length < HCI_ACL_HDR_SIZE) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        return;\n\n    }\n\n\n\n    handle = acl_handle((data[1] << 8) | data[0]);\n\n    flags = acl_flags((data[1] << 8) | data[0]);\n\n    datalen = (data[3] << 8) | data[2];\n\n    data += HCI_ACL_HDR_SIZE;\n\n    length -= HCI_ACL_HDR_SIZE;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid ACL handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        /* TODO: signal an error */\n\n        return;\n\n    }\n\n    handle &= ~HCI_HANDLE_OFFSET;\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    link = hci->lm.handle[handle].link;\n\n\n\n    if ((flags & ~3) == ACL_ACTIVE_BCAST) {\n\n        if (!hci->asb_handle)\n\n            hci->asb_handle = handle;\n\n        else if (handle != hci->asb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    if ((flags & ~3) == ACL_PICO_BCAST) {\n\n        if (!hci->psb_handle)\n\n            hci->psb_handle = handle;\n\n        else if (handle != hci->psb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS */\n\n    bt_hci_event_num_comp_pkts(hci, handle | HCI_HANDLE_OFFSET, 1);\n\n\n\n    /* Do this last as it can trigger further events even in this HCI */\n\n    hci->lm.handle[handle].lmp_acl_data(link, data,\n\n                    (flags & 3) == ACL_START, length);\n\n}\n", "idx": 20370, "substitutes": {"info": ["fa", "io", "ami", "i", "about", "start", "def", "Info", "bis", "linux", "config", "INFO", "afi", "handler", "home", "f", "raf", "init", "state", "bug", "inf", "id", "thin", "index", "source", "family", "error", "base", "iso", "http", "conf", "from", "image", "api", "fo", "type"], "data": ["i", "next", "fail", "message", "key", "extra", "pad", "buffer", "address", "last", "ip", "url", "field", "load", "shift", "window", "raw", "draw", "slice", "batch", "di", "image", "type", "delay", "name", "response", "end", "object", "valid", "text", "d", "style", "da", "code", "body", "complete", "pass", "a", "media", "database", "options", "multi", "li", "tail", "offset", "ui", "result", "xxx", "sha", "bytes", "one", "size", "zip", "p", "number", "open", "memory", "error", "dat", "resource", "api", "limit", "start", "input", "Data", "results", "entry", "args", "cache", "version", "id", "content", "index", "missing", "in", "DATA", "len", "update", "parent", "array", "block", "base", "padding", "value"], "length": ["delay", "shape", "limit", "end", "level", "Length", "text", "result", "part", "xxx", "loop", "message", "style", "duration", "build", "l", "type", "offset", "buffer", "split", "path", "padding", "section", "address", "size", "sequence", "zip", "head", "full", "lock", "number", "body", "load", "filename", "match", "capacity", "value", "line", "se", "library", "ength", "len", "child", "slice", "total", "th", "angle", "loc", "block", "position", "tail", "ph", "url", "count"], "hci": ["hlini", "htcci", " hini", "hlcci", "ehci", "rhco", "hlcu", "lcit", " hce", "affci", "hco", "fki", "hdi", "ahci", "pdi", "fci", "ehdi", " hct", "fani", "Hcci", "hlcin", " hcci", "hlct", "hcit", "hsi", "rhcu", "rhct", "rhini", " hai", "hcu", "hii", "ihci", "rhii", "ihcit", "hancu", "ahcin", "hlcit", "hanci", "hini", "Hcu", "hct", "shii", "pii", " hco", "hsii", "shce", "shani", "hlci", "lci", "shci", "ehsi", "hlco", "htci", " hii", "Hcin", " hc", "affcin", " hsi", "ihii", "hlii", "ahcu", "hcci", "hsdi", "hani", "htcin", " hcu", " hdi", " hki", "hance", "rhki", "ahcci", " hcin", "shki", "affuci", "shcin", "hscu", "hlai", "huci", "hsci", "Hco", " hcit", "lsi", "Hai", " hani", "hce", "pci", "hlc", "hai", "hki", "ehcit", "fii", "ahuci", "affcci", "rhci", "Hci", "hlki", "hc", "pcu", "shcu", "htcu", "ihc", "ahii", "hluci", "rhcci", "hcin", "ldi", "hancin"], "handle": [" carry", "target", "area", "fail", "bind", "download", "hold", "post", "force", "key", "connection", "process", "hip", "device", "path", "address", "use", "url", "load", "header", "future", "mem", "draw", "line", "alias", "old", "type", "route", "delay", "name", "support", "end", "object", "conn", "ind", "scale", "mount", "handler", "style", "align", "write", "term", "lock", "component", "code", "body", "detail", "ink", "add", "pass", "hash", "carry", "child", "li", "tail", "offset", "store", "hand", "wrapper", "thread", "result", "mode", "host", "size", "addr", "open", "memory", "module", "edge", "service", "error", "show", "side", "ignore", " Handle", "group", "folder", "note", "h", "status", "port", "handled", "start", "send", "anch", "build", "bridge", "follow", "transfer", "socket", "id", "help", "label", "sync", "close", "index", "hide", "match", "pull", "session", "len", "Handle", "append", "update", "range", "base", "share"], "datalen": ["dstalency", "Datalan", " datalens", "Davalue", "dotalener", "Datalen", " datalened", "datalue", " datalength", "Datalener", " dalistened", "dalency", "dallon", "Davalen", "daldens", "dotalen", "Davalength", "datalener", " datalener", "datalens", "dmalength", "dalens", "dstalon", " dalisten", "daldened", " dalistength", "davalue", "dstalener", " datalon", "dalistens", "dotalon", " dstalener", "Datalue", " dalistens", "dallener", "datalength", " dstalency", "davalan", "dmalon", "datalan", "Davalan", "dstalen", "dalength", "dallength", "davalength", "dalisten", "dallue", "dachelue", "dalen", "dalden", "datalened", "dalener", "dalistength", "dalon", "Datalon", "Dalen", "Datalength", "Dalon", "dallan", " dstalen", "dallen", "daldength", " datalency", "Dalength", " dstalon", "datalon", "dmalen", "datalency", "dmalener", "dachelen", "dalened", "dachelan", "dotalency", "davalen", "dachelength", "dalistened", "Dalener"], "flags": ["status", "delay", "ips", "types", "kind", "ags", "fixes", "fs", "features", "allows", "lines", "rules", "style", "plugins", "dates", "tails", "ds", "heads", "f", "properties", "posts", "planes", "args", "members", "ils", "strings", "vals", "count", "ports", "stats", "ants", "settings", "Flags", "groups", "lag", "opens", "reads", "styles", "bits", "flag", "FLAG", "atts", "les", "fd", "details", "mask", "len", "fields", "requires", "utils", "options", "skip", "alls", "checks", "links", "relations", "mods", "files", "tail", "states", "type"], "link": ["route", "delay", "name", "light", "ref", "download", "ind", "uri", "style", "handler", "hip", "l", "follow", "local", "path", "write", "address", "bug", "rel", "stat", "head", "lock", "ip", "id", "label", "field", "load", "comment", "ink", "Link", "hide", "index", "source", "sh", "match", "linked", "line", "location", "reply", "read", "error", "session", "call", "child", "loc", "len", "skip", "di", "parent", "lib", "li", "links", "image", "offset", "base", "url", "type"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_flush(&s->client);\n\n}\n", "idx": 20398, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "bis", "es", "ba", "fs", "ses", "fb", "bb", "ks", "bid", "bl", "ds", "as", "fps", "state", "os", "vs", "cs", "ls", "b", "bits", "blocks", "ms", "ns", "BS", "iss", "Bs", "ps", "gs", "bh", "rb", "ss", "gb"], "s": ["sv", "sb", "e", "sl", "fs", "ses", "ks", "ds", "services", "m", "its", "state", "ssl", "os", "p", "cs", "vs", "ls", "o", "is", "stats", "sa", "c", "js", "sq", "si", "a", "b", "n", "S", "ns", "iss", "ps", "ins", "ss", "states"]}}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 20410, "substitutes": {"qiov": ["quiov", "quir", "qqliv", "hilo", "Qrolet", " qrolet", " qwav", "Qiov", " qio", "qurolet", " qrons", "qrolet", "qqiov", "qir", "kiov", "hiov", " qilo", "qliv", "kwav", "qrons", "kio", " qliv", "kilo", "Qilo", "hrons", "qilo", "qqrons", " qir", "hliv", "qqilo", "quilo", "quwav", "quio", "qio", "Qir", "qwav"], "i": ["io", "e", "start", "ix", "fi", "qi", "ri", "ui", "pi", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "t", "u", "oi", "ini", "m", "it", "j", "info", "phi", "ip", "p", "o", "bi", "c", "mu", "index", "si", "a", "ii", "b", "ji", "iu", "slice", "ai", "xi", "di", "v", "z", "multi", "li", "yi", "h", "ie", "x", "zi", "k", "count"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20422, "substitutes": {"avctx": ["abcmp", "aveca", "ajbc", "apcmp", "apctx", "AVcmp", "afca", "apcontext", "avcit", "ajcontext", "avsc", "afcmp", " avcit", "afclient", "aucontext", "afctx", "AVcontext", "avecmp", " avsc", "AVca", "avcas", " avbc", "avca", "afcas", "AVclient", "avecontext", "afcu", "avbc", "ajcas", "avcontext", "avcu", "abctx", "afbc", "afsc", "avclient", " avcas", "abcu", "avecit", "avectx", "afcit", "avcmp", "abcontext", "afcontext", "AVctx", "ajctx", "auctx", " avcontext", "apcu", "auclient", "aucmp", "avesc"], "data": ["uf", "start", "def", "response", "obj", "config", "result", "input", "val", "progress", "message", "Data", "meta", "queue", "func", "bytes", "f", "buffer", "ata", "info", "address", "size", "cache", "code", "body", "load", "record", "memory", "la", "frame", "source", "DATA", "read", "media", "reader", "slice", "flow", "len", "length", "feed", "batch", "buff", "parent", "dat", "vec", "li", "image", "block", "base", "video"], "data_size": ["data\u00b7scale", "data\u00b7size", "data_scale", "data_small", "data_fee", "batch_source", "batch_size", "batch_time", " data_scale", "data_source", "data\u00b7fee", "data_time", " data_fee", "batch_small"], "avpkt": ["avPct", "avlpkt", "avpeft", "abpconn", "abfacket", "abpkn", "avvpkn", "avppka", "afPacket", "avlpacket", "avfpft", "afpka", "avfpctx", "avppkt", " avpecht", "abfkn", " avpcht", "avfka", "avpka", "avpconn", "avlpconn", "abpacket", "avPacket", "avfkt", " avpectx", "afPct", "avlpcht", "avpcht", " avpeft", "avpecht", "abpkt", "avlpft", "abfkt", " avpft", "avpekt", "avfct", " avpekt", "avpft", "afPka", "avfacket", "avpct", "avlpctx", "avfconn", "avpectx", "afpct", "avppacket", "avfkn", "avvpkt", "avppct", "afpkt", "avlpkn", "afPkt", "avvpacket", "avfpcht", "avpkn", "avvpconn", "avpctx", " avpctx", "avPka", "avpacket", "avPkt", "avfpkt", "abfconn", "afpacket"], "buf": ["bc", "pb", "uf", "uc", "ref", "config", "val", "fb", "queue", "bb", "pad", "img", "cas", "f", "buffer", "alloc", "cache", "cf", "wb", "pool", "la", "cb", "rc", "b", "fd", "flow", "br", "batch", "buff", "proc", "array", "vec", "bag", "rb", "block", "base", "feat", "cap"], "seq": ["lc", "bc", "cc", "sel", "uc", "sci", "jp", "config", "ref", "coll", "val", "xxx", "pkg", "cv", "lex", "clus", "queue", "wave", "cl", "sequ", "cas", "cmp", "exec", "acc", "cmd", "sequence", "cache", "zip", "job", "ctrl", "que", "context", "q", "code", "cli", "la", "pse", "ctx", "frame", "aux", "comp", "sub", "rev", "qa", "slice", "iq", "req", "iter", "feed", "sem", "buff", "select", "ec", "sec", "vec", "fam", "fi", "feat", "sq"]}}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static ssize_t imx_fec_receive(NetClientState *nc, const uint8_t *buf,\n\n                               size_t len)\n\n{\n\n    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));\n\n    IMXFECBufDesc bd;\n\n    uint32_t flags = 0;\n\n    uint32_t addr;\n\n    uint32_t crc;\n\n    uint32_t buf_addr;\n\n    uint8_t *crc_ptr;\n\n    unsigned int buf_len;\n\n    size_t size = len;\n\n\n\n    FEC_PRINTF(\"len %d\\n\", (int)size);\n\n\n\n    if (!s->regs[ENET_RDAR]) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Unexpected packet\\n\",\n\n                      TYPE_IMX_FEC, __func__);\n\n        return 0;\n\n    }\n\n\n\n    /* 4 bytes for the CRC.  */\n\n    size += 4;\n\n    crc = cpu_to_be32(crc32(~0, buf, size));\n\n    crc_ptr = (uint8_t *) &crc;\n\n\n\n    /* Huge frames are truncated.  */\n\n    if (size > ENET_MAX_FRAME_SIZE) {\n\n        size = ENET_MAX_FRAME_SIZE;\n\n        flags |= ENET_BD_TR | ENET_BD_LG;\n\n    }\n\n\n\n    /* Frames larger than the user limit just set error flags.  */\n\n    if (size > (s->regs[ENET_RCR] >> 16)) {\n\n        flags |= ENET_BD_LG;\n\n    }\n\n\n\n    addr = s->rx_descriptor;\n\n    while (size > 0) {\n\n        imx_fec_read_bd(&bd, addr);\n\n        if ((bd.flags & ENET_BD_E) == 0) {\n\n            /* No descriptors available.  Bail out.  */\n\n            /*\n\n             * FIXME: This is wrong. We should probably either\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n        } else {\n\n            s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n        }\n\n        imx_fec_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n", "idx": 20425, "substitutes": {"nc": ["lc", "bc", "fc", "cc", "org", "uc", "irc", "conn", "ct", "nic", "nn", "kt", "pc", "anc", "ci", "nec", "nd", "mc", "cs", "rc", "c", "ctx", "rn", "cn", "roc", "sc", "nw", "dc", "gc", "n", "NC", "ns", "cdn", "cms", "ne", "nt", "ec", "nm"], "buf": ["bc", "pb", "port", "uf", "prop", "uc", "config", "db", "cv", "fb", "queue", "bb", "bl", "cas", "buffer", "alloc", "cmd", "box", "data", "cf", "wb", "rc", "cb", "ctx", "mem", "b", "raw", "seq", "ff", "src", "fd", "br", "cap", "buff", "bf", "doc", "vec", "rb", "fi", "gb"], "len": ["lc", "str", "limit", "en", "conn", "val", "ln", "bin", "l", "bl", "pos", "lan", "size", "data", "args", "full", "enc", "gen", "el", "lim", "num", "low", "line", "seq", "fl", "n", "length", "loc", "lib", "alt", "z", "SIZE", "lf", "all", "block", "offset", "Len", "count"], "s": ["status", "sb", "e", "sym", "qs", "serv", "es", "sl", "hs", "g", "ses", "uns", "fs", "d", "site", "services", "f", "sys", "t", "r", "m", "state", "stat", "ssl", "p", "cs", "ts", "ls", "o", "sync", "is", "ss", "sa", "sg", "c", "js", "self", "spec", "si", "sc", "sts", "b", "service", "n", "S", "ns", "session", "sf", "iss", "rss", "ps", "rs", "gs", "south", "conf", "sec", "secondary", "sq", "states"], "bd": ["md", "td", "bc", "pb", "sb", "cd", "ba", "board", "db", "fb", "d", "vd", "bb", " b", "pd", "ds", "ld", "bl", "sth", "gd", "da", "dd", "data", "hd", "nd", "ad", "bt", "bg", "obb", "bn", "kb", "wb", "od", "cb", "sd", "ib", "dt", "b", "dc", " kb", "fd", "bm", "nb", "bf", "bs", "rb", "BD", "nm", "gb"], "addr": ["md", "route", "area", "conn", "adr", "config", "amp", "acl", "db", "origin", "ack", "ord", "func", "bb", "amd", "align", "host", "node", "layer", "cmp", "pos", "nl", "gb", "alloc", "coord", "address", "cmd", "da", "data", "ad", "size", "dd", "ac", "ip", "ace", "url", "code", "np", "rc", "ext", "cb", "dr", "el", "index", "dist", "ann", "rt", " address", "ptr", "seq", "fd", "src", "er", "loc", "offset", "attr", "nm", "cap", "rg"], "crc": ["Crs", "crs", "circ", "Crc", " cpc", "csc", "cbc", "fbc", "firc", "Cpc", " circ", "lcloc", "frc", " cbc", "cloc", " csc", "Csc", "frs", "lcfc", "lcrc", "fpc", " cfc", "Cloc", "cpc", "lcrs", "lcbc", "ffc", " cloc", "lcsc", "cfc", "Circ", " crs", "lcpc"], "buf_addr": ["buf_data", "cb_length", "buf2addr", "buf4length", " buf_pos", " buf_data", "buf4addr", "buf_pointer", "buf4pointer", "buf2len", "buf2pos", "uf_len", "cb_pointer", "uf_dr", "buf_dr", "buf4ptr", "buf2data", "cb_addr", "buf_pos", "uf_pos", "buf_length", "uf_addr", "buf_ptr", "cb_ptr"], "crc_ptr": ["crc_offset", "crc2offset", "cRC_str", "cpc2len", "cpc2ctr", "cpc_ctr", "cpc_len", "cpc_ptr", "crc2str", "cpc2ptr", "crc2ptr", "crc2len", "crc_addr", "cRC_offset", "cpc2addr", "crc2addr", "crc2ctr", "cRC_addr", "crc_ctr", "cpc_addr", "crc_str", "cRC_ptr", "crc_len"], "buf_len": ["bufGcount", "buf_line", "block_pos", "buf_size", "buffspos", "buffer_val", "buf_lf", "bufJlin", "blockslen", "bufGsize", "buf_length", "bufJlen", "buffer_length", "bufsln", "buffer_block", "uf_line", "bufslen", "uf_limit", "bufnlf", "tmp_val", "buff_ln", "buf2len", "uf_len", "bufscount", "buffer_lf", "block_count", "bufssize", "bufJlf", "bufPlen", "buffer_Len", "bufnlen", "buf2count", "buf_ln", "uf_val", "buf_limit", "bufsLen", "blockscount", "bufJval", "bufspos", "bufslength", "tmpJval", "buf_val", "buf2pos", "block_len", "blockssize", "bufPgen", "buf_count", "bufnval", "bufPval", "buffer_len", "bufGlen", "bufJblock", "buffsln", "buf_lin", "block_size", "buff_pos", "bufsval", "tmp_lin", "tmpJgen", "buffslen", "bufnblock", "bufJgen", "buf_Len", "buf2size", "buf_pos", "buf_gen", "buff_len", "tmp_len", "tmpJlen", "bufPlin", "bufGpos", "buf_block", "tmpJlin", "blockspos", "tmp_gen"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n", "idx": 20433, "substitutes": {"env": ["app", "config", "event", "eni", "eve", "exc", "que", "context", "qa", "erg", "global", "v", "conf", "ev", "output", "org", "conn", "jp", "db", "cv", "oa", "eng", "site", "ah", "dev", "enc", "code", "ng", "ext", "network", "erv", "scope", "net", "e", "forge", "eu", "ea", "enos", "exec", "her", "act", "Environment", "advert", "enable", "dt", "nw", "gui", "loader", "core", "er", "req", "stage", "manager", "ne", "ec", "en", "obj", "plugin", "export", "engine", "esi", "nc", "entry", "cache", "vs", "ep", "np", "ctx", "viron", "console", "vm", "vp", "server", "environment", "here"], "bp": ["lc", "bc", "pb", "hp", "sb", "lb", "ap", "conn", "jp", "lp", "adj", "esp", "fb", "bb", "pd", "pc", "fp", "pg", "gb", "po", "eb", "BIP", "cp", "bg", "tp", "pp", "p", "kb", "np", "bps", "cb", "wp", "gp", "cpu", "b", "xp", "cpp", "BP", "bm", "br", "bf", "vm", "sp", "vp", "rb", "bsp", "pa"]}}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "substitutes": {"widget": ["view", "ui", "input", "plugin", "ou", "poll", "pipe", "win", "ac", "owl", "cli", "q", "client", "wp", "ch", "gui", "window", "w", "draw", "fl", "fw", "ogg", "console", "wx", "util", "lib", "Widget"], "button": ["delete", "bc", "target", "attribute", "class", "next", "off", "event", "config", "key", "connection", "cell", "click", "bug", "data", "field", "shift", "submit", "trigger", "select", "type", "password", "object", "option", "text", "style", "lock", "component", "current", "code", "atom", "title", "channel", "element", "action", "ui", "fb", "patch", "p", "or", "number", "comment", "open", "module", "gui", "error", "page", "callback", "html", "bot", "api", "command", "span", "icon", "focus", "press", "category", "loop", "input", "color", "feature", "plugin", "down", "Button", "label", "ctrl", "timeout", "pin", "document", "pull", "flag", "touch", "editor", "skip", "att", "toggle", "url"], "opaque": ["OPaque", "opaques", "OPchid", "OPaques", "oppac", "Opaqu", " opchid", "oppaque", "opaqu", "obaques", "opchid", "Opacity", "obaque", "opacity", "OPacity", "OPac", "opac", " opacity", " opaqu", "obac", "Opaque", "Opchid", "OPaqu", "oppaques"], "vc": ["lc", "bc", "serv", "conn", "nv", "vt", "vim", "input", "cv", "bb", "vg", "pc", "ci", "win", "sys", "nc", "ac", "cs", "wl", "cf", "ctrl", "tc", "iw", "cli", "rc", "c", "ctx", "wp", "ch", "gui", "dc", "ic", "service", "gc", "vv", "fw", "ogg", "VC", "wx", "util", "qt", "vp", "hw", "voc", "oc", "cu", "gb"], "s": ["status", "sv", "i", "sb", "e", "space", "es", "qs", "sie", "sl", "fs", "g", "ses", "xs", "d", "sis", "site", "services", "f", "sys", "less", "m", "args", "storage", "state", "ssl", "os", "p", "cs", "screen", "o", "sync", "is", "stats", "sg", "c", "settings", "js", "spec", "self", "si", "b", "w", "session", "S", "ns", "sf", "south", "h", "secondary", "server", "scope", "ss", "states"], "btn": ["lc", "bc", "sb", "fc", "txt", "focus", "bolt", "jp", "config", "ct", "mot", "nn", "yout", "input", "butt", "kt", "fb", "bb", "token", "ou", "bp", "fp", "Button", "click", "t", "nc", "cmd", "bg", "affle", "bug", "bt", "tick", "ctrl", "wb", "cli", "kn", "c", "cb", "kk", "tag", "wp", "cn", "dt", "colour", "b", "dc", "rl", "wt", "gui", "touch", "lvl", "fl", "qa", "src", "tn", "callback", "batch", "wx", "ko", "bot", "qt", "typ", "toggle", "ctl"]}}
{"project": "FFmpeg", "commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "target": 1, "func": "static void * attribute_align_arg worker(void *v){\n\n    AVCodecContext *avctx = v;\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    AVPacket *pkt = NULL;\n\n\n\n    while(!c->exit){\n\n        int got_packet, ret;\n\n        AVFrame *frame;\n\n        Task task;\n\n\n\n        if(!pkt) pkt= av_mallocz(sizeof(*pkt));\n\n        if(!pkt) continue;\n\n        av_init_packet(pkt);\n\n\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {\n\n            if(c->exit){\n\n                pthread_mutex_unlock(&c->task_fifo_mutex);\n\n                goto end;\n\n            }\n\n            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);\n\n        }\n\n        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n        frame = task.indata;\n\n\n\n        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);\n\n        pthread_mutex_lock(&c->buffer_mutex);\n\n        av_frame_unref(frame);\n\n        pthread_mutex_unlock(&c->buffer_mutex);\n\n        av_frame_free(&frame);\n\n        if(got_packet) {\n\n            int ret2 = av_dup_packet(pkt);\n\n            if (ret >= 0 && ret2 < 0)\n\n                ret = ret2;\n\n        } else {\n\n            pkt->data = NULL;\n\n            pkt->size = 0;\n\n        }\n\n        pthread_mutex_lock(&c->finished_task_mutex);\n\n        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;\n\n        c->finished_tasks[task.index].return_code = ret;\n\n        pthread_cond_signal(&c->finished_task_cond);\n\n        pthread_mutex_unlock(&c->finished_task_mutex);\n\n    }\n\nend:\n\n    av_free(pkt);\n\n    pthread_mutex_lock(&c->buffer_mutex);\n\n    avcodec_close(avctx);\n\n    pthread_mutex_unlock(&c->buffer_mutex);\n\n    av_freep(&avctx);\n\n    return NULL;\n\n}\n", "idx": 20457, "substitutes": {"v": ["conv", "sv", "nv", "vt", "V", "lv", "g", "vim", "cv", "vd", "f", "t", "u", "r", "m", "p", "vs", "uv", "b", "vol", "n", "vv", "va", "ve", "VC", "util", "vm", "vp", "h", "l", "k", "vc"], "avctx": ["avecu", "afci", "awcontext", "avconn", "afctx", "AVcontext", "awcu", "avecli", " avcli", "AVci", "avecontext", "avlc", "afcli", "afcu", "awctx", "avelc", "avcontext", "avcu", "AVconn", "awlc", "avci", " avconn", "avectx", "afcontext", "aveci", "AVctx", "afconn", "avcli", " avcontext", "aveconn", "aflc"], "c": ["lc", "bc", "fc", "arc", "cd", "e", "cc", "uc", "conn", "ct", "g", "chain", "coll", "cv", "unc", "cm", "d", "con", "rec", "ca", "pc", "l", "cl", "cu", "f", "anc", "ci", "can", "t", "nc", "u", "cp", "ac", "m", "r", "cache", "s", "p", "mc", "cs", "xc", "ctrl", "tc", "cf", "abc", "rc", "ctx", "cn", "icc", "ch", "sc", "b", "dc", "ic", "cy", "core", "cr", "n", "call", "cur", "C", "co", "ce", "conf", "h", "oc", "ec", "k", "vc"], "pkt": ["Packet", " pkg", "peth", "Pct", "tpdt", "tct", "wkt", "telt", "jpkt", "wpet", "fet", "pdt", "Pnt", "spkt", "tcht", "fnt", "fkt", "pakt", "wet", "paelt", "Pcht", "feth", " pct", "tpkt", "Pkid", "backet", "pkg", "padt", " pdt", "pact", "tft", " pett", "pnt", "Pqt", "mkt", "peqt", "mdt", "pft", " peth", "pkid", "wpacket", "Peth", "bcht", "pekt", "felt", "peett", "paet", "pet", "pett", "spelt", "bqt", "bet", " pcht", "mkg", "Pdt", "bkt", " pqt", " pnt", "tacket", " pet", " pkid", "tet", "jpacket", "pqt", "Pelt", "tpelt", "spacket", "pcht", "tkid", "wcht", "wpkt", "tqt", "bnt", "Pet", "tkt", "jpct", "bkg", "tett", "macket", "pelt", "tpct", " pelt", "jpet", "wpcht", "welt", "spet", "Pkg", "melt", "Pkt", "packet", "mnt", "pacht", "belt", " packet", " pft", "pct", "facket", "peft"], "got_packet": ["got_packageete", "got_packsET", "got_compete", "got_packete", "got_compet", "got_packeline", "got_packageel", "got_compacket", "got_packageets", "got_packsel", "got_packel", "got_capet", "got_packset", "got_packET", "got_fixacket", "got_packageet", "got_codeline", "got_packageET", "got_packageacket", "got_packsacket", "got_packeter", "got_packacket", "got_packageeter", "got_fixeter", "got_packsets", "got_packageeline", "got_capET", "got_capacket", "got_fixete", "got_codacket", "got_packseline", "got_packets", "got_fixet", "got_competer", "got_capets", "got_codel", "got_codet"], "ret": ["status", "reg", "ut", "def", "en", "obj", "ref", "gt", "valid", "result", "val", "arg", "ft", "det", "db", "Ret", "mt", "bit", "res", "cat", "fin", "opt", "code", "fun", "success", "rot", "ext", "rc", "num", "match", "let", "RET", "rt", "sr", "flag", "reply", "rev", "re", "desc", "len", "lt", "bf", "alt", "nt", "sec", "rb", "lit", "att", "feat", "url", "rets"], "frame": ["camera", "plane", "view", "target", "e", "iframe", "object", "thread", "nn", "fab", "part", "kt", "flake", "framework", "fb", "za", "feature", "style", "f", "layer", "fake", "wk", " Frame", "data", "j", "bug", "figure", "component", "setup", "point", "code", "body", "el", "module", "fe", "frames", "hole", "fr", "b", "rame", "face", "worker", "channel", "session", "slice", "flow", "element", "game", "html", "Frame", "fram", "qt", "jo", "image", "position", "fi", "feat", "ze", "video"], "task": ["remote", "course", "name", "target", "class", "table", "shape", "object", "obj", "event", "thread", "item", "config", "result", "project", "week", "container", "message", "ack", "time", "func", "piece", "tx", "process", "ork", "node", "device", "layer", "exec", "t", "j", "patch", "component", "job", "unit", "ace", "work", "tc", "word", "load", "sync", "code", "kk", "tag", "ask", "complete", "module", "tf", "service", "worker", "channel", "session", "call", "slice", "test", "game", "co", "proc", "instance", "ck", "pack", "image", "block", "feat", "Task", "type"]}}
{"project": "qemu", "commit_id": "86865c5ff16bd1a2ef2b9ce217a7bb8f39e2126c", "target": 1, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n    /* This code tries to make movcal emulation sufficiently\n\n       accurate for Linux purposes.  This instruction writes\n\n       memory, and prior to that, always allocates a cache line.\n\n       It is used in two contexts:\n\n       - in memcpy, where data is copied in blocks, the first write\n\n       of to a block uses movca.l for performance.\n\n       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used\n\n       to flush the cache. Here, the data written by movcal.l is never\n\n       written to memory, and the data written is just bogus.\n\n\n\n       To simulate this, we simulate movcal.l, we store the value to memory,\n\n       but we also remember the previous content. If we see ocbi, we check\n\n       if movcal.l for that address was done previously. If so, the write should\n\n       not have hit the memory, so we restore the previous content.\n\n       When we see an instruction that is neither movca.l\n\n       nor ocbi, the previous content is discarded.\n\n\n\n       To optimize, we only try to flush stores when we're at the start of\n\n       TB, or if we already saw movca.l in this TB and did not flush stores\n\n       yet.  */\n\n    if (ctx->has_movcal)\n\n\t{\n\n\t  int opcode = ctx->opcode & 0xf0ff;\n\n\t  if (opcode != 0x0093 /* ocbi */\n\n\t      && opcode != 0x00c3 /* movca.l */)\n\n\t      {\n\n\t\t  gen_helper_discard_movcal_backup ();\n\n\t\t  ctx->has_movcal = 0;\n\n\t      }\n\n\t}\n\n\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\t\t\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(low, REG(B7_4));\n\n\t    tcg_gen_bswap16_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, addr, 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n#define LD(reg,ldnum,ldpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\n\n#define ST(reg,stnum,stpnum,prechk)\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_gen_mov_i32(REG(B11_8), addr);\t\t\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n\tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\\n\n\tST(reg,stnum,stpnum,prechk)\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)\n\n\tLD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n        {\n\n            TCGv val = tcg_temp_new();\n\n            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);\n\n            gen_helper_movcal (REG(B11_8), val);            \n\n            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n        }\n\n        ctx->has_movcal = 1;\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    gen_helper_ocbi (REG(B11_8));\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 20467, "substitutes": {"ctx": ["bc", "fc", "cam", "ct", "config", "cm", "connection", "parse", "css", "cp", "na", "cs", "xc", "kb", "context", "la", "cpp", "qa", "fw", "wx", "conf", "cgi", "wcs", "support", "conn", "jp", "pkg", "cv", "anc", "fp", "ci", "component", "rc", "c", "cb", "wp", "cfg", "sc", "dc", "gc", "utils", "scope", "cu", "vc", "conv", "lc", "grad", "cc", "gpu", "hs", "crit", "tx", "cas", "cmp", "exec", "cmd", "cf", "tc", "cli", "loc", "cca", "gs", "hw", "git", "sci", "std", "ca", "Context", "nc", "mc", "ctrl", "np", "sync", "client", "cn", "console", "ck"], "CHECK_NOT_DELAY_SLOT": ["CHECK_NOT_DELAY_BLOTS", "CHECK_NOT_DELAYEDLORT", "CHECK_NOT_DELAY_SLORT", "CHECK_NOT_DELAY_Lot", "CHECK_NOT_DELAY_BLAT", "CHECK_NOT_DELAYEDSLOT", "CHECK_NOT_DELAY_SlOST", "CHECK_NOT_DELAY_LOT", "CHECK_NOT_DELAY_ALLOTS", "CHECK_NOT_DELAY_ALLORT", "CHECK_NOT_DELAY_SLot", "CHECK_NOT_DELAY_SLOTS", "CHECK_NOT_DELAY_LOTS", "CHECK_NOT_DELAY_SlOTS", "CHECK_NOT_DELAY_SlOT", "CHECK_NOT_DELAYEDLOT", "CHECK_NOT_DELAY_ALLOST", "CHECK_NOT_DELAY_BLOT", "CHECK_NOT_DELAYEDLOST", "CHECK_NOT_DELAYEDSLOTS", "CHECK_NOT_DELAY_SLOST", "CHECK_NOT_DELAY_SLAT", "CHECK_NOT_DELAY_ALLOT", "CHECK_NOT_DELAYEDSLORT", "CHECK_NOT_DELAY_LORT", "CHECK_NOT_DELAY_LOST", "CHECK_NOT_DELAY_LAT", "CHECK_NOT_DELAYEDLOTS", "CHECK_NOT_DELAYEDSLOST", "CHECK_NOT_DELAY_SlORT", "CHECK_NOT_DELAY_BLot"], "delayed_pc": ["delayed_mc", "delaying_pc", "delaying_path", "delayedThepc", "delayedThepath", "delayed_PC", "delaying_mc", "delayed_path", "delayedThepid", "delayed_pid", "delaying_pid", "delayedThePC", "delaying_PC"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471, "substitutes": {"opaque": ["oacity", "opaques", "oaque", "ospacity", "octaque", "Opesc", " opesc", "octacity", " opaques", "octaques", "oifice", "opesc", "Opacity", "ospaques", "opacity", " opacity", "oaques", "Opaque", "Opaques", "ospaque", "octifice", "opifice", " opifice", "ospesc"], "hz": ["az", "delay", "icity", "scale", "loop", "xxx", "eth", "height", "GHz", "wave", "hello", "kHz", "fps", "MHz", "size", "fee", "kh", "phy", "bass", "rh", "abc", "depth", "dy", "sync", "Hz", "cb", "density", "cpu", "hash", "length", "len", "cz", "z", "conf", "hw", "frequency", "clock", "tz", "broad", "ss", "hh", "padding", "count"], "s": ["sb", "i", "native", "e", "ruby", "sym", "es", "sl", "fs", "g", "ses", "an", "features", "d", "sets", "plugins", "ops", "services", "f", "t", "r", "u", "m", "socket", "ssl", "new", "p", "ts", "o", "sync", "is", "ss", "c", "js", "opens", "spec", "submit", "settings", "a", "b", "n", "S", "ns", "session", "south", "v", "secondary", "l", "sq", "padding"]}}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_dma_write(BlockBackend *blk,\n\n                         int64_t sector_num, int nb_sectors,\n\n                         void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    dma_addr_t dma_addr, dma_len;\n\n    void *mem;\n\n    int nsector, remainder;\n\n    int extra = 0;\n\n\n\n    qemu_iovec_destroy(&io->iov);\n\n    qemu_iovec_init(&io->iov, io->len / MACIO_PAGE_SIZE + 1);\n\n\n\n    if (io->remainder_len > 0) {\n\n        /* Return remainder of request */\n\n        int transfer = MIN(io->remainder_len, io->len);\n\n\n\n        MACIO_DPRINTF(\"--- processing write remainder %x\\n\", transfer);\n\n        cpu_physical_memory_read(io->addr,\n\n                                 &io->remainder + (0x200 - transfer),\n\n                                 transfer);\n\n\n\n        io->remainder_len -= transfer;\n\n        io->len -= transfer;\n\n        io->addr += transfer;\n\n\n\n        s->io_buffer_index += transfer;\n\n        s->io_buffer_size -= transfer;\n\n\n\n        if (io->remainder_len != 0) {\n\n            /* Still waiting for remainder */\n\n            return;\n\n        }\n\n\n\n        MACIO_DPRINTF(\"--> prepending bounce buffer with size 0x200\\n\");\n\n\n\n        /* Sector transfer complete - prepend to request */\n\n        qemu_iovec_add(&io->iov, &io->remainder, 0x200);\n\n        extra = 1;\n\n    }\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        sector_num = (int64_t)(s->lba << 2) + (s->io_buffer_index >> 9);\n\n    } else {\n\n        sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    }\n\n\n\n    nsector = (io->len >> 9);\n\n    remainder = io->len - (nsector << 9);\n\n\n\n    MACIO_DPRINTF(\"--- DMA write transfer - addr: %\" HWADDR_PRIx \" len: %x\\n\",\n\n                  io->addr, io->len);\n\n    MACIO_DPRINTF(\"xxx remainder: %x\\n\", remainder);\n\n    MACIO_DPRINTF(\"xxx sector_num: %\"PRIx64\"   nsector: %x\\n\",\n\n                  sector_num, nsector);\n\n\n\n    dma_addr = io->addr;\n\n    dma_len = io->len;\n\n    mem = dma_memory_map(&address_space_memory, dma_addr, &dma_len,\n\n                         DMA_DIRECTION_TO_DEVICE);\n\n\n\n    if (!remainder) {\n\n        MACIO_DPRINTF(\"--- DMA write aligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, io->len);\n\n        qemu_iovec_add(&io->iov, mem, io->len);\n\n    } else {\n\n        /* Write up to last complete sector */\n\n        MACIO_DPRINTF(\"--- DMA write unaligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, (nsector << 9));\n\n        qemu_iovec_add(&io->iov, mem, (nsector << 9));\n\n\n\n        MACIO_DPRINTF(\"--- DMA write read    - bounce addr: %p \"\n\n                      \"remainder_len: %x\\n\", &io->remainder, remainder);\n\n        cpu_physical_memory_read(io->addr + (nsector << 9), &io->remainder,\n\n                                 remainder);\n\n\n\n        io->remainder_len = 0x200 - remainder;\n\n\n\n        MACIO_DPRINTF(\"xxx remainder_len: %x\\n\", io->remainder_len);\n\n    }\n\n\n\n    s->io_buffer_size -= ((nsector + extra) << 9);\n\n    s->io_buffer_index += ((nsector + extra) << 9);\n\n\n\n    io->len = 0;\n\n\n\n    MACIO_DPRINTF(\"--- Block write transfer   - sector_num: %\"PRIx64\"  \"\n\n                  \"nsector: %x\\n\", sector_num, nsector + extra);\n\n\n\n    m->aiocb = blk_aio_writev(blk, sector_num, &io->iov, nsector + extra, cb,\n\n                              io);\n\n}\n", "idx": 20480, "substitutes": {"blk": ["blK", " blks", " blkt", "plks", "BlK", "plkt", "Blk", "blks", "blkt", "plK", "Blkt", "plk", "Blks", " blK"], "sector_num": [" sector_name", "sectorFsum", "sector__num", "section_num", "sector_sum", " sector_index", " sector_n", "sector_n", "section_number", "sector__n", "sectorFnum", "sectorFoffset", "section_sum", "sector_offset", "sector_index", "section_offset", " sector_number", "sectorFnumber", "sector_name", " sector_orig", "sector__orig", "sector_orig", "sector_number", "sector__number"], "nb_sectors": ["nb_segments", "nb_shcs", "nb_vegments", "nb_secxes", "nb_vexes", "nb_shctors", "nb_secctors", "nb_shgments", "nb_vectors", "nb_vecs", "nb_secs", "nb_secgments", "nb_sexes", "nb_seccs", "nb_shxes"], "cb": ["bc", "ref", "ctr", "cv", "unc", "cm", "func", "orb", "fp", "cmp", "ync", "exec", "cp", "ob", "ctrl", "sync", "buf", "CB", "ctx", "aux", "dc", "seq", "core", "callback", "buff", "proc", "lib", "rb", "fun"], "opaque": ["OPaque", "operacity", "opaques", "operaque", "preca", "opca", "OPque", " opca", "copaques", "obca", " opac", "copaque", " opaques", "offac", "compaque", "operacs", "offaque", "compca", "operca", "obque", "OPca", "obaque", "compac", "preac", " opacs", "opacity", "preacity", "OPac", " opque", "opac", " opacity", "offacs", "obac", "opque", "copacity", "offacity", "operac", "compacity", "preaque", "operaques", "copac", "opacs"], "io": ["gio", "i", "area", "config", "connection", "copy", "device", "no", "ex", "info", "bit", "use", "mo", "ip", "out", "go", "bo", "di", "global", "http", "image", "cgi", "output", "object", "ri", "option", "so", "ion", "op", "o", "audio", "office", "to", "hub", "boot", "lib", "multi", "su", "ie", "interface", "rio", "net", "wrapper", "ui", "ao", "mode", "ki", "f", "exec", "zip", "p", "cli", "si", "cho", "service", "error", "flow", "co", "IO", "hw", "api", "ne", "fo", "ilo", "iol", "obj", "input", "engine", "ro", "po", "entry", "storage", "cache", "sync", "timeout", "lo", "client", "source", "w", "server"], "m": ["wm", "e", "om", "g", "mode", "cm", "meta", "d", "f", "y", "r", "p", "mc", "machine", "mm", "mi", "c", "mu", "module", "sm", "b", "fm", "ms", "dm", "n", "media", "em", "bm", "mx", "M", "v", "tm", "manager", "gm", "im", "h", "l", "an"], "s": ["ions", "sv", "sim", "sb", "i", "e", "sym", "qs", "es", "serv", "sl", "sie", "fs", "g", "ses", "uns", "xs", "d", "ops", "sets", "ks", "so", "l", "services", "ds", "f", "sys", "t", "r", "its", "storage", "os", "ssl", "p", "cs", "ts", "us", "o", "ls", "sync", "is", "ss", "c", "js", "settings", "sm", "spec", "source", "si", "sc", "a", "b", "in", "service", "session", "S", "ns", "ps", "rs", "gs", "ins", "v", "http", "sp", "server", "su", "sq"], "dma_addr": ["dma_address", "dma_host", "dna_host", "dna_address", "dna_addr", "dna_len"], "dma_len": ["dva_len", "dma__ln", "dma__den", "dma_Len", "dma__Len", "dma_ln", "dva_Len", "dma__len", "dma_den", "dva_den", "dva_ln"], "mem": ["serv", "mb", "mode", "meta", "rem", "copy", "temp", "mon", "mop", "ro", "alloc", "info", "ram", "mo", "cache", "mod", "mm", "mi", "memory", "ctx", "lim", "sh", "mp", "tmp", "mx", "vm", "server", "Mem"], "nsector": ["nsection", "nplayer", "numarea", "nconnection", "unsection", "Narea", "nnsection", "numsection", "naxis", "nnsector", " Nsector", "Nchannel", "unchannel", "unconnection", "narea", " narea", "nnaxis", "numsector", "unsector", "Nconnection", " Naxis", " Nplayer", " Nsection", "nnplayer", "Nsection", "numchannel", "Nsector", "numconnection", " naxis", " nplayer", "nchannel", " nsection"], "remainder": ["remainter", " remainingter", "REMainter", "remainedter", " remainedder", " remainedcer", " remainDER", " remaincer", " remainter", "remainingner", " remaindr", " remaineddr", " remainden", "remainscer", "retaindr", "retainter", " remainedner", "REMainedder", "remainDER", "REMainedter", "remainedder", " remainingDER", "remireter", "REMainedDER", "remrainder", "remiverner", "remiverder", " remainner", "remainsDER", "REMainedner", "remireder", " remrainder", "retainner", "REMainner", "remrainden", "remiverden", "remaindr", "remrainner", "remainsdr", "remainingcer", "retainsner", "remaincer", "remaineddr", "remainedden", "remainden", "remainedner", "remraincer", "remireDER", "remainner", "remainingdr", "retainsdr", "retainder", " remrainden", "REMainDER", "remainsder", "remainingder", " remraincer", "remivercer", "retainsder", "retainster", "remainingDER", "remainedDER", " remainingner", "remainster", " remrainner", "REMainder", "remainedcer", "remainsner", " remainingder", "remainingter", "remirener"]}}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n", "idx": 20485, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "lb", "bis", "es", "ba", "obj", "fs", "ses", "ubs", "xs", "als", "db", "fb", "bb", "ops", "ks", "bid", "ds", "bes", "bl", "css", "bing", "bas", "os", "vs", "cs", "ls", "sync", "bps", "js", "cb", "b", "bits", "blocks", "ns", "BS", "iss", "Bs", "rs", "gs", "ps", "ins", "banks", "bh", "base", "ss", "las", "gb"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 20495, "substitutes": {"iommu_mr": ["iommuit_mi", "iommu_rr", "iommur_rs", "iommu_br", "iommu_mid", "iommur_br", "iommuit_rr", "iommur_vr", "iommu__mr", "iommuit__mr", "iommuit__rr", "iommu__mi", "iommuit__mi", "iommu__rr", "iommu_mi", "iommu_rs", "iommu__mid", "iommur_mr", "iommu_vr", "iommuit__mid", "iommuit_mr", "iommuit_mid"], "n": ["i", "net", "e", "nat", "nn", "g", "d", "node", "f", "dn", "t", "y", "N", "r", "m", "nc", "j", "u", "p", "o", "network", "c", "self", "num", "a", "b", "w", "ns", "nb", "v", "nt", "sn", "fn", "h", "l", "x", "ne", "k", "nm"], "vtd_as": ["vtd__as", "vtd_state", "vdt_at", "vtd_cache", "vtd_AS", "vdtikcache", "vdt_as", "vtd__at", "vcd_asse", "vtd_at", "vtd__ws", "vcd_an", "vtd_an", "vtd_ac", "vtd_nas", "vtdikat", "vtdOCKAs", "vpc__ras", "vtd7as", "vdat_las", "vtdika", "vpd_as", "vtd7state", "vpc__ms", "vtdobas", "vtd7ras", "vtdappasin", "vdtikas", "vdd_As", "vtdikas", "vtdocat", "vdat_a", "vtd__ac", "vdat_as", "vpc_ras", "vtd__AS", "vtdockas", "vdtikAs", "vdd_as", "vpd_nas", "vdd_ac", "vpd_with", "vtd_ws", "vtdoat", "vtd_ras", "vtdocbas", "vcd_as", "vcd_asin", "vtd_asin", "vtdiknas", "vpc_an", "vtd__cache", "vtdikwith", "vpc_as", "vtd___as", "vdat_at", "vpc_ms", "vpc__an", "vtdocknas", "vdd_state", "vtd_As", "vtd___asin", "vtdockwith", "vtdOCKAS", "vtdOCKac", "vtdockras", "vtdappasse", "vtd_las", "vtdocws", "vtdikcache", "vtdikAs", "vtdappAs", "vtdows", "vtd_via", "vtd_a", "vdd_at", "vdd_AS", "vtd__las", "vtdappcache", "vtd___asse", "vtdockms", "vtdockvia", "vtd_ms", "vtdOCKas", "vtd___an", "vtd_bas", "vdt_cache", "vpc__as", "vtd__As", "vtd__an", "vtdockan", "vdt_As", "vtdikws", "vtd_asse", "vpd_via", "vdtikat", "vtdocas", "vtdikvia", "vtdappan", "vtdiklas", "vtd__a", "vdat_ws", "vtd__ras", "vtd_with", "vdat_bas", "vtdappat", "vtd__ms", "vdd_ras", "vtdappas", "vtdoas"], "s": ["i", "sb", "e", "sl", "ses", "sis", "ops", "ds", "services", "f", "sys", "t", "u", "r", "m", "state", "ssl", "os", "p", "cs", "ts", "o", "sync", "is", "sa", "c", "js", "spec", "a", "b", "S", "ns", "session", "side", "ps", "south", "gs", "v", "scope", "ss", "states"], "ce": ["ate", "cc", "ix", "ces", "ee", "e", "cing", "oe", "ct", "ind", " pe", "ance", "pe", "ette", "ade", " CE", "none", "nce", "ze", "za", " ke", "ca", "che", "cur", "cel", "cell", "ci", "ine", "ide", "ue", " ne", " ace", "cle", "cer", "CE", "ace", "code", "cess", "SE", "le", "que", "cue", "coe", "client", "dr", "fe", "ste", "cf", "du", "cal", "se", "face", "cy", "ced", "core", "te", "ve", "cca", "co", "cast", "see", "ince", "ae", "ke", "ck", "GE", "ge", "cod", "ie", "ice", "ne", " ge"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n", "idx": 20507, "substitutes": {"sd": ["md", "td", "sv", "sb", "sed", "rd", "sk", "sam", "sl", "std", "db", "d", "vd", " td", "pd", "ds", "ld", "gd", "dev", "dd", "ad", "hd", "cs", "od", "sa", "sg", "sm", "sq", "sh", "si", "se", "dk", "dl", "fd", "inst", "sf", "bd", "SD", "di", "ss", "gb"], "addr": ["route", "ref", "adr", "ha", "kt", "ord", "wd", "rx", "align", "host", "mt", "ld", "pad", "node", "pc", "adder", "ac", "address", "size", "data", "ad", "state", "dd", "hd", "ace", "id", "od", "mac", "dr", "ext", "rc", "cb", "nr", "rm", "ar", "rt", "ptr", "hash", "alias", "src", "pointer", "offset", "x", "attr"]}}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_handle_escape(QemuConsole *s)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i<s->nb_esc_params; i++) {\n\n        switch (s->esc_params[i]) {\n\n            case 0: /* reset all console attributes to default */\n\n                s->t_attrib = s->t_attrib_default;\n\n                break;\n\n            case 1:\n\n                s->t_attrib.bold = 1;\n\n                break;\n\n            case 4:\n\n                s->t_attrib.uline = 1;\n\n                break;\n\n            case 5:\n\n                s->t_attrib.blink = 1;\n\n                break;\n\n            case 7:\n\n                s->t_attrib.invers = 1;\n\n                break;\n\n            case 8:\n\n                s->t_attrib.unvisible = 1;\n\n                break;\n\n            case 22:\n\n                s->t_attrib.bold = 0;\n\n                break;\n\n            case 24:\n\n                s->t_attrib.uline = 0;\n\n                break;\n\n            case 25:\n\n                s->t_attrib.blink = 0;\n\n                break;\n\n            case 27:\n\n                s->t_attrib.invers = 0;\n\n                break;\n\n            case 28:\n\n                s->t_attrib.unvisible = 0;\n\n                break;\n\n            /* set foreground color */\n\n            case 30:\n\n                s->t_attrib.fgcol=COLOR_BLACK;\n\n                break;\n\n            case 31:\n\n                s->t_attrib.fgcol=COLOR_RED;\n\n                break;\n\n            case 32:\n\n                s->t_attrib.fgcol=COLOR_GREEN;\n\n                break;\n\n            case 33:\n\n                s->t_attrib.fgcol=COLOR_YELLOW;\n\n                break;\n\n            case 34:\n\n                s->t_attrib.fgcol=COLOR_BLUE;\n\n                break;\n\n            case 35:\n\n                s->t_attrib.fgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 36:\n\n                s->t_attrib.fgcol=COLOR_CYAN;\n\n                break;\n\n            case 37:\n\n                s->t_attrib.fgcol=COLOR_WHITE;\n\n                break;\n\n            /* set background color */\n\n            case 40:\n\n                s->t_attrib.bgcol=COLOR_BLACK;\n\n                break;\n\n            case 41:\n\n                s->t_attrib.bgcol=COLOR_RED;\n\n                break;\n\n            case 42:\n\n                s->t_attrib.bgcol=COLOR_GREEN;\n\n                break;\n\n            case 43:\n\n                s->t_attrib.bgcol=COLOR_YELLOW;\n\n                break;\n\n            case 44:\n\n                s->t_attrib.bgcol=COLOR_BLUE;\n\n                break;\n\n            case 45:\n\n                s->t_attrib.bgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 46:\n\n                s->t_attrib.bgcol=COLOR_CYAN;\n\n                break;\n\n            case 47:\n\n                s->t_attrib.bgcol=COLOR_WHITE;\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 20518, "substitutes": {"s": ["sv", "sb", "e", "qs", "es", "sl", "fs", "g", "ses", "an", "hs", "this", "d", "sis", "site", "l", "ds", "services", "f", "sys", "t", "y", "r", "u", "m", "its", "tp", "os", "ssl", "p", "ts", "cs", "us", "ls", "o", "is", "sg", "c", "js", "self", "si", "a", "b", "service", "se", "ms", "n", "S", "ns", "session", "sf", "ps", "rs", "gs", "v", "conf", "z", "h", "server", "su", "ss", "k"], "i": ["io", "e", "fi", "qi", "ind", "ri", "ui", "eni", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "t", "r", "phi", "ini", "m", "j", "u", "oi", "info", "p", "ip", "o", "bi", "cli", "mi", "c", "mu", "index", "si", "dim", "a", "ii", "b", "ji", "n", "iu", "ai", "xi", "hi", "di", "v", "yi", "multi", "li", "h", "pi", "x", "zi", "k", "ni", "type"]}}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 20520, "substitutes": {"s": ["e", "fs", "ses", "sets", "services", "f", "t", "m", "ssl", "p", "sync", "c", "js", "sq", "sc", "b", "w", "n", "S", "session", "sf", "v", "sec", "h", "secondary", "scope", "ss"], "tcg_src": ["tcG_src", "tcg__src", "tcg_inst", "tcg7rc", "tcG_rc", "tcerg_sb", "tcg_sel", "tcG_sb", "tcG_enc", "tcG_inst", "tcG_rs", "tcgi_sel", "tcgi_sb", "tcg__rc", "tcg7sb", "tcg_rin", "tcerg_src", "tcg_sur", "tcgi_rin", "tcg_rs", "tcg_enc", "tcG_sur", "tcg7src", "tcg_sb", "tcg_rc", "tcerg_rc", "tcg__sur", "tcg7enc", "tcgi_src", "tcerg_enc", "tcg__inst"], "destidx": [" destinz", " destinx", "destidz", "srcIdX", "destIdX", "srcIdz", " destinxc", "destindz", " destidz", "destidxc", "destidX", "destinx", "destinxc", "srcidx", "destindX", " destidxc", "srcidz", "destIdc", "destinz", "srcidX", " destinc", "srcIdx", "destIdxc", "srcidxc", "destidc", "srcIdxc", "destIdx", " destidc", "destindxc", "destindx", "destinc", "destIdz"], "element": ["member", "Element", "e", "attribute", "ee", "object", "event", "item", "option", "input", "key", "mode", "uri", "style", "token", "node", "device", "layer", "section", "address", "entry", "data", "seed", "dimension", "unit", "number", "field", "el", "index", "present", "ele", "lements", "length", "iterator", "child", "append", "lement", "array", "offset"], "memop": ["memopus", "Memop", "emaop", "mmOp", "MemOp", "ramop", "Memoop", "limopt", "remopus", "mmopt", "remopt", "limoper", "limop", "memhop", "moro", "emaoper", "Memo", "ramhop", "memoop", "moroper", "memo", "emaoop", "Memhop", "morhop", "mmoop", "Memoper", "mmop", "limopus", "emaOp", "memOp", "mmopus", "remop", "morop", "ramo", "remoper", "mmoper", "memopt", "memoper", "ramoper"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),\n\n                                    int ra, int rb, int rc,\n\n                                    int islit, uint8_t lit)\n\n{\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    if (ra != 31) {\n\n        if (islit) {\n\n            if (lit != 0)\n\n                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));\n\n            else\n\n                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);\n\n        } else {\n\n            TCGv tmp1, tmp2;\n\n            tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);\n\n            tcg_gen_shli_i64(tmp1, tmp1, 3);\n\n            tmp2 = tcg_const_i64(64);\n\n            tcg_gen_sub_i64(tmp1, tmp2, tmp1);\n\n            tcg_temp_free(tmp2);\n\n            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);\n\n            tcg_temp_free(tmp1);\n\n        }\n\n        if (tcg_gen_ext_i64)\n\n            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);\n\n    } else\n\n        tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n}\n", "idx": 20531, "substitutes": {"tcg_gen_ext_i64": ["tcg_gen_ext_ii16", "tcg_gen_ext_ui24", "tcg_gen_ext_i24", "tcg_gen_ext_ui32", "tcg_gen_ext_i6", "tcg_gen_ext_ii6", "tcg_gen_ext_I16", "tcg_gen_ext_f24", "tcg_gen_ext_I6", "tcg_gen_ext_f16", "tcg_gen_ext_ui16", "tcg_gen_ext_ii24", "tcg_gen_ext_ui64", "tcg_gen_ext_I32", "tcg_gen_ext_f32", "tcg_gen_ext_ii64", "tcg_gen_ext_f64", "tcg_gen_ext_I64", "tcg_gen_ext_i32", "tcg_gen_ext_i16", "tcg_gen_ext_ui6", "tcg_gen_ext_I24"], "ra": ["ras", "ru", "arc", "ria", "area", "rd", "ia", "Ra", "ref", "ur", "ri", "asc", "ha", "rog", "sha", "rap", "RA", "rr", "ring", "ca", "ara", "rf", "dra", "ro", "po", "ica", "r", "dir", "raf", "da", "ka", "star", "year", "sa", "rac", "la", "spec", "ar", "rar", "RC", "rt", "a", "ta", "rad", "sr", "ran", "sur", "cr", "src", "va", "loc", "rss", "up", "alpha", "ma", "ir"], "rb": ["pb", "ru", "sb", "ruby", "lb", "rd", "ref", "ri", "ril", "db", "rr", "rf", "lr", "ro", "r", "reb", "raf", "wb", "cb", "rn", "rm", "rar", "rt", "rl", "b", "vr", "rad", "sr", "src", "RB", "attr", "gb", "rg"], "rc": ["lc", "bc", "ource", "ru", "fc", "arc", "rd", "ruby", "ras", "irc", "uc", "ref", "ur", "config", "name", "asc", "ri", "rog", "inc", "cv", "rin", "rr", "rec", "rect", "cur", "rf", "lr", "dra", "ci", "rank", "cmp", "ro", "ica", "r", "ac", "path", "c", "rac", "rn", "dr", "cb", "rar", "roc", "RC", "rt", "sc", "rl", "rad", "dc", "hr", "sr", "hl", "sur", "row", "cr", "qa", "src", "ran", "desc", " src", "loc", "ann", "rs", "alpha", "rib", "kr", "rg"], "islit": ["isalitted", "rlited", "ssli", "slited", "slitt", "islitting", "sli", "rlite", "isli", "sslited", "sslite", "slit", "islitted", "isalit", "slitting", "isali", "sslitted", "slite", "rlit", "islite", "isalitting", "sslitting", "slitted", "islited", "sslitt", "sslit", "islitt", "rlitt"], "lit": ["lc", "ident", "lot", "lat", "sel", "nat", "sl", "late", "sil", "val", "pit", "bl", "cl", "split", "lab", "info", "lite", "it", "init", "rel", "stat", "inf", "lin", "la", "rot", "lim", "spec", "pl", "lif", "lambda", "len", "loc", "lt", "iter", " literal", "util", "alt", "lib", "lang", "eval", "l", "fi", "lic", "lam"], "tmp1": [" tmpl", "temp2", "mp1", "cp3", "txt1", "mpone", "temp8", " tmp8", "tmp64", "cpp2", "tmpl", "cpp1", "tempone", "cpp64", "cppl", "tmp4", "templ", "temp3", "buf1", "cp2", "bufl", "mp2", "buf3", "tmp8", "mp3", " tmp4", "buf64", "cpp3", " tmp64", "temp1", "txt3", "mp8", "mp4", " tmp3", "txtone", "tmp3", "cp1", "cpl", "tmpone", " tmpone", "temp4", "mpl", "txt2"], "tmp2": ["tmp32", "temp2", "mp1", "txt1", "tmpb", "mp32", "tmp4", "temp3", "tempb", "temp32", "mp2", " tmp32", "mp3", " tmp4", "temp1", "mp4", "mpb", " tmp3", "txt4", "tmp3", "txtb", "temp4", "txt2"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_dequant_tables(H264Context *h)\n\n{\n\n    int i, x;\n\n    init_dequant4_coeff_table(h);\n\n    if (h->pps.transform_8x8_mode)\n\n        init_dequant8_coeff_table(h);\n\n    if (h->sps.transform_bypass) {\n\n        for (i = 0; i < 6; i++)\n\n            for (x = 0; x < 16; x++)\n\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n\n        if (h->pps.transform_8x8_mode)\n\n            for (i = 0; i < 6; i++)\n\n                for (x = 0; x < 64; x++)\n\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n\n    }\n\n}\n", "idx": 20534, "substitutes": {"h": ["ih", "hhh", "hp", "hm", "hum", "e", "hs", "sl", "g", "ha", "beh", "host", "oh", "f", "t", "ah", "eh", "m", "php", "u", "kh", "s", "hd", "p", "rh", "context", "uh", "H", "c", "ctx", "sh", "ch", "hr", "b", "w", "he", "hl", "gh", "history", "th", "html", "hi", "di", "http", "v", "bh", "hw", "hist", "ph", "ht", "hh", "k"], "i": ["io", "lc", "e", "ix", "ik", "ie", "fi", "qi", "start", "ind", "ri", "ui", "mini", "key", "gi", "d", "my", "ti", "I", "l", "f", "ci", "y", "u", "oi", "m", "ini", "s", "j", "info", "init", "it", "ip", "p", "id", "o", "bi", "phi", "is", "mi", "c", "mu", "index", "si", "a", "ii", "b", "iu", "slice", "ai", "xi", "ei", "di", "v", "yi", "multi", "li", "pi", "zi", "ni"], "x": ["name", "e", "ix", "ya", "ux", "cross", "g", "xe", "wa", "xs", "xy", "xxx", "lex", "time", "rx", "tx", "xx", "cl", "f", "sex", "y", "t", "ex", "u", "m", "php", "j", "xf", "full", "fx", "p", "xc", "id", "na", "work", "yx", "code", "is", "c", "px", "index", "dx", "X", "plus", "xa", "b", "xp", "rex", "sw", "any", "xi", "ax", "wx", "v", "z", "mix", "orig", "xb", "image", "zi"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int g722_encode_init(AVCodecContext * avctx)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono tracks are allowed.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    c->band[0].scale_factor = 8;\n\n    c->band[1].scale_factor = 2;\n\n    c->prev_samples_pos = 22;\n\n\n\n    if (avctx->trellis) {\n\n        int frontier = 1 << avctx->trellis;\n\n        int max_paths = frontier * FREEZE_INTERVAL;\n\n        int i;\n\n        for (i = 0; i < 2; i++) {\n\n            c->paths[i] = av_mallocz(max_paths * sizeof(**c->paths));\n\n            c->node_buf[i] = av_mallocz(2 * frontier * sizeof(**c->node_buf));\n\n            c->nodep_buf[i] = av_mallocz(2 * frontier * sizeof(**c->nodep_buf));\n\n            if (!c->paths[i] || !c->node_buf[i] || !c->nodep_buf[i]) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (avctx->frame_size) {\n\n        /* validate frame size */\n\n        if (avctx->frame_size & 1 || avctx->frame_size > MAX_FRAME_SIZE) {\n\n            int new_frame_size;\n\n\n\n            if (avctx->frame_size == 1)\n\n                new_frame_size = 2;\n\n            else if (avctx->frame_size > MAX_FRAME_SIZE)\n\n                new_frame_size = MAX_FRAME_SIZE;\n\n            else\n\n                new_frame_size = avctx->frame_size - 1;\n\n\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested frame size is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_frame_size,\n\n                   avctx->frame_size);\n\n            avctx->frame_size = new_frame_size;\n\n        }\n\n    } else {\n\n        /* This is arbitrary. We use 320 because it's 20ms @ 16kHz, which is\n\n           a common packet size for VoIP applications */\n\n        avctx->frame_size = 320;\n\n    }\n\n    avctx->delay = 22;\n\n\n\n    if (avctx->trellis) {\n\n        /* validate trellis */\n\n        if (avctx->trellis < MIN_TRELLIS || avctx->trellis > MAX_TRELLIS) {\n\n            int new_trellis = av_clip(avctx->trellis, MIN_TRELLIS, MAX_TRELLIS);\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested trellis value is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_trellis,\n\n                   avctx->trellis);\n\n            avctx->trellis = new_trellis;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    g722_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 20541, "substitutes": {"avctx": ["avecf", "avalctl", "awcontext", "vercontext", "vercf", "AVcp", "avhw", "avcca", "avcup", "varctrl", "avalhw", "navctx", "varcca", "avalconf", "awctx", "avalcmp", "ajcup", "varcontext", "avconf", "avsys", " avconn", "avalconn", "ajctx", "avcmp", "afconn", "avctrl", "avcn", "avalc", "navcontext", "abcmp", "avecu", "afconf", "verctx", "afcup", "avcp", "AVctrl", "afctx", " avpkg", "verconf", " avc", "ajcf", "navcu", "avcontext", "ajconn", " avctl", "avalpkg", "afcal", "svcf", "navcmp", "avalcu", "AVctx", "avalcontext", "afcca", "avalsys", "aveconn", "navcf", "avpkg", "svcontext", "AVcf", " avcp", "svcmp", "ajcontext", "afcn", "navcup", "avcal", "afctl", "afcmp", "afcmd", "afhw", "avcf", "afpkg", "svctx", "afcu", "varcmd", "vercal", "avcu", "abctx", "AVconn", "avctl", "navctl", "avalcf", "avalcmd", "avectx", "afcontext", "afc", "navpkg", "awctl", "afctrl", "AVcmp", "vercu", "afcf", "avalcal", "avalcn", " avhw", "vercn", "avconn", "AVpkg", "AVcontext", "avecmp", "afsys", "abcf", "avecontext", "avecmd", "awcf", "varctx", "avalctrl", "avalctx", "avalcca", "avc", "abcontext", "avcmd", " avcontext", "ajcp", "varsys"], "c": ["lc", "arc", "cc", "e", "uc", "conn", "ct", "config", "g", "this", "coll", "com", "cm", "d", "con", "ca", "pc", "cur", "cl", "cu", "f", "ci", "t", "ac", "u", "cp", "s", "m", "cache", "p", "mc", "cf", "cs", "ctrl", "enc", "context", "tc", "xc", "o", "ctx", "cn", "ch", "sc", "b", "dc", "w", "ic", "cy", "cr", "n", "C", "co", "v", "ce", "conf", "h", "l", "ec", "k", "vc"], "ret": ["ut", "reg", "mel", "def", "ref", "pet", "result", "val", "arg", "det", "Ret", "mt", "bit", "res", "cat", "job", " RET", "fun", "success", "aux", "match", "RET", "resp", "rt", " Ret", "reply", "re", "back", "util", "alt", "nt", "lit", "feat", "rets"], "i": ["io", "lc", "e", "ix", "ie", "fi", "qi", "ri", "ui", "eni", "g", "part", "mini", "pi", "gi", "d", "uri", "chi", "ti", "I", "f", "ci", "y", "t", "phi", "r", "ini", "s", "oi", "j", "u", "info", "it", "p", "ip", "abi", "id", "bi", "cli", "mi", "mu", "index", "si", "ii", "b", "in", "ji", "n", "iu", "slice", "ai", "xi", "hi", "di", "v", "multi", "yi", "li", "isi", "h", "api", "l", "x", "zi", "isin", "ni", "type"], "new_frame_size": ["new_line_unit", "new_frame_name", "new_frame\u00b7rate", "new_line_level", "new_frame_rate", "new_line_len", "new_frame_level", "new_framexstyle", "new_frame\u00b7size", "new_frame_unit", "new_line_size", "new_framelexsize", "new_framelexsend", "new_line_name", "new_frame64unit", "new_frame64size", "new_framexsend", "new_frame_style", "new_frame\u00b7start", "new_line_style", "new_frame_len", "new_frame_start", "new_frame_scale", "new_line_cycle", "new_framelexstyle", "new_framexsize", "new_frame_send", "new_frame64len", "new_frame_cycle", "new_line_send"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n", "idx": 20548, "substitutes": {"opaque": ["OPaque", "opaques", "ipopaques", "opec", "OPaques", " opaco", "ipopaco", " opac", "opaco", " opaques", "opsque", "OPaco", "opacity", "OPacity", " opque", "opac", " opacity", "opque", "iopaque", "iopac", " opec", "opsec", "opsaque", "iopec", "iopque", "opsac", "ipopacity", "ipopaque"], "addr": ["port", "grad", "asm", "obj", "adr", "config", "mode", "oa", "ord", "amd", "pad", "pc", "host", "node", "device", "pos", "adder", "address", "args", "data", "ad", "da", "state", "p", "ace", "mac", "dr", "nr", "byte", " address", "ptr", "ada", "Address", "dc", "arm", "alias", "slice", "pointer", "offset", "x", "padding"], "size": ["name", "mode", "Size", "bytes", "ize", "address", "data", "args", "or", "rc", "c", " Size", "capacity", "length", " length", " sizes", "len", "large", "from", "SIZE", "block", "offset", "x", "type"], "s": ["i", "sb", "e", "sym", "sl", "fs", "g", "ses", "d", "ops", "ds", "f", "t", "r", "u", "m", "socket", "state", "ssl", "os", "p", "params", "o", "sync", "is", "ss", "c", "settings", "opens", "spec", "a", "b", "w", "session", "S", "n", "sf", "secondary", "sq", "states"]}}
{"project": "qemu", "commit_id": "465f2fedd262cbdcbfc92c181660cf85e5029515", "target": 0, "func": "static int cryptodev_builtin_create_cipher_session(\n\n                    CryptoDevBackendBuiltin *builtin,\n\n                    CryptoDevBackendSymSessionInfo *sess_info,\n\n                    Error **errp)\n\n{\n\n    int algo;\n\n    int mode;\n\n    QCryptoCipher *cipher;\n\n    int index;\n\n    CryptoDevBackendBuiltinSession *sess;\n\n\n\n    if (sess_info->op_type != VIRTIO_CRYPTO_SYM_OP_CIPHER) {\n\n        error_setg(errp, \"Unsupported optype :%u\", sess_info->op_type);\n\n        return -1;\n\n    }\n\n\n\n    index = cryptodev_builtin_get_unused_session_index(builtin);\n\n    if (index < 0) {\n\n        error_setg(errp, \"Total number of sessions created exceeds %u\",\n\n                  MAX_NUM_SESSIONS);\n\n        return -1;\n\n    }\n\n\n\n    switch (sess_info->cipher_alg) {\n\n    case VIRTIO_CRYPTO_CIPHER_AES_ECB:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CBC:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CBC;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CTR:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CTR;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_DES_ECB:\n\n        algo = QCRYPTO_CIPHER_ALG_DES_RFB;\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher alg :%u\",\n\n                   sess_info->cipher_alg);\n\n        return -1;\n\n    }\n\n\n\n    cipher = qcrypto_cipher_new(algo, mode,\n\n                               sess_info->cipher_key,\n\n                               sess_info->key_len,\n\n                               errp);\n\n    if (!cipher) {\n\n        return -1;\n\n    }\n\n\n\n    sess = g_new0(CryptoDevBackendBuiltinSession, 1);\n\n    sess->cipher = cipher;\n\n    sess->direction = sess_info->direction;\n\n    sess->type = sess_info->op_type;\n\n\n\n    builtin->sessions[index] = sess;\n\n\n\n    return index;\n\n}\n", "idx": 20549, "substitutes": {"builtin": [" BuiltIN", "builtini", "builtins", "buildin", "builtIN", "buildout", "buildini", " builtout", "buildIN", "builtout", " builtini", "boundIN", " builtIN", " Builtout", "boundini", "buildins", " builtins", " Builtin", "boundins", "boundin"], "sess_info": ["ssession_label", "sesserobject", "sess_manager", "sesspoinfo", "sop_inf", "sessrinformation", "sess_INFO", "sessginfo", "sesslinfo", "sop_information", "sessghandle", "ssession_information", "ssession_INFO", "sessername", "ssession_object", "sesssinf", "siz_information", "ssession_info", "sess_inf", "sesserinfo", "sessgINFO", "sesssmanager", "session_manager", "ssession_handle", "sessropt", "session_info", "ssession_opt", "sesspolabel", "sesspoinformation", "sess_information", "sess_label", "sess_class", "sop_info", "sess_name", "session_inf", "sessallhandle", "sesslinformation", "sessjinfo", "sessllabel", "sess_object", "sess_opt", "sessjinformation", "ssession_name", "sessallINFO", "sessrinfo", "sess_handle", "sesssinfo", "sessjclass", "sessallinfo", "siz_info", "siz_class"], "errp": ["orderpre", " errf", "grfp", "arrpin", "moreping", " errpre", "arrfp", "oderpin", " errpc", "gerp", "errfp", "errpa", "eerpre", " errip", "errpin", "irpc", "irP", "oderp", "erP", "ererp", "gerpre", "eerip", "ererf", " errpin", "drp", "errf", "orderpc", "drpress", "moref", "irfp", "gerpress", "errpre", "oderfp", "errorp", "morep", "erpre", "nerp", "nerpc", "ferp", " errfp", "errP", "eerp", "gerip", "drpre", " errpa", "grp", "irp", "erfp", " errP", "errip", "nerP", "ferip", "moreip", "ferpc", "errorip", "errpress", "nerfp", "grP", "ererip", "arrpa", " errping", "errpc", "errping", "errorpre", "ererping", "orderp", "drip", "grpre", "arrp", "oderpa", "orderip", "erp", "errorpress", "ferpre", "erpc"], "algo": ["ALgin", " alho", "algin", "ALgn", "elgin", "chalgo", " algone", "allgin", "isalho", "chalgan", "adga", "allga", "elga", "elho", "adgin", "calbo", "allgo", "Algn", "algorithm", "ALga", "Algo", "ALgorithm", "elgo", "elbo", " algn", "isalga", " algan", "algn", "palgo", "alpo", " alpo", "palgorithm", "calgorithm", "Alpo", "Algin", "elgone", "chalgorithm", "chalga", "alga", "Algorithm", " alga", "adgo", "isalgo", " algin", "algan", "adgone", "alho", "palgin", "albo", "Alga", "elgorithm", "allgorithm", "elgan", "algone", "ALgo", " albo", "palga", "calga", "isalgorithm", " algorithm", "calgo", "ALpo"], "mode": ["member", "route", "md", "view", "step", "name", "phase", "kind", "language", "config", "scale", "driver", " modes", "lane", "layout", "key", "shell", " module", "style", "access", "engine", "device", "node", "model", "path", "slave", "disable", "MODE", "vel", "method", "id", "mod", "mid", "mi", "mission", "module", "source", "gone", "dim", "direction", "role", "error", "session", "slice", "mask", "element", "grade", "stage", "range", "multi", "parent", "sid", "ward", "guide", "Mode", "command", "type"], "cipher": [" cmp", "chip", "cortex", "cip", "acortex", "cmp", "chmp", " cip", "chipher", " cortex", "acmp", "chortex", "acipher", "acip"], "index": ["member", "route", "i", "name", "end", "level", "ind", "option", "loop", "input", "inc", "part", "connection", "weight", "pos", "path", "ion", "section", "address", "ini", "size", "cache", "method", "version", "list", "number", "prefix", "depth", "find", "sync", "timeout", "Index", "search", "num", "match", "dim", "value", "error", "length", "slice", "loc", "len", "page", "element", "append", "update", "array", "pointer", "instance", "position", "offset", "x", "action", "count"], "sess": [" ssession", "sessl", "sys", "sesess", " ssl", " sys", "ssl", "sessession", "ssession", "sesys"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n", "idx": 20553, "substitutes": {"entry": ["member", "route", "lc", "je", "row", "e", "end", "obj", "next", "option", "part", "ger", "key", "connection", "card", "entity", "cell", "ell", "section", "slave", "cat", "data", "zip", "her", "link", "or", "list", "id", "code", "inner", "comment", "index", "search", "si", "service", "se", "enter", "error", "child", "reader", "try", "element", "archive", "feed", "base", "Entry", "ew", "ry", "ent", "nt", "server", "ge", "ie", "record", "ev", " Entry", "letter"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 20562, "substitutes": {"ahci": ["AHcu", "ehcu", "avecu", "accium", "aphcia", "ahcin", "akcin", "ahcium", "yahcu", "ehci", "yahcci", "lahcin", "akcium", "avec", "avecium", "akcu", "lahcu", "earci", "AHcin", "akcci", "ahc", "lahcia", "akrc", "accu", "lahcci", "acc", "earcium", "AHcia", "ahrc", "yahrc", "earcci", "acci", "ahcci", "lahci", "lahcium", "yahcin", "ehcin", "akci", "ahcia", "earcu", "AHci", "ehcci", "amcium", "aphcin", "amci", "aphci", "yahci", "aphcu", "aveci", "amcu", "amc", "ehrc", "ahcu"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static int writev_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector qiov;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&writev_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_writev(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}", "idx": 20576, "substitutes": {"argc": ["Argc", "agf", "argumentlc", "agp", "argdc", "axp", "argumentv", "axv", "axc", " argn", "argn", "Argn", "argumentc", "argl", "agv", "argp", "Arglc", " argp", "argumentdc", "axf", "arglc", " argf", "argf", "aglc", "axlc", "Argf", "Argdc", "Argv", " argl", "argumentf", " arglc", " argdc", "argumentn", "agc", "axl", "agl", "argumentl", "Argl"], "argv": ["Argc", "agf", "argb", "agp", "argw", "Argp", "Argw", " argb", "parf", "argsp", "argumentv", "argu", "agw", "argval", "argumentp", "argsv", "parc", "argsval", "argumentc", "execv", "agv", "argsvs", " argu", "argp", " argp", "execc", "execb", " argf", "argf", "parv", "parvs", " argval", "argsu", " argvs", "argsb", "Argv", "argumentf", "argsc", "agc", "agval", "argsf", "argvs", "execu", " argw"], "t1": ["tt0", "f2", "pt3", " t0", "T2", "pt1", "p2", "p0", "pt2", " tb", "T9", "T1", "p4", "T3", "f1", "t4", "p1", "tt2", "t9", " t4", "f3", "t3", "pt9", "T0", "Tb", "t0", "ttb", "tb", "f9", "T4", "tt1"], "t2": ["temp2", "f2", "TTwo", " tTwo", " t0", "temptwo", "T2", "p2", "p0", "tmp2", "f4", "T1", "p4", "tmp4", "T3", "temp3", "Ttwo", "f1", "t4", "p1", "int2", " t4", "tmpTwo", "tmp1", "int0", "f3", "t3", "temp1", " t3", "T0", "int1", " ttwo", "t0", "tTwo", "int4", "ttwo", "T4"], "c": ["lc", "col", "i", "e", "start", "cc", "end", "ct", "config", "d", "con", "f", "ci", "t", "r", "nc", "ac", "s", "m", "cp", "cache", "opt", "p", "cf", "mc", "xc", "enc", "o", "code", "comment", "cb", "ctx", "cn", "sc", "ch", "b", "dc", "cy", "channel", "cr", "n", "call", "loc", "C", "v", "cod", "l", "ec", "k", "count"], "cnt": ["cnd", "pcnn", "nNT", "nount", "Cnc", "ccnt", "ccint", "rcno", "ccNT", "ecnt", "nnt", " cnc", "CNT", "ecnc", "cNT", "Cint", "pcnt", "rcnt", "cint", "cno", "pcct", "cnc", "Count", "ecct", "nant", "cnn", "pcno", " cnn", " cNT", " cnd", "Cno", " cno", " count", "ccno", "cant", " cint", "Cnd", "cct", "rcNT", "Cct", "Cnt", "Cant", " cant", "rcnd", " cct", "ecno", "Cnn", "count"], "buf": ["bc", "port", "uf", "uc", "nat", "obj", "ref", "config", "text", "cv", "fb", "queue", "func", "pad", "home", "img", "Buff", "fp", "cas", "buffer", "alloc", "cmd", "box", "data", "socket", "bed", "cf", "runner", "np", "wb", "rc", "pool", "cb", "ctx", "aux", "b", "mem", "tmp", "seq", "ff", "fd", "fw", "br", "bd", "Buffer", "ab", "aka", "buff", "proc", "bag", "rb", "vec", "fam", "lit", "block", "bus", "fi", "prop"], "offset": ["i", "start", "end", "off", "ref", "config", "option", "part", "layout", "origin", "usage", "align", "fp", "offs", "pos", "info", "coord", "entry", "address", "data", "size", "enabled", "p", "ip", "number", "prefix", "count", "slot", "o", "np", "shift", "timeout", "url", "rot", "index", "num", "inet", "et", "set", "location", "online", "seq", "error", "Offset", "length", "loc", "len", "total", "slice", "append", "addr", "range", "reset", "alpha", "nt", "pointer", "sn", "gap", "position", "base", "output", "format", "padding", "type"], "nr_iov": ["nrJliv", "nrJio", "usr_dyl", "nerqeni", "nr_dyl", "yrqrolet", "nerqnr", "yrqilo", "nrqnr", "nrpilo", "yr_ilo", "nr_eni", "nr_io", "usr_iov", "yrqiov", "nerqiov", "ner_iov", "nrJnox", "nrjeni", "nerqnox", "nrJdyl", "nrjnox", "nrqeni", "yr_rolet", "yr_videos", "nrJnr", "nr_nr", "nrjnr", "nrjiov", "nrprolet", "nr_liv", "nrJeni", "ner_nr", "nr_nox", "usr_io", "nrqiov", "nr_ilo", "nrqnox", "nrJiov", "yr_iov", "nrqrolet", "nrqvideos", "nrpvideos", "nr_rolet", "nr_videos", "nrpiov", "ner_eni", "usr_liv", "ner_nox", "yrqvideos", "nrqilo"], "qiov": ["qiop", "quiov", "iqilo", "qiris", "wiov", "Qiop", "Qovi", "sqiris", "Qiov", "quivari", "qurolet", "idiris", "sqovi", "questilo", "wovi", "qrolet", "idliv", "qqiov", "quovi", "questovi", "questiov", "wiris", "iqrolet", "questnox", "sqiov", "iqiov", " qilo", "qliv", "qovi", "qnox", "dqliv", " qliv", "sqliv", " qiop", "qunox", "Qilo", "idiov", "dqiop", "qilo", "dqiov", "dqilo", "Qliv", "idovi", "qqrolet", "qqilo", "quilo", "qivari", "wliv", "qqivari", "Qnox", "iqivari"], "optind": ["optid", " optinn", " optid", "roport", "destInd", "varInd", "infoinc", "varinc", "optint", "ropInd", "optinc", "opInd", "parentInd", "optionInd", "destind", "opinc", "Optpos", "optimind", " optInd", "ropind", "infoind", "OptInd", " optpos", "optin", "optionin", "optpos", "destint", "optimInd", "optinn", "parentind", "optimin", "optionint", "parentinc", "Optinn", "optort", "optimort", "optioninc", "varinst", "optInd", "varind", "infoInd", "Optind", "opinst", "optionind", "optioninn", "infoinst", "Optid", "optionid", "parentinn", "optionpos", "opint", "optinst", "destinc", "ropin", "opind", "destinn", "optionort"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++) {\n\n        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n    }\n\n}\n", "idx": 20581, "substitutes": {"dst": ["datst", "Dst", "adsp", "sst", "fdst", "ssrc", "nsrc", "ssts", "fdset", "datput", "dsp", "datset", "rdput", "ldstr", "dsrc", "Ddest", "dbl", "nstr", " dstr", "ldput", " dbl", "dsl", "nst", "Dsrc", "ldst", "ddest", "sdbl", "dsts", "fdsts", "adput", "rdst", "adsl", "rdsrc", "rdsp", "adst", "sdst", "dset", "ldbl", "adsrc", "sdstr", "Dsts", "fdput", "datsts", " ddest", " dsts", " dsrc", "dput", "sdput", "adstr", " dput", " dsp", "nsl", "sdest", " dsl", "dstr"], "i": ["io", "lc", "uli", "e", "ix", "fi", "qi", "ind", "ri", "iii", "ui", "eni", "pi", "gi", "d", "uri", "ti", "I", "f", "ci", "t", "u", "adi", "ini", "oi", "phi", "j", "m", "info", "init", "p", "list", "abi", "id", "o", "bi", "c", "mu", "index", "source", "si", "a", "ii", "b", "in", "iu", "sup", "slice", "ai", "xi", "hi", "di", "v", "z", "yi", "li", "multi", "uni", "h", "api", "l", "x", "zi", "ni"]}}
{"project": "FFmpeg", "commit_id": "6fd00e9dd94ac3aecf4fa14ca6fa23c395215ac9", "target": 1, "func": "static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n\n                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],\n\n                      GetBitContext *gb)\n\n{\n\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;\n\n    int comment_len;\n\n\n\n    skip_bits(gb, 2);  // object_type\n\n\n\n    sampling_index = get_bits(gb, 4);\n\n    if (m4ac->sampling_index != sampling_index)\n\n        av_log(avctx, AV_LOG_WARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n\n\n\n    align_get_bits(gb);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n\n\n\n    skip_bits_long(gb, comment_len);\n\n    return 0;\n", "idx": 20600, "substitutes": {"avctx": ["avcot", "Avconnection", "avcv", "groundcontext", "groundcv", "avercv", "afctx", "avercontext", "groundctrl", "averctx", "navctx", "Avcontext", "navconnection", "averctrl", "Avcot", "avcontext", "groundctx", "afcot", "avconnection", "Avctx", "afcontext", "avctrl", "afcv", "afctrl", "navcot", "navcontext", "afconnection"], "m4ac": ["m4jac", "m8mac", "cmfourmac", "m04acc", "m4acc", "mfourmac", "mfourac", "mfourAC", "m8ac", "cmfouracc", "m104fac", "m4fac", "cm4acs", " m04ac", " m04jac", "m4mac", "m04ac", " m4jac", "mfourfac", "m104ac", "m8acs", "cm4acc", "cm4mac", "m04jac", "mfouracs", "m8acc", "m4AC", "m4acs", "cm4ac", "cmfourac", "m04AC", " m4AC", "m104jac", "m04acs", "m04fac", "m104AC", "m04mac", " m04AC", " m4fac", "mfouracc", "mfourjac", " m04fac", "cmfouracs"], "new_che_pos": ["new_pe_pos", "new_sche_pos", "new_che_cos", "new_cheadpos", "new_che___neg", "new_che_os", "new_ch_val", "new_che_val", "new_ch_pose", "new_ch_trans", "new_che___pos", "new_che___vis", "new_onge_pose", "new_che_neg", "new_chy_loc", "new_chy_pos", "new_onge_neg", "new_ch_cos", "new_sche_po", "new_che_tag", "new_ch_position", "new_cheadtag", "new_che_vis", "new_chy_po", "new_che_po", "new_pe_pose", "new_che_pose", "new_che__pos", "new_pe_pid", "old_\n", "new_che__neg", "new_che__pose", "new_ch_pos", "new_chy_tag", "new_ch_ass", "new_onge_pos", "new_cheadloc", "new_che_pid", "new_sche_set", "new_che_ass", "new_che_trans", "new_cheadpo", "new_onge_vis", "new_ch_loc", "new_pe_os", "new_che_loc", "new_che__vis", "new_che___pose", "new_sche_pose", "new_\n", "new_che_set", "new_che_position", "new_ch_neg"], "gb": ["gio", "bc", "sb", "binary", "lb", "gpu", "gt", "usb", "gram", "gal", "g", "gu", "ui", "db", "mb", "gnu", "gl", "gi", "bb", "og", "gin", "ged", "yg", "pc", "bridge", "gd", "pg", "Gb", "eb", "ga", "gow", "phy", "bg", "gru", "storage", "hd", "agg", "tg", "bn", "gy", "kb", "gg", "wb", "gz", "gae", "sg", "cfg", "gp", "b", "go", "bo", "hub", "gc", "bm", "ogg", "gh", "nb", "gs", "boot", "lib", "bf", "gam", "ko", "GB", "rb", "gm", "cgi", "ge", "abb", "rg"], "num_front": ["num_behind", "num_board", "num64fore", "sum_back", "dim_behind", "dim_fore", "num64front", "num_forward", "dim_back", "num__fore", "num__behind", "sum_front", " num_forward", "sum_fore", " num_board", "num__front", "num__back", "num64behind", "num64back", "num_fore", "sum_behind", "dim_front"], "num_side": ["num_sided", " num_server", "num\u00b7server", " num__front", "num_board", "sum_back", " num__back", "num__side", " num__server", "num2center", "num_center", "sum_center", "num__server", "num2side", "sum_sided", "sum_front", "sum_side", "num\u00b7side", "num\u00b7back", "num\u00b7front", "num__front", "num__back", "sum_board", "num2back", "num2sided", "num_server", " num__side"], "num_back": ["num68before", "num68bridge", "sum_back", "n67front", "n67side", "num_bottom", "n_back", "n_before", "num67before", "numjcross", "numedfront", "numedbridge", "n67before", "num68front", "num_cross", "num68bottom", "n_front", "sum_bridge", "numjback", "sum_front", "num68back", "num67back", "sum_side", "num67side", "numjside", "numedback", "sum_cross", "n_side", "sum_bottom", "num_before", "n67back", "numedbottom", "num67front", "num68side", "numjfront", "num_bridge"], "num_lfe": ["num_afe", "num_lafe", "num_alffe", "num_lale", "num_affleoe", "num_lae", "num_lfde", "num_lfc", "num_afea", "num_affe", "num_seqoe", "num_efde", "num_efea", "num_ffieldde", "num_ffielde", "num_lfle", "num_efe", "num_alfe", "num_seqee", "num_efc", "num_afc", "num_afee", "num_alfle", "num_seqe", "num_alfoe", "num_affleee", "num_affleeb", "num_afde", "num_lffe", "num_afflee", "num_laee", "num_afle", "num_alfee", "num_lfoe", "num_ffieldea", "num_lfeb", "num_lfee", "num_ffieldc", "num_alfeb", "num_lfea", "num_seqeb"], "num_assoc_data": ["num_assoc_only", "num_assocwdata", "num_assoc2only", "num_assoc2len", "num_association_data", "num_associ_data", "num_assocaldat", "num_assoc_dat", "num_assvoc2len", "num_associ_cache", "num_assoc2dat", "num_assocaldevices", "num_assvoc2only", "num_associ2cache", "num_assocaldata", "num_assoc_Data", "num_assvoc_only", "num_assoc2data", "num_assoc_len", "num_assoc2devices", "num_association_len", "num_assvoc2data", "num_associ_devices", "num_assvoc_len", "num_assoc_cache", "num_assocalcache", "num_associ2dat", "num_associ2devices", "num_associ_dat", "num_association_Data", "num_associ2data", "num_assocwonly", "num_assoc_devices", "num_assocwlen", "num_assvoc_data", "num_assoc2cache"], "num_cc": ["num_cs", "num_ff", "num_ce", "num67rc", "num_cca", "num_rc", "num67ff", "num54rc", " num67cc", " num67ff", "num67cc", " num67rc", "num67ce", " num_rc", " num67ce", " num_cca", " num_ck", "num54cc", "num_ck", " num_ce", " num_ff", " num_cs", "num54ce", "num54ff"], "sampling_index": ["sampling_id", "sampler_index", "sampping_ind", "sampling_list", "sampling67index", "sampler_field", "sampling_Index", "sampling67token", "sampled_ind", "sampling67size", "sampled_list", "sampling67ind", "sampling67base", "sampping_id", "sampled_index", "sampling_field", "sampler_size", "sampling_token", "sampling67field", "sampling_ind", "sampled_Index", "sampling67Index", "sampling_base", "sampling_size", "sampler_Index", "sampping_index"], "comment_len": [" byteaclen", " byte_long", " byteacval", " record_length", " byteaclength", " record_val", " byteaclong", " byte_length", " recordaclong", " record_len", " recordacval", " recordaclength", " byte_len", " record_long", " byte_val", " recordaclen"]}}
{"project": "FFmpeg", "commit_id": "5257743aee0c3982f0079e6553aabc6aa39401d2", "target": 1, "func": "static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,\n\n                               int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    WSSndContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n\n\n    int in_size, out_size, ret;\n\n    int sample = 128;\n\n    uint8_t *samples;\n\n    uint8_t *samples_end;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    out_size = AV_RL16(&buf[0]);\n\n    in_size  = AV_RL16(&buf[2]);\n\n    buf += 4;\n\n\n\n    if (in_size > buf_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame data is larger than input buffer\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* get output buffer */\n\n    s->frame.nb_samples = out_size;\n\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples     = s->frame.data[0];\n\n    samples_end = samples + out_size;\n\n\n\n    if (in_size == out_size) {\n\n        memcpy(samples, buf, out_size);\n\n        *got_frame_ptr   = 1;\n\n        *(AVFrame *)data = s->frame;\n\n        return buf_size;\n\n    }\n\n\n\n    while (samples < samples_end && buf - avpkt->data < buf_size) {\n\n        int code, smp, size;\n\n        uint8_t count;\n\n        code  = *buf >> 6;\n\n        count = *buf & 0x3F;\n\n        buf++;\n\n\n\n        /* make sure we don't write past the output buffer */\n\n        switch (code) {\n\n        case 0:  smp = 4;                              break;\n\n        case 1:  smp = 2;                              break;\n\n        case 2:  smp = (count & 0x20) ? 1 : count + 1; break;\n\n        default: smp = count + 1;                      break;\n\n        }\n\n        if (samples_end - samples < smp)\n\n            break;\n\n\n\n        /* make sure we don't read past the input buffer */\n\n        size = ((code == 2 && (count & 0x20)) || code == 3) ? 0 : count + 1;\n\n        if ((buf - avpkt->data) + size > buf_size)\n\n            break;\n\n\n\n        switch (code) {\n\n        case 0: /* ADPCM 2-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ( code       & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 2) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 4) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample +=  (code >> 6)        - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 1: /* ADPCM 4-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ws_adpcm_4bit[code & 0xF];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ws_adpcm_4bit[code >> 4];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 2: /* no compression */\n\n            if (count & 0x20) { /* big delta */\n\n                int8_t t;\n\n                t = count;\n\n                t <<= 3;\n\n                sample += t >> 3;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            } else { /* copy */\n\n                memcpy(samples, buf, smp);\n\n                samples += smp;\n\n                buf     += smp;\n\n                sample = buf[-1];\n\n            }\n\n            break;\n\n        default: /* run */\n\n            memset(samples, sample, smp);\n\n            samples += smp;\n\n        }\n\n    }\n\n\n\n    s->frame.nb_samples = samples - s->frame.data[0];\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = s->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20606, "substitutes": {"avctx": [" avctrl", "AVcf", "akctrl", "avecf", "avcot", "aflc", "auctrl", "afci", "AVcmp", "afcf", "afnp", "abcup", " avconfig", "avcca", "afcup", "afcmp", "avconfig", "avcup", "navcca", "aucontext", "afctx", "AVcontext", " avpkg", "avcf", "Avconfig", "AVnp", "abcf", "rafcontext", "avnp", "akcontext", "afpkg", " avcmp", "navctx", " avci", "Avcontext", "avlc", "avecontext", "akctx", "akcca", "aupkg", "avelc", "avcontext", "abctx", "avci", "AVlc", "avalctx", "Avci", "avalctrl", "avalcf", "afcot", "avalcca", " avnp", "afconfig", "avectx", "abcontext", "Avctx", "avcmp", "afcontext", "rafcca", "AVctx", "auctx", "avalcontext", "afcca", "avctrl", " avcontext", "avalcup", "rafcot", "rafctx", "afctrl", "navcot", "navcontext", "avpkg"], "data": ["bc", "shape", "start", "def", "response", "next", "config", "result", "input", "wa", "map", "message", "Data", "connection", "queue", "d", "extra", "rec", "bytes", "bin", "meta", "device", "f", "buffer", "devices", "ata", "split", "info", "m", "da", "cache", "head", "final", "p", "list", "version", "last", "body", "open", "memory", "header", "content", "frame", "module", "a", "window", "DATA", "w", "blocks", "to", "channel", "media", "reader", "slice", "call", "batch", "parent", "buff", "v", "reset", "dat", "image", "empty", "block", "offset", "output", "video"], "got_frame_ptr": ["got_frame_len", "got_frames_addr", "got_frame_pointer", "got_frames_tr", "got_frame_buf", "got_frame_addr", "got_frames_ptr", "got_frame_tr", "got_frames_pointer"], "avpkt": ["avtopnt", "avppKT", "abpacket", "abvpka", "avvpnt", "avckt", "avtopkt", "affKT", "abpct", "avpeth", "avppeth", "afpKT", "avtopka", "abvpKT", "abvpkt", "avcct", "avpent", "afpiece", "affct", "afpct", "avfiece", "avhut", "affiece", "abpka", "avvpKT", "avPkt", "avpiece", "avppkt", "avtopKT", "abput", "avfKT", "avcpiece", "avpka", "avPacket", "abcct", "avhkt", "abpkt", "avpekt", "abcacket", "avhacket", "avvpeth", "avppacket", "avpeka", "afpeth", "avvpacket", "avfut", "afpkt", "avcacket", "afpacket", "avPct", "avpnt", "abvpnt", "abpnt", "abcut", "avpKT", "avhct", "avfkt", "avcpkt", "avcut", "abckt", "avPiece", "avfct", "avpct", "avfacket", "affacket", "avfeth", "avput", "affkt", "avvpka", "avpeKT", "avvpkt", "affeth", "avcpct", "avcpacket", "abpKT", "avpacket"], "s": ["i", "e", "sym", "space", "qs", "bis", "es", "fs", "g", "ses", "d", "ops", "as", "ks", "ds", "services", "l", "f", "sys", "m", "args", "its", "ssl", "os", "p", "cs", "ts", "ls", "sync", "is", "sa", "sg", "c", "js", "spec", "si", "a", "b", "in", "aws", "service", "session", "S", "src", "ns", "ps", "ins", "gs", "rs", "v", "conf", "bs", "h", "su", "sq"], "buf": ["bc", "row", "off", "cube", "pad", "wave", "buffer", "pos", "alloc", "cat", "que", "wb", "pool", "header", "window", "bo", "raw", "ff", "src", "br", "bd", "comb", "ab", "batch", "proc", "v", "rb", "fam", "fi", "feat", "cap", "ru", "uf", "cv", "ctr", "bb", "ef", "bu", "coord", "rc", "cb", "lim", "bh", "bag", "vec", "prop", "uc", "brace", "result", "fb", "queue", "func", "img", "cas", "f", "band", "cmd", "box", "p", "cf", "tc", "bi", "num", "b", "tmp", "fd", "length", "callback", "buff", "h", "pb", "port", "ha", "loop", "cur", "cache", "ctx", "frame", "aux", "seq", "auc", "len", "border", "block"], "in_size": ["buf_size", "in_storage", " in_ize", " in64size", "in_range", "in_loc", "in64offset", "in67Size", "in64size", "in33scale", " in_Size", "in_large", "vin_loc", "in64Size", " in_range", "vin_large", "in33Size", "in_ize", "in67range", " in_storage", " in64storage", "in64ize", "inqsize", "buf_scale", "buf_offset", "in_offset", " in64ize", "in67size", "vin_ize", "inqstorage", "in_member", "in_scale", "in33offset", "vin_size", "inqize", " in_member", "in67member", "in64storage", "buf_Size", "in64scale", "in_Size", "in33size"], "out_size": ["outmaxchannel", "buf_size", "config_data", " out_scale", "out_small", "out_shape", "out_pos", " inmaxsize", "out_channel", " in_shape", "config_size", "out_count", "outlextime", "boxlexsize", "outlexscale", "out_data", "boxlexlarge", "outksmall", "out_core", "outlexlarge", "out_len", " out_len", "out_large", " out_core", "box_scale", "outkcount", "boxlexscale", " out_storage", "config_small", "outkdata", " inmaxshape", "out_storage", "box_time", "buf_scale", "outksize", "boxlextime", "box_size", "config_count", "configksmall", "outmaxtime", " inmaxtime", "configkdata", "box_large", "configkcount", "outmaxshape", "out_time", " in_time", "configksize", " inmaxchannel", "out_scale", "outmaxsize", "outlexsize", " out_capacity", "buf_pos", "buf_storage", " in_channel", "out_capacity"], "ret": ["status", "reg", "ru", "red", "def", "en", "obj", "err", "ref", "valid", "result", "val", "det", "rep", "rec", "temp", "Ret", "cur", "f", "bad", "r", "info", "res", "rets", "fin", "arr", "success", "rc", "ext", "out", "match", "RET", "rt", "mem", "value", "flag", "tmp", "reply", "rev", "re", "error", "len", "iter", "alt", "nt", "lit", "resp", "fun"], "samples": ["seamps", "usamps", "specamps", "ssources", "Sums", "sample", "nample", "nannels", "ssims", "sims", "specims", "ssmp", "Smp", "outsample", "ssamples", " sages", "gamples", "pamps", " samps", "seample", "namples", "namps", "outsamples", "outsamps", "Sources", "pamples", "sums", "samps", "seamples", "usamples", "ssamps", "Samples", "semp", "simages", "sources", "outsources", "ssample", "specamples", "sages", "usums", "gages", " sums", "specimages", "Samps", "Sannels", "gamps", "Sample", "usages", "sannels", "Sages", "pages", "ssimages", "seannels"], "samples_end": ["sipes_ends", "samples_limit", "samples_max", "samp_end", "sample_end", "sample_length", "samples_start", "samples_ended", "samp_start", "samples___start", "samples_length", "samples___ends", "samps_start", "samples___end", "sample_start", "sipes_end", "samp_ended", "samps_end", "samps_ends", "sipes_start", "sipes_max", "samples_ends", "sample_limit"], "code": ["status", "name", "cc", "err", "message", "mode", "key", "charge", "f", "cmp", "catch", "codes", "cache", "state", "zip", "cat", "cycle", "change", "id", "que", "number", "c", "cb", "index", "num", "tag", "comp", "Code", "line", "flag", "seq", "error", "desc", "call", "length", "loc", "test", "co", "ce", "cod", "type"], "smp": ["Syp", " syp", " sape", "sMP", "pmp", "gsps", "smb", "Smp", "pMP", "spp", "usmp", " sme", "Smb", "gsmb", "syp", "cmp", "cmb", " sMP", "sesamp", "Smm", " smm", " sdc", "sesyp", "usamp", "srape", "cape", " smb", "pdc", "smm", "usomew", "somew", "sdc", "supp", "Supp", "sme", " supp", " spp", " sps", "Samp", "SMP", "uspp", "gsrape", " samp", " srape", "sesmp", "cme", "sesMP", "sps", " somew", "samp", "gsmp", "pamp", "sape"], "size": ["name", "shape", "area", "en", "esc", "end", "send", "scale", "g", "age", "time", "sized", "mode", "extra", "Size", "engine", "ize", "type", "weight", "buffer", "address", "cache", "storage", "sum", "unit", "body", "gz", "shift", "content", "c", "small", "sea", "capacity", "si", "speed", "channel", "length", "len", "loc", "large", "global", "SIZE", "sec", "empty", "offset", "max", "cap"], "count": ["col", "found", "name", "cc", "class", "start", "age", "coll", "val", "map", "cond", "process", " counts", "cur", "weight", "f", "buffer", "catch", "info", "Count", "cache", "cat", "zip", "list", "sum", "current", "id", "number", "depth", "last", "comment", "content", "c", "index", "num", "match", "low", "comp", "flag", "counter", "seq", "error", "length", "child", "call", "len", "test", "loc", "large", "parent", "cod", "empty", "all", "base", "max", "type"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n\n                                     const int16_t *hLumFilter,\n\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n\n                                     uint8_t *formatConvBuffer,\n\n                                     uint32_t *pal, int isAlpha)\n\n{\n\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n\n\n\n    if (toYV12) {\n\n        toYV12(formatConvBuffer, src, srcW, pal);\n\n        src= formatConvBuffer;\n\n    } else if (c->readLumPlanar && !isAlpha) {\n\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n\n        src = formatConvBuffer;\n\n    }\n\n\n\n    if (!c->hyscale_fast) {\n\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n\n    }\n\n\n\n    if (convertRange)\n\n        convertRange(dst, dstWidth);\n\n}\n", "idx": 20613, "substitutes": {"c": ["lc", "bc", "fc", "e", "cc", "uc", "conn", "ct", "config", "g", "this", "coll", "com", "unc", "cm", "d", "con", "ca", "pc", "cur", "cl", "cu", "f", "ci", "can", "t", "u", "ac", "m", "s", "nc", "cp", "r", "oc", "p", "mc", "cs", "enc", "cf", "tc", "context", "ctrl", "xc", "rc", "ctx", "ch", "sc", "comp", "b", "dc", "w", "cpp", "ic", "cy", "gc", "core", "n", "cr", "call", "C", "co", "v", "ce", "conf", "h", "cit", "l", "ec", "k", "vc"], "dst": ["Dst", "adsc", "ldda", " dST", "sdsth", "dsc", "isdst", "tdsrc", " dsc", "dST", "dsrc", "idst", "dsl", "isdsc", "adest", "Dsrc", "sdST", "ldst", "tdsth", "isdST", "dsts", "idsc", "sdsc", "Dsth", " dsth", " dest", "bdst", "isdsth", "adst", "adsts", "dda", "sdst", "bdsl", "tdst", "tdsts", "Dsts", "bdsc", " dsts", "dsth", " dsrc", "idsts", "dest", "ldsl", " dda", "idest", "bdda", "ldsc", " dsl"], "dstWidth": [" dstLength", "drcHeight", "dSTwidth", "dgestwidth", " dstwidth", " dSTLength", "dSTExp", "drcwidth", " dSTHeight", "destwidth", "dscWidth", "dgestHeight", "dstswidth", "DstLength", "dgestPath", "destWidth", "DSTLength", "dstwidth", " dSTWidth", "dSTHeight", " dstPath", "dstExp", "dscHeight", "dstHeight", " dscExp", " dscwidth", "dgestWidth", " dstExp", "dscwidth", "DstWidth", "dstsHeight", "dscExp", " dscHeight", "dirstExp", "dStLength", "dSTWidth", "dStWidth", "dstLength", "dSTLength", "dSTPath", "dscPath", "dstPath", "dStwidth", "DSTwidth", "dstsLength", "drcWidth", "dirstWidth", "destLength", "Dstwidth", " dstHeight", "DSTWidth", "DSTHeight", "DstHeight", "dirstHeight", "dStHeight", "destHeight", "drcLength", " dSTwidth", " dscWidth", " dscPath", "dstsWidth", "dirstwidth"], "src_in": ["loc_ins", "src2inc", " src_inc", "loc_inn", "rc_ins", "src_ins", "loc_out", "src2in", "src_out", "src_inn", " src_out", "rc_in", "rc_again", "src_again", "src_inc", "src2out", "loc_in"], "srcW": ["locw", "instW", "locV", " srcH", "instw", " srcWidth", "instH", "srcWidth", "rcL", "sourceW", "instV", "srcL", "instL", "rcWidth", "srcw", "locW", "srcV", " srcV", " srcw", "sourceL", "rcV", "locWidth", "sourceV", "rcH", "rcw", "sourcew", " srcL", "srcH", "rcW"], "xInc": ["xaInc", "xinc", "XInc", "xiInc", " xIncre", "xiinc", "xainc", " xINC", "Xinc", "xiINC", "xaINC", "xiAdd", " xAdd", "xaIncre", "xINC", "XIncre", "xIncre", "xAdd", "XAdd", " xinc", "XINC"], "hLumFilter": ["hLUMMask", "hPlumF", "hElUMMask", "hElUMLayer", "hElumFilter", "hLoughFilter", "hElumMask", "hLUMF", "hLumberF", "hLamFilter", "hLoughFrame", "hPlUMTarget", "hPlumMask", "hElUMFrame", "hPlumTarget", "hElumFrame", "hLUMFrame", "hLoughLayer", "hLumFrame", "hLUMTarget", "hLamF", "hLumberMask", "hPlUMFilter", "hLumTarget", "hLoughMask", "hElUMFilter", "hLUMLayer", "hLumLayer", "hElumLayer", "hLamTarget", "hLUMFilter", "hLamFrame", "hPlumFilter", "hLamMask", "hLumMask", "hLamLayer", "hPlUMMask", "hLumberFilter", "hLumberTarget", "hPlUMF", "hLumF"], "hLumFilterPos": ["hLumFSize", "hLumBufferPos", "hLUMFilterRel", "hLumFilterDef", "hLumFileDef", "hLumGroupRes", "hLUMFPos", "hLumGroupRel", "hLumFilePosition", "hLumbFPos", "hLumFilterRes", "hLumFilterPosition", "hLUMFilterPosition", "hLumBufferRes", "hLumFDef", "hLumbFilterDef", "hLUMFRel", "hLumbFSize", "hLumbFilterPos", "hLumbFilterSize", "hLumBufferSize", "hLumFRel", "hLUMFPosition", "hLumGroupPosition", "hLumGroupPos", "hLumbFilterPosition", "hLumBufferRel", "hLUMFilterRes", "hLumFilterRel", "hLumFileSize", "hLumFPosition", "hLUMFilterPos", "hLumbFPosition", "hLumBufferPosition", "hLumbFDef", "hLumBufferDef", "hLumFPos", "hLUMFRes", "hLumFilePos", "hLumFRes"], "hLumFilterSize": ["hLumFSize", "hLumLimitOffset", "hLumMaskCount", "hLumBufferPos", "hLumBlockLen", "hLUMFilterSize", "hLumBufferStyle", "hLUMFStyle", "hLUMFPos", "hLumBufferLen", "hLumFilterStyle", "hLumbBufferSize", "hLumMaskSize", "hLumFStyle", "hLumBufferCount", "hLumFOffset", "hLumLimitPos", "hLumbBufferCount", "hLumBufferOffset", "hLumFilterCount", "hLumbFilterPos", "hLumbFilterCount", "hLumbFilterSize", "hLumBufferSize", "hLumLimitSize", "hLumBlockSize", "hLumbBufferLen", "hLumMaskPos", "hLumbFilterLen", "hLumbBufferPos", "hLUMFilterPos", "hLUMFSize", "hLumFilterLen", "hLUMFOffset", "hLumMaskLen", "hLUMFilterOffset", "hLumLimitStyle", "hLUMFilterStyle", "hLumFPos", "hLumFilterOffset", "hLumBlockPos", "hLumBlockCount"], "formatConvBuffer": ["formatConVBuff", "formatEnVBuffer", "formatConvBegin", "formatConvertBar", "formatEnVReader", "formatConvCache", "formatConvPtr", "formatConVPtr", "formatConVBuffer", "formatEnfbuffer", "formatConvertSource", "formatConventionBuffer", "formatEnfFile", "formatConvReader", "formatConvertReader", "formatConventionbuffer", "formatConvertBuffer", "formatEnvBegin", "formatConfBuffer", "formatEnvReader", "formatConvertBuff", "formatEnvBar", "formatConvtFile", "formatEnvFile", "formatConVBar", "formatConVFile", "formatEnfBar", "formatConfbuffer", "formatConfFile", "formatEnfBuffer", "formatConvBar", "formatConvpCache", "formatConfCache", "formatConVBegin", "formatConuvPtr", "formatEnvCache", "formatConuvBuff", "formatConVCache", "formatConvSource", "formatEnfSource", "formatConvBuff", "formatConVSource", "formatConvpBuffer", "formatEnVBegin", "formatConVReader", "formatConVbuffer", "formatConfBegin", "formatConvtBuffer", "formatConfBuff", "formatConvertbuffer", "formatEnfBuff", "formatEnvbuffer", "formatConvtbuffer", "formatConvtBuff", "formatConuvBuffer", "formatConuvBegin", "formatConfBar", "formatConfSource", "formatEnVBuff", "formatEnVPtr", "formatEnvPtr", "formatConventionBuff", "formatEnVBar", "formatConvbuffer", "formatConvpBuff", "formatConfPtr", "formatConventionReader", "formatConvpBar", "formatConvFile", "formatEnvBuffer", "formatEnVCache", "formatEnvBuff", "formatEnVbuffer", "formatEnvSource"], "pal": ["app", "scale", "Pal", "val", "bin", "align", "pad", "bl", "as", "local", "pixel", "cell", "al", "cache", "rel", "pp", "p", "opal", "ace", "pl", "ar", "cal", "real", " Pal", "face", "alias", "ass", "plan", "ab", "cale", "conf", "alpha", "li", "isal", "pack"], "isAlpha": ["isalpha", "hasAlpha", "ISAlias", "Isalpha", "hasalpha", " isRa", "areRa", "ISFace", "arealpha", " isalpha", "isaalpha", "areAlias", "hasBeta", "areFace", "IsAlias", " isDelta", "ISAlpha", "IsDelta", "areAlpha", "isAlias", "IsAlpha", " isFace", "isaRa", " isBeta", "hasDelta", "isRa", "isBeta", "isFace", " isAlias", "IsBeta", "isaAlpha", "isaAlias", "ISalpha", "isDelta", "ISBeta"], "toYV12": ["toXv14", "toYF12", "toYv15", "toXV6", "toYYV15", "toYH12", "toYX13", "toYv14", "toYV20", "toYv52", "toYYH13", "toXV12", "toYGV12", "toYX52", "toYv11", "toYYV13", "toYN13", "toYV11", "toXv6", "toYV13", "toYN12", "toYYH15", "toXv13", "toXv12", "toXv11", "toYYV52", "toYv6", "toYX12", "toYYH12", "toYV14", "toYGV6", "toYYH52", "toYGV20", "toYv20", "toYF13", "toYM11", "toYF20", "toYF6", "toYH52", "toXV20", "toYX15", "toYv12", "toYV52", "toYM12", "toYM13", "toYV6", "toYGV13", "toYv13", "toXV11", "toYN14", "toYV15", "toYH15", "toYN11", "toYH13", "toXV14", "toXV13", "toXv20", "toYYV12", "toYM14"], "convertRange": ["Converrange", "convertingrange", "conversionRGB", "ConverRing", "ConvertRing", "pervertedRange", "ConversionRange", "convertingRing", "pervertedrange", "pervertFrame", "convertedrange", "converResource", "conversionRegion", "conpectRange", "convertingRGB", "conformatrange", "convertingRange", "Conversionrange", "convertRing", "conversionRange", "convertedRange", "convertFrame", "ConvertResource", "convertRegion", "conformatRange", "conversionFrame", "conversionrange", "convertrange", "conformatRegion", "pervertRegion", "convertedFrame", "converRing", "conpectRGB", "converrange", "ConversionRGB", "pervertedRegion", "ConvertRange", "pervertRange", "converRange", "pervertrange", "conpectrange", "convertedRegion", "convertRGB", "ConverResource", "convertResource", "pervertedFrame", "ConvertRGB", "conformatFrame", "Convertrange", "ConverRange", "convertingResource"], "src": ["bc", "sb", "fc", "sel", "uc", "support", "config", "sl", "asc", "gl", "impl", "uri", "func", "rin", "rect", "img", "scl", "gb", "secure", "sys", "rob", "stat", "ssl", "sit", "sync", "rc", "cb", "ctx", "supp", "source", "sq", "sc", "comp", "rl", "sub", "sr", "usr", "sur", "inst", "sup", "loc", "rss", "rs", "proc", "st", "lib", "sid", "dest", "rb", "stream", "sn", "href", "feat", "attr", "url", "rg"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */\n\n                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n", "idx": 20617, "substitutes": {"av_flatten": ["av_fl_", "av_flatt", "av_ff_", "av2flip", "av_ffip", "av_fratten", "av2frip", "av2fratt", "av_ffatt", "av_frip", "av_flip", "av2flatten", "av_fip", "av_fr_", "av2fratten", "av2fr_", "av_ffatten", "av_fatt", "av_f_", "av2fl_", "av_fratt", "av2flatt", "av_fatten"], "pix": ["Pix", "spixel", " pip", "spix", "bixel", "npixel", "perix", "spius", "spirm", "pIX", "pox", "fIX", "vix", "picks", "ipix", "pericks", "cix", "npip", "plex", " picks", "fius", "vlex", "perinch", "vx", "spixels", "cox", "cIX", "npox", "spIX", "pip", "ipx", "cixels", " pixels", "pixel", "Pox", " pirm", "Pixels", "tixels", " plex", " pinch", "pius", "spox", "Pip", "PIX", "tix", " px", "tirm", "fox", "fix", "vip", "px", "Pixel", "ipicks", "pinch", " pox", "npix", " pius", "bix", "iplex", "bixels", "fixels", " pixel", "tius", " pIX", "ipip", "pixels", "fixel", "spip", "bip", "perx", "ipinch", "pirm"], "xstride": ["xdecide", "xbrider", "xdecride", "xstrid", "ystrid", "xptide", "xstrice", "ystided", "XStrided", "xbrride", "xdivides", "xcollider", "xdivided", "Xstrided", "ystider", "xdecider", "Xstride", "Xstrides", "xStrider", "XStrides", "Xstrider", "xbrides", "xSTRided", "xstrider", "xStrides", "xStrid", "xStrride", "xbride", "ystrice", "xstid", "xstice", "xcollide", "xstrided", "XStrider", "ystide", "xptride", "xSTRride", "xSTRide", "xStrice", "xStride", "xcollided", "xstided", "XStride", "ystrided", "ystrride", "xstider", "xstrride", "xdivide", "xptice", "ystice", "xStrided", "xSTRid", "ystid", "ystrider", "xstide", "xdivider", "xdecided", "xcollride", "xstrides", "xbrided", "xptided"], "ystride": ["ystided", "xstrapse", "yStrider", "yvariride", "ystrapse", "ystider", "ydrides", "yetrides", "ystaider", "ystaide", "ystaided", "xstrider", "ystapse", "ycollide", "xstides", "yStrides", "ycollider", "yStride", "xstrided", "ystide", "ystides", "ycollride", "yetride", "ystrides", "xstided", "ystrided", "ystrride", "xstrride", "yvariide", "xstapse", "ystaides", "yetrider", "ystrider", "xstide", "ydrided", "ycollapse", "ydride", "yStrided", "ydrider", "yvariapse", "xstrides", "xstider", "yetrided", "yvariider"], "alpha": ["ima", "phase", "area", "amp", "scale", "asc", "acl", "inc", "A", "ca", "as", "zero", "phi", "ac", "acc", "u", "size", "r", "igma", "p", "abi", "la", "mu", "rc", "audio", "filter", "lambda", "si", "a", "b", "ta", "aa", "ma", "\u03b1", "offset", "Beta", "sum", "Alpha"], "beta": ["bc", "phase", "ba", "scale", "budget", "pha", "\u03b2", "margin", "bb", "A", "ca", "pad", "zero", "phi", "ac", "acc", "size", "da", "igma", "appa", "abi", "tc", "la", "mu", "negative", "lambda", "si", "a", "b", "ta", "ii", "x", "error", "qa", "aa", "base", "radius", "\u03b1", "offset", "Beta", "pa", "sum", "Alpha"], "tc0": ["TC8", "tc6", "lc6", "lc8", "cu2", "TC6", "uc0", "ec8", "uc8", "tc8", "TC2", "tc2", "cu6", "cu0", "cu8", "ec0", "TC0", "lc2", "lc0"], "i": ["io", "e", "ix", "ie", "fi", "qi", "ri", "ui", "pi", "gi", "chi", "ti", "I", "f", "ci", "y", "u", "r", "m", "ini", "it", "j", "oi", "info", "p", "ip", "id", "o", "bi", "vi", "is", "mi", "c", "mu", "index", "si", "b", "ii", "ji", "n", "iu", "ai", "xi", "di", "v", "yi", "li", "l", "x", "zi", "k", "ni"], "d": ["md", "e", "cd", "ct", "ind", "g", "dh", "ds", "ld", "f", "dn", "df", "t", "u", "m", "s", "da", "dd", "data", "j", "ad", "nd", "p", "diff", "id", "dy", "c", "dx", "dom", "dt", "du", "x", "dc", "dq", "dim", "w", "dm", "b", "dl", "n", "fd", "bd", "D", "z", "v", "dat", "l", "dp", "k"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "int ff_mpeg4_decode_picture_header(MpegEncContext * s, GetBitContext *gb)\n\n{\n\n    int startcode, v;\n\n\n\n    /* search next start code */\n\n    align_get_bits(gb);\n\n    startcode = 0xff;\n\n    for(;;) {\n\n        v = get_bits(gb, 8);\n\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        \n\n        if(get_bits_count(gb) >= gb->size*8){\n\n            if(gb->size==1 && s->divx_version){\n\n                printf(\"frame skip %d\\n\", gb->size);\n\n                return FRAME_SKIPED; //divx bug\n\n            }else\n\n                return -1; //end of stream\n\n        }\n\n\n\n        if((startcode&0xFFFFFF00) != 0x100)\n\n            continue; //no startcode\n\n        \n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            printf(\"startcode: %3X \", startcode);\n\n            if     (startcode<=0x11F) printf(\"Video Object Start\");\n\n            else if(startcode<=0x12F) printf(\"Video Object Layer Start\");\n\n            else if(startcode<=0x13F) printf(\"Reserved\");\n\n            else if(startcode<=0x15F) printf(\"FGS bp start\");\n\n            else if(startcode<=0x1AF) printf(\"Reserved\");\n\n            else if(startcode==0x1B0) printf(\"Visual Object Seq Start\");\n\n            else if(startcode==0x1B1) printf(\"Visual Object Seq End\");\n\n            else if(startcode==0x1B2) printf(\"User Data\");\n\n            else if(startcode==0x1B3) printf(\"Group of VOP start\");\n\n            else if(startcode==0x1B4) printf(\"Video Session Error\");\n\n            else if(startcode==0x1B5) printf(\"Visual Object Start\");\n\n            else if(startcode==0x1B6) printf(\"Video Object Plane start\");\n\n            else if(startcode==0x1B7) printf(\"slice start\");\n\n            else if(startcode==0x1B8) printf(\"extension start\");\n\n            else if(startcode==0x1B9) printf(\"fgs start\");\n\n            else if(startcode==0x1BA) printf(\"FBA Object start\");\n\n            else if(startcode==0x1BB) printf(\"FBA Object Plane start\");\n\n            else if(startcode==0x1BC) printf(\"Mesh Object start\");\n\n            else if(startcode==0x1BD) printf(\"Mesh Object Plane start\");\n\n            else if(startcode==0x1BE) printf(\"Still Textutre Object start\");\n\n            else if(startcode==0x1BF) printf(\"Textutre Spatial Layer start\");\n\n            else if(startcode==0x1C0) printf(\"Textutre SNR Layer start\");\n\n            else if(startcode==0x1C1) printf(\"Textutre Tile start\");\n\n            else if(startcode==0x1C2) printf(\"Textutre Shape Layer start\");\n\n            else if(startcode==0x1C3) printf(\"stuffing start\");\n\n            else if(startcode<=0x1C5) printf(\"reserved\");\n\n            else if(startcode<=0x1FF) printf(\"System start\");\n\n            printf(\" at %d\\n\", get_bits_count(gb));\n\n        }\n\n\n\n        switch(startcode){\n\n        case 0x120:\n\n            decode_vol_header(s, gb);\n\n            break;\n\n        case USER_DATA_STARTCODE:\n\n            decode_user_data(s, gb);\n\n            break;\n\n        case GOP_STARTCODE:\n\n            mpeg4_decode_gop_header(s, gb);\n\n            break;\n\n        case VOP_STARTCODE:\n\n            return decode_vop_header(s, gb);\n\n        default:\n\n            break;\n\n        }\n\n\n\n        align_get_bits(gb);\n\n        startcode = 0xff;\n\n    }\n\n}\n", "idx": 20618, "substitutes": {"s": ["ions", "sim", "sv", "sb", "e", "qs", "space", "sci", "sl", "fs", "g", "ses", "rates", "d", "ops", "ks", "so", "ds", "f", "sys", "m", "storage", "ssl", "os", "ts", "cs", "sync", "ss", "sa", "sg", "c", "js", "self", "spec", "ctx", "sm", "si", "sc", "b", "aws", "service", "se", "session", "S", "ns", "n", "sf", "ps", "gs", "http", "conf", "server", "su", "sq"], "gb": ["gio", "bc", "pb", "sb", "usb", "sl", "g", "ui", "mb", "db", "gi", "fb", "bb", "gin", "bp", "bridge", "img", "pc", "gd", "buffer", "pg", "ga", "eb", "bg", "storage", "tg", "fx", "bn", "gy", "kb", "gg", "py", "gz", "sg", "ges", "cb", "ctx", "cfg", "gp", "b", "hub", "gc", "src", "bm", "jpg", "nb", "gs", "buff", "bf", "gam", "GB", "rb", "gm", "cod", "ge", "cgi", "abb", "rg"], "startcode": ["playcode", " startcall", "addcode", "stepscore", "trycode", "idstart", "artcase", "skystate", "stopframe", "endcode", "artcod", "writecod", "stepstart", "stopce", "startcreate", " startdesc", "stepcue", "usecue", "endscore", "frontstate", "lookfe", "startCode", "initCode", "initcount", "startcall", "trycod", "idcount", "startstart", "trystart", "cellcell", "typecode", "cellcode", "stopcoded", "startcount", "frontcomp", "opencod", "checkcell", " startcheck", "startcell", "checkce", " starterror", "addcall", "newcod", " startscore", "useclass", "cellcomplete", " startframe", "trycheck", " startcell", "bootcodes", "endcount", "lookcod", "frontdesc", "startstate", "startscore", "initpage", " startcase", "artstart", "writecode", "initcode", "gradeCode", "startce", "pickcodes", " startcount", "fillcode", "newcode", "starterror", "usecode", "initerror", "startcodes", "startclass", "stopstate", "stopcomp", "playcolor", " startce", "gradecase", "workcode", "pickstate", " startstart", "addback", "launchstate", "skyframe", "startcase", "artcell", "launchcod", "endCode", " startc", "frontclass", "bootval", "startcatch", "startingcolor", "startdesc", "statcod", " startcomplete", " startcatch", "fillcodes", "gradehide", "idcod", "opencue", " startsequence", "frontcode", "startback", "initcoded", "statcall", "idCode", "lookcode", "idcodes", " startcoded", "startframe", "writestart", " startpage", "idval", "startsequence", "showfore", "stopcell", " startfore", "workcatch", " startclass", "startcheck", "initcod", "idcode", "stopcod", " startcodes", "lookdesc", "frontframe", "launchcreate", "startingback", "endcod", "bootc", "addcell", "stopc", "addcomplete", "gradecode", "writecheck", "frontstart", " starthide", "startcue", "lookframe", "stepcode", "stopstart", "showcode", "stopclass", "bootsequence", " startfe", "workfore", "openframe", "usestart", "addstart", "fillcod", " startcomp", "lookcall", "fillcount", "launchcode", "playcod", "skycod", "pickerror", "pickcreate", "startval", "showcod", "frontcod", "playback", "newcolor", " startstate", "workcod", "pickval", "initstart", "startfe", "showcatch", "stopCode", "bootcode", "startcoded", "pickCode", " startCode", "endcodes", "artCode", " startcod", "checkcode", "stepcount", "idback", "startpage", "stepcod", "stopsequence", "typeframe", "usecod", "stepcell", "openstate", "startcomp", "opencode", "startfore", "stopcode", "stepCode", "useCode", "bootstate", "addcod", "pickpage", "typestate", "pickcod", "frontcreate", "startcolor", "bootCode", "pickcode", "statfe", "statcode", "starthide", "openCode", "lookstart", "stopcall", " startback", "frontCode", "startingcod", "checkcall", "arthide", "artcode", "typestart", "startc", "cellcall", "skycode", "startcod", "startcomplete", "newback", "startingcode", "pickstart"], "v": ["tv", "sv", "i", "e", "V", "vt", "lv", "g", "val", "d", "vd", "vg", "f", "t", "u", "r", "m", "j", "p", "version", "uv", "vs", "vi", "count", "q", "o", "b", "w", "n", "vv", "va", "ve", "z", "vp", "h", "l", "x", "k", "value"]}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n    const uint8_t *buf_start= buf;\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1) * 2;\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        s->repeat_pict = 1;\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 5;\n\n                                else\n\n                                    s->repeat_pict = 3;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 2;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}\n", "idx": 20620, "substitutes": {"s": ["sv", "sim", "sb", "e", "qs", "bis", "sl", "hs", "g", "ses", "private", "sets", "ks", "services", "f", "sys", "t", "r", "u", "m", "socket", "ssl", "os", "p", "cs", "ts", "ls", "sync", "ss", "stats", "sg", "c", "ctx", "self", "spec", "client", "sa", "js", "si", "sc", "b", "service", "aws", "session", "S", "parser", "ps", "rs", "gs", "v", "conf", "sec", "http", "h", "server", "su", "sq", "acs"], "avctx": ["AVkb", "avalmac", "aveca", "capconn", "avecas", "awcontext", "akcmd", "afca", "awutils", "AVcas", "auutils", "avconn", "capcontext", "averkb", "afcmd", "aucontext", "akloc", "AVcontext", "afctx", "avercontext", "avutils", "aubc", "AVca", "awbc", "avcas", "afutils", "avca", "afloc", "akcontext", "awcas", "averutils", "averctx", "navctx", "akctx", "afmac", "avecontext", "awctx", "avbc", "avcontext", "afbc", " avutils", "AVutils", "capctx", "avalctx", "navcmd", " avconn", "awca", "avalconn", " avkb", "avectx", "avcmd", "afcontext", "AVctx", "auctx", "afconn", "avalcontext", " avca", " avcontext", "navcontext", "avmac", "navloc", "aveconn", "capmac", "avkb", "avloc"], "buf": ["begin", "bc", "off", "config", "buffer", "pos", "alloc", "exc", "data", "wb", "header", "bo", "ff", "src", "fw", "comb", "br", "bd", "ab", "batch", "v", "rb", "fam", "feat", "cap", "fab", "uf", "binary", "end", "text", "db", "cv", "ctr", "bb", "fp", "bu", "coord", "rc", "cb", "lim", "hub", "bh", "vec", "bag", "offset", "su", "conv", "uc", "ba", "fb", "queue", "func", "ffff", "Buff", "img", "cas", "xff", "f", "cmd", "box", "cf", "bn", "num", "b", "uu", "usr", "fd", "length", "loc", "Buffer", "buff", "bf", "orig", "gb", "count", "BU", "pb", "port", "loop", "ha", "home", "cur", "uber", "grab", "ctx", "aux", "seq", "auc", "len", "border", "block", "max"], "buf_size": ["buf_num", "bufallend", "bufdend", "buf_scale", "bufallsize", "bufallnum", "buffer_size", "buffer_num", "bufallsh", "buflexsource", "bufdsize", "buf_source", "buffer_end", "buffer_sh", "buflexsize", " buf_scale", " buf_source", "buflexend", "buflexscale", "bufdnum", "buf_sh", "bufdsh"], "pc": ["lc", "bc", "pb", "fc", "arc", "cc", "cam", "uc", "ct", "lp", "amp", "acl", "inc", "toc", "pm", "ca", "pd", "bp", "anc", "cl", "gb", "pg", "sys", "ac", "nc", "cp", "cache", "p", "cs", "mc", "pic", "xc", "tc", "enc", "py", "PC", "c", "ctx", "rc", "px", "client", "wp", "sc", "dc", "aa", "pac", "co", "cus", "cz", "jc", "proc", "cms", "ec", "pt", "oc", "cu", "pa", "vc"], "buf_end": ["cmd67size", "cmd_size", "buf67size", "cmd_End", "cmd_range", "buf67end", "buf00offset", "buf00end", "uc_offset", "buf_set", "buf67range", "buf67length", "buf_est", "uf_pos", "buf_length", "buffer_length", "buf__set", "uf_stop", "buffer_size", "buf00set", "cmd_end", "cmd67End", "buf67start", "cmd67range", "buf00stop", "uf_offset", "uc_set", "buffer_start", "cmd67end", "uc_est", "buf_offset", "buffer_end", "buf00start", "uf_set", "buf__offset", "buf_End", "uc_end", "buf_stop", "buf__est", "uf_start", "buf00pos", "uf_end", "buf__end", "buf_range", "buf_pos", "buf67End"], "buf_start": ["queue_last", "seqMstart", "queue_info", "buf_last", "bufamend", "buf00last", "bufMstart", "seqMsource", "bufamlast", "queue_start", "buf_info", "bufMsource", "bufMend", "buf00end", "bufMid", "buf_source", "seq_start", "seqMend", "seq_source", "buf00info", "bufamstart", "queue_end", "bufaminfo", "seq_id", "buf00start", "seq_end", "buf_id", "seqMid"], "start_code": ["startaccode", "part64func", " start_size", "end_order", "starting_Code", "startensize", "starting_length", "end_ce", "start_order", "startencode", "part_code", " start_count", "start67order", "starting_code", "start_count", "starting_number", "start_mode", "start67code", "part64codes", "startxlength", "start64codes", "end_Code", "startencount", "startingxnumber", "start_length", "startingxCode", "startingxlength", "start67Code", "part_number", "start_codes", "start64func", "startxCode", "part64number", "startingxcode", "startenmode", "start_number", "startxnumber", "start64code", " start_mode", "part64code", "start64number", "start_ce", "startlensize", "start_Code", "startlencode", "startlenmode", "startxcode", "part_codes", "start67ce", "end_code", "startaclength", "part_func", "start_func", "startacnumber", "startacCode", "start_size", "startlencount"], "frame_rate_index": ["frame_ride_count", "frame_scoreacindex", "frame_ride_loc", "frame_rate_ind", "frame_rate_left", "frame_rate2lead", "frame_rateacloc", "frame_rate_loc", "frame_score_index", "frame_scoreaclead", "frame_rate_count", "frame_score_left", "frame_rateacindex", "frame_scoreacleft", "frame_rateactype", "frame_scoreactype", "frame_rate_condition", "frame_score_type", "frame_rate_id", "frame_rate_key", "frame_rideaccount", "frame_rate2left", "frame_rateaclead", "frame_rate2index", "frame_rate_lead", "frame_ride_key", "frame_score_lead", "frame_rideackey", "frame_rideacloc", "frame_rate_type", "frame_ride_index", "frame_rideacindex", "frame_rate_offset", "frame_rateacleft", "frame_rate_prefix", "frame_rateaccount", "frame_rate2type", "frame_rateackey"], "ext_type": ["ext_position", "extlposition", "ext_typ", "extltype", "frame_type", "extlstyle", "frame_typ", "ext_style", "extltyp", "frame_position", "frame_style"], "bytes_left": [" bytes___found", "bytes2bottom", "bytes_size", "bytesxsize", "bytesxlimited", "bytesxright", "bytes_bottom", "bytes64right", "seconds_bottom", "bytes___found", "seconds_leave", "lines_right", "bytes___right", "lines_shift", "bytes___left", " bytes_right", " bytes___right", "seconds_left", " bytes___width", "bytes2right", "bytes_shift", "bytes2left", "seconds_right", " bytes_found", "bytes64shift", " bytes___left", "bytes64needed", "bytesxleft", "bytes___bottom", "lines_needed", "bytes_found", "bytes_leave", "bytes64left", "bytes_limited", "lines_size", "bytes_width", "bytes_right", "bytes___leave", "bytes___width", " bytes_width", "bytes2leave", "lines_limited", "bytes_needed", "lines_left"], "frame_rate_ext_n": ["frame_rate_ext_num", "frame_rate_xt_pos", "frame_rate_xt_n", "frame_rate_xt_num", "frame_rate_ext_pos", "frame_rate_xt_d"], "frame_rate_ext_d": ["frame_rate_xt_n", "frame_rate_xt_min", "frame_rate_ext_min", "frame_rate_xt_d", "frame_rate_xt_dim", "frame_rate_ext_dim"], "picture_structure": ["picture_estitute", "picture_estyle", "picture_distructure", "picture_distyle", "picture_restitute", "picture_distitute", "picture_estructure", "picture_restyle", "picture_restruction", "picture_struction", "picture_stitute", "picture_estruction", "picture_restructure", "picture_distruction", "picture_style"], "top_field_first": ["top_field_prev", "top_line_last", "top_field_count", "top_line_first", "top_field_last", "top_line_count", "top_line_prev"], "repeat_first_field": ["repeat_first___frame", "repeat_firstalframe", "repeat_max_window", "repeat_max_field", "repeat_max___block", "repeat_firstalwindow", "repeat_first_frame", "repeat_max___frame", "repeat_first___window", "repeat_first_block", "repeat_firstalblock", "repeat_firstalfield", "repeat_first___block", "repeat_max_frame", "repeat_max_block", "repeat_max___window", "repeat_max___field", "repeat_first___field", "repeat_first_window"], "progressive_frame": ["progressiveablemedia", "progressive_window", "proitiveacsize", "progressiveableframe", "progressiveablesize", "progressiveacsize", "proitive_window", "proitive_frame", "proitive_size", "progressivelywindow", "proitive_media", "proitiveacframe", "progressivelyframe", "proitiveacmedia", "progressiveacframe", "progressive_size", "progressivelysize", "progressiveacmedia", "progressiveacwindow", "progressivelymedia", "proitiveacwindow", "progressive_media", "progressiveablewindow"], "horiz_size_ext": ["horiz_size_sec", "horiz_ize_xt", "horiz_ize_sec", "horiz_ize_ext", "horiz_size_EXT", "horiz_ize_EXT", "horiz_size_xt"], "vert_size_ext": ["vert_sizeedext", "vert_sizeedaux", "vert_sizeedcomplete", "vert_sizeetdownload", "vert_sizeeddownload", "vert_sizeetext", "vert_data_ext", "vert_size_aux", "vert_data_aux", "vert_data_complete", "vert_size1complete", "vert_size_download", "vert_dataedext", "vert_sizeetcomplete", "vert_size1download", "vert_dataedcomplete", "vert_size1ext", "vert_dataedaux", "vert_dataeddownload", "vert_size_complete", "vert_data_download", "vert_size1aux", "vert_sizeetaux"], "bit_rate_ext": ["bit_rate_x", "bit_size_txt", "bit_size_x", "bit_size_ext", "bit_rate_txt", "bit_rate_xt", "bit_size_xt"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int set_chroma_format(AVCodecContext *avctx)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx) {\n\n        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {\n\n            p_schro_params->format->chroma_format =\n\n                            schro_pixel_format_map[idx].schro_pix_fmt;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR,\n\n           \"This codec currently only supports planar YUV 4:2:0, 4:2:2\"\n\n           \" and 4:4:4 formats.\\n\");\n\n\n\n    return -1;\n\n}\n", "idx": 20623, "substitutes": {"avctx": ["avcam", "abcmp", "ajcam", "AVcmp", "avcv", "ajcontext", " avcv", "akcmp", "afcam", "afcmp", "avconn", "afctx", "AVcontext", "avcas", "akcontext", "abcv", "afcas", " avcmp", "akctx", "ajcas", "avcontext", "avxc", "AVconn", "abctx", "akconn", "AVxc", " avcas", "ajctx", " avxc", "avcmp", "abcontext", "afcontext", "AVctx", " avcam", "afconn", " avcontext", "afcv", "afxc"], "idx": ["idy", "ipb", "Idy", "idev", "IDy", " idix", "idux", "IDxs", "midx", "sidex", "kidx", "IDx", "indx", "pidp", "ipix", "ipp", "kidix", " idy", " idv", "ipi", "sidux", "kidv", "ipx", "idb", " idX", "idz", "ipxc", "idei", "ideb", "ipz", "indy", "idv", "Idxs", "sidx", " idxc", "midxc", " idux", " idex", " idz", "idex", "indX", "index", "idi", "idp", "pidx", "idxs", "IdX", " idp", "idix", "midp", "IDX", " idxs", "idey", "pidy", "indi", "kidy", "idxc", "Idx", "pidX", "midz", "indb", "indux", "sidy", "indix", "indp", "ideix", "idX"], "p_schro_params": ["p_schaco_args", "p_schro_ams", "p_schlo_ams", "p_schro_args", "p_schropparam", "p_schro_nas", "p_schaco_nas", "p_schlo_manager", "p_schlo_param", "p_schaco_ams", "p_schropparams", "p_schropmanager", "p_schlo_params", "p_schro_manager", "p_schaco_params", "p_schro_param", "p_schropams"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 20631, "substitutes": {"ctx": ["conv", "bc", "cc", "irc", "conn", "linux", "config", "pkg", "cv", "cm", "tx", "ca", "Context", "pc", "anc", "cas", "cmp", "ci", "exec", "ga", "cp", " cx", "cf", "xc", "mc", "kb", "context", "tc", "cli", "c", "cb", " context", "sc", "comp", "dc", "cci", "qa", "src", "loc", "cca", "jc", "kw", "ck", "cu"], "rb": ["lc", "bc", "pb", "sb", "ru", "ra", "lb", "rd", "db", "fb", "rx", "bb", "rf", "lr", "r", "ctrl", "abc", "wb", "rw", "cb", "rm", "rt", "rl", "vr", "b", "sr", "cr", "src", "bf", "RB", "xb", "gb", "rg"], "rc": ["lc", "bc", "ource", "fc", "ru", "ra", "cc", "uc", "irc", "ref", "config", "result", "input", "cv", "rx", "rec", "rr", "rect", "pc", "cur", "rf", "anc", "nc", "r", "entry", "inf", "tc", "context", "c", "cb", "rn", "roc", "RC", "sc", "rt", "sr", "dc", "rl", "auc", "cr", "error", "inst", "src", "rs", "rib", "rg", "gb"], "fn11": ["fn15", "fn14", "dn12", "sn12", "tn15", " fn14", " fn31", "fn12", " fn12", "ln14", "hn12", " fn15", "ln31", "FN11", "tn11", "fn31", "lf11", "tn2011", "hn15", "hn11", "fn2011", "FN12", "sn15", "dn11", "FN31", "ln12", "ln11", "sn11", "ln9", "FN9", "dn31", "fn9", "hn14", "lf15", "sn14", "lf2011", " fn2011", " fn9", "FN14"], "vb": ["ivc", "ivba", "nvb", "svb", "ivcb", "jp", "Vb", "vib", "vbas", "nvcb", "varibas", "vibas", "Va", " vba", " vdb", "Vv", "nvf", " vf", "svp", "vidb", "svv", "vcb", "svcb", "Vf", "Vp", "varib", "vba", "vip", "svf", "Vc", "ivf", "ivp", "nva", "ivb", "vv", " vv", "va", "varidb", "jf", "vdb", "svba", "jc", " vcb", " vp", "varip", "sva", "vp", "vf", "jb", " vbas", " va"], "vc": ["lc", "sv", "fc", "cc", "wcs", "nv", "vt", "lv", "pkg", "cv", "wd", "vd", "bb", "vg", "qv", "pc", "fp", "gd", "ci", "ga", "gru", "cf", "xc", "ctrl", "gg", "iw", "cli", "context", "c", "cb", "client", "dc", "vr", "ic", "cci", "dk", "service", "gc", "qa", "vv", "src", "fw", "VC", "wx", "lib", "vm", "vp", "hw", "voc", "cu"]}}
{"project": "qemu", "commit_id": "0e86c13fe2058adb8c792ebb7c51a6a7ca9d3d55", "target": 1, "func": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 20643, "substitutes": {"dev": ["md", "Dev", "priv", "grad", "cam", "def", "conn", "app", "err", "obj", "driver", "gu", "db", "private", "der", "wd", "d", "temp", "device", "gd", "info", "data", "ad", "bug", "dd", "p", "serial", "mod", "var", "comment", "self", "sd", "spec", "dem", "dom", "pro", "ver", "ch", "rad", "w", "prom", "er", "test", "req", "v", "conf", "user", "hw", "development", "ev", "server"], "vser": ["kseller", " vsl", "evserv", "gserv", "lserv", "svseller", "wse", "kster", "vsel", "vse", "Vser", "gse", "lserver", "wseller", "svserv", "lse", "devster", "vsl", " vster", "evser", "nvster", "fserver", "nvserver", "mse", "sser", "wser", "devser", "nvser", "mster", "fser", "lser", "mser", "sster", "wserv", "fsel", "gser", "Vsc", "fserv", "vserv", "svster", "wster", "evse", "gsc", "nvse", "wserver", "kserver", " vsel", "evserver", "fse", " vsc", "mserver", "fster", "devserver", "svserver", "sserver", "devsel", "Vserv", "lster", "gsl", "Vsl", "vserver", "svser", "vsc", " vserv", " vserver", "sse", "vseller", "vster", "evster", "kser", "gserver"], "vdev": ["vdd", "svdev", "gserv", "lserv", "Vrent", "vdef", "vdiv", "svserv", "Vdef", "verdef", " vdd", "verdd", " vrent", "verrent", "vserv", "svconn", "Vdd", " vdef", "verdev", "ldev", "gdev", "svdiv", "vconn", "lconn", "gconn", "Vdev", "gdiv", "vrent"]}}
{"project": "qemu", "commit_id": "5666ca4ae06d20497f887241151278e266947087", "target": 1, "func": "int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n", "idx": 20644, "substitutes": {"cenv": ["rcdb", " cdb", "rcenv", "cEnvironment", "qdb", "pcenter", "cdata", "cserver", "cconf", "rcenvironment", "catdev", "pcenvironment", " cdata", " cEnvironment", "rcdata", "fdata", "cdev", "qenc", "rcenc", "fserver", "pcEnvironment", " center", " cserver", "catenvironment", "cdb", "fenv", " cconf", "qconf", "catenv", "cenvironment", " cenvironment", " cdev", "qenv", "fenter", "pcenv", "center", "fdev", "cenc", "rcconf", "fenvironment", "rcserver", " cenc", "fEnvironment"], "sregs": [" sregns", "msregds", "sREGp", "SREGs", "sgrns", "sregcs", "Sregs", "SREGps", "sredcs", "sREGns", "sregistermap", "sREGcs", "sremgs", "sservds", "msservgs", "sregmap", "sservs", "Sregcs", "srems", "msserve", "SREGcs", "sdefcs", " sgrs", " sregp", " sregmap", "sserve", "sREGmap", " sgrns", "sregp", "sregisterns", "sREGs", "sservgs", "sregds", "msreggs", "sregisterp", "sgrmap", "sdefs", " sgrmap", "sreggs", "msregs", "msservs", "sreme", "sreds", "sremds", "sdefps", "sredps", "srege", "sgrp", "msservds", "Sregps", "msrege", "sregns", "sregps", "sregisters", " sgrp", "sgrs", "sREGps"]}}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647, "substitutes": {"vq": ["Vqq", " vquery", "vqq", "Vq", "varquery", "evue", "Vqa", "viciq", "flqa", "svself", "VQ", "varque", "evQ", "vue", "uvqa", "verque", "avque", "fiq", "vqu", "vqa", "vcqa", "voltque", "svque", "vcself", "vck", "evq", "svqa", "vicque", "avq", "vicq", "vque", "svqq", "flque", " vQ", "flq", "evque", "lQ", "evqq", "svue", " vquest", "evquest", "evqu", "vcque", "sviq", "vquery", " vqa", "vquest", "verqa", "fquest", "eviq", "uvque", "voltq", "vcQ", "vciq", "viq", "avck", " vck", " vqq", "varck", "lreq", "varq", " vque", "voltQ", "vcq", "uvq", "flqu", "svdev", "svq", "svquest", "fq", "lque", "lq", "vreq", "verq", "vself", "Vque", "vicqq", "uvqu", "avquery", "fue", "Viq", " viq", "verdev", " vself", "svreq", "voltreq", "vcquest", "evqa", "vQ", "svQ"], "vdev": ["vdd", "svDev", "nvdevice", "Vq", "vddev", "vDev", "svdevice", "vreq", "svdem", "vsdd", "vdq", "nvdev", "vd", "pdevice", "tvdevice", " vd", "evq", "wDev", "svdc", "svdd", " vdd", "vpu", "preq", "vdc", "vpriv", "pdev", "vdevice", "wpu", "svd", "Vdevice", "wdevice", "nvad", "tvdev", "svad", "evdev", "vdpriv", "wreq", "evdevice", "ppu", "wdc", "gmod", " vdem", "vsdem", "wdev", "vmod", "gdevice", "tvpu", "vsdev", "gdev", "vsd", " vDev", " vdc", "vad", "nvmod", "vdem", "Vpriv", "svmod", "evpriv", "vddevice", "tvreq", "Vdev", "gad", "svdev", " vdevice"]}}
{"project": "FFmpeg", "commit_id": "8728360b5664ef9db31137d8d3104cac33b9a911", "target": 1, "func": "static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}", "idx": 20659, "substitutes": {"avctx": ["avecf", "ivcontext", "vercontext", "ajcli", "mediacf", " avcu", "AVc", "avconfig", "AVcu", "AVca", " avcm", "ovctx", "abconfig", "ovcf", "afcm", "groundcdn", "avcb", "avcms", "avobj", "afconfig", "ajctx", "vercb", "avcmp", "Avctx", "afconn", "avcli", "avecu", "aveconfig", "afobj", "ovcontext", "avcdn", "avecb", "verctx", "AVtx", "avcp", "avecp", "afctx", " avpkg", " avc", "ajcf", "avscope", "abobj", "avcontext", "aviacms", "ajconn", "mediactx", "AVctx", " avca", "afcp", "ivcu", "avpkg", "AVcf", " avcp", "ajcontext", "groundcontext", "Avca", "afcmp", "AVcli", "avcf", "afscope", "avca", "ivctx", "afpkg", " avcmp", "afcms", "AVcms", "ajscope", "afcu", "avcu", "aviactx", "AVconn", "abctx", "vercmp", "AVcdn", "afcb", "ovcli", "avectx", "afcontext", "Avtx", "ivcm", "AVcmp", "aviacmp", "afcf", "vercu", "verc", "afcdn", "verconn", "avconn", "AVcontext", "avecmp", "ajcdn", "Avcontext", "groundpkg", "avecontext", "aviacontext", "avecms", " avtx", "ovscope", "avcm", "groundctx", " avcdn", "avtx", "mediacms", "avc", "abcontext", "aveobj", " avcontext", "mediacontext"], "mp": ["md", "bc", "pb", "cam", "ph", "omp", "ap", "app", "jp", "lp", "amp", "lv", "av", "me", "mb", "pkg", "cv", "cm", "pm", "bb", "cop", "rup", "mt", "mom", "mic", "fp", "mpeg", "pg", "cmp", "op", "cp", "msg", "mo", "agg", "pp", "p", "mc", "MP", "ep", "mod", "mm", "context", "mac", "gg", "ip", "ctx", "lim", "pl", "wp", "match", "peer", "gp", "comp", "tmp", "fm", "ms", "par", "media", "craft", "ps", "Mp", "manager", "tm", "sp", "gm", "ppa", "cap", "capt"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n", "idx": 20662, "substitutes": {"s": ["sv", "sb", "e", "support", "qs", "sam", "sl", "fs", "g", "ses", "lines", "ops", "l", "ds", "services", "f", "t", "m", "storage", "ssl", "os", "p", "cs", "setup", "ls", "ss", "sa", "sg", "c", "js", "settings", "spec", "si", "sc", "b", "service", "aws", "S", "ns", "sup", "sf", "utils", "ps", "rs", "gs", "v", "bs", "su", "sq"], "stream": ["view", "transform", "row", "sel", "object", "event", "sl", "valid", "thread", "iv", "loop", "input", "coll", "progress", "gram", "post", "message", "forward", "draft", "Stream", "model", "path", "ream", "data", "ssl", "context", "upload", "client", "pool", "content", "audio", "frame", "source", "document", "form", "channel", "read", "sw", "src", "reader", "slice", "child", "feed", "stage", "image", "video"], "presentation_time": ["presentation_Time", "presentationpttimes", "presenting_Time", "presenting_time", "presentation_times", "presentation_url", "presentation64Time", "presenting_times", "presentationpturl", "presentation64cost", "presentationpttime", "presentation64times", "presentation36time", "presentation_cost", "presentationptspeed", "presentation_speed", "presentation64time", "presenting_url", "presenting_speed", "presenting_cost", "presentation36Time", "presentation36times", "presentation36cost"], "m_obj_size": ["m_obj2size", "m_obj__size", "m_obj__time", "m_obj__len", "m_obj_num", "m_obj_member", "m_obj_time", "m_obj0len", "m_obj2address", "m_obj0num", "m_object_size", "m_obj2offset", "m_obj\u00b7size", "m_block_size", "m_block_address", "m_obj__num", "m_object_time", "m_obj\u00b7address", "m_obj\u00b7member", "m_obj\u00b7offset", "m_object_len", "m_block_offset", "m_obj_address", "m_obj_len", "m_obj2member", "m_obj0size", "m_obj0time", "m_object_num", "m_block_member"], "m_obj_offset": ["m_obj_seq", "m_obj_off", "m_object_pos", "m_object_off", "m_obj_header", "m_object_size", "m_object_header", "m_object_offset", "m_obj_pos", "m_object_seq"], "payload_len": ["payload33number", "payload2len", "payflow_val", "payload_Len", "payflow_number", "payflow2Len", "payload33length", "payload_length", "payload33val", "payflow_Len", "payload_number", "payload64val", "payflow_size", "payload2size", "payload_size", "payload64length", "payload64number", "payload64len", "payflow2len", "payload2Len", "payload33len", "payflow_len", "payload_val", "payflow2length", "payflow2size", "payflow_length", "payload2length"], "asf": ["ASfs", "Asdf", "asdf", "Asf", " asfc", "assfo", "masfs", "lasfc", "csfs", "masF", "ASf", "asfo", "asfc", "rasfs", "assfs", " ascf", "csfo", " asF", "ASfc", "asF", "lasfs", "asfs", "rasf", "rasF", "assf", "lasf", "Asfs", "assF", "csf", "AsF", "masf", "csF", " asfs", "AScf", "masdf", "ascf", "lascf", " asfo", "rasdf"], "pb": ["lc", "bc", "platform", "sb", "bos", "summary", "fc", "lb", "prop", "jp", "lp", "prot", "mb", "cv", "db", "pkg", "fb", "pm", "pd", "bp", "pc", "plugin", "fp", "gb", "pg", "bsp", "rob", "eb", "lab", "cp", "login", "PB", "obb", "ob", "p", "kb", "abc", "wb", "bps", "kk", "ctx", "cb", "ib", "wp", "mp", "gp", "ub", "b", "cpp", "hub", "alist", "dl", "bm", "nb", "ab", "bf", "proc", "bh", "dp", "rb", "vp", "typ", "xb", "bs", "bj", "ppa", "emb", "pa"], "val": ["ival", "col", "bc", "sel", "ee", "ref", "ind", "valid", "sl", "il", "lv", "part", "key", "cond", "ol", "tx", "xx", "pos", "split", "win", "al", "bit", "fee", "enc", "unit", "vals", "slot", "count", "year", "py", "el", "index", "num", "ctx", "aval", "byte", "pid", "x", "seq", "vol", "fl", "vc", "length", "len", "loc", "slice", "VAL", "Val", "v", "sec", "eval", "lit", "pt", "offset", "base", "prop", "value"]}}
{"project": "FFmpeg", "commit_id": "0eaec10550bd9a0682db9f7920ed0d86f1450f4b", "target": 1, "func": "static int pcm_encode_frame(AVCodecContext *avctx,\n\n\t\t\t    unsigned char *frame, int buf_size, void *data)\n\n{\n\n    int n, sample_size, v;\n\n    short *samples;\n\n    unsigned char *dst;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n    case CODEC_ID_PCM_S16BE:\n\n    case CODEC_ID_PCM_U16LE:\n\n    case CODEC_ID_PCM_U16BE:\n\n        sample_size = 2;\n\n        break;\n\n    default:\n\n        sample_size = 1;\n\n        break;\n\n    }\n\n    n = buf_size / sample_size;\n\n    samples = data;\n\n    dst = frame;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = (v + 128) >> 8;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = ((v + 128) >> 8) + 128;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_alaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_ulaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    avctx->key_frame = 1;\n\n    //avctx->frame_size = (dst - frame) / (sample_size * avctx->channels);\n\n\n\n    return dst - frame;\n\n}\n", "idx": 20697, "substitutes": {"avctx": ["evcca", "AVcf", "capconfig", "apctx", "AVconfig", "evcf", "airconfig", "apcontext", "airctx", " avconfig", "avcca", "avconn", "capcontext", "avconfig", "apconn", "AVctrl", "capctrl", "afctx", "AVcontext", "evcontext", "avcf", "abcf", "abcca", "AVcca", "avcontext", "abctx", " avconn", "capctx", "afconfig", "evctx", "abcontext", "afcontext", "AVctx", "apconfig", "afconn", "aircontext", "avctrl", " avcontext", "airctrl"], "frame": ["iframe", "fi", "next", "sample", "board", "input", "val", "message", "file", "f", "buffer", "fake", "series", "sequence", "state", "cf", "code", "body", "buf", "filename", "header", "frames", "document", "source", "window", "line", "first", "channel", "element", "Frame", "buff", "fram", "image", "base", "format", "video", "value"], "buf_size": [" buf_strength", "buf_start", "queue_size", "buf_sized", "buf64ize", "queue_start", "buf2len", "buf64size", "buf2start", "buf___ize", "buf_strength", "buf64strength", "queue_len", "buf___strength", "queue_sized", " buf_ize", "buf2size", "buf___size", "buf_len", "buf_ize", "buf2sized"], "data": ["start", "next", "sample", "config", "scale", "input", "message", "Data", "d", "bytes", "pad", "f", "buffer", "results", "one", "size", "new", "body", "shift", "buf", "memory", "a", "DATA", "window", "draw", "raw", "first", "media", "len", "database", "base", "multi", "dat", "array", "image", "block", "empty", "record", "format", "zero"], "n": ["span", "after", " N", "net", "i", "syn", "un", "en", "nin", "conn", "yn", "nan", "nn", "g", "non", "an", "none", "gn", "d", "ln", "not", "no", "f", "dn", "nl", "t", "y", "N", "nc", "m", "s", "size", "j", "u", "init", "p", "na", "o", "np", "ng", "network", "c", "rn", "num", "cn", "inn", "nw", "b", "in", "min", "ns", "len", "nb", "z", "nt", "sn", "nor", "fn", "all", "nu", "l", "x", "pn", "ne", "mn", "k"], "sample_size": ["sample_sized", "sample\u00b7shape", "sample_slice", "sample\u00b7size", "scale_scale", "scale_number", "ample_slice", "ample\u00b7size", "sample\u00b7range", "ample\u00b7slice", "ample\u00b7range", "sampleacsize", "sample_sec", " sample_sec", "sample\u00b7slice", "sample_number", "sample_set", "scale_size", "sample\u00b7set", "scale_sized", "sampleacrange", "ample_size", "sample_scale", " sample_shape", "sample_shape", " sample_set", "ample_range", "sampleacslice", "sample_range"], "v": ["conv", "tv", "sv", "view", "i", "e", "ul", "en", "nv", "vt", "V", "iv", "g", "lv", "av", "val", "virtual", "cv", "d", "vg", "qv", "f", "t", "y", "u", "m", "dev", "j", "s", "p", "uv", "vs", "version", "vi", "o", "q", "var", "c", "ver", "ch", "b", "ov", "w", "volt", "rev", "vol", "vv", "va", "ve", "vert", "z", "vp", "h", "api", "ev", "l", "x", "k", "video", "value", "vo"], "samples": ["unsamps", "sample", "statescriptions", "insimens", "dources", " samps", "sourses", "testsamples", "gallamples", " sessions", "unsources", "stones", " spackages", "gallplays", " sacters", "servicesamples", "unsessions", " splays", "statesamples", "statestones", "instones", "damples", "Smodels", "inscriptions", "sacters", "socks", "splays", "statesacters", "dsteps", " sages", "scriptions", "gallages", " ssteps", "statesimens", "specample", "dimens", "sessions", "unsamples", "insamples", "Sumps", "sources", "insamps", "servicesmodels", "Samps", "Sample", "simens", "dmodels", "gallpackages", "sumps", "Socks", "statesamps", "servicesamps", "specocks", "samps", "smodels", " sumps", "spackages", " sources", "servicesourses", "specamps", "ssources", "dourses", "ssamples", " sourses", "ssessions", "ssteps", "testsplays", "testsages", "statessteps", "insources", "ssamps", "Samples", "specamples", "sages", "statesample", "statesources", "damps", " smodels", "statesocks", "dacters", "testspackages"], "dst": ["bdset", "Dst", "datost", "sdste", "bdsts", "ldstr", "bdST", "vdstage", "sdstd", " dstr", "wdsn", "fost", "sdst", "wdste", " dstore", "sdsts", "Dsts", "rdsts", "Dstage", "Dste", "idsts", "dastore", "djste", "Dstep", "dsn", "Dost", "dasts", " dsn", "djst", " dost", "idste", "dsc", "isdst", "madsts", "dustage", "didst", " dsc", "idst", " dstep", "djsts", "dsstack", "sdST", "ldst", "dsost", "ddest", "sdsp", "didstack", "dsstr", "bdst", "dstop", "sdrest", "dste", "sdstop", "dast", "ldrest", " dstd", "idrest", "dudest", "wdst", "sdput", " dput", " dsp", "fste", "madstore", "DST", "datst", " dST", "sdstore", "didstore", "fdstore", "dsp", "datdest", "fst", "dbl", "dost", "fsts", "ldsn", "dstd", "idsc", " dstack", "bdstd", "Drest", "dust", "dset", "vdste", "rdsc", "dsstore", " dste", "sdost", " ddest", " dsts", "madst", "dstep", "dsbl", "rdset", "ldbl", "Dstore", "madsp", "fdst", "djstep", "dsst", "dsST", " drest", "dST", "vdst", " dbl", "dstore", "dssts", " dstage", "dstack", "dsts", "fdsts", "isdput", "duost", "isdost", "daste", "rdst", "fdste", "dstage", "isdstop", "didost", "ldsts", " dset", "drest", " dstop", "wdsts", "bdsc", "dput", "vdost", "ldste", "ldsc", "datstage", "dstr"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {\n\n  register int i;\n\n  int __attribute__ ((aligned (16))) tempo[4];\n\n\n\n  if (filterSize % 4) {\n\n    for(i=0; i<dstW; i++) {\n\n      register int j;\n\n      register int srcPos = filterPos[i];\n\n      register int val = 0;\n\n      for(j=0; j<filterSize; j++) {\n\n\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n      }\n\n      dst[i] = av_clip(val>>7, 0, (1<<15)-1);\n\n    }\n\n  }\n\n  else\n\n  switch (filterSize) {\n\n  case 4:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_vEven, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 12) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\t// now put our elements in the even slots\n\n\tsrc_v = vec_mergeh(src_v, (vector signed short)vzero);\n\n\n\n\tfilter_v = vec_ld(i << 3, filter);\n\n        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)\n\n\n\n        // the neat trick : we only care for half the elements,\n\n        // high or low depending on (i<<3)%16 (it's 0 or 8 here),\n\n        // and we're going to use vec_mule, so we chose\n\n        // carefully how to \"unpack\" the elements into the even slots\n\n\tif ((i << 3) % 16)\n\n\t  filter_v = vec_mergel(filter_v,(vector signed short)vzero);\n\n\telse\n\n\t  filter_v = vec_mergeh(filter_v,(vector signed short)vzero);\n\n\n\n\tval_vEven = vec_mule(src_v, filter_v);\n\n\tval_s = vec_sums(val_vEven, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 8:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_v, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 8) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tfilter_v = vec_ld(i << 4, filter);\n\n        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)\n\n\n\n\tval_v = vec_msums(src_v, filter_v, (vector signed int)vzero);\n\n\tval_s = vec_sums(val_v, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 16:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1 = vec_ld(srcPos + 16, src);\n\n\tvector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tvector signed short src_vA = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tvector signed short src_vB = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n\tvector signed short filter_v0 = vec_ld(i << 5, filter);\n\n       \tvector signed short filter_v1 = vec_ld((i << 5) + 16, filter);\n\n        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)\n\n\n\n\tvector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);\n\n\tvector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n\tvector signed int val_s = vec_sums(val_v, vzero);\n\n\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  default:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int j;\n\n\tregister int srcPos = filterPos[i];\n\n\n\n        vector signed int val_s, val_v = (vector signed int)vzero;\n\n\tvector signed short filter_v0R = vec_ld(i * 2 * filterSize, filter);\n\n        vector unsigned char permF = vec_lvsl((i * 2 * filterSize), filter);\n\n\n\n        vector unsigned char src_v0 = vec_ld(srcPos, src);\n\n        vector unsigned char permS = vec_lvsl(srcPos, src);\n\n\n\n        for (j = 0 ; j < filterSize - 15; j += 16) {\n\n          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);\n\n          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          vector signed short src_vA = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          vector signed short src_vB = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n          vector signed short filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          vector signed short filter_v2R = vec_ld((i * 2 * filterSize) + (j * 2) + 32, filter);\n\n          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);\n\n          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);\n\n\n\n          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);\n\n          val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n          filter_v0R = filter_v2R;\n\n          src_v0 = src_v1;\n\n        }\n\n\n\n        if (j < (filterSize-7)) {\n\n          // loading src_v0 is useless, it's already done above\n\n          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);\n\n          vector unsigned char src_v1, src_vF;\n\n          vector signed short src_v, filter_v1R, filter_v;\n\n          if ((((int)src + srcPos)% 16) > 8) {\n\n            src_v1 = vec_ld(srcPos + j + 16, src);\n\n          }\n\n          src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          src_v = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          // loading filter_v0R is useless, it's already done above\n\n          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);\n\n          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          filter_v = vec_perm(filter_v0R, filter_v1R, permF);\n\n\n\n          val_v = vec_msums(src_v, filter_v, val_v);\n\n        }\n\n\n\n        val_s = vec_sums(val_v, vzero);\n\n\n\n        vec_st(val_s, 0, tempo);\n\n        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n\n\n    }\n\n  }\n\n}\n", "idx": 20698, "substitutes": {"dst": ["DST", "ssc", "Dst", " dST", "sst", "dsc", "ssts", "Dsc", " dsc", "dST", "cdsts", "dsrc", "cdsrc", "Dsrc", "Drc", "drc", "cdST", "dsts", " drc", "cdst", "Dsts", " dsts", " dsrc"], "dstW": ["drcC", "dSTH", "DscH", " drcw", "Dstw", "dstC", "drcw", "dscWidth", "dSTP", "DscW", "dstsW", "dSTW", "DstW", "dstsC", "DscP", "drcW", " dstw", "dscC", "DstP", "dscH", " dstC", " dstWidth", "dscP", "DstH", "drcH", "dstw", "dstH", "dstsH", " drcWidth", " drcW", "dsrcW", "drcP", "dscW", "dstP", " drcC", "dsrcw", "drcWidth", "dSTw", "dstsw", " dstH", "dsrcH", "dstWidth", " drcH", "dscw", "Dscw", "dsrcWidth"], "src": ["conv", "transform", "sb", "target", "sel", "support", "connect", "uc", "sci", "config", "iv", "asc", "include", "input", "ctr", "gl", "rin", "uri", "control", "cur", "img", "scl", "reverse", "secure", "dist", "cmp", "rob", "acc", "front", "seed", "ssl", "nil", "sync", "crop", "gz", "rc", "filename", "cb", "reflect", "spec", "source", "low", "RC", "sc", "sr", "go", "sub", "tmp", "sur", "core", "surface", "lower", "inst", "sup", "loc", "rss", "slice", "req", "sec", "dest", "rib", "rb", "stream", "sn", "image", "resource", "feat", "sq", "url"], "srcW": ["distW", "rcw", "distw", " srcU", "rcWidth", "srcw", "distU", " srcw", " srcWidth", "distWidth", "srcWidth", "srcU", "rcW", "rcU"], "xInc": ["uxArg", "wxEnc", "uxSec", "exEnc", "xinc", "xSec", "xArg", "exinc", "exArg", "wxSec", "uxEnc", "wxinc", "xEnc", "wxArg", "uxinc", "exSec"], "filter": ["conv", "protect", "transform", "target", "limit", "support", "flat", "end", "config", "ind", "map", "force", "feature", "control", "wave", "f", "layer", "buffer", "ac", "patch", "version", "id", "header", "c", "search", "spec", "source", "match", "sub", "Filter", "flag", "rule", "channel", "fl", "mask", "test", "batch", "v", "alpha", "fil", "fn", "frequency", "block", "cover", "sort", "offset", "format", "condition"], "filterPos": [" filterStart", "controlLen", "maskStart", " filterPtr", "sortPtr", "filterPosition", "maskPtr", "controlPos", "filterStart", "maskSize", "filRes", "sortSize", "filterPtr", "filterLen", "controlRes", "controlPtr", "controlSize", " filterPosition", "maskPos", " filterLen", "filLen", "controlPosition", "filStart", "filPos", "sortPos", "controlStart", "filterRes", " filterRes", "sortPosition"], "filterSize": ["sortLen", "maskExp", "flatSize", "filterSection", "filterCode", "FilterMode", "maskSize", "filterMode", "featuresize", "configsize", "FilterSize", "sortSize", "formatLen", "filterLen", "formatsize", "filMode", "filCount", "formatSection", "maskCode", "filterExp", "masksize", " filterSection", "FilterCount", "filSize", " filterLen", "filLen", "flatLen", "maskPos", "filterCount", "featureExp", "filsize", "FilterLen", "configSize", "filtersize", "flatPos", " filtersize", "sortCode", "featureLen", "formatSize", "filPos", "configLen", " filterMode", " filterCount", " filterExp", "flatsize", "FilterCode", "maskLen", "configSection", "featureSize"], "i": ["io", "anti", "e", "ix", "start", "ie", "fi", "qi", "ri", "ui", "eni", "g", "mini", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "t", "y", "u", "info", "ini", "m", "it", "init", "phi", "p", "ip", "id", "o", "bi", "inner", "is", "mi", "cli", "wei", "c", "mu", "index", "si", "a", "ii", "b", "ji", "n", "iu", "sup", "ai", "xi", "ei", "di", "v", "z", "multi", "li", "yi", "pi", "x", "zi", "k", "ni", "ori"], "tempo": ["typo", "emporal", "dimpr", "tempr", "dimporal", "tembo", "typr", "empr", "temporal", "dimbo", "empo", "tybo", "typoral", "embo", "dimpo"], "j": ["ja", "jit", "oj", "ix", "e", "jl", "ik", "obj", "jp", "bj", "adj", "ui", "g", "key", "l", "f", "jj", "y", "t", "u", "r", "m", "pre", "uj", "dj", "jet", "p", "o", "bi", "q", "js", "aj", "index", "el", "fr", "pr", "out", "J", "ch", "b", "ii", "ji", "ij", "n", "br", "jc", "z", "v", "li", "jo", "pt", "all", "ie", "x", "k", "ni"], "src_v1": ["src_v2", "src_f0", "src_V2", "src_sv1", "src_h2", "src_vN", "src_hF", "src_v0", "src_h0", "src_fF", "src_VF", "src_V0", "src_sv2", "src_fN", "src_V1", "src_hN", "src_sv0", "src_v6", "src_f1", "src_f2", "src_V6", "src_h1", "src_sv6", "src_f6", "src_VN"], "src_vF": ["src_vgf", "src_hf", "src_f0", "src_vgD", "src_vD", "src_hF", "src_v0", "src_svf", "src_svD", "src_fF", "src_VE", "src_VF", "src_V0", "src_ff", "src_VD", "src_vP", "src_vFi", "src_vf", "src_vE", "src_svF", "src_fD", "src_V1", "src_VFi", "src_mF", "src_f1", "src_hE", "src_vgFi", "src_m1", "src_hD", "src_fFi", "src_m0", "src_vgF", "src_VP", "src_fP", "src_svE", "src_Vf", "src_mP"], "src_v": ["src_f", "srcJh", "rc_v", "rc_f", "src_V", "srcJs", "src_l", "rc_l", "src_s", "rc_t", "src_ver", "rc_h", " src_V", " src_vp", "src_t", " src_s", "rc_s", "src_c", " src_f", "rc_ver", "srcJver", " src_h", "src_vp", "src_h", "rc_c", "srcJv"], "filter_v": ["fil__v", "filter__c", "var_s", "filter__vs", "filterures", "url_v", "filter__h", " filter_s", "filterianv", "filter_s", "fil__h", " filter_m", "var_v", "reflect_v", "filter__v", "filter_conv", "fil__vs", " filter_h", "url_c", "reflect_nv", "filter__m", "filter_c", "filter_dev", "filter_vs", "filter_nv", "filteriansv", "filteriandev", "var_dev", "var_rev", "filter_rev", "filter_m", "filterurev", "filteruredev", " filter_p", " filter_V", "filter_sv", "filter_p", "filter_h", "url_conv", "fil_v", "reflect_sv", "filter_l", " filter_l", "url_h", "filter_V", "fil__c", " filter_c", "filter_f", "filter__f", "fil_vs", "filter__V", "fil_c", "reflect_dev", "filterurerev", " filter_f", "filteriannv", "fil_h"], "val_vEven": ["val_fEven", "val_0", "val_uLong", "val_fLong", "val_fA", "val_lEven", "val_lEx", "val_ivEx", "val_iv0", "val_feven", "val_ivLong", "val_VEven", "val_V0", "val_ueven", "val_v0", "val_uEven", "filter_0", "val_svA", "val_vA", "val_VLong", "val_svLong", "filter_\n", "val_VEx", "val_sveven", "val_svEven", "val_vLong", "val_l0", "val_uA", "val_vEx", "val_veven", "val_lLong", "val_\n", "val_ivEven"], "val_s": ["val_r", "val_b", "eval_b", "val_d", "val2v", " val2d", "val2d", "val_h", " val_r", "val2r", " val_d", " val2r", " val2s", "eval_v", " val2v", "eval_s", "eval_h", "val2s"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n", "idx": 20716, "substitutes": {"env": ["status", "txt", "en", "obj", "err", "config", "iv", "result", "device", "buffer", "dev", "init", "data", "enc", "dict", "code", "np", "addr", "buf", "settings", "cal", "set", "console", "proc", "ev", "environment", "fi", "ec"], "value": ["status", "member", "begin", "package", "reg", "name", "the", "attribute", "property", "Value", "response", "object", "end", "scale", "result", "non", "val", "message", "key", "lua", "feature", "token", "get", "type", "function", "buffer", "hello", "device", "one", "entry", "address", "size", "data", "program", "use", "fee", "description", "version", "current", "number", "id", "code", "comment", "values", "complete", "source", "document", "beta", "create", "set", "error", "child", "total", "element", "definition", "reference", "expression", "parent", "range", "resource", "image", "server", "block", "variable", "VALUE", "command", "format", "vector"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n", "idx": 20722, "substitutes": {"obj": ["object", "ref", "Object", "iv", "val", "xxx", "func", "orb", "f", "po", "op", "env", "t", "m", "j", "opt", "ob", "os", "p", "o", "buf", "ctx", "self", "Obj", "b", "bo", "tmp", "objects", "rev", "inst", "src", "parent", "rb", "api", "x", "emb"], "v": ["tv", "sv", "inv", "e", "object", "V", "vt", "iv", "lv", "val", "d", "f", "op", "t", "u", "env", "m", "s", "j", "ob", "vu", "p", "uv", "vs", "o", "c", "b", "w", "vv", "z", "vm", "vp", "ev", "l", "api"], "opaque": ["opaques", "opec", "coacity", "ipace", "paco", "ipacity", "ipaque", "opaco", "Opaco", "Opace", "coaques", "coaque", "opace", "Opacity", "pacity", "ipec", "opacity", "Opec", "paques", " opacity", "Opaque", " opace", "Opaques", "paque", " opec", "coaco"], "name": ["member", "str", "property", "named", "none", "part", "key", "time", "null", "style", "type", "no", "path", "names", "size", "data", "new", "NAME", "label", "prefix", "code", "word", "comment", "Name", "nice", "missing", "alias", "error", "n", "desc", "ns", "clean", "parent", "base", "cap"], "errp": ["resultps", "errcp", "resultpp", " errlp", "errps", "rrpre", "grlp", "irpre", "resultp", "refpc", "ircp", "rrp", " errcp", "ierp", "refp", "reflp", " errpre", " errpi", "ierps", " errpc", "errpc", "rrpc", "resultP", "errP", "ierP", " errps", "refpi", "rrcp", "grp", " errpp", "irpc", "errpi", "errpre", "irp", "errpp", "errlp", " errP", "grpi", "ierpp", "grpc"], "prop": ["lc", "pb", "priv", "property", "fi", "ref", "jp", "pred", "option", "prot", "val", "part", "key", "fb", "properties", "cmp", "po", "pos", "op", "term", "info", "cp", "data", "opt", "p", "np", "buf", "cb", "pro", "mp", "tmp", "nb", "owner", "proc", "pointer", "rb", "typ", "lit", "api", "feat", "attr", "Prop", "type"], "value": ["member", "native", "property", "Value", "object", "ref", "valid", "option", "result", "val", "message", "key", "null", "function", "model", "size", "data", "current", "number", "id", "field", "comment", "index", "values", "create", "length", "total", "element", "reference", "parent", "array", "image", "VALUE", "format", "type"]}}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n", "idx": 20728, "substitutes": {"path": ["col", "transform", "request", "name", "port", "cross", "ath", "object", "end", "next", "pattern", "config", "text", "part", "Path", "key", "file", "broken", "sign", "temp", "host", "node", "anc", "dir", "ith", "entry", "data", "full", "PATH", "method", "p", "or", "enc", "prefix", "code", "word", "open", "c", "self", "index", "match", "pass", "core", "child", "loc", "test", "root", "parent", "then", "pointer", "image", "url", "value"]}}
{"project": "qemu", "commit_id": "1466cef32dd5e7ef3c6477e96d85d92302ad02e3", "target": 0, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 20738, "substitutes": {"d": ["dos", "cd", "e", "dose", "ind", "ded", "db", "connection", "dad", "dh", "ds", "ld", "f", "dj", "t", "m", "da", "dd", "ad", "p", "did", "dy", "dr", "c", "dx", "sd", "dt", "du", "b", "dc", "dim", "dm", "dl", "fd", "bd", "D", "dat", "l"], "i": ["io", "span", "e", "ix", "qi", "ui", "mini", "pi", "gi", "ti", "I", "f", "t", "phi", "r", "u", "j", "ip", "abi", "p", "id", "o", "bi", "inner", "cli", "c", "index", "si", "a", "ii", "b", "ji", "n", "iu", "child", "slice", "xi", "hi", "multi", "v", "z", "li", "l", "x", "zi", "k", "ni", "count"], "mch": ["Mich", "hcha", "omich", "mgh", "omcha", " mth", "dmch", "wmch", "smcht", "Mth", "umach", "rmich", "mrcher", "pcha", "gmcher", "umich", "bmarch", "smtch", "mcht", "imich", "gmach", "gmcht", "cmzh", "omuth", "gmich", "mrich", "umch", "hche", "mach", "rmcht", "amcha", "Mchid", "mce", "mmich", "dmcher", "amcht", "mcher", "cmich", "ymche", "Mcher", "pmcha", " muth", "umcher", "mcch", "Mche", "pzh", " mcha", "wmcha", "hch", "ymich", "imach", "mrch", "pach", "manach", "ymth", "imcha", "umche", "nmche", "Muth", " mzh", " mtch", "imch", "mchid", "rmcher", "gmtch", "Mach", "hich", "Mce", "manch", "bmch", " mach", "cmche", "mccht", "mzh", "mtch", "Mcha", "mth", "pchid", "rmch", "gmch", "dmich", "mcach", "march", " mcht", "gmche", "Mgh", "amich", "mmcha", "gmzh", "Mch", "pche", "amche", "dmcha", " mich", "mmche", "March", "mccha", "cmcher", "omch", "wmich", "pcher", "pmach", "cmch", "fmach", " mce", "pmich", "mich", "manche", "cmcha", "cmgh", "pchan", "fmchan", "mancha", "omoch", "manich", "cmcht", "pich", "nmch", "mancher", "pmch", "mche", "bmcher", "nmach", "cmoch", "Moch", "omcher", "fmich", "cmth", "amch", " mgh", "moch", "pmche", "nmich", "mmch", "rmcha", "Mchan", "imcht", "umcha", "mrcha", "pmcht", "wmche", "Mzh", "bmich", "ymch", "smch", "pch", "imche", "Mcht", "fmch", "cmce", "fmchid", "mchan", " march", "rmche", "gmcha", "omche", "dmcht", "omach", " mcher", "mcha", "muth", "cmach", " mchid", " mche", "dmche", "smach", "parch"]}}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static int h261_find_frame_end(ParseContext *pc, AVCodecContext* avctx, const uint8_t *buf, int buf_size){\n\n    int vop_found, i, j, bits_left, last_bits;\n\n    uint32_t state;\n\n\n\n    H261Context *h = avctx->priv_data;\n\n\n\n    if(h){\n\n        bits_left = h->bits_left;\n\n        last_bits = h->last_bits;\n\n    }\n\n    else{\n\n        bits_left = 0;\n\n        last_bits = 0;\n\n    }\n\n\n\n    vop_found= pc->frame_start_found;\n\n    state= pc->state;\n\n    if(bits_left!=0 && !vop_found)\n\n        state = state << (8-bits_left) | last_bits;\n\n    i=0;\n\n    if(!vop_found){\n\n        for(i=0; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    i++;\n\n                    vop_found=1;\n\n                    break;\n\n                }\n\n            }\n\n            if(vop_found)\n\n                    break;    \n\n        }\n\n    }\n\n    if(vop_found){\n\n        for(; i<buf_size; i++){\n\n            if(avctx->flags & CODEC_FLAG_TRUNCATED)//XXX ffplay workaround, someone a better solution?\n\n                state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pc->frame_start_found= vop_found;\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 20741, "substitutes": {"pc": ["lc", "bc", "pb", "fc", "arc", "cc", "uc", "conn", "ct", "amp", "inc", "cv", "post", "BC", "pm", "con", "ca", "pd", "bp", "anc", "pg", "po", "gb", "ci", "can", "nc", "ac", "cp", "pre", "exec", "sys", "p", "enc", "xc", "mc", "tc", "mac", "py", "PC", "pr", "ctx", "c", "pl", "rc", "client", "cb", "px", "sc", "wp", "cpp", "gc", "pac", "cca", "cus", "co", "cz", "jc", "proc", "cms", "ck", "pt", "oc", "api", "pa", "vc"], "avctx": ["Avconnection", "ajcontext", "ajpkg", "avconn", "AVpkg", "aucontext", "afctx", "AVcontext", "avcas", "Avloc", "afloc", "afcas", "aucas", "afpkg", " avconnection", "Avcontext", "avcontext", "avxc", "AVconn", "ajconn", " avloc", "avconnection", " avcas", "ajctx", " avxc", "Avctx", "afcontext", "AVctx", "auctx", "afconn", " avcontext", "afxc", "auxc", "avpkg", "avloc", "afconnection"], "buf": ["bc", "pb", "port", "uf", "uc", "ba", "config", "map", "db", "cv", "fb", "queue", "bin", "Buff", "home", "img", "cas", "buffer", "alloc", "bu", "cmd", "grab", "box", "raf", "cache", "ob", "cf", "que", "context", "wb", "pool", "rc", "cb", "ctx", "b", "bo", "seq", "auc", "src", "loc", "br", "comb", "ab", "batch", "buff", "proc", "border", "array", "vec", "rb", "bag", "fam", "block", "bus", "gb", "pub"], "buf_size": ["queue_size", "buf_sized", "bufMloc", "buf_scale", "buf_SIZE", "bufMsource", "queue_source", "queue_sized", "queue_ize", "queue_SIZE", "buf_loc", "buf_source", "queue_Size", "queue_scale", "buf_Size", "bufMscale", "bufMsize", "buf_ize", "queue_loc"], "vop_found": ["vop_left", "vapperaygiven", "vantkfound", "vompallfound", "vopalgiven", "vop__found", "vopalerr", "vop6found", "vomp_find", "vopallfound", "vop_matched", "vot__found", "vhop_found", "vop_tested", "vopayfinished", "vomp_found", "vop_finding", "vopt_find", "voup_given", "vop64Found", "vopAfound", "vap_Found", "vopallfind", "voup_err", "vomp_left", "vant_received", "vop_received", "vop_error", "vop64found", "vop_changed", "vopffind", "vop_err", "vopenerror", "vop6matched", "vap_find", "vapperayfinished", "vopt_tested", "vantkfind", "vop_finished", "vop_bound", "vopffound", "vopkreceived", "vop_added", "vop_full", "vap_changed", "vapperaymatched", "vant_find", "vopalreceived", "vot_found", "vop__finished", "vop64find", "vop64changed", "vopalfind", "vap_found", "vop0valid", "vop0found", "vopaygiven", "vapper_given", "vant_found", "vop_Found", "vopt_found", "voup_full", "vapper_finished", "vopalfinding", "vopAerror", "vompallfind", "vopenbound", "vapper_found", "vop_find", "vop0tested", "vopkfind", "vot_bound", "vop_valid", "vopalfull", "vop__given", "vhop_added", "vot__error", "vop0find", "vopfadded", "vop6given", "vopferr", "vopkfound", "vopallleft", "vop__bound", "vopAbound", "vopalfound", "vot__bound", "vot_error", "vop_given", "vompallleft", "vop__error", "vantkfinding", "vopenfound", "vantkreceived", "vhop_find", "vapperayfound", "vopkfinding", "vapper_matched", "vhop_err", "voup_found", "vopt_valid", "vopaymatched", "vop__matched", "vopayfound", "vop6finished", "vant_finding"], "i": ["io", "eni", "ti", "y", "info", "ini", "ip", "n", "iu", "slice", "di", "v", "l", "fi", "ix", "qi", "ri", "ind", "iv", "g", "gi", "d", "my", "I", "ci", "u", "o", "mi", "c", "a", "ji", "xi", "yi", "li", "ie", "pi", "ni", "e", "ik", "ui", "ki", "f", "phi", "it", "init", "p", "bi", "cli", "si", "b", "z", "api", "x", "zi", "count", "ori", "start", "uri", "oi", "id", "is", "index", "ii", "in", "ai", "ei", "hi", "isi", "im", "ski", "value"], "j": ["jit", "off", "key", "pos", "y", "jet", "ip", "dy", "js", "aj", "fr", "n", "jay", "br", "di", "v", "l", "je", "qi", "jp", "ind", "g", "d", "dj", "u", "o", "q", "J", "ji", "em", "li", "ie", "k", "ja", "e", "jl", "ui", "f", "it", "p", "job", "pr", "el", "b", "er", "jc", "z", "note", "jo", "x", "ne", "oj", "obj", "adj", "jen", "jj", "uj", "m", "ch", "ii", "w", "ij", "im", "pt", "all"], "bits_left": ["bits_flo", "strings_found", " bits_right", "bits64found", "bits0needed", "its_right", "bits0right", "bits48left", " bits_Left", "bits_right", " bits_lost", "bitsSflo", "bitsESSjoined", "stringsSjoined", "bits0left", "bitsESSfound", "stringsSflo", "bits_lost", "bits_size", "bits64left", "bits48lic", "its_left", "bits_wrong", "strings_left", "bits64flo", "bits_diff", "bits_needed", "bits_lic", "bits0size", "its_lic", "stringsSfound", "bitsSjoined", "bits_last", "bits_joined", "blocks_diff", "bitsESSleft", "bitsESSflo", "blocks_left", "bits48right", "bits_found", "its_needed", " bits_last", "bits64joined", "bits_low", "strings_joined", "bitsSleft", "its_pl", "stringsSleft", "its_size", "strings_flo", "blocks_low", " bits_found", "bits48pl", "bits_Left", "bitsSfound", "bits_pl", "blocks_wrong"], "last_bits": ["lastaypieces", "first64bytes", "last_pieces", "last_fps", "last36ints", "last__locks", " last__planes", "last36bit", " last_bit", "first_bit", "lastaypoints", "last64locks", "last67ints", "last__bit", " last_ints", "first64bits", "last__bytes", "last36bits", "last__bits", " last__ints", "first64bit", "last67bits", "first_locks", "first64locks", "last__ints", "lastembytes", "lastembit", "worst_nets", "worst_bits", "last_ints", "last_nets", "lastemfps", "last_bytes", "lastaybytes", "last__planes", " last_planes", "first_bytes", "worst_bytes", "last64bytes", "first_bits", " last__bit", "last36planes", "worst_pieces", "last67planes", "lastaybits", "last_planes", "last64bits", " last_fps", "last_bit", "last_locks", " last_pieces", "last_points", " last_points", "last67bit", " last_bytes", "lastembits", "last64bit", " last__bits"], "state": ["ate", "bc", "step", " State", "class", "un", "area", "ct", "config", "STATE", "wa", "none", "part", "pe", "val", "power", "message", "key", "address", "use", "data", "seed", "last", "context", " rc", "rule", "line", "date", "slice", "are", "instance", "type", "sb", "name", "print", "conn", "scale", "g", "private", " self", "d", "style", "statement", "sth", "al", " config", "stat", "current", "code", "o", "body", "self", "back", "st", "scope", "State", "e", "store", "err", "mode", "region", "func", "f", "patch", "p", "ace", "we", "point", "open", "comment", "si", "error", "length", "call", "loc", "note", "resource", "param", "ke", "ne", "status", "span", "port", "start", "cur", " c", "m", "rate", "cache", "id", "sync", "is", "ctx", "tag", "frame", "source", "sh", "ch", "cal", "se", " sc", "session", "grade", "update", "parent", "range", "shadow", "block", "cause", "states", "value"], "h": ["ih", "hp", "hm", "e", "hs", "ha", "ssh", "han", "d", "oh", "f", "ah", "eh", "kh", "m", "s", "r", "u", "hd", "adh", "p", "rh", "o", "q", "auth", "uh", "H", "c", "ctx", "sh", "ch", "hr", "b", "w", "he", "hl", "n", "gh", "v", "bh", "ec", "http", "l", "ph", "ht"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_write(AddressSpace *as, target_phys_addr_t addr,\n\n                         const uint8_t *buf, int len)\n\n{\n\n    address_space_rw(as, addr, (uint8_t *)buf, len, true);\n\n}\n", "idx": 20743, "substitutes": {"as": ["pas", "ras", "asm", "ach", "ast", "ap", "ack", "nas", "cas", "sys", "al", "r", "ac", "res", "os", "or", "asu", "at", "us", "p", "As", "mac", "var", "is", "sa", "ar", "a", "aws", "has", "inas", "AS", "ag", "from", "bs", "las", "acs"], "addr": ["port", "holder", "ast", "ref", "adr", "config", "amp", "eth", "wd", "func", "align", "host", "pad", "node", "layer", "pos", "coord", "address", "data", "ad", "ace", "ctx", "ar", "rt", " address", "ptr", "a", "Address", "alias", "src", "loc", "pair", "pointer", " af", "offset", "base", "attr"], "buf": ["bc", "pb", "uf", "lb", "uc", "off", "ref", "null", "queue", "func", "pad", "cur", "buffer", "alloc", "cmd", "rc", "cb", "lim", "ctx", "aux", "byte", "b", "ptr", "seq", "src", "length", "fd", "cap", "ab", "buff", "bh", "vec", "rb", "offset", "gb"], "len": ["name", "limit", "en", "off", "val", "ln", "l", "bl", "f", "pos", "lan", "size", "data", "fin", "enc", "la", "el", "lim", "num", "line", "seq", "fl", "n", "length", "fd", " length", "lon", "nt", "li", "lf", "lit", "offset", "base", "Len", "cap", "count"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_run_capture (AudioState *s)\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        int live, rpos, captured;\n\n        HWVoiceOut *hw = &cap->hw;\n\n        SWVoiceOut *sw;\n\n\n\n        captured = live = audio_pcm_hw_get_live_out (hw);\n\n        rpos = hw->rpos;\n\n        while (live) {\n\n            int left = hw->samples - rpos;\n\n            int to_capture = audio_MIN (live, left);\n\n            st_sample_t *src;\n\n            struct capture_callback *cb;\n\n\n\n            src = hw->mix_buf + rpos;\n\n            hw->clip (cap->buf, src, to_capture);\n\n            mixeng_clear (src, to_capture);\n\n\n\n            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n                cb->ops.capture (cb->opaque, cap->buf,\n\n                                 to_capture << hw->info.shift);\n\n            }\n\n            rpos = (rpos + to_capture) % hw->samples;\n\n            live -= to_capture;\n\n        }\n\n        hw->rpos = rpos;\n\n\n\n        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {\n\n            if (!sw->active && sw->empty) {\n\n                continue;\n\n            }\n\n\n\n            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {\n\n                dolog (\"captured=%d sw->total_hw_samples_mixed=%d\\n\",\n\n                       captured, sw->total_hw_samples_mixed);\n\n                captured = sw->total_hw_samples_mixed;\n\n            }\n\n\n\n            sw->total_hw_samples_mixed -= captured;\n\n            sw->empty = sw->total_hw_samples_mixed == 0;\n\n        }\n\n    }\n\n}\n", "idx": 20751, "substitutes": {"s": ["sv", "sim", "sb", "sym", "space", "csv", "serv", "sie", "sl", "sam", "ses", "ssh", "an", "sound", "ds", "sys", "ssl", "p", "ls", "sync", "ss", "sa", "sg", "c", "spec", "si", "a", "w", "service", "se", "n", "S", "ns", "session", "sf", "south", "rs", "v", "su", "sq"], "cap": ["bc", "sv", "cam", "app", "config", "amp", "acl", "ipp", "av", "aps", "pe", "cm", "snap", "copy", "pc", "can", "acc", "cp", "ip", "cs", "cpp", "rip", "comm", "ab", "v", "conf", "fab", "cv", "rap", "op", "ac", "oper", "code", "mac", "af", "c", "lim", "wp", "cfg", "mp", "sc", "capacity", "chip", "ce", "su", "cu", "vc", "capt", "lc", "cc", "uc", "com", "cop", "host", "scl", "cmp", "p", "cf", "cup", "call", "up", "cod", "clip", "sq", "en", "sk", "ap", "hop", "ha", "CAP", "ca", "cl", "grab", "Cap", "mc", "caps", "sh", "gp", "ch", "w", "cr", "pac", "ape"], "live": ["val", "wave", "win", "slave", "Live", "lu", "load", "la", "pl", "line", "dl", "slice", "game", "living", "old", "l", "file", "split", "nl", "lan", "vel", "rc", "life", "lim", "irm", "low", "online", "vol", "liv", "ive", "lib", "lived", "lc", "how", "sel", "lb", "lane", "mode", "roll", "full", "play", "lin", "mid", "le", "cli", "comp", "core", "length", "loc", "stage", "lf", "wl", "sl", "il", "loop", "shell", "dri", "player", "home", "cl", "lr", "local", "active", "lo", "source", "rl", "seq", "fl", "len", "large", "won", "hi", "lic"], "rpos": ["lval", "rrpid", "rlen", "rcpos", " rpo", "rdpt", " rval", "lpos", " rneg", " rposition", "rclen", "rrposition", "rrpo", "srlen", "wposition", " rloc", "rposition", "srpos", "wpo", "ppo", "rneg", "ploc", "rloc", "Rposition", "lpose", "ppt", "rfpose", "srloc", "lpo", "fpo", "srposition", "rfposition", "pposition", "rcpose", "wpos", "srpo", "Rpose", "rdposition", "rpo", "rfpos", "Rpos", "crpos", "rpid", "rhposition", "wpose", "rlpt", "rrpos", "lposition", "crposition", "crneg", "rhpose", " rpose", "fposition", "ppos", "rpt", "rcposition", "wpid", "Rpush", "rfpush", "rdpo", "rlpo", " rpush", "rpush", "rcpo", "rpose", "rdpos", "crpo", "fval", "rlpos", "rhpos", "rlposition", "crpose", "fpos", " rpid", "rhneg", " rlen", "rval"], "captured": ["scure", "capture", "capturing", "missured", "Capture", " captressed", "scuring", "Capturing", "capturred", "aptured", "captected", "cturer", "cturing", "accured", " capturing", "ctored", "captored", "ctured", " captuted", "apturer", "scured", " Capturing", "apturred", "accrypted", " captrypted", " Captured", "captressed", " Capturred", "captuted", "Captured", "snapurer", "aptressed", " capthed", " capturred", "accected", "capthed", " capturer", "missurer", "missored", "accurer", "accuring", "apturing", "apture", "capturer", "missuring", "aptored", "ctrypted", "accuted", "captrypted", "ctressed", "apthed", "scurred", " capture", "snapured", "ctuted", " Capture", "Capturred", " captected", "cthed", "snapuring", "snapected"], "hw": ["wm", "hhh", "hp", "hm", "wcs", "how", "ow", "nv", "own", "him", "conn", "lv", "hop", "cv", "gew", "wd", "ww", "host", "cu", "drm", "rack", "cmp", "wo", "web", "rew", "xc", "haw", "rh", "aw", "iw", "rw", "wb", "cow", "uh", "mm", "ctx", "wp", "wow", "sh", "wn", "wy", "nw", "w", "hl", "wu", "fw", "wav", "zh", "ll", "craft", "wx", "avi", "vm", "vp", "kw", "h", "wl", "wi", "ht", "hh", "vc", "vo"], "sw": ["sb", "syn", "sel", "serv", "sk", "ow", "own", "sl", "hop", "nn", "wa", "ha", "push", "coll", "cv", "wr", "ww", "so", "ho", " SW", "pg", "sex", "wo", "oss", "ga", "mo", "rew", "web", "wh", "new", "rh", "work", "rw", "iw", "wb", "aw", "sync", "sm", "wp", "fr", "sh", "wn", "sc", "wy", "nw", "go", "wow", "w", "now", "wt", "Sw", "wan", "fl", "cr", "flo", "fw", "sf", "ew", "wx", "tw", "sem", "sn", "SW", "stream", "kw", "su", "sq", "who", "www"], "src": ["bc", "sb", "fc", "ruby", "sel", "uc", "support", "irc", "sl", "coll", "gl", "bb", "img", "cl", "scl", "gb", "secure", "sys", "rob", "cmp", "ssl", "sit", "sync", "buf", "rc", "ctx", "spec", "supp", "source", "cro", "sc", "sr", "sub", "hub", "inst", "sup", "loc", "comb", "rss", "st", "sec", "dest", "rb", "sn", "pack", "feat", "sq", "url"], "cb": ["bc", "pb", "fc", "sb", "cd", "cc", "uc", "ref", "cor", "db", "cv", "ctr", "fb", "bb", "ca", "cur", "cmp", "eb", "cmd", "cp", "grab", "obb", "ob", "cf", "ctrl", "code", "sync", "wb", "cue", "rc", "buf", "CB", "ctx", "c", "kk", "sc", "ub", "b", "cpp", "hub", "core", "call", "cdn", "callback", "co", "ab", "nb", "buff", "bf", "conf", "rb", "fn", "cod", "cgi", "ck", "abb", "gb"]}}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "substitutes": {"chr": ["echrr", " chrr", " chrs", "chrb", "Chr", "chrs", "chrc", " chru", "ichrc", "echrc", "corrs", " chlr", "chlr", "chru", " chrc", "corr", "ichr", "Chlr", "ichrr", "corrb", "echru", "echr", "ichru", "chrr", "Chrb", "Chrs", "corlr", " chrb"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n", "idx": 20766, "substitutes": {"base": ["stable", "port", "i", "name", "target", "start", "ix", "area", "ref", "scale", "part", "kit", "bin", "temp", "Base", "f", "buffer", "model", "no", "pre", "address", "bas", "size", "cache", "ip", "p", "unit", "prefix", "id", "addr", "count", "bi", "frame", "beta", "byte", "b", "ada", "set", "seq", "core", "req", "root", "boot", "bf", "parent", "block", "server", "api", "offset", "ase", "format", "type", "zero"], "irq": [" irquest", " irqs", "irisqu", " irz", "IRz", "iraqu", "IRquest", "irtz", "irz", "irqu", "irave", " irqu", "irtquest", "iraq", "IRq", " irve", "irquest", "irqs", "irtp", "irisqs", "IRp", "irisve", " irp", "irp", "iraqs", "irve", "irisq", "irtq"], "version": ["supported", "platform", "ception", "step", "versions", "class", "support", "level", "option", "scale", "connection", "feature", "generation", "model", "release", "ion", "section", "patch", "serial", "current", "number", "component", "ant", "index", "ver", "Version", "value", "python", "channel", "secret", "length", "update", "vert", "parent", "v", "VERSION", "stage", "vision", "server", "position", "action", "format", "type"], "dev": ["Dev", "priv", "grad", "e", "cam", "def", "conn", "err", "app", "valid", "DEV", "g", "driver", "result", "gu", "av", "der", "de", "d", "temp", "device", "f", "r", "u", "m", "data", "ad", "dd", "ga", "adv", "p", "enc", "serial", "mod", "od", "var", "sd", "pro", "dem", "sh", "spec", "ver", "ch", "rad", "dom", "dc", "w", "prom", "error", "n", "ve", "req", "debug", "di", "v", "conf", "ev", "k", "prop"], "s": ["sv", "sb", "e", "sym", "sk", "sl", "fs", "g", "ses", "d", "ops", "ks", "ds", "services", "device", "f", "sys", "u", "r", "m", "os", "ssl", "p", "cs", "us", "o", "ls", "sync", "is", "sg", "c", "js", "self", "spec", "sd", "si", "b", "w", "service", "session", "S", "ns", "n", "sup", "ps", "rs", "gs", "south", "v", "server", "su", "ss", "k"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 20797, "substitutes": {"cpu": ["lc", "platform", "computer", "hp", "net", "lb", "gpu", "conn", "linux", "jp", "config", "GPU", "eni", "kernel", "loop", "progress", "nic", "pkg", "performance", "CP", "consumer", "processor", "pc", "CPU", "node", "fp", "cmp", "sys", "nc", "cp", "cache", "p", "component", "cycle", "machine", "uci", "np", "que", "cli", "mac", "pool", "c", "ctx", "cn", "roc", "ocr", "loader", "uu", "python", "core", "gc", "chip", "console", "boot", "proc", "vm", "hw", "ck", "PF", "clock", "pu", "ilo"], "r1": ["er1", "r8", "sr8", "ar31", "er2", "R4", "rone", "sr2", "rcone", "R31", "rc3", "r4", "fr5", "sr3", "ar1", "ar2", "R1", "sr1", "rc2", "R3", "r2", "fr2", "rc1", " r4", "r31", "sr4", "R8", " r8", "fr1", "ar5", "er3", " rone", " r2", "Rone", "fr31", "R5", "r5", "R2"], "r3": [" r5", " r11", "er11", "r11", "R4", "er2", "rr11", "rr2", "r4", "r6", "p4", "p6", "ar1", "p1", "R1", "R3", "ar6", "rr5", "r2", "er5", "ar4", "rr3", "er3", "R6", "p3", " r2", "r5", "ar3"], "gaddr": ["ghost", "mgdb", "gaddress", "mgaddress", "_db", "mghost", "_host", "_addr", "_address", "wdb", "gdb", "waddr", "mgaddr", "waddress", "whost"], "ar": ["arc", "ap", "err", "acl", "arg", "amd", "ara", "art", "al", "ac", "args", "ad", "arr", "arp", "au", "sa", "xa", "rar", "ann", "ard", "aa", "ai", "ag", "array", "AR", "att", "ars", "cap", "rg"], "env": ["config", "event", "eni", "chal", "prov", "exc", "ini", "que", "context", "qa", "cdn", "global", "osc", "v", "conf", "ev", "inet", "end", "conn", "iv", "db", "cv", "oa", "eng", "site", "state", "enc", "code", "ext", "cfg", "ass", "fen", "qt", "ce", "uni", "scope", "net", "stack", "e", "forge", "err", "eu", "kernel", "esp", "ou", "ea", "exec", "init", "cf", "zone", "cli", "Environment", "el", "dt", "gui", "loader", "python", "core", "req", "skin", "stage", "dat", "ne", "ec", "enh", "en", "lv", "shell", "energy", "engine", "po", "esi", "nc", "args", "cache", "vs", "np", "kn", "ctx", "agent", "cn", "cal", "profile", "session", "console", "vm", "estate", "server", "environment"], "pbdev": ["lpdev", "ppdiv", "lpdiv", "sbdevice", "lpdriver", "ppdevice", "PBDev", "lpdevice", "sbdriver", "rbdev", "fbdevice", "pbDev", "fbdiv", "jpdev", "xbserial", "pprent", "cbdiv", "cbdriver", "pdevice", "fbrent", "pcDEV", "lpconf", "cberror", "PBdev", "pbdiv", "PBDEV", "pbDEV", "pcDev", "cbserial", "jpdevice", "cbdevice", "sbdev", "xbdriver", "pcdiv", "rbdevice", "jpdef", "xbdevice", "pdev", "fbdev", "pbdevice", "lpDev", "pbdef", "pcdevice", "sbserial", "PBdiv", "pbserial", "pbdriver", "pberror", "cbdev", "ppdev", "lprent", "jpdriver", "pbrent", "rbdriver", "xbdev", "lpdef", "pcconf", "fbconf", "pdiv", "lpDEV", "lperror", "pcdev", "pbconf", "rbdef"], "mr": ["wm", "hm", "bro", "err", "adr", "ml", "Mr", "rpm", "rr", "wr", "rx", "mt", "bridge", "lr", "yr", "km", "wk", "r", "m", "arr", "mc", "dr", "mer", "igr", "module", "pr", "rm", "fr", "shr", "hr", "sr", "vr", "dm", "LR", "bm", "er", "br", "gr", "rs", "vm", "kr", "gm", "MR", "attr", "mn", "mmm", "gb"], "i": ["io", "e", "pi", "d", "ti", "I", "type", "f", "ci", "r", "s", "j", "p", "ip", "or", "id", "is", "c", "a", "ii", "b", "n", "v", "z", "l", "count"], "fh": [" fhs", "tfh", "fhs", "cfw", "dfhs", " fah", " fw", "dfh", "fq", "ghs", "rfhr", "cfh", "tfht", "dfgh", " fbh", "rfh", "tfhs", "rfhs", " fH", "fhr", "lfhr", "cfsh", "tfah", " fph", "fht", "fah", "fhp", " fhp", " fsh", "fH", "fph", "fbh", "fsh", "ggh", "gq", "Fhs", "dfhp", "dfht", "fbhs", "Fgh", " fhr", "dfw", "dfq", "lfH", "Fh", "dfsh", "fw", "gh", "fgh", "lfhs", "dfah", "lfph", "fbph", "Fq", "lfbh", "lfh", "cfhp", "rfbh", "fbH", " fht"], "pcias": ["pbias", "pociasi", "pidiasing", "pciAS", "Pciasi", "piiase", "cbiAs", "cbiasi", "pdiase", "pidias", "pcmasi", "pqias", "Pciase", "cciac", "piias", "Pdiase", "piiAS", "pbiAs", "pciasi", "pqiAs", "pidiAS", "cociAS", "pciac", "Pdiasi", "Pciac", "pociAS", "PdiAS", "piliase", "cociasing", "cciAs", "Pcias", "pbiasi", "pciase", "pdias", "pkiasing", "pocias", "pkiac", "PciAS", "cociac", "pciAs", "pcmas", "piiac", "pociasing", "pqiAS", "cciAS", "pdiasi", "pqiasi", "pdiAS", "cbias", "Pdiac", "piliac", "pciasing", "cciasi", "pidiac", "ccias", "pbiAS", "cbiAS", "pkiAS", "cciasing", "pociac", "cocias", "pkias", "pilias", "pcmAs", "pdiac", "pcmAS", "Pdias", "pbiac", "piliAS"], "len": ["lc", "span", "str", "limit", "en", "conn", "sl", "acl", "val", "part", "ln", "bin", "bl", "layer", "offset", "pos", "lan", "cmp", "split", "size", "vel", "data", "rel", "lin", "fun", "depth", "dy", "le", "count", "live", "gen", "el", "lim", "body", "code", "ann", "mem", "seq", "rev", "fl", "dl", "length", "min", "loc", "lt", "den", "lon", "lib", "ler", "li", "lf", "fn", "l", "Len", "cap", "fin"], "buffer": ["row", "binary", "shape", "ba", "uffer", "extra", "null", "bb", "bin", "bytes", "transfer", "alloc", "info", "data", "arr", "buf", "raw", "blocks", "read", "Buffer", "batch", "buff", "array", "block", "empty", "cap"]}}
{"project": "qemu", "commit_id": "293d2a0014a0e849477413f55aaa05f2743b2e04", "target": 0, "func": "static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n\n                                  void *opaque)\n\n{\n\n    monitor_flush(opaque);\n\n    return FALSE;\n\n}\n", "idx": 20802, "substitutes": {"chan": ["reg", "irc", "conn", "app", "circ", "nan", "cor", "han", "Chan", "con", "bin", "ca", "can", "path", "cat", "scan", "gen", "cn", "ch", "ann", "anon", "wan", "channel", "anim", "chron", "qt", "an"], "cond": ["bc", " pri", " Cond", "rupt", " interrupt", " proc", " parent", "val", " conditional", "func", "crit", "tx", " pipe", "pipe", "Cond", "ac", "cmd", "bit", "cb", "comp", " func", "parent", "proc", "sec", " whence", " latch", "resp", "condition"], "opaque": ["OPaque", "operacity", "operaque", "iopause", "phole", "iopaqu", "paqu", "operhole", "pause", "opaqu", "ophole", "pque", "pacity", "opause", "operque", "OPause", "opacity", "OPacity", " opque", " opacity", "opque", "iopacity", "OPaqu", "iopaque", "paque", " ophole"]}}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_store_spr(int reg, TCGv t)\n\n{\n\n    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n", "idx": 20803, "substitutes": {"reg": [" REG", "rol", "port", "name", "org", "ig", "conn", "ref", "pred", "ind", " Reg", "rem", "eng", "region", "rec", "pre", "acc", "aug", "data", "stat", "rel", "ret", "mod", "fun", "addr", "registered", "tag", "num", "index", "run", "mem", "rule", "REG", "Reg", "re", "loc", "proc", "sec", "orig", "eg", "feat", "rg", "type"], "t": [" T", "ut", "i", "port", "e", "target", "vt", "g", "d", "tt", "tx", "mt", "f", "y", "u", "r", "m", "unt", "it", "ts", "p", "at", "o", "tc", "ant", "out", "c", "et", "tf", "rt", "b", "a", "T", "n", "te", "tty", "ot", "tower", "v", "qt", "nt", "ent", "pt", "l", "ht", "type"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n", "idx": 20811, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "bis", "ba", "fs", "ses", "ubs", "als", "fb", "null", "boxes", "bytes", "ops", "bid", "bes", "bing", "bas", "os", "vs", "cs", "vals", "ls", "bi", "bps", "is", "b", "bits", "blocks", "ns", "BS", "iss", "Bs", "ps", "banks", "gs", "ins", "rs", "ss"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n", "idx": 20812, "substitutes": {"opaque": ["ospac", "operacity", "operaque", "ospacity", "placity", "Oponymous", "ospaco", " opaco", "placle", "Opac", "opaco", "opacle", "ospacle", "plaque", "Opacity", "placo", "osponymous", "opacity", "operonymous", "opac", " opacity", "Opaque", "ospaque", "operac", " opacle", "oponymous"], "addr": ["grad", "target", "obj", "ref", "config", "eth", "ack", "ord", "tx", "pad", "host", "align", "node", "device", "layer", "pos", "alloc", "coord", "cmd", "address", "data", "ad", "enc", "p", "ace", "id", "buf", "index", "x", "ptr", "alias", "src", "loc", "alt", "pointer", "offset", "base", "attr"], "val": ["grad", "sel", "ul", "def", "ref", "sl", "valid", "tx", "bin", "bl", "buffer", "fat", "pos", "exec", "al", "data", "arr", "vals", "unit", "count", "slot", "el", "byte", "vol", "slice", "len", "loc", "VAL", "base", "Val", "v", "alt", "eval", "block", "x", "value"], "size": ["name", "shape", "e", "class", "en", "esc", "send", "scale", "g", "message", "sized", "Size", "ize", "pos", "address", "s", "fee", "sum", "unit", "c", "small", "capacity", "value", "length", "len", "loc", "large", "z", "sec", "SIZE", "from", "empty", "offset", "max", "count"], "b": ["pb", "sb", "i", "binary", "e", "lb", "emb", "g", "db", "be", "fb", "d", "orb", "bin", "f", "buffer", "r", "m", "ob", "p", "o", "buf", "c", "a", "w", "hub", "br", "bd", "ab", "lib", "rb", "B", "h", "l", "base", "abb", "gb"]}}
{"project": "qemu", "commit_id": "54ca9095f046dfa03c3d093cc55f6d76b61864e1", "target": 0, "func": "void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    unsigned long pc;\n\n    CPUX86State *saved_env;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);\n\n    if (ret) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc, NULL);\n\n            }\n\n        }\n\n        if (retaddr)\n\n            raise_exception_err(EXCP0E_PAGE, env->error_code);\n\n        else\n\n            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);\n\n    }\n\n    env = saved_env;\n\n}\n", "idx": 20831, "substitutes": {"addr": ["net", "name", "conn", "ref", "adr", "config", "amp", "eni", "pkg", "mode", "oa", "ord", "amd", "pad", "host", "node", "device", "layer", "proxy", "address", "socket", "data", "ad", "ip", "ace", "code", "mac", "rc", "ext", "arch", "index", "nr", "ar", "ptr", "alias", "channel", "src", "len", "sid", "pointer", "server", "offset", "base", "url", "type"], "is_write": ["is_writer", "is1read", "is1write", "is2writer", "is__write", " is_log", "is_log", "is__writer", "is2log", "is1log", " is_server", "is_server", "is_read", "is1writer", " is_read", " is_writer", "is__user", "is__server", "is2write", "is2read"], "is_user": ["is67master", "is_master", "islandadmin", "is67touch", "is_admin", "is_touch", "islandwrite", "is_use", " is_touch", " is_master", "is67write", "islanduse", "is67user", " is_use", "islanduser", " is_admin"], "retaddr": ["refarg", "revfunc", "reflayer", "refaddr", "returnaddr", "pretaddr", "returnconn", "pretfunc", "retfunc", "revroute", "revaddr", "returnlayer", "revadr", "returnarg", " retroute", "retaddress", " retfunc", " retconn", " retarg", "revaddress", "revnode", "returnaddress", " retadr", "retlayer", "refconn", "retroute", " retaddress", "refaddress", "retnode", "retconn", "retarg", "pretadr", "pretroute", "pretconn", "revconn", "retadr", "pretnode", "pretlayer", "pretaddress", " retnode"], "tb": ["atlb", " tbh", "rpb", "tlb", "ttba", "tbt", "ftfb", " tbt", "ctfb", "ftb", "atp", " tbb", "ctb", " tp", " tfb", "rp", "untbs", "atpb", "ftbs", "ttbd", "untba", "atbh", "tp", "tfb", "tbh", "rlb", "atbb", "ttbs", "tbs", "untbd", " tpb", " tbs", " tbd", "ftbt", "ttbb", " tlb", "ctbt", "atb", "ttpb", "tbb", "ttb", "tpb", " tba", "ctbs", "rb", "ttbh", "tbd", "untb", "tba"], "ret": ["reg", "def", "conn", "ref", "pet", "result", "val", "arg", "ft", "det", "tr", "Ret", "mt", "bl", "art", "al", "bit", "res", "full", "cat", " RET", "code", "ext", "lag", "et", "match", "run", "ar", "RET", "rt", "rl", "flag", "rev", "reply", "re", "pat", "len", "back", "alt", "nt", "sec", "lit", "att", "pt", "inter", "fun", "pub"], "pc": ["lc", "bc", "pb", "port", "fc", "arc", "cc", "uc", "ig", "ref", "ct", "lp", "amp", " pointer", "val", "inc", "bp", "nc", "ac", " PC", "enc", " lac", "p", "cs", "xc", "tc", "code", " plat", " RPC", "PC", "c", "rc", "mc", "index", "attr", "ctx", " rc", " dc", "cpu", "sc", "pid", "dc", "point", "cr", "vc", "pac", " protocol", " func", "proc", "pointer", " cc", "pt", "pa", "ec", " CPC", "type"], "saved_env": ["saved__stage", "saved__environment", "save_environment", "saving_state", "save_state", "saved__state", "saved2state", "saved2environment", "save_stage", "saved__env", "saving_environment", "saved2env", "save_env", "saved_stage", "saved_state", "saving_env", "saved_environment"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835, "substitutes": {"d": ["md", "dos", "i", "e", "cd", "rd", "ind", "g", "driver", "ded", "db", "ed", "wd", "dad", "xd", "de", " dd", "pd", "dh", "vd", "ds", "ld", "f", "gd", "done", "t", "u", "cmd", "m", "s", "da", "dd", "nd", "data", "ad", "j", "p", "did", "diff", "id", "dict", "o", "mod", "q", "dy", "od", "c", "dr", "module", "sd", "dx", "dom", "self", "dt", "b", "dc", "w", "in", "draw", "dm", "mad", "dl", "n", "fd", "ard", "bd", "D", "di", "dat", "h", "l", "x", "k"], "val": ["ival", "reg", "sel", "end", "err", "ref", "ind", "valid", "sl", "arg", "part", "cond", "Ret", "bl", "al", "pre", "bit", "args", "data", "dev", "stat", "vals", "unit", "slot", "elt", "live", "rot", "el", "fe", "aval", "rt", "x", "seq", "vol", "len", "VAL", "Val", "v", "alt", "sec", "eval", "all", "pt", "base", "value"], "ret": ["sat", "ut", "reg", "sel", " alt", "gt", "valid", "result", "part", "arg", "aud", "det", "rep", "pit", "Ret", "ben", "bit", " arg", "res", " pat", "rets", "fin", " RET", "rot", "out", "rc", "pin", "et", "match", "let", "RET", "rt", " Ret", "value", "flag", "rev", "pat", "re", "len", "lt", "vert", "alt", "nt", "lit", "eval", " result", "ft"]}}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n", "idx": 20840, "substitutes": {"format": ["status", "feat", "platform", "str", "package", "transform", "name", "class", "target", "attribute", "object", "language", "config", "option", "pattern", "text", "layout", "mode", "region", "file", "style", "feature", "plugin", "host", "pretty", "mt", "function", "f", "model", "fp", "path", "term", "op", "cat", "data", "size", "method", "version", "at", "unit", "id", "prefix", "act", "Format", "ant", "filename", "settings", "spec", "title", "source", "form", "value", "brand", "channel", "magic", "atter", "fd", "options", "template", "qt", "fn", "api", "sort", "base", "output", "command", "type", "letter"], "QemuOpts": ["QCryptuLibs", "QCryptoClSpec", "QCryptuClts", "QCryptoCls", "QCryptoClts", "QCryptuClo", "QCryptoOpts", "QCryptoOptSpec", "QCryptuConfigSpec", "QCryptuConfigo", "QCryptuOpts", "QCryptuConfigs", "QCryptuCls", "QCryptuClSpec", "QCryptuOptSpec", "QCryptoClo", "QCryptuOpto", "QCryptuLibts", "QCryptuOptts", "QCryptuConfigts", "QCryptoOptts", "QCryptoOpto", "QCryptuLibSpec", "QCryptuLibo"], "ov": ["sv", "kov", "opp", "vers", "ow", "oo", "own", "adr", "ur", "eu", "iv", "off", "over", "av", "obile", "oyer", "cv", "ott", "oto", "oa", "ou", "ork", "oh", "rf", "ef", "ove", "nov", "obb", "oy", "ob", "gov", "oven", "uv", "o", "ovan", "ood", "ever", "ovo", "oid", "ocr", "vr", "oval", "gr", "OV", "orf", "rov", "ovi", "ova", "lov", "boot", "ko", "erv", "ev", "voc", "oc", "fo", "vo"], "ret": ["status", "ut", "reg", "uf", "def", "ig", "obj", "ref", "gt", "conn", "vt", "result", "val", "arg", "ft", "det", "tr", "Ret", "cur", "f", "fit", "sys", "t", "al", "r", "res", "j", "cat", "full", "rets", "opt", "os", "job", "arr", "fin", "auth", "py", "success", "ext", "out", "cb", "rc", "pro", "match", "pass", "RET", "rt", "mem", "vr", "reply", "rev", "re", "session", "gr", "len", "req", "rs", "boot", "alt", "v", "nt", " result", "eval", "att", "lit", "fi", "Return", "fab", "fun"], "local_err": ["local_sys", "localLoger", " local_orig", "local_orig", "local67message", "localableorig", "local_risk", "externalalrisk", "local67err", "local67orig", "local67error", " local_er", "remote_er", "localalnr", " local_ler", " local_rr", "localWlog", "localappresult", "local67risk", "local67nr", "localableerror", "localLogexc", "external_message", "localalrisk", "local_er", "externalalnr", "remote_err", " local_result", "localapperror", "remote_exc", "localallrisk", "localLogerror", "localallerr", "externalalerr", "local_log", "localableerr", "localLogerr", "localallmessage", " local_log", "localWerror", "local_result", "localalerr", "localalmessage", "local_message", "local67sys", "localallnr", "external_risk", "localWrisk", "externalalmessage", "local_ler", " local_sys", "localapper", "localablesys", "external_nr", "local_error", "localapperr", "remote_error", "local_nr", " local_risk", "local_rr", "local_exc", "localWerr", " local_error", "external_err"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 20856, "substitutes": {"c": ["lc", "e", "cc", "ct", "config", "g", "cm", "d", "con", "pc", "cur", "cl", "f", "ci", "t", "ac", "u", "m", "s", "r", "cache", "oc", "p", "mc", "xc", "ctrl", "tc", "context", "ctx", "icc", "a", "b", "dc", "w", "cpp", "C", "v", "cit", "h", "l", "ec", "vc"], "lumFilter": ["LumbRef", "LumbFile", "lumRef", "lumbFilter", "lumFile", "LumFile", "LumRef", "lUMFilter", "LumFilter", "lumbRef", "lucRef", "lUMRef", "lucFile", "lucFilter", "LumbFilter", "lUMFile", "lumbFile"], "lumSrc": ["lumaAsrc", "lumaSsrc", "lumCsrc", "lumCuc", "lumaSuc", "lumSRC", "lumaAssrc", "lumVSuc", "lumAsuc", "lumAsrc", "lumaAsuc", "lumSuc", "lumVSRC", "lumCrc", "lumAsRC", "lumaSrc", "lumaSRC", "lumCRC", "lumVSsrc", "lumSsrc", "lumVSrc", "lumaAsRC", "lumAssrc"], "lumFilterSize": ["lumContextC", "lumFileStyle", "lulFilterSIZE", "lulFlSize", "lumFlStyle", "lumFilterC", "lumContextSIZE", "lulFlC", "lumContextSize", "lumFlC", "lumFilterStyle", "lumFlSize", "lumFileC", "lumFileSize", "lulFlStyle", "lulFlSIZE", "lumFlSIZE", "lumFileSIZE", "lulFilterC", "lumContextStyle", "lumFilterSIZE", "lulFilterStyle", "lulFilterSize"], "chrFilter": ["chrgLimit", "echreLimit", "chreHeader", "chrgHeader", "echrLimit", "chreLimit", "echreFilter", "chrgFilter", "chrLimit", "chcHeader", "chcFilter", "echreHeader", "chrHeader", "chcLimit", "echrHeader", "chreFilter", "echrFilter"], "chrUSrc": ["chrSSsrc", "chrSSrc", "chrSrc", "chrKSsrc", "chrSSRC", "chrUSRC", "chrsUSrc", "chrsUSci", "chrKSRC", "chrKSrc", "chrKSci", "chrsSci", "chrSsrc", "chrSci", "chrSRC", "chrsUSRC", "chrsSRC", "chrSSci", "chrsUSsrc", "chrUSci", "chrUSsrc", "chrsSrc", "chrsSsrc"], "chrVSrc": ["chrCSsrc", "chrgVSrc", "chrSSsrc", "chrgVSuc", "chrCSuc", "chrSSrc", "chrgVSsrc", "chrCSrc", "chrVSource", "chrgVSource", "chrSSource", "chrgSSrc", "chrSSuc", "chrNsource", "chrNsrc", "chrNsuc", "chrgSSsrc", "chrVSsrc", "chrgSSuc", "chrNssrc", "chrgSSource", "chrCSource", "chrVSuc"], "chrFilterSize": ["chrbBlockLen", "chrFilterLen", "chrBlockLen", "chrBlockSIZE", "chrFilterSIZE", "chrfilterLen", "chrFlSIZE", "chrfilterSIZE", "chrFlLen", "chrbFilterSIZE", "chrbFilterLen", "chrbBlockSize", "chrbBlockSIZE", "chrFlSize", "chrBlockSize", "chrfilterSize", "chrbFilterSize"], "alpSrc": ["alpSSdr", "alpSSrc", "alpOSRC", "alpAssrc", "alpOSrc", "alcSdr", "alpOSsrc", "alcAsdr", "alpSdr", "alcSsrc", "alpAsRC", "alpAsdr", "alpSSRC", "alcAsRC", "alcSrc", "alpSSsrc", "alpSRC", "alcAsrc", "alpAsrc", "alcSRC", "alcAssrc", "alpSsrc", "alpOSdr"], "dest": ["md", "route", "transform", "name", "target", "uc", "config", "asc", "mode", "de", "d", "home", "img", "path", "dist", "dep", "cont", "done", "dev", "data", "da", "wb", "shift", " Dest", "destroy", "cb", "Dest", "source", "match", "sc", "du", "dc", "tmp", "desc", "src", "loc", "dat", "orig", "feat", "prop"], "uDest": ["uDep", "UDep", "uDir", "vDir", "udest", "UDest", " uDir", "adest", "Udest", "UDir", "iSource", "uHome", "aSource", "vOrig", "aExt", "pDesc", "vHome", "uSource", "UHome", "iDesc", "vExt", "vdest", "uOrig", "UExt", "USource", "pSource", "pOrig", " uHome", "uExt", "vDesc", "pDest", "iDest", " uDep", "vDep", "vSource", "iOrig", "uDesc"], "vDest": [" vOrd", "uDep", "vDist", "fOrd", "hDist", "hDesc", "hDep", " vDist", "pDep", "vOrig", "pDesc", "uOrig", " vOrig", "pDist", "hDest", "vOrd", "fDist", "uDist", "vDesc", "uOrd", "pDest", "fDest", "vDep", "uDesc", "fOrig"], "aDest": ["AOrig", "apiOrig", " adest", "vaOrig", "aDist", "ASc", "sadest", "aOrig", "bdest", "adest", "apiSc", " aOrig", " aEnt", "aaOrig", " aDesc", " aSc", "bDist", "aaDest", "apiDest", "saDest", "ADest", "aaDesc", "apiEnt", "vaDesc", " aDist", "bDest", "aEnt", "vaDest", "aSc", "AEnt", "saDist", "aDesc"], "dstW": ["dstFW", "dptWS", "DndW", "DscH", "DstFW", "dostW", "dstM", "dndM", "dstB", "drcM", "DscW", "dscM", "DstW", "dstWS", "dostH", "drestWS", "DndM", "dostM", "drestM", "dptM", "dndH", "drcW", "DptW", "drestW", "DndH", "DscFW", "dscH", "dscFW", "DstM", "drestH", "DptWS", "DstH", "drcH", "dstH", "dostB", "dndW", "dptH", "DptM", "DptH", "DndB", "dscW", "DscM", "DstB", "dptW", "drcB", "dndB", "drcFW", "drestFW", "DstWS", "drcWS"], "chrDstW": ["chrLstM", "chrDscH", "chrdSTL", "chrSrcN", "chrdSTW", "chrdstGW", "chrDblW", "chrDntD", "chrdstH", "chrDrcW", "chrDblw", "chrLstw", "chrDscN", "chrDstL", "chrDrdH", "chrLstGW", "chrDrcN", "chrSstD", "chrDstw", "chrDrcM", "chrDrdW", "chrDscW", "chrSstW", "chrDstM", "chrDstGW", "chrDestw", "chrDrcD", "chrSrcD", "chrdstL", "chrDrdGW", "chrDblM", "chrDrcGW", "chrdSTGW", "chrDSTH", "chrDestM", "chrDSTL", "chrDestW", "chrDrdL", "chrDscD", "chrSstN", "chrdstW", "chrSstM", "chrDblGW", "chrDSTW", "chrdSTH", "chrDntW", "chrDestGW", "chrDSTGW", "chrDscL", "chrLestw", "chrDstH", "chrDscGW", "chrSrcM", "chrSrcW", "chrDscM", "chrDstN", "chrDntM", "chrLstW", "chrLestGW", "chrDstD", "chrDntN", "chrLestM", "chrLestW", "chrDrcw"]}}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n", "idx": 20902, "substitutes": {"key": ["KEY", "row", "name", "ee", "object", "conn", "app", "pe", "connection", "fork", "copy", "access", "path", "ro", "alloc", "ac", "entry", "fee", "size", "ip", "link", "ace", "id", "code", "mac", "pri", "index", "peer", "byte", "value", "hash", "core", "keys", "call", "child", "Key", "root", "parent", "ke", "image", "k", "type"], "opaque": ["operacity", "opaques", "operaque", "appca", "opca", "opsca", " opca", "ipace", "ipca", "opsaques", "ipacity", "ipaque", " opaques", "operca", "opace", "ophole", "operace", "opacity", "appaques", " opacity", " opace", "opshole", "appaque", "opsaque", "apphole", " ophole"], "cpu": ["lc", "platform", "lb", "gpu", "conn", "linux", "GPU", "eni", "kernel", "nic", "consumer", "copy", "processor", "piece", "uri", "pex", "pc", "CPU", "intel", "node", "css", "cmp", "proxy", "nc", "cp", "cache", "lu", "component", "uno", "cycle", "ace", "np", "mac", "cli", "sync", "pool", "px", "ctx", "cn", "roc", "capacity", "gp", "loader", "core", "gc", "auc", "chip", "cus", "boot", "proc", "vm", " CPU", "hw", "instance", "winner", "fi", "pu", "cu", "gb", "ilo"], "regidx": ["blockIdxc", "regpidy", "regIdz", "recidX", "regIDx", "regidn", "blockIdxi", "recidxs", "regidy", "regIDX", "regpidn", "rigidn", "recIdX", "regpidx", "regIDxi", "regIdxc", "blockidxc", "recidz", "regsidxy", "regsidx", "regenX", "regindz", "regidxy", "regindxes", "blockIdx", "regIDxs", "regidz", "rigindn", "blockidxs", "regidex", "blockidx", "regidexi", "regidexs", "rigidx", "regenx", "regideX", "regidxs", "regindy", "regindxy", "recIdz", "regIdX", "regidxi", "regIdxes", "regindxc", "blockidX", "blockIdxes", "regenxs", "rigindx", "blockIdxs", "regsidn", "regpidxy", "blockIdz", "recIdx", "regidxc", "blockidxes", "regIdxs", "regidX", "blockidxi", "rigidy", "blockIdX", "regindn", "regindx", "rigindy", "regsidy", "recIdxs", "blockidz", "regIdxi", "rigindxy", "recidx", "regidxes", "regIdx", "rigidxy", "regenz"], "ri": ["io", "rio", "i", "ra", "rd", "adr", "eni", "ki", "gi", "uri", "rin", "ti", "ci", "ro", "ris", "adi", "ini", "bi", "ani", "mi", "si", "ati", "rt", "ii", "rid", "RI", "ai", "xi", "co", "di", "stri", "ry", "li", "arin", "pi", "iri", "zi", "ni", "ori"], "cpreg_array_len": ["cpreg_string_pos", "cpreg_array_pos", "cpreg_string_len", "cpreg_string_count", "cpreg_arrayscount", "cpreg_array_count", "cpreg_array_val", "cpreg_arrayspos", "cpreg_arrayslength", "cpreg_string_length", "cpreg_string_base", "cpreg_array_length", "cpreg_string_val", "cpreg_arrayslen", "cpreg_array_base"]}}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_huffman_decode(unsigned char *dest, unsigned char *src)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    int counter = 0;\n\n\n\n    unsigned char bits = *ptr++;\n\n\n\n    while ( val != 0x16 ) {\n\n        if ( (1 << counter) & bits )\n\n            val = src[byte + val - 0x17];\n\n        else\n\n            val = src[val - 0x17];\n\n\n\n        if ( val < 0x16 ) {\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n\n\n        if (counter++ == 7) {\n\n            counter = 0;\n\n            bits = *ptr++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20903, "substitutes": {"dest": ["route", "txt", "target", "class", "end", "store", "config", "push", "ctr", "d", "bin", "reverse", "cont", "dist", "dep", "neg", "address", "rest", "data", "dev", "uv", "trans", "wb", "buf", "ext", "source", "Dest", "dc", "tmp", "desc", "inst", "slice", "loc", "test", "parent", "proc", "st", "prop"], "src": ["bc", "uint", "sb", "stack", "start", "sel", "ul", "support", "sl", "config", "iv", "text", "val", "ctr", "impl", "bytes", "cur", "img", "sth", "gb", "cont", "split", "socket", "data", "uv", "addr", "buf", "rc", "ctx", "cb", "source", "byte", "sc", "sr", "b", "sub", "rl", "tmp", "comp", "inst", "slice", "loc", "rs", "proc", "st", "sid", "rb", "stream", "rib", "sec", "lit", "attr", "url"], "ptr": ["uint", "priv", "grad", "xt", "ref", "iv", "prot", "val", "ctr", "impl", "tr", "pad", "cur", "pc", "fp", "sth", "buffer", "pos", "address", "inters", "data", "addr", "shift", "buf", "ext", "plug", "dr", "fe", "pert", "dim", "comp", "pull", "vr", "seq", "pend", "inst", "slice", "loc", "br", "len", "req", "eger", "Ptr", "proc", "pair", "pointer", "vec", "sp", "eval", "pt", "spl", "offset", "quad", "inter"], "counter": ["bc", "step", "limit", "prev", "loop", "controller", "result", "coll", "chain", "ctr", "cube", "stop", "card", "processor", "race", "cur", "lr", "contin", "Counter", "buffer", "per", "pixel", "info", "ter", "entry", "bit", "cmp", "r", "cache", "currency", "current", "number", "code", "field", "var", "comment", "ext", "c", "index", "num", "fe", "ver", "comp", "value", "seq", "child", "mask", "ab", "parent", "pointer", "vec", "instance", "clock", "cover", "offset", "repeat", "inter", "url", "count"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)\n\n{\n\n    return t && t->rearm;\n\n}\n", "idx": 20908, "substitutes": {"t": [" T", "i", "txt", "e", "timer", "start", "g", "time", "d", "tt", "tim", "temp", "yt", "f", "y", "r", "u", "m", "it", "tp", "tif", "tg", "ts", "p", "at", "tick", "o", "tc", "c", "tf", "dt", "rt", "b", "a", "T", "n", "tn", "test", "tty", "tower", "reset", "v", "qt", "template", "h", "att", "l", "this", "k"]}}
{"project": "FFmpeg", "commit_id": "3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba", "target": 1, "func": "static int iff_read_header(AVFormatContext *s)\n\n{\n\n    IffDemuxContext *iff = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    uint8_t *buf;\n\n    uint32_t chunk_id, data_size;\n\n    uint32_t screenmode = 0, num, den;\n\n    unsigned transparency = 0;\n\n    unsigned masking = 0; // no mask\n\n    uint8_t fmt[16];\n\n    int fmt_size;\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codec->channels = 1;\n\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n    avio_skip(pb, 8);\n\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n\n    st->codec->codec_tag = avio_rl32(pb);\n\n    iff->bitmap_compression = -1;\n\n    iff->svx8_compression = -1;\n\n    iff->maud_bits = -1;\n\n    iff->maud_compression = -1;\n\n\n\n    while(!url_feof(pb)) {\n\n        uint64_t orig_pos;\n\n        int res;\n\n        const char *metadata_tag = NULL;\n\n        chunk_id = avio_rl32(pb);\n\n        data_size = avio_rb32(pb);\n\n        orig_pos = avio_tell(pb);\n\n\n\n        switch(chunk_id) {\n\n        case ID_VHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 14)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 12);\n\n            st->codec->sample_rate = avio_rb16(pb);\n\n            if (data_size >= 16) {\n\n                avio_skip(pb, 1);\n\n                iff->svx8_compression = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_MHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 32)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 4);\n\n            iff->maud_bits = avio_rb16(pb);\n\n            avio_skip(pb, 2);\n\n            num = avio_rb32(pb);\n\n            den = avio_rb16(pb);\n\n            if (!den)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 2);\n\n            st->codec->sample_rate = num / den;\n\n            st->codec->channels = avio_rb16(pb);\n\n            iff->maud_compression = avio_rb16(pb);\n\n            if (st->codec->channels == 1)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            else if (st->codec->channels == 2)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            break;\n\n\n\n        case ID_ABIT:\n\n        case ID_BODY:\n\n        case ID_DBOD:\n\n        case ID_MDAT:\n\n            iff->body_pos = avio_tell(pb);\n\n            iff->body_end = iff->body_pos + data_size;\n\n            iff->body_size = data_size;\n\n            break;\n\n\n\n        case ID_CHAN:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            if (avio_rb32(pb) < 6) {\n\n                st->codec->channels       = 1;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            } else {\n\n                st->codec->channels       = 2;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            }\n\n            break;\n\n\n\n        case ID_CAMG:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            screenmode                = avio_rb32(pb);\n\n            break;\n\n\n\n        case ID_CMAP:\n\n            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case ID_BMHD:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size <= 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            avio_skip(pb, 4); // x, y offset\n\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n\n            if (data_size >= 10)\n\n                masking                      = avio_r8(pb);\n\n            if (data_size >= 11)\n\n                iff->bitmap_compression      = avio_r8(pb);\n\n            if (data_size >= 14) {\n\n                avio_skip(pb, 1); // padding\n\n                transparency                 = avio_rb16(pb);\n\n            }\n\n            if (data_size >= 16) {\n\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_DPEL:\n\n            if (data_size < 4 || (data_size & 3))\n\n                return AVERROR_INVALIDDATA;\n\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n\n                return fmt_size;\n\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n\n            else {\n\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            break;\n\n\n\n        case ID_DGBL:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size < 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            iff->bitmap_compression          = avio_rb16(pb);\n\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n\n            st->codec->bits_per_coded_sample = 24;\n\n            break;\n\n\n\n        case ID_DLOC:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width  = avio_rb16(pb);\n\n            st->codec->height = avio_rb16(pb);\n\n            break;\n\n\n\n        case ID_TVDC:\n\n            if (data_size < sizeof(iff->tvdc))\n\n                return AVERROR_INVALIDDATA;\n\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n\n            if (res < 0)\n\n                return res;\n\n            break;\n\n\n\n        case ID_ANNO:\n\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n\n        case ID_NAME:      metadata_tag = \"title\";     break;\n\n        }\n\n\n\n        if (metadata_tag) {\n\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n\n                return res;\n\n            }\n\n        }\n\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n\n    }\n\n\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n\n\n    switch(st->codec->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n\n\n        if (st->codec->codec_tag == ID_16SV)\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n\n        else if (st->codec->codec_tag == ID_MAUD) {\n\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n\n            } else {\n\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            st->codec->bits_per_coded_sample =\n\n                av_get_bits_per_sample(st->codec->codec_id);\n\n\n\n            st->codec->block_align =\n\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n\n        } else {\n\n        switch (iff->svx8_compression) {\n\n        case COMP_NONE:\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n\n            break;\n\n        case COMP_FIB:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n\n            break;\n\n        case COMP_EXP:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n\n            return -1;\n\n        }\n\n        }\n\n\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        iff->bpp          = st->codec->bits_per_coded_sample;\n\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n\n            st->codec->bits_per_coded_sample = 24;\n\n        }\n\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n\n        iff->masking      = masking;\n\n        iff->transparency = transparency;\n\n\n\n        if (!st->codec->extradata) {\n\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n\n        buf = st->codec->extradata;\n\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n\n        bytestream_put_byte(&buf, iff->bpp);\n\n        bytestream_put_byte(&buf, iff->ham);\n\n        bytestream_put_byte(&buf, iff->flags);\n\n        bytestream_put_be16(&buf, iff->transparency);\n\n        bytestream_put_byte(&buf, iff->masking);\n\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 20917, "substitutes": {"s": ["sv", "sim", "sb", "e", "sym", "qs", "es", "sl", "fs", "ses", "ops", "ks", "ds", "services", "f", "sys", "t", "storage", "os", "ssl", "p", "cs", "ts", "ls", "sync", "ss", "sa", "sg", "js", "c", "settings", "spec", "si", "sc", "b", "se", "S", "ns", "slice", "src", "sf", "sup", "south", "ps", "gs", "v", "sp", "bs", "su", "sq"], "iff": ["upp", "iol", "iffs", "fc", "uf", "def", "sci", "ref", "ind", "lp", "coll", "pe", "inc", "IFF", "fb", "intel", "bl", "img", "eff", "f", "fp", "fig", "ef", "cmp", "cel", "exec", "eb", "lab", "dist", "xf", "tif", "pp", "fx", "diff", "ctrl", "work", "gz", "aff", "ext", "ss", "ctx", "pl", "tf", "ipl", "comp", "ii", "pull", "gif", "ff", "qa", "imp", "sup", "slice", "fw", "sf", "fl", "co", "ist", "feed", "buff", "lib", "http", "FF", "lf", "fi"], "pb": ["lc", "platform", "bc", "sb", "fc", "summary", "uf", "lb", "prop", "uc", "txt", "bos", "asm", "jp", "lp", "prot", "db", "cv", "verb", "mb", "fb", "queue", "pkg", "bb", "pm", "phrase", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "PB", "ob", "pp", "p", "wb", "cli", "bps", "ctx", "cb", "pl", "ib", "wp", " eb", "ub", "b", "cpp", "hub", "dl", "bm", "parser", "ab", "bf", "proc", "bh", "bot", "bs", "rb", "typ", "lib", "xb", "pt", "api", "dp", "ppa", "abb", "pa"], "st": ["td", "lc", "str", "sb", "est", "start", "rd", "ast", "obj", "ct", "sl", "end", "std", "ost", "pe", "part", "kt", "St", "stop", "l", "ld", "bl", "cl", "sth", "art", "t", "rest", "nd", "bt", "sa", "c", "fe", "sd", "fr", "ste", "et", "self", "sts", "sc", "set", "tmp", "se", "cr", "sw", "inst", "src", "ist", "sf", "usc", "ST", "stage", "nt", "sp", "sn", "pt", "ust", "irst", "sta", "stab", "ss", "ft"], "buf": ["conv", "port", "uf", "cv", "queue", "img", "fp", "buffer", "alloc", "cmd", "cp", "opt", "wb", "pool", "rc", "cb", "ctx", "seq", "fd", "src", "len", "batch", "buff", "proc", "vec", "dest", "block"], "chunk_id": ["choy_info", "choy_id", "chunkername", "chunk_ids", "chunks_sid", "chunk_name", "chunk_tag", "chunks_ids", "chunkertag", "chunk_type", "chunks_type", "chunks_id", "choy_type", "chunkerid", "chunk_info", "chunk_sid", "chunkertype"], "data_size": ["sample_data", "data___rate", "data___size", "sample_address", "Data_speed", "data_address", "message_length", "load_speed", "data_loc", "data_rate", "Data_size", "sample_size", "dataqrate", "data___length", "data_data", " data_name", "data_weight", "data_speed", "data_range", "data_name", "data_length", "message_rate", "data___offset", "dataqsize", "sample_scale", "messageqlength", "dataqoffset", "message_offset", " data_range", "messageqrate", "load_size", "messageqoffset", "data_scale", "Data_scale", "data_offset", "load_weight", "message_size", "messageqsize", "dataqlength", "load_loc", "Data_length"], "num": ["col", "NUM", "name", "un", "en", "off", "om", "inc", "ord", "con", "bin", "umi", "img", "no", "cmp", "nom", "split", "bit", "data", "unit", "id", "mod", "tu", "gen", "index", "dim", "mem", "seq", "n", "len", "loc", "nb", "Num", "uni", "block", "lit", "nu", "um", "mn", "sum"], "den": ["def", "en", "err", "ind", "nan", "none", "val", "mode", "con", " len", "done", "nc", "dev", "nd", "diff", "dy", "Den", "dim", "error", "desc", "mask", "len", "orig", "ne", "sum"], "fmt": ["xfmt", " fflags", " fver", "fver", "xfnt", "frnt", "frver", "frmt", " fnt", "xfflags", "xfver", "fflags", "frflags", "fnt"], "fmt_size": ["fformat_size", "fmt_len", "fformat_scale", "fmt_scale", "fmt_capacity", "fformat_len", "fformat_capacity"], "orig_pos": ["Orig_position", "orig_post", " orig_len", "orig_position", " orig_loc", "orig_loc", " orig_position", "Orig_pos", "Orig_post", "Orig_len", "orig_len"], "res": ["reg", "NUM", " val", "off", " ret", "val", "RES", "rem", "con", " rs", "no", "N", "r", " vers", "Res", " seq", "rc", "gen", "ver", " rc", " mem", "seq", " rem", "len", "req", "Num", "nt"], "metadata_tag": ["metadata_type", "metadata__pos", "meta_type", "metadata__tag", "metadata__loc", "metadata_pos", "meta_tag", "meta_pos", "metadata_loc", "metadata__type", "meta_loc"]}}
{"project": "FFmpeg", "commit_id": "f3ace37a3b8c93218630a37b7df4dc195f1215a9", "target": 1, "func": "static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n\n{\n\n    int err, i, dash = 0, result = 0, code_found = 0;\n\n    char buf[CONTROL_BUFFER_SIZE];\n\n    AVBPrint line_buffer;\n\n\n\n    if (line)\n\n        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    while (!code_found || dash) {\n\n        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n\n            av_bprint_finalize(&line_buffer, NULL);\n\n            return err;\n\n        }\n\n\n\n        av_log(s, AV_LOG_DEBUG, \"%s\\n\", buf);\n\n\n\n        if (strlen(buf) < 4)\n\n            continue;\n\n\n\n        err = 0;\n\n        for (i = 0; i < 3; ++i) {\n\n            if (buf[i] < '0' || buf[i] > '9')\n\n                continue;\n\n            err *= 10;\n\n            err += buf[i] - '0';\n\n        }\n\n        dash = !!(buf[3] == '-');\n\n\n\n        for (i = 0; response_codes[i]; ++i) {\n\n            if (err == response_codes[i]) {\n\n                if (line)\n\n                    av_bprintf(&line_buffer, \"%s\", buf);\n\n                code_found = 1;\n\n                result = err;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (line)\n\n        av_bprint_finalize(&line_buffer, line);\n\n    return result;\n\n}\n", "idx": 20918, "substitutes": {"s": ["sv", "sb", "e", "qs", "es", "sk", "sl", "fs", "g", "ses", "ssh", "d", "ks", "ds", "f", "t", "u", "r", "m", "ssl", "os", "ts", "cs", "p", "us", "ls", "o", "sync", "cli", "sg", "c", "js", "ctx", "client", "spec", "sq", "sc", "a", "b", "service", "se", "session", "ns", "south", "gs", "http", "v", "l", "ss"], "line": ["status", "lc", "str", "row", "name", "limit", "Line", "e", "fail", "valid", "lined", "result", "text", "db", "force", "lines", "file", "d", "parse", "cl", "cell", "buffer", "nl", "ine", "entry", "data", "bug", "liner", "link", "id", "lin", "code", "sync", "cli", "LINE", "comment", "header", "frame", "source", "error", "call", "len", "page", "v", "user", " result", "block", "server", "l", "base", "url", "notice"], "response_codes": ["responseCitems", "response_strings", "responseClevels", "responseervalues", "response_cells", "responseXcodes", "response_items", "responseClines", " response_values", "responseXlines", " response_errors", " response_lines", "response_code", " response_strings", "responseercode", "responseXitems", "responseCcodes", " response_items", "response_errors", " response_cells", "response_values", "responseererrors", "response_lines", "responseXlevels", "response_levels", " response_levels", "responseercells", "responseercodes", " response_code", "responseerstrings"], "err": ["status", "md", "str", "e", "next", "ind", "result", "progress", "ger", "message", "der", "extra", "acer", "Er", "rr", "style", "cur", "l", "lr", "order", "r", "phi", "msg", "bug", "init", "ir", "arr", "diff", "runner", "code", "rh", "inner", "var", "comment", "dy", "dr", "fe", "spec", "fr", "nr", "die", "ver", "sr", "error", "Error", "cr", "er", "gr", "br", " Err", "grade", "req", "mr", "iter", "doc", "ner", "ler", "rage", "orig", "ise", "kr", "ie", "attr", "type"], "i": ["io", "lc", "e", "ix", "ie", "qi", "ri", "ui", "eni", "result", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "y", "t", "r", "phi", "m", "info", "ini", "j", "oi", "u", "p", "ip", "diff", "id", "code", "bi", "o", "cli", "mi", "inner", "c", "mu", "index", "si", "a", "ii", "b", "x", "ji", "n", "iu", "ai", "xi", "iter", "di", "z", "multi", "v", "li", "uni", "yi", "pi", "fi", "zi", "ni"], "buf": ["bc", "config", "map", "pad", "buffer", "path", "msg", "data", "context", "wb", "font", "header", "bo", "ff", "src", "br", "bd", "ab", "batch", "doc", "proc", "rb", "output", "str", "ru", "uf", "txt", "text", "db", "cv", "null", "bb", "enc", " buffer", "code", "rc", "cb", "desc", "bh", "bag", "vec", "conv", "uc", "result", "fb", "queue", "func", "lines", "bytes", "Buff", "cas", "cmd", "box", "cf", "b", "fd", "loc", " buffers", "Buffer", "buff", "bf", "pb", "port", "input", "grab", "ctx", "seq", "block"], "line_buffer": ["lin_cache", "linkAreference", "lineacbuffer", "line_data", "inline_queue", "linkAbuffer", "link_buff", "line_buf", "LINE_resource", "lineAbuff", "line_cache", "link_buffer", "lineCdata", "lineAwriter", "LINE_data", "block_buffer", "line___resource", "link_reference", "lineCreference", "lineCbuff", "line_header", "LINEChandler", "lineAreference", "line___buffer", "lineCwriter", "line_resource", "line_writer", "lin_header", "linkAwriter", "lineacheader", "LINE_buffer", "line_handler", "lineChandler", "line_buff", "block_buff", "inline_length", "lin_buffer", "line64buffer", "line_length", "lineAbuffer", "block_buf", "lineaccache", "link_writer", "line_reader", "lin_window", "line_reference", "line64data", "LINE_handler", "block_queue", "lineCbuffer", "line_window", "LINECresource", "lineacwindow", "LINECdata", "line64handler", "lineCresource", "LINECbuffer", "line___data", "linkAbuff", "line_queue", "inline_buffer", "inline_reader", "line64resource", "line___handler"]}}
{"project": "qemu", "commit_id": "26e92f65525ef4446a500d85e185cf78835922aa", "target": 0, "func": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)\n\n{\n\n    arm_sysctl_state *s = (arm_sysctl_state *)opaque;\n\n\n\n    switch (offset) {\n\n    case 0x00: /* ID */\n\n        return s->sys_id;\n\n    case 0x04: /* SW */\n\n        /* General purpose hardware switches.\n\n           We don't have a useful way of exposing these to the user.  */\n\n        return 0;\n\n    case 0x08: /* LED */\n\n        return s->leds;\n\n    case 0x20: /* LOCK */\n\n        return s->lockval;\n\n    case 0x0c: /* OSC0 */\n\n    case 0x10: /* OSC1 */\n\n    case 0x14: /* OSC2 */\n\n    case 0x18: /* OSC3 */\n\n    case 0x1c: /* OSC4 */\n\n    case 0x24: /* 100HZ */\n\n        /* ??? Implement these.  */\n\n        return 0;\n\n    case 0x28: /* CFGDATA1 */\n\n        return s->cfgdata1;\n\n    case 0x2c: /* CFGDATA2 */\n\n        return s->cfgdata2;\n\n    case 0x30: /* FLAGS */\n\n        return s->flags;\n\n    case 0x38: /* NVFLAGS */\n\n        return s->nvflags;\n\n    case 0x40: /* RESETCTL */\n\n        return s->resetlevel;\n\n    case 0x44: /* PCICTL */\n\n        return 1;\n\n    case 0x48: /* MCI */\n\n        return 0;\n\n    case 0x4c: /* FLASH */\n\n        return 0;\n\n    case 0x50: /* CLCD */\n\n        return 0x1000;\n\n    case 0x54: /* CLCDSER */\n\n        return 0;\n\n    case 0x58: /* BOOTCS */\n\n        return 0;\n\n    case 0x5c: /* 24MHz */\n\n        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());\n\n    case 0x60: /* MISC */\n\n        return 0;\n\n    case 0x84: /* PROCID0 */\n\n        /* ??? Don't know what the proper value for the core tile ID is.  */\n\n        return 0x02000000;\n\n    case 0x88: /* PROCID1 */\n\n        return 0xff000000;\n\n    case 0x64: /* DMAPSR0 */\n\n    case 0x68: /* DMAPSR1 */\n\n    case 0x6c: /* DMAPSR2 */\n\n    case 0x70: /* IOSEL */\n\n    case 0x74: /* PLDCTL */\n\n    case 0x80: /* BUSID */\n\n    case 0x8c: /* OSCRESET0 */\n\n    case 0x90: /* OSCRESET1 */\n\n    case 0x94: /* OSCRESET2 */\n\n    case 0x98: /* OSCRESET3 */\n\n    case 0x9c: /* OSCRESET4 */\n\n    case 0xc0: /* SYS_TEST_OSC0 */\n\n    case 0xc4: /* SYS_TEST_OSC1 */\n\n    case 0xc8: /* SYS_TEST_OSC2 */\n\n    case 0xcc: /* SYS_TEST_OSC3 */\n\n    case 0xd0: /* SYS_TEST_OSC4 */\n\n        return 0;\n\n    default:\n\n        printf (\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 20938, "substitutes": {"opaque": ["OPaque", "operacity", "opaques", "operaque", "plaques", "OPaques", " opaco", "ipaques", "ipaque", "opaco", "plque", " opaques", "ipaco", "plaque", "placo", "OPaco", "ipque", "opacity", "OPacity", " opque", " opacity", "opque", "operaques", "operaco"], "offset": ["delay", "port", "i", "start", "off", "ref", "mode", "null", "pad", "align", "fp", "buffer", "pos", "alloc", "address", "entry", "size", "data", "seed", "number", "prefix", "slot", "addr", "operation", "sync", "shift", "timeout", "o", "index", "ptr", "set", "location", "seek", "alias", "error", "Offset", "length", "loc", "len", "reset", "range", "array", "pointer", "empty", "position", "base", "padding", "type", "zero"], "s": ["status", "ands", "ions", "ors", "sb", "i", "e", "outs", "sym", "qs", "es", "fs", "ses", "ing", "als", "ed", "lines", "d", "sets", "ops", "irs", "ches", "ings", "l", "ds", "services", "f", "eds", "r", "m", "its", "os", "p", "cs", "ts", "or", "o", "ports", "sync", "ls", "ss", "ments", "c", "ances", "ants", "ows", "a", "b", "w", "ims", "session", "S", "n", "er", "words", "ps", "ins", "gs", "ers", "instance", "erences", "ies", "scope", "ips", "sq", "itions", "states"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_is_self(cpu)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    wi.free = false;\n\n    if (cpu->queued_work_first == NULL) {\n\n        cpu->queued_work_first = &wi;\n\n    } else {\n\n        cpu->queued_work_last->next = &wi;\n\n    }\n\n    cpu->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(cpu);\n\n    while (!wi.done) {\n\n        CPUState *self_cpu = current_cpu;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        current_cpu = self_cpu;\n\n    }\n\n}\n", "idx": 20945, "substitutes": {"cpu": ["lc", "computer", "fc", "gpu", "conn", "linux", "config", "nic", "eni", "pkg", "processor", "process", "pc", "CPU", "node", "fp", "css", "cmp", "ci", "custom", "nc", "cp", "gru", "cache", "lu", "component", "current", "cycle", "osi", "tc", "np", "uci", "cli", "mac", "cow", "wei", "c", "ctx", "cfg", "roc", "loader", "cpp", "core", "gc", "auc", "chip", "pai", "proc", "vm", "hw", "winner", "clock", "instance", "fi", "pu", "cu"], "func": ["conv", "lc", "bc", "package", "reg", "fc", "name", "cc", "wrapper", "conn", "loop", "val", "pkg", "unc", "fb", "apply", "pc", "function", "f", "fp", "exec", "sys", "alloc", "nc", "custom", "cmd", "full", "super", "cf", "mc", "job", "mod", "code", "work", "sync", "mac", "word", "c", "cb", "ctx", "module", "lambda", "comp", "b", "go", "value", "worker", "seq", "auc", "src", "callback", "co", "task", "doc", "proc", "fn", "wrap", "fun"], "data": ["start", "next", "fail", "config", "ui", "result", "wa", "val", "this", "none", "input", "key", "Data", "progress", "processor", "paid", "function", "device", "results", "done", "write", "exec", "pos", "buffer", "one", "fee", "da", "cache", "args", "lu", "new", "na", "last", "current", "work", "wei", "body", "buf", "mu", "ctx", "self", "lambda", "du", "missing", "future", "DATA", "draw", "worker", "call", "reader", "media", "foo", "partial", "callback", "base", "di", "parent", "proc", "multi", "dat", "block", "api", "fi", "value"], "wi": ["wm", "wal", "ee", "WI", "iri", "lp", "ui", "wine", "wa", "eni", "wife", " Wi", "gi", "ki", "ti", "wid", "Wi", "hei", "ci", "wk", "wo", "ini", "wiki", "fee", "wic", "lu", "wake", "wei", "iw", "bi", "mi", "ani", "mu", "wp", "cfg", "wy", "gui", "nw", "w", "wan", " wifi", "wu", "xi", " wo", "hi", "di", "wx", "yi", "wig", "hw", "kw", " pci", "wl", "fi", "ski", "ni", "wit"], "self_cpu": ["self_lc", "self__gpu", "self__cpu", "self_processor", " self_processor", " self_pu", " self_lc", "self__processor", "self_gpu", " self_clock", "self__pu", "self_clock", " self_gpu", "self_pu"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "double avpriv_strtod(char *restrict nptr, char **restrict endptr)\n\n{\n\n    char *end;\n\n    double res;\n\n\n\n    /* Skip leading spaces */\n\n    while (isspace(*nptr))\n\n        nptr++;\n\n\n\n    if (!av_strncasecmp(nptr, \"infinity\", 8)) {\n\n        end = nptr + 8;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"inf\", 3)) {\n\n        end = nptr + 3;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"nan\", 3)) {\n\n        end = check_nan_suffix(nptr + 3);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"+nan\", 4) ||\n\n               !av_strncasecmp(nptr, \"-nan\", 4)) {\n\n        end = check_nan_suffix(nptr + 4);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"0x\", 2) ||\n\n               !av_strncasecmp(nptr, \"-0x\", 3) ||\n\n               !av_strncasecmp(nptr, \"+0x\", 3)) {\n\n        /* FIXME this doesn't handle exponents, non-integers (float/double)\n\n         * and numbers too large for long long */\n\n        res = strtoll(nptr, &end, 16);\n\n    } else {\n\n        res = strtod(nptr, &end);\n\n    }\n\n\n\n    if (endptr)\n\n        *endptr = end;\n\n\n\n    return res;\n\n}\n", "idx": 20958, "substitutes": {"nptr": [" neger", "onwr", " npad", "noptr", "Npad", "neptr", "unstruct", " npointer", "inpad", "Nwr", "noplug", "anplug", "nanptr", "nonsth", "unprot", "nectr", "anpointer", " ndr", " nreq", "noprot", "nnptr", "ntr", "neplug", "npert", "lpointer", "enptr", "onptr", "cpert", "unproc", " npeer", " nfer", "onsth", "nanpert", "cpointer", " nport", "Nproc", " naddr", "necert", "nnctr", "nerust", "unpert", "nonptr", "nojug", "nstruct", "onpert", "onpointer", "nonstruct", "Nplug", "naddr", "unplug", "npeer", "unjug", "injug", "nanproc", "Nptr", "nplug", "inpert", "lpad", "nrust", "nejug", "inport", "ensth", "nnpointer", "enproc", "nfp", "csth", "unpointer", "insth", "enpad", "npointer", " nctr", "enreq", "nnfp", "Nctr", "neproc", "nepointer", "nonpert", "unpad", "nsth", " nplug", "neger", "enpointer", "anpert", "onstruct", "ltr", "nopointer", "entr", " njug", "Nsth", "unpeer", "nfer", "unport", "lcert", "nPtr", " nproc", "nostruct", "nepert", "nreq", "lreq", "npad", "Npeer", "enplug", "nopert", "inpointer", "nproc", "lptr", "lpert", "uneger", "lproc", "norust", "anptr", "inplug", " ntr", "cproc", " nstruct", "nwr", "naneger", "ondr", " npert", "enstruct", "unPtr", "nprot", "enpeer", "Npert", "nefer", "nocert", " nfp", "unfer", " nwr", "njug", "cptr", "Nfp", "Naddr", "cprot", "enPtr", "nonpointer", "noproc", "cstruct", "nnaddr", "inrust", "inptr", " nPtr", "ndr", "ncert", "nctr", "Ndr", "unptr", "Npointer", "enpert", "nport"], "endptr": ["startPtr", "adptr", "endPtr", " endproc", "allpointer", "endtr", "endpointer", "adtr", "startptr", "naddr", "alltr", "startaddr", "endproc", " endaddr", "nPtr", "endaddr", "allPtr", "adpointer", "nproc", " endtr", "startproc", " endpointer", "npointer", "startpointer", "adPtr", "allptr", " endPtr"], "end": ["begin", "row", "es", "next", "END", "post", "eff", "pos", "win", "order", "r", "address", "use", "rest", "last", "work", "ff", "n", "ent", "eval", "End", "est", "ion", "ac", "ad", "enc", "ext", "c", "add", "pass", "set", "best", "offset", "sum", " End", "after", "e", "ort", "result", "region", "stop", "one", "size", "it", "init", "head", "nd", "p", "mid", "find", "edge", "enable", "ending", "core", "enter", "error", "api", "x", "shape", "start", "en", "and", "send", "obj", "get", "final", "id", "inner", "is", "close", "index", "run", "append", "update", "range", "all", "ended", "max", "url", "value"], "res": ["feat", "str", "reg", "ras", "row", "obj", "err", "rows", "result", "val", "ress", "RES", "region", "rx", "rec", "css", "results", "rez", "r", "rest", "final", "rel", "args", "os", "ret", "Res", "cs", "vals", "arr", "rh", "reed", "rus", "out", "js", "resh", "pass", "ver", "real", "des", "pres", "ms", "rev", "re", "details", "gr", "len", "rss", "req", "rs", "reset", "range", "resolution", "resource", " Res", "scope", "x", "resp", "max", "sum"]}}
{"project": "FFmpeg", "commit_id": "b2a8850969b89151677253be4d99e0ba29212749", "target": 0, "func": "static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {\n\n    double time = av_gettime() / 1000000.0;\n\n    /* update current video pts */\n\n    is->video_current_pts = pts;\n\n    is->video_current_pts_drift = is->video_current_pts - time;\n\n    is->video_current_pos = pos;\n\n    is->frame_last_pts = pts;\n\n    check_external_clock_sync(is, is->video_current_pts);\n\n}\n", "idx": 20961, "substitutes": {"is": ["ois", "isa", "obs", "i", "was", "serv", "es", "bis", "app", "ri", "fs", "ui", "ses", "kit", "sis", "ops", "mis", "as", "css", "get", "IS", "isc", "can", "sys", "pick", "info", "s", "lis", "its", "it", "isu", "init", "os", "state", "ip", "Is", "us", "id", "cs", "ls", "isl", "que", "js", "self", "ar", "ii", "in", "ic", "ics", "parts", "has", "ai", "iss", "iso", "ins", "boot", "cms", "ais", "http", "bs", "isi", "image", "ie", "ss", "iris"], "pts": ["ntds", "pptimes", "emptds", "cts", "pgd", "pgp", "ppp", "prs", "empts", "psd", "emptsets", "ptsets", "ptd", "ptt", "pst", "ntsets", "nts", "ctt", "prd", "ppd", "pgtimes", "ptp", "ntd", "nttimes", "PTs", "ptds", "pss", "pttimes", "ctd", "PTds", "ntp", "prt", "PTsets", "pgs", "pps"], "pos": ["str", "port", "name", "start", "obj", "val", "time", "cond", "pc", "offset", "po", "neg", "op", "data", "os", "Pos", "diff", "unit", "pr", "pass", "pose", "pid", "pres", "seq", "min", "src", "loc", "len", "proc", "up", "sec", "sp", "tz", "clock", "block", "position", "pt", "oc", "base"], "serial": [" error", "port", " alt", " end", " z", " mode", " sleep", " len", " pack", " tag", " def", "Pos", " seq", " date", " port", " cur", " dest", " cond", " packed", " disp", " vel", " code", " trans", " neg", " prop", " dev", " ref", " ver"]}}
{"project": "qemu", "commit_id": "a659979328fb6d4d6100d398f5bd9a2310c3e169", "target": 0, "func": "open_f(int argc, char **argv)\n\n{\n\n\tint flags = 0;\n\n\tint readonly = 0;\n\n\tint growable = 0;\n\n\tint c;\n\n\n\n\twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 's':\n\n\t\t\tflags |= BDRV_O_SNAPSHOT;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\n\t\t\tflags |= BDRV_O_NOCACHE;\n\n\t\t\tbreak;\n\n\t\tcase 'r':\n\n\t\t\treadonly = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'g':\n\n\t\t\tgrowable = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&open_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (!readonly) {\n\n            flags |= BDRV_O_RDWR;\n\n        }\n\n\n\n\tif (optind != argc - 1)\n\n\t\treturn command_usage(&open_cmd);\n\n\n\n\treturn openfile(argv[optind], flags, growable);\n\n}\n", "idx": 20970, "substitutes": {"argv": ["agp", "agvs", "docvp", "docV", "argsp", "genf", "docc", "incv", "argsv", " argc", "agv", "argsvs", "argvp", "argp", " argp", "incvp", "genp", "argV", "docv", "genv", "incV", " argf", "argf", "incc", " argvs", " argvp", "argsc", "agc", " argV", "genvs", "argsf", "argvs", "argc"], "c": ["lc", "i", "fc", "arc", "e", "cc", "cd", "ct", "g", "d", "pc", "cl", "f", "ci", "t", "nc", "cmd", "ac", "r", "s", "m", "cp", "opt", "p", "cf", "or", "cs", "enc", "o", "code", "xc", "mc", "rc", " rc", "ch", "a", "b", "dc", "w", "cy", "cr", "n", "C", "v", "ce", "z", "h", "l", "x", "ec", "k", "type"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n", "idx": 20975, "substitutes": {"s": ["sv", "sb", "i", "e", "sym", "es", "sie", "sl", "hs", "g", "ses", "fs", "private", "su", "sports", "d", "sis", "ops", "site", "ks", "ds", "services", "f", "sys", "t", "series", "u", "m", "its", "state", "ssl", "os", "ts", "cs", "p", "ls", "o", "sync", "is", "ss", "c", "js", "self", "spec", "settings", "si", "a", "b", "service", "ms", "se", "n", "S", "ns", "south", "rs", "gs", "ps", "conf", "h", "secondary", "l", "sq", "states"], "buf": ["bc", "pb", "port", "uf", "uc", "config", "text", "result", "map", "db", "cv", "fb", "queue", "func", "bin", "pad", "img", "fp", "cas", "buffer", "alloc", "cmd", "box", "data", "cache", "cat", "cf", "context", "rc", "cb", "ctx", "aux", "b", "ptr", "bo", "seq", "ff", "fd", "src", "bd", "br", "cap", "Buffer", "ab", "batch", "cast", "buff", "bh", "array", "bag", "rb", "vec", "block", "output", "fab"], "event_code": ["eventoptype", "resource_cod", "event_status", "eventopcase", "media_count", " event_type", "resource_codes", " event_status", "eventopscore", "event_score", " event_case", "eventercode", "eventersize", "event_cod", "resourcealcode", "eventopcode", "resource_code", "resource_size", "event_cycle", "media_score", "event_size", "eventalcod", "eventercod", "eventopstatus", " event_count", "media_cycle", "eventopcount", "event_case", "eventalcodes", "event_count", "event_key", "resourcealsize", "eventalkey", "eventalstatus", "media_key", "eventalsize", "eventercodes", "event_codes", "eventopcycle", "resourcealcodes", "eventalcode", "event_type", "eventalcount", "media_code", "resourcealcod"], "media_status": ["photo_stat", "media_rate", "media_result", "event_status", "mediaacstat", "mediafstat", "media_stats", "mediaalstats", "photoalrate", "image_status", "photoalstats", "media_settings", "image_type", "mediaalstatus", "audio_stat", "media_type", "mediafsettings", "media_stat", "media_source", "resource_code", "mediafsync", "mediafnum", "resource_status", "image_source", "photo_rate", "mediaacnum", "photoalstatus", "resource_stat", "event_num", "mediaacstatus", "audio_status", "photo_status", "mediaacstats", "resource_result", "audio_settings", "media_speed", "mediafstatus", "event_stat", "media_num", "audio_sync", "mediaalrate", "mediafstats", "event_stats", "photo_stats", "mediaalstat", "event_type", "media_code", "image_speed", "media_sync", "photoalstat"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n", "idx": 20994, "substitutes": {"hotplug_dev": ["hotpack_device", "hotlog_def", "hotlog_dev", "hotpack_conn", "hotplug_div", "hotlog_conf", "hotpack_dev", "hotplug_def", "hotlog_ev", "hotplug_ev", "hotplug_device", "hotpack_div", "hotplug_conf", "hotplug_conn"], "dev": ["md", "Dev", "priv", "grad", "def", "sk", "ow", "conn", "err", "DEV", "driver", "der", "wd", "d", "vd", "engine", "device", "f", "adv", "info", "data", "nov", "state", "dd", " def", "p", "diff", "mod", " d", "self", "dem", "dom", "ver", "dim", "rad", "ch", " device", "w", "dm", "prom", "error", " dom", " Dev", "req", "di", "v", "conf", "development", "ev", " dw"], "errp": ["rrP", "corsp", "rrpre", "erpre", "arylp", "erlp", "rrp", "corP", "aryP", "rrlp", "corr", "arypre", "errP", "errsp", " errsp", "errpre", "errlp", "errorP", " errP", "errorr", "erp", "erP", "errr", "aryp", "errorsp", " errr", "corp", "errorp"], "vdev": ["Vdiff", "nvdevice", " vsd", "wde", "vdef", "vvar", "nvdev", "lsd", "vmdevice", "nvsd", "Vvar", " vdevice", "Vde", "nvdef", "vdevice", "wdevice", "ldevice", "ldef", "wdev", " vdef", "vmdev", "ldev", "vsd", "fdev", "fde", "fdevice", "vde", "vmdiff", "vmvar", "Vdev", " vdiff", " vvar", "vdiff", "Vdevice"], "s": ["sv", "sb", "i", "e", "sk", "es", "sl", "g", "ses", "d", "ks", "l", "ds", "services", "f", "sys", "t", "r", "m", "storage", "os", "ssl", "p", "cs", "o", "ls", "sync", "sa", "sg", "c", "js", "self", "spec", "sq", "sh", "si", "b", "w", "service", "se", "n", "S", "ns", "ps", "south", "gs", "v", "conf", "sp", "sn", "server", "su", "ss"], "sd": ["md", "td", "sv", "sb", "cd", "sk", "sam", "sl", "std", "ed", "d", "vd", "pd", "dh", "ds", "ld", "gd", "ci", "df", "dd", "ad", "hd", "cs", "od", "sa", "sg", "sh", "si", "sc", "se", "dl", "fd", "sf", "bd", "SD", "di", "sn", "ss"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,\n\n                                    SocketAddress *addr,\n\n                                    Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_connect_sync(ioc, addr);\n\n    fd = socket_connect(addr, NULL, NULL, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_connect_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_connect_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20996, "substitutes": {"ioc": ["iooc", "tioc", "atiocol", "ioroc", "ioorp", "iocation", "uiroc", "iec", "atioc", "iroc", "piec", "piocation", "iOC", "siorp", "atiocl", "iaoc", "tiocl", "ioci", "yioc", "ioocol", "airoc", "uioc", "ciroc", "iocol", "atiocation", "uiocl", "iorp", "ioocl", "aioc", "xioci", "ioOC", "yiocl", "iioc", "iaorp", "aiOC", "sioc", " ioci", "aiocl", "ciocation", "iaec", "atiorp", "iaocation", "tiocation", "siec", "xioc", "xiocl", "iiocol", "atiroc", "cioc", "yioci", "iiocl", "ciocl", " iocl", "iiorp", "piorp", "siocation", "tiroc", "uiOC", "pioc", "iocl"], "addr": ["md", "start", "conn", "ast", "adr", "ref", "amp", "kt", "pkg", "eth", "ack", "oa", "ord", "wd", "afi", "amd", "rr", "host", "ea", "layer", "alloc", "ac", "r", "address", "socket", "ad", "ip", "osi", "ace", "od", "dr", "rn", "add", "ar", "ann", "rt", "ptr", "Address", "arm", "ock", "server", "offset", "attr", "url"], "errp": ["errcp", "morep", "errps", "errorfp", "err", "corq", "errorq", "corfp", "rP", "rr", " errcp", "rp", " errc", "errq", "errorcp", " errfp", "moreps", "Erp", "morec", "morer", "Erps", "errfp", "errP", "Err", " errps", " errq", "errc", "Erc", "rfp", "erfp", " errP", "corcp", "erp", "errr", "erP", " errr", "corp", "errorp"], "fd": ["md", "fa", "td", "fc", "fff", "cd", "conn", "fail", "ct", "fs", "db", "cond", "connection", "fb", "wd", "d", "vd", "xd", "handler", "ln", "pd", "temp", "draft", "ds", "ld", "fp", "f", "dn", "FD", "df", "gd", "pipe", "fee", "socket", "dd", "nd", "hd", "fx", "cf", "fun", "dy", "ffff", "buf", "c", "fe", "sd", " fid", "dt", "du", "pid", "dc", "fm", "fed", "dl", "fl", "flo", "len", "bd", "sf", "fw", "ff", "fen", "bf", "fn", "lf", "fi", "fin"]}}
{"project": "FFmpeg", "commit_id": "e30b068ef79f604ff439418da07f7e2efd01d4ea", "target": 1, "func": "static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    /** when the frame data does not need to be concatenated, the input buffer\n        is resetted and additional bits from the previous frame are copyed\n        and skipped later so that a fast byte copy is possible */\n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);", "idx": 21007, "substitutes": {"s": ["sv", "i", "es", "uns", "xs", "ds", "sys", "y", "ssl", "os", "ts", "cs", "us", "js", "aws", "ms", "n", "S", "ns", "rs", "ins", "l", "this", "ss", "sb", "g", "ses", "sets", "as", "services", "o", "sites", "sg", "c", "self", "su", "e", "sym", "qs", "tests", "hs", "fs", "f", "new", "p", "si", "b", "service", "core", "ps", "gs", "h", "sq", "sl", "your", "ops", "ks", "m", "args", "its", "vs", "ls", "sync", "is", "settings", "ctx", "in", "w", "se", "session"], "gb": ["gio", "bc", "pb", "git", "sb", "binary", "uf", "lb", "gpu", "gt", "usb", "g", "gram", "gal", "ui", "db", "mb", "gnu", "fb", "bb", "og", "gin", "ged", "bin", "bp", "pc", "bridge", "gd", "buffer", "Gb", "ga", "phy", "eb", "lab", "bg", "gru", "storage", "tg", "gy", "kb", "gg", "bps", "py", "sg", "ges", "cb", "ctx", "cfg", "si", "gp", "ub", "b", "hub", "ym", "gc", "bm", "game", "nb", "gs", "buff", "bf", "boot", "gam", "GB", "rb", "gm", "cgi", "abb", "rg"], "len": ["lc", "span", "limit", "un", "en", "ig", "end", "conn", "ie", "sl", "lp", "il", "val", "ln", "bin", "align", "bl", "ld", "f", "offset", "pos", "lan", "ell", "size", "data", "lu", "rel", "lock", "lin", "ls", "dy", "elt", "count", "le", "la", "fun", "el", "lim", "lif", "line", "hl", "dl", "fl", "n", "length", "lt", "ll", "lon", "lib", "z", "alt", "li", "lf", "lang", "lit", "all", "l", "base", "Len", "fin"], "append": ["odd", "opp", "end", "fail", "app", "send", "next", "adj", "nn", "flower", "push", "none", "text", "obj", "post", "force", "true", "extra", "repeat", "apply", "pad", "write", "fake", "op", "optional", "open", "escape", "advert", "add", "enable", "ending", "replace", "pend", "atten", "element", "insert", "callback", "update", "vert", "except", "all", "att", "ended", "ppa"], "buflen": ["bucessen", "Buflatten", "bullenn", " bullenn", "darflen", "bucln", " bullen", "buvelen", "bullen", "Bufrender", "Bufren", "Buflen", " buflenn", "darflener", "Buflender", "buflend", "bublen", "buflened", "buflatten", "bufrent", "darflened", "darblened", "bucessatten", " buflend", "bublener", "buwln", "buwlenn", "bucessender", "buflender", "bulln", "bullatten", "buwlen", "buflener", "bufln", "bublened", "buvelent", "darblent", "bullender", "buvelener", "bufrener", "darblen", "bufrened", "buflenn", "bufrn", "buwlend", " bullend", "bufrender", "bullend", " bulln", "Bufln", "buclend", "darflent", "buflent", "buclenn", "buvelened", "bufratten", "bucessn", "bublent", "buclen", "bufren", "Bufratten", "darblener", "Bufrn", " bufln"]}}
{"project": "FFmpeg", "commit_id": "a55692a96099c40aabb25e1443890be99f9c845c", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012, "substitutes": {"w": ["writer", "cam", "wcs", "ow", "g", "wa", "wr", "temp", "r", "m", "we", "aw", "rw", "iw", "wb", "W", "wp", "window", "sw", "RW", "fw", "wav", "wx", "tw", "hw", "kw", "wrap"], "fmt_ctx": ["fmt_reader", "frt_cmp", "fmt_coll", "fmt_cu", "fmtfloc", "fmt_sci", "fmt_context", "fmt2sci", "fmt2context", "fmtfrx", "frt_coll", "frt_reader", "fMT_context", "fmt_loc", "fmt_rx", "fMT_rx", "fmt_cmp", "frt_sci", "frt_cu", "fmtfctx", "fMT_loc", "fmtfcontext", "fmt2ctx", "fmt2cmp", "frt_ctx", "fMT_ctx", "frt_context"], "interval": ["extcal", "nerver", "interscel", "INTERsection", "sural", "intervol", "irval", "inseval", "extval", "intersval", "warval", "interchange", "extVAL", "infvol", "interref", "INTERref", " interruction", "interpoint", "intersvals", "warpol", "intercel", "intcel", "extpoint", "perref", "overval", "curval", "Intervals", "nerval", "interrupt", "iterchange", "inseVAL", "iterpol", " intervals", "iterval", " interpre", "INTERv", "iterver", "interpol", " interal", "surval", "INTERpol", "INTERver", "intcol", "perpre", "interv", "iterpoint", "infpol", "overpol", "INTERcal", "intervert", "curchange", "interVAL", " interver", "pervert", "irvals", " interv", "Interval", "iterrupt", "intervals", "extvert", " intercol", "extsection", "insever", "interrule", " interrule", "curpoint", "intvals", "iterpre", "warruction", "insepre", "insesection", "perv", "Intercel", "INTERval", "waral", "nerpol", "surruction", "itervol", "ircel", "INTERVAL", "extpol", "insecal", "intersrule", "iterVAL", "INTERpre", "nerVAL", "perVAL", "extchange", "intercol", "intval", "intersection", "ircol", " intercel", "infver", "interver", "oververt", " interpol", "infval", "interal", "extrupt", "surpol", "perval", "Interrule", "interpre", " interref", "currupt", " intervol", "perpol", "intercal", "overVAL", "interruction"], "cur_ts": [" cur_qs", " cur_ds", "curGats", "curGqs", "cur8times", " cur_TS", "Cur_ts", "cur2times", " cur_ats", "curLvalues", "cur2ts", "cur_uts", "cur_steps", "cur8TS", "cur2steps", " cur_times", " cur_values", "cur_ats", "rc\n", "cur_TS", "Cur\n", " cur\n", "cur_ds", "curLts", "Cur_TS", " cur_uts", "curGts", "cur8ts", "cur_times", "cur_qs", "cur2TS", "Cur_steps", "cur_values", "cur8uts", "Cur_times", "curLtimes", "curLds", "curGtimes", "cur\n"], "pkt": ["Packet", "cpet", " pct", "Pct", "pmt", "Pwk", "backet", "cpacket", "cpsth", "pet", "cpkt", "Pet", "pett", "fct", "promacket", "promkt", "cwk", " pett", " pwk", "pelt", "promct", "Psth", "fqt", "Pqt", "cpct", "opmt", "Pett", "bkt", "fet", " pelt", "bct", "celt", "Pmt", " pqt", "promett", " pet", "Pkt", "packet", "opct", "fkt", "pwk", " packet", "opacket", "psth", "pqt", "opkt", "bsth", "cpmt", "facket", "pct", "Pelt", "ckt", "cacket"], "pkt1": ["packet2", "pct2", " pqt1", "packet1", "pqt2", " pkt2", "pkt2", "pct1", " pqt2", "pqt1"], "frame": ["view", "e", "object", "event", "thread", "result", "part", "val", "feature", "parse", "f", "buffer", "fat", "sequence", "data", "state", "lock", "p", "ret", "point", "ace", "dr", "live", "fr", "window", "seq", "session", "call", "slice", "flow", "trace", "Frame", "range", "boot", "fram", "parent", "image", "block", "fi", "feat"], "target": ["feat", "port", "net", "Target", "arget", "start", "limit", "next", "conn", "gt", "end", "pattern", "valid", "object", "result", " offset", " ret", "project", "arg", "blank", "transform", "token", "weight", "buffer", "path", "master", "address", "cat", "data", "rel", "ret", "ip", "current", " Target", "point", "timeout", "client", "ctx", "tag", "goal", "source", "match", "ARGET", "ault", "window", "date", "core", "qa", "session", "top", " next", "test", "iter", "base", "global", "root", "range", "alt", "parent", "nt", "reset", "dest", "expected", "pointer", "gap", "offset", " result", "output", "format", "value"], "frame_count": ["frame___weight", "frame_id", "frame2id", "frame_counter", "frame___counter", "frame2counter", "frame2count", "block_weight", "block_counter", "block_count", "block_id", "frame2weight", "frame___count", "block___counter", "block___count", "block___weight", "block___id", "frame___id", "frame_weight"], "i": ["io", "ind", "ti", "I", "f", "ci", "t", "info", "it", "j", "ip", "p", "at", "id", "mi", "timeout", "c", "index", "num", "si", "ii", "slice", "ai", "len", "multi", "fi", "ni"], "stream_index": ["wave_position", "stream_config", "stream_number", " streamingconfig", "streamityupdate", "streamingconfig", "wavealposition", "streamityconfig", "wave_index", "streamityposition", "streamalindex", "streamingindex", " stream_int", "streamishposition", "streamalposition", "wavealindex", "stream_int", "wavealupdate", "stream_condition", "streamitycondition", "streamingnumber", "streamalcondition", " stream_number", "streamitynumber", " streamingnumber", "streamishindex", "stream_position", " stream_config", "wave_update", " streamingint", "wavealcondition", " streamingindex", "wave_condition", "streamityindex", "streamalupdate", "stream_update", "streamishupdate", "streamingint", "streamityint", "streamishcondition"]}}
{"project": "FFmpeg", "commit_id": "d32547a24a3fcc8286b318353f43805838b84775", "target": 1, "func": "int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx,\n                                             uint8_t *buf, int buf_size,\n                                             const short *samples)\n{\n    AVPacket pkt;\n    AVFrame *frame;\n    int ret, samples_size, got_packet;\n    av_init_packet(&pkt);\n    pkt.data = buf;\n    pkt.size = buf_size;\n    if (samples) {\n        frame = av_frame_alloc();\n        if (!frame)\n            return AVERROR(ENOMEM);\n        if (avctx->frame_size) {\n            frame->nb_samples = avctx->frame_size;\n        } else {\n            /* if frame_size is not set, the number of samples must be\n             * calculated from the buffer size */\n            int64_t nb_samples;\n            if (!av_get_bits_per_sample(avctx->codec_id)) {\n                av_log(avctx, AV_LOG_ERROR, \"avcodec_encode_audio() does not \"\n                                            \"support this codec\\n\");\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            nb_samples = (int64_t)buf_size * 8 /\n                         (av_get_bits_per_sample(avctx->codec_id) *\n                          avctx->channels);\n            if (nb_samples >= INT_MAX) {\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            frame->nb_samples = nb_samples;\n        }\n        /* it is assumed that the samples buffer is large enough based on the\n         * relevant parameters */\n        samples_size = av_samples_get_buffer_size(NULL, avctx->channels,\n                                                  frame->nb_samples,\n                                                  avctx->sample_fmt, 1);\n        if ((ret = avcodec_fill_audio_frame(frame, avctx->channels,\n                                            avctx->sample_fmt,\n                                            (const uint8_t *)samples,\n                                            samples_size, 1)) < 0) {\n            av_frame_free(&frame);\n            return ret;\n        }\n        /* fabricate frame pts from sample count.\n         * this is needed because the avcodec_encode_audio() API does not have\n         * a way for the user to provide pts */\n        if (avctx->sample_rate && avctx->time_base.num)\n            frame->pts = ff_samples_to_time_base(avctx,\n                                                 avctx->internal->sample_count);\n        else\n            frame->pts = AV_NOPTS_VALUE;\n        avctx->internal->sample_count += frame->nb_samples;\n    } else {\n        frame = NULL;\n    }\n    got_packet = 0;\n    ret = avcodec_encode_audio2(avctx, &pkt, frame, &got_packet);\n    if (!ret && got_packet && avctx->coded_frame) {\n        avctx->coded_frame->pts       = pkt.pts;\n        avctx->coded_frame->key_frame = !!(pkt.flags & AV_PKT_FLAG_KEY);\n    }\n    /* free any side data since we cannot return it */\n    av_packet_free_side_data(&pkt);\n    if (frame && frame->extended_data != frame->data)\n        av_freep(&frame->extended_data);\n    av_frame_free(&frame);\n    return ret ? ret : pkt.size;\n}", "idx": 21030, "substitutes": {"avctx": [" avctrl", "avecf", "avalvoc", "alcontext", "vercontext", "vercf", "avhw", " avcu", "avcca", "avconfig", "evcomponent", " avcci", "navctx", "varcca", "navcp", "avalcmp", "avetx", "varcontext", "afcomponent", "avsys", "avcomponent", "avxc", " avcf", "avalconn", "afconfig", "avcmp", "afconn", "alctx", "avctrl", "avcn", "afkb", "navcontext", "avkb", "abcmp", "avecu", "aveconfig", "avecca", "avsupport", "airctx", "avalconfig", "afcci", "verctx", " avsys", "avct", "avcp", "afctx", "avepkg", " avpkg", "aftx", "avehw", "verconfig", "airsupport", "avecn", "avalkb", "avecci", "avcontext", "abcp", "evcmp", "avalcomponent", "navcmp", "avebuff", "avevoc", "avalcontext", "afcca", "avvoc", "afcp", "avalsys", "aveconn", "afxc", " avct", "avpkg", "avect", "afcn", "afcmp", "afbuff", "afhw", "avalxc", "avexc", "evcontext", "avcf", "afct", "avalsupport", "navhw", "afpkg", " avcmp", "verxc", "afcu", "afvoc", "avcu", "abctx", " avcca", "evctx", "avectx", "afcontext", "aircontext", "afctrl", "avcci", "alcu", "afcf", "vercu", "verconn", "avconn", "avecmp", "afsys", "avecontext", "avekb", "varbuff", "varctx", "avalctx", "afsupport", "altx", "avalcca", "avtx", "navcn", " avxc", "abcontext", " avcontext", "avbuff", "airxc", "verctrl"], "buf": ["conv", "bc", "pb", "uf", "config", "cv", "fb", "queue", "pad", "Buff", "img", "fp", "buffer", "alloc", "cmd", "data", "rc", "pool", "ctx", "cb", "mem", "window", "b", "tmp", "seq", "src", "fd", "wav", "bd", "br", "Buffer", "batch", "buff", "bf", "array", "bag", "vec", "block", "base"], "buf_size": ["buf_sized", "cmd_size", "buflexnumber", "uf_count", "uf_size", "buf_scale", "bufallsize", "buflexsized", "buf_cap", "buf_number", "windowlexsized", "buf128count", "window_size", "cmd_count", "buf_count", "uf_scale", "cmd_address", "windowlexsize", "windowlexnumber", "buflexcap", "bufallcount", "window_number", "bufalladdress", "window_cap", "windowlexcap", "buf128size", "buflexsize", "window_sized", "buf_address", "buf128scale", "cmd_start", "bufallstart", "buf_start"], "samples": ["famp", "fample", "sample", "nample", "Siblings", "pspaces", "spaces", "gsample", "famples", "insample", "solutions", "gsamps", "gsamples", "gsamp", "Solutions", "Spaces", "famps", "namples", "namps", "servicesamps", "inspaces", "psamples", "insiblings", "samps", "sessions", "servicesamples", "insamples", "siblings", "Samples", "servicesessions", "psiblings", "namp", "Sessions", "Samps", "Sample", "samp", "servicesolutions", "psample"], "pkt": ["Packet", " pkg", " pct", "Pct", "pck", "cpacket", "Pck", "pet", "Pet", "cpkt", "pkg", "apKT", "apet", "apkt", "cpct", " pck", "PKT", "Pkg", "cpck", " pet", "Pkt", "packet", "pKT", " packet", "apck", "pct", "apacket", "apkg", " pKT"], "frame": ["row", "property", "class", "target", "config", "event", "scene", "part", "parse", "buffer", "df", "data", "bug", "figure", "dy", "load", "live", "fr", "window", "line", "qa", "slice", "game", "Frame", "fam", "image", "fi", "feat", "fab", "request", "object", "scale", "coll", "file", "za", "style", "node", "fake", "state", "lock", "fx", "setup", "component", "tick", "code", "body", "pse", "flo", "element", "feed", "boot", "fen", "fram", "ce", "position", "video", "interface", "flower", "thread", "fb", "framework", "host", "function", "f", "layer", "model", "section", "zip", "play", "cf", "ace", "point", "module", "rame", "call", "flow", "loc", "html", "up", "ze", "view", "iframe", "hop", "feature", "build", "motion", "cycle", "fe", "hide", "frames", "document", "session", "update", "parent", "range", "block", "base"], "ret": ["reg", "class", "def", "en", "ref", "valid", "std", "result", "val", "part", "ft", "det", "arg", "rep", "Ret", "buffer", "al", "info", "bit", "res", "cat", "final", "data", "rets", "fin", "it", "id", "addr", "success", "rc", "match", "let", "RET", "rt", "flag", "reply", "re", "desc", "len", "back", "alt", "sid", "nt", "lit", "att", "resp", "fun"], "samples_size": ["samples_ize", "samples_needed", "samples_length", "samples_speed", "samples_scale", "samples_min", "samples_value"], "got_packet": ["got_sexets", "got_sexett", "got_buckacket", "got_compet", "got_compacket", "_", "got_compets", "func", "bytes", "function", "buffer", "got_sexacket", "got_sexet", "got_compett", "got_packacket", "c", "got_buckett", "got_buckets", "got_bucket", "seq", "length", "feed", "got_packets", "array", "all", "this", "got_packett"], "nb_samples": ["nb_suients", "nb_ssiblings", "nb_sesamples", "nb_sourses", "nb_sqonents", "nb_suamples", "nb_svucks", "nb_usounds", "nb_sesourses", "nb_donents", "nb_assists", "nb__seents", "nb67samps", "nb_dsocks", "nb_assumes", "nb_dsims", "nb_sesamps", "nb_assamples", "nb_suills", "nb_psumes", "nb64psores", "nb_servicesourses", "nb_dsamples", "nb64psones", "nb_inances", "nb_servicesamples", "nb_sources", "nb_ssizes", "nb_sumes", "nb67servicesamples", "nb_siblings", "nb_inamples", "nb_psamps", "nb64psamps", "nb_svocks", "nb_namps", "nb_sonents", "nb_compizes", "nb_exones", "nb_eventsents", "nb_usamples", "nb_samps", "nb_usizes", "nb_examps", "nb_sists", "nb_jsamples", "nb_psores", "nb_svims", "nb_namples", "nb64psamples", "nb__sources", "nb_csamples", "nb_dizes", "nb_suances", "nb_sucks", "nb_servicesiblings", "nb64sores", "nb_suizes", "nb67siblings", "nb_usills", "nb_eventsiblings", "nb_psists", "nb_csumes", "nb_seiblings", "nb_sents", "nb_svamples", "nb_simocks", "nb64samps", "nb__siblings", "nb_simamples", "nb_eventsamples", "nb_simucks", "nb_ssourses", "nb_examples", "nb_eventsources", "nb__seiblings", "nb67samples", "nb_ssonents", "nb_psones", "nb67servicesamps", "nb_sients", "nb_psances", "nb__samples", "nb_sores", "nb_psamples", "nb_sqamples", "nb__sents", "nb_damps", "nb_compills", "nb64samples", "nb_sqamps", "nb_sones", "nb_nores", "nb_csances", "nb__seamples", "nb67servicesiblings", "nb64sones", "nb__seources", "nb_simims", "nb_sizes", "nb_sances", "nb_sills", "nb_socks", "nb_servicesamps", "nb_csists", "nb_nients", "nb_seamples", "nb_ssamples", "nb_sims", "nb67servicesourses", "nb_jsources", "nb_dsucks", "nb_exores", "nb_jsiblings", "nb_compamples", "nb_sqizes", "nb_ssamps", "nb_nances", "nb_compounds", "nb_jsents", "nb67sourses", "nb_inients", "nb_nones", "nb_damples", "nb_assances", "nb_seources", "nb_suounds", "nb_seents", "nb_sounds", "nb_sesiblings"]}}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n", "idx": 21034, "substitutes": {"function": ["package", "name", "functional", "class", "object", "unc", "file", "func", "feature", "handler", "f", "section", "size", "program", "version", "cycle", "unit", "number", "code", "operation", "word", "filename", "module", "document", "family", "value", "python", "library", "math", "call", "Function", "length", "expression", "parent", "array", "fn", "resource", "variable", "command", "format", "fun", "letter"], "count": ["col", "name", "start", "config", "loop", "coll", "val", "time", "file", "fold", "process", "f", "use", "Count", "size", "cache", "score", "cycle", "id", "number", "code", "depth", "context", "c", "index", "num", "counter", "seq", "error", "call", "length", "child", "len", "test", "base", "array", "repeat", "max", "type"], "eax": ["ebex", " eaz", "fau", "Eau", "Eex", "eix", "eap", "ieix", " ease", "fax", "eas", " eex", "Eae", "fae", "peax", "eeaz", "Ead", " eix", "fas", "eae", " eap", "peas", "eau", " ead", "eex", "eaz", "ebap", "ease", "ieax", "ieaz", "ead", "peau", "iease", "eease", "peae", "eeix", "eeax", "ebax", "Eap", "Eax", "ebad", "Eas"], "ebx": ["eedX", "ecc", "efX", "ebX", "eby", "ibz", "ecid", "ebp", "efax", "evx", "egid", "efx", "ecX", "ibp", "ebid", "evz", "ecp", "ibb", "eedax", "evy", "ecz", "ibX", "egp", "ebz", "iby", "ibid", "efc", "ecb", "egx", "ecy", "eedc", "ebc", "evb", "egX", "ibx", "ebax", "eedx", "ecax", "ebb"], "ecx": ["ecc", "ebX", "eby", "exe", "eqX", "exX", "exxx", "emy", "eff", "ef", "ex", "efx", "eqe", "ecX", "ep", "ecp", "eqxx", "efb", "egp", "ebxx", "egc", "emx", "efy", "efc", "egx", "eqx", "ebe", "ecb", "ecy", "ece", "ecf", "ebc", "egf", "emc", "ecxx", "ebb", "exx", "efp", "ec", "emb"], "edx": ["pedx", "gedc", "gedz", "sdp", "pedz", "gedx", "pedc", "sdz", "pedp", "aedy", "aedx", "aidz", "odx", "endedax", "nedx", "gedp", "nedax", "odc", "aidex", "nedc", " edex", "edex", "sdx", "aedex", "sdc", "nedex", "aidy", "edy", "aedz", "aidx", "edax", " edz", "odex", "edc", "endedc", "odax", "edz", "endedx", "endedex", " edy", "edp"], "vec": ["bc", "uint", "sv", "expr", "val", "xy", "cube", "digit", "buffer", "vre", "sequence", "data", "nec", "list", "cs", "vals", "context", "var", "js", "later", "window", "vor", "proc", "v", "pointer", "factor", "this", "feat", "str", "binary", "name", "iv", "text", "coll", "ctr", "file", "contin", "ef", "term", "op", "coord", "opt", "cer", "unit", "buf", "filename", "life", "soc", "winner", "video", "vc", "lc", "prev", "flat", "serv", "time", "verb", "crit", "func", "bytes", "fit", "arr", "uv", "score", "cf", "depth", "ver", "length", "req", "script", "cod", "voc", "variable", "ec", "fun", "nv", "kt", "feature", "json", "entry", "version", "cycle", "id", "word", "ctx", "index", "frame", "vr", "seq", "editor", "vert", "array", "chrom", "fn", "vp", "vector", "zero"]}}
{"project": "FFmpeg", "commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "target": 1, "func": "static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,\n\n                           int flags)\n\n{\n\n    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n", "idx": 21037, "substitutes": {"ctx": ["conv", "lc", "bc", "txt", "cam", "wcs", "cc", "support", "conn", "sci", "config", "pkg", "cv", "kt", "cm", "tx", "ca", "anc", "cas", "fp", "cmp", "ci", "nc", "cmd", "cp", "setup", "xc", "cs", "ctrl", "kb", "context", "cf", "cli", "rc", "c", "cb", "client", "cn", "sc", "ann", "qa", "fw", "loc", "cca", "utils", "wx", "cms", "kw", "ck", "sq", "vc"], "dst": ["Dst", "adsc", "sdste", "Dsc", "post", "dist", "idust", "wust", "sdst", "sdsts", "Dsts", "nste", "pdst", "idsts", "Dste", "dnsc", "Dost", "wst", " dost", "idste", "dsc", "fdsp", " dsc", "idst", "nst", "dsost", "adST", "sdsc", "adst", "nist", " dstream", "dste", "Dput", "pST", " dsp", "wput", "dnsts", "DST", " dST", "dsp", "idist", "nsts", "dost", "fdstream", " dstack", "fdsc", "dssc", "Drest", "dust", "dstream", " dste", "pdsts", "wsts", " dsts", "dnost", "fdst", "adost", "dsst", "dsST", "psc", " drest", "dST", "pdstack", "dnrest", "idput", "dstack", "pst", "dsts", "pdsc", "Dust", "drest", "dnsp", "dput", "dnstream", "dnst", "Dstack", "Dist"], "src": ["conv", "bc", "pb", "sb", "sel", "support", "uc", "sl", "scene", "cv", "impl", "func", "rin", "cur", "img", "scl", "sth", "rob", "storage", "ssl", "setup", "sync", "buf", "rc", "reflect", "cb", "source", "roc", "sc", "RC", "sr", "rl", "sub", "ptr", "sur", "inst", "sup", "loc", "req", "st", "proc", "dest", "rb", "stream", "bs", "sn", "sq", "gb"], "flags": ["ips", "types", "ints", "fs", "features", "xs", "lines", "locks", "ops", "properties", "nl", "fps", "planes", "args", "faces", "vals", "ports", "stats", "ants", "settings", "Flags", "lag", "frames", "styles", "bits", "limits", "flag", "FLAG", "fl", "fd", "details", "mask", "ns", "fields", "utils", "options", "alls", "lf", "links", "ats", "files", "atts", "fi", "format"], "surface": ["package", "port", "area", "sym", "sample", "scene", "ser", "metadata", "rect", "pad", "cur", "layer", "dra", "slave", "FACE", "master", "data", "faces", "sheet", "ample", "sa", "filename", "tile", "reflect", "source", "sea", "material", "sc", "sr", "ptr", "face", "sur", "save", "desc", "slice", "sf", " Surface", "skin", "cover", "aster", "sta", "texture"], "map": ["port", "plane", "shape", "ap", "app", "scale", "maps", "apper", "file", "pad", "bridge", "wave", "node", "img", "per", "master", "address", "m", "Map", "data", "cache", "msg", "zip", "lock", "arr", "change", "code", "work", "addr", "mi", "tool", "tile", "move", "module", "pl", "match", "sh", "mp", "create", "replace", "mem", "rule", "save", "mage", "mask", "bm", "test", "co", "mg", "ape", "MAP", "image", "ge", "cover", "pack", "block", "scope", "aster", "cap"], "surfaceDesc": ["surfaceInfo", "faceDescription", " surfaceDescription", "faceInfo", " SurfaceDesc", "sourceDes", " SurfaceStruct", "sourceStruct", " surfaceDes", " surfacedesc", "surfaceDescription", "surfaceDes", " SurfaceInfo", "faceDesc", "surfacedesc", " Surfacedesc", "sourceDesc", "sourceDescription", " surfaceStruct", "sourcedesc", "facedesc", "faceDes", "surfaceStruct", " surfaceInfo", " SurfaceDescription"], "LockedRect": ["LockerRect", "LlockedRect", "IlotedRect", "LockingRECT", "LockRECT", "Liedrect", "LockerRECT", "Blockedrect", " LockingText", " LockingRECT", "LockedBox", "Slockingrect", "LiedRect", "BlockingRect", "IlockedText", "LotedText", "LockingRect", " LockedText", "Lockingrect", "Lockerrect", "IlockedRect", "LippedRECT", "Lockrect", "IlotedBox", "Slockedrect", "LockerText", "LlockedText", " Lockedrect", " Lockingrect", "LockingText", " LockedRECT", "LotedRect", "LotedRECT", "LockRect", "LrictedRect", "Llockedrect", "BlockedRect", "LotedBox", "LrictedRECT", "Lippedrect", "SlockedRECT", " LockingRect", "BlockingRECT", "Blockingrect", "IlotedText", "SlockingRECT", "BlockedRECT", "LlockedRECT", "LockingBox", "IlockedRECT", "Lockedrect", "IlotedRECT", "LockedText", "IlockedBox", "SlockingRect", "LiedRECT", "LippedRect", "SlockedRect", "LrictedBox", "LockedRECT", "LrictedText"], "hr": ["ih", "str", "e", "rd", "ig", "ref", "ride", "sl", "g", "cv", "ctr", "rx", "rin", "rr", "wr", "tr", "rec", "yr", "img", "lr", "f", "hei", "r", "s", "her", "p", "arr", "rh", "code", "dr", "rc", "fe", "resh", "fr", "pr", "roc", "shr", "ar", "RR", "a", "vr", "sr", "pull", "ocr", "hl", "cr", "er", "gr", "br", "mr", "req", "HR", "rs", "hour", "kr", "h", "ir", "ec", "rg"], "i": ["io", "uli", "ix", "start", "ik", "ie", "fi", "qi", "e", "ind", "ri", "ui", "eni", "gi", "d", "uri", "ti", "I", "l", "f", "layer", "ci", "y", "t", "phi", "r", "info", "ini", "it", "j", "oi", "u", "adi", "p", "ip", "id", "code", "ani", "mi", "c", "index", "si", "ii", "b", "line", "n", "iu", "ai", "xi", "di", "multi", "v", "li", "h", "pi", "x", "zi", "k", "ni", "ori"], "err": ["str", "delay", "ind", "ctr", "der", "Er", "rr", "yr", "r", "init", "cache", "bug", "arr", "act", "or", "rh", "code", "inner", "dy", "dr", "cb", "nr", "fr", "ar", "rar", "ver", "sr", "arm", "error", "min", "magic", "er", "gr", "len", "loc", "test", "iter", "req", "mr", "try", "br", "ner", "rage", "ler", "user", "kr", "ir", "fi", "resp", "attr"], "nb_planes": ["nbOfviews", "nbxframes", "nb_rows", "nbxviews", "nb_plates", "np_frames", "nb__frames", "npxframes", "npxplates", "nb_liners", "lnOflevels", "lnOfviews", "npxplanes", "nballrows", "nballplanes", "lnOfplanes", "npxrows", "nbxrows", "nbxlevels", "np_rows", "nbxplates", "nbxplanes", "np_planes", "num_bands", "nb_levels", "nb_views", "nbOfplanes", "lnOfbands", "num_liners", "nb_frames", "nbOflevels", "nballplates", "ln_views", "np_plates", "nballframes", "ln_planes", "nb_bands", "nbxbands", "num_frames", "nb__plates", "nb__rows", "num_planes", "nbOfbands", "nb__planes", "ln_bands", "ln_levels"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n", "idx": 21050, "substitutes": {"prog": ["proge", "Progs", "pregs", "Progn", "rougs", "Prog", "prob", "progn", "prb", "prgg", " proge", " prob", "rouG", "proG", "pregn", "progs", "ProG", "puge", "proga", " progs", "preG", " proG", "prega", "prge", " progg", "Proga", "rouga", "progg", "prg", "pug", "pugg", "preg", "roug", " progn", "pub"], "po": ["Ko", "ee", "obj", "oo", "oe", "jp", "pe", "ao", "oa", "apo", "pd", "Po", "pc", "so", "no", "yo", "elo", "pos", "pg", "op", "pre", "wo", "mo", "obo", "da", "pp", "gro", "p", "zone", "o", "py", "lo", "pr", "la", "pro", "aco", "cho", "bo", "vo", "flo", "va", "PO", "aa", "co", "ps", "ote", "ko", "li", "odo", "jo", "pi", "ppa", "poke", "pa", "ppo"], "i": ["io", "lc", "e", "ix", "ie", "fi", "qi", "ri", "ind", "ui", "part", "gi", "d", "uri", "ti", "I", "l", "f", "hei", "ci", "split", "r", "oi", "ini", "u", "it", "j", "phi", "p", "ip", "id", "o", "bi", "ori", "cli", "mi", "c", "index", "si", "a", "ii", "in", "b", "n", "iu", "slice", "ai", "xi", "hi", "di", "yi", "multi", "v", "li", "z", "api", "pi", "x", "zi", "ni", "type"], "expert": ["comret", "expr", "invert", "pretern", "intervert", "inert", "expconfig", "xert", "interert", "exlr", "prepert", "Exvert", "comtern", "Exert", "exert", "exvert", " exret", "explr", "xlr", "inpert", "interpr", "Expr", "preper", "compert", "Exconfig", "exret", "preret", "exppert", "inpr", "exconfig", "comper", " exper", "xpert", "xconfig", "Expert", "exper", "Exlr", "interpert"], "buf": ["begin", "bc", "str", "uf", "binary", "uc", "brace", "nat", "ba", "fab", "board", "ha", "cv", "fb", "queue", "utf", "Buff", "img", "home", "fp", "cas", "buffer", "path", "xff", "alloc", "cmd", "box", "cat", "cf", " buffer", "wb", "font", "rc", "cb", "ctx", "la", "b", "seq", "auc", "desc", "fd", "src", "fw", "bd", "br", "append", "Buffer", "aka", "buff", "proc", "bh", "bag", "rb", "vec", "block", "lit", "fi", "cap"]}}
{"project": "FFmpeg", "commit_id": "b8a2331a70b720e83e1be243f7d17941c8952ef2", "target": 1, "func": "av_cold int ffv1_common_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    if (!avctx->width || !avctx->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    s->avctx = avctx;\n\n    s->flags = avctx->flags;\n\n\n\n    s->picture.f = avcodec_alloc_frame();\n\n    s->last_picture.f = av_frame_alloc();\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width  = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    // defaults\n\n    s->num_h_slices = 1;\n\n    s->num_v_slices = 1;\n\n\n\n    return 0;\n\n}", "idx": 21061, "substitutes": {"avctx": ["avecf", "avalctl", " avcu", "avcca", "AVcu", "afloc", "avetx", "avcb", " avloc", "ajctx", "avcmp", "afconn", "AVloc", "abcmp", "avecca", "avec", "avecb", "afcci", "afctx", "aftx", " avc", "avecci", "avcontext", "ajconn", "ajcmp", "abcu", "avevoc", "AVctx", "avalcontext", "afcca", "avvoc", "aveconn", " avvoc", "avecoll", "ajcontext", "groundcontext", "afctl", "afcmp", "evconn", "aucontext", "avcoll", "evcontext", "avcf", "afcu", "autx", "afvoc", "avcu", "abctx", "avctl", "avalcf", "groundcf", "afcb", "evctx", "avectx", "afcontext", "afc", "auctx", "avcci", "ajcci", "afcoll", "evcf", "AVcmp", " avcb", "afcf", "avconn", "AVcontext", "avecmp", "avecontext", "ajcca", " avtx", "avalctx", "groundctx", "aucoll", "avtx", "avc", "abcontext", " avcontext", "groundctl", "avloc"], "s": ["sv", "i", "sb", "e", "qs", "es", "fs", "g", "ses", "private", "su", "lines", "d", "ops", "sets", "as", "ds", "services", "f", "sys", "u", "m", "args", "data", "full", "its", "ssl", "os", "p", "ts", "cs", "vs", "ls", "o", "sync", "is", "ss", "sa", "sg", "js", "c", "self", "settings", "si", "b", "w", "service", "parts", "session", "S", "n", "ns", "sup", "sf", "ps", "rs", "gs", "ins", "http", "ans", "sec", "conf", "v", "l", "sq"]}}
{"project": "FFmpeg", "commit_id": "c776531aef9b546ca576d4c8e3ec14a513394618", "target": 0, "func": "static int vqa_decode_chunk(VqaContext *s)\n\n{\n\n    unsigned int chunk_type;\n\n    unsigned int chunk_size;\n\n    int byte_skip;\n\n    unsigned int index = 0;\n\n    int i;\n\n    unsigned char r, g, b;\n\n    int index_shift;\n\n    int res;\n\n\n\n    int cbf0_chunk = -1;\n\n    int cbfz_chunk = -1;\n\n    int cbp0_chunk = -1;\n\n    int cbpz_chunk = -1;\n\n    int cpl0_chunk = -1;\n\n    int cplz_chunk = -1;\n\n    int vptz_chunk = -1;\n\n\n\n    int x, y;\n\n    int lines = 0;\n\n    int pixel_ptr;\n\n    int vector_index = 0;\n\n    int lobyte = 0;\n\n    int hibyte = 0;\n\n    int lobytes = 0;\n\n    int hibytes = s->decode_buffer_size / 2;\n\n\n\n    /* first, traverse through the frame and find the subchunks */\n\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n\n        index      = bytestream2_tell(&s->gb);\n\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case CBF0_TAG:\n\n            cbf0_chunk = index;\n\n            break;\n\n\n\n        case CBFZ_TAG:\n\n            cbfz_chunk = index;\n\n            break;\n\n\n\n        case CBP0_TAG:\n\n            cbp0_chunk = index;\n\n            break;\n\n\n\n        case CBPZ_TAG:\n\n            cbpz_chunk = index;\n\n            break;\n\n\n\n        case CPL0_TAG:\n\n            cpl0_chunk = index;\n\n            break;\n\n\n\n        case CPLZ_TAG:\n\n            cplz_chunk = index;\n\n            break;\n\n\n\n        case VPTZ_TAG:\n\n            vptz_chunk = index;\n\n            break;\n\n\n\n        default:\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: Found unknown chunk type: %c%c%c%c (%08X)\\n\",\n\n            (chunk_type >> 24) & 0xFF,\n\n            (chunk_type >> 16) & 0xFF,\n\n            (chunk_type >>  8) & 0xFF,\n\n            (chunk_type >>  0) & 0xFF,\n\n            chunk_type);\n\n            break;\n\n        }\n\n\n\n        byte_skip = chunk_size & 0x01;\n\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n\n    }\n\n\n\n    /* next, deal with the palette */\n\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CPL0 and CPLZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the palette chunk */\n\n    if (cplz_chunk != -1) {\n\n\n\n/* yet to be handled */\n\n\n\n    }\n\n\n\n    /* convert the RGB palette into the machine's endian format */\n\n    if (cpl0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the palette size */\n\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found a palette chunk with %d colors\\n\",\n\n                chunk_size / 3);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        for (i = 0; i < chunk_size / 3; i++) {\n\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n\n            r = bytestream2_get_byteu(&s->gb) * 4;\n\n            g = bytestream2_get_byteu(&s->gb) * 4;\n\n            b = bytestream2_get_byteu(&s->gb) * 4;\n\n            s->palette[i] = (r << 16) | (g << 8) | (b);\n\n        }\n\n    }\n\n\n\n    /* next, look for a full codebook */\n\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBF0 and CBFZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the full codebook chunk */\n\n    if (cbfz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if ((res = decode_format80(&s->gb, chunk_size, s->codebook,\n\n                                   s->codebook_size, 0)) < 0)\n\n            return res;\n\n    }\n\n\n\n    /* copy a full codebook */\n\n    if (cbf0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the full codebook size */\n\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: CBF0 chunk too large (0x%X bytes)\\n\",\n\n                chunk_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n\n    }\n\n\n\n    /* decode the frame */\n\n    if (vptz_chunk == -1) {\n\n\n\n        /* something is wrong if there is no VPTZ chunk */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: no VPTZ chunk found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n\n    chunk_size = bytestream2_get_be32(&s->gb);\n\n    if ((res = decode_format80(&s->gb, chunk_size,\n\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n\n        return res;\n\n\n\n    /* render the final PAL8 frame */\n\n    if (s->vector_height == 4)\n\n        index_shift = 4;\n\n    else\n\n        index_shift = 3;\n\n    for (y = 0; y < s->frame.linesize[0] * s->height;\n\n        y += s->frame.linesize[0] * s->vector_height) {\n\n\n\n        for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) {\n\n            pixel_ptr = x;\n\n\n\n            /* get the vector index, the method for which varies according to\n\n             * VQA file version */\n\n            switch (s->vqa_version) {\n\n\n\n            case 1:\n\n                lobyte = s->decode_buffer[lobytes * 2];\n\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                /* uniform color fill - a quick hack */\n\n                if (hibyte == 0xFF) {\n\n                    while (lines--) {\n\n                        s->frame.data[0][pixel_ptr + 0] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 1] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 2] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 3] = 255 - lobyte;\n\n                        pixel_ptr += s->frame.linesize[0];\n\n                    }\n\n                    lines=0;\n\n                }\n\n                break;\n\n\n\n            case 2:\n\n                lobyte = s->decode_buffer[lobytes];\n\n                hibyte = s->decode_buffer[hibytes];\n\n                vector_index = (hibyte << 8) | lobyte;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                break;\n\n\n\n            case 3:\n\n/* not implemented yet */\n\n                lines = 0;\n\n                break;\n\n            }\n\n\n\n            while (lines--) {\n\n                s->frame.data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n\n                pixel_ptr += s->frame.linesize[0];\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle partial codebook */\n\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBP0 and CBPZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (cbp0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n\n\n            /* time to replace codebook */\n\n            memcpy(s->codebook, s->next_codebook_buffer,\n\n                s->next_codebook_buffer_index);\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    if (cbpz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n            GetByteContext gb;\n\n\n\n            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n\n            /* decompress codebook */\n\n            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,\n\n                                       s->codebook, s->codebook_size, 0)) < 0)\n\n                return res;\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21070, "substitutes": {"s": ["sv", "sb", "e", "sym", "qs", "es", "serv", "bis", "sie", "sci", "fs", "ses", "your", "sets", "site", "ks", "ds", "services", "f", "sys", "t", "u", "its", "ssl", "p", "cs", "ts", "ls", "o", "sync", "is", "ss", "sa", "sg", "c", "settings", "js", "spec", "self", "stats", "si", "a", "service", "se", "parts", "session", "S", "ns", "sup", "sf", "rs", "gs", "v", "conf", "server", "su", "sq"], "chunk_type": ["chunktypetype", "chacket_type", "chump_types", "chunkinglength", "chunkingsize", "chunker_type", "chunker_info", "chunktypesize", "chunkerinfo", "chunkingTYPE", "chunk_style", "chump_level", "chunk_offset", "chunk_TYPE", "chunkersize", "chunk_info", "chump_type", "chunker_types", "chump_size", "chunk_num", "chunkingtype", "chunker_size", "chacket_length", "chacket_TYPE", "chunk_length", "chunktypeoffset", "chacket_size", "chunk_id", "chunk_level", "chunk_types", "chunkertypes", "chunkertype"], "chunk_size": ["chunker_size", "chunk64length", "chacket_handle", "chunks_size", "chunk_address", "chunks_Size", "chacket_type", "chunk_len", "chunk_sized", "chunk_handle", "chunk_Size", "chunk_name", "chunkingsized", "chunk_length", "chunkinglength", "chunkingsize", "chunk64Size", "chunk64len", "chunker_sized", "chacket_size", "chacket_name", "chunks_address", "chunks_len", "chunk64sized", "chunker_length", "chunk64name", "chunk64address", "chunkingname", "chunker_name", "chunk64size"], "byte_skip": [" byte_size", "Byte_size", "byte_offset", "byte___seek", "Byte_start", "byte_start", "bytexstart", "bytexsize", "Byte_offset", "byte___skip", " byte_seek", "byte___size", "byte_seek", "Byte_skip", " byte_offset", "byte_size", "bytexskip", "bytexoffset", "byte___offset"], "i": ["io", "ui", "bin", "I", "f", "ci", "phi", "info", "m", "j", "p", "bi", "is", "c", "index", "si", "ii", "n", "slice", "di", "z", "li", "h", "pi"], "r": ["row", "e", "end", "err", "d", "lr", "f", "m", "p", "rw", "rc", "c", "rl", "w", "re", "n", "er", "R", "rs", "range", "v", "pair", "rb", "h", "l", "rg"], "g": ["e", "G", "gn", "gl", "d", "f", "pg", "ga", "m", "u", "bg", "p", "gg", "q", "gz", "c", "gp", "w", "n", "gs", "h", "l", "k", "rg"], "b": ["bc", "sb", "e", "lb", "fb", "bb", "bin", "bp", "f", "buffer", "eb", "p", "bi", "wb", "buf", "c", "cb", "nb", "v", "bs", "rb", "B", "l"], "index_shift": [" index_offset", "index_offset", "index_skip", "index_map", " index_map", " index_skip"], "res": ["col", "row", "runs", "es", "obj", "err", "rows", "rem", "rx", "rep", "results", "pos", "planes", "Res", "vals", " rows", "bits", "blocks", "seq", "rev", "error", "details", "req", "ps", "reset", "resolution", "files", "base"], "x": ["e", "en", "xs", "_", "d", "xx", "f", "pixel", "ex", "m", "p", "ip", "xc", "o", "c", "px", "index", "X", "w", "n", "ax", "z", "h", "l"], "y": ["ya", "e", "vy", "yy", "d", "yt", "f", "t", "ey", "m", "p", "o", "dy", "ye", "c", "Y", "w", "cy", "ym", "n", "z", "h", "l", "type"], "pixel_ptr": ["pixelalskip", "pixel_skip", "pixelaloffset", "vectoraloffset", "vector_skip", "vector_offset", "pixel_offset", "pixelalpos", "pixelalptr", "vectoralskip", "vectoralptr", "vector_pos", "vectoralpos", "vector_ptr", "pixel_pos"], "lobytes": ["lobyges", "locyte", "Locyte", "Lobyges", "Locytes", "Lobytes", "locyges", "loyte", "LocyTE", "Lobyte", "loytes", "lodyte", "LobyTE", "loyTE", "lodyges", "loyges", "locyTE", "lodyTE", "Locyges", "lobyTE", "locytes", "lodytes", "lobyte"], "hibytes": ["hibeyts", "hibYts", "obytes", "hibYmits", "hibeytes", "hibittes", "hibitmits", "hibYte", "obymits", "hibeyte", "hibitts", "obeyte", "hibymits", "hibyts", "hibYtes", "obeytes", "obeyts", "obyte", "obyts", "hibeymits", "hibyte", "obeymits", "hibitte"], "lines": ["rows", "bytes", "flags", "pos", "m", "planes", "codes", "cells", "vals", "lin", "ls", "code", "breaks", "frames", "bits", "ii", "line", "blocks", "total", "points", "len", "links", "files", "ips", "bands", "pages", "count"], "gb": ["sb", "binary", "gpu", "gt", "usb", "gram", "gal", "ui", "gold", "db", "xy", "gl", "vg", "gin", "pc", "home", "gd", "ga", "bg", "gru", "storage", "uv", "gy", "gg", "gz", "rc", "cb", "cfg", "hub", "gc", "src", "bm", "jpg", "game", "gom", "lib", "gam", "GB", "rb", "gm", "cgi", "ge", "yg", "rg", "gly"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_mmio_map(PCIDevice *d, int region_num,\n\n                              pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    int mmio_io_addr;\n\n\n\n    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,\n\n                                                 DEVICE_NATIVE_ENDIAN);\n\n\n\n    cpu_register_physical_memory(addr, size, mmio_io_addr);\n\n}\n", "idx": 21092, "substitutes": {"d": ["md", "cd", "e", "driver", "de", "xd", " dd", "ds", "ld", "gd", "f", "m", "da", "dd", "ad", "data", "did", " D", "c", "du", "b", "dc", "dm", "dl", "fd", "dll", "D", "dp"], "region_num": [" module_num", "region_nr", " module_NUM", " module_nr", "region_number", "region_NUM", " module_number"], "addr": ["port", "name", "start", "ref", "adr", "amp", "db", "mode", "oa", "ord", "rx", "uri", "align", "host", "access", "pos", "alloc", "address", "args", "ad", "ip", "ace", "mac", "la", "rc", "index", "nr", "rt", "ptr", "arm", "seq", "alias", "call", "src", "loc", "len", "ock", "alt", "ange", "pointer", "offset", "base"], "size": ["name", "store", "scale", "g", "ui", "gn", "cm", "oa", "mode", "Size", "sized", "ize", "weight", "ci", "address", "data", "args", "storage", "code", "small", "capacity", "si", "speed", "len", "SIZE", "empty", "pack", "offset", "cap", "count"], "type": [" typ", "port", "Type", "name", "types", "kind", "shape", " format", "config", " offset", "pe", "TYPE", " name", " mode", "info", " TYPE", "address", "data", " kind", "id", "rc", "ptr", "ype", "fd", "loc", "len", "offset", "format"], "mmio_io_addr": ["mmio_lib_device", "mmio_lo_base", "mmio_io2base", "mmio_lo_add", "mmio_io2ref", "mmio_io_ref", "mmio_io_add", "mmio_lib_base", "mmio_lo_ord", "mmio_io_base", "mmio_lib_add", "mmio_lib_addr", "mmio_io_address", "mmio_io2address", "mmio_lib_ref", "mmio_lib_address", "mmio_lo_addr", "mmio_io_device", "mmio_io_ord", "mmio_io2addr"]}}
{"project": "qemu", "commit_id": "ac4b0d0c4feb291643c0e8a07a92e449e13881b5", "target": 0, "func": "static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t/* NOP */\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  */\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        /* TODO: */\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            /* No length check */;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        /* Filters are not implemented */\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            /* TODO: ordering? */\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        /* TODO */\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        /* TODO: check that the remaining bits are all 0 */\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command */\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command */\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n", "idx": 21100, "substitutes": {"info": ["fa", "about", "start", "def", "Info", "fi", "conn", "linux", "ref", "config", "meta", "INFO", "home", "f", "information", "init", "state", "stat", "inf", "id", "thin", "ctx", "index", "source", "family", "a", "error", "base", "iso", "http", "conf", "from", "image", "api", "fo", "type"], "data": ["request", "limit", "start", "response", "next", "config", "valid", "ui", "result", "input", "message", "Data", "d", "bytes", "pad", "buffer", "results", "done", "exec", "pos", "size", "cache", "args", "da", "ad", "p", "params", "help", "code", "number", "body", "shift", "buf", "memory", "header", "index", "complete", "missing", "DATA", "window", "value", "draw", "media", "slice", "len", "database", "batch", "parent", "multi", "dat", "array", "resource", "image", "api", "offset", "base", "output", "command", "type", "zero"], "length": ["delay", "shape", "limit", "end", "Length", "result", "input", "message", "time", "style", "duration", "l", "maximum", "type", "offset", "f", "path", "function", "section", "size", "sequence", "full", "lock", "p", "number", "url", "id", "body", "filename", "L", "match", "value", "line", "ength", "len", "partial", "total", "angle", "th", "range", "array", "position", "tail", "ph", "padding", "count"], "hci": ["hbi", "hlcci", "hlcu", "bhci", " hCI", "hdi", "ahci", "rhdi", "hladi", "Hcci", "hlcin", " hcci", "hCI", "rhcu", "shsync", "hbc", " hai", "hcu", "hii", "rhii", "Hcu", "hsync", "hscin", " hxc", " hbc", "khcin", "hscci", "hlci", "hlbi", "shci", "phcu", "bhii", "bhdi", " hii", "Hki", "shbi", "hldi", "hlii", "ahcu", "hcci", "shdi", "phii", " hcu", " hdi", "bhbc", " hki", "rhki", "phki", "ahcci", " hcin", "hlsync", "hlxc", "hscu", "hlai", "phci", "hxc", "hsci", "shai", " hadi", "khci", " hbi", "phdi", "hai", "hki", "shxc", "hlCI", "rhci", "Hci", "hlki", "khdi", "khCI", "hadi", "hlbc", "phadi", "ahii", "shcci", "rhcci", "hcin", " hsync"], "cmd": ["md", "name", "cc", "cd", "kind", "conn", "config", "pkg", "ctr", "cookie", "cm", " payload", "mode", "func", "pipe", "cmp", "op", "Cmd", "msg", "cp", "cat", " command", "head", "method", "cf", "setup", "params", "ctrl", "code", "mac", "cli", "buf", "client", "header", "ctx", " chunk", "module", "cb", "cfg", "cn", "c", "dom", "dc", "cpp", "seq", "channel", "comm", "src", "vc", "req", "domain", "proc", "chrom", "param", "ck", "cod", "command", "type"], "paramlen": ["paramlength", "paramstr", "arampos", "requestpos", " paramLen", "parlen", "paramLen", " parampos", "aramstr", " paramstr", "paramsln", "namelin", "nameid", "namelen", "paramslen", "paramln", "aramlen", "parLen", "paramid", "requestlen", "requestlength", "aramid", "paramlin", "nameln", "parampos", "aramLen", "paramslin", "paramsid", " paramlength", "parpos", "aramlin", "parstr", "aramln", "parlength", "requestLen"], "i": ["io", "binary", "ind", "input", "uri", "I", "umi", "m", "j", "ip", "p", "abi", "id", "inner", "cli", "c", "index", "num", "a", "ii", "n", "slice", "ai", "array", "li", "uni"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n", "idx": 21102, "substitutes": {"fs": ["fa", "fc", "qs", "linux", "features", "fb", "farm", "irs", "ks", "fp", "f", "flows", "df", "flags", "sys", "ids", "fps", "raf", "os", "vs", "cs", "fits", "cf", "ls", "settings", "FS", "fd", "fw", "feed", "bf", "http", "Fs", "files", "ips", "fi", "acs", "states"], "id": ["ident", "i", "name", "cd", "start", "kid", "ref", "key", "uri", "bid", "offset", "path", "wire", "info", "ids", "aid", "Id", "address", "init", "bit", "ad", "ip", "p", "code", "mid", "auth", "index", "oid", "ID", "pid", "rid", "seq", "error", "desc", "mask", "root", "parent", "sid", "vid", "uid", "url", "type"], "isc": ["lc", "isa", "bc", "ih", "fc", "cc", "esc", "ig", "irc", "uc", "iv", "ui", "asc", "sil", "inc", "eth", "ich", "pc", "oci", "mic", "ci", "custom", "alloc", "ac", "wic", "isu", "oc", "enc", "mc", "misc", "ISC", "uci", "isl", "is", "rc", "small", "ib", "icc", "sc", "ic", "isp", "ics", "soc", "loc", "iss", "usc", "isi", "isco", "disc", "fi", "lic", "ec"], "swap": ["shap", " swash", "Swapped", "swrap", "waps", "flash", "Swap", "shaps", "wapped", "Swaps", "Swash", "swaps", "shapping", "flap", "wapping", "swapped", "shrap", "swapping", " swaps", "flapping", " swapping", "flaps", "wash", " swapped", "flrap", "wrap", "swash", "wap"], "is_maskable": ["is_weightless", "is_passed", "is_passless", "is_fixed", "is_maskible", "is_askabled", "is_maskless", "is_askible", "is_fixible", "is_askless", "is_signabled", "is_fixabled", "is_weighted", "is_askable", "is_weightible", "is_signed", "is_signible", "is_passable", "is_weightable", "is_masked", "is_maskabled", "is_signable", "is_asked", "is_passible", "is_fixable"], "flic": ["clic", "Flict", "fring", "eflin", "clu", "clux", "eflu", "Flu", " flux", "Flin", "Fring", "Flic", " flin", "Flux", "clict", " flict", "efring", "flict", " flu", "flux", " fring", "flu", "flin", "eflic"], "r": ["str", "i", "ru", "e", "err", "ribute", "ur", "result", "d", "rx", "rr", "rec", " arr", "l", "rf", "lr", "f", "art", "ter", "t", "u", "m", "res", "j", "p", "rh", "rc", "c", "rn", "nr", "ar", "rar", "sr", "b", "hr", "w", "re", "n", "error", "er", "gr", "R", "cr", "mr", "rs", "v", "rb", "ir", "attr", "rg"], "ret": ["str", "reg", "red", "def", "obj", "err", "ref", "result", "val", "det", "rr", "Ret", "cur", "entry", "res", "data", "j", "rel", "arr", "rc", "dr", "out", "match", "run", "RET", "sr", "rt", "b", "rl", "usr", "reply", "re", "len", "mr", "rs", "back", "alt", "nt", "rb", "resp", "fun"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                int lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                int lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_ff1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_fl1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 21106, "substitutes": {"dc": ["lc", "bc", "fc", "cc", "cd", "ct", "oci", "pc", "isc", "nc", "ac", "da", "mc", "xc", "tc", "rc", "c", "roc", "icc", "sc", "dm", "cdn", "jc", "di", "oc", "ec", "DC"], "insn": ["intsn", "kinn", "incd", "kinna", "kinconn", "insd", "ind", " insl", "ainsc", "inb", "inc", " insne", "intsp", "insnc", "outsn", "kinc", "insf", "linsconn", "inconn", "lsd", "lsc", "lsf", "insl", "linb", "insp", "inne", "insc", "innc", "lsn", "insnot", "pexconn", "incf", "inl", "incb", "inssn", "inf", "insconn", " insp", "inp", "innot", "incna", "inna", "linsnot", "ink", "linn", "pexn", "incc", "insk", "linc", "inn", "intsl", "intsne", "incn", "pexnot", "pexc", "linsc", "inck", "outssn", "linf", "insne", "lsb", "ainssn", "ainsnc", "linsn", "insna", "lsk", "outsnc", "incconn", "outsc", "insb", "ainsn"], "op0": ["oper6", "opt1", "oper1", "rop2", "op3", " op19", "op19", "OP0", " op6", "op4", "oper2", "rop19", "hop2", "rop4", "hop0", "opt0", "op6", "opt3", "rop0", "OP6", "hop4", "OP1", "oper0", " op4", "OP3", "hop19", " op3", "OP2"], "op1": ["oper1", "cop4", "cop3", "op3", "op4", "oper2", "OP01", "cop1", "OP4", "op01", "cop01", " op01", "oper01", "OP1", "oper3", "cop2", " op4", "OP3", " op3", "OP2"], "op2": ["op32", "oper4", "cop4", "hop32", "cop3", "op3", " op32", "op4", "oper2", "hop2", "cop1", "hop0", "OP4", "hop4", "OP1", "oper0", "cop2", " op4", "OP3", " op3", "OP2", "oper32"], "ra": ["ras", "ru", "ria", "gra", "area", "ia", "ba", "Ra", "ri", "wa", "stra", "oa", "ina", "RA", "rr", "ca", "ara", "rf", "dra", "ro", "po", "r", "da", "na", "ka", "au", "sa", "la", "rc", "dr", "rar", "ar", "a", "sr", "ta", "ada", "rad", "rt", "ran", "min", "cr", "va", "rs", "ira", "tra", "up", "from", "ma", "alpha", "rg"], "rb": ["pb", "ru", "sb", "ruby", "lb", "adr", "ri", "db", "fb", "rx", "rr", "rf", "lr", "erb", "rob", "r", "reb", "raf", "rh", "rw", "wb", "rc", "cb", "nr", "rm", "rar", "rt", "rl", "b", "vr", "sr", "rid", "usr", "cr", "nb", "ab", "rab", "rs", "bf", "RB", "gb", "rg"], "rd": ["ras", "ru", "ruby", "adr", "ri", "RM", "rog", "rx", "d", "rr", "rf", "lr", "ld", "dra", "rob", "r", "RD", "dd", "rh", "rw", "dr", "rc", "rn", "nr", "rm", "rar", "RR", "rt", "rl", "sr", "rid", "vr", "hr", "cr", "fd", "rss", "rod", "rs", "RF", "rg"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n", "idx": 21110, "substitutes": {"timer_list": ["timer2base", "timerlisttype", "timer_part", "timer2part", "timerlisttable", "loader_queue", "timerprequeue", "timer_base", "timerpretype", "loader_list", "loader_table", "timer_table", "timerlistlist", "timer2list", "timer_type", "timerlistqueue", "timerprelist", "timer_queue", "loader_type", " timer_part", "timer2type", " timer_type", " timer_base", "timerpretable"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n", "idx": 21118, "substitutes": {"src": ["bc", "sb", "stack", "types", "start", "sel", "ints", "sl", "config", "iv", "gl", "bb", "cur", "img", "bl", "gb", "dist", "split", "front", "rest", "inf", "sync", "rc", "cb", "resources", "source", "sc", "b", "sub", "sur", "desc", "inst", "slice", "loc", "ins", "rs", "st", "lib", "sec", "dest", "rb", "chrom", "url"], "dst": ["adost", " dST", "dedST", "dsst", " dost", "dsdest", "dedsts", "dST", "dsrc", "dssts", "dost", "dysts", "dsost", "ddest", "addest", "dsts", "dedst", "adst", "adsts", "dedsrc", "dyst", " ddest", " dsts", " dsrc", "dysrc", "dyST"], "num_pixels": ["num_preorts", "num_ports", "num_cixels", "num_Pixels", "num_corts", "num_hixels", "num_preamples", "num_hicks", "num_camples", "num_apannels", "num_picks", "num_apamples", "num_apixels", "num_hannels", "num_horts", "num_Pannels", "num_apels", "num_cels", "num_pannels", "num_Picks", "num_apicks", "num_pels", "num_preels", "num_Ports", "num_pamples", "num_preixels", "num_aports"], "palette": ["alii", "alignment", "annettes", "assite", "palettes", "alge", "alettes", "alette", "palge", "assge", "palite", "annii", " palettes", "blette", "alite", "palii", "palignment", " palge", "blettes", "assette", "annignment", "blignment", "blii", "annette", " palite", "assettes"], "i": ["io", "e", "start", "ix", "qi", "ri", "ui", "pi", "key", "gi", "d", "uri", "ti", "I", "f", "ci", "t", "u", "oi", "m", "ini", "it", "j", "phi", "info", "ip", "p", "id", "o", "bi", "wei", "mi", "c", "mu", "index", "si", "a", "ii", "b", "ji", "n", "length", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "pointer", "h", "l", "x", "zi"]}}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n", "idx": 21135, "substitutes": {"obj": ["sb", "class", "org", "object", "conn", "jp", "Object", "coll", "orb", "ops", "so", "po", "op", "cmd", "j", "data", "init", "ob", "os", "opt", "o", "buf", "ctx", "self", "cb", "Obj", "tmp", "objects", "n", "src", "nb", "boot", "ock", "bh", "nt", "pt", "bj", "emb"], "ioc": ["giocl", "uroc", "dioca", "hoc", "aoc", "uioco", "ieoco", "idroc", "uioc", "gioca", "uOC", "piroc", "ieroc", "cioca", "ieocal", "pioca", "ioca", "aocl", "uiroc", "iroc", "riroc", "diocl", "giocon", "giOC", "inoc", "abioc", "uiocl", "oac", "oisc", "ciOC", "iac", "gioc", "uac", "uocl", "inocom", "piocom", "ciocal", "uocom", "riocl", "iocon", "piocol", "ciocom", "aoca", "piocl", "iocom", "iOC", " iOC", " ioca", "hroc", "rioc", "uiocal", "abiocol", "ooc", "inac", "ieoc", "giisc", "ciocol", "ciisc", "hocal", "cioc", "ioco", "abiocom", "ciocl", "idoc", "aroc", "iocal", "uiocom", "iocl", "iisc", " iisc", "piOC", "idocl", "oocom", "riOC", "inisc", "giocol", "hocl", "diroc", "ciroc", "iocol", "piocon", "idocal", "ciocon", "uoc", "abioca", "uisc", "cioco", "dioc", "pioc"]}}
{"project": "FFmpeg", "commit_id": "028cc42a1638e6f93a857f11c2568d1c3a51e612", "target": 1, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n\n    if (!strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data+5) == 2) {\n\n        uint8_t desc[256];\n\n        int score = AVPROBE_SCORE_MAX / 2, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 21155, "substitutes": {"st": ["td", "str", "sb", "est", "start", "ct", "std", "ost", "kt", "St", "d", "ld", "bl", "sth", "art", "t", "rest", "nd", "stat", "state", "ts", "ace", "sa", "client", "fe", "sd", "ste", "sc", "sts", "dt", "station", "inst", "src", "sw", "ist", "sf", "test", "th", "stage", "ST", "nt", "sp", "pt", "ust", "sta", "ss", "ft"], "pkt": ["pk", "Packet", " pkg", "peth", " pct", "Pct", "bk", "bnt", "backet", "plkg", "pet", "Pet", "pkg", "tkt", "bkg", " pka", "plka", "pka", "pnt", "apkt", "Pka", "bkt", "beth", "Pcp", "pcp", "Pnt", "apct", " pnt", "Pkg", "plkt", "tacket", " pet", "Pkt", "packet", "tcp", " pk", "tet", " peth", "placket", "Peth", " packet", "pct", "apacket", "apkg", "Pk", " pcp"], "desc": ["lc", "bc", "td", "name", "summary", "txt", "def", "esc", "uc", "config", "asc", "result", "text", "meta", "extra", "null", "rec", "cmp", "dist", "dep", "cont", "info", "dir", "data", "description", "code", "buf", "ext", "rc", "cb", "sc", "sub", "dc", "des", "seq", "rev", "src", "req", "doc", "dest", "Desc", "cod", "pub"], "ret": ["status", "feat", "reg", "def", "en", "xt", "gt", "std", "result", "val", "det", "rec", "Ret", "cur", "no", "res", "data", "cat", "rets", "nz", "score", "opt", "job", "id", "code", "count", "success", "rc", "ext", "num", "match", "RET", "mem", "des", "flag", "seq", "reply", "re", "len", "test", "back", "alt", "sec", "nt", "best", "lit", "att", "resp", "max", "url", "fun"], "ast": ["est", "tta", "ess", "asted", "end", "conn", "ct", "ap", "asm", "amp", "std", "ref", "ost", "part", "mast", "post", "esp", "AST", "tx", "amd", "pc", "host", "anc", "ld", "sth", "art", "node", "aste", "op", "ac", "aid", "rest", "ad", "nd", "hd", "p", "act", "asts", "ace", "aw", "od", "am", "sa", "af", "Ast", "ctx", "asting", "sd", "el", "add", "ta", "sta", "inst", "ard", "ist", "test", "cast", "ab", "ape", "alt", "nt", "old", "best", "pt", "aster", "att", "api", "an", "ft"], "sub_demuxer": ["sub_Democer", "sub_demployler", "sub_promuxER", "sub_demirectER", "sub_democler", "sub_promuxler", "sub_demuxester", "sub_promxers", "sub_demluxers", "sub_Democester", "sub_Democera", "sub_demxER", "sub_demirecteri", "sub_democera", "sub_demirecter", "sub_demluxester", "sub_promuxeri", "sub_demployeri", "sub_Demuxester", "sub_Demuxers", "sub_demuxER", "sub_democer", "sub_demluxer", "sub_promxeri", "sub_demxeri", "sub_demployer", "sub_demluxera", "sub_demxer", "sub_demlexers", "sub_democeri", "sub_demxester", "sub_demxers", "sub_Demuxer", "sub_demlexER", "sub_promxER", "sub_demuxers", "sub_demuxler", "sub_Democers", "sub_democester", "sub_demlexeri", "sub_promuxers", "sub_demirecters", "sub_promxler", "sub_demlexer", "sub_demxera", "sub_Demuxera", "sub_demuxeri", "sub_demxler", "sub_demuxera", "sub_promuxer", "sub_demployers", "sub_democers", "sub_promxer"], "time_base": ["event_stable", "timeprebase", "time2base", "timenbas", "Time_unit", "event_file", "timealdata", "time_stable", " time_data", "time_based", "timealbase", " time_bas", "timeinginfo", "Time_base", "time2unit", "time_file", "timenitem", "Time_based", "event_base", "time_item", " time_based", " time_info", "timealinfo", "time_data", "timeingdata", "time2based", "time_unit", "timeprestable", "timeingbased", "time_info", "timeingbase", "timenbase", "timealbased", "timeprefile", " time_item", "time_bas"], "pb": ["lc", "bc", "platform", "sb", "fc", "txt", "uf", "lb", "summary", "ba", "jp", "lp", "pkg", "db", "mb", "cv", "fb", "cm", "pm", "pit", "bb", "phrase", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "PB", "ob", "p", "tc", "np", "wb", "bps", "buf", "ctx", "cb", "pl", "wp", "mp", "ub", "b", "sub", "cpp", "tmp", "hub", "dl", "bm", "ab", "bf", "bh", "bot", "rb", "typ", "vp", "xb", "api", "dp", "primary", "ppa", "pa"], "pd": ["td", " FD", "pod", "sb", "cd", " prot", " prod", "jp", "lp", "edd", " db", " parser", "pe", " cp", "pm", "vd", " td", "PD", " dd", "d", "pc", "ds", "xd", "fp", "dra", " cd", "pg", " da", "po", "sth", "ud", "gd", "cp", "dd", "PB", "hd", "tp", " ad", "pp", "p", "np", " ta", " df", "py", " DP", " cad", "cb", "sd", "wp", " rc", " dc", "dt", " DD", " disp", " sd", "dl", "fd", "bd", " ep", "parser", " cmd", "dp", " np", "ppa", " std", "pa"]}}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)\n\n{\n\n    int ret;\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    if (o_out)\n\n        *o_out = o;\n\n    if (!o)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n    if (!val || o->offset<=0)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (o->type == FF_OPT_TYPE_BINARY) {\n\n        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);\n\n        int *lendst = (int *)(dst + 1);\n\n        uint8_t *bin, *ptr;\n\n        int len = strlen(val);\n\n        av_freep(dst);\n\n        *lendst = 0;\n\n        if (len & 1) return AVERROR(EINVAL);\n\n        len /= 2;\n\n        ptr = bin = av_malloc(len);\n\n        while (*val) {\n\n            int a = hexchar2int(*val++);\n\n            int b = hexchar2int(*val++);\n\n            if (a < 0 || b < 0) {\n\n                av_free(bin);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            *ptr++ = (a << 4) | b;\n\n        }\n\n        *dst = bin;\n\n        *lendst = len;\n\n        return 0;\n\n    }\n\n    if (o->type != FF_OPT_TYPE_STRING) {\n\n        int notfirst=0;\n\n        for (;;) {\n\n            int i;\n\n            char buf[256];\n\n            int cmd=0;\n\n            double d;\n\n\n\n            if (*val == '+' || *val == '-')\n\n                cmd= *(val++);\n\n\n\n            for (i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++)\n\n                buf[i]= val[i];\n\n            buf[i]=0;\n\n\n\n            {\n\n                const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n\n                if (o_named && o_named->type == FF_OPT_TYPE_CONST)\n\n                    d= o_named->default_val.dbl;\n\n                else if (!strcmp(buf, \"default\")) d= o->default_val.dbl;\n\n                else if (!strcmp(buf, \"max\"    )) d= o->max;\n\n                else if (!strcmp(buf, \"min\"    )) d= o->min;\n\n                else if (!strcmp(buf, \"none\"   )) d= 0;\n\n                else if (!strcmp(buf, \"all\"    )) d= ~0;\n\n                else {\n\n                    int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n\n                    if (res < 0) {\n\n                        av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val);\n\n                        return res;\n\n                    }\n\n                }\n\n            }\n\n            if (o->type == FF_OPT_TYPE_FLAGS) {\n\n                if      (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;\n\n                else if (cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;\n\n            } else {\n\n                if      (cmd=='+') d= notfirst*av_get_double(obj, name, NULL) + d;\n\n                else if (cmd=='-') d= notfirst*av_get_double(obj, name, NULL) - d;\n\n            }\n\n\n\n            if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n\n                return ret;\n\n            val+= i;\n\n            if (!*val)\n\n                return 0;\n\n            notfirst=1;\n\n        }\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (alloc) {\n\n        av_free(*(void**)(((uint8_t*)obj) + o->offset));\n\n        val= av_strdup(val);\n\n    }\n\n\n\n    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));\n\n    return 0;\n\n}\n", "idx": 21166, "substitutes": {"obj": ["io", "str", "start", "org", "object", "off", "ref", "adj", "conn", "coll", "xy", "func", "orb", "img", "eff", "pos", "po", "op", "data", "j", "init", "opt", "ob", "os", "arr", "lock", "act", "abi", "prefix", "wb", "ant", "rot", "js", "ctx", "cb", "num", "out", "self", "oid", "Obj", "xp", "bo", "tmp", "objects", "n", "src", "inst", "bm", "loc", "cdn", "ab", "buff", "lib", "nt", "bot", "fn", "sn", "orig", "image", "att", "pt", "typ", "attr"], "name": ["nam", "option", "part", "key", "style", "anc", "type", "path", "names", "size", "data", "NAME", "na", "label", "prefix", "word", "filename", "out", "pass", "family", "Name", "a", "alias", "n", "len", "base", "parent", "v", "old", "x", "nm", "value"], "val": ["sv", "expr", "def", "Value", "part", "xy", "key", "pos", "fat", "win", "msg", "data", "vals", "prefix", "var", "live", "pl", "br", "test", "VAL", "doc", "v", "eval", "fi", "ul", "end", "ind", "valid", "text", "split", "al", "unit", "vet", "aval", "vol", "boot", "lib", "alt", "vec", "li", "offset", "sel", "serv", "ref", "tx", "exec", "cmd", "it", "arr", "p", "vi", "rot", "el", "byte", "ver", "b", "call", "loc", "Val", "lit", "x", "count", "sl", "arg", "ol", "bl", "slot", "elt", "ctx", "index", "seq", "fl", "len", "pol", "vert", "block", "pt", "all", "base", "value"], "alloc": ["reg", "valid", "unc", "func", "ef", "ac", "ok", "init", "cache", "final", "opt", "nil", "slot", "c", "ctx", "aux", "mem", "vol", "loc", "VAL", "nt", "orig", "eval", "empty", "all", "oc"], "o_out": ["o_again", " o_in", "O_OUT", " o_copy", "o_OUT", "o_bit", "o_in", "O_out", "o_copy", " o_bit", " o_OUT", "O_again", " o_Out", "O_in", "o_Out"], "ret": ["reg", "def", "ref", "result", "rep", "Ret", "res", "cat", "data", "arr", "code", "var", "rc", "num", "RET", "mem", "flag", "re", "nt", "vec", " result", "resp", "max", "Len", "fun"], "o": ["io", "e", "object", "off", "O", "oo", "option", "oe", "none", "oa", "ol", "so", "yo", "l", "no", "f", "po", "t", "y", "oi", "op", "one", "m", "mo", "u", "ob", "os", "p", "or", "od", "out", "c", "lo", "oid", "fo", "b", "go", "bo", "to", "ov", "n", "co", "iso", "v", "ko", "image", "oc", "k", "vo"], "dst": [" ddr", "rdstr", "lste", "Dst", "lst", "dsc", "lbl", "sdest", "Dsc", "bdr", "dsp", " dsc", "bste", "dbl", "lsc", "Dbl", "idst", " dbl", " dstr", "rdest", "idstr", "lsp", "sdsp", "dsts", "ldr", "rdst", "sdsc", " dest", "sdst", "lest", " dste", "rdsts", "dste", " dsts", "idsts", "Dste", "dest", "bbl", " dsp", "bst", "idest", "ddr", "dstr"], "lendst": ["loudSt", "ladsta", "bloudsta", "ladSt", "lndst", "ladsc", "lendedsp", "bloudsc", "lendsost", "loudsta", " lendirst", " lndst", "loudst", "lendsirst", "lendsts", " lndsp", "bloudst", "blendsc", "lendsc", "lndirst", "ladst", "loudsc", "lendost", "lndsp", "bloudSt", "lENDSt", "lndsts", "lendest", "lENDst", " lendost", "lendedst", "lendsta", "lizrest", "blendst", "lendssp", "blendSt", "lendedost", "lendedirst", "lndest", "lndost", "lENDsta", "lendsp", "lndrest", "lizst", "lizest", "lendrest", "lizsts", " lendest", "lENDsc", " lendsts", " lndost", "blendsta", " lendsp", " lendrest", "lendSt", "lendsst", " lndirst", "lendirst"], "bin": ["bc", "binary", "bis", "nn", "db", "spin", "part", "rin", "bb", "ln", "gin", "pc", "bl", "local", "buffer", "win", "split", "ac", "bit", "socket", "abi", "bn", "lin", "bi", "inner", "sync", "index", "pin", "vin", "num", "byte", "in", "len", "br", "loc", "obin", "root", "border", "lib", "sid", "bot", "bar", "offset", "base", "gb", "fin"], "ptr": ["str", "start", "err", "ref", "ind", "butt", "tr", "pad", "pc", "bl", "buffer", "pos", "abi", "arr", "code", "addr", "var", "dr", "rot", "fe", "dim", "vr", "rev", "inst", "src", "fd", "len", "loc", "slice", "length", "br", "Ptr", "proc", "pointer", "sp", "lf", "pt", "offset", "attr"], "i": ["io", "anti", "e", "ix", "start", "ie", "fi", "qi", "ui", "g", "mini", "gi", "uri", "chi", "ti", "I", "l", "f", "ci", "t", "y", "phi", "u", "m", "ini", "it", "j", "oi", "info", "s", "ip", "p", "id", "bi", "cli", "mi", "c", "mu", "index", "si", "ii", "in", "ji", "n", "iu", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "yi", "h", "pi", "x", "k", "ni"], "buf": ["conv", "bc", "port", "stack", "uf", "uc", "config", "text", "map", "cv", "fb", "queue", "img", "cas", "buffer", "cmd", "box", "data", "cat", "bed", "bn", "pool", "header", "ctx", "out", "cb", "rc", "window", "bo", "seq", "ff", "fd", "src", "loc", "br", "bd", "batch", "buff", "proc", "bag", "vec", "rb", "block", "pt", "output", "cap"], "d": [" r", " stride", " prod", " img", " dd", " pad", " cd", " c", "Cmd", " def", " df", " diff", " chunk", " data", " cur", " vec", " count", " grad", " init", " digest", " disp", " bc", " delta", " dev", " dw", " comp", " std", " exec"], "o_named": ["n_amed", "o__name", "o__placed", "o__amed", "oaJaligned", "oJamed", "o_specified", "o_ned", "n__amed", "o___placed", "oJbuilt", "o_aligned", "oo___name", "o_name", "o___specified", "oa_aligned", "o___named", "o_placed", "oaJbuilt", "o_amed", "oo_name", "n_name", "oo_placed", "oaJnamed", "o__named", "n_named", "oJnamed", "n_ned", "oo___named", "oo___placed", "o_built", "oJaligned", "o___amed", "o___name", "oa_built", "n__name", "oa_named", "o__specified", "oa_amed", "o__ned", "oaJamed", "n__named", "oo_named", "n__ned", "oo___specified", "o___ned", "oo_specified"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,\n\n                                    int alpha, int beta, int8_t *tc)\n\n{\n\n    uint8_t bs0 = 1;\n\n    uint8_t bs1 = 1;\n\n    uint8_t bs2 = 1;\n\n    uint8_t bs3 = 1;\n\n\n\n    if (tc[0] < 0)\n\n        bs0 = 0;\n\n    if (tc[1] < 0)\n\n        bs1 = 0;\n\n    if (tc[2] < 0)\n\n        bs2 = 0;\n\n    if (tc[3] < 0)\n\n        bs3 = 0;\n\n\n\n    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,\n\n                                               bs0, bs1, bs2, bs3,\n\n                                               tc[0], tc[1], tc[2], tc[3],\n\n                                               alpha, beta,\n\n                                               img_width);\n\n}\n", "idx": 21168, "substitutes": {"data": ["end", "next", "config", "scale", "valid", "result", "input", "map", "db", "Data", "d", "device", "buffer", "results", "ata", "da", "cache", "ad", "dd", "new", "load", "memory", "la", "DATA", "window", "ada", "tmp", "reader", "test", "database", "batch", "parent", "dat", "image", "block", "api", "base"], "img_width": ["img_height", "imgwwidth", "imgwname", "img_weight", "img_size", " img_length", "img_length", " img_name", " img_size", "imgwheight", "imgwweight", " img_weight", " img_height", "img_name"], "alpha": ["ity", "ana", "ra", "i", "area", "amp", "scale", "acl", "asc", "inc", "average", "pha", "extra", "A", "ca", "as", "ac", "da", "igma", "size", "na", "sa", "la", "audio", "filter", "lambda", "si", "a", "uca", "ta", "alias", "qa", "sup", "aa", "angle", "ma", "\u03b1", "Beta", "Alpha"], "beta": ["bc", "ba", "asc", "db", "meta", "\u03b2", "uma", "phi", "ga", "fee", "appa", "abi", "abc", "wb", "eta", "la", "mu", "cb", "negative", "lambda", "si", "a", "b", "ta", "uca", "error", " Beta", "mega", "bot", "gam", "offset", "Beta", "pa"], "tc": ["lc", "bc", "pb", "fc", "col", "txt", "cc", "types", "uc", "config", "ui", "com", "toc", "ctr", "cm", "tr", "tx", "tim", "ca", "bb", "temp", "pc", "cl", "cu", "cas", "ci", "term", "ac", "acc", "cp", "nc", "cache", "cases", "TC", "ts", "mc", "cs", "ctrl", "tu", "rc", "c", "ctx", "cb", "spec", "tf", "icc", "sc", "ta", "dc", "tmp", "ic", "tn", "test", "loc", "cus", "co", "tm", "oc", "ec", "k", "gb"]}}
{"project": "qemu", "commit_id": "f37343197708d90f119007ce5ecc2503be9c04c1", "target": 0, "func": "void slirp_select_poll(fd_set *readfds, fd_set *writefds, fd_set *xfds,\n\n                       int select_error)\n\n{\n\n    Slirp *slirp;\n\n    struct socket *so, *so_next;\n\n    int ret;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_instances)) {\n\n        return;\n\n    }\n\n\n\n    global_readfds = readfds;\n\n    global_writefds = writefds;\n\n    global_xfds = xfds;\n\n\n\n    curtime = qemu_get_clock_ms(rt_clock);\n\n\n\n    QTAILQ_FOREACH(slirp, &slirp_instances, entry) {\n\n\t/*\n\n\t * See if anything has timed out\n\n\t */\n\n\t\tif (time_fasttimo && ((curtime - time_fasttimo) >= 2)) {\n\n\t\t\ttcp_fasttimo(slirp);\n\n\t\t\ttime_fasttimo = 0;\n\n\t\t}\n\n\t\tif (do_slowtimo && ((curtime - last_slowtimo) >= 499)) {\n\n\t\t\tip_slowtimo(slirp);\n\n\t\t\ttcp_slowtimo(slirp);\n\n\t\t\tlast_slowtimo = curtime;\n\n\t\t}\n\n\n\n\t/*\n\n\t * Check sockets\n\n\t */\n\n\tif (!select_error) {\n\n\t\t/*\n\n\t\t * Check TCP sockets\n\n\t\t */\n\n\t\tfor (so = slirp->tcb.so_next; so != &slirp->tcb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\t/*\n\n\t\t\t * FD_ISSET is meaningless on these sockets\n\n\t\t\t * (and they can crash the program)\n\n\t\t\t */\n\n\t\t\tif (so->so_state & SS_NOFDREF || so->s == -1)\n\n\t\t\t   continue;\n\n\n\n\t\t\t/*\n\n\t\t\t * Check for URG data\n\n\t\t\t * This will soread as well, so no need to\n\n\t\t\t * test for readfds below if this succeeds\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, xfds))\n\n\t\t\t   sorecvoob(so);\n\n\t\t\t/*\n\n\t\t\t * Check sockets for reading\n\n\t\t\t */\n\n\t\t\telse if (FD_ISSET(so->s, readfds)) {\n\n\t\t\t\t/*\n\n\t\t\t\t * Check for incoming connections\n\n\t\t\t\t */\n\n\t\t\t\tif (so->so_state & SS_FACCEPTCONN) {\n\n\t\t\t\t\ttcp_connect(so);\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} /* else */\n\n\t\t\t\tret = soread(so);\n\n\n\n\t\t\t\t/* Output it if we read something */\n\n\t\t\t\tif (ret > 0)\n\n\t\t\t\t   tcp_output(sototcpcb(so));\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Check sockets for writing\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, writefds)) {\n\n\t\t\t  /*\n\n\t\t\t   * Check for non-blocking, still-connecting sockets\n\n\t\t\t   */\n\n\t\t\t  if (so->so_state & SS_ISFCONNECTING) {\n\n\t\t\t    /* Connected */\n\n\t\t\t    so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t    ret = send(so->s, (const void *) &ret, 0, 0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXXXX Must fix, zero bytes is a NOP */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    }\n\n\t\t\t    /* else so->so_state &= ~SS_ISFCONNECTING; */\n\n\n\n\t\t\t    /*\n\n\t\t\t     * Continue tcp_input\n\n\t\t\t     */\n\n\t\t\t    tcp_input((struct mbuf *)NULL, sizeof(struct ip), so);\n\n\t\t\t    /* continue; */\n\n\t\t\t  } else\n\n\t\t\t    ret = sowrite(so);\n\n\t\t\t  /*\n\n\t\t\t   * XXXXX If we wrote something (a lot), there\n\n\t\t\t   * could be a need for a window update.\n\n\t\t\t   * In the worst case, the remote will send\n\n\t\t\t   * a window probe to get things going again\n\n\t\t\t   */\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Probe a still-connecting, non-blocking socket\n\n\t\t\t * to check if it's still alive\n\n\t \t \t */\n\n#ifdef PROBE_CONN\n\n\t\t\tif (so->so_state & SS_ISFCONNECTING) {\n\n                          ret = qemu_recv(so->s, &ret, 0,0);\n\n\n\n\t\t\t  if (ret < 0) {\n\n\t\t\t    /* XXX */\n\n\t\t\t    if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\terrno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t      continue; /* Still connecting, continue */\n\n\n\n\t\t\t    /* else failed */\n\n\t\t\t    so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t    so->so_state |= SS_NOFDREF;\n\n\n\n\t\t\t    /* tcp_input will take care of it */\n\n\t\t\t  } else {\n\n\t\t\t    ret = send(so->s, &ret, 0,0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXX */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    } else\n\n\t\t\t      so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t  }\n\n\t\t\t  tcp_input((struct mbuf *)NULL, sizeof(struct ip),so);\n\n\t\t\t} /* SS_ISFCONNECTING */\n\n#endif\n\n\t\t}\n\n\n\n\t\t/*\n\n\t\t * Now UDP sockets.\n\n\t\t * Incoming packets are sent straight away, they're not buffered.\n\n\t\t * Incoming UDP data isn't buffered either.\n\n\t\t */\n\n\t\tfor (so = slirp->udb.so_next; so != &slirp->udb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\tif (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                            sorecvfrom(so);\n\n                        }\n\n\t\t}\n\n\n\n                /*\n\n                 * Check incoming ICMP relies.\n\n                 */\n\n                for (so = slirp->icmp.so_next; so != &slirp->icmp;\n\n                     so = so_next) {\n\n                     so_next = so->so_next;\n\n\n\n                    if (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                        icmp_receive(so);\n\n                    }\n\n                }\n\n\t}\n\n\n\n\t/*\n\n\t * See if we can start outputting\n\n\t */\n\n\tif (slirp->if_queued) {\n\n\t    if_start(slirp);\n\n\t}\n\n    }\n\n\n\n\t/* clear global file descriptor sets.\n\n\t * these reside on the stack in vl.c\n\n\t * so they're unusable if we're not in\n\n\t * slirp_select_fill or slirp_select_poll.\n\n\t */\n\n\t global_readfds = NULL;\n\n\t global_writefds = NULL;\n\n\t global_xfds = NULL;\n\n}\n", "idx": 21202, "substitutes": {"readfds": ["writefordds", "readvdd", "readfordds", "readinfps", "writefdds", "readinfns", "readforks", "writefks", "readrfdds", "readddds", "readgns", "writerfds", " readfdds", "readrfns", "readinfdds", "readfks", "writeforks", "readfps", "readvdds", "writerfns", "writerfdds", "readlns", "readfdds", "readvns", "readifdds", "readfordd", "writefps", "readgps", "readrfds", "writefdd", "readinfds", "readfns", "readfords", "readdds", "readldd", "readifds", "readvds", "readifdd", "writefords", "readgds", "readgdds", "writefordd", "readddd", "readrfps", "readdks", "readlds", "readldds", " readfdd", " readfns", "writerfps", "readifks", "readfdd", "writefns"], "writefds": ["writefd", "sendfd", "writefcda", "writefsd", "writerfros", "writetfdds", "writefdds", "sendfsdd", "writetfsts", "writecsts", " writefsts", "writecdds", "writerfds", "writefsts", " writefsd", "writerfsts", "writeofsts", "writeofords", "sendfsds", "writecds", " writeofdds", "writefsros", " writeofds", "sendfdd", "sendfssts", "writefdd", " writefsds", "writefssts", "writerfdd", "writefcds", "sendfsts", "writefcros", " writeofords", "writeofds", "writefsda", "writefords", " writefd", " writeofsts", " writefdds", "writerfd", "writefros", "writecords", "writeofdds", "writefsdd", " writefsros", "writefsds", "writetfds", " writefda", " writefsda", " writefros", "writefcd", "writefda", "sendfds", "writetfords", " writefords", "writerfda", "sendfsd"], "xfds": ["efdd", "fcades", "cfades", "fxks", "xcds", "xcks", "xcda", "cfda", "efd", "sfded", "xfades", "sfks", "xfks", "xcdd", "fcdds", "xfd", "efded", "xfda", "xcded", "xfdd", "fcda", "sfda", "xfded", "fxds", "cfds", "sfd", "xcd", "cfdds", "efds", "fxades", "sfds", "fxda", "fxdds", "fcds", "sfdd", "xfdds", "fxd"], "select_error": ["connect_Error", "selectjerror", "select_ror", "connect_error", "select2ror", " select_err", "selectjcommand", "select2Error", " select_ror", "selectableror", "select2error", "selectableerror", "selectjror", "select2err", " select_command", "connect_err", "select_command", "select_err", "selectjerr", "selectableerr", "select_Error", "selectableError", "connect_ror"], "slirp": ["slearc", "plirtpe", "shirtpc", "sliperv", "slirc", "slierr", "slrrpc", "sliverpc", "slirepc", "slpirf", "slirpo", "slirepo", " slirepc", "slurP", "shirp", "sliperpc", "slirepe", "slrispe", "slearpa", "silirper", "slirP", " slirepe", "plirpe", "slirpc", "shyrp", "slpirpa", "slirper", "silirpc", "slurp", "slirtpo", "silwerpc", "slirtpe", "slyrpc", "slmirp", "slirtv", "slmirpo", "plirtpo", "silirp", "slpirpe", "plirtpa", "slirv", "slrrcp", "slurping", "plirtpc", "plirpo", "slearpe", "slyrpe", "slwerp", "silwerp", "slirping", "slpirp", "slmirpc", "slirtf", "slierping", "slrispc", "slwerpe", "shirtcp", "slirep", "sliverpo", "shyrpe", "plirpa", "shirtv", "shirping", "slrrv", "slearpc", "slwerpc", "slearpo", "slearf", "plirtp", "slireping", "sliperp", "slyrp", "slireP", "slircp", "slirtpa", "slurr", "slpirpc", "shircp", "slirf", "silirpe", "shirpe", "shierp", "slrrp", "plirf", "slirer", "slyrpo", "slrisp", "slipercp", "silwerpe", "slyrc", "shirr", "slearp", "sliverpe", "slirr", "shirc", "sliverp", "plirtf", " slirpo", "slrisper", "slwerper", "slierP", "slirtpc", "plirp", " slirpe", "slirtcp", "shirtp", "shirP", " slirepo", "shyrc", "shirv", "slirec", "slirpa", "slierp", "plirpc", "slpirper", "shyrpc", "slirtp", "slirpe", "shierr", "shierping", "shierP", " slirpc", " slirep", "silwerper", "slmirpe", "shirpc"], "so": ["oso", "zo", "thro", "oh", "shi", "no", "ho", "mo", "os", "ssl", "osa", "la", "go", "bo", "SO", "te", "ku", "ko", "from", "ge", "who", "sb", "oe", "So", "style", "ci", "s", "o", "sm", "plus", "sc", "to", "va", "flo", "olo", "ce", "ie", "su", "ni", "sel", "ao", "ki", "ou", "model", "oss", "or", "cli", "coe", "si", "sw", "zh", "co", "sq", "fo", "ilo", "sk", "obj", "sl", "po", "oi", "ico", "osi", "sync", "sa", "lo", "client", "sh", "sing", "se", "sp", "sn", "isi", "kee", "ski"], "so_next": ["so_cookie", "so_last", "fo_cookie", "so_prev", "sw_string", "so_current", "fo_last", "so__future", "so_sequence", "fo_state", "o_last", "so__string", "fo_next", "fo_sequence", "so_future", "so__next", "so_string", "sw_future", "so_link", "fo_string", "o_link", "so__last", "so_state", "sw_last", "so_new", "fo_current", "o_new", "sw_next", "o_next", "fo_prev"], "ret": ["status", "sat", "str", "reg", "ut", "def", "obj", "gt", "ct", "ref", "pet", "result", "val", "ft", "arg", "det", "db", "Ret", "mt", "no", "bit", "res", "data", "cat", "fin", "opt", "arr", " RET", "id", "code", "fun", "py", "rc", "ext", "out", "num", "match", "pass", "let", "RET", "rt", " Ret", "mem", "flag", "usr", "reply", "re", "len", "lt", "back", "bf", "alt", "ry", "nt", "rb", "lit", "att", "pt", "resp", "rets"]}}
{"project": "qemu", "commit_id": "970d622e8ab1de8fdf5762e23e92a2dea9d7d36c", "target": 0, "func": "uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n", "idx": 21218, "substitutes": {"op1": ["ipb", "oper1", "ip01", "hopa", "operb", " op8", "ops01", "op01", "ops1", "ops8", "hop1", "ipa", " op01", "oper8", "hopb", "oper01", "hop01", "opsb", "op8", "ip1"], "op2": ["ipb", "rop8", "Op2", "Op8", "rop2", "opertwo", "optwo", "oper2", "OpII", "copb", "Optwo", "ropII", "op0", " op0", "opII", "cop0", "ip0", "ip2", "oper8", "roptwo", "operII", "op8", "cop2"], "opa": ["ja", "apa", "jp", "rog", "oda", "pha", "oa", "apo", "ca", "cop", "ara", "so", "elo", "oka", "abo", "asa", "po", "ona", "op", "pre", "obo", "data", "oga", "ip", "osi", "na", "asi", "appa", "o", "opal", "ollo", "osa", "cro", "aco", "cho", "appy", "vo", "aa", "pai", "pol", "phony", "di", "azi", "jo", "api", "ppa", "opus", "pa", "ori", "ppo"], "opb": ["optb", " oplb", "optba", " opbb", "apab", "optlb", "ropba", "apb", "hopba", "ropb", "hopa", "roplb", "operbb", "operb", "OPbb", "opba", " opab", "operab", "opbb", "ropbb", "OPba", "oplb", "optbb", "OPb", "OPa", "hopb", " opba", "hopbb", "opab", "apbb"], "res": ["reg", "ras", "response", "err", "result", "val", "ress", "features", "RES", "rem", "rap", "rx", "rep", "rec", "rates", "css", "results", "rez", "r", "ris", "gre", "ares", "rest", "rel", "os", "ret", "Res", "arr", "rh", "reed", "success", "rus", "resh", "pres", "ms", "seq", "rev", "Rs", "re", "details", "gr", "changes", "rss", "req", "ps", "rs", "ries", "resolution", "resp"], "i": ["io", "uli", "ix", "e", "start", "fi", "qi", "ri", "ui", "eni", "part", "pi", "gi", "my", "d", "chi", "ti", "I", "l", "f", "ci", "t", "u", "oi", "r", "m", "ini", "j", "s", "info", "ip", "p", "abi", "id", "o", "bi", "is", "mi", "c", "index", "si", "a", "ii", "b", "slice", "ai", "xi", "hi", "di", "v", "multi", "z", "li", "ie", "x", "zi", "k", "ni"]}}
{"project": "qemu", "commit_id": "7b527b86eb3560d68f41218cec0cdf3d60a38323", "target": 0, "func": "static int s390_ipl_init(SysBusDevice *dev)\n\n{\n\n    S390IPLState *ipl = S390_IPL(dev);\n\n    uint64_t pentry = KERN_IMAGE_START;\n\n    int kernel_size;\n\n\n\n    int bios_size;\n\n    char *bios_filename;\n\n\n\n    /*\n\n     * Always load the bios if it was enforced,\n\n     * even if an external kernel has been defined.\n\n     */\n\n    if (!ipl->kernel || ipl->enforce_bios) {\n\n        uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;\n\n\n\n        if (bios_name == NULL) {\n\n            bios_name = ipl->firmware;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (bios_filename == NULL) {\n\n            hw_error(\"could not find stage1 bootloader\\n\");\n\n        }\n\n\n\n        bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,\n\n                             &ipl->bios_start_addr, NULL, NULL, 1,\n\n                             ELF_MACHINE, 0);\n\n        if (bios_size > 0) {\n\n            /* Adjust ELF start address to final location */\n\n            ipl->bios_start_addr += fwbase;\n\n        } else {\n\n            /* Try to load non-ELF file (e.g. s390-zipl.rom) */\n\n            bios_size = load_image_targphys(bios_filename, ZIPL_IMAGE_START,\n\n                                            4096);\n\n            ipl->bios_start_addr = ZIPL_IMAGE_START;\n\n            if (bios_size > 4096) {\n\n                hw_error(\"stage1 bootloader is > 4k\\n\");\n\n            }\n\n        }\n\n        g_free(bios_filename);\n\n\n\n        if (bios_size == -1) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        /* default boot target is the bios */\n\n        ipl->start_addr = ipl->bios_start_addr;\n\n    }\n\n\n\n    if (ipl->kernel) {\n\n        kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n\n                               NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n\n         * kernel parameters here as well. Note: For old kernels (up to 3.2)\n\n         * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n\n         * loader) and it won't work. For this case we force it to 0x10000, too.\n\n         */\n\n        if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n\n            ipl->start_addr = KERN_IMAGE_START;\n\n            /* Overwrite parameters in the kernel image, which are \"rom\" */\n\n            strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n\n        } else {\n\n            ipl->start_addr = pentry;\n\n        }\n\n\n\n        if (ipl->initrd) {\n\n            ram_addr_t initrd_offset;\n\n            int initrd_size;\n\n\n\n            initrd_offset = INITRD_START;\n\n            while (kernel_size + 0x100000 > initrd_offset) {\n\n                initrd_offset += 0x100000;\n\n            }\n\n            initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n            if (initrd_size == -1) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        ipl->initrd);\n\n                exit(1);\n\n            }\n\n\n\n            /*\n\n             * we have to overwrite values in the kernel image,\n\n             * which are \"rom\"\n\n             */\n\n            stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n\n            stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 21219, "substitutes": {"dev": ["Dev", "priv", "reg", "grad", "cam", "conn", "DEV", "Device", "gu", "eth", "de", "d", "temp", "device", "gd", "devices", "data", "serial", "mod", "od", "plug", "sd", "pro", "dem", "dom", "die", "ver", "ch", "rad", "dm", "di", "proc", "bus", "ev", "pu", "pub"], "ipl": ["upp", "opl", "Impl", "ipp", "ibl", "eff", "iop", "tif", "ssl", "isl", "iw", "PL", "ipper", "pl", "phil", "hl", "mult", "util", "ips", "inet", "ppo", "ul", "sil", "obl", "repl", "control", "cel", "fp", "ffe", "owl", "plug", "chip", "sf", "dll", "utils", "lip", "expl", "ELF", "ctl", "operator", "impl", "iper", "intel", "scl", "compl", "inf", "cli", " pl", "inst", "imp", "abul", "hw", "spl", "abb", "ilo", "ipping", "iol", "sl", "lv", "il", "ril", "inc", "ffield", "qq", "ippers", "inyl", "multipl", "pp", "ctrl", "bitcoin", "rl", "pull", "fl", "vp", "elf"], "kernel_size": ["kernel128size", "family_width", "family5width", "kernel_name", "pixel_offset", "family5size", "kernel128number", "pixel_name", "family5sized", " kernel_number", "kernel67score", "kernel67large", "kernel64sized", "kernel_time", "kernel_large", "kernel67count", "kernel_offset", "kernel67time", "thread_score", "kernel5sized", "kernel67size", "kernel5size", "thread_fee", "kernel_score", "pixel_size", "kernel_ize", "kernel64size", "kernel_number", "kernel_sized", "kernel67fee", "family_sized", "kernel_fee", "kernel128ize", "thread_size", " kernel_large", "kernel5width", "kernel_width", "kernel67ize", "kernel64width", " kernel_ize", "kernel_count", " kernel_time", "kernel67number", "family_size", "thread_count"], "bios_size": ["botes_size", "bios_name", "bios_ize", "botes_ize", "bios_width", "bios_number", "bips_size", "bits_number", "bits_capacity", "bias_size", "bits_size", "bias_width", "bips_load", "bias_sized", "bio_name", "bias_ize", "bios_sized", "bios_loc", "bins_number", "bios_use", "bins_size", "bips_speed", "bio_scale", "bios_capacity", "botes_SIZE", "bios_SIZE", "bips_use", "bins_area", "bios_scale", "bio_size", "bios_speed", "bits_width", "bios_load", "bio_loc", "bins_name", "bios_area"], "bios_filename": ["bos_size", "bios__name", "bios_fp", "bias_file", "bios_name", "bios_fil", "bixels__location", "bios_location", "bias_fp", "bias_username", "bixels_name", "bixels_path", "bixels__filename", "bios__location", "bixels_Filename", "bio_name", "bios_path", "bios__fp", "bixels_fil", "bio_filename", "bios_file", "bias_filename", "bos_name", "bias_Filename", "bixels__fp", "bio_file", "bias_fn", "bios_Filename", "bixels_fp", "bios_fn", "bos_file", "bio_size", "bixels_filename", "bixels__name", "bios__filename", "bos_filename", "bias_path", "bios_username", "bixels_location"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 21250, "substitutes": {"devname": [" devno", " devnm", "evnames", " devName", "devno", "devName", "divnames", "devicenm", "evName", "devnm", "evname", "deviceno", " devnames", "devicename", "divName", "deviceName", "evno", "Devname", "Devnm", "divname", "DevName", "devnames"], "device": ["package", "pod", "target", "attribute", "gpu", "object", "conn", "config", "option", "driver", "Device", "project", "mount", "mode", "connection", "de", "d", "display", "host", "node", "product", "devices", "buffer", "path", "model", "custom", "address", "dev", "data", "serial", "component", "unit", "machine", "disk", "module", "cpu", "DA", "dc", "task", "di", "parent", "server", "ev"], "label": ["bind", "config", "val", "key", "cell", "path", "info", "address", "data", "link", "prefix", "field", "load", "alias", "dl", "test", "output", "col", "Label", "name", "ind", "ride", "driver", "text", "null", "style", "align", "node", "description", "unit", "code", "title", "brand", "channel", "desc", " labels", "abel", "li", "summary", "err", "ref", " Label", "model", "new", "comment", "el", "module", "error", "call", "mark", "length", "loc", "group", "note", "layout", "display", "bridge", "bl", "lab", "diff", "frame", "hide", "tex", "session", "len", "console", "border", "block", "value"], "bus_opts": ["bus_ops", "bus_optpt", "bus_operments", "bus_optents", "bus_opte", "bus___optd", "bus_cht", "bus_OPte", "bus_optte", "bus_OPents", "bus_optd", "bus_optts", "bus_operte", "bus___opts", "bus_optments", "bus_opments", "bus_OPts", "bus_OPments", "bus_opt", "bus_optt", "bus_opers", "bus_opents", "bus_chts", "bus_chpt", "bus___opt", "bus_oppt", "bus_chtd", "bus_operts", "bus___oppt", "bus_OPt", "bus_opttd", "bus_opert", "bus_OPs"], "dev_opts": ["dev_OPter", "dev_OPps", "dev_coptr", "dev_hopt", "dev_OPts", "dev_copts", "dev_appTS", "dev_ims", "dev_popps", "dev_optter", "dev_popt", "dev_optts", "dev_OPt", "dev_apptes", "dev_appt", "dev_optes", "dev_poptr", "dev_operts", "dev_imts", "dev_opcs", "dev_imt", "dev_popts", "dev_hoptes", "dev_opter", "dev_optr", "dev_opTS", "dev_OPtes", "dev_OPcs", "dev_optt", "dev_OPs", "dev_optcs", "dev_OPtr", "dev_OPTS", "dev_opert", "dev_hopts", "dev_operter", "dev_imcs", "dev_copps", "dev_hopTS", "dev_ops", "dev_opers", "dev_opps", "dev_copt", "dev_appts", "dev_opt"], "index": ["route", "i", "name", "ix", "end", "level", "ind", "option", "config", "valid", "pattern", "loop", "input", "part", "inc", "key", "connection", "column", "pos", "ion", "section", "axis", "address", "ini", "size", "version", "current", "diff", "number", "count", "find", "body", "prefix", "comment", "condition", "Index", "code", "localhost", "num", "search", "match", "form", "x", "value", "date", "point", "error", "length", "slice", "len", "test", "page", "loc", "element", "insert", "update", "append", "pointer", "ticket", "instance", "image", "position", "offset", "output", "action", "type"]}}
{"project": "qemu", "commit_id": "6cff3e8594cd974a507d531da09455d1c7aeb30d", "target": 0, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n", "idx": 21256, "substitutes": {"mon": ["Mon", "monitor", "member", "un", "bro", "conn", "om", "config", "non", "connection", "mag", "mor", "con", "my", "pm", "emon", "amon", "kin", "m", "mo", "don", "man", "mc", "mm", "MON", "mi", "am", "mu", "atom", "mons", "sm", "module", "num", "dom", "ann", "on", "pid", "bo", "dm", "n", "mun", "meter", "mand", "mut", "prem", "http", "manager", "param", "block", "mos", "an", "mn"], "str": ["lc", "arc", "Str", "err", "chain", "ctr", "cm", "tr", "cur", "cl", "exec", "r", "strings", "arr", "or", "enc", "inner", "cli", "dr", "fr", "pass", "sc", "sr", "dc", "cr", "br", "iter", "stri", "st", "ner", "sp", "STR"], "c": ["lc", "bc", "fc", "i", "arc", "e", "cc", "uc", "esc", "ct", "g", "chain", "unc", "cm", "d", "cl", "cu", "f", "ci", "t", "exc", "nc", "ac", "u", "m", "r", "y", "enc", "p", "xc", "cf", "cs", "mc", "code", "tc", "comment", "sc", "ch", "b", "dc", "cy", "cr", "C", "v", "ce", "h", "l", "x", "ec"]}}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n", "idx": 21261, "substitutes": {"s": ["sim", "i", "sb", "e", "sym", "qs", "es", "hs", "sl", "g", "ses", "d", "sets", "ks", "l", "ds", "services", "f", "sys", "t", "u", "r", "m", "less", "args", "ssl", "os", "ts", "p", "cs", "us", "o", "ls", "sync", "is", "ss", "stats", "sg", "c", "ctx", "js", "spec", "self", "settings", "si", "a", "b", "w", "service", "n", "S", "ns", "session", "sf", "ps", "gs", "conf", "sec", "h", "su", "sq", "states"], "seg_reg": ["seg__rec", "seg_run", "seg_min", "sega_REG", "segptag", "seG_rec", "segn_register", "seg_Reg", "sega_tag", "seg_register", "seg_num", "seig_reg", "seG_reg", "sega_reg", "seig_min", "seG_Reg", "seig_rec", "sereg_tag", "seg_tag", "segn_rec", "seg__num", "seg_rule", "seg_REG", "seg__Reg", "sereg_num", "segn_reg", "segpREG", "segpreg", "sereg_REG", "sereg_reg", "segprun", "seg_ret", "sereg_min", "seG_num", "sega_run", "seg__reg", "seig_rule", "sereg_ret", "seg_rec"]}}
{"project": "qemu", "commit_id": "5d98bf8f38c17a348ab6e8af196088cd4953acd0", "target": 0, "func": "void gen_intermediate_code_a64(ARMCPU *cpu, TranslationBlock *tb)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    target_ulong next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n\n\n    dc->aarch64 = 1;\n\n    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then\n\n     * there is no secure EL1, so we route exceptions to EL3.\n\n     */\n\n    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&\n\n                               !arm_el_is_aa64(env, 3);\n\n    dc->thumb = 0;\n\n    dc->bswap_code = 0;\n\n    dc->condexec_mask = 0;\n\n    dc->condexec_cond = 0;\n\n    dc->mmu_idx = ARM_TBFLAG_MMUIDX(tb->flags);\n\n    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (dc->current_el == 0);\n\n#endif\n\n    dc->fp_excp_el = ARM_TBFLAG_FPEXC_EL(tb->flags);\n\n    dc->vec_len = 0;\n\n    dc->vec_stride = 0;\n\n    dc->cp_regs = cpu->cp_regs;\n\n    dc->features = env->features;\n\n\n\n    /* Single step state. The code-generation logic here is:\n\n     *  SS_ACTIVE == 0:\n\n     *   generate code with no special handling for single-stepping (except\n\n     *   that anything that can make us go to SS_ACTIVE == 1 must end the TB;\n\n     *   this happens anyway because those changes are all system register or\n\n     *   PSTATE writes).\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 1: (active-not-pending)\n\n     *   emit code for one insn\n\n     *   emit code to clear PSTATE.SS\n\n     *   emit code to generate software step exception for completed step\n\n     *   end TB (as usual for having generated an exception)\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 0: (active-pending)\n\n     *   emit code to generate a software step exception\n\n     *   end the TB\n\n     */\n\n    dc->ss_active = ARM_TBFLAG_SS_ACTIVE(tb->flags);\n\n    dc->pstate_ss = ARM_TBFLAG_PSTATE_SS(tb->flags);\n\n    dc->is_ldex = false;\n\n    dc->ss_same_el = (arm_debug_target_el(env) == dc->current_el);\n\n\n\n    init_tmp_a64_array(dc);\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    tcg_clear_temp_count();\n\n\n\n    do {\n\n        tcg_gen_insn_start(dc->pc, 0);\n\n        num_insns++;\n\n\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    gen_exception_internal_insn(dc, 0, EXCP_DEBUG);\n\n                    /* Advance PC so that clearing the breakpoint will\n\n                       invalidate this TB.  */\n\n                    dc->pc += 2;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc->ss_active && !dc->pstate_ss) {\n\n            /* Singlestep state is Active-pending.\n\n             * If we're in this state at the start of a TB then either\n\n             *  a) we just took an exception to an EL which is being debugged\n\n             *     and this is the first insn in the exception handler\n\n             *  b) debug exceptions were masked and we just unmasked them\n\n             *     without changing EL (eg by clearing PSTATE.D)\n\n             * In either case we're going to take a swstep exception in the\n\n             * \"did not step an insn\" case, and so the syndrome ISV and EX\n\n             * bits should be zero.\n\n             */\n\n            assert(num_insns == 1);\n\n            gen_exception(EXCP_UDEF, syn_swstep(dc->ss_same_el, 0, 0),\n\n                          default_exception_el(dc));\n\n            dc->is_jmp = DISAS_EXC;\n\n            break;\n\n        }\n\n\n\n        disas_a64_insn(env, dc);\n\n\n\n        if (tcg_check_temp_count()) {\n\n            fprintf(stderr, \"TCG temporary leak before \"TARGET_FMT_lx\"\\n\",\n\n                    dc->pc);\n\n        }\n\n\n\n        /* Translation stops when a conditional branch is encountered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefetch aborts occur at the right place.\n\n         */\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             !dc->ss_active &&\n\n             dc->pc < next_page_start &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(cs->singlestep_enabled || dc->ss_active)\n\n        && dc->is_jmp != DISAS_EXC) {\n\n        /* Note that this means single stepping WFI doesn't halt the CPU.\n\n         * For conditional branch insns this is harmless unreachable code as\n\n         * gen_goto_tb() has already handled emitting the debug exception\n\n         * (and thus a tb-jump is not possible when singlestepping).\n\n         */\n\n        assert(dc->is_jmp != DISAS_TB_JUMP);\n\n        if (dc->is_jmp != DISAS_JUMP) {\n\n            gen_a64_set_pc_im(dc->pc);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            gen_exception_internal(EXCP_DEBUG);\n\n        } else {\n\n            gen_step_complete_exception(dc);\n\n        }\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_UPDATE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            /* fall through */\n\n        case DISAS_JUMP:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n        case DISAS_EXC:\n\n        case DISAS_SWI:\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_WFI:\n\n            /* This is a special case because we don't want to just halt the CPU\n\n             * if trying to debug across a WFI.\n\n             */\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         4 | (dc->bswap_code << 1));\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 21267, "substitutes": {"cpu": ["lc", "bc", "fc", "hp", "net", "lb", "uc", "gpu", "conn", "linux", "config", "processor", "process", "pc", "CPU", "node", "device", "cmp", "sys", "nc", "cp", "cache", "mc", "uci", "np", "rc", "c", "ctx", "cn", "frame", "cfg", "roc", "spec", "gp", "cpp", "core", "gc", "auc", "chip", "cca", "boot", "proc", "vm", "hw", "pu"], "tb": ["tsa", "pz", "tsemb", "ptf", "tbl", " tsb", "otbb", "tp", "ptsb", "ttbi", " tbs", "temeb", "tembi", "ta", "tapp", "ttb", "tz", "otbl", "ptbs", "tbase", "ttf", " teb", "tsnb", "Tnb", "otsb", "ttp", "ttapp", "ktb", "tteb", "ptbase", "tememb", "ptb", "ptbi", "ttbs", "Ta", "tf", "Tapp", "ttz", "tbb", " temb", "ktbs", "pk", "otbs", "tbar", "pbs", " tbar", "ktf", " tbb", "otemb", "tang", " tf", "tsbs", "ttang", "tsapp", "tsb", "ptp", "ttnb", " tz", "ptang", " tbi", "ptbb", "ttbl", "ktbi", "tnb", "otbase", "pb", "otb", "tta", "tsbl", "pp", "ttbar", " tbase", "pang", "tbs", "tsbar", " tk", "temb", "ttemb", "tsk", "teb", "tk", "Tb", "tbi", "pf", "ttk"], "cs": ["lc", "bc", "ras", "cc", "wcs", "Cs", "sk", "qs", "conn", "fs", "ks", "css", "ds", "pc", "cas", "CS", "sys", "nc", "cp", "vs", "mc", "cf", "ls", "tc", "sync", "rc", "c", "ctx", "spec", "sc", "ns", "cus", "utils", "ps", "rs", "cms", "bs", "ck", "ec", "acs"], "env": ["exe", "config", "eni", "extra", "eve", "path", "exc", "que", "context", "proc", "conf", "dest", "ev", "txt", "end", "conn", "db", "cv", "eng", "style", "anc", "ef", "dev", "enc", "machine", "rc", "ext", "cb", "spec", "cfg", "equ", "desc", "qt", "scope", "net", "e", "err", "eu", "kernel", "impl", "host", "ea", "cmd", "cf", "uv", "cli", "Environment", "dt", "gui", "loader", "core", "er", "req", "skin", "stage", "dat", "ne", "ec", "enh", "en", "energy", "engine", "args", "cache", "dict", "np", "ctx", "agent", "viron", "session", "console", "vm", "estate", "environment"], "dc1": ["dcone", "ncone", "vc8", "fc1", "fcone", "vc1", "cfone", "dc0", "dc2", "cf1", "mc2", "fc0", "dc8", " dc2", " dc8", "nc1", "nc0", "cf0", "mc8", "mc1", "vc2"], "dc": ["lc", "bc", "col", "fc", "cd", "cc", "uc", "conn", "ct", "config", "acl", "controller", "input", "inc", "db", "cm", "de", "d", "pc", "ds", "device", "ea", "df", "nc", "ac", "ga", "acc", "da", "cmd", "data", "dir", "design", "cf", "mc", "ctrl", "tc", "abc", "mac", "rc", "c", "dr", "cfg", "die", "sc", "dt", "du", "dm", "dk", "gc", "enter", "vc", "desc", "auc", "cdn", "loc", "dl", "fd", "jc", "di", "doc", "dat", "dest", "disc", "dp", "ec", " DC", "DC"], "pc_start": ["pc__size", "page_end", "pc__block", "cp__start", "pageamend", "page_add", "cp_pos", "cp_end", "pc_size", "channel_size", "cp__block", "PC_end", "page_pos", "page_start", "PC_started", "pcampos", "pc67block", "PC_count", "pcamend", "channel_pos", "pc__pos", "pc_end", "cp_start", "pc_started", "channel_start", "PC_start", "pcamadd", "pc__end", "pageamstart", "pc__start", "pc_add", "cp__end", "pc67started", "pc67end", "pageamadd", "pageampos", "pc_block", "pc_count", "pc67pos", "pc67count", "cp_block", "pc67start", "pc67add", "cp__pos", "channel_end", "pcamstart", "pc_pos"], "next_page_start": ["next_page__start", "next_page_stop", "next_page___end", "next_page___start", "next_page2use", "next_page__started", "next_page__end", "next_page2end", "next_page_use", "next_page___started", "next_page_count", "next_page_end", "next_page_started", "next_page___stop", "next_page__stop", "next_page2start", "next_page2count"], "num_insns": ["num_intsn", "num__inccs", "num__inscs", "num_incns", "num__insqs", "num_incn", "num_winns", "num_inccs", "num_gincs", "num_incqs", "num_ginvs", "num_intscs", "num_winn", "num_inn", "num_incs", "num_insvs", "num_insqs", "num_ginn", "num_intsqs", "num__incns", "num_invs", "num_winvs", "num_inns", "num__incqs", "num_insn", "num_inscs", "num_wincs", "num__incn", "num_intsns", "num_ginns", "num__insns", "num__insn", "num_inqs"], "max_insns": ["max_inccs", "max_inns", "max_insnas", "max_incks", " max_\n", "max_this", "max_incs", "max_gescs", "max_gesns", "maxim\n", "max_gesnas", " max_this", "max_gesks", "max_innas", "max_incnas", "max_incns", "max_inscs", "maximthis", "max_\n", "max_insks", "max_inks"]}}
{"project": "FFmpeg", "commit_id": "2ac00d2d1d51047c6ce69d5fbe1a08392d142658", "target": 0, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {\n\n            sc->stsc_data[i].id = 0;\n\n            if (c->fc->error_recognition & AV_EF_EXPLODE) {\n\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 21281, "substitutes": {"c": ["lc", "bc", "fc", "arc", "cc", "uc", "ct", "config", "g", "coll", "com", "cv", "cm", "con", "ca", "pc", "cur", "cl", "f", "cell", "ci", "t", "nc", "ac", "m", "u", "cp", "cache", "p", "cf", "cs", "mc", "xc", "tc", "ctrl", "enc", "cycle", "rc", "ctx", "icc", "ch", "b", "dc", "w", "ic", "cy", "cr", "n", "C", "cus", "co", "v", "ec", "conf", "ce", "l", "cu", "k", "vc"], "pb": ["lc", "bc", "platform", "sb", "fc", "summary", "lb", "uc", "ref", "jp", "lp", "prot", "db", "cv", "pkg", "fb", "pm", "phrase", "bb", "pd", "bp", "pc", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "PB", "tp", "pp", "p", "tc", "np", "wb", "bps", "py", "rc", "cb", "ctx", "pl", "pro", "wp", "mp", "b", "ub", "cpp", "hub", "bm", "ab", "bf", "bh", "bot", "rb", "typ", "xb", "dp", "ppa", "pa"], "atom": ["bc", " am", " parent", "com", "cm", "orb", " acc", " arr", "mom", " orb", " mom", " Atom", " slab", " app", "abc", " plat", "am", " ac", " ab", " program", " form", " com", " ap", " ax", " subp", " atoms", " om", " adm"], "st": ["lc", "bc", "SC", "sb", "str", "uc", "sci", "ct", "sl", "std", "ost", "cv", "St", "pc", "cl", "sth", "t", "r", "s", "p", "sync", "sa", "fe", "sd", "ste", "sts", "ch", "se", "cr", "sw", "inst", "src", "osc", "ST", "sec", "sp", "sn", "pt", "sta", "ss", "ft"], "sc": ["bc", "fc", "cam", "esc", "ct", "config", "asc", "Sc", "pc", "acc", "cs", "go", "src", "cus", "osc", "ss", "sb", "sche", "cv", "anc", "cont", "isc", "pg", "enc", "cer", "rc", "spec", "dc", "soc", "desc", "scope", "capt", "lc", "cc", "uc", "crit", "exec", "cf", "tc", "cli", "sd", "icc", "sub", "ced", "core", "sw", "loc", "cca", "co", "sec", "ec", "sq", "SC", "sci", "inc", "ca", "cur", "cl", "nc", "ga", "cache", "mc", "ctrl", "sync", "sa", "client", "ctx", "match", "ch", "cr", "usc", "sp", "contract"], "i": ["eni", "mini", "ti", "y", "info", "r", "ini", "data", "j", "ip", "field", "mu", "n", "iu", "slice", "di", "v", "l", "fi", "type", "ix", "qi", "ri", "iv", "g", "gi", "d", "I", "ci", "u", "s", "abi", "code", "o", "mi", "ji", "xi", "multi", "li", "ie", "pi", "k", "ni", "e", "ui", "f", "t", "phi", "it", "init", "p", "bi", "cli", "si", "b", "z", "h", "x", "zi", "count", "limit", "start", "uri", "esi", "oi", "entry", "m", "id", "inner", "index", "ii", "in", "ai", "ei", "hi", "ski"], "entries": ["entrows", "ENTresses", "entrs", "distrys", "ENTry", "extries", "gentrys", "genturies", "ntures", "Entrys", "entrys", "entrations", "gentried", "ntry", "gentencies", "entues", "gentorts", "ntrations", "distresses", "ENTrs", "gentents", "ENTries", "attrys", "entrics", "Entries", "centries", "atturies", "etrics", "extures", "attents", "ntrics", "entents", "estried", "ntrys", "attries", "entresses", "enturies", "centures", "Entresses", "entsorts", "gentures", "ntents", "Entrs", "etries", "ENTrows", "extencies", "entures", "ientries", "nturies", "centry", "ientues", "ENTues", "gentry", "distries", "estrations", "ientry", "distrs", "extorts", "ntried", "entsures", "entsries", "estries", "ENTrys", "centrys", "etrys", "etures", "centrics", "ntries", "ientrys", "entorts", "entry", "ntrows", "gentries", "gentrations", "entencies", "entried", "gentrows", "estry", "centues", "entsencies"]}}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n", "idx": 21284, "substitutes": {"frame": ["target", "iframe", "ref", "config", "scene", "force", "file", "host", "f", "buffer", "fake", " Frame", "zip", "cycle", "code", "live", "cb", "fr", "frames", "source", "family", "window", "rame", "line", "channel", "slice", "flow", "Frame", "range", "fram", "image", "block", "base", "type"], "height": ["row", "shape", "end", "windows", "rows", "driver", "container", "style", "ops", "pad", "build", "img", "Height", "y", "dir", "size", "head", "hd", "ip", "hang", "work", "rh", "depth", "crop", "ows", "images", "pull", "window", "direction", "w", "stroke", "length", "fw", "gh", "upper", "resolution", "h", "bottom", "max", "padding"], "src": ["sb", "target", "start", "sel", "send", "ref", "scene", "sl", "scale", "origin", "ctr", "img", "buffer", "split", "dist", "gb", "rob", "head", "ssl", "inf", "sync", "crop", "buf", "rc", "filename", "cb", "ctx", "source", "low", "comp", "ptr", "core", "channel", "desc", "inst", "slice", "rss", "loc", "len", "length", "rs", "lib", "dest", "rb", "stream", "rib", "image", "offset", "attr", "url"], "src_end": ["source_id", "src_start", "source_end", "src_id", " src_id", " src_start", "source_start"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n", "idx": 21296, "substitutes": {"n": ["i", "name", "net", "e", "un", "en", "conn", "yn", "config", "nn", "g", "d", "node", "f", "dn", "t", "y", "N", "nc", "m", "s", "u", "r", "j", "p", "na", "o", "np", "client", "c", "network", "self", "cn", "num", "b", "w", "nb", "v", "z", "nt", "fn", "sn", "nu", "l", "x", "ne", "mn", "nm", "k"], "cmd": ["md", "request", "grad", "cd", "cc", "def", "conn", "bind", "obj", "config", "input", "pkg", "ctr", "cookie", "mode", "ack", "d", "qq", "node", "cl", "cmp", "op", "Cmd", "msg", "cp", "m", "init", "head", "args", "dr", "cf", "id", "ctrl", "code", "q", "cli", "mac", "client", "c", "ctx", "cb", "gen", "num", "cfg", "dom", "module", "xml", "cn", "dc", "w", "cr", "comm", "qt", "nt", "ck", "cod", "h", "resp", "command", "prop", "vc"], "req": ["md", "str", "request", "reg", "ru", "row", "grad", "def", "response", "ref", "err", "progress", "ctr", "rx", "crit", "rec", "rr", " request", "qq", "cur", "rf", "required", "get", "cook", "r", "ok", "res", "cache", "method", "ret", "q", "rw", "client", "cb", "require", "ctx", "pro", "rt", "pull", "w", "seq", "cr", "call", "gr", "proc", "http", "conf", "ry", "user", "orig", "rb", "resp", "requ"], "ns": ["nets", "net", "syn", "outs", "nav", "qs", "sk", "conn", "fs", "coll", "xs", "lines", "nas", "ks", "ds", "names", "sys", "nc", "s", "os", "ys", "vs", "cs", "na", "mc", "ls", "sync", "ains", "c", "ctx", "xml", "cn", "si", "sts", "nw", "w", "ms", "ims", "Ns", "ps", "gs", "ne", "nt", "bs", "sn", "sp", "ips", "NS", "ss", "nos"]}}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n", "idx": 21302, "substitutes": {"link": ["lc", "like", "name", "cross", "e", "key", "connection", "message", "file", "style", "parse", "hip", "plugin", "local", "f", "model", "info", "dd", "bug", "lock", "play", "list", "id", "ace", "sync", "load", "comment", "ink", "hack", "plug", "Link", "friend", "tag", "filter", "mail", "module", "source", "check", "match", "pull", "linked", "a", "line", "service", "install", "call", "child", "loc", "feed", "di", "parent", "lib", "http", "user", "li", "group", "lang", "ck", "image", "block", "pack", "l", "base", "links", "action", "url", "type"], "i": ["io", "ami", "name", "e", "ix", "fi", "qi", "ri", "ui", "pi", "key", "gi", "d", "uri", "chi", "ti", "I", "f", "ci", "y", "info", "phi", "m", "ini", "oi", "j", "u", "ip", "p", "abi", "o", "bi", "wei", "mi", "mu", "index", "si", "ii", "b", "ji", "iu", "ai", "xi", "base", "hi", "di", "multi", "v", "yi", "li", "l", "x", "zi", "ni", "type"], "picref": ["picdef", "docref", " picdef", "docreference", "picRef", "Picdef", "picreference", "nicreference", "pcdef", "icrel", "pictrel", "nicRef", "pcreference", "pcrel", " picblock", "pinreference", "pinref", "icRef", "icreference", "pcref", "pictRef", "pinflow", "picrel", "pictref", "Picrel", "PicRef", "pcRef", "nicref", " picRef", "docrel", "nicrel", "pcflow", "docflow", "Picref", "pictreference", "Picblock", "pinblock", " picreference", "picblock", "picflow", "Picreference", "pinrel", "icref", "pinRef"]}}
{"project": "qemu", "commit_id": "375cb560295484b88898262ebf400eff9a011206", "target": 0, "func": "static uint64_t pl110_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl110_state *s = (pl110_state *)opaque;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return idregs[s->version][(offset - 0xfe0) >> 2];\n\n    }\n\n    if (offset >= 0x200 && offset < 0x400) {\n\n        return s->raw_palette[(offset - 0x200) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* LCDTiming0 */\n\n        return s->timing[0];\n\n    case 1: /* LCDTiming1 */\n\n        return s->timing[1];\n\n    case 2: /* LCDTiming2 */\n\n        return s->timing[2];\n\n    case 3: /* LCDTiming3 */\n\n        return s->timing[3];\n\n    case 4: /* LCDUPBASE */\n\n        return s->upbase;\n\n    case 5: /* LCDLPBASE */\n\n        return s->lpbase;\n\n    case 6: /* LCDIMSC */\n\n        if (s->version != PL110) {\n\n            return s->cr;\n\n        }\n\n        return s->int_mask;\n\n    case 7: /* LCDControl */\n\n        if (s->version != PL110) {\n\n            return s->int_mask;\n\n        }\n\n        return s->cr;\n\n    case 8: /* LCDRIS */\n\n        return s->int_status;\n\n    case 9: /* LCDMIS */\n\n        return s->int_status & s->int_mask;\n\n    case 11: /* LCDUPCURR */\n\n        /* TODO: Implement vertical refresh.  */\n\n        return s->upbase;\n\n    case 12: /* LCDLPCURR */\n\n        return s->lpbase;\n\n    default:\n\n        hw_error(\"pl110_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 21306, "substitutes": {"opaque": ["opusbuffer", "operacity", "operaque", "ospque", "opusacity", "operae", "opusaque", "opusula", "operbuffer", "ospa", "operula", "operque", "opbuffer", "opacity", "opae", " opula", " opque", "opula", " opacity", "opque", "ospae", " opbuffer", "ospaque", "opa", "opera", " opa", " opae"], "offset": ["route", "row", "i", "phase", "limit", "start", "attribute", "notation", "object", "off", "next", "part", "layout", "origin", "oa", "bytes", "style", "usage", "align", "outer", "pos", "optional", "address", "entry", "data", "seed", "fee", "p", "number", "url", "slot", "addr", "operation", "o", "prefix", "timeout", "shift", "id", "sync", "index", "et", "oid", "ptr", "set", "office", "location", "online", "alias", "always", "Offset", "length", "error", "len", "loc", "page", "skip", "reset", "range", "pointer", "image", "position", "offer", "base", "api", "server", "padding"], "size": [" error", "start", " bytes", "scale", "sized", "Size", "bytes", "ize", "address", "fee", "data", "izes", "timeout", " data", " address", "set", "length", " length", " sizes", "len", "from", "SIZE", "count"], "s": ["ions", "i", "es", "ed", "ds", "sys", "y", "ssl", "os", "ts", "cs", "js", "aws", "S", "ns", "ients", "rs", "ins", "ures", "conf", "erences", "ing", "l", "ips", "ss", "itions", "ands", "sb", "outs", "rows", "g", "ses", "d", "sets", "irs", "site", "services", "eds", "o", "ports", "ments", "c", "ances", "self", "spec", "sg", "a", "has", " settings", "sf", "changes", "ers", "ies", "times", "ors", "e", "sym", "fs", "lines", " errors", "ings", "ations", "f", "t", "new", "p", "or", "ows", " results", "si", "b", "service", "ists", "er", "words", "ps", "gs", "alls", "ries", "h", "secondary", "sq", "sl", " values", "als", "ops", "results", "socket", "its", "ls", "sync", "is", "session", "comments", "south", "server", "resses", "states", "ees"]}}
{"project": "FFmpeg", "commit_id": "eb38d8fe926bdce8110fa4be4fddf6598a079a20", "target": 0, "func": "static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,\n\n                sb_int8_array coding_method, int nb_channels,\n\n                int c, int superblocktype_2_3, int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    // This should never happen\n\n    if (nb_channels <= 0)\n\n        return;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 21311, "substitutes": {"tone_level_idx": ["tone_level_Idxs", "tone_level_namexc", "tone_level_idsv", "tone_level_idsxes", "tone_level_idsx", "tone_level_itxs", "tone_level_IdX", "tone_level_idxes", "tone_level_infoz", "tone_level_counts", "tone_level_infoxs", "tone_level_endy", "tone_level_endx", "tone_level_Idx", "tone_level_inz", "tone_level_itx", "tone_level_idsxc", "tone_level_namex", "tone_level_onexes", "tone_level_idsz", "tone_level_onexc", "tone_level_endz", "tone_level_idw", "tone_level_its", "tone_level_inx", "tone_level_onez", "tone_level_infox", "tone_level_inxx", "tone_level_countx", "tone_level_idy", "tone_level_itw", "tone_level_idv", "tone_level_Idy", "tone_level_infoxx", "tone_level_Idz", "tone_level_idxx", "tone_level_endxs", "tone_level_infoX", "tone_level_namev", "tone_level_onex", "tone_level_idz", "tone_level_countw", "tone_level_countxs", "tone_level_inxs", "tone_level_idX", "tone_level_idxs", "tone_level_idxc", "tone_level_namez", "tone_level_ids"], "tone_level_idx_temp": ["tone_level_idz_Temp", "tone_level_idz_method", "tone_level_idx_source", "tone_level_idf_temp", "tone_level_idf_clean", "tone_level_idx_clean", "tone_level_idz_tmp", "tone_level_idz_temp", "tone_level_idx_buffer", "tone_level_idg_default", "tone_level_idx_current", "tone_level_idg_level", "tone_level_idg_temp", "tone_level_idx_cache", "tone_level_idx_Temp", "tone_level_idx_tmp", "tone_level_idx_default", "tone_level_idf_current", "tone_level_idx_method", "tone_level_idx_level", "tone_level_idf_cache", "tone_level_idg_source", "tone_level_idz_buffer"], "coding_method": ["coding2temp", "coder_function", "coding2type", "coder_method", "coder_type", "coding2function", "coding_function", "coding_type", "coding_temp", "coder_temp", "coding2method"], "nb_channels": ["nb_chanunks", "nbofchanchannel", "nb_hchannel", "nb_compairs", "nb__channels", "nb_colchannel", "nb__chairs", "nb__compannels", "nb_hars", "nb_colunks", "nb_bars", "nb_compannels", "nb_chears", "nbofchchannel", "nb_cheairs", "nbofchunks", "nb_chars", "nb_colords", "nbofchannels", "nb__chords", "nb_bbands", "nb_compords", "nb_chunks", "nb_cbands", "nb__compars", "nbofchords", "nb_chanchannel", "nb_cars", "nb__compords", "nb_hannels", "nbofchanannels", "nb_hbands", "nb_chchannel", "nb_cannels", "nb_chanords", "nb_bannels", "nb_vunks", "nb_vannels", "nb_chords", "nbofchanunks", "nb_cheords", "nb_hairs", "nb__chars", "nb_chanannels", "nb_bchannel", "nb_compars", "nb_colannels", "nb_vords", "nb__compairs", "nb_chairs", "nb_chbands", "nb_vchannel", "nb_cchannel", "nb_cheannels", "nbofchanords", "nb_hords"], "c": ["conv", "lc", "cc", "e", "ct", "con", "cl", "f", "ci", "cmp", "ac", "nc", "m", "cp", "cache", "p", "mc", "xc", "enc", "cb", "b", "dc", "w", "cpp", "n", "C", "cod", "count"], "superblocktype_2_3": ["superblocktype_1_7", "superblocktype_1_3", "superblocktype_2_three", "superblocktype_1_three", "superblocktype_2_03", "superblocktype_2A53", "superblocktype_2_53", "superblocktype_2_7", "superblocktype_1_53", "superblocktype_1_03", "superblocktype_2A03", "superblocktype_2Athree", "superblocktype_2A3"], "cm_table_select": ["cm_table_list", "cm_interface_use", "cm_interface_list", "cm_table_use", "cm_table_seq", "cm_table1seq", "cm_interface_seq", "cm_interface_select", "cm_table1use", "cm_table1list", "cm_table1select"], "ch": ["i", "chn", "app", "ct", "cm", "Ch", "che", "eff", "cell", "cp", "qu", "CH", "chart", "fr", "cpp", "gh", "v", "conf", " cs", "cha", "col", "conn", "cor", "g", "ich", "bb", "cel", "ci", "s", "code", "q", "rc", "cb", "channel", "bh", "ce", "ph", "k", "vc", "lc", "com", "uch", "chi", "f", "cmp", "cht", "p", "cf", "number", "cho", "b", "cy", "zh", "loc", "co", "th", "buff", "hw", "h", "ht", "count", "sch", "cd", "och", "sk", "ach", "chan", "_", "cl", "ky", "ctx", "sh", "session", "chu", "cher", "all"], "sb": ["bc", "sv", "i", "mb", "bp", "bg", "sit", "kb", "java", "wb", "dy", "ib", "dl", "n", "src", "ff", "bm", "nb", "rb", "ss", "conn", "jp", "g", "db", "bb", "cel", "sth", "split", "s", "sy", "SB", "sg", "cb", "sm", "sc", "ann", "sf", "yi", "bh", "bj", "lc", "syn", "lb", "sel", "sie", "usb", "nn", "shop", "fb", "eb", "obb", "sd", "num", "si", "b", "sub", "length", "sup", "zh", "ll", "jc", "bf", "cod", "stab", "sq", "abb", "gb", "pb", "sk", "sci", "sl", "btn", "bl", "lr", "jj", "ctrl", "sync", "sa", "cn", "sh", "bs", "sn", "sp"], "j": ["ja", "je", "i", "jit", "jl", "ie", "obj", "jp", "ind", "adj", "g", "jen", "jam", "f", "pos", "jj", "ju", "uj", "y", "r", "u", "m", "kj", "it", "dj", "jet", "p", "job", "jon", "o", "q", "aj", "pr", "el", "fr", "si", "J", "b", "x", "ji", "ij", "n", "er", "br", "jc", "v", "z", "jan", "sp", "sn", "li", "note", "jo", "pt", "l", "bj", "k", "pa"], "tmp": ["output", "txt", "area", "obj", "app", "jp", "config", "amp", "vt", "adj", "yy", "xxx", "extra", "fb", "bb", "tt", "temp", "pad", "img", "emp", "cmp", "jj", "fake", "pre", "cp", "cache", "seed", "tp", "zip", "p", "tem", "diff", "prefix", "tc", "Temp", "np", "elt", "buf", "rc", "kk", "cb", "ctx", "mm", "beta", "mp", "xxxx", "ptr", "stuff", "ff", "vv", "src", "sup", "pot", "test", "nb", "wx", "bf", "proc", "alpha", "v", "sp", "rb", "offset", "api", "resp", "attr"], "acc": ["cc", "app", "circ", "ind", "config", "amp", "adj", "input", "cond", "rec", "img", "eff", "emp", "cont", "cmp", "op", "ac", "ad", "cache", "seed", "abc", "add", "ai", "test", "aa", "alpha", "att", "attr"], "esp_40": ["esp_buffer", "asm_len", "asm_40", "asm_layer", "asm_buffer", "esp_layer", "esp_len"], "comp": ["omp", "circ", "config", "amp", "com", "ctr", "cond", "bb", "rec", "cur", "cmp", "pos", "op", "cp", "cache", "component", "frac", "mod", "code", "seq", "loc", "comb", "co", "proc", "lib", "conf", "quad"], "add1": ["ad2", " add16", "addOne", "load2", "add8", "added2", "ad16", "AddOne", " add7", "load1", "load99", "add16", "dd4", " add99", "Add1", "dd2", "ad8", "Add7", "added8", "added3", "add99", "dd1", "ad4", "added16", "Add2", "add7", "added4", "Add4", "added1", "Add3", " addOne", "ad1", "dd99", "adOne", "added7", " add8"], "add2": ["ad2", " add14", "inc92", "add8", "address92", "added2", " addsecond", "add62", "inc4", "add82", "added62", " add56", "addedsecond", "addedTwo", "sendsecond", "add14", "call82", "Add1", "address4", " add82", "added8", "send4", "add92", "ad4", "added22", "call4", "apply4", "Add2", "call2", "added4", "send2", "inc14", "addsecond", "Add4", "add56", "apply2", "inc2", "inc56", "address82", "apply62", " addTwo", "sendTwo", "call92", " add92", "add22", " add22", "addTwo", " add62", "address2", "inc1", "address56", "apply8", " add8", "ad22", "Add14"], "add3": ["extra83", "add236", "dd3", "add43", "join44", "inc13", "plus15", "inc39", "dd4", "plus3", "addThree", "added4", "extra15", "applythree", "inc3", "inc83", "addIII", "added13", "added43", "app236", "inc15", "incThree", "applyThree", "app39", "add83", "add44", "dd1", "push123", "ad3", "plus83", "do6", "join236", " addthree", "extraThree", "add39", "inc236", "add6", "add123", "addthree", "pushIII", "Addthree", "inc44", "do123", "plusThree", "doIII", "added3", "extra1", "push3", "apply03", "ddthree", " add13", "Add3", "call3", "Add03", "ad1", "call123", "extrathree", "add03", "call6", "inc4", " add03", " add43", "adthree", "app3", " addThree", "push6", "extra3", "inc43", "join39", "AddThree", "ad4", "extra4", "do3", "join3", "callIII", "app44", "add15", "apply3", "add13"], "add4": [" add94", "ad2", "inc24", "address47", " add6", "adfour", "added2", " add47", "inc44", "add5", "addedfour", "inc4", "inc22", "add24", "append4", "added44", "address4", " add24", "Add6", "readfour", "inc47", "append22", "add44", "ad4", "read4", "apply94", "inc5", "addfour", "Add2", "apply4", "added4", "append2", "append94", "add47", "Add4", "inc64", "Addfour", "added6", "inc2", " addfour", "apply2", "address22", "added5", "add64", "add22", "apply22", " add5", "read2", " add64", " add22", "Add64", "inc6", " add44", "address2", "add6", "added24", "add94"], "multres": ["emptre", "addreed", "ractres", "ractreed", "addrice", "emptrice", "addres", "ractrice", "ractre", "requreed", "requrice", "requre", "emptres", "requres", "emptreed", "addre"]}}
{"project": "qemu", "commit_id": "1e577cc7cffd3de14dbd321de5c3ef191c6ab07f", "target": 0, "func": "void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                        int flags)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    int i;\n\n\n\n    if (is_a64(env)) {\n\n        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);\n\n        return;\n\n    }\n\n\n\n    for(i=0;i<16;i++) {\n\n        cpu_fprintf(f, \"R%02d=%08x\", i, env->regs[i]);\n\n        if ((i % 4) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n        else\n\n            cpu_fprintf(f, \" \");\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t xpsr = xpsr_read(env);\n\n        const char *mode;\n\n\n\n        if (xpsr & XPSR_EXCP) {\n\n            mode = \"handler\";\n\n        } else {\n\n            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {\n\n                mode = \"unpriv-thread\";\n\n            } else {\n\n                mode = \"priv-thread\";\n\n            }\n\n        }\n\n\n\n        cpu_fprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\",\n\n                    xpsr,\n\n                    xpsr & XPSR_N ? 'N' : '-',\n\n                    xpsr & XPSR_Z ? 'Z' : '-',\n\n                    xpsr & XPSR_C ? 'C' : '-',\n\n                    xpsr & XPSR_V ? 'V' : '-',\n\n                    xpsr & XPSR_T ? 'T' : 'A',\n\n                    mode);\n\n    } else {\n\n        uint32_t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n", "idx": 21324, "substitutes": {"cs": ["lc", "cc", "ix", "wcs", "Cs", "sk", "qs", "conn", "fs", "cons", "ses", "ca", "ks", "css", "pc", "ds", "cas", "CS", "ci", "sys", "nc", "s", "args", "cache", "ys", "vs", "cf", "ace", "ls", "sync", "rc", "c", "ctx", "spec", "si", "sc", "ics", "ns", "ps", "rs", "gs", "bs", "ec", "acs"], "f": ["fa", "of", "fc", "e", "fs", "g", "fb", "file", "d", "framework", "func", "rf", "fp", "function", "df", "exec", "r", "m", "s", "j", "xf", "p", "fx", "cf", "o", "af", "filename", "c", "cb", "fe", "fr", "tf", "form", "b", "w", "fm", "ff", "fd", "F", "fw", "sf", "feed", "buff", "fen", "v", "bf", "fn", "lf", "h", "files", "l", "fi", "fo", "fun"], "cpu_fprintf": ["cpu_efformat", "cpu_lfmt", "cpu_rfprintf", "cpu_rfmt", "cpu_efprint", "cpu_fmt", "cpu_cprintf", "cpu_bmt", "cpu_bprint", "cpu_efdump", "cpu_Fprintf", "cpu_Fprintln", "cpu_efprintf", "cpu_sfprint", "cpu_frint", "cpu_cprintln", "cpu_lfprintln", "cpu_bappend", "cpu_fxprint", "cpu_cfprintln", "cpu_fdump", "cpu_bdump", "cpu_rfrite", "cpu_fxlt", "cpu_flt", "cpu_lfrint", "cpu_sflt", "cpu_bprintf", "cpu_fprint", "cpu_Frite", "cpu_Fformat", "cpu_fxrite", "cpu_dmt", "cpu_sfprintf", "cpu_fappend", "cpu_fformat", "cpu_rfprint", "cpu_rfformat", "cpu_bformat", "cpu_cfformat", "cpu_dprint", "cpu_fprintln", "cpu_cdump", "cpu_frite", "cpu_cmt", "cpu_cformat", "cpu_rfdump", "cpu_dappend", "cpu_cfprintf", "cpu_fxprintln", "cpu_cprint", "cpu_cfmt", "cpu_fxprintf", "cpu_fxformat", "cpu_bprintln", "cpu_lfprintf", "cpu_rfprintln", "cpu_dprintf", "cpu_brint"], "flags": ["items", "includes", "ags", "ints", "fs", "features", "func", "ffff", "ops", "plugins", "fish", "nl", "fps", "fee", "faces", "ils", "vals", "stats", "ants", "Flags", "settings", "lag", "reads", "forces", "bits", "flag", "FLAG", "fd", "details", " Flags", "fields", "sf", "utils", "alls", "acks", "lf", "files", "ips", "fi", "fun"], "cpu": ["lc", "bc", "platform", "computer", "fc", "bench", "gpu", "conn", "cv", "cm", " cp", "processor", "pc", "CPU", "anc", "nc", "cp", "cache", "cf", "mc", "uno", "uci", "np", "cli", "c", "ctx", "cn", "roc", "cal", "uca", "loader", "python", "core", "n", "utils", "proc", "vm", "clock", "fi", "pu"], "env": ["bc", "exe", "config", "eni", "exc", "que", "context", "iss", "osc", "proc", "v", "conf", "ev", "fi", "conn", "db", "cv", "oa", "eng", "style", "site", "anc", "state", "lock", "enc", "assets", "code", "ext", "c", "spec", "et", "cfg", "equ", "esm", "ass", "desc", "em", "sf", "fen", "qt", "ce", "scope", "net", "e", "forge", "err", "eu", "esp", "ea", "exec", "cli", "Environment", "el", "si", "enable", "dt", "gui", "loader", "intern", "core", "inst", "er", "skin", "stage", "param", "ne", "ec", "enh", "en", "shell", "energy", "engine", "nc", "args", "cache", "vs", "np", "kn", "settings", "cal", "viron", "console", "vm", "server", "environment"], "i": ["io", "col", "uli", "ix", "e", "start", "fi", "qi", "name", "ind", "ri", "ui", "eni", "key", "gi", "d", "uri", "ti", "I", "l", "ci", "t", "u", "oi", "m", "phi", "it", "j", "ip", "abi", "p", "id", "o", "bi", "wei", "c", "mu", "index", "si", "ii", "b", "in", "counter", "min", "n", "child", "iu", "slice", "ai", "xi", "hi", "di", "multi", "v", "li", "pi", "x", "zi", "k", "ni", "count"], "mode": ["status", "route", "md", "member", "view", "name", "phase", "kind", "password", "language", "option", "scale", "driver", "lane", "project", "key", "shell", "time", "phrase", "style", "plugin", "access", "device", "no", "model", "track", "slave", "disable", "MODE", "m", "bit", "size", "program", "state", "version", "ace", "mod", "code", "mm", "id", "mac", "normal", "strip", "mission", "day", "module", "tag", "dim", "direction", "role", "line", "date", "mask", "maybe", "stage", "range", "chrom", "ward", "scope", "Mode", "command", "theme", "type"], "ns_status": ["ns__level", "ns__status", "ns_magic", "css_num", "ns_score", "net_status", "css_magic", "ns__num", "ns_level", "net_level", "ns__score", "ns_num", "css_status", "net_score", "ns__magic"]}}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n    int ret = 0;\n\n\n\n    trace_vmstate_load_state(vmsd->name, version_id);\n\n    if (version_id > vmsd->version_id) {\n\n        error_report(\"%s: incoming version_id %d is too new \"\n\n                     \"for local version_id %d\",\n\n                     vmsd->name, version_id, vmsd->version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        if (vmsd->load_state_old &&\n\n            version_id >= vmsd->minimum_version_id_old) {\n\n            ret = vmsd->load_state_old(f, opaque, version_id);\n\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n\n            return ret;\n\n        }\n\n        error_report(\"%s: incoming version_id %d is too old \"\n\n                     \"for local minimum version_id  %d\",\n\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if (vmsd->pre_load) {\n\n        int ret = vmsd->pre_load(opaque);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n    while (field->name) {\n\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n\n        if ((field->field_exists &&\n\n             field->field_exists(opaque, version_id)) ||\n\n            (!field->field_exists &&\n\n             field->version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n", "idx": 21335, "substitutes": {"f": ["fa", "e", "fac", "fs", "g", "fb", "file", "fp", "df", "exec", "t", "info", "m", "xf", "p", "inf", "fx", "o", "af", "c", "fr", "tf", "form", "b", "fed", "fd", "F", "sf", "feed", "buff", "fen", "v", "proc", "fn", "lf", "h", "files", "arf", "l", "fo", "elf"], "vmsd": ["vmsl", "fmsz", "vrsde", "vssd", "vmssd", "tvmsds", "vansdt", "vmsad", " vmsdl", "vvsdd", "svmsds", "vmmsdk", "svvsd", "vmsdy", "lmesdat", "vssl", " vbsdl", "vorsad", "svmsD", "vcsz", "svvsdy", "ventsdl", "vdscd", "tvmsdd", "vdsconfig", "varsid", "vmentsdk", "varmsdk", "vasd", "vmesd", "ventsbd", "attmsd", " vmsid", "vmsD", "svmsd", "vapsdt", "vsdl", "vorscd", "gudsd", " vansdl", "svvsds", "varsdr", "fmesds", "hmsds", "vcsde", "vmesmd", "vmsdal", "varmssd", "vimsdl", "gudsdat", " ventsd", "vmesl", "vapsd", "vatsdat", "vdsdl", "vmasmd", "hmsl", "vwsdie", "vrsds", "vvsbd", "fmesd", "vmasd", "varmsbd", "varsdad", "promorsad", "ventsdal", "lmesd", "gumsd", "valsdl", "varsd", "varsdl", "memsb", "vapsds", "vansdad", "vemsd", "vmsdr", "vssds", "fmsd", "vvsdk", " vmsds", "vmsb", "vmsdata", "prommscd", "vmsgd", " vumsdat", "vemsb", "vMSds", "ventscd", "vbsdata", "vwsds", "vdsde", "vamesds", "promorsdd", "lmsdt", " vmsdad", "tvidsdd", "mmsdd", "vssdt", "vrsd", " vmsda", "lmsd", "fcsd", "vwsdat", "vmasds", " vimsdt", "vmesD", "vmsdd", "tvmsconfig", " vmssd", "vimsds", "fmsdl", "vansid", "ventsd", "vmwsds", "vmmsd", "prommsd", "vidsd", "vansdr", "vvsdal", "vmsconfig", "attimsbd", "vvsad", "hmesd", "vmsbd", "vumsdt", "gudsdl", "vmsid", "vmsu", "mmsd", "vmasdal", "vMSl", "memsd", " vimsda", "vdsad", "vmesdy", "vmentsd", "vacsdl", "vmmdad", "vasdd", "fmsds", "vmmsds", " vansid", " vmsdata", " vmsdr", "vmmsdie", " vansd", "lmesdt", "vmsdad", " vbsgd", "vcsd", "hmesds", "vumsd", "vmmdd", "vdsz", "vatsd", "hmesD", "fmsp", "vvsds", "varmsd", " vumsdr", "vmwsd", "vmasdat", "vimsd", "vmesds", "vcsds", "vmmb", "vwsd", "ventssd", "svvsD", "vmsdat", " vmsdt", " vimsd", "gudsdal", "prommsdd", "vatsbd", "fcsz", "hmsD", "lmsdat", "vssda", "fmesp", "vumsdat", "vimsdt", "vumsdr", "vmwsdat", "prommsad", "fcsds", "vimsbd", "vmasda", "lmsmd", "vsp", " vmsdat", "hmsd", "vmasdl", "gumsdl", "vamesd", "vMSconfig", "vmwsdie", " vmsgd", "vbsdl", "promorsd", "tvidsd", "vmesdt", "vansdl", "vorsdd", "memsdad", "vatsdal", "vmsda", "memsdd", " ventssd", "vidsdd", "vmsdt", "vemsdad", "vmmsdat", "vmsds", "vidsconfig", "vatsu", " vansdad", "fmsde", "vmasdt", "varmsdal", "vorsd", " vmsdal", "vssD", "vdsgd", "lmsds", "vansdat", "vmentsbd", "valsid", "vmsz", "vmesp", "vidsds", "fcsde", "tvmsd", "vssdy", "vmmscd", "vvscd", "hmesl", "vmsmd", "vmentscd", "vmsdl", "vanssd", "vimsu", "vmsp", "vvsD", "vvsu", "vmesdie", "vimsp", "vsds", "gumsdal", "ventsdat", "vvsd", "vmmsbd", "vMSdd", "vansd", "svmsdy", "vrsz", "attimsu", "fmesdl", "vbsgd", "attmsdal", "mmsb", "vdsdd", " vimsds", " vumsdt", "gumsdat", "vdsdal", "attimsd", "vMSd", "vmscd", "vdsds", "lmesmd", "ventsdk", "varmscd", "vasb", " vbsd", "vamesdie", "vmesdl", "vmmd", "vdsdata", "ventsdata", "vmsde", "vapsdat", "vamesdat", " vumsd", "vmsdk", "vemsdd", "lmesds", "vansdal", "mmsdad", "vbsd", "vsd", "valsdad", "vacsdat", "vvsdy", "vacsd", "vMSD", "vimsdat", "varmsdat", "vasdad", " vbsdata", "vmesdat", "attmsu", "attimsdal", "tvidsconfig", "varsdat", "ventsgd", "tvidsds", " ventsdal", "vimsdal", "attmsbd", "valsd", "vatsmd", "vatsds", "vdsdat", " ventsdat", "vdsd", "promorscd", "varsdt", "vacsdal", "vmsdie", "vimsda"], "opaque": ["openaque", "operacity", "ospula", "opaques", "operaque", "ospacity", "hopity", "octque", "octaque", "Opque", "opatile", " opaco", "ipaques", "openacity", "ipaque", "opaco", " opac", "octacity", " opity", " opaques", "compaque", "ipaco", "compula", " opatile", "obaques", "Opacity", "ipac", "openatile", "operula", "operity", "obque", "ospaques", "operque", "hopaque", "obaque", "ipque", "opacity", " opque", "opula", " opacity", "opac", "openaques", "Opaque", "obacity", "opque", "Opaques", "operatile", "ospaque", "compaques", "operaco", "hopacity", "octity", "operac", "opity", "compacity", "operaques", "ipacity", "hopaques"], "version_id": ["version64ident", "version9number", "position_name", "version9id", "version_ID", "ver_name", "field_key", "vision_id", "version_ide", "versionername", "version8uri", "versionCname", "versionCkey", "version8i", "version_vid", " versionCkey", "versioningvid", "version_Id", "versionalids", "versionIdpath", "version64desc", "versionalid", "version64id", "generation_vid", "version33name", "version_day", "field_name", "generationaldepth", "feature_depth", "version_head", "version64ids", "vision_path", "versioningname", "version_type", " version_name", "version_start", "package_start", "version_part", "versioningdepth", "versionalnumber", " versionCids", "generationalid", " versionCid", "versionalvid", "versionCid", "field_id", " version_ids", "versioningid", " version_ID", "version_uri", "generationalname", "versionIdId", "generation_depth", "version_ids", "ver_number", " version_it", "version_desc", "vision_Id", "ver_id", "vision_day", "version9ide", " version_part", " version_sid", "generationalvid", "version_it", "ver_ide", "generation_name", "version_depth", "versionalide", "feature_ids", " version_uri", "version_number", "position_ide", "version_ad", "versionIdid", "version8part", "version64name", "field_desc", "version64ID", "versionIdday", "feature_head", " version_i", "version_key", "version64it", "version64key", "versionerdesc", "versioninghead", "package_name", "versionerkey", "version64Id", "versionalname", "feature_id", " version_Id", "versioningids", "version_i", "versionaldepth", "package_id", "position_ids", "position_id", "version_sid", "version33id", " version_ident", "version_path", "generation_id", " versionCname", "version8id", "version_ident", "version33sid", "versionerid", "version9name", "version33ids", "package_type", "version_name", " version_key", "versionCids", " version_ad", "versionalhead"], "field": ["lc", "package", "after", "holder", "attribute", "end", "object", "event", "option", "input", "post", "force", "message", "key", "player", "queue", "file", "feature", "handler", "style", "plugin", "node", "Field", "layer", "cell", "function", "FIELD", "term", "m", "box", "data", "cache", "um", "man", "lock", "play", "list", "diff", "label", "machine", "p", "inner", "comment", "fix", "open", "add", "document", "match", "form", "value", "rule", "line", "flag", "service", "child", "slice", "element", "update", "parent", "lib", "manager", "group", "lf", "user", "record", "type"], "first_elem": ["first_elelement", "first_nelem", "first_nelements", "first_eleleg", "first_elele", "first_nele", "first_eele", "first_elelegate", "first_aelem", "first_ele", "first_elelem", "first_aelement", "first_eelem", "first_seleg", "first_selement", "first_eleg", "first_nelement", "first_aelements", "first_eeleg", "first_eelements", "first_elegate", "first_eelement", "first_selem", "first_element", "first_selegate", "first_selements", "first_elements", "first_aelegate", "first_elelements"], "i": ["e", "ui", "I", "info", "j", "init", "p", "ip", "id", "c", "index", "num", "si", "a", "ii", "b", "in", "n", "slice", "len", "base", "di", "v", "z", "li", "x", "k", "type"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n\n                          int128_get64(section->size));\n\n}\n", "idx": 21348, "substitutes": {"listener": ["listen", "listend", "oldening", "preoder", "lineners", "neweners", "linend", "olden", "linener", "latener", "newener", "newening", "listoder", "newen", "listening", "preend", "hipoder", "hipeners", "preeners", "hipend", "hipener", "preener", "oldener", "oldeners", "listeners", "linoder", "lateners", "latening", "laten"], "section": ["port", "writer", "area", "object", "event", "option", "character", "part", "container", "connection", "region", "plugin", "journal", "layer", "ion", "entry", "address", "size", "data", "storage", "patch", "setting", "component", "sections", "sector", "Section", "sub", "sect", "service", "channel", "core", "division", "length", "slice", "definition", "element", "parser", "parent", "stage", "shadow", "sec", "vision", "secondary", "server", "environment"], "state": ["port", "State", "area", "start", "object", "STATE", "config", "event", "part", "region", "style", "as", "info", "address", "data", "j", "stat", "patch", "cache", "list", "ace", "id", "context", "sync", "settings", "tag", "cal", "rule", "ass", "session", "length", "slice", "back", "parent", "manager", "resource", "instance", "scope", "states", "type"]}}
{"project": "FFmpeg", "commit_id": "d59591fb02c29b41e5b8d611160971a4493394c2", "target": 1, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 4;\n\n                                else\n\n                                    s->repeat_pict = 2;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}", "idx": 21374, "substitutes": {"s": ["sv", "sb", "e", "qs", "es", "bis", "sam", "sl", "fs", "g", "ses", "private", "sets", "ds", "services", "f", "sys", "t", "r", "u", "m", "socket", "ssl", "os", "p", "cs", "ts", "ls", "sync", "stats", "sa", "client", "c", "ctx", "self", "spec", "sg", "sq", "settings", "si", "sc", "b", "aws", "service", "soc", "session", "S", "sup", "parser", "utils", "ps", "rs", "gs", "south", "v", "http", "sec", "conf", "server", "su", "ss", "acs"], "avctx": ["svcontext", "AVkb", "avecu", "AVcf", "aveca", "AVconfig", "Avcf", "airconfig", "abxc", "avecca", "avhw", "airctx", "Avconn", " avhw", "avcca", "evconn", "avconn", "afcmp", "avconfig", "AVcontext", "afctx", "evcontext", "avcf", "AVca", "avecmp", "avehw", "avca", "AVhw", " avcmp", "afcms", "Avcontext", "svcu", "svctx", "svcms", "avecontext", "afcu", "evcms", "avecms", "abconfig", "avcontext", " avcf", "avcu", "avxc", "abctx", "afgb", "avgb", "avcms", " avcca", "AVxc", " avkb", "evctx", "Avcms", " avxc", "avectx", "Avctx", "abcontext", "afcontext", "AVctx", "aircontext", "afconn", " avgb", "avcmp", " avca", " avcontext", "AVgb", "afcca", "Avxc", "airxc", "afkb", "avkb"], "buf": ["begin", "bc", "off", "config", "av", "mb", "buffer", "pos", "alloc", "exc", "data", "bt", "que", "context", "wb", "header", "bo", "ff", "src", "fw", "br", "bd", "ab", "batch", "proc", "v", "rb", "fam", "feat", "cap", "uf", "txt", "end", "text", "mount", "db", "cv", "ctr", "bb", "fp", "bu", "coord", "filename", "rc", "cb", "lim", "c", "bh", "vec", "bag", "offset", "su", "ph", "conv", "uc", "ba", "usb", "fb", "queue", "func", "Buff", "img", "cas", "xff", "f", "band", "cmd", "box", "cf", "bn", "num", "b", "usr", "length", "fd", "loc", "buff", "bf", "orig", "gb", "count", "pb", "port", "loop", "ha", "home", "cur", "uber", "grab", "ctx", "aux", "seq", "auc", "len", "block", "max"], "buf_size": ["bufallend", "buf_scale", "buffer_start", "bufallsize", "buffer_size", " buf_engine", "buf_engine", "bufalladdress", "bufallscale", "bufallengine", "bufallsum", " buf_scale", "buffer_address", "buf_address", "buffer_sum", "buf_sum", "bufallstart", "buf_start"], "pc": ["lc", "bc", "pb", "fc", "arc", "cc", "cam", "wcs", "uc", "conn", "amp", "inc", "toc", "pm", "con", "ca", "pd", "bp", "anc", "can", "gb", "sys", "ac", "nc", "cp", "cache", "p", "mc", "cs", "pic", "xc", "tc", "enc", "mac", "py", "PC", "c", "ctx", "rc", "px", "wp", "client", "sc", "dc", "aa", "pac", "co", "cz", "jc", "proc", "cms", "ec", "pt", "oc", "api", "cu", "pa", "vc"], "buf_end": ["buJend", "bu_end", "buJget", "bufjindex", "cap_start", "buff_index", "buf67get", "bufacstart", "buff0id", "buf67end", "bufpend", "bufenoffset", "uf_id", "uf_off", "cap_ended", "buf_off", "buff_end", "buff_id", "bufpindex", "buf_clean", "buf_ent", "buff_start", "bufjend", "buf_ended", "buf0end", "buf0start", "img_end", "bufjoffset", "bufjsize", "imgjend", "buJclean", "bufpstart", "buf67clean", "bufenindex", "buff0start", "buf_offset", "buf0index", "bufensize", "cap_end", "bufpid", "buf0off", "buf0id", "bufenend", "bufJend", "buf_End", "bu_clean", "cap_ent", "img_size", "bufJclean", "bufacoff", "buf_index", "bufJEnd", "uf_start", "uf_end", "buJEnd", "img_index", "buf_get", "buff0end", "imgjindex", "imgjoffset", "bufacend", "img_offset", "bufacid", "imgjsize", "bu_get", "buff0index", "buf_id", "bufJget", "buf67End", "buf_start", "bu_End"], "start_code": ["start_type", "startaccode", "start64buffer", "startfcoded", "end_coded", "start64Code", "start67codes", "startPcodes", "start67code", "end_Code", "start64coded", "stop_code", "end_type", "stop_type", "end_codes", "startprecode", "start_header", "start_coded", "startacsize", "startprenumber", "start_codes", "stop_size", " start_codes", " start_header", "start_number", "start67header", "start64code", "startprecodes", "startacconst", "start_Code", "startPcode", "start_const", "end_buffer", "start67number", "startfCode", " start_number", "startpreheader", "startPCode", "end_code", "start_buffer", "startactype", "startPtype", "startfbuffer", "stop_const", "startfcode", "start_size"], "frame_rate_index": ["frame_ratexwidth", "frame_rating_width", "frame_rate_ind", "frame_rating_key", "frame_rates_element", "frame_rating_index", "frame_rate_count", "frame_rates_key", "frame_rates_entry", "frame_rating_len", "frame_rate_size", "frame_rate___key", "frame_rate_width", "frame_rate_key", "frame_rates_index", "frame_ratexkey", "frame_rate_slice", "frame_rate_entry", "frame_ratexindex", "frame_rate_element", "frame_rate_len", "frame_ratexlen", "frame_rate___entry", "frame_rate___element", "frame_rate___index"], "ext_type": ["proc_format", "ext_format", "ext_num", "extitystyle", "procityformat", "extitynum", "proc_num", "proc_type", "extalstyle", "procitystyle", "extalformat", "procitytype", "extaltype", "procitynum", "ext_style", "extityformat", "extitytype", "extalnum", "proc_style"], "bytes_left": ["lines_diff", "bytes_diff", "bytes_old", "bytes___end", "bytes___left", "lines_length", "bytes___offset", "bytes_right", "bits_left", "bytes_length", "lines_old", "bytes_joined", "bytes_offset", "bits_offset", "bytes_end", "bytesenleft", "lines_two", "bits_right", "bytesenlength", "bytes_two", "lines_right", "bytes___right", "bits_joined", "lines_left", "bytesenright", "bits_end", "bytesentwo"], "frame_rate_ext_n": ["frame_rate_xt_N", "frame_rate_xt_n", "frame_rate_xt_d", "frame_rate_xt_nc", "frame_rate_ext_N", "frame_rate_ext_nc"], "frame_rate_ext_d": ["frame_rate_ext16pos", "frame_rate_ext16x", "frame_rate_xt_pos", "frame_rate_ext5pos", "frame_rate_ext16n", "frame_rate_ext5d", "frame_rate_xt_n", "frame_rate_xt_x", "frame_rate_ext16d", "frame_rate_ext_x", "frame_rate_ext5n", "frame_rate_ext_pos", "frame_rate_xt_d", "frame_rate_ext5x"], "picture_structure": ["picture_Struction", "picture_strruction", "picture_strructure", "picture_strolerance", "picture_Stolerance", "picture_struction", "picture_astructure", "picture_stolerance", "picture_Sturation", "picture_Structure", "picture_astruction", "picture_astolerance", "picture_asturation", "picture_sturation", "picture_struration"], "top_field_first": ["top_fieldallast", "top_line_last", "top_fieldalleft", "top_fielddfirst", "top_line_left", "top_field_bottom", "top_line_first", "top_field_left", "top_fielddleft", "top_fieldalbottom", "top_fieldalfirst", "top_fielddlast", "top_field_last", "top_line_bottom", "top_fielddbottom"], "repeat_first_field": ["repeat_last_line", "repeat_last_frame", "repeat_last_field", "repeat_first_line", "repeat_first_bit", "repeat_first_frame", "repeat_firstsbit", "repeat_last_bit", "repeat_firstsline", "repeat_firstsframe", "repeat_firstsfield"], "progressive_frame": ["progressive67seq", "progressivealedge", "progressive2edge", "progressive67frame", "progressive2frame", "progressive_seq", "progressive2seq", "progressive67image", "progressive_edge", "proicient_frame", "progressive2image", "proicientaledge", "progressivealframe", "proicient_edge", "proicientalimage", "proicient_seq", "proicient_image", "progressive67edge", "proicientalframe", "progressive_image", "proicientalseq", "progressivealseq", "progressivealimage"], "horiz_size_ext": ["horiz_size_complete", "horiz_size_sec", "horiz_sizeingsec", "horiz_sizeingext", "horiz_len_ex", "horiz_sizexex", "horiz_len_sec", "horiz_sizeingex", "horiz_leningsec", "horiz_leningext", "horiz_len_ext", "horiz_sizexext", "horiz_leningcomplete", "horiz_sizeingcomplete", "horiz_sizexcomplete", "horiz_len_complete", "horiz_sizexsec", "horiz_leningex", "horiz_size_ex"], "vert_size_ext": ["vert_scale_ex", "vert_scale__desc", "vert_size__txt", "vert_scale__ext", "vert_size__ext", "vert_size_ex", "vert_size__desc", "vert_size_desc", "vert_size__ex", "vert_scale__txt", "vert_size_txt", "vert_scale_txt", "vert_scale_desc", "vert_scale_ext", "vert_scale__ex"], "bit_rate_ext": ["bit_rate_EXT", "bit_rate_xt", "bit_rate_Ext"]}}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "func": "static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n", "idx": 21383, "substitutes": {"data": ["writer", "def", "object", "valid", "g", "result", "input", "board", "val", "wa", "Data", "d", "style", "pad", "ds", "device", "buffer", "info", "da", "cache", "ad", "storage", "new", "p", "o", "code", "memory", "la", "self", "index", "DATA", "window", "error", "reader", "test", "database", "di", "parent", "dat", "li", "block", "base"], "off": ["OFF", "def", "own", "fail", "none", "ord", "before", "no", "eff", "pos", "front", "bit", "address", "ip", "load", "shift", "out", "ff", "unknown", "test", "br", "type", "name", "end", "valid", "non", "ack", "oa", "style", "offs", "op", "o", "code", "on", "a", "set", "online", "alt", "empty", "offer", "offset", "remote", "after", "opp", "ref", "not", "one", "head", "size", "new", "Off", "addr", "open", "num", "check", "error", "length", "command", "port", "start", "obj", "down", "id", "close", "index", "now", "block", "pack", "all", "value"], "sig": ["psign", "opensIG", "gsIG", " sigma", "SIG", "sigs", "ssign", " sign", "wsig", "Sig", "opensigma", " sigs", "sign", " sib", "gsigma", "sigh", "sIG", "dsig", "wsigh", "ssarg", "Sec", "ssigs", "gsiger", " sigh", "siger", "ssib", " sarg", "opensigh", "psarg", "ssig", "Sib", "dsIG", " sIG", "Sigs", "sib", "wsigma", "dsigs", "sigma", "wsIG", "ssIG", "gsig", "ssigma", "psig", "gsigs", "sarg", "psigs", "Siger", "sec", "opensig", " sec", "ssec", "dsiger", "dsigma"], "i": ["io", "e", "ix", "start", "ie", "fi", "qi", "ri", "ind", "ui", "mini", "gi", "d", "ti", "I", "l", "f", "ci", "t", "phi", "u", "m", "ini", "oi", "j", "info", "init", "ip", "p", "abi", "id", "o", "bi", "mi", "c", "mu", "index", "si", "a", "ii", "b", "in", "min", "n", "iu", "slice", "ai", "xi", "di", "v", "z", "multi", "li", "pi", "x", "k"]}}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385, "substitutes": {"sc": ["lc", "bc", "SC", "fc", "cc", "cam", "uc", "esc", "sk", "sci", "asc", "sche", "cv", "ca", "Sc", "cur", "pc", "cl", "cmp", "enc", "cs", "cer", "cf", "tc", "context", "rc", "c", "ctx", "spec", "dc", "soc", "cr", "desc", "src", "loc", "usc", "osc", "cms", "scope", "ec"], "duration": ["span", "delay", "port", "period", "attribute", "end", "event", "until", "time", "d", "uri", "pause", "feature", "pad", "device", "uration", "series", "sequence", "data", "lasting", "design", "Duration", "dimension", "component", "unit", "number", "depth", "context", "timeout", "tube", "audio", "document", "distance", "window", "direction", "date", "length", "database", "stage", "range", "doc", "frequency", "gap", "resource", "sleep", "repeat", "video"]}}
{"project": "FFmpeg", "commit_id": "1197c04896423c6c7db65f69da8bc3865b26bb50", "target": 1, "func": "static void fft_calc_c(FFTContext *s, FFTComplex *z) {\n\n\n\n    int nbits, i, n, num_transforms, offset, step;\n\n    int n4, n2, n34;\n\n    FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;\n\n    FFTComplex *tmpz;\n\n    const int fft_size = (1 << s->nbits);\n\n    int64_t accu;\n\n\n\n    num_transforms = (0x2aab >> (16 - s->nbits)) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 2;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[0].re + tmpz[1].re;\n\n        tmp5 = tmpz[2].re + tmpz[3].re;\n\n        tmp2 = tmpz[0].im + tmpz[1].im;\n\n        tmp6 = tmpz[2].im + tmpz[3].im;\n\n        tmp3 = tmpz[0].re - tmpz[1].re;\n\n        tmp8 = tmpz[2].im - tmpz[3].im;\n\n        tmp4 = tmpz[0].im - tmpz[1].im;\n\n        tmp7 = tmpz[2].re - tmpz[3].re;\n\n\n\n        tmpz[0].re = tmp1 + tmp5;\n\n        tmpz[2].re = tmp1 - tmp5;\n\n        tmpz[0].im = tmp2 + tmp6;\n\n        tmpz[2].im = tmp2 - tmp6;\n\n        tmpz[1].re = tmp3 + tmp8;\n\n        tmpz[3].re = tmp3 - tmp8;\n\n        tmpz[1].im = tmp4 - tmp7;\n\n        tmpz[3].im = tmp4 + tmp7;\n\n    }\n\n\n\n    if (fft_size < 8)\n\n        return;\n\n\n\n    num_transforms = (num_transforms >> 1) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 3;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[4].re + tmpz[5].re;\n\n        tmp3 = tmpz[6].re + tmpz[7].re;\n\n        tmp2 = tmpz[4].im + tmpz[5].im;\n\n        tmp4 = tmpz[6].im + tmpz[7].im;\n\n        tmp5 = tmp1 + tmp3;\n\n        tmp7 = tmp1 - tmp3;\n\n        tmp6 = tmp2 + tmp4;\n\n        tmp8 = tmp2 - tmp4;\n\n\n\n        tmp1 = tmpz[4].re - tmpz[5].re;\n\n        tmp2 = tmpz[4].im - tmpz[5].im;\n\n        tmp3 = tmpz[6].re - tmpz[7].re;\n\n        tmp4 = tmpz[6].im - tmpz[7].im;\n\n\n\n        tmpz[4].re = tmpz[0].re - tmp5;\n\n        tmpz[0].re = tmpz[0].re + tmp5;\n\n        tmpz[4].im = tmpz[0].im - tmp6;\n\n        tmpz[0].im = tmpz[0].im + tmp6;\n\n        tmpz[6].re = tmpz[2].re - tmp8;\n\n        tmpz[2].re = tmpz[2].re + tmp8;\n\n        tmpz[6].im = tmpz[2].im + tmp7;\n\n        tmpz[2].im = tmpz[2].im - tmp7;\n\n\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp1 + tmp2);\n\n        tmp5 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 - tmp4);\n\n        tmp7 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp2 - tmp1);\n\n        tmp6 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 + tmp4);\n\n        tmp8 = (int32_t)((accu + 0x40000000) >> 31);\n\n        tmp1 = tmp5 + tmp7;\n\n        tmp3 = tmp5 - tmp7;\n\n        tmp2 = tmp6 + tmp8;\n\n        tmp4 = tmp6 - tmp8;\n\n\n\n        tmpz[5].re = tmpz[1].re - tmp1;\n\n        tmpz[1].re = tmpz[1].re + tmp1;\n\n        tmpz[5].im = tmpz[1].im - tmp2;\n\n        tmpz[1].im = tmpz[1].im + tmp2;\n\n        tmpz[7].re = tmpz[3].re - tmp4;\n\n        tmpz[3].re = tmpz[3].re + tmp4;\n\n        tmpz[7].im = tmpz[3].im + tmp3;\n\n        tmpz[3].im = tmpz[3].im - tmp3;\n\n    }\n\n\n\n    step = 1 << ((MAX_LOG2_NFFT-4) - 4);\n\n    n4 = 4;\n\n\n\n    for (nbits=4; nbits<=s->nbits; nbits++){\n\n        n2  = 2*n4;\n\n        n34 = 3*n4;\n\n        num_transforms = (num_transforms >> 1) | 1;\n\n\n\n        for (n=0; n<num_transforms; n++){\n\n            const FFTSample *w_re_ptr = ff_w_tab_sr + step;\n\n            const FFTSample *w_im_ptr = ff_w_tab_sr + MAX_FFT_SIZE/(4*16) - step;\n\n            offset = ff_fft_offsets_lut[n] << nbits;\n\n            tmpz = z + offset;\n\n\n\n            tmp5 = tmpz[ n2].re + tmpz[n34].re;\n\n            tmp1 = tmpz[ n2].re - tmpz[n34].re;\n\n            tmp6 = tmpz[ n2].im + tmpz[n34].im;\n\n            tmp2 = tmpz[ n2].im - tmpz[n34].im;\n\n\n\n            tmpz[ n2].re = tmpz[ 0].re - tmp5;\n\n            tmpz[  0].re = tmpz[ 0].re + tmp5;\n\n            tmpz[ n2].im = tmpz[ 0].im - tmp6;\n\n            tmpz[  0].im = tmpz[ 0].im + tmp6;\n\n            tmpz[n34].re = tmpz[n4].re - tmp2;\n\n            tmpz[ n4].re = tmpz[n4].re + tmp2;\n\n            tmpz[n34].im = tmpz[n4].im + tmp1;\n\n            tmpz[ n4].im = tmpz[n4].im - tmp1;\n\n\n\n            for (i=1; i<n4; i++){\n\n                FFTSample w_re = w_re_ptr[0];\n\n                FFTSample w_im = w_im_ptr[0];\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].re;\n\n                accu += (int64_t)w_im*tmpz[ n2+i].im;\n\n                tmp1 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].im;\n\n                accu -= (int64_t)w_im*tmpz[ n2+i].re;\n\n                tmp2 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].re;\n\n                accu -= (int64_t)w_im*tmpz[n34+i].im;\n\n                tmp3 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].im;\n\n                accu += (int64_t)w_im*tmpz[n34+i].re;\n\n                tmp4 = (int32_t)((accu + 0x40000000) >> 31);\n\n\n\n                tmp5 = tmp1 + tmp3;\n\n                tmp1 = tmp1 - tmp3;\n\n                tmp6 = tmp2 + tmp4;\n\n                tmp2 = tmp2 - tmp4;\n\n\n\n                tmpz[ n2+i].re = tmpz[   i].re - tmp5;\n\n                tmpz[    i].re = tmpz[   i].re + tmp5;\n\n                tmpz[ n2+i].im = tmpz[   i].im - tmp6;\n\n                tmpz[    i].im = tmpz[   i].im + tmp6;\n\n                tmpz[n34+i].re = tmpz[n4+i].re - tmp2;\n\n                tmpz[ n4+i].re = tmpz[n4+i].re + tmp2;\n\n                tmpz[n34+i].im = tmpz[n4+i].im + tmp1;\n\n                tmpz[ n4+i].im = tmpz[n4+i].im - tmp1;\n\n\n\n                w_re_ptr += step;\n\n                w_im_ptr -= step;\n\n            }\n\n        }\n\n        step >>= 1;\n\n        n4   <<= 1;\n\n    }\n\n}\n", "idx": 21386, "substitutes": {"s": ["sb", "e", "outs", "sym", "space", "qs", "sample", "g", "ses", "d", "sets", "site", "ds", "services", "f", "t", "u", "m", "size", "j", "p", "cs", "o", "sync", "sites", "c", "settings", "js", "spec", "sq", "si", "sc", "in", "b", "service", "S", "ns", "sup", "sf", "south", "ps", "gs", "sec", "sn", "su", "ss"], "z": ["az", "e", "hz", "iz", "zo", "Z", "config", "cm", "ze", "d", "za", "temp", "qq", "ld", "f", "cell", "y", "t", "m", "j", "zip", "p", "uz", "zz", "zone", "zx", "q", "zon", "gz", "c", "ctx", "zen", "ez", "w", "zy", "slice", "zh", "cz", "zn", "v", "tz", "l", "x", "nz", "zi"], "nbits": ["nbbit", " nlines", " nframes", "numbytes", "lenbit", "numlines", "nnbits", "nrows", "nframes", "Nbits", "nints", "Nbytes", "lenbits", "nnbit", " nbit", "nbbits", "numframes", "lenlines", "numints", "numbits", "Nints", "Nframes", " nints", " nbytes", "nbytes", "nbit", "lenbytes", "nnrows", "numbit", " nrows", "nbrows", "nlines"], "i": ["io", "ind", "d", "ti", "I", "f", "ci", "ini", "m", "it", "j", "ip", "p", "bi", "mi", "c", "index", "ib", "si", "ii", "b", "in", "iu", "xi", "li", "pi", "ni"], "n": ["net", "syn", "name", "un", "e", "en", "conn", "adj", "nn", "g", "non", "an", "none", "d", "mn", "not", "no", "f", "dn", "t", "y", "N", "nc", "m", "j", "init", "r", "p", "na", "o", "inner", "ng", "network", "c", "nr", "num", "cn", "inn", "ann", "on", "b", "in", "w", "a", "ns", "len", "br", "nb", "v", "nt", "sn", "fn", "nor", "all", "nu", "l", "x", "pn", "ne", "k", "ni"], "num_transforms": ["num_transversions", "num_transformed", "numallshocksections", "num_constsections", "num_surmissions", "num_shocksections", "num_ransform", "num_transflows", "numalltransplays", "num2traframes", "num_shockractions", "num_transferformer", "num_ransceptions", "num_nonflows", "num__transractions", "num_transmits", "numallshockractions", "num_transform", "num_traforms", "num_shockforms", "numalltransractions", "num_transferframes", "num_traceptions", "num_surformed", "num__transsts", "num_ransformer", "num2transtransform", "num_firstractions", "numalltranssections", "num_transfertransform", "num_shocksts", "num__transforms", "num_surforms", "num_ransmissions", "numalltransforms", "num2transframes", "num_shockplays", "num_traframes", "num_perceptions", "num_conforms", "num_comsts", "num_traformed", "num_parttransform", "num_constforms", "num_transsections", "num_tratransform", "num__shocksts", "num_performed", "num_peractions", "num_ransformed", "num_transtransform", "num_transractions", "num_partactions", "num_partforms", "num_partframes", "num2traforms", "num_shockmits", "num_commits", "num2tratransform", "numallshockplays", "num_firstforms", "num_nonformer", "num_transsts", "num__shockforms", "num2transforms", "num_transceptions", "num_transplays", "num_transferactions", "num_transmissions", "num_firstplays", "num_conractions", "num__shockmits", "num_transferforms", "num_constplays", "num_transframes", "num_constractions", "num__transmits", "num_transferversions", "num_ransversions", "numallshockforms", "num2transactions", "num_ransactions", "num_nonforms", "num2traactions", "num_performs", "num_firstsections", "num_comractions", "num_ransflows", "num_transformer", "num_consts", "num_surform", "num_traactions", "num_ransforms", "num_transferflows", "num_nonversions", "num__shockractions", "num_transactions", "num_comforms", "num_conmits"], "offset": ["adjust", "delay", "bound", "phase", "limit", "start", "area", "attribute", "notation", "end", "off", "ref", "scale", "option", "amp", "item", "hop", "part", "stop", "align", "f", "layer", "pos", "order", "optional", "axis", "address", "entry", "size", "seed", "adjusted", "unit", "url", "o", "slot", "initial", "addr", "shift", "timeout", "af", "index", "set", "location", "online", "alias", "error", "Offset", "length", "len", "loc", "slice", "append", "nb", "skip", "parent", "range", "reset", "alpha", "alt", "frequency", "image", "position", "output", "action", "padding"], "step": ["delay", "sb", "start", "ct", "scale", "loop", "trial", "weight", "init", "seed", "version", "ip", "sync", "shift", "timeout", "index", "dim", "dc", "w", "Step", "steps", "min", "ai", "batch", "skip", "stage", "sec", "sleep"], "n4": [" n3", "m5", "num2", "m2", "num4", "n3", "m4", "num5", " n5", "m3", "num3", "n5"], "n2": ["g32", "g2", "num2", " n32", "g42", "num42", "num5", "n42", "n32", " n5", "g5", " n42", "n5", "num32"], "n34": ["nan35", "inn34", "na34", "N54", "N39", "na39", "N34", "nan39", "na54", "na35", "inn54", "inn35", "inn39", "nan34", "nan54", "N35"], "tmp1": ["temp2", "mp1", "cmp1", "dest3", "temp5", "tem01", "temp8", "tmpnum", "tem1", "dest1", "cmpnum", "mp5", "temp3", "cmp2", "cmp3", "cmp8", "tempnum", "mp2", "tem2", "tmp01", "mp3", "tem5", " tmp01", "temp1", "mp4", " tmpnum", "dest4", "mp01", "dest2", "cmp4", "temp4"], "tmp2": ["temp2", "mp1", "temp5", "txt1", "temp02", "mp5", "temp3", "mp2", "mp3", "tmp02", "temp1", "mp4", "txt4", "mp02", "txt02", "mp6", "temp4", "temp6", "txt2"], "tmp3": ["temp2", "mp1", "temp03", "temp5", "tmp03", "tempThree", " tmp53", "sup4", " tmp03", "mp53", "mp5", "temp3", "sup1", "mp2", "mp3", "temp1", "mp4", " tmpThree", "tmp53", "sup3", "sup2", "mpThree", "mp6", "temp53", "mp03", "temp4", "temp6", "tmpThree"], "tmp4": ["temp2", "mp1", "temp5", "temp7", "temp04", " tmp04", "tmp04", "mp5", " tmp40", "np2", "np40", "mp7", "temp40", "tmp40", "mp2", "temp1", "mp4", "np4", "mp6", "temp4", "temp6", "np04"], "tmp5": ["mp50", "appy6", "temp5", "temp2", "sup05", "appy2", "temp55", "sup8", "tmp05", "sup4", "mp55", "tmp55", "sup5", "tmp50", "mp5", "appy1", " tmp50", "appy5", "temp50", "cmp8", "sup6", "temp25", "appy4", " tmp55", " tmp25", "mp25", "temp1", "cmp05", "sup2", "cmp4", "cmp5", "temp4", "temp6", "tmp25", " tmp05"], "tmp6": ["appy6", "temp5", "sup8", "temp8", "mp16", "temp60", "fake6", " tmp16", "sup4", "mp60", "appy8", "sup5", "fake4", "mp5", "appy5", "sup6", "appy4", " tmp60", "fake5", "mp8", "temp16", "mp4", "fake8", "tmp16", "mp6", "temp6", "temp4", "tmp60"], "tmp7": ["temp07", "temp5", "tmp57", "zip4", "zip8", "temp7", "api7", "tp7", "temp8", "zip9", "api4", "zip7", "api9", "mp5", "package4", "mp7", "package5", "temp57", "tp57", "tmp07", "tp70", "package7", "mp8", " tmp70", "mp4", "zip6", "tmp70", "zip5", "api5", "package9", "tmp9", " tmp57", "temp70", " tmp07", "mp6", "temp4", "temp6", "tp07"], "tmp8": ["temp2", "appy6", "temp5", "zip8", "temp7", "temp8", "appy8", "tmp08", "zip7", "mp5", "mp7", "appy4", "mp2", "appy08", "temp08", "mp8", "mp4", "zip6", "zip5", "mp6", "temp6", "temp4", "mp08"], "tmpz": ["tempza", "supx", "supz", "tmiz", "tempiz", "appyw", "optZ", "currentw", "cropw", "tmpzip", "mpx", "txtz", "tmpld", "tempzn", "cachezo", "mpzl", "tmpcz", " tmpy", "tempzi", "tempzone", "topc", "videoz", "tempzl", "tmpzi", "tmpzl", "tpc", "tempzo", "supzip", "apix", "mpzip", "temy", "mpl", "etcz", "tmple", "temZ", "tmzi", "temp5", "tmpZ", "tempzip", "tempc", " tmpiz", "tpzi", " tmpcz", "tpcz", "tmx", "bbx", "ppiz", "appyy", " tmpZ", "bby", "vmy", "optz", "optzone", "tmpx", "tempw", " tmpza", "tempgz", " tmpaz", " tmpzn", "fakez", "tmpzn", "ppzone", "cropz", "tmpoz", "apizen", "tempZ", "tempzz", "etcza", "temx", "tvw", "vmle", "fakezen", "videox", " tmpc", "temc", "tmw", "cachex", "mpz", "temza", "tvz", "txtx", "tvy", "cropy", "cvZ", " tmpx", "topaz", "optiz", "mpiz", "topz", "cachey", "oppiz", "cvz", "mpzen", "tempaz", "tmz", "tpx", "bbz", "ppz", "tmpw", "etcc", "topzip", " tmpoz", " tmpf", "appyz", "tvzip", "mp5", "tempx", "mpld", "tmy", "tmpaz", "temple", "cvc", "oppz", "mpgz", "temz", "mpzz", "tpz", "currentzip", "ppZ", "tempzen", "cviz", "txtld", "oppf", "videoy", "tmpf", " tmpl", "appyiz", "mpw", "currentz", "cropoz", "cachez", "tmpc", "mpza", "tmpl", "fakec", "vmzl", "tempcz", "tempoz", "tempy", "vmz", "templ", "currentl", "mpy", "tpy", "templd", "txtw", "tmpzo", "tmzl", "apiy", "tpzz", "tmpgz", "supw", " tmpw", "mpzo", "tmpiz", "apiz", "tmpy", "cropzl", "tmzn", "tmpzone", "fakex", "bb5", "mpzi", " tmpzip", "crople", "etcw", "mpc", "tmpza", "oppw", " tmpzi", "tempz", "tempf", "videogz", "tmpzz", "tmpzen"], "accu": ["accul", "circu", "circul", "skuu", "circuu", "circU", "accU", "asmU", "sku", "skul", "asmu", "asmuu", "skU", "asmul", "accuu"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                             int mmu_idx)\n\n{\n\n    mmu_ctx_t ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    env->error_code = 1 << 18;\n\n                    env->spr[SPR_IMISS] = address;\n\n                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;\n\n                    goto tlb_miss;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    goto tlb_miss_74xx;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    env->error_code = 0x40000000;\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    return -1;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_ESR] = 0x00000000;\n\n                }\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    /* XXX: this might be incorrect */\n\n                    env->error_code = 0x40000000;\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_ISEG;\n\n                    env->error_code = 0;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                        env->error_code = 1 << 16;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                        env->error_code = 0;\n\n                    }\n\n                    env->spr[SPR_DMISS] = address;\n\n                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;\n\n                tlb_miss:\n\n                    env->error_code |= ctx.key << 19;\n\n                    env->spr[SPR_HASH1] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[0], HASH_PTE_SIZE_32);\n\n                    env->spr[SPR_HASH2] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[1], HASH_PTE_SIZE_32);\n\n                    break;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                    }\n\n                tlb_miss_74xx:\n\n                    /* Implement LRU algorithm */\n\n                    env->error_code = ctx.key << 19;\n\n                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |\n\n                        ((env->last_way + 1) & (env->nb_ways - 1));\n\n                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;\n\n                    break;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] = 0x00800000;\n\n                    } else {\n\n                        env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                    return -1;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                if (env->mmu_model == POWERPC_MMU_SOFT_4xx\n\n                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] |= 0x00800000;\n\n                    }\n\n                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                } else {\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x0A000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x08000000;\n\n                    }\n\n                }\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or stwcx. */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    /* XXX: this might be incorrect */\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_DSEG;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 21387, "substitutes": {"env": ["config", "eni", "chal", "extra", "pos", "exc", "fg", "gov", "que", "context", "header", "cdn", "osc", "proc", "conf", "ev", "inet", "output", "sb", "txt", "org", "end", "conn", "db", "cv", "ench", "eng", "style", "site", "ah", "dev", "enc", "assets", "ext", "cb", "et", "equ", "esm", "rev", "ass", "qt", "erv", "scope", "net", "e", "forge", "err", "eu", "queue", "ou", "ea", "init", "Environment", "el", "enable", "dt", "gui", "nw", "core", "req", "stage", "manager", "dat", "ne", "ec", "en", "inc", "json", "engine", "export", "po", "esi", "nc", "args", "cache", "vs", "dict", "np", "client", "settings", "cal", "foundation", "viron", "session", "console", "vm", "server", "environment"], "address": ["route", "instead", "port", "request", "target", "attribute", "password", "shape", "area", "object", "asm", "config", "event", "eni", "message", "connection", "uri", "host", "interface", "node", "master", "size", "cache", "state", "ip", "point", "number", "code", "context", "addr", "ace", "prefix", "network", "index", "localhost", "ptr", "Address", "location", "service", "alias", "channel", "enter", "error", "element", "test", "reference", "array", "pointer", "pair", "instance", "resource", "block", "server", "image", "offset", "position", "output", "ACE", "url", "type"], "rw": ["row", "writer", "wcs", "wa", "mode", "wd", "rx", "rr", "wr", "ww", "rf", "lr", "rack", "wk", "r", "rew", "wh", "rh", "work", "wb", "iw", "rc", "rn", "wp", "wn", "nw", "sr", "raw", "w", "rt", "usr", "rl", "worker", "sw", "length", "RW", "fw", "rss", "ew", "wx", "tw", "hw", "rb", "kw", "wl", "resp"], "mmu_idx": ["mmu_sidxc", "mmu_sidf", "mmu_idc", "mmu_midy", "mmu_idxc", "mmu_idX", "mmu_Idx", "mmu_midf", "mmu_sidy", "mmu_sidX", "mmu_idg", "mmu_midX", "mmu_idy", "mmu_Idg", "mmu_sidc", "mmu_Idc", "mmu_sidx", "mmu_sidg", "mmu_midx", "mmu_idf", "mmu_Idxc"], "ctx": ["conv", "lc", "bc", "git", "cc", "wcs", "conn", "obj", "ct", "config", "jp", "event", "acl", "std", "ref", "pkg", "cv", "cm", "connection", "tx", "ca", "Context", "qq", "fp", "cas", "cmp", "ci", " c", "alloc", "nc", "cp", "cmd", "cf", "xc", "ctrl", "tc", "context", "sync", "cli", "client", "rc", "cb", "cn", "cfg", "sq", " context", "ann", "dc", "tmp", "hub", "qa", "session", "fw", "loc", "cca", "hw", "cu", "vc"], "access_type": ["access_key", " access_level", "accessableid", "accessingtype", "access_level", "access_name", "accessitylength", " access_id", "accessinglevel", "accessionkey", "accessfultype", "accessfulcolor", "access_types", "cache_types", "access_length", "accessingkey", "accessingname", "access_color", "cache_type", "cache_key", "accessionunit", "accessioncolor", " access_code", "access_unit", "access_id", "accessfulunit", "accessingcode", "accessaltype", "accessabletype", " access_key", "accessalkey", "access_size", "accessingsize", " access_size", "cache_name", " access_unit", "accessalsize", "accessfulkey", "accessingid", " access_types", " access_length", " access_format", "access_code", " access_color", "accessitytype", "accessablekey", "accessablecode", "accessingtypes", "accessiontype", "accessitycode", "access_format", "accessallevel"]}}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392, "substitutes": {"ds": ["md", "dos", "plays", "rd", "fs", "std", "ses", "Ds", "ded", "db", "xs", "der", "d", "pd", "ks", "uds", "ld", "services", "gd", "DS", "df", "dist", "dh", "da", "dd", "data", "state", "ys", "vs", "cs", "dy", "sync", "settings", "cb", "sd", "sts", "dt", "dim", "dc", "des", "dds", "dm", "dl", "fd", "ns", "states", "bd", "ps", "rs", "gs", "di", "dat", "ss", "gb"]}}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n", "idx": 21411, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "lb", "bis", "ba", "fs", "ses", "ubs", "fb", "as", "css", "ds", "bes", "fps", "bas", "os", "vs", "cs", "ls", "bi", "bps", "js", "b", "ns", "BS", "iss", "ps", "rs", "banks", "bh", "rb", "ss", "gb"], "sector_num": ["sector___number", " sector_name", " sector_con", "sector___ident", "sector_ident", " sector_number", "sector_con", "sector___num", "sector_name", " sector_ident", "sector_number", " sector_off", "sector_off", "sector___con"], "nb_sectors": ["nb_segments", "nb_sections", "nb_vegments", "nb_pegments", "nb_pections", "nb_vections", "nb_sector", "nb_secctors", "nb_vesections", "nb_pector", "nb_secfs", "nb_secsections", "nb_serctions", "nb_vectors", "nb_sesections", "nb_spegments", "nb_pectors", "nb_secgments", "nb_serctors", "nb_serctor", "nb_sergments", "nb_sefs", "nb_spectors", "nb_vefs", "nb_spefs", "nb_vector", "nb_spesections"], "pnum": ["PNom", "pnUM", "pronenum", "rnenum", "panUM", "cnUM", "bnum", "rnumber", "PNnum", "pnnum", "panumb", "pnenum", "rnom", "cnum", "cnenum", "rnUM", "bnenum", "pronumer", "natumer", "gnume", "gnenum", "natum", "cnom", "natenum", "cnnum", "snum", "rnumer", "gnnum", "cnumin", "snnum", "pnumb", "pnumin", "bnnum", "rnumb", "panum", "snenum", "PNenum", "rnum", "snume", "pnumber", "bnume", "PNum", "panumin", "gnum", "rnumin", "pnumer", "natumber", "cnumb", "pnume", "pronum", "pronumber", "pnom", "rnnum"], "cluster_offset": ["cluster_number", "cluster_part", "cloff6offset", "cluster_error", "clustersentry", "cloff6type", "cluster_entry", "cloff_type", "cluster_type", "cluster6type", "cluster6offset", "cluster6number", "clustersoffset", "cloff6number", "cloff6error", "cloff_error", "cloff_offset", "clusterstype", "cluster6error", "cloff_number", "cluster_size"], "ret": ["reg", "nat", "obj", "ref", "result", "val", "part", "arg", "ft", "det", "Ret", "mt", "cur", "art", "pre", "info", "bit", "res", "data", "cat", "opt", "arr", "fun", "success", "rot", "match", "let", "RET", "rt", " Ret", "mem", "rl", "flag", "sr", "re", "len", "br", "iter", "bf", "alt", "nt", "rb", "lit", "att", "pt", "rets"]}}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_test_apply(MigrateSetParameters *params,\n\n                                      MigrationParameters *dest)\n\n{\n\n    *dest = migrate_get_current()->parameters;\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        dest->compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        dest->compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        dest->decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        dest->cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        dest->cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        dest->tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        dest->tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        dest->max_bandwidth = params->max_bandwidth;\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        dest->downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        dest->x_checkpoint_delay = params->x_checkpoint_delay;\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        dest->block_incremental = params->block_incremental;\n\n    }\n\n}\n", "idx": 21413, "substitutes": {"params": ["target", "es", "config", "part", "afi", "parse", "css", "ds", "Param", "ams", "pos", "names", "sys", "list", "prefix", "resources", "alias", "src", "details", "test", "rs", "global", "proc", "http", "cms", "same", "ras", "phys", "conn", "asm", "nas", "services", "master", "pre", "s", "mac", "spec", "mp", "pres", "media", "changes", "options", "scope", "mos", "masters", "remote", "sym", "result", "rules", "cmp", "members", "p", "gas", "parts", "words", "points", "pins", "ps", "gs", "manager", "param", "api", "las", "models", "includes", "types", "shape", "lp", "pm", "ops", "plugins", "plugin", "results", "args", "rel", "vs", "ls", "mm", "sync", "settings", "ctx", "source", "maker", "par", "comments", "session", "mes", "parser", "prem", "vm", "sp", "apps", "server"], "dest": ["delete", "target", "class", "config", "copy", "temp", "path", "dist", "rest", "wb", "later", "src", "slice", "test", "comb", "global", "proc", "output", "feat", "this", "attr", "route", "name", "txt", "option", "text", "private", "true", "style", "node", "cont", "master", "coord", "opt", "trans", "Dest", "replace", "desc", "options", "best", "prop", "remote", "public", "miss", "store", "err", "result", "new", "gen", "usr", "service", "blast", "foreign", "sup", "orig", "ident", "external", "shape", "plugin", "home", "build", "transfer", "done", "dep", "source", "die", "session", "parent", "kw", "sort", "outer"]}}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "void cpu_state_reset(CPUMIPSState *env)\n\n{\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", env->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n\n    tlb_flush(env, 1);\n\n\n\n    /* Reset registers to their default values */\n\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n\n                                 << env->cpu_model->CP0_LLAddr_shift;\n\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n\n    env->CCRes = env->cpu_model->CCRes;\n\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = env->cpu_model->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = env->cpu_model->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n\n    env->insn_flags = env->cpu_model->insn_flags;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->hflags = MIPS_HFLAG_UM;\n\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n\n       hardware registers.  */\n\n    env->CP0_HWREna |= 0x0000000F;\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n#ifdef TARGET_MIPS64\n\n    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n#endif\n\n#else\n\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n\n        /* If the exception was raised from a delay slot,\n\n           come back to the jump.  */\n\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n\n    } else {\n\n        env->CP0_ErrorEPC = env->active_tc.PC;\n\n    }\n\n    env->active_tc.PC = (int32_t)0xBFC00000;\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n    env->CP0_Wired = 0;\n\n    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);\n\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n\n    /* vectored interrupts not implemented, timer on int 7,\n\n       no performance counters. */\n\n    env->CP0_IntCtl = 0xe0000000;\n\n    {\n\n        int i;\n\n\n\n        for (i = 0; i < 7; i++) {\n\n            env->CP0_WatchLo[i] = 0;\n\n            env->CP0_WatchHi[i] = 0x80000000;\n\n        }\n\n        env->CP0_WatchLo[7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n", "idx": 21427, "substitutes": {"env": ["inv", "gear", "app", "config", "event", "eni", "extra", "pos", "exc", "fg", "ini", "data", "que", "context", "header", " environments", "cdn", "iter", "global", "v", "conf", "ev", "inet", "output", "this", "emb", "org", "end", "conn", "db", "cv", "ench", "oa", "eng", "qv", "site", "ah", "dev", "vel", "enc", "assets", "code", "ext", "self", "et", "equ", " environment", "rev", "ass", " en", "NV", "fen", "qt", "erv", "net", "example", "e", "err", "eu", "token", "img", "ea", "exec", "init", "agen", "her", "Environment", "el", "module", "edge", "enable", "dt", "gui", "core", "er", "req", "stage", "dat", "manager", "h", "ec", "ne", "en", "obj", "inc", "engine", "export", "esi", "nc", "args", "cache", "vs", "dict", "np", "py", "client", "En", "het", "viron", "session", "console", " Environment", "vm", "server", "environment", "here"]}}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 21430, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "lb", "bis", "ba", "obj", "fs", "ses", "ubs", "db", "fb", "bb", "ops", "bytes", "bid", "bl", "ds", "bes", "bing", "bas", "os", "vs", "cs", "ls", "bps", "js", "b", "bits", "blocks", "ns", "BS", "iss", "ps", "rs", "banks", "ins", "gs", "bot", "rb", "base", "ss", "las"], "op": ["io", "rol", "step", "name", "opp", "prev", "obj", "off", "ap", "app", "option", "Op", "hop", "OP", "loop", "post", "key", "ops", "cop", "rop", "node", " cop", "f", "cmp", "pre", "info", "bit", "ok", "opt", "pp", "p", "ip", "oper", "id", "ep", "o", "operation", "mod", "code", "open", "ext", "ocl", "ask", "pop", "mp", "comp", "ic", "ype", "top", "oop", "doc", "ipop", "http", "root", "vert", "sp", "typ", "block", "oc", "x", "opus", "prop", "type"], "errp": ["errcp", " errlp", "errps", "rrP", "asterlp", "prop", " errn", "errper", "ryn", "rylp", "rrp", " errcp", "prpa", "asterper", "errn", "errop", " errpc", "ern", "asterr", "errpc", "rrpc", "errpa", "errP", "rrop", " errps", "prp", "ryr", "rycp", "rypa", " errpa", "ercp", "asterp", " errper", "rrpa", "prpc", "errlp", " errP", "ryp", "erpa", "erp", "erP", "errr", "ryper", " errr", "erpc", "erps", " errop", "rrps"], "blocker": ["Blocker", "boxer", "baner", " blockter", "blockter", "banner", "Blockiner", " blockler", " blockers", "lockers", "lockter", "blockacer", "lockler", "lockner", "Blockacer", " blockiner", "baners", "Blockler", "locker", "boxiner", "Blockers", "blockner", "blockers", "banter", "blockiner", "Blockner", "boxacer", " blockner", " blockacer", "blockler"]}}
{"project": "qemu", "commit_id": "3ddf3efefa364505ee44582873612dd8f6abb838", "target": 0, "func": "static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21435, "substitutes": {"device": ["port", "virt", "name", "target", "attribute", "password", "gpu", "driver", "Device", "mode", "de", "d", "feature", "plugin", "engine", "product", "devices", "path", "model", "mobile", "phy", "address", "dev", "data", "serial", "ip", "unit", "code", "disk", "network", "tag", "module", "dim", "service", "definition", "task", "user", " dev", "block", "VICE", "android", "prop", "type"], "aio_context": ["aio_concept", "aio_queue", "aios_queue", "aioopdocument", "aios_spec", "aios_session", "aios_ctx", "aio___socket", "aios_context", "aio_condition", "aio_network", "aio_document", "aios_condition", "aios_concept", "aios_network", "aio_ctx", "aio_center", "aio___ctx", "aio_socket", "aio_session", "aio_collection", "aios_config", "aio___queue", "aioopcontext", "aioopctx", "aios_support", "aios_document", "aios_center", "aio_support", "aios_socket", "aio___context", "aio_config", "aio_spec", "aioopsession", "aios_collection"], "errp": ["errps", "rrP", "eorp", "err", "eorps", "erc", "rrp", "erb", " errb", "errP", " errps", "errb", "rrc", "errc", "iterps", "iterc", "eorb", "eorr", "iterp", "erp", "erP", "errr", "iterP", " errr", "erps", "rrps"], "blk": ["blK", "BLk", "llker", " blck", "plks", "dlk", "dlker", "dlkt", "Blk", "oblsk", "blks", "silk", "oblker", "oblks", "plK", "Blck", " blK", " blks", "blck", "bleunk", "bleker", "BLck", "blsk", "bleks", "llunk", "dlunk", "blker", "plck", "Blb", "llk", "llks", " blkt", "oblk", "BLb", "blb", "plunk", "blek", "plkt", " blunk", "silsk", "Blkt", "silks", "Blks", "BLks", " blb", "plker", " blker", "plb", "blunk", "oblunk", "blkt", "silker", " blsk", "plk", "BLK", "oblkt"], "bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "bis", "ba", "obj", "fs", "ubs", "db", "fb", "boxes", "bb", "bin", "bytes", "as", "bid", "ds", "bes", "bl", "css", "bp", "eb", "ros", "bas", "its", "ob", "os", "vs", "cs", "ls", "bi", "abc", "is", "js", "cb", "b", "bits", "blocks", "ns", "BS", "iss", "ab", "ps", "ins", "gs", "Bs", "lib", "rs", "base", "android", "ss", "las", "gb"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n", "idx": 21450, "substitutes": {"str": ["txt", "name", "Str", "err", "text", "ctr", "tr", "wr", "cur", "f", "buffer", "exec", "r", "strings", "enc", "arr", "dict", "code", "dr", "fr", "pass", "sr", "ptr", "w", "read", "cr", "br", "iter", "st", "kr", "STR"], "hci": ["ihcu", "cc", "khai", "ihcin", "hlcu", "rhco", "khci", "hhcit", "cii", " hco", "hhcci", " hcu", "khcin", "pci", "hlc", "hai", "hdco", "affci", "hlci", "handcin", "hcin", "Hcit", "handcci", "handcu", "rhcin", "hhci", " hai", "hco", "pcci", "vci", "hdii", "hii", "ihci", "Hoci", "affcci", "rhci", "Hci", "vni", "handci", "ihai", "hc", " hcin", "hdcin", "pcu", "vcci", "Hcci", "cci", "pcin", " hcci", "hcit", " hoci", "hhoci", " hii", " hc", "khcu", "hdci", "affcin", "hni", "ccu", "hoci", "affni", "vcin", " hcit", "hlii", "hcu", "hcci", "rhii", " hni"], "bdaddr": ["godplayer", "ndwork", "bbaddr", "bdadr", "godpart", "bdno", "godattr", "hdaddr", "cbwork", "bdptr", "nbnode", "bdorig", "fdaddr", "ndattr", "bdwork", "cbattr", "bbadr", "dbadr", "pdaddress", "ndno", "ndaddress", "godnode", "bdplayer", "ndplayer", "bdpart", "ndowner", "nbaddress", "ndorder", "cbptr", "BDno", "bdowner", "dbattr", "cbaddr", "godaddress", "fdaddress", "ndadr", "BDorig", "nbpart", "bdattr", "nbaddr", "dbaddr", "dbaddress", "bbattr", "godaddr", "hdno", "fdptr", "cbaddress", "BDaddress", "cbadr", "ndaddr", "bdaddress", "pdaddr", "bbpart", "pdowner", "ndptr", "BDaddr", "hdaddress", "pdorder", "bbnode", "bdnode", "hdorig", "BDattr", "ndorig", "fdwork", "bdorder", "dborder", "dbowner", "BDadr", "bbaddress", "dbplayer"]}}
{"project": "qemu", "commit_id": "58aebb946acff82c62383f350cab593e55cc13dc", "target": 0, "func": "static int cris_mmu_translate_page(struct cris_mmu_result *res,\n\n\t\t\t\t   CPUState *env, uint32_t vaddr,\n\n\t\t\t\t   int rw, int usermode, int debug)\n\n{\n\n\tunsigned int vpage;\n\n\tunsigned int idx;\n\n\tuint32_t pid, lo, hi;\n\n\tuint32_t tlb_vpn, tlb_pfn = 0;\n\n\tint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\n\n\tint cfg_v, cfg_k, cfg_w, cfg_x;\t\n\n\tint set, match = 0;\n\n\tuint32_t r_cause;\n\n\tuint32_t r_cfg;\n\n\tint rwcause;\n\n\tint mmu = 1; /* Data mmu is default.  */\n\n\tint vect_base;\n\n\n\n\tr_cause = env->sregs[SFR_R_MM_CAUSE];\n\n\tr_cfg = env->sregs[SFR_RW_MM_CFG];\n\n\tpid = env->pregs[PR_PID] & 0xff;\n\n\n\n\tswitch (rw) {\n\n\t\tcase 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;\n\n\t\tcase 1: rwcause = CRIS_MMU_ERR_WRITE; break;\n\n\t\tdefault:\n\n\t\tcase 0: rwcause = CRIS_MMU_ERR_READ; break;\n\n\t}\n\n\n\n\t/* I exception vectors 4 - 7, D 8 - 11.  */\n\n\tvect_base = (mmu + 1) * 4;\n\n\n\n\tvpage = vaddr >> 13;\n\n\n\n\t/* We know the index which to check on each set.\n\n\t   Scan both I and D.  */\n\n#if 0\n\n\tfor (set = 0; set < 4; set++) {\n\n\t\tfor (idx = 0; idx < 16; idx++) {\n\n\t\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\t\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \n\n\t\t\t\t\tset, idx, hi, lo, tlb_vpn, tlb_pfn);\n\n\t\t}\n\n\t}\n\n#endif\n\n\n\n\tidx = vpage & 15;\n\n\tfor (set = 0; set < 4; set++)\n\n\t{\n\n\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\n\n\t\ttlb_vpn = hi >> 13;\n\n\t\ttlb_pid = EXTRACT_FIELD(hi, 0, 7);\n\n\t\ttlb_g  = EXTRACT_FIELD(lo, 4, 4);\n\n\n\n\t\tD_LOG(\"TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\\n\", \n\n\t\t\t mmu, set, idx, tlb_vpn, vpage, lo, hi);\n\n\t\tif ((tlb_g || (tlb_pid == pid))\n\n\t\t    && tlb_vpn == vpage) {\n\n\t\t\tmatch = 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\n\n\tres->bf_vec = vect_base;\n\n\tif (match) {\n\n\t\tcfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);\n\n\t\tcfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);\n\n\t\tcfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);\n\n\t\tcfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);\n\n\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\t\ttlb_v = EXTRACT_FIELD(lo, 3, 3);\n\n\t\ttlb_k = EXTRACT_FIELD(lo, 2, 2);\n\n\t\ttlb_w = EXTRACT_FIELD(lo, 1, 1);\n\n\t\ttlb_x = EXTRACT_FIELD(lo, 0, 0);\n\n\n\n\t\t/*\n\n\t\tset_exception_vector(0x04, i_mmu_refill);\n\n\t\tset_exception_vector(0x05, i_mmu_invalid);\n\n\t\tset_exception_vector(0x06, i_mmu_access);\n\n\t\tset_exception_vector(0x07, i_mmu_execute);\n\n\t\tset_exception_vector(0x08, d_mmu_refill);\n\n\t\tset_exception_vector(0x09, d_mmu_invalid);\n\n\t\tset_exception_vector(0x0a, d_mmu_access);\n\n\t\tset_exception_vector(0x0b, d_mmu_write);\n\n\t\t*/\n\n\t\tif (cfg_k && tlb_k && usermode) {\n\n\t\t\tD(printf (\"tlb: kernel protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 2;\n\n\t\t} else if (rw == 1 && cfg_w && !tlb_w) {\n\n\t\t\tD(printf (\"tlb: write protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\t/* write accesses never go through the I mmu.  */\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (rw == 2 && cfg_x && !tlb_x) {\n\n\t\t\tD(printf (\"tlb: exec protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (cfg_v && !tlb_v) {\n\n\t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 1;\n\n\t\t}\n\n\n\n\t\tres->prot = 0;\n\n\t\tif (match) {\n\n\t\t\tres->prot |= PAGE_READ;\n\n\t\t\tif (tlb_w)\n\n\t\t\t\tres->prot |= PAGE_WRITE;\n\n\t\t\tif (tlb_x)\n\n\t\t\t\tres->prot |= PAGE_EXEC;\n\n\t\t}\n\n\t\telse\n\n\t\t\tD(dump_tlb(env, mmu));\n\n\t} else {\n\n\t\t/* If refill, provide a randomized set.  */\n\n\t\tset = env->mmu_rand_lfsr & 3;\n\n\t}\n\n\n\n\tif (!match && !debug) {\n\n\t\tcris_mmu_update_rand_lfsr(env);\n\n\n\n\t\t/* Compute index.  */\n\n\t\tidx = vpage & 15;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, pid, 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  pid,\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->phy = tlb_pfn << TARGET_PAGE_BITS;\n\n\treturn !match;\n\n}\n", "idx": 21459, "substitutes": {"res": ["ras", "reg", "def", "response", "err", "result", "RES", "rem", "rec", "results", "sys", "ex", "pers", "ret", "Res", "arr", "rh", "rc", "des", "pres", "rev", "re", "gr", "req", "proc", "resource", "resp"], "env": ["inv", "txt", "e", "en", "end", "conn", "obj", "eu", "config", "err", "forge", "eni", "event", "db", "esp", "eng", "shell", "energy", "qv", "site", "engine", "export", "ea", "eve", "ef", "pos", "exec", "esi", "ens", "exc", "nc", "dir", "init", "her", "enc", "assets", "que", "np", "context", "Environment", "ext", "En", "equ", "dt", "profile", "esm", "het", "core", "viron", "enter", "console", "iss", "global", "qt", "dat", "conf", "erv", "ne", "manager", "ev", "environment", "scope", "ec"], "vaddr": ["lvaddr", "nvaddr", "evaddr", "lvaddress", "faddr", "vaddress", "lvcall", "nvaddress", "faddress", "vadd", " vadd", "nvcall", "vcall", "svadd", "nvhost", "evhost", "fadd", "svaddress", "fhost", "svhost", "svaddr", "evaddress", "evcall", " vhost", "vhost", " vaddress", "lvhost"], "rw": ["ru", "rd", "ride", "wa", "rx", "rr", "wr", "ww", "rf", "ro", "nc", "rew", "wh", "rh", "wb", "iw", "rc", "nr", "nw", "rl", "raw", "w", "dc", "usr", "worker", "sw", "RW", "fw", "rss", "mr", "wx", "tw", "proc", "rb", "hw", "rg"], "usermode": ["winmode", "winlevel", "userlevel", " userid", "userid", "winid", "usrid", "usrlevel", " userlevel", "usrmode"], "debug": ["reg", "err", "config", "scale", "progress", "DEBUG", "rec", "write", "Debug", "info", "dev", "bug", "cache", "web", "mod", "depth", "cli", "rc", "run", "dc", "error", "trace", "proc", "fun"], "vpage": ["fpages", " vpl", " vpages", " vpg", "Vpp", " vcenter", "svpp", "vPage", "Vpage", "valpage", "lcenter", " vPage", "vpages", " vrecord", "lpages", " vpp", "Vrecord", "vrecord", "vcenter", "VPage", "svpage", "fpl", "valpages", "fcenter", "Vpages", "Vpg", "vpp", "lpage", "vpg", "vpl", "fpage", "valpg", "svPage", "lpl", "valrecord"], "idx": ["Idxc", "Idy", "IDw", "ndX", "midx", "IDx", " idxx", "Idwx", "oidxc", "aidz", "indy", "idv", " idxc", "idexx", "indX", "IDxx", "indxi", "oidwx", "aidy", "IDX", "indi", "ridX", "IDxs", "indx", " idX", "idz", "idn", " idz", "oidx", "idxs", "idwx", "idxc", "Idi", " idu", "idu", "midX", "idX", " idi", "idy", " idwx", "ndu", "IDy", "aidn", "idw", " idy", " idxi", "ridxi", "IDz", "ideX", "idi", " idxs", "IdX", "idey", "aidX", " idw", "midw", "ndx", " idv", "ndy", "ridz", "idez", "midy", " idn", "idxx", "Idxs", "oidX", "idex", "indz", "Idu", "aidv", "idxi", "ridx", "iden", "Idx", "aidx", "Idv"], "pid": ["port", "net", "i", "prop", "conn", "nic", "mode", "pm", "uri", "pd", "pc", "offset", "pos", "po", "ci", "phi", "pp", "p", "id", "prefix", "mid", "mi", "py", "rot", "pri", "pin", "cpu", "page", "pins", "proc", "sid", "pty", "pointer", "vid", "uid", "pt", "pi", "pu", "pa"], "lo": ["lc", "rio", "zo", "ino", "loop", "ha", "LO", "lie", "ln", "so", "elo", "cl", "no", "local", "hei", "pos", "po", "ro", "ci", "ini", "lite", "mo", "lu", "las", "Hi", "lin", "o", "mid", "que", "le", "mi", "cli", "la", "pri", "lim", "pl", "Lo", "low", "cho", "go", "bo", "line", "min", "loc", "lt", "len", "co", "olo", "lon", "iso", "los", "ko", "lib", "li", "old", "l", "base", "fo", "who", "ilo"], "hi": ["i", "limit", "big", "ul", "end", "hel", "ha", "wa", "mini", "LO", "l", "home", "ho", "hello", "hei", "ci", "po", "win", "pos", "phi", "info", "ini", "full", "tick", "Hi", "id", "mid", "cli", "mi", "la", "index", "lim", "Lo", "low", "hide", "hu", "ii", "go", "hl", "HI", "flo", "loc", "gh", "show", "base", "ko", "li", "h", "cgi", "pi", "api", "high", "ph", "hh", "ni"], "tlb_vpn": ["tlb_venn", "tlb_fpn", "tlb_svfn", "tlb_nvnp", "tlb_svpn", "tlb_lfn", "tlb_rpn", "tlb_lnp", "tlb_vrn", "tlb_vsn", "tlb_avrn", "tlb_rcn", "tlb_avfn", "tlb_nvrn", "tlb_lpn", "tlb_ppn", "tlb_psn", "tlb_pcn", "tlb_lsn", "tlb_avnp", "tlb_svenn", "tlb_vfn", "tlb_pfn", "tlb_nvfn", "tlb_svcn", "tlb_fsn", "tlb_ffn", "tlb_vcn", "tlb_penn", "tlb_fpc", "tlb_avpn", "tlb_lpc", "tlb_vpc", "tlb_vnp", "tlb_ppc", "tlb_lrn", "tlb_nvpn", "tlb_renn", "tlb_rfn"], "tlb_pid": ["tlb_vid", "tla_pid", "tla_p", "tlb_pin", "tla_pin", "tla_vid", "tlb_p"], "tlb_g": ["tla_g", "tla_gn", "tlb_gn", "tlb_ga", "tla_ga", "tla_w"], "tlb_v": ["tlb_h", "tlb_y", "tlb__y", "tlb__w", "tlb__v", "tlb__h"], "tlb_k": ["tlb_q", "tbl_k", "tbl_n", "tbl_w", "tlb_n", "tbl_q"], "tlb_w": ["tbl_k", "tlb_y", "tbl_wa", "tbl_w", "tlb_wa", "tbl_y"], "tlb_x": ["tla_x", "tlb_xes", "tlb_h", "tla_h", "tla_xes", "tla_w"], "cfg_v": ["cfg_vy", "config_v", "config_vy", "config_g", "cfg_g", "cfg_f", "config_f"], "cfg_k": ["config_v", "cfg_z", "config_q", "config_k", "cfg_q", "config_z"], "cfg_w": ["conf_ws", "conf_d", "conf_w", "cfg_ws", "conf_wa", "cfg_wa", "cfg_d"], "cfg_x": ["config_ex", "config_w", "cfg_y", "config_x", "config_y", "cfg_ex"], "set": ["row", "nat", "config", "post", "kit", "parse", "no", "SET", "pos", "slave", "use", "Set", "shift", "draw", "test", "ment", "type", "col", "name", "end", "ind", "scale", "sche", "site", "write", "setup", "unit", "mod", "rc", "c", "spec", "et", "add", "sc", "see", "reset", "offset", "net", "stop", "section", "size", "init", "it", "open", "num", "check", "create", "error", "loc", "sec", "dat", "start", "en", "send", "ha", "inc", "get", "done", "setting", "id", "sync", "settings", "index", "match", "se", "vert", "server", "sort", "base", "value", "zero"], "r_cause": ["r__cause", "racca", "r_ca", " racCause", "r__Cause", " racca", "r_Cause", "rl_case", "raccause", "r__ca", " r_Cause", "r_src", "racCause", "r_case", " racdesc", " r_ca", "rl_Cause", " raccause", "r_desc", "rl_src", "r__desc", "racdesc", " r_desc", "rl_cause"], "r_cfg": ["r_fg", "p_config", "p_cf", "r2conf", " r_gc", "r2cfg", "r_cf", "r_gc", "r_config", "r_conf", "p_cfg", " r_conf", "r2cf", " r_cf", "r__config", "p__cf", "r__fg", "p__fg", "p__config", "p__cfg", "r__cf", "r2gc", "p_fg", "r__cfg"], "rwcause": ["rwCause", "rxraise", "swcause", "rwreason", "swscope", "wlCause", "rwtype", "rwsource", "swtype", "rfreason", "swreason", "rwcedes", "wlsequence", "wldue", "rfcause", "wrsource", "RWsource", "rhreason", "rwsequence", "wxdue", "rxsource", "wrreason", "rhtype", "rwscope", "rhraise", "wxCause", "rftype", "wlcause", "rxcause", "rfscope", "rhcedes", "RWsequence", "rhsequence", "rxcedes", "wxcause", "rwraise", "rhsource", "RWCause", "rhcause", "wxsequence", "wrsequence", "rfsource", "rwdue", "rfcedes", "rfraise", "RWcause", "RWreason", "rhscope", "RWdue", "wrcause"], "vect_base": ["vect_bin", "vect_bas", "vex_Base", "vex_base", "vex_bas", "vect2Base", "vect_Base", "vect_name", "vex_name", "vex_bin", "vect2bin", "vect2base", "vect2name"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n", "idx": 21466, "substitutes": {"ctx": ["conv", "lc", "fc", "txt", "cc", "conn", "sci", "ct", "config", "jp", "obj", "pkg", "cv", "cm", "crit", "tx", "ca", "Context", "pc", "anc", "fp", "node", "cmp", "ci", "exec", "nc", "component", "cf", "xc", "ctrl", "kb", "context", "tc", "np", "mac", "rc", "c", "cn", "sc", "cpp", "gc", "qa", "src", "loc", "cca", "cms", "hw", "scope", "vc"]}}
{"project": "qemu", "commit_id": "96193c22ab39ea24f81e386ad7883260ff24f5fd", "target": 0, "func": "static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n", "idx": 21473, "substitutes": {"cpu": ["lc", "platform", "bench", "fc", "uc", "gpu", "conn", "linux", "eni", "kernel", "processor", "pc", "CPU", "node", "anc", "intel", "nc", "cp", "cache", "xc", "uci", "np", "cli", "cow", "c", "ctx", "uca", "core", "mx", "chip", "proc", "vm", "hw", "instance", "pu", "ec"], "env": ["bench", "stack", "net", "disk", "e", "en", "end", "conn", "err", "eu", "config", "eni", "kernel", "oa", "energy", "eng", "esp", "extra", "style", "site", "engine", "anc", "export", "ea", "path", "exec", "exc", "fg", "ini", "nc", "args", "cache", "opt", "enc", "vs", "zone", "code", "context", "np", "cli", "Environment", "que", "ext", "settings", "ctx", "c", "agent", "et", "cfg", "el", " environment", "loader", "profile", "core", "viron", "desc", "inst", "console", "skin", "stage", "armor", "global", "conf", "vm", "ne", "ev", "environment", "scope", "server", "ec"], "i": ["io", "ami", "name", "e", "qi", "ri", "ui", "eni", "key", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "esi", "u", "oi", "m", "ini", "phi", "j", "adi", "ski", "ip", "abi", "p", "id", "o", "bi", "mi", "c", "mu", "index", "si", "a", "ii", "x", "b", "n", "iu", "ai", "xi", "ei", "di", "v", "multi", "yi", "li", "z", "h", "pi", "fi", "zi", "k", "ni"], "esa": ["isa", "ede", "ya", "tta", "anza", "ia", "es", "era", "ses", "iera", "anse", "za", "ega", "ca", "ti", "ea", "ci", "ozo", "esi", "aga", "nette", "ESA", "asi", "osi", "esse", "ace", "esta", "sa", "la", "pse", "una", "sea", "si", "edi", "uca", "ada", "se", "iza", "issa", "essa", "sem", "isi", "ma", "pa", "zi", "ette", "ista"], "s": ["status", "sb", "e", "sym", "sk", "sie", "sl", "g", "ses", "shell", "d", "l", "services", "f", "sys", "y", "u", "r", "m", "t", "state", "ssl", "os", "p", "o", "sync", "sa", "c", "settings", "js", "spec", "sc", "sr", "b", "in", "w", "service", "se", "session", "n", "S", "src", "sf", "south", "v", "http", "server", "su", "sq", "states"]}}
{"project": "qemu", "commit_id": "2bcf018340cbf233f7145e643fc1bb367f23fd90", "target": 0, "func": "int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n", "idx": 21487, "substitutes": {"env": ["inv", "priv", "net", "txt", "e", "en", "esc", "exe", "err", "eu", "config", "conn", "eni", "eng", "energy", "engine", "export", "ea", "eye", "exc", "init", "enc", "que", "context", "np", "buf", "equ", "enable", "ptr", "viron", "er", "console", "manager", "erv", "estate", "scope", "environment", "ec", "emb"], "raddr": ["wadd", "paddr", "rconfig", " rconfig", "padd", "pptr", " rptr", "wptr", "waddr", "Raddr", " radd", " raddress", "rptr", "raddress", "Rptr", "waddress", "paddress", "Raddress", "wconfig", "radd", "Rconfig"], "rw": [" w", " wid", "mode", "rx", "rr", "wr", "ww", "lr", "slave", "wo", "wh", "rh", "wb", "W", "rc", "wp", "nw", "rl", "w", "worker", "ran", "sw", "RW", " wo", "wx", "rb", " ro"], "addr": ["route", "grad", "en", "adr", "amp", "mode", "oa", "ord", "func", "amd", "align", "host", "pad", "lr", "node", "layer", "r", "coord", "address", "args", "ad", "data", "size", "arr", "ace", "nr", "edge", "lag", "add", "ar", "ptr", "seq", "fd", "callback", "rs", "pointer", "offset", "attr", "inter"], "flags": ["includes", "types", "ags", "workers", "weights", "ints", "fs", "features", "rules", "locks", "ops", "bytes", "plugins", "ages", "orts", "fps", "planes", "args", "vals", "ports", "caps", "stats", "Flags", "settings", "lag", "reads", "forces", "bits", "flag", "FLAG", "cycles", "parts", "mask", "fields", "options", "ins", "files", "ips", "pages"]}}
{"project": "qemu", "commit_id": "6cded3a43ad0044d9831590795d9c6cf0dc2d2ee", "target": 0, "func": "static void nic_selective_reset(EEPRO100State * s)\n\n{\n\n    size_t i;\n\n    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n\n    //~ eeprom93xx_reset(s->eeprom);\n\n    memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n\n    eeprom_contents[0xa] = 0x4000;\n\n    if (s->device == i82557B || s->device == i82557C)\n\n        eeprom_contents[5] = 0x0100;\n\n    uint16_t sum = 0;\n\n    for (i = 0; i < EEPROM_SIZE - 1; i++) {\n\n        sum += eeprom_contents[i];\n\n    }\n\n    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;\n\n    TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eeprom_contents[EEPROM_SIZE - 1]));\n\n\n\n    memset(s->mem, 0, sizeof(s->mem));\n\n    uint32_t val = BIT(21);\n\n    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n\n\n\n    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));\n\n    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));\n\n}\n", "idx": 21492, "substitutes": {"s": ["sb", "e", "sym", "qs", "es", "tests", "uns", "g", "ses", "fs", "xs", "your", "d", "sets", "ks", "ds", "services", "f", "t", "u", "r", "m", "args", "state", "ssl", "new", "p", "cs", "ts", "ls", "o", "sync", "is", "stats", "sites", "sg", "c", "js", "self", "spec", "sq", "si", "a", "b", "in", "w", "service", "aws", "n", "S", "ns", "sf", "south", "ps", "rs", "gs", "ins", "http", "secondary", "l", "ss", "states"], "i": ["io", "ix", "e", "fi", "qi", "ri", "y", "ui", "me", "key", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "pre", "u", "oi", "ini", "m", "r", "j", "data", "phi", "it", "info", "p", "ip", "abi", "id", "count", "bi", "o", "is", "mi", "q", "c", "mu", "index", "si", "a", "ii", "b", "ji", "n", "slice", "ai", "xi", "base", "di", "v", "z", "multi", "li", "pi", "x", "zi", "k", "ni", "type"], "eeprom_contents": ["eeprom_macants", "eeprom_scents", "eeprom_compants", "eeprom_descens", "eeprom_contentent", "eeprom_compENTS", "eeprom_extences", "eeprom_descents", "eeprom_scens", "eeprom_contENTS", "eeprom_macENTS", "eeprom_contentainers", "eeprom_scences", "eeprom_extents", "eeprom_constenses", "eeprom_contentENTS", "eeprom_contens", "eeprom_contentens", "eeprom_extants", "eeprom_compents", "eeprom_CONTents", "eeprom_contentents", "eeprom_content", "eeprom_contentenses", "eeprom_compences", "eeprom_CONTENTS", "eeprom_contences", "eeprom_descent", "eeprom_condences", "eeprom_constENTS", "eeprom_containers", "eeprom_condents", "eeprom_compent", "eeprom_CONTens", "eeprom_contants", "eeprom_constens", "eeprom_descences", "eeprom_contentences", "eeprom_constent", "eeprom_condENTS", "eeprom_scainers", "eeprom_compenses", "eeprom_constents", "eeprom_CONTainers", "eeprom_contenses", "eeprom_condens", "eeprom_macens", "eeprom_CONTants", "eeprom_macents", "eeprom_extent", "eeprom_CONTences", "eeprom_condent", "eeprom_contentants", "eeprom_constences", "eeprom_compens"]}}
{"project": "qemu", "commit_id": "0208def1cadd4f72f862e62548c2af268a543b20", "target": 1, "func": "void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n", "idx": 21508, "substitutes": {"dev": ["Dev", "reg", "priv", "cam", "def", "end", "conn", "app", "ref", "DEV", "driver", "de", "d", "pad", "bridge", "device", "info", "bug", "ad", "serial", "diff", "mod", "var", "plug", "module", "self", "pro", "dom", "ver", "ch", "rad", "w", "debug", "v", "bus", "param", "block", "ev", "pub"], "conf": ["bc", "def", "app", "config", "info", "bug", "aff", "ff", "comb", "v", "fam", "fi", "cap", "fab", "pub", "col", "conn", "coll", "sche", "ac", "enc", "rc", "c", "cb", "spec", "cfg", "pass", "vol", "cert", "ph", "prop", "sum", "conv", "lc", "cc", "uc", "ref", "err", "f", "cmp", "init", "cf", "inf", "comment", "loc", "co", "sec", "param", "count", "ang", "fac", "gu", "inc", "con", "ca", "cur", "cl", "cache", "dict", "sync", "py", "client", "ctx", "cn", "ch", "cal", "block", "um", "Conf"]}}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n", "idx": 21511, "substitutes": {"client": ["remote", "port", "public", "conn", "config", "project", "connection", "con", "pc", "node", "local", "cell", "cache", "ip", "cli", "c", "self", "child", "global", "parent", "util", "http", "resource", "server", "api", "command", "Client", "contract"], "start_addr": ["end_off", "start_hop", "start00off", "startedrange", "start_name", "start_off", "startedaddress", "startedaddr", "end_hop", "end_address", "start00address", "end_range", "start00addr", "end_name", "start_address", "startedhop", "start00name", "start_range"], "end_addr": ["start_hop", "start_arm", "end64hop", "end64addr", "end_hop", "end_address", "end_arm", "start_address", "end64arm", "end64address"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 21513, "substitutes": {"opaque": ["OPaque", "Opsa", "opaques", "opec", "Opque", "OPque", "OPaques", " opaques", "opsa", "optque", " opsa", "Opec", "OPec", " opque", "optaque", "OPsa", "Opaque", "opque", "optaques", " opec"], "addr": ["route", "port", "grad", "start", "conn", "ref", "adr", "asm", "amp", "arg", "mode", "oa", "ord", "rx", "afi", "amd", "pad", "host", "mt", "align", "node", "ea", "pos", "cmp", "alloc", "r", "address", "args", "data", "ad", "size", "ip", "ace", "point", "slot", "code", "dr", "rc", "ctx", "nr", "ar", "rt", " address", "ptr", "xp", "x", "arm", "seq", "alias", "src", "slice", "len", "alt", "sid", "pointer", "offset", "base"], "s": ["status", "ions", "port", "sb", "ums", "e", "outs", "sym", "aces", "es", "hs", "fs", "g", "ses", "rows", "als", "sets", "ds", "sys", "r", "m", "ssl", "os", "p", "ts", "cs", "ls", "o", "ss", "sg", "c", "opens", "ows", " streams", "a", "session", "S", "ps", "ins", "gs", "acks", "conf", "ies", "ips", "resses", "sq", "states", "ays"], "saddr": ["paddr", "faddr", "southhost", "ssrc", "pptr", "scall", " scall", "baddr", "sha", "pha", "faddress", "pcall", "asptr", "raddr", " snode", "rint", " sint", " saddress", "asaddress", "taddr", "phost", "raddress", " sptr", "snode", "baddress", "paddress", " sha", "isnode", "taddress", "sint", "saddress", "psrc", "fhost", "southsrc", "slayer", "tlayer", "asaddr", "fsrc", "pint", "isaddress", "southaddr", "islayer", "ascall", "rha", "shost", "bptr", "southaddress", "tnode", "sptr", "isaddr", " slayer"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    int i;\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    qemu_irq dma_irqs[6];\n\n    DriveInfo *dinfo;\n\n    SysBusDevice *busdev;\n\n\n\n    if (!core)\n\n        core = \"ti925t\";\n\n\n\n    /* Core */\n\n    s->mpu_model = omap310;\n\n    s->cpu = cpu_arm_init(core);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP15XX_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    memory_region_init_ram(&s->emiff_ram, NULL, \"omap1.dram\", s->sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->emiff_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_EMIFF_BASE, &s->emiff_ram);\n\n    memory_region_init_ram(&s->imif_ram, NULL, \"omap1.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->imif_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_IMIF_BASE, &s->imif_ram);\n\n\n\n    omap_clkm_init(system_memory, 0xfffece00, 0xe1008000, s);\n\n\n\n    s->ih[0] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[0], \"size\", 0x100);\n\n    qdev_prop_set_ptr(s->ih[0], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0xfffecb00);\n\n    s->ih[1] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[1], \"size\", 0x800);\n\n    qdev_prop_set_ptr(s->ih[1], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[1]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_15XX_IH2_IRQ));\n\n    /* The second interrupt controller's FIQ output is not wired up */\n\n    sysbus_mmio_map(busdev, 0, 0xfffe0000);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap1_dma_irq_map[i].ih],\n\n                                       omap1_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma_init(0xfffed800, dma_irqs, system_memory,\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_DMA_LCD),\n\n                           s, omap_findclk(s, \"dma_ck\"), omap_dma_3_1);\n\n\n\n    s->port[emiff    ].addr_valid = omap_validate_emiff_addr;\n\n    s->port[emifs    ].addr_valid = omap_validate_emifs_addr;\n\n    s->port[imif     ].addr_valid = omap_validate_imif_addr;\n\n    s->port[tipb     ].addr_valid = omap_validate_tipb_addr;\n\n    s->port[local    ].addr_valid = omap_validate_local_addr;\n\n    s->port[tipb_mpui].addr_valid = omap_validate_tipb_mpui_addr;\n\n\n\n    /* Register SDRAM and SRAM DMA ports for fast transfers.  */\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->emiff_ram),\n\n                         OMAP_EMIFF_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->imif_ram),\n\n                         OMAP_IMIF_BASE, s->sram_size);\n\n\n\n    s->timer[0] = omap_mpu_timer_init(system_memory, 0xfffec500,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER1),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[1] = omap_mpu_timer_init(system_memory, 0xfffec600,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER2),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[2] = omap_mpu_timer_init(system_memory, 0xfffec700,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER3),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n\n\n    s->wdt = omap_wd_timer_init(system_memory, 0xfffec800,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_WD_TIMER),\n\n                    omap_findclk(s, \"armwdt_ck\"));\n\n\n\n    s->os_timer = omap_os_timer_init(system_memory, 0xfffb9000,\n\n                    qdev_get_gpio_in(s->ih[1], OMAP_INT_OS_TIMER),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->lcd = omap_lcdc_init(system_memory, 0xfffec000,\n\n                            qdev_get_gpio_in(s->ih[0], OMAP_INT_LCD_CTRL),\n\n                            omap_dma_get_lcdch(s->dma),\n\n                            omap_findclk(s, \"lcd_ck\"));\n\n\n\n    omap_ulpd_pm_init(system_memory, 0xfffe0800, s);\n\n    omap_pin_cfg_init(system_memory, 0xfffe1000, s);\n\n    omap_id_init(system_memory, s);\n\n\n\n    omap_mpui_init(system_memory, 0xfffec900, s);\n\n\n\n    s->private_tipb = omap_tipb_bridge_init(system_memory, 0xfffeca00,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PRIV),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n    s->public_tipb = omap_tipb_bridge_init(system_memory, 0xfffed300,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PUB),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n\n\n    omap_tcmi_init(system_memory, 0xfffecc00, s);\n\n\n\n    s->uart[0] = omap_uart_init(0xfffb0000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART1),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    s->drq[OMAP_DMA_UART1_TX], s->drq[OMAP_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap_uart_init(0xfffb0800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART2),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    s->drq[OMAP_DMA_UART2_TX], s->drq[OMAP_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap_uart_init(0xfffb9800,\n\n                                qdev_get_gpio_in(s->ih[0], OMAP_INT_UART3),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    s->drq[OMAP_DMA_UART3_TX], s->drq[OMAP_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->dpll[0] = omap_dpll_init(system_memory, 0xfffecf00,\n\n                                omap_findclk(s, \"dpll1\"));\n\n    s->dpll[1] = omap_dpll_init(system_memory, 0xfffed000,\n\n                                omap_findclk(s, \"dpll2\"));\n\n    s->dpll[2] = omap_dpll_init(system_memory, 0xfffed100,\n\n                                omap_findclk(s, \"dpll3\"));\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap_mmc_init(0xfffb7800, system_memory,\n\n                           blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_OQN),\n\n                           &s->drq[OMAP_DMA_MMC_TX],\n\n                    omap_findclk(s, \"mmc_ck\"));\n\n\n\n    s->mpuio = omap_mpuio_init(system_memory, 0xfffb5000,\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_KEYBOARD),\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_MPUIO),\n\n                               s->wakeup, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"clk\", omap_findclk(s, \"arm_gpio_ck\"));\n\n    qdev_init_nofail(s->gpio);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->gpio), 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_GPIO_BANK1));\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s->gpio), 0, 0xfffce000);\n\n\n\n    s->microwire = omap_uwire_init(system_memory, 0xfffb3000,\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireTX),\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireRX),\n\n                    s->drq[OMAP_DMA_UWIRE_TX], omap_findclk(s, \"mpuper_ck\"));\n\n\n\n    s->pwl = omap_pwl_init(system_memory, 0xfffb5800,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n    s->pwt = omap_pwt_init(system_memory, 0xfffb6000,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x11);\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"mpuper_ck\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(s->ih[1], OMAP_INT_I2C));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP_DMA_I2C_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP_DMA_I2C_RX]);\n\n    sysbus_mmio_map(busdev, 0, 0xfffb3800);\n\n\n\n    s->rtc = omap_rtc_init(system_memory, 0xfffb4800,\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_TIMER),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_ALARM),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->mcbsp1 = omap_mcbsp_init(system_memory, 0xfffb1800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1RX),\n\n                    &s->drq[OMAP_DMA_MCBSP1_TX], omap_findclk(s, \"dspxor_ck\"));\n\n    s->mcbsp2 = omap_mcbsp_init(system_memory, 0xfffb1000,\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_TX),\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_RX),\n\n                    &s->drq[OMAP_DMA_MCBSP2_TX], omap_findclk(s, \"mpuper_ck\"));\n\n    s->mcbsp3 = omap_mcbsp_init(system_memory, 0xfffb7000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3RX),\n\n                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, \"dspxor_ck\"));\n\n\n\n    s->led[0] = omap_lpg_init(system_memory,\n\n                              0xfffbd000, omap_findclk(s, \"clk32-kHz\"));\n\n    s->led[1] = omap_lpg_init(system_memory,\n\n                              0xfffbd800, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    /* Register mappings not currenlty implemented:\n\n     * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310)\n\n     * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310)\n\n     * USB W2FC\t\tfffb4000 - fffb47ff\n\n     * Camera Interface\tfffb6800 - fffb6fff\n\n     * USB Host\t\tfffba000 - fffba7ff\n\n     * FAC\t\tfffba800 - fffbafff\n\n     * HDQ/1-Wire\tfffbc000 - fffbc7ff\n\n     * TIPB switches\tfffbc800 - fffbcfff\n\n     * Mailbox\t\tfffcf000 - fffcf7ff\n\n     * Local bus IF\tfffec100 - fffec1ff\n\n     * Local bus MMU\tfffec200 - fffec2ff\n\n     * DSP MMU\t\tfffed200 - fffed2ff\n\n     */\n\n\n\n    omap_setup_dsp_mapping(system_memory, omap15xx_dsp_mm);\n\n    omap_setup_mpui_io(system_memory, s);\n\n\n\n    qemu_register_reset(omap1_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 21538, "substitutes": {"system_memory": ["sys_memory", " system_message", "system_message", "get_queue", "system_queue", " system_mem", " system_machine", "system_program", "system_machine", "system_modules", "native_machine", "system_mem", "native_modules", "get_memory", "sys_network", "get_storage", "native_program", "system_reference", "get_audio", "system_storage", "sys_mem", "native_memory", "system_audio", "system_network", "sys_reference"], "sdram_size": ["sdramsscale", "sdmem_mode", "sdcam_address", "sdcam_Size", "sdmem_name", "sdcam_ui", "sdram_ui", "sdgram_scale", "sdram2len", "sdmem_weight", "sdram_weight", "sdram_sized", "sdgram_size", "sdram_address", "sdramsmode", "sdram2size", "sdcam_size", "sdgram_mode", "sdcam_sized", "sdram_name", "sdram_len", "sdcam_name", "sdram_Size", "sdramssize", "sdcam2len", "sdcam2size", "sdmem_size", "sdram_mode", "sdcam2Size", "sdcam_len", "sdram2name", "sdcam2name", "sdram2Size", "sdram_scale"], "core": ["lc", "col", "chrome", "functional", "name", "binary", "support", "fine", "category", "cor", "force", "ore", "mode", "cm", "framework", "con", "feature", "processor", "node", "function", " Core", "path", "ync", "ro", "custom", "cp", "cat", "rest", "cache", "common", "respect", "score", "component", "cycle", "code", "year", " cores", "sync", "rc", "c", "arch", "six", "ext", "cn", "cpu", "Core", "ores", "cy", "python", "wheel", "cr", "chip", "ignore", "ce", "scope", "base", "primary", "type"], "i": ["io", "e", "d", "I", "l", "f", "r", "j", "p", "ip", "id", "count", "is", "rc", "c", "index", "si", "a", "b", "ii", "counter", "n", "xi", "z", "pi", "base", "k", "type"], "s": ["es", "sample", "uns", "xs", "ds", "sys", "y", "r", "j", "ssl", "os", "ts", "cs", "us", "params", "stats", "js", "aws", "n", "S", "ns", "details", "rs", "conf", "l", "ss", "this", "sb", "security", "g", "ses", "d", "sets", "site", "services", "u", "state", "o", "sg", "c", "self", "spec", "sc", "a", "sf", "options", "scope", "su", "native", "e", "sym", "qs", "fs", "f", "t", "new", "p", "si", "b", "service", "ps", "gs", "secondary", "sq", "sl", "ks", "m", "args", "its", "storage", "ls", "sync", "is", "sa", "settings", "w", "se", "session", "south", "server", "states"], "dma_irqs": ["dma_mircs", "dma_ireq", "dma_rinq", "dma_ireqq", "dma_rinqs", "dma_ircs", "dma_irq", "dma_mirqs", "dma_irecs", "dma_mirq", "dma_irqq", "dma_ireqs", "dma_rinqq", "dma_mirqq", "dma_rincs"], "dinfo": ["bdid", " dfo", "bdinfo", "vdfo", "bdfi", "vdfi", " dfi", "vdinfo", "bdfo", " did", "vdid", "did", "dfo", "dfi"], "busdev": ["ckDev", "busdevice", "buscam", "Buscam", "ckdevice", "ckcam", " busdevice", "Busdev", "BusDev", " buscam", " busDev", "Busdevice", "ckdev", "busDev"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_client_close(NBDClient *client)\n\n{\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    client->closing = true;\n\n\n\n    /* Force requests to finish.  They will drop their own references,\n\n     * then we'll close the socket and free the NBDClient.\n\n     */\n\n    shutdown(client->sock, 2);\n\n\n\n    /* Also tell the client, so that they release their reference.  */\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n}\n", "idx": 21549, "substitutes": {"client": ["remote", "request", "public", "port", "name", "google", "connect", "end", "conn", "app", "object", "config", "event", "project", "container", "cookie", "connection", "consumer", "cm", "null", "con", "handler", "plugin", "pc", "host", "cl", "product", "local", "cell", "secure", "node", "custom", "cmd", "php", "cp", "socket", "cache", "patch", "ssl", "current", "cli", "open", "content", "close", "friend", "c", "self", "service", "core", "channel", "session", "call", "child", "clean", "parent", "lib", "http", "ce", "manager", "resource", "cod", "image", "server", "protected", "api", "command", "Client", "contract"]}}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,\n\n                             bool *again, ram_addr_t *ram_addr_abs)\n\n{\n\n    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,\n\n                                              ram_addr_abs);\n\n    if (pss->complete_round && pss->block == rs->last_seen_block &&\n\n        pss->offset >= rs->last_offset) {\n\n        /*\n\n         * We've been once around the RAM and haven't found anything.\n\n         * Give up.\n\n         */\n\n        *again = false;\n\n        return false;\n\n    }\n\n    if (pss->offset >= pss->block->used_length) {\n\n        /* Didn't find anything in this RAM Block */\n\n        pss->offset = 0;\n\n        pss->block = QLIST_NEXT_RCU(pss->block, next);\n\n        if (!pss->block) {\n\n            /* Hit the end of the list */\n\n            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n            /* Flag that we've looped */\n\n            pss->complete_round = true;\n\n            rs->ram_bulk_stage = false;\n\n            if (migrate_use_xbzrle()) {\n\n                /* If xbzrle is on, stop using the data compression at this\n\n                 * point. In theory, xbzrle can do better than compression.\n\n                 */\n\n                flush_compressed_data(rs);\n\n            }\n\n        }\n\n        /* Didn't find anything this time, but try again on the new block */\n\n        *again = true;\n\n        return false;\n\n    } else {\n\n        /* Can go around again, but... */\n\n        *again = true;\n\n        /* We've found something so probably don't need to */\n\n        return true;\n\n    }\n\n}\n", "idx": 21567, "substitutes": {"rs": ["ras", "vers", "rd", "qs", "sl", "rics", "rows", "rys", "RS", "xs", "ack", "rates", "nas", "ks", "ds", "sys", "r", "ris", "ros", "ares", "res", "s", "args", "ys", "vs", "ts", "cs", "params", "ls", "stats", "rc", "dr", "ges", "arch", "spec", "sr", "rt", "hr", "pres", "Rs", "ims", "src", "ns", "rss", "mr", "ps", "ins", "acks", "gs", "rb", "ars", "ss", "rg"], "pss": [" pass", "rass", "apds", "prs", "jpcss", "psiss", "dss", "dSS", "rds", "psl", "pSS", "Pds", " pose", "pws", "foss", "opws", "wpds", "apss", "cpds", "Psl", " piss", "copcss", "mrs", "mts", "dws", "jcss", "wpSS", "apcss", "pts", "copds", "mss", "Pss", "jiss", "opess", "pess", "Poss", " pess", "cpss", " psc", "piss", "cpass", "opds", "pass", "dds", "fiss", "jsc", "cpess", " psl", "opiss", "copss", "pcss", "Pts", "Pose", "ress", "jpss", " pws", "Pcss", "pds", "fess", "Psc", "copess", "frs", "fss", "apass", "psoss", " pcss", "pose", " prs", " pSS", "joss", "fcss", " pds", "poss", "psose", "dcss", "cpcss", "jpds", "jposs", "psc", " poss", "wpcss", "pssl", "wpss", " pts", "mds", "jds", "wpess", "wpiss", "opcss", "Piss", "opss", "psss", "rss", "jpess", "Pess", "Prs", "jss"], "again": ["confirmed", "member", "after", "though", "only", "external", "outs", "nin", "asm", "ahead", "another", "option", "asc", "until", "an", "inc", "stall", "average", "unc", "extra", "account", "stay", "Again", "every", "standard", "login", "addon", "size", "even", "new", "abc", "ains", "success", "out", "later", "destroy", "advert", "outside", "second", "say", "into", "anon", "always", "inas", "also", "each", "ain", "since", "except", "great", "away", "illegal", "blank", "this"], "ram_addr_abs": ["ram_addr_ab", "ram_address_tab", "ram_address_abs", "ram_address_rel", "ram_address_int", "ram_addr_int", "ram_addr_ref", "ram_address_ab", "ram_addr_rel", "ram_addr_tab", "ram_address_ref"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n", "idx": 21569, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)\n\n{\n\n    Wmv2Context *const w = (Wmv2Context *) s;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (w->j_type_bit)\n\n            w->j_type = get_bits1(&s->gb);\n\n        else\n\n            w->j_type = 0; // FIXME check\n\n\n\n        if (!w->j_type) {\n\n            if (w->per_mb_rl_bit)\n\n                s->per_mb_rl_table = get_bits1(&s->gb);\n\n            else\n\n                s->per_mb_rl_table = 0;\n\n\n\n            if (!s->per_mb_rl_table) {\n\n                s->rl_chroma_table_index = decode012(&s->gb);\n\n                s->rl_table_index        = decode012(&s->gb);\n\n            }\n\n\n\n            s->dc_table_index = get_bits1(&s->gb);\n\n        }\n\n        s->inter_intra_pred = 0;\n\n        s->no_rounding      = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \\n\",\n\n                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,\n\n                   s->dc_table_index, s->per_mb_rl_table, w->j_type);\n\n        }\n\n    } else {\n\n        int cbp_index;\n\n        w->j_type = 0;\n\n\n\n        parse_mb_skip(w);\n\n        cbp_index = decode012(&s->gb);\n\n        if (s->qscale <= 10) {\n\n            int map[3]         = { 0, 2, 1 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else if (s->qscale <= 20) {\n\n            int map[3]         = { 1, 0, 2 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else {\n\n            int map[3]         = {2,1,0};\n\n            w->cbp_table_index = map[cbp_index];\n\n        }\n\n\n\n        if (w->mspel_bit)\n\n            s->mspel = get_bits1(&s->gb);\n\n        else\n\n            s->mspel = 0; // FIXME check\n\n\n\n        if (w->abt_flag) {\n\n            w->per_mb_abt = get_bits1(&s->gb) ^ 1;\n\n            if (!w->per_mb_abt)\n\n                w->abt_type = decode012(&s->gb);\n\n        }\n\n\n\n        if (w->per_mb_rl_bit)\n\n            s->per_mb_rl_table = get_bits1(&s->gb);\n\n        else\n\n            s->per_mb_rl_table = 0;\n\n\n\n        if (!s->per_mb_rl_table) {\n\n            s->rl_table_index        = decode012(&s->gb);\n\n            s->rl_chroma_table_index = s->rl_table_index;\n\n        }\n\n\n\n        s->dc_table_index   = get_bits1(&s->gb);\n\n        s->mv_table_index   = get_bits1(&s->gb);\n\n\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n\n        s->no_rounding     ^= 1;\n\n\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n\n                   s->rl_table_index, s->rl_chroma_table_index,\n\n                   s->dc_table_index, s->mv_table_index,\n\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n\n                   s->inter_intra_pred);\n\n        }\n\n    }\n\n    s->esc3_level_length = 0;\n\n    s->esc3_run_length   = 0;\n\n    s->picture_number++; // FIXME ?\n\n\n\n    if (w->j_type) {\n\n        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);\n\n\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21576, "substitutes": {"s": ["i", "es", "xs", "ds", "sys", "y", "r", "ssl", "os", "ts", "cs", "us", "params", "stats", "js", "aws", "ms", "n", "S", "ns", "rs", "ins", "v", "conf", "http", "l", "this", "ss", "request", "sb", "g", "ses", "d", "sets", "site", "as", "services", "u", "o", "sg", "c", "self", "spec", "sc", "sf", "k", "native", "e", "sym", "qs", "fs", "f", "t", "new", "p", "si", "b", "service", "ims", "parts", "sw", "words", "ps", "gs", "h", "sq", "sl", "features", "ops", "ks", "m", "its", "args", "storage", "ls", "sync", "is", "settings", "se", "session", "comments", "south"], "w": ["es", "wa", "wave", "win", "y", "data", "wh", "os", "work", "rw", "wb", "iw", "window", "aws", "ms", "n", "ns", "fw", "wx", "v", "conf", "l", "wcs", "ow", "g", "d", "as", "wo", "u", "war", "web", "aw", "o", "q", "c", "self", "wp", "a", "k", "e", "ess", "wal", "fs", "way", "f", "t", "new", "p", "we", "W", "nw", "wt", "b", "wan", "sw", "words", "gs", "z", "hw", "h", "wl", "x", "writer", "wr", "ww", "cl", "m", "word", "sh", "WS", "tw", "kw", " W"], "cbp_index": ["cbp64slice", "cbc_id", "cbp67weight", "cbp_point", "cbc_index", "cbP_index", "cbp_address", "cbp_Index", "cbp_type", "cbp_key", "cbP_Index", "cbp_input", "cbP_ind", "cbn_type", "cbp67Index", "cbp_weight", "cbc_input", "cbn_key", "cbp64index", "cbpdbaddress", "cbpdbweight", "cbp_id", "cbn_index", "cbpdbid", "cbn_id", "cbP_id", "cbp_length", "cbp_ind", "cbpdbindex", "cbp67input", "cbp67index", "cbc_weight", "cbp_slice", "cbc_address", "cbp64point", "cbp64length", "cbc_Index"], "map": ["view", "shape", "table", "ap", "app", "config", "store", "maps", "file", "share", "copy", "pad", "wave", "model", "one", "pre", "master", "use", "m", "Map", "address", "cache", "msg", "size", "shared", "lock", "arr", "list", "wise", "dict", "open", "gen", "module", "complete", "match", "mem", "set", "hash", "mask", "pair", "comb", "batch", "array", "MAP", "group", "grid", "stream", "block", "cover", "pack", "scope", "image", "cap"]}}
{"project": "FFmpeg", "commit_id": "a494792961a08f9f0e47e7eeed65e609178ff436", "target": 1, "func": "static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n", "idx": 21583, "substitutes": {"table": ["stable", "col", "view", "binary", "query", "object", "result", "input", "tree", "Table", "file", "interface", "column", "buffer", "model", "section", "pre", "tab", "address", "round", "cache", "code", "body", "comment", "out", "module", "index", "source", "window", "rule", "element", "page", "test", "array", "image", "block", "bar", "TABLE", "count"], "elemsize": ["Elemmize", "Elemmized", "eleapsize", "elekesizes", "elmsizes", "elksize", "elemsIZE", "elmsIZE", "elekesize", "elemmiz", "elkssize", "elmsize", "Elemmizing", "elemesIZE", "Elemsize", "elekesized", "elemmize", "eleksiz", "elemesiz", "elekesizing", "elksizes", "elemersize", "elmessize", "elemmsize", "elemsized", "eleksize", "elmesIZE", "eleapsized", "elmesiz", "elekssize", "elemmIZE", "elksiz", "elemerssize", "elemsiz", "elemersiz", "elemsizes", "elemmizing", "Elemsizes", "eleapsizing", "elmssize", "elemssize", "eleapsizes", "elmsiz", "elmesize", "Elemmizes", "elemmized", "elemessize", "elemersizes", "eleksizes", "Elemsized", "elemsizing", "elemmizes", "Elemsizing", "elemesize", "eleksIZE", "elemesizes"], "inc": ["bc", "fc", "shape", "cc", "level", "ind", "config", "include", "input", "extra", "margin", "rec", "pc", "acc", "Inc", "ini", "ac", "nc", "amin", "enc", "inf", "mc", "frac", "abc", "rc", "c", "index", "pin", "fr", "inn", "in", "pull", "dc", "ii", "seq", "length", "imp", "page", "iter", "ins", "alpha", "up", "INC", "incre", "ec"], "y_tab": ["y_lab", "my_bag", "y__table", "my_struct", "y_bag", "y__tab", "y__bag", "y__struct", "y_struct", "my_table", "my_lab", "my_tab"], "i": ["io", "e", "ix", "start", "qi", "jp", "ri", "ui", "mini", "pi", "key", "gi", "uri", "ti", "I", "f", "ci", "t", "u", "oi", "m", "ini", "phi", "j", "it", "s", "ip", "p", "abi", "id", "o", "bi", "mi", "c", "mu", "index", "si", "a", "ii", "b", "ji", "in", "n", "iu", "ai", "xi", "di", "v", "z", "multi", "li", "h", "l", "x", "zi", "k", "ni"], "y_table": ["yactable", "y6session", "y_file", "my_db", "y6table", "y_count", "y___db", "yacfile", " y_session", "my_file", "y_session", "y_db", "y6tab", "y6db", " y_db", "my_table", "y___session", "yacdb", "yactab", "y___tab", "y___table", "y_TABLE", "my_TABLE", "my_count", "my_tab"]}}
{"project": "FFmpeg", "commit_id": "f3e5a7844bbf13620ca4b6a5e19aa087c9141b15", "target": 0, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 21584, "substitutes": {"alac": ["alsacs", "beloc", "maluc", "elec", "calacc", "malacs", "alsc", "alloc", " alec", "allAC", "altacc", "alunc", "calanc", "plmac", "alacs", "elacl", "altac", "elacc", "elac", "altc", "palAC", "ploc", "ilanc", "palmac", " alacs", "allc", "pliac", " alacl", "ALac", "elmac", "alsac", "elax", "aliacc", "plac", "belmac", "paliac", "almac", " aliac", "ALoc", "alsacc", "calac", "pluc", " alacc", "allacs", "malac", "aliec", "placs", "alc", "elacs", "alAC", " alunc", "alec", " alc", "maloc", "ilacc", "allacc", "alic", " alax", "alacc", "elAC", "alax", "ALAC", "malunc", "aluc", "ilacs", " aloc", " alAC", "aloc", "calacs", "plAC", "aliac", "alanc", "alacl", " almac", "belac", "allac", " alanc", "palac", "altacl", "elc", "malc", "eloc", "eluc", "elunc", "ilac", "ALacs", "belax"], "ch": ["cha", "col", "sch", "i", "och", "chn", "sk", "conn", "ach", "ct", "mot", "jp", "err", "cor", "hop", "chan", "ich", "cm", "cry", "anch", "chi", "Ch", "che", "cur", "cl", "f", "y", "cp", "oy", "j", "cht", "p", "CH", "enc", "change", "code", "work", "q", "client", "c", "el", "arch", "ctx", "ver", "cho", "cham", "b", "comp", "cy", "channel", "child", "length", "zh", "pol", "gr", "chip", "gh", "batch", "cher", "ech", "conf", "bh", "chrom", "h", "l", "x", "k", "count"]}}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static int put_cod(Jpeg2000EncoderContext *s)\n\n{\n\n    Jpeg2000CodingStyle *codsty = &s->codsty;\n\n\n\n    if (s->buf_end - s->buf < 14)\n\n        return -1;\n\n\n\n    bytestream_put_be16(&s->buf, JPEG2000_COD);\n\n    bytestream_put_be16(&s->buf, 12); // Lcod\n\n    bytestream_put_byte(&s->buf, 0);  // Scod\n\n    // SGcod\n\n    bytestream_put_byte(&s->buf, 0); // progression level\n\n    bytestream_put_be16(&s->buf, 1); // num of layers\n\n    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){\n\n        bytestream_put_byte(&s->buf, 2); // ICT\n\n    }else{\n\n        bytestream_put_byte(&s->buf, 0); // unspecified\n\n    }\n\n    // SPcod\n\n    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height\n\n    bytestream_put_byte(&s->buf, 0); // cblk style\n\n    bytestream_put_byte(&s->buf, codsty->transform); // transformation\n\n    return 0;\n\n}\n", "idx": 21585, "substitutes": {"s": ["sv", "i", "sb", "e", "sym", "qs", "es", "fs", "g", "ses", "this", "xs", "als", "d", "sets", "site", "ks", "as", "ds", "services", "l", "f", "sys", "t", "u", "m", "its", "args", "os", "ssl", "p", "cs", "ts", "vs", "ls", "o", "sync", "is", "us", "sg", "c", "js", "self", "spec", "settings", "sq", "si", "ads", "a", "b", "in", "service", "aws", "ms", "has", "session", "S", "ns", "sup", "new", "sf", "side", "ps", "rs", "gs", "v", "conf", "su", "x", "ss"], "codsty": ["cdsty", "codesy", "Codsty", "codesty", " codpty", "ancsy", "codgy", "cmdrt", "codst", "odpty", "camsty", "ancsty", " codstyle", "cdsy", "czety", "codestyle", "odstyle", "pedst", "cdpty", "typgly", "codty", "pedty", "odgly", "Codty", "codost", " codty", "odsy", "Codst", "codstyle", "typsty", "typstyle", "cmdsty", "odty", " codsy", "typsta", " codsta", "czst", "ldgy", "cdgy", "camty", "camrt", "ldsty", "Codrt", " codgy", "cmdty", "codegy", "codsta", "ancty", "pedety", "czty", "odsta", "ldstyle", " codgly", "odgy", " codst", "odsty", "Codost", "codety", "codsy", "codrt", "ancst", "Codety", "cmdost", "codgly", "ldty", "codest", "camost", "czsty", "codpty", "pedsty"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "substitutes": {"mr": ["ru", "err", "adr", "Mr", "rpm", "rr", "tr", "yr", "rf", "lr", "pc", "r", "m", "mc", "rh", "dr", "rc", "nr", "rm", "fr", "rar", "sr", "rl", "vr", "rt", "hr", "usr", "fm", "cr", "er", "bm", "reader", "br", "req", "rs", "manager", "vm", "kr", "rb", "tm", "ir", "MR", "mn", "rg"], "addr": ["conn", "ref", "adr", "hop", "amp", "part", "val", "kt", "mode", "oa", "ord", "wd", "align", "host", "node", "layer", "address", "ip", "enc", "id", "ace", "prefix", "mac", "ext", "dr", "index", "nr", "edge", "rt", "ptr", "src", "slice", "base", "offset", "x", "attr", "inter", "url"], "size": ["name", "security", "shape", "iz", "esc", "en", "scale", "eni", "sized", "Size", "style", "ize", "ish", "address", "use", "storage", "grow", "gz", "six", "small", "si", "len", "z", "sec", "from", "SIZE", "empty", "offset", "max", "count"], "client": ["remote", "sim", "public", "external", "conn", "wrapper", "gray", "config", "progress", "cm", "connection", "null", "pc", "local", "cell", "buffer", "ian", "standard", "box", "cache", "mac", "cli", "close", "ctx", "self", "window", "worker", "child", "ients", "clean", "global", "parent", "lib", "util", "ce", "resource", "server", "this", "Client"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n    int ret;\n\n\n\n    ret = bdrv_get_info(bs, &bdi);\n\n    if (ret < 0 || bdi.cluster_size == 0) {\n\n        return bs->request_alignment;\n\n    } else {\n\n        return bdi.cluster_size;\n\n    }\n\n}\n", "idx": 21622, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "lb", "bis", "fs", "ses", "ubs", "xs", "db", "als", "fb", "bb", "ks", "bid", "ds", "bes", "css", "s", "bas", "its", "state", "os", "vs", "cs", "ts", "ls", "bps", "js", "b", "blocks", "ns", "BS", "iss", "Bs", "ps", "gs", "rs", "banks", "ins", "rb", "base", "ss", "las"], "bdi": ["abti", "obadi", "abadi", "abdi", "bci", "bbti", "bda", " bsi", "abdc", "obci", "bbdi", "bbni", "pci", "bti", " bti", "bni", "bbda", "bdc", " bDI", "brdi", "abDI", "pdi", "pdc", "abni", " bci", " bda", "obdi", " badi", "brci", "bbci", "pni", "brsi", "bsi", "bDI", "brda", "abci", "bbsi", "obti", " bdc", " bni", "badi", "bbDI"], "ret": ["nat", "obj", "ref", "gt", "ct", "xt", "end", "std", "result", "val", "ber", "ft", "det", "Ret", "mt", "ben", "no", "bit", "res", "cat", "j", "opt", "code", "fun", "success", "af", "out", "ext", "num", "et", "match", "pass", "RET", "rt", " Ret", "sr", "rl", "flag", "re", "pat", "desc", "len", "iter", "back", "alt", "nt", "att", "pt", "rets"]}}
{"project": "FFmpeg", "commit_id": "40cf1bbacc6220a0aa6bed5c331871d43f9ce370", "target": 0, "func": "static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                        const AVFrame *frame, int *got_packet)\n\n{\n\n    int enc_size = 0;\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroEncoder *encoder = p_schro_params->encoder;\n\n    struct FFSchroEncodedFrame *p_frame_output = NULL;\n\n    int go = 1;\n\n    SchroBuffer *enc_buf;\n\n    int presentation_frame;\n\n    int parse_code;\n\n    int last_frame_in_sequence = 0;\n\n    int pkt_size, ret;\n\n\n\n    if (!frame) {\n\n        /* Push end of sequence if not already signalled. */\n\n        if (!p_schro_params->eos_signalled) {\n\n            schro_encoder_end_of_stream(encoder);\n\n            p_schro_params->eos_signalled = 1;\n\n        }\n\n    } else {\n\n        /* Allocate frame data to schro input buffer. */\n\n        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);\n\n        if (!in_frame)\n\n            return AVERROR(ENOMEM);\n\n        /* Load next frame. */\n\n        schro_encoder_push_frame(encoder, in_frame);\n\n    }\n\n\n\n    if (p_schro_params->eos_pulled)\n\n        go = 0;\n\n\n\n    /* Now check to see if we have any output from the encoder. */\n\n    while (go) {\n\n        int err;\n\n        SchroStateEnum state;\n\n        state = schro_encoder_wait(encoder);\n\n        switch (state) {\n\n        case SCHRO_STATE_HAVE_BUFFER:\n\n        case SCHRO_STATE_END_OF_STREAM:\n\n            enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n\n            if (enc_buf->length <= 0)\n\n                return AVERROR_BUG;\n\n            parse_code = enc_buf->data[4];\n\n\n\n            /* All non-frame data is prepended to actual frame data to\n\n             * be able to set the pts correctly. So we don't write data\n\n             * to the frame output queue until we actually have a frame\n\n             */\n\n            if ((err = av_reallocp(&p_schro_params->enc_buf,\n\n                                   p_schro_params->enc_buf_size +\n\n                                   enc_buf->length)) < 0) {\n\n                p_schro_params->enc_buf_size = 0;\n\n                return err;\n\n            }\n\n\n\n            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n\n                   enc_buf->data, enc_buf->length);\n\n            p_schro_params->enc_buf_size += enc_buf->length;\n\n\n\n\n\n            if (state == SCHRO_STATE_END_OF_STREAM) {\n\n                p_schro_params->eos_pulled = 1;\n\n                go = 0;\n\n            }\n\n\n\n            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {\n\n                schro_buffer_unref(enc_buf);\n\n                break;\n\n            }\n\n\n\n            /* Create output frame. */\n\n            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));\n\n            if (!p_frame_output)\n\n                return AVERROR(ENOMEM);\n\n            /* Set output data. */\n\n            p_frame_output->size     = p_schro_params->enc_buf_size;\n\n            p_frame_output->p_encbuf = p_schro_params->enc_buf;\n\n            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&\n\n                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))\n\n                p_frame_output->key_frame = 1;\n\n\n\n            /* Parse the coded frame number from the bitstream. Bytes 14\n\n             * through 17 represesent the frame number. */\n\n            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n\n\n\n            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,\n\n                                     p_frame_output);\n\n            p_schro_params->enc_buf_size = 0;\n\n            p_schro_params->enc_buf      = NULL;\n\n\n\n            schro_buffer_unref(enc_buf);\n\n\n\n            break;\n\n\n\n        case SCHRO_STATE_NEED_FRAME:\n\n            go = 0;\n\n            break;\n\n\n\n        case SCHRO_STATE_AGAIN:\n\n            break;\n\n\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown Schro Encoder state\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* Copy 'next' frame in queue. */\n\n\n\n    if (p_schro_params->enc_frame_queue.size == 1 &&\n\n        p_schro_params->eos_pulled)\n\n        last_frame_in_sequence = 1;\n\n\n\n    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);\n\n\n\n    if (!p_frame_output)\n\n        return 0;\n\n\n\n    pkt_size = p_frame_output->size;\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n\n        pkt_size += p_schro_params->enc_buf_size;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", pkt_size);\n\n        goto error;\n\n    }\n\n\n\n    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n\n    avctx->coded_frame->key_frame = p_frame_output->key_frame;\n\n    /* Use the frame number of the encoded frame as the pts. It is OK to\n\n     * do so since Dirac is a constant frame rate codec. It expects input\n\n     * to be of constant frame rate. */\n\n    pkt->pts =\n\n    avctx->coded_frame->pts = p_frame_output->frame_num;\n\n    pkt->dts = p_schro_params->dts++;\n\n    enc_size = p_frame_output->size;\n\n\n\n    /* Append the end of sequence information to the last frame in the\n\n     * sequence. */\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n\n        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n\n               p_schro_params->enc_buf_size);\n\n        enc_size += p_schro_params->enc_buf_size;\n\n        av_freep(&p_schro_params->enc_buf);\n\n        p_schro_params->enc_buf_size = 0;\n\n    }\n\n\n\n    if (p_frame_output->key_frame)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nerror:\n\n    /* free frame */\n\n    libschroedinger_free_frame(p_frame_output);\n\n    return ret;\n\n}\n", "idx": 21641, "substitutes": {"avctx": ["avcam", "afcoll", "awcontext", "avecoll", "avecca", "AVcmd", " avcoll", "avecam", "afcam", "awcfg", "avcca", "avconn", "afcmd", "afctx", "AVcontext", "avcoll", "awconn", "avecfg", "avecontext", "awctx", "avcontext", "avcfg", "AVconn", "avectx", "avcmd", "afcontext", "AVctx", " avcam", "afconn", "afcca", " avcontext", "afcfg", "awcmd", "awcca"], "pkt": ["Packet", "cpet", " pct", " packet", "Pct", " pet", "pct", "Pkt", "packet", "pet", "Pet", "cpkt", "cpct", "cpacket"], "frame": ["row", "e", "iframe", "object", "config", "event", "none", "part", "kt", "framework", "fb", "file", "feature", "process", "node", "function", "f", "buffer", "fake", "motion", " Frame", "data", "zip", "component", "setup", "code", "fe", "fr", "frames", "cfg", "dom", "module", "document", "window", "rame", "seq", "channel", "call", "slice", "flow", "element", "game", "base", "Frame", "range", "fram", "image", "block", "position", "fi"], "got_packet": ["got2compacket", "got2packacket", "got_packsET", "got2packet", "got_compet", "got_compacket", "got2competer", "got_octET", "got_octeter", "got2compet", "got_packset", "got_packET", "got2packET", "got_packsacket", "got_octacket", "got_packeter", "got_packacket", "got_compET", "got2compET", "got2packeter", "got_packseter", "got_octet", "got_competer"], "p_schro_params": ["p_schrob_remote", "p_schro5resources", "p_schroPDchanges", "p_schrotparam", "p_schros_resources", "p_schrosparams", "p_schro__manager", "p_schoreappparam", "p_schro2params", "p_schro2manager", "p_schroappmanager", "p_schrotparams", "p_Sch\n", "p_schros_params", "p_schro5args", "p_schro2param", "p_schrob_param", "p_schrob_params", "p_schoreappsource", "p_schroPDparams", "p_schro_ams", "p_schroapprequest", "p_schro_args", "p_schro_changes", "p_schoreappparams", "p_schroPDrequest", "p_schore_source", "p_ch\n", "p_schroappphys", "p_schro__settings", "p_schore_phys", "p_schro__param", "p_schore_params", "p_sch\n", "p_schro5params", "p_schro5manager", "p_schro_source", "p_schro_remote", "p_schrob_manager", "p_schros_connection", "p_schroappremote", "p_schros_args", "p_schro_data", "p_schrosresources", "p_schrob_ams", "p_schros_manager", "p_schroappsource", "p_schro__params", "p_schros_settings", "p_schro_resources", "p_schrosparam", "p_schro_param", "p_schros_request", "p_schro2ams", "p_schroappparams", "p_schrotmanager", "p_schroappparam", "p_schrob_resources", "p_schoreappphys", "p_schrotconnection", "p_schros_param", "p_schro_settings", "p_schore_param", "p_schro_phys", "p_schro_request", "p_schrossettings", "p_schro_connection", "p_sche\n", "p_schroappchanges", "p_schro_manager", "p_schros_changes", "p_schrob_data", "p_schroPDmanager"], "encoder": ["engoder", "ecode", "encader", "incoser", " encoster", "enryption", " encoded", "ecoder", "decader", "encoding", "engoding", "encator", "engoded", "incator", "enoder", "enoding", "enader", "enler", "enater", "decoding", "engader", "encoster", " encode", "encler", "encode", " encoding", "encoser", "encater", "enoser", "incoding", "ecator", "enator", "engode", "incoder", "ecler", "decler", "enode", "engoster", "ecoser", "encoded", "enoded", "decoded", " encryption", "decoder", "encryption", "decator", "ecoded", "ecoding", " encater", "engryption", " encator", "decode", "decoster", "engater"], "p_frame_output": ["p_frame_input", "p_fram_full", "p_fram_output", "p_frame_data", "p_fram_input", "p_fram_data", "p_frame_full"], "enc_buf": ["enc_window", "enc__data", "enc_uf", " enc_uf", "enc_config", "encxbuff", "encJqueue", "ec_buffer", "enc_box", "en_cb", "enc_vec", " enc_buff", "ec_buf", "encJheader", "en_buf", "enc__buffer", "enc_bag", "pc_buf", "en_uf", "en_buff", "enc_db", " enc_func", "encswindow", "enc2uf", " enc_db", "enc2cb", "encxconfig", "encxbuf", "encscb", "enc_queue", "encxdata", "pc_cb", "enc_buffer", " enc_config", "ec_queue", "encsbuf", "enc2buf", " enc_bag", "enc_buff", "pc_vec", " enc_box", "encsvec", "enc__buff", "ec_data", " enc_data", "ec_bag", "encJdata", "enc__buf", "enc_func", "enc__uf", "enc__bag", "ec_header", "enc_cb", "pc_window", "enc_data", "enc_header", "enc2buff", "encJbuf", " enc_cb", " enc_buffer"], "presentation_frame": ["presentation_fram", "presentation_sequence", "presentational_frames", "presentationamFrame", "presentationamnode", "presentationamframe", "presentational_sequence", "presentational_node", "presentational_Frame", "presentational_frame", "presentation_node", "presentational_fram", "presentation_frames", "presentation_Frame", "presentationamframes"], "parse_code": ["parse_codes", "parse2code", "parse2tag", "parseableinfo", " parse_data", "parserablecount", "parse_tag", "parse2codes", "parse_queue", "parseablecount", " parse_tag", "parse_count", "parserablecode", "parse___code", "parserablequeue", " parse2code", "parseablecode", " parse2tag", "parser_code", "parserableinfo", "parseablequeue", "parse_info", "parse___count", "parse_data", "parser_info", "parse___queue", "parser_queue", "parse___info", "parser_count", " parse_codes", "parse2data", " parse2data", " parse2codes"], "pkt_size": ["pet_name", "pkt_name", "pkt_len", "pet_len", "pet_size"], "ret": ["status", "reg", "def", "std", "result", "val", "progress", "rx", "rec", "msg", "res", "fin", "arr", "success", "rc", "lo", "run", "RET", "reply", "seq", "proc", "orig", "fi", "resp", "fun"], "in_frame": [" in_story", " in_motion", "in__window", "in_message", "in__frame", " in_window", "in_point", "inamframe", "inammessage", " in_sample", "in_window", "in_story", "in_sample", " in_message", "in_fram", " in_fram", "in_motion", "in__story", " in_point", "in__fram", "inammotion"], "err": ["status", "str", "e", "asm", "ind", "result", "val", "mode", "der", "Er", "rr", "f", "order", "op", "r", "msg", "bug", "init", "opt", "risk", "arr", "act", "id", "code", "rh", "count", "var", "addr", "rc", "dr", "out", "fe", "num", "rule", "arm", "usr", "error", "Error", "magic", "er", "erg", "loc", "gr", " Err", "mr", "req", "ner", "rage", "conf", "orig", "ise", "h", "attr", "type"], "state": ["status", "str", "step", "reg", "State", " State", "e", "class", "name", "kind", "next", "STATE", "event", "config", "val", "part", "mode", "key", "style", "use", "stat", "new", "act", "code", "work", "sync", "comment", "open", "action", "tag", "run", "go", "set", "rule", "error", "session", "states", "stage", "are", "instance", "resource", "scope", "this", " STATE", "type"]}}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int fill_default_ref_list(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n    int smallest_poc_greater_than_current = -1;\n\n    int structure_sel;\n\n    Picture sorted_short_ref[32];\n\n    Picture field_entry_list[2][32];\n\n    Picture *frame_list[2];\n\n\n\n    if (FIELD_PICTURE) {\n\n        structure_sel = PICT_FRAME;\n\n        frame_list[0] = field_entry_list[0];\n\n        frame_list[1] = field_entry_list[1];\n\n    } else {\n\n        structure_sel = 0;\n\n        frame_list[0] = h->default_ref_list[0];\n\n        frame_list[1] = h->default_ref_list[1];\n\n    }\n\n\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        int list;\n\n        int len[2];\n\n        int short_len[2];\n\n        int out_i;\n\n        int limit= INT_MIN;\n\n\n\n        /* sort frame according to POC in B slice */\n\n        for(out_i=0; out_i<h->short_ref_count; out_i++){\n\n            int best_i=INT_MIN;\n\n            int best_poc=INT_MAX;\n\n\n\n            for(i=0; i<h->short_ref_count; i++){\n\n                const int poc= h->short_ref[i]->poc;\n\n                if(poc > limit && poc < best_poc){\n\n                    best_poc= poc;\n\n                    best_i= i;\n\n                }\n\n            }\n\n\n\n            assert(best_i != INT_MIN);\n\n\n\n            limit= best_poc;\n\n            sorted_short_ref[out_i]= *h->short_ref[best_i];\n\n            tprintf(h->s.avctx, \"sorted poc: %d->%d poc:%d fn:%d\\n\", best_i, out_i, sorted_short_ref[out_i].poc, sorted_short_ref[out_i].frame_num);\n\n            if (-1 == smallest_poc_greater_than_current) {\n\n                if (h->short_ref[best_i]->poc >= s->current_picture_ptr->poc) {\n\n                    smallest_poc_greater_than_current = out_i;\n\n                }\n\n            }\n\n        }\n\n\n\n        tprintf(h->s.avctx, \"current poc: %d, smallest_poc_greater_than_current: %d\\n\", s->current_picture_ptr->poc, smallest_poc_greater_than_current);\n\n\n\n        // find the largest POC\n\n        for(list=0; list<2; list++){\n\n            int index = 0;\n\n            int j= -99;\n\n            int step= list ? -1 : 1;\n\n\n\n            for(i=0; i<h->short_ref_count && index < h->ref_count[list]; i++, j+=step) {\n\n                int sel;\n\n                while(j<0 || j>= h->short_ref_count){\n\n                    if(j != -99 && step == (list ? -1 : 1))\n\n                        return -1;\n\n                    step = -step;\n\n                    j= smallest_poc_greater_than_current + (step>>1);\n\n                }\n\n                sel = sorted_short_ref[j].reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n                frame_list[list][index  ]= sorted_short_ref[j];\n\n                frame_list[list][index++].pic_id= sorted_short_ref[j].frame_num;\n\n            }\n\n            short_len[list] = index;\n\n\n\n            for(i = 0; i < 16 && index < h->ref_count[ list ]; i++){\n\n                int sel;\n\n                if(h->long_ref[i] == NULL) continue;\n\n                sel = h->long_ref[i]->reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n\n\n                frame_list[ list ][index  ]= *h->long_ref[i];\n\n                frame_list[ list ][index++].pic_id= i;\n\n            }\n\n            len[list] = index;\n\n        }\n\n\n\n        for(list=0; list<2; list++){\n\n            if (FIELD_PICTURE)\n\n                len[list] = split_field_ref_list(h->default_ref_list[list],\n\n                                                 h->ref_count[list],\n\n                                                 frame_list[list],\n\n                                                 len[list],\n\n                                                 s->picture_structure,\n\n                                                 short_len[list]);\n\n\n\n            // swap the two first elements of L1 when L0 and L1 are identical\n\n            if(list && len[0] > 1 && len[0] == len[1])\n\n                for(i=0; h->default_ref_list[0][i].data[0] == h->default_ref_list[1][i].data[0]; i++)\n\n                    if(i == len[0]){\n\n                        FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n                        break;\n\n                    }\n\n\n\n            if(len[list] < h->ref_count[ list ])\n\n                memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));\n\n        }\n\n\n\n\n\n    }else{\n\n        int index=0;\n\n        int short_len;\n\n        for(i=0; i<h->short_ref_count; i++){\n\n            int sel;\n\n            sel = h->short_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->short_ref[i];\n\n            frame_list[0][index++].pic_id= h->short_ref[i]->frame_num;\n\n        }\n\n        short_len = index;\n\n        for(i = 0; i < 16; i++){\n\n            int sel;\n\n            if(h->long_ref[i] == NULL) continue;\n\n            sel = h->long_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->long_ref[i];\n\n            frame_list[0][index++].pic_id= i;\n\n        }\n\n\n\n        if (FIELD_PICTURE)\n\n            index = split_field_ref_list(h->default_ref_list[0],\n\n                                         h->ref_count[0], frame_list[0],\n\n                                         index, s->picture_structure,\n\n                                         short_len);\n\n\n\n        if(index < h->ref_count[0])\n\n            memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));\n\n    }\n\n#ifdef TRACE\n\n    for (i=0; i<h->ref_count[0]; i++) {\n\n        tprintf(h->s.avctx, \"List0: %s fn:%d 0x%p\\n\", (h->default_ref_list[0][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[0][i].pic_id, h->default_ref_list[0][i].data[0]);\n\n    }\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        for (i=0; i<h->ref_count[1]; i++) {\n\n            tprintf(h->s.avctx, \"List1: %s fn:%d 0x%p\\n\", (h->default_ref_list[1][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 21665, "substitutes": {"h": ["ih", "hp", "hm", "enh", "e", "end", "ref", "him", "hs", "g", "ha", "d", "oh", "host", "img", "home", "f", "t", "ah", "eh", "m", "r", "u", "adh", "hd", "j", "p", "rh", "o", "q", "uh", "H", "header", "c", "self", "sh", "ch", "hr", "b", "w", "he", "hash", "hl", "n", "gh", "hi", "html", "v", "http", "bh", "hw", "hist", "image", "l", "ph", "ht", "hh"], "s": ["ions", "ides", "es", "ds", "sys", "y", "r", "ils", "ssl", "ains", "stats", "js", "n", "S", "ns", "ures", "http", "v", "erences", "l", "ss", "sb", "support", "g", "d", "site", "as", "ages", "services", "u", "opt", "setup", "screen", "o", "network", "ances", "c", "self", "spec", "a", "sf", "ats", "e", "qs", "serv", "hs", "fs", "f", "t", "p", "si", "b", "service", "sup", "ps", "gs", "sq", "port", "sl", "ubs", "ops", "m", "storage", "ls", "sync", "is", "sa", "client", "settings", "sh", "in", "w", "session", "server", "share"], "i": ["io", "ami", "limit", "start", "ix", "e", "qi", "ri", "ui", "eni", "mini", "pi", "gi", "my", "uri", "chi", "ti", "I", "f", "ci", "y", "phi", "adi", "ini", "u", "it", "j", "info", "ip", "p", "id", "abi", "ori", "bi", "o", "cli", "mi", "c", "mu", "index", "si", "ii", "x", "n", "iu", "ai", "xi", "di", "multi", "yi", "z", "li", "image", "api", "l", "fi", "ni", "count"], "structure_sel": ["structuressol", "structuressels", "sture_fail", "structure_sels", "struction_sell", "struction_isl", "structure_fail", "struction_cel", "structure_cel", "structure_sl", "struction_sel", "structure_Sel", "structure_isl", "structure_sell", "sture_sl", "struction_sol", "sture_sel", "struction_sels", "sture_Sel", "structure_sol", "structuressell", "structuressel"], "sorted_short_ref": ["sorted_small_diff", "sorted_short64Ref", "sorted_small_info", "sorted_short2ref", "sorted_short_reference", "sorted_short64ref", "sorted_short2Ref", "sorted_long_def", "sorted_short_rec", "sorted_small_ref", "sorted_small_Ref", "sorted_small_list", "sorted_long_reference", "sorted_short_diff", "sorted_short_list", "sorted_short64list", "sorted_short64def", "sorted_long_Ref", "sorted_short_def", "sorted_short2reference", "sorted_short_Ref", "sorted_long_ref", "sorted_short_info", "sorted_short64reference", "sorted_small_reference", "sorted_long_rec", "sorted_short2def", "sorted_short64diff"], "field_entry_list": ["field_entrydlist", "field_entryingall", "field_entry0list", "field_filedlist", "field_entry_record", "field_filedlists", "field_entry_part", "field_def_pair", "field_image_record", "field_entryinglist", "field_entry_lock", "field_entry_lists", "field_image_set", "field_entry_pair", "field_entry0lock", "field_entryingset", "field_entry0set", "field_entry_all", "field_image_list", "field_entrydlock", "field_entry_set", "field_image_part", "field_filedset", "field_def_set", "field_filedlock", "field_file_lists", "field_entrydset", "field_file_lock", "field_def_list", "field_file_list", "field_entrydlists", "field_def_all", "field_entryingpair", "field_file_set", "field_entry0lists"], "frame_list": ["frame_object", "frameeslist", "frame2type", "frameallist", "fram_lists", "framealtest", "fram_detail", "frameacarray", "frameglists", "frame_size", "framegarray", "frameeslists", "frame_diff", "frame_entry", " frame_type", "frame2diff", "frame_detail", "frame2set", "fram_list", "element_result", "elementacarray", "feature_list", "element_list", "frame_result", " frame_set", "framegresult", " frame_diff", "frameaclist", "frame_system", "frame_set", "frameglist", "frame2list", "frame_test", "frame_array", "theme_size", "element_array", "frameacresult", "elementaclists", "themeallist", "element_lists", "elementaclist", "frame_lists", "theme_test", "themealtest", "framealsize", "frameacsystem", "theme_entry", "frameesdetail", "themealsize", "fram_object", "frameesobject", "elementacresult", "feature_lists", "frame_type", "theme_list", "frameacset", "frameaclists", "feature_system", "feature_set", "framealentry", "themealentry"], "list": ["loop", "map", "val", "null", "file", "lists", "data", "cache", "p", "arr", "List", "code", "pool", "L", "set", "seq", "batch", "array", "li", "block", "all", "l"], "len": ["limit", "en", "ref", "val", "part", "ln", "bin", "pos", "split", "fat", "cmp", "data", "lock", "lin", "depth", "body", "lim", "line", "seq", "min", "n", "length", "lang", "Len", "count"], "short_len": ["short_list", "short__len", " short_list", " short_sum", "short_sum", "short_ref", " short_ref", "short__ref", "short__sum", "short__list"], "out_i": ["out_ini", "remotePEsite", "remote_yi", "out_uri", " out_zi", " out_io", "out_di", "out_iu", "OUTXi", "in_j", "workJini", "workJei", "OUTXti", "outPei", "outEnduri", "outCti", "out24abi", " out_si", "out_site", "out24i", "work_it", " out_I", "outxli", "out_o", "outXo", "outDi", "out_I", "outputLi", "outCo", "outputLie", "out_ci", "remotePEyi", "work_abi", "workJi", "work_di", "out64i", "output_ie", "outDmulti", "outXabi", "outEndie", "outLmulti", "OUTXo", "outCi", "in_li", "outEndmulti", "outOi", "output_i", "out_it", " out_li", "work_ci", "outXit", "out_si", "out24ci", "outLogu", "outDiu", "out_abi", "outEndiu", "outOmulti", "work_ei", "outPEi", "remotePEmulti", "remote_site", "outLoguri", "out_io", "out_multi", "out64ei", "outlexio", "workJdi", "in_ti", "outXti", " out_u", "out24it", "remote_multi", "out_j", "outOyi", "in_i", "outLie", "remote_i", "out64ini", "remotePEi", "outPdi", "OUTXsi", "outEndi", "outOsite", "outPini", "out_li", "outlexit", "outXsi", "outputLiu", "outClio", "out_ie", "outJdi", "outPi", "output_iu", "outPEsite", "outxti", "OUT_o", "outPEmulti", "OUT_ti", "out_ti", "outEndzi", "out64di", "out_ei", "out_u", "OUT_i", "outClit", "outxj", "output_multi", "outLiu", "OUT_si", "out_yi", "outCli", "outDie", "outxi", "outClI", "out_zi", "outLogi", " out_it", "outLi", " out_uri", "outJi", "outJei", "outLogzi", "outPEyi", "outlexi", "outCsi", "outputLmulti", "outJini", "outlexI", "outXi", "outXci", "outEndu", "work_i", "work_ini"]}}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "substitutes": {"f": ["fa", "fc", "e", "config", "fs", "g", "fb", "file", "d", "_", "parse", "ops", "rf", "fp", "df", "write", "t", "u", "m", "j", "s", "new", "p", "fx", "cf", "inf", "code", "q", "af", "c", "fe", "fr", "tf", "form", "b", "fd", "F", "sf", "feed", "update", "bf", "fen", "z", "v", "fn", "lf", "h", "l", "fi", "this", "fo", "k"], "vmdesc": ["vmdec", "vamddesc", " vcmdesc", "mmandesc", "vmaosc", "vmandocument", " vmaosc", "vcmdec", " vcmdasc", "vmnrec", "vmdex", " vcmdex", " vmdrec", " vMDesc", "vmodosc", "vmddesc", "vamdasc", "vmadoc", "vnddesc", "vmdrec", "vmderella", "vddisc", " vmdasc", "vmef", "gmmesc", "vmdest", " vcmdrec", "vndoc", "vMDsc", "vcmdest", "mmdesc", "vMDasc", "vcmdrec", " vmdsc", "vmdect", "vmandest", " vmdisc", "vmesc", "vMDest", "vmanderella", "vmonddesc", " vmdex", "mmdocument", "mmdest", "vamdef", " vMDdesc", " vmaser", "gmdisc", " vcmdest", "vamddec", "vamdser", "vmondest", "vmandrec", "vmnex", "vamdesc", "vmtesc", "vMDesc", "mmdoc", "vnddec", "vamderella", "vmdasc", "vcmddesc", "vmmasc", "vMDisc", "vmterella", "vmondisc", "gmmisc", " vmdef", "vmondasc", " vmaesc", "vmest", "mmderella", "vddasc", "vcmdsc", "gmdasc", "vamdocument", " vmdser", "vndesc", "vmadesc", " vcmdef", " vmdest", "vmondoc", "vmec", "vmaser", "vmtocument", "vmmisc", "gmdect", "vmasc", "vmodser", "vmddec", " vMDisc", "mmandest", "vmadest", "vmondesc", "vmdisc", "vcmdoc", "vddect", "vmodesc", "vmondsc", "vMDdesc", " vcmdoc", "vMDec", " vMDsc", " vmdoc", "vcmdasc", "vmandesc", "vmanddesc", "mmandoc", "gmdesc", "vmdser", "mmanddec", "gmmasc", "mmanddesc", "vcmdesc", "vmmect", "gmmect", "vamdsc", "vmaesc", "vcmdisc", " vmddesc", "vmanddec", " vmdec", "vmdoc", "vmandex", "mmanderella", " vcmdec", "vmmesc", "vmdsc", "mmandocument", "vmadasc", " vcmddesc", "vamdest", "vamdoc", "vMDect", "vcmdef", "vmnesc", "vmsc", " vmadesc", "mmddec", "vmtest", "vmdef", "vmnef", "vddesc", "vmdosc", "vmoddesc", " vmdosc", "mmddesc", "vamdosc", " vcmdsc", "vmandoc", "vmdocument", "vcmdex", "vmandef"], "vmdesc_len": ["vmdsc_length", "vmdsc_len", "vmdesc_long", "vmdsc_Len", "vmdsc_long", "vmdesc_Len", "vmdesc_length"], "se": ["ite", "e", "sel", "sed", "sk", "es", "serv", "ie", "ee", "sl", "ser", "ses", "ade", "pe", "lex", "sche", "be", "de", "parse", "site", "so", "ine", "oss", "entry", "s", "ue", "Se", "esse", "del", "cle", "SE", "sync", "le", "sa", "pse", "ese", "el", "spec", "ste", "sea", "si", "sh", "sc", "ch", "he", "service", "sing", "te", "spe", "ve", "loc", "see", "sem", "st", "ae", "ce", "ne", "sp", "sec", "ke", "pack", "ge", "su", "ase", "ze", "sle"], "ret": ["status", "bc", "reg", "def", "en", "xt", "gt", "ref", "err", "valid", "result", "val", "arg", "det", "repl", "Ret", "mt", "get", "no", "art", "cur", "rf", "bl", "al", "r", "bit", "msg", "res", "data", "cat", "rets", "fin", "last", " RET", "fun", "code", "success", "rc", "ext", "num", "match", "let", "RET", "rt", " Ret", "sr", "flag", "rev", "sur", "re", "reply", "error", "len", "lt", "back", "alt", "nt", "lit", "pt", "att", "ft"]}}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void mvp_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));\n\n\n\n    /* MVPConf1 implemented, TLB sharable, no gating storage support,\n\n       programmable cache partitioning implemented, number of allocatable\n\n       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs\n\n       implemented, 5 TCs implemented. */\n\n    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |\n\n                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |\n\n// TODO: actually do 2 VPEs.\n\n//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |\n\n//                             (0x04 << CP0MVPC0_PTC);\n\n                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |\n\n                             (0x00 << CP0MVPC0_PTC);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Usermode has no TLB support */\n\n    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);\n\n#endif\n\n\n\n    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,\n\n       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */\n\n    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |\n\n                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |\n\n                             (0x1 << CP0MVPC1_PCP1);\n\n}\n", "idx": 21694, "substitutes": {"env": ["net", "txt", "e", "external", "en", "end", "conn", "err", "eu", "vt", "config", "event", "obj", "db", "cv", "eng", "engine", "export", "ea", "eve", "exec", "exc", "fg", "nc", "dev", "init", "cache", "entry", "enc", "cf", "dict", "code", "np", "context", "Environment", "ext", "el", "self", "et", "cfg", "enable", "dt", "gui", "window", "loader", "core", "viron", "ass", "session", "console", "global", "v", "ne", "manager", "ner", "conf", "eval", "server", "environment", "ev", "ec"], "def": ["Def", "obj", "ref", "config", "defined", "push", "val", "decl", "tx", "local", "ef", "exec", "entry", "dev", "init", "DEF", "define", "definition", "test", "req", "proc", "conf", "block", "eval"]}}
{"project": "FFmpeg", "commit_id": "ae3da0ae5550053583a6f281ea7fd940497ea0d1", "target": 1, "func": "static int decode_band(IVI45DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2, pos;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    if (!band->buf) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return result;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i * 2];\n\n        idx2 = band->corr[i * 2 + 1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    pos = get_bits_count(&ctx->gb);\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        if (tile->mb_size != band->mb_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n\n                   band->mb_size, tile->mb_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n", "idx": 21708, "substitutes": {"ctx": ["conv", "lc", "bc", "grad", "cam", "cc", "wcs", "support", "gpu", "conn", "sci", "ref", "config", "coll", "pkg", "cv", "kt", "cm", "connection", "crit", "tx", "ca", "anc", "cas", "scl", "cmp", "ci", "nc", "cmd", "cp", "component", "cf", "xc", "ctrl", "kb", "context", "sync", "np", "buf", "rc", "c", "cb", "cn", "bank", "client", "la", "sc", "ann", "cal", "cpp", "cci", "gc", "qa", "media", "fw", "loc", "bm", "cca", "utils", "buff", "cms", "conf", "hw", "ck", "kw", "voc", "concept", "cu", "gb", "vc"], "plane_num": [" sheet_num", " sheet_name", " frame_num", " sheet_no", " sheet_sum", " frame_sum", " frame_name", " frame_no"], "band": ["target", "app", "event", "amp", "config", "part", "map", "cm", "piece", "device", "cell", "front", "bit", "cat", "data", "leg", "list", "link", "work", "field", "bank", "bo", "line", "rule", "library", "station", "slice", "bd", "cast", "batch", "grid", "image", "output", "phase", "support", "object", "db", "d", "bb", "style", "bass", "component", "tool", "plug", "low", "ann", "brand", "hub", "channel", "Band", "feed", "dB", "boot", "back", "bus", "lc", "fb", "not", "ld", "function", "layer", "model", "cmd", "full", "nd", "act", "point", "gen", "day", "b", "service", "flow", "co", "stage", "group", "guide", "gb", "plane", "obj", "board", "project", "kt", "player", "card", "feature", "plugin", "bridge", "product", "grab", "pp", "word", "kk", "tag", "frame", "filter", "match", "ground", "range", "unk", "block", "broad"], "avctx": ["svcontext", "aveca", "avcci", "svcmp", "AVcmp", "AVctl", "ivcontext", "vercontext", "airctx", "verconn", "afcci", "afctl", "averctl", "afcmp", "avconn", "AVcli", "verctx", "airconn", "AVcontext", "afctx", "avercontext", "AVca", "avca", "ivctx", "averctx", "svcb", " avcli", "vercci", "svctx", "avecontext", "avercli", "avcontext", "verkb", "ivcci", "svconn", "avctl", "AVconn", "svctl", "avcb", " avctl", " avconn", "ivconn", "afcb", "vercb", "avectx", "avcmp", "afcontext", "AVctx", "aircontext", "afconn", " avca", "avcli", " avcontext", "airkb", "aveconn", "afkb", "avkb"], "result": ["status", "found", "response", "effect", "err", "event", "valid", "val", "mate", "inc", "message", "card", "feature", "duration", "type", "product", "results", "df", "done", "term", "order", "catch", "info", "acc", "rate", "entry", "res", "data", "final", "other", "ret", "score", "compl", "diff", "number", "arr", "work", "current", "record", "comment", "success", "rc", "mer", "answer", "match", "pass", "die", "ver", "future", "value", "Result", "date", "there", "error", "length", "total", "test", "page", "grade", "root", "dest", "ge", "su", "attr", "count"], "i": ["io", "name", "ix", "start", "e", "ie", "qi", "ind", "ui", "eni", "part", "pi", "key", "ki", "gi", "d", "uri", "my", "ti", "I", "f", "ci", "y", "u", "info", "m", "ini", "phi", "j", "size", "p", "ip", "id", "bi", "is", "mi", "c", "index", "si", "ii", "in", "x", "b", "n", "iu", "sup", "slice", "ai", "xi", "hi", "di", "multi", "v", "yi", "li", "l", "fi", "k", "ni", "type"], "t": ["port", "the", "target", "e", "g", "time", "d", "tt", "token", "tim", "ti", "l", "f", "y", "u", "m", "s", "j", "p", "ts", "at", "o", "c", "num", "tf", "dt", "a", "b", "ta", "w", "to", "T", "n", "te", "test", "task", "ot", "v", "z", "qt", "tz", "h", "pt", "offset", "x", "k", "type"], "idx1": ["idxf1", "idnt1", " idxOne", "idx4", "idy4", " idxc0", " idx0", "idx81", " idxc2", "idww81", "idxOne", "idxf2", "idxBack", "idww2", "idxc2", "idXOne", "idwwone", " idxone", "idxc0", " idxc81", "iddx2", "idxcJ", " idxcBack", "idxf81", "idxc4", "idy1", " idxcJ", "iddxBack", "idnOne", "idn0", "idX1", " idX0", "iddxJ", "idx0", "idy0", "idxfone", "idnt2", " idX1", " idxBack", "idX0", "idxone", "idn1", " idXOne", "idX4", " idxcone", "idntJ", "idww1", "idxc1", " idxc1", "idntBack", " idx4", "idy2", "idX2", " idxJ", " idxc4", "idxc81", "idyOne", "idxcone", " idx81", "iddx1", "idxcBack", "idxJ", " idX2", "idn2"], "idx2": ["idxf02", "indx2", "idxe1", "idXFL", "idxe2", "idx4", " idxc0", "idt02", "idxi1", " idx62", "sidt1", "indxFL", "idX0", "sidx1", "idxe22", "sidx02", "idxTwo", "idxFL", "idt1", "idX02", "idxi0", "idy02", "idt2", "idcyTwo", "idxc4", "idy1", "idxc62", "idx02", "idX1", "indcy02", "idxc1", " idx4", "idy2", "idX2", "idxi22", "idx62", "indx02", " idx0", "idXTwo", "idxc2", "idx22", "idxc0", " idx22", "indcy2", "idcy2", "indcyTwo", "idxfFL", "indcyFL", "idcyFL", "sidx2", "indxTwo", " idxc2", "idxe4", "idxi2", "idxf2", "idxfTwo", "idxi62", "idX62", "idx0", "idxc22", "idcy02", " idxc62", " idxc1", " idxc22", " idxc4", "sidt02", "idxi4", "sidt2"], "pos": ["col", "port", "def", "end", "obj", "ref", "val", "part", "pi", "post", "pc", "POS", "no", "po", "neg", "op", "j", "cache", "rel", "os", "p", "Pos", "slot", "trans", "o", "index", "pl", "pro", "spec", "pid", "pres", "min", "n", "len", "loc", "conf", "sp", "pt", "position", "offset", "prop", "type"], "tile": ["route", "pod", "col", "Tile", "plane", "port", "target", "table", "flat", "oe", "late", "scale", "hop", "item", "nn", "coll", "token", "kt", "so", "cube", "file", "feature", "plate", "style", "plugin", "bridge", "tle", "cand", "node", "layer", "pixel", "split", "cell", "transfer", "coord", "tab", "cat", "zip", "tif", "component", "unit", "zone", "sheet", "tool", "tag", "tf", "rule", "line", "service", "ele", "flo", "slice", "chip", "mask", "ole", "co", "stone", "task", "grid", "image", "ge", "texture", "fo", "entity"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723, "substitutes": {"dev": ["cam", "def", "app", "device", "dist", "info", "nov", "data", "bug", "serial", "var", "dem", "dim", "raw", "gh", "test", "di", "v", "conf", "ev", "pub", "priv", "end", "conn", "valid", "driver", "non", "der", "de", "d", "ad", "mod", "self", "dom", "dc", "md", "err", "f", "model", "exec", "adv", "dd", "p", "comment", "module", "sd", "ver", "dt", "rad", "error", "req", "user", "Dev", "cd", "DEV", "gu", "wd", "cur", "engine", "gd", "diff", "id", "client", "pro", "die", "ch", "w", "debug", "block", "pack", "development", "server"], "vdev": ["qdd", "vdd", "qdevice", "frad", "nvdevice", "Vd", "lrad", "vdiv", "vvdiv", "qdev", "nvdev", "vd", "pdevice", " vd", "pd", "ldd", "nvdd", "fdiv", "vvdev", " vdevice", "pdev", "vdevice", "ddevice", "nvrad", "ddev", "ddiv", "vvrad", "drad", "ldevice", "qrad", "vvdevice", "ldev", "vrad", "fdev", "fdevice", "pdiv", "Vdev", "Vdiv", "Vdevice", " vdiv"], "bus": ["io", "lc", "bc", "class", "def", "obj", "usb", "config", "board", "loop", "mount", "val", "db", "Bus", "bridge", "host", "build", "home", "local", "path", "band", "device", "lab", "dir", "use", "cat", "cache", "bug", "cart", "lock", "os", "us", "sync", "comment", "buf", "plug", "disk", "pl", "pass", "ch", "pull", "b", "hub", "session", "show", "BUS", "feed", "back", "boot", "lib", "http", "conf", "proc", "bs", "user", "nt", "pack", "block", "base", "pub"], "dev_len": ["priv_lin", "ev_val", " dev_Len", "dev5lan", "priv_lon", "dev64len", "dev_base", "ev_la", "dev_lan", "ev_lon", "dev64lim", "dev64lon", "dev_la", "av_lon", "devenfin", "devenlin", "priv7len", "dev6lin", "dev6fin", "ev_base", "patch_label", "av_lit", "dev_lon", "ev_len", "patch_lin", "priv7lin", "patch_len", "patchenlabel", "dev_lin", "dev_lit", " dev_length", "av_len", "patchenlin", "devenlen", "dev5lon", "dev6label", "dev64lit", "ev_den", "patch_fin", "dev_fin", "patchenfin", "priv_lan", "dev7lin", "priv7lon", "dev_den", "dev7lan", "dev7lon", " dev_val", "dev_Len", "dev_label", "av_lim", "dev7len", "priv7lan", "priv_len", "dev_length", "devenlabel", "dev5len", "dev5lin", "dev_val", "dev6len", "patchenlen", "dev_lim"], "cpu": ["platform", "computer", "bench", "net", "gpu", "linux", "GPU", "performance", "pkg", "consumer", "rpm", "processor", "process", "pc", "CPU", "node", "device", "css", "cp", "fps", "cache", "component", "machine", "np", "disk", "pool", "px", "cn", "gp", "pid", "mem", "loader", "chip", "xi", "proc", "vm", " CPU", "clock", "sta", "pu", "ilo"]}}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n", "idx": 21731, "substitutes": {"size": ["i", "name", "shape", "security", "password", "ix", "scale", "g", "time", "mode", "sized", "Size", "bytes", "ize", "weight", "zero", "address", "use", "fee", "cache", "storage", "enc", "sum", "unit", "code", "sync", "timeout", "content", "six", "small", "source", "sh", "capacity", "si", "speed", "core", "any", "length", "slice", "loc", "len", "large", "root", "range", "SIZE", "sec", "empty", "position", "server", "offset", "base", "max", "count"], "max_size": ["maxfullnumber", "max_shape", "max64number", "max64capacity", "last64sized", "maxFshape", "max48length", "maxxlength", "default_number", "maxxoffset", " max_length", "maxxsize", "max_address", "max64use", "max00offset", "maxlensize", "max48sized", "max00sized", "maxfulluse", "maxfulllength", "max64offset", "default64use", "maxxsized", "max64size", "min_shape", "max48offset", " max_capacity", "max_length", "max48size", " max_offset", "max64sized", "last_sized", " max_ize", "max_ize", "default64length", "max_sized", "max_offset", "maxlenuse", "max64ize", "maxlennumber", "max_number", "default_size", "maxlenlength", "min_address", "default64size", "maxfullsize", " max_sized", "default_length", "max_capacity", "maxFaddress", "min_size", "default_use", "maxFsize", "max00size", "max64length", "default64number", "last_offset", "last64offset", "last64size", "last_size", "max_use"], "resized": ["resize", "greerved", "resored", "presizable", "desolved", "presizes", "greizing", "presize", "resizes", "presized", "greizable", "realizable", "Resized", "realizing", "resizing", " resizes", " resolved", "desored", " resize", "greized", "Resizable", "realerved", "presizing", "realized", "resolved", "desizable", "Resize", "realored", "Resizes", " resizable", "reserved", "resizable", "realolved", "preserved", "desized", " resored"], "host": ["remote", "port", "native", "name", "target", "shape", "ghost", "object", "config", "scale", "hard", "hop", "driver", "chain", "loop", "mount", "container", "mode", "connection", "compatible", "home", "node", "device", "path", "pos", "proxy", "address", "bit", "full", "cache", "ip", "component", "prefix", "addr", "mac", "context", "condition", "hack", "pool", "header", "localhost", "index", "frame", "arch", "source", "capacity", "comp", "raw", "location", "hub", "error", "Host", "length", "ctor", "loc", "large", "domain", "root", "parent", "h", "block", "server", "image", "oc", "base", "format", "url", "type"], "resizeable": ["resizables", "rsizeabled", "resizableble", "rsizabled", "resizablele", "resizableables", "resizeabled", " resizeble", "resizeability", "rsizeables", "resizableabled", "resizability", "resizingable", "resizationble", "resizingabled", "resizeables", "resizle", "resizele", "resizationables", "resizationle", "resizble", "rsizables", "rsizeability", " resizable", "resizableability", " resizble", " resizeables", " resizle", "resizableable", " resizables", "rsizeable", "rsizable", "resizable", "resizingability", "resizingables", "resizeble", "rsizability", "resizationable", " resizele", "resizabled"], "mr": ["md", "lc", "wm", "ru", "hm", "err", "adr", "ml", "Mr", "rpm", "rr", "mor", "pm", "mt", "lr", "drm", "master", "r", "m", "mc", "rh", "mid", "mm", "mac", "dr", "igr", "module", "nr", "rm", "rar", "shr", "RR", "hr", "rl", "vr", "sr", "usr", "dm", "fm", "er", "bm", "gr", "mx", "br", "bh", "manager", "vm", "kr", "rb", "nor", "mk", "MR", "attr", "mn", "mmm", "gb", "rg"], "errp": ["eorp", "erpre", "err", "erpb", "errorpc", " errpre", " errpc", "errpc", " errpb", "errP", "errorpre", "eorpb", "eorr", "errpre", "errorP", " errP", "errpb", "erp", "erP", "errr", "eorpc", " errr", "erpc", "errorp"], "new_block": [" new_flow", " new_clock", "NEW_panel", "existing_coll", "new_panel", "NEW_device", "newAcnode", "newlywork", "new_object", "unique_ban", "existing_def", "unique_block", "newxdevice", "newjblock", "newAcblock", "newlylock", "newlyblock", "new__block", "new_bro", "new_ban", "new_flow", "news_chain", "newacframe", "newPclock", " new_link", "newjrow", "newAclock", "old_ban", "new67block", "New_base", "new___block", "newJjoin", "plus_block", "new___network", "NEW_lock", "new__blocks", "newPblock", "unique_chain", "plusJjoin", "newPlock", "new_frame", "extra_block", "new67coll", "new_row", "existing_block", "new___chain", "New_sync", "new___lock", "plus_join", "extra_network", "new67bin", "new_case", "newacchain", "newedcoll", "old_case", "new_blocks", "newjbro", "existing_bin", "unique_node", "new_device", "uniquefnode", "newacblock", "newfnode", " new_bro", "newaclock", "plusJunit", "news_lock", "newfban", "extra_frame", "newacnetwork", "new_base", "extra_lock", "newacunit", "newAcbase", "newjlock", "old_object", "new___node", "new_clean", "uniquefchain", "newfchain", " new_lock", "newedblock", "plus_unit", "new_link", "old_lock", "new_bin", "New_block", "newJunit", "new___frame", "new_join", "new_coll", "new_work", "newlypanel", "plus_lock", "newJblock", "newJlock", "new_sync", "newfblock", "new_node", " new_node", "newAcsync", "new_lock", "neweddef", "newxblock", "newAcclock", "new_clock", "newxlock", "newacnode", "uniquefblock", " new_clean", "new_chain", "extraacframe", "extraacnetwork", "New_lock", "new___ban", "newacjoin", "newlydevice", " new_blocks", "newPnode", "news_work", "new_network", "old_device", "new__lock", "new_def", "old_block", "newedbin", "new67def", "news_block", "plusJlock", "new_unit", "uniquefban", "new__row", "plusJblock", "extraacblock", " new_row", "newlychain", "newacban", "newxobject", "NEW_block", "extraaclock", " new_chain"], "local_err": ["global_gr", "localwerror", "localwresult", "global_result", "local_error", "localwer", "local_risk", " local_risk", "localwerr", "global_er", "local_result", "global_err", "local_er", "global_error", " local_er", "local_gr", " local_error"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n", "idx": 21739, "substitutes": {"s": ["request", "sb", "i", "types", "e", "sym", "g", "ses", "private", "your", "d", "ops", "site", "services", "f", "sys", "t", "r", "u", "m", "info", "ssl", "os", "p", "cs", "sync", "is", "stats", "sg", "c", "ctx", "groups", "js", "self", "spec", "b", "w", "python", "session", "S", "ns", "n", "sf", "south", "gs", "http", "conf", "sec", "h", "secondary", "scope", "server", "sq"], "type": ["pb", "reg", "str", "Type", "name", "types", "target", "class", "def", "obj", "val", "pe", "TYPE", "style", "ty", "path", "op", "t", "y", "id", "py", "spec", "ype", "re", "typ", "param"], "ret": ["str", "reg", "red", "en", "bis", "xt", "ref", "gt", "valid", "result", "val", "ft", "det", "Arg", "Ret", "mt", "f", "t", "info", "r", "bit", "res", "rets", "opt", "addr", "success", "ext", "match", "RET", "resp", "rt", " Ret", "mem", "b", "flag", "sr", "reply", "rev", "re", "er", "len", "back", "alt", "v", "nt", "sec", "lit", "att", "x", "feat", "fun"], "arg": ["i", "target", "next", "config", "amp", "val", "parse", "other", "info", "r", "bit", "use", "data", "msg", "var", "lag", "date", "doc", "v", "feat", "str", "arc", "name", "ig", "asm", "option", "item", "g", "Arg", "op", "ac", "res", "ad", "opt", "enc", "code", "mac", "ext", "pass", "ag", "alt", "empty", "prop", "reg", "grad", "err", "ref", "result", "func", "f", "cmd", "p", "arr", "act", "ace", "addr", "gen", "num", "byte", "arm", "call", "er", "loc", "sec", "param", "count", "argument", "en", "ang", "inc", "art", "bad", "args", "id", "word", "tag", "match", "ar", "flag", "magic", "len", "max"]}}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740, "substitutes": {"luks": ["like", "lack", "licks", "fluKS", "flucks", "LUke", "laks", "lucs", "fluck", "flucs", "LUKS", "lucks", "LUks", "lick", "luke", "lics", "liks", "LUcs", "fluke", "lacks", "fluks", "lacs", "liKS", "luKS", "luck"], "luks_opts": ["luks_os", "luks_opters", "luks_opted", "luks_lockts", "luks_optcs", "luks_OPbs", "luks_optals", "luks_ots", "luks_cpters", "luks_obls", "luks_optms", "luks_optls", "luks_Opts", "luks_Opcs", "luks_catters", "luks_ryts", "luks_copters", "luks_okts", "luks_proths", "luks_opte", "luks_optt", "luks_optments", "luks_defte", "luks_adts", "luks_opens", "luks_hopte", "luks_otms", "luks_copks", "luks_Opt", "luks_otcs", "luks_OPted", "luks_opt", "luks_defts", "luks_opsts", "luks_optters", "luks_Ops", "luks_opments", "luks_OPps", "luks_hopps", "luks_opcs", "luks_otts", "luks_ryths", "luks_opms", "luks_opents", "luks_prots", "luks_OPns", "luks_cpts", "luks_copss", "luks_OPts", "luks_OPte", "luks_alts", "luks_alters", "luks_adbs", "luks_pcs", "luks_OPters", "luks_ryt", "luks_OPtes", "luks_pters", "luks_hopals", "luks_optted", "luks_obts", "luks_OPs", "luks_lockters", "luks_okt", "luks_proters", "luks_cats", "luks_hopters", "luks_optts", "luks_optes", "luks_opks", "luks_ott", "luks_prosts", "luks_alns", "luks_obments", "luks_opls", "luks_cpouts", "luks_opths", "luks_opentes", "luks_OPt", "luks_oktes", "luks_obters", "luks_opouts", "luks_locktes", "luks_ocs", "luks_adters", "luks_lockt", "luks_openments", "luks_defths", "luks_copsts", "luks_adouts", "luks_hopted", "luks_OPcs", "luks_catts", "luks_deft", "luks_optte", "luks_OPms", "luks_opals", "luks_opss", "luks_openls", "luks_alss", "luks_okters", "luks_adths", "luks_optps", "luks_pt", "luks_hopt", "luks_pts", "luks_alks", "luks_opbs", "luks_rybs", "luks_copts", "luks_copths", "luks_cpns", "luks_adt", "luks_ot", "luks_ops", "luks_opps", "luks_adns", "luks_OPths", "luks_alt", "luks_okns", "luks_cattes", "luks_hopts", "luks_openters", "luks_opns"], "local_err": ["local___bug", "shared_er", "shared_bug", "local___er", "local__er", "local_ver", "local__err", "local__ver", "local_bug", "shared_err", "local_er", "local___err", "local___ver", "shared_ver", "local__bug"], "masterkey": ["mastername", "primarykey", "parentblock", "parentKey", "parentkey", "primaryname", "masterblock", "publicblock", "primaryKey", "primaryblock", "publicname", "masterKey", "publicKey", "parentname", "publickey"], "slotkey": ["slicekey", "bitname", "bitid", "sliceid", "bitkey", "bitKey", "slotname", "offsetKey", "sliceKey", "offsetid", "slotKey", "slicename", "slotid", "offsetname", "offsetkey"], "splitkey": ["splitblock", "splitkeys", "sliceblock", "sharedkey", "sliceKey", "sharedkeys", "sessionblock", "slicekeys", "sessionkeys", "sharedblock", "sessionKey", "slicekey", "splitKey", "sessionkey", "sharedKey"], "i": ["I", "t", "s", "data", "shared", "ip", "abi", "p", "is", "c", "a", "b", "ii", "n", "multi", "array", "l", "fi", "k"], "cipher": ["scrypt", "scipher", "Crypt", "acrypt", "acairo", "scairo", "acursor", "crypt", "scursor", "Cairo", "cairo", "cursor", "Cursor", "acipher", "Cipher"], "ivgen": ["ivdec", " ivdec", "IVgener", "vmap", "ivmap", " ivmap", " ivgener", "IVmap", "vdec", "IVgen", "vgen", "vgener", "ivgener", "IVdec"], "password": ["security", "wallet", "text", "RAW", "phrase", "token", "path", "enc", "params", "prefix", "word", "auth", "mac", "comment", "rw", "random", "pass", "w", "alias", "session", "secret", "words", "mask", "sword", "user", "username", "Password", "padding"], "cipher_alg": ["cryption_mag", "cipher_erg", "cryption_method", "cryption_erg", "cipher_round", "cipher_orig", "cryption_mode", "cryption_orig", "cryption_round", "cryption_alg", "cipher_method", "cipher_mag"], "cipher_mode": ["cipher\u00b7level", "cipheringmodule", "cipher_level", "cursor_level", "cipheringstyle", "cursor_type", "crypt_style", "cipheringalg", "cipher_style", "crypt_mode", "cipher\u00b7type", "cipher_type", "cipher_def", "cipher\u00b7mode", "crypt_module", "crypt_alg", "cursor_mode", "cipher_module", "cursor_def", "cipheringmode", "cipher\u00b7def"], "ivgen_alg": ["ivgen_agg", "ivgn_alg", "ivgn_generation", "ivget_rg", "ivget_alg", "ivgeningrg", "ivgeningagg", "ivgen_rg", "ivgn_rg", "ivgetingrg", "ivgen_alt", "ivgeningmode", "ivgetingagg", "ivgen_mode", "ivgeningalg", "ivgn_alt", "ivget_agg", "ivgn_lass", "ivgn_mode", "ivgetingmode", "ivgetingalg", "ivget_mode", "ivgen_lass", "ivgen_generation"], "ivgen_hash_alg": ["ivgen_hash_mode", "ivgen_hash_mag", "ivgen_hash_lim"], "hash_alg": ["hash___arch", "hash67spec", "hash67alg", " hash_dec", " hash_mode", "hashabledec", "hashablemode", " hash_arch", "hashablealg", "hash_arch", "hash_spec", "hash_mode", "hash_dec", " hash_gen", "hash___alg", "hashablearch", "hash___mode", "hash67gen", "hash___dec", "hash67mode", "hash_gen", " hash_spec"], "cipher_mode_spec": ["cipher_mod_spec", "cipher_mode_mode", "cipher_mod_len", "cipher_mode_SPEC", "cipher_mod_SPEC", "cipher_mod_mode", "cipher_mode_len"], "iters": ["itering", "integers", "liters", "integer", "iter", "litering", "itered", "ifered", "ifer", "liter", "litered", "ifering", "ifers", "integered", "integering"]}}
{"project": "FFmpeg", "commit_id": "17269bdfcdb79679f6b92024d1228e876b799a63", "target": 1, "func": "static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n", "idx": 21750, "substitutes": {"s": ["sv", "sb", "e", "types", "sym", "qs", "es", "bis", "sl", "fs", "g", "ses", "an", "xs", "sports", "d", "sets", "ops", "site", "ks", "l", "ds", "services", "f", "sys", "t", "u", "r", "args", "storage", "os", "ssl", "ts", "p", "cs", "us", "ls", "o", "sync", "is", "ss", "sa", "sg", "c", "js", "ctx", "settings", "submit", "spec", "si", "a", "b", "w", "service", "aws", "n", "S", "ns", "sup", "parser", "ps", "rs", "gs", "south", "v", "conf", "bs", "su", "sq"], "swf": ["srv", " swfx", "SWfx", "surrf", "srf", "swv", "wwrf", "slfs", "twtf", " swfs", "swfp", "SWfs", "wwf", "Swf", "srfx", " swv", "swrf", "surfs", "slf", "SWv", "Swfp", "swfr", "twfs", "surf", "svfs", "svf", "swfs", "twf", "wwfp", "slfr", "Swrf", "sltf", "Swfs", "svtf", "wwfs", "svfr", "surfp", "swtf", "twfr", "SWf", "srfs", "swfx"], "pb": ["bc", "platform", "sb", "binary", "summary", "prototype", "lb", "uf", "fc", "ref", "jp", "lp", "prot", "db", "cv", "verb", "mb", "fb", "pkg", "pm", "bb", "orb", "phrase", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "PB", "um", "tp", "ob", "p", "url", "tc", "abc", "wb", "bps", "plug", "ctx", "pl", "ib", "pro", "mp", "b", "ub", "cpp", "tmp", "hub", "fm", "dl", "bm", "parser", "ab", "bf", "bh", "rb", "vp", "xb", "api", "dp", "ppa", "pa"], "enc": ["bc", "lc", "e", "oder", "en", "ig", "esc", "conn", "uc", "eu", "sl", "ct", "iv", "g", "acl", "obj", "coll", "inc", "unc", "eng", "impl", "pc", "img", "Enc", "anc", "cel", "ea", "env", "nc", "ac", "nec", "cat", "act", "code", "rh", "rc", "c", "ext", "ctx", "equ", "sc", "ch", "ocr", "dc", "ic", "inst", "loc", "ent", "sec", "lang", "cod", "ENC", "voc", "ev", "oc", "ec", "emb", "vc"], "video_enc": ["video4ec", "video_dec", "video_fc", "videoIPent", "audio_enc", "video67enc", " video_fc", "video64enc", " video_Enc", "player_ec", "player_enc", "audio_ec", "audio_dec", "video_en", "video_encrypted", " video_encrypted", "video4ent", "player_en", "video_Enc", "videoalEnc", " video_ent", "videoalencrypted", "audio_impl", "video64en", "videoaldec", "videoalec", "video_ent", "video4enc", "video64engine", " video_end", "video_engine", "videoIPfc", "video67encrypted", "videoalenc", "videoIPec", "video67end", "video_ec", "video_end", " video_ec", "video_impl", "player_engine", "video64ec", "videoIPenc", "video67Enc", "videoalimpl", "video4fc"], "file_size": ["filexsize", "file64sum", "file_sum", "filelexexternal", "filexcount", " file_count", " file64sum", "filexspeed", " file_time", " file_sum", " file64time", "file64time", "filenamelexsize", "filelexsum", "filename_speed", "filexsum", "file___number", "filenamelexexternal", "filelexspeed", "file64size", " file64size", "file_external", "file___size", "file_count", "filename_external", "file___count", "file_number", "filexnumber", "filename_sum", "file64number", "filename_size", " file64number", " file_number", "filenamelexsum", "filextime", "file___speed", "filelexsize", "file_time", " file_speed", "filenamelexspeed", "file_speed"], "i": ["io", "lc", "e", "ix", "ie", "qi", "ind", "ri", "ui", "eni", "key", "gi", "uri", "ti", "I", "l", "f", "ci", "t", "oi", "info", "ini", "m", "phi", "j", "u", "p", "ip", "id", "vi", "bi", "o", "inner", "mi", "c", "mu", "index", "si", "ii", "in", "ji", "x", "iu", "ai", "xi", "hi", "di", "multi", "v", "yi", "li", "pi", "fi", "zi", "k", "ni", "ori"]}}
{"project": "FFmpeg", "commit_id": "fbfbd97be25c4da0562ef61e2f27192d1ec4d276", "target": 1, "func": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    XPMDecContext *x = avctx->priv_data;\n\n    AVFrame *p=data;\n\n    const uint8_t *end, *ptr = avpkt->data;\n\n    int ncolors, cpp, ret, i, j;\n\n    int64_t size;\n\n    uint32_t *dst;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n\n\n    end = avpkt->data + avpkt->size;\n\n    while (memcmp(ptr, \"/* XPM */\\n\", 10) && ptr < end - 10)\n\n        ptr++;\n\n\n\n    if (ptr >= end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n\n        return ret;\n\n\n\n    if (cpp <= 0 || cpp >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size = 1;\n\n    for (i = 0; i < cpp; i++)\n\n        size *= 94;\n\n\n\n    if (ncolors <= 0 || ncolors > size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size *= 4;\n\n\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n\n    if (!x->pixels)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n\n    for (i = 0; i < ncolors; i++) {\n\n        const uint8_t *index;\n\n        int len;\n\n\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        if (ptr + cpp > end)\n\n            return AVERROR_INVALIDDATA;\n\n        index = ptr;\n\n        ptr += cpp;\n\n\n\n        ptr = strstr(ptr, \"c \");\n\n        if (ptr) {\n\n            ptr += 2;\n\n        } else {\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        len = strcspn(ptr, \"\\\" \");\n\n\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n\n            return ret;\n\n\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n\n\n        for (j = 0; j < avctx->width; j++) {\n\n            if (ptr + cpp > end)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n\n                return ret;\n\n\n\n            *dst++ = x->pixels[ret];\n\n            ptr += cpp;\n\n        }\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    p->key_frame = 1;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 21762, "substitutes": {"avctx": ["avecf", "vercontext", " avcu", "avcca", "avconfig", "avcup", "verctl", "avsci", " avcci", "navctx", "avlc", "avalcmp", "ajcup", "ajcoll", "avcms", "avalconn", "afconfig", "ajcmd", "ajctx", "avcmp", "afconn", "aimcot", "navcontext", "ajcit", "avecu", "avercot", "avcot", "vercca", "afsync", "avsync", "avalcot", "ajpkg", "afcci", "verctx", "afcup", "avcp", "avecp", "ajconfig", "avercup", "afctx", " avpkg", "ajctl", "ajcf", "avesci", "avelc", "avercms", "aimcms", "avcontext", "vercp", "avecci", "ajsync", "ajconn", "ajcu", "navcci", "AVctx", "avalcontext", "afcca", "afcp", "evcmd", "aveconn", "navcf", "avpkg", "avecoll", "ajcontext", "avcit", "afctl", "afcmp", "evconn", "afcmd", "avcoll", "evcontext", "avcf", "afpkg", "averctx", "afcu", "avcu", "abctx", "avctl", "evctx", "avalsci", "AVcup", "avectx", "afcit", "afcontext", "avecup", "avalcup", "aflc", "avesync", "avcci", "ajcci", "afcoll", "AVcmp", "afcf", "vercu", "aimcup", " avconfig", "avconn", "AVcontext", "abcf", "ablc", "versync", "avecontext", "ajcca", "aimctx", "avalcms", "avalctx", "avecit", "abcontext", "afsci", "avcmd", " avcontext"], "data": ["package", "delay", "name", "start", "next", "sample", "off", "config", "result", "input", "val", "Data", "d", "pad", "align", "f", "buffer", "pos", "done", "master", "da", "cache", "nd", "dd", "ad", "final", "id", "code", "body", "open", "buf", "header", "ctx", "frame", "DATA", "window", "draw", "date", "read", "media", "reader", "call", "length", "feed", "base", "parent", "alpha", "dat", "gap", "image", "empty", "api", "offset", "primary", "block", "video", "value"], "got_frame": ["data_buffer", "data_frames", "max_fram", "datafullbuffer", "max_buffer", "max_frames", "datafullframe", "data_frame", "datafullfram", "max_frame", "datafullframes", "data_fram"], "avpkt": ["avbacket", "avbett", "avpeft", "avlpct", "avpatch", "avplvt", "avppkg", "affatch", " avlpacket", "avnpkg", "avppke", "avepacket", " avpacket", "avcpk", "avlpacket", "avebacket", "avnpkt", "avebett", "avepkg", " avlpct", "avpett", "avlpft", " avpft", "avplkt", "avfatch", "avprft", "afpft", " avpct", "avPft", "avpratch", "avPkt", "avepett", "avpeatch", "avppkt", "avpkg", "avepkt", "avppk", "avlpkt", "avepke", "avPacket", "avpekt", "avecpkt", "avnpke", "avpvt", "avbkt", "avpke", "afpatch", "avpracket", "avfft", "avecpke", "afpkt", "afpacket", "avPct", " avlpft", "avfvt", "avepk", "avprkt", "avebvt", "avecpk", "avfkt", "avcpkt", "avepvt", "avbvt", "avfct", "avplacket", "avpeacket", "avpft", "avpct", "avfacket", "affacket", "avpk", "affkt", "avebkt", "avcpkg", " avlpkt", "avecpkg", "avnpk", "avfett", "avpacket", "avplett", "affft", "avcpke"], "x": ["ix", "e", "cross", "ux", "config", "xxx", "lex", "xs", "xy", "rx", "d", "tx", "xx", "f", "sex", "y", "t", "ex", "r", "m", "s", "xf", "fx", "xc", "work", "ext", "px", "xes", "xml", "dx", "c", "X", "xa", "xp", "w", "rex", "ic", "python", "nex", "xi", "ax", "wx", "z", "v", "image", "l"], "p": ["pb", "e", "jp", "lp", "pe", "d", "P", "bp", "pc", "fp", "f", "buffer", "t", "y", "pre", "r", "m", "cp", "tp", "cache", "pp", "np", "c", "ctx", "wp", "b", "n", "v", "sp", "vp", "pointer", "api", "pt", "pi", "pa"], "end": ["begin", "after", "est", "e", "start", "en", "tail", "send", "event", "END", "pe", "post", "stop", "d", "con", "f", "pos", "address", "ad", "nd", "enc", "ep", "id", "last", "ext", "c", "close", "edge", "ending", "End", "set", "pend", "enter", "length", "ender", "append", "v", "ent", "z", "h", "offset", "ended", "max", "fin"], "ptr": ["next", "pad", "buffer", "pos", "address", "tp", "dy", "rw", "shift", "pl", "fr", "ff", "src", "slice", "br", "proc", "pointer", "dest", "attr", "ft", "type", "str", "oe", "jp", "push", "ctr", "fp", "sth", "coord", "pointers", "code", "buf", "plug", "ext", "rc", "rt", "desc", "offset", "prop", "grad", "xt", "ref", "adr", "cmp", "ace", "addr", "pr", "tmp", "inst", "length", "fd", "loc", "req", "trace", "Ptr", "buff", "stage", "dat", "lf", "td", "port", "start", "tr", "wr", "cur", "lr", "elt", "dr", "ctx", "fe", "pull", "tip", "pend", "pt"], "ncolors": ["nfilours", "cicolores", "ncolters", "ncolorors", "ncolorores", "ccolrons", " nColters", "nicolours", "ncolori", " nColnames", "ncallections", "ngenerners", "ccolores", "nicolor", "cicolrons", " ncoloror", "nfillections", " nCollections", " nicolor", "nselectors", "ncalori", "ncalor", "ngenerors", "nColores", "nselectners", " ncolorori", "nfiloring", " nColores", "nicolrons", "ngenerores", "nicolors", "ncolores", "nColnames", "ngenernames", " ncolnames", "ncollections", " ncolours", "nicolores", "nCOLores", "nolours", "nColors", " nColners", "nCollections", "nselectores", "cicolors", "noloring", "nicollections", "nicolori", "nColters", "nolor", "ncolours", "nCOLrons", "cicollections", " ncolorores", "nCOLlections", " ncolores", "ncoloror", "ncoloring", " nicolors", "nfilor", " nicoloring", "ncolorori", "ncolnames", "ncolrons", "nfilrons", " ncolor", " ncolters", "ncalors", " nicolours", "nfilors", "nfilters", "ccollections", "nolors", "nselectnames", " ncolorors", "nicoloring", "ncolor", " ncolori", "nfilores", " nColors", " ncoloring", "ncalores", " ncolners", " ncollections", "nCOLors", "ncalters", "ncolners", "nColners", "ccolors"], "cpp": ["upp", "pb", "hp", "cc", "jp", "prot", "pkg", "cv", "cm", "fb", "esp", "height", "ffff", "qq", "bp", "xx", "fp", "cmp", "ci", "nc", "cmd", "cp", "zip", "tp", "pp", "ep", "cf", "xc", "uv", "np", "cup", "crop", "c", "ctx", "kk", "dx", "wp", "cb", "cpu", "gp", "dc", "tmp", "ff", "src", "sup", "length", "chip", "sf", "eps", "ce", "vp", "cod", "ppa", "pps", "cap", "vc", "ppo"], "ret": ["status", "reg", "def", "obj", "ref", "err", "fail", "pet", "prot", "result", "val", "mini", "ft", "det", "utf", "rep", "cur", "rf", "Ret", "get", "f", "buffer", "bad", "dist", "r", "info", "res", "rets", "id", "count", "success", "rc", "ext", "buf", "match", "RET", "rt", "mem", "replace", "value", "flag", "reply", "rev", "re", "desc", "req", "back", "reset", "alt", "proc", "nt", "att", "offset", "fi", "resp", "fun"], "i": ["io", "ami", "jit", "start", "ie", "qi", "ri", "ind", "ui", "eni", "gi", "uri", "chi", "ti", "I", "ci", "phi", "ini", "it", "ip", "id", "vi", "ani", "inner", "mi", "c", "si", "ii", "in", "ji", "b", "iu", "ai", "xi", "hi", "di", "li", "h", "pi", "fi", "zi", "k", "ni"], "j": ["je", "jp", "adj", "g", "ny", "bp", "pos", "pg", "y", "ok", "js", "b", "ii", "ji", "ij", "n", "loc", "jc", "v", "z", "sp", "h", "ie", "k", "jump", "ni"], "size": ["mini", "cm", "ize", "cp", "address", "six", "small", "cap", "member", "name", "scale", "g", "ci", "fee", "unit", "code", "body", "c", "capacity", "nice", "channel", "SIZE", "empty", "offset", "sum", "iz", "ui", "sized", "mode", "bytes", "weight", "white", "number", "si", "form", "speed", "core", "length", "loc", "z", "sec", "count", "shape", "start", "en", "send", "Size", "ny", "storage", "sync", "content", "fe", "ii", "large", "sp", "sn", "max"], "dst": ["fst", "dnrc", "dcr", "dncr", " dsts", "fcr", "drc", "fsts", "dnsts", "frc", "dnst", "dsts", " dcr", " drc"]}}
{"project": "FFmpeg", "commit_id": "452ac2aaecf7210a2912d9156869c6314142a794", "target": 0, "func": "static void ripemd160_transform(uint32_t *state, const uint8_t buffer[64], int ext)\n\n{\n\n    uint32_t a, b, c, d, e, f, g, h, i, j;\n\n    uint32_t block[16];\n\n    int n;\n\n\n\n    if (ext) {\n\n        a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4];\n\n        f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9];\n\n    } else {\n\n        a = f = state[0];\n\n        b = g = state[1];\n\n        c = h = state[2];\n\n        d = i = state[3];\n\n        e = j = state[4];\n\n    }\n\n\n\n    for (n = 0; n < 16; n++)\n\n        block[n] = AV_RL32(buffer + 4 * n);\n\n\n\n    for (n = 0; n < 16 - 1;) {\n\n        ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_0_TO_15(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_0_TO_15(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_0_TO_15(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);\n\n    }\n\n    ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n    SWAP(a,f)\n\n\n\n    for (; n < 32 - 1;) {\n\n        ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_16_TO_31(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_16_TO_31(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_16_TO_31(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_16_TO_31(a,b,c,d,e,f,g,h,i,j);\n\n    }\n\n    ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n    SWAP(b,g)\n\n\n\n    for (; n < 48 - 1;) {\n\n        ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_32_TO_47(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_32_TO_47(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_32_TO_47(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_32_TO_47(e,a,b,c,d,j,f,g,h,i);\n\n    }\n\n    ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n    SWAP(c,h)\n\n\n\n    for (; n < 64 - 1;) {\n\n        ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_48_TO_63(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_48_TO_63(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_48_TO_63(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_48_TO_63(d,e,a,b,c,i,j,f,g,h);\n\n    }\n\n    ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n    SWAP(d,i)\n\n\n\n    for (; n < 75;) {\n\n        ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_64_TO_79(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_64_TO_79(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_64_TO_79(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_64_TO_79(c,d,e,a,b,h,i,j,f,g);\n\n    }\n\n    ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n    SWAP(e,j)\n\n\n\n    if (ext) {\n\n        state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e;\n\n        state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j;\n\n    } else {\n\n        i += c + state[1];\n\n        state[1] = state[2] + d + j;\n\n        state[2] = state[3] + e + f;\n\n        state[3] = state[4] + a + g;\n\n        state[4] = state[0] + b + h;\n\n        state[0] = i;\n\n    }\n\n}\n", "idx": 21766, "substitutes": {"state": ["handle", "class", "area", "config", "event", "power", "map", "pe", "part", "post", "key", "message", "order", "r", "info", "address", "use", "data", "seed", "list", "work", "context", "rule", "slice", "type", "object", "conn", "private", "style", "statement", "stat", "oper", "code", "o", "body", "element", "back", "pair", "position", "scope", "reg", "State", "space", "store", "mode", "layer", "model", "size", "patch", "p", "point", "memory", "form", "ver", "length", "manager", "group", "resource", "port", "view", "shape", "start", "down", "transfer", "m", "sync", "index", "se", "range", "states"], "buffer": ["shape", "table", "uffer", "message", "null", "queue", "bb", "bin", "offset", "transfer", "size", "program", "seed", "number", "code", "count", "buf", "memory", "header", "timeout", "cb", "num", "source", "byte", "window", "counter", "channel", "length", "len", "iter", "Buffer", "append", "batch", "buff", "v", "image", "position", "bar", "record"], "ext": ["str", "Ext", "txt", "external", "flat", "esc", "xt", "end", "prot", "text", "ctr", "extra", "tr", "temp", "fp", "transfer", "nc", "ex", "enc", "code", "sync", "gz", "cut", "cb", "aux", " extend", "xp", "seq", "rev", "desc", "br", "append", "req", "EXT", "vert", "z", "sec", "flex", "expl", "empty", "secondary"], "a": ["fa", "aaa", "area", "ia", "ba", "A", "ca", "as", "ea", "y", "t", "ac", "u", "s", "m", "r", "ad", "ah", "da", "p", "at", "ace", "aw", "o", "am", "sa", "af", "action", "ar", "x", "w", "va", "aa", "ai", "ab", "ae", "z", "alpha", "v", "l", "base", "an"], "b": ["bc", "sb", "ba", "db", "be", "fb", "bb", "ca", "as", "y", "t", "r", "u", "eb", "s", "m", "ad", "ac", "p", "o", "wb", "q", "cb", "ch", "w", "aa", "bd", "ab", "bf", "v", "bh", "z", "bs", "l", "x", "an", "k"], "c": ["col", "cd", "con", "ca", "ci", "y", "t", "u", "r", "m", "s", "ac", "cat", "p", "cf", "cs", "o", "q", "cn", "ch", "dc", "w", "cy", "C", "z", "ce", "v", "l", "x", "ec", "k"], "d": ["md", "cd", "db", "dh", "ds", "df", "t", "y", "u", "r", "m", "s", "dd", "ad", "da", "nd", "p", "id", "o", "dy", "q", "dt", "dc", "w", "D", "di", "z", "v", "l", "x", "k"], "e": ["ee", "ie", "es", "en", "oe", "E", "be", "ed", "ef", "y", "t", "u", "r", "m", "s", "p", "o", "el", "fe", "w", "se", "er", "em", "element", "ei", "ae", "v", "ce", "z", "ne", "ge", "l", "x", "ec", "k"], "f": ["fa", "fc", "ph", "fi", "fs", "fb", "df", "y", "t", "u", "r", "m", "s", "p", "cf", "inf", "o", "q", "af", "el", "fe", "fr", "w", "fl", "fd", "F", "ff", "sf", "bf", "v", "z", "l", "x", "k"], "g": ["big", "ig", "en", "G", "err", "gi", "pg", "y", "t", "u", "r", "m", "s", "p", "o", "gg", "q", "gen", "sh", "ch", "go", "w", "in", "he", "er", "gh", "di", "gs", "v", "z", "group", "gm", "ge", "l", "x", "k"], "h": ["ih", "en", "ul", "err", "hs", "ha", "oh", "y", "t", "u", "r", "m", "s", "ah", "kh", "ht", "wh", "it", "eh", "p", "id", "o", "rh", "q", "uh", "H", "sh", "ch", "hr", "w", "he", "hl", "gh", "th", "hi", "html", "z", "v", "bh", "l", "x", "ph", "k", "hh"], "i": ["io", "ie", "fi", "pi", "gi", "I", "ci", "y", "t", "u", "r", "m", "s", "it", "phi", "p", "id", "o", "bi", "q", "is", "sh", "si", "ii", "in", "w", "ic", "ai", "di", "v", "z", "li", "l", "x", "k"], "j": ["io", "je", "ie", "obj", "jp", "key", "y", "t", "r", "u", "m", "uj", "s", "it", "p", "o", "q", "aj", "js", "el", "sh", "si", "J", "ch", "ii", "ji", "w", "ij", "jc", "v", "z", "li", "jo", "l", "x", "k"], "block": [" Block", "row", "object", "null", "BL", "bin", "bl", "node", "offset", "bit", "lock", "ip", "unit", "number", "out", "header", "frame", "num", "byte", "blocks", "channel", "length", "slice", "page", "batch", "array", "group", "image", "Block", "position", "base", "output", "pack", "type"], "n": ["net", "name", "un", "en", "conn", "adj", "nn", "an", "mn", "not", "node", "no", "dn", "t", "y", "N", "r", "m", "nc", "u", "s", "size", "p", "na", "number", "o", "network", "nr", "num", "w", "ns", "len", "nb", "z", "v", "nt", "sn", "fn", "nu", "l", "x", "pn", "ne", "k", "nm", "ni", "count"]}}
{"project": "FFmpeg", "commit_id": "bc7eb330e3d42f6cff3f95432da999bd4538e2e1", "target": 0, "func": "static void opt_frame_size(const char *arg)\n\n{\n\n    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n\n        fprintf(stderr, \"Incorrect frame size\\n\");\n\n        av_exit(1);\n\n    }\n\n    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n\n        fprintf(stderr, \"Frame size must be a multiple of 2\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n", "idx": 21767, "substitutes": {"arg": ["arc", "argument", "ang", "ig", "valid", "g", "age", "val", "inc", "ay", "mor", "Arg", "as", "other", "ac", "axis", "use", "args", "ad", "cat", "new", "arr", "play", "enc", "ace", "mac", "var", "gen", "ar", "flag", "arm", "par", "ag", "ax", "sec", "lang", "ma", "param", "empty", "inter"]}}
{"project": "FFmpeg", "commit_id": "20fe316e47fedb28787e77e77a7011133f3d4e73", "target": 1, "func": "static int sdl_write_trailer(AVFormatContext *s)\n\n{\n\n    SDLContext *sdl = s->priv_data;\n\n\n\n    sdl->quit = 1;\n\n\n\n    if (sdl->overlay)\n\n        SDL_FreeYUVOverlay(sdl->overlay);\n\n\n    if (sdl->event_thread)\n\n        SDL_WaitThread(sdl->event_thread, NULL);\n\n\n    if (sdl->mutex)\n\n        SDL_DestroyMutex(sdl->mutex);\n\n\n    if (sdl->init_cond)\n\n        SDL_DestroyCond(sdl->init_cond);\n\n\n\n\n    if (!sdl->sdl_was_already_inited)\n\n        SDL_Quit();\n\n\n\n    return 0;\n\n}", "idx": 21776, "substitutes": {"s": ["sv", "i", "sb", "e", "sl", "g", "ses", "su", "d", "ds", "services", "f", "sys", "t", "m", "storage", "ssl", "p", "cs", "ls", "o", "sg", "c", "ctx", "js", "spec", "sq", "si", "sc", "a", "b", "w", "n", "ns", "south", "gs", "v", "l", "ss"], "sdl": ["ddn", "ldll", " sdlc", " sdle", "ldel", "gdls", "tdl", "gdl", "ddel", "dsel", "wdsl", "sdL", "ddlp", "dddl", "ldlp", "ddpl", "gdel", "ldlc", "ddle", "sdls", "dslp", "eddli", "SDlc", "dsla", "sddl", "gdsl", "dsn", " sdL", "ldL", "ldl", "svl", "dlll", "sdli", "wdl", "dlsl", "ddls", "tdll", "ddla", "sdle", " sdel", "sdel", "ddlc", "dll", "ddll", "sdpl", "SDll", "ldsl", " sddl", "ldle", "wdL", "SDn", "sdsl", "eddl", "lddl", " sdr", "gdlc", "ddsl", "SDpl", "dlL", "svn", "sdla", "tdle", "SDsl", "gdld", "tdlc", "sdr", "sdn", "sdll", "sdlp", "ddli", "ddr", "gdll", "ddL", "eddL", "SDld", "dslc", " sdll", "ldn", "ldla", "dsl", "gdr", "svpl", "SDli", "sdld", "SDL", "sdlc", " sdls", "svlc", "SDl", "wdll", "dsll", "ldld", "ddl", "eddll", "dsL"]}}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "void MPV_decode_mb(MpegEncContext *s, DCTELEM block[6][64])\n\n{\n\n    int mb_x, mb_y;\n\n    int dct_linesize, dct_offset;\n\n    op_pixels_func *op_pix;\n\n    qpel_mc_func *op_qpix;\n\n\n\n    mb_x = s->mb_x;\n\n    mb_y = s->mb_y;\n\n\n\n#ifdef FF_POSTPROCESS\n\n    quant_store[mb_y][mb_x]=s->qscale;\n\n    //printf(\"[%02d][%02d] %d\\n\",mb_x,mb_y,s->qscale);\n\n#endif\n\n\n\n    /* update DC predictors for P macroblocks */\n\n    if (!s->mb_intra) {\n\n        if (s->h263_pred || s->h263_aic) {\n\n          if(s->mbintra_table[mb_x + mb_y*s->mb_width])\n\n          {\n\n            int wrap, xy, v;\n\n            s->mbintra_table[mb_x + mb_y*s->mb_width]=0;\n\n            wrap = 2 * s->mb_width + 2;\n\n            xy = 2 * mb_x + 1 +  (2 * mb_y + 1) * wrap;\n\n            v = 1024;\n\n            \n\n            s->dc_val[0][xy] = v;\n\n            s->dc_val[0][xy + 1] = v;\n\n            s->dc_val[0][xy + wrap] = v;\n\n            s->dc_val[0][xy + 1 + wrap] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[0][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + wrap], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1 + wrap], 0, 16 * sizeof(INT16));\n\n            if (s->h263_msmpeg4) {\n\n                s->coded_block[xy] = 0;\n\n                s->coded_block[xy + 1] = 0;\n\n                s->coded_block[xy + wrap] = 0;\n\n                s->coded_block[xy + 1 + wrap] = 0;\n\n            }\n\n            /* chroma */\n\n            wrap = s->mb_width + 2;\n\n            xy = mb_x + 1 + (mb_y + 1) * wrap;\n\n            s->dc_val[1][xy] = v;\n\n            s->dc_val[2][xy] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[1][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[2][xy], 0, 16 * sizeof(INT16));\n\n          }\n\n        } else {\n\n            s->last_dc[0] = 128 << s->intra_dc_precision;\n\n            s->last_dc[1] = 128 << s->intra_dc_precision;\n\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n\n        }\n\n    }\n\n    else if (s->h263_pred || s->h263_aic)\n\n        s->mbintra_table[mb_x + mb_y*s->mb_width]=1;\n\n\n\n    /* update motion predictor, not for B-frames as they need the motion_val from the last P/S-Frame */\n\n    if (s->out_format == FMT_H263) { //FIXME move into h263.c if possible, format specific stuff shouldnt be here\n\n      if(s->pict_type!=B_TYPE){\n\n        int xy, wrap, motion_x, motion_y;\n\n        \n\n        wrap = 2 * s->mb_width + 2;\n\n        xy = 2 * mb_x + 1 + (2 * mb_y + 1) * wrap;\n\n        if (s->mb_intra) {\n\n            motion_x = 0;\n\n            motion_y = 0;\n\n            goto motion_init;\n\n        } else if (s->mv_type == MV_TYPE_16X16) {\n\n            motion_x = s->mv[0][0][0];\n\n            motion_y = s->mv[0][0][1];\n\n        motion_init:\n\n            /* no update if 8X8 because it has been done during parsing */\n\n            s->motion_val[xy][0] = motion_x;\n\n            s->motion_val[xy][1] = motion_y;\n\n            s->motion_val[xy + 1][0] = motion_x;\n\n            s->motion_val[xy + 1][1] = motion_y;\n\n            s->motion_val[xy + wrap][0] = motion_x;\n\n            s->motion_val[xy + wrap][1] = motion_y;\n\n            s->motion_val[xy + 1 + wrap][0] = motion_x;\n\n            s->motion_val[xy + 1 + wrap][1] = motion_y;\n\n        }\n\n      }\n\n    }\n\n    \n\n    if (!(s->encoding && (s->intra_only || s->pict_type==B_TYPE))) {\n\n        UINT8 *dest_y, *dest_cb, *dest_cr;\n\n        UINT8 *mbskip_ptr;\n\n\n\n        /* avoid copy if macroblock skipped in last frame too \n\n           dont touch it for B-frames as they need the skip info from the next p-frame */\n\n        if (s->pict_type != B_TYPE) {\n\n            mbskip_ptr = &s->mbskip_table[s->mb_y * s->mb_width + s->mb_x];\n\n            if (s->mb_skiped) {\n\n                s->mb_skiped = 0;\n\n                /* if previous was skipped too, then nothing to do ! \n\n                   skip only during decoding as we might trash the buffers during encoding a bit */\n\n                if (*mbskip_ptr != 0 && !s->encoding) \n\n                    goto the_end;\n\n                *mbskip_ptr = 1; /* indicate that this time we skiped it */\n\n            } else {\n\n                *mbskip_ptr = 0; /* not skipped */\n\n            }\n\n        }\n\n\n\n        dest_y = s->current_picture[0] + (mb_y * 16 * s->linesize) + mb_x * 16;\n\n        dest_cb = s->current_picture[1] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n        dest_cr = s->current_picture[2] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n\n\n        if (s->interlaced_dct) {\n\n            dct_linesize = s->linesize * 2;\n\n            dct_offset = s->linesize;\n\n        } else {\n\n            dct_linesize = s->linesize;\n\n            dct_offset = s->linesize * 8;\n\n        }\n\n\n\n        if (!s->mb_intra) {\n\n            /* motion handling */\n\n            if((s->flags&CODEC_FLAG_HQ) || (!s->encoding)){\n\n                if ((!s->no_rounding) || s->pict_type==B_TYPE){                \n\n                    op_pix = put_pixels_tab;\n\n                    op_qpix= qpel_mc_rnd_tab;\n\n                }else{\n\n                    op_pix = put_no_rnd_pixels_tab;\n\n                    op_qpix= qpel_mc_no_rnd_tab;\n\n                }\n\n\n\n                if (s->mv_dir & MV_DIR_FORWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture, op_pix, op_qpix);\n\n                    if ((!s->no_rounding) || s->pict_type==B_TYPE)\n\n                        op_pix = avg_pixels_tab;\n\n                    else\n\n                        op_pix = avg_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* add dct residue */\n\n            add_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            add_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            add_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            add_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            add_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            add_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        } else {\n\n            /* dct only in intra block */\n\n            put_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            put_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            put_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            put_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            put_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            put_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        }\n\n    }\n\n the_end:\n\n    emms_c(); //FIXME remove\n\n}\n", "idx": 21779, "substitutes": {"s": ["ions", "sv", "i", "bis", "es", "xs", "ds", "sys", "y", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "ms", "n", "S", "ns", "ins", "rs", "conf", "http", "ans", "l", "ss", "an", "sim", "sb", "g", "ses", "sets", "site", "services", "enc", "o", "sites", "sg", "c", "self", "spec", "a", "sf", "su", "e", "sym", "qs", "space", "fs", "sis", "f", "t", "full", "p", "si", "b", "service", "parts", "sup", "side", "ps", "gs", "h", "x", "sq", "ops", "ks", "m", "its", "vs", "ls", "sync", "is", "client", "settings", "w", "se", "session", "comments", "states"], "block": ["bc", " Block", "obj", "BL", " arr", "bl", " bl", "buffer", "MODE", "size", "data", " BL", "arr", "buf", "out", " chunk", "frame", "byte", "mem", "blocks", " blocks", "image", "Block", "record", "output", "type"], "mb_x": ["MB_X", "mbamexs", "mb00x", "lim_ey", "mb_wx", "amp_x", "mb_X", "mp_x", "mb67y", "mb_ey", "MB_y", "mp_wy", "lim_name", "mb_w", "limamex", "mb00base", "limameey", "eb_height", "amp_y", "mp_tx", "mb_base", "lim_x", "eb_wx", "mb_tx", "mb_xs", "mb_on", "mb00y", "eb_y", "amp00x", "mb33x", "lim_xs", "limamexs", "MB_xx", "amp00size", "mb00size", "mb00ey", "limamename", "amp00base", "mb67x", "mp_y", "mbxx", "mb_xx", "mbxX", "mb33name", "MB_x", "mp_z", "mb_wy", "mb_height", "mb00xs", "mb33ey", "mbamex", "mb67z", "mp_on", "mb00name", "mbxxx", "mb_z", "mb_size", "mb33xs", "mp_w", "amp_size", "mb_width", "mb_name", "mbameey", "amp00y", "amp_base", "mp_width", "mb67wy", "eb_x", "mbamename", "mbxy"], "mb_y": ["mb_yo", "kb_y", "mp_x", "mb67y", "mb_ey", "mm_x", "mb_sy", "sm67Y", "mb_vy", "mb___y", "amb_yi", "mn_y", "mp_yl", "mm_yo", "mb_yl", "sm67y", "mb67iy", "mm_sy", "mb_i", "amb_dy", "mn_z", "mb___yo", "sm67iy", "amb_yo", "mp_y", "sm_y", "kb_ey", "mb_Y", "sm_yd", "amb_y", "sm_Y", "mb_dy", "kb_i", "mb_iy", "mp_z", "mb08Y", "mp_ya", "mm_y", "mb___x", "mb__vy", "mb67yd", "mp_vy", "mb_yi", "mb08iy", "mb08y", "sm_iy", "mn_yd", "mb__yl", "sm67yd", "kb_sy", "mb_yd", "mb_z", "mb__x", "mb67Y", "mn_x", "mb_ya", "mb08yd", "mb__y", "mb___sy"], "dct_linesize": ["dct_codesizes", "dct_linesizes", "dct_filesiz", "dct_pagessize", "dct_linessize", "dct_linesiz", "dct_codessize", "dct_filessize", "dct_codesiz", "dct_codesize", "dct_pagesizes", "dct_pagesize", "dct_filesizes", "dct_filesize", "dct_pagesiz"], "dct_offset": ["dct_auto", "dct_padding", "dctpoffset", "dctppadding", "dCT_auto", "dct_pos", "dctppos", "dCT_padding", "dCT_pos", "dctpauto", "dCT_offset"], "op_pix": ["op_cpix", "op_vpow", "op_cpixel", "op_fpix", "op_vpix", "op_vpixel", "op_pow", "op_cpik", "op_vpik", "op_pixel", "op_cpow", "op_fpow", "op_pik", "op_fpik", "op_fpixel"], "op_qpix": ["op_qnpx", "op_sqpius", "op_sqwpix", "op_qvpx", "op_qwpius", "op_qvpixels", "op_qwpx", "op_sqwpius", "op_sqwpixels", "op_sqpix", "op_qwpixels", "op_qnpix", "op_qnpixels", "op_sqpixels", "op_sqwpx", "op_qvpius", "op_qpx", "op_sqpx", "op_qnpius", "op_qpius", "op_qpixels", "op_qwpix", "op_qvpix"], "wrap": ["step", "wind", "wa", "force", "pad", "wave", "win", "use", "work", "wb", "rw", "shift", "crop", "live", "xxxx", "window", "fw", "comb", "wx", "grid", "format", "cap", "end", "late", "rap", "rx", "style", "align", "wra", "split", "write", "coord", "lock", "code", "strip", "lace", "replace", "space", "wrapper", "xxx", "margin", "weight", "box", "zip", "patch", "play", "grow", "cut", "edge", "sw", "length", "html", "wait", "cover", "quad", "count", "span", "start", "fold", "word", "close", "move", "run", "wy", "quote", "w", "read", "sp", "scroll", "max"], "xy": ["step", "tight", "lat", "exe", "xe", "val", "key", "xx", "no", "yt", "pie", "pos", "y", "proxy", "phy", "cat", "tiny", "dy", "wb", "live", "px", "xxxx", "dim", "ele", "comb", "iter", "wx", "cgi", "route", "yy", "rx", "yo", "pipe", "mie", "dj", "coord", "opt", "axy", "zx", "code", "rh", "quick", "lim", "gone", "dom", "try", "xb", "ie", "offset", "flat", "kid", "xxx", "f", "fit", "gay", "xf", "zip", "uv", "gy", "mid", "num", "tmp", "zh", "loc", "xxxxxxxx", "html", "note", "quad", "x", "XY", "fo", "gb", "biz", "layout", "home", "lite", "slot", "py", "cue", "lo", "index", "hide", "die", "wy", "xp", "w", "tw", "vp", "photo"], "v": ["tv", "sv", "i", "e", "V", "vt", "lv", "g", "iv", "val", "cv", "f", "t", "y", "u", "m", "size", "p", "uv", "vs", "vi", "o", "var", "c", "ver", "b", "vr", "w", "n", "vv", "va", "ve", "vert", "z", "vp", "h", "cover", "l", "x", "ev", "k", "value"]}}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n", "idx": 21794, "substitutes": {"ram_addr": ["rampaddress", " ram_offset", " ram_size", "gram_address", "gram_nr", "ram_nr", " ramacaddress", "ram__addr", "ram_attr", "ram_ref", "ram64size", "gram_host", "ramxaddr", "ramamnr", "gram_addr", "ram_ad", " ramacoffset", "ram2ad", "ram2address", "ram_offset", "ram__address", "ramfaddress", "rampaddr", "ramxaddress", "gram_ref", "ramxalign", "ram_hop", "ram2addr", "ramacaddr", "ram2ref", "ram_align", "ram_address", "ram64address", "ram__host", " ramacsize", "ramfaddr", "gram_ad", "ram64addr", "ramfhop", "ramacoffset", "ramamaddr", "ramfhost", "ramamattr", "gram_hop", "ramacaddress", "gram_attr", "ramxnr", "rampad", "ram__hop", "ramacsize", "gram_align", "ram64offset", "ram_size", " ramacaddr", "ram_host", "rampref", "ramamaddress", " ram_address"], "page": ["pb", "Page", "view", "row", "e", "next", "lp", "item", "result", "age", "inc", "pe", "layout", " Page", "site", "pc", "node", "blog", "model", "pg", "write", "per", "order", "section", "entry", "data", "cache", "new", "pp", "p", "list", "current", "load", "comment", "content", "pool", "c", "module", "pl", "index", "collection", "plus", "document", "peer", "gp", "x", "line", "core", "child", "large", "feed", "skip", "see", "parent", "ae", "group", "instance", "image", "server", "ge", "block", "record", "www"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int decode_i_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n    return 0;\n\n}\n", "idx": 21796, "substitutes": {"v": ["conv", "tv", "sv", "inv", "i", "lc", "serv", "nv", "V", "lv", "iv", "vt", "g", "vim", "av", "gu", "val", "cv", "d", "vd", "ou", "f", "t", "u", "m", "s", "vic", "j", "dev", "vu", "p", "vs", "version", "uv", "vi", "o", "q", "var", "c", "ver", "b", "ov", "w", "value", "volt", "rev", "vol", "vv", "n", "va", "ve", "vert", "vm", "vp", "h", "ev", "l", "k", "video", "vc"], "gb": ["gio", "bc", "wm", "sb", "gpu", "usb", "ui", "g", "gu", "mb", "db", "gnu", "gi", "pm", "bb", "vg", "gin", "ged", "pc", "gd", "ci", "Gb", "ga", "bg", "gru", "storage", "agg", "bn", "gy", "kb", "gg", "cli", "gz", "gae", "sg", "cb", "ctx", "cfg", "gp", "gui", "b", "bo", "hub", "gc", "bm", "gh", "cca", "nb", "gs", "buff", "bf", "lib", "gam", "tm", "gom", "GB", "rb", "gm", "cgi", "ge", "kw", "abb", "rg"], "pqindex": ["pchindex", "dqcount", "pqoffset", "piqpage", " pQindex", "ppqlindex", "pippage", " pQoffset", "ppqlpage", "pqcount", "pkIndex", "pipdate", "pqaddress", "pqsize", "jpqoffset", "jpqsearch", "ppqldate", "pquoffset", "pqlpage", "jpqusearch", "pcklevel", "piqdate", "pvindex", "pqnum", "pqaoffset", "jpquoffset", "pvoffset", "pqadesign", "pplevel", " pQsize", " pQnum", "pquindex", " pqoffset", "pqpage", "ppqnumber", "jpqudesign", "dquindex", "pqulevel", "pqasearch", "ppqdate", "pchoffset", "dqulevel", "jpqindex", "pipnumber", "pQnum", "pqlevel", "pqnumber", " pqnum", "ppindex", "pckcount", "jpqdesign", "ppcount", "dqindex", "pquaddress", "dqucount", "dqlevel", "pQoffset", "pchsize", "ppqlnumber", "piqnumber", "pdqsize", "ppqindex", "pqusearch", "pqudesign", "pqsearch", "pdqoffset", "Pkaddress", "pqucount", "PqIndex", "pckindex", "ppqpage", "piqindex", "pqaindex", "pqlindex", "Pqindex", "pipindex", "pkindex", "PkIndex", "jpquindex", "pquIndex", "pvsearch", "pkaddress", "pqldate", "pqIndex", " pqsize", "Pkindex", "pQindex", "Pqaddress", "pdqnum", "pdqindex", "pchnum", "pQsize", "pqlnumber", "pqdate", "pqdesign", "pvdesign"]}}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n", "idx": 21820, "substitutes": {"s": ["sb", "phys", "i", "e", "sym", "bis", "es", "g", "ses", "ssh", "sets", "ops", "ds", "services", "f", "t", "r", "m", "ssl", "os", "p", "o", "sync", "is", "js", "c", "si", "b", "service", "S", "ns", "south", "rs", "http", "ss"], "mmcfg_addr": ["mmcfg_ad", "mmconfig_address", "mmcfg_src", "mmcfg_offset", "mmconfig_ord", "mmcfg67address", "mmcfgIPad", "mmcfg_ord", "mmcfg67src", "mmcfg_address", "mmcfgIPoffset", "mmcfgIPaddr", "mmcfg67addr", "mmconfig_src", "mmconfig_ad", "mmcfgIPaddress", "mmconfig_offset", "mmcfg67ord", "mmconfig_addr"], "val": ["sel", "def", "ref", "sl", "valid", "ind", "key", "bin", "bl", "ld", "local", "fat", "split", "al", "data", "ret", "arr", "enc", "vals", "slot", "elt", "count", "el", "aval", "b", "mem", "x", "seq", "vol", "VAL", "Val", "v", "all", "eval", "pt", "base", "value"], "len": ["lc", "en", "end", "ln", "ld", "f", "pos", "lan", "split", "size", "data", "fin", "id", "lin", "ls", "elt", "le", "lo", "L", "el", "lim", "num", "lif", "line", "seq", "fl", "n", "length", "lon", "v", "z", "li", "lf", "l", "Len", "count"], "pci_dev": ["pci0dev", "pci_debug", "pci2Dev", "pki_device", "pci__Dev", "pci__dev", "pcin_dev", "pci_ev", "pcin_device", "pcinacdef", "pci2def", "pci_def", "pci_rad", "pcin_def", "pcinacdevice", "pki_dev", "pci2dev", "pai_rad", "pci_device", "pki_ev", "pai_debug", "pcinacdev", "pcin_data", "pci__ev", "pci__def", "pcinacdata", "pciacdev", "pci2ev", "pci_Dev", "pci_data", "pci0device", "pai_device", "pci0rad", "pciacdata", "pai_dev", "pciacdef", "pciacdevice", "pci0debug", "pki_Dev", "pki_def"]}}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n", "idx": 21822, "substitutes": {"s": ["ions", "sv", "i", "sb", "e", "outs", "sym", "qs", "es", "hs", "fs", "g", "ses", "xs", "features", "als", "lines", "sets", "ops", "site", "ks", "as", "ds", "services", "css", "f", "sys", "t", "less", "m", "args", "ssl", "os", "ts", "cs", "p", "us", "ls", "o", "sync", "is", "ss", "c", "js", "settings", "spec", "self", "si", "ads", "a", "b", "aws", "se", "ms", "ims", "parts", "S", "ns", "words", "ps", "rs", "gs", "ins", "v", "conf", "ans", "ats", "l", "x", "sq"], "n": [" N", "i", "e", "en", "conn", "nn", "g", "d", "node", "f", "nl", "t", "y", "N", "nc", "m", "r", "j", "u", "p", "o", "c", "nr", "num", "b", "w", "min", "ns", "len", "nb", "z", "nt", "sn", "nor", "h", "all", "l", "x", "ne", "k", "ni", "nos"], "bit_index": ["bit_num", "bit_end", "boot_index", "bitzind", "bitzend", "bitfindex", "data_position", "bit_value", "byte_index", "datakindex", "bits_length", "bit_Index", "bitklength", "bit_range", "boot_ind", "bitfvalue", "data_num", "bit_len", "bit_ind", "byte_width", "dataklength", "bit_width", " bit_ind", "byte_len", "bitzindex", "bitkindex", "byte_value", "bits_limit", "bitfwidth", "data_length", "bit_length", "data_index", "bits_index", "bit_position", "boot_end", "datakposition", "boot_range", "bitknum", "bitkposition", "dataknum", "bits_width", "bitzrange", " bit_Index", "bitflen", "bit_limit", " bit_width"], "buf": ["conv", "bc", "uf", "uc", "brace", "off", "av", "cv", "ctr", "queue", "func", "cur", "home", "img", "cas", "buffer", "path", "alloc", "bu", "cmd", "box", "data", "cache", "cf", "wb", "pool", "rc", "cb", "header", "ctx", "raw", "seq", "desc", "fd", "src", "len", "br", "comb", "loc", "ab", "feed", "batch", "buff", "parent", "doc", "vec", "rb", "bag", "dest", "fam", "cap"]}}
{"project": "FFmpeg", "commit_id": "bf252f7f6fa9c79743242f3efdd30827c97407b4", "target": 0, "func": "static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    char *str = NULL;\n\n    int size;\n\n    uint16_t str_size;\n\n\n\n    if (c->itunes_metadata) {\n\n        int data_size = get_be32(pb);\n\n        int tag = get_le32(pb);\n\n        if (tag == MKTAG('d','a','t','a')) {\n\n            get_be32(pb); // type\n\n            get_be32(pb); // unknown\n\n            str_size = data_size - 16;\n\n        } else return 0;\n\n    } else {\n\n        str_size = get_be16(pb); // string length\n\n        get_be16(pb); // language\n\n    }\n\n    switch (atom.type) {\n\n    case MKTAG(0xa9,'n','a','m'):\n\n        str = c->fc->title; size = sizeof(c->fc->title); break;\n\n    case MKTAG(0xa9,'A','R','T'):\n\n    case MKTAG(0xa9,'w','r','t'):\n\n        str = c->fc->author; size = sizeof(c->fc->author); break;\n\n    case MKTAG(0xa9,'c','p','y'):\n\n        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;\n\n    case MKTAG(0xa9,'c','m','t'):\n\n    case MKTAG(0xa9,'i','n','f'):\n\n        str = c->fc->comment; size = sizeof(c->fc->comment); break;\n\n    case MKTAG(0xa9,'a','l','b'):\n\n        str = c->fc->album; size = sizeof(c->fc->album); break;\n\n    }\n\n    if (!str)\n\n        return 0;\n\n    get_buffer(pb, str, FFMIN(size, str_size));\n\n    dprintf(c->fc, \"%.4s %s\\n\", (char*)&atom.type, str);\n\n    return 0;\n\n}\n", "idx": 21828, "substitutes": {"c": ["lc", "bc", "fc", "cd", "cc", "e", "uc", "ct", "config", "g", "coll", "com", "cv", "cm", "d", "con", "rec", "pc", "cur", "cl", "cu", "f", "anc", "ci", "cmp", "t", "cell", "nc", "ac", "m", "s", "u", "cp", "cache", "p", "cs", "xc", "cf", "enc", "tc", "context", "mc", "current", "rc", "ctx", "cn", "icc", "sc", "ch", "b", "dc", "ic", "cy", "cr", "C", "cus", "co", "z", "ce", "cod", "cit", "l", "ec", "k", "vc"], "pb": ["lc", "bc", "platform", "sb", "fc", "lb", "uc", "plain", "jp", "lp", "prot", "db", "fb", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "PB", "tp", "pp", "p", "tc", "wb", "bps", "py", "cb", "ctx", "pl", "wp", "pro", "ib", "mp", "cpp", "bm", "ab", "bf", "proc", "bh", "bs", "rb", "xb", "api", "dp", "abb", "pa"], "atom": ["operator", "bc", "mol", "article", "sym", "object", "obj", "om", "config", "item", "com", "chem", "container", "cm", "mag", "bb", "orb", "temp", "mom", "node", "atomic", "cell", "entity", "term", "op", " Atom", "ac", "acc", "m", " bom", "component", "url", "tc", "abc", "species", "tom", " ac", "tag", "xml", "num", "module", " com", "comm", "orbit", "kat", "element", "carbon", "canon", "html", "doc", "car", "http", "tm", "chrom", "typ", "instance", "param", " atoms", "attr", "prop"], "str": ["status", "lc", "i", "name", "txt", "e", "Str", "expr", "obj", "err", "sl", "g", "text", "coll", "input", "ctr", "key", "tr", "style", "uri", "bytes", "temp", "bl", "buffer", "pos", "exec", " Str", "r", "u", "ini", "data", "init", "strings", "arr", "enc", "unit", "code", "inner", "strip", "dr", "ext", "spec", "fr", "ar", "hr", "sr", "ptr", "read", "cr", "inst", "gr", "len", "br", "iter", "stri", "doc", "st", "sp", "orig", "empty", "url", "STR"], "size": ["handle", "esc", "ize", "pos", "address", "use", "shift", "small", "go", "type", "name", "password", "scale", "g", "style", "ci", "enc", "unit", "code", "complete", "capacity", "SIZE", "empty", "strength", "sum", "e", "err", "ui", "time", "sized", "weight", "full", "score", "si", "speed", "length", "loc", "z", "x", "count", "shape", "external", "en", "send", "Size", "args", "storage", "word", "sync", "index", "len", "large", "grade", "sn", "max"], "str_size": ["data_SIZE", "data_sized", " str_length", " str_set", " str_len", "str_set", "str_len", "str_width", " str_width", "data_width", "data_length", "data_size", "str_name", "str_SIZE", " str_name", "data_len", "str_sized", "str_length"]}}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n", "idx": 21836, "substitutes": {"ctx": ["lc", "bc", "git", "cc", "wcs", "support", "conn", "ct", "config", "pkg", "cv", "cm", "connection", "tx", "ca", "Context", "pc", "css", "cl", "cas", "anc", "ci", "cmp", "exec", "nc", "cmd", "cp", "p", "cs", "cf", "xc", "ctrl", "tc", "context", "mac", "cli", "mc", "rc", "c", "cb", "cn", "cfg", "sc", "cal", "comp", "dc", "cpp", "gc", "qa", "cr", "fw", "loc", "console", "cca", "co", "cus", "cms", "ce", "hw", "ck", "cu", "vc"], "errp": ["Erfp", "erfp", " errfp", "errpc", "Erp", "err", "Erpc", "erp", "errr", " errpc", " errr", "errfp", "erpc", "Err"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n\n                                        int buf_size, AVSubtitle *sub)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n\n\n    DVBSubRegion *region;\n\n    DVBSubRegionDisplay *display;\n\n    AVSubtitleRect *rect;\n\n    DVBSubCLUT *clut;\n\n    uint32_t *clut_table;\n\n    int i;\n\n    int offset_x=0, offset_y=0;\n\n\n\n    sub->rects = NULL;\n\n    sub->start_display_time = 0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    sub->format = 0;\n\n\n\n    if (display_def) {\n\n        offset_x = display_def->x;\n\n        offset_y = display_def->y;\n\n    }\n\n\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects <= 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,\n\n                                  sizeof(*sub->rects));\n\n    if (!sub->rects)\n\n        return AVERROR(ENOMEM);\n\n\n\n    i = 0;\n\n\n\n    for (display = ctx->display_list; display; display = display->next) {\n\n        region = get_region(ctx, display->region_id);\n\n        rect = sub->rects[i];\n\n\n\n        if (!region)\n\n            continue;\n\n\n\n        rect->x = display->x_pos + offset_x;\n\n        rect->y = display->y_pos + offset_y;\n\n        rect->w = region->width;\n\n        rect->h = region->height;\n\n        rect->nb_colors = 16;\n\n        rect->type      = SUBTITLE_BITMAP;\n\n        rect->pict.linesize[0] = region->width;\n\n\n\n        clut = get_clut(ctx, region->clut);\n\n\n\n        if (!clut)\n\n            clut = &default_clut;\n\n\n\n        switch (region->depth) {\n\n        case 2:\n\n            clut_table = clut->clut4;\n\n            break;\n\n        case 8:\n\n            clut_table = clut->clut256;\n\n            break;\n\n        case 4:\n\n        default:\n\n            clut_table = clut->clut16;\n\n            break;\n\n        }\n\n\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n        if (!rect->pict.data[1]) {\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n\n        if (!rect->pict.data[0]) {\n\n            av_free(rect->pict.data[1]);\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n\n\n        i++;\n\n    }\n\n\n\n    sub->num_rects = i;\n\n\n\n#ifdef DEBUG\n\n    save_display_set(ctx);\n\n#endif\n\n\n\n    return 1;\n\n}\n", "idx": 21841, "substitutes": {"avctx": ["vercontext", "verconn", "verctx", "evconn", "avconn", "AVcli", "AVctrl", "AVcontext", "evcontext", "amctx", "evctrl", "avcontext", "amcontext", "AVconn", "avalctrl", "avalcli", "amcli", "avalctx", "evctx", "AVctx", "avalcontext", "avctrl", "avcli", "amctrl", "verctrl"], "buf": ["conv", "port", "uf", "ref", "map", "cv", "queue", "img", "buffer", "alloc", "cmd", "box", "cache", "pool", "rc", "cb", "mem", "seq", "src", "br", "batch", "buff", "proc", "conf", "vec", "rb", "block"], "buf_size": ["buf_small", " buffer8len", " buffer8small", "buf8small", " buffer_len", " buffer_small", "buf8size", " buffer_size", " buffer8size", "buf8len", "buf_len"], "sub": ["app", "config", "part", "address", "submit", "small", "pl", "dim", "src", "slice", "ab", "http", "conf", "image", "this", "type", "pub", "sim", "sb", "text", "split", "builder", "pre", "trans", "ext", "sc", "hub", "desc", "child", "feed", "Sub", "lib", "sum", "remote", "reg", "public", "summary", "sel", "uc", "ref", "queue", "func", "exec", "section", "full", "new", "job", "comment", "form", "b", "sup", "loc", "sec", "user", "children", "pb", "shape", "project", "input", "ubs", "plugin", "home", "build", "rob", "super", "abc", "py", "client", "hide", "search", "match", "ub", "sing", "rub", "block", "server", "um"], "ctx": ["lc", "bc", "git", "sync", "fc", "cc", "cam", "wcs", "uc", "conn", "sci", "config", "ha", "progress", "pkg", "cv", "chan", "cm", "tx", "ca", "Context", "anc", "cas", "cl", "cu", "ci", "cmp", "exec", "fp", "cmd", "cp", "data", "storage", "cf", "xc", "cs", "ctrl", "kb", "context", "que", "cli", "mac", "rc", "c", "cb", "cn", "client", "cfg", "sc", "comp", "ocr", "hub", "qa", "media", "src", "fw", "loc", "cca", "utils", "buff", "cms", "lib", "ck", "kw", "concept", "sq", "pub"], "display_def": ["process_manager", "displayerDef", "displayabledef", "displayabledefinition", "displayaldesign", "screenerconf", "displayacdefine", "displayername", "display_config", "displayJconfig", "regionaddel", "display_conf", "process_def", "winADdefault", "displayWdef", "screenerdist", "display_del", "displayADdev", "displayADdefault", "win_def", "displayitydef", "displayADdefine", "displayerdef", "displayerconf", "screen_dist", "displayerdefine", "regionadconfig", "display_design", "display_dev", "displayabledist", "displayermanager", "winADdefine", "win_default", "regionaddef", "displayalconfig", "displayaddel", "screen_def", "displayaddesign", "win_dev", "screen_conf", "region_design", "displayacdefault", "displayalconf", "displayaldefinition", "displayWDef", "displayWmanager", "display_manager", "process_Def", "processWdef", "display_default", "screen_definition", "displayableconf", "region_config", "displayacdef", "regionaddesign", "displayadconfig", "processWmanager", "displayaddef", "displayacdev", "processWname", "displayJdel", "displayerdist", "win_define", "displayWname", "displayerdefault", "process_name", "display_Def", "displayaldist", "displayityname", "region_del", "displayerdev", "displayADdef", "displayJdef", "displayaldel", "screenerdef", "displayityDef", "displayitymanager", "display_name", "displayerdefinition", "display_dist", "display_definition", "screenerdefinition", "displayJdesign", "processWDef", "display_define", "region_def", "winADdev", "winADdef", "displayaldef"], "region": ["remote", "route", "feat", "country", "view", "reg", "port", "summary", "shape", "recent", "area", "config", "pattern", "project", "progress", "feature", "plugin", "local", "layer", "transfer", "dist", "section", "address", "cache", "description", "component", "gallery", "zone", "content", "memory", "tag", "module", "dim", "rule", "location", "REG", "division", "desc", "slice", "loc", "definition", "large", "radius", "update", "stage", "report", "Region", "range", "manager", "shadow", "artist", "resource", "script", "image", "production", "scope", "gap", "record", "output", "texture", "format", "theme", "contract"], "display": ["remote", "render", "roy", "reg", "view", "public", "summary", "disc", "app", "config", "be", "rem", "player", "mor", "feature", "process", "bin", "host", "device", "dist", "section", "use", "ini", "rest", "full", "cache", "address", "description", "play", "component", "screen", "profile", "destroy", "hide", "index", "fe", "match", "run", "dim", "gui", "role", "present", "draw", "REG", "orn", "service", "date", "Display", "show", "console", "large", "debug", "domain", "update", "feed", "stage", "report", "shadow", "script", "image", "position", "production", "block", "record", "output", "browser"], "rect": ["remote", "str", "port", "view", "col", "shape", "lat", "nav", "area", "object", "ref", "config", "project", "butt", "progress", "coll", "input", "post", "map", "tr", "feature", "Rect", "device", "layer", "section", "coord", "dir", "box", "round", "init", "patch", "act", "point", "crop", "thin", "rc", "tile", "dr", "client", "spec", "tag", "texture", "dom", "font", "ext", "dim", "rt", "pull", "ptr", "draw", "slice", "loc", "test", "large", "RECT", "image", "block", "pt", "att", "record", "feat", "attr", "format", "tri", "contract"], "clut": ["slut", "decut", "Clut", " clott", "clob", "clur", "cluto", "cluton", " clob", "kluts", "plot", "window", "cluts", "Clutor", "lcaut", "klot", "slunt", "flob", "this", "type", "flant", "flunt", "plut", "plute", "slute", "flatur", "g", "aclaut", "decuto", "Clur", "Clott", " cluton", "clant", "decatur", "lcut", "klutt", " clatur", "klunt", "flut", "clatur", " cluts", " clute", "slur", " clunt", "plaut", "plutt", "clutt", "bytes", "img", "clute", "klatur", "lcutt", "celott", "fluts", " clutor", "acluto", " clot", " clutt", "klut", " claut", "slutt", "celur", "kluto", " clur", "slant", " cluto", "plur", " clant", "klob", "claut", "clot", "celutor", "lcuto", "kluton", "obj", "aclut", "aclutt", "_", "pluto", "decuton", "clott", "clutor", "plunt", "celut", "clunt", "slaut", "flaut", "all"], "clut_table": ["clute_tab", "clit_table", "clit2tree", "clut2tree", "clit2index", "clit_index", "clut_db", "cluts_cache", "clit2list", "clutt_type", "clit2table", "clutttype", "clutt_cache", "clut___family", "clute_family", "clut_list", "clit_tree", "clut_family", "clut___tab", "clut_tree", "clute_stable", "clut2list", "clut_cache", "clut___table", "cluts_type", "clutt_level", "clut2table", "cluts_table", "cluttcache", "clut_tab", "cluttlevel", "clute_table", "clutt_table", "clut2index", "clutttable", "clut_index", "clit_list", "clut_type", "clut___stable", "clut_level", "cluts_db", "clut_stable"], "i": ["start", "fi", "qi", "ind", "ri", "ui", "mini", "connection", "gi", "d", "ti", "I", "l", "f", "ci", "y", "phi", "u", "ini", "j", "ip", "p", "abi", "vi", "bi", "mi", "c", "index", "num", "si", "ii", "b", "n", "iu", "ai", "xi", "hi", "di", "uni", "li", "pi", "x", "ni", "ori"]}}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "static QUANT_FN(pvq_encode_band)\n\n{\n\n    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,\n\n                               lowband_out, level, gain, lowband_scratch, fill, 1);\n\n}\n", "idx": 21851, "substitutes": {}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n\n\t\t\t     ram_addr_t size,\n\n\t\t\t     ram_addr_t phys_offset)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - nothing to be done. */\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 21863, "substitutes": {"start_addr": ["start64addr", "start67work", "startqptr", "end_md", "startameaddr", "start6nr", "start_work", "start6addr", "startPattr", "startfuloffset", "end_attr", "startqdevice", "start___attr", "end_node", "end_hop", "start6md", "start_address", "end_adr", "start__adr", "startingaddress", "start_node", "start6align", "start58addr", "start64ptr", "startPoffset", "start67off", "end_conn", "startPaddress", "startqaddr", "end_off", "start64conn", "startamenode", "start_hop", "start_ord", "startfulsta", "end_afi", "end_dr", "startqnode", "end_host", "startfuladdr", "end_nr", "startqaddress", "end_range", "end_work", "start64device", "start_md", "end_pad", "start58offer", "startPloc", "end_oa", "startxoa", "end_point", "startfuladdress", "start64address", "start_oa", "start67offer", "start6address", "startamedevice", "start_pad", "startingadr", "start00work", "start_off", "end_align", "start_adr", "startPpad", "start_host", "start67oa", "startingrange", "start_device", "end_offer", "start_ptr", "end_address", "startqafi", "end_addr", "start67address", "end_coord", "start00addr", "start__address", "start_align", "start_attr", "startPaddr", "start_dr", "end_loc", "start_loc", "start00offer", "startxaddress", "start__addr", "start_conn", "start_afi", "end_ord", "start58address", "startingaddr", "startxoff", "start_sta", "start_point", "end_device", "start_nr", "end_ptr", "start___loc", "start__range", "startjaddr", "end_sta", "start_offset", "startjaddress", "startjattr", "startqattr", "start00address", "startameaddress", "start_coord", "start___address", "start58point", "startjhost", "start_offer", "startjhop", "startjcoord", "start67addr", "start6pad", "startxaddr", "start___addr", "end_offset", "start_range"], "size": ["member", "i", "name", "shape", "start", "security", "esc", "iz", "en", "scale", "ui", "g", "mini", "time", "sized", "mode", "eng", "Size", "ny", "uri", "ize", "zero", "ci", "address", "use", "fee", "storage", "data", "full", "sum", "unit", "izes", "activity", "code", "grow", "body", "shift", "timeout", "memory", "c", "six", "small", "rc", "sh", "capacity", "si", "now", "speed", "core", "length", "len", "loc", "large", "parent", "z", "sec", "SIZE", "sn", "empty", "offset", "x", "max", "count"], "phys_offset": ["phys_location", "pg_pos", "physacset", "hyper_alt", "phys67size", "hyper_offset", "phys_off", "hyper67offset", "physical_slot", "mem_offset", "phys67position", "physlsize", "physacerror", "physladdress", "phys_pos", "hyper_location", "phys1offset", "phys_addr", "hyper67length", "phys_position", "pg_balance", "physacoffset", "phys_alias", "mem_padding", "physloffset", "mem_addr", "phys67pos", "phys67balance", "phys_address", "memory_format", "phys67location", "pg_offset", "physaclocation", "phys1size", "mem_position", "memory_slot", "phys1addr", "phys_balance", "mem_size", "phys_slot", "pg_size", "mem_off", "memory_error", "memory_offset", "memory_length", "hyper_length", "memory_set", "phys_set", "phys_padding", "phys64offset", "physacalt", "mem_alias", "hyper67location", "phys67alt", "physical_size", "physical_offset", "phys64length", "physaclength", "phys64slot", "phys_length", "phys_error", "phys_format", "phys_size", "phys67offset", "physacsize", "phys_alt", "memory_size", "phys67length", "hyper67alt", "physical_addr", "physlformat", "memory_address", "phys67off", "phys64size", "phys1slot"], "s": ["sim", "request", "i", "sb", "e", "sym", "space", "serv", "es", "sie", "fs", "g", "ses", "an", "this", "xs", "d", "sets", "site", "ds", "services", "f", "sys", "t", "r", "m", "args", "state", "stat", "new", "os", "p", "ts", "current", "ssl", "o", "ls", "sync", "is", "ss", "sg", "c", "js", "self", "spec", "settings", "sh", "si", "b", "w", "service", "set", "session", "n", "S", "ns", "changes", "sf", "utils", "south", "ps", "gs", "v", "conf", "secondary", "server", "sq", "states"], "mem": ["own", "app", "gram", "wa", "me", "mb", "cm", "temp", "mon", "mom", "win", "msg", "mo", "program", "mat", "lay", "thin", "gem", "pool", "small", "ib", "dem", "dim", "go", "ym", "bm", "ame", "image", "ge", "Mem", "nm", "member", "conn", "g", "my", "mod", "mac", "mi", "am", "lim", "sm", "rm", "cfg", "mp", "ann", "child", "em", "lib", "alt", "ph", "sum", "md", "reg", "serv", "ref", "com", "rem", "bin", "access", "imm", "cmd", "ram", "man", "new", "memory", "gen", "num", "loc", "buff", "tm", "hw", "ne", "gb", "fun", "ha", "pm", "mor", "home", "bl", "cl", "m", "tab", "cache", "mc", "tem", "mm", "slot", "py", "move", "ctx", "session", "large", "vm", "gm", "im", "um", "lam"], "old": ["after", "handle", "recent", "prev", "and", "obj", "own", "ind", "item", "event", "il", "hard", "an", "val", "hold", "arg", "post", "ore", "file", "style", "build", "ld", "get", "home", "f", "local", "cmp", "img", "pre", "original", "other", "OLD", "rest", "init", "j", "full", "new", "shared", "last", "current", "diff", "p", "mod", "past", "inner", "initial", "py", "thin", "ext", "gen", "small", "num", "low", "add", "in", "set", "now", "any", "Old", "slice", "update", "or", "lib", "buff", "from", "li", "orig", "older", "ne", "ori"], "err": [" error", "aaa", "ee", "val", "acer", "yr", "sys", "order", "msg", "bug", "last", "var", "later", "fr", " er", "go", "Error", "erg", "br", "iter", "doc", "ner", "conf", "eor", "kr", "ev", "resp", "str", "conn", "ind", "valid", "g", "der", "style", "ef", "ah", "dev", "res", "rh", "self", "ir", "e", "yer", " errors", "ln", "f", "new", "act", "arr", "gz", "pr", "ver", "arm", "error", "er", "gr", "loc", "req", "rage", "ler", "orig", "count", "found", "cry", "Er", "rr", "wr", "more", "inner", "py", "dr", "fe", "ar", "rar", "magic", "cr", "len", " Err", "mr", "nor", "ise", "all", "aster", "fer"]}}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889, "substitutes": {"opaque": ["OPacle", "iopacity", "OPatile", "OPaque", "iopacle", "iopaque", "opacity", "opacle", "OPacity", " opatile", " opacity", "opatile", " opacle", "iopatile"], "addr": ["name", "start", "off", "ref", "ost", "part", "eth", "mode", "ord", "amd", "pad", "pos", "alloc", "address", "data", "ad", "add", "ptr", "Address", "src", "fd", "len", "pointer", "offset", "x", "inter", "type"], "val": ["str", "reg", "ul", "valid", "tx", "bin", "bl", "cl", "al", "alloc", "data", "enc", "arr", "vals", "unit", "slot", "byte", "x", "b", "len", "VAL", "Val", "v", "all", "block", "base", "value"], "size": ["name", "Size", "bytes", "ize", "address", "data", "unit", "izes", "timeout", "rc", "c", "small", "desc", " length", "length", " sizes", "len", "large", "sec", "SIZE", "from", "empty", "block", "offset", "type"]}}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}", "idx": 21899, "substitutes": {"s": ["sv", "sim", "sb", "i", "native", "e", "sym", "qs", "es", "space", "support", "sci", "sl", "fs", "g", "ses", "site", "ks", "l", "ds", "services", "f", "sys", "t", "j", "ssl", "os", "ts", "cs", "p", "us", "ls", "sync", "is", "ss", "sa", "sg", "c", "js", "settings", "spec", "si", "a", "service", "se", "n", "S", "ns", "sup", "session", "sf", "south", "rs", "gs", "ps", "conf", "su", "sq"], "height": ["view", "row", "shape", "end", "level", "layout", "style", "align", "build", "pad", "Height", "rank", "y", "size", "data", "hang", "depth", "crop", "index", "distance", "pull", "window", "w", "stroke", "top", "length", "angle", "alpha", "volume", "gap", "h", "image", "resolution", "bottom", "arrow", "x", "high", "max", "block", "padding"]}}
{"project": "FFmpeg", "commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "target": 1, "func": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n", "idx": 21919, "substitutes": {"c": ["lc", "fc", "e", "cc", "uc", "ct", "config", "g", "coll", "cm", "d", "con", "pc", "cur", "cl", "cu", "f", "ci", "t", "ac", "u", "m", "s", "cp", "nc", "cache", "oc", "p", "mc", "cs", "xc", "enc", "cf", "tc", "o", "rc", "ctx", "self", "sc", "ch", "b", "dc", "ic", "cy", "gc", "cr", "n", "C", "co", "z", "ce", "v", "cit", "l", "x", "ec", "vc"], "buf": ["uint", "pb", "port", "bc", "uf", "uc", "end", "config", "text", "cv", "fb", "queue", "ffff", "bin", "bridge", "home", "cur", "fp", "f", "buffer", "cmp", "alloc", "cmd", "tab", "data", "cache", "cf", "que", "context", "count", "pool", "rc", "cb", "ctx", "num", "aux", "b", "tmp", "seq", "fd", "src", "loc", "br", "ab", "batch", "buff", "v", "vec", "rb", "block", "offset", "max", "gb", "pub"], "buf_size": ["queue_size", " buf_len", "buf_count", " buf_length", "queue_len", "queue_count", "buf_length", "buf_len"]}}
{"project": "FFmpeg", "commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "target": 1, "func": "static int hls_read_header(AVFormatContext *s)\n\n{\n\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n\n    HLSContext *c = s->priv_data;\n\n    int ret = 0, i;\n\n    int highest_cur_seq_no = 0;\n\n\n\n    c->ctx                = s;\n\n    c->interrupt_callback = &s->interrupt_callback;\n\n    c->strict_std_compliance = s->strict_std_compliance;\n\n\n\n    c->first_packet = 1;\n\n    c->first_timestamp = AV_NOPTS_VALUE;\n\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n\n\n    if (u) {\n\n        // get the previous user agent & set back to null if string size is zero\n\n        update_options(&c->user_agent, \"user-agent\", u);\n\n\n\n        // get the previous cookies & set back to null if string size is zero\n\n        update_options(&c->cookies, \"cookies\", u);\n\n\n\n        // get the previous headers & set back to null if string size is zero\n\n        update_options(&c->headers, \"headers\", u);\n\n\n\n        // get the previous http proxt & set back to null if string size is zero\n\n        update_options(&c->http_proxy, \"http_proxy\", u);\n\n    }\n\n\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = save_avio_options(s)) < 0)\n\n        goto fail;\n\n\n\n    /* Some HLS servers don't like being sent the range header */\n\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n\n\n    if (c->n_variants == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n    /* If the playlist only contained playlists (Master Playlist),\n\n     * parse each individual playlist. */\n\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n\n        for (i = 0; i < c->n_playlists; i++) {\n\n            struct playlist *pls = c->playlists[i];\n\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n\n                goto fail;\n\n        }\n\n    }\n\n\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n\n\n    /* If this isn't a live stream, calculate the total duration of the\n\n     * stream. */\n\n    if (c->variants[0]->playlists[0]->finished) {\n\n        int64_t duration = 0;\n\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n\n        s->duration = duration;\n\n    }\n\n\n\n    /* Associate renditions with variants */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *var = c->variants[i];\n\n\n\n        if (var->audio_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n\n        if (var->video_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n\n        if (var->subtitles_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n\n    }\n\n\n\n    /* Create a program for each variant */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *v = c->variants[i];\n\n        AVProgram *program;\n\n\n\n        program = av_new_program(s, i);\n\n        if (!program)\n\n            goto fail;\n\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n\n    }\n\n\n\n    /* Select the starting segments */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n\n    }\n\n\n\n    /* Open the demuxer for each playlist */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        AVInputFormat *in_fmt = NULL;\n\n\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->index  = i;\n\n        pls->needed = 1;\n\n        pls->parent = s;\n\n\n\n        /*\n\n         * If this is a live stream and this playlist looks like it is one segment\n\n         * behind, try to sync it up so that every substream starts at the same\n\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n\n         * all active streams within the first few seconds). This is not very generic,\n\n         * though, as the sequence numbers are technically independent.\n\n         */\n\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n\n            pls->cur_seq_no = highest_cur_seq_no;\n\n        }\n\n\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n\n        if (!pls->read_buffer){\n\n            ret = AVERROR(ENOMEM);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n\n                          read_data, NULL, NULL);\n\n        pls->pb.seekable = 0;\n\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n\n                                    NULL, 0, 0);\n\n        if (ret < 0) {\n\n            /* Free the ctx - it isn't initialized properly at this point,\n\n             * so avformat_close_input shouldn't be called. If\n\n             * avformat_open_input fails below, it frees and zeros the\n\n             * context, so it doesn't need any special treatment like this. */\n\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        pls->ctx->pb       = &pls->pb;\n\n        pls->ctx->io_open  = nested_io_open;\n\n\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n\n            goto fail;\n\n\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n\n            avformat_queue_attached_pictures(pls->ctx);\n\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n\n            pls->id3_deferred_extra = NULL;\n\n        }\n\n\n\n        if (pls->is_id3_timestamped == -1)\n\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n\n\n        /*\n\n         * For ID3 timestamped raw audio streams we need to detect the packet\n\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n\n         * on us if they want to.\n\n         */\n\n        if (pls->is_id3_timestamped) {\n\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n\n\n        /* Create new AVStreams for each stream in this playlist */\n\n        ret = update_streams_from_subdemuxer(s, pls);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n\n    }\n\n\n\n    update_noheader_flag(s);\n\n\n\n    return 0;\n\nfail:\n\n    free_playlist_list(c);\n\n    free_variant_list(c);\n\n    free_rendition_list(c);\n\n    return ret;\n\n}\n", "idx": 21925, "substitutes": {"s": ["sv", "sb", "e", "sym", "qs", "es", "sl", "fs", "g", "ses", "d", "sets", "ops", "site", "ks", "l", "ds", "services", "f", "sys", "t", "y", "r", "m", "args", "ssl", "os", "p", "cs", "ts", "o", "sync", "is", "sg", "ctx", "js", "spec", "settings", "sq", "si", "sc", "a", "b", "service", "se", "aws", "n", "S", "sup", "ns", "comments", "sf", "rs", "gs", "conf", "sec", "server", "su", "ss"], "u": ["ut", "ru", "uf", "e", "un", "ul", "uc", "eu", "ur", "ui", "g", "gnu", "you", "null", "uri", "ou", "l", "f", "t", "universal", "m", "ue", "lu", "p", "us", "uv", "uno", "tu", "tc", "o", "uci", "cli", "q", "client", "mu", "hu", "a", "b", "U", "uu", "iu", "util", "up", "user", "uid", "h", "nu", "su", "api", "cu"], "c": ["lc", "bc", "col", "fc", "arc", "cc", "e", "uc", "conn", "ct", "g", "this", "coll", "com", "cm", "d", "con", "rec", "ca", "pc", "cur", "cl", "f", "ci", "t", "nc", "cp", "ac", "m", "r", "cache", "cat", "p", "cf", "cs", "xc", "enc", "mc", "o", "client", "ctx", "cb", "cn", "ch", "sc", "b", "dc", "ic", "cy", "cr", "n", "C", "co", "ec", "ce", "conf", "sec", "h", "l", "cu", "k", "vc"], "i": ["io", "ix", "e", "ie", "qi", "ri", "ui", "eni", "g", "mini", "gi", "my", "uri", "d", "ti", "I", "f", "ci", "t", "y", "info", "m", "ini", "oi", "j", "phi", "p", "ip", "id", "o", "bi", "inner", "mi", "mu", "index", "si", "b", "ii", "x", "in", "n", "iu", "ai", "xi", "hi", "di", "multi", "yi", "li", "z", "h", "pi", "fi", "ni"], "pls": [" Plz", "plz", " plb", "pln", "PLn", " plgs", " plz", " pli", "coln", "plp", "PLp", "coli", " plp", " cls", "PLi", "PLs", " Pls", " Plp", " Plgs", "cols", " clgs", " Pli", " cli", " clz", "plb", " pln", "plgs", " Plb", "PLb", "pli"]}}
{"project": "FFmpeg", "commit_id": "8a9641a652ed1546fedfda22584f79d3d423096e", "target": 0, "func": "AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n\n{\n\n    AVBitStreamFilter *bsf = first_bitstream_filter;\n\n\n\n    while (bsf) {\n\n        if (!strcmp(name, bsf->name)) {\n\n            AVBitStreamFilterContext *bsfc =\n\n                av_mallocz(sizeof(AVBitStreamFilterContext));\n\n            bsfc->filter    = bsf;\n\n            bsfc->priv_data =\n\n                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n\n            return bsfc;\n\n        }\n\n        bsf = bsf->next;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21938, "substitutes": {"name": ["package", "space", "named", "part", "none", "time", "key", "anc", "layer", "path", "names", "address", "size", "data", "NAME", "new", "version", "id", "prefix", "label", "word", "normal", "filename", "ext", "search", "filter", "Name", "value", "alias", "n", "child", "call", "mask", "ame", "base", "parent", "group", "block", "image", "scope", "x", "action", "cap", "type"], "bsf": ["resfac", "csfc", "bisinf", "bisf", "resf", "ksfp", "ubsfr", "nsf", "lsrf", "csfx", "dsfe", "lsfe", "ubscf", "dsfr", "basfe", "bsfx", "basfx", "besf", "besrf", "opsf", "csscf", "nsfs", "alsf", "nsrf", "lsfp", "lsc", "lsf", "bescf", "ksf", "cssfp", "lscf", "bsrf", "ssf", "besfs", "lsfr", "bsinf", "basfc", "opsfe", "bsfp", "outscf", "besfo", "bsfs", "ksfs", "besfp", "alsfo", "csfe", "lsfac", "resfs", "lsfx", "dsinf", "cssf", "kscf", "besfac", "ssfs", "bsfr", "dsf", "csf", "cssfs", "psfp", "cssfac", "sscf", "bsfe", "pscf", "lsfs", "ssc", "bsc", "ubsfc", "bscf", "bsfo", "ubsf", "opsfr", "outsfs", "alsfs", "opsinf", "nscf", "bsfac", "bisfe", "outsfac", "outsf", "psf", "lsfc", "nsfp", "nsfr", "nsfc", "nsc", "bisfr", "psfs", "alsfac", "basf", "resfo"], "bsfc": ["usfi", "dsfc", "pscf", "bfi", "rasFC", "gsfc", "ssfc", "rascf", "bfc", "bingcf", "basfi", "basfl", "dsfp", "bingfi", "psfd", "bascf", "bscf", "gsfe", "alsfc", "alsfd", "rasfc", "asfd", "ssFC", "bsfi", "gsfp", "psfc", "alscf", "asfc", "dsfe", "bsFC", "usFC", "bfl", "bsfe", "bsfl", "rasfi", "bsfx", "dsfx", "bcf", "usfc", "psfe", "bingfl", "basfc", "psfp", "psfx", "gsfx", "uscf", "bsfp", "ascf", "ssfi", "asfe", "alsfe", "sscf", "bingfc", "bsfd"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957, "substitutes": {}}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n", "idx": 21958, "substitutes": {"bdrv": ["bDRb", "bDRV", "bgrc", " bdb", "bstrf", " bdrw", "bstrV", "bdb", " bdv", "bdrf", "bderf", "bdrif", "bdriv", "bstrv", "bDRv", "bdrw", " bdrc", "bdrb", "bderv", "bgrw", "bdc", " bdrV", " bdw", "bdrV", "bgrv", " bdrb", " bdrs", "bdrs", "bstrc", "bdrc", "bders", "bDRw", "bdris", " bdrf", "bdv", "bdw", "bderb", "bDRc", "bdrib", "bDRf", "bgrb", " bdc"], "index": ["i", "row", "e", "name", "edit", "object", "level", "ind", "option", "thread", "loop", "input", "inc", "xxx", "val", "part", "key", "connection", "degree", "coll", "style", "site", "column", "xx", "weight", "f", "node", "path", "info", "original", "address", "data", "list", "diff", "number", "id", "count", "prefix", "unit", "sync", "condition", "active", "Index", "comment", "localhost", "num", "module", "match", "search", "success", "add", "in", "date", "point", "length", "slice", "element", "page", "append", "update", "pointer", "ticket", "instance", "image", "position", "x", "output", "value", "letter"]}}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962, "substitutes": {"obj": ["class", "object", "conn", "jp", "next", "Object", "adj", "ref", "oa", "orb", "ops", "img", "node", "po", "op", "args", "j", "obb", "init", "ob", "os", "o", "elt", "active", "ext", "js", "ctx", "aj", "self", "cb", "module", "Obj", "tmp", "objects", "n", "src", "inst", "boot", "bot", "fn", "api", "bj", "inter"], "nf": ["nfx", "Nfx", "cncf", "ncf", "yncf", "nncf", "Nfe", "Nfs", "ynfc", "nfs", "cnfc", "uncf", " nfe", "nfe", "unc", " nfs", "nnfx", "snf", "ynf", "unf", "nnf", "Ncf", "cnc", "ync", "Nfc", "nc", "snfe", "cnfe", "snfc", " ncf", "ynfe", "snfs", " nfx", " nc", "nnfs", "unfe", "cnf", "cnfs", "Nf", "unfc"], "nfc": ["ncf", "yncf", "Nfe", "Nfs", "ynfc", "nfs", "uncf", " nfe", "nfe", " nfs", "ynf", "Nc", "Ncf", "ync", "Nfc", "nc", "ynfe", " ncf", " nc", "unfe", "unfs", "Nf", "ynfs", "unfc"]}}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 21967, "substitutes": {"args": ["Args", "ras", "asm", "config", "g", "arg", "func", "parse", "ks", "host", "ds", "flags", "f", "ams", "sys", "alloc", "ac", "init", "arr", "cs", "params", "ports", "mac", "stats", "py", "ctx", "self", "ass", "parts", "call", "arms", "parser", "options", "gs", "conf", "array", "lang", "empty"]}}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969, "substitutes": {"dev": ["md", "Dev", "priv", "grad", "name", "kind", "def", "serv", "sk", "conn", "prof", "app", "valid", "fail", "driver", "gu", "progress", "av", "der", "de", "d", "prov", "home", "device", "dist", "sys", "info", "adv", "dd", "state", "serial", "diff", "mod", "comment", "disk", "spec", "pro", "dem", "sh", "die", "ver", "ch", "dt", "rad", "dc", "w", "des", "error", "ve", "test", "br", "debug", "req", "di", "boot", "proc", "conf", "user", "hw", "development", "ev", "block"], "err": ["str", "aaa", " error", "asm", "valid", "result", "progress", "ctr", "der", "acer", "Er", "rr", "sys", "r", "phy", "fee", "cache", "arr", "nil", "cer", "errors", "rh", "dr", " nil", "cb", "spec", "irm", "fr", "ar", "ch", "sr", "usr", "error", "cr", "Error", "er", "gr", "test", "mr", "req", "rs", "proc", "ner", "ry", "lib", "conf", "rb", "nor", "server", "ir", "fi"], "s": ["sv", "i", "es", "uns", "none", "ds", "device", "sys", "y", "r", "ssl", "os", "ts", "cs", "us", "js", "n", "S", "ns", "rs", "http", "conf", "v", "l", "ss", "an", "str", "request", "sb", "g", "ses", "d", "sets", "site", "services", "u", "state", "o", "sg", "c", "self", "spec", "a", "sf", "su", "e", "sym", "qs", "hs", "fs", "func", "bytes", "f", "t", "less", "p", "addr", "si", "b", "service", "parts", "er", "ps", "gs", "z", "h", "sq", "sl", "_", "ks", "m", "args", "storage", "ls", "sync", "is", "settings", "in", "w", "se", "session", "south", "server", "states"], "x86_iommu": ["x86_iompo", "x86_iommi", "x86_iomi", "x86_iompur", "x86_iomsu", "x86_kormo", "x86_uiommo", "x86_iormi", "x86_iomu", "x86_uiormo", "x86_kormu", "x86_iormur", "x86_iormus", "x86_kommu", "x86_iomui", "x86_uiommur", "x86_iomso", "x86_iommui", "x86_kommo", "x86_iommus", "x86_iompui", "x86_iompu", "x86_iommo", "x86_uiormu", "x86_iomsus", "x86_iormui", "x86_kormi", "x86_iomur", "x86_kommus", "x86_iommur", "x86_uiommui", "x86_uiormui", "x86_kommi", "x86_iormo", "x86_uiommu", "x86_iormu", "x86_kormus", "x86_iomo", "x86_uiormur", "x86_iomus", "x86_iomsi"], "bus": ["io", "bc", "port", "i", "class", "bis", "fi", "usb", "config", "fs", "driver", "board", "mount", "connection", "Bus", "bridge", "host", "device", "f", "devices", "ds", "u", "bit", "bug", "cache", "os", "p", "us", "serial", "machine", "o", "sync", "c", "self", "pass", "b", "service", "hub", "session", "BUS", "di", "boot", "lib", "v", "proc", "nt", "bs", "hw", "conf", "block", "http", "l", "base", "this"]}}
{"project": "FFmpeg", "commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "target": 1, "func": "int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)\n\n{\n\n    DynBuffer *d = s->opaque;\n\n    int size;\n\n    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};\n\n    int padding = 0;\n\n\n\n    if (!s) {\n\n        *pbuffer = NULL;\n\n        return 0;\n\n    }\n\n\n\n    /* don't attempt to pad fixed-size packet buffers */\n\n    if (!s->max_packet_size) {\n\n        avio_write(s, padbuf, sizeof(padbuf));\n\n        padding = FF_INPUT_BUFFER_PADDING_SIZE;\n\n    }\n\n\n\n    avio_flush(s);\n\n\n\n    *pbuffer = d->buffer;\n\n    size = d->size;\n\n    av_free(d);\n\n    av_free(s);\n\n    return size - padding;\n\n}\n", "idx": 21971, "substitutes": {"s": ["ions", "sb", "i", "e", "space", "es", "sl", "fs", "g", "ses", "an", "seconds", "sets", "ops", "ks", "ds", "services", "f", "secure", "t", "r", "u", "m", "storage", "os", "ssl", "p", "cs", "ts", "o", "sync", "is", "ss", "stats", "sg", "c", "ctx", "opens", "settings", "spec", "client", "js", "si", "self", "a", "b", "w", "service", "se", "n", "S", "ns", "comments", "sf", "session", "south", "rs", "gs", "ps", "http", "v", "conf", "uploads", "h", "server", "l", "sq"], "pbuffer": ["bbuf", " pqueue", " pcap", "cpheader", "bbuffer", "bcap", "Pheader", " pheader", "precap", "bheader", "cpbuffer", " pbase", "preuffer", "padbuffer", "padcap", "Pqueue", "pbuf", "prebuf", "pheader", " pbuf", "cpbase", "preheader", "puffer", "pbase", "pqueue", "Pbase", "prebuffer", " puffer", "Pbuffer", "pcap", "paduffer", "cpqueue"], "d": ["md", "dos", "i", "grad", "e", "cd", "driver", "db", "dad", "dh", "ds", "ld", "f", "dn", "gd", "done", "t", "u", "cmd", "m", "da", "ad", "data", "nd", "p", "did", "del", "id", "o", "dy", "sync", "c", "dr", "sd", "dx", "dom", "dt", "b", "dc", "w", "draw", "dm", "dl", "n", "fd", "D", "z", "dat", "l"], "size": ["i", "name", "shape", "external", "en", "send", "scale", "mode", "sized", "connection", "Size", "style", "l", "ize", "buffer", "pos", "write", "address", "data", "storage", "fee", "use", "p", "unit", "number", "code", "sync", "body", "timeout", "content", "c", "small", "capacity", "now", "speed", "value", "channel", "n", "length", "len", "page", "large", "z", "from", "SIZE", "pointer", "empty", "position", "offset", "x", "padding", "type"], "padbuf": ["adbuffer", "padbuff", "preuf", "paduf", " padbr", " paddcb", "capbuffer", "pbuff", "capbuff", " padbuffer", "adbuff", "paddingbuffer", " padbuff", "padcb", "capcb", "padbuffer", "prebuff", "capuf", " padcb", "pbuf", "prebuf", "padbr", " paddbuf", "paddingcb", " paddbuffer", "pcb", "prebuffer", "adbuf", "aduf", "paddingbr", "capbuf", "paddingbuf", " paddbr"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995, "substitutes": {"queue": ["status", "port", "stack", "Queue", "menu", "event", "loop", "connection", "plugin", "buffer", "entry", "ue", "sequence", "cache", "list", "prefix", "que", "context", "q", "pool", "client", "header", "module", "collection", "gui", "priority", "seq", "channel", "qa", "core", "console", "flow", "feed", "update", "database", "stage", "parent", "manager", "group", "server", "command", "type"], "sender": ["send", "sidender", "sidensor", "senders", "sink", "Send", "Sink", "pink", "penders", "nsorter", "sensor", "sorter", "resenders", " senders", "nsink", "sener", " sensor", "reserver", "pender", "Sorter", "Senders", "Sender", "resener", "pend", "resender", "Sensor", "pener", "nsenders", "nsender", "nsend", "nserver", "nsener", "sidenders", "perver", "server", " send", "porter", "sidend"], "flags": ["status", "types", "workers", "config", "weights", "fs", "features", "ops", "bytes", "tails", "orts", "weight", "offset", "nl", "enabled", "fps", "fee", "args", "data", "ils", "ents", "vs", "cs", "fx", "prefix", "version", "addr", "stats", "ants", "Flags", "settings", "filename", "lag", "bits", "flag", "FLAG", "parts", "fl", "length", "fd", "mask", "len", "fields", " Flags", "options", "ats", "files", "ips", "feat", "states", "fun"], "buf": ["bc", "uf", "ref", "config", "cv", "func", "fp", "buffer", "path", "env", "alloc", "cmd", "msg", "data", "box", "args", "addr", "wb", "rc", "pool", "cb", "ctx", "b", "window", "raw", "flag", "seq", "length", "fd", "src", "len", "loc", "callback", "flow", "buff", "vec", "bag", "rb", "offset", "prop", "count"], "size": ["io", "ize", "pos", "use", "address", "data", "live", "small", "name", "ix", "end", "scale", "g", "eng", "ci", "fee", "unit", "izes", "code", "body", "c", "capacity", "SIZE", "empty", "position", "offset", "iz", "store", "ui", "time", "mode", "bytes", "weight", "new", "form", "length", "loc", "page", "z", "sec", "x", "count", "limit", "shape", "en", "Size", "args", "storage", "cache", "content", "source", "len", "large", "parent"], "sent_cb": [" sent_Callback", " sent_data", "sentitycd", "sentfnc", "sentablecd", " sent_rb", " sent_nc", "sentablecor", "sentitycor", " sent_cd", "sentfCallback", "sent_code", "sent_cor", "sentitycb", " sent_fn", "sent_Callback", "sent_cd", "sent_rb", "sent_callback", "sent_fn", " sent_code", "sentablecb", "sentfcallback", "sentitycallback", "sentablecallback", "sentfcb", " sent_cor", "sent_nc", " sent_callback", "sent_data"], "packet": ["payacket", "compart", "competer", "passeter", " Packacket", "competing", "payett", "comppt", "compec", "packageet", " packant", "compett", "pad", "packeter", "payeter", "packageec", " packend", "hooketer", "packct", "packacker", "compant", "pacacket", "packacket", "compat", "packart", "hookacket", "compset", "ppeter", "ppet", " packeter", "passacket", " Packet", "ppacket", "passet", "packett", "compend", "pat", " packart", "assacket", "packpt", "compet", " packacket", "packec", "pacet", "packageant", "assacker", "compct", " Packart", " packset", " Packpt", "pet", "compad", "paceting", "packageacket", "asset", "compacket", "payet", "packat", "packeting", "packageart", "hookct", " packct", " packad", " packec", " packat", "packset", "compacker", "packend", "pacacker", "packad", "packant", "asseting", "packageend", " packpt", "passett", "ppset", "hooket"]}}
{"project": "FFmpeg", "commit_id": "02591641f88097aec2a573f0ae384c8b87bcfe3b", "target": 1, "func": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n", "idx": 22003, "substitutes": {"s": ["sb", "e", "sym", "qs", "es", "fs", "g", "ses", "xs", "d", "sets", "site", "ks", "l", "ds", "services", "f", "sys", "t", "u", "m", "args", "ssl", "os", "ts", "p", "cs", "o", "context", "sync", "is", "ss", "ls", "sg", "c", "ctx", "js", "self", "spec", "settings", "si", "a", "b", "service", "n", "S", "ns", "states", "session", "sf", "side", "ps", "gs", "v", "conf", "server", "su", "sq", "gb"], "channel": ["course", "col", "fc", "name", "phase", "row", "sch", "config", "scale", "category", "prot", "character", "chan", "mode", "cm", "queue", "connection", "uri", "column", "pixel", "path", "section", "nc", "axis", "cat", "Channel", "version", "component", "unit", "code", "context", "network", "c", "cb", "sector", "frame", "source", "byte", "sc", "ch", "wan", "core", "qa", "chron", "range", "gap", "block", "server", "base", "video", "type"], "residual_size": ["residinal_len", "residinal_count", "residUAL_size", "residual_count", "residual1count", "residual1len", "residual1size", "residual_len", "residUAL_scale", "residual_name", "residual_scale", "residinal_size", "residUAL_name"], "pred_order": ["predsorders", " pred_size", " pred_row", "orig_orig", "pred_size", "pred67orig", "pred67order", " pred_orig", " pred_asc", "orig_order", "predingorder", "orig_size", "predingORD", "pred_orig", "pred_asc", "predsORD", " pred_ord", " pred_orders", "pred_ORD", "predingord", "predsord", "pred_row", "pred_ord", "predingorders", " pred_ORD", "predsorder", "pred67asc", "orig_orders", "pred67size", "pred_orders"], "sum": ["sim", "summary", "e", "ul", "sk", "scale", "Sum", "g", "cost", "gram", "val", "av", "average", "su", "style", "sign", "weight", "f", "offset", "fat", "u", "info", "used", "fee", "size", "use", "p", "mean", "diff", "us", "am", "cum", "out", "num", "add", "beta", "si", "sh", "pass", "cal", "b", "sub", "value", "hash", "ass", "vol", "n", "min", "total", "loss", "v", "alpha", "mix", "up", "user", "all", "ge", "l", "um", "max", "count"], "i": ["io", "ami", "ix", "e", "ik", "ie", "fi", "qi", "start", "ind", "ri", "ui", "eni", "pi", "ki", "gi", "d", "uri", "I", "f", "ci", "y", "u", "oi", "ini", "m", "it", "adi", "p", "ip", "id", "o", "bi", "is", "mi", "c", "index", "si", "a", "ii", "b", "ji", "n", "iu", "ai", "xi", "ei", "di", "z", "v", "multi", "li", "h", "api", "im", "l", "x", "zi", "k", "ni", "ori"], "j": ["ja", "jit", "je", "oj", "e", "ix", "jl", "ie", "syn", "qi", "jp", "adj", "g", "key", "d", "f", "ci", "jj", "y", "r", "u", "m", "it", "p", "job", "o", "ani", "js", "aj", "index", "c", "fr", "si", "J", "ch", "ii", "b", "ji", "ij", "n", "jc", "z", "v", "li", "h", "jo", "l", "x", "k"], "coeffs": ["coeffd", "coEFFs", "coeffi", "coffes", "coefficientss", "coffs", " coefments", "coffe", "coEFFp", "coefficientsi", "cocoste", "coefficientsp", " coffs", "coefficientse", "coefficients", " coffe", "coefments", "coefficientses", "coeffe", "coffi", " coeffe", "coefficientsd", "coffd", "coefficientsments", " coeffments", "coefp", " coffes", "coeffes", " coffp", " coeffd", "coefficientes", " coeffi", " coefs", " coefp", "cocosti", "cocostes", "coefficientp", " coeffes", " coeffp", "coEFFi", " coffd", "coeffments", "coefi", "cocosts", "coefs", "coefficientd", "coEFFments", "coeffp", " coefi", "coffp", " coffi"]}}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006, "substitutes": {"timer_list": ["timerlisttest", "meterapplist", "timerappget", "tick_List", " timer_count", "timerlqueue", "timerdList", "timer_diff", "timerAtable", "timer2config", "ticklistlist", "ticklistList", "tick_queue", "timeridbatch", "lateridlist", "timer2list", "lateridleft", "timer2def", "timerappstack", "timerallconfig", "timeralldef", "timerAlist", "meter_get", "timer_record", "theme6stack", "er_list", "theme_get", "later_add", "ticklistqueue", "er_lock", "timer_batch", "theme0list", "theme0detail", "timerlistdetail", "timer_left", "timerlistList", " timer_diff", "timer5LIST", "timer6stack", "timeralllist", "theme_LIST", "ticklisttree", "timerlistlist", "theme6LIST", "meter_list", "timerkdiff", "lateridadd", "timerappconfig", "timer0get", "timerllist", "timer0test", "timer_queue", "timeridlist", "timer6LIST", "er_batch", "timerappdef", "timer0list", "meterappget", "tick_list", "timeridleft", "timerxlist", "timerklist", "timer_add", "meter_config", "timer5list", "theme6get", "timerktable", "timerdpair", "er_type", "timerxpair", "timer_test", "timer5stack", "timer_config", "timer_List", "theme_detail", "timer_table", "timer6get", "timerxList", "timer_type", "theme_test", "timerdlist", "timerlistqueue", "timer5get", "meter_def", " timer_table", "theme0get", "timer_count", "timerapplist", "timerAdiff", "timer_lock", "theme_stack", "timerdrecord", "timerlisttree", "timer2get", "er_pair", "later_batch", "timerlList", "timer_get", "timer_tree", "timer_detail", "theme0test", "timer_pair", "timerappLIST", "timerltree", "tick_tree", "theme6list", "timer_stack", "meterappconfig", "meterappdef", "timerAcount", "timerkcount", "theme_list", "lateridbatch", "later_list", "er_record", "timerxrecord", "timer0detail", "timerallget", "timerlistget", "er_List", "later_left", "timer_LIST", "timer_def", "timer6list", "timeridadd"], "expire_time": ["expireystart", "expireftime", "exire_money", "expireycount", "exake_start", "expire_start", "expire64timeout", "expire_count", "expirefmode", "exire_Time", "exire_mode", "expirextime", "exake___hour", "expiration_timeout", "exake_count", "exake___time", "expire__money", "expire_hour", "expire64start", "expire_money", "expireyhour", "expire64count", "expirexmoney", "exire_count", "expire__timeout", "expire__time", "expire64hour", "expire_timeout", "expire___count", "expireytime", "exake___count", "expirexmode", "exake_time", "expire_mode", "expire___time", "expire___start", "expire_Time", "exake___start", "expiration_time", "exake_hour", "exire_time", "expire64money", "expiration_money", "expire___hour", "expire64time", "expirefmoney"]}}
{"project": "FFmpeg", "commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "target": 1, "func": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n\n                            int compressed_size, int uncompressed_size,\n\n                            EXRThreadData *td)\n\n{\n\n    unsigned long dest_len, expected_len = 0;\n\n    const uint8_t *in = td->tmp;\n\n    uint8_t *out;\n\n    int c, i, j;\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n\n            expected_len += (td->xsize * td->ysize * 2);\n\n        } else {//UINT 32\n\n            expected_len += (td->xsize * td->ysize * 4);\n\n        }\n\n    }\n\n\n\n    dest_len = expected_len;\n\n\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (dest_len != expected_len) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    out = td->uncompressed_data;\n\n    for (i = 0; i < td->ysize; i++)\n\n        for (c = 0; c < s->nb_channels; c++) {\n\n            EXRChannel *channel = &s->channels[c];\n\n            const uint8_t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22009, "substitutes": {"s": ["sv", "sb", "hm", "e", "sym", "space", "sk", "support", "sl", "fs", "g", "ses", "this", "su", "rates", "d", "ks", "ds", "services", "f", "sys", "t", "u", "m", "ssl", "ts", "p", "cs", "ls", "sync", "sa", "sg", "js", "self", "sd", "sm", "sq", "sh", "si", "sc", "spec", "sts", "b", "service", "parts", "session", "S", "ns", "sf", "side", "ps", "south", "gs", "bs", "l", "ss", "settings"], "src": ["sb", "fc", "sel", "config", "sl", "input", "rin", "img", "scl", "secure", "gb", "ssl", "setup", "rc", "filename", "ctx", "cb", "source", "ipl", "sc", "sr", "rl", "sub", "tmp", "inst", "slice", "loc", "rs", "proc", "st", "dest", "rb", "stream", "attr", "url"], "compressed_size": ["compressed67area", "comppped_size", "compressed64sum", "compressed_sum", "compressed2size", "compressed64scale", "compressed2len", "compached_sum", "comppped_offset", "comppped_data", "compressed_data", "compached_size", "compressed67data", "compressed_len", "compressed_area", "compressed_scale", "compressed64len", "compressed2sum", "compressed67offset", "compressed67size", "compressed_offset", "compressed2scale", "comppped_area", "compached_len", "compached_scale", "compressed64size"], "uncompressed_size": ["uncompressedrize", "uncompressed_width", "uncompressed64size", "uncompured64width", "uncompressedrwidth", "uncompressed64ize", "uncompured_source", "uncompressed_ize", "uncompured_ize", "uncompressedrsize", "uncompured64size", "uncompured64source", "uncompressedrsource", "uncompressed64source", "uncompured_size", "uncompressed_source", "uncompressed64width", "uncompured_width", "uncompured64ize"], "td": ["md", "pb", "sb", "txt", "cd", "table", "rd", "uc", "conn", "ind", "amp", "edd", "std", "prot", "lv", "butt", "input", "kt", "db", "det", "wd", "dal", "d", "xd", "vd", "pd", "ti", "dh", "ld", "ds", "pc", "layer", "dn", "ud", "t", "cmd", "standard", "dd", "nd", "tp", "hd", "tif", "data", "ts", "ssl", "tc", "elt", "od", "thin", "header", "sd", "tf", "dt", "ta", "dc", "tmp", "dl", "fd", "tn", "bd", "dll", "cz", "tm", "dat", "nt", "lf", "cod", "li", "pt", "att", "TD", "ht", "gb", "ctl"], "dest_len": ["dest_l", "dest9ler", "expected_l", "expected64Len", "expected64lon", "gest___ler", "dest64len", " dest_val", "dest2limit", "dest___len", "dest___lin", "rest_limit", "dest_size", "dest9val", "dest___ler", "expected_Len", "dest__count", "dest_lon", "gest_ler", "gest___len", " dest_count", "dest_length", "dest_lock", "dest2lock", "dest2length", "dest2len", "expected64l", "gest___lin", "rest_length", "dest_ler", " dest_size", "dest__len", "dest64l", "expected64len", "dest_limit", "dest64lon", "gest_val", "dest9lin", "gest___val", "rest_lock", "dest9len", "gest_lin", "expected_len", "dest64Len", "dest_val", "dest_count", "dest_lin", "expected_lon", "rest_len", "dest__size", "gest_len", "dest_Len", "dest__val", "dest___val"], "in": ["conn", "err", "config", "ind", "input", "inc", "val", "part", "connection", "impl", "rin", "d", "bin", "gin", "rec", "pc", "img", "din", "ci", "win", "again", "r", "address", "m", "socket", "data", "ssl", "p", "id", "inner", "rc", "index", "pin", "ctx", "source", "inn", "In", "ii", "dc", "pull", "into", "IN", "min", "inst", "ins", "proc", "inside", "resource", "image", "att", "inch", "isin"], "out": ["io", "name", "outs", "password", "conn", "err", "config", "result", "part", "copy", "bin", "gin", "token", "temp", "process", "img", "device", "buffer", "exec", "again", "other", "cmd", "bit", "m", "data", "opt", "new", "p", "at", "version", "sync", "ext", "client", "OUT", "source", "window", "error", "call", "Out", "parent", "proc", "v", "dest", "image", "att", "server", "output", "attr", "sum"], "c": ["lc", "col", "e", "uc", "g", "d", "con", "pc", "f", "ci", "y", "t", "nc", "r", "u", "ac", "cp", "cache", "m", "p", "cs", "enc", "rc", "cn", " rc", "sc", "ch", "b", "cy", "n", "vc", "call", "C", "co", "z", "v", "ce", "h", "l", "x", "cu", "k", "count"], "i": ["io", "lc", "ami", "e", "ix", "start", "ie", "fi", "qi", "ri", "iii", "ui", "eni", "mini", "pi", "ki", "gi", "d", "uri", "my", "chi", "ti", "I", "f", "ci", "y", "u", "oi", "ini", "m", "phi", "info", "it", "init", "p", "ip", "id", "o", "bi", "q", "is", "mi", "inner", "index", "si", "ii", "b", "n", "iu", "ai", "xi", "di", "v", "multi", "yi", "li", "h", "im", "l", "x", "k", "ni"], "j": ["je", "ja", "oj", "e", "jl", "obj", "jp", "ind", "g", "key", "d", "f", "pos", "y", "t", "u", "other", "m", "p", "o", "q", "js", "aj", "el", "num", "J", "ch", "b", "ii", "ji", "ij", "fl", "n", "jc", "v", "z", "li", "h", "jo", "l", "x", "ne", "k"], "channel": ["member", "camera", "row", "attribute", "conn", "config", "character", "container", "chan", "cv", "connection", "cm", "queue", "player", "handler", "plugin", "pc", "type", "layer", "pixel", "can", "socket", "Channel", "component", "slot", "cup", "client", "ch", "sc", "window", "service", "wan", "core", "call", "chron", "chip", "page", "parent", "group", "server", "course"], "ptr": ["str", "port", "grad", "start", "err", "ref", "prot", "pe", "ctr", "tr", "wr", "pad", "pc", "img", "rect", "fp", "buffer", "pos", "pointers", "address", "cp", "data", "tp", "pp", "patch", "p", "uv", "arr", "point", "code", "addr", "elt", "np", "ext", "dr", "ctx", "pr", "pl", "fr", "ch", "rt", "pull", "tmp", "desc", "inst", "fd", "loc", "slice", "iter", "Ptr", "stage", "st", "proc", "buff", "dat", "pointer", "nt", "pair", "dest", "pty", "pt", "att", "offset", "sp", "attr", "inter", "ft"]}}
{"project": "FFmpeg", "commit_id": "caa7a3914f499f74b3ee346f26d598ebdc0ec210", "target": 1, "func": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    int64_t total_size = 0;\n\n    MOVAtom a;\n\n    int i;\n\n\n\n    if (atom.size < 0)\n\n        atom.size = INT64_MAX;\n\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n\n        a.size = atom.size;\n\n        a.type=0;\n\n        if (atom.size >= 8) {\n\n            a.size = avio_rb32(pb);\n\n            a.type = avio_rl32(pb);\n\n            if (a.type == MKTAG('f','r','e','e') &&\n\n                a.size >= 8 &&\n\n                c->moov_retry) {\n\n                uint8_t buf[8];\n\n                uint32_t *type = (uint32_t *)buf + 1;\n\n                avio_read(pb, buf, 8);\n\n                avio_seek(pb, -8, SEEK_CUR);\n\n                if (*type == MKTAG('m','v','h','d') ||\n\n                    *type == MKTAG('c','m','o','v')) {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n\n                    a.type = MKTAG('m','o','o','v');\n\n                }\n\n            }\n\n            if (atom.type != MKTAG('r','o','o','t') &&\n\n                atom.type != MKTAG('m','o','o','v'))\n\n            {\n\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n\n                {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n\n                    avio_skip(pb, -8);\n\n                    return 0;\n\n                }\n\n            }\n\n            total_size += 8;\n\n            if (a.size == 1) { /* 64 bit extended size */\n\n                a.size = avio_rb64(pb) - 8;\n\n                total_size += 8;\n\n            }\n\n        }\n\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n\n        if (a.size == 0) {\n\n            a.size = atom.size - total_size + 8;\n\n        }\n\n        a.size -= 8;\n\n        if (a.size < 0)\n\n            break;\n\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n\n            if (mov_default_parse_table[i].type == a.type) {\n\n                parse = mov_default_parse_table[i].parse;\n\n                break;\n\n            }\n\n\n\n        // container is user data\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n\n                       atom.type == MKTAG('i','l','s','t')))\n\n            parse = mov_read_udta_string;\n\n\n\n        if (!parse) { /* skip leaf atoms data */\n\n            avio_skip(pb, a.size);\n\n        } else {\n\n            int64_t start_pos = avio_tell(pb);\n\n            int64_t left;\n\n            int err = parse(c, pb, a);\n\n            if (err < 0)\n\n                return err;\n\n            if (c->found_moov && c->found_mdat &&\n\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n\n                 start_pos + a.size == avio_size(pb))) {\n\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n\n                    c->next_root_atom = start_pos + a.size;\n\n                return 0;\n\n            }\n\n            left = a.size - avio_tell(pb) + start_pos;\n\n            if (left > 0) /* skip garbage at atom end */\n\n                avio_skip(pb, left);\n\n            else if (left < 0) {\n\n                av_log(c->fc, AV_LOG_WARNING,\n\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n\n                       (char*)&a.type, -left);\n\n                avio_seek(pb, left, SEEK_CUR);\n\n            }\n\n        }\n\n\n\n        total_size += a.size;\n\n    }\n\n\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n\n        avio_skip(pb, atom.size - total_size);\n\n\n\n    return 0;\n\n}\n", "idx": 22013, "substitutes": {"c": ["lc", "bc", "fc", "cc", "cd", "e", "uc", "conn", "ct", "g", "coll", "cv", "cm", "d", "con", "ca", "pc", "cur", "f", "ci", "nc", "cp", "m", "cache", "p", "cs", "xc", "cf", "mc", "tc", "context", "ctrl", "rc", "ctx", "cn", "icc", "ch", "sc", "b", "dc", "cy", "cr", "C", "cca", "jc", "ce", "conf", "cod", "l", "cu", "k", "vc"], "pb": ["bc", "platform", "sb", "fc", "uf", "lb", "jp", "lp", "fab", "db", "mb", "pkg", "fb", "pm", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "PB", "tp", "p", "tc", "wb", "bps", "ctx", "cb", "pl", "wp", "apy", "b", "cpp", "tmp", "hub", "bm", "ab", "bf", "proc", "bh", "rb", "xb", "api", "dp", "ppa", "pa", "pub"], "atom": ["bc", "fc", "article", "ak", "app", "om", "config", "acl", "map", "container", "cm", "mag", "temp", "mom", "buffer", "acc", "cat", "data", "na", "xml", "ta", "perm", "ab", "aka", "alpha", "instance", "attr", "an", "fab", "mA", "arc", "object", "asm", "item", "g", "bb", "A", "as", "node", "term", "op", "ac", "o", "spec", "aa", "element", "prop", "operator", "com", "meta", "fb", "orb", "f", "atomic", "t", "p", "ace", "tc", "num", "b", "tmp", "x", "api", "obj", "input", "ga", "m", "cache", "at", "abc", "tom", "document", "ar", "anon", "parser", "root", "array", "att", "base"], "a": ["mA", "aaa", "tta", "e", "area", "ba", "ast", "app", "fab", "wa", "input", "meta", "ack", "A", "ca", "as", "f", "ea", "asa", "ata", "art", "t", "ac", "ga", "s", "da", "ad", "p", "at", "ka", "na", "ace", "o", "eta", "am", "sa", "af", "la", "au", "aux", "ar", "b", "ada", "sta", "qa", "va", "ai", "aa", "parser", "ab", "parent", "ae", " ca", "alpha", "http", "ma", "l", "api", "an", "pa", "ama"], "i": ["e", "ia", "ie", "ui", "d", "I", "f", "ac", "it", "j", "data", "ip", "at", "p", "id", "o", "is", "index", "ii", "b", "n", "iu", "ai", "z", "li", "l", "count"], "parse": ["send", "config", "val", "func", "P", "pc", "buffer", "cmp", "ci", "r", "cat", "init", "abc", "scan", "cb", "byte", "dc", "seq", "aa", "parser", "util", "proc", "parent", "pair", "array", "pack", "format"], "type": ["class", "target", "part", "val", "pe", "post", "key", "message", "TYPE", "copy", "ty", "buffer", "y", "r", "info", "data", "link", "list", "field", "pl", "rule", "v", "template", "image", "attr", "format", "col", "name", "Type", "cross", "scale", "valid", "style", "split", "op", "state", "description", "lock", "unit", "code", "body", "title", "set", "media", "typ", "offset", "action", "like", "ref", "time", "token", "weight", "model", "t", "size", "p", "comment", "day", "num", "byte", "speed", "role", "error", "length", "call", "loc", "page", "x", "count", "port", "shape", "types", "kind", "color", "get", "cl", "rel", "id", "label", "py", "tag", "index", "match", "location", "ype", "parent", "block", "broad", "url", "value"], "buf": ["bc", "uint", "port", "uf", "binary", "uc", "end", "off", "ref", "config", "cv", "fb", "queue", "func", "bb", "ffff", "bin", "pad", "cur", "img", "cas", "xff", "buffer", "pos", "fp", "alloc", "data", "wb", "pool", "header", "cb", "rc", "num", "shift", "ctx", "mem", "window", "tmp", "seq", "ff", "fd", "src", "len", "comb", "loc", "br", "Buffer", "ab", "batch", "buff", "orig", "rb", "block", "cap", "count"]}}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 22016, "substitutes": {"ad": ["md", "pod", "ang", "end", "Ad", "ap", "conn", "aud", "db", "post", "ay", "wd", "d", "jad", "ca", "pad", "pc", "as", "ld", "art", "ud", "AD", "al", "exec", "ac", "adh", "da", "dd", "cat", "dev", "data", "p", "at", "id", "mod", "addr", "od", "ant", "c", "sd", "ady", "add", "ads", "rad", "a", "mad", "admin", "ada", "dc", "b", "ass", "bd", "ag", "ax", "http", "dat", "att", "quad", "an"], "sglist": ["sglister", " sgelister", "siglist", "siglists", " sglister", "sgnist", " sgelists", "sgelest", "sgelist", "sgelists", "sglists", "sgelister", "sgnists", " sgelist", "sgnest", "siglister", " sglists", "sglest", " sgelest", "sgnister", " sglest", "siglest"], "cmd": ["md", "grad", "cd", "def", "conn", "obj", "bind", "config", "pkg", "mode", "d", "pad", "host", "cmp", "df", "op", "Cmd", "msg", "cp", "args", "data", "cat", "cf", "dict", "ctrl", "code", "addr", "client", "c", "ctx", "cb", "dr", "atom", "cfg", "dom", "rad", "dc", "comm", "req", "proc", "conf", "cod", "command", "MD", "ctl"], "limit": ["delay", "end", "acl", "Limit", "afi", "required", "pos", "cache", "lock", "ip", "shift", "timeout", "lim", "limits", "seq", "min", "length", "page", "iter", "skip", "alt", "block", "position", "base", "url", "count"], "offset": ["summary", "start", "end", "off", "ref", "option", "amount", "align", "f", "pos", "address", "entry", "size", "p", "url", "slot", "o", "initial", "shift", "timeout", "index", "num", "set", "location", "seq", "error", "Offset", "length", "len", "loc", "slice", "skip", "boot", "reset", "range", "alpha", "position", "sort", "base", "outer", "padding", "sum", "zero"], "prdt": ["PRtd", "promdt", "Prdt", "PRt", "prdm", "brtz", "Prdm", " prdm", "Prta", "sprdt", "PRtt", "trqt", "sprtd", " prtd", " prtt", "promqt", "brqt", "brtd", "prtt", "prtd", "promdm", "trtd", "sprtt", "brdt", "promta", "trtz", "prtz", "prta", "PRdt", "sprt", " prtz", " prqt", " prta", " prt", "prt", "trdt", "prqt", "Prqt"], "i": ["io", "ami", "anti", "uli", "e", "ix", "ie", "fi", "qi", "eni", "ui", "gu", "pi", "ki", "gi", "d", "uri", "chi", "ti", "I", "f", "ci", "pos", "t", "y", "r", "phi", "m", "ini", "u", "j", "oi", "info", "it", "p", "ip", "abi", "o", "bi", "mi", "c", "mu", "index", "si", "a", "ii", "b", "ji", "in", "n", "iu", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "yi", "l", "x", "zi", "k", "ni", "count"], "tbl_entry_size": ["tbl_entry2sum", "tbl_ent_Size", "tbl_row_code", "tbl_ent_size", "tbl_entry_scale", "tbl_entry_code", "tbl_part2size", "tbl_no64size", "tbl_part_pos", "tbl_ent_scale", "tbl_no_size", "tbl_entry_sum", "tbl_entry___code", "tbl_entry64loc", "tbl_part2Size", "tbl_no64sum", "tbl_entry2Size", "tbl_entry_length", "tbl_entry___count", "tbl_entry_count", "tbl_entry64sum", "tbl_part_Size", "tbl_entry2pos", "tbl_entry_pos", "tbl_entry_loc", "tbl_entry_speed", "tbl_entry64length", "tbl_entry64size", "tbl_no64loc", "tbl_no_length", "tbl_entry___size", "tbl_entry2length", "tbl_ent_speed", "tbl_entry2loc", "tbl_entry2size", "tbl_row_number", "tbl_no_sum", "tbl_part2pos", "tbl_entry_number", "tbl_no_loc", "tbl_part_size", "tbl_entry___number", "tbl_row_count", "tbl_row_size", "tbl_entry_Size", "tbl_no64length"], "bus": ["io", "bc", "port", "class", "ux", "usb", "config", "board", "db", "connection", "way", "brid", "ou", "bridge", "Bus", "proxy", "cat", "bug", "dev", "state", "cache", "os", "p", "us", "plug", "c", "ch", "b", "service", "hub", "se", "ass", "session", "BUS", "feed", "back", "boot", "h", "block", " buses"], "qbus": ["sqBUS", "qBUS", "sqboot", "sqbus", "QBUS", " qdev", " qBUS", " qboot", "Qboot", "Qdev", "qboot", "sqdev", "qdev", "Qbus"], "tbl": ["ktbt", "typl", "tbt", " tbt", "tbo", "btll", " tbo", "tyBL", "tybl", "ktll", " tll", "tll", "tBL", "ktbl", " tpl", " tBL", "tyml", "pml", "tpl", "btbo", "pbl", "ppl", "tml", " tml", "pBL", "btbt", "ktbo", "btbl"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void dwt_encode97_int(DWTContext *s, int *t)\n\n{\n\n    int lev,\n\n        w = s->linelen[s->ndeclevels-1][0];\n\n    int *line = s->i_linebuf;\n\n    line += 5;\n\n\n\n    for (lev = s->ndeclevels-1; lev >= 0; lev--){\n\n        int lh = s->linelen[lev][0],\n\n            lv = s->linelen[lev][1],\n\n            mh = s->mod[lev][0],\n\n            mv = s->mod[lev][1],\n\n            lp;\n\n        int *l;\n\n\n\n        // VER_SD\n\n        l = line + mv;\n\n        for (lp = 0; lp < lh; lp++) {\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lv; i++)\n\n                l[i] = t[w*i + lp];\n\n\n\n            sd_1d97_int(line, mv, mv + lv);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n        // HOR_SD\n\n        l = line + mh;\n\n        for (lp = 0; lp < lv; lp++){\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lh; i++)\n\n                l[i] = t[w*lp + i];\n\n\n\n            sd_1d97_int(line, mh, mh + lh);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n    }\n\n}\n", "idx": 22034, "substitutes": {"s": ["sky", "sv", "sb", "e", "sym", "space", "support", "es", "bis", "sl", "fs", "g", "ses", "an", "d", "site", "ds", "services", "f", "sys", "u", "m", "ssl", "os", "ts", "p", "cs", "sync", "is", "sites", "sg", "c", "js", "settings", "spec", "self", "sq", "si", "a", "b", "in", "w", "sr", "service", "se", "n", "S", "ns", "sup", "session", "sf", "south", "rs", "gs", "v", "conf", "server", "su", "ss"], "t": ["ut", "e", "table", "flat", "ct", "d", "tt", "yt", "f", "y", "r", "m", "unt", "it", "tp", "opt", "ret", "ts", "p", "at", "bt", "o", "tu", "elt", "ant", "tool", "c", "out", "tf", "dt", "rt", "b", "ta", "w", "set", "T", "n", "te", "tn", "test", "total", "st", "v", "qt", "tm", "z", "nt", "pt", "att", "x", "type"], "lev": ["sv", "lat", "av", "lex", "mag", "lie", "ell", "lu", "leg", "dy", "la", "dim", "ov", "lem", "v", "ev", "lad", "hum", "lez", "scale", "coll", "cel", "coord", "u", "vel", "lim", "low", "du", "vol", "atten", "liv", "ag", "vl", "escal", "lc", "ld", "compl", "uv", "fall", "lin", "depth", "le", "cli", "el", "sea", "lvl", "vv", "loc", "ll", "up", "wl", "zi", "count", "light", "sk", "level", "sl", "lv", "age", "land", "orient", "hor", "ii", "fl", "min", "len", "grade", "lov", "vert"], "line": ["row", "no", "cell", "ell", "liner", "link", "kl", "lay", "LINE", "la", "fr", "rule", "n", "slice", "ge", "end", "scale", "lined", "g", "coll", "d", "style", "ine", "lock", "o", "code", "c", "lim", "vol", "li", "e", "lane", "time", "lines", "margin", "ln", "ld", "layer", "model", "zip", "lin", "le", "edge", "b", "length", "loc", "co", "lf", "wl", "ne", "Line", "light", "level", "sl", "lv", "cl", "entry", "cle", "mm", "sync", "lo", "frame", "source", "se", "len", "range", "block", "base"], "lp": ["hp", "amp", "ml", "lie", "hip", "bp", "pc", "dh", "ell", "cp", "lu", "tp", "lla", "kl", "la", "pl", "hl", "dl", "iu", "v", "atl", "pn", "jp", "ql", "aml", "pd", "fp", "lis", "wp", "mp", "ji", "li", "pi", "dp", "bsp", "vl", "pa", "lc", "lb", "jl", "ln", "layer", "f", "p", "lin", "el", "si", "b", "lvl", "ll", "lf", "wl", "api", "pb", "lv", "il", "pm", "LP", "lr", "ilk", "pp", "tall", "ls", "np", "py", "ijk", "gp", "ii", "rl", "len", "lt", "sp", "vp"], "l": ["lc", "e", "lb", "ul", "lv", "sl", "g", "ml", "il", "d", "ol", "ln", "f", "nl", "ell", "u", "r", "m", "lu", "p", "list", "kl", "lin", "o", "ls", "q", "le", "la", "L", "el", "c", "pl", "b", "rl", "w", "hl", "dl", "n", "fl", "ll", "v", "z", "li", "lf", "h", "all", "k", "url"], "i": ["io", "eni", "key", "ti", "y", "info", "ini", "ip", "iw", "mu", "n", "iu", "di", "v", "fi", "ix", "qi", "jp", "ri", "iv", "g", "gi", "d", "my", "I", "ci", "u", "abi", "o", "code", "mi", "c", "a", "\u0438", "ji", "xi", "yi", "li", "ie", "pi", "ir", "k", "ni", "uli", "e", "ik", "ui", "ki", "f", "phi", "it", "p", "vi", "bi", "cli", "si", "b", "z", "h", "api", "x", "zi", "ori", "iii", "il", "uri", "oi", "adi", "m", "at", "id", "is", "ii", "in", "w", "ai", "ei", "isi"], "j": ["je", "ja", "jit", "oj", "e", "jl", "en", "qi", "jp", "lv", "adj", "g", "ui", "pi", "jen", "d", "json", "bl", "f", "jj", "y", "uj", "u", "m", "kj", "dj", "it", "op", "jet", "p", "jon", "vi", "o", "q", "dy", "js", "el", "aj", "sh", "si", "J", "ijk", "b", "ii", "ji", "x", "ij", "n", "er", "br", "xi", "ll", "jc", "v", "z", "qt", "li", "note", "h", "jo", "api", "bj", "k", "ni"]}}
{"project": "FFmpeg", "commit_id": "0424e052f83adc422d8a746e3cdc5ab6bc28679e", "target": 1, "func": "static void decode_postinit(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture *out = s->current_picture_ptr;\n\n    Picture *cur = s->current_picture_ptr;\n\n    int i, pics, out_of_order, out_idx;\n\n\n\n    s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_H264;\n\n    s->current_picture_ptr->pict_type= s->pict_type;\n\n\n\n    if (h->next_output_pic) return;\n\n\n\n    if (cur->field_poc[0]==INT_MAX || cur->field_poc[1]==INT_MAX) {\n\n        //FIXME this allows the next thread to start once we encounter the first field of a PAFF packet\n\n        //This works if the next packet contains the second field. It does not work if both fields are\n\n        //in the same packet.\n\n        //ff_thread_finish_setup(s->avctx);\n\n        return;\n\n    }\n\n\n\n    cur->interlaced_frame = 0;\n\n    cur->repeat_pict = 0;\n\n\n\n    /* Signal interlacing information externally. */\n\n    /* Prioritize picture timing SEI information over used decoding process if it exists. */\n\n\n\n    if(h->sps.pic_struct_present_flag){\n\n        switch (h->sei_pic_struct)\n\n        {\n\n        case SEI_PIC_STRUCT_FRAME:\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_FIELD:\n\n        case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n            cur->interlaced_frame = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n            if (FIELD_OR_MBAFF_PICTURE)\n\n                cur->interlaced_frame = 1;\n\n            else\n\n                // try to flag soft telecine progressive\n\n                cur->interlaced_frame = h->prev_interlaced_frame;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n            // Signal the possibility of telecined film externally (pic_struct 5,6)\n\n            // From these hints, let the applications decide if they apply deinterlacing.\n\n            cur->repeat_pict = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n            // Force progressive here, as doubling interlaced frame is a bad idea.\n\n            cur->repeat_pict = 2;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n            cur->repeat_pict = 4;\n\n            break;\n\n        }\n\n\n\n        if ((h->sei_ct_type & 3) && h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n\n            cur->interlaced_frame = (h->sei_ct_type & (1<<1)) != 0;\n\n    }else{\n\n        /* Derive interlacing flag from used decoding process. */\n\n        cur->interlaced_frame = FIELD_OR_MBAFF_PICTURE;\n\n    }\n\n    h->prev_interlaced_frame = cur->interlaced_frame;\n\n\n\n    if (cur->field_poc[0] != cur->field_poc[1]){\n\n        /* Derive top_field_first from field pocs. */\n\n        cur->top_field_first = cur->field_poc[0] < cur->field_poc[1];\n\n    }else{\n\n        if(cur->interlaced_frame || h->sps.pic_struct_present_flag){\n\n            /* Use picture timing SEI information. Even if it is a information of a past frame, better than nothing. */\n\n            if(h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM\n\n              || h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n\n                cur->top_field_first = 1;\n\n            else\n\n                cur->top_field_first = 0;\n\n        }else{\n\n            /* Most likely progressive */\n\n            cur->top_field_first = 0;\n\n        }\n\n    }\n\n\n\n    //FIXME do something with unavailable reference frames\n\n\n\n    /* Sort B-frames into display order */\n\n\n\n    if(h->sps.bitstream_restriction_flag\n\n       && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n        s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n        s->low_delay = 0;\n\n    }\n\n\n\n    if(   s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT\n\n       && !h->sps.bitstream_restriction_flag){\n\n        s->avctx->has_b_frames= MAX_DELAYED_PIC_COUNT;\n\n        s->low_delay= 0;\n\n    }\n\n\n\n    pics = 0;\n\n    while(h->delayed_pic[pics]) pics++;\n\n\n\n    assert(pics <= MAX_DELAYED_PIC_COUNT);\n\n\n\n    h->delayed_pic[pics++] = cur;\n\n    if(cur->reference == 0)\n\n        cur->reference = DELAYED_PIC_REF;\n\n\n\n    out = h->delayed_pic[0];\n\n    out_idx = 0;\n\n    for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame && !h->delayed_pic[i]->mmco_reset; i++)\n\n        if(h->delayed_pic[i]->poc < out->poc){\n\n            out = h->delayed_pic[i];\n\n            out_idx = i;\n\n        }\n\n    if(s->avctx->has_b_frames == 0 && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset))\n\n        h->next_outputed_poc= INT_MIN;\n\n    out_of_order = out->poc < h->next_outputed_poc;\n\n\n\n    if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)\n\n        { }\n\n    else if((out_of_order && pics-1 == s->avctx->has_b_frames && s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT)\n\n       || (s->low_delay &&\n\n        ((h->next_outputed_poc != INT_MIN && out->poc > h->next_outputed_poc + 2)\n\n         || cur->pict_type == AV_PICTURE_TYPE_B)))\n\n    {\n\n        s->low_delay = 0;\n\n        s->avctx->has_b_frames++;\n\n    }\n\n\n\n    if(out_of_order || pics > s->avctx->has_b_frames){\n\n        out->reference &= ~DELAYED_PIC_REF;\n\n        out->owner2 = s; // for frame threading, the owner must be the second field's thread\n\n                         // or else the first thread can release the picture and reuse it unsafely\n\n        for(i=out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i+1];\n\n    }\n\n    if(!out_of_order && pics > s->avctx->has_b_frames){\n\n        h->next_output_pic = out;\n\n        if(out_idx==0 && h->delayed_pic[0] && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset)) {\n\n            h->next_outputed_poc = INT_MIN;\n\n        } else\n\n            h->next_outputed_poc = out->poc;\n\n    }else{\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"no picture\\n\");\n\n    }\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n}\n", "idx": 22037, "substitutes": {"h": ["ih", "hp", "hm", "e", "hand", "hs", "g", "ha", "han", "beh", "dh", "oh", "host", "f", "t", "ah", "eh", "m", "kh", "adh", "hd", "her", "p", "rh", "q", "uh", "H", "header", "c", "sh", "ch", "hr", "b", "w", "he", "hash", "hl", "n", "zh", "gh", "history", "th", "hi", "v", "bh", "http", "hw", "hist", "l", "ph", "ht", "hh", "k"], "s": ["ions", "sv", "es", "ds", "sys", "y", "r", "os", "ts", "cs", "stats", "js", "n", "S", "ns", "rs", "ures", "http", "conf", "l", "this", "ss", "sb", "hm", "support", "g", "ses", "d", "sav", "ages", "services", "u", "rh", "o", "q", "sg", "c", "ances", "self", "spec", "sc", "a", "sf", "su", "e", "qs", "hs", "fs", "f", "t", "p", "si", "b", "service", "ps", "gs", "sq", "sch", "sci", "sl", "ops", "m", "storage", "ls", "sync", "is", "settings", "sh", "ch", "in", "w", "comments", "session", "server", "share"], "out": ["conv", "outs", "obj", "conn", "err", "inc", "copy", "rec", "img", "op", "t", "m", "cache", "opt", "arr", "p", "o", "ch", "in", "w", "n", "Out", "co", "doc", "conf", "image", "att", "output"], "cur": ["bc", "config", "catch", "r", "rest", "last", "Cur", "fr", "src", "proc", "http", "conf", "tur", "attr", "pub", "cha", "conn", "ser", "coll", "ctr", "der", "sth", "pg", "cont", "master", "ah", "enc", "cer", "q", "rc", "c", "cb", "spec", "sc", "desc", "child", "try", "keep", "car", "oc", "ph", "cu", "conv", "lc", "public", "prev", "sel", "uc", "ur", "result", "impl", "rec", "per", "cf", "pr", "ver", "sr", "ocr", "usr", "enter", "loc", "co", "th", "sq", "sch", "fac", "sl", "tr", "con", "uber", "cache", "ctrl", "dr", "client", "ch", "ub", "sur", "cr", "cher"], "i": ["io", "name", "e", "ui", "d", "chi", "ti", "I", "ci", "phi", "j", "p", "id", "field", "c", "si", "ii", "n", "ai", "xi", "di", "v", "li", "image", "pi", "x", "ni", "type"], "pics": ["pic", " pic", "spcs", "Pics", "Pcs", "picks", " pcs", "pcs", "Picks", "spics", " picks", "spicks", "spic", "Pic"], "out_of_order": ["out_of_orders", "out_or_desc", "out_of_desc", "out_of_info", "out_or_orders", "out_or_order", "out_or_info"], "out_idx": ["out_sidi", "out_Idx", "out_idi", "out_Idxc", "out_idxs", "out_sidxc", "out_startxs", "out_sidxs", "out_idxc", "out_starti", "out_Idi", "out_Idxs", "out_startx", "out_sidx", "out_startxc"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047, "substitutes": {"dst_errp": ["dst_rrr", "dst_erpre", "dst_irps", "dst_rrP", "dst_rr", "dst_erl", "dst_rpc", "dst_rP", "dst_erpc", "dst_erps", "dst_errpc", "dst_rpre", "dst_errr", "dst_rrp", "dst_errP", "dst_raisel", "dst_raiser", "dst_erb", "dst_irp", "dst_raiseb", "dst_rrpre", "dst_errorb", "dst_erp", "dst_errorp", "dst_errorP", "dst_errorpc", "dst_rrps", "dst_errorl", "dst_err", "dst_rp", "dst_raisep", "dst_errorr", "dst_errl", "dst_errb", "dst_errpre", "dst_erP", "dst_errorps", "dst_irr", "dst_errps"], "local_err": ["localallvar", "local___error", "local___arr", "global_r", " local_arr", "local___req", " local_req", " local_er", "remote_er", "Local_err", "local_var", "loc_rr", " local_rr", "global_er", "local_req", "local_er", "local___err", "remote_err", "local_arr", "localallrr", "localallerr", "loc_error", "local_r", "global_err", "Local_gr", "global_error", "local_gr", "loc_err", "Local_er", "Local_r", "local_type", "localallerror", "local_error", "remote_error", "local_rr", "remote_type", "loc_var", " local_error"]}}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "substitutes": {"ret": ["reg", "expr", "wrapper", "result", "ctr", "tr", "prep", "Ret", "buffer", "fit", "model", "path", "final", "cache", "prefix", "active", "ctx", "aux", "seq", "test", "iter", "req", "alt", "template", "output"], "TCGv": ["TCGlvv", "OCGuvv", "TCGuvr", "TCGvr", "TCGlf", "PGGMv", "TCCGv", "PCgvs", "TCgver", "PCGvan", "TCGenerv", "PCgv", "TCGarf", "TCgvv", "TCGsV", "PGGMV", "TCGMvm", "TCMGvv", "TCGroupvc", "TCGenevv", "TCGWf", "TCMGver", "TCGarv", "TCGroupev", "TCGlvan", "TCGef", "PCGvs", "TCGenevan", "TCGuvv", "PGGMvr", "TCGvan", "TCGMv", "TCGatep", "OCGuver", "PCGcv", "TCGenef", "PCgvc", "TCGenervc", "OCGuvr", "TCGsv", "TCGsvr", "TCGatev", "TCGeneralvc", "TCGvm", "TCgvan", "PGGMvm", "OCGv", "PCGp", "TCgev", "TCGarev", "PCgvan", "TCGvv", "PGGvm", "TCGarvs", "TCgf", "PCgev", "TCGsvm", "TCGWev", "PCgcv", "OCGvr", "TCgvr", "PGGV", "TCGWvc", "TCgvs", "TCGV", "TCGev", "TCGenerf", "TCGeneralf", "PGGvr", "OCGver", "TCGver", "TCGeneralvs", "PCGvc", "TCCGvm", "TCGep", "TCGWvs", "PCgvv", "PGGv", "TCCGV", "TCGcv", "TCGlv", "TCGMV", "PCGf", "TCMGv", "TCGuver", "OCGvv", "OCGuv", "TCgvc", "TCGatecv", "PCgp", "TCGenev", "TCGf", "PCGvv", "TCgp", "TCgcv", "PCGv", "TCGWv", "TCMGvr", "TCGeneralv", "TCGecv", "PCgf", "TCGroupv", "TCGuv", "PCGev", "TCGp", "TCGvc", "TCGvs", "TCGenervs", "TCCGvr", "TCGatef", "TCGMvr", "TCGroupf", "TCgv"], "uint32_t": ["uint32_n", "uint8_f", "uint32_int", "uint8_t", "uint16_n", "uint16_T", "uint8_T", "uint32_f", "uint32_T", "uint32_p", "uint16_p", "uint16_t", "uint8_int"]}}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 22065, "substitutes": {"STATUS_PARAM": ["STATUS_VAR", "STATUS_AVAS", "STATUS_AVAR", "STATUS_PAM", "STATUS_PAME", "STATUS_PARAR", "STATUS_PARAS", "STATUS_PAR", "STATUS_PARAME", "STATUS_VAS", "STATUS_VAME", "STATUS_AVAM", "STATUS_AVAME", "STATUS_VAM", "STATUS_PAS"], "aSign": ["asSign", "aIgn", "aeSign", "aDig", "aaExp", "aaMod", "APass", "asScale", "aScript", "anDig", "vaSign", "ADig", "arComp", "aeScale", "ASign", "saExp", "saSign", "arSign", "aComp", "asExp", "aaIgn", "aMod", " aIgn", " aScale", "vaShift", "aeExp", "vaDig", "anSign", "aScale", " aDig", "anExp", "aaDig", "anPass", "arScript", "alphaMod", "arExp", "aaComp", " aMod", "aPass", "alphaSign", "aaScript", " aPass", "saScale", "alphaExp", "aShift", "aaSign", "AExp", " aShift", " aScript", "vaIgn", "aaShift", " aComp"], "aExp": ["anRaw", "anaExp", "alphaExt", " aEx", "anComp", "aRaw", "amaNorm", "vaExpl", "aDecl", "anEXP", "vaEXP", "saEx", "aExpl", " aExpl", "anaNorm", " aEXP", "anotherScale", "saExp", "pSign", "saExpl", "anCl", "aComp", "anExt", "anotherExp", "laExp", "anaEx", " aDecl", "amaDecl", " aNorm", "vaExt", "amaEx", " aScale", "alphaEXP", "vaEsc", "anEx", "pCl", "aScale", "anSign", "alphaComp", "aEx", "anaDecl", "aExt", "saExt", "anExp", "ACl", "aCl", "laScale", " aRaw", "anotherEXP", "pExp", "anotherEx", "ARaw", "vaExp", "aEXP", "AComp", "gaEx", "pEx", "gaEXP", "alphaExp", " aExt", "laEx", "laEXP", "amaExp", "AExp", " aCl", " aEsc", "aEsc", "gaEsc", " aComp", "aNorm", "gaExp", "vaEx"], "shiftCount": ["ShiftSum", "shiftcount", "pushCount", "sliceCast", "hiftCast", " shiftType", "shiftSum", " shiftcount", "pushcount", "hiftSum", "sliceCount", " shiftSum", "hiftCount", "hiftcount", " shiftCast", "pushType", "pushCast", "hiftType", "ShiftCount", "Shiftcount", "shiftType", "shiftCast", "slicecount"], "aSig": ["aSuigma", "aPresign", "aPresigs", "aSlig", "aEsIG", "aJsIG", "aJsigma", "aSIG", "aCassigs", "aAsIG", "aDsiger", "aPsIG", "aIssigma", "aPsigs", "aDsign", " aSiz", "aAsig", " aSlig", "aSuig", "aAsign", "aDsigs", " aAsig", "aPsim", " aAsign", "aSature", "aAsigma", "aCassign", "aSlim", "aIssIG", "aSiger", " aSigma", "aDsig", "aVsign", "aSim", "aSigs", "aUsign", "aSuiz", "aJsig", "aCassig", " aSlIG", "aDsiz", "aCassiger", " aAsigma", "aVsature", "aPsig", "aPresigma", "aJsigs", "aEsiz", "aPresig", "aUsig", " aSligs", "aAsigs", "aVsig", "aPresiger", "aPresIG", "aSiz", "aEsigs", " aAsature", "aUsigma", "aIssig", "aEsig", " aSuig", "aDsigma", " aAsIG", "aDsIG", " aAsigs", "aVsIG", " aSature", " aSuign", "aSligs", "aSuign", "aEsign", "aIssiger", "aAsiger", " aSuigma", "aUsigs", " aSlim", " aSigs", "aEsigma", "aSigma", "aJsign", " aSim", " aSuiz", " aAsiger", "aSlIG", " aSIG", " aSiger", "aAsature"], "savedASig": ["savingASigma", "saveASign", "savedASIG", "saveAsigma", "savedPSig", "saveASigma", "savedASiger", "saveASig", "savedNASig", "savingAsIG", "savedNASign", "savingASig", "saveASIG", "savedAsiger", "savedSig", "savedSigma", "saveASiger", "savedASigma", "savedAsig", "savingAsign", "savingAsig", "savedSiger", "savedAsign", "savedASign", "saveAsiger", "savedSIG", "savedAsigma", "savedAsIG", "savedNASIG", "saveAsign", "savingASign", "savedSign", "savedNASigma", "savedPSign", "savingAsigma", "savedPSiger", "savedPSIG", "saveAsig", "saveAsIG", "savingASIG"], "z": ["az", "i", "e", "iz", "zo", " w", "Z", " Z", "yz", "g", "spin", "ze", "d", "za", "sign", "f", "y", "t", "u", "r", "m", "oz", "j", "zip", "p", "zz", "zone", "code", "q", "gz", "sa", "shift", "c", "zen", "ez", "zer", "a", "b", "w", "qa", "n", "zh", "cz", "v", "ce", "tz", "h", "l", "x", "nz", "zi", "k"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 22082, "substitutes": {"bs_queue": ["bc_que", "bs_file", "ns_channel", "bs_server", "b_queue", "b_que", "bs_que", "bc_queue", "b_entry", "ns_que", "ns_queue", "blocks_que", "bs_channel", "bs_client", "vs_file", "bc_client", "blocks_file", "vs_que", "blocks_queue", "vs_server", "vs_queue", "vs_entry", "b_file", "blocks_entry", "bc_entry", "ns_parent", "bs_parent", "blocks_server"], "bs": ["lc", "bc", "pb", "obs", "sb", "bos", "lbs", "lb", "bis", "obj", "ba", "fs", "ses", "ubs", "bal", "fb", "bb", "bytes", "plugins", "bin", "bp", "css", "bl", "bes", "ds", "bing", "blog", "bid", "eb", "bas", "state", "ob", "os", "vs", "cs", "ls", "bps", "buf", "js", "cb", "b", "bits", "sub", "blocks", "ns", "BS", "iss", "ps", "ins", "gs", "lib", "bot", "base", "ss", "gb"], "flags": ["status", "iffs", "lbs", "types", "ags", "linux", "ints", "fixes", "fs", "features", "rules", "locks", "bytes", "ops", "plugins", "properties", "bugs", "fg", "fps", "s", "size", "args", "ils", "fee", "data", "state", "codes", "fx", "cs", "vals", "vs", "ports", "caps", "stats", "ants", "Flags", "settings", "lag", "styles", "forces", "bits", "flag", "FLAG", "seq", "parts", "fl", "fd", "mask", " Flags", "fields", "sf", "utils", "options", "util", "files", "ips", "feat", "states", "fun"], "bs_entry": ["bs_file", "vs_rance", "ss_queue", "vs_check", "bc_queue", "bs_rance", "bs_service", "bs_module", "ns_enter", "bs_reader", "ss_service", "bs_check", "ns_entry", "vs_enter", "bsPcheck", "ss_enter", "vs_queue", "ss_entry", "vs_entry", "bs_Entry", "bsPqueue", "bc_file", "bsPentry", "bc_entry", "bsPenter", "ns_reader", "ns_module", "bc_Entry", "vs_Entry", "bs_enter"]}}
{"project": "FFmpeg", "commit_id": "808c10e728db2d92ccbb0f8b3bcd4a2f4305a2cf", "target": 0, "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        AVBPrint part[3], int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    av_bprint_init(part+0, 0, 1);\n\n    av_bprint_init(part+1, 0, 1);\n\n    av_bprint_init(part+2, 0, 65536);\n\n\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                av_bprintf(part+0, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(parent);\n\n            }\n\n        }\n\n        av_bprintf(part+1, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    av_vbprintf(part+2, fmt, vl);\n\n\n\n    if(*part[0].str || *part[1].str || *part[2].str) {\n\n        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;\n\n        *print_prefix = lastc == '\\n' || lastc == '\\r';\n\n    }\n\n}\n", "idx": 22086, "substitutes": {"ptr": ["uint", "class", "pad", "pc", "buffer", "pos", "alloc", "r", "slave", "address", "cp", "later", "fr", "peer", "src", "slice", "br", "proc", "nt", "pointer", "fi", "primary", "attr", "inter", "str", "jp", "push", "mount", "ctr", "eth", "private", "fp", "code", "ext", "desc", "dll", "eger", "pair", "typ", "offset", "remote", "ref", "adr", "thread", " pointer", "p", "nil", "ace", "point", "addr", "comp", "tmp", "inst", "length", "fd", "trace", "reference", "tty", "Ptr", "pty", "h", "porter", "port", "kind", "tr", "transfer", "dr", "ctx", "touch", "tip", "pt"], "level": ["col", "kind", "scale", "mode", "style", "ln", "temp", "cl", "layer", "Level", "vel", "unit", "point", "depth", "levels", "line", "lvl", "length", "loc", "len", "stage", "lf", "lang", "scope", "base", "count", "letter"], "fmt": [" flt", "vret", " filt", "vformat", "Flt", " fformat", "Fnt", "hnt", "filt", "hformat", "Fret", "fret", "fformat", " fnt", "Fformat", "fnt", " fret", "vlt", "hmt", "Fmt", "hilt", "Filt", "flt", "vmt"], "vl": [" l", "lc", "lp", "lv", "ml", "iv", "bb", "ol", "ln", "mt", "ld", "buffer", "split", "nl", "lan", " ls", "wl", "kl", "ls", "var", "el", "pl", " lvl", "lvl", "vol", "ure", "fl", "icle", "vv", "len", "ll", "nb", " LP", "v", "tl", "lf", "erv", "l", "vc"], "part": ["step", "class", "half", "key", "connection", "pad", "no", "pos", "order", "info", "front", "bit", "data", "list", "work", "sector", "line", "division", "PART", "from", "old", "instance", "format", "but", "member", "name", "phase", "only", "object", "item", "split", "pre", "state", "component", "unit", "year", "detail", "self", "add", "try", "element", "pair", "position", "offset", "result", "time", "Part", "function", "layer", "one", "section", "patch", "p", "or", "point", "comment", "day", "parts", "error", "partial", "page", "stage", "group", "pty", "count", "span", "start", "argument", "and", "obj", "cond", "product", "art", "entry", "diff", "id", "change", "word", "ch", "block", "pt", "base"], "print_prefix": ["print__format", "logableformat", "printablefix", "printableformat", "log_format", "log_fix", "logablegap", "print__fix", "printlogname", "print_fix", " print_format", "printlogtoken", "print_offset", "printablegap", "write_token", "log_prefix", "print_gap", "logablefix", "printableprefix", "printlogprefix", "printlogoffset", "print_token", "log_gap", "print_format", "logableprefix", "write_prefix", " print_fix", "printlogformat", "printlogfix", "print_name", "print__prefix", "print__gap", "printloggap", "write_offset", "write_name"], "type": ["class", "target", "val", "pe", "post", "key", "TYPE", "ty", "sys", "y", "order", "info", "other", "cat", "list", "link", "var", "line", "rule", "attr", "format", "Type", "name", "cross", "object", "option", "ping", "style", "op", "pre", "unit", "code", "year", "typ", "like", "ref", "time", "function", "layer", "model", "t", "size", "p", "or", "point", "number", "comment", "pr", "ver", "error", "call", "length", "user", "group", "resource", "x", "count", "status", "span", "port", "types", "rel", "at", "id", "py", "tag", "index", "match", "in", "ype", "block", "all", "base", "where", "value"], "avc": ["avcs", "avect", "avl", "Avcs", "avec", " avlc", "ajb", "AvC", " avcu", " avac", "avb", "avct", "avecs", "afct", "avf", "afcs", "ajc", "avac", "avlc", "afcu", "Avf", " avl", "avelc", "aff", "Avcu", "avcu", "Avc", " avC", "avC", "Avb", "auc", "aveac", "ajC", "aulc", "aul", " avb", "afac", "ajf", "afc", " avf", " avcs", "avel", "aflc", "auct", "afl"], "parent": ["author", "class", "target", "none", "pe", "key", "connection", "temp", "pc", "path", "fat", "parents", "other", "pool", "family", "pid", "test", "pointer", "cot", "instance", "gap", "col", "name", "conn", "option", "g", "coll", "null", "file", "anc", "term", "op", "master", "ac", "component", "current", "unit", "o", "c", "self", "channel", "child", "offset", "pa", "remote", "public", "ref", "result", "layer", "per", "size", "p", "or", "point", "mother", "pr", "comp", "loc", "owner", "reference", "children", "api", "tax", "paren", "port", "and", "Parent", "anch", "cache", "rel", "common", "father", "id", "ctx", "source", "root", "pt"]}}
{"project": "FFmpeg", "commit_id": "1f4ff53aea7c5090f31cd1323d95f7c407c9b2bb", "target": 0, "func": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)\n\n{\n\n    if (cid != ctx->cid) {\n\n        int index;\n\n\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);\n\n            return AVERROR(ENOSYS);\n\n        }\n\n        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);\n\n\n\n        ff_free_vlc(&ctx->ac_vlc);\n\n        ff_free_vlc(&ctx->dc_vlc);\n\n        ff_free_vlc(&ctx->run_vlc);\n\n\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n\n                 ctx->cid_table->ac_bits, 1, 1,\n\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,\n\n                 ctx->cid_table->dc_bits, 1, 1,\n\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n\n                 ctx->cid_table->run_bits, 1, 1,\n\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n\n\n        ctx->cid = cid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22089, "substitutes": {"ctx": ["bc", "fc", "cam", "config", "cm", "connection", "pc", "css", "sys", "cp", "na", "cs", "xc", "kb", "context", "cpp", "qa", "general", "fw", "cus", "cms", "fi", "txt", "wcs", "support", "conn", "linux", "jp", "coll", "pkg", "cv", "anc", "fp", "ci", "component", "setup", "rc", "c", "cb", "wp", "cfg", "sc", "cci", "gc", "utils", "lib", "ce", "scope", "cu", "vc", "conv", "lc", "cc", "tx", "cas", "cmp", "exec", "cmd", "act", "cf", "tc", "cli", "loc", "cca", "co", "hw", "voc", "git", "obj", "sci", "chan", "ca", "Context", "qq", "cl", "nc", "mc", "ctrl", "np", "sync", "client", "cn", "gp", "cal", "ck", "kw"], "cid": ["cname", "pids", " caid", "cuids", "Cip", "pip", "gid", "foid", "cfid", "cuID", "dcid", "uId", "pid", "lcurl", " ciden", " cID", "nid", "cfname", "pname", "ride", "Cids", "lcId", "ucID", "caid", "csids", "csiden", "ucurl", "rID", "Cname", " coid", "raid", "lcoid", "acname", "csid", "ucid", "cuid", " cname", "fid", "cID", "lcid", "lcip", "noid", " curl", "coid", "gname", "dcide", "cids", "csID", "acId", "cuiden", " cId", " cip", "dcids", "cfurl", "acid", "nID", "rid", "cide", "lcname", "gids", "uurl", "ucId", "fID", "acID", "curl", " cide", "Cid", "acip", "acaid", "acids", "ciden", "gip", "fids", "cId", "cip", "cfoid", "dcname", "uID", " cids", "acide", "nids", "uid"], "index": ["member", "found", "i", "view", "edit", "connect", "end", "level", "ind", "include", "input", "inc", "part", "key", "connection", "access", "column", "node", "weight", "type", "pos", "path", "ion", "section", "info", "address", "size", "j", "id", "prefix", "count", "find", "context", "sync", "comment", "active", "Index", "num", "search", "match", "add", "x", "pull", "location", "date", "length", "slice", "loc", "len", "element", "append", "insert", "update", "instance", "block", "position", "image", "offset", "action", "value"]}}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n", "idx": 22093, "substitutes": {"avctx": ["mpctx", "attcontext", "evca", "autcms", "Avcf", "AVcmp", "afca", "autctx", "afcf", "akcn", "afcn", "afcmp", "Avjp", "afctx", "AVcontext", "evcontext", "avcf", "mpcontext", "avca", "attcms", "akcontext", "afcms", "Avcontext", "AVcms", "akctx", "akcms", " avjp", "mpca", "avcontext", " avcf", "attcmp", "afjp", "evcmp", "avcms", " avcn", "evctx", "autcontext", " avcms", "avcmp", "Avctx", "afcontext", "AVctx", "autcmp", " avcontext", "avjp", "avcn", "mpcmp", "attctx"], "x4": [" x14", "f2", "yfour", "ex6", "i72", "cross384", "xi384", "wa54", " x484", "y84", " x24", "xi484", "x24", "pfour", "cross4", "ex004", "x2004", "cross24", "y2", "rx4", "i004", "q72", "crossfour", " x104", "wa004", "u004", "xoutput", "u04", "exfour", "q2004", " x40", "ax2004", "ffour", "ax04", "ax4", "work84", "ax6", "wa104", "X4", "f4", "wa4", "p4", "ex4", "f04", "viewoutput", "axfour", "Xfour", "q4", "X14", "p104", "view4", " x54", "ax104", "x6", "p40", "y2004", "qfour", "X40", "rx40", "cross6", "x14", " x004", "xi400", "x54", "u6", "cross400", " x6", "view484", " x44", "workfour", "cross104", "x2", "cross54", "cross004", " x04", " xoutput", "ax40", "x04", "u4", "work2", "f14", "i4", "ifour", "q004", "y4", "u72", " x2", "x104", "x484", "ufour", "x40", "x004", "X2", "x44", "X84", "x384", "work4", "x84", "xi4", "xfour", "x72", "xi14", "view14", "rxfour", "xioutput", " x400", " xfour", "rx44", "x400", " x384", "X44", "xi24", "f6"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n", "idx": 22094, "substitutes": {"env": ["priv", "net", "enh", "txt", "e", "en", "end", "conn", "err", "eu", "config", "next", "iv", "eni", "ench", "eng", "queue", "style", "ea", "ef", "exec", "exc", "ah", "nc", "args", "enc", "ep", "code", "context", "np", "que", "ext", "rc", "equ", "enable", "profile", "viron", "enter", "er", "console", "iss", "osc", "v", "vm", "erv", "ev", "environment", "fi", "ec"], "sigset": ["sigsget", "ssigmamatch", "sigcase", "ssigmatch", "sighmatch", " sigsend", "sigmamatch", " sigsbase", "swigbase", "swigmatch", "siggbase", "siggset", "siget", "dsiget", "ssigcheck", "sigsmatch", "ssigset", "psigset", "sigsSET", "sIGSET", "sighbase", "psigmaSET", "sigscase", " sigsSET", "ssigmaset", "sigmacase", " sigSET", "sigscheck", "sigbase", "dsigsset", "ssigmacheck", "sigerend", "sigmaSET", "sigend", "sIGget", "segcheck", "sIGet", "sigmaend", "psigmasc", "psigmaset", "sigsend", "sigcheck", " sigget", "psigmacheck", "sigmatch", "sigerset", "sigsc", "swigend", "sigsset", "sighset", "dsigbase", "sIGcase", "sIGset", " sigmatch", "psigsc", " sigsget", "segSET", " sigbase", " siget", "sigermatch", "sigssc", "segsc", "psigcheck", "swigcheck", "sIGend", " sigsmatch", " sigcase", "segset", "swigset", "sigSET", "sigmaget", " sigsset", "sigmacheck", "ssigmaend", "sigmaset", "sigercheck", "sigget", "psigSET", " sigscase", "sigmasc", "dsigset", " sigend", "sigsbase", "ssigend", "sigmaet", "dsigsbase"], "sigmask": ["sirmuth", " sigmak", "smmask", "symake", "sirmake", "semicatch", "sigmaake", " sigmaake", "sirmik", "siggak", "sigake", " sirmuth", "sigmaatch", "sirmask", " sirmatch", " sirmallow", "semicake", " sirmik", "sigmash", "siggask", "semicallow", "sigmaik", "sirmark", "sigmaask", "siematch", "sigash", "sirmallow", " sigmash", "siemask", " sigmaak", "sigmik", "sigmuth", " sigmauth", "sigask", "sighask", "siemake", "sigmatch", " sigmaask", "sigguth", "smmake", "sigmak", "siggatch", "siemak", "sigmallow", "sighake", "sigmake", "siemallow", "sigmaallow", " sigmatch", "siggake", "smmak", "semicask", "sirmatch", "sigark", " sirmask", "symash", "sigmaak", " sigmark", " sigmuth", " sigmake", " sigmallow", " sigmik", " sirmake", "sigmauth", " sirmash", " sirmark", "symask", " sirmak", "sirmash", "sigmark", "sighak", "sirmak", "smmuth", "symark", "sighik"], "r": ["e", "rd", "err", "ur", "result", "d", "rr", "rf", "lr", "f", "order", "u", "m", "s", "p", "or", "rh", "rw", "rc", "c", "dr", "nr", "rn", "ar", "rar", "run", "rt", "b", "sr", "rl", "hr", "vr", "re", "cr", "er", "reader", "R", "br", "mr", "rs", "ler", "ner", "z", "v", "rb", "kr", "l", "k", "rg"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n", "idx": 22132, "substitutes": {"opaque": ["ompusher", "opaques", "operacity", "operaque", "opec", "ospacity", "ospque", "opusher", "ompacity", "ompaques", " opaques", "operusher", " opusher", "opacity", " opque", " opacity", "ospec", "opque", "iopacity", "ospaque", "iopaque", " opec", "ompaque", "operaques", "iopec", "iopque"], "s": ["i", "sb", "e", "sym", "es", "sie", "sl", "g", "ses", "fs", "d", "ops", "ds", "services", "f", "secure", "sys", "u", "php", "socket", "ssl", "os", "p", "o", "ls", "sync", "is", "open", "sa", "sg", "c", "js", "self", "opens", "close", "settings", "si", "a", "b", "w", "S", "ns", "sf", "gs", "sec", "server", "ss"]}}
{"project": "FFmpeg", "commit_id": "de1824e970d448a84bedce4936c301c322baa714", "target": 0, "func": "static int mpeg_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    Mpeg1Context *s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n\n    av_dlog(avctx, \"fill_buffer\\n\");\n\n\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {\n\n        /* special case for last picture */\n\n        if (s2->low_delay == 0 && s2->next_picture_ptr) {\n\n            *picture = s2->next_picture_ptr->f;\n\n            s2->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return buf_size;\n\n    }\n\n\n\n    if (s2->flags & CODEC_FLAG_TRUNCATED) {\n\n        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n\n\n\n        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)\n\n            return buf_size;\n\n    }\n\n\n\n    s2->codec_tag = avpriv_toupper4(avctx->codec_tag);\n\n    if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32(\"VCR2\")\n\n                                           || s2->codec_tag == AV_RL32(\"BW10\")\n\n                                          ))\n\n        vcr2_init_sequence(avctx);\n\n\n\n    s->slice_count = 0;\n\n\n\n    if (avctx->extradata && !avctx->frame_number) {\n\n        int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);\n\n        if(*data_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"picture in extradata\\n\");\n\n            *data_size = 0;\n\n        }\n\n        if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n\n            return ret;\n\n    }\n\n\n\n    return decode_chunks(avctx, picture, data_size, buf, buf_size);\n\n}\n", "idx": 22137, "substitutes": {"avctx": [" avctrl", "aveca", "avecf", "avecas", "afca", "vercontext", " avcoll", "avecam", "ajkb", "avcas", "afloc", "aucas", "avecv", "alcam", " avconn", "aircas", "ajcmd", "ajctx", "avcmp", "afconn", "alctx", "avctrl", "afkb", "avkb", "avecu", "aveloc", "avcv", "afsync", "avsync", "airctx", "afcam", "afcci", "verctx", "avct", "afctx", "ajcf", "ajcal", "avecci", "avcontext", "alcv", "vercoll", "ajcu", "afcal", "ajcmp", "aircf", "AVcam", "AVctx", "afcv", "aveconn", "alcmp", "airctrl", "avect", "avcam", "avecoll", "ajcontext", "avcal", "afcmp", "afcmd", "aucontext", "avcoll", "avcf", "afct", "avca", "afcas", "afcu", "avcu", "avectx", "afcontext", "aircontext", "aucf", "auctx", "afctrl", "avesync", "avcci", "ajcci", "ajcam", "ajloc", "afcoll", "AVcmp", "afcf", "avconn", "ajct", "AVcontext", "avecmp", "versync", "avecontext", "ajca", "avecmd", "avekb", "avecal", " avcas", "avcmd", "aircam", " avcontext", "avloc"], "data": ["package", "view", "i", "start", "next", "sample", "config", "result", "input", "board", "val", "message", "Data", "queue", "bytes", "img", "fp", "buffer", "pos", "size", "cache", "p", "code", "body", "au", "memory", "frame", "audio", "du", "a", "window", "DATA", "tmp", "library", "media", "reader", "slice", "length", "iterator", "src", "database", "batch", "buff", "dat", "image", "block", "api", "pack", "base", "photo", "video", "value"], "data_size": ["buf_size", "data_sized", " data_count", "data6sized", "ata_size", "ata6needed", "data_count", "slice_number", "data_number", "data2mode", "batch_size", "slice_unit", "ata6size", "ata_sized", "data2size", "buf_mode", "data2needed", "data_unit", "ata6sized", "ata6mode", "data2sized", "buf_scale", "data6needed", "data_mode", "data_cache", "batch_offset", " data_len", "data6mode", " data_scale", "slice_size", "ata_needed", "data6size", "data_stream", "data_scale", "data_offset", "ata_mode", "data_ize", "batch_stream", "slice_ize", "data_len", "data_needed", "batch_cache"], "avpkt": ["avlpkt", "avpnt", "avpacht", "abfacket", "avpud", "avpatt", "avlpacket", "avpakt", "avfpnt", "avfck", "avfpsth", "abpatt", "avpaud", " avfpkt", "avbsth", "avpks", "abpacket", "avpck", "avvpck", "avedud", "avfkt", "avfcht", "avPsth", "abpck", "avlpck", "avpaacket", "avepkt", "abfkt", "avPnt", "avpcht", "abpkt", " avpnt", "avepcht", "avedacket", " avfpnt", " avpsth", "avdcht", "avedcht", "avfacket", "avfpks", "avdud", " avpks", "avedkt", "avbnt", "avbkt", " avfpks", "avPks", "avpsth", "avvpkt", "avlpatt", "abfck", "avdkt", "avepacket", "avepud", "avvpacket", "avvpatt", "avdacket", " avfpsth", "avPkt", "abfatt", "avpacket", "avfud", "avfpkt", "avbks", "avfatt"], "buf": ["conv", "bc", "pb", "uf", "uc", "next", "config", "result", "cv", "fb", "queue", "pad", "home", "img", "fp", "cas", "buffer", "alloc", "cp", "box", "cf", "code", "wb", "cb", "ctx", "frame", "b", "raw", "seq", "src", "fd", "length", "wav", "br", "bd", "batch", "buff", "proc", "vec", "bag", "rb", "block", "fi", "feat"], "s": ["e", "sym", "qs", "hs", "sl", "fs", "g", "ses", "sac", "nas", "sets", "ds", "services", "f", "sys", "t", "u", "r", "m", "args", "ssl", "p", "cs", "ts", "params", "ls", "stats", "sa", "sg", "js", "c", "spec", "sq", "si", "b", "aws", "service", "session", "S", "ns", "n", "sf", "utils", "ps", "rs", "gs", "http", "v", "h", "su", "ss", "share"], "picture": ["ana", "package", "summary", "cam", "csv", "obj", "movie", "config", "meta", "file", "uri", "feature", "Picture", "img", "fp", "buffer", "pict", "info", "storage", "stat", "p", "pic", "filename", "bank", "ctx", "frame", "audio", "sea", "profile", "library", "media", " pictures", "slice", "jpg", "doc", "avi", "li", "image", "photo", "fi", "video"], "s2": ["s02", "aws256", "ftwo", "f2", "sessionnow", " s1", "ls2", "p2", "sstwo", "cbc", "h02", "sgII", "stwo", "nssecond", "ns62", "aws2", "p62", "Stwo", "sys2", "ss2", " s5", "c1", "f82", "session62", " s4", "session2", "ctwo", "nstwo", "sbc", "ds02", "htwo", "ss6", "sg12", "hs12", "sys1", "ptwo", "s5", "sys0", "ws2", "pstwo", "s62", "nsII", "h1", "awstwo", "dstwo", "is2", "ds2", " sII", "c4", " stwo", "dtwo", "ds1", "sgnow", "S2", "csecond", "sg4", "hs62", "S12", " sbc", "ns82", "c02", "s0", "isnow", "S82", "sg62", "ks2", "h2", "sbs", "sysbc", "ls82", "ws82", "p0", "sys4", "d2", "s6", "hs2", "ns4", "ps2", "sys5", "s1", "is62", "f12", "ks1", "c62", "wstwo", "c256", "ps256", "ks62", "hsbs", "d62", "snow", "sys62", "sessiontwo", "s256", "ss0", "c5", "ws256", " s0", "s82", "ls256", "sII", "p02", "sgbs", "ssecond", " snow", "c2", "nsnow", "dnow", "ns256", "sg2", "s12", "nsbs", "istwo", "p1", " s6", "awssecond", "s4", "ns2", "ns12", "ws6", "ps82", "lstwo", " s62", "ks02", "ws0"]}}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n", "idx": 22140, "substitutes": {"opaque": ["transacity", "operacity", "opaques", "operaque", "iopaco", "opatile", " opaco", "paco", "oppac", "transac", " opac", "opaco", "ompaco", "iopaques", " opaques", "oppaco", "oplaques", "oppaque", "ompac", " opatile", "oplaque", "opacity", "opac", " opacity", "oplacity", "transatile", "transaque", "oppa", "iopacity", "operatile", "pac", "iopaque", "operac", "opa", "paque", "ompa", "ompaque", "pa", "oplaco"], "chr": ["chsr", " chrr", "qri", " chrs", "phr", "ochrar", "CHrar", "CHr", "Chr", "chrs", "phri", "mutrr", "chrc", "cherc", "Chrr", " chru", "CHsr", "attrr", "ochrr", "qru", " chm", "qsr", "chru", " chro", "Chm", "mutr", "CHri", "chm", "phro", "mutrs", "ochrc", "ochr", "attrar", "chri", "chro", " chri", "cherr", "chrr", " chsr", "Chrs", "cher", "mutm", "qro", "qrar", "phru", "chrar", " chrar", "attr", "qr", "cherar", "attrc"], "s": ["sv", "sb", "e", "sym", "space", "es", "sl", "hs", "g", "ses", "sie", "ops", "ks", "ds", "services", "f", "secure", "sys", "r", "m", "socket", "state", "ssl", "os", "p", "cs", "ls", "o", "sync", "is", "ss", "sg", "c", "js", "self", "spec", "si", "sc", "sr", "b", "service", "se", "aws", "n", "S", "ns", "session", "sf", "ps", "rs", "gs", "south", "http", "conf", "sec", "sq"], "size": ["i", "name", "e", "limit", "shape", "en", "start", "send", "end", "scale", "val", "time", "Size", "ize", "type", "f", "weight", "pos", "offset", "address", "fee", "zip", "enc", "sum", "unit", "code", "body", "rc", "c", "el", "small", "content", "capacity", "form", "speed", "min", "n", "length", "loc", "large", "grade", "clean", "z", "SIZE", "sec", "sn", "li", "empty", "l", "x", "ec", "count"], "len": ["lc", "span", "limit", "en", "conn", "fail", "sl", "val", "ln", "ld", "cl", "f", "pos", "lan", "ell", "full", "fin", "enc", "lin", "ls", "dy", "le", "body", "kn", "el", "lim", "num", "ann", "line", "seq", "min", "n", "length", "dl", "fl", "loc", "ll", "iter", " length", "lon", "z", "ler", "li", "lf", "lit", "l", "Len", "ni", "count"], "buf": ["bc", "str", "uf", "uc", "ref", "config", "result", "map", "cv", "null", "queue", "fb", "bb", "bytes", "bin", "fp", "cas", "buffer", "pos", "alloc", "exc", "cmd", "data", "context", "wb", "pool", "rc", "cb", "ctx", "byte", "b", "raw", "blocks", "seq", "fl", "ff", "fd", "src", "br", "loc", "bd", "Buffer", "batch", "buff", "bh", "array", "bag", "vec", "rb", "empty", "block", "cap"]}}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n", "idx": 22151, "substitutes": {"opts": ["ffts", " oppt", "cpts", "OPts", " optuts", "setuts", "popts", "opta", "operta", "hopts", "opttes", "argts", "opTS", "opte", "experts", "depta", "setted", "optt", "ppts", "ffuts", "appte", "appts", "depments", "optics", "popTS", "optops", "cpops", "setts", "argouts", " opouts", "opt", "ppets", "setops", "opps", "pputs", "oppt", "OPt", " optets", "hoptics", "ffets", " opttx", "arguts", "optted", "apputs", "verouts", "veruts", "deptes", "opets", " opt", "opertes", "optte", "sette", "fftx", " opTS", "OPTS", "cputs", "hopted", "depts", " opps", "popouts", "optuts", "optTS", "pptx", "optta", "opttics", "optts", "optps", "opments", "cptes", "opted", "experte", "verte", "oputs", "operts", "optpt", "optx", "opops", "OPps", "operments", "optments", "experted", "settes", "optouts", "opouts", "appted", " optts", "argte", "verts", "optes", "expertics", "hopte", "poppt"], "val": ["bc", "ana", "def", "ee", "fail", "part", "key", "pos", "fat", "msg", "data", "j", "vals", "var", "la", "live", "pl", "let", "pid", "rule", "VAL", "util", "doc", "v", "eval", "l", "str", "name", "ul", "ind", "valid", "g", "text", "cel", "split", "al", "pre", "vel", "enc", "unit", "pass", "aval", "vol", "lib", "alt", "li", "k", "vc", "lc", "sel", "serv", "ref", "err", "func", "bin", "ld", "f", "exec", "it", "p", "nil", "play", "pr", "el", "gen", "ver", "b", "call", "loc", "ll", "Val", "lit", "x", "sl", "il", "arg", "cond", "ol", "bl", "local", "pal", "rel", "label", "slot", "elt", "py", "cal", "rl", "fl", "len", "vert", "all", "pt", "base", "url", "value"]}}
{"project": "qemu", "commit_id": "5829b097204189c56dd1fb62c7f827360394bb39", "target": 0, "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd, colour;\n\n    int args, len;\n\n    int x, y, dx, dy, width, height;\n\n    struct vmsvga_cursor_definition_s cursor;\n\n    uint32_t cmd_start;\n\n\n\n    len = vmsvga_fifo_length(s);\n\n    while (len > 0) {\n\n        /* May need to go back to the start of the command if incomplete */\n\n        cmd_start = s->cmd->stop;\n\n\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n\n        case SVGA_CMD_UPDATE:\n\n        case SVGA_CMD_UPDATE_VERBOSE:\n\n            len -= 5;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n\n            break;\n\n\n\n        case SVGA_CMD_RECT_FILL:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            colour = vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_FILL_ACCEL\n\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_RECT_COPY:\n\n            len -= 7;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            dx = vmsvga_fifo_read(s);\n\n            dy = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_RECT_ACCEL\n\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_DEFINE_CURSOR:\n\n            len -= 8;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            cursor.id = vmsvga_fifo_read(s);\n\n            cursor.hot_x = vmsvga_fifo_read(s);\n\n            cursor.hot_y = vmsvga_fifo_read(s);\n\n            cursor.width = x = vmsvga_fifo_read(s);\n\n            cursor.height = y = vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            cursor.bpp = vmsvga_fifo_read(s);\n\n\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n\n            if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n\n                    goto badcmd;\n\n            }\n\n\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n#ifdef HW_MOUSE_ACCEL\n\n            vmsvga_cursor_define(s, &cursor);\n\n            break;\n\n#else\n\n            args = 0;\n\n            goto badcmd;\n\n#endif\n\n\n\n        /*\n\n         * Other commands that we at least know the number of arguments\n\n         * for so we can avoid FIFO desync if driver uses them illegally.\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n", "idx": 22155, "substitutes": {"s": ["ions", "i", "es", "ds", "sys", "r", "ssl", "os", "us", "js", "n", "S", "src", "ns", "details", "v", "conf", "http", "an", "request", "sb", "phys", "g", "ses", "d", "sets", "site", "services", "u", "state", "current", "o", "sg", "c", "self", "spec", "a", "set", "blocks", "sf", "multi", "native", "e", "sym", "result", "lines", "f", "t", "series", "new", "p", "si", "b", "service", "parts", "gs", "secondary", "sq", "status", "features", "your", "results", "m", "its", "storage", "strings", "sync", "is", "client", "settings", "session", "south", "server", "states"], "cmd": ["md", "grad", "name", "target", "cc", "def", "cd", "kind", "conn", "bind", "send", "config", "input", "cookie", "force", "mode", "shell", "cl", "pipe", "path", "Cmd", "nc", "msg", "cp", "init", "head", "method", "cf", "dict", "ctrl", "code", "id", "cli", "client", "header", "ctx", "module", "cb", "gen", "cfg", "dom", "c", "seq", "comm", "call", "history", "req", "command", "MD"], "colour": ["md", "feat", "col", "str", "i", "view", "grey", "our", "config", "event", "vt", "g", "blue", "text", "force", "color", "style", "rect", "dh", "f", "win", "gb", "t", "fg", "msg", "bg", "cycle", "dict", "rg", "thin", "dr", "c", "background", "ch", "b", "window", "draw", "vc", "ll", " colours", "v", "template", "qt", "fn", "h", "image", "quad", "l", "output", "action", "theme", "type"], "args": ["md", "Args", "col", "argument", "next", "err", "config", "rows", "val", "arg", "lines", "style", " flags", "bytes", "flags", "pos", "axis", " arg", "size", "data", "arr", "params", "fun", "body", "self", "frame", "num", "dim", "blocks", "parts", "min", "call", "fields", "partial", "debug", "doc", "all", "l", "count"], "len": ["lc", "span", "delay", "syn", "name", "limit", "en", "light", "fail", "yn", "err", "sl", "nn", "il", "non", "val", "part", "ln", "bin", "duration", "bl", "ld", "layer", "split", "pos", "lan", "win", "ell", "size", "fin", "list", "del", "label", "lin", "elt", "fun", "body", "ls", "el", "lim", "num", "dim", "ann", "pid", "line", "seq", "lvl", "rev", "dl", "n", "length", "fl", "lt", "ll", "lon", "lib", "alt", "nt", "li", "lf", "fn", "lang", "lit", "vec", "l", "Len", "ni", "count"], "x": [" i", "i", "name", "ix", "e", "xt", "input", "val", "xs", "xy", "pe", "d", "rx", "tx", "xx", "f", "pixel", "win", "pos", "t", "ex", "u", "m", "p", "fx", "work", "px", "c", "index", "X", "b", "w", "n", "xi", "ax", "wx", "z", "v", "h", "image", "l", " X"], "y": ["sky", "ya", "i", "hy", "start", "yd", "yn", "vy", "yy", "yer", "xy", "ay", "d", "ny", "ty", "yo", "yt", "f", "ey", "sy", "oy", "ys", "p", "year", "ye", "py", "iy", "ady", "wy", "b", "Y", "w", "ym", "cy", "zy", "n", "yl", "lon", "z", "yi", "ry", "h", "type"], "dx": ["md", "ix", "start", "ind", "xs", "xy", "d", "rx", "tx", "pad", "dh", "ds", "xx", "ex", "phy", "data", "dd", "fx", "del", "tick", "depth", "py", "px", "index", "ady", "distance", "dim", "w", "min", "length", "foo", "xi", "ax", "wx", "z", "eddy"], "dy": ["md", "delay", "yy", "yer", "xy", "d", "dh", "ds", "dn", "dj", "dir", "phy", "dd", "del", "gy", "depth", "py", "thin", "ady", "distance", "dim", "dq", "zy", "dl", "length", "foo", "den", "lon", "di", "z", "tail", "eddy"], "height": ["shape", "lat", "inches", "driver", "hold", "layout", "d", "margin", "duration", "ty", "img", "build", "weight", "png", "Height", "rank", " heights", "size", "hd", "quality", "hang", "gy", "rh", "depth", "crop", "thin", "density", "distance", "images", "dim", "pull", "window", "w", "huge", "length", "above", "gh", "th", "html", "angle", "z", "volume", "resolution", "h", "image", "bottom", "arrow", "ht", "padding"], "cursor": ["lcurses", "curation", "ccoder", "lcuration", "coder", "bcoder", "bcuration", "lcoder", "ccuration", "lcursor", "curses", "ccurses", "bcursor", "bcurses", "ccursor"], "cmd_start": ["md_end", "md_st", "cmd_st", "cmdnadd", "cmdnstart", "md_id", "cmd_end", "cmdnstarting", "cmdnend", "md_starting", "cmd_id", "md_add", "cmd_add", "cmd_starting", "md_start"]}}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 22167, "substitutes": {"st": ["td", "str", "sb", "est", "stack", "start", "ast", "ct", "sl", "std", "this", "ost", "kt", "St", "d", "style", "mt", "ld", "sth", "t", "rest", "data", "nd", "stat", "sd", "ste", "sts", "sc", "dt", "sw", "inst", "src", "ist", "sf", "test", "stage", "ST", "sec", "sp", "nt", "pt", "sta", "ss", "ft"], "buf": ["fa", "bc", "pb", "uf", "uc", "brace", "config", "result", "db", "cv", "fb", "queue", "func", "bytes", "pad", "temp", "cur", "fp", "xff", "buffer", "path", "f", "cas", "alloc", "exc", "cmd", "grab", "data", "cache", "cf", " buffer", "context", "wb", "cb", "ctx", "aux", "mem", "window", "b", "tmp", "seq", "ff", "desc", "fd", "src", "br", "bd", "append", "Buffer", "ab", "feed", "buff", "proc", "bf", "bag", "rb", "vec", "block", "fi", "output", "cap"], "end": ["begin", "output", "after", "port", "est", "e", "start", "en", "send", "event", "END", "result", "post", "stop", "pos", "path", "rest", "ad", "enc", "last", "id", "open", "ext", "c", "close", "index", "edge", "run", "enable", "ending", "End", "set", "enter", "desc", "len", "ender", "element", "append", "ent", "block", "offset", "api", "ended", "max", "format", "url", " End"], "sysfspath": ["sysfaspath", "syscaspaths", "sysfcSPeth", "sysfasport", "sysfSPaths", "sysfsSPATH", "sysfispaths", "sysfsSPath", "syscsport", "sysfbspth", "sysfsceth", "sysfSPp", "sysfsSPp", "syscspaths", "sysfpash", "sysfcSPath", "sysfscash", "sysfspeth", "sysfbspATH", "syscspath", "sysfpath", "sysfSPth", "sysfcSPth", "syscaspath", "sysfispATH", "sysfsspaths", "sysfpeth", "sysfpATH", "sysfaspaths", "syscasport", "sysfaspATH", "sysfspp", "sysfspATH", "sysfsSPaths", "sysfpaths", "sysfcspeth", "syscspad", "sysfspth", "syscspATH", "syscaspATH", "sysfpp", "sysfsspp", "sysfbspaths", "sysfsspATH", "sysfcspath", "sysfsport", "sysfispad", "sysfSPath", "sysfport", "sysfbspad", "syscaspad", "sysfispath", "sysfscth", "sysfbspath", "sysfbsport", "sysfaspth", "sysfspad", "sysfaspp", "sysfSPash", "sysfcspth", "sysfaspad", "sysfscath", "sysfcspash", "syscaspth", "sysfpth", "sysfsspath", "sysfSPATH", "syscspth", "sysfSPeth", "sysfcSPash", "sysfspaths", "sysfspash"], "ret": ["fail", "val", "part", "post", "temp", "Ret", "no", "fat", "r", "info", "bit", "cat", "out", "mem", "re", "iter", "nt", "feat", "resp", "format", "ft", "fin", "rets", "str", "valid", "db", "mt", "res", "opt", "code", "ext", "rt", "reply", "rev", "back", "alt", "expected", "reg", "xt", "ref", "gt", "pet", "result", "rf", "f", "fit", "arr", "addr", "success", "num", "RET", "fd", "req", "html", "bf", "orig", "lit", "wrap", "fun", "status", "obj", "std", "arg", "det", "art", "gd", "id", "match", "run", "flag", "sur", "len", "att", "base"], "max_segments": ["max_segment", "max_psegs", "max_SEgment", "max_SEgs", "max_psegments", "max_pregs", "max_SEgments", "max_segs", "max_pegments", "max_presections", "max_SEments", "max_pesections", "max_pregment", "max_pegements", "max_pregments", "max_sements", "max_psegment", "max_begment", "max_begments", "max_begements", "max_sesections", "max_pegment", "max_begs", "max_segements", "max_pegs", "max_SEgements", "max_psesections", "max_pements"]}}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201, "substitutes": {"s": ["status", "i", "sb", "e", "sym", "es", "sie", "fs", "g", "ses", "xs", "sis", "sets", "ops", "site", "ds", "services", "f", "sys", "t", "m", "args", "storage", "state", "ssl", "os", "p", "cs", "ts", "o", "sync", "is", "stats", "sa", "sg", "c", "js", "submit", "spec", "self", "settings", "sq", "si", "b", "service", "aws", "n", "S", "ns", "session", "side", "sf", "south", "rs", "gs", "ps", "http", "conf", "su", "ss", "states"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250, "substitutes": {}}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n", "idx": 22265, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "outs", "lb", "bis", "fs", "ses", "db", "uses", "fb", "bb", "bytes", "plugins", "as", "css", "ds", "bl", "bid", "utils", "bing", "s", "bas", "cache", "os", "bt", "vs", "cs", "us", "abi", "ls", "bi", "sync", "bps", "js", "b", "bits", "blocks", "ns", "BS", "iss", "ab", "ps", "rs", "ins", "banks", "cms", "gs", "bh", "bot", "rb", "server", "base", "ss", "gb"], "options": ["includes", "outs", "obj", "config", "option", "fs", "acl", "Options", "private", "ops", "plugins", "fp", "properties", "pos", "offs", "exec", "op", "info", "args", "cache", "opt", "os", "ts", "params", "stats", "settings", "opens", "aux", "bits", "objects", "details", "array", "files", "ips", "base"], "flags": ["status", "types", "ints", "fs", "prot", "features", "lines", "rules", "utf", "locks", "ops", "bytes", "properties", "nl", "info", "bit", "s", "args", "ils", "vals", "stats", "ants", "Flags", "settings", "opens", "lag", "reads", "bits", "flag", "FLAG", "parts", "fl", "mask", " Flags", "fields", "len", "ats", "files", "ips", "fun"], "errp": ["errcp", "rorP", "ErP", "rorps", "errps", "erpre", "err", " errcp", "Erp", " errpre", "Erps", "errP", "Err", " errps", "Ercp", "rorcp", "errpre", " errP", "Erpre", "erp", "errr", "erP", " errr", "rorp"], "client": ["io", "remote", "request", "public", "conn", "wrapper", "app", "config", "circ", "container", "private", "connection", "cm", "con", "handler", "plugin", "pc", "cl", "cell", "secure", "proxy", "ac", "cmd", "cp", "use", "socket", "cat", "cache", "ssl", "p", "ctrl", "q", "cli", "open", "c", "bird", "self", "cn", "ctx", "core", "session", "call", "co", "base", "parent", "util", "http", "ce", "manager", "resource", "server", "api", "Client", "url"], "ret": ["status", "str", "reg", "def", "conn", "ref", "fail", "valid", "pet", "hard", "obj", "result", "val", "arg", "ft", "det", "tr", "Ret", "mt", "art", "f", "buffer", "fit", "al", "bit", "res", "data", "cat", "final", "fin", "opt", "job", "id", "fun", "code", "success", "ext", "rc", "out", "num", "pass", "run", "RET", "let", "rt", " Ret", "mem", "sr", "flag", "reply", "rev", "re", "length", "len", "ait", "req", "back", "bf", "alt", "reset", "nt", "ry", "lit", "att", "base", "resp", "url", "rets"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22270, "substitutes": {"opaque": ["oacity", "OPaque", "opaques", "opec", "oaque", "octaque", " opac", "octec", "iopaques", " opaques", "opc", "opacle", " opc", "opacity", "OPec", "OPac", "octc", "opac", " opacity", "oacle", "oaques", "OPc", "iopacity", "iopacle", "octac", "iopaque", " opec", " opacle"], "addr": ["az", "config", "amp", "none", "part", "ord", "afi", "amd", "pad", "no", "pos", "address", "data", "ip", "ada", "src", "pointer", "route", "conn", "asm", "eth", "oa", "align", "node", "ac", "ad", "enc", "code", "mac", "od", "ext", "cb", "add", "rt", "dc", "alt", "offset", "md", "grad", "adr", "mode", "host", "layer", "ea", "cmp", "adder", "cmd", "dd", "arr", "ace", " address", "ptr", "loc", "x", "start", "hop", "arg", "kt", "bridge", "art", "args", "osi", "id", "dr", "nr", "seq", "len", "base", "url"], "retval": ["defvals", "altfail", "altvalid", "resultVAL", "altvals", "retvalue", "rtfail", "Retvalid", "RetVAL", "argval", "defsel", " retvalid", "RETVAL", "argeval", " retfail", "defeval", "argVAL", "retfail", "altval", "Retval", "rtval", "resultval", "defval", "retsel", "argvalue", "Retvals", "defvalid", "retvals", "retVAL", "altVAL", " reteval", "defVAL", "RETvalid", " retvalue", "rtvalid", "argvalid", " retv", "RETval", "RETvalue", "reteval", "altv", "argvals", "RETvals", " retvals", "retvalid", "resultvalid", "retv", "rtsel", "RETeval", " retVAL", "rtVAL", "rtv", "resultsel"], "d": ["md", "i", "grad", "e", "cd", "ded", "db", "vd", "dad", " dd", "pd", "dh", "ds", "ld", "gd", "f", " da", "t", "u", "m", "da", "ad", "nd", "data", "p", "id", "o", "od", "c", "dr", "sd", "dt", "b", "dc", "dm", "dl", "fd", "bd", "D", "di", "z", "dat", "l", "x"]}}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276, "substitutes": {"env": ["inv", "enh", "e", "en", "conn", "err", "obj", "eu", "config", "eur", "eni", "chal", "him", "db", "ench", "eng", "impl", "energy", "engine", "ea", "eve", "ef", "exec", "esi", "exc", "her", "enc", "vs", "code", "context", "Environment", "ext", "el", "loader", "profile", "esm", "viron", "enter", "er", "console", "iss", "v", "qt", "erv", "estate", "ev", "environment", "ec", "emb"], "tlb": ["ttlam", "atbm", "atlb", "llb", "tbm", "ttl", "atbl", " tbm", "ttlb", "tlr", "tbl", "llam", "trb", "ptlam", " tbl", " tlr", "llc", "ptrb", "tlc", " tlc", "ptbl", "ttbl", "ll", "atlr", "ttlc", "ttrb", "ptlb", "tlam", "tl", "Tlb", "Tbm", " trb", "Tlr", "Tbl", " tl", " tlam"], "tlbncfg": ["tlBNcf", "lbmconf", "tlbmconn", "tlbonconf", "slbanfg", "lbmconn", "tlbncf", "tlbenconfig", "slbnfg", "tlbencf", "lbmcf", "lbmconfig", "tlbnconf", "tlbinconfig", "tlbanfg", "tlboncfg", "slbnconn", "tlbonconn", "tlbnconfig", "lbncf", "lbnconn", "tlbencfg", "tlbinfg", "tlbincf", "tlbnfg", "lbmcfg", "tlfnconfig", "lbmfg", "lbncfg", "tlfncf", "tlbinconf", "tlbmconfig", "tlbmcf", "tlfnfg", "tlbenconn", "lbnconfig", "slbncfg", "slbanconn", "tlbnconn", "tlbincfg", "tlbancfg", "tlBNconfig", "tlfnconf", "tlbanconn", "tlfncfg", "tlbonfg", "slbanconf", "tlbanconf", "lbnfg", "tlBNconn", "slbancfg", "tlbmconf", "tlbmfg", "slbnconf", "tlbmcfg", "lbnconf", "tlBNcfg"], "tlbm_size": ["tlbon_scale", "tlbh_name", "tlBM_sum", "tlbh_size", "tlbh2rate", "tlBM_source", "tlbm_source", "tlbm__ize", "tlbh2type", "tlbh2name", "tlbm__size", "tlbon_ize", "tlbm_rate", "tlbm__mode", "tlbmxspeed", "tlbon_size", "tlbm_scale", "tlbh_rate", "tlbh_ize", "tlbm2size", "tlbn_size", "tlbh_speed", "tlbn_mode", "tlbm_speed", "tlbm2rate", "tlbon__scale", "tlbm2type", "tlbm_name", "tlbm__speed", "tlbon__size", "tlbm_mode", "tlbm_ize", "tlbm_sum", "tlbm2name", "tlbon__ize", "tlbh_type", "tlbm__scale", "tlbmxmode", "tlbn_speed", "tlbmxscale", "tlbh2size", "tlbm_type", "tlBM_size", "tlbmxsize", "tlbn_scale", "tlbon_speed", "tlbon__speed"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n", "idx": 22279, "substitutes": {"xfer": [" xcer", "xger", "axter", "pxfer", " xender", "byger", "viewfer", "wfar", "xference", " xger", "yxfar", "yporter", "yFER", " xFER", " xeder", "ylporter", " xfen", "xffen", "txfer", "fxter", "pxporter", "fxputer", "xffer", "xporter", "yaferred", "ylputer", "byference", "pxference", "wFER", "lexfer", "pxFER", "yxcer", "fxfer", "yaference", "Xputer", "xxfen", "fxacher", "lexference", "xfference", "xfen", "wcer", "xxf", "axformer", " xacher", "axfer", "txfen", "yafer", "rxporter", "byfen", "rxference", "plusener", "xxference", "xter", "lexferred", "yxFER", "helfen", "Xfer", "xender", "xformer", " xference", "xxporter", "axener", "plusference", "helporter", "rxfen", " xener", "xputer", "xff", "axference", "viewter", "xf", "axputer", "viewacher", "axporter", "xacher", "xcer", "txger", "axeder", "yaporter", "Xf", " xformer", "helfer", "pxf", " xfar", "xxputer", "rxfer", "yference", "Xporter", "plusformer", "wfer", "txference", "pxfen", "axender", "yfer", "lexporter", "xfar", "xferred", "xener", " xf", "yxfer", "helference", "yleder", "xFER", "byfer", "fxference", "pxferred", "ylfer", "viewference", "xxfer", " xter", "plusfer", "fxender", " xporter", " xputer", "xeder"], "port": ["target", "nat", "end", "ort", "config", "hop", " Port", "post", "tr", "host", "path", "proxy", "ip", "ports", "mac", "PORT", "pass", "ported", " sport", "gate", "test", " transport", "Port", "parent", "proc", "pointer", "porter"], "ep": [" esp", "phase", "e", "ap", " Ep", "esp", " ip", "fp", "pipe", "ef", "dep", "ream", "op", "eb", "cp", "EP", "pp", "ip", "p", "point", "ek", "ext", "el", " p", "mp", " e", "gp", "xp", "seq", "channel", "yp", "req", "ew", "eps", " epoch", "sp", "ev", " EP", "dp", "ec", "Ep"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n", "idx": 22280, "substitutes": {"acb": ["acp", "acf", "acsl", "acl", "akf", "ascbr", "ascb", "acbr", "akbr", " acbr", "acsp", "akp", "ascp", " acl", "akb", "Acbe", "Acb", "acsb", "Acl", "Acp", "acsbe", " acf", "ascf", "acbe", " acbe", " acp"], "elem": ["pelements", "beleg", "belem", "pelement", "eject", "elev", "aelement", "ebm", "oelements", "aelem", " elev", "elements", "oelee", " elee", "kelement", "oelete", " element", "elee", "eeade", "kelements", "belement", "peject", "Elev", "peade", "pelem", " ebm", "keject", "Elem", "elam", "aeleg", "eelam", "eelev", "belements", "eelete", "kelem", " elete", "eleg", "eeject", " elam", "eelements", "Elee", "pebm", " eade", "aelements", "element", "oelem", "Elements", "eelee", "eebm", "eeleg", "eelement", "eelem", "Elete", " elements", "pelam", "elete", "pelete", "eade"], "pool": ["rol", "platform", "col", "place", "port", "row", "table", "serv", "object", "conn", "fail", "wrapper", "ref", "thread", "ping", "lane", "loop", "coll", "wa", "container", "guard", "connection", "queue", "pm", "file", "widget", "pc", "host", "cl", "poll", "pg", "proxy", "rain", "box", "full", "cache", "round", "gro", "lock", "list", "job", "p", "prefix", "work", "que", "timeout", "client", "module", "pl", "hole", "plus", "role", "worker", "Pool", "call", "iam", "flow", "four", "page", "batch", "sem", "parent", "lib", "group", "clock", "block", "server", "wl", "allow", "pa", "lam"]}}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 22300, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "5952b8da0b7f65dfa23991e71737e0abdaeb339c", "target": 1, "func": "static int seek_test(const char *input_filename, const char *start, const char *end)\n\n{\n\n    AVCodec *codec = NULL;\n\n    AVCodecContext *ctx= NULL;\n\n    AVCodecParameters *origin_par = NULL;\n\n    AVFrame *fr = NULL;\n\n    AVFormatContext *fmt_ctx = NULL;\n\n    int video_stream;\n\n    int result;\n\n    int i, j;\n\n    long int start_ts, end_ts;\n\n\n\n    size_of_array = 0;\n\n    number_of_elements = 0;\n\n    crc_array = pts_array = NULL;\n\n\n\n    result = avformat_open_input(&fmt_ctx, input_filename, NULL, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't open file\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avformat_find_stream_info(fmt_ctx, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't get stream info\\n\");\n\n        return result;\n\n    }\n\n\n\n    start_ts = read_seek_range(start);\n\n    end_ts = read_seek_range(end);\n\n    if ((start_ts < 0) || (end_ts < 0))\n\n        return -1;\n\n\n\n    //TODO: add ability to work with audio format\n\n    video_stream = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n\n    if (video_stream < 0) {\n\n      av_log(NULL, AV_LOG_ERROR, \"Can't find video stream in input file\\n\");\n\n      return -1;\n\n    }\n\n\n\n    origin_par = fmt_ctx->streams[video_stream]->codecpar;\n\n\n\n    codec = avcodec_find_decoder(origin_par->codec_id);\n\n    if (!codec) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't find decoder\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx = avcodec_alloc_context3(codec);\n\n    if (!ctx) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate decoder context\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = avcodec_parameters_to_context(ctx, origin_par);\n\n    if (result) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't copy decoder context\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avcodec_open2(ctx, codec, NULL);\n\n    if (result < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Can't open decoder\\n\");\n\n        return result;\n\n    }\n\n\n\n    fr = av_frame_alloc();\n\n    if (!fr) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate frame\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);\n\n    if (result != 0)\n\n        return -1;\n\n\n\n    for (i = start_ts; i < end_ts; i += 100) {\n\n        for (j = i + 100; j < end_ts; j += 100)\n\n        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 0);\n\n        if (result != 0)\n\n            return -1;\n\n    }\n\n\n\n    av_freep(&crc_array);\n\n    av_freep(&pts_array);\n\n    av_frame_free(&fr);\n\n    avcodec_close(ctx);\n\n    avformat_close_input(&fmt_ctx);\n\n    avcodec_free_context(&ctx);\n\n    return 0;\n\n}\n", "idx": 22316, "substitutes": {"input_filename": ["input64filename", "inputlockdocument", "input64location", "inputlockfile", "input_file", " input_file", "inputingfilename", "input_document", "image_filename", "image_file", " input_location", "inputlockfilename", "inputingfile", "input_location", " input_document", "input64file", "inputlocklocation", "input64document", "inputingdocument", "image_document"], "start": ["name", "starting", "send", "origin", "time", "stop", "before", "cur", "get", "art", "pos", "pre", "info", "use", "address", "size", "init", "play", "id", "mid", "scan", "load", "open", "source", "add", "in", "create", "set", "first", "read", "length", "range", "from", "Start", "offset", "x"], "end": ["after", "view", "est", "limit", "en", "send", "END", "time", "stop", "r", "address", "size", "nd", "p", "last", "id", "index", "edge", "ending", "in", "set", "End", "length", "len", "append", "vert", "range", "offset", "ended", "max"], "codec": ["codef", "codformat", "codeformat", "predesc", "metesc", "codeesc", " codformat", "preduc", "codEC", "code\n", "odformat", "indocol", " cod\n", "codocol", "odEC", " codesc", "Codec", "codiac", " codiac", "cod\n", "odeca", "odesc", "odec", "predocol", "prediac", "pedesc", " coduc", "Codef", "coderc", " coderc", "inderc", "CodEC", "Codeca", "pedEC", "pedec", "codeca", "metEC", "predec", " codocol", "codesc", "indiac", "Codesc", "codeec", "metec", "pedef", "od\n", "induc", "meteca", "indec", "prederc", "coduc", "indesc", "codeEC", "codeef"], "ctx": ["conv", "lc", "bc", "fc", "grad", "txt", "cam", "wcs", "cc", "uc", "conn", "obj", "jp", "config", "coll", "pkg", "cv", "chan", "cm", "rx", "crit", "tx", "ca", "pc", "anc", "fp", "cas", "cmp", "exec", "cmd", "cp", "mc", "xc", "cf", "ctrl", "cs", "context", "np", "cli", "sync", "mac", "client", "c", "cb", "cn", " context", "ch", "cpp", "auc", "cr", "qa", "src", "fw", "loc", "cca", "parent", "lib", "hw", "kw", "fn", "voc", "scope", "concept", "cu", "vc"], "origin_par": ["origin_param", "Origin_p", "origin_adr", "originityadr", "Origin_comp", "origin_dep", "origin_p", "Origin_adr", "origin_comp", "origin__rec", " origin_rec", " origin_param", "origin_pos", "Origin_pc", "originityarc", "originitydep", "origin__par", "origin_arc", " origin_dep", "origin_rec", "origin_pc", "originitycomp", "Origin_par", " origin_comp", "origin__comp", " origin_arc", "originitypar", "originpydep", "originpyarc", "originitypos", "Origin_pos", "originpypar", "origin__param", "originpycomp"], "fr": ["iframe", "err", "jp", "fs", "coll", "progress", "cv", "FR", "tr", "feature", "img", "fps", "res", "frac", "fx", "play", "arr", "frame", "rt", "vr", "fm", " frame", "ff", "req", "mult", "fram", "vec", "fi", "fin"], "fmt_ctx": ["fMT_tx", "fmt_cf", "fmt_context", "fmt_comp", "frt_cn", "fMT_loc", "frt_cf", "fmtjconfig", "frt_ctx", "fmt2loc", "fmt_tx", "fmt_cp", "fmt_cn", "fMT_context", "filt_ctx", "frt_comp", "filt_context", "fmt2ctx", "fmt_ci", "fmtjcontext", "fmtjctx", "frt_tx", "filt_config", "fmt2tx", "filt_ci", "fmt_loc", "frt_context", "fmt_config", "fmt2context", "fmtjci", "filt_cp", "fMT_ctx"], "video_stream": ["origin_stream", "video_stick", "picture_url", "origin_group", "videoadtag", "picturekstream", "media_thread", "video_tag", "videokurl", "videoadcoll", "videoalsrc", "videoalgroup", "originalgroup", "media_string", "videokstream", " video_tag", "picture_rec", "videoflowstream", "video_form", "origin_src", "picture_channel", "video_group", "video_thread", "video_channel", "video_rec", "videoadform", " video_form", "video_coll", "videoflowstick", "videokrec", "media_form", "video_url", "video_src", "media_stream", "originalstream", "videoingrec", "videoflowsrc", "picture_stream", " video_coll", "picturekurl", "videoingstream", "videoingurl", "videokchannel", "originalstick", "videoingchannel", "origin_stick", "video_string", "videoadstream", "picturekchannel", "videoalstream", "videoalstick", "picturekrec", "originalsrc", "videoflowgroup"], "result": ["package", "row", "next", "event", "message", "duration", "df", "order", "catch", "info", "acc", "use", "data", "method", "work", "Result", "date", "br", "test", "gap", "instance", "member", "request", "response", "valid", "coll", "true", "term", "res", "current", "successful", "rc", "pass", "first", "child", "try", "back", "sum", "after", "err", "function", "weight", "cmp", "full", "new", "ret", "score", "compl", "number", "cup", "answer", "comment", "success", "ver", "sr", "error", "length", "mark", "total", "page", "resource", "count", "status", "found", "feature", "cur", "product", "results", "done", "reason", "rate", "final", "diff", "runner", "dict", "mer", "search", "match", "source", "counter", "math", "session", "mask", "grade", "mr", "root", "range", "report", "record", "value"], "i": ["e", "d", "I", "f", "ci", "y", "u", "it", "p", "id", "o", "c", "index", "a", "ii", "b", "in", "n", "v", "z", "li", "l", "x", "k"], "j": ["step", "e", "obj", "jp", "adj", "f", "pos", "op", "section", "r", "t", "m", "ok", "it", "p", "o", "js", "aj", "J", "ii", "b", "n", "range", "v", "z", "k", "jump"], "start_ts": ["writeThetypes", "startThets", " start_dt", "startNtimes", "writeTheacks", "start_types", "write_tz", " start_tes", " start_times", "start_tes", "end_times", "startIPtypes", "startTheacks", "startThetz", "startNTS", "start_dt", "writeThetz", "end_TS", "start_times", "startIPacks", "write_ts", "end_points", "write_types", "startNts", "write_acks", "startNpoints", "start_points", "start_acks", "start_tz", "startIPts", "startThetypes", "startIPtz", "writeThets", "start_TS"], "end_ts": ["end_ms", "end\u00b7ets", "end\u00b7ms", "end_tz", "end\u00b7ts", "start_tt", "end_times", "start_offs", "start_times", "start_ms", "end\u00b7times", "end36ts", "end_Ts", "end_tt", "end36tt", "end_ets", "start_Ts", "start_tz", "end_offs", "end36times", "start_ets", "end36Ts"]}}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330, "substitutes": {"bus": ["io", "bc", "port", "ux", "fi", "usb", "config", "drive", "driver", "board", "controller", "mount", "loop", "db", "connection", "plugin", "Bus", "bridge", "host", "product", "engine", "device", "proxy", "bug", "cache", "cat", "socket", "lock", "serial", "us", "sync", "plug", "service", "hub", "BUS", "feed", "boot", "lib", "http", "user", "base"], "cmd": ["md", "name", "grad", "class", "kind", "def", "cd", "cc", "conn", "bind", "send", "config", "pkg", "ctr", "cookie", "mode", "ack", "cm", "func", "handler", "plugin", "host", "cl", "device", "node", "cmp", "path", "ctrl", "Cmd", "msg", "head", "nd", "mid", "method", "id", "prefix", "code", "addr", "count", "mac", "fun", "buf", "content", "header", "ctx", "module", "cb", "client", "cfg", "c", "num", "dc", "seq", "magic", "comm", "call", "callback", "cli", "req", "domain", "MD", "proc", "cod", "command", "type"], "address": ["route", "package", "target", "attribute", "shape", "end", "object", "config", "event", "eni", "ress", "message", "connection", "uri", "handler", "host", "device", "path", "order", "slave", "size", "component", "ip", "ace", "number", "point", "addr", "attr", "content", "header", "network", "index", "source", "Address", "service", "location", "alias", "date", "channel", "enter", "error", "length", "email", "each", "grade", "array", "pointer", "resource", "image", "position", "server", "offset", "inet", "output", "command", "interface"], "len": ["lc", "delay", "limit", "un", "en", "end", "conn", "ind", "sl", "nn", "non", "val", "ln", "ld", "offset", "f", "pos", "lan", "split", "size", "fin", "lock", "list", "del", "lin", "fun", "addr", "body", "dy", "gen", "el", "lim", "num", "pl", "dim", "mem", "line", "seq", "lvl", "dl", "n", "length", "fl", "min", "loc", "ll", "partial", "lon", "alt", "nt", "li", "fn", "lf", "block", "all", "l", "base", "Len", "url", "count"], "data": ["delay", "after", "str", "name", "start", "def", "response", "config", "result", "input", "message", "Data", "connection", "queue", "d", "uri", "bytes", "pad", "buffer", "msg", "size", "ad", "cache", "new", "id", "addr", "body", "load", "buf", "content", "memory", "byte", "a", "DATA", "reply", "channel", "length", "reader", "di", "alpha", "dat", "block", "command", "format"], "i2c_bus": ["i2cu__usb", "i2c2bus", "i2c_plugin", "i2ct_proc", "i2ctADblock", "i2xc_fail", "i2cin_die", "i2c_Bus", "i2cADbus", "i2xc_serial", "i2cu__loop", "i2ce_bus", "i2cPubplugin", "i2vcAMspace", "i2f_usb", "i2cJbus", "i2ch_bit", "i2chJplugin", "i2f_bus", "i2xc_root", "i2c6boot", "i2cin_block", "i2chJboot", "i2c_die", "i2cADblock", "i2c_driver", "i2c__usb", "i2c_root", "i2cAMcontroller", "i2cPubbus", "i2vc_space", "i2c6space", "i2ctADbus", "i2vc_controller", "i2c_ux", "i2cin_bus", "i2cu__bus", "i2c_bis", "i2vc_boot", "i2c_usb", "i2c_serial", "i2c6controller", "i2cADux", "i2ch_plugin", "i2c_bit", "i2c_use", "i2c_proc", "i2c__loop", "i2cPubbit", "i2ch_boot", "i2c_space", "i2ct_ux", "i2cin_bis", "i2vcAMbus", "i2c_fail", "i2c_block", "i2c6bus", "i2vcAMcontroller", "i2f_bridge", "i2ce_controller", "i2cAMboot", "i2cJboot", "i2cJbit", "i2f_Bus", "i2cADproc", "i2cu__boot", "i2cJplugin", "i2ctADux", "i2ct_bus", "i2ct_block", "i2cPubboot", "i2cu_loop", "i2c_loop", "i2c__bridge", "i2chJbit", "i2cAMbus", "i2cu_bus", "i2c2bridge", "i2ce_use", "i2xc_bus", "i2c__bus", "i2vcAMboot", "i2c2usb", "i2cAMspace", "i2ch_bus", "i2c2Bus", "i2c__Bus", "i2c_boot", "i2cu_usb", "i2c_controller", "i2ctADproc", "i2chJbus", "i2cu_boot", "i2c__boot", "i2ce_driver", "i2vc_bus", "i2c_bridge"], "i": ["io", "udi", "ix", "e", "qi", "ri", "ind", "eni", "ui", "val", "pi", "gi", "d", "uri", "ti", "I", "f", "buffer", "ci", "info", "phi", "m", "s", "ini", "j", "oi", "ip", "p", "abi", "id", "addr", "is", "mi", "c", "index", "si", "a", "ii", "b", "n", "iu", "ai", "xi", "di", "v", "multi", "array", "li", "block", "l", "fi", "ni", "type"]}}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 22361, "substitutes": {"c": ["lc", "fc", "e", "cc", "uc", "ct", "config", "g", "cv", "cm", "d", "con", "ca", "cur", "cu", "f", "ci", "ac", "u", "m", "s", "cache", "oc", "p", "cs", "xc", "enc", "ctrl", "cf", "context", "client", "ctx", "cn", "icc", "b", "dc", "w", "cy", "n", "C", "co", "v", "ce", "cit", "h", "l", "ec", "vc"], "lumFilter": ["LumbFile", "lumbFilter", "lumFile", "LumFile", "LumbFil", "Lumbfilter", "LumFil", "lumfilter", "lufFilter", "LumFilter", "lumFil", "lacFile", "lumbfilter", "lufFil", "lumbFil", "lacfilter", "lufFile", "lacFil", "luffilter", "LumbFilter", "lacFilter", "Lumfilter", "lumbFile"], "lumSrc": ["lumAsvc", "lumSysnc", "lumaAsnc", "lumVSvc", "lumaSnc", "lumVSnc", "lumSRC", "lumAsnc", "lumAsrc", "lumSysvc", "lumVSRC", "lumaSvc", "lumSnc", "lumaAsvc", "lumAsRC", "lumSvc", "lumaSrc", "lumaSRC", "lumSysRC", "lumSysrc", "lumVSrc", "lumaAsRC", "lumaAsrc"], "lumFilterSize": ["lmpfilterC", "lumControlExport", "lumFilterC", "lumfilterExport", "lumFilterExport", "lmpfilterExport", "lumControlSize", "lumfilterSize", "lumFileC", "lmpFilterExport", "lumFileExport", "lumFileSize", "lmpfilterSize", "lmpFilterSize", "lumControlC", "lumfilterC", "lmpFilterC"], "chrFilter": ["chrfFilter", "shrfFilter", "chmSource", "chmFl", "chbFl", "chmConfig", "chrfSource", "shrFilter", "chrfConfig", "chrConfig", "shrSource", "shrfFl", "chbFilter", "chmFilter", "shrfConfig", "chrfFl", "chrSource", "chbSource", "shrConfig", "chbConfig", "shrFl", "shrfSource", "chrFl"], "chrUSrc": ["chrSSsrc", "chrUSSec", "chrSSrc", "chrUSec", "chrfUSrc", "chrSSrs", "chrfSSrc", "chrUSSrs", "chrUSSsrc", "chrfUSrs", "chrUSSrc", "chrfUSec", "chrUSrs", "chrVSsrc", "chrfUSsrc", "chrfSSrs", "chrfSSec", "chrVSrs", "chrSSec", "chrUSsrc", "chrVSec", "chrfSSsrc"], "chrVSrc": ["chrbVsrc", "chrVSRC", "chrVsRC", "chrbVSrc", "chrRSsrc", "chrbVssrc", "chrSdc", "chrSrc", "chrVsdc", "chrbVSdc", "chrVsrc", "chrbVsRC", "chrRSrc", "chrVSdc", "chrRSRC", "chrSsrc", "chrbVsdc", "chrVSsrc", "chrbVSsrc", "chrSRC", "chrRSdc", "chrbVSRC", "chrVssrc"], "chrFilterSize": ["chrbFilterLength", "chrfilterLength", "chrSortSIZE", "chrFiltersize", "chrbSortLength", "chrbSortSIZE", "chrSortsize", "chrFilterSIZE", "chrSortSize", "chrfilterSIZE", "chrbFilterSIZE", "chrbFiltersize", "chrfiltersize", "chrfilterSize", "chrFilterLength", "chrbSortsize", "chrSortLength", "chrbSortSize", "chrbFilterSize"], "alpSrc": ["alpSSdr", "alpSSrc", "alpAssrc", "alcSdr", "alcAsdr", "alpSdr", "alcSsrc", "alpAsRC", "alpAsdr", "alpSSRC", "alcAsRC", "alcSrc", "alpSSsrc", "alpSRC", "alcAsrc", "alpAsrc", "alcSRC", "alcAssrc", "alpSsrc"], "dest": ["md", "route", "transform", "name", "txt", "target", "shape", "uc", "send", "config", "mode", "de", "d", "home", "img", "cur", "dep", "dist", "path", "done", "cont", "dir", "coord", "dev", "data", "diff", "wb", "shift", "destroy", "cb", "Dest", "source", "match", "die", "sc", "beta", "dc", "tmp", "desc", "src", "loc", "comb", "dat", "ie"], "uDest": ["vSc", "uDir", "vDir", "uRest", "URest", "udest", "cComb", "UDest", "aOrig", " uDir", "adest", "UDir", "aRest", "aComb", " uSc", "fComb", " udest", "cDest", "vdest", "USc", "uOrig", "vRest", " uRest", "uSc", "fDest", "uComb", "cOrig", "aDir", "fOrig"], "vDest": ["vDist", "wDesc", "wOrig", "wDes", " vDesc", "wDist", "bDesc", " vDist", "vOrig", "bDes", "vExt", "fExt", "wExt", " vOrig", "fDesc", "bDest", "fDist", " vDes", " vExt", "vDesc", "bOrig", "wDest", "fDest", "vDes"], "aDest": ["sDesc", "vaCor", "bSource", "AOrig", " aDep", "vaPriv", " aForce", "aDist", "baDest", "APriv", "bDep", "aOrig", "ADep", "sPriv", " aOrig", "aSource", " aDesc", " aPriv", "bDist", "baPriv", "sCor", "aCor", "ADest", " aSource", "aForce", "ADist", "vaDesc", " aCor", "ASource", "sDest", " aDist", "bDest", "vaDest", "aDep", "AForce", "baOrig", "aDesc", "aPriv", "baForce"], "dstW": ["DscWS", "dSTH", "DscH", "dstageW", "Dstw", "dscL", " dstD", "dstM", "drcw", "drcMW", "dscD", "dstMW", "drcM", "DscW", " drcD", "dSTD", "DrcW", "dSTW", "DrcMW", "DstW", "dscM", "dstL", "dstWS", "dscWS", "dmtH", "dstageM", "drcW", "drcD", "dscH", "DstM", "DstH", "drcH", "dstw", "dstH", "DrcH", "dmtW", "dstageWS", " drcW", "dmtMW", "dstageH", "dscW", "drcL", "DscM", "dmtw", "DstMW", "dstD", " dstL", "dSTw", "dSTMW", " dstH", "dSTL", "Drcw", "DstWS", " drcH", "drcWS", " drcL"], "chrDstW": ["chrDSTWS", "chrLstM", "chrDscH", "chrIdstVW", "chrDftW", "chrDrcH", "chrDSTVW", "chrDstVW", "chrDstrU", "chrDrcW", "chrNSTW", "chrLSTW", "chrIdstW", "chrNstW", "chrDstL", "chrLstH", "chrDstU", "chrNstU", "chrDrcG", "chrDftG", "chrDSTG", "chrIdstG", "chrDSTU", "chrDrcM", "chrIdftW", "chrDscW", "chrDstM", "chrDSTF", "chrDstWS", "chrDstrW", "chrDSTH", "chrIdftG", "chrLstL", "chrDstF", "chrDftVW", "chrNSTWS", "chrDntWS", "chrDntU", "chrDSTL", "chrNstWS", "chrDntF", "chrDstrF", "chrIdftH", "chrLSTH", "chrDrcVW", "chrNSTF", "chrDftH", "chrDSTW", "chrDntW", "chrIdstH", "chrDscL", "chrDrcL", "chrLSTL", "chrDstH", "chrNSTU", "chrLSTM", "chrDscM", "chrIdftVW", "chrDstG", "chrLstW", "chrDSTM", "chrDstrWS", "chrNstF"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 22364, "substitutes": {"errp": ["derps", "efpe", "errpe", "erps", "errps", "errlp", "efps", "erp", "erpe", "efp", "eflp", "derlp", "erlp", "derpe", "derp"], "info": ["i", "area", "def", "off", "app", "config", "event", "part", "post", "key", "extra", "afi", "ok", "bug", "data", "os", "link", "thin", "qa", "fw", "slice", "di", "http", "conf", "image", "fi", "type", "name", "txt", "end", "linux", "gi", "style", "op", "php", "state", "opt", "current", "q", "ext", "tf", "options", "iso", "li", "sum", "ami", "Info", "menu", "fs", "ui", "result", "meta", "by", "f", "information", "it", "full", "init", "zip", "new", "inf", "job", "comment", "success", "num", "check", "si", "admin", "available", "error", "ignore", "z", "user", "manager", "note", "orig", "api", "fo", "start", "obj", "INFO", "json", "home", "follow", "diff", "id", "help", "inner", "is", "py", "index", "source", "ii", "now", "hi", "update", "base"], "s": ["ions", "i", "es", "xs", "ds", "sys", "y", "data", "ssl", "os", "ts", "cs", "params", "stats", "S", "ns", "details", "rs", "v", "ss", "sb", "g", "ses", "sets", "site", "as", "services", "res", "state", "o", "sg", "c", "spec", "a", "set", "sf", "su", "e", "sym", "rates", "f", "t", "new", "p", "si", "b", "service", "parts", "sup", "ps", "gs", "sec", "secondary", "sq", "status", "sl", "ops", "m", "args", "its", "storage", "ls", "sync", "is", "sa", "settings", "source", "se", "session", "comments", "states"]}}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365, "substitutes": {"bs": ["obs", "bc", "pb", "ras", "ums", "bos", "lbs", "outs", "lb", "bis", "ba", "fs", "ses", "ubs", "als", "bb", "bytes", "ks", "bid", "ds", "bes", "css", "ros", "bas", "os", "vs", "cs", "asts", "abi", "us", "ls", "js", "cb", "bits", "b", "blocks", "ns", "BS", "iss", "ab", "ins", "bh", "ec", "rb", "base", "ss", "las"], "bitnum": ["bitnom", "blockum", "BITnum", "BITnumber", "intnumber", "bytenom", "bitum", "intnum", "bitNum", "byteNum", " bitnom", "Bitum", "blockNum", "Bitnum", " bitno", "bitsnumber", "bitsnum", "bitno", "BITnom", "bytenum", " bitnumber", " bitum", " bitNum", "Bitnumber", "intno", "blocknum", "bytenumber", "bitsno", "bitnumber", "BitNum", "blocknumber", "BITNum"], "bitmap": ["nullmap", "nullflow", "bitfill", "byteMap", "nullmask", "bytemap", "bytearray", "bmaps", "bfill", "tagflow", "bytemaps", "blockMap", "bitmaps", "daycast", "Bitblock", "Bitmap", "bitflow", "bitsdata", "tagview", "bootlock", "daymap", "blockcast", "bootcast", "binMap", "bootmask", "Bitmask", " bitmask", "nullview", "bincap", "blockblock", "blocklock", " bitfill", "bmask", "bitdata", "bitcache", "bitlock", "tagmap", "binfill", "blockcache", " bitblock", "bitMap", " bitarray", "blockmask", "bitarray", "binflow", "bitscache", "Bitdata", " bitcap", "bincache", "bitcast", "bitblock", "bitcap", "daymask", "bitsmask", "Bitmaps", "tagmask", "BitMap", "bmap", "bitmask", "bitsmap", "binmaps", "binview", "bitview", " bitmaps", "bindata", "daylock", "blockmap", "bitsmaps", " bitMap", "bootmap", "binarray", "bitscap", "binmap", "blockmaps", "binmask"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int voc_probe(AVProbeData *p)\n\n{\n\n    int version, check;\n\n\n\n    if (p->buf_size < 26)\n\n        return 0;\n\n    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n\n        return 0;\n\n    version = p->buf[22] | (p->buf[23] << 8);\n\n    check = p->buf[24] | (p->buf[25] << 8);\n\n    if (~version + 0x1234 != check)\n\n        return 10;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 22379, "substitutes": {"p": ["pb", "i", "e", "ap", "app", "jp", "lp", "progress", "post", "s", "d", "P", "cop", "bp", "pc", "l", "img", "fp", "f", "per", "t", "exec", "u", "op", "m", "cp", "pre", "data", "j", "tp", "it", "pp", "patch", "ip", "at", "o", "np", "c", "wp", "gp", "a", "b", "n", "br", "v", "up", "http", "sp", "vp", "pi", "api", "k", "pa"], "version": ["ception", "name", "versions", "scale", "option", "result", "val", "feature", "build", "f", "release", "ion", "info", "data", "bug", "patch", "number", "id", "code", "depth", "ant", "fix", "c", "index", "num", "byte", "ver", "Version", "value", "ison", "date", "core", "error", "n", "length", "test", "update", "vert", "VERSION", "v", "vision", "block", "position", "server", "type"], "check": ["view", "start", "print", "query", "look", "end", "valid", "CHECK", "val", "force", "key", "info", "ok", "Check", "bug", "patch", "lock", "play", "id", "work", "code", "sync", "load", "comment", "fix", "checked", "c", "index", "match", "add", "ver", "pull", "set", "read", "call", "test", "clean", "update", "feed", "wait", "ck", "block", "max"]}}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381, "substitutes": {"f": ["fa", "fc", "i", "uf", "e", "fac", "fs", "g", "fb", "file", "d", "rf", "fp", "df", "t", "r", "m", "s", "j", "xf", "p", "fx", "cf", "inf", "c", "fe", "self", "fr", "tf", "form", "b", "fm", "fed", "ff", "fd", "F", "fw", "sf", "feed", "fen", "bf", "v", "conf", "lf", "fn", "h", "l", "fi", "fo", "elf"], "opaque": ["iopacity", "Ophole", "opacity", "iopaque", "iophole", "opshole", "Opque", "opsaque", "opsque", "ophole", "opsacity", "Opacity", "iopque", "Opaque", "opque"], "version_id": ["versionCvid", "version1num", "versionEname", "versionEid", "versionEkey", "versionPid", "versionedline", "version_ID", " versionekey", "versionervalue", "version_bit", "stage_line", "versionFvalue", "stageedid", "version_vid", "versioneid", "stageedvid", " versioneid", "version1version", "versioneedesc", "version1oid", "versionedid", "versionCdesc", "versionekey", " version_name", "version_aid", "versioneeid", "versioneeline", "versionerids", "stage_id", "servereroid", "version1id", "version_line", "versionCid", "stage_vid", "server_id", " version_ids", " version_ID", "versionCline", "version_index", "version_ids", "version_desc", "versionFid", "language_value", "version_version", "language_id", "stageedline", "versioneroid", "versionerversion", "language_ids", " version_index", "server_version", "serverernum", "versioneraid", "stageeddesc", "servererversion", "server_oid", "versionedvid", "version_key", "versionFids", " versionebit", "versionPindex", "versionernum", "servererid", "versionFaid", "versionPID", " version_bit", " versionename", "stage_desc", "version_num", "server_num", "versioneevid", "versionerid", "versionebit", "versioneddesc", "language_aid", "versionPids", "version_oid", "version_name", " version_key", "version_value", "versionEbit", "versionename"], "addr": ["config", "amp", "acl", "part", "ord", "afi", "amd", "pad", "buffer", "pos", "r", "address", "data", "ip", "prefix", "url", "alias", "src", "image", "attr", "ast", "asm", "ack", "oa", "height", "bb", "align", "node", "nl", "coord", "ac", "ad", "state", "opt", "fx", "code", "od", "mac", "buf", "filename", "ext", "arch", "rc", "rt", "back", "alt", "offset", "md", "ref", "adr", "mode", "rf", "layer", "cmp", "cmd", "size", "arr", "act", "ace", "p", "b", "ptr", " address", "fd", "inst", "loc", "x", "port", "start", "hop", "args", "dr", "index", "frame", "xp", "Address", "seq", "mask", "rss", "base", "padding"], "flags": ["config", "acl", "allows", "utf", "afi", "properties", "fg", "ils", "vals", "stats", "lag", "styles", "forces", "details", "fields", "ins", "rs", "ips", "format", "linux", "eth", "services", "bugs", "nl", "ids", "fps", "s", "fx", "ports", "Flags", "bits", "FLAG", "blocks", "requires", "utils", "options", "files", "offset", "tests", "fs", "rules", "ffff", "bytes", "heads", "xff", "ants", " bits", "groups", "fd", " Flags", "alls", "lf", "mods", "count", "versions", "types", "ints", "features", "locks", "ops", "plugins", "planes", "args", "strings", "vs", "settings", "rights", "frames", "reads", "flag", "seq", "fl", "mask", "links"], "id": ["ident", "like", "i", "name", "str", "start", "def", "end", "ref", "kid", "map", "part", "val", "key", "aid", "d", "uri", "pad", "bid", "no", "offset", "split", "path", "info", "ids", "bit", "Id", "address", "data", "ad", "stat", "head", "size", "lock", "link", "ip", "p", "count", "code", "body", "gen", "tag", "num", "frame", "oid", "ID", "a", "pid", "in", "line", "hash", "seq", "root", "r", "sid", "h", "image", "uid", "base", "url", "type"], "length": ["row", "name", "limit", "shape", "en", "end", "rows", "Length", "val", "part", "key", "message", "style", "l", "build", "buffer", "path", "split", "section", "info", "padding", "address", "size", "data", "sequence", "full", "lock", "ip", "link", "sum", "count", "number", "code", "load", "label", "index", "pl", "match", "capacity", "value", "line", "seq", "n", "ength", "loc", "slice", "partial", "up", "position", "offset", "base", "url", "type"], "block": ["bc", "inv", "row", "name", "limit", "prev", "def", "blocking", "object", "off", "end", "ref", "obj", "chain", "coll", "part", "none", "bin", "plugin", "bl", "node", "function", "cl", "buffer", "pos", "offset", "r", "bit", "address", "box", "data", "full", "lock", "ip", "unit", "label", "number", "point", "comment", "open", "frame", "num", "complete", "check", "byte", "b", "line", "blocks", "channel", "error", "child", "slice", "flow", "partial", "parent", "range", "group", "pack", "Block", "image", "base", "empty", "type"], "len": ["lc", "str", "limit", "en", "sl", "ind", "il", "val", "part", "ln", "bin", "bl", "offset", "pos", "lan", "pre", "size", "data", "rel", "lock", "lin", "label", "dy", "le", "el", "num", "line", "seq", "fl", "dl", "n", "slice", "loc", "den", "ler", "z", "li", "lf", "fn", "all", "lit", "l", "Len", "url", "count"], "host": ["port", "name", "target", "connect", "serv", "object", "conn", "ref", "config", "hop", "hard", "driver", "mount", "chan", "ich", "build", "node", "home", "xx", "path", "proxy", "address", "cp", "bug", "head", "patch", "ip", "component", "cf", "act", "machine", "work", "mac", "pool", "c", "arch", "localhost", "frame", "dr", "source", "comp", "service", "hub", "location", "channel", "Host", "loc", "cast", "th", "parent", "boot", "ce", "hw", "h", "server", "image", "url"], "ch": ["cha", "col", "sch", "chn", "sk", "conn", "ach", "ct", "cor", "chan", "eth", "ich", "anch", "Ch", "che", "cl", "cmp", "cp", "dev", "bug", "cht", "p", "CH", "cs", "code", "work", "q", "c", "arch", "ctx", "el", "sh", "tch", "channel", "gr", "chip", "zh", "th", "batch", "cher", "ech", "conf", "chrom", "bh", "h", "count"]}}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 22387, "substitutes": {"common": ["remote", "lc", "pb", "chief", "stack", "public", "summary", "security", "recent", "name", "conn", "config", "performance", "com", "none", "connection", "meta", "null", "cm", "con", "control", "node", "function", "local", "Common", "custom", "generic", "standard", "full", "storage", "cache", "final", "data", "component", "current", "communication", "java", "tc", "sync", "central", "context", "mod", "client", "normal", "ctx", "module", "cli", "low", "document", "family", "create", "loader", "core", "comm", "media", "general", "flow", "utils", "sem", "util", "lib", "global", "http", "conf", "resource", "base", "command", "fun"], "errp": ["Errorpc", " errlp", "errorfp", "errpr", "rarr", "rrpr", "errorpc", "rrp", "Errorp", " errfp", "Errorlp", "rrr", " errpc", "errpc", "errfp", "rrpc", "errP", "errorlp", "rarp", "errlp", "erfp", "errorP", " errP", "rarpc", " errpr", "erp", "erP", "errr", " errr", "erpc", "rarpr", "errorp"], "state": ["i", "un", "area", "STATE", "config", "power", "part", "key", "parse", "info", "use", "j", "data", "list", "work", "rule", "date", "slice", "instance", "l", "type", "name", "conn", "g", "private", "style", "statement", "stat", "current", "code", "body", "pse", "self", "set", "ass", "media", "back", "st", "lib", "scope", "reg", "public", "State", "store", "result", "region", "f", "new", "p", "comment", "loc", "manager", "resource", " states", "status", "port", "start", "local", "m", "rate", "cache", "storage", "runner", "sync", "is", "settings", "tag", "cal", "session", "grade", "update", "parent", "block", "base", "states"], "bs": ["obs", "bc", "pb", "ras", "sb", "bos", "outs", "lb", "bis", "ba", "obj", "hs", "fs", "ses", "ubs", "db", "bal", "fb", "bb", "nas", "bytes", "bid", "ds", "bes", "css", "bl", "bing", "bu", "ros", "bas", "os", "vs", "cs", "us", "ls", "bi", "sync", "js", "ctx", "cb", "b", "bits", "blocks", "ns", "BS", "iss", "br", "ab", "ps", "rs", "banks", "gs", "lib", "ins", "bh", "bot", "bus", "base", "ss", "gb"], "backup": ["frontupid", "udup", " backap", "backdown", "unddown", "frontback", "buckup", "workdown", " backdown", "frontup", "buckap", "workupid", "frontUP", "pullout", "undups", "Backup", "frontups", "undback", "pullup", "backups", "pulldown", "backback", "buckdown", "Backdown", "udout", "Backback", "pullupid", "backout", "undup", "frontdown", "backUP", "uddown", "backap", "backupid", " backout", " backUP", "udap", "workout", "Backups", "frontout", "buckout", "workUP", "workup"], "local_err": ["local67er", "local_ctr", "localiprs", "global_ctr", "local67ctr", "global_msg", "local_error", "localiperror", "remote_error", "localiperr", "localipmsg", "local67err", "global_er", "global_err", "local_er", "global_error", "global_rs", "remote_err", " local_er", "remote_er", "local_rs", "local_msg", " local_error"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n", "idx": 22389, "substitutes": {"ctx": ["lc", "bc", "fc", "cc", "conn", "sci", "ct", "config", "jp", "pkg", "cv", "chan", "cm", "crit", "tx", "ca", "Context", "pc", "anc", "fp", "cas", "cmp", "ci", "exec", "cmd", "cp", "cf", "cs", "xc", "ctrl", "tc", "context", "kb", "rc", "c", "cn", "sc", "dc", "cpp", "cr", "qa", "src", "loc", "cca", "ce", "ck", "scope"]}}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n", "idx": 22392, "substitutes": {}}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399, "substitutes": {"env": ["bc", "priv", "enh", "txt", "en", "err", "eu", "config", "chal", "cv", "queue", "impl", "ea", "ef", "exc", "fg", "enc", "dict", "que", "np", "context", "Environment", "rc", "cb", "cfg", "loader", "viron", "fw", "req", "proc", "qt", "manager", "conf", "vm", "ev", "environment", "scope", "fi", "ec", "emb"], "ctx": ["conv", "lc", "git", "pb", "cc", "wcs", "gpu", "conn", "obj", "config", "hs", "event", "acl", "std", "pkg", "cv", "cm", "tx", "ca", "css", "cas", "fp", "cu", "ci", "cmp", "exec", "local", "exc", "cmd", "cp", "act", "cf", "xc", "ctrl", "kb", "context", "sync", "cli", "que", "comment", "rc", "c", "cb", "cn", "cfg", "sc", "gc", "qa", "general", "fw", "loc", "console", "zh", "utils", "util", "qt", "conf", "hw", "ck", "kw", "fn", "scope", "sq", "vc"], "eaddr": ["eadhr", "eddhr", "eddDR", "oadder", "eddbr", "ewder", "engrd", "engDR", "adr", "eebr", "ecdr", "oadhr", "awDR", "oaddr", "eadaddr", "ewDR", "awdr", "eedr", "execdr", "eehr", "eystr", "eadstr", "ewdr", "eadrd", "edddr", "hwrd", "addr", "acedr", "ecstr", "eeDR", "eadr", "awbr", "aedr", "adaddr", "eadbr", "acerr", "eadrr", "execstr", "eydr", "aeaddr", "eadder", "engder", "engdr", "execder", "oadDR", "awrd", "eadDR", "hwder", "aceder", "hwDR", "eyrr", "ecaddr", "aestr", "awder", "eyder", "adstr", "aer", "ewbr", "hwdr", "execrr", "oadbr", "ecr", "acestr"], "rw": ["reg", "class", "table", " pri", "ref", "rows", "eth", "mode", "tr", "rec", "wr", "rr", "rep", " flags", "weight", "buffer", " len", "res", "rc", "pool", "match", "xp", "w", "ptr", "src", "req", "dest"], "type": ["pb", "port", "Type", "name", "types", "shape", "class", "target", "ref", "ping", "val", "key", "TYPE", "style", "ty", "info", "version", "ip", "py", "ver", "ptr", "value", "ype", "len", "block", "lit", "pt", "format"], "hash": ["str", "hz", "ref", "ha", "val", "sha", "key", "height", "tr", "img", "kh", "msg", "cache", "version", "sum", "id", "number", "count", "depth", "mac", "auth", "rh", "pool", "header", "memory", "index", "ash", "num", "match", "search", "sh", "Hash", "value", "rev", "chip", " Hash", "html", "skip", "root", "v", "array", "h", "block", "image", "empty", "where", "ph"], "vsid": ["VSaid", "vside", "dsID", "hersID", "vesid", "VSparent", "veside", " vsID", " vsd", "pssid", "bsid", "versoid", "vs\n", "lside", "psid", "ss\n", "VS\n", "versids", "versuid", "ssbit", "cosd", "osids", "opensid", "vskey", " vsi", "vssid", "vsbit", "vassecret", "vasid", "dsids", "versi", "VSd", "csoid", "vsi", " vsaid", "VSname", "kinsparent", "cosid", "opensId", "dsid", "vsoid", "osID", "cside", " vskid", "ssaid", "umsid", "pside", "ssid", "vsip", " vside", "lsId", "obside", "vessecret", "vskid", "VSkid", "opsID", " vs0", "opensID", "VSsecret", "hersid", " vsname", "kinsid", " vsfile", "vsaid", "bsfile", "osid", "vsname", "psoid", "stsparent", "csid", "kinsID", "VSid", "VSID", "kinsId", "umsname", "obsid", "vasname", "vs0", "stsoid", "csname", "dskey", "vsids", "obsID", "stside", "Vsid", "Vsparent", "versname", "csID", "VSoid", "opsid", " vskey", "VSId", "cosId", "umsids", "vesId", "bsId", "VSsid", "versip", "lsID", "cosaid", "psuid", "obsId", "bsID", "vasId", "vessid", "vesID", "versite", "dside", "opsId", "VSip", " vsids", "versid", "vsd", "stsID", "stsid", " vsuid", "VS0", "umsID", "ss0", "lsid", "vsfile", "vsID", "vsuid", "stsId", "hersaid", "dsparent", "vssecret", "vsite", "opensfile", "versID", "psname", "Vside", " vsoid", "stskid", "stsite", "cskid", "VsID", " vsId", "psID", "vsId", " vsip", " vs\n", "oskey", "VSids", "VSbit", "vsparent", "psi", "ssID", "hersbit", "vesname", "VSide", "opsparent", "verskid", "csite"], "pr": ["PR", "ra", "Ra", "err", "val", "pe", "rx", "tr", "rr", "wr", "repl", "pc", "build", "lr", "pos", "po", "per", "pre", "r", "j", "rel", "arr", "p", "spr", "sa", "dr", "lo", "pl", "fr", "pin", "pro", "ver", "ch", "sr", "pull", "ptr", "seq", "cr", "fl", "gr", "br", "mr", "ps", "rs", "put", "up", "sp", "kr", "pt", "pa", "Pr"], "target_page_bits": ["target_page_bytes", "target_Page_pieces", "target_site_bytes", "target_page64pieces", "target_page_pieces", "target_site_pieces", "target_page64bit", "target_page_ints", "target_page2pieces", "target_page2bytes", "target_page_bit", "target_page32bits", "target_site_ints", "target_Page_bytes", "target_page32bytes", "target_pagepbytes", "target_page32bit", "target_page2bit", "target_pagepbits", "target_page64bytes", "target_page2bits", "target_page64bits", "target_pagepbit", "target_pagepints", "target_Page_bits", "target_site_bit", "target_site_bits", "target_page32pieces", "target_Page_bit"], "ret": ["reg", "def", "result", "val", "rep", "Ret", "res", "rel", "rets", "arr", "pin", "match", "RET", "mem", "seq", "rev", "re", "pat", "req", "proc", "alt", "sec", "nt", "lit", "resp", "fun", "pub"], "ret2": ["Ret1", "seq4", " ret4", " ret1", "ret1", "ret4", "seq2", "Ret2", "Ret4", "seq1"], "slb": ["sslbu", "llb", "slbs", " slB", "sslB", "Slbs", "mlr", " slr", "selob", "ellsb", "clb", "slob", " slab", "Slb", "blf", " slbb", "selab", "selb", "selp", "ellp", "Slf", "dlb", "dlbar", "slk", "islb", "ellab", "islB", "mlB", "Slbi", "dlB", "selbs", " slf", "sslib", "silb", "slf", "clB", "mlk", "mlb", "llbb", "slab", " slbs", "self", "slsb", "llf", "blb", "selr", "slbu", "slr", "SLb", " slib", "plbb", " slp", "clbi", "plb", "sslb", "slbar", " slbar", "llp", "mlib", "mlp", "slbi", "llB", "SLsb", "slB", "selB", "dlsb", "slib", "SLB", "islib", "silf", "blB", "SLbb", "islbu", "SlB", "dlob", "islsb", "SLf", "silB", "silab", "selib", "SLp", " slsb", "ellb", "slbb", " slbi", "SLbar", "plob", "SLab", "Slbb", "dlbb", "selbb", " slbu", "selk", "mlbb", "plB", "slp", " slk", "blab"], "pageaddr": ["pagebreak", "pagead", "screenatt", "screenaddr", " pagehop", "serverattr", " pageaddress", "screenaddress", "agead", " pageadd", "pageoffset", "recordattr", "pageattr", "gehop", " pageAddress", "pagehop", "ageflags", "pageatt", "serveraddr", "screenptr", "geaddress", " pageflags", "changeoffset", "ageaddress", "pageadd", "recordaddr", "changead", "diskatt", "pageAddress", "ageaddr", "recordaddress", "diskaddr", "changeaddress", "agebreak", "serveradd", "serveraddress", "_address", "recordadd", "imageaddr", "imageAddress", "changeaddr", "pageaddress", " pageattr", " pagebreak", " pageptr", " pagead", "imagehop", "_flags", "geAddress", "geaddr", "pageflags", " pageoffset", "_break", "pageptr", "imageaddress", "diskaddress", "_addr", "diskptr", " pageatt", "ageoffset"], "segment_bits": ["segmentnumabs", "segment_pieces", "sevisionationbits", "segment_abs", "segmentsbits", "sevision64files", "segmentnumcats", "segmentsbytes", "sevisionationabs", "segment64bits", "segment_flags", "sevision_pins", "segment54pins", "segment_cats", "segment36bits", "segmentationbits", "segmentnumbits", "segement_bytes", "segment64pins", "segment_files", "sevision_bits", "sevisionationpieces", "segment_locks", "sevision_pieces", "sevision64pins", "segmentnumpieces", "segment36cats", "sevision_files", "segment36abs", "segmentationcats", "segement_locks", "sevision_abs", "segmentsparts", "segmentationpieces", "segment64files", "sevision_cats", "segmentationabs", "segment54bits", "sevision64bits", "segment_pins", "segmentsflags", "segment_parts", "segment36pieces", "segment_bytes", "segement_bits", "segment54files", "segement_pieces", "sevisionationcats"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n", "idx": 22413, "substitutes": {"sockfd": [" socksfd", "sockecd", " socksFD", "socksfd", "sinkdir", "socksFD", "fsinkdf", " sockfb", "sinkstream", "sockdf", "sickdf", "sOCKfb", "fsinkdir", "sockstream", " socksecd", "sOCKFD", "fsinkstream", "svcfd", "sdkstream", "fsockfd", "sinkfd", " sockFD", "sOCKfd", "fsockdf", "sickdir", "svcfb", "fsockstream", "sdkfd", "sOCKecd", "svcFD", "socksecd", "fsockdir", "sdkdf", "sdkdir", "sockfb", "sickfd", "fsinkfd", " socksfb", "svcecd", "sinkdf", "sockdir", "socksfb", " sockecd", "sickstream", "sockFD"], "status": ["output", "str", "summary", "security", "class", "response", "STAT", "level", "result", "progress", "message", "mode", "temp", "sex", "sys", "info", "ok", "login", "state", "stat", "ssl", "method", "version", "current", "unit", "p", "score", "code", "sync", "stats", "success", "content", "header", "settings", "spec", "complete", "source", "dom", "si", "speed", "date", "seq", "gc", "received", "error", "comm", "details", " Status", "update", "skip", "wait", "stage", "proc", "sp", "Status", "resp", "command", "format", "type"], "iov": ["io", "member", "iol", "micro", "gio", "club", "imi", "rolet", "mus", "irc", "lore", "iv", "iii", "minecraft", "oyer", "vg", "anova", "iro", "drm", "mpeg", "iop", "userc", "oy", "gru", "obo", "voice", "uno", "nox", "misc", "iris", "memory", "mu", "music", "oren", "mem", "wikipedia", "anon", "imedia", "soc", "ilib", "intern", "dm", "media", "wav", "liv", "lov", "avi", "uni", "hw", " io", "voc", "ibr", "ilo"], "msg": ["bc", "config", "gram", "message", "mag", "copy", "og", "mom", "info", "mo", "live", "mu", "mem", "go", "ms", "comm", "bm", "game", "global", "doc", "mess", "fi", "pub", "member", "sim", "name", "conn", "rag", "g", "db", "pkg", "file", "node", "stat", "buf", "sg", "irm", "cfg", "media", "iq", "md", "err", "menu", "mode", "generic", "cmd", "man", "addr", "mid", "cli", "gen", "module", "gui", "error", "call", "co", "req", "mg", "gs", "manager", "mn", "Msg", "send", "input", "vg", "m", "dr", "client", "mail", "frame", "dm", "seq", "session", "console", "debug", "gm", "block"], "cmsg": ["cfcmd", "decmsg", "concomm", "hmsg", "hcomm", "Cog", "rcdesc", "cdoc", "decconn", " cmn", "fcmd", " cmail", "dcmem", "cfmd", "crmn", "fmail", "confmessage", "cimd", "Ccmd", "fmsg", "dcmessage", "fmessage", "rcmessage", "conmsg", " cnode", "Cmsg", "cfmsg", "rcmsg", "cmessage", "lcmsg", "concmd", "dcmail", "cvmsg", "nccomm", "cvcomm", "dcmsg", "lccmd", "cmodule", "cvdoc", "Cmd", " cmg", "decdesc", "crmodule", "lcmessage", "cnode", "fog", " cconn", "conmn", "decnode", "cdesc", "cconn", "ncmg", "cfconn", "cog", "cmem", "cmail", "ccomm", "hmessage", "decgame", "cfnode", "lcmd", "cimessage", "cmd", "ncmsg", "crmessage", "cmn", "Cmg", "rcgame", " cmodule", " cmem", " ccomm", "crmsg", "cimsg", "cvmessage", "confog", "cicmd", "decmessage", " cmd", "confmodule", "confcomm", "deccmd", " cmessage", "ncmd", " cdesc", "cmg", "conmodule", "Cmessage", "confcmd", "confmsg", "hdoc", " ccmd", "ncdoc", "ncmessage", " cgame", "ccmd", "cgame", "conmessage", "fmem", "cfmessage"], "retval": ["altVal", "returnvals", "defvals", "returnVAL", " retrol", "altvalid", "defvalue", " retVal", "retvalue", "altvals", "pretval", "RetVAL", "retVal", "refvalid", " retvalid", "returnVal", "retrol", "defeval", "Retval", "altval", "rtval", "alteval", "refrol", "defval", "retreq", "altvalue", "altreq", "Retvals", "retvals", "retVAL", "altVAL", " reteval", " retvalue", "rtvalid", "returnval", " retv", "pretvals", "RetVal", "pretVal", "reteval", "refval", "altv", "refVAL", " retvals", "altrol", "retvalid", "retv", " retreq", "pretreq", " retVAL", "rtvalue", "rtv"], "data": ["io", "i", "def", "next", "fail", "download", "config", "val", "message", "connection", "ds", "no", "buffer", "info", "ip", "load", "mu", "mem", "raw", "comm", "reader", "di", "doc", "resp", "format", "str", "response", "valid", "text", "file", "d", "da", "stat", "buf", "a", "failed", "media", "uni", "empty", "action", "err", "result", "rec", "bytes", "function", "size", "dd", "init", "voice", "addr", "memory", "byte", "dt", "error", "loc", "req", "dat", "send", "input", "Data", "results", "done", "id", "dr", "content", "frame", "DATA", "received", "len", "update", "parent", "block", "record"], "fd": ["io", "md", "fa", "fc", "fff", "cd", "def", "db", "cond", "fb", "wd", "d", "handler", "pd", "ds", "fp", "f", "df", "FD", "fee", "da", "dd", "ad", "fin", "hd", "fx", "dy", "buf", "cb", "fe", "sd", "dt", "dc", "dm", "fm", "fed", "fl", "dl", "ff", "bd", "bf", "dat", "fn", "fi", "output", "format", "fun"], "msg_control": [" msg_ctrl", "msg_coll", "message_Control", " msg_Control", "msgvcontrol", " msg_config", "msg_controller", " msg_controller", "msgvcontroller", "msg_ctrl", "message_ctrl", "msg_length", " msg_length", "msgvctrl", "msg_controlled", "message_control", "msgvconfig", "msg_config", "msg_Control", "message_coll", "message_controlled"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n", "idx": 22417, "substitutes": {"env": ["status", "gear", "e", "en", "end", "conn", "exe", "eu", "config", "err", "eni", "db", "oa", "eng", "energy", "mode", "style", "site", "engine", "ea", "ef", "path", "exec", "exc", "fg", "ey", "ah", "dev", "args", "cache", "state", "enc", "vs", "ace", "context", "np", "cli", "open", "Environment", "ext", "rc", "ctx", "network", "edge", "c", "si", "enable", "gui", "nw", "loader", "profile", "esm", "viron", "inst", "iss", "skin", "osc", "fen", "v", "qt", "ce", "conf", "vm", "stage", "proc", "ev", "environment", "scope", "server", "output", "ec"], "mce": ["emcel", "cCE", "vcel", "pge", " mge", "pce", "vce", "vCE", "mge", "Mcer", "emce", "ccing", "Mce", " mcing", "pcing", "vcer", "cce", "emCE", "mcer", "Mge", "Mcel", "mcing", "emcer", "cge", "pCE", "cke", " mke", "mke", "Mke", "MCE", "mCE", "mcel", " mCE"], "flag": ["status", "name", "start", "ind", "thread", "age", "arg", "mode", "file", "func", "draft", "feature", "pad", "flags", "f", "info", "bit", "fee", "args", "data", "sy", "state", "bug", "use", "Flag", "id", "code", "count", "fun", "sync", "af", "ext", "lag", "FLAG", "fd", "len", "ag", "wait", "stage", "sid", "image", "offset", "fi", "type"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22418, "substitutes": {"ctx": ["lc", "bc", "cc", "cd", "conn", "obj", "config", "pkg", "cv", "cm", "connection", "tx", "handler", "ca", "Context", "cas", "cl", "ci", "exec", "cp", "cache", "cf", "xc", "ctrl", "context", "buf", "client", "c", "cb", "cn", "cfg", "sc", " context", "dc", "cdn", "loc", "conf", "fn", "instance", "scope"], "fd": ["fa", "td", " FD", "fc", "cd", "fs", "fb", "wd", "d", "ffff", "handler", "pd", "ds", "ld", "fp", "f", "dn", "df", "FD", "pipe", "dir", "fee", "size", "dd", "nd", "xf", "fx", "filename", "cb", "fe", "sd", " fid", "dim", "pid", "dc", "fm", "lvl", "fed", "dl", "fl", "fw", "flow", "bd", "sf", "loc", "dB", "fen", "bf", "fn", "lf", "fi", "fin"], "node": ["remote", "route", "native", "name", "e", "query", "object", "ref", "event", "valid", "nn", "result", "none", "tree", "post", "null", "de", "anch", "handler", "leaf", "host", "function", "local", "f", "path", "no", "one", "op", "ode", "new", "component", "link", "id", "annot", "Node", "load", "content", "live", "self", "edge", "index", "source", "document", "destroy", "nw", "missing", "loader", "core", "error", "n", "child", "call", "cdn", "root", "parent", "fn", "instance", "this", "value"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421, "substitutes": {"env": ["bc", "priv", "e", "en", "conn", "eu", "config", "iv", "ea", "ef", "dir", "fg", "her", "enc", "dict", "rc", "cb", "usr", "hl", "enter", "inst", "proc", "conf", "kw", "ev", "environment", "ec"], "dc": ["lc", "bc", "fc", "cc", "cd", "disc", "ct", "director", "cm", "d", "pc", "nc", "ac", "da", "mc", "xc", "tc", "rc", "c", "sc", "dm", "fd", "cdn", "jc", "di", "oc", "ec", "DC"]}}
{"project": "FFmpeg", "commit_id": "043800a96888f1a04732f12316ba477d8f098d3f", "target": 0, "func": "static int end_frame(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext    *ctx = inlink->dst;\n\n    FPSContext           *s = ctx->priv;\n\n    AVFilterLink   *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef  *buf = inlink->cur_buf;\n\n    int64_t delta;\n\n    int i, ret;\n\n\n\n    inlink->cur_buf = NULL;\n\n    s->frames_in++;\n\n    /* discard frames until we get the first timestamp */\n\n    if (s->pts == AV_NOPTS_VALUE) {\n\n        if (buf->pts != AV_NOPTS_VALUE) {\n\n            write_to_fifo(s->fifo, buf);\n\n            s->first_pts = s->pts = buf->pts;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\n                   \"timestamp.\\n\");\n\n            avfilter_unref_buffer(buf);\n\n            s->drop++;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* now wait for the next timestamp */\n\n    if (buf->pts == AV_NOPTS_VALUE) {\n\n        return write_to_fifo(s->fifo, buf);\n\n    }\n\n\n\n    /* number of output frames */\n\n    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\n\n                         outlink->time_base);\n\n\n\n    if (delta < 1) {\n\n        /* drop the frame and everything buffered except the first */\n\n        AVFilterBufferRef *tmp;\n\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n\n        s->drop += drop;\n\n\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n\n        flush_fifo(s->fifo);\n\n        ret = write_to_fifo(s->fifo, tmp);\n\n\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    /* can output >= 1 frames */\n\n    for (i = 0; i < delta; i++) {\n\n        AVFilterBufferRef *buf_out;\n\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n\n\n        /* duplicate the frame if needed */\n\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n\n            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n\n            s->dup++;\n\n        }\n\n\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n\n                                    outlink->time_base) + s->frames_out;\n\n\n\n        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n\n            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n\n            (ret = ff_end_frame(outlink)) < 0) {\n\n            avfilter_unref_bufferp(&buf);\n\n            return ret;\n\n        }\n\n\n\n        s->frames_out++;\n\n    }\n\n    flush_fifo(s->fifo);\n\n\n\n    ret = write_to_fifo(s->fifo, buf);\n\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n\n\n    return ret;\n\n}\n", "idx": 22425, "substitutes": {"inlink": ["inslock", "inlock", "outlock", "inclink", "incline", "outline", "Inlock", "insLink", "inflow", "InLink", "inload", "Inload", " inload", "ninline", "inslink", "inclock", "outflow", "inLink", "insline", "outink", "ninflow", " inink", " inlock", "outLink", "Inlink", " inflow", " inLink", "outload", "insload", "insink", "incink", "ninlock", "ninlink", "inink"], "ctx": ["conv", "lc", "bc", "sync", "fc", "cc", "wcs", "cam", "uc", "conn", "sci", "config", "acl", "driver", "pkg", "cv", "cm", "crit", "tx", "ca", "Context", "anc", "cas", "cu", "ci", "cmp", "exec", "nc", "cmd", "cp", "cs", "cf", "xc", "ctrl", "mc", "context", "tc", "kb", "cli", "rc", "c", "cb", "client", "mac", "cn", "sc", "ann", "cal", "gc", "qa", "media", "fw", "loc", "bm", "cca", "utils", "wx", "util", "cms", "hw", "ck", "kw", "sq", "vc"], "s": ["bc", "sv", "es", "config", "uns", "xs", "ds", "sys", "r", "data", "ssl", "ts", "cs", "us", "stats", "js", "aws", "ms", "n", "S", "ns", "src", "slice", "rs", "ins", "v", "conf", "ans", "http", "ss", "sb", "uf", "g", "ses", "d", "sets", "as", "services", "u", "sg", "c", "spec", "sc", "a", "soc", "sf", "scope", "su", "e", "sym", "qs", "serv", "space", "tests", "hs", "fs", "lines", "sis", "f", "full", "p", "si", "sr", "b", "service", "parts", "sup", "ps", "gs", "sq", "sl", "ops", "ks", "m", "args", "its", "storage", "vs", "ls", "sync", "is", "sa", "settings", "session", "bs", "server"], "outlink": ["offlink", "outplug", " outconnection", "unline", " outline", "outline", "outman", "outconnection", "upline", "unconnection", "unlink", "unLink", "uplink", "inLink", "upplug", " outLink", "inconnection", "outLink", "offplug", "inman", "offline", "upman", "inplug", "offman"], "buf": ["conv", "bc", "pb", "port", "sb", "uf", "lb", "uc", "ref", "config", "pkg", "cv", "fb", "queue", "func", "bridge", "img", "home", "fp", "f", "buffer", "cas", "cmp", "cur", "alloc", "bu", "cmd", "cp", "raf", "box", "bt", "cf", "context", "wb", "pool", "cb", "aux", "b", "window", "seq", "ff", "src", "fd", "bm", "fw", "bd", "br", "ab", "buff", "bf", "proc", "bh", "bag", "vec", "rb", "su", "fi", "cap"], "delta": ["adelta", "cdelta", "sdqa", "dancel", "lDelta", " danta", "Dota", "Dqa", "sdance", "dqa", "cdota", "adetime", "nency", "Delt", "sdelt", "lota", "nota", "nelt", "danta", "DDelta", "lelta", " dota", "sdetime", "nqa", "adota", " dency", "sdota", "netime", "detime", "Delta", " dancel", "dency", "nanta", "sdelta", "delt", " dDelta", "sdanta", "dDelta", "cdelt", "dance", "sdency", "dota", "nelta", "adance", " delt", "cdancel", "sdancel", "nance"], "i": ["io", "jit", "ix", "e", "start", "ie", "qi", "ind", "ri", "ui", "mini", "ki", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "y", "t", "u", "info", "ini", "phi", "it", "j", "p", "ip", "id", "count", "bi", "ani", "is", "c", "mu", "index", "si", "a", "ii", "b", "x", "ji", "n", "iu", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "pi", "base", "zi", "k", "ni", "type"], "ret": ["reg", "red", "flat", "en", "obj", "ref", "gt", "result", "val", "mini", "det", "rem", "stop", "rep", "Ret", "rf", "get", "lr", "r", "info", "res", "data", "final", "fin", "rets", "fun", "mi", "rc", "rot", "match", "pass", "RET", "rt", "mem", "reply", "rev", "re", "fl", "len", "iter", "back", "alt", "nt", "rb", "fi", "resp", "url", "ft"], "frames_in": ["frames__end", "framesNin", "frames_used", "frames__out", "frame_used", "frame_out", "frame_end", "framesNend", "framesNused", "frames_end", "frames__used", "frames__in", "framesNout", "frame_in"], "drop": ["delete", "delay", "col", "grad", "phase", "shape", "flat", "fail", "level", "hop", "clear", "throw", "scale", "push", "loop", "stop", "pad", "down", "type", "layer", "pos", "op", "roll", "size", "zip", "patch", "diff", "change", "fall", "Drop", "field", "grow", "id", "dro", "shift", "pool", "move", "dr", "fix", "hide", "drops", "low", "pass", "pop", "crop", "add", "pull", "create", "x", "carry", "save", "core", "dl", "error", "min", "slice", "ignore", "keep", "update", "batch", "fly", "dropping", "sleep", "clip", "sort", "close", "dp", "max", "count"], "tmp": ["conv", "pb", "uf", "txt", "flat", "obj", "ref", "vt", "config", "result", "map", "part", "pkg", "meta", "fb", "bb", "copy", "temp", "pad", "img", "etc", "fp", "buffer", "cmp", "front", "cp", "tab", "data", "storage", "cache", "zip", "tc", "np", "wb", "mm", "gz", "kk", "cb", "cro", "wp", "mp", "ptr", "stuff", "appy", "src", "media", "slice", "foo", "test", "nb", "buff", "proc", "bag", "rb", "api", "attr"], "buf_out": ["bufKout", "bufadin", "bufnoff", "fp_io", "buf_again", "buf_io", "buff_again", "buff_in", "bufKio", "fpKio", "bufKo", "buf_clean", "fp_o", "bufnout", "buffer_out", "bufKarr", "buf_arr", "buf_o", "bufadclean", "bufadout", "buffer_off", "buff_clean", "fp_arr", "buffer_Out", "buf_off", "bufnOut", "fpKout", "fp_out", "buffer_list", "buf_in", "buff_out", "fpKarr", "bufadagain", "buf_Out", "bufnlist", "fpKo", "buf_list"]}}
{"project": "FFmpeg", "commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "target": 1, "func": "static int roq_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    RoqDemuxContext *roq = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    unsigned int chunk_size;\n\n    unsigned int chunk_type;\n\n    unsigned int codebook_size;\n\n    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];\n\n    int packet_read = 0;\n\n    int64_t codebook_offset;\n\n\n\n    while (!packet_read) {\n\n\n\n        if (avio_feof(s->pb))\n\n            return AVERROR(EIO);\n\n\n\n        /* get the next chunk preamble */\n\n        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n\n            RoQ_CHUNK_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n\n\n        chunk_type = AV_RL16(&preamble[0]);\n\n        chunk_size = AV_RL32(&preamble[2]);\n\n        if(chunk_size > INT_MAX)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        chunk_size = ffio_limit(pb, chunk_size);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case RoQ_INFO:\n\n            if (roq->video_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);\n\n                roq->video_stream_index = st->index;\n\n                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;\n\n                st->codecpar->codec_tag    = 0;  /* no fourcc */\n\n\n\n                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)\n\n                    return AVERROR(EIO);\n\n                st->codecpar->width  = roq->width  = AV_RL16(preamble);\n\n                st->codecpar->height = roq->height = AV_RL16(preamble + 2);\n\n                break;\n\n            }\n\n            /* don't care about this chunk anymore */\n\n            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);\n\n            break;\n\n\n\n        case RoQ_QUAD_CODEBOOK:\n\n            if (roq->video_stream_index < 0)\n\n                return AVERROR_INVALIDDATA;\n\n            /* packet needs to contain both this codebook and next VQ chunk */\n\n            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;\n\n            codebook_size = chunk_size;\n\n            avio_skip(pb, codebook_size);\n\n            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n\n                RoQ_CHUNK_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n\n                codebook_size;\n\n\n\n            if (chunk_size > INT_MAX)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            /* rewind */\n\n            avio_seek(pb, codebook_offset, SEEK_SET);\n\n\n\n            /* load up the packet */\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n\n            if (ret != chunk_size)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = roq->video_stream_index;\n\n            pkt->pts = roq->video_pts++;\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case RoQ_SOUND_MONO:\n\n        case RoQ_SOUND_STEREO:\n\n            if (roq->audio_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);\n\n                roq->audio_stream_index = st->index;\n\n                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;\n\n                st->codecpar->codec_tag = 0;  /* no tag */\n\n                if (chunk_type == RoQ_SOUND_STEREO) {\n\n                    st->codecpar->channels       = 2;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n                } else {\n\n                    st->codecpar->channels       = 1;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22426, "substitutes": {"s": ["sim", "sv", "sb", "e", "sed", "support", "sym", "qs", "sie", "sl", "sci", "g", "ses", "xs", "d", "sets", "ops", "ks", "ds", "services", "f", "sys", "t", "r", "ssl", "os", "p", "cs", "ls", "sync", "stats", "sa", "sg", "c", "js", "self", "spec", "single", "sq", "client", "si", "sc", "sr", "b", "service", "aws", "session", "S", "ns", "sf", "south", "ps", "gs", "rs", "conf", "su", "ss"], "pkt": ["Packet", "ppkt", "ppct", " pct", "ppacket", " packet", "Pct", "psth", " psth", "pct", "Pkt", "packet", "Psth", "ppsth"], "roq": ["boq", "boqa", "roqs", " roqu", "ROq", "riflow", "troqs", "broquest", "roqu", "grok", "proqs", "groquest", "groq", "croqa", "croq", "groqt", "rouqu", "croqt", "troqu", "koqu", " roQ", "broqs", "bok", "troz", "troQ", "roz", "troquest", "resourceqa", "groqa", "ROql", "rok", "rouquest", "roqt", "groqs", "roqa", "ROqt", "koq", "croqs", "rouQ", "ROqa", "rouq", "roql", "groqu", "troq", " roquest", "koQ", "rik", "resourcez", "roQ", "groQ", "roflow", "troqa", "proq", "broz", "broq", "boflow", "riq", "resourceql", "troql", "roquest", "ROqs", "ROz", "proquest", "proz", "riqa", "groflow", "resourceq", "koquest"], "pb": ["platform", "bc", "sb", "fc", "summary", "uf", "lb", "lp", "prot", "pkg", "cv", "db", "fb", "pm", "bb", "pit", "phrase", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "PB", "tp", "pp", "p", "np", "wb", "bps", "ctx", "cb", "pl", "ib", "wp", "mp", "b", "ub", "cpp", "tmp", "hub", "bm", "ab", "bh", "bs", "rb", "vp", "typ", "xb", "dp", "ppa", "pa"], "chunk_size": ["chunklexsum", "chick_number", "chunks_size", "chunk_cache", "chunkactype", "chunklexSIZE", "chunks_type", "chunkacsn", "chunk_sn", "chunk_number", "chickersized", "chummy_speed", "chunks_strength", "chunkerid", "chunks_sn", "chummy_value", "chunk_sized", "chunc_size", "chunk_weight", "chunc_sum", "chick_sized", "chunkersized", "chunkersize", "chunk_strength", "chunkacsize", "chunk_speed", "chickersize", "chick_size", "chunk_value", "chummy_form", "chunkacstrength", "chunklexlength", "chummy_size", "chunklexsize", "chunc_SIZE", "chunk_sum", "chunkernumber", "chunk_length", "chunc_length", "chick_id", "chickernumber", "chunk_form", "chunk_id", "chickerid", "chunk_SIZE"], "chunk_type": ["chunk_family", "chunk6style", "chunknid", "chunker_number", "chunker_id", "chunkertype", "chunk8type", "chunk_name", "chunk_style", "chunknname", "chunker_type", "chunk8id", "chunk8index", "chunkerindex", "chunknnumber", "chunk_id", "chunk_number", "chunk6family", "chunk_index", "chunk6size", "chunkersize", "chunkerid", "chunk6type", "chunk8size", "chunker_name", "chunkntype"], "codebook_size": ["codebox_capacity", "codebox_length", "codebookssize", "codebox_size", "codebookscapacity", "codebook_length", "codebox_len", "codebookslength", "codebookslen", "codebook_len", "codebook_capacity"], "preamble": ["promle", "pamble", " preambled", "pawnbled", "prawbles", " pepble", "Prambled", "PramBLE", "Pramle", "ppREAMback", "Preambler", "Preamback", "ppreamBLE", "pREAMle", "pymback", "pambled", "piddBLE", "pramBLE", "pepBLE", "PREAMbler", " pepl", "pepback", "pucbles", " peple", "piddle", "praml", "promble", "prawback", "pREAMbled", "pREAMbe", "preamle", "Preambe", "pREAMback", "pawnle", "pREAMl", "PreamBLE", " pepbled", "pawnBLE", "pepble", "piddbled", "prambles", "pucble", "PREAMl", "preamback", "Preamle", "piddble", "pepl", "pymble", "prawble", "Preambles", "preambled", "preambler", "pymbler", "prambled", "Pramble", "preambe", "ppreamle", "pyml", "Prambles", "pamle", "Prambe", "pramle", "pREAMbler", "prawle", "PREAMble", "pREAMBLE", "pawnble", "prombled", "Preamble", " preamle", "pREAMble", "pramble", "proml", "pucbe", "ppREAMle", " preaml", "prawbe", "preaml", "Preaml", "preambles", "Preambled", "peple", "prawBLE", "pambe", "ppreamback", "pucle", "PREAMback", "pepbler", "pepbled", "ppreamble", "ppREAMBLE", "ppREAMble", "prambe", "preamBLE"], "codebook_offset": ["codeboard_position", "codeboard__offset", "codebook_position", "codebook_no", "codebook__len", "codebook__offset", "codeboard_len", "codeboard__len", "codeboard_no", "codeboard__position", "codebook__no", "codebook__position", "codeboard__no", "codebook_len", "codeboard_offset"], "st": ["lc", "str", "sv", "sb", "est", "ut", "stack", "start", "sk", "ast", "obj", "ct", "sl", "std", "ost", "kt", "St", "d", "tt", "mt", "ld", "bl", "sth", "art", "t", "rest", "nd", "ts", "sty", "sa", "fe", "sd", "et", "ste", "sh", "fr", "sc", "sts", "sr", "set", "tmp", "se", "spect", "sw", "inst", "src", "ist", "put", "stage", "ST", "nt", "sp", "sn", "stream", "pt", "ust", "sta", "ss", "ft"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,\n\n\t\t\t\t  int16_t *filter, int16_t *filterPos, int filterSize)\n\n{\n\n#ifdef HAVE_MMX\n\n\tassert(filterSize % 4 == 0 && filterSize>0);\n\n\tif(filterSize==4) // allways true for upscaling, sometimes for down too\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 4), %%mm1\\n\\t\"\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 4), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse if(filterSize==8)\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*4;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 16(%1, %%\"REG_BP\", 8), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 24(%1, %%\"REG_BP\", 8), %%mm5\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm4, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\t\t\t\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse\n\n\t{\n\n\t\tuint8_t *offset = src+filterSize;\n\n\t\tlong counter= -2*dstW;\n\n//\t\tfilter-= counter*filterSize/2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"mov %2, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%%\"REG_c\", %0), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%%\"REG_c\", %0), %%ebx\t\\n\\t\"\n\n\t\t\t\"mov %5, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%1), %%mm1\t\t\\n\\t\"\n\n\t\t\t\"movq (%1, %6), %%mm3\t\t\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_a\"), %%mm0\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_b\"), %%mm2\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm0, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"add $8, %1\t\t\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\" jb 2b\t\t\t\t\\n\\t\"\n\n\t\t\t\"add %6, %1\t\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"mov %3, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm4, (%%\"REG_a\", %0)\t\\n\\t\"\n\n\t\t\t\"add $4, %0\t\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t: \"+r\" (counter), \"+r\" (filter)\n\n\t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset),\n\n\t\t\t  \"m\" (src), \"r\" ((long)filterSize*2)\n\n\t\t\t: \"%\"REG_b, \"%\"REG_a, \"%\"REG_c\n\n\t\t);\n\n\t}\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\n\thScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<dstW; i++)\n\n\t{\n\n\t\tint j;\n\n\t\tint srcPos= filterPos[i];\n\n\t\tint val=0;\n\n//\t\tprintf(\"filterPos: %d\\n\", filterPos[i]);\n\n\t\tfor(j=0; j<filterSize; j++)\n\n\t\t{\n\n//\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]);\n\n\t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n\t\t}\n\n//\t\tfilter += hFilterSize;\n\n\t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...\n\n//\t\tdst[i] = val>>7;\n\n\t}\n\n#endif\n\n#endif\n\n}\n", "idx": 22429, "substitutes": {"dst": ["dstal", "datst", "Dst", "datsrc", " dost", "dsc", " dstal", "Dsc", " dsc", "nddest", "datsc", "dsrc", "Ddest", "dbl", "Dbl", "idst", " dbl", "Dsrc", "dost", "ddest", "idstal", "dsts", "Dstal", "ndst", "datbl", "ndsts", "Dsts", " ddest", " dsts", "Dost", " dsrc", "idsts", "ndstal", "idost"], "dstW": ["dblH", "dSTH", "dsrcL", "Dstw", "dblW", "drcw", "dscWidth", "DSTH", "dconstL", "dconstW", "dSTW", " dstV", "DstW", "DSTw", "dstL", "lstN", "lstW", "lconstW", "dscV", "lconstL", " dblW", "dblV", " dstw", "drcW", "dsrcN", "dblWidth", " dstWidth", "DstH", "dstH", "dstw", "dstV", " dblw", " dblWidth", "dconstN", "dsrcW", "dstN", "dblw", "DstWidth", "dscW", "drcL", "dSTWidth", "DSTW", "dconstw", "lstw", "lstL", "drcN", "dsrcw", "dSTw", "dSTV", "DSTWidth", " dblV", "dsrcH", "dstWidth", "dscw", "lconstw", "dsrcWidth", "lconstN"], "src": ["conv", "sb", "sl", "config", "include", "rin", "scl", "secure", "scan", "sync", "rc", "reflect", "source", "sc", "RC", "sr", "usr", "sur", "loc", "dest", "rb", "rib", "fn", "stream", "sort", "attr", "url"], "srcW": ["srcL", "destW", "sourceV", "destL", " srcRW", "sourceRW", "srcV", " srcV", "destRW", "sourceL", " srcL", "destV", "sourceW", "srcRW"], "xInc": ["ixInc", "ixAdd", "xinc", "rxAdd", "ixinc", "rxDir", " xDir", "xAdd", "ixDir", "rxInc", " xAdd", "xDir", " xinc", "rxinc"], "filter": ["name", "limit", "target", "shape", "support", "tail", "query", "event", "config", "force", "stop", "feature", "control", "plugin", "wave", "rf", "layer", "model", "path", "f", "per", "ir", "version", "header", "search", "match", "source", "Filter", "profile", "counter", "channel", "fl", "mask", "page", "batch", "skip", "parent", "fil", "frequency", "block", "cover", "sort", "resource", "output", "url", "type"], "filterPos": ["sortLen", " filterOffset", "FilterPos", "sourceDir", "sourceMin", "featurePo", "filterPo", "filterDir", "filDir", " filterMin", "filterOffset", "sortSize", "FilterSize", "filterpos", "sourcePos", "filterLen", "sourcepos", "filMin", "featurePos", "filterMin", " filterpos", " filterDir", "featurepos", "filSize", " filterLen", " filterPo", "filPo", "FilterLen", "filpos", "sortOffset", "FilterOffset", "filPos", "sortPos", "featureSize"], "filterSize": ["sortLen", "filAddress", "flatSIZE", "filterCode", "flatSize", "flatCode", "headerC", "headerSize", "maskSize", "filterC", "filSIZE", "sortSize", "FilterSize", "sortSIZE", "filterLen", "Filtersize", "headerSIZE", "filterSmall", "filterSIZE", "controlSIZE", " filterC", "controlSize", "controlCode", "masksize", "filC", " filterAddress", "filSize", " filterLen", "filsize", "FilterLen", "filtersize", " filterSIZE", "sortC", " filterCode", " filtersize", "maskAddress", "sortCode", "headerSmall", " filterSmall", "maskSIZE", "sortsize", "filSmall", "filterAddress", "FilterCode", "FilterSIZE", "controlsize", "FilterC"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "substitutes": {"f": ["fc", "i", "e", "ref", "fs", "g", "this", "framework", "file", "fb", "rf", "fp", "df", "t", "m", "tif", "new", "p", "fx", "inf", "cf", "o", "af", "c", "self", "fr", "tf", "w", "ff", "fd", "F", "fw", "sf", "fen", "v", "bf", "lf", "l", "fo", "elf"], "ret": ["reg", "red", "en", "xt", "ref", "result", "val", "arg", "det", "rep", "Ret", "mt", "al", "res", "cat", "rets", "arr", "id", "ext", "RET", "rt", " Ret", "mem", "reply", "re", "pat", "pret", "back", "alt", "ry", "nt", "lit", "att", "resp", "fun"]}}
{"project": "FFmpeg", "commit_id": "d3b4b74c32cf302d36a4c4d2cce08027f0a22560", "target": 0, "func": "static int encode_picture_lossless(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    MJpegContext * const m = s->mjpeg_ctx;\n\n    AVFrame *pict = data;\n\n    const int width= s->width;\n\n    const int height= s->height;\n\n    AVFrame * const p= (AVFrame*)&s->current_picture;\n\n    const int predictor= avctx->prediction_method+1;\n\n\n\n    init_put_bits(&s->pb, buf, buf_size);\n\n\n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    p->key_frame= 1;\n\n\n\n    ff_mjpeg_encode_picture_header(s);\n\n\n\n    s->header_bits= put_bits_count(&s->pb);\n\n\n\n    if(avctx->pix_fmt == PIX_FMT_RGB32){\n\n        int x, y, i;\n\n        const int linesize= p->linesize[0];\n\n        uint16_t (*buffer)[4]= (void *) s->rd_scratchpad;\n\n        int left[3], top[3], topleft[3];\n\n\n\n        for(i=0; i<3; i++){\n\n            buffer[0][i]= 1 << (9 - 1);\n\n        }\n\n\n\n        for(y = 0; y < height; y++) {\n\n            const int modified_predictor= y ? predictor : 1;\n\n            uint8_t *ptr = p->data[0] + (linesize * y);\n\n\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < width*3*4){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            for(i=0; i<3; i++){\n\n                top[i]= left[i]= topleft[i]= buffer[0][i];\n\n            }\n\n            for(x = 0; x < width; x++) {\n\n                buffer[x][1] = ptr[4*x+0] - ptr[4*x+1] + 0x100;\n\n                buffer[x][2] = ptr[4*x+2] - ptr[4*x+1] + 0x100;\n\n                buffer[x][0] = (ptr[4*x+0] + 2*ptr[4*x+1] + ptr[4*x+2])>>2;\n\n\n\n                for(i=0;i<3;i++) {\n\n                    int pred, diff;\n\n\n\n                    PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                    topleft[i]= top[i];\n\n                    top[i]= buffer[x+1][i];\n\n\n\n                    left[i]= buffer[x][i];\n\n\n\n                    diff= ((left[i] - pred + 0x100)&0x1FF) - 0x100;\n\n\n\n                    if(i==0)\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                    else\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                }\n\n            }\n\n        }\n\n    }else{\n\n        int mb_x, mb_y, i;\n\n        const int mb_width  = (width  + s->mjpeg_hsample[0] - 1) / s->mjpeg_hsample[0];\n\n        const int mb_height = (height + s->mjpeg_vsample[0] - 1) / s->mjpeg_vsample[0];\n\n\n\n        for(mb_y = 0; mb_y < mb_height; mb_y++) {\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < mb_width * 4 * 3 * s->mjpeg_hsample[0] * s->mjpeg_vsample[0]){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n            for(mb_x = 0; mb_x < mb_width; mb_x++) {\n\n                if(mb_x==0 || mb_y==0){\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n                                if(y==0 && mb_y==0){\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= 128;\n\n                                    }else{\n\n                                        pred= ptr[-1];\n\n                                    }\n\n                                }else{\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= ptr[-linesize];\n\n                                    }else{\n\n                                        PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n                                    }\n\n                                }\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n//printf(\"%d %d %d %d %8X\\n\", mb_x, mb_y, x, y, ptr);\n\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(s);\n\n    s->picture_number++;\n\n\n\n    flush_put_bits(&s->pb);\n\n    return pbBufPtr(&s->pb) - s->pb.buf;\n\n//    return (put_bits_count(&f->pb)+7)/8;\n\n}\n", "idx": 22436, "substitutes": {"avctx": ["avcam", "abcmp", "AVcf", "avecf", "avqa", "AVconfig", "AVcmp", "avcv", "afqa", "afcf", " avcv", "avec", "avecam", "afcam", "AVc", "afcmp", "avconn", "avconfig", "afctx", " avpkg", "avercontext", "avecmp", "avcf", "AVcontext", "afpkg", "avercam", "navctx", "Avcontext", "Avcv", "avecontext", "averctx", "abconfig", "Avpkg", "avcontext", "navconn", "abctx", "navqa", "afconfig", "avc", "avectx", "avcmp", "Avctx", "abcontext", "afcontext", "AVctx", "afc", "afconn", "afcv", " avcontext", "aveconn", "aveqa", "avercmp", "navcontext", "avpkg"], "buf": ["conv", "bc", "pb", "port", "uf", "uc", "off", "text", "map", "cv", "ctr", "fb", "queue", "file", "img", "fp", "alloc", "cmd", "cf", "prefix", "wb", "rc", "header", "ctx", "cb", "num", "aux", "b", "window", "mem", "raw", "seq", "ff", "fd", "src", "br", "Buffer", "batch", "buff", "proc", "vec", "rb", "dest", "block", "cap"], "buf_size": ["buf_num", "pad_count", "buflexdepth", "padlexsize", " buf_num", "buf1num", "buflexform", "pad_depth", "buf_count", "padlexform", "buf1source", "buflexsource", "buflexcount", "buf5count", "padlexcount", "buf_source", "pad_size", "buf_form", "buf5depth", "buflexsize", "pad_form", "buf_depth", "buf5size", " buf_source", "buflexnum", "padlexdepth", "buf1size", "buf5form"], "data": ["next", "config", "ui", "text", "input", "board", "map", "result", "Data", "queue", "d", "bin", "pad", "img", "picture", "f", "pos", "device", "devices", "padding", "cache", "code", "body", "open", "memory", "a", "DATA", "window", "tmp", "first", "media", "reader", "slice", "batch", "buff", "parent", "proc", "alpha", "dat", "image", "block", "empty", "offset", "format", "video", "capt"], "s": ["sv", "bis", "es", "xs", "ds", "sys", "r", "tp", "ssl", "os", "ts", "cs", "params", "stats", "js", "small", "sts", "aws", "ms", "n", "S", "ns", "rs", "ins", "conf", "http", "ss", "sb", "support", "g", "ses", "d", "sets", "services", "u", "stat", "sites", "sg", "c", "self", "spec", "sm", "sc", "a", "sf", "su", "e", "sym", "qs", "space", "hs", "fs", "f", "t", "si", "b", "service", "parts", "sup", "ps", "gs", "sec", "sq", "sl", "ops", "ks", "storage", "ls", "sync", "is", "sa", "client", "settings", "ctx", "se", "session", "sp"], "m": ["mA", "ml", "g", "cm", "d", "f", "r", "man", "mc", "mm", "mac", "mi", "c", "mp", "mem", "w", "ms", "n", "media", "bm", "M", "manager", "gm", "l", "mn", "nm"], "pict": ["pb", "txt", "cam", "password", "csv", "obj", "conn", "sci", "ct", "config", "jp", "phot", "Picture", "img", "png", "picture", "peg", "fig", "fat", "fp", "info", "cp", "stat", "pic", "np", "ctx", "tmp", "seq", " picture", "jpg", "Pict", "doc", "proc", "buff", "pty", "image", "photo", "fi", "feat", "capt"], "p": ["pb", "e", "jp", "lp", "g", "pe", "part", "d", "P", "pd", "bp", "pc", "l", "cop", "fp", "f", "pg", "po", "t", "pre", "u", "op", "cp", "j", "tp", "r", "pp", "pic", "o", "np", "py", "pr", "c", "gp", "a", "b", "n", "ps", "parent", "sp", "pointer", "vp", "pi", "pn", "pa"], "x": ["ix", "e", "ct", "g", "pe", "xxx", "xy", "d", "height", "tx", "rx", "host", "xx", "f", "pos", "win", "sex", "t", "ex", "r", "u", "j", "ip", "fx", "id", "xc", "code", "yx", "q", "c", "px", "index", "dx", "num", "X", "el", "on", "b", "in", "w", "xp", "n", "any", "xi", "ax", "wx", "z", "image", "l", "k"], "y": ["sky", "ya", "e", "yn", "vy", "g", "yy", "xy", "ay", "height", "d", "ny", "ty", "yo", "yr", "yt", "xx", "f", "ey", "t", "u", "oy", "j", "sy", "id", "o", "count", "dy", "ye", "py", "c", "ch", "b", "Y", "w", "cy", "ym", "python", "n", "yl", "hi", "z", "yi", "ry", "l", "type"], "i": ["io", "ix", "e", "ie", "fi", "qi", "g", "ui", "eni", "pi", "gi", "d", "my", "chi", "ti", "I", "f", "ci", "t", "u", "phi", "ini", "it", "j", "init", "info", "one", "ip", "id", "o", "bi", "q", "mi", "c", "mu", "index", "si", "ii", "b", "w", "in", "n", "iu", "ai", "xi", "hi", "di", "z", "yi", "li", "multi", "l", "zi", "k", "ni"], "buffer": ["bc", "config", "message", "cube", "pause", "pad", "pos", "r", "program", "que", "context", "pool", "header", "paste", "window", "slice", "iter", "proc", "image", "cap", "uf", "table", "g", "text", "ctr", "d", "c", "surface", "position", "stack", "result", "queue", "img", "layer", "memory", "b", "page", "Buffer", "buff", "resource", "command", "port", "writer", "uffer", "input", "_", "transfer", "cache", "source", "document", "profile", "border", "scroll", "all", "server", "padding", "vector"], "top": ["platform", "Top", "stack", "target", "start", "tail", "stop", "per", "op", "master", "tops", "last", "pop", "first", "tip", "min", "above", "upper", "skip", "root", "parent", "up", "bot", "sp", "dot", "pointer", "TOP", "best", "bottom", "pt", "offset", "position", "high", "max", "but"], "topleft": ["trossofts", "tokefts", "stopleft", "toplevel", "tokeft", "stopleaft", "trieft", "striefts", "stounquest", "stounvel", "stounfts", "stounft", "trossoquest", "stoplequest", "tounft", "strieft", "tolloft", "toplefts", "stoplecl", "t\u00favel", "strieaft", "stoplevel", "triecl", "trieaft", "tolloaft", "toplecl", "topleaft", "tounfts", "t\u00faft", "trossoft", "stoplefts", "trossovel", "tokeaft", "triefts", "tollocl", "tollofts", "tounvel", "tounquest", "striecl", "toplequest", "t\u00fafts", "tokecl", "t\u00faquest"], "ptr": ["td", "grad", "xt", "ref", "iv", "prot", "butt", "val", "tr", "pad", "temp", "rect", "cur", "pos", "ud", "alloc", "pre", "pointers", "arr", "code", "addr", "elt", "que", "dr", "rot", "ext", "pr", "pl", "rt", "length", "inst", "slice", "loc", "br", "Ptr", "buff", "pair", "pointer", "pty", "inter", "pt", "offset", "attr", "tips", "padding"], "linesize": ["posize", "linesIZE", "linspace", "linescore", "framesizer", "linsize", " linesization", "linessize", "posizes", "planesizer", "netsize", "framesize", "linesizer", "elinesization", "linescale", " linesIZE", "linssize", "netssize", "linscale", "framesiz", "planesiz", "linesiz", "possize", "netsizes", "linesization", " linespace", "elinesize", " linescore", "planescore", "linsIZE", "poscale", " linesiz", "planesize", " linesizer", "framescore", "elinespace", "linsization", "elinesIZE", "linespace", "linsizes", "linesizes", "netscale"]}}
{"project": "FFmpeg", "commit_id": "934fe00680a1139cbc0950641655af5923dd7763", "target": 0, "func": "static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (o->format) {\n\n        if (!(file_iformat = av_find_input_format(o->format))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Unknown input format: '%s'\\n\", o->format);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n    if (o->nb_audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (o->nb_audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_channels[o->nb_audio_channels - 1].u.i);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (o->nb_frame_rates) {\n\n        av_dict_set(&format_opts, \"framerate\", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_sizes) {\n\n        av_dict_set(&format_opts, \"video_size\", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_pix_fmts)\n\n        av_dict_set(&format_opts, \"pixel_format\", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);\n\n\n\n    ic->video_codec_id   = video_codec_name ?\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;\n\n    ic->audio_codec_id   = audio_codec_name ?\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;\n\n    ic->subtitle_codec_id= subtitle_codec_name ?\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n    ic->interrupt_callback = int_cb;\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* open the input file with generic avformat function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    /* apply forced codec ids */\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        choose_decoder(o, ic, ic->streams[i]);\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        exit_program(1);\n\n    }\n\n\n\n    timestamp = o->start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n", "idx": 22459, "substitutes": {"o": ["io", "e", "ow", "oo", "O", "object", "off", "oe", "obj", "ao", "oa", "ol", "ou", "so", "node", "no", "f", "ro", "po", "op", "t", "oi", "u", "m", "wo", "original", "mo", "custom", "one", "ob", "os", "oc", "p", "od", "ant", "c", "lo", "module", "oid", "ocr", "go", "fo", "bo", "ov", "online", "to", "n", "co", "iso", "ot", "ko", "http", "from", "image", "l", "k", "ilo", "vo"], "opt": ["io", "obj", "config", "option", "text", "Opt", "rec", "path", "op", "alloc", "cmd", "info", "cat", "enc", "open", "timeout", "ctx", "Option", "w", "loc", "options", "root", "proc", "fn", "oc", "attr", "url"], "filename": ["name", "txt", "binary", "download", "il", "utf", "file", "fb", "phrase", "microsoft", "fax", "json", "lua", "uri", "ln", "png", "fp", "f", "path", "login", "msg", "nil", "wl", "kl", "prefix", "directory", "subject", "which", "sheet", "timeout", "println", "kn", "nuclear", "title", "source", "document", "ename", "location", "src", "fd", "length", "wav", "dll", "jpg", "sf", "tty", "bf", "fil", "fn", "username", "files", "l", "Filename", "url"], "ic": ["lc", "bc", "fc", "ik", "ig", "fi", "ici", "ican", "ct", "nic", "IC", "aci", "aic", "pc", "mic", "anc", "ci", "isc", "ac", "ico", "mc", "xc", "pic", "tc", "ant", "au", "c", "ctx", "icc", "iac", "cy", "cci", "ics", "gc", "ai", "xi", "ec", "icer", "cit", "voc", "oc", "lic", "cu", "acs", "vc"], "file_iformat": ["file_iformart", "file_iolac", "file_iformant", "file_iolant", "file_iplac", "file_iformata", "file__iformat", "file_isolat", "file__iformac", "file_isolata", "file_iliart", "file_iplat", "file_iformt", "file__iolt", "file_iddant", "file_iddac", "file__iformt", "file_iolata", "file_iliat", "file_isolit", "file_iddt", "file_isolart", "file_iolart", "file_iformit", "file_iolit", "file_iplt", "file__iformant", "file__iolac", "file_iliata", "file_iddat", "file_iformac", "file__iolant", "file_iliit", "file_iplant", "file__iolat", "file_iolt", "file_iolat"], "err": ["status", " typ", " error", " aux", " pri", "result", "rr", " resp", " len", " fe", "res", "stat", "id", " seq", "var", "rc", "out", "cb", " rc", "seq", "error", "fd", "len", "req", "nt", "h", "resp", "fun"], "i": ["io", "ix", "e", "ind", "ui", "d", "ti", "I", "l", "f", "ci", "t", "info", "u", "ini", "m", "it", "r", "s", "ip", "p", "id", "is", "mi", "c", "index", "si", "ii", "b", "n", "iu", "ai", "v", "z", "li", "h", "pi", "x", "zi", "k", "ni", "count"], "ret": ["status", "bc", "en", "result", "val", "wa", "Ret", "no", "buffer", "res", "cat", "rc", "cb", "aux", "RET", "rt", "mem", "flag", "seq", "len", "back", "alt", "ry", "nt", "fi"], "timestamp": ["frametime", "microoffset", "framestamp", "framest", "microestamp", "framoffset", "timest", "imoffset", "imestamp", "timoffset", "microetime", "microest", "timetime", "imest", "imetime"], "buf": ["begin", "bc", "config", "buffer", "alloc", "msg", "bg", "data", "context", "wb", "pool", "header", "font", "la", "mem", "window", "bo", "ff", "src", "br", "bd", "batch", "wx", "doc", "proc", "rb", "fam", "feat", "output", "cap", "str", "uf", "text", "cv", "null", "fp", "ucc", "bed", "rc", "cb", "desc", "bh", "bag", "vec", "conv", "uc", "ref", "fb", "queue", "func", "bytes", "bin", "Buff", "img", "f", "box", "bn", "byte", "b", "tmp", "usr", "fd", "loc", "buff", "bf", "pb", "port", "cur", "ctx", "aux", "seq", "auc", "block", "url"], "opts": [" opttr", " opttes", "operts", "optes", "opertr", "opfs", " opfs", " optes", " optts", "opertes", " optfs", "optr", " optr", "operfs"], "orig_nb_streams": [" orig_nb_streamries", " orig_nb_roundd", " orig_nb_threadd", " orig_nb_inputries", " orig_nb_roundries", " orig_nb_threadries", " orig_nb_inputd", " orig_nb_rounding", " orig_nb_inputing", " orig_nb_inputs", " orig_nb_threading", " orig_nb_rounds", " orig_nb_streaming", " orig_nb_streamd", " orig_nb_threads"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 22462, "substitutes": {"val": ["expr", "grad", "ref", "sl", "valid", "scale", "ind", "cond", "func", "tx", "f", "al", "data", "p", "arr", "vals", "unit", "fx", "var", "py", "el", "ctx", "cal", "b", "x", "rt", "min", "vol", "VAL", "Val", "v", "eval", "pt", "all", "l", "base", "gb", "value"], "u": ["io", "ut", "i", "uf", "ru", "ul", "eu", "ur", "ui", "yu", "d", "ou", "l", "f", "t", "bu", "ue", "s", "lu", "p", "uv", "us", "tu", "o", "q", "c", "mu", "num", "du", "a", "b", "U", "w", "uu", "iu", "chu", "util", "v", "up", "user", "nu", "su", "pu", "cu"]}}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n", "idx": 22465, "substitutes": {"linker": ["linke", "laye", " linkger", "pullener", "linkner", "layer", "lockger", "linkator", " linkator", "layener", "lockler", " linkler", "linkener", "pullier", "lockner", "linkier", "locker", "layger", " linke", "lockator", "installier", "fixener", "layator", "linkker", "fixker", "layner", "fixier", "layler", " linkener", "pullker", " linkner", "installener", "locke", "puller", "lockener", "linkger", "installer", "linkler", "installker", "fixer"], "file_name": ["entryNameName", "fileNamestring", "fileNamename", "entryNamename", "entry_Name", " file_num", "filexuri", "fileMname", "fileMlen", "filexname", "fileNameaddress", " file_address", "file_len", "fileNameName", "file_address", "file_uri", "entry_len", " file_string", "entry_name", "fileNameconnection", "file_string", "entry_connection", "file_connection", "entryNamelen", " file_uri", "file_Name", "filexnum", "fileMName", "file_num", "fileNamelen", "entryNameconnection", "fileMconnection"], "start": ["begin", "step", "name", "limit", "space", "end", "starting", "scale", "part", "origin", "time", "stop", "get", "type", "offset", "pos", "info", "address", "use", "init", "data", "new", "last", "sum", "unit", "id", "load", "shift", "index", "self", "source", "run", "enable", "set", "line", "first", "se", "speed", "read", "error", "length", "slice", "len", "grade", "skip", "range", "from", "resource", "block", "image", "Start", "scope", "base", "position", "count"], "size": ["member", "i", "name", "limit", "shape", "end", "send", "scale", "g", "time", "extra", "mode", "sized", "Size", "style", "ize", "address", "use", "data", "storage", "last", "unit", "izes", "number", "count", "sync", "timeout", "six", "small", "source", "capacity", "second", "si", "speed", "set", "se", "n", "length", " sizes", "len", "loc", "slice", "from", "SIZE", "empty", "all", "position", "offset", "sum"], "checksum": ["checkum", " checksums", " checksumer", "alsumer", "checksumer", "alsum", "checkssum", "ckssum", "checksume", "checksumm", "alsums", " checksam", " checksnum", "cksume", "cksumer", " checksup", "readsnum", "checksam", "cksumm", "readsumm", "cksum", "cksup", " checkssum", "checksnum", "cksums", "checkup", "readsum", "alssum", "checkam", "cksnum", " checksume", "checksup", " checksumm", "cksam", "readsume", "checksums"], "entry": ["package", "row", "class", "next", "event", "part", "connection", "extra", "parse", "cell", "info", "data", "line", "install", "reader", "ent", "image", "ge", "type", "import", "member", "name", "table", "object", "end", "valid", "ger", "write", "component", "code", "escape", "add", "try", "element", "feed", "expected", "ie", "offset", "lc", "e", "result", "way", "entity", "new", "her", "or", "comment", "module", "byte", "si", "loader", "service", "enter", "error", "insert", "archive", "ries", "ry", "sec", "command", "view", "writer", "inc", "engine", "export", "ue", "cache", "diff", "inner", "cue", "index", "source", "match", "se", "parser", "Entry", "array", "server", "record", "value", "zero"], "file": ["part", "message", "connection", "buffer", "path", "info", "use", "data", "pool", "line", "rule", "from", "image", "ge", "l", "this", "format", "type", "letter", "ile", "name", "binary", "table", "phase", "ul", "end", "item", "db", "handler", "fp", "dir", "unit", "filename", "set", "File", "child", "feed", "files", "offset", "lane", "time", "queue", "f", "model", "per", "full", "play", "le", "comment", "el", "module", "service", "length", "page", "up", "folder", "resource", "count", "port", "limit", "il", "cache", "change", "content", "index", "single", "source", "read", "len", "parent", "block", "base", "url", "value"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->internal->thread_ctx;\n\n    FrameThreadContext *fctx;\n\n    AVFrame *dst, *tmp;\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                          avctx->thread_safe_callbacks                   ||\n\n                          (\n\n#if FF_API_GET_BUFFER\n\n                           !avctx->get_buffer &&\n\n#endif\n\n                           avctx->get_buffer2 == avcodec_default_get_buffer2);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    if (!f->f->buf[0])\n\n        return;\n\n\n\n    if (avctx->debug & FF_DEBUG_BUFFERS)\n\n        av_log(avctx, AV_LOG_DEBUG, \"thread_release_buffer called on pic %p\\n\", f);\n\n\n\n    av_buffer_unref(&f->progress);\n\n    f->owner    = NULL;\n\n\n\n    if (can_direct_free) {\n\n        av_frame_unref(f->f);\n\n        return;\n\n    }\n\n\n\n    fctx = p->parent;\n\n    pthread_mutex_lock(&fctx->buffer_mutex);\n\n\n\n    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))\n\n        goto fail;\n\n    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,\n\n                          (p->num_released_buffers + 1) *\n\n                          sizeof(*p->released_buffers));\n\n    if (!tmp)\n\n        goto fail;\n\n    p->released_buffers = tmp;\n\n\n\n    dst = &p->released_buffers[p->num_released_buffers];\n\n    av_frame_move_ref(dst, f->f);\n\n\n\n    p->num_released_buffers++;\n\n\n\nfail:\n\n    pthread_mutex_unlock(&fctx->buffer_mutex);\n\n}\n", "idx": 22503, "substitutes": {"avctx": ["abcmp", "avecu", "axctx", "aveca", "devcontext", "AVcf", "aveconfig", "AVconfig", "AVcmp", "afca", "afcf", "ajcontext", "devcmp", "avhw", "axcontext", "afctl", "avcal", "afcmp", "avconn", "AVcal", "avconfig", "afhw", "afctx", "afconv", "AVcontext", "avecmp", "evcontext", "AVcu", "devcf", "avcf", "aycontext", "avehw", "avconv", "avca", "evcu", "avectl", "ayctx", "axca", "aycu", "avecontext", "avlc", "afcu", "ajcal", "avelc", "avcu", "avcontext", "devctx", "avctl", "abctx", "AVconn", "evconv", "ajconn", "AVlc", "ajcu", "axctl", "afcal", "ajconv", "evctx", "afconfig", "ayctl", "avectx", "avcmp", "abcontext", "ajctx", "afcontext", "AVctx", "afconn", "abhw", "aflc"], "f": ["fa", "of", "fc", "i", "uf", "e", "fac", "ref", "fs", "g", "fb", "framework", "d", "file", "rf", "fp", "function", "df", "exec", "t", "u", "info", "m", "s", "r", "j", "cache", "full", "new", "cf", "fx", "inf", "q", "af", "ext", "c", "fe", "frame", "fr", "tf", "form", "b", "x", "w", "fm", "ff", "fl", "fd", "F", "fw", "flow", "sf", "k", "feed", "parent", "bf", "v", "fen", "conf", "fn", "h", "l", "fi", "fo", "interface", "elf"], "p": ["pb", "after", "i", "e", "ap", "app", "jp", "lp", "g", "pe", "part", "pkg", "post", "d", "pm", "parse", "P", "cop", "bp", "pc", "l", "fp", "pg", "po", "per", "t", "pre", "u", "r", "m", "cp", "op", "j", "cache", "tp", "s", "pp", "patch", "point", "o", "np", "q", "c", "ctx", "self", "pr", "wp", "b", "w", "n", "br", "ps", "parent", "v", "up", "http", "sp", "vp", "h", "pi", "api", "this", "k", "pa"], "fctx": ["frctrl", "ifca", "pcmp", "fctrl", "Fcf", "cfcontext", "flowcmp", "afca", "afcf", "fca", "fxtx", "frcontext", "Fctx", "fcmp", "frctx", "afctx", "cfsci", "ifcontext", "Fcb", "cfctx", "cfctrl", "psci", " fcontext", "fcb", "flowcontext", "Ftx", "fsci", "Fcontext", "ftx", "fxcb", "pctx", "flowctx", "cfcmp", "fcf", "afcontext", "pctrl", "pcontext", " fcb", "flowsci", "frcmp", "fxcontext", "fcontext", " ftx", "ifctx", "Fca", "ifcf", "fxctx"], "dst": ["Dst", "lst", " dST", "dedST", " dost", "dedost", "rdfe", "dedsts", "hdset", "hdstore", "lost", "dST", "dsrc", "dstore", "hdst", "Dsrc", "dost", "ddput", "dfe", "lST", "dsts", " dfe", "adput", "ddset", "rdst", "dedst", "hdput", "rdsrc", "adset", "Dfe", "adst", "dset", "Dsts", "rdsts", " dsts", " dsrc", "dput", "lsts", "ddst", "ddstore", "adstore"], "tmp": ["pb", "sb", "txt", "obj", "err", "jp", "vt", "result", "part", "pkg", "fb", "copy", "tt", "bb", "temp", "pad", "img", "fp", "emp", "pos", "fake", "cmp", "t", "pre", "acc", "cp", "j", "cache", "tp", "bug", "data", "bt", "zip", "diff", "tc", "Temp", "buf", "kk", "cb", "wp", "tf", "mp", "beta", "b", "ptr", "now", "cpp", "stuff", "vv", "fd", "src", "sup", "slice", "test", "loc", "nb", "boot", "proc", "v", "bf", "nt", "sp", "rb", "dest", "buff", "su", "output", "attr", "mmm"], "num_released_buffers": ["num_released_buffores", "num_released_Buffests", "num_released_codests", "num_released_buffants", "num_released_buckants", "num_releasedingbufferc", "num_released_buffERS", "num_releaseditycodeners", "num_released_comperc", "num_releaseditycoders", "num_released_buckers", "num_released_bufores", "num_released_bufters", "num_released_compERS", "num_released_buckerc", "num_released_fundters", "num_releasedingbuckerc", "num_released_coder", "num_released_buffeners", "num_released_bufERS", "num_released_compers", "num_released_ufers", "num_released_scribants", "num_releasedingbuffers", "num_released_funders", "num_released_counterc", "num_released_countensions", "num_releaseditycodests", "num_released_Buffers", "num_released_Bufferers", "num_released_Bufferc", "num_released_bufferers", "num_released_Buffer", "num_released_buterers", "num_releasedingbuffants", "num_released_codeners", "num_releaseditybuffests", "num_releaseditybuffers", "num_released_buffests", "num_released_calleners", "num_released_scribensions", "num_releaseditybuffer", "num_released_caller", "num_released_ufters", "num_released_buffensions", "num_released_fundores", "num_released_ufERS", "num_released_BuffERS", "num_released_Buffeners", "num_releasedingbuckants", "num_released_buffer", "num_released_countants", "num_releasedingbuffensions", "num_released_ufores", "num_releasedingbuckensions", "num_releasedingbuckers", "num_released_coders", "num_released_buterc", "num_released_comperers", "num_released_scriberc", "num_released_buters", "num_released_buffters", "num_released_fundERS", "num_released_callers", "num_released_scribers", "num_releaseditybuffeners", "num_released_callests", "num_released_counters", "num_released_bufferc", "num_released_bufers", "num_released_buckensions", "num_releaseditycoder", "num_released_butERS"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n", "idx": 22531, "substitutes": {"queue": ["status", "route", "port", "Queue", "event", "config", "thread", "menu", "loop", "progress", "message", "file", "plugin", "buffer", "pipe", "model", "entry", "ue", "sequence", "cache", "list", "job", "p", "prefix", "que", "q", "sync", "client", "pool", "module", "complete", "collection", "future", "priority", "line", "flag", "seq", "worker", "channel", "qa", "page", "batch", "lib", "manager", "user", "group", "server", "command"], "free_func": ["free2lambda", " free_dc", " free_function", "free2pc", "freefunccb", "free_function", "free__dc", "free_cb", "free__func", " free_lambda", "free_dc", "free__cb", "free2function", " free_pc", "free__function", "freefuncdc", "free_pc", "freefuncfunction", " free_cb", "free_lambda", "freefuncfunc", "free2func"]}}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534, "substitutes": {}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n", "idx": 22545, "substitutes": {"val": ["reg", "expr", "sel", "def", "ref", "sl", "valid", "ind", "il", "ay", "func", "ol", "al", "data", "vals", "unit", "count", "slot", "el", "index", "cal", "min", "vol", "len", "loc", "VAL", "Val", "v", "alt", "sec", "all", "eval", "pt", "base", "value"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 22552, "substitutes": {"dc": ["lc", "bc", "fc", "cc", "cd", "disc", "uc", "conn", "ct", "config", "input", "inc", "db", "cm", "d", "DC", "pc", "ds", "ea", "df", "exec", "nc", "ac", "ga", "cmd", "da", "design", "enc", "mc", "cf", "tc", "context", "mac", "rc", "c", "dr", "source", "sc", "dt", "du", "gui", "draw", "ic", "dm", "gc", "enter", "desc", "fd", "cdn", "loc", "cca", "jc", "di", "doc", "dat", "oc", "dp", "ec", " DC", "vc"], "t0": [" T1", "tt0", "p50", " t8", "f2", "t1", "T2", "p0", " t50", "t2", "t50", "ta4", "t8", "T1", "f0", "p4", "f1", " Tfe", " t1", "t4", "tt8", "tt2", "p1", "t25", " T0", "ta8", " t25", "ta1", " t4", "tt25", "Tfe", "T50", "tt4", "T0", "tfe", "T25", " tfe", " t2", "ta0", "T4", "tt1"]}}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "AVInputFormat *av_find_input_format(const char *short_name)\n\n{\n\n    AVInputFormat *fmt = NULL;\n\n    while ((fmt = av_iformat_next(fmt)))\n\n        if (match_format(short_name, fmt->name))\n\n            return fmt;\n\n    return NULL;\n\n}\n", "idx": 22559, "substitutes": {"short_name": ["Short_path", "shortPpath", "Short_Name", "Short_NAME", "short_Name", "short2names", "short2name", "short_names", "short_NAME", "shortFnames", "shortPName", "shortFpath", "short2NAME", "shortnameNAME", "short2size", "Short_names", "Short_size", "shortPnames", "short_size", "shortPname", "shortnamesize", "Short_name", "short_path", "shortFname", "shortnamename", "shortFName", "shortnamenames"], "fmt": ["Fatter", "Fbf", "compatter", " flt", "fatt", "complt", "formmd", "bmt", "blt", " fbf", "bpl", " fatter", "Fpr", "Flt", " fmd", "formnt", "frnt", " fMT", "Fnt", "compmt", "tfmt", "fatter", "Fpl", "tfmd", "compbf", "fbf", " fnt", "fMT", "fpl", "formlt", "ufpl", "Fmd", "fpr", "frlt", "fmd", "fnt", "tfatt", "frmt", "tflt", " fatt", "Fmt", "tfMT", "ufmt", "formmt", "FMT", "ufpr", "tfnt", "frmd", "flt", "uflt", "Fatt", "bpr"]}}
{"project": "FFmpeg", "commit_id": "b791a0831b0a027e7ba4eb6961cc0180472ac603", "target": 1, "func": "static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,\n\n                                      int mm_flags)\n\n{\n\n#if HAVE_SSE2_INLINE\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {\n\n        c->idct_put              = ff_idct_xvid_sse2_put;\n\n        c->idct_add              = ff_idct_xvid_sse2_add;\n\n        c->idct                  = ff_idct_xvid_sse2;\n\n        c->idct_permutation_type = FF_SSE2_IDCT_PERM;\n\n    }\n\n#endif /* HAVE_SSE2_INLINE */\n\n\n\n#if HAVE_SSE2_EXTERNAL\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;\n\n    if (mm_flags & AV_CPU_FLAG_ATOM) {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;\n\n    } else {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_sse2;\n\n    }\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_sse2;\n\n    } else if (!(mm_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        c->apply_window_int16 = ff_apply_window_int16_round_sse2;\n\n    }\n\n    c->bswap_buf = ff_bswap32_buf_sse2;\n\n#endif /* HAVE_SSE2_EXTERNAL */\n\n}\n", "idx": 22597, "substitutes": {"c": ["lc", "bc", "fc", "cd", "cc", "e", "uc", "ct", "config", "g", "this", "coll", "cv", "cm", "d", "con", "ca", "pc", "cur", "l", "cu", "f", "ci", "cmp", "t", "u", "ac", "cp", "nc", "s", "m", "cache", "r", "p", "mc", "cf", "cs", "enc", "xc", "tc", "ctrl", "o", "ctx", "self", "sc", "ch", "a", "b", "dc", "w", "cy", "cr", "n", "call", "C", "co", "v", "conf", "ce", "h", "oc", "x", "ec", "k", "vc"], "avctx": ["aveca", "AVcmp", "awcontext", "afca", "AVcmd", "afcmp", "awcmp", "avconn", "evconn", "afcmd", "afctx", "AVcontext", "avecmp", "evcontext", "AVca", "avca", "afloc", " avcmp", "avecontext", "awctx", "avcontext", "AVconn", "evcmp", " avloc", "evctx", "avectx", "avcmp", "avcmd", "afcontext", "AVctx", "afconn", " avcontext", "AVloc", "awcmd", "avloc"], "mm_flags": ["ml_includes", "mmptones", "mm_groups", "mmpflags", "cmdamflags", "cmdamrules", "cmd_alls", "cmd_lists", "mmpgroups", "mm_rules", "mm_tones", "mmamrules", "cmdamlists", "mmamalls", "ml_planes", "mmamlists", "mm_alls", "mmamflags", "mm_planes", "cmd_rules", "mmacflags", " mm_tones", "mmacfields", "cmdamalls", "cmd_flags", "mmacincludes", "ml_flags", "ml_fields", "mm_includes", "mm_lists", "mmacplanes", "mm_fields", " mm_groups"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int au_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 24)\n\n        return 0;\n\n    if (p->buf[0] == '.' && p->buf[1] == 's' &&\n\n        p->buf[2] == 'n' && p->buf[3] == 'd')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 22601, "substitutes": {"p": ["pb", "i", "e", "prev", "ap", "jp", "lp", "g", "exec", "progress", "pe", "post", "d", "P", "bp", "pc", "fp", "f", "per", "t", "op", "r", "u", "m", "cp", "pre", "data", "j", "tp", "it", "pp", "ip", "at", "current", "o", "np", "c", "wp", "a", "b", "comp", "n", "parser", "ps", "http", "up", "sp", "vp", "l", "api", "k", "pa"]}}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615, "substitutes": {"opts": [" optt", "opments", "OPta", "opcs", "otta", "OPts", "operts", "otments", " opats", "OPcs", " opt", "opta", "operta", "opttes", "opt", " opcs", "optments", " optats", " optcs", "opTS", "operTS", " optts", " opTS", "opttt", "otts", "ottes", "optt", "optats", "optes", " opta", "OPt", "optTS", " optes", "opats", "optcs", " opments", "optta", " optments", "optts", "opertt"], "machine": ["computer", "name", "object", "app", "controller", "project", "message", "connection", "mode", "file", "handler", "plugin", "company", "engine", "node", "device", "mobile", "model", "host", "builder", "slave", "info", "m", "bug", "mc", "oper", "mac", "record", "module", "source", "money", "b", "office", "loader", "service", "rule", "window", "mage", "session", "media", "division", "editor", "element", "database", "parent", "boot", "template", "manager", "vm", "user", "instance", "folder", "image", "Machine", "server", "base", "interface", "creator"], "filename": ["package", "name", "binary", "txt", "password", "download", "il", "message", "utf", "file", "metadata", "phrase", "fax", "fp", "mpeg", "f", "path", "original", "sequence", "full", "nil", "wl", "kl", "prefix", "sheet", "directory", "word", "kn", "buf", "title", "document", "ema", "b", "rl", "location", "fd", "length", "sf", "jpg", "dll", "database", "ppa", "bf", "fil", "fn", "SourceFile", "username", "files", "folder", "l", "Filename", "url"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,\n\n                        int *duration)\n\n{\n\n    int64_t out_pts = AV_NOPTS_VALUE;\n\n    int removed_samples = 0;\n\n\n\n#ifdef DEBUG\n\n    ff_af_queue_log_state(afq);\n\n#endif\n\n\n\n    /* get output pts from the next frame or generated pts */\n\n    if (afq->frame_queue) {\n\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n\n    } else {\n\n        if (afq->next_pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->next_pts - afq->remaining_delay;\n\n    }\n\n    if (pts) {\n\n        if (out_pts != AV_NOPTS_VALUE)\n\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n\n        else\n\n            *pts = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n\n       for the output packet and leave all frames in the queue */\n\n    if (afq->remaining_delay >= nb_samples) {\n\n        removed_samples      += nb_samples;\n\n        afq->remaining_delay -= nb_samples;\n\n    }\n\n    /* remove frames from the queue until we have enough to cover the\n\n       requested number of samples or until the queue is empty */\n\n    while (removed_samples < nb_samples && afq->frame_queue) {\n\n        removed_samples += afq->frame_queue->duration;\n\n        delete_next_frame(afq);\n\n    }\n\n    afq->remaining_samples -= removed_samples;\n\n\n\n    /* if there are no frames left and we have room for more samples, use\n\n       any remaining delay samples */\n\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n\n        int add_samples = FFMIN(afq->remaining_samples,\n\n                                nb_samples - removed_samples);\n\n        removed_samples        += add_samples;\n\n        afq->remaining_samples -= add_samples;\n\n    }\n\n    if (removed_samples > nb_samples)\n\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n\n    if (duration)\n\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n\n}\n", "idx": 22637, "substitutes": {"afq": ["offqs", "avqa", "aphsq", "affcl", "avqs", "afg", "auxk", "ajQ", " afquest", "ufque", "efqa", "abq", "affqa", "aup", "avz", "phz", "abqa", "affsq", "ajq", "afsq", "affque", "afiqt", "awcl", " afk", "efq", "affqi", "cfq", "rafq", "alfqu", "afiqs", "awsq", "awqi", "afcle", "afiq", "abz", "efcle", " afg", "avct", "faque", "alfq", "awk", "avq", "phq", "avQ", "affkg", "ajk", "cfk", "affz", "phqu", "ufkg", "affct", "cfg", "rafqa", "phqa", "alfk", "aphq", "aphk", "avk", "awqs", "affw", "afp", "alfQ", "offq", "alfg", "alfcl", "afqu", "affq", " afck", "ajqi", "cfqa", "afqs", "awqa", "afqa", "auqt", "awck", " afkg", "rafqs", "affg", "affp", "auqs", " afqa", "awquest", "afct", "afQ", "afqt", "auxcle", " afque", "afck", "avck", "afque", "awQ", "auquest", "alfquest", "awg", "faw", "efk", "afiqu", "ajquest", "rafw", " afQ", "offqa", "affQ", "avw", "awqu", "afkg", "ufck", "aww", "faqs", "auct", "aphquest", "avqt", "affqu", "ajg", "ajp", "avcl", "awq", "affck", "affk", "affquest", "aucl", "afcl", "ajqs", "alfck", "affqt", "auk", "afw", "abqu", "rafque", "faq", "afk", " afqs", "auxq", "affcle", "alfqa", "offque", "ufq", "auxqa", "afz", "afquest", " afsq", "auq", " afz", "faqa", "awz", "ajqt", "avqu", "ajsq", "awqt", "affqs", "afqi"], "nb_samples": ["nb_tsipes", "nb_nocks", "nb_vamples", "nb_sourses", "nb_tummies", "nb_inspects", "nb_sessions", "nb_svamps", "nb7timesamples", "nb25outsances", "nb7samples", "nb_eventsalls", "nb_sickets", "nb_nourses", "nb_tsickets", "nb_timesims", "nb_npects", "nb_svpects", "nb_sources", "nb_nources", "nb_insummies", "nb_insamps", "nb_psamps", "nb_seubs", "nb_syspects", "nb_nimens", "nb_spects", "nb_insippers", "nb_namps", "nb_timesamples", "nb_vipes", "nb_nipes", "nb_vickets", "nb_samps", "nb_tsamples", "nb7sipes", "nb_specalls", "nb_namples", "nb7socks", "nb_vourses", "nb_ssources", "nb_seipes", "nb_tippers", "nb_sipes", "nb_outsamples", "nb7timesocks", "nb_compipes", "nb7timesipes", "nb_svamples", "nb_nalls", "nb_timesocks", "nb_summies", "nb_ssances", "nb_eventsamples", "nb_insamples", "nb25samples", "nb_sippers", "nb_sysances", "nb_ssubs", "nb_insimens", "nb_outspects", "nb_eventsources", "nb_compims", "nb_scamps", "nb_scamples", "nb_tsourses", "nb_eventsessions", "nb_psances", "nb_psamples", "nb_ssipes", "nb7sims", "nb25outsamples", "nb25outsipes", "nb25outspects", "nb_timesipes", "nb_nickets", "nb_tipes", "nb_nims", "nb_subs", "nb_svimens", "nb_sances", "nb_compocks", "nb_tamples", "nb_sysamples", "nb_specamples", "nb_socks", "nb25sances", "nb_seamples", "nb_outsipes", "nb_ssamples", "nb_sims", "nb_tamps", "nb7timesims", "nb_specources", "nb_psources", "nb_solutions", "nb_nessions", "nb_scippers", "nb25sipes", "nb_salls", "nb_outsances", "nb_tolutions", "nb_ssolutions", "nb_ssamps", "nb_nances", "nb_compamples", "nb_seolutions", "nb_specessions", "nb_scummies", "nb_tubs", "nb25spects", "nb_simens", "nb_sysipes"], "pts": ["ptsk", "iptds", "prds", "ctns", "ctsk", "ptss", "lls", "cold", "ctn", "aptsum", "cts", "roundns", "xtd", "ptn", "txss", "prs", "txd", "empts", "emptd", "prsid", "roundd", "ptsets", "ipts", "iptsum", "ptns", "ptsum", "ptd", "txs", "xtss", "aptd", "rounds", "prd", "colsets", "lld", "emptsk", "ptds", "iptd", "iptsid", "iptn", "lln", "colsid", "iptns", "ctd", "cols", "xts", "prsk", "iptsets", "prsum", "roundn", "aptds", "apts", "ptsid", "iptss", "prsets"], "duration": ["span", "delay", "period", "phase", "timer", "until", "amount", "age", "time", "seconds", "d", "pause", "pad", "term", "series", "address", "fee", "rate", "sequence", "description", "Duration", "videos", "version", "unit", "depth", "timeout", "memory", "later", "audio", "lag", "document", "distance", "direction", "window", "date", "runtime", "length", "grade", "angle", "doc", "range", "stage", "volume", "frequency", "gap", "sleep", "repeat", "video", "type"]}}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "lb", "bis", "ba", "fs", "ses", "db", "fb", "bb", "bid", "ds", "bing", "fps", "bas", "os", "vs", "cs", "ls", "bi", "sync", "bps", "stats", "js", "ib", "b", "blocks", "src", "ns", "BS", "ps", "rs", "gs", "bh", "rb", "ss", "las"], "base": ["status", "bc", "sb", "name", "binary", "start", "area", "e", "sl", "chain", "db", "file", "bb", "site", "build", "bid", "Base", "local", "buffer", "f", "builder", "proxy", "address", "bas", "cache", "state", "based", "p", "id", "prefix", "work", "body", "sync", "client", "c", "ctx", "pool", "source", "family", "b", "core", "root", "parent", "back", "server", "ase", "url", "type"], "base_id": ["baseacid", "file_path", "baseipid", "file_id", "baseacsource", "baseacids", "file_size", "base_name", "baseamid", "base_offset", "base_source", "baseamoffset", "base_ids", "file_ids", "baseamnum", "base_path", "baseipids", "baseamids", "baseipnum", "base_num", "baseipoffset", "base_size", "file_source", "baseacname", "file_offset", "file_name", "file_num"], "speed": ["status", "sb", "peed", "Speed", "start", "sk", "sl", "scale", "driver", "cost", "mode", "css", "engine", "weight", "fast", "rate", "size", "state", "ssl", "score", "ace", "sync", "ss", "spec", "sm", "source", "si", "sc", " speeds", "service", "gc", "src", "length", "slice", "sf", "ism", "sp", "stream", "sn", "url", "type"], "cb": ["bc", "pb", "fc", "sb", "cd", "cc", "cor", "db", "cv", "unc", "fb", "func", "bb", "pc", "function", "f", "ci", "cmd", "cp", "ob", "cf", "cs", "tc", "cow", "c", "CB", "ctx", "b", "Callback", "core", "callback", "buff", "bf", "conf", "rb", "cod", "cgi", "ec", "fun"], "opaque": ["operacity", "opaques", "operaque", "copaques", " opaco", "paco", "ipacity", "ipaque", " opac", "copaque", "opaco", " opaques", "compaque", "ipac", "pacity", "opacity", "opac", " opacity", "copacity", "pac", "compaques", "operac", " opcode", "compacity", "paque", "ipcode", "pcode", "opcode", "operaco"], "errp": ["errps", "err", "ierpa", "isepc", "ierp", " errpc", "oeps", "errpc", "isepa", "errpa", "errP", "oepa", "ierP", " errps", " errpa", "iseps", "ierr", "oepc", " errP", "erpa", "erp", "errr", "erP", "oep", "isep", " errr"], "s": ["sb", "e", "sym", "es", "sk", "sl", "hs", "g", "ses", "coll", "ops", "ks", "so", "ds", "services", "l", "css", "f", "sys", "r", "m", "state", "os", "ssl", "p", "cs", "ts", "us", "ls", "o", "sync", "is", "sa", "sg", "c", "js", "spec", "sq", "sh", "si", "sc", "b", "se", "n", "S", "ns", "sup", "ps", "rs", "gs", "ins", "http", "v", "sn", "su", "ss"], "co": ["lc", "bc", "cc", "cross", "oo", " Co", "oe", "coll", "cm", "con", "ca", "pc", "company", "cur", "so", "ci", "ro", "po", "can", "mo", "cache", "ico", "mc", "xc", "cf", "oper", "o", "cs", "que", "code", "coe", "c", "rc", "aco", "Co", "go", "bo", "loc", "cca", "cus", "CO", "ko", "ce", "ck", "oc", "cu"]}}
{"project": "FFmpeg", "commit_id": "2711cb28f46463760f0326d806fe5ef9551ade2c", "target": 1, "func": "static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){\n\n    RateControlContext *rcc= &s->rc_context;\n\n    AVCodecContext *a= s->avctx;\n\n    const int pict_type= rce->new_pict_type;\n\n    const double last_p_q    = rcc->last_qscale_for[P_TYPE];\n\n    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];\n\n\n\n    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))\n\n        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;\n\n    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)\n\n        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;\n\n\n\n\n    /* last qscale / qdiff stuff */\n\n    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){\n\n        double last_q= rcc->last_qscale_for[pict_type];\n\n        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;\n\n\n\n        if     (q > last_q + maxdiff) q= last_q + maxdiff;\n\n        else if(q < last_q - maxdiff) q= last_q - maxdiff;\n\n    }\n\n\n\n    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring\n\n\n\n    if(pict_type!=B_TYPE)\n\n        rcc->last_non_b_pict_type= pict_type;\n\n\n\n    return q;\n\n}", "idx": 22655, "substitutes": {"s": ["sv", "sb", "i", "e", "sed", "qs", "es", "sl", "g", "ses", "d", "sis", "sets", "ds", "services", "f", "sys", "t", "r", "u", "m", "ssl", "os", "p", "cs", "ts", "o", "ss", "sa", "sg", "c", "js", "self", "spec", "si", "sc", "b", "w", "service", "session", "S", "ns", "n", "sf", "south", "sec", "su", "sq"], "rce": ["rcing", " rge", "rtge", "srce", "prces", "rtce", "rfe", " rfe", "rtcing", "srces", " rcing", "rtces", " rces", "arge", "srge", "arces", "srcing", "rces", "arfe", "prce", "prfe", "rge", "prge", "arce"], "q": ["view", "i", "e", "query", "qs", "eq", "qi", "quit", "g", "val", "Q", "force", "d", "qv", "qq", "l", "charge", "f", "y", "t", "u", "m", "ue", "qu", "bug", "um", "aq", "quality", "p", "id", "change", "max", "o", "load", "sync", "quick", "comment", "c", "sh", "check", "ch", "dq", "question", "value", "quant", "quest", "qa", "error", "length", "iq", "req", "z", "qt", "ce", "v", "ck", "h", "qual", "quad", "x", "sq", "k", "count"], "rcc": ["srpc", "ercd", "prrc", " racc", "rbc", "ircc", "ecca", "rbpc", "srbc", "ircca", "Rcd", "arrc", "srcca", "srco", "brcca", "rbce", "srrc", "racc", " rbc", "rcd", "Rck", "rco", "Ruc", "arcca", "fracc", "rrck", "pruc", "rrcd", "fruc", "rrc", " rpc", "luc", "prck", "arcc", "ercc", "rck", " ruc", "brcc", "rrcc", "aruc", "rscc", "rrce", "erck", "prco", "erce", "rsck", "rpc", "frcc", "rbuc", "arpc", "bruc", "rcca", "duc", "Rpc", "errc", "eruc", "prpc", "lcca", "frcca", "eacc", "dck", "dcc", "irbc", "lcc", "ecc", "arck", "arco", "rsacc", "Rce", "pracc", "bracc", " rcca", "iruc", "euc", "prcca", "sruc", "prcc", "dacc", "rbcc", "lck", "dcca", "Rcc", "srcc", "ruc", "rsuc", "erpc"], "a": ["mA", "ana", "cha", "aaa", "i", "ya", "e", "area", "ia", "ba", "app", "fac", "another", "wa", "ha", "this", "ao", "ack", "oa", "A", "ca", "as", "access", "ora", "ea", "f", "ata", "y", "ac", "ga", "u", "args", "ad", "da", "p", "na", "am", "sa", "la", "c", "aj", "index", "au", "ar", "b", "w", "ua", "va", "ai", "aa", "parser", "ab", "aka", "ae", "alpha", "ma", "api", "sta", "an", "pa", "ama"]}}
{"project": "FFmpeg", "commit_id": "67400f6b6219892ab7a555fb61ef979c857692d7", "target": 0, "func": "static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n\n    int64_t pos = avio_tell(pb);\n\n\n\n    if (!track) { /* no media --> data handler */\n\n        hdlr      = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr     = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr     = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            hdlr_type = \"soun\";\n\n            descr     = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = \"sbtl\";\n\n            else                                      hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {\n\n            hdlr_type = \"hint\";\n\n            descr     = \"HintHandler\";\n\n        }\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"hdlr\");\n\n    avio_wb32(pb, 0); /* Version & flags */\n\n    avio_write(pb, hdlr, 4); /* handler */\n\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track || track->mode == MODE_MOV)\n\n        avio_w8(pb, strlen(descr)); /* pascal string */\n\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n\n    if (track && track->mode != MODE_MOV)\n\n        avio_w8(pb, 0); /* c string */\n\n    return update_size(pb, pos);\n\n}\n", "idx": 22662, "substitutes": {"pb": ["td", "bc", "platform", "sb", "uf", "hp", "bos", "lb", "fc", "prop", "jp", "lp", "amp", "bj", "prot", "pkg", "db", "fb", "pm", "pd", "bp", "pc", "fp", "pg", "gb", "eb", "lab", "cp", "PB", "tp", "aph", "pp", "p", "tc", "wb", "bps", "py", "ctx", "cb", "pl", "pro", "wp", "mp", "b", "cpp", "tmp", "hub", "bm", "bf", "proc", "bh", "bs", "vp", "rb", "xb", "api", "pt", "dp", "ppa", "bsp", "pa", "pub"], "track": ["step", "row", "event", "road", "progress", "post", "sound", "trial", "rack", "tp", "seek", "test", "task", "gap", "type", "route", "cost", "coll", "ack", "bb", "tt", "tick", "trans", "strip", "audio", "wp", "add", "tracking", "transform", "mode", "metadata", "token", "Track", "layer", "t", "roll", "round", "gro", "play", "tc", "comment", "check", "form", "call", "trace", "stage", "tm", "note", "jump", "port", "hop", "project", "song", "tr", "rr", "cur", "follow", "ACK", "tab", "gg", "sync", "dr", "tag", "match", "run", "session", "ogg", "skip", "report", "tracks", "ck", "sort", "record"], "hdlr": ["vdlr", "hdrl", "pdrf", "hidler", "mdll", "hdlc", "hdrel", "hidll", "vdrel", "hidrepl", "wdler", "adhll", "mdlr", "hdsr", "wdrl", "vdrn", "mdlc", "mdrl", "wdsr", "pdrl", "hidlc", "adhlr", "adhlc", "hidrel", "vdsr", "adhrl", "hidsr", "vdler", "hidrf", "hdll", "hdrn", "wdlr", "adhrepl", "pdrn", "adhrel", "hidlr", "hidrl", "hdrf", "hidrn", "hdler", "vdrf", "pdlr", "hdrepl", "vdrepl", "vdrl"], "descr": ["accrr", "structr", " descrs", "Descar", " descrin", "testrs", "structrs", "structrin", "prirr", "defl", "discar", "descR", "descriptionrin", "descres", "ascrin", "accerr", "declr", "testar", "accrs", " descR", "defrs", "Descl", "decll", "pririn", "declry", "escr", "neglr", "descrs", "defR", "defr", "structerr", "desterr", "descry", "declrin", "testR", "prierr", "escerr", "descrin", "descrr", "descriptionres", "accr", "declrs", "esclr", " desclr", "escres", "destr", "depr", "DescR", "discR", "descar", "escrin", "escrr", "discr", "declR", "negr", "negrs", " descrr", "Descrs", "descriptionrs", "escrs", "escR", "descrt", "ascr", "descriptionl", "deprs", "ascl", "deperr", "descerr", "deprr", "destrr", " descerr", "declres", " descrt", "prir", "Descr", " descl", "descriptionR", "destrin", "descriptionr", "ascry", "escrt", "descl", "descriptionry", "negrt", "testr", "desclr", "discrs"], "hdlr_type": ["hdrl_key", "hdlr_types", "hdLR_types", "hdrl_time", "hdlr__id", "hdlr_name", "hdlr__type", "hdril_ty", "hdrl_type", "hdlr_val", "hdlr_id", "hdlr_time", "hdrl_types", "hdLR_block", "hdlrJkey", "hdlrJtime", "hdlr_rel", "hdLR_type", "hdlr_Type", "hdlr__name", "hdrl_TYPE", "hdlrJtype", "hdlr_TYPE", "hdlr_ref", "hdlr__block", "hdlr_key", "hdril_type", "hdrl_Type", "hdrl_ty", "hdler_name", "hdlrJname", "hdriter_TYPE", "hdriter_val", "hdril_ref", "hdler_type", "hdriter_type", "hdrl_var", "hdlr_ty", "hdler_id", "hdlr_style", "hdlr__types", "hdlr_var", "hdrl_name", "hdlr__Type", "hdLR_Type", "hdrl_style", "hdlr_info", "hdler_types", "hdlr_block", "hdril_types", "hdriter_info", "hdrl_rel"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683, "substitutes": {}}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "substitutes": {"file": ["port", "place", "ile", "name", "class", "e", "txt", "binary", "config", "ban", "db", "message", "time", "key", "connection", "uri", "handler", "function", "f", "buffer", "path", "write", "model", "fp", "use", "entry", "socket", "data", "cache", "bug", "id", "code", "work", "le", "comment", "cli", "filename", "hide", "single", "source", "future", "line", "File", "call", "feed", "http", "folder", "resource", "files", "empty", "l", "base", "output", "command", "type", "letter"]}}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_probe(AVProbeData *p)\n\n{\n\n    const unsigned char *ptr = p->buf;\n\n    int i, v, num = 0;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3;  /* skip UTF-8 BOM */\n\n\n\n    while (*ptr == '\\r' || *ptr == '\\n')\n\n        ptr++;\n\n    for (i=0; i<2; i++) {\n\n        if ((num == i || num + 1 == i)\n\n            && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)\n\n            return AVPROBE_SCORE_MAX;\n\n        num = atoi(ptr);\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22702, "substitutes": {"p": ["pb", "e", "prop", "ap", "jp", "lp", "g", "d", "P", "bp", "pc", "l", "fp", "f", "t", "pre", "r", "op", "m", "cp", "s", "data", "tp", "pp", "o", "np", "c", "pro", "gp", "a", "b", "n", "ps", "proc", "pair", "pointer", "vp", "sp", "h", "pi", "pa"], "ptr": ["uint", "pe", "pad", "temp", "buffer", "pos", "alloc", "address", "data", "tp", "shift", "pl", "fr", "peer", "src", "slice", "br", "test", "proc", "pointer", "fi", "attr", "str", "push", "mount", "ctr", "eth", "fp", "sth", "ci", "code", "buf", "plug", "ext", "tch", "eger", "pair", "offset", "ref", "adr", "prot", "f", "tc", "addr", "num", "length", "fd", "inst", "loc", "req", "trace", "Ptr", "tty", "buff", "cod", "td", "port", "start", "tr", "uri", "cur", "transfer", "np", "dr", "ctx", "index", "fe", "pert", "vr", "tip", "pend", "pt", "padding"], "i": ["io", "e", "fi", "qi", "ri", "ui", "ki", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "y", "t", "u", "r", "phi", "m", "it", "j", "oi", "ip", "vi", "bi", "mi", "c", "index", "num", "si", "b", "ii", "n", "iu", "ai", "xi", "hi", "di", "z", "multi", "li", "api", "pi", "x", "zi", "k", "ni"], "v": ["sv", "e", "V", "vt", "val", "pi", "d", "temp", "f", "ci", "pos", "t", "u", "r", "m", "s", "j", "vs", "unit", "vi", "o", "c", "num", "si", "b", "ii", "w", "value", "n", "xi", "vp", "h", "l", "x", "k", "vc"]}}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 22705, "substitutes": {"s": ["sb", "i", "e", "sym", "es", "fs", "g", "ses", "d", "ds", "services", "f", "sys", "t", "u", "r", "m", "less", "state", "ssl", "os", "ts", "p", "cs", "params", "o", "sync", "is", "sg", "c", "js", "self", "spec", "sq", "b", "w", "service", "session", "S", "ns", "n", "sup", "side", "south", "ps", "gs", "rs", "v", "http", "conf", "bs", "h", "server", "su", "ss", "states"], "dev": ["Dev", "priv", "grad", "kind", "def", "serv", "conn", "app", "err", "DEV", "driver", "gu", "der", "wd", "de", "d", "cur", "engine", "prov", "device", "ds", "info", "adv", "bug", "dd", "ad", "data", "serial", "mod", "sd", "pro", "ver", "ch", "develop", "rad", "dc", "dm", "prom", "rev", "error", "test", "debug", "req", "di", "v", "conf", "user", "hw", "development", "ev", "block", "dot", "fin", "pub"], "bus": ["bc", "prev", "config", "fs", "board", "loop", "Bus", "bridge", "device", "pos", "bug", "cache", "state", "os", "data", "us", "bi", "sync", "is", "gen", "self", "pass", "sc", "b", "child", "BUS", "feed", "boot", "lib", "conf", "bs", "block", "fi"], "qdev": ["qdevice", "iqdev", "pdebug", "qqgu", "qdebug", "qdiv", "pdevice", "cdevice", "eqdev", "cdev", "dqdevice", " qdebug", " qdevice", "dqdiv", "qgu", "ddevice", "wdevice", "ddev", "eqdie", "qbus", "iqdiv", "qprom", "eqgu", "qqdie", "iqdevice", "dqbus", "iqbus", "wdev", "cdie", "qqdev", "eqdevice", "pprom", "sqdevice", "sqprom", "cgu", "pdiv", "dqdev", "wdebug", "qdie", "pbus", "qqdevice", "dprom", "sqdev"], "next": ["step", "prev", "start", "bis", "config", "result", " Next", "follow", "device", "done", "pos", "path", "data", "sequence", "state", "new", "last", "current", "version", "link", "code", "sync", "success", "gen", "Next", "second", "future", "sub", "first", "reply", "seq", "error", "child", "iterator", "flow", "then", "proc", "ner", "parent", "sec", "dot", "server"], "pdev": ["lpdev", "ppriv", "pev", "ppdevice", "qdevice", "lpdem", "lpdevice", "qev", " pdem", " ppriv", "qDev", "prad", " pdevice", "pdevice", "cdevice", " prad", "lprad", "cdev", "qdem", " pDev", "pDev", "ppev", "cev", "lpDev", "pdem", "ppdev", "lpev", "cpriv", "pppriv", " pev", "qrad"], "pc": ["lc", "bc", "pb", "fc", "arc", "cc", "cam", "conn", "ct", "amp", "pm", "con", "pd", "sys", "nc", "ac", "cp", "FC", "p", "cs", "mc", "pic", "tc", "py", "PC", "px", "c", "rc", "client", "pl", "sc", "cci", "soc", "proc", "pointer", "ec", "vc"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 22709, "substitutes": {"job": ["status", "obs", "object", "config", "project", "db", "connection", "queue", "plugin", "section", "slave", "address", "j", "lock", "work", "slot", "pool", "Job", "jobs", "run", "sea", "b", "service", "worker", "child", "flow", "feed", "lib", "manager", "image", "block", "server", "base"], "speed": ["status", "step", "port", "Speed", "peed", "limit", "plane", "shape", "sk", "level", "scale", "gain", "performance", "power", "cost", "mph", "time", "stop", "race", "weight", "rank", "slow", "rate", "size", "score", "settings", "powered", "spec", "source", "skill", "si", "capacity", "pass", "service", "error", "sw", "length", "slice", "grade", "sp", "scroll", "image", "strength", "high"], "errp": ["iterpe", " errlp", "rrP", "erpe", "erc", "derP", "rrp", " errc", "rrlp", " errpe", "errP", "derp", "rrc", "errc", "iterc", "derlp", "iterp", "errpe", "errlp", " errP", "erp", "erP", "iterP", "derc"], "s": ["e", "es", "sl", "fs", "g", "ses", "ops", "ds", "services", "f", "m", "os", "ssl", "p", "cs", "ls", "o", "sync", "is", "c", "js", "spec", "sq", "sh", "si", "b", "service", "se", "session", "S", "ns", "sw", "ps", "rs", "gs", "v", "l", "ss"]}}
{"project": "FFmpeg", "commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "target": 1, "func": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n", "idx": 22718, "substitutes": {"avctx": ["AVcmp", "avercb", "AVwcs", "afcmp", "avconn", "afctx", "AVcontext", "avercontext", "avecmp", "avwcs", "averctx", "avecontext", "avcontext", "AVconn", "AVcb", "avcb", "averwcs", "afcb", "avectx", "avcmp", "afcontext", "AVctx", "afconn", "aveconn", "afwcs"], "ctx": ["conv", "lc", "bc", "fc", "cc", "wcs", "cam", "conn", "obj", "sci", "config", "coll", "pkg", "cv", "cm", "crit", "tx", "ca", "Context", "anc", "cas", "fp", "cmp", "ci", "alloc", "nc", "cmd", "cp", "data", "cs", "cf", "xc", "ctrl", "tc", "context", "cli", "buf", "coe", "c", "cb", "cn", "la", "sq", "aux", "sc", "comp", "dc", "soc", "auc", "qa", "gc", "fw", "loc", "cca", "cus", "utils", "cms", "hw", "voc", "cu", "vc"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 22741, "substitutes": {"path": ["col", "port", "str", "name", "binary", "txt", "ath", "conn", "text", "Path", "key", "time", "file", "uri", "temp", "node", "win", "dir", "ith", "PATH", "method", "enc", "p", "id", "prefix", "filename", "c", "ctx", "pass", "alias", "loc", "root", "parent", "user", "pointer", "image", "url"], "un": ["package", "ut", "name", "unity", "en", "ul", "uc", "Un", "bind", "off", "conn", "il", "une", "an", "non", "unc", "connection", "_", "file", "null", "func", "con", "tun", "ou", "build", "node", "no", "f", "release", "other", "u", "use", "unt", "socket", "common", "new", "uno", "unit", "gen", "out", "una", "num", "run", "family", "in", "UN", "rule", "mun", "n", "loc", "unknown", "child", "update", "put", "util", "sun", "boot", "up", "uni", "user", "old", "block", "x", "url", "fun"], "sock": ["servock", "peth", "syocked", "seth", "sink", "wsvc", "oip", "pip", "saddr", "syock", "Ssocket", "svc", "wock", "hsaddr", "insib", "wsock", "servocket", " Sock", " Socks", "sib", "wsink", "hsocked", "slocked", "issink", "insock", " svc", "opensock", "slock", "socks", "hsocks", "issaddr", "pocket", "sick", "insocks", "insocket", "wick", "syvc", "syocket", "servsocket", "oocks", " Ssocket", "issick", "hseth", "ssocket", "sesvc", " socket", "hsink", "newocket", "wsaddr", "bsocket", "sesock", "Socks", "waddr", "oock", "pock", " sib", "slvc", " socks", "sesink", "hsock", "opensink", "pocks", "opensick", "hsvc", "newock", " sip", "newsocket", " Socket", "oocket", "issock", "opensaddr", "slocket", "bocket", "pocked", "Sock", "socket", "sip", "Sib", " seth", "wink", " socked", "socked", "bock", "Socket", "sesaddr"]}}
{"project": "qemu", "commit_id": "d9e0dfa2462e32cc5c6c49401ad7bff36453f75c", "target": 0, "func": "void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    Error *local_err = NULL;\n\n\n\n    memset(&bs->bl, 0, sizeof(bs->bl));\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* Default alignment based on whether driver has byte interface */\n\n    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;\n\n\n\n    /* Take some limits from the children as a default */\n\n    if (bs->file) {\n\n        bdrv_refresh_limits(bs->file->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n", "idx": 22752, "substitutes": {"bs": ["bc", "lbs", "bis", "css", "ds", "blog", "sys", "bit", "ils", "lu", "os", "bt", "ts", "cs", "us", "facebook", "js", "sels", "ms", "ns", "iss", "ab", "rs", "ins", "http", "ss", "obs", "ras", "sb", "outs", "org", "ses", "db", "boxes", "bb", "as", "bing", "bu", "web", "abi", "cb", "bits", "blocks", "BS", "bel", "utils", "banks", "lib", "bh", "bos", "lb", "qs", "ba", "fs", "fb", "bytes", "bin", "bes", "eb", "bn", "bi", "bps", "b", "ps", "gs", "bf", "bot", "las", "git", "pb", "biz", "obj", "ubs", "als", "BC", "plugins", "ks", "bid", "bl", "tails", "ros", "bas", "its", "cache", "ys", "vs", "ls", "abc", "sync", "is", "mes", "block", "base"], "errp": ["magicr", "rorps", "errps", "rorpa", "errorfp", "ersp", "err", "erpt", "rypt", " errfp", "errpt", "odersp", "magicp", "errfp", "errpa", "errP", " errps", "ryr", "errsp", "rysp", "oderr", "oderp", "magicpa", "erfp", "errorP", " errP", "ryp", "rorr", "oderpt", "erpa", "magicps", "erp", "erP", "errr", "rorp", "errorps", "erps", "errorp"], "drv": ["srv", "Drb", " drp", "Drp", "drvs", "srf", "drp", "drf", "DrV", "Drvs", "srvs", "srV", "drb", "drV", "DRf", " drb", "rtf", "drc", "hrp", "hrv", "rtV", "hrc", " drc", "rtvs", "DRc", "Drv", "hrf", "DRv", "Drf", " drf", "DRp", "hrb", "rtv"], "local_err": ["local_str", "localxlr", "foreign_late", "locallyerror", "local__err", "remote_msg", " local_er", "remote_er", "local_var", "local_late", "foreign_ctr", "localxvar", "localxerror", " local_op", "locallyer", "global_er", "local_finder", "localacer", "local_er", "remote_err", "localacerr", "global_mr", "foreign_finder", "global_str", "local_ctr", "locallyop", "local__Er", "remote_var", "localayerror", "remote_lr", "localxerr", "global_err", "local_lr", "global_error", "local_mr", " local_Er", "foreign_err", "localayerr", "local_Er", "localayvar", "localaylr", "local_op", "local__er", "local_error", "remote_error", "locallyerr", "local__str", "localacEr", "local_msg", " local_error"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n                Error *local_err = NULL;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size,\n\n                                    &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22759, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "bis", "qs", "fs", "ses", "ubs", "db", "fb", "account", "bb", "bytes", "bin", "ks", "css", "ds", "bl", "bes", "ros", "bit", "bas", "its", "os", "vs", "cs", "ts", "us", "ls", "abi", "sync", "bi", "is", "buf", "url", "js", "cb", "b", "bits", "aws", "ms", "hub", "blocks", "core", "src", "ns", "bm", "BS", "iss", "ab", "ps", "rs", "ins", "gs", "http", "bh", "bot", "fn", "base", "ss", "gb"], "res": ["reg", "ras", "def", "response", "err", "rows", "cons", "fs", "result", "val", "ress", "RES", "rem", "rx", "rep", "css", "results", "rez", "sys", "r", "args", "pers", "os", "Res", "cs", "vals", "rh", "rus", "rc", "js", "spec", "des", "pres", "reply", "rev", "re", "details", "gr", "changes", "rss", "mr", "req", "ps", "rs", "conf", "resolution", "resp", "nos"], "fix": ["status", "delay", " Fix", "prev", "def", "edit", "next", "ix", "fixes", "config", "clear", "valid", "post", "commit", "ack", "force", "apply", "get", "op", "pre", "address", "init", "cache", "bug", "final", "patch", "method", "diff", "prefix", "code", "comment", "Fix", "hack", "add", "check", "FIX", "future", "missing", "replace", "make", "re", "error", "call", "test", " prefix", "update", "reset", "conf", "pack", "correct", "x", "type"], "rebuild": ["rrun", "prebuild", "preuild", "reshuild", "reshbuild", "preupdate", "reshupdate", "refrun", "rerun", "refupdate", "reupdate", "relrun", "refbuild", "refuild", "rbuild", "precover", "recover", "reluild", "relbuild", "rupdate", "relupdate", "reshcover", "reuild", "rcover", "ruild"], "refcount_table": ["refsize_table", "refcountsfile", "refcount_type", "refcount2table", "refount_buffer", "refsizestype", "refsizestree", "refsizesfile", "refcount_tab", "refcount2tree", "refcount_tree", "refcountingbuffer", "refcountingarray", "refcountingTABLE", "refsizeingfile", "refsize_TABLE", "refount_tab", "refount_array", "refsize_tree", "refcountstype", "refcount2type", "refsize_array", "refcount_file", "refsize_type", "refcountingtable", "refcountstree", "refcount_buffer", "refsizeingtable", "refcount_TABLE", "refcount_array", "refcountingfile", "refsizestable", "refcount2file", "refcountingtab", "refsizeingarray", "refsizeingTABLE", "refcountstable", "refsize_file", "refount_table"], "nb_clusters": ["nb_CLients", "nb_claxies", "nb_clappers", "nb_sclashes", "nb_blusters", "nb_splusters", "nb_clients", "nb_lashes", "nb_locations", "nb_zaxies", "nb_lodes", "nb_CLresses", "nb_chashes", "nb_allocations", "nb_sluster", "nb_CLuster", "nb_splaxies", "nb_sclusters", "nb_splappers", "nb_scluster", "nb_clresses", "nb_alluster", "nb_CLashes", "nb_CLaxies", "nb_zusters", "nb_CLocations", "nb_CLappers", "nb_spluster", "nb_bluster", "nb_chients", "nb_clodes", "nb_cluster", "nb_clocations", "nb_blashes", "nb_chusters", "nb_blodes", "nb_chuster", "nb_slocations", "nb_luster", "nb_allresses", "nb_CLodes", "nb_sclocations", "nb_allusters", "nb_zuster", "nb_CLusters", "nb_slresses", "nb_lients", "nb_zappers", "nb_lusters", "nb_slusters", "nb_clashes", "nb_blients"], "s": ["sv", "bis", "es", "xs", "ds", "sys", "r", "os", "ssl", "ts", "cs", "us", "stats", "js", "aws", "comm", "S", "ns", "src", "details", "iss", "rs", "ins", "http", "ss", "sb", "g", "ses", "d", "sets", "site", "services", "state", "stat", "o", "c", "spec", "sc", "scope", "su", "e", "sym", "qs", "sie", "hs", "rates", "f", "p", "si", "b", "service", "parts", "sup", "ps", "gs", "secondary", "sq", "status", "sl", "m", "its", "ls", "sync", "is", "sa", "settings", "se", "session", "sp", "server", "states"], "i": ["io", "ix", "e", "start", "ie", "fi", "qi", "ui", "eni", "mini", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "y", "u", "phi", "ini", "m", "info", "j", "oi", "it", "ip", "p", "abi", "id", "ori", "bi", "o", "is", "mi", "mu", "c", "index", "ib", "si", "ii", "b", "in", "x", "n", "iu", "slice", "ai", "xi", "iter", "di", "multi", "v", "li", "pi", "base", "zi", "ski", "ni", "count"], "size": ["area", "mini", "part", "key", "temp", "ize", "fat", "address", "data", "shift", "small", "slice", "ice", "name", "ix", "security", "big", "scale", "g", "unit", "code", "body", "ext", "c", "complete", "capacity", "set", "desc", "SIZE", "empty", "sum", "e", "iz", "err", "time", "sized", "weight", "full", "zip", "new", "max", "el", "si", "form", "error", "length", "loc", "page", "sec", "count", "shape", "en", "Size", "cl", "storage", "cache", "content", "len", "sp"], "ret": ["def", "fail", "val", "part", "rep", "Ret", "info", "bit", "cat", "let", "re", "iter", "nt", "feat", "resp", "ft", "rets", "str", "ut", "big", "conn", "valid", "mt", "opt", "code", "rc", "ext", "rt", "reply", "rev", "back", "alt", "after", "reg", "flat", "err", "ref", "gt", "pet", "result", "fit", "job", "success", "rot", "num", "RET", "sr", "usr", "error", "req", "sec", "lit", "wrap", "count", "fun", "status", "en", "obj", "arg", "det", "cur", "get", "bad", "id", "match", "rl", "flag", "len", "att"], "offset": ["adjust", "start", "end", "off", "ref", "ui", "part", "origin", "post", "stop", "style", "align", "fp", "split", "pos", "absolute", "address", "entry", "fee", "p", "abi", "ip", "point", "prefix", "o", "ace", "slot", "id", "shift", "timeout", "initial", "tile", "url", "index", "inet", "missing", "set", "location", "alias", "error", "Offset", "length", "slice", "loc", "reference", "iso", "addr", "reset", "range", "alpha", "pointer", "gap", "image", "position", "secondary", "base", "api", "padding"], "cluster": ["pluster", "bluster", "bloser", " clust", "splust", "clancer", "clust", "splancer", " clause", "splanch", "plard", "plause", "blancer", "plip", "blip", "spluster", "sluster", "sloser", "clard", "clause", " clard", "blust", "clanch", "slancer", "ploser", "blard", "plust", "planch", "blanch", " clip", "blause", "clip", "closer", "plancer", " clancer", "slanch", "slust"], "corruptions": ["corriptitions", "corriptisions", "Corruptisions", "corruption", "corription", "corintions", "corriptions", "Corruptitions", "corintion", "corintitions", "corintisions", "Corruptions", "corruptitions", "corruptisions", "Corruption"], "new_nb_clusters": ["new_nb_labords", "new_nb_clients", "new_nb_scones", "new_nb_cluster", "new_nb_blients", "new_nb_Clusters", "new_nb_Clords", "new_nb_CLicas", "new_nb_bluster", "new_nb_lusters", "new_nb_scusters", "new_nb_custers", "new_nb_cicas", "new_nb_cores", "new_nb_scients", "new_nb_Clores", "new_nb_chords", "new_nb_blores", "new_nb_plusters", "new_nb_chuster", "new_nb_chos", "new_nb_CLusters", "new_nb_CLores", "new_nb_clores", "new_nb_Clones", "new_nb_lores", "new_nb_clicas", "new_nb_pluster", "new_nb_luster", "new_nb_licas", "new_nb_custer", "new_nb_clos", "new_nb_Clos", "new_nb_Clients", "new_nb_Clicas", "new_nb_clones", "new_nb_scuster", "new_nb_CLuster", "new_nb_chusters", "new_nb_blones", "new_nb_plores", "new_nb_plicas", "new_nb_clords", "new_nb_labuster", "new_nb_labos", "new_nb_blusters", "new_nb_labusters", "new_nb_blicas", "new_nb_Cluster"], "local_err": ["local_errors", "local7errors", "local_size", "raw_arr", "localingsize", "remote_result", "localingexc", "external_err", "external_errors", "localamer", "localingarr", "localingerr", "localingdata", "localamresult", "localinger", "external7er", "local_error", "remote_error", "local7er", "external_size", "raw_exc", "external_er", "external7err", "localamerror", "local_result", "local_exc", "local_er", "external7size", "local7size", "remote_err", "external7errors", "local_data", "local_arr", "remote_er", "localamerr", "local7err", "raw_err", "raw_data", "localingerrors"], "check_errors": ["check_params", "check__errors", "check__comments", "work__params", "checkallparams", "checkallcomments", "checkerparams", "work_err", "checkallerr", "checkererr", "check_comments", "work_comments", "check__err", "work__err", "check__params", "work_params", "checkererrors", "work__errors", "work__comments", "checkercomments", "checkallerrors", "check_err", "work_errors"], "corruptions_fixed": ["corruptIONS_failed", "corruptIONS_fix", "corruptions_failed", "corruptions_fix", "corruptIONS_diff", "corruptions_diff", "corruptIONS_fixed"]}}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801, "substitutes": {"opts": [" opted", " optt", " oppt", "Opters", "OPts", "optns", "ott", "omted", "Oputs", "otments", "OPTs", " opats", "omments", "opta", "hopts", "oprs", "OPrs", "otters", "experts", "optt", "expert", "optats", " opsts", "experns", "OPments", "OPuts", "hopta", "OPta", "opcs", "optters", "copters", "hoputs", "omts", "opersts", "opt", " optns", "opps", "oppt", "copcs", "OPt", "optcs", "opats", "OPns", "OPpt", "opns", "OPted", "OPsts", "copts", "optted", "opters", "operrs", "Opts", "otuts", " optters", "Opted", " opt", " oprs", "OPters", "OPats", "otsts", "opert", "otcs", "hopted", " opps", "optuts", "otTs", "copats", "coprs", "optta", "optts", "optps", "opments", "opted", "copt", "operts", "oputs", "optpt", "OPps", "optrs", "operments", "optments", "optTs", "Opta", "experted", "omt", " optts", "opTs", "otts", "opercs", "optsts", " opments", "opsts"], "block_default_type": ["block_default_class", "block_default_t", "block_block_type", "block_block_t", "block_default_types", "block_block_types", "block_block_class"], "buf": ["conv", "bc", "uf", "binary", "uc", "ref", "config", "text", "input", "pkg", "cv", "fb", "queue", "func", "img", "fp", "cas", "buffer", "path", "alloc", "cmd", "box", "data", "runner", "label", "rc", "filename", "cb", "pool", "ctx", "aux", "b", "tmp", "seq", "ff", "desc", "src", "fd", "br", "callback", "Buffer", "buff", "proc", "bag", "vec", "bus", "rb", "block", "output"], "file": ["place", "port", "ile", "name", "class", "ul", "il", "input", "time", "connection", "uri", "fp", "f", "model", "path", "dir", "socket", "data", "cache", "zip", "unit", "filename", "pool", "la", "mail", "source", "book", "File", "show", "http", "resource", "files", "image", "base", "where", "url", "letter"], "serial": ["io", "rol", "package", "sel", "tel", "usb", "ser", "mount", "xxx", "mode", "phone", "device", "local", "model", "mobile", "custom", "series", "roll", "socket", "dev", "zip", "version", "tag", "random", "spec", "pass", "alias", "unknown", "iso", "select", "proc", "http", "template", "volume", "resource", "Serial"], "mediastr": ["mediastril", "mediendrs", "mediastrl", "datestr", "mediestr", "mediostrl", "mediestrs", "mediendril", "datastril", "datastrs", "mediendrl", "datestrl", "datestril", "datastrl", "mediostrs", "mediostr", "mediendr", "mediastrs", "mediostril", "mediestrl", "datastr", "datestrs", "mediestril"], "type": ["span", "col", "like", "i", "Type", "name", "types", "class", "shape", "object", "level", "config", "ping", "pe", "part", "message", "time", "key", "TYPE", "style", "ty", "weight", "no", "model", "split", "t", "other", "info", "y", "pre", "size", "data", "state", "lock", "p", "diff", "number", "id", "code", "count", "unit", "var", "comment", "py", "day", "tag", "create", "month", "value", "ype", "length", "call", "unknown", "test", "total", "options", "parent", "typ", "block", "all", "sort", "position", "x"], "media": ["io", "package", "port", "medi", "message", "mode", "meta", "metadata", "uri", "control", "device", "model", "m", "medium", "data", "storage", "memory", "module", "audio", "spec", "source", "document", "material", "Media", "library", "reader", "http", "template", "manager", "volume", "resource", "image", "record", "format", "import"], "bus_id": ["unitpid", "unit_version", "bus_version", "unitpsid", "buspsid", "unitpbid", "unit_sid", "unitpversion", "bus_ids", "buspbid", "bus_bid", " bus_type", "bus_name", "buspid", " bus_name", "bus_sid", "bus_type", " bus_ids", "unit_bid", "buspversion"], "unit_id": ["device_version", "unit_ids", "unit_name", "device_name", "unitacversion", "unit_type", "device_id", " unit_type", "device_type", "unitacname", "unitactype", " unit_ids", "unitacid", " unit_name", "unit_version"], "cyls": ["ryps", " cyrs", " crols", " cyles", "cyrs", "rylf", "cyols", " crls", "zylf", "corrs", "cyps", "zyls", "cylf", "corles", "rycs", "zycs", " crrs", " cyps", "corls", " cycs", "ryls", "zyps", "cycs", "cyles", "corols", " cylf", " cyols", " crles"], "heads": ["obs", "outs", "docs", "workers", "headers", "tests", "maps", "rows", "hook", "HEAD", "locks", "plugins", "tails", "shots", "flags", "offs", "members", "head", "shows", "cases", "tops", "modules", "loads", "sections", "opens", "jobs", "frames", "reads", "blocks", "views", "sticks", "checks", "links", "mods", "files", "times", "pages"], "secs": [" secp", "seqseconds", "seqs", "supps", " secseconds", "ribn", "suppp", "suppn", "seqls", "seco", "seqo", "ribo", "suppseconds", "secls", "ribls", " secn", "seqp", " seco", "ribs", "secseconds", "seqn", "secp", " secls", "secn"], "translation": ["port", "name", "flash", "language", "acl", "message", "rating", "protection", "Translation", "bl", "local", "flags", "pos", "proxy", "info", "mo", "description", "version", "abi", "misc", "trans", "comment", "rot", "settings", "la", "title", "alias", "loc", "utils", "options", "http", "template", "conf", "lang", "image", "resource", "lit", "offset", "base"], "drv": ["srv", " drc", "Drf", " drf", "drw", " drw", "srf", "drc", "Drv", "Drc", "srw", "Drw", "drf", "src"], "max_devs": ["max_evi", "max_devid", "max_evp", "max_devp", "max_devicei", "max_deviceid", "max_devicep", "max_defi", "max_evs", "max_devi", "max_devices", "max_defs", "max_defp", "max_defid", "max_evid"], "index": ["name", "shape", "target", "limit", "level", "config", "ind", "input", "inc", "key", "connection", "height", "weight", "pos", "proxy", "info", "axis", "dir", "head", "cache", "version", "unit", "diff", "id", "prefix", "number", "depth", "Index", "num", "match", "x", "length", "slice", "loc", "parent", "image", "position", "block"], "on_read_error": ["on_read_ror", "on_write_progress", "on_read_progress", "on_read_errors", "on_write_ror", "on_write_errors"], "on_write_error": ["on_writing_error", "on_writeoutresult", "on_write_result", "on_writeouterr", "on_writing_err", "on_writeouterror", "on_writing_result", "on_write_err", "on_writing_change", "on_write_change", "on_writeoutchange"], "devaddr": ["devaddress", "pubAddress", "evaddr", "pubaddr", "devAddress", "devicesid", "deviceaddr", "pubaddress", "deviceAddress", "pubsid", "evAddress", "evaddress", "deviceaddress", "devsid", "evsid"], "dinfo": ["dcconf", "dlconf", " dconf", "dlinfo", "dconf", " dInfo", "dlInfo", " dapi", "dcInfo", "dlapi", "dInfo", "dapi", "dcinfo", "dcapi"], "io_limits": ["IO_limited", "IO_maps", "IO_limit", "io_limit", "IO_limits", "io_limited", "io_maps"], "copy_on_read": ["copy_on__reader", "copy_on__read", "copy_on_READ", "copy_onCaccess", "copy_On_write", "copy_On_access", "copy_On_read", "copy_on_reader", "copy_off_reader", "copy_on__write", "copy_off_read", "copy_On_load", "copy_on_write", "copy_on_access", "copy_off_write", "copy_off_READ", "copy_on__READ", "copy_onCwrite", "copy_onCread", "copy_on_load", "copy_onCload"], "ret": ["class", "def", "ref", "result", "val", " reply", "Ret", " resp", "model", "res", "rc", "rot", "num", "RET", "rt", "mem", "reply", "rev", "re", "rs", "nt", "lang", "lit", "resp", "rets"], "error": ["status", "ror", "row", "attribute", "query", "err", "option", "result", "progress", "ack", "layer", "op", "info", "bug", "ERROR", "comment", "success", "Error", "call", "slice", "parser", "rage", "resource", "block", "server", "danger", "command"]}}
{"project": "qemu", "commit_id": "0b2c1beea4358e40d1049b8ee019408ce96b37ce", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815, "substitutes": {"qdict": ["qdatabase", "sqdict", "qconfig", "qudict", "qdb", "reqconfig", "reqdict", "qttable", "qutable", "qtdict", "qtdatabase", "dqobject", "qobject", "dqtable", " qdef", "qudatabase", "qtobject", "sqdef", "dqdatabase", "reqdef", "sqdb", " qconfig", "quobject", "sqconfig", "reqdb", "dqdict", "qdef", " qdb", "qtable"], "params": ["ras", "name", "types", "shape", "query", "qs", "es", "sym", "start", "config", "ses", "part", "phrase", "ops", "plugins", "json", "ks", "properties", "ams", "names", "sys", "m", "members", "args", "ssl", "p", "cs", "vals", "prefix", "ls", "py", "settings", "ctx", "spec", "resources", "sq", "search", "objects", "seq", "ms", "par", "keys", "parts", "words", "slice", "req", "ps", "options", "rs", "gs", "ins", "conf", "array", "sid", "param", "kw", "ips", "attr", "k"], "implied_key": ["implied_keys", "implied_name", "implicit__key", "implicatedPKey", "implied_Key", "impliedPKey", "impliedJkey", "implicated_Key", "implicated_name", "impliedsname", "impliedskey", "implicit__name", "impliedJname", "implixed_value", "implied_rule", "impliedPkeys", "imploded_code", "impliedJver", "implied_value", "implicated_type", "impliedenmessage", "implied__name", "implied__value", "implicatedPvalue", "implicit_name", "impliedPver", "impliedPtype", "implicit__field", "impliedOkey", "impliedPvalue", "implied__Key", "imploded_key", "implied_message", "implicatedPtype", "imploded_name", "implicated_value", "implied_type", "implied__type", "implicit_ver", "implicit_type", "impliedenvalue", "impliedPrule", "implicatedPkey", "implicit__type", "impliedOnext", "impliedPkey", "implixed_key", "impliedsfield", "implixed_message", "implicated_key", "implied__code", "implied_ver", "implied__field", "implicit_field", "impliedJnext", "impliedOname", "impliedstype", "implicated_next", "implied_field", "implied_next", "implicit_keys", "implied__key", "implied_code", "implicated_ver", "imploded_Key", "implicit_key", "impliedenkey", "impliedOver", "implicit_rule"], "errp": ["errcp", "Erfp", "krpr", "ErP", "errps", "errpr", "yrr", "err", "dersp", "interpa", "ierpa", "erc", "krg", "derP", "yrp", "rrp", "krp", "ierp", "astercp", "iersp", " errfp", "Erp", "rrr", "armg", "armr", "interp", "asterr", "errfp", "errpa", "derpa", "derp", "ierP", "errP", "Err", "errsp", "rrcp", "armp", "rrc", "errc", "ercp", "armpr", "erpr", "asterp", "intersp", "erpy", "asterps", "errg", "erg", "erfp", " errP", "erp", "errr", "erP", "yrpy", "rrpy", " errr", "interP", "errpy", "yrc", "erps", "krr", "rrps"], "key": ["KEY", "row", "i", "ak", "pe", "part", "temp", "ty", "no", "order", "y", "data", "j", "seed", "ip", "link", "list", "field", "pri", "go", "rule", "date", "keys", "n", "select", "v", "type", "str", "name", "phrase", "sign", "op", "fee", "sy", "state", "code", "q", "mac", "c", "self", "hash", "any", "ce", "pair", "ie", "k", "sum", "e", "time", "by", "f", "size", "full", "p", "ace", "ver", "service", "core", "error", "call", "length", "secret", "req", "ry", "sec", "param", "x", "start", "query", "kind", "sk", "args", "cache", "id", "change", "sync", "close", "index", "search", "match", "source", "w", "se", "seq", "par", "min", "Key", "root", "parent", "kw", "block", "base", "max", "value"], "key_end": ["key__en", "key_en", "keyjstart", " key_size", "text_length", "keyjend", "key__size", "value0end", "key_length", "key__start", "key_ended", "key0offset", "keyPstart", "key__end", " key_END", "key0ended", "key_size", "key0start", "key0end", " key_add", "textCended", "keyClength", "key_add", " key_start", "keyCended", "value_offset", "value_end", "key_offset", "textCend", "keyPended", "keyPoffset", "keyjsize", " key_en", "value_ended", "value0offset", "keyjen", " key_offset", "keyCend", "text_ended", "value0start", "keyPend", "key_start", "key_END", " key_n", "value_start", "text_end", "textClength", "key_n", "value0ended"], "s": ["i", "es", "uns", "xs", "ds", "pos", "sys", "y", "r", "j", "os", "ssl", "ts", "cs", "js", "keys", "n", "S", "ns", "slice", "rs", "ins", "v", "l", "ss", "str", "sb", "g", "ses", "d", "sets", "services", "u", "sy", "res", "o", "sg", "c", "spec", "set", "scope", "su", "k", "e", "sym", "sie", "hs", "fs", "bytes", "f", "t", "size", "new", "p", "si", "sr", "b", "service", "parts", "sup", "words", "side", "ps", "gs", "sid", "sec", "h", "secondary", "sq", "start", "sk", "send", "sl", "ops", "ks", "m", "args", "ls", "sync", "is", "settings", "search", "single", "source", "w", "sing", "session", "sp", "server", "states"], "len": ["fail", "part", "pos", "fat", "data", "j", "lu", "field", "dy", "la", "js", "line", "n", "lon", "v", "nt", "l", "fin", "str", "name", "end", "conn", "ind", "valid", "sil", "non", "repl", "split", "pre", "lock", "body", "lim", "spec", "lif", "low", "rev", "lib", "alt", "li", "vec", "ie", "lc", "syn", "net", "ref", "err", "ln", "ld", "f", "size", "full", "lin", "le", "el", "ren", "num", "length", "loc", "ll", "ler", "lf", "lang", "lit", "fun", "count", "span", "limit", "en", "sl", "bl", "args", "rel", "label", "ls", "elt", "L", "seq", "fl", "min", "lt", "vert", "sp", "fn", "all", "base", "Len", "url"], "key_in_cur": ["key_out_ver", "key_out_car", "key_out_cur", "key_n_ser", "key_int_rc", "key_n_cur", "key_in_ser", "key_in_cache", "key_int_var", "key_in_var", "key_in_ur", "key_n_ur", "key_out_ser", "key_in_rc", "key_out_valid", "key_in_valid", "key_in_sur", "key_in_car", "key_out_sur", "key_in_per", "key_int_cur", "key_in_ver", "key_n_cache", "key_out_per"], "cur": ["col", "row", "prev", "sel", "serv", "uc", "conn", "oe", "ur", "sl", "ser", "result", "coll", "ctr", "der", "tr", "con", "rec", "sth", "cb", "per", "r", "cat", "rest", "rel", "new", "enc", "cf", "current", "dict", "sync", "var", "attr", "buf", "rc", "client", "c", "pri", "Cur", "spec", "pr", "dr", "ch", "sc", "sr", "ocr", "cal", "ver", "sur", "rev", "cr", "desc", "src", "child", "loc", "co", "req", "keep", "car", "tra", "sq"], "ret": [" fin", "str", " lib", "reg", "en", " alt", "obj", "ref", "err", "result", "arg", "repl", " reply", "Ret", " repl", " resp", "f", "pre", "r", "res", "j", "rel", " sr", "rets", "arr", "opt", "fun", "success", "ext", "el", "ren", "num", "pass", "RET", "rt", "sr", "rl", " fun", "seq", "rev", "reply", "min", "n", "re", "lt", "ll", " lang", "iter", "req", "alt", "nt", "sec", "lit", "att", " rel", "Len", "fin"], "next": ["then", "start", "prev", "en", "bis", "conn", "err", "obj", "config", "valid", "end", "eni", "result", "sche", "again", "dev", "data", "args", "state", "j", "new", "more", "last", "current", "enc", "head", "code", "p", "open", "client", "gen", "Next", "c", "ver", "future", "now", "first", "tmp", "rev", "big", "min", "session", "child", "br", "skip", "doc", "proc", "ner", "conf", "sec", "z", "ne", "li", "dot", "sen", "primary", "sq", "value"], "val": ["str", "name", "sel", "def", "sl", "valid", "arg", "pre", "cache", "rel", "arr", "vals", "ls", "var", "el", "seq", "rev", "VAL", "Val", "lib", "v", "li", "eval", "base", "prop", "value"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)\n\n{\n\n    int16_t input[MDCT_SAMPLES];\n\n    int32_t output[AC3_MAX_COEFS];\n\n    float input1[MDCT_SAMPLES];\n\n    float output1[AC3_MAX_COEFS];\n\n    float s, a, err, e, emax;\n\n    int i, k, n;\n\n\n\n    for (i = 0; i < MDCT_SAMPLES; i++) {\n\n        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;\n\n        input1[i] = input[i];\n\n    }\n\n\n\n    mdct512(mdct, output, input);\n\n\n\n    /* do it by hand */\n\n    for (k = 0; k < AC3_MAX_COEFS; k++) {\n\n        s = 0;\n\n        for (n = 0; n < MDCT_SAMPLES; n++) {\n\n            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));\n\n            s += input1[n] * cos(a);\n\n        }\n\n        output1[k] = -2 * s / MDCT_SAMPLES;\n\n    }\n\n\n\n    err  = 0;\n\n    emax = 0;\n\n    for (i = 0; i < AC3_MAX_COEFS; i++) {\n\n        av_log(NULL, AV_LOG_DEBUG, \"%3d: %7d %7.0f\\n\", i, output[i], output1[i]);\n\n        e = output[i] - output1[i];\n\n        if (e > emax)\n\n            emax = e;\n\n        err += e * e;\n\n    }\n\n    av_log(NULL, AV_LOG_DEBUG, \"err2=%f emax=%f\\n\", err / AC3_MAX_COEFS, emax);\n\n}\n", "idx": 22826, "substitutes": {"mdct": ["magcf", "cmdconfig", " mdconfig", "cmdcf", " mdect", "amdcf", "MDCT", "magconfig", "cmdCT", " mdcf", "magect", "cmdect", "mdc", "mdCT", "amdCT", "cmdc", "amdct", "magct", "MDcf", "amdc", "mdcf", "mdect", "cmdct", "MDc", "mdconfig", "MDct"], "lfg": ["dfG", "dlgs", "lfgs", "olfge", "afgc", "afg", "lvG", "olfG", "dfg", "afG", "olfgc", "lfcfg", "lvgs", "dlG", "lfG", "lfgc", "lvcfg", "dlg", "dfge", "lfge", "dfgc", "afgs", "lvg", "afge", "afcfg", "olfg", "dlcfg"], "input": ["request", "view", "argument", "table", "support", "response", "target", "config", "option", "include", "text", "temp", "control", "model", "buffer", "op", "address", "Output", "init", "data", "state", "Input", "method", "version", "inf", "current", "list", "context", "inner", "initial", "condition", "answer", "out", "submit", "index", "audio", "source", "document", "form", "in", "value", "first", "error", "child", "PUT", "feed", "batch", "update", "select", "parent", "array", "stream", "instance", "image", "accept", "interface", "import"], "output": ["summary", "target", "response", "object", "fore", "config", "option", "result", "text", "hidden", "forward", "queue", "display", "control", "wave", "generation", "model", "write", "outer", "other", "address", "information", "Output", "version", "current", "unit", "number", "prefix", "o", "operation", "context", "memory", "out", "network", "index", "complete", "source", "document", "second", "four", "console", "flow", "PUT", "reference", "put", "expression", "update", "image", "position", "environment", "production", "value"], "input1": ["request2", "requestone", "context2", "input2", " input2", "Inputone", " inputone", "request1", "outputone", "Input2", "output2", "context1", "contextone", "Input1", "inputone"], "output1": [" outputOne", "resource100", "image100", "responseOne", "image2", "imageOne", "outputOne", "OutputOne", " output100", " output2", "input2", "resource1", "imageone", "responseone", "resource2", "outputone", "resourceOne", "output2", " outputone", "inputOne", "output100", "Output2", "image1", "response1", "Output1"], "s": ["sv", "sb", "space", "es", "sl", "g", "su", "d", "as", "ks", "ds", "f", "y", "t", "r", "u", "m", "j", "os", "ssl", "p", "cs", "ls", "o", "sync", "is", "sa", "c", "sq", "si", "b", "w", "se", "S", "ns", "sf", "ps", "rs", "gs", "south", "ans", "z", "v", "h", "l", "ss"], "a": ["fa", "area", "ba", "g", "wa", "oa", "d", "A", "ca", "as", "ata", "y", "u", "r", "m", "ac", "ga", "p", "na", "aw", "o", "am", "sa", "au", "c", "af", "ar", "b", "ta", "sta", "va", "aa", "ai", "ab", "ae", "alpha", "ma", "x", "an"], "err": ["str", "ie", "ee", "end", "oe", "late", "scale", "g", "result", "E", "d", "Er", "rr", "l", "lr", "f", "ea", "y", "esi", "r", "ell", "m", "fee", "j", "u", "p", "diff", "ace", "errors", "o", "max", "dy", "gz", "dr", "c", "fe", "fr", "ar", "die", "b", "w", "error", "cr", "er", "Error", "iter", "req", "ae", "z", "v", "ec", "h", "ge", "ir", "ne"], "e": ["ee", "en", "es", "end", "oe", "eu", "event", "g", "E", "none", "pe", "me", "be", "ed", "energy", "d", "de", "ze", "l", "ea", "f", "ef", "y", "ell", "r", "eb", "m", "ue", "ffe", "esi", "u", "ep", "p", "diff", "ace", "o", "c", "el", "fe", "edge", "se", "ele", "error", "er", "te", "element", "ei", "ae", "z", "ne", "ce", "equal", "eval", "ev", "ge", "ie", "x", "ec", "entity"], "emax": ["tmake", "amall", " emake", "termazon", "EMax", "omaxy", "imake", "EMack", "emaj", "tmack", "tmAX", "emaone", "emaax", " emone", "tmax", "omax", "omack", "EMin", " emin", "imase", "atemaj", "atemin", "emAX", "emask", "emack", "amake", "EMaj", "emone", "ematch", "atematch", "imAX", "emaxy", "emaatch", " ematch", " emaxy", "termone", "emaazon", "emase", "imall", " emall", "termatch", "imax", "termax", " emazon", " emask", "amask", "omase", "amax", "emall", " emase", " emaj", "atemax", "emin", "emake", "emazon", " emack", "EMake", "imaxy", "EMatch", "imask", "imack", "EMAX"], "i": ["io", "ix", "ie", "fi", "qi", "ri", "iv", "g", "ui", "eni", "part", "mini", "pi", "gi", "d", "uri", "my", "ti", "I", "f", "ci", "y", "t", "u", "oi", "m", "ini", "info", "j", "init", "it", "phi", "p", "ip", "id", "o", "bi", "ani", "is", "mi", "cli", "inner", "mu", "c", "index", "si", "ii", "b", "iu", "ai", "xi", "di", "v", "multi", "z", "li", "yi", "l", "x", "ni", "ori"], "k": ["kick", "ik", "sk", "ak", "kid", "g", "key", "ki", "ack", "d", "ks", "f", "y", "u", "r", "m", "ok", "j", "kin", "N", "p", "id", "o", "K", "q", "kn", "ek", "c", "self", "ask", "b", "w", "dk", "uk", "v", "ko", "z", "mk", "h", "kw", "ke", "ck", "l", "x"], "n": ["name", "net", "un", "en", "g", "nn", "d", "f", "y", "N", "u", "m", "r", "j", "nc", "p", "na", "o", "ng", "c", "cn", "b", "ns", "nb", "v", "z", "nt", "ne", "sn", "fn", "nu", "l", "x", "pn", "an", "ni"]}}
{"project": "FFmpeg", "commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "target": 1, "func": "static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n", "idx": 22833, "substitutes": {"old_w": ["old_wid", "old_W", "old01h", "old25W", "old25wd", "old01w", "old01wid", "new_wd", "old25h", "new_wid", "old01width", "old25w", "old_width", "new_width", "new_W", "old_wd"], "old_h": ["old44max", "old55c", "new_max", "old67h", "old67max", "old44q", "new_c", "old55w", "old44w", "new_q", "old_q", "old67w", "old55h", "old_z", "old55z", "old67q", "old_max", "old44h", "new_z", "old_c"], "sar": [" sart", "yAR", "sesarl", "lsarl", " spar", "setsar", "sars", "psarl", "sarp", "Saur", "esarat", "psarin", "asar", "nsara", "setsaur", "sesarat", " sarl", "setsarp", "pspar", "lsarin", "yarr", "dslar", "sarr", "nsAR", "slar", "asara", "sesara", "yara", "dsar", "psara", "saur", "psar", "yar", "asarat", "dsart", "ssAR", "SAR", "Sarp", "sarat", "nsars", "eslar", "nsar", "nsarr", "setsara", "esar", "sesar", "Sar", "ssar", "Sarr", "esart", "Sara", "asarl", "lspar", "dsarat", " slar", "sarl", " sarin", "sarin", "sart", "lsar", "psarat", "spar", "sara", "ssars", "ssara", " sarat", "psarp", "psaur", "sAR"], "new_w": ["new25wd", "new_iw", "new25iw", "new_wd", " new_wal", " new_wa", "new25h", "new_wal", "new_wa", "old_iw", "new25w", "old_wd"], "new_h": ["new44H", "new_sh", "old_end", "old_sh", "new44w", "new_H", "new_c", "new2H", "new44end", "new_end", "new2h", "new2w", "old_H", "new44h", "old_c", "new2end"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834, "substitutes": {"bus": ["port", "bis", "usb", "config", "board", "controller", "mount", "plugin", "Bus", "bridge", "engine", "pos", "used", "use", "bug", "cache", "os", "serial", "us", "sync", "buf", "plug", "pass", "book", "BUS", "boot", "proc"], "devfn": ["evfp", "devn", " devfp", "evn", "Devfp", " devn", "Devn", "privfn", "privfp", "devfp", "Devfn", "Devpath", "evpath", "privpath", " devpath", "devpath", "evfn"], "offset": ["phase", "limit", "start", "attribute", "off", "style", "fp", "pos", "optional", "enabled", "address", "data", "size", "number", "prefix", "slot", "annot", "url", "o", "addr", "timeout", "index", "et", "location", "Offset", "length", "len", "base", "parent", "reset", "pointer", "position", "inet", "format", "padding", "type"]}}
{"project": "FFmpeg", "commit_id": "ee90119e9ee0e2c54f1017bbe1460bfcd50555d0", "target": 1, "func": "static int decode_block(BinkAudioContext *s, float **out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = out[ch];\n\n\n\n        if (s->version_b) {\n\n            if (get_bits_left(gb) < 64)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n        } else {\n\n            if (get_bits_left(gb) < 58)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        if (get_bits_left(gb) < s->num_bands * 8)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            int value = get_bits(gb, 8);\n\n            quant[i]  = quant_table[FFMIN(value, 95)];\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else {\n\n                int v;\n\n                GET_BITS_SAFE(v, 1);\n\n                if (v) {\n\n                    GET_BITS_SAFE(v, 4);\n\n                    j = i + rle_length_tab[v] * 8;\n\n                } else {\n\n                    j = i + 8;\n\n                }\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            GET_BITS_SAFE(width, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    GET_BITS_SAFE(coeff, width);\n\n                    if (coeff) {\n\n                        int v;\n\n                        GET_BITS_SAFE(v, 1);\n\n                        if (v)\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        int j;\n\n        int count = s->overlap_len * s->channels;\n\n        if (!s->first) {\n\n            j = ch;\n\n            for (i = 0; i < s->overlap_len; i++, j += s->channels)\n\n                out[ch][i] = (s->previous[ch][i] * (count - j) +\n\n                                      out[ch][i] *          j) / count;\n\n        }\n\n        memcpy(s->previous[ch], &out[ch][s->frame_len - s->overlap_len],\n\n               s->overlap_len * sizeof(*s->previous[ch]));\n\n    }\n\n\n\n    s->first = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 22844, "substitutes": {"s": ["sv", "bis", "es", "xs", "ds", "sys", "y", "os", "ssl", "ts", "cs", "us", "stats", "js", "aws", "n", "S", "ns", "rs", "conf", "l", "ss", "sim", "sb", "outs", "support", "g", "ses", "sets", "site", "services", "u", "o", "sg", "c", "self", "spec", "sc", "a", "sf", "multi", "su", "e", "sym", "qs", "hs", "fs", "sis", "f", "ves", "t", "less", "full", "p", "si", "b", "service", "parts", "sup", "words", "side", "ps", "gs", "sq", "sl", "features", "your", "ops", "plugins", "ks", "m", "storage", "ls", "sync", "is", "settings", "ges", "w", "se", "session", "sp", "server", "states"], "out": ["io", "outs", "conn", "obj", "err", "amp", "g", "result", "input", "part", "bin", "process", "buffer", "op", "again", "cmd", "m", "data", "cache", "p", "at", "params", "prefix", "o", "code", "sync", "buf", "c", "OUT", "source", "in", "b", "w", "channel", "Out", "batch", "up", "array", "image", "att", "block", "output"], "use_dct": ["use_dft", "use_bdcc", "use_dCT", "use_fuct", "use_pCT", "use_fft", "use_fct", "use_bdCT", "use_bdct", "use_dst", "use_Dct", "use_fCT", "use_Duct", "use_bdst", "use_duct", "use_pft", "use_Dft", "use_puct", "use_DCT", "use_pct", "use_dcc", "use_Dcc", "use_Dst"], "ch": ["col", "sch", "e", "och", "chn", "sk", "qi", "conn", "ach", "g", "cor", "chan", "ich", "cm", "chi", "Ch", "che", "f", "ci", "y", "ht", "cp", "cht", "p", "CH", "cs", "code", "rc", "c", "cb", " chunk", "arch", "sh", "cho", "b", "cy", "channel", "core", "vc", "child", "chip", "zh", "th", "chu", "batch", "z", "conf", "bh", "chrom", "h", "l", "x", "ph", "count"], "i": ["io", "ix", "e", "ik", "start", "fi", "qi", "ind", "ui", "g", "eni", "mini", "pi", "key", "ki", "gi", "d", "uri", "my", "ti", "I", "l", "f", "ci", "y", "u", "info", "m", "ini", "phi", "it", "init", "p", "ip", "id", "o", "bi", "mi", "c", "index", "si", "ii", "b", "in", "ji", "w", "n", "iu", "ai", "xi", "hi", "di", "z", "yi", "li", "multi", "api", "ie", "x", "ni"], "j": ["ja", "jit", "e", "ix", "jl", "ie", "start", "qi", "jp", "adj", "g", "ui", "key", "jen", "d", "f", "jj", "y", "uj", "u", "r", "m", "size", "dj", "p", "jet", "o", "dy", "js", "aj", "index", "fr", "si", "J", "b", "ii", "ji", "w", "ij", "vol", "n", "length", "br", "xi", "jc", "z", "li", "h", "l", "x"], "k": ["e", "ik", "sk", "qi", "g", "key", "ki", "d", "ks", "f", "y", "u", "r", "m", "ok", "p", "o", "K", "c", "kk", "b", "w", "n", "z", "ck", "h", "ke", "x"], "q": [" quality", "query", "qs", " w", "ig", "qi", " query", "ind", "g", "val", "Q", "d", "qv", "pad", "qq", "cl", "f", "y", "r", "u", "m", "qu", "quality", "p", "frac", "max", "c", "dq", "w", "qa", "req", "z", "qt", "ill", "h", "quad", "sq"], "quant": ["query", "press", "config", "scale", "percent", "cost", "text", "complex", "post", "private", "rec", "qq", "cur", "pad", "cat", "qu", "final", "patch", "pp", "quality", "component", "compl", "frac", "sum", "comment", "quick", "spec", "sc", "comp", "window", "raw", "draw", "qa", "mask", "total", "quart", "req", "mult", "util", "proc", "buff", "qt", "user", "gap", "pack", "quad", "qual", "requ"], "coeff": ["coefficient", "loff", "coff", " coef", "loef", "Coff", "Coef", " coff", "coef", "Coefficient", " coefficient", "loefficient", "loeff", "Coeff"], "gb": ["io", "gio", "bc", "sb", "binary", "lb", "gpu", "gt", "usb", "sl", "gram", "g", "ui", "gal", "gold", "mb", "db", "xy", "cm", "fb", "gnu", "gi", "bb", "gl", "vg", "gin", "bp", "pc", "bridge", "yg", "gd", "ga", "eb", "phy", "bg", "gru", "storage", "mc", "uv", "gy", "url", "kb", "gg", "wb", "py", "gz", "rc", "px", "cb", "ctx", "cfg", "gp", "go", "b", "hub", "general", "bm", "gh", "nb", "gs", "buff", "bf", "range", "gam", "lib", "boot", "GB", "rb", "gm", "cgi", "ge", "abb", "rg"], "coeffs": ["COEFFos", "coEFFn", "coEFFes", " coeffn", "coEFFos", "coeffi", "coffes", "coffs", "coefficos", "coefes", "coEFFp", "coeffn", " coeffns", "coffn", " coefn", "coefficp", "coaffp", "coffos", " coefes", "coffi", "coaffes", "coefp", "coefns", "COEFFs", "coffns", "coaffns", "COeffes", "coeffes", "coefn", "coefficientes", " coeffi", "coeffp", "coEFs", "coefos", " coefs", "COeffi", " coefp", "coeffns", "coeffos", "coEFp", "COEFFes", "coeffices", "coEFes", "coaffs", "coeffics", "COEFFi", "coefficientp", "COeffs", "COeffos", " coefos", " coeffp", " coeffes", "coEFFi", "coefficientos", "coefi", " coeffos", "coefficienti", "coefs", " coefns", "coEFFs", " coefi", "coffp", "coefficients"], "v": ["tv", "sv", "e", "V", "lv", "iv", "g", "vt", "av", "val", "d", "qv", "f", "t", "u", "r", "m", "p", "vs", "uv", "version", "vi", "o", "c", "ver", "b", "ii", "w", "ov", "volt", "vol", "n", "vv", "va", "ve", "vert", "z", "vp", "h", "vid", "ev", "l", "x", "value"]}}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875, "substitutes": {"cpu": ["lc", "computer", "fc", "gpu", "conn", "linux", "nic", "performance", "loop", "pkg", "CP", "consumer", "null", "processor", "pc", "CPU", "css", "home", "node", "cmp", "proxy", "nc", "cp", "cache", "p", "current", "component", "mac", "cli", "pool", "c", "ctx", "px", "cn", "roc", "gp", "loader", "cpp", "gc", "core", "auc", "foo", "pai", "cus", "boot", "proc", "parent", " CPU", "hw", "instance", "clock", "pu"], "scc": [" scca", "dsfc", "suc", "dsuc", "scci", "asuc", "cscc", " suc", "syscc", " scci", " sBC", "sysBC", "ascca", "csCC", "scca", " sCC", "SBC", "asfc", "sBC", "Scca", " sfc", "dscca", "Scc", "sCC", "syscca", "cscca", "cscci", "sysCC", "sfc", "Scci", "ascc", "SCC", "dscc"]}}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n", "idx": 22876, "substitutes": {"s": ["sv", "sb", "e", "qs", "sl", "fs", "ses", "ops", "as", "ds", "services", "f", "sys", "env", "r", "u", "state", "ssl", "ys", "cs", "ts", "p", "ls", "o", "is", "stats", "js", "c", "sq", "a", "b", "S", "ns", "iss", "ps", "v", "http", "ans", "bs", "ss", "states"], "vs": ["sv", "VS", "es", "vt", "xs", "css", "ds", "pos", "posts", "ils", "os", "ts", "cs", "vals", "Vs", "var", "stats", "js", "sts", "ov", "ms", "ns", "vas", "rs", "ins", "v", "ips", "pages", "ss", "obs", "outs", "services", "state", "ents", "vis", "rev", "va", "files", "vc", "prev", "qs", "fs", "lines", "rules", "flags", "ves", "oss", "cf", "ver", "vv", "events", "ps", "gs", "alls", "ums", "versions", "vers", "sk", "lv", "ops", "ks", "env", "args", "ys", "ls", "vr", "verts", "vm", "bs", "vp", "eps"], "err": ["status", " error", "str", "ig", "asm", "ind", "result", "an", "ctr", "good", "der", "Er", "rr", "cur", "lr", "order", "ah", "r", "msg", "fee", "dev", "bug", "ok", "fg", "arr", "ace", "errors", "code", "rh", "dy", "var", "inner", "runner", "rc", "dr", "cb", "fe", "pr", "ar", "ver", "error", "Error", "cr", "er", "gr", "len", " Err", "mr", "req", "iter", "rs", "ner", "orig", "nor", "aster", "ir", "resp", "attr", "count"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906, "substitutes": {"info": ["io", "ami", "i", "txt", "start", "def", "Info", "end", "off", "app", "hand", "config", "ui", "result", "this", "part", "INFO", "extra", "gi", "afi", "json", "build", "f", "op", "information", "it", "data", "bug", "init", "state", "full", "link", "inf", "diff", "setup", "id", "help", "inner", "is", "py", "thin", "index", "aux", "check", "si", "die", "tf", "ii", "now", "error", "utils", "hi", "feed", "options", "update", "di", "http", "conf", "base", "li", "manager", "image", "api", "fo", "type"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931, "substitutes": {"ram_size": ["ram2len", "ram_len", "gram_count", "ram_address", "ram2size", "gram_len", "ram2count", "gram_address", "ram__count", "gram_size", "ram__len", "ram_count", "ram2address", "ram__size", "ram__address"], "do_init": ["do_load", "do_setup", "do_set"], "cpu_model": ["cpu_Model", "cpulexModel", "cpuamcontroller", " cpu_models", "cpulexmodel", " cpu_format", "cpulexmethod", "cpuammethod", "cpu_method", "cpu__format", "CPU_method", "cpu__models", "cpuamModel", "cpuammodel", " cpu__model", " cpu__format", "cpu__Model", "CPU_model", "cpu_models", " cpu__models", " cpu__Model", "cpu_format", " cpu_Model", "cpulexcontroller", "CPU_Model", "cpu__model", "cpu_controller", "CPU_controller"], "sysclk": ["sysClok", "sysplk", "ysclk", " sysCLok", "sysplok", "sysCLks", " sysclok", "sysblk", "ysclok", " sysCLk", "sysCLok", "sysblks", "sysblck", "ysclck", " sysCLks", "sysCLck", "sysplks", "sysblok", " sysclks", "ysCLk", "sysClks", "sysclks", "ysCLck", "ysclks", "ysCLok", "sysClk", "ysCLks", "sysclok", "sysplck", "sysclck", "sysCLk"], "cpu": ["lc", "platform", "computer", "bench", "hp", "net", "lb", "gpu", "conn", "linux", "config", "GPU", "eni", "performance", "none", "result", "processor", "process", "pc", "CPU", "css", "node", "fp", "cmp", "nc", "cp", "fps", "cache", "appa", "uno", "uci", "np", "cli", "pool", "px", "ctx", "c", "cn", "cfg", "gp", "pid", "uca", "loader", "PU", "cpp", "python", "core", "auc", "chip", "pai", "console", "boot", "proc", " CPU", "vm", "hw", "instance", "clock", "nu", "pu"], "env": ["exe", "config", "eni", "extra", "exc", "que", "context", "qa", "proc", "v", "conf", "ev", "inet", "priv", "txt", "password", "end", "conn", "db", "cv", "oa", "eng", "style", "pect", "dir", "dev", "state", "enc", "code", "ext", "cfg", "equ", "qt", "erv", "scope", "net", "stack", "e", "err", "eu", "agents", "ea", "exec", "init", "cf", "cli", "Environment", "el", "gui", "loader", "worker", "core", "req", "skin", "manager", "ec", "en", "inc", "shell", "energy", "export", "engine", "nc", "args", "cache", "vs", "np", "ctx", "agent", "profile", "viron", "session", "console", "vm", "anne", "estate", "server", "environment"], "irqs": ["irques", "IRqus", " irques", " irks", "iercks", "irks", "IRcks", "IRacks", "pirq", "irches", "ircks", "mirches", "IRquest", "irsches", " irq", "errq", "errqs", "miracks", "irql", "ierqus", " ircks", "pirques", "iracks", "pirqs", "ierches", "IRq", "irqus", "ierqs", "IRks", "ierql", "irquest", "pirquest", "IRques", "pircks", "irsq", "errquest", "mirq", "irsql", "mirks", "irsqs", "IRqs", "ierq", "errques", "mirqs", "irq", "mirql", " irqus", " iracks", "pirks"]}}
{"project": "FFmpeg", "commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "target": 1, "func": "static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n", "idx": 22944, "substitutes": {"qtables": ["tables", "ktries", "table", "qries", "qtools", "ktables", "quantable", "iotabilities", "iotables", "qtries", "iotable", "quantions", "qtions", "qtabilities", "iotions", "questries", "tions", "tabilities", "questools", "ktools", "questables", "quantabilities", "qables", "ktable", "quantables", "qable", "qtable", "qools", "questable"], "q": ["col", "ix", "limit", "query", "qs", "qi", "ct", "scale", "g", "requ", "Q", "val", "force", "qq", "cl", "f", "r", "u", "qu", "bug", "quality", "p", "id", "max", "depth", "c", "ch", "dq", "w", "value", "question", "quant", "qa", "quest", "length", "iq", "req", "base", "range", "z", "qt", "v", "conf", "frequency", "quad", "l", "x", "factor", "sq", "k", "count"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ind", "ui", "val", "part", "gi", "uri", "ti", "I", "f", "ci", "t", "phi", "u", "ini", "info", "it", "j", "lock", "ip", "p", "id", "o", "bi", "mi", "c", "index", "si", "b", "ii", "line", "n", "iu", "len", "ai", "xi", "base", "di", "v", "li", "pi", "x", "zi", "k", "ni", "count"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n", "idx": 22949, "substitutes": {"afq": ["artqs", "artqa", "afqs", "awq", "afqa", "afiq", "apqu", " afqu", "avalqu", "rafqs", " afquest", "afcl", "avquest", "afe", "avalqs", " afqa", "afick", "alfq", "apque", "affqa", "avq", "afQ", "afiquest", "avz", " afqs", "alfque", "avalq", " afque", "afck", "afqu", "apq", "artcl", "alfqa", "afque", "affque", "artq", " afcl", "rafqa", "afiz", "afz", "awqs", "rafq", "afquest", "avale", " afe", "alfQ", " afz", " afQ", "affQ", "apck", "afique", "afiqu", "awe", "awqu", "affq", "avque", "rafcl", " afck"]}}
{"project": "FFmpeg", "commit_id": "81cc7d0bd1eab0aa782ff8dd49e087025a42cdee", "target": 1, "func": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n", "idx": 22955, "substitutes": {"_dst": ["_lsts", "_fST", " _fst", "_sdST", "_rdST", "_fbl", "_fst", " _lsts", "_sdbl", "_lST", "_rdbl", "_dest", "_fest", " _fbl", "_DST", " _lbl", "_Dbl", "_sdst", " _dbl", "_dbl", "_sdsts", " _lst", " _dsts", " _dest", "_dsts", " _dST", "_Dsts", "_lst", "_rdst", " _fest", "_Dest", " _fST", "_dST", " _lST", "_rdest", "_Dst", "_lbl"], "i": ["io", "e", "fi", "qi", "ri", "ui", "eni", "pi", "key", "gi", "d", "uri", "ti", "I", "f", "ci", "t", "r", "u", "m", "oi", "it", "j", "data", "phi", "info", "init", "ini", "p", "abi", "id", "o", "field", "bi", "attr", "c", "mu", "index", "si", "a", "ii", "b", "in", "ji", "iu", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "h", "l", "x", "zi", "k", "ni", "count"], "dst": ["DST", "Dst", " dST", "fST", "dST", "dconst", "fst", "dbl", "Dbl", " dbl", "Dconst", "nst", "sdST", "dsta", "ndbl", "fsts", "sdsta", "dsts", "ndST", "nest", " dest", " dconst", "ndst", "sdst", "ndsts", "nsta", "Dsts", "fconst", " dsts", "dest", "nST", " dsta", "sdest"]}}
{"project": "FFmpeg", "commit_id": "1f80742f49a9a4e846c9f099387881abc87150b2", "target": 1, "func": "static void fill_coding_method_array(sb_int8_array tone_level_idx,\n\n                                     sb_int8_array tone_level_idx_temp,\n\n                                     sb_int8_array coding_method,\n\n                                     int nb_channels,\n\n                                     int c, int superblocktype_2_3,\n\n                                     int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n}\n", "idx": 22956, "substitutes": {"tone_level_idx": ["tone_level_sidx", "tone_level_idsv", "tone_level_addy", "tone_level_addx", "tone_level_idez", "tone_level_idsx", "tone_level_infoz", "tone_level_addld", "tone_level_namexs", "tone_level_infoxs", "tone_level_endv", "tone_level_dv", "tone_level_addz", "tone_level_endx", "tone_level_ridx", "tone_level_idev", "tone_level_dx", "tone_level_infoc", "tone_level_ridxf", "tone_level_idsc", "tone_level_endxe", "tone_level_namex", "tone_level_idey", "tone_level_idsz", "tone_level_idld", "tone_level_ideld", "tone_level_idc", "tone_level_ridv", "tone_level_idec", "tone_level_endz", "tone_level_idsxs", "tone_level_sidv", "tone_level_infox", "tone_level_idex", "tone_level_endn", "tone_level_sidn", "tone_level_idxf", "tone_level_idxe", "tone_level_idy", "tone_level_dz", "tone_level_idv", "tone_level_dxe", "tone_level_ridxs", "tone_level_namexf", "tone_level_namev", "tone_level_sidz", "tone_level_idz", "tone_level_idxs", "tone_level_idn"], "tone_level_idx_temp": ["tone_level_idz_tem", "tone_level_idx_alt", "tone_level_idz_output", "tone_level_idz_temp", "tone_level_idx_index", "tone_level_idb_Temp", "tone_level_idst_flat", "tone_level_idx2flat", "tone_level_idb_level", "tone_level_idx_cache", "tone_level_idx_Temp", "tone_level_idst_table", "tone_level_idx_table", "tone_level_idst_cache", "tone_level_idx_flat", "tone_level_idz_alt", "tone_level_idst_temp", "tone_level_idx__temp", "tone_level_idx__alt", "tone_level_idx2table", "tone_level_idx2cache", "tone_level_idx_tem", "tone_level_idx_output", "tone_level_idx__index", "tone_level_idb_temp", "tone_level_idx2temp", "tone_level_idz_index", "tone_level_idx_level"], "coding_method": ["coder_function", "coding2type", "coder_method", "coder_type", "coding2function", "coding_function", "coding_round", "coder_round", "coding_type", "coding2method", "coding2round"], "nb_channels": ["nb_chones", "nb_pchannel", "nb_chans", "nb_pairs", "nb_cips", "nb_pannels", "nb_thords", "nb_thannels", "nb_vairs", "nb_thairs", "nb_chchannel", "nb_whans", "nb_cannels", "nb_vannels", "nb_Chips", "nb_chords", "nb_whips", "nb_Chans", "nb_vords", "nb_Chones", "nb_chairs", "nb_cans", "nb_pords", "nb_cones", "nb_chips", "nb_vchannel", "nb_Channels", "nb_thchannel", "nb_whannels", "nb_whones"], "c": ["conv", "lc", "cc", "e", "ct", "con", "cl", "f", "ci", "cmp", "ac", "nc", "m", "cp", "cache", "p", "mc", "xc", "enc", "rc", "sc", "b", "dc", "w", "cpp", "n", "C", "count"], "superblocktype_2_3": ["superblocktype_1_7", "superblocktype_2C3", "superblocktype_1_3", "superblocktype_2_23", "superblocktype_2O03", "superblocktype_2_03", "superblocktype_2O3", "superblocktype_2x03", "superblocktype_2x23", "superblocktype_2O7", "superblocktype_2_7", "superblocktype_1_23", "superblocktype_2C03", "superblocktype_1_03", "superblocktype_2C23", "superblocktype_2O23", "superblocktype_2C7", "superblocktype_2x3", "superblocktype_2x7"], "cm_table_select": ["cm_tablewcount", "cm_table2count", "cm_cache2count", "cm_cache2desc", "cm_cache2block", "cm_cache_select", "cm_cache_count", "cm_tablewdesc", "cm_table_desc", "cm_table2block", "cm_table2desc", "cm_cache_block", "cm_tablewblock", "cm_table_block", "cm_cache2select", "cm_table_count", "cm_cache_desc", "cm_table2select", "cm_tablewselect"], "ch": ["chn", "app", "ct", "cm", "Ch", "che", "y", "cp", "qu", "CH", "chart", "fr", " rc", "cham", "gh", "v", "conf", " cs", "cha", "col", "conn", "cor", "ich", "cel", "ci", "code", "rh", "q", "cb", "arch", "chip", "bh", "ce", "ph", "k", "vc", "lc", "hand", "uch", "chi", "f", "cmp", "cht", "p", "form", "cho", "b", "cy", "zh", "loc", "co", "th", "hw", "h", "ht", "count", "sch", "och", "sk", "ach", "chan", "cl", "ky", "cle", "ctx", "cn", "sh", "he", "se", "chu", "cher"], "sb": ["bc", "sv", "i", "chal", "bp", "bg", "sit", "wb", "dy", "ib", "dl", "n", "src", "ff", "bm", "nb", "rb", "kr", "l", "ss", "jp", "g", "db", "bb", "cel", "sth", "split", "s", "sy", "SB", "sg", "cb", "sm", "sc", "ji", "sf", "yi", "bh", "bash", "su", "bj", "lc", "lb", "sel", "sie", "usb", "nn", "shop", "fb", "eb", "obb", "job", "bps", "zon", "sd", "num", "si", "b", "sub", "length", "sup", "zh", "loc", "jc", "bf", "cod", "secondary", "stab", "sq", "abb", "gb", "span", "pb", "sk", "sci", "sl", "btn", "bl", "lr", "jj", "ctrl", "sync", "sa", "ctx", "cn", "sh", "bs", "sn", "sp"], "j": ["ja", "je", "i", "jl", "ie", "obj", "jp", "ind", "adj", "g", "nn", "ui", "part", "jen", "d", "temp", "f", "jj", "ju", "uj", "dj", "r", "y", "m", "u", "it", "kj", "jet", "p", "job", "o", "q", "dy", "pr", "js", "aj", "el", "fr", "si", "J", "b", "x", "ji", "ij", "n", "em", "br", "jc", "v", "z", "jan", "sp", "sn", "li", "h", "jo", "note", "l", "bj", "k"], "tmp": ["txt", "obj", "app", "jp", "config", "amp", "adj", "input", "yy", "xxx", "fb", "bb", "tt", "temp", "pad", "img", "emp", "cmp", "jj", "fake", "pre", "cp", "treatment", "cache", "zip", "opt", "tp", "p", "diff", "prefix", "tc", "Temp", "np", "elt", "buf", "rc", "kk", "cb", "mm", "beta", "mp", "xxxx", "stuff", "ff", "src", "perm", "sup", "loc", "test", "xxxxxxxx", "buff", "proc", "bf", "alpha", "v", "sp", "rb", "att", "output", "attr"], "acc": ["ACC", "cc", "uc", "fac", "app", "circ", "ind", "amp", "config", "adj", "gain", "input", "inc", "ack", "rec", "eff", "emp", "cmp", "exc", "ac", "rate", "aug", "ad", "cache", "abc", "ani", "num", "add", "pass", "test", "alpha", "conf", "Acc", "att", "attr", "count"], "esp_40": ["esp_result", "esp_num", "asm_40", "asm_time", "esp_time", "asm_num", "asm_result"], "comp": ["grad", "omp", "circ", "config", "amp", "com", "cond", "time", "rec", "cmp", "pos", "op", "cp", "cache", "frac", "unit", "change", "mod", "code", "seq", "comb", "co", "proc", "lib", "conf", "quad"], "add1": ["att1", " add1001", "add6", " add6", "addOne", "added2", "update55", "att2", "added1001", "access1", "push2", "AddOne", " add55", "push1", "access55", "dd4", " add99", "Add1", "dd2", "pushOne", "Add6", "update99", "access99", "add99", "dd1", "att0", "ad4", "ad3", "push3", "Add2", "accessOne", "Add4", "added0", "add1001", "added1", "add55", "Add3", " addOne", "ad6", " add0", "update1", "ad1", "updateOne", "att1001", "add0"], "add2": ["added02", "ad2", "add8", "incTwo", "added2", "add182", "address96", " addtwo", "added12", "add5", "address02", "push2", "address182", "index8", "inc4", "add96", "append02", "addedTwo", "change4", "Add1", "append96", "add02", "change1", "change2", "added8", "indexTwo", "index2", "ad4", "push02", "push96", "adTwo", "Add2", "index4", "add12", "added4", "append2", "Add4", "Addtwo", "inc2", "changetwo", "ad5", " addTwo", "added5", " add02", " add5", "addTwo", "append182", "address2", "push182", "inc12", "ad02", " add12", "addtwo", " add8"], "add3": ["ADD30", "add43", "inc103", "plus53", "build3", "show3", " add30", "plus3", "addThree", "added4", "pushThree", "app83", "inc3", "added1", "address48", "add53", "append48", "address3", "inc15", "incThree", "app48", "append53", "Add1", "app123", " add53", "Add53", "add83", "push4", "show48", "inc18", "attthird", "build103", "append103", "added53", "add23", "add123", "add103", "build48", "ADD23", "att43", "push15", "append43", "added3", "att3", "push3", "appendthird", "added30", "Add3", "add48", "show83", "plusthird", " add15", "inc48", "inc4", "address123", "address83", "app3", " addThree", "ADD3", "ADD4", " add23", "added23", "append18", "build18", "add18", "append3", "plus43", "att53", "add15", "addthird", "show123", "add30"], "add4": ["mod2", "ad2", "inc256", "show2", " add6", "mod4", "load2", "show104", " add48", "pushfour", "add5", "push2", "sumfour", "addedFour", "inc4", "push04", "load48", "added44", "Add5", "mod6", "mod5", "sum256", "load4", " add104", "Add6", "add44", "add04", "push4", "show4", "load104", "ad4", "addFour", "ad3", "ADD4", "addfour", "sum4", "Add2", "show48", "added4", "ADD44", "Add4", "add104", "inc2", " addfour", "Add3", " add256", "incfour", " add5", "inc04", "add48", " add44", "sum2", " addFour", "ADDFour", "add6", "add256", " add04"], "multres": ["countreed", "centre", "addreed", "countre", "centres", "addrix", "rendrix", "addres", "rendreed", "centreed", "rendres", "countrix", "centrix", "rendre", "addre", "countres"]}}
{"project": "FFmpeg", "commit_id": "9ec39937f9c7f28a2279a19f71f290d8161eb52f", "target": 1, "func": "static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,\n\n                        int width, int height, int stride, Transform *t)\n\n{\n\n    int x, y;\n\n    IntMotionVector mv = {0, 0};\n\n    int counts[128][128];\n\n    int count_max_value = 0;\n\n    int contrast;\n\n\n\n    int pos;\n\n    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));\n\n    int center_x = 0, center_y = 0;\n\n    double p_x, p_y;\n\n\n\n    // Reset counts to zero\n\n    for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n        for (y = 0; y < deshake->ry * 2 + 1; y++) {\n\n            counts[x][y] = 0;\n\n        }\n\n    }\n\n\n\n    pos = 0;\n\n    // Find motion for every block and store the motion vector in the counts\n\n    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {\n\n        // We use a width of 16 here to match the libavcodec sad functions\n\n        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {\n\n            // If the contrast is too low, just skip this block as it probably\n\n            // won't be very useful to us.\n\n            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);\n\n            if (contrast > deshake->contrast) {\n\n                //av_log(NULL, AV_LOG_ERROR, \"%d\\n\", contrast);\n\n                find_block_motion(deshake, src1, src2, x, y, stride, &mv);\n\n                if (mv.x != -1 && mv.y != -1) {\n\n                    counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1;\n\n                    if (x > deshake->rx && y > deshake->ry)\n\n                        angles[pos++] = block_angle(x, y, 0, 0, &mv);\n\n\n\n                    center_x += mv.x;\n\n                    center_y += mv.y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pos = FFMAX(1, pos);\n\n\n\n    center_x /= pos;\n\n    center_y /= pos;\n\n\n\n    t->angle = clean_mean(angles, pos);\n\n    if (t->angle < 0.001)\n\n        t->angle = 0;\n\n\n\n    // Find the most common motion vector in the frame and use it as the gmv\n\n    for (y = deshake->ry * 2; y >= 0; y--) {\n\n        for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n            //av_log(NULL, AV_LOG_ERROR, \"%5d \", counts[x][y]);\n\n            if (counts[x][y] > count_max_value) {\n\n                t->vector.x = x - deshake->rx;\n\n                t->vector.y = y - deshake->ry;\n\n                count_max_value = counts[x][y];\n\n            }\n\n        }\n\n        //av_log(NULL, AV_LOG_ERROR, \"\\n\");\n\n    }\n\n\n\n    p_x = (center_x - width / 2);\n\n    p_y = (center_y - height / 2);\n\n    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;\n\n    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;\n\n\n\n    // Clamp max shift & rotation?\n\n    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);\n\n    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);\n\n    t->angle = av_clipf(t->angle, -0.1, 0.1);\n\n\n\n    //av_log(NULL, AV_LOG_ERROR, \"%d x %d\\n\", avg->x, avg->y);\n\n    av_free(angles);\n\n}\n", "idx": 22959, "substitutes": {"deshake": ["ldeshak", "dellak", "pardeshake", "denseale", "duzzleale", "dhesase", "deshaker", "dadhave", "deseame", "dscheake", "ldellinate", "gethare", "dhattanaker", "teshase", "dethase", "densease", "ldeshoise", "denseake", "deshure", "denseack", "deshane", "deshoise", "leseare", "dhemak", "dhattanave", "teshaker", "dhedinate", "nalshake", "delshare", "dephaker", "dhedatch", "deske", "dalshale", "dalshak", "delshack", "desak", "dhesak", "dhedane", "duscheose", "dscheuke", "lduzzleale", "lduzzleave", "dehape", "dahade", "teseake", "dhattanake", "dhemaker", "deshase", "dhedake", " denseack", "desease", "nalshaker", "geshape", "ondeseare", "dadhak", "neshak", "desisake", "tishak", "dhemake", "doeake", " denseare", "ldeshaker", "ineshure", "dishace", "lduzzleake", "desake", "pardhattanave", "dhedaker", "ineshak", " deshase", "fhesace", "fhesame", "dalshape", "feshace", "denseaker", "deseak", "dadhase", " dleshare", "ondeseake", "dhedave", "deseake", "dalshaker", "deseape", "dehak", "dhesure", "delshase", "deseke", "deseaker", "doeak", "dashake", "dahake", "dishame", " denseake", "feshake", "dueshke", " dhemaker", "deshatch", "dleshake", "ondeshak", "pardeshave", "teseak", "dalshade", "pardhattanane", "dehaker", "tesease", "ldelloise", "dellinate", "dashak", "dhedoise", "inhedure", "ghedatch", "deshke", "dscheose", "ldeshave", "dhesaker", "ondeshaker", "ldellake", "ghedase", "dephare", "dshake", "denseave", "dleshase", "desape", "feshame", "doodleke", "dleshade", "doodleake", "dhedak", "dhesale", "dueshake", "dehake", "dephak", "teshak", " dleshase", "dleshare", "ldeshale", "ghedale", "dhesame", "desare", "doease", "doeare", "dadhare", "dshatch", "doodleose", "deshack", "dishare", "deshuke", "dethake", "dhedure", "teseke", "feshare", "deshise", "ondeseaker", "deshare", "duscheke", "deshave", "ldeshake", "desisaker", "deshade", "denseak", " densease", " dhemise", "dshase", "dashaker", "geshake", "geshak", "geshase", "nalshape", " dleshak", "delshake", "denseare", "pardhattanake", "dshale", "ondeseak", "teshake", "fhesare", "leshare", "duscheake", "denseatch", "inhedake", "deshape", " deshise", "neshaker", "deseise", "pardhattanaker", "dishaker", "dueshose", "tishake", "dhedose", "leseape", "denseape", "dadhale", " dhemak", "dueshuke", "dadhake", "dishake", "deshale", " deshaker", "dahak", "teshke", " deshak", "dhemise", "dheduke", "inhedak", "dashise", "dhesack", "tishaker", "dhesace", "gethak", " dhemake", "delloise", "geshale", "leseale", "deshak", "desisade", "ldellak", " deshack", "leshape", "dhedale", "pardeshane", "duscheuke", "dhesake", "deseace", "ondeshare", "dahale", "nalshak", "leseake", "dhemave", "dleshaker", "desisak", "ghedake", "duzzleaker", "ondeshake", "dhesinate", "deshame", "dishade", "dalshake", "desale", "pardeshaker", "dscheke", "ineshake", "neshake", "dhedase", "deshace", "inhedaker", "leshake", "leshale", "deseure", "lduzzleaker", "ldeshinate", "desase", "gethape", " deshare", "dhattanane", "geshare", "dethare", "ineshaker", "dethape", "fhesake", "deshinate", "deseale", "dethak", "dhesoise", "deseade", "duzzleake", "dleshak", "dephake", "teshade", "neshape", "dishak", "dhesare", "deshose", "dhedke", "dellake", "dhemane", " dleshake", "dethke", "dadhaker", "geshatch", "dhesape", "doodleuke", "tishade", "duzzleave", "gethake", "deseare"], "src1": [" src0", "source1", "source2", "rcone", " src3", "rc3", "source3", "src0", "rc2", "rc0", "srcone", "rcOne", "rc1", "source0", " srcOne", " srcone", "sourceone", "srcOne", "src3", "sourceOne"], "src2": ["proc5", "proc1", "source02", "srcTwo", "procsecond", " src0", "rb2", "source1", "sourceTwo", "source2", "rb1", "inst5", "proc2", "rctwo", "rb0", " srctwo", "src02", "src0", "rc2", "instsecond", "rc0", "src5", "rc5", "img1", " src02", " srcTwo", "rcsecond", "rc1", "inst1", "img2", "imgTwo", "inst2", "rbtwo", "img02", "srcsecond", "srctwo"], "height": ["row", "shape", "lat", "inches", "square", "level", "rows", "layout", "d", "style", "ty", "Height", "dir", "size", "hang", "id", "rh", "depth", "dy", "three", "crop", "thin", "density", "dim", "deep", "window", "direction", "w", "stroke", "top", "length", "flow", "angle", "alpha", "radius", "resolution", "h", "scroll", "bottom", "padding"], "stride": ["trided", " stridi", "tride", "stande", " strad", "strade", "striad", "trate", " strided", "shrided", "tridi", "striade", "stided", "strad", "decided", "decade", "stridi", " strate", "shride", " strande", "decande", "stad", "striided", "strande", "stide", "stade", "strided", "shrate", "decide", "shridi", " strade", "strate", "striide"], "t": ["ut", "i", "port", "e", "table", "g", "d", "tr", "tt", "tor", "ti", "temp", "f", "r", "m", "unt", "it", "tp", "bt", "p", "ts", "at", "ret", "tc", "o", "ant", "c", "tf", "dt", "rt", "b", "ta", "w", "T", "n", "tools", "ot", "tower", "tw", "v", "qt", "tm", "st", "h", "att", "pt", "l", "type"], "x": ["i", "ya", "lat", "ct", "wa", "xe", "pe", "xs", "xy", "key", "xx", "pixel", "path", "ex", "data", "j", "xc", "work", "dy", "px", "ic", "n", "wx", "v", "image", "l", "an", "type", "name", "ix", "cross", "ux", "rx", "d", "u", "s", "fx", "yx", "code", "ye", "c", "dx", "X", "xa", "on", "xi", "ph", "e", "xt", "xxx", "time", "tx", "host", "weight", "f", "sex", "one", "size", "xf", "p", "el", "b", "ax", "z", "h", "wd", "m", "id", "index", "ady", "wy", "xp", "w", "min", "hi"], "y": ["sky", "i", "ya", "hy", "area", "e", "ery", "start", "yan", "yn", "vy", "yy", "yer", "xy", "key", "ay", "d", "ny", "ty", "yo", "yr", "yt", "xx", "ky", "f", "ey", "ish", "sy", "j", "oy", "ys", "p", "id", "gy", "o", "year", "dy", "ye", "py", "iy", "c", "ady", "wy", "ch", "b", "iny", "Y", "w", "cy", "zy", "ym", "n", "asy", "yl", "lon", "ry", "z", "yi", "v", "h", "k", "type"], "counts": ["countances", "seqings", " countments", "condp", "Counts", "seqs", " countances", "weights", "lengthances", "condings", "Countds", "weightds", "conds", "countps", "seqments", "lengthps", "Countings", "weightances", "weightps", "weightings", "lengthds", "Countances", "Countps", "seqp", " countps", " countings", "lengths", "countp", "countings", "countments", " countp", "countds", "condments"], "contrast": ["ucistor", "distness", "consrast", "contness", "Conturation", "containt", "Contistor", "contractor", " contrib", "Contractor", "contistor", "Containt", "continrast", "disterence", "extractor", " contractor", "conturation", "Contrib", "extrast", "Contness", "continuration", "ucrast", " contness", "consaint", "continraction", "contraction", "conterence", "continness", "ucaint", "consness", "Contraction", "extness", "Conterence", "distrast", "contrib", " conterence", " conturation", "consistor", "Contrast", "extrib", "ucness", " contraction"], "pos": ["col", "port", "i", "start", "config", "none", "val", "part", "pi", "cond", "style", "POS", "pc", "no", "po", "neg", "ac", "axis", "size", "cache", "rel", "os", "p", "Pos", "unit", "diff", "id", "slot", "o", "px", "index", " position", "pro", "spec", "pass", "num", "pose", "pid", "pres", "seq", "ass", "min", "n", "Position", "len", "loc", "ps", " positions", "z", "conf", "sp", "block", "position", "pt", "offset", "all", "prop", "type", "nos"], "angles": ["rots", "ions", "mol", "shape", "types", "units", "inches", "anges", "es", "xs", "lines", "boxes", "hours", "ings", "archs", "faces", "chains", "abi", "params", "actions", "holes", "cb", "xes", "breaks", "styles", "images", "angled", "forces", "ii", "bits", "letters", "limits", "blocks", "objects", "ads", "rings", "les", " angle", "length", "angular", "slice", "points", "states", "angle", "ps", "gs", "sticks", "array", "cuts", "balls", "image", "ots", "quad", "bands", "eps", "padding", "ays"], "p_x": ["p_xy", "p_w", " p_w", " p_xy"], "p_y": [" p_i", "p_i", "p_cy", " p_cy"]}}
{"project": "FFmpeg", "commit_id": "984f50deb2d48f6844d65e10991b996a6d29e87c", "target": 1, "func": "static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)\n\n{\n\n    DiracContext *s     = avctx->priv_data;\n\n    AVFrame *picture    = data;\n\n    uint8_t *buf        = pkt->data;\n\n    int buf_size        = pkt->size;\n\n    int i, data_unit_size, buf_idx = 0;\n\n    int ret;\n\n\n\n    /* release unused frames */\n\n    for (i = 0; i < MAX_FRAMES; i++)\n\n        if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {\n\n            av_frame_unref(s->all_frames[i].avframe);\n\n            memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));\n\n        }\n\n\n\n    s->current_picture = NULL;\n\n    *got_frame = 0;\n\n\n\n    /* end of stream, so flush delayed pics */\n\n    if (buf_size == 0)\n\n        return get_delayed_pic(s, (AVFrame *)data, got_frame);\n\n\n\n    for (;;) {\n\n        /*[DIRAC_STD] Here starts the code from parse_info() defined in 9.6\n\n          [DIRAC_STD] PARSE_INFO_PREFIX = \"BBCD\" as defined in ISO/IEC 646\n\n          BBCD start code search */\n\n        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {\n\n            if (buf[buf_idx  ] == 'B' && buf[buf_idx+1] == 'B' &&\n\n                buf[buf_idx+2] == 'C' && buf[buf_idx+3] == 'D')\n\n                break;\n\n        }\n\n        /* BBCD found or end of data */\n\n        if (buf_idx + DATA_UNIT_HEADER_SIZE >= buf_size)\n\n            break;\n\n\n\n        data_unit_size = AV_RB32(buf+buf_idx+5);\n\n        if (buf_idx + data_unit_size > buf_size || !data_unit_size) {\n\n            if(buf_idx + data_unit_size > buf_size)\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Data unit with size %d is larger than input buffer, discarding\\n\",\n\n                   data_unit_size);\n\n            buf_idx += 4;\n\n            continue;\n\n        }\n\n        /* [DIRAC_STD] dirac_decode_data_unit makes reference to the while defined in 9.3 inside the function parse_sequence() */\n\n        if (dirac_decode_data_unit(avctx, buf+buf_idx, data_unit_size))\n\n        {\n\n            av_log(s->avctx, AV_LOG_ERROR,\"Error in dirac_decode_data_unit\\n\");\n\n            return -1;\n\n        }\n\n        buf_idx += data_unit_size;\n\n    }\n\n\n\n    if (!s->current_picture)\n\n        return buf_size;\n\n\n\n    if (s->current_picture->avframe->display_picture_number > s->frame_number) {\n\n        DiracFrame *delayed_frame = remove_frame(s->delay_frames, s->frame_number);\n\n\n\n        s->current_picture->avframe->reference |= DELAYED_PIC_REF;\n\n\n\n        if (add_frame(s->delay_frames, MAX_DELAY, s->current_picture)) {\n\n            int min_num = s->delay_frames[0]->avframe->display_picture_number;\n\n            /* Too many delayed frames, so we display the frame with the lowest pts */\n\n            av_log(avctx, AV_LOG_ERROR, \"Delay frame overflow\\n\");\n\n\n\n            for (i = 1; s->delay_frames[i]; i++)\n\n                if (s->delay_frames[i]->avframe->display_picture_number < min_num)\n\n                    min_num = s->delay_frames[i]->avframe->display_picture_number;\n\n\n\n            delayed_frame = remove_frame(s->delay_frames, min_num);\n\n            add_frame(s->delay_frames, MAX_DELAY, s->current_picture);\n\n        }\n\n\n\n        if (delayed_frame) {\n\n            delayed_frame->avframe->reference ^= DELAYED_PIC_REF;\n\n            if((ret=av_frame_ref(data, delayed_frame->avframe)) < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    } else if (s->current_picture->avframe->display_picture_number == s->frame_number) {\n\n        /* The right frame at the right time :-) */\n\n        if((ret=av_frame_ref(data, s->current_picture->avframe)) < 0)\n\n            return ret;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    if (*got_frame)\n\n        s->frame_number = picture->display_picture_number + 1;\n\n\n\n    return buf_idx;\n\n}\n", "idx": 22966, "substitutes": {"avctx": ["aveconfig", "avecas", "AVcmp", "airconfig", "afca", "avectrl", "avhw", "airctx", " avconfig", "airhw", "afcmp", "avconn", "avconfig", "AVctrl", "afhw", "afctx", "avexc", "AVcontext", "avcas", "avca", "akcontext", "AVhw", "afcas", "akctx", "avecontext", "aircmp", "avcontext", "akca", "avxc", "abctx", "AVconn", "avalctrl", "avalctx", "avalconn", "aircas", "afconfig", "abcas", "avectx", " avxc", "abcontext", "avcmp", "afcontext", "AVctx", "aircontext", "avalcontext", "avctrl", " avcontext", "aveconn", "afxc", "abca", "akcas"], "data": ["package", "binary", "name", "start", "def", "next", "object", "obj", "config", "valid", "ui", "result", "input", "val", "xxx", "board", "message", "Data", "meta", "queue", "d", "metadata", "style", "align", "img", "f", "buffer", "device", "ata", "info", "m", "size", "da", "cache", "new", "p", "o", "code", "body", "client", "content", "memory", "frame", "audio", "index", "ctx", "a", "DATA", "window", "draw", "media", "reader", "slice", "feed", "database", "batch", "parent", "buff", "alpha", "dat", "base", "li", "image", "empty", "block", "api", "video", "value"], "got_frame": ["got_large", "gotencycle", "gotayiframe", "got__cycle", "gotenversion", "gotenpixel", "got__version", "got_iframe", " got_component", " got_large", "gotkversion", "gotaylarge", "got___frame", "got_version", "gotkpixel", " got__version", " got__cycle", "got_component", "got_image", "got_cycle", " got__pixel", " got_iframe", "gotayframe", " got_version", "got___position", "gotenframe", " got__frame", " got_pixel", "got__frame", "got___component", "gotkframe", " got_position", "gotkcycle", "got___image", " got_cycle", "got_pixel", " got_image", "got__pixel", "got_position"], "pkt": [" punt", "Packet", " pct", "Pct", "bnt", "backet", "biece", "punt", "pett", "Punt", " piece", "bett", "piece", " pett", "pnt", "fiece", "spqt", "Pqt", "Pett", "bkt", "bct", " pqt", " pnt", "spkt", "Pkt", "packet", "fnt", "fkt", "spunt", " packet", "pqt", "pct", "facket", "spacket"], "s": ["sv", "bis", "es", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "S", "ns", "rs", "http", "conf", "l", "this", "ss", "sb", "g", "ses", "d", "sets", "as", "services", "sites", "sg", "c", "self", "spec", "sc", "a", "sf", "su", "e", "sym", "qs", "hs", "fs", "f", "full", "p", "groups", "si", "service", "parts", "sup", "events", "ps", "gs", "sq", "sk", "ops", "ks", "m", "its", "ls", "sync", "is", "sa", "ctx", "se", "session", "comments", "bs", "states"], "picture": ["summary", "cam", "obj", "config", "meta", "Picture", "img", "buffer", "pict", "info", "m", "stat", "pic", "filename", "ctx", "cb", "frame", "profile", "media", "slice", "doc", "v", "avi", "vec", "image", "photo", "fi", "video"], "buf": ["conv", "bc", "pb", "port", "ru", "uf", "uc", "ba", "ref", "config", "text", "av", "board", "ha", "pkg", "cv", "fb", "queue", "func", "cur", "img", "home", "fp", "wave", "buffer", "alloc", "bu", "grab", "box", "raf", "p", "cf", "uv", "np", "wb", "rc", "font", "cb", "ctx", "mem", "b", "bo", "profile", "window", "seq", "ff", "src", "fd", "fw", "loc", "br", "ab", "feed", "buff", "v", "vec", "bag", "fam", "bus", "block", "rb", "um", "feat", "cap", "capt"], "i": ["io", "lc", "e", "ix", "ie", "fi", "qi", "ri", "iv", "ui", "eni", "pi", "ki", "gi", "d", "uri", "ti", "I", "f", "ci", "t", "y", "u", "oi", "ini", "m", "size", "it", "j", "phi", "info", "p", "ip", "abi", "id", "o", "bi", "cli", "mi", "c", "mu", "index", "si", "a", "ii", "b", "n", "iu", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "yi", "h", "api", "l", "x", "zi", "k", "ni"], "data_unit_size": ["data_unit__len", "data_units_scale", "data_transfer_name", "data_units_count", "data_unit2length", "data_unit___size", "data_unit_scale", "data_units_size", "data_unitfullsize", "data_unit_start", "data_unitfullscale", "data_unit_length", "data_unit_address", "data_unit___id", "data_unit_style", "data_Unit_scale", "data_unit_adjust", "data_transfer_start", "data_unit_len", "data_units_len", "data_unit__scale", "data_unit__count", "data_Unit_size", "data_transfer_size", "data_unitfullstyle", "data_Unit_name", "data_unit__size", "data_unit_id", "data_unit2address", "data_unit_number", "data_unit_count", "data_unit2size", "data_unit_name", "data_unit___adjust"], "ret": [" fin", " li", " r", " pri", " ip", " arr", "Ret", "f", " counter", "r", " mi", " def", " il", " pi", " fid", " rc", " rows", " fu", " init", " di", " bi", " disp", " ptr", " res", " result"], "buf_idx": ["buf_ilxx", "buf_argq", "buf_idex", "buf_errorxf", "buf_Ide", "buf0IDex", "buf_fx", "buf0idxf", "buf0IDxf", "buf_idsct", "buf_edz", "buf_sideis", "buf0idex", "buf_Idct", "buf_sidex", "buf_errorces", "buf_edxs", "buf_pathxs", "buf_ardxs", "buf_Idxb", "bufPidze", "bufPidxs", "buf_idis", "buf_idxx", "buf_indb", "buf_mainp", "buf_Idxx", "buf_edy", "buf_addest", "buflexidco", "buf_idg", "buf_idxs", "buf_argis", "buflexidis", "buf_ilx", "buf_erxx", "buf_keyz", "buf_IDx", "buf_countxx", "buf_idsz", "buf_Idze", "buf_erz", "buf_sideq", "bufOidxx", "buf_pidq", "buf_keyxs", "buf_idsw", "buf_idze", "buf0idx", "buf_sidesw", "buf_mainx", "buflexmainp", "buf_namex", "buf_namez", "buf_pidx", "buf_keyco", "bufOcountxx", "buf_pathy", "buf0idl", "buf_idxf", "buf_ilz", "buflexidp", "buf_idc", "buf_nameg", "buf_indxs", "buflexidq", "bufOidld", "bufPidy", "buflexsidesw", "buf_indl", "buflexmainco", "buf_addp", "buf_idep", "buflexmainx", "buf_idsxs", "buflexidx", "bufOidy", "buf_ide", "buf_edld", "buf_IDll", "buf_idy", "bufOcounty", "buf_IDxf", "buf_ideest", "buf_errorl", "buf_idk", "buflexidest", "buf_errorex", "buf_idq", "buf_pathx", "buf_idxb", "buf_idct", "buf_pidis", "buf_pidsw", "buf_erxb", "buf_ardze", "buf_countx", "buflexmainest", "buf_IDz", "buf_erc", "buf_mainest", "buf_IDb", "buf_idll", "buf_Idc", "buf_IDex", "buf_edze", "buf_indct", "bufPidx", "buf_erx", "buf_IDg", "buf_addx", "buf_ideco", "buf_errory", "buflexsideis", "buf_keyx", "buf_pathze", "buf_addco", "buf_edx", "bufPfx", "buf_ardx", "buf_Idx", "buf_fxs", "buflexsideq", "bufPfy", "buflexidsw", "buf_indx", "buf_idces", "buf_argx", "buf0IDx", "bufPfze", "buf_idsx", "buf_idco", "buf_ardz", "buf_idest", "buf_namell", "buf_indz", "buf_Idz", "buf_mainco", "bufOcountx", "bufOidx", "buf_idld", "buf_argsw", "buf_ilxs", "buf0IDl", "buf_maink", "buf_idp", "buf_index", "buf_fy", "buf_fze", "buf_ere", "buf_errorx", "buf_ilco", "buf_edxx", "buf_countld", "bufOcountld", "bufPfxs", "buf_Idxs", "buf_idl", "buf_mainces", "buf_idz", "buf_mainy", "buflexsidex", "buf_indxf", "buf_errork", "buf_county", "buf_IDl", "buf_ile", "buf_idb"]}}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969, "substitutes": {"env": ["inv", "sb", "enh", "txt", "e", "en", "conn", "eu", "config", "sl", "chal", "ses", "eni", "impl", "dh", "engine", "ds", "ea", "f", "win", "exec", "esi", "exc", "nc", "init", "cache", "state", "ssl", "enc", "setup", "vs", "dict", "context", "np", "Environment", "settings", "c", "ctx", "esm", "viron", "session", "inst", "console", "sf", "iss", "v", "conf", "dat", "estate", "ev", "environment", "scope", "server", "ec"], "s": ["ions", "sv", "sb", "native", "e", "qs", "bis", "es", "sl", "fs", "g", "ses", "xs", "d", "sets", "ops", "site", "ds", "services", "f", "local", "sys", "t", "r", "m", "socket", "storage", "state", "stat", "ssl", "p", "setup", "us", "o", "sync", "sites", "stats", "sg", "c", "settings", "js", "ctx", "spec", "sq", "si", "sc", "b", "service", "session", "S", "src", "ns", "n", "sf", "proc", "http", "v", "server", "scope", "ss", "states"], "insn": ["incd", "insm", "insd", "idsz", "ssm", "incpace", "INSnin", "opsn", "insnc", "insv", "inspace", "incN", "INSc", "vinb", "insz", "incne", "INSsn", "linsc", "insnin", "inassn", "INSm", "inasnin", "intsz", "ainsne", "incnt", "inasv", "nspace", "INSN", "intsn", "INSconn", "INSd", "nsn", " insl", "ssnt", "idsd", "vinN", "inccn", "linesnt", "opsnin", "insl", "insc", "INSz", "INSn", "ssne", "insN", "ssn", "intsnc", "ssd", "idsnc", "insne", "idscn", "ainsz", "INSnc", "linsn", "linsN", "ainsn", "insen", "intsN", "linesN", "INSnt", "opsv", "upsne", "INSv", "intsc", "nsne", "incb", "inssn", "INSl", "inscn", "idsN", "linesn", "intsl", "incn", "inasn", "intsconn", " insnc", "INSen", "INScn", "ssN", "INSne", "upsN", " insne", "intsm", " insconn", " insen", "insnt", "idsl", "ainsen", "vinn", "idsn", "insconn", "opssn", "incc", "linsb", "intsne", "upsn", " insz", "nsnc", "vinc", "linesd", "upsnt", "insb", " insc", "incnc", "INSpace"], "opsize": ["opensIZE", "opersization", " opspace", "outssize", "psizer", "topsization", "offsization", "ipsized", "piecesization", "bitsizing", "topsizer", "opersize", "outsization", "vssize", "vertsize", "OPSizer", "opsizer", "opssize", "pssize", "opensizer", "vsize", "oosize", "pinsizer", "bitspace", "opersized", "bitsiz", "upsizer", "OPSiz", "piecesizer", "outsize", "opsizing", "outsized", "offsizer", "bitsizer", "upsize", "oosizer", "piecesize", "openssize", "copization", "nosizer", "oopsizer", "oosizing", "coppace", "vertsization", "vertsiz", "vsization", "topsize", "pinssize", "vertsizer", " opsIZE", "copizer", "offsize", "OPSIZE", "OPSize", "piecesiz", "ipsizer", "opsized", "OPSsize", "pinsization", "nosize", "OPSized", "bitsize", "posization", "copize", "opensizing", "nosized", "opsIZE", "topsized", "posize", "upsIZE", "nosization", "posized", "opensized", "ipsize", "opsiz", "ipsization", "psize", "opspace", "upssize", "opensize", "vsized", "opensiz", "opersiz", "offsiz", "oopsize", " opsizer", "psization", "posizer", "opensization", "bitsization", "oopsIZE", "outsiz", "pinsize", " opsization", "oopsization", "opsization", "OPSization", "oosiz"], "val": ["bc", "ival", "expr", "grad", "def", "serv", "sel", "ig", "store", "ref", "ind", "valid", "sl", "arg", "func", "bl", "local", "win", "pos", "exec", "al", "alloc", "data", "stat", "ret", "arr", "play", "vals", "p", "fun", "slot", "unit", "var", "vi", "buf", "ctx", "el", "pl", "aval", "cal", "rule", "seq", "vol", "call", "slice", "loc", "len", "VAL", "Val", "util", "lib", "v", "doc", "eval", "all", "x", "feat", "prop", "value"], "addrp": ["addresspi", "ordps", "addressps", "drps", "ptrpr", "attrpin", "addresspc", "hoppc", "argp", "ptrp", "armpin", "addrpr", "alignpr", "addresspe", "argps", "alignp", "attrpi", "drp", "addrpre", "argP", "drpc", "lenpe", "addrP", "alignps", "alignpa", "ordv", "hostpe", " addrP", "ptrP", "addressc", " addrv", "addrpin", "addrv", "argpc", "addrpe", "addrpi", "drpr", "lenp", "hostP", "hostp", "addressP", "armp", "drpre", "hopv", " addrpc", "hostpc", "attrp", "alignpc", " addrpr", "addresspin", "addressv", "hostv", "drP", "addressp", "ordP", "addrps", "argpr", " addrps", "hostps", "attrP", "armP", "ptrpa", " addrc", "ordp", "alignP", "argpre", "hopc", "addrc", "lenpc", "addrpc", " addrpre", "hopp", "armpi", "addrpa", " addrpa"], "what": ["about", "app", "event", "none", "What", "hat", "other", "exc", "wh", "work", "which", "pl", "rule", "make", "there", "test", " What", "task", "doc", "util", "feat", "truth", "who", "theme", "type", "col", "name", "meaning", "wrong", "item", "non", "existing", "ack", "something", "style", "al", "fact", "component", "current", "when", "unit", "self", "spec", "pres", "channel", "anything", "whatever", "action", "like", "how", "thing", "menu", "nic", "you", "good", "that", "by", "function", "again", "it", " how", "act", "module", "ask", "form", "resource", "fun", "why", "hop", "arg", "yes", "args", "nothing", "diff", "missing", "w", "also", "chrom", "all", "where", "WHAT", "here", "value"], "reg": ["rol", "app", "config", "pred", "wa", "lex", "win", "r", "acc", "rest", "data", "bg", "leg", "var", "mem", "rule", "re", "erg", "br", "comb", "proc", "feat", "rg", "org", "ig", "conn", "g", "db", "eng", "sign", "pg", "op", "res", "stat", "greg", "enc", "mod", "code", "ng", "sg", "rc", "ann", "Reg", "eg", "urg", "store", "sam", "err", "ref", "region", "rem", "func", "rec", "function", "exec", "round", "ret", "play", "gen", "num", "form", "REG", "gr", "loc", "req", "sec", "lang", "mn", "fun", "adj", "arg", "bl", "cl", "ro", "aug", "cache", "abc", "tag", "run", "seq", "debug", "root", "record", "value"], "result": ["feat", "output", "found", "row", "transform", "response", "err", "event", "valid", "config", "true", "region", "cur", "function", "results", "cmp", "order", "master", "acc", "res", "round", "final", "data", "rest", "new", "method", "ret", "cache", "arr", "dict", "diff", "work", "current", "runner", "answer", "comment", "success", "rc", "complete", "match", "run", "replace", "rule", "Result", "date", "re", "session", "child", "mask", "test", "br", "page", "root", "parent", "proc", "report", "up", "array", "rb", "resource", "group", "su", "record", "resp", "compl", "value"], "offset": ["start", "off", "ref", "err", "map", "unc", "extra", "ops", "align", "pos", "op", "alloc", "order", "data", "shift", "index", "num", "seq", "error", "Offset", "loc", "len", "empty", "base", "count"], "tmp": ["property", "next", "app", "vt", "amp", "config", "part", "extra", "pad", "temp", "bp", "cp", "data", "bug", "tp", "params", "cpp", "ff", "slice", " obj", "test", "nb", "wx", "proc", "v", "dest", "rb", "resp", "output", "attr", "txt", "jp", "pkg", "private", "bb", "tt", "handler", "cont", "term", "pre", "current", "buf", "cb", "mp", "appy", "empty", "su", "prop", "flat", "wrapper", "fb", "img", "cmp", "original", "zip", "new", "p", "success", "ptr", "inst", "sup", "xxxxxxxx", "buff", "dat", "param", "api", "pb", "obj", "cur", "done", "storage", "cache", "diff", "np", "elt", "py", "kk", "source", "now", "stuff", "session", "tra", "array", "sp"]}}
{"project": "FFmpeg", "commit_id": "1330a0f31f373f3b9f1ea53d48b94edc47759b76", "target": 1, "func": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->bit_rate > 0) {\n\n        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n\n\n    if (avctx->rc_max_rate > 0)\n\n        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;\n\n\n\n    if (ctx->rc < 0) {\n\n        if (ctx->flags & NVENC_ONE_PASS)\n\n            ctx->twopass = 0;\n\n        if (ctx->flags & NVENC_TWO_PASSES)\n\n            ctx->twopass = 1;\n\n\n\n        if (ctx->twopass < 0)\n\n            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;\n\n\n\n        if (ctx->cbr) {\n\n            if (ctx->twopass) {\n\n                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;\n\n            } else {\n\n                ctx->rc = NV_ENC_PARAMS_RC_CBR;\n\n            }\n\n        } else if (avctx->global_quality > 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;\n\n        } else if (ctx->twopass) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;\n\n        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;\n\n        }\n\n    }\n\n\n\n    if (ctx->flags & NVENC_LOSSLESS) {\n\n        set_lossless(avctx);\n\n    } else if (ctx->rc > 0) {\n\n        nvenc_override_rate_control(avctx);\n\n    } else {\n\n        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;\n\n        set_vbr(avctx);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n}\n", "idx": 22970, "substitutes": {"avctx": [" avctrl", "akcmd", "AVcp", " avcu", "avcca", "akloc", "avconfig", "AVcu", "navctx", "varcca", "navcp", "calcontext", "varcontext", " avcf", "AVcb", "avcb", " avloc", "varcp", "calpkg", "afconfig", "avcmp", "avctrl", "AVvoc", "AVloc", "navcontext", "vargc", "aveloc", "AVctl", "avkw", "avecb", "vardc", "AVctrl", "avcp", "afctx", "AVdc", "afdc", "avcontext", "navconfig", "navcmd", "navcmp", "AVctx", "avvoc", "navloc", "avpkg", "AVkw", "AVcf", "AVconfig", "afcmp", "afcmd", "navcca", "avcf", "varctl", "calctx", "varcmp", "afpkg", " avcmp", "afkw", "navgc", "afcu", "avdc", "AVcca", "afvoc", "avcu", "avctl", "navctl", "avectx", "afcontext", "avgc", "navkw", "AVcmp", "akconfig", "afcf", "AVcmd", "AVpkg", "navvoc", "AVcontext", "AVgc", "akcontext", "navctrl", "akctx", "avecontext", "calcmp", "varctx", "avcmd", "navcb", " avcontext", "avloc"], "ctx": ["bc", "fc", "cam", "ct", "config", "acl", "cm", "pc", "sys", "cp", "msg", "na", "cs", "xc", "kb", "context", "la", "qa", "fw", "bm", "cus", "wx", "cms", "conf", "instance", "txt", "wcs", "support", "conn", "coll", "pkg", "cv", "anc", "ci", "component", "rc", "c", "cb", "cfg", "sc", "scope", "concept", "cu", "vc", "lc", "cc", "tx", "cas", "cmp", "exec", "cmd", "act", "cf", "tc", "cli", "loc", "cca", "co", "hw", "voc", "sq", "sci", "ca", "btn", "cl", "nc", "cache", "ctrl", "sync", "client", "cn", "auc", "console", "fn", "kw", "ck"]}}
{"project": "FFmpeg", "commit_id": "8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f", "target": 1, "func": "static av_cold int vp3_decode_end(AVCodecContext *avctx)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if (avctx->is_copy && !s->current_frame.data[0])\n\n        return 0;\n\n\n\n    av_free(s->superblock_coding);\n\n    av_free(s->all_fragments);\n\n    av_free(s->coded_fragment_list[0]);\n\n    av_free(s->dct_tokens_base);\n\n    av_free(s->superblock_fragments);\n\n    av_free(s->macroblock_coding);\n\n    av_free(s->motion_val[0]);\n\n    av_free(s->motion_val[1]);\n\n    av_free(s->edge_emu_buffer);\n\n\n\n    if (avctx->is_copy) return 0;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        free_vlc(&s->dc_vlc[i]);\n\n        free_vlc(&s->ac_vlc_1[i]);\n\n        free_vlc(&s->ac_vlc_2[i]);\n\n        free_vlc(&s->ac_vlc_3[i]);\n\n        free_vlc(&s->ac_vlc_4[i]);\n\n    }\n\n\n\n    free_vlc(&s->superblock_run_length_vlc);\n\n    free_vlc(&s->fragment_run_length_vlc);\n\n    free_vlc(&s->mode_code_vlc);\n\n    free_vlc(&s->motion_vector_vlc);\n\n\n\n    /* release all frames */\n\n    if (s->golden_frame.data[0])\n\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n\n        ff_thread_release_buffer(avctx, &s->last_frame);\n\n    /* no need to release the current_frame since it will always be pointing\n\n     * to the same frame as either the golden or last frame */\n\n\n\n    return 0;\n\n}\n", "idx": 22976, "substitutes": {"avctx": ["avecu", "avecf", "AVconfig", "afcrit", "afca", "afcf", "ajcontext", "avnas", "akcu", "navcup", "accountcrit", "operpc", " avconfig", "afcup", "avconfig", "avcup", "avcrit", "ajconfig", "operctx", "AVcontext", "afctx", "accountpc", "evcontext", "avcf", "AVca", "avca", "akcontext", "evcu", "navctx", "akctx", "accountcontext", "avecontext", "avalkb", "ajca", "afcu", "avbc", "opercontext", "abnas", "navcu", "navbc", "avcontext", "avcu", "accountctx", "abctx", "afnas", "avpc", "afbc", "afpc", "avalctx", "ajnas", "akcf", "opercrit", "evctx", "ajctx", "avectx", "abcontext", "afcontext", "AVctx", "navkb", "avalcontext", "evcup", " avca", " avcontext", "navcontext", "afkb", "avalbc", "abca", "avkb"], "s": ["ions", "sv", "bis", "es", "uns", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "js", "aws", "ms", "n", "S", "ns", "rs", "ins", "v", "conf", "http", "l", "ss", "sb", "g", "ses", "d", "sets", "as", "services", "u", "stat", "o", "sg", "c", "spec", "sc", "a", "has", "changes", "sf", "su", "e", "sym", "qs", "hs", "fs", "f", "t", "p", "si", "b", "service", "sup", "side", "ps", "gs", "h", "sq", "als", "your", "ops", "ks", "m", "its", "args", "ls", "sync", "is", "ctx", "se", "session", "comments", "bs", "states"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ui", "eni", "mini", "gi", "d", "uri", "ti", "I", "l", "ci", "y", "phi", "info", "ini", "m", "oi", "j", "u", "it", "ip", "abi", "p", "id", "o", "bi", "vi", "cli", "mi", "dr", "mu", "c", "index", "idi", "si", "ii", "b", "ji", "n", "iu", "ai", "xi", "hi", "di", "z", "yi", "multi", "li", "api", "pi", "x", "zi", "ni"]}}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980, "substitutes": {"vs": ["sv", "VS", "es", "config", "vt", "xs", "css", "ds", "ils", "os", "cs", "vals", "Vs", "stats", "js", "sts", "ov", "ms", "ns", "iss", "vas", "rs", "ins", "v", "http", "grades", "pages", "ss", "obs", "nav", "iv", "ses", "cv", "nas", "services", "pg", "s", "state", "ports", "wp", "va", "changes", "views", "utils", "vc", "prev", "qs", "fs", "lines", "flags", "ves", "vi", "ver", "ps", "gs", "alls", "vid", "ums", "versions", "vers", "sk", "lv", "ops", "vg", "plugins", "ks", "plugin", "env", "ls", "vr", "verts", "ues", "vm", "bs", "vp"]}}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n", "idx": 22994, "substitutes": {"opts": ["operations", "opls", " opations", " optt", "copts", "opations", "opters", "obds", "catds", " ops", "opcs", "optps", "prols", "optters", "OPts", "operts", "ops", "ppters", "obps", "ppps", "prott", "obts", "copTS", "hopts", "props", "catt", " opcs", "ppds", "hoptt", "opTS", "catts", "operTS", "optds", "opds", "opps", " opTS", "OPs", "obters", " opds", "OPds", "optt", "opercs", "prots", " opps", "copcs", "ppts", "OPt", " opls", "cats", "hopls", "hopps", "optts", "copations"], "opt": ["step", "expr", "def", "esc", "off", "config", "val", "post", "ott", "key", "ord", "temp", "eff", "pos", "neg", "info", "cat", "go", "optim", "comb", "iter", "doc", "proc", "nt", "dest", "attr", "type", "name", "txt", "org", "option", "iv", "text", "ctr", "term", "op", "oper", "o", "ext", "sc", "options", "alt", "aut", "oc", "prop", "prev", "err", "ort", "exec", "oss", "init", "ret", "or", "inf", "p", "open", "num", "cho", "sub", "tmp", "usr", "always", "error", "loc", "sec", "lit", "obj", "hop", "loop", "Opt", "tr", "tag", "tip", "lt", "skip", "parent", "vert", "fn", "dot", "zero"], "desc": ["bc", "def", "esc", "next", "config", "asc", "ord", "path", "neg", "info", "src", "test", "comb", "doc", "dest", "resp", "type", "name", "org", "end", "conn", "oe", "option", "text", "der", "anc", "cont", "term", "op", "dir", "dev", "description", "enc", "code", "rc", "ext", "sc", "dc", "des", "child", "feed", "prop", "lc", "uc", "eq", "ref", "err", "meta", "rec", "exec", "sub", "sup", "loc", "req", "stage", "sec", "bot", "Desc", "cod", "ec", "td", "obj", "inc", "decl", "cur", "dep", "env", "entry", "diff", "seq", "sort", "contract"], "value": ["name", "property", "start", "Value", "object", "language", "option", "valid", "iv", "result", "text", "val", "none", "key", "message", "null", "feature", "json", "style", "home", "type", "function", "hello", "offset", "r", "entry", "address", "size", "data", "description", "version", "current", "unit", "number", "help", "id", "field", "count", "max", "comment", "content", "values", "num", "set", "error", "min", "flow", "element", "reference", "parent", "v", "alt", "group", "resource", "server", "variable", "VALUE", "format", "letter"]}}
{"project": "qemu", "commit_id": "e3da9921ebc554fad3224a9fdda9a7425ffd9ef7", "target": 0, "func": "static uint32_t nvic_readl(nvic_state *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t val;\n\n    int irq;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return (s->num_irq / 32) - 1;\n\n    case 0x10: /* SysTick Control and Status.  */\n\n        val = s->systick.control;\n\n        s->systick.control &= ~SYSTICK_COUNTFLAG;\n\n        return val;\n\n    case 0x14: /* SysTick Reload Value.  */\n\n        return s->systick.reload;\n\n    case 0x18: /* SysTick Current Value.  */\n\n        {\n\n            int64_t t;\n\n            if ((s->systick.control & SYSTICK_ENABLE) == 0)\n\n                return 0;\n\n            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n            if (t >= s->systick.tick)\n\n                return 0;\n\n            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;\n\n            /* The interrupt in triggered when the timer reaches zero.\n\n               However the counter is not reloaded until the next clock\n\n               tick.  This is a hack to return zero during the first tick.  */\n\n            if (val > s->systick.reload)\n\n                val = 0;\n\n            return val;\n\n        }\n\n    case 0x1c: /* SysTick Calibration Value.  */\n\n        return 10000;\n\n    case 0xd00: /* CPUID Base.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.cp15.c0_cpuid;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = s->gic.running_irq[0];\n\n        if (val == 1023) {\n\n            val = 0;\n\n        } else if (val >= 32) {\n\n            val -= 16;\n\n        }\n\n        /* RETTOBASE */\n\n        if (s->gic.running_irq[0] == 1023\n\n                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* VECTPENDING */\n\n        if (s->gic.current_pending[0] != 1023)\n\n            val |= (s->gic.current_pending[0] << 12);\n\n        /* ISRPENDING */\n\n        for (irq = 32; irq < s->num_irq; irq++) {\n\n            if (s->gic.irq_state[irq].pending) {\n\n                val |= (1 << 22);\n\n                break;\n\n            }\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)\n\n            val |= (1 << 26);\n\n        /* PENDSVSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)\n\n            val |= (1 << 28);\n\n        /* NMIPENDSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)\n\n            val |= (1 << 31);\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa05000;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* TODO: Implement Configuration Control bits.  */\n\n        return 0;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        /* TODO: Implement Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Configurable Fault Status unimplemented\\n\");\n\n        return 0;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n    case 0xd30: /* Debug Fault Status.  */\n\n    case 0xd34: /* Mem Manage Address.  */\n\n    case 0xd38: /* Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23016, "substitutes": {"s": ["i", "es", "uns", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "params", "stats", "js", "submit", "aws", "ms", "n", "S", "ns", "rs", "ins", "http", "conf", "v", "ing", "l", "ss", "sim", "request", "sb", "g", "ses", "seconds", "d", "sets", "site", "services", "u", "current", "sites", "c", "spec", "sf", "options", "su", "native", "e", "sym", "qs", "tests", "sie", "hs", "fs", "ings", "f", "less", "p", "si", "b", "service", "ims", "ps", "gs", "secondary", "sq", "your", "ops", "ks", "socket", "its", "storage", "vs", "ls", "sync", "is", "settings", "se", "session", "south", "server", "states"], "offset": ["delay", "phase", "limit", "start", "origin", "pad", "align", "fp", "pos", "axis", "address", "bit", "size", "data", "orient", "prefix", "slot", "addr", "operation", "sync", "shift", "timeout", "rot", "o", "index", "ptr", "location", "seq", "Offset", "length", "slice", "len", "boot", "reset", "range", "pointer", "frequency", "clock", "position", "base", "padding", "type"], "cpu": ["lc", "platform", "port", "net", "gpu", "conn", "linux", "config", "nic", "processor", "process", "pc", "CPU", "node", "css", "cmp", "sys", "nc", "phy", "cp", "fps", "cache", "component", "p", "np", "c", "ctx", "cn", "gp", "pid", "mem", "core", "chip", "xi", "boot", "proc", " CPU", "vm", "clock", "vidia", " pci", "fi", "pu", "pa"], "val": ["rol", "ee", "Value", "fail", "key", "trial", "pc", "pos", "r", "data", "vals", "live", "la", "pl", "pid", "VAL", "doc", "v", "eval", "l", "delay", "col", "ind", "valid", "item", "sil", "d", "cel", "split", "sol", "al", "pre", "op", "dev", "fx", "unit", "year", "aval", "ann", "rt", "vol", "ot", "alt", "li", "pa", "fa", "sel", "serv", "ref", "err", "result", "fb", "f", "it", "ret", "p", "play", "nil", "rot", "el", "num", "b", "call", "Val", "lit", "x", "count", "sl", "il", "arg", "cond", "bal", "ol", "bl", "pal", "rel", "slot", "elt", "py", "timeout", "index", "fe", "cal", "rl", "fl", "min", "len", "lt", "pol", "update", "isal", "pt", "base", "value"], "irq": ["ierry", "iraQ", "ierqual", "ierce", "rich", " irque", "iraqu", "iraqual", "iraque", "irqu", "IRqa", "arqu", " irqu", "ierqu", "irry", " irqa", "irary", "prqu", "irtch", "iraf", " irQ", "irtque", "irce", "iraq", "irtx", "IRq", "irace", " irch", "irQ", "arch", "irqa", "prq", "irf", "ierque", "IRqu", "arqa", "irach", "irqual", "IRQ", "prch", "iraqa", "irque", "irx", "rix", "rique", "arq", "ierq", "riq", "ierqa", " irx", " irce", "prf", "arf", "irtq", "arqual", " irry", "irch"], "t": ["ut", "i", "e", "ct", "g", "d", "tt", "token", "tim", "ti", "ty", "f", "y", "r", "u", "m", "j", "tp", "p", "tick", "ts", "at", "o", "tu", "tc", "ant", "rot", "c", "dt", "rt", "b", "ta", "x", "T", "n", "test", "ot", "v", "z", "nt", "tz", "pt", "l", "type"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int gxf_write_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    GXFContext *gxf = s->priv_data;\n\n    GXFStreamContext *vsc = NULL;\n\n    uint8_t tracks[255] = {0};\n\n    int i, media_info = 0;\n\n\n\n    if (!pb->seekable) {\n\n        av_log(s, AV_LOG_ERROR, \"gxf muxer does not support streamed output, patch welcome\");\n\n        return -1;\n\n    }\n\n\n\n    gxf->flags |= 0x00080000; /* material is simple clip */\n\n    for (i = 0; i < s->nb_streams; ++i) {\n\n        AVStream *st = s->streams[i];\n\n        GXFStreamContext *sc = av_mallocz(sizeof(*sc));\n\n        if (!sc)\n\n            return AVERROR(ENOMEM);\n\n        st->priv_data = sc;\n\n\n\n        sc->media_type = ff_codec_get_tag(gxf_media_types, st->codecpar->codec_id);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (st->codecpar->codec_id != AV_CODEC_ID_PCM_S16LE) {\n\n                av_log(s, AV_LOG_ERROR, \"only 16 BIT PCM LE allowed for now\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->sample_rate != 48000) {\n\n                av_log(s, AV_LOG_ERROR, \"only 48000hz sampling rate is allowed\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->channels != 1) {\n\n                av_log(s, AV_LOG_ERROR, \"only mono tracks are allowed\\n\");\n\n                return -1;\n\n            }\n\n            sc->track_type = 2;\n\n            sc->sample_rate = st->codecpar->sample_rate;\n\n            avpriv_set_pts_info(st, 64, 1, sc->sample_rate);\n\n            sc->sample_size = 16;\n\n            sc->frame_rate_index = -2;\n\n            sc->lines_index = -2;\n\n            sc->fields = -2;\n\n            gxf->audio_tracks++;\n\n            gxf->flags |= 0x04000000; /* audio is 16 bit pcm */\n\n            media_info = 'A';\n\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (i != 0) {\n\n                av_log(s, AV_LOG_ERROR, \"video stream must be the first track\\n\");\n\n                return -1;\n\n            }\n\n            /* FIXME check from time_base ? */\n\n            if (st->codecpar->height == 480 || st->codecpar->height == 512) { /* NTSC or NTSC+VBI */\n\n                sc->frame_rate_index = 5;\n\n                sc->sample_rate = 60;\n\n                gxf->flags |= 0x00000080;\n\n                gxf->time_base = (AVRational){ 1001, 60000 };\n\n            } else if (st->codecpar->height == 576 || st->codecpar->height == 608) { /* PAL or PAL+VBI */\n\n                sc->frame_rate_index = 6;\n\n                sc->media_type++;\n\n                sc->sample_rate = 50;\n\n                gxf->flags |= 0x00000040;\n\n                gxf->time_base = (AVRational){ 1, 50 };\n\n            } else {\n\n                av_log(s, AV_LOG_ERROR, \"unsupported video resolution, \"\n\n                       \"gxf muxer only accepts PAL or NTSC resolutions currently\\n\");\n\n                return -1;\n\n            }\n\n            avpriv_set_pts_info(st, 64, gxf->time_base.num, gxf->time_base.den);\n\n            if (gxf_find_lines_index(st) < 0)\n\n                sc->lines_index = -1;\n\n            sc->sample_size = st->codecpar->bit_rate;\n\n            sc->fields = 2; /* interlaced */\n\n\n\n            vsc = sc;\n\n\n\n            switch (st->codecpar->codec_id) {\n\n            case AV_CODEC_ID_MJPEG:\n\n                sc->track_type = 1;\n\n                gxf->flags |= 0x00004000;\n\n                media_info = 'J';\n\n                break;\n\n            case AV_CODEC_ID_MPEG1VIDEO:\n\n                sc->track_type = 9;\n\n                gxf->mpeg_tracks++;\n\n                media_info = 'L';\n\n                break;\n\n            case AV_CODEC_ID_MPEG2VIDEO:\n\n                sc->first_gop_closed = -1;\n\n                sc->track_type = 4;\n\n                gxf->mpeg_tracks++;\n\n                gxf->flags |= 0x00008000;\n\n                media_info = 'M';\n\n                break;\n\n            case AV_CODEC_ID_DVVIDEO:\n\n                if (st->codecpar->format == AV_PIX_FMT_YUV422P) {\n\n                    sc->media_type += 2;\n\n                    sc->track_type = 6;\n\n                    gxf->flags |= 0x00002000;\n\n                    media_info = 'E';\n\n                } else {\n\n                    sc->track_type = 5;\n\n                    gxf->flags |= 0x00001000;\n\n                    media_info = 'D';\n\n                }\n\n                break;\n\n            default:\n\n                av_log(s, AV_LOG_ERROR, \"video codec not supported\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        /* FIXME first 10 audio tracks are 0 to 9 next 22 are A to V */\n\n        sc->media_info = media_info<<8 | ('0'+tracks[media_info]++);\n\n        sc->order = s->nb_streams - st->index;\n\n    }\n\n\n\n    if (ff_audio_interleave_init(s, GXF_samples_per_frame, (AVRational){ 1, 48000 }) < 0)\n\n        return -1;\n\n\n\n    gxf_init_timecode_track(&gxf->timecode_track, vsc);\n\n    gxf->flags |= 0x200000; // time code track is non-drop frame\n\n\n\n    gxf_write_map_packet(s, 0);\n\n    gxf_write_flt_packet(s);\n\n    gxf_write_umf_packet(s);\n\n\n\n    gxf->packet_count = 3;\n\n\n\n    avio_flush(pb);\n\n    return 0;\n\n}\n", "idx": 23049, "substitutes": {"s": ["sv", "es", "xs", "ds", "sys", "ssl", "os", "ts", "cs", "us", "stats", "js", "sts", "aws", "n", "S", "ns", "details", "ins", "rs", "v", "http", "conf", "l", "ss", "request", "sb", "g", "ses", "d", "sets", "site", "services", "stat", "sg", "c", "spec", "sf", "su", "e", "sym", "qs", "fs", "f", "t", "p", "si", "b", "service", "ps", "gs", "sq", "types", "sci", "sl", "ops", "ks", "m", "storage", "ys", "ls", "sync", "is", "sa", "client", "settings", "single", "w", "sing", "se", "session", "comments", "parser", "south", "server"], "pb": ["bc", "platform", "sb", "fc", "summary", "uf", "lb", "prop", "jp", "lp", "prot", "db", "fb", "pm", "impl", "phrase", "pd", "bp", "pc", "fp", "pg", "rob", "eb", "lab", "cp", "PB", "tp", "p", "tc", "wb", "ctx", "cb", "pl", "pro", "mp", "b", "cpp", "hub", "loc", "pac", "parser", "ab", "bh", "bs", "vp", "rb", "typ", "dp", "ppa", "pa"], "gxf": ["igfx", "gxc", "rgxc", "rgfx", "gufc", "gaxe", "guxf", "gfx", "gufx", "igxe", "Gfc", "gaxc", " gxc", "gaxf", "rgfc", "Gxe", "gafx", "Gfx", "ergxc", "Gxf", " gfx", "ergfx", "Gxc", "gxe", "igxf", "gfc", " gfc", "ergxf", "igxc", "ergfc", " gxe", "rgxf", "guxc"], "vsc": ["fSC", "Vsc", "vcc", "VSC", "Vcc", "fsc", "vSC", "fcc", " vcc", " vSC"], "tracks": ["cc", "ints", "rows", "ributes", "ctr", "clips", "bytes", "track", "flags", "cmp", "order", "cp", "codes", "cs", "ls", "icks", "frames", "gp", "raw", "seq", "desc", "length", "fields", "acks", "stream", "files", "ips"], "i": ["io", "anti", "ix", "area", "e", "ie", "fi", "qi", "start", "ri", "ui", "eni", " ii", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "y", "phi", "oi", "ini", "m", "it", "j", "u", "info", "r", "ip", "p", "abi", "id", "o", "code", "cli", "mi", "c", "index", "idi", "si", "ii", "in", "b", "n", " j", "iu", "ai", "xi", "hi", "di", "yi", "z", "multi", "li", "v", "pi", "x", "zi", "k", "type"], "st": ["lc", "td", "sv", "sb", "str", "est", "start", "rd", "uc", "support", "ast", "ct", "sl", "std", "ost", "kt", "post", "St", "d", "pc", "ld", "bl", "mt", "sth", "r", "rest", "nd", "sync", "sa", "dr", "c", "fe", "sd", "fr", "ste", "spec", "si", "sts", "sr", "set", "se", "cr", "sw", "src", "inst", "ist", "sf", "stage", "ST", "nt", "sp", "sn", "stream", "dest", "typ", "sta", "ss", "ft"], "sc": ["bc", "fc", "row", "cam", "esc", "ct", "config", "asc", "Sc", "pc", "acc", "cs", "context", "scan", "la", "pl", "src", "test", "cus", "osc", "sb", "sche", "cv", "anc", "cont", "isc", "enc", "rc", "c", "spec", "mp", "dc", "soc", "desc", "scope", "sum", "capt", "lc", "syn", "cc", "uc", "sac", "scl", "model", "cf", "comment", "si", "sr", "sub", "sw", "inst", "sup", "loc", "stage", "sec", "sq", "ec", "SC", "sci", "project", "ca", "cl", "nc", "mc", "sync", "sa", "client", "ctx", "match", "sh", "ch", "ub", "cr", "usc", "server"], "audio_tracks": ["media_info", "media_count", "audio_info", "audio_track", "media_tracks", "media_track", "audio_count"], "media_type": ["mediaingtype", "audio_source", "mediaingcount", "mediaaltype", "media_info", "media_count", "media_source", "audio_info", "mediainginfo", "mediaalcount", "mediaalinfo", "mediaalsource", "audio_count", "audio_type", "mediaingsource"]}}
{"project": "qemu", "commit_id": "2f464b5a32b414adb545acc6d94b5c35c7d258ba", "target": 0, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 23050, "substitutes": {"qxl": ["qvel", " qfxlp", "qxxli", "kxxel", "qxmlle", " qxlp", "qpxL", "qxo", "qulll", "qxlp", "qaxli", "qexlc", "qexL", "qexlr", "qxesly", "qullil", "qwwL", "quylc", "aqxl", "qllL", "sqreli", "qxtl", "qlexl", "qlexil", "vxl", "quxcla", "qxv", "qxfel", "qxil", "sqpxlc", "quyl", " qxmlel", "pexesel", "gulexlc", "quxv", " qxL", "sqxli", "sqzn", "qpxlp", "kexesl", "qexf", "qxyl", "qxesli", "qxu", "qxly", "qxpl", "qqfxu", "quxli", "qexil", "qvl", "qxeslc", "qexls", "sqzl", "pexesli", "qulldl", "qswly", "sqpxL", "qqxe", "qxxl", " qwwle", "qXli", "queswf", "qullL", "qreli", " qfxlc", "qexe", "kexlc", "queswly", "quxesl", "qwxu", "qreil", "qexv", "pexesl", "qylr", "qxmldl", "qxn", "quexrl", "guxle", "qrel", "qrxli", "qwxll", "quxil", "kxxl", "qlldl", "qxxls", "kexeslc", "iqexl", "qasylo", "qxtn", "qxesf", "guxli", "qexb", "qexle", "qyli", "pexli", "qwwu", "qwxn", "quexly", "qxxdl", "quxel", "qrxl", "qxylr", "qzll", " qxo", "qrexel", "qrxb", "qzli", "qpxll", "qze", "q\n", "qxpli", "qexel", "aqxli", "qctel", "sqpxla", " qxxlp", "kxl", "qurxl", "quenexrl", "quxl", "qnglo", "q_", "vxlc", "qXL", "qswl", "qxlo", " qxxla", "qustr", " q\n", "qswf", "qctl", "quexf", "qxxll", "qxyv", "qxel", "vxle", "qwwl", "sqxll", "qctu", "kxxlp", "sqxxl", " qxll", "quenexlc", "qxylc", "qtxl", "qxesl", "qpxel", "iqxlc", "qasyil", "quyv", "pexesdl", "qxrl", "qzil", "quxesL", "quexL", "qaxl", " qxle", " qxu", "qaxdl", "qxtlc", "qren", "qngli", "qxesla", "sqzll", "qwwli", "qasyl", "qtxdl", "sqpxli", "qxla", "qxesel", "qlexlo", "qwxls", "iqxl", "qexrl", "gulexl", "qrexli", "qapxlc", "sq_", "qttl", "sqxil", "sqxe", "qxmllc", "quxcshell", "sqxxll", "qrxel", "qexll", "aqxlo", " qxmlb", "qlexli", "sqpxel", "qxL", "guxl", "qpxla", "qrxo", "qurxel", " qstr", "qlexle", "qngil", "qexlp", "qaxlc", " qxmll", "vxmldl", "qswL", "quxu", "qxesn", "gulexle", "qxls", " qfxl", "qzL", "qqxlc", "qstr", "qxesL", "qxpu", "pexel", "qwxdl", "qxf", "aqngil", "qxshell", "qfxl", "qqfxlc", "kxel", "qwxe", "qfxlp", " qxmlo", "qxflc", "qu_", " qxla", "qapxlp", "quxlc", "iqexll", "qpxdl", "sqrel", "quexl", "qlexlc", "qurxlc", "pexdl", "gulexli", "qzl", "qxxlc", "qxmll", "qXla", "qctlc", "qxli", "qqfxl", "qllil", "qxxel", " qxxel", "qlll", "quxpu", "sqren", "qnexrl", "qwwle", "qxlr", "qfxli", "qxxlp", "qexu", "qu\n", "qrxlc", "guxlc", "qxpdl", "qngl", "qfxla", "kexla", "qasyli", "quxpdl", "qylp", "vxmlle", "qxdl", "qvdl", "qxfl", "qpxli", "sqpxl", "quxcel", "sqxls", "qexla", "qrexl", "qaxla", "qxmlli", " qxlc", "qtxel", "qexly", "sqxL", "qxcla", "qnexl", " qxxli", "qxcel", "qaxll", " qxb", "quxlp", "aqxil", "qxmlb", "kexl", "quxpl", "qapxl", "iqxb", "qrexlc", "sqstr", " qxel", "qylc", "aqngl", "quxpli", "qxxu", " qxxlc", "quxeslp", "quxL", "iqexlc", " qxli", "qaxel", "qexdl", "qurxli", "qxcl", "pexl", "iqxll", "qctrl", "sqxla", "kxdl", "vxmllc", "qfxlc", "queswl", "sqxlc", "aqngli", "qxxshell", "qexli", "qxxla", " qwwll", "qexl", " qfxli", "queswL", "aqnglo", "sqxxls", "qxtla", "qfxle", "qwxl", "sqxn", "qxesdl", "quexlc", "quxla", "qxb", "qxfli", "quxesli", "qfxll", " qxxu", "qfxb", "qXl", "qpxlc", "qxmlo", "kexesn", "qzdl", "qaxshell", "qxcshell", "qttlc", "qxlc", "qxmlel", "qpxl", "qnexlc", "quxlr", " qxxl", "quylr", "qxeslp", "sqxl", "kexesla", "qfxe", "qqxl", "kxxdl", "quxshell", "qttb", "sqze", " q_", "sq\n", "sqxel", "qwxli", "quxcl", "qfxel", "quxe", "qapxll", "qxxe", "kexn", "sqxxli", "qzn", "qfxL", "qxll", " qwwl", "kxlp", "quxdl", "qqfxe", "qfxdl", "qaxlp", "sqreil", "qtxlp", "qpxil", "qvli", "qwwll", "qxle", "qexn", "qxe", "vxmll", " qwwL", "qwwdl", "qyl", "qttli", "quenexl", "qfxu", "qexo", "qqxu", "qyv", "qyla", "vxdl", "qttll", "qttlp", "iqexb"], "vga": ["vgas", "qda", "lga", "lca", "qqa", "avqa", "vqa", "fga", " vqa", "svgas", "svma", "lgas", "gja", "avma", "vma", " vma", "qma", "avgas", "vema", " vgas", "vega", "veqa", "Vga", "qca", "svja", "avga", "vca", "gga", "fqa", "Vca", "qgas", " vja", "vta", "ggas", "vegas", "veta", "fgas", "nvga", " vca", "Vgas", "lda", "fma", "Vda", "svga", "nvda", "qta", " vta", "lma", "gqa", "vda", "veja", "lja", " vda", "nvqa", "qga", "vja", "Vma"], "i": ["io", "lc", "ami", "e", "ix", "start", "fi", "qi", "ri", "ind", "ui", "eni", "mini", "pi", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "t", "y", "phi", "adi", "ini", "m", "oi", "j", "u", "ip", "p", "diff", "o", "bi", "mi", "attr", "mu", "c", "index", "si", "gui", "ii", "b", "ji", "n", "iu", "length", "slice", "ai", "xi", "hi", "di", "z", "multi", "uni", "li", "yi", "ie", "x", "zi", "k", "ni"]}}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052, "substitutes": {"system_info": ["system_id", "systemdbstatus", " system_status", " system_inf", "system_Info", "systemdbinfo", "systemdbInfo", " system_information", " system_fo", "systemdbinformation", " system_id", "system_information", " system_Info", "system_inf", "system_status", "system_fo"], "freep": ["Freyp", "feip", "faip", "freip", "fremp", "freeps", "feeak", "feeep", "faeps", "Freap", "feeEP", "Freek", " freap", " freq", "feap", "faak", "speeps", "fapp", "passep", "speep", "freq", "feq", "passeps", "fayp", "faEP", "faep", "freeap", "flemp", "fleek", "freap", " freEP", "Freq", "freeek", "Freak", "feeeps", "faec", "faek", "FreEP", "Freeps", "feep", "freek", "freec", " frepp", "passip", "fleap", "speEP", "feec", "freemp", "Freep", "freyp", "Frepp", "passEP", "freak", " freek", "frepp", "speip", " freyp", " fremp", " freec", " freip", "freeep", "fleep", " freeps", "freEP", "feek"], "i": ["io", "lc", "udi", "jit", "uli", "ix", "start", "e", "ie", "fi", "qi", "ri", "eni", "ui", "part", "gi", "uri", "chi", "ti", "I", "l", "hei", "ci", "y", "t", "phi", "oi", "ini", "it", "j", "ip", "abi", "p", "id", "o", "inner", "mi", "c", "mu", "index", "si", "gui", "ii", "b", "ji", "iu", "slice", "ai", "xi", "di", "yi", "multi", "z", "li", "pi", "api", "zi", "ni", "count"], "cnt": ["cnd", "ncnt", "lcid", "Cnc", "ncnc", " cnc", "lcno", "Cid", "crnc", "Crt", "crno", "ncnd", "cno", " cid", "lcnt", "cnc", "lcount", "Count", "cnn", "crt", "crnt", " crt", " cnn", "ncnn", " cnd", "Cno", " cno", " count", "cid", "Cnd", "Cnt", "crrt", "Cnn", "count"], "startaddr": ["patchaddr", " startadr", "sumptr", "endattr", "stopattr", "stopaddress", "stopaddr", "loadaddr", " startptr", "startptr", "partattr", "endadr", " startaddress", "likeaddr", "sumhop", "endptr", "patchaddress", "partptr", "startaddress", "endaddress", "sourceaddress", "starthop", "sourceaddr", "shareptr", "sourcehop", "partaddr", " starthop", "loadptr", "sumaddr", "shareaddress", "sourceptr", "startattr", "sumaddress", "patchptr", "likeaddress", "endhop", "stopptr", "loadaddress", "startadr", "shareaddr", "partaddress", "patchhop", "likeadr"], "endaddr": ["Endaddress", " endalign", " endoffset", "endattr", " endwork", "stopaddress", " endaug", "Endattr", "endalign", "pendalign", " endorder", " startorder", "stopaddr", "startoffset", "startwork", " startptr", "endnode", "startaug", " endnode", " endhop", "ENDaddress", "endoffset", "stopoffset", " startaddress", "startnode", "endptr", " endattr", "endaug", "startaddress", "endaddress", "ENDattr", "pendaddress", " endconn", "endedconn", "pendaddr", "alladdress", " endaddress", "startconn", "starthop", "endedaddress", " enddr", "endwork", "startalign", " endptr", "ENDhop", "allorder", "endedhop", "endedaddr", "endedwork", "endedattr", "endedaug", "Endaddr", "startattr", "enddr", "endhop", "stopdr", "endednode", "alladdr", "ENDaddr", "pendaug", "Endhop", "endorder", "endconn", "startdr", "allptr"], "f": ["fa", "e", "fs", "fb", "file", "d", "func", "handler", "rf", "fp", "function", "df", "t", "fu", "u", "r", "m", "p", "c", "fe", "fr", "form", "a", "b", "x", "w", "fl", "fd", "F", "fw", "ff", "feed", "buff", "fen", "v", "fn", "h", "files", "l", "fi", "fo", "fun"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 23066, "substitutes": {"host_port": ["host_name", "host_address", "address_address", "address_name", "address_port", "address_host", " host_address", " host_host", "host_host"], "errp": [" errf", "ErP", "Erpc", "acep", " errnp", "errf", "acesp", "Ernp", "Erp", " errpc", "Erf", "errpc", "errP", " errip", "errsp", " errsp", "ernp", "acef", "Ersp", " errP", "Erip", "errip", "aceip", "erp", "erP", "erpc", "errnp"], "iaddr": ["iager", "siager", "ipaddress", "iadr", "tiaddr", "ikt", "spkg", "ipaddr", "ipkg", " ipkg", "shop", "iwork", " iaddress", "ipptr", "iptr", "tiptr", "sager", "siaddress", " ikt", "skt", "sass", "Ipkg", "siwork", "saddress", "Iass", "Iaddress", "swork", "ipadr", "tiadr", "iphop", "sadr", " iwork", "sikt", " iass", "ipager", "siaddr", "iass", "iaddress", "sptr", "tiaddress", "Iaddr", "ihop", "sihop"], "saddr": ["wsaddr", " sdb", "salign", "paddr", "sihost", "padd", "pptr", "Saddress", " sarr", "psaddr", " sadd", "ssalign", "sadd", " sadr", " srt", "ssaddress", "sslayer", "wsrt", "sarr", " saddress", "oshost", "Saddr", "srt", "phost", "Salign", " sptr", "paddress", "svr", "sidb", " svr", "psvr", "saddress", "ssrt", "ssaddr", "wslayer", "Sarr", "slayer", "sdb", " slayer", "ihost", "sadr", " salign", "siadr", " shost", "osaddr", "wsaddress", "iadd", "ssarr", "shost", "osdb", "psptr", "siaddr", "iaddress", "pvr", "sptr", "psaddress", "osadr"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n", "idx": 23074, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "lb", "qs", "ba", "fs", "ses", "fb", "bb", "ks", "bp", "bl", "ds", "bid", "state", "os", "vs", "cs", "us", "ts", "ls", "sa", "cb", "b", "blocks", "ms", "ns", "BS", "iss", "Bs", "ps", "rs", "gs", "ss", "gb"], "s": ["sv", "sb", "sym", "qs", "es", "sl", "hs", "ses", "d", "ops", "ds", "f", "u", "m", "state", "ssl", "os", "ts", "p", "cs", "ls", "o", "is", "sa", "sg", "c", "js", "opens", "spec", "sq", "si", "b", "ms", "n", "S", "ns", "session", "ps", "ins", "gs", "south", "rs", "ss", "states"]}}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "substitutes": {"d": ["md", "i", "e", "cd", "driver", "dh", "ds", "ld", "f", "dn", "gd", "t", "r", "u", "m", "s", "da", "data", "ad", "state", "p", "dict", "o", "c", "dr", "dx", "sd", "dt", "a", "b", "dc", "dm", "fd", "bd", "D", "st", "z", "l", "dp"], "drc": ["drt", "sdrt", "sdrc", "trc", "brc", "datrc", " drec", "dsrc", "dsrec", "ldsrc", "lRC", "adru", "datru", "Drec", "datlc", "lirc", "pdrac", "ldRC", " drac", "adrec", "tdrt", " dsrc", "tdrc", "dnroc", "datrec", "dnrt", "dsc", "dirc", " dsc", "dsrt", "drrc", "drsrc", "ldrac", "droc", "adrc", "brec", "fRC", "lrc", "DRC", "Dru", "adrt", "lsrc", "tsc", "frec", " drt", " dRC", "prec", "adlc", "lrec", "flc", "tdsrc", "drec", "drsc", "Drc", "sdroc", "frc", "dru", " droc", "dssc", "adRC", "troc", "prc", "tdrec", "trt", "drRC", "ldrec", "ldirc", "dnrc", "datRC", "dsRC", "pdrec", "psc", "drac", "bsc", "sdRC", "dRC", "drrec", "pdrc", "drirc", "dlc", "pdroc", "dnRC", "psrc", "birc", "pdsc", "bRC", "adsrc", "ldrc", "dssrc", "bsrc", "ldsc", "pirc", "pdrt"], "drck": ["strcc", "hrck", "hrok", "derck", "hrock", "hrac", "drac", " drco", "hrco", "drrc", "DRck", " drcks", " drack", "drco", "derok", " drok", "drcks", "derco", "derac", "drok", "DRrc", "drcc", "drack", "DRack", "hrack", "hrrc", " drcc", " drac", "strack", "DRcks", "strcks", "drock", " drock", "DRock", "DRcc", " drrc", "strck"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23088, "substitutes": {"current_env": ["current_session", "cur_environment", "current_enc", "current_eni", "currentlexenv", "current_ext", "current_obj", "reported_ext", "active_session", " current_state", "current_environment", "activewenv", " current_enc", "currentwsession", "current__exc", "current_exc", "reported_conn", "current__state", "current__enc", "currentJenv", "currentlexobj", "active_obj", "reported_eni", "active_server", "activewobj", "cur_eni", "currentJobj", "reported_env", " current_exc", "current_server", "activewserver", "current_conn", "cur_env", "currentwobj", "activewsession", "currentJsession", "currentwserver", "active_env", "current__env", "current_state", "currentlexsession", "currentwenv", "currentJserver", "currentlexserver"], "addr": ["route", "name", "target", "en", "conn", "ref", "config", "hop", "amp", "acl", "pkg", "mode", "oa", "align", "host", "pad", "node", "ld", "layer", "pos", "dir", "cmd", "address", "entry", "ad", "enc", "ip", "ace", "prefix", "arp", "mac", "rc", "dr", "arch", "nr", "el", "ext", "ar", "rt", "ptr", "seq", "alias", "src", "loc", "pointer", "offset", "base", "attr", "url"], "len": ["net", "limit", "un", "en", "end", "ref", "val", "ln", "bin", "offset", "pos", "lan", "size", "list", "enc", "lin", "count", "la", "gen", "el", "lim", "ann", "mem", "line", "seq", "rev", "lvl", "length", "loc", "ll", "lon", "li", "lf", "lang", "l", "base", "resp", "Len", "url", "fin"], "type": ["port", "Type", "name", "types", "kind", "class", "ref", "ping", "val", "time", "key", "TYPE", "style", "plugin", "model", "path", "t", "op", "info", "y", "pre", "rel", "state", "p", "link", "unit", "id", "o", "year", "code", "var", "py", "ext", "source", "role", "ype", "error", "length", "typ", "block", "offset", "x", "action", "format"], "bp": ["bc", "pb", "sb", "hp", "lb", "ap", "conn", "jp", "lp", "amp", "adj", "mb", "pkg", "db", "fb", "bb", "pc", "bridge", "fp", "buffer", "pg", "eb", "cp", "bg", "tp", "pp", "p", "ip", "kb", "np", "arp", "bps", "py", "sg", "cb", "ctx", "wp", "gp", "b", "xp", "cpp", "BP", "br", "nb", "bf", "bh", "vm", "sp", "vp", "rb", "bsp", "gb"], "env": ["net", "e", "org", "en", "ig", "next", "conn", "exe", "eu", "config", "jp", "obj", "eni", "db", "esp", "eng", "queue", "oa", "qv", "site", "engine", "ea", "dep", "po", "exec", "eye", "exc", "nc", "args", "dev", "cache", "lock", "enc", "p", "vs", "ep", "work", "context", "np", "ext", "c", "ctx", "edge", "equ", "enable", "gui", "loader", "core", "viron", "n", "inst", "console", "br", "loc", "global", "proc", "v", "qt", "fen", "vm", "manager", "eval", "scope", "environment", "ev", "ec"], "err": [" error", "ee", "val", "yr", "y", "order", "r", "fg", "ok", "msg", "bug", "far", "var", "later", "fr", "go", "Error", "reader", "erg", "br", "iter", "doc", "ner", "eor", "kr", "fam", "ev", "resp", "attr", "str", "ig", "rag", "ind", "finder", "der", "rx", "ah", "dev", "code", "rh", "rc", "cb", "ir", "better", "e", "result", "orr", "f", "init", "arr", "or", "nil", "act", "pr", "rn", "ver", "hr", "sr", "fy", "error", "er", "gr", "req", "ler", "rage", "orig", "Er", "rr", "wr", "lr", "risk", "runner", "dr", "fe", "hide", "nr", "ar", "rar", "cr", " Err", "mr", "root", "nor", "aster", "fer", "here"], "use_count": ["use2count", "useblocktype", "useblocksum", "useblockcache", "use_type", "used_count", "used_type", "used_cache", "use2sum", "use2cache", "use_size", "use_sum", "use2size", "use_cache", "used_size", "used_sum", "useblockcount"]}}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n", "idx": 23104, "substitutes": {"env": ["net", "txt", "e", "en", "end", "conn", "err", "eu", "config", "event", "obj", "forge", "db", "cv", "ench", "eng", "style", "engine", "export", "ea", "exec", "exc", "ah", "args", "state", "her", "enc", "ep", "vs", "dict", "code", "context", "que", "Environment", "cb", "el", "equ", "enable", "gui", "loader", "core", "viron", "enter", "qa", "er", "ass", "console", "stage", "v", "conf", "manager", "erv", "server", "environment", "ev", "scope", "ec"], "t0": ["t12", " t00", "T2", "p00", "p2", "p0", "t2", "T00", "p12", "T1", "p1", "T0", "T12", "t00", " t2", " t12"], "t1": ["T2", "p2", "p0", " t121", "t2", "ty1", "T1", "ty121", "p4", "ty0", "t4", "p1", "ty2", "t121", " t4", "T121", "T0", " t2", "T4"], "relation": ["span", "different", "cross", "attribute", "notation", "option", "related", "result", "orr", "bearing", "origin", "connection", " relationship", "rr", "feature", "hip", "bridge", "function", "sharing", "cmp", "term", "section", "use", "rel", " association", "component", "version", "unit", "number", "balance", "operation", "relative", " correlation", "action", "family", "role", "ation", " ratio", " comparison", "error", "length", "unknown", "rection", "angle", "reference", "parent", "translation", "relations", "nor", "resource", "position", "effect", "record", "attr", "format", "type"]}}
{"project": "qemu", "commit_id": "f0536bb848ad6eb2709a7dc675f261bd160c751b", "target": 0, "func": "static int img_info(int argc, char **argv)\n\n{\n\n    int c;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n", "idx": 23105, "substitutes": {"argc": ["Argc", "argsC", "argb", "argumentv", "arml", "incv", " argce", " argcount", "armv", "argce", "argumentc", "argl", "argcount", "argumentcount", "argumentb", "inccount", "armce", "Argce", "incc", "armc", "incl", "argsb", "Argv", " argl", "argsc", "argC", " argC", " argb", "argumentl", "argsl", "Argl", "argumentC"], "argv": ["Argc", "arc", "drvs", "arvs", "drl", "arv", "Argp", "argsp", "drv", "argsv", "usec", "usev", "usevs", "argl", "usep", "argsvs", "argp", "drc", " argp", "arp", " argf", "argf", "Argf", " argvs", "Argv", " argl", "argsc", "argvs", "argsf", "argsl"], "c": ["lc", "bc", "fc", "i", "e", "cc", "uc", "end", "ct", "category", "cm", "d", "con", "rec", "ca", "pc", "cur", "cl", "f", "ci", "nc", "ac", "m", "u", "cp", "ad", "r", "p", "mc", "xc", "cs", "enc", "code", "cn", "sc", "b", "dc", "cy", "channel", "cr", "n", "C", "v", "ce", "ec", "sec", "cod", "h", "l", "cu", "k", "count"], "filename": ["nm", "platform", "name", "summary", "binary", "txt", "password", "jl", "download", "software", "config", "input", "file", "metadata", "lua", "fp", "f", "path", "size", "data", "figure", "version", "nil", "setup", "kl", "prefix", "directory", "which", "kn", "println", "title", "source", "document", "location", "fd", "dll", "jpg", "sf", "database", "STDOUT", "fil", "fn", "username", "files", "wl", "Filename", "format", "url"], "fmt": ["Ftm", "cfmt", " flt", "bmt", "Flt", " fformat", "bactory", " fMT", "tfmt", "hformat", "cfformat", " frt", "factory", "frt", "hrt", "cfMT", "tfformat", "fformat", "Frt", "bMT", "Fformat", "fMT", "bformat", "ftm", " factory", "Factory", "hmt", "tflt", "tfMT", "Fmt", " ftm", "FMT", "flt", "cftm", "hMT"], "output": ["target", "next", "config", "progress", "key", "other", "enabled", "Output", "data", "prefix", "out", "global", "image", "production", "format", "type", "letter", "name", "binary", "response", "option", "text", "file", "style", "control", "write", "unit", "o", "complete", "offset", "after", "public", "summary", " Output", "flat", "result", "hidden", "pretty", "function", "again", "cut", "success", "error", "four", "page", "put", "resource", "protected", "external", "input", "display", "export", "generation", "reason", "final", "version", "source", "document", "console", "append", "update", "fn", "dot", "sort", "outer"], "bs": ["obs", "bc", "pb", "sb", "bos", "aos", "outs", "lb", "org", "bis", "ba", "obj", "fs", "ubs", "db", "fb", "bb", "bytes", "plugins", "bp", "bid", "ds", "bl", "bes", "bing", "bu", "eb", "s", "bas", "bg", "ob", "os", "abi", "vs", "cs", "bn", "ls", "bi", "us", "bps", "sync", "js", "ib", "b", "bits", "browser", "blocks", "ms", "src", "ns", "details", "BS", "iss", "ps", "rs", "ins", "gs", "bf", "banks", "bh", "bot", "lib", "http", "buff", "base", "ss", "las", "gb"], "info": ["io", "fa", "ami", "i", "summary", "Info", "fi", "bis", "off", "app", "config", "fs", "ui", "result", "part", "pi", "INFO", "gi", "fb", "file", "afi", "json", "home", "build", "f", "properties", "ok", "information", "data", "init", "state", "full", "bug", "j", "abi", "setup", "inf", "diff", "job", "bi", "is", "py", "js", "index", "frame", "source", "tf", "si", "check", "ii", "now", "error", "details", "fw", "show", "zip", "options", "update", "iso", "buff", "http", "conf", "z", "li", "image", "api", "jo", "guide", "base", "fo"], "long_options": ["long_types", "short_values", "long_values", "long__option", "long__types", "long_ops", " long_ops", "long__values", "short_options", "long_option", "short_option", " long_option", "long_args", "long__options", "short_types", " long_args"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23108, "substitutes": {"resolver": ["reector", "regector", "reolver", "resistor", "msolution", "registor", "msver", "resver", "solution", "msolver", "regolves", "erolution", "assolver", " resolution", " resver", "regolver", "assector", "sector", "resector", "assistor", "solver", "reolving", "erector", "resolving", "erolving", "solving", "sver", " resistor", "assolves", "erolver", "resolves", "resolution", " resector", "reolution", " resolves", "msector"], "addr": ["str", "port", "name", "ix", "ast", "conn", "adr", "obj", "amp", "hop", "driver", "pkg", "kt", "ack", "oa", "ord", "mode", "rr", "amd", "pton", "host", "ld", "node", "prov", "layer", "device", "exec", "alloc", "adder", "cmd", "address", "socket", "ad", "ip", "act", "ace", "prefix", "p", "mac", "work", "at", "dr", "ext", "add", "ar", "rt", "x", "ptr", "Address", "hash", "alias", "enter", "pointer", "server", "inet", "attr", "url"], "naddrs": ["nattls", "Nddls", "Nddras", "nastresses", "naddls", "ndders", "naddrd", "nodrs", "nastrs", "nadrs", "nastls", "nadders", "nattresses", "Naddresses", "nodresses", "nattras", "natters", "nddrs", "nddrd", "Nddrd", "Ndders", "noders", "nddresses", "Naddls", "nastras", "Naddras", "Naddrs", "nddls", "nadresses", "nattrs", "naddresses", "Nddrs", "Nddresses", "nadrd", "Naddrd", "nddras", "nodls", "nattrd", "nadls", "naddras", "Nadders"], "addrs": ["adr", "ddresses", "ddras", "addresses", "adrd", "adres", "ddrs", "adras", " addrd", "addres", "addrd", "adrs", "adresses", "addras", "ddrd", "ddr", " addres", " addras", "ddres", " addresses"], "errp": ["Erfp", " errlp", "errps", "errorfp", "err", "rylp", "ryfp", "ierpc", "ierpa", "ierp", "ierlp", "Erp", "aerpa", "aerlp", " errpc", "errfp", "errpc", "errpa", "errorlp", "errorpre", "acerps", " errpa", "iterr", "iterps", "acerr", "iterpo", "aerp", "iterp", "acerpo", "errpre", "acerp", "errpo", "errlp", "erpo", "ryp", "rypre", "aerpc", "Erlp", "Erpre", "erp", "errr", "erps", "errorp"]}}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n    Error *err = NULL;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 23116, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "lb", "bis", "fs", "ses", "ubs", "db", "fb", "bb", "bid", "ds", "bl", "bes", "css", "bing", "bu", "ros", "fps", "bas", "os", "vs", "cs", "us", "abi", "ls", "bi", "sync", "bps", "js", "cb", "b", "bits", "src", "ns", "BS", "iss", "ps", "banks", "gs", "bh", "base", "ss", "gb"], "sector_num": ["section_id", "section_dom", " sector_name", " sector_um", "section_num", "sector_begin", "section_no", "sector7um", "sector___um", "sector2id", "section_number", "sector7uri", "sector_uri", "sector2no", "sector___name", "sector_offset", "sector___uri", "sector_dom", "sector_no", "sector2number", "section_offset", "section_begin", "sector7num", "sector7name", "sector___num", "sector_name", " sector_uri", "sector_number", "sector_um", "sector_id", "sector2num"], "nb_sectors": ["nb_semgments", "nb_seures", "nb_pevers", "nb_segments", "nb_semctors", "nb_nectors", "nb_severs", "nb_seators", "nb_semures", "nb_pegments", "nb_vegments", "nb_serets", "nb_inseorers", "nb_shctors", "nb_cevers", "nb_secures", "nb_secctors", "nb_shgments", "nb_shrets", "nb_peorers", "nb_caseorers", "nb_ceivers", "nb_cectors", "nb_seorers", "nb_vectors", "nb_perets", "nb_eleures", "nb_semators", "nb_shvers", "nb_seivers", "nb_pectors", "nb_insevers", "nb_secgments", "nb_peivers", "nb_inserets", "nb_verets", "nb_elegments", "nb_negments", "nb_casevers", "nb_vevers", "nb_secators", "nb_caserets", "nb_nevers", "nb_insectors", "nb_neivers", "nb_eleators", "nb_casectors", "nb_cegments", "nb_electors"], "qiov": ["quiov", " qarrison", " qilib", "wiov", "quveh", "woyer", " quno", "qilib", "questoren", "woren", "Qiov", "questliv", " qoren", "quliv", "questilo", "qoren", "questoyer", " qimoto", " qveh", "qimoto", "quoren", "questimoto", "questuno", "Qarrison", "quarrison", "questiov", "quoyer", "questilib", "quuno", "qveh", " qoyer", "sqimoto", "sqiov", " qilo", "qliv", "sqilo", "questveh", "Qilo", "qarrison", "qilo", "qoyer", "quilo", "sqilib", "wliv", "quno", "Qoyer"], "s": ["sim", "sb", "sym", "serv", "space", "es", "sl", "fs", "g", "ses", "sie", "uns", "xs", "sets", "site", "ds", "services", "f", "sys", "t", "state", "stat", "os", "ssl", "p", "cs", "ts", "ls", "sync", "is", "stats", "sa", "sg", "c", "js", "settings", "spec", "sites", "sq", "submit", "si", "self", "b", "service", "aws", "parts", "session", "S", "ns", "sup", "side", "rss", "ps", "rs", "gs", "ins", "http", "conf", "su", "ss", "states"], "index_in_cluster": ["index_in_clusters", "index_in_Closer", "index_in_Clica", "index_in_sclica", "index_in_Clorsi", "index_in_chorsi", "index_in_lication", "index_in_sclication", "index_in_lica", "index_in_chensus", "index_in_Cluster", "index_in_choser", "index_in_locuster", "index_in_closer", "index_in_lusters", "index_in_clorsi", "index_in_Clication", "index_in_locoser", "index_in_clica", "index_in_sclusters", "index_in_queoser", "index_in_locusters", "index_in_luster", "index_in_chusters", "index_in_locensus", "index_in_Clensus", "index_in_clication", "index_in_queuster", "index_in_chuster", "index_in_queusters", "index_in_queorsi", "index_in_Clusters", "index_in_scluster", "index_in_clensus"], "n": ["span", "i", "net", "un", "en", "nat", "conn", "adj", "nn", "non", "d", "ny", "no", "f", "dn", "nl", "t", "y", "N", "nc", "m", "r", "j", "size", "u", "p", "na", "number", "o", "np", "network", "c", "rn", "nr", "num", "cn", "b", "ns", "len", "nb", "z", "v", "nt", "sn", "nor", "fn", "nu", "l", "x", "pn", "ne", "mn", "nm", "ni", "k"], "cluster_offset": ["cluster2num", "cluster_auto", "clard_position", "clause__start", "clayer_num", "clause_len", "cluster64slot", "clorum_offset", "clution_len", "clause__position", "clayer64num", "cluster64offset", "clorum_auto", "clayer_slot", "clution_size", "cluster_data", "cluster2size", "cluster_position", "clause_offset", "clayer64data", "cluster_len", "clayer64slot", "clayer_data", "cluster2offset", "cluster64data", "cluster_slot", "clard_Offset", "cluster_Offset", "cluster64num", "clause__offset", "cluster__position", "clause__len", "cluster_size", "cluster_alias", "cluster_start", "cluster__start", "clard_location", "cluster__offset", "clard_offset", "clorum_num", "clause_start", "clution_offset", "clayer64offset", "clayer_offset", "clution_num", "cluster_num", "clorum_alias", "cluster2len", "cluster__len", "cluster_location", "clause_position"], "hd_iov": ["hd_rolet", "hd_veh", "gh_oren", "hd_ilo", "hd_liv", "hid_iov", "hd_oren", "hid_rolet", "hid_io", "pd_iov", "hd_oyer", "gh_liv", "hd_lov", "uds_ilo", "gh_ilo", "uds_lov", "pd_liv", "uds_oyer", "hd_iris", "hd_io", "pd_ilo", "gh_iov", "uds_iov", "pd_veh", "hid_iris"], "hd_qiov": ["hd_quarrison", "hd_gicho", "hd_qqoyer", "hd_sqoyer", "hd_quoyer", "hd_koyer", "hd_qqoren", "hd_Qoyer", "hd_Qiov", "hd_qovo", "hd_karrison", "hd_qqarrison", "hd_sqiov", "hd_koren", "hd_quiov", "hd_sqoren", "hd_quiris", "hd_qarrison", "hd_govo", "hd_qoyer", "hd_kiov", "hd_qoren", "hd_qicho", "hd_quoren", "hd_giris", "hd_qqiov", "hd_giov", "hd_Qovo", "hd_sqiris", "hd_goyer", "hd_goren", "hd_Qicho", "hd_qiris"], "buf": ["conv", "bc", "pb", "port", "uf", "uc", "brace", "obj", "config", "result", "text", "cv", "fb", "queue", "func", "home", "img", "Buff", "fp", "cas", "buffer", "xff", "alloc", "cmd", "box", "raf", "data", "cf", "runner", "wb", "pool", "rc", "cb", "ctx", "aux", "b", "raw", "bo", "mem", "tmp", "seq", "auc", "ff", "fl", "src", "fd", "fw", "loc", "bd", "br", "Buffer", "ab", "feed", "buff", "bh", "bag", "vec", "rb", "dest", "orig", "block", "feat"], "orig_buf": ["orig_buff", "orig_vec", " orig_vec", "orig_uf", "origPvec", "prev_buf", "orig_header", "orig2buf", "orig_cb", "prev_buff", "prev_buffer", " orig_header", "prev_cb", "origPheader", "orig_buffer", "origPbuf", "orig2vec", "orig2header", "orig2buff", "origPbuff", "prev_uf", " orig_buff"], "err": ["str", "e", "ctr", "rx", "Er", "rr", "sys", "exc", "r", "msg", "res", "arr", "rh", "rc", "sg", "go", "usr", "error", "Error", "cr", "er", "gr", "br", "req", "rs", "proc", "resp"]}}
{"project": "FFmpeg", "commit_id": "9a0f60a0f89a7a71839dfa9def5a26f2037aed62", "target": 0, "func": "static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n\n{\n\n    int hours, minutes, seconds;\n\n\n\n    if (!show_bits(gb, 23)) {\n\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hours   = get_bits(gb, 5);\n\n    minutes = get_bits(gb, 6);\n\n    skip_bits1(gb);\n\n    seconds = get_bits(gb, 6);\n\n\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n\n\n    skip_bits1(gb);\n\n    skip_bits1(gb);\n\n\n\n    return 0;\n\n}\n", "idx": 23123, "substitutes": {"s": ["sv", "sb", "e", "qs", "sl", "hs", "fs", "g", "ses", "rates", "ops", "sets", "ks", "ds", "services", "f", "sys", "ssl", "os", "p", "cs", "ts", "ls", "o", "sync", "ss", "sa", "sg", "c", "ges", "ctx", "js", "self", "spec", "si", "sc", "b", "aws", "service", "S", "ns", "rs", "gs", "http", "conf", "bs", "server", "sq"], "gb": ["gio", "bc", "sb", "binary", "lb", "gt", "usb", "ui", "gram", "g", "gal", "gu", "db", "gnu", "gi", "boot", "bb", "og", "gin", "pc", "gd", "ci", "Gb", "ga", "eb", "phy", "bg", "storage", "hd", "agg", "gy", "kb", "gg", "wb", "sync", "gae", "sg", "cb", "gp", "du", "go", "b", "bo", "hub", "gc", "general", "bm", "ogg", "game", "gs", "buff", "bf", "lib", "gam", "ko", "multi", "GB", "rb", "gm", "cgi", "ge", "cod", "kw", "google", "abb", "rg"], "hours": ["obs", "pages", "hm", "runs", "units", "workers", "inches", "headers", "years", "ints", "Hours", "features", "time", "lines", "dates", "ages", "flows", "months", "shows", "eks", "groups", "ows", "jobs", "frames", "forces", "images", "bits", "itudes", "cycles", "days", "ms", "blocks", "parts", "steps", "utes", "length", "details", "words", "events", "hour", "quarters", "h", "times", "hops", "amples", "hh", "ays"], "minutes": ["Minions", "minsments", "donute", "minsutions", "mnions", "monutions", "Minutes", "Minute", "minseconds", "mnutions", "menuted", "menutes", "monutes", "continuted", "continues", "minues", "continutes", "continute", "minsseconds", "Minuted", "nicments", "minsutes", "monseconds", "donues", "menutions", "minments", "nicseconds", "menions", "Minutions", "nicutes", "minions", "donutes", "minuted", "minute", "mnuted", "donuted", "mnutes", "nicutions", "Minues", "minutions", "monments"], "seconds": ["outs", "ones", "units", "security", "years", "abytes", "ses", "mins", "sets", "bytes", "duration", "dates", "tones", "flows", "services", "games", "pieces", "months", "fps", "size", "strings", "timeout", "sections", "reports", "six", "groups", "frames", "second", "letters", "blocks", "days", "steps", "utes", "details", "words", "events", "utils", "quarters", "sec", "files", "eps"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_restart(FTPContext *s, int64_t pos)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    const int rest_codes[] = {350, 0};\n\n\n\n    snprintf(command, sizeof(command), \"REST %\"PRId64\"\\r\\n\", pos);\n\n    if (!ftp_send_command(s, command, rest_codes, NULL))\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n}\n", "idx": 23136, "substitutes": {"s": ["sb", "i", "e", "sym", "support", "es", "fs", "ses", "ssh", "sets", "ds", "f", "t", "r", "m", "socket", "php", "ssl", "os", "ts", "p", "setup", "o", "sync", "client", "c", "settings", "self", "sq", "service", "session", "S", "ns", "src", "sudo", "sf", "rs", "gs", "secondary", "server", "scope", "ss"], "pos": ["port", "i", "start", "end", "ref", "val", "POS", "pc", "po", "op", "info", "address", "args", "size", "cache", "patch", "os", "p", "Pos", "point", "addr", "index", " position", "spec", "pose", "pid", "ptr", "line", "location", "seq", "length", "Position", "loc", "len", "proc", "pointer", "block", "position", "offset", "type"], "command": ["Command", "package", "argument", "password", "query", "response", "send", "pattern", "character", "result", "text", "input", "power", "message", "connection", "mode", "function", "buffer", "exec", "cmd", "php", "msg", "sequence", "data", "address", "program", "patch", "method", "communication", "prefix", "code", "operation", "word", "directory", "comment", "content", "document", "python", "error", "comm", "child", "length", "call", "array", "script", "execute"], "rest_codes": [" rest_code", "rest_code", "rest_keys", "restperrors", " rest_cod", " rest_comm", "restpcomm", "rest_cod", "restpcodes", "rest_errors", "rest_comm", " rest_keys", "restpcode", " rest_errors"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n\n{\n\n    BlockDriverState *bs = child->bs;\n\n\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_offset;\n\n    unsigned int cluster_bytes;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* FIXME We cannot require callers to have write permissions when all they\n\n     * are doing is a read request. If we did things right, write permissions\n\n     * would be obtained anyway, but internally by the copy-on-read code. As\n\n     * long as it is implemented here rather than in a separate filter driver,\n\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n\n     * it could request permissions. Therefore we have to bypass the permission\n\n     * system for the moment. */\n\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 23140, "substitutes": {"child": ["conn", "fs", "uncle", "bin", "cur", "pc", "cl", "bl", "f", "crypt", "Child", "bit", "cache", "ssl", "job", "current", "code", "inner", "buf", "client", "pool", "c", "GV", "ch", "sub", "cy", "core", "fd", "cus", "feed", "root", "parent", "lib", "children", "block", "baby", "gb"], "offset": ["net", "phase", "limit", "start", "off", "config", "acl", "origin", "initialized", "afi", "align", "fp", "layer", "offs", "pos", "alloc", "info", "slave", "address", "entry", "size", "optional", "seed", "number", "url", "slot", "prefix", "initial", "o", "shift", "timeout", "index", "inet", "et", "oid", "set", "loader", "location", "online", "seq", "alias", "error", "Offset", "length", "slice", "len", "loc", "utils", "root", "parent", "reset", "pointer", "image", "position", "base", "output", "padding", "count"], "bytes": ["bc", "items", "binary", "net", "outs", "units", "es", "rows", "fs", "seconds", "lines", "null", "ops", "css", "pieces", "fee", "size", "codes", "data", "zip", "tes", "videos", "os", "classes", "errors", "ls", "bps", "gz", "values", "byte", "bits", "b", "blocks", "seq", "les", "length", "steps", "len", "Bytes", "boot", "files", "ips", "pages"], "qiov": [" qregor", " qrolet", "questoren", "dqirin", " qoren", " qirin", "qrolet", "qclub", "zregor", "qoren", "questoyer", "questiov", " qoyer", "ziov", "qirin", " qclub", "questregor", "questclub", "questirin", "dqclub", "zoyer", "questrolet", "dqiov", "qoyer", "qregor", "dqrolet", "zoren"], "bs": ["bc", "pb", "sb", "bos", "lbs", "lb", "outs", "bis", "serv", "ba", "obj", "fs", "ses", "ubs", "bal", "fb", "BC", "bb", "bin", "plugins", "bid", "bl", "bes", "ds", "css", "bing", "eb", "fps", "s", "bas", "os", "vs", "cs", "bn", "us", "ls", "bi", "sync", "bps", "settings", "cb", "js", "ib", "b", "bits", "blocks", "hub", "ns", "BS", "bel", "iss", "ps", "rs", "ins", "boot", "bf", "http", "bh", "banks", "gs", "root", "lib", "base", "ss", "las", "gb", "ubis"], "bounce_buffer": ["bouncepqueue", "botation67table", "bouncepwriter", "bounce2buffer", "bounceablequeue", "bounce64byte", "botation_buffer", "bait_buff", "batteryablebuffer", "bancel64iter", "bancel64buffer", "bounceingbuffer", "benge24buffer", "bancel_byte", "bouncelexiter", "bouncelextable", "bounceprelength", "bouncelexlayer", "bancel_buf", "botation_layer", "botation67buffer", "battery_length", "bait_length", "bouncelexbuf", "bait_Buffer", "bounceingbyte", "bounce_iter", "bounce_layer", "batteryablepad", "benge_queue", "bounce2byte", "bounce24queue", "bounce64buf", "battery_queue", "bounce_buff", "bounce64buffer", "bounce_buf", "benge_buffer", "bounceingbuf", "benge_writer", "bounce67layer", "bounceingiter", "bancel_iter", "bouncelexbuffer", "bounce_byte", "botation_table", "benge_resource", "benge24queue", "batteryablelength", "bounce_table", "bounce_length", "bouncepbuffer", "bounceablebuffer", "bounce_writer", "bounceablebyte", "bancel64buf", "bouncepresource", "bouncepreBuffer", "bounce_resource", "bounce67buffer", "bounceprepad", "batteryableBuffer", "battery_Buffer", "batteryablequeue", "botation67layer", "bounce_pad", "bounce24buffer", "bounceablelength", "bounceableBuffer", "bancel_buffer", "bouncelexbyte", "bounceprebuffer", "bait_buffer", "battery_pad", "battery_buffer", "benge24writer", "bancel64byte", "bounce_queue", "bounce24writer", "bounceablepad", "benge24resource", "batteryablebyte", "bounce24resource", "bounce_Buffer", "bounce2queue", "battery_byte", "bounce64iter", "bounce67table"], "drv": ["srh", "srv", "irj", "Drb", "hrj", "rrf", "drj", "drvs", "drh", "srf", "drf", "DrV", "srvs", " drV", "drb", "drV", "DRf", "rrvs", "irb", " drb", "rrv", " drvs", "hrv", "irV", "DRb", " drj", "irv", "hrV", "rrh", " drh", "Drv", "DRv", "Drf", " drf", "DRV", "hrb"], "iov": ["io", "gio", "iol", "club", " ensemble", " gymn", "rolet", "dyl", "iev", " cohort", "minecraft", "\u00ef", "oyer", "Club", "ibl", "vg", " liv", "icho", "iro", "drm", "vre", "iop", "ionic", "userc", "gru", "obo", "nov", "\u00ee", "voice", "uno", "nox", "ville", "iris", "nih", "buf", "ressor", "sbm", "oren", "ij", "imedia", "soc", "ilib", "wav", "liv", "rov", "lov", "IO", "lib", "chrom", "isco", "igroup", "voc", "ir", "ibr", " bio", " club", "ilo"], "bounce_qiov": ["bounce_qqoyer", "bounce_pilo", "bounce_qqrolet", "bounce_qrolet", "bounce_prolet", "bounce_giop", "bounce_gliv", "bounce_piop", "bounce_quiov", "bounce_gilo", "bounce_qqiov", "bounce_quiop", "bounce_poyer", "bounce_qqiop", "bounce_quoyer", "bounce_pliv", "bounce_qliv", "bounce_qiop", "bounce_qqilo", "bounce_dqiop", "bounce_qilo", "bounce_dqiov", "bounce_piov", "bounce_grolet", "bounce_giov", "bounce_qurolet", "bounce_dqliv", "bounce_dqoyer", "bounce_qoyer", "bounce_goyer"], "cluster_offset": ["clusters_Offset", "cluster_part", "cluster__length", "cluster__off", "cluster_end", "cluster___loss", "clusters_length", "clresh___layer", "cluster_off", "clusters_layer", "clusters_size", "cluster67offset", "clistry67offset", "clistry_part", "clistry_len", "cluster64index", "cluster64offset", "cluster_address", "clusters_padding", "cluster___layer", "cluster67part", "clusters_seconds", "cluster___offset", "cluster64len", "cluster_loss", "cluster_len", "cluster_area", "clresh_align", "cluster_padding", "clistry_offset", "clusterIPoffset", "cluster_frequency", "cluster67area", "clresh___align", "clistry67len", "cluster_layer", "cluster_Offset", "cluster_index", "cluster7frequency", "cluster7len", "cluster_size", "clistry67area", "clusterIPseconds", "clusters_index", "clresh_layer", "cluster_align", "clresh___offset", "clusters_len", "clusters_offset", "cluster64padding", "cluster__seconds", "clistry67part", "cluster__offset", "cluster67len", "cluster7layer", "cluster__size", "clusters_frequency", "clusterIPlayer", "clusterIPlength", "clusters_off", "clusterIPoff", "cluster_seconds", "clresh___loss", "clresh_loss", "cluster___align", "clusterIPfrequency", "cluster_length", "cluster__len", "cluster7offset", "clistry_area", "cluster__Offset", "clusterIPlen", "clresh_offset"], "cluster_bytes": ["clusters_files", "clancer_seconds", "cluster7bytes", "cluster_pieces", "cluster0items", "clusters_flows", "cluster67loads", "clancer_blocks", "cluster6bytes", "cluster6sequence", "clluster_items", "cluster8bytes", "cluster_values", "clensus_items", "clensus6items", "clensus6bytes", "cluster67values", "cluster67bytes", "cluster7ops", "cluster64lines", "cluster6length", "cluster_blocks", "clancer_loads", "cluster7items", "clluster67items", "cluster_len", "cluster0bytes", "clause_bytes", "clluster_bytes", "closer_bits", "clensus_length", "clause_byte", "cluster67sequence", "cluster_size", "clluster67values", "cluster_ops", "clancer_bytes", "cluster64seconds", "clensus6ops", "cluster6ops", "closer_lines", "clluster67len", "cluster_files", "clause_pieces", "cluster67seconds", "cluster64bits", "cluster0ops", "cluster7length", "cluster_items", "closer_bytes", "cluster8len", "clluster_values", "clensus_bytes", "cluster6items", "cluster67len", "cluster67blocks", "clusters_blocks", "clluster_len", "cluster64bytes", "clluster67bytes", "cluster67files", "cluster6files", "cluster8values", "clensus_ops", "cluster_flows", "clusters_bytes", "cluster_bits", "cluster_seconds", "cluster_lines", "clensus6length", "cluster67items", "cluster_sequence", "cluster_length", "cluster0length", "cluster_loads", "clause_size", "cluster67length", "closer_seconds", "cluster8items", "cluster_byte", "cluster67flows"], "skip_bytes": ["skip___lines", "skip2bps", "skip67tes", " skip_seconds", "skip2bits", "skip___bits", "skip67units", " skip_bits", "skip2bytes", "skip_seconds", "skip___units", "skip_tes", "skip67bytes", "skip___bps", "skip___bytes", "skip_bits", "skip_units", "skip_lines", "skip___tes", " skip_bps", "skip2lines", "skip_bps", " skip_units", " skip_tes", " skip_lines"], "ret": ["feat", "status", "reg", "def", "obj", "gt", "ref", "std", "result", "val", "arg", "ft", "det", "part", "Ret", "mt", "no", "art", "fit", "cmp", "bit", "res", "cat", "final", "rets", "fin", "opt", "job", " RET", "id", "code", "count", "addr", "success", "out", "num", "match", "pass", "let", "RET", "rt", " Ret", "value", "flag", "usr", "reply", "rev", "re", "sur", "lt", "len", "base", "back", "alt", "nt", "group", "lit", "att", "fi", "resp", "fun"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n", "idx": 23145, "substitutes": {"s": ["sv", "sb", "sym", "space", "es", "sl", "ses", "aps", "sis", "as", "ds", "services", "f", "sys", "t", "ssl", "os", "p", "o", "is", "ss", "sa", "sg", "c", "spec", "sh", "si", "a", "b", "se", "n", "S", "ns", "sf", "ps", "ans", "sp", "sq"], "type": ["port", "Type", "name", "types", "class", "shape", "ref", "app", "amp", "val", "part", "pe", "key", "time", "null", "TYPE", "style", "ty", "pc", "f", "art", "pos", "t", "op", "info", "pre", "address", "al", "data", "tp", "method", "p", "list", "ip", "id", "o", "var", "py", "ar", "ype", "error", "test", "parent", "sp", "typ", "block", "pt", "format", "prop"], "ret": ["status", "reg", "sb", "red", "en", "xt", "obj", "ref", "gt", "err", "pet", "result", "val", "part", "ft", "db", "det", "Ret", "mt", "no", "art", "al", "bit", "cat", "data", "res", "arr", "id", "code", "fun", "py", "af", "ext", "out", "rc", "num", "match", "let", "RET", "ann", "rt", "flag", "reply", "re", "pat", "len", "br", "lt", "back", "bf", "alt", "nt", "all", "att", "lit", "rets"], "arg": ["arc", "argument", "ig", "ak", "err", "ref", "app", "config", "ang", "g", "val", "inc", "mag", "Arg", "pc", "art", "exec", "al", "op", "ac", "args", "ad", "p", "play", "enc", "ace", "arr", "or", "addr", "arp", "var", "au", "aj", "ar", "ann", "flag", "arm", "ass", "par", "call", "ag", "ax", "doc", "alt", "sp", "lang"], "ap": [" sp", "ak", "app", "jp", "ast", "amp", "wa", "av", "aps", "map", "rep", "bp", "as", "op", "al", "ac", "apt", "tp", "list", "ip", " app", "ep", "p", "np", "arp", "AP", "af", "xml", "hap", "apy", " AP", "ar", "mp", "a", "ag", "ab", "ape", "ps", "array", "sp", "gap", "att", "api", "pa", "an", "cap"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155, "substitutes": {"opaque": ["oplonymous", "opec", "iopcus", "oophole", "oopivalent", "oplcus", "opthole", "ioponymous", " ophole", "oplaque", "ophole", "hopaque", "oopec", "hoponymous", "opcus", "optaque", "optec", "optivalent", "iopaque", "oopaque", " opec", "hopcus", "oponymous", "opivalent", " opivalent"], "offset": ["delay", "bound", "port", "i", "phase", "start", "attribute", "off", "ref", "sample", "config", "option", "part", "origin", "energy", "style", "align", "buffer", "pos", "alloc", "address", "entry", "data", "seed", "fee", "number", "prefix", "slot", "addr", "operation", "o", "timeout", "initial", "exclusive", "action", "ptr", "set", "location", "online", "seq", "alias", "error", "Offset", "length", "slice", "loc", "parent", "reset", "range", "alpha", "pointer", "position", "server", "base", "command", "padding", "type", "zero"], "size": [" error", " bytes", "Size", "bytes", "align", "ize", "type", "address", "data", "length", " length", " sizes", "len", "SIZE"], "s": ["sv", "sim", "sb", "native", "e", "sym", "sie", "sl", "g", "ses", "fs", "hs", "d", "sets", "ops", "site", "ks", "ds", "services", "os", "f", "sys", "t", "u", "its", "storage", "ssl", "shared", "p", "ts", "us", "cs", "o", "ls", "sync", "is", "stats", "sa", "sg", "c", "ss", "js", "spec", "self", "si", "b", "service", "aws", "n", "session", "S", "ns", "slice", "sf", "ps", "rs", "gs", "conf", "secondary", "server", "su", "sq", "states", "sum"], "index": ["i", "name", "row", "start", "connect", "end", "conn", "level", "ind", "input", "inc", "val", "key", "connection", "align", "access", "column", "weight", "type", "pos", "ion", "address", "version", "id", "number", "prefix", "field", "find", "fix", "Index", "num", "match", "si", "x", "length", "slice", "loc", "len", "element", "pointer", "block", "position", "base", "action"], "shift": ["transform", "hift", "shape", "start", "limit", "ix", "off", "send", "ind", "scale", "throw", "push", "power", "ctr", "force", "pad", "align", "weight", "reverse", "pos", "dist", "address", "use", "seed", "patch", "diff", "label", "balance", "depth", "field", "load", "timeout", "strip", "sh", "pop", "pull", "ptr", "set", "carry", "length", "sup", "slice", "mask", "flow", "Shift", "show", "range", "mix", "pack", "sleep", "sort", "max"], "count": ["col", "found", "i", "name", "limit", "handle", "start", "cc", "ref", "ind", "text", "coll", "part", "weight", "type", "info", "Count", "cat", "cache", "list", "sum", "current", "id", "number", "code", "depth", "content", "c", "num", "match", "flag", "counter", "seq", "carry", "length", "call", "mask", "len", "total", "allow", "child", "batch", "array", "all", "base", "max"], "value": ["Value", "val", "message", "device", "slave", "info", "data", "balance", "v", "instance", "image", "output", "this", "format", "type", "member", "name", "response", "end", "object", "scale", "valid", "null", "gi", "style", "dev", "description", "current", "unit", "child", "media", "element", "multi", "VALUE", "action", "reg", "native", "example", "summary", "amount", "result", "weight", "function", "model", "number", "vi", "depth", "comment", "memory", "values", "num", "service", "python", "error", "length", "expression", "volume", "start", "feature", "home", "get", "version", "label", "content", "document", "seq", "parent", "range", "server"], "lt_i": [" seq_ii", " seq_i", " ref_int", " seq_slice", " seq_int", " ref_ii", " ref_i", " ref_slice"]}}
{"project": "FFmpeg", "commit_id": "bb146bb57bea6647f9c080aa4f9323a3a789ad22", "target": 0, "func": "theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)\n\n{\n\n    struct ogg *ogg = ctx->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    struct theora_params *thp = os->private;\n\n    uint64_t iframe = gp >> thp->gpshift;\n\n    uint64_t pframe = gp & thp->gpmask;\n\n\n\n    if (thp->version < 0x030201)\n\n        iframe++;\n\n\n\n    if(!pframe)\n\n        os->pflags |= AV_PKT_FLAG_KEY;\n\n\n\n    if (dts)\n\n        *dts = iframe + pframe;\n\n\n\n    return iframe + pframe;\n\n}\n", "idx": 23159, "substitutes": {"ogg": ["obs", "ogi", "ow", "app", "gram", "rog", "aud", "argo", "ott", "pkg", "bb", "og", "oci", "ogo", "gd", "mpeg", "pg", "oss", "ga", "orm", "gow", "obb", "agg", "ob", "pp", "oga", "oper", "owl", "gg", "od", "ogs", "gz", "audio", "gp", "ocr", "go", "window", "math", "omm", "soc", "media", "ppy", "osc", "hw", "embed", "stream", "tz", "oc", "attr", "ogl"], "os": ["io", "dos", "obs", "bos", "ow", "obj", "conn", "object", "linux", "ost", "pkg", "ott", "oa", "ol", "ops", "so", "ds", "pc", "css", "pos", "sys", "op", "oss", "ok", "s", "ob", "oc", "osi", "p", "oper", "cs", "o", "od", "mac", "et", "oid", "ns", "ps", "ot", "boot", "proc", "osc", "OS", "ips", "ss"], "thp": ["ithlp", " thpc", "tha", "Thpe", "thpa", "thpe", "uthpa", "pllp", "sthos", "uthpc", "ithpc", "thap", "ghp", "thnp", "THps", "thf", "thos", "gha", " thps", "ithp", "THp", "Thpc", "thlp", "Tha", "plpa", "plpc", "thaps", "plp", " thf", " thpe", "thpc", "ghpc", "sthnp", "THf", "uthp", "sthp", "thanp", "thper", "Thper", " thper", "THpe", "thps", "Thf", "Thps", "sthps", " thos", "Thp", "ghper", "ithpa", "uthlp", " tha", " thnp", "thaos"], "iframe": ["episode", "binary", "cam", "wrapper", "movie", "ui", "include", "video", "mini", "cm", "fb", "margin", "plugin", "img", "pipe", "ci", "proxy", "fps", "fee", "size", "zip", "tif", "ip", "gallery", "pic", "py", "ctx", "frame", "gui", "uca", "window", "rame", "gif", "python", "media", "slice", "border", "multi", "avi", "isi", "hw", "embed", "gm", "image", "clip", "scroll", "li", "fi", "zi", "gb", "interface"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void av_build_index_raw(AVFormatContext *s)\n\n{\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    st = s->streams[0];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, s->data_offset, SEEK_SET);\n\n\n\n    for(;;) {\n\n        ret = av_read_frame(s, pkt);\n\n        if (ret < 0)\n\n            break;\n\n        if (pkt->stream_index == 0 && st->parser &&\n\n            (pkt->flags & PKT_FLAG_KEY)) {\n\n            add_index_entry(st, st->parser->frame_offset, pkt->dts, \n\n                            AVINDEX_KEYFRAME);\n\n        }\n\n        av_free_packet(pkt);\n\n    }\n\n}\n", "idx": 23161, "substitutes": {"s": ["sv", "request", "sb", "i", "e", "qs", "es", "bis", "sl", "fs", "g", "ses", "an", "d", "sets", "ops", "site", "services", "f", "sys", "t", "less", "u", "m", "args", "data", "storage", "r", "socket", "os", "ssl", "p", "cs", "us", "ls", "context", "sync", "is", "ss", "sa", "sg", "c", "js", "ctx", "spec", "settings", "self", "aus", "sts", "a", "b", "in", "set", "service", "se", "parts", "n", "S", "ns", "session", "sf", "south", "rs", "gs", "ps", "v", "server", "su", "sq"], "pkt1": ["packet2", " pkt0", "pkt3", "pqt0", "Packet2", " pct0", "pk0", "packet1", "Packet1", "pct0", "pkg1", " pct3", "Pkt2", "pKT0", "pKT1", "Pkt0", " pct1", "packet0", "pkt0", "pk1", "pkg3", "pqt3", "pkt2", "Packet0", "pct1", "pk2", "Pkt1", "pkg0", "pKT2", "pqt1", " pkt3", "pct3"], "pkt": ["Packet", "cpet", " pkg", " pct", "peracket", "Pct", "cpacket", "pet", "Pet", "cpkt", "pant", "pkg", "apnt", "perkt", "pernt", "pnt", "pakg", "apkt", "cpct", "perkg", "Pnt", "apct", "cpnt", " pnt", "Pkg", "paacket", " pet", "Pkt", "packet", "pakt", " packet", "cpkg", "pct", "apacket"], "ret": ["str", "reg", "ut", "en", "ref", "ur", "valid", "pet", "result", "val", "arg", "det", "Ret", "mt", "art", "al", "res", "cat", "fin", "rets", "arr", " RET", "fun", "addr", "success", "rc", "num", "match", "pass", "RET", "ver", "rt", " Ret", "sr", "flag", "reply", "re", "pat", "len", "iter", "back", "bf", "alt", "nt", "lit", "att", "ft"], "st": ["str", "step", "est", "sb", "start", "ast", "ct", "sl", "std", "ost", "kt", "St", "ld", "sth", "art", "t", "r", "rest", "ts", "ace", "sa", "sd", "et", "ste", "sh", "sts", "sc", "se", "sw", "src", "inst", "ist", "stage", "ST", "nt", "sp", "sn", "stream", "pt", "sta", "ss", "ft"]}}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163, "substitutes": {"fw_cfg": ["fwappfg", "nw_gd", "fwxcgi", "fwercfg", "cf_conn", "nw_fg", "cf_gate", "rw_conn", "cf_gen", "fwthegeneral", "fw_forge", "fx_forge", "fd_gui", "fw25cfg", "cf_config", "fwfcb", "rw_dc", "fw_gen", "fw25gui", "fwfconn", "fwxgd", "fx_cfg", "rw_fg", "cf_cf", "fw_gui", "fw__bg", "work_dc", "fwxcfg", "fw_config", "nw_cgi", "work_conn", "fwthecf", "fw_gd", "fwfdc", "fdthecfg", "fwxfg", "nw_cfg", "workfcfg", "fwfcfg", "cf_fg", "wk_fg", "fwappgd", "rw_cb", "fw_dc", "fx_settings", "fwappbg", "rw_cfg", "wk_cfg", "fwergeneral", "fwthesettings", "fdthegui", "wk_cf", "fw_bg", "fwthegui", "fw_fg", "workfcb", "work_cb", "fw25cf", "fdthegeneral", "fdthecf", "rw_cf", "work_cfg", "fd_cfg", "wk_conn", "fw_cf", "fwtheforge", "fd_cf", "fw_general", "fwthecfg", "fx_general", "fw_cgi", "fw25general", "workfdc", "fw_cb", "fw_gate", "fwersettings", "nw_bg", "fw__cfg", "fwerforge", "fw_conn", "fw__gd", "cf_cfg", "fw__fg", "fd_general", "fwappcfg", "fw_settings", "workfconn"], "smbios_tables": ["smbios_untable", "smbios_testries", "smbios_tasks", "smbios_entables", "smbios_temrees", "smbios_ttables", "smbios_tenras", "smbios_temables", "smbios_bipes", "smbios_nries", "smbios_ontables", "smbios_lrees", "smbios_tries", "smbios_tigs", "smbios_ontabs", "smbios_ftras", "smbios_tributes", "smbios_tees", "smbios_stigs", "smbios_nigs", "smbios_trees", "smbios_stables", "smbios_untables", "smbios_nables", "smbios_entubs", "smbios_ftipes", "smbios_Tipes", "smbios_ttubs", "smbios_ftributes", "smbios_table", "smbios_brees", "smbios_Tables", "smbios_stries", "smbios_ttamps", "smbios_ptigs", "smbios_ptrees", "smbios_tenributes", "smbios_stributes", "smbios_testables", "smbios_nributes", "smbios_ptasks", "smbios_tamps", "smbios_tenests", "smbios_tenipes", "smbios_tras", "smbios_Tries", "smbios_temipes", "smbios_ftables", "smbios_ttries", "smbios_contees", "smbios_untabs", "smbios_Tributes", "smbios_Tigs", "smbios_tenrees", "smbios_ontable", "smbios_temasks", "smbios_entries", "smbios_contabs", "smbios_bables", "smbios_bests", "smbios_contable", "smbios_tipes", "smbios_tubs", "smbios_temests", "smbios_tabs", "smbios_ligs", "smbios_temigs", "smbios_Tras", "smbios_testubs", "smbios_tests", "smbios_lasks", "smbios_entamps", "smbios_ptables", "smbios_lables", "smbios_contables", "smbios_testamps", "smbios_ontees", "smbios_untees", "smbios_tenables"], "smbios_anchor": ["smbios_actor", "smbios_chation", "smbios_cher", "smbios_chorer", "smbios_ancor", "smbios_archor", "smbios_actation", "smbios_minors", "smbios_archuser", "smbios_annors", "smbios_minOR", "smbios_chors", "smbios_ancore", "smbios_annorer", "smbios_gateore", "smbios_adaptors", "smbios_extation", "smbios_anchuser", "smbios_gateors", "smbios_adapter", "smbios_ancorer", "smbios_chore", "smbios_anchOR", "smbios_annore", "smbios_anchorer", "smbios_extors", "smbios_annor", "smbios_ancors", "smbios_archer", "smbios_gateor", "smbios_actore", "smbios_chor", "smbios_minor", "smbios_extore", "smbios_chOR", "smbios_adaptuser", "smbios_adaptor", "smbios_minore", "smbios_extor", "smbios_anchation", "smbios_ancher", "smbios_anchors", "smbios_chuser", "smbios_anchore", "smbios_archors", "smbios_gateOR", "smbios_actors"], "smbios_tables_len": ["smbios_tables_seq", "smbios_tables___lon", "smbios_tables__seq", "smbios_tables__Len", "smbios_tipes_en", "smbios_tributes_Len", "smbios_tablesslen", "smbios_tipes_lon", "smbios_tables_lon", "smbios_tables_length", "smbios_tablesslength", "smbios_tables_en", "smbios_tipes_Len", "smbios_tipes_len", "smbios_tables_rev", "smbios_tables__length", "smbios_tables_el", "smbios_tables__len", "smbios_tributes_length", "smbios_tables___length", "smbios_tables___Len", "smbios_tipes_length", "smbios_tributes_el", "smbios_tablessel", "smbios_tables_Len", "smbios_tributes_len", "smbios_tributes_part", "smbios_tipes_seq", "smbios_tablesspart", "smbios_tributes_rev", "smbios_tables_part", "smbios_tables___len"], "smbios_anchor_len": ["smbios_anchr_len", "smbios_anchr_length", "smbios_anchore_name", "smbios_anchr_lon", "smbios_anchr_Len", "smbios_anchor_val", "smbios_anchor_Len", "smbios_anchore_length", "smbios_anchore_Len", "smbios_anchor_length", "smbios_anchore_len", "smbios_anchor_name", "smbios_anchor_lon", "smbios_anchor_l", "smbios_anchore_val", "smbios_anchore_l"], "numa_fw_cfg": ["numa_FW_cfg", "numa_fw_cgi", "numa_fw_conf", "numa_fw_config", "numa_FW_cgi", "numa_FW_config", "numa_FW_conf"], "i": ["io", "ui", "d", "I", "f", "ci", "t", "y", "u", "r", "it", "p", "ip", "id", "o", "is", "c", "index", "a", "ii", "n", "iu", "v", "l", "x", "ni"], "j": ["jp", "g", "f", "pos", "r", "m", "p", "job", "o", "q", "aj", "J", "ii", "b", "ji", "ij", "n", "len", "v", "z", "uni", "l", "ne", "k"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23174, "substitutes": {"env": ["net", "enh", "txt", "e", "org", "en", "conn", "oe", "eu", "config", "event", "iv", "eni", "chal", "db", "esp", "eng", "energy", "ench", "eas", "engine", "etr", "ea", "ef", "exec", "esi", "exc", "fg", "init", "enc", "ep", "code", "context", "np", "que", "Environment", "ext", "ctx", "et", "equ", "enable", " environment", "loader", "viron", "enter", "er", "console", "iss", "osc", "v", "qt", "conf", "vm", "erv", "ev", "environment", "scope", "server", "ec", "here"], "vaddr": ["paddr", "rhost", "vcaddress", "pptr", " vord", " vptr", "wptr", "vaddress", "bdr", "waddr", "baddr", "ervaddress", "ervattr", "rdc", "haddr", "hattr", "ervaddr", "venter", "vcaddr", "rptr", "raddress", "vdc", "vord", "ovattr", "baddress", "waddress", "vptr", "paddress", "vattr", "word", "wenter", "vcattr", "wdr", " vdr", "wdc", "ervconfig", "vconfig", " vconfig", "haddress", " vhost", "oventer", " venter", "ovaddr", "whost", " vdc", "ovaddress", "wattr", "bptr", "vhost", "vdr", " vattr", "vcord", " vaddress", "hconfig"], "rw": ["row", "ru", "wcs", "rd", "wal", "ow", "wa", "wd", "rx", "rr", "wr", "ww", "rec", "rf", "rack", "ro", "wo", "r", "rew", "wh", "rh", "work", "wb", "rc", "rus", "rn", "nr", "wp", "wn", "nw", "rl", "raw", "w", "sr", "usr", "wheel", "sw", "wu", "RW", "fw", "rss", "walker", "ew", "rs", "wx", "tw", "rb", "hw", "kw", "wrap", "rg"], "asc": ["lc", "bc", "SC", "fc", "ru", "ra", "prev", "esc", "uc", "irc", "asm", "scale", "acl", "inc", "ctr", "rec", "as", "pc", "cl", "anc", "reverse", "isc", "rank", "alloc", "ac", "acc", "ASC", "abc", "ss", "rc", "rac", "arch", "rar", "sc", "raw", "rev", "auc", "desc", "src", "rss", "stage", "proc", "alpha", "up", "all", "oc", "ase", "attr"], "raddr": ["chop", "mhost", "rmac", "caddr", "hraddress", "rradder", "rlayer", "rptr", "bsta", "vptr", "rhop", "srptr", "rrpad", "srsta", " rdr", "craddress", " rloc", "vdr", " rmac", "rrmac", "rhost", "rloc", " rptr", "Raddr", "ruadder", "maddress", "rraddress", "srloc", "radder", "Rhost", "hraddr", "maddr", "rraddr", "Raddress", "ruaddr", "crpad", " rpad", "rsta", "srhop", "bptr", "vhost", "vpad", "rusta", "rpad", "baddr", "ruaddress", "vlayer", "nraddr", "raddress", "baddress", "nraddress", "rdr", " rroute", "rrsta", "vroute", "sraddress", "nrroute", "srlayer", "vhop", "vaddress", "rroute", "caddress", "clayer", "vloc", " rsta", " raddress", "Rptr", "mptr", "crlayer", "vsta", "vadder", " rhop", "hrhop", "craddr", "sraddr", "srdr", " rlayer", "hrlayer", "vmac", "srpad"], "flags": ["runs", "lights", "allows", "lists", "properties", "posts", "ils", "vals", "stats", "lag", "styles", "forces", "details", "fw", "fields", "rs", "ips", "feat", "pages", "rets", "items", "wcs", "rows", "offs", "nl", "fx", "Flags", "opens", "bits", "FLAG", "dds", "requires", "utils", "options", "checks", "works", "ats", "files", "inks", "atts", "ags", "fs", "cons", "lines", "rules", "bytes", "dates", "f", "members", "ants", "groups", "sw", "fd", "words", " Flags", "alls", "acks", "quarters", "lf", "mods", "versions", "includes", "types", "features", "locks", "ops", "plugins", "orts", "flows", "planes", "args", "faces", "strings", "tops", "vs", "errors", "caps", "settings", "rights", "reads", "flag", "fl", "comments", "tracks", "links", "states"], "sk": ["sky", "sch", "ik", "ak", "Sk", "kid", "sl", "hop", "nn", "cost", "push", "key", "ki", "ks", "ork", "can", "cp", "ok", "pp", "vs", "ka", "cs", "ace", "ep", "work", "K", "q", "SK", "kn", "ek", "kk", "c", "ask", "spec", "ink", "sh", "sc", "ch", "se", "dk", "cr", "sw", "call", "mask", "sf", "uk", "sp", "kr", "ke", "sn", "ck", "ss", "ski", "k"]}}
{"project": "FFmpeg", "commit_id": "dbc1163b203b175d246b7454c32ac176f84006d1", "target": 0, "func": "static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,\n\n                                   int blocks_per_slice,\n\n                                   int plane_size_factor,\n\n                                   const uint8_t *scan)\n\n{\n\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n\n    int max_coeffs, bits_left;\n\n\n\n    /* set initial prediction values */\n\n    run   = 4;\n\n    level = 2;\n\n\n\n    max_coeffs = blocks_per_slice << 6;\n\n    block_mask = blocks_per_slice - 1;\n\n\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n\n        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];\n\n        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return 0;\n\n\n\n        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);\n\n        if (run < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        level = decode_vlc_codeword(gb, ff_prores_ac_codebook[lev_cb_index]) + 1;\n\n        if (level < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        pos += run + 1;\n\n        if (pos >= max_coeffs)\n\n            break;\n\n\n\n        sign = get_sbits(gb, 1);\n\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n\n            (level ^ sign) - sign;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23184, "substitutes": {"gb": ["gio", "bc", "sb", "binary", "ig", "usb", "g", "gal", "gram", "gu", "db", "gnu", "gi", "bb", "vg", "gin", "ged", "che", "ds", "gd", "ci", "eb", "ga", "phy", "bg", "gru", "storage", "tg", "bn", "gy", "kb", "gg", "gz", "py", "sg", "rc", "ctx", "cb", "ges", "cfg", "gp", "b", "bo", "hub", "gc", "src", "bm", "game", "nb", "gs", "buff", "bf", "lib", "gam", "GB", "rb", "gm", "cgi", "ge", "cod", "abb", "rg"], "out": ["io", "outs", "serv", "err", "result", "inc", "copy", "gin", "process", "img", "buffer", "can", "op", "again", "cmd", "cache", "new", "ret", "params", "prefix", "o", "sync", "strip", "pin", "OUT", "source", "pass", "byte", "ann", "in", "b", "line", "Out", "batch", "boot", "lib", "parent", "up", "array", "group", "image", "output", "attr"], "blocks_per_slice": ["blocks_per_region", "blocks_per\u05bcscale", "blocks_per_shape", "blocks_pre_scale", "blocks_pre_pixel", "blocks_per_zone", "blocks_per_edge", "blocks_per_case", "blocks_per_scale", "blocks_pre_slice", "blocks_per_layer", "blocks_per\u05bcside", "blocks_per\u05bccase", "blocks_per\u05bcslice", "blocks_per_pixel", "blocks_pre_shape", "blocks_per_side"], "plane_size_factor": ["plane_size_flag", "plane_unit_digit", "plane_size__digit", "plane_unit_sector", "plane_size32flag", "plane_size_fact", "plane_size_digit", "plane_unit__digit", "plane_unit__sector", "plane_size32factor", "plane_unit_factor", "plane_size__fact", "plane_unit__factor", "plane_size64digit", "plane_size_limit", "plane_unit_fact", "plane_size32limit", "plane_size64fact", "plane_size64sector", "plane_size__sector", "plane_unit__fact", "plane_size_sector", "plane_size__factor", "plane_size64factor"], "scan": ["row", "query", "look", "store", "scale", "nan", "gram", "nn", "chan", "con", "parse", "feature", "bin", "align", "cell", "can", "split", "sys", "win", "ga", "cat", "stat", "sync", "gen", "pin", "search", "sc", "ann", "sub", "read", "gate", "call", "mask", "slice", "ignore", "Scan", "pan", "skip", "range", "block", "sum"], "pos": ["port", "i", "lat", "start", "un", "rupt", "off", "config", "ind", "push", "val", "part", "post", "cond", "su", "d", "POS", "no", "po", "order", "pre", "coord", "neg", "win", "size", "data", "cache", "j", "os", "p", "Pos", "unit", "diff", "id", "o", "depth", "pr", "index", " position", "spec", "pl", "pass", "pro", "pose", "pid", "pres", "seq", "ass", "min", "n", "slice", "len", "loc", "base", "ps", " positions", "z", "block", "position", "pt", "offset", "x"], "block_mask": ["block2mask", "bit_patch", "block_key", "word__sum", "blockingmask", "blockaclabel", "run64pack", "block2key", "blockacdepth", "word_mask", "run_label", "block__sum", "bit_mask", "block__mask", "word__mask", "blockacmask", "blockacpack", "block_sum", "run_pack", "word__count", "run64depth", "word_count", "word__clean", "bit_key", "blockinglabel", "block2patch", "block_count", "blockingdepth", "block\u00b7mask", "word_clean", "word_sum", "block_depth", "blockingpack", "block64label", "run64label", "block64depth", "block64mask", "block\u00b7key", "block__clean", "run_depth", "block_patch", "block_pack", "run64mask", "block_clean", "block_label", "block64pack", "run_mask", "block__count", "block\u00b7patch"], "run": ["reg", "row", "name", "runs", "ru", "un", "step", "ind", "config", "thread", "nn", "loop", "trial", "node", "model", "win", "Run", "order", "rank", "r", "use", "dir", "exec", "round", "zip", "man", "lock", "version", "play", "job", "runner", "unit", "work", "depth", "year", "fun", "id", "day", "tag", "num", "index", "plot", "pass", "add", "go", "line", "date", "ran", "min", "n", "call", "running", "clean", "update", "range", "group", "block", "position", "sort", "su", "record", "type"], "level": ["rol", "row", "fail", "pe", "val", "key", "win", "order", "lev", "la", "pl", "levels", "line", "clean", "l", "type", "letter", "col", "ul", "scale", "coll", "file", "style", "sol", "dir", "Level", "vel", "lock", "unit", "code", "year", "low", "pass", "vol", "child", "keep", "scope", "position", "lc", "mode", "layer", "model", "roll", "round", "full", "zip", "play", "lin", "depth", "le", "lvl", "length", "call", "show", "loc", "stage", "count", "limit", "loop", "inc", "build", "cl", "local", "rel", "lo", "index", "tag", "pull", "min", "len", "parent", "block", "where"], "sign": ["step", "name", "pen", "shape", "ix", "connect", "sk", "ind", "scale", "inc", "gn", "weight", "win", "size", "round", "version", "sum", "diff", "act", "id", "max", "mod", "vis", "shift", "close", "gen", "tag", "spec", "ask", "plus", "pass", "index", "sc", "ann", "pull", "sub", "value", "se", "dig", "save", "min", "call", "ign", "mask", "loc", "side", "secret", "clean", "Sign", "skip", "z", "SIGN", "pack", "sort", "ss", "type"], "run_cb_index": ["run_seq_index", "run_cod_offset", "run_cb_address", "run_cbstype", "run_cod_id", "run_cb_id", "run_cb_slice", "run_bc_index", "run_cb_Index", "run_cbPid", "run_cbPlevel", "run_cb_type", "run_cb_level", "run_cbsaddress", "run_cbsindex", "run_cbPoffset", "run_cbPindex", "run_cbsslice", "run_cb_offset", "run_seq_type", "run_seq_address", "run_bc_count", "run_cb_count", "run_seq_slice", "run_bc_Index", "run_cod_level", "run_cod_index"], "lev_cb_index": ["lev_cbsslice", "lev_cbocknode", "lev_cb_slice", "lev_cbendlist", "lev_cb_part", "lev_cb_image", "lev_cbockblock", "lev_db_index", "lev_cbsid", "lev_cbrblock", "lev_cod_list", "lev_cbrindex", "lev_cbsindex", "lev_db_slice", "lev_nb_index", "lev_cod_Index", "lev_cbspart", "lev_db_part", "lev_nb_size", "lev_cbrnode", "lev_cbbid", "lev_cbendIndex", "lev_cbendindex", "lev_cb_size", "lev_cbendimage", "lev_cod_index", "lev_nb_node", "lev_cb_block", "lev_cbbpart", "lev_cbrsize", "lev_cbockindex", "lev_cbocksize", "lev_cb_node", "lev_cb_list", "lev_cbbindex", "lev_cb_id", "lev_nb_block", "lev_cb_Index", "lev_cod_image", "lev_db_id", "lev_cbbslice"], "max_coeffs": ["max_coefp", "max_coeffits", "max_coefs", "max_coefd", "max_COffits", "max_coefficienti", "max_coefficientsits", "max_coefficientsp", "max_coefi", "max_coffp", "max_COeffd", "max_COeffs", "max_coefficientits", "max_coefes", "max_coffes", "max_COeffits", "max_coEFFs", "max_coeffi", "max_coefficients", "max_coEFFi", "max_coefficientsi", "max_coefficientd", "max_coffs", "max_coffd", "max_coeffes", "max_COeffp", "max_COeffi", "max_COffs", "max_COffi", "max_coEFFd", "max_coEFFits", "max_coeffd", "max_COffp", "max_coEFFes", "max_coffits", "max_COffd", "max_coffi", "max_coefficientss", "max_coefits", "max_coeffp"], "bits_left": ["bits_ignore", "ports_left", "bitslenlost", "bits___joined", "its_free", "topsSlimit", "cutsPleft", " bits_default", " bits_right", "bits_2", "cutsPpath", "bytes_none", "ports_leave", "bits_off", "cuts_plus", "boxes___la", "cutsPbottom", "its_right", "bits64leave", "tops_left", "bits___down", "bits_loaded", "bits_pull", "bits___left", "bits0right", "ports_off", "bits_right", " bits_lost", " bits_leave", " bits_log", "bitsSavailable", "bitsNpath", "boxes___pull", "bits0left", "bits___free", "bitsNbottom", "bits_free", "blocks_l", "bitsPbottom", "bits_lost", "bits_available", "cuts_left", "topsSright", "bits64left", "cutsPplus", "bitsPpath", "bits___la", "boxes_pull", "bitslendefault", "boxes_la", "bitsNleft", "its_left", "bits8free", "blocks_2", "bits_plus", "bits_bottom", "bits_leave", "bits64ignore", "bits_limit", "boxes_left", "bitsNplus", "cuts_path", "bits_none", "bits_la", "bits_path", "its_joined", "boxes___left", "bitsPplus", "bits64right", "bytes_left", "ports_loaded", "bits_l", "tops_limit", "bits8right", "bitslenleft", "topsSleft", "boxes_down", "bits_log", "bits_joined", "boxes___down", "bits_default", "bitsSright", "bits___right", "blocks_left", "bits___pull", "bytes_right", "bits8joined", "bitslenlog", "topsSavailable", " bits_ignore", "blocks_right", "cuts_bottom", "tops_available", "bitsSleft", "bits_down", "bits8left", "bitsSlimit", "tops_right", "bits0none", "bitsPleft"]}}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}", "idx": 23186, "substitutes": {"ctx": ["conv", "lc", "bc", "grad", "ux", "conn", "linux", "jp", "config", "coll", "lex", "pkg", "cm", "tx", "ca", "Context", "anc", "cas", "fp", "cmp", "ci", "exec", "alloc", "cp", "cs", "cf", "xc", "mc", "tc", "context", "buf", "rc", "c", "aux", "sc", "gc", "src", "fw", "loc", "cca", "utils", "buff", "hw"], "fs_path": ["fs67part", "fs1text", " fs_parent", " fs_Path", " fs1part", "fs1prop", "fs_part", "fs67path", "fs1part", " fs1text", "fs67prop", "fs_Path", "fs67text", " fs_part", "fs_prop", "fs_parent", "fs1path", " fs1path", " fs_prop", " fs_text", " fs1prop", "fs_text"], "fs": ["obs", "fc", "qs", "linux", "fb", "irs", "ops", "ks", "ds", "fp", "f", "flows", "df", "flags", "sys", "raf", "args", "ils", "cache", "os", "vs", "cf", "cs", "vals", "ls", "FS", "self", "aws", "fd", "ns", "fw", "sf", "utils", "feed", "ps", "bs", "lf", "Fs", "files", "ss", "acs", "states"], "dirfd": ["drawfd", "directoryFD", "DIRfd", "directoryfd", "fdd", "drfd", " dirFD", "dirflow", "fdfd", "foldersd", "dird", " dird", "dnf", "drf", "DIRFD", "dndir", "dirsd", " dirsd", "fdsd", "folderfd", " directoryfd", " dirflow", "drawdf", " dirf", "DIRdf", "drawfn", "directoryf", "folderf", "dirFD", "drdir", " directoryflow", "folderd", "dirfn", "drpd", "DIRfn", "dnpd", "drawFD", " dirdir", " dirfn", "dirpd", "dnfd", " dirpd", " dirdf", "directoryflow", " directoryf", "fdf", "dirdir", "dirdf", " directoryFD", "dirf"], "stream": ["transform", "port", "view", "public", "object", "wrapper", "level", "sl", "driver", "input", "coll", "hold", "progress", "cloud", "forward", "file", "draft", "Stream", "handler", "host", "follow", "f", "pipe", "path", "model", "dir", "entry", "data", "zip", "dd", "wh", "context", "upload", "open", "pool", "live", "client", "content", "source", "filter", "form", "plus", "raw", "speed", "draw", "through", "seek", "channel", "sw", "fd", "reader", "length", "src", "iterator", "clean", "feed", "stage", "resource", "unk", "ev", "type"]}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, ac3_id;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd = (ctx->oformat == &mpeg1vcd_mux);\n\n    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_mux);\n\n    \n\n    if (s->is_vcd)\n\n        s->packet_size = 2324; /* VCD packet size */\n\n    else\n\n        s->packet_size = 2048;\n\n        \n\n    /* startcode(4) + length(2) + flags(1) */\n\n    s->packet_data_max_size = s->packet_size - 7;\n\n    if (s->is_mpeg2)\n\n        s->packet_data_max_size -= 2;\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n    mpa_id = AUDIO_ID;\n\n    ac3_id = 0x80;\n\n    mpv_id = VIDEO_ID;\n\n    s->scr_stream_index = -1;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        switch(st->codec.codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if (st->codec.codec_id == CODEC_ID_AC3)\n\n                stream->id = ac3_id++;\n\n            else\n\n                stream->id = mpa_id++;\n\n            stream->max_buffer_size = 4 * 1024; \n\n            s->audio_bound++;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            /* by default, video is used for the SCR computation */\n\n            if (s->scr_stream_index == -1)\n\n                s->scr_stream_index = i;\n\n            stream->id = mpv_id++;\n\n            stream->max_buffer_size = 46 * 1024; \n\n            s->video_bound++;\n\n            break;\n\n        default:\n\n            av_abort();\n\n        }\n\n    }\n\n    /* if no SCR, use first stream (audio) */\n\n    if (s->scr_stream_index == -1)\n\n        s->scr_stream_index = 0;\n\n\n\n    /* we increase slightly the bitrate to take into account the\n\n       headers. XXX: compute it exactly */\n\n    bitrate = 2000;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        bitrate += st->codec.bit_rate;\n\n    }\n\n    s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n    \n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n       s->pack_header_freq = 1;\n\n    \n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* every 40 packets, this is my invention */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n    \n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        stream->buffer_ptr = 0;\n\n        stream->packet_number = 0;\n\n        stream->start_pts = AV_NOPTS_VALUE;\n\n        stream->start_dts = AV_NOPTS_VALUE;\n\n    }\n\n    s->last_scr = 0;\n\n    return 0;\n\n fail:\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        av_free(ctx->streams[i]->priv_data);\n\n    }\n\n    return -ENOMEM;\n\n}\n", "idx": 23193, "substitutes": {"ctx": ["conv", "lc", "bc", "cc", "cam", "wcs", "qs", "conn", "sci", "jp", "config", "ct", "coll", "xs", "kt", "cv", "pkg", "cm", "tx", "ca", "Context", "pc", "ks", "anc", "cas", "fp", "cu", "cmp", "ci", "cl", "nc", "cp", "cf", "cs", "xc", "ctrl", "tc", "context", "kb", "sync", "cli", "rc", "c", "cb", "cn", "wp", "client", "sc", "cpp", "gc", "media", "loc", "cca", "cus", "co", "gs", "wx", "cms", "qt", "conf", "hw", "ck", "kw", "sq", "vc", "www"], "s": ["sv", "es", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "js", "sts", "aws", "ms", "n", "S", "ns", "rs", "ins", "ans", "conf", "v", "ing", "l", "ss", "sb", "g", "ses", "d", "sets", "services", "u", "o", "sg", "c", "self", "spec", "set", "sf", "su", "e", "sym", "qs", "hs", "fs", "rates", "ings", "f", "t", "p", "si", "b", "service", "sup", "ps", "gs", "h", "sq", "sk", "sl", "als", "ops", "ks", "m", "its", "storage", "ys", "vs", "ls", "sync", "is", "sa", "client", "settings", "se", "session", "south", "bs", "server"], "bitrate": ["wordrates", "BITrate", "Bitrate", "wordrate", "BitRate", "BITration", "BITrates", "audrates", "audRate", " bitration", "wordration", " bitrates", "bitration", "audrate", "Bitrates", "bitRate", " bitRate", "bitrates"], "i": ["io", "lc", "jit", "ix", "start", "e", "ie", "qi", "ri", "ind", "ui", "eni", "mini", "key", "gi", "uri", "chi", "ti", "I", "l", "f", "ci", "y", "t", "phi", "info", "m", "ini", "adi", "j", "u", "it", "ret", "ip", "p", "abi", "id", "bi", "inner", "mi", "c", "index", "si", "ii", "x", "in", "ji", "ij", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "yi", "v", "li", "z", "h", "image", "im", "pi", "fi", "ni", "type"], "mpa_id": ["mpa67ids", "mpada67ids", "mpada67pid", "mpa__size", "mpp__ids", "mpa__ids", "mpada_pid", "mpa67id", "mpv_oid", "mpp_name", "mpa_pid", "mpada67id", "mpa67uid", "mpv_path", "mpa_ids", "mpada_id", "mpa_path", "mpa_name", "mpa_oid", "mpp_ids", "mpada_ids", "mpp_size", "mpa__id", "mpp__size", "mpp__id", "mpada67uid", "mpa_size", "mpa_uid", "mpp_id", "mpv_uid", "mpp__name", "mpa__pid", "mpa__name", "mpa67pid", "mpa__uid", "mpada_uid"], "mpv_id": ["mpv_kid", "mpvockpid", "mpv2name", "mpvrocktype", "mpvappindex", "mpvr_mid", "mpov_i", "mpvr_id", "mpv2kid", "mpv_mid", "mpvrockid", "mpvocktype", "mpov_index", "mpv_index", "mpv_pid", "mpf_id", "mpvrockpid", "mpv2ip", "mpvapptype", "mpf_kid", "mpv_ip", "mpv_i", "mpvappid", "mpvockid", "mpv_type", "mpov_type", "mpf_name", "mpvockmid", "mpvr_pid", "mpv2id", "mpvrockmid", "mpvr_type", "mpvappi", "mpv_name", "mpf_ip", "mpov_id"], "ac3_id": ["ac63_ids", "ac3_num", "ac3sid", "ac3_path", "ac63_sid", "acd_name", "ac3snum", "acd_type", "ac63_path", "ac3_sid", "acd_sid", "ac3_name", "ac3ssid", "acd_pid", "ac3_pid", "ac3_type", "acd_id", "ac3sname", "ac63_id", "ac3_ids", "acd_num"], "st": ["td", "str", "sv", "sb", "est", "step", "stack", "start", "sk", "ast", "ct", "sl", "steam", "std", "ost", "St", "d", "stop", "bl", "cl", "sth", "t", "rest", "nd", "p", "ts", "trans", "sa", "fe", "sd", "fr", "ste", "sts", "sc", "a", "sw", "inst", "src", "ist", "sf", "stage", "ST", "v", "sp", "sn", "dest", "pt", "sta", "ss", "ft"], "stream": ["row", "steam", "event", "progress", "post", "temp", "path", "data", "ssl", "load", "live", "pool", "draw", "src", "reader", "slice", "instance", "image", "output", "response", "flash", "object", "valid", "iv", "g", "coll", "ack", "file", "Stream", "track", "ream", "enc", "trans", "body", "upload", "sc", "channel", "child", "feed", "back", "video", "public", "stack", "uc", "wrapper", "thread", "result", "rec", "f", "model", "round", "form", "sw", "fd", "length", "put", "stage", "user", "resource", "port", "view", "sl", "input", "draft", "tr", "engine", "bl", "sync", "client", "source", "document", "filter", "w", "console", "server", "record"], "audio_bound": ["video_cond", "audio_bind", "audio64limit", "audiolexcond", "video_bind", "image_Bound", "audio_Bound", "audio_limit", "audiolexbound", "image_bound", "image_limit", "audiolexbind", "audiolexBound", "video_Bound", "audio__limit", "image_position", "audio64position", "audio64bound", "audio__Bound", "audio_position", "audio_cond", "audio__bound", "audio64Bound", "audio__position"], "video_bound": ["media_weight", "videolorder", "media_bound", "video_weight", "video_count", "media_count", "video_offset", "media_limit", "videoloffset", "audio_order", "audio_offset", "videolbound", "video_limit", "video_order"]}}
{"project": "FFmpeg", "commit_id": "d7da4d47a6841444f12bf56dfe4230d3e4af8646", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n    int ret;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n    mxf->edit_units_per_packet = 1;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!url_feof(s->pb)) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n\n\n            if (!mxf->current_partition) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            if (!mxf->current_partition->essence_offset) {\n\n                /* for OP1a we compute essence_offset\n\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n\n                 */\n\n                int64_t op1a_essence_offset =\n\n                    round_to_kag(mxf->current_partition->this_partition +\n\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n\n\n                if (mxf->op == OPAtom) {\n\n                    /* point essence_offset to the actual data\n\n                    * OPAtom has all the essence in one big KLV\n\n                    */\n\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n\n                    mxf->current_partition->essence_length = klv.length;\n\n                } else {\n\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n\n                }\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else if (mxf->parsing_backward)\n\n                continue;\n\n            /* we're still parsing forward. proceed to parsing this partition pack */\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n\n\n                    /* only seek forward, else this can loop for a long time */\n\n                    if (avio_tell(s->pb) > next) {\n\n                        av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n\n                               klv.offset);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    /* we need to do this before computing the index tables\n\n     * to be able to fill in zero IndexDurations with st->duration */\n\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n\n        return ret;\n\n\n\n    if (mxf->nb_index_tables > 1) {\n\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    mxf_handle_small_eubc(s);\n\n\n\n    return 0;\n\n}\n", "idx": 23206, "substitutes": {"s": ["sv", "i", "es", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "S", "ns", "rs", "http", "v", "conf", "l", "ss", "sb", "g", "ses", "d", "sets", "site", "services", "o", "sg", "c", "spec", "sc", "sf", "su", "native", "e", "sym", "qs", "serv", "fs", "com", "f", "t", "new", "p", "si", "b", "service", "gs", "sec", "secondary", "sq", "sci", "sl", "ops", "m", "storage", "ls", "sync", "is", "client", "settings", "single", "source", "se", "session", "south", "server"], "mxf": ["ncf", "nxc", "gxc", "Mcf", "mfc", "fmcf", "dxf", "dxd", "dxc", "fmxc", "Mxc", "mxd", "nxf", "Mxf", " mxd", "cmxf", "Mxe", "gxd", "nxd", "fmxe", "Mxa", "dxe", "gxf", "Mxd", "cmxd", "cmcf", "mcf", "mxa", "cmxc", "pxc", " mcf", "mxe", " mxe", "pcf", "pxd", " mxc", "gxe", "mxc", "cmfc", " mfc", "fmxf", "Mfc", "dcf", "pxf", " mxa", "nxa", "nfc", "cmxe", "nxe", "fmxd"], "klv": ["kvl", "cklv", "kela", "Kql", "keLV", "kln", "knvi", "kvc", "kswl", "okwl", "mlv", "sklf", " kql", "skla", "skql", " kwl", "okrl", "klc", "skln", "kLV", "skrl", " klf", " kvl", "kla", "skvi", "kslv", "ikLV", "skLV", "kevc", "Kln", "kql", "Kwl", "klf", "ikwl", "kwl", " kll", "sklp", "kelp", "mlp", "cklc", "Klc", "oklp", "mLV", "uklc", "ukvl", "uklv", "skvc", "kll", "iklv", "okvm", "ckwl", "uklf", "okln", "okvl", " klc", "kelv", "Kvm", "kvm", "sklv", "Klf", "ikvl", "kvi", "cklf", "oklf", "Kvl", "kslc", "ksll", "skvm", " kLV", "Klv", "ckll", "klp", "mrl", "okvc", "kevi", "okLV", "oklv", "knlv", "knla", "knlp", "sklc", "krl"], "ret": ["col", " val", "def", " success", "val", "rep", " flags", "Ret", " resp", " RET", "rc", "num", "RET", " Ret", "ry", "nt"], "metadata": ["ATA", "package", "summary", "message", "meta", "json", "node", "ata", "info", "entry", "m", "data", "description", "params", "annot", "o", "filename", "adata", "header", "tmp", "iterator", "details", "definition", "parser", "options", "met", "stream", "ma"]}}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23213, "substitutes": {"retval": ["returnvals", "gtref", "retvalue", " retVal", "rtpart", "revalue", "Retref", "retVal", "gtVal", "resel", "reVal", "returnVal", "gtval", "RETVal", "Retval", "rtval", "retpart", "retsel", "Retpart", "retvals", " retvalue", "returnval", "rtref", "RETval", "RETvalue", "RetVal", "rtVal", "retref", "RETvals", " retvals", "reval", "rtsel", "gtpart", "rtvalue", " retsel", "returnvalue"], "msg": ["md", "status", "str", "Msg", "name", "def", "obj", "err", "send", "config", "gram", "g", "text", "val", "ger", "arg", "pkg", "message", "cm", "mb", "db", "og", "plugin", "op", "reason", "info", "cmd", "args", "data", "generic", "bg", "bug", "m", "enc", "sys", "mod", "code", "word", "body", "comment", "sg", "gen", "ext", "module", "frame", "dr", "cfg", "u", "missing", "go", "ms", "error", "comm", "desc", "details", "loc", "game", "debug", "req", "html", "mess", "doc", "gs", "manager", "ma", "gm", "l", "base", "gb", "notice"], "flags": ["status", "types", "ags", "ints", "rows", "fs", "features", "lines", " errors", "rules", "locks", "bytes", "ops", "plugins", "ages", "properties", "bugs", "fps", "args", "codes", "ils", "cs", "vals", "errors", "ports", "modules", "prefix", "stats", "Flags", " bits", "settings", "lag", "frames", "styles", "forces", "bits", "flag", "FLAG", "magic", "comments", "details", "mask", " Flags", "fields", " bugs", "utils", "options", "alls", "checks", "tracks", "links", "tags", "mods", "files", "ips"], "nchars": ["nchats", "nChards", "nspants", "lchicks", "Nquats", "Nchats", "nfars", "lcharicks", "nscapes", "nchants", "nchards", " nchannels", "ncolases", "nbARS", "nshannels", " nvalls", "lcharases", "lchars", "Nquars", "nbicks", "ncolares", "nchapes", "nchalls", "nichars", "ncquases", " nchans", " nquars", "nscalls", "nshases", " nchats", "ncquars", "narchards", "lcharARS", "nchases", " nChards", "nquans", "nquats", "narchars", "nbases", "nquants", "lchases", "Nchards", "nChats", "nvards", "ncchards", " nquans", "narchalls", "narchapes", "lcharars", "ncharARS", "nspards", "nchicks", "ncolars", "nfans", " nvards", " nChats", "nquares", "Nquards", "nshards", " nchalls", "ncolans", "nbars", "nquannels", "nChases", "nChants", " nvars", "nichases", "ncharars", "nscards", "nchares", "nspars", "Nquases", "nquards", "nchannels", "nhicks", "nvars", "nchans", " nchares", " nquares", "nquars", "ncchannels", "nhARS", "ncolannels", "nhases", " nvapes", "nChars", "nichards", " nchards", "ncchars", "ncolards", "nshars", "nscars", "ncharases", "ncharicks", "nquases", "ncquannels", "Nchars", "nchARS", "lchARS", "nspats", "nichats", "Nchases", " nChants", "nfares", " nChars", "ncchases", " nchants", " nchapes", "nhars", "nvapes", "ncquards", "nfannels", " nquannels", "nvalls"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n", "idx": 23237, "substitutes": {"r": ["ru", "e", "rd", "err", "adr", "ur", "result", "rx", "d", "rr", "rec", "cur", "rf", "lr", "f", "t", "u", "m", "rel", "ir", "p", "arr", "or", "rh", "o", "rw", "dr", "pr", "rc", "nr", "c", "fr", "ar", "rt", "sr", "hr", "b", "rl", "w", "re", "cr", "er", "gr", "R", "br", "reader", "mr", "rs", "range", "rb", "kr", "l", "record", "attr", "k", "rg"], "r_next": [" r_last", "r__seq", "r___next", "R_end", "r___rev", " r_sequence", "r___sequence", "r_end", " r_rev", "r_sequence", " r_seq", "R_next", "r_rev", "r_seq", "R_last", "r__last", "r__next", "r_last"], "h": ["ih", "i", "hm", "e", "err", "hs", "g", "ha", "d", "dh", "oh", "host", "ho", "f", "sth", "t", "ah", "u", "m", "kh", "eh", "head", "hd", "p", "id", "o", "rh", "q", "work", "uh", "code", "H", "c", "header", "sh", "ch", "hr", "b", "w", "he", "hash", "hl", "n", "zh", "gh", "th", "hi", "v", "bh", "l", "x", "ph", "ht", "hh", "k"]}}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n", "idx": 23244, "substitutes": {"iscsilun": ["iscinfut", "iscsilune", "iscsluni", "iscsinuna", "iscsluno", "iscielun", "iscsinumen", "iscrielun", "itschsiluni", "ircsiluna", "iscseluno", "iscrubuna", "iscralmun", "ircsiluno", "uscsluna", "iscrieluni", "iscielunion", "iscislunin", "isclituno", "iscsilmun", "uscslumen", "iscrubune", "uscslut", "iscralune", "iscseluna", "iscselun", "iscislun", "ircslun", "isclituna", "iscrielunion", "iscinfun", "iscselunin", "iscslun", "iscslmun", "uscsilun", "uscsiluna", "iscisluno", "ircsilun", "uscslun", "iscrieluna", "itschsilun", "iscsilumen", "iscalun", "iscsinuno", "iscsiluna", "iscieluni", "iscsilunin", "itschrieluni", "iscsilunion", "itschsiluna", "iscrubun", "iscalmun", "uscsilmun", "uscsilut", "ircsluna", "ircsluno", "uscsiluno", "iscieluna", "iscraluna", "iscisluna", "iscinfuna", "iscaluna", "ircslunin", "ircsilunin", "iscsluna", "itschrielun", "iscsinun", "iscslumen", "uscsluno", "uscslune", "iscslut", "itschrieluna", "isclitun", "iscsiluni", "iscralun", "iscsilut", "iscrubut", "itschsilunion", "uscsilumen", "uscsilune", "uscslmun", "iscslunion", "iscalune", "iscslune", "iscsiluno", "iscinfune", "iscslunin", "itschrielunion", "isclitumen"], "sector_num": ["sector_initial", " sector_name", "section_set", "section_num", "sector_sum", "sectoridoffset", " sector_length", "section_number", "section_initial", "section_sum", "sector_offset", "sectoridset", "sector00num", "section_offset", "sectoridsum", "sector00offset", " sector_number", "sector00set", "sector_length", "sector_name", "sector_set", "sector_number", "sectoridnum", "sector00sum"], "nb_sectors": ["nb_segments", "nb_sections", "nb_pegments", "nb_pections", "nb_psesections", "nb_gector", "nb_psector", "nb_servec", "nb_suvec", "nb_psegments", "nb_sugments", "nb_sector", "nb_secctors", "nb_suctors", "nb_gectors", "nb_secsections", "nb_serctions", "nb_suctions", "nb_sesections", "nb_secctor", "nb_gegments", "nb_pectors", "nb_psectors", "nb_secgments", "nb_gesections", "nb_serctors", "nb_sergments", "nb_sevec", "nb_pevec"], "cluster_num": ["cluster_Num", "cluster_number", "cluster_count", "cluster_n", "cluster_sum", "cluster_size", "clancer_num", "clusters_Num", "clusters_num", "clancer_sum", "cluster_name", "clancer_count", "clusters_name", "clancer_Num"], "nb_clusters": ["nb_blions", "nbNallers", "nb_compuster", "nb_CLions", "nb_CLuster", "nbNclusters", "nb_compers", "nbNclblocks", "nb_bluster", "nb_plards", "nb_clayers", "nb_allusters", "nbNcluster", "nb_blusters", "nb_CLusters", "nb_clonents", "nb_plonents", "nb_splayers", "nb_splusters", "nb_plblocks", "nb_clions", "nb_splonents", "nb_cluster", "nb_allblocks", "nbNclers", "nb_slonents", "nb_players", "nb_clards", "nbNallusters", "nb_CLards", "nbNalluster", "nb_alluster", "nb_allers", "nb_compblocks", "nb_plers", "nb_slions", "nb_splions", "nb_slayers", "nb_clblocks", "nb_compusters", "nbNallblocks", "nb_slusters", "nb_plusters", "nb_blards", "nb_plions", "nb_clers", "nb_pluster"]}}
{"project": "qemu", "commit_id": "e511b4d783c47a32420da802104cfb0eb974b22f", "target": 0, "func": "int cpu_exec(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n#endif\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    uintptr_t next_tb;\n\n    SyncClocks sc;\n\n\n\n    /* This must be volatile so it is not trashed by longjmp() */\n\n    volatile bool have_tb_lock = false;\n\n\n\n    if (cpu->halted) {\n\n        if (!cpu_has_work(cpu)) {\n\n            return EXCP_HALTED;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    current_cpu = cpu;\n\n\n\n    /* As long as current_cpu is null, up to the assignment just above,\n\n     * requests by other threads to exit the execution loop are expected to\n\n     * be issued using the exit_request global. We must make sure that our\n\n     * evaluation of the global value is performed past the current_cpu\n\n     * value transition point, which requires a memory barrier as well as\n\n     * an instruction scheduling constraint on modern architectures.  */\n\n    smp_mb();\n\n\n\n    if (unlikely(exit_request)) {\n\n        cpu->exit_request = 1;\n\n    }\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n    cpu->exception_index = -1;\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n\n            /* if an exception is pending, we execute it here */\n\n            if (cpu->exception_index >= 0) {\n\n                if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = cpu->exception_index;\n\n                    if (ret == EXCP_DEBUG) {\n\n                        cpu_handle_debug_exception(env);\n\n                    }\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    cc->do_interrupt(cpu);\n\n#endif\n\n                    ret = cpu->exception_index;\n\n                    break;\n\n#else\n\n                    cc->do_interrupt(cpu);\n\n                    cpu->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = cpu->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        cpu->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        cpu->halted = 1;\n\n                        cpu->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                        cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n                        do_cpu_init(x86_cpu);\n\n                        cpu->exception_index = EXCP_HALTED;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#else\n\n                    if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n                        cpu_reset(cpu);\n\n                    }\n\n#endif\n\n                    /* The target hook has 3 exit conditions:\n\n                       False when the interrupt isn't processed,\n\n                       True when it is, and we should restart on a new TB,\n\n                       and via longjmp via cpu_loop_exit.  */\n\n                    if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                        next_tb = 0;\n\n                    }\n\n                    /* Don't use the cached interrupt_request value,\n\n                       do_interrupt may have updated the EXITTB flag. */\n\n                    if (cpu->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(cpu->exit_request)) {\n\n                    cpu->exit_request = 0;\n\n                    cpu->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit(cpu);\n\n                }\n\n                spin_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = true;\n\n                tb = tb_find_fast(env);\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tcg_ctx.tb_ctx.tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tcg_ctx.tb_ctx.tb_invalidated_flag = 0;\n\n                }\n\n                if (qemu_loglevel_mask(CPU_LOG_EXEC)) {\n\n                    qemu_log(\"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));\n\n                }\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~TB_EXIT_MASK),\n\n                                next_tb & TB_EXIT_MASK, tb);\n\n                }\n\n                have_tb_lock = false;\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                cpu->current_tb = tb;\n\n                barrier();\n\n                if (likely(!cpu->exit_request)) {\n\n                    trace_exec_tb(tb, tb->pc);\n\n                    tc_ptr = tb->tc_ptr;\n\n                    /* execute the generated code */\n\n                    next_tb = cpu_tb_exec(cpu, tc_ptr);\n\n                    switch (next_tb & TB_EXIT_MASK) {\n\n                    case TB_EXIT_REQUESTED:\n\n                        /* Something asked us to stop executing\n\n                         * chained TBs; just continue round the main\n\n                         * loop. Whatever requested the exit will also\n\n                         * have set something else (eg exit_request or\n\n                         * interrupt_request) which we will handle\n\n                         * next time around the loop.\n\n                         */\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        next_tb = 0;\n\n                        break;\n\n                    case TB_EXIT_ICOUNT_EXPIRED:\n\n                    {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n", "idx": 23245, "substitutes": {"env": ["bc", "bench", "net", "e", "org", "en", "conn", "exe", "eu", "config", "eni", "db", "cv", "esp", "eng", "engine", "ea", "exc", "nc", "cmd", "cp", "cache", "enc", "vs", "context", "np", "cli", "Environment", "rc", "c", "et", "cfg", "loader", "profile", "core", "osc", "proc", "ec", "vm", "conf", "ev", "environment", "server", "fi", "ne"], "cpu": ["bc", "platform", "fc", "hp", "exe", "config", "process", "pc", "css", "cp", "px", "hu", "pid", "cpp", "proc", "instance", "clock", "computer", "conn", "linux", "jp", "GPU", "pkg", "processor", "CPU", "node", "fp", "fps", "component", "current", "unit", "mac", "c", "cfg", "gc", "chip", "utils", "boot", "lib", " CPU", "pu", "cu", "ubuntu", "lc", "lb", "uc", "gpu", "eu", "nic", "kernel", " cp", "framework", "host", "intel", "cmp", "gru", "uno", "cli", "coe", "module", "num", "roc", "loader", "uu", "python", "core", "hw", "ec", "bench", "consumer", "nc", "cache", "uci", "np", "ctx", "cn", "frame", "auc", "console", "chu", "prem", "vm", "server"], "cc": ["lc", "bc", "fc", "uc", "conn", "ct", "cm", "con", "ca", "pc", "css", "cl", "ci", "cmp", "acc", "nc", "cp", "cache", "ucc", "mc", "cf", "cs", "ctrl", "tc", "xc", "PC", "rc", "c", "ctx", "cow", "cn", "icc", "dc", "cci", "CC", "gc", "core", "cca", "co", "proc", " gcc", "ck", "hw", "ec", "vc", "ctl"], "x86_cpu": ["x64_CPU", "x86_core", "x64_cpu", "x64_core", "x64_gpu", "x86_gpu", "x86_CPU"], "ret": ["feat", "bc", "ut", "reg", "red", "ref", "ct", "vt", "valid", "pet", "result", "val", "ft", "arg", "det", "Ret", "mt", "bit", "res", "data", "cat", "fin", "opt", "job", " RET", "id", "code", "fun", "success", "num", "match", "let", "RET", "rt", " Ret", "mem", "rev", "seq", "re", "len", "lt", "back", "alt", "nt", "lit", "att", "fi", "resp", "rets", "pub"], "interrupt_request": ["interruption_Request", "interrupt67response", "interrupt_received", "interruptablecall", "interrupt_call", "interruptfullength", "interruptfulresponse", "interruptlyrequire", "interrupt_query", "interrupt_demand", "interruption_demand", "interart_path", "interruption_right", "interruptablereport", "interrupt_require", "interruptlyseek", "interruption_request", "intercept_length", "interart_response", "intercept_request", "interrupt67right", "intercept_question", "interrupt67Request", "interruptableresponse", "interruptMseek", "interrupt_path", "interrupt_question", "interrupt_report", "intercept_right", "interrupt_response", "intercept_received", "interrupt_seek", "interruptMright", "interruption_response", "interruptedresponse", "interrupt_Request", "interruptlyright", "interart_request", "interruptedreceived", "interruption_report", "interart_query", "interrupt_right", "interruptMrequire", "intercept_require", "interruptfulrequest", "interruption_call", "interrupt_length", "interruptfulquestion", "interrupt67request", "interruptlyrequest", "interruptablerequest", "interruptMrequest", "interruptedrequest", "interruptedright", "intercept_response", "intercept_seek"], "tb": ["ttb", "tpb", "ttbs", "ttrb", "tbs", " tpb", "untrb", "untbs", " tbs", " trb", "ttpb", "trb", "untb", "untpb"], "tc_ptr": ["TC_ptr", "TC_pointer", "tcxpointer", "tcxinst", "tc_pointer", "TC_ref", "tcxref", "tc_ref", "tc_inst", "tcxptr", "TC_inst"], "next_tb": ["next_xtab", "next_Tbi", "next_untbi", "next_xtbi", "next_xtlb", "next_Tp", "next_nab", "next_tbi", "next_nbi", "next_untf", "next_rtf", "next_Tlb", "next_nb", "next_untp", "next_tf", "next_Tab", "next_nlb", "next_tlb", "next_rtbi", "next_tab", "next_rtp", "next_tp", "next_rtb", "next_xtb", "next_untb", "next_Tf", "next_Tb"], "sc": ["lc", "bc", "SC", "sb", " ssh", " scr", "uc", "esc", "sci", "ct", "sl", "asc", "ca", "Sc", "pc", "cl", "scl", "isc", "acc", " Sc", "cs", "mc", "tc", "sync", "sa", "rc", "c", "spec", "sq", "sh", "si", "icc", "ch", "soc", "cr", "sw", "src", "osc", "ec", "sp", "scope", "ss"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "substitutes": {"str": ["lc", "expr", "ix", "Str", "start", "obj", "err", "text", "ctr", "tr", "wr", "temp", "css", "cur", "exec", "r", "arr", "cs", "frac", "enc", "last", "code", "inner", "dr", "pr", "spec", "fr", "sc", "ocr", "sr", "hr", "ptr", "seq", "cr", "inst", "gr", "len", "br", "iter", "rs", "stri", "st", "sec", "empty", "wrap", "STR"], "endptr": ["startPtr", "endpointers", "ndpt", "endedptr", "adptr", "endPtr", "endpt", "endpointer", " endpointers", "startptr", "ndptr", "startaddr", " endaddr", "endaddr", "endedPtr", "Endpointers", "adpointer", "adaddr", "EndPtr", "ndpointer", " endpt", "endedpointer", "endedpointers", " endpointer", "startpt", "startpointer", "adPtr", "Endpointer", "Endptr", " endPtr"], "res": ["reg", "ras", "obj", "err", "rows", "result", "ress", "RES", "_", "rap", "rx", "rr", "bytes", "css", "results", "rez", "pre", "ris", "r", "s", "args", "os", "ret", "Res", "cs", "vals", "arr", "rh", "reed", "rc", "out", "js", "resh", "bits", "des", "pres", "ms", "ics", "rev", "re", "cr", "gr", "R", "rss", "req", "ps", "rs", "resolution", "resp"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 23250, "substitutes": {"ysrc": ["sysrt", "ssrc", "iessrc", "xsync", "ysync", "ysRC", "iesync", "xsrt", "sRC", "sysync", "ysroc", "sysroc", "iesrt", "sroc", "inssrc", "insroc", "src", "iesrc", "yssrc", "insrc", "syssrc", "xssrc", "sysrc", "xsrc", "sysRC", "insRC", "ysrt"], "usrc": ["usource", "ausdc", " ussrc", "uri", "ausource", "uource", "usri", "usdc", " usri", " usource", "aussrc", "ausrc", " usdc", "udc", "urc", "ussrc", "ausri"], "vsrc": ["usst", "wsource", "svloc", "usource", "svsl", "wsl", "fsl", "vsource", "wsrc", "vloc", "vsl", "vst", "vssrc", "vsst", "ussource", "vssource", "wloc", "fsrc", "svsrc", "fsource", "urc", "ussrc", "vrc", "svsource", "ust", "floc"], "dst": ["DST", "Dst", "sst", "ssrc", "idste", "bdste", "bdsts", "dST", "dsrc", "Ddest", "idst", "sdsrc", "Dsrc", "sdST", "dbe", "idbe", "ddest", "dsts", " dbe", "bdst", "sdst", "sST", " dste", "dste", " dsts", "bdbe", "sddest", "idsts", "sdest"], "height": ["shape", "high", "square", "input", "style", "ty", "pad", "img", "Height", "dist", "rank", " heights", "y", "size", "hd", "depth", "crop", "thin", "density", "distance", "images", "dim", "deep", "window", "direction", "pull", "stroke", "length", "above", "alpha", "resolution", "gap", "h", "image", "bottom", "wrap", "max", "padding"], "lumStride": ["lumStrro", "lumStrip", "lumbStrro", "lumStro", "lumbstride", "lumbstrite", "lumScro", "lumSTride", "lumStrrip", "lumScride", "lumScrite", "lumbstro", "lumSTro", "lumstro", "lumbstrip", "lumbStri", "lumbStrride", "lumSTrip", "lumbStrrip", "lumSTri", "lumbStrri", "lumbStrite", "lumStrri", "lumStrite", "lumstrip", "lumstri", "lumScrip", "lumStri", "lumbStro", "lumbStrip", "lumbStride", "lumstride", "lumStrride", "lumstrite", "lumSTrite"], "chromStride": ["chromStrite", "romstride", "homStri", "chromsterve", "chromstrite", "chromSTerve", "chromSTride", "chromEstride", "romStrite", "homStrric", "chromStrri", "chromStrride", "chromSTrip", "chromEstri", "chromUride", "chromSTri", "homStrip", "chromSTric", "romsterve", "chromSTro", "romstrite", "chromUerve", "chromStro", "romStro", "chromStrrip", "chromSterve", "chromStrric", "homStric", "chromEstric", "chromUro", "chromstride", "homStrri", "chromStri", "homStride", "homStrrip", "chromEstrip", "homStrride", "chromstro", "romstro", "romStride", "chromSTrite", "chromStrip", "chromUrite", "romSterve", "chromStric"], "dstStride": ["dspStend", "dspStride", "dstSTrip", "dstSTride", "dstStro", "dstRestro", "dscStro", "dscStide", "dspTue", "dstSTend", "dstStrrip", "dspTend", "dscStrrip", "dstStrride", "dstRestide", "dspTride", "dscStrride", "dstClride", "dstClend", "dstTrip", "dstStide", "dstClue", "dstRestride", "dstSTue", "dstRestrip", "dspStrip", "dstTride", "dstClrip", "dspTrip", "dstTend", "dspStue", "dstStend", "dstStrip", "dstStue", "dstTue", "dstStrro", "dscStrip", "dscStride", "dscStrro"]}}
{"project": "FFmpeg", "commit_id": "b7d9b4a1f1fcd01084ccbec6f7ef32c853681833", "target": 1, "func": "int ff_h263_decode_mb(MpegEncContext *s,\n                      int16_t block[6][64])\n{\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    const int xy= s->mb_x + s->mb_y * s->mb_stride;\n    int cbpb = 0, pb_mv_count = 0;\n    av_assert2(!s->h263_pred);\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        do{\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for(i=0;i<6;i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->mb_skipped = !(s->obmc | s->loop_filter);\n                goto end;\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 20);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra) goto intra;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n            cbpy ^= 0xF;\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n            /* 16x16 motion prediction */\n            s->mv_type = MV_TYPE_16X16;\n            ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n            if (s->umvplus)\n               mx = h263p_decode_umotion(s, pred_x);\n            else\n               mx = ff_h263_decode_motion(s, pred_x, 1);\n            if (mx >= 0xffff)\n            if (s->umvplus)\n               my = h263p_decode_umotion(s, pred_y);\n            else\n               my = ff_h263_decode_motion(s, pred_y, 1);\n            if (my >= 0xffff)\n            s->mv[0][0][0] = mx;\n            s->mv[0][0][1] = my;\n            if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n               skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type = MV_TYPE_8X8;\n            for(i=0;i<4;i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                  skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                mot_val[0] = mx;\n                mot_val[1] = my;\n    } else if(s->pict_type==AV_PICTURE_TYPE_B) {\n        int mb_type;\n        const int stride= s->b8_stride;\n        int16_t *mot_val0 = s->current_picture.motion_val[0][2 * (s->mb_x + s->mb_y * stride)];\n        int16_t *mot_val1 = s->current_picture.motion_val[1][2 * (s->mb_x + s->mb_y * stride)];\n//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;\n        //FIXME ugly\n        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=\n        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=\n        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=\n        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;\n        do{\n            mb_type= get_vlc2(&s->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);\n            if (mb_type < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b mb_type damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            mb_type= h263_mb_type_b_map[ mb_type ];\n        }while(!mb_type);\n        s->mb_intra = IS_INTRA(mb_type);\n        if(HAS_CBP(mb_type)){\n            s->bdsp.clear_blocks(s->block[0]);\n            cbpc = get_vlc2(&s->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);\n            if(s->mb_intra){\n                dquant = IS_QUANT(mb_type);\n                goto intra;\n            cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n            if (cbpy < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n                cbpy ^= 0xF;\n            cbp = (cbpc & 3) | (cbpy << 2);\n        }else\n            cbp=0;\n        av_assert2(!s->mb_intra);\n        if(IS_QUANT(mb_type)){\n            h263_decode_dquant(s);\n        if(IS_DIRECT(mb_type)){\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type |= set_direct_mv(s);\n        }else{\n            s->mv_dir = 0;\n            s->mv_type= MV_TYPE_16X16;\n//FIXME UMV\n            if(USES_LIST(mb_type, 0)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                s->mv_dir = MV_DIR_FORWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n            if(USES_LIST(mb_type, 1)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 1, &pred_x, &pred_y);\n                s->mv_dir |= MV_DIR_BACKWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[1][0][0] = mx;\n                s->mv[1][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do{\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 8);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\nintra:\n        s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n        if (s->h263_aic) {\n            s->ac_pred = get_bits1(&s->gb);\n            if(s->ac_pred){\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n                s->h263_aic_dir = get_bits1(&s->gb);\n        }else\n            s->ac_pred = 0;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(cbpy<0){\n            av_log(s->avctx, AV_LOG_ERROR, \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        pb_mv_count += !!s->pb_frame;\n    while(pb_mv_count--){\n        ff_h263_decode_motion(s, 0, 1);\n        ff_h263_decode_motion(s, 0, 1);\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (h263_decode_block(s, block[i], i, cbp&32) < 0)\n            return -1;\n        cbp+=cbp;\n    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)\n        return -1;\n    if(s->obmc && !s->mb_intra){\n        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)\n            preview_obmc(s);\nend:\n        /* per-MB end of slice check */\n    {\n        int v= show_bits(&s->gb, 16);\n        if (get_bits_left(&s->gb) < 16) {\n            v >>= 16 - get_bits_left(&s->gb);\n        if(v==0)\n            return SLICE_END;\n    return SLICE_OK;", "idx": 23256, "substitutes": {"s": ["sv", "bis", "es", "uns", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "stats", "js", "ms", "n", "S", "ns", "ins", "rs", "v", "conf", "l", "ss", "sb", "support", "g", "ses", "sports", "sets", "site", "as", "services", "o", "sites", "sg", "c", "self", "spec", "a", "des", "set", "changes", "sf", "su", "times", "e", "sym", "qs", "fs", "cons", "rates", "f", "t", "new", "p", "si", "b", "service", "ims", "parts", "side", "ps", "gs", "secondary", "sq", "your", "ops", "ks", "m", "its", "ls", "sync", "is", "settings", "w", "session", "comments", "states"], "block": ["bc", "str", " Block", "row", "view", "def", "object", "obj", "ref", "map", "part", "ban", "BL", "bin", "plugin", "bl", "cl", "node", "layer", "buffer", "device", "bit", "box", "data", "lock", "arr", "ip", "unit", "job", "code", "record", "buf", "header", "frame", "byte", "mem", "line", "blocks", "seq", "channel", " blocks", "base", "array", "image", "Block", "x", "type"], "cbpc": ["pbproc", "dbpn", "pbpb", "abbpc", "bbc", "abbPC", "bbproc", "dbc", "rbPC", "cbPC", "kbpi", "cbpb", "CBPC", "rbp", "ctrpr", "cdfc", "bbfc", "bcproc", "CBp", "bbpc", "abbfc", "cbc", "cbpn", "CBproc", "bcpc", "rbpc", "cbfc", "cbpr", "ctrfc", "cbnc", "cbpi", "dbpc", "bcp", "bbpi", "bbpb", "cfp", "CBfc", "kbpn", "rbnc", "kbpc", "cfproc", "cfpc", "pbpc", "cbproc", "rbfc", "bbpn", "cdnc", "cdbc", "CBnc", "ctrpc", "pbfc", "ctrp", "bbp", "CBpb", "dbpi", "bcfc", "CBpr", "cbbc", "cdpc", "CBbc", "bbpr", "kbc", "cffc", "abbp", "rbbc", "CBpc"], "cbpy": ["cfpc", "cfpy", "pbpy", "pbpc", "pbpx", "CBpm", "cfpm", "cfpx", "CBpy", "pbpm", "cbpx", "CBpx", "cbpm", "CBpc"], "i": ["io", "e", "ix", "fi", "qi", "ri", "ui", "eni", "pi", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "y", "info", "u", "ini", "phi", "oi", "j", "init", "r", "ip", "p", "id", "bi", "inner", "cli", "mi", "is", "c", "index", "si", "ii", "in", "b", "ji", "n", "iu", "ai", "xi", "hi", "di", "multi", "v", "z", "li", "ie", "x", "zi", "k", "ni", "type"], "cbp": ["gcpm", "cbpe", "cvpm", "gcp", "cbbp", "cvbp", "cvp", "cvpe", "cfpm", "gcbp", "cfpe", "gcpe", "cfbp", "cbpm", "cfp"], "pred_x": ["prop_y", "pred_p", "prop_x", "prop_name", "pred_name", "prop_p"], "pred_y": ["cb_z", "cb_x", "pred_z", "cb_y", "pred_vy", "cb_vy"], "mx": ["md", "wm", "ml", "mb", "xy", "cm", "mag", "mode", "rx", "pm", "m", "mc", "mm", "np", "mi", "mp", "mem", "xp", "ms", "ym", "dm", "mes", "bm", "foo", "loc", "mr", "vm", "mn"], "my": ["sym", "another", "yy", "me", "meta", "mode", "rx", "mis", "mon", "mic", "hh", "sys", "custom", "mc", "mm", "mys", "mi", "cy", "ms", "test", "Mi", "wx", "mix", "My", "mos", "mn", "mmm"], "dquant": ["mcount", "dbbuff", " dcount", "lqual", " dproc", "fqual", "fproc", "lquant", "dcount", "fquant", "dbqual", "dcomp", "dbquant", "dqual", "dbcount", " dqual", "dproc", "lcomp", "mquant", "lproc", "dbuff", " dbuff", "mqual", "fcomp", "mbuff", " dcomp"], "mot_val": ["reg2val", "reg2depth", "reg2type", "mot2val", "reg_value", "mot2value", "reg2value", "mot__value", "motFval", "motFtype", "reg_depth", "mot2depth", "mot__depth", "motFdepth", "reg_val", "mot_depth", "mot__val", "mot_type", "reg_type", "mot2type", "motFvalue", "mot__type", "mot_value"], "mb_type": ["mb__list", "mb_style", "mb_types", "mp_types", "mb_list", "mp_style", "mb__types", "mb__style", "mp_type", "mb__type", "mp_list"], "pb_mv_count": ["pb_mtv0info", "pb_mtv0count", "pb_mtv0id", "pb_mtv0size", "pb_mv_info", "pb_mv__id", "pb_mv__count", "pb_mv0count", "pb_mv_id", "pb_mtv_size", "pb_mav_id", "pb_mtv_id", "pb_mv__info", "pb_mv__size", "pb_mtv_info", "pb_mv_size", "pb_mv0info", "pb_mv_base", "pb_mav_base", "pb_mav_count", "pb_mtv_count", "pb_mv0id", "pb_mv0size"]}}
{"project": "FFmpeg", "commit_id": "92fabca427ff2d8fffa4bd4f09839d8d3822ef31", "target": 0, "func": "static void DEF(put, pixels16_x2)(uint8_t *block, const uint8_t *pixels, ptrdiff_t line_size, int h)\n\n{\n\n    MOVQ_BFE(mm6);\n\n    __asm__ volatile(\n\n        \"lea        (%3, %3), %%\"REG_a\" \\n\\t\"\n\n        \".p2align 3                     \\n\\t\"\n\n        \"1:                             \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"subl   $4, %0                  \\n\\t\"\n\n        \"jnz    1b                      \\n\\t\"\n\n        :\"+g\"(h), \"+S\"(pixels), \"+D\"(block)\n\n        :\"r\"((x86_reg)line_size)\n\n        :REG_a, \"memory\");\n\n}\n", "idx": 23259, "substitutes": {"block": ["col", "row", "name", "limit", "blocking", "end", "level", "none", "inc", "bl", "column", "buffer", "cell", "pixel", "pos", "pre", "bit", "full", "cache", "patch", "lock", "enc", "unit", "pool", "header", "index", "frame", "hole", "byte", "w", "line", "blocks", "channel", "length", "page", "wall", "batch", "image", "Block", "clock", "pack", "type"], "pixels": ["tixel", "npixel", "cowers", "picks", "towers", "teps", " picks", "tiles", "npeps", "peps", "cixels", "pixel", " piles", "tixels", " powers", "ticks", "npixels", "piles", "cicks", "ceps", "cixel", "ciles", "powers"], "line_size": [" line_num", "lineallrate", "line32size", "line32rate", " line_level", "lineallscale", "block_scale", "line_rate", "line_scale", "linewsize", "linewlevel", "line_num", "lineallsize", "linewnum", "lineallSize", "line32scale", "block_Size", "line_level", "line32Size", "line_Size", "block_rate", "block_size"], "h": ["ih", "i", "row", "hm", "e", "hp", "headers", "ach", "hs", "hidden", "d", "oh", "heads", "f", "layer", "y", "r", "m", "head", "p", "o", "rh", "H", "c", "header", "hole", "sh", "ch", "b", "w", "hash", "n", "history", "v", "bh", "z", "hw", "l", "x", "ht", "padding"]}}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274, "substitutes": {"idstr": ["midstring", "pidStr", "sidstr", "midbytes", "IDbytes", "endstr", "idobj", "sidobj", "pidstr", "aidstr", " idarr", "sidStr", "idStr", "pidcr", "aidbr", "idcode", "IDarr", " idStr", " idbytes", "midstr", "midarr", "aidstring", "idst", "idlist", "IDSTR", "pidcode", "aidst", "idSTR", "IdStr", "pidbr", "IDstring", "keystr", "endSTR", "idcr", "keyStr", "nameStr", "namestring", "IDcr", "midStr", "midbr", "idbytes", "pidlist", "namestr", "pidstring", "endobj", " idcr", "idstring", " idlist", "nameobj", "IDobj", "Idcode", "Idstr", "IDstr", "endStr", " idobj", " idSTR", "keystring", "idbr", "midst", "pidst", "keyobj", "IDStr", "pidSTR", "sidSTR", "idarr", " idcode", "Idlist"], "instance_id": ["ance_ids", "instance64ids", "instance64name", " instance_offset", "instance_version", "instance_offset", "instance64i", "instance_end", "ance_name", "ance_sid", "instance64base", "ance_Id", "instance___version", " instance_base", "instance_Id", "instance___id", "instance_sid", "instance___name", "instance_base", "instance_oid", " instance_type", "ance_version", " instance_oid", " instance_name", "instance_i", "instance_type", "instance64id", "instance_name", " instance_i", "ance_id", "instance_ids", " instance_ids", "instance___ids", "instance_count", "ance_end", " instance_sid", "ance_count"], "version_id": ["instance_ident", "versionalstart", "versionalname", "instance_code", "versionPoolid", "versioneename", "version_start", "versionfulident", " version_ident", "instance_start", "instance_source", "versionPoolsource", "version_ident", " version_index", "versioneeid", "versionfulid", "version_code", "version_name", "versioneesource", " version_ids", "versionalid", "versionPoolname", "instance_name", "versionfulstart", "version_source", "versionfulname", "version_index", "versioneecode", "versionPoolcode", "version_ids", "versionalident"], "save_state": ["saveedpolicy", "load_policy", "savefpolicy", "saveedstatus", "save__resource", "ave_state", "instanceedstate", "saveedstates", "saveedstate", "load_rule", "save_id", "saveingstate", "instanceedstatus", "save_rule", "instanceedstates", "instance_policy", "ave_rule", "save__state", "instance_state", "save_policy", "savefstates", "instance_states", "save_states", "saveingpolicy", "save__id", "save_config", "save_status", "instanceedpolicy", "ave_id", "savefstate", "saveingrule", "savefstatus", "save__rule", "instance_status", "load_config", "ave_resource", "save_resource", "saveingconfig"], "load_state": ["loadingingstate", "loadingingstring", "load_session", "loadalsession", "loaderjob", "load_states", "load_rule", "load_string", "load_type", "loadamstates", "loaderrule", "save_session", "loadingstates", " load_rule", "loadingstring", "loadamjob", "loadingingstates", "loading_rule", "loadingtype", " load_states", "loadamrule", "loadalstate", "load_job", "loadingrule", "loadaltype", " load_job", "save_type", "loadingingrule", "loaderstate", "loadingstate", "loading_state", "loading_string", "loaderstates", "loading_states", "loadingsession", "loadamstate"], "opaque": ["operacity", "opaques", "operaque", "opsicit", "copicit", "uppicate", "copaques", " opicate", "opsacity", "obasso", "opsaques", "uppacity", "copaque", "oppaque", "opicit", "oppacity", "oppity", "opicate", "Opicit", "operacement", "Opacity", "operity", "obaque", "uppaque", "opacity", "oppasso", " opacity", " opacement", "obity", "Opaque", "opericate", "obacity", "Opaques", "copacity", "operasso", "opity", "opasso", "opacement", "opsaque", "uppacement"], "se": ["ede", "ite", "asse", "e", "sel", "sed", "es", "ie", "serv", "send", "sk", "sl", "ph", "ser", "ses", "ade", "pe", "lex", "be", "isse", "de", "parse", "site", "so", "ine", "ide", "ue", "s", "Se", "seed", "esse", "del", "cle", "ace", "SE", "sync", "le", "sa", "ese", "sd", "ste", "sea", "sh", "sc", "ch", "si", "sing", "te", "ve", "spe", "see", "sem", "ae", "ce", "ne", "sp", "sec", "ke", "ge", "su", "ase", "ze", "sle"], "pse": ["ple", "pas", "ede", "je", "syn", "ite", "pen", "press", "ee", "oe", "jp", "ene", " pe", "xe", "ade", "pe", "lex", "me", "isse", "clus", "phone", "pm", "pex", "pei", "parse", "process", "sei", "pos", "ine", "esi", "pre", "ffe", "tp", "p", "na", "SE", "cess", "sa", "coe", "pes", "pr", "fe", "la", "inse", "sea", "perse", "pass", "pose", "si", "pid", "ste", "kes", "vale", "seq", "te", "spe", "ve", "phe", "ps", "psy", "sem", "proc", "ae", "ne", "ship", "pty", "ke", "ge", "su", "ph", "poke", "pa"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "substitutes": {"klass": [" kcl", "skclass", "kslass", "kcl", "ksclass", " klasses", "kscl", "Klass", "sklasses", " kclass", "Kcl", "kclass", "sklass", "klasses", " kass", "skass", "Klasses", "kslasses", "kass", "Kass", "Kclass"], "data": ["after", "i", "def", "config", "ui", "this", "input", "Data", "ata", "exec", "info", "da", "cache", "dd", "load", "rc", "DATA", "loader", "session", "di", "parent", "dat", "api"], "dc": ["md", "lc", "bc", "fc", "cd", "cc", "conn", "config", "controller", "db", "cm", "d", "DC", "pc", "ds", "css", "df", "nc", "ga", "ac", "da", "cat", "dd", "design", "mc", "cf", "ctrl", "tc", "dr", "c", "rc", "spec", "dt", "dk", "tk", "gc", "cr", "enter", "fd", "cdn", "loc", "cca", "jc", "di", "doc", "dat", "disc", "ec", " DC", "vc"]}}
{"project": "FFmpeg", "commit_id": "042ef4b720f5d3321d9b7eeeb2067c671d5aeefd", "target": 1, "func": "static int decode_mb_cavlc(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;\n\n    int partition_count;\n\n    unsigned int mb_type, cbp;\n\n    int dct8x8_allowed= h->pps.transform_8x8_mode;\n\n\n\n    s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?\n\n\n\n    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);\n\n    cbp = 0; /* avoid warning. FIXME: find a solution without slowing\n\n                down the code */\n\n    if(h->slice_type != I_TYPE && h->slice_type != SI_TYPE){\n\n        if(s->mb_skip_run==-1)\n\n            s->mb_skip_run= get_ue_golomb(&s->gb);\n\n\n\n        if (s->mb_skip_run--) {\n\n            if(FRAME_MBAFF && (s->mb_y&1) == 0){\n\n                if(s->mb_skip_run==0)\n\n                    h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n                else\n\n                    predict_field_decoding_flag(h);\n\n            }\n\n            decode_mb_skip(h);\n\n            return 0;\n\n        }\n\n    }\n\n    if(FRAME_MBAFF){\n\n        if( (s->mb_y&1) == 0 )\n\n            h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n    }else\n\n        h->mb_field_decoding_flag= (s->picture_structure!=PICT_FRAME);\n\n\n\n    h->prev_mb_skipped= 0;\n\n\n\n    mb_type= get_ue_golomb(&s->gb);\n\n    if(h->slice_type == B_TYPE){\n\n        if(mb_type < 23){\n\n            partition_count= b_mb_type_info[mb_type].partition_count;\n\n            mb_type=         b_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 23;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else if(h->slice_type == P_TYPE /*|| h->slice_type == SP_TYPE */){\n\n        if(mb_type < 5){\n\n            partition_count= p_mb_type_info[mb_type].partition_count;\n\n            mb_type=         p_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 5;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else{\n\n       assert(h->slice_type == I_TYPE);\n\ndecode_intra_mb:\n\n        if(mb_type > 25){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"mb_type %d in %c slice too large at %d %d\\n\", mb_type, av_get_pict_type_char(h->slice_type), s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n        partition_count=0;\n\n        cbp= i_mb_type_info[mb_type].cbp;\n\n        h->intra16x16_pred_mode= i_mb_type_info[mb_type].pred_mode;\n\n        mb_type= i_mb_type_info[mb_type].type;\n\n    }\n\n\n\n    if(MB_FIELD)\n\n        mb_type |= MB_TYPE_INTERLACED;\n\n\n\n    h->slice_table[ mb_xy ]= h->slice_num;\n\n\n\n    if(IS_INTRA_PCM(mb_type)){\n\n        unsigned int x, y;\n\n\n\n        // We assume these blocks are very rare so we do not optimize it.\n\n        align_get_bits(&s->gb);\n\n\n\n        // The pixels are stored in the same order as levels in h->mb array.\n\n        for(y=0; y<16; y++){\n\n            const int index= 4*(y&3) + 32*((y>>2)&1) + 128*(y>>3);\n\n            for(x=0; x<16; x++){\n\n                tprintf(s->avctx, \"LUMA ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*((x>>2)&1) + 64*(x>>3)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA U ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 64 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA V ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n\n\n        // In deblocking, the quantizer is 0\n\n        s->current_picture.qscale_table[mb_xy]= 0;\n\n        h->chroma_qp = get_chroma_qp(h->pps.chroma_qp_index_offset, 0);\n\n        // All coeffs are present\n\n        memset(h->non_zero_count[mb_xy], 16, 16);\n\n\n\n        s->current_picture.mb_type[mb_xy]= mb_type;\n\n        return 0;\n\n    }\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] <<= 1;\n\n        h->ref_count[1] <<= 1;\n\n    }\n\n\n\n    fill_caches(h, mb_type, 0);\n\n\n\n    //mb_pred\n\n    if(IS_INTRA(mb_type)){\n\n            int pred_mode;\n\n//            init_top_left_availability(h);\n\n            if(IS_INTRA4x4(mb_type)){\n\n                int i;\n\n                int di = 1;\n\n                if(dct8x8_allowed && get_bits1(&s->gb)){\n\n                    mb_type |= MB_TYPE_8x8DCT;\n\n                    di = 4;\n\n                }\n\n\n\n//                fill_intra4x4_pred_table(h);\n\n                for(i=0; i<16; i+=di){\n\n                    int mode= pred_intra_mode(h, i);\n\n\n\n                    if(!get_bits1(&s->gb)){\n\n                        const int rem_mode= get_bits(&s->gb, 3);\n\n                        mode = rem_mode + (rem_mode >= mode);\n\n                    }\n\n\n\n                    if(di==4)\n\n                        fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );\n\n                    else\n\n                        h->intra4x4_pred_mode_cache[ scan8[i] ] = mode;\n\n                }\n\n                write_back_intra_pred_mode(h);\n\n                if( check_intra4x4_pred_mode(h) < 0)\n\n                    return -1;\n\n            }else{\n\n                h->intra16x16_pred_mode= check_intra_pred_mode(h, h->intra16x16_pred_mode);\n\n                if(h->intra16x16_pred_mode < 0)\n\n                    return -1;\n\n            }\n\n\n\n            pred_mode= check_intra_pred_mode(h, get_ue_golomb(&s->gb));\n\n            if(pred_mode < 0)\n\n                return -1;\n\n            h->chroma_pred_mode= pred_mode;\n\n    }else if(partition_count==4){\n\n        int i, j, sub_partition_count[4], list, ref[2][4];\n\n\n\n        if(h->slice_type == B_TYPE){\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=13){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"B sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      b_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n            if(   IS_DIRECT(h->sub_mb_type[0]) || IS_DIRECT(h->sub_mb_type[1])\n\n               || IS_DIRECT(h->sub_mb_type[2]) || IS_DIRECT(h->sub_mb_type[3])) {\n\n                pred_direct_motion(h, &mb_type);\n\n                h->ref_cache[0][scan8[4]] =\n\n                h->ref_cache[1][scan8[4]] =\n\n                h->ref_cache[0][scan8[12]] =\n\n                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;\n\n            }\n\n        }else{\n\n            assert(h->slice_type == P_TYPE || h->slice_type == SP_TYPE); //FIXME SP correct ?\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=4){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"P sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      p_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n        }\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            int ref_count= IS_REF0(mb_type) ? 1 : h->ref_count[list];\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) continue;\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    unsigned int tmp = get_te0_golomb(&s->gb, ref_count); //FIXME init to 0 before and skip?\n\n                    if(tmp>=ref_count){\n\n                        av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", tmp);\n\n                        return -1;\n\n                    }\n\n                    ref[list][i]= tmp;\n\n                }else{\n\n                 //FIXME\n\n                    ref[list][i] = -1;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(dct8x8_allowed)\n\n            dct8x8_allowed = get_dct8x8_allowed(h);\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) {\n\n                    h->ref_cache[list][ scan8[4*i] ] = h->ref_cache[list][ scan8[4*i]+1 ];\n\n                    continue;\n\n                }\n\n                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ]=\n\n                h->ref_cache[list][ scan8[4*i]+8 ]=h->ref_cache[list][ scan8[4*i]+9 ]= ref[list][i];\n\n\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    const int sub_mb_type= h->sub_mb_type[i];\n\n                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;\n\n                    for(j=0; j<sub_partition_count[i]; j++){\n\n                        int mx, my;\n\n                        const int index= 4*i + block_width*j;\n\n                        int16_t (* mv_cache)[2]= &h->mv_cache[list][ scan8[index] ];\n\n                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        if(IS_SUB_8X8(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]=\n\n                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;\n\n                            mv_cache[ 1 ][1]=\n\n                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;\n\n                        }else if(IS_SUB_8X4(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]= mx;\n\n                            mv_cache[ 1 ][1]= my;\n\n                        }else if(IS_SUB_4X8(sub_mb_type)){\n\n                            mv_cache[ 8 ][0]= mx;\n\n                            mv_cache[ 8 ][1]= my;\n\n                        }\n\n                        mv_cache[ 0 ][0]= mx;\n\n                        mv_cache[ 0 ][1]= my;\n\n                    }\n\n                }else{\n\n                    uint32_t *p= (uint32_t *)&h->mv_cache[list][ scan8[4*i] ][0];\n\n                    p[0] = p[1]=\n\n                    p[8] = p[9]= 0;\n\n                }\n\n            }\n\n        }\n\n    }else if(IS_DIRECT(mb_type)){\n\n        pred_direct_motion(h, &mb_type);\n\n        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;\n\n    }else{\n\n        int list, mx, my, i;\n\n         //FIXME we should set ref_idx_l? to 0 if we use that later ...\n\n        if(IS_16X16(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, 0, list)){\n\n                        val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                        if(val >= h->ref_count[list]){\n\n                            av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                            return -1;\n\n                        }\n\n                    }else\n\n                        val= LIST_NOT_USED&0xFF;\n\n                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, val, 1);\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                unsigned int val;\n\n                if(IS_DIR(mb_type, 0, list)){\n\n                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my);\n\n                    mx += get_se_golomb(&s->gb);\n\n                    my += get_se_golomb(&s->gb);\n\n                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                    val= pack16to32(mx,my);\n\n                }else\n\n                    val=0;\n\n                fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, val, 4);\n\n            }\n\n        }\n\n        else if(IS_16X8(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 4);\n\n                }\n\n            }\n\n        }else{\n\n            assert(IS_8X16(mb_type));\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 4);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if(IS_INTER(mb_type))\n\n        write_back_motion(h, mb_type);\n\n\n\n    if(!IS_INTRA16x16(mb_type)){\n\n        cbp= get_ue_golomb(&s->gb);\n\n        if(cbp > 47){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"cbp too large (%u) at %d %d\\n\", cbp, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        if(IS_INTRA4x4(mb_type))\n\n            cbp= golomb_to_intra4x4_cbp[cbp];\n\n        else\n\n            cbp= golomb_to_inter_cbp[cbp];\n\n    }\n\n    h->cbp = cbp;\n\n\n\n    if(dct8x8_allowed && (cbp&15) && !IS_INTRA(mb_type)){\n\n        if(get_bits1(&s->gb))\n\n            mb_type |= MB_TYPE_8x8DCT;\n\n    }\n\n    s->current_picture.mb_type[mb_xy]= mb_type;\n\n\n\n    if(cbp || IS_INTRA16x16(mb_type)){\n\n        int i8x8, i4x4, chroma_idx;\n\n        int chroma_qp, dquant;\n\n        GetBitContext *gb= IS_INTRA(mb_type) ? h->intra_gb_ptr : h->inter_gb_ptr;\n\n        const uint8_t *scan, *scan8x8, *dc_scan;\n\n\n\n//        fill_non_zero_count_cache(h);\n\n\n\n        if(IS_INTERLACED(mb_type)){\n\n            scan8x8= s->qscale ? h->field_scan8x8_cavlc : h->field_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->field_scan : h->field_scan_q0;\n\n            dc_scan= luma_dc_field_scan;\n\n        }else{\n\n            scan8x8= s->qscale ? h->zigzag_scan8x8_cavlc : h->zigzag_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;\n\n            dc_scan= luma_dc_zigzag_scan;\n\n        }\n\n\n\n        dquant= get_se_golomb(&s->gb);\n\n\n\n        if( dquant > 25 || dquant < -26 ){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"dquant out of range (%d) at %d %d\\n\", dquant, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        s->qscale += dquant;\n\n        if(((unsigned)s->qscale) > 51){\n\n            if(s->qscale<0) s->qscale+= 52;\n\n            else            s->qscale-= 52;\n\n        }\n\n\n\n        h->chroma_qp= chroma_qp= get_chroma_qp(h->pps.chroma_qp_index_offset, s->qscale);\n\n        if(IS_INTRA16x16(mb_type)){\n\n            if( decode_residual(h, h->intra_gb_ptr, h->mb, LUMA_DC_BLOCK_INDEX, dc_scan, h->dequant4_coeff[0][s->qscale], 16) < 0){\n\n                return -1; //FIXME continue if partitioned and other return -1 too\n\n            }\n\n\n\n            assert((cbp&15) == 0 || (cbp&15) == 15);\n\n\n\n            if(cbp&15){\n\n                for(i8x8=0; i8x8<4; i8x8++){\n\n                    for(i4x4=0; i4x4<4; i4x4++){\n\n                        const int index= i4x4 + 4*i8x8;\n\n                        if( decode_residual(h, h->intra_gb_ptr, h->mb + 16*index, index, scan + 1, h->dequant4_coeff[0][s->qscale], 15) < 0 ){\n\n                            return -1;\n\n                        }\n\n                    }\n\n                }\n\n            }else{\n\n                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);\n\n            }\n\n        }else{\n\n            for(i8x8=0; i8x8<4; i8x8++){\n\n                if(cbp & (1<<i8x8)){\n\n                    if(IS_8x8DCT(mb_type)){\n\n                        DCTELEM *buf = &h->mb[64*i8x8];\n\n                        uint8_t *nnz;\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            if( decode_residual(h, gb, buf, i4x4+4*i8x8, scan8x8+16*i4x4,\n\n                                                h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 16) <0 )\n\n                                return -1;\n\n                        }\n\n                        nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                        nnz[0] += nnz[1] + nnz[8] + nnz[9];\n\n                    }else{\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            const int index= i4x4 + 4*i8x8;\n\n\n\n                            if( decode_residual(h, gb, h->mb + 16*index, index, scan, h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale], 16) <0 ){\n\n                                return -1;\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    uint8_t * const nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                    nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(cbp&0x30){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++)\n\n                if( decode_residual(h, gb, h->mb + 256 + 16*4*chroma_idx, CHROMA_DC_BLOCK_INDEX, chroma_dc_scan, NULL, 4) < 0){\n\n                    return -1;\n\n                }\n\n        }\n\n\n\n        if(cbp&0x20){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++){\n\n                const uint32_t *qmul = h->dequant4_coeff[chroma_idx+1+(IS_INTRA( mb_type ) ? 0:3)][chroma_qp];\n\n                for(i4x4=0; i4x4<4; i4x4++){\n\n                    const int index= 16 + 4*chroma_idx + i4x4;\n\n                    if( decode_residual(h, gb, h->mb + 16*index, index, scan + 1, qmul, 15) < 0){\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n            nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n        }\n\n    }else{\n\n        uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);\n\n        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n        nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n    }\n\n    s->current_picture.qscale_table[mb_xy]= s->qscale;\n\n    write_back_non_zero_count(h);\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] >>= 1;\n\n        h->ref_count[1] >>= 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23299, "substitutes": {"h": ["ih", "hhh", "hp", "hm", "e", "hand", "him", "hs", "g", "ha", "ssh", "this", "han", "d", "oh", "host", "home", "f", "t", "ah", "eh", "m", "u", "it", "kh", "hd", "her", "help", "rh", "o", "q", "uh", "H", "c", "header", "self", "sh", "hu", "ch", "hr", "b", "w", "he", "hash", "hl", "n", "zh", "gh", "history", "th", "hi", "http", "v", "bh", "z", "hw", "hist", "l", "ph", "ht", "hh", "k"], "s": ["ions", "sv", "es", "xs", "ds", "sys", "r", "os", "ssl", "ts", "cs", "us", "params", "stats", "js", "ms", "n", "S", "ns", "rs", "ins", "ures", "v", "conf", "http", "l", "this", "ss", "sb", "g", "ses", "d", "sets", "site", "as", "ages", "services", "u", "o", "sites", "sg", "ances", "c", "self", "spec", "sc", "has", "sf", "options", "scope", "su", "e", "ess", "sym", "qs", "hs", "fs", "ssh", "f", "t", "si", "b", "service", "parts", "ps", "gs", "sec", "sq", "sl", "ops", "ks", "m", "its", "args", "storage", "vs", "ls", "is", "settings", "sh", "ch", "w", "session"], "partition_count": ["partitionablecount", "partitionablesize", "partitions_type", "partitions_number", "partitionablenumber", "partitioningcount", "partitioningweight", "partition_length", "partition_size", "partitioningnumber", "partition_number", "partitioningtype", "partition_type", "partitions_map", "partitions_size", "partitions_weight", "partitions_length", "partitioninglength", "partition_map", "partitions_count", "partition_weight", "partitioningsize", "partitionableweight"], "mb_type": ["urlFtype", "mbJlist", "mbFfamily", "mbPfamily", "mn_type", "mbPparent", "urlFTYPE", "mb_spec", "mm_site", "mbFTYPE", "mbFtype", "cm_length", "mbPinfo", "mbJname", "mbPscale", "mbJtypes", "urlFid", "mm_type", "mb_scale", "mbjtype", "emb_name", "bg_scale", "mb_shape", "mbjorder", "emb_type", "url_TYPE", " MB_class", "bg_shape", "mb_types", "mb_typ", "mn_info", "mb_site", " MB_order", "mn_typ", "mb9rule", "bg_parent", "mbPtype", "mbFinfo", "mb_family", "emb_list", "mb_info", "url_id", "mb_class", "mb9type", "mn_family", "mm_class", "mbPtyp", "mb_list", "mbFtyp", "emb_types", "urlFty", "cm_type", "cm_y", " MB_name", "mb_order", "bg_type", "mbjname", "mb_parent", "mbFid", "url_type", "mbJtype", "mm_rule", "mb_name", "mb9class", " MB_type", "cm_spec", "mb_length", "mb_TYPE", "mbPshape", "mb_rule", "mb_id", "mb_ty", "mb_y", "mb9site", "mbjclass", "url_ty", "mbFty"], "cbp": ["obp", "abbpc", "abbP", "cbv", "cbpc", "rbr", "zbr", "rbp", "CBp", "bbpc", "CBP", "rbpc", "cbP", "obpc", "cbr", "abbv", "zbpy", "obP", "bbr", "rbpy", "CBv", "bbp", "zbpc", "obv", "cbpy", "zbp", "abbp", "bbpy", "CBpc"], "mb_skip_run": ["mb_skipqr", "mb_run__runs", "mb_skip__skip", "mb_skip__r", "mb_run_ran", "mb_skipJmode", "mb_run_mode", "mb_skipqrun", "mb_skip_unit", "mb_run_runs", "mb_skip_min", "mb_skip_r", "mb_skip_skip", "mb_skip_runs", "mb_skip_mode", "mb_run_r", "mb_skip__runs", "mb_skipJruns", "mb_run_run", "mb_skip__run", "mb_skip__mode", "mb_skipJrun", "mb_run__min", "mb_skipJmin", "mb_run_min", "mb_skip_in", "mb_run__run", "mb_skipqruns", "mb_run_skip", "mb_skip_ran", "mb_skip__min", "mb_run_unit", "mb_skipqskip", "mb_run__mode"], "gb": ["bc", "git", "sb", "gpu", "usb", "gram", "gal", "db", "mb", "gl", "bb", "bin", "gin", "vg", "pc", "gd", "buffer", "ga", "bg", "storage", "uv", "gy", "kb", "gg", "mm", "wb", "py", "gz", "gp", "hub", "ym", "gc", "gue", "src", "bm", "jpg", "nb", "gom", "bf", "gam", "lib", "GB", "rb", "gm"]}}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307, "substitutes": {"d": ["md", "dos", "e", "cd", "config", "g", "db", "dad", "dh", "plugin", "ds", "ld", "gd", "dn", "df", "f", "t", "u", "m", "s", "da", "dd", "ad", "data", "cmd", "p", "dict", "o", "c", "sd", "dom", "dt", "du", "b", "dc", "dm", "dl", "n", "fd", "bd", "D", "z", "dat", "l", "dp"], "address": ["target", "attribute", "config", "event", "eni", "message", "connection", "ord", "duration", "device", "order", "data", "ip", "prefix", "work", "which", "direction", "date", "alias", "email", "alpha", "pointer", "clock", "image", "output", "attr", "route", "name", "align", "code", "network", "capacity", "office", "channel", "any", "element", "pair", "position", "offset", "hello", "allow", "interface", "e", "adr", "ress", "mode", "host", "layer", "size", "p", "ace", "number", "point", "answer", "ptr", "service", "enter", "length", "reference", "resource", "x", "port", "shape", "en", "hop", "uri", "m", "entry", "index", "Address", "array", "block", "server", "each", "value"], "val": ["def", "sel", "fi", "ref", "config", "valid", "sl", "ind", "arg", "bal", "ol", "bin", "tx", "bl", "type", "f", "pos", "al", "alloc", "pre", "exec", "data", "cache", "stat", "rel", "ret", "arr", "p", "vals", "unit", "code", "var", "buf", "pr", "el", "index", "values", "aval", "byte", "cal", "mem", "x", "rule", "seq", "vol", "call", "test", "loc", "VAL", "Val", "v", "alt", "eval", "all", "block", "base", "value"], "len": ["lc", "limit", "en", "sl", "valid", "ol", "ln", "bl", "ld", "layer", "pos", "lan", "split", "size", "data", "lock", "lin", "code", "L", "el", "lim", "num", "pl", "ann", "mem", "line", "seq", "dl", "n", "length", "loc", "ll", "lon", "v", "alt", "lib", "li", "fn", "lf", "z", "l", "Len", "fin"], "can_write": ["canFwrite", " can_writing", "ban_written", "canaywrite", " can_writer", "can_written", "ban_write", "canaycontrol", "ban_edit", "canaywritten", " can_read", "canOveredit", "can_config", "can_control", " can_written", "can_edit", " can_config", "allow_write", "can2writer", "can2config", "canOverwrite", "can2write", "can_load", "canOverwritten", "can_writer", "allow_written", "allow_control", " can_load", "canFconfig", "canFwriter", "can_read", "can_writing"], "i": ["ami", "ix", "start", "ie", "fi", "qi", "zi", "ri", "ui", "eni", "mini", "gi", "uri", "chi", "ti", "I", "l", "ci", "pos", "esi", "info", "adi", "ini", "u", "it", "j", "phi", "m", "p", "ip", "id", "bi", "ani", "mi", "c", "index", "si", "dim", "ii", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "uni", "li", "pi", "x", "attr", "ni", "ori"], "end": ["port", "start", "ind", "valid", "iv", "pos", "dev", "data", "nd", "enc", "id", "code", "is", "fe", "num", "index", "byte", "loc", "Val", "sec", "rib", "all", "eval", "ended", "value"], "addr": ["route", "port", "name", "e", "asm", "ref", "adr", "config", "amp", "hop", "acl", "eni", "eth", "ack", "oa", "ord", "mode", "amd", "align", "host", "node", "device", "layer", "ea", "pos", "order", "adder", "coord", "ad", "data", "arr", "ip", "ace", "prefix", "p", "enc", "mac", "code", "dr", "index", "advert", "add", "ady", "ptr", "direction", "Address", "arm", "dc", "enter", "slice", "loc", "alt", "offset", "attr"], "r": ["ru", "e", "rd", "err", "adr", "g", "result", "region", "rr", "rf", "f", "ro", "t", "u", "m", "s", "rel", "p", "or", "rh", "o", "dr", "pr", "rn", "nr", "rc", "c", "fr", "ar", "rar", "sr", "rt", "vr", "b", "hr", "w", "rl", "re", "cr", "er", "R", "br", "mr", "rs", "range", "v", "ner", "rb", "kr", "l", "rg"], "reg": ["rol", "row", "port", "org", "ig", "conn", "err", "ref", "config", "ind", "adj", "g", "pred", "lex", "region", " Reg", "eng", "rx", "rin", "rec", "sign", "rem", "bl", "ro", "pg", "ac", "acc", "rest", "res", "rel", "stat", "leg", "ret", "mod", "fun", "rc", "tag", "num", "ann", "rule", "REG", "par", "Reg", "re", "loc", "br", "debug", "sec", "eg", "feat", "rg"]}}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309, "substitutes": {"avctx": ["avesci", "Avsci", "avectx", "afsci", "Avmedia", "Avctx", "afcontext", "afctx", "avcontext", "afmedia", "avemedia", "avmedia", "avsci", "Avcontext", "avecontext"], "s": ["ions", "sv", "es", "uns", "xs", "ds", "sys", "r", "os", "ssl", "ts", "cs", "us", "params", "js", "aws", "ms", "S", "ns", "rs", "ins", "ans", "conf", "http", "l", "ss", "this", "sb", "rows", "g", "ses", "d", "sets", "as", "ches", "services", "u", "o", "sg", "c", "self", "spec", "a", "sf", "ies", "ats", "su", "e", "sym", "qs", "hs", "fs", "lines", "ings", "f", "t", "new", "p", "si", "b", "service", "ims", "parts", "ps", "gs", "h", "sq", "sl", "ubs", "als", "your", "ops", "plugins", "ks", "m", "args", "its", "strings", "ys", "ls", "sync", "is", "settings", "session", "comments"], "length": ["off", "part", "duration", "oh", "buffer", "path", "other", "sequence", "j", "list", "url", "load", "pl", "line", "slice", "angle", "l", "type", "delay", "end", "text", "style", "sth", "lock", "code", "child", "position", "tail", "ph", "k", "section", "size", "full", "zip", "p", "number", "el", "form", "ength", "total", "th", "count", "shape", "limit", "level", "sl", "Length", "build", "id", "L", "supp", "match", "sh", "se", "seq", "len", " lengths", "block", "value"], "v": ["conv", "tv", "sv", "e", "limit", "end", "nv", "V", "lv", "iv", "g", "gu", "val", "av", "cv", "d", "vd", "qv", "f", "t", "y", "u", "r", "m", "j", "p", "uv", "vals", "vs", "vi", "code", "o", " V", "q", "c", "ver", "a", "b", "ii", "volt", "w", "vol", "n", "va", "vv", "ve", "z", "vp", "h", "ev", "l", "x", "k", "value"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ind", "iv", "ui", "eni", "pi", "gi", "uri", "ti", "I", "f", "ci", "y", "oi", "u", "ini", "info", "phi", "j", "it", "ip", "p", "abi", "id", "vi", "bi", "o", "is", "mi", "cli", "c", "mu", "index", "si", "ii", "b", "ji", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "yi", "li", "z", "api", "l", "x", "zi", "k", "ni", "ori"]}}
{"project": "FFmpeg", "commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n", "idx": 23323, "substitutes": {"s": ["i", "es", "uns", "xs", "ds", "sys", "y", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "ns", "ins", "http", "ans", "v", "ing", "l", "ss", "sb", "support", "g", "ses", "private", "d", "sets", "site", "as", "services", "u", "php", "o", "sg", "c", "self", "spec", "a", "scope", "su", "e", "sym", "qs", "fs", "ings", "f", "t", "less", "full", "p", "si", "b", "service", "ims", "sup", "side", "ps", "gs", "sq", "als", "ops", "m", "args", "its", "ls", "sync", "is", "settings", "w", "session", "comments"], "crc": ["Crs", "crs", "circ", "csrc", "acrc", "CRC", "Croc", "Crc", "cbc", "croc", "rcRC", "cRC", " circ", "rcrc", " cRC", "csroc", "acRC", "rcrs", " cbc", "Cbc", "Cdc", "cdc", "csdc", "rcirc", "acrs", " cdc", "Circ", " crs", " croc", "acirc", "csbc"], "S": ["SC", "SA", "O", "G", "V", "SI", "TS", "RS", "US", "Q", "SH", "Si", "A", "Sa", "P", "SP", "I", "CS", "DS", "IS", "SR", "N", "PS", "SS", "SE", "K", "SB", "W", "L", "H", "SN", "X", "INT", "U", "SU", "T", "WS", "F", "R", "C", "BS", "AS", "D", "M", "ST", "Socket", "OS", "Source", "B", "NS", "ss"], "bit": ["bc", "str", "step", "binary", "i", "big", "and", "ct", "hit", "hop", "character", "option", "BIT", "text", "input", "part", "g", "arg", "val", "key", "null", "bin", "token", "feature", "sign", "digit", "no", "f", "op", "ac", "it", "bug", "cat", "Bit", "lock", "ip", "version", "unit", "id", "slot", "word", "count", "component", "comment", "fix", "tag", "pin", "pass", "byte", "second", "bits", "b", "value", "set", "flag", "mask", "block", "all", "image", "offset", "x", "feat", "type"]}}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339, "substitutes": {"env": ["app", "G", "config", "event", "eni", "chal", "eye", "exc", "fg", "que", "context", "cdn", "global", "doc", "proc", "ev", "priv", "sb", "conn", "db", "oa", "style", "site", "ef", "ah", "enc", "assets", "ext", "et", "equ", "qt", "erv", "stack", "e", "eu", "esp", "ea", "exec", "init", "act", "Environment", "dt", "loader", "usr", "skin", "stage", "dat", "ec", "enh", "en", "shell", "_", "dep", "esi", "nc", "LE", "cache", "vs", "dict", "np", "kn", "py", "ctx", "viron", "console", "vm", "environment", "here"], "arg1": ["ackOne", "enc4", "inputinf", " argOne", "arg01", "askf", "aggOne", "oc2", "comp1", "mem3", "ac4", " arg81", " argone", "doc2", "locf", "arcpre", "ackinf", "exec81", "ask81", "exec2", "rec1", "argumentpart", "tagOne", "acOne", "arg4", "inputOne", "ag1", " argpre", "locinf", "argumentone", "mem2", "encinf", "gu81", "ag81", "mem1", "argument3", "docone", "arg3", "option4", "arc2", "arm81", "arcann", "errorinf", "loc81", "gu01", "loc1", "exec4", "encname", "result1", "ocul", "errorf", "argul", "oc81", "ang2", "ack1", "argann", "enc2", "ic1", "ack2", "agg81", "result81", "ocName", "recinf", "ang4", "tagname", "argname", "error81", "askinf", " arg01", "enc1", "recOne", "rec81", "compOne", "arm01", "arm1", " argann", "agginf", " arg4", " arg3", "agg1", "gu2", "ackName", "ac1", "angOne", "gu1", "encpart", "doc1", "argumentOne", "taginf", "optionann", "inputul", "ack81", "argpart", "execinf", "arg81", "ocOne", "execOne", "memOne", "compul", "input1", "argName", "comppart", "agOne", "arginf", "input81", "encOne", "error1", "argone", "docpart", "exec01", "option2", "inputpart", "ackname", "ang1", "arc1", "option81", "ask1", "ac81", " argpart", "execpart", "resultOne", "argument1", "argument2", "aginf", "argf", "argpre", "resultinf", "option1", " argName", "ocpart", "ac2", "tag1", "exec1", "argOne", "oc1", "optionpre", "arm2"], "arg2": ["enc4", "tagTwo", "tagtwo", "argument4", "argsTwo", "locto", "Arg1", "artwo", "ag2", "ag82", "arg22", "args4", "ar6", "ar4", "id1", "arg4", "Arg4", "ag1", "val4", "mem2", " arg02", "agsecond", "mem4", "arg02", "rg2", "mem1", " arg62", " argtwo", "loctwo", " argSecond", "val22", "ar2", "idsecond", "memSecond", "ang2", "Arg62", "gentwo", "idtwo", "enc2", "ArgSecond", "arg62", "tag4", "arg6", "argTwo", "ang6", "ang4", "rg4", "rg1", "loc2", "valtwo", "enc1", "argsecond", "tag82", "rg02", "enctwo", "argtwo", "id2", " arg4", "ar1", "val6", " arg5", "args02", "arsecond", "argument82", "args1", "tagless", "args2", "Argtwo", "argument6", "args5", "Arg2", "valto", "tag5", "ag62", "gen1", "id4", "argto", "tag2", "argSecond", "ang1", "gen62", "gen82", "agtwo", "argless", "tagto", " argTwo", "argument1", " arg6", "argument2", "ag4", "val2", "Arg82", "tag1", "arg5", "argument22", "gen2", "arg82", "ar22", " arg82", "gen4", "locless", "valless"], "mem_idx": ["mem_idsxc", "mem_idsxi", "mem_argld", "mem_lengthx", "mem_idxi", "mem_ginx", "mem_idex", "mem_numz", "mem_pathe", "mem_ridx", "mem_midp", "mem_Ide", "mem_ide", "mem_sidv", "mem_idg", "mem_idld", "mem_ginxp", "mem_idsx", "mem_Idex", "mem_indxp", "mem_idcent", "mem_idsp", "mem_lengthz", "mem_numx", "mem_lin1", "mem_gincent", "mem_midxc", "mem_sidg", "mem_latex", "mem_pathex", "mem_sidX", "mem_linx", "mem_ridv", "mem_Idz", "mem_catx", "mem_idv", "mem_Idg", "mem_argz", "mem_ride", "mem_midx", "mem_id1", "mem_latx", "mem_idz", "mem_midz", "mem_argces", "mem_Idcode", "mem_lengthld", "mem_ridex", "mem_linz", "mem_pathx", "mem_lengthces", "mem_sidx", "mem_linex", "mem_idp", "mem_idspe", "mem_idX", "mem_idpe", "mem_Idx", "mem_indz", "mem_idces", "mem_idcode", "mem_ginz", "mem_lat1", "mem_catxi", "mem_catpe", "mem_catz", "mem_IdX", "mem_idxp", "mem_argx", "mem_indcent", "mem_latz", "mem_idsz", "mem_numcode", "mem_indx", "mem_idxc", "mem_numv", "mem_Idv", "mem_pathv"], "tmp": ["next", "app", "vt", "amp", "config", "part", "extra", "copy", "temp", "bp", "pad", "mom", "buffer", "cp", "bg", "data", "tp", "bt", "wb", "var", "ff", "src", "br", "nb", "proc", "v", "dest", "rb", "resp", "output", "attr", "nm", "sb", "txt", "jp", "pkg", "db", "bb", "tt", "fp", "pre", "opt", "buf", "ext", "cb", "wp", "tf", "mp", "beta", "appy", "boot", "alt", "result", "meta", "fb", "img", "cmp", "zip", "p", "Temp", "vv", "sup", "req", "html", "buff", "mk", "api", "pb", "obj", "input", "cur", "tab", "cache", "storage", "diff", "np", "elt", "py", "kk", "now", "stuff", "pot", "parent", "vm", "sp"]}}
{"project": "FFmpeg", "commit_id": "289520fd97395ffd5bf933ac80487e858bc4039d", "target": 0, "func": "static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n        int v = get_bits(&s->gb, 8);\n\n        if (v == 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\");\n\n            return -1;\n\n        }\n\n        if (intra && i == 0 && v != 8) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v);\n\n            v = 8; // needed by pink.mpg / issue1046\n\n        }\n\n        matrix0[j] = v;\n\n        if (matrix1)\n\n            matrix1[j] = v;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23344, "substitutes": {"s": ["ions", "sv", "sb", "e", "bis", "qs", "space", "es", "fs", "g", "ses", "this", "xs", "sports", "your", "sets", "ops", "ks", "ds", "services", "f", "t", "u", "r", "m", "data", "ssl", "ts", "p", "cs", "us", "ls", "o", "sync", "is", "ss", "client", "c", "ctx", "js", "self", "settings", "spec", "si", "a", "b", "w", "cpp", "aws", "ms", "service", "session", "src", "ns", "S", "sf", "ps", "rs", "gs", "v", "su", "sq"], "matrix0": ["atrow5", "atrix2", "matrices0", "mathrix1", "atrix00", "matrow2", "matrow00", "mathrix2", "atrix0", "mathrix00", "matric1", "matri00", "matric2", "matract2", "mathric0", "atrow00", "matrix00", "atrix5", "matrix5", "matract5", "matric00", "matrow5", "matrices1", "matri1", "matrix2", "matresh5", "mathrix0", "mathric1", "matresh0", "matract0", "matrow0", "atrow0", "matri2", "matri0", "matresh00", "atrow2", "matrices2", "mathric2", "mathric00", "matrices00", "matric0", "matract00", "matresh2"], "matrix1": ["atrices1", "matMatrixx", "matrice0", "matrices0", "attrix0", "matrix9", "attrix1", "matrixx", "matricesx", "attrix2", "matrorI", "atrix0", "materialricI", "matric1", "atrix1", "matrice1", "matric2", "matror10", "attric0", "attric9", "matror1", "matric10", "atricesx", "atrixx", "attric1", "matx2", "matrices1", "matrices9", "matrix2", "atricesOne", "matMatrix1", "matxI", "matx1", "matricesOne", "materialric1", "matMatrixOne", "atrixOne", "matricI", "matrixI", "matror2", "materialric10", "attrix9", "matric9", "matrix10", "materialric2", "matx10", "matrices2", "materialrixI", "materialrix1", "matMatrix0", "matrixOne", "matric0", "atrices0", "matrice9", "materialrix2", "matrice2", "materialrix10", "attric2"], "intra": ["disttra", "intlo", "intras", "intbase", "utra", "constbase", "extra", "uttra", "intri", "outri", "utbase", " inttra", "outras", " intlo", "constra", " intbase", "utlo", "inttra", "distras", "distra", "outra", "constlo", "outtra", "consttra", "exttra", "extri", "distri", "extras"], "i": ["io", "ami", "e", "ix", "start", "ie", "fi", "qi", "ind", "iv", "ui", "eni", "pi", "key", "gi", "d", "uri", "ti", "I", "f", "ci", "y", "u", "oi", "m", "ini", "j", "it", "info", "ip", "p", "id", "vi", "bi", "o", "mi", "c", "index", "si", "ii", "b", "ji", "n", "iu", " j", "ai", "xi", "hi", "di", "v", "yi", "z", "li", "multi", "l", "x", "k", "ni"]}}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n", "idx": 23354, "substitutes": {"sig": [" sigs", "figs", "figh", "sigh", "Sigs", "sigs", "fig", "Sig", "Sigh", " sigh"], "status": ["str", "expr", "class", "serv", "STAT", "level", "sl", "result", "progress", "uses", "process", "temp", "ex", "fps", "s", "size", "msg", "args", "stat", "data", "ssl", "p", "current", "id", "code", "stats", "success", "active", "index", "complete", "xml", "si", "worker", "error", "sw", "wait", "atus", "server", "Status", "type"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)\n\n{\n\n    int current_offset = s->pixel_ptr - dst->data[0];\n\n    int motion_offset = current_offset + delta_y * dst->linesize[0]\n\n                       + delta_x * (1 + s->is_16bpp);\n\n    if (motion_offset < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motion_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (motion_offset > s->upper_motion_limit_offset) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\",\n\n            motion_offset, s->upper_motion_limit_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (src->data[0] == NULL) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,\n\n                                            dst->linesize[0], 8);\n\n    return 0;\n\n}\n", "idx": 23361, "substitutes": {"s": ["sv", "i", "sb", "e", "sym", "qs", "es", "sl", "fs", "g", "ses", "xs", "d", "sets", "ops", "site", "ks", "l", "ds", "services", "f", "sys", "t", "r", "u", "m", "args", "ssl", "os", "ts", "p", "cs", "us", "ls", "new", "sync", "is", "ss", "client", "c", "ctx", "self", "js", "spec", "source", "sg", "si", "sc", "aws", "service", "se", "ims", "session", "ns", "S", "n", "sf", "comments", "ps", "rs", "gs", "ins", "south", "http", "conf", "su", "sq", "states"], "src": ["conv", "sb", "sel", "support", "flash", "uc", "sl", "config", "iv", "ses", "d", "impl", "ds", "img", "sth", "gb", "secure", "r", "ssl", "cs", "ls", "sync", "ss", "rc", "ctx", "cb", "spec", "fr", "source", "sc", "sr", "b", "sur", "inst", "sup", "loc", "ins", "rs", "gs", "st", "dest", "rb", "sn", "bs", "sq", "url"], "dst": ["DST", "Dst", " dST", "adsp", "sdsth", "dsc", "dedsts", "Dsc", " drest", " dsc", "dsp", "dST", "dconst", "pdstd", "pdconst", "dedsth", "dstd", "dsts", "adST", "dedst", "rdst", " dsth", " dconst", "rdsp", "Dsp", "adst", "sdst", "adsts", "insts", "rdsc", "sdsts", "sdrest", "inst", "drest", "Dsts", "rdsts", "pdsts", "pdst", "dedrest", " dsts", "dsth", " dstd", "rdST", "instd", "inconst"], "delta_x": ["delt_l", "delta_w", "delt_xy", "delta2w", "delta_xy", "delt_y", "delt_x", "delta2xy", "delta_l", "delta2x", "delt_w", "delta2l"], "delta_y": ["delta64ye", "delta_f", "delta67y", "delta_ye", "delt_y", "delta_Y", "delt_z", "delta67x", "delta64y", "delt_x", "delta64f", "delta67ye", "delta67f", "delta_z", "delt_Y", "delta64x"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n", "idx": 23371, "substitutes": {"dev": ["md", "Dev", "priv", "reg", "cam", "def", "conn", "de", "d", "tr", "temp", "home", "device", "devices", "info", "dd", "data", "serial", "mod", "pro", "dem", "dom", "ver", "ch", "rad", "w", "dm", "prom", "test", "debug", "req", "di", "conf", "hw", "ev", "pub"], "s": ["sb", "i", "e", "sym", "qs", "es", "tests", "sl", "fs", "g", "ses", "this", "uns", "xs", "your", "d", "sets", "ops", "plugins", "ks", "l", "ds", "services", "site", "f", "sys", "t", "r", "u", "m", "args", "its", "state", "ssl", "os", "p", "ts", "cs", "vs", "ls", "o", "sync", "is", "stats", "params", "sg", "c", "js", "settings", "spec", "sq", "b", "service", "se", "ms", "session", "S", "ns", "new", "ps", "rs", "gs", "v", "conf", "su", "ss", "states"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374, "substitutes": {}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386, "substitutes": {"child": ["bc", "request", "row", "serv", "conn", "kid", "app", "g", "queue", "leaf", "cur", "build", "cl", "pc", "f", "cell", "ell", "slave", "r", "Child", "bit", "fee", "head", "cache", "p", "job", "current", "id", "q", "inner", "client", "c", "pool", "ib", "fr", "ch", "sub", "seq", "session", "desc", "ab", "feed", "root", "parent", "lib", "http", "rib", "children", "block", "server", "count"], "req": ["request", "reg", "org", "def", "query", "conn", "download", "ref", "config", "err", "queue", "rx", "crit", "rec", "rr", "repl", "qq", "cur", "required", "rf", " request", "f", "cmp", "exec", "per", "r", "cmd", "grab", "res", "rel", "compl", "job", "id", "q", "load", "ext", "client", "require", "pro", "fr", "spec", "low", "ver", "ch", "comp", "dq", "pull", "sub", "seq", "worker", "desc", "quest", "call", "reader", "rss", "gr", "sem", "proc", "http", "qt", "resource", "resp", "requ"], "offset": ["route", "delay", "phase", "start", "end", "off", "part", "origin", "uri", "layer", "transfer", "pos", "offs", "order", "absolute", "address", "entry", "size", "seed", "ace", "prefix", "slot", "url", "initial", "addr", "shift", "timeout", "operation", "tile", "header", "index", "aff", "location", "online", "alias", "error", "Offset", "length", "lower", "slice", "reference", "archive", "iso", "skip", "reset", "range", "alpha", "pointer", "aligned", "gap", "position", "inet", "padding"], "bytes": ["io", "items", "binary", "ips", "outs", "ones", "units", "net", "es", "abytes", "rows", "seconds", "lines", " errors", "locks", "ops", "hops", "flows", "pieces", "ets", "s", "size", "data", "fee", "zip", "cells", "vals", "errors", "elt", "bps", "loads", "settings", " bits", "groups", "values", "reads", "byte", "bits", "blocks", "seq", "parts", "les", "length", "steps", "len", "ns", " offsets", "boot", "Bytes", "aligned", "files", "pages", "amples", "eps", "padding", "count"], "align": ["adjust", "delay", "binary", "tail", "scale", "il", "margin", "bin", "intel", "lead", "pixel", "pal", "al", "ell", "coord", "address", "aug", "cache", "rel", "label", "balance", "work", "addr", "sync", "lap", "shift", "aff", "lace", "ext", "el", "lag", "byte", "ignment", "replace", "role", " aligned", "seq", "alias", "length", "ign", "join", "len", "shake", "batch", "border", "range", "pair", "array", "aligned", "gap", " alignment", "sort", "repeat", "format", "padding"], "qiov": ["quiov", "quiour", " qilib", "chivari", " quno", "qilib", "quilib", "qtiour", "qibl", "Qibl", "Qiov", "quivari", " qoren", "qu\u00ef", "quliv", "quiev", "qquno", "qtiev", "qoren", "chiev", "q\u00ef", "quoren", "qqiov", "quuno", "qiour", "chiov", " qilo", "qliv", " qivari", "chiour", " q\u00ef", "qtiov", " qibl", " qliv", "Qilo", "qtivari", "Qoren", "quibl", "qilo", "Qilib", "qiev", "Qliv", "qq\u00ef", "quilo", "qivari", "qqivari", "quno"], "flags": ["lbs", "types", "FL", "linux", "fs", "features", "rules", "locks", "ops", "tails", "lists", "fp", "offs", "orts", "flows", "fps", "fee", "args", "planes", "faces", "ils", "strings", "tops", "vals", "errors", "stats", "ants", "Flags", "settings", "lins", "lag", "reads", "styles", "bits", "limits", "flag", "FLAG", "fl", "mask", "fields", "utils", "options", "alls", "links", "files", "format"], "bs": ["obs", "bc", "pb", "sb", "bos", "outs", "lb", "bis", "ba", "fs", "ses", "ubs", "db", "bal", "fb", "bb", "css", "bl", "ds", "bes", "bid", "bing", "bu", "eb", "ros", "s", "bas", "ob", "os", "vs", "cs", "bn", "abi", "ls", "bi", "abc", "bps", "sync", "plug", "settings", "cb", "js", "ib", "b", "bits", "blocks", "core", "ns", "BS", "bel", "rss", "ab", "ps", "rs", "gs", "utils", "bf", "http", "bh", "bot", "block", "base", "ss", "las", "gb"], "drv": ["srv", "Drb", " drver", "rrf", "srf", "drf", "rrV", " drV", "drb", "DRf", "drV", "drvin", "irb", "rrv", "srw", "DRb", "DRvin", "irv", "grf", "irf", "Drv", "rrver", "grv", "DRv", "srb", "Drf", " drf", "drw", "DRver", "Drvin", "DRw", "grb", "DRV", "grw", "drver", "irvin"], "waited": ["waits", "awitted", "WAait", "laits", "awaiting", "paited", "awaiter", "paitted", "awaait", "Waiting", "Waited", "waused", "awaited", "paiting", "wited", "WAitted", "Waits", "waiting", "Waused", "Waitted", "awaits", "waait", "awaitted", "witted", "awiting", "witing", "laited", "laitted", "waitted", "wait", "WAiting", "paused", "WAited", "Waiter", "awited", "waiter", "laiter", "awused"], "ret": ["feat", "sat", "reg", "ut", "def", "obj", "ref", "result", "val", "ft", "det", "Ret", "mt", "art", "bit", "res", "fin", "rets", " RET", "id", "success", "rc", "out", "num", "match", "let", "RET", "rt", "flag", "reply", "rev", "re", "len", "back", "alt", "nt", "lit", "att", "fi", "resp", "fun"], "max_transfer": [" max_size", "maxallsize", " max_address", "maxftransfer", "max_import", "limitallflush", "limit_transfer", "limit_size", "maxftrans", "max_flush", "maxallflush", "maxlogtrans", " max_trans", "maxfimport", " max_import", "limit_flush", "limitalltransfer", "maxfaddress", "max_address", "limit_address", "maxfsize", "max_size", "limitalladdress", "maxlogsize", "limitallsize", "maxlogtransfer", "maxalltransfer", "maxalladdress", "maxlogaddress", "max_trans"]}}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "substitutes": {"bs": ["obs", "bc", "pb", "lc", "sb", "bos", "lb", "bis", "qs", "ba", "fs", "ses", "ubs", "db", "fb", "bytes", "bid", "bl", "bes", "css", "ds", "bing", "cas", "eb", "fps", "bas", "ob", "os", "vs", "cs", "ls", "bi", "bps", "sa", "js", "b", "bits", "ns", "BS", "iss", "ps", "gs", "http", "rb", "base", "ss", "las", "gb"], "sector_num": ["section_dom", " sector_name", "sector_begin", "block_begin", "section_num", "sectoridnom", "block_name", "sector_end", " sector_length", "block_number", "block_num", "sector_dom", "sectoriddom", "sector_nom", "sectoringnom", "sectoridend", "sectoringend", " sector_number", "section_nom", "section_end", "sector_length", "sector_name", "sectoringdom", "sector_number", "sectoridnum", "sectoringnum"], "buf": ["bc", "pb", "port", "uf", "limit", "lb", "prop", "uc", "end", "ref", "config", "text", "val", "cv", "fb", "queue", "bb", "bytes", "pad", "fp", "cas", "buffer", "gb", "path", "cmd", "data", "wb", "pool", "rc", "lim", "num", "byte", "b", "mem", "blocks", "seq", "ff", "src", "length", "fd", "len", "loc", "bd", "Buffer", "ab", "batch", "feed", "buff", "bf", "proc", "array", "bag", "vec", "rb", "block", "offset", "feat", "padding"], "nb_sectors": ["nb_segments", "nb_sections", "nb_teces", "nb_vegments", "nb_beivers", "nb_pegments", "nb_veivers", "nb_pections", "nb_vections", "nb_veces", "nb_gecs", "nb_beces", "nb_secctions", "nb_veapters", "nb_secctors", "nb_begments", "nb_teivers", "nb_gectors", "nb_tegments", "nb_serctions", "nb_tectors", "nb_vectors", "nb_sercs", "nb_seces", "nb_bectors", "nb_vecs", "nb_seivers", "nb_pectors", "nb_secs", "nb_secgments", "nb_serctors", "nb_seccs", "nb_seapters", "nb_serapters", "nb_geapters", "nb_pecs", "nb_gections"], "cb": ["lc", "bc", "pb", "sb", "cd", "lb", "config", "usb", "db", "cv", "unc", "fb", "func", "bb", "function", "fp", "buffer", "cmp", "rob", "eb", "cmd", "cp", "obb", "ob", "cf", "ctrl", "tc", "abc", "code", "wb", "c", "ctx", "CB", "cfg", "b", "cpp", "gc", "src", "callback", "buff", "conf", "rb", "fn", "cod", "cgi", "gb"], "opaque": ["OPaque", "opaques", "opec", "copc", "copaques", "ipace", "ipacity", "Opac", "ipaque", " opac", "copaque", "oppaque", "iopaques", "opc", "oppacity", "opace", "pque", "Opacity", "pacity", "iopace", "pace", " opc", "ipque", "opacity", "OPec", "OPacity", "OPac", "opac", " opacity", "Opaque", "OPc", "opque", "iopacity", "copque", "copacity", "iopaque", "paque", " opec", "oppaques", "copec", "iopque", "oppque"], "acb": ["accp", "awab", " acbs", " acv", "acv", " acbf", "ACb", "ACB", "ackfb", "acca", "akb", "ocb", "ecv", "ecb", "accbe", "ackbb", "ocbs", "accn", "ecf", "ainpl", "acB", " acp", "accab", "accv", "acab", "acfb", "ack", "ancp", "aca", "sacob", " acn", "accb", "ecbf", "ACp", " acob", "sacbs", "ecfb", " acsb", " acB", "accf", "ancob", "sacbb", "ecn", "acsb", "ecsb", "akpl", " acfb", "agk", "akbb", " acf", "acn", "acob", "anca", "accbb", "ackbf", "sacb", "ancv", "agbe", "ancpl", "ancbe", "acf", "ainb", " aca", "ancsb", "ainob", "ocbe", "akob", "accsb", "ocbb", "ancbb", "ackb", "awa", "acpl", "acbf", "ACsb", "acp", "agp", "agb", "anck", "ancb", "acbs", "awb", "ocp", "awv", "ecB", "ecp", "eca", "ainbb", "ecbe", "acbb", "ecbb", "ACbb", "ocob", "ecab", "ock", " acbb", "acbe"], "s": ["status", "e", "bis", "sl", "fs", "ses", "services", "sys", "state", "ssl", "os", "p", "cs", "ls", "is", "stats", "sa", "sg", "settings", "c", "js", "spec", "si", "b", "service", "session", "S", "ns", "iss", "ps", "rs", "gs", "http", "secondary", "su", "ss", "states"], "bh": ["ih", "hab", "pb", "sb", "hp", "hy", "hm", "lb", "ba", "bang", "acl", "ha", "db", "fb", "bb", "bp", "dh", "bl", "lr", "fp", "sth", "ah", "ht", "kh", "adh", "bg", "obb", "aph", "bt", "abi", "rh", "bi", "wb", "uh", "af", "amb", "kk", "sh", "b", "hub", "hl", "bm", "zh", "bd", "bel", "gh", "bf", "http", "h", "xb", "ph", "abb", "hh"]}}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 23405, "substitutes": {"child": ["port", "end", "kid", "kernel", "cost", "leaf", "brother", "uncle", "build", "pc", "cur", "f", "cell", "slave", "daughter", "Child", "fee", "entry", "bit", "cache", "id", "code", "inner", "sync", "cow", "client", "c", "self", "hole", "ch", "window", "sub", "feed", "root", "parent", "global", "lib", "children", "block", "baby", "count"], "sector_num": [" sector_name", "sector8count", "sector8num", "sector8name", "sector8number", " sector_count", "sector_count", " sector_number", "sector_name", "sector_number"], "nb_sectors": ["nb_sharectors", "nb_segments", "nb_sections", "nb_spections", "nb_severs", "nb_vegments", "nb_pegments", "nb_pections", "nb_secarers", "nb_seckers", "nb_secctions", "nb_sharesections", "nb_secctors", "nb_sekers", "nb_cectors", "nb_secsections", "nb_searers", "nb_vectors", "nb_sharekers", "nb_sesections", "nb_cearers", "nb_sharegments", "nb_spegments", "nb_vecs", "nb_spekers", "nb_pectors", "nb_secgments", "nb_secs", "nb_spearers", "nb_cesections", "nb_seccs", "nb_spectors", "nb_pesections", "nb_vevers", "nb_cecs", "nb_spesections", "nb_cegments", "nb_secvers", "nb_cevers"], "qiov": ["qiop", "koyer", "piov", "Qiop", "Qiov", "kfour", "chimedia", "choyer", "pnox", "ciov", "chiov", "kiov", "kimedia", "qliv", "qnox", " qliv", "chfour", " qiop", "pliv", "qimedia", "coyer", "qfour", "piop", "cfour", "Qliv", "qoyer", "cimedia", " qnox", "Qnox"], "flags": ["fc", "weights", "fs", "features", "ops", "plugins", "orts", "f", "properties", "fps", "fee", "args", "faces", "ils", "fx", "vals", "stats", "ants", "Flags", "settings", "lins", "aux", "styles", "forces", "bits", "flag", "FLAG", "fd", "friends", "mask", " Flags", "fields", "sf", "utils", "options", "lib", "lf", "files", "atts", "feat", "fun"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n", "idx": 23411, "substitutes": {"signal": [" signals", "ignals", "Signals", " signaler", "signals", " signAL", "ignaler", "SignAL", "ignal", "ignAL", "signAL", "Signal", "Signaler", "signaler"]}}
{"project": "FFmpeg", "commit_id": "b3f9f7a33337e9b64e6044b0010e2722fa0b2f9c", "target": 0, "func": "static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)\n\n{\n\n    MpegTSFilter *tss;\n\n    PESContext *pes;\n\n\n\n    /* if no pid found, then add a pid context */\n\n    pes = av_mallocz(sizeof(PESContext));\n\n    if (!pes)\n\n        return 0;\n\n    pes->ts = ts;\n\n    pes->stream = ts->stream;\n\n    pes->pid = pid;\n\n    pes->pcr_pid = pcr_pid;\n\n    pes->stream_type = stream_type;\n\n    pes->state = MPEGTS_SKIP;\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);\n\n    if (!tss) {\n\n        av_free(pes);\n\n        return 0;\n\n    }\n\n    return pes;\n\n}\n", "idx": 23425, "substitutes": {"ts": ["types", "qs", "tests", "pps", "hs", "fs", "cons", "TS", "aps", "xs", "als", "tips", "amps", "tx", "tr", "ops", "tt", "ks", "as", "pc", "ds", "flags", "uts", "t", "s", "pers", "cases", "tp", "tes", "cs", "ports", "context", "trans", "ls", "stats", "tc", "xml", "ms", "ics", "parts", "ns", "test", "points", "events", "ps", "options", "rs", "alls", "arts", "tracks", "tz", "tags", "ats", "stream", "bs", "times", "ss", "las", "acs"], "pid": ["status", "pod", "pb", "port", "period", "phase", "prop", "ping", "pet", "pe", "part", "pi", "pm", "pd", "plugin", "pc", "fp", "pipe", "pos", "po", "per", "proxy", "path", "phi", "p", "did", "ip", "id", "params", "mid", "mi", "pri", "pse", "pr", "pin", "px", "priority", "ptr", "fd", "pot", "pai", "pins", "page", "ps", "parent", "proc", "sid", "pty", "pointer", "vid", "pt", "uid", "pu", "pa", "type"], "pcr_pid": ["pcr_id", "pcr_pin", "pcre_port", "pcre_id", "pci_pa", "pcr_vid", "pcr__id", "pcr__did", "pcr_uid", "pcre_vid", "pcr_port", "pcr_pa", "pcre_pin", "pcr__pid", "pcre_did", "pcr_did", "pci_pid", "pcre_pid", "pcr__pin", "pci_id", "pci_uid"], "stream_type": ["stream_ref", "channel_level", "stream___type", "streamsname", "streamslevel", "stream_level", "stream_types", "streamtypedata", " stream_data", "stream_name", "channel_types", "stream_base", "stream___name", "streamacbase", " stream_level", " stream_ref", " stream_base", "streamtypename", "streamtypebase", "streamactype", "channel_type", "streamtypetype", "streamstypes", " stream_name", "streamacname", "stream___level", "channel_name", "stream___types", "streamstype", "streamacdata", "stream_data"], "tss": ["Tiss", "Tps", "atbs", "dsc", "toss", "atsc", "frss", "dse", "dss", " tsc", " toss", "Tss", "tmSS", "tmrss", " tSS", "trss", "foss", " trss", "atss", "Trss", "tSS", "tbs", " tbs", "fss", "tsc", "tmps", "TSS", "tmss", "dbs", " tiss", " tse", "fiss", "atse", "tps", " tps", "tse", "tiss", "Toss"], "pes": [" pulls", "docs", "ides", "es", "aps", "pe", "xs", "lex", "amps", "pc", "posts", "hes", "cases", "cs", "params", "px", "pl", "ases", "cus", "rs", "ips", "pages", "pps", "pas", "ras", "items", "fts", "oe", "ales", "ches", "projects", " copies", "ports", "ypes", "ples", "pse", "ances", "options", "files", "times", "ppa", "pa", "packs", "qs", "tests", "fs", "cons", "lines", "rules", "pex", "cas", "ves", "per", "tes", "ists", "pins", "apes", "ps", "alls", "phones", "pb", "ums", "types", "ces", "Ps", "features", "ops", "plugins", "ks", "ros", "vs", "PS", "ls", "aults", "aves", "ges", "settings", "kes", "pull", "rss", "ups", "apps", "eps"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void mpeg_motion_internal(MpegEncContext *s,\n\n                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                 int field_based, int bottom_field, int field_select,\n\n                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int dxy, uvdxy, mx, my, src_x, src_y,\n\n        uvsrc_x, uvsrc_y, v_edge_pos;\n\n    emuedge_linesize_type uvlinesize, linesize;\n\n\n\n#if 0\n\nif(s->quarter_sample)\n\n{\n\n    motion_x>>=1;\n\n    motion_y>>=1;\n\n}\n\n#endif\n\n\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    src_x = s->mb_x* 16               + (motion_x >> 1);\n\n    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);\n\n\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n\n        if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){\n\n            mx = (motion_x>>1)|(motion_x&1);\n\n            my = motion_y >>1;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        }else{\n\n            uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n\n            uvsrc_x = src_x>>1;\n\n            uvsrc_y = src_y>>1;\n\n        }\n\n    }else if(!is_mpeg12 && s->out_format == FMT_H261){//even chroma mv's are full pel in H261\n\n        mx = motion_x / 4;\n\n        my = motion_y / 4;\n\n        uvdxy = 0;\n\n        uvsrc_x = s->mb_x*8 + mx;\n\n        uvsrc_y =    mb_y*8 + my;\n\n    } else {\n\n        if(s->chroma_y_shift){\n\n            mx = motion_x / 2;\n\n            my = motion_y / 2;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        } else {\n\n            if(s->chroma_x_shift){\n\n            //Chroma422\n\n                mx = motion_x / 2;\n\n                uvdxy = ((motion_y & 1) << 1) | (mx & 1);\n\n                uvsrc_x = s->mb_x* 8           + (mx >> 1);\n\n                uvsrc_y = src_y;\n\n            } else {\n\n            //Chroma444\n\n                uvdxy = dxy;\n\n                uvsrc_x = src_x;\n\n                uvsrc_y = src_y;\n\n            }\n\n        }\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0)\n\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&1) - h , 0)){\n\n            if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n               s->codec_id == AV_CODEC_ID_MPEG1VIDEO){\n\n                av_log(s->avctx,AV_LOG_DEBUG,\n\n                        \"MPEG motion vector out of boundary (%d %d)\\n\", src_x, src_y);\n\n                return;\n\n            }\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n\n                                17, 17+field_based,\n\n                                src_x, src_y<<field_based,\n\n                                s->h_edge_pos, s->v_edge_pos);\n\n            ptr_y = s->edge_emu_buffer;\n\n            if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n                uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize;\n\n                s->vdsp.emulated_edge_mc(uvbuf ,\n\n                                    ptr_cb, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n\n                                    ptr_cr, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                ptr_cb= uvbuf;\n\n                ptr_cr= uvbuf+16;\n\n            }\n\n    }\n\n\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n\n        dest_y += s->linesize;\n\n        dest_cb+= s->uvlinesize;\n\n        dest_cr+= s->uvlinesize;\n\n    }\n\n\n\n    if(field_select){\n\n        ptr_y += s->linesize;\n\n        ptr_cb+= s->uvlinesize;\n\n        ptr_cr+= s->uvlinesize;\n\n    }\n\n\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n\n    }\n\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n\n         s->out_format == FMT_H261){\n\n        ff_h261_loop_filter(s);\n\n    }\n\n}\n", "idx": 23429, "substitutes": {"s": ["sim", "sv", "sb", "e", "ess", "sym", "qs", "es", "space", "bis", "sl", "uns", "g", "ses", "this", "hs", "fs", "sports", "d", "sets", "ops", "ks", "ds", "services", "f", "sys", "t", "m", "ssl", "strings", "p", "cs", "ts", "os", "ls", "o", "sync", "is", "stats", "ss", "sg", "c", "js", "self", "spec", "settings", "si", "w", "service", "ms", "se", "us", "n", "S", "session", "ns", "comments", "sf", "ps", "rs", "gs", "ins", "v", "conf", "secondary", "su", "sq", "support", "states"], "dest_y": ["dest_yo", "Dest_vy", "dest_vy", "dest__vy", "Dest_y", "Dest_py", "dest_py", "dest__y", "dest__yo", "Dest_yo", "dest__py"], "dest_cb": ["dest_rb", "dest_bb", "Dest_cr", "Dest_bb", "Dest_cb", "Dest_rb"], "dest_cr": ["dest_rb", "dest_rc", "src_cr", "src_rc", "src_rb", "src_rx", "dest_rx"], "field_based": ["field_derived", "file_related", "field67enabled", "fieldalgiven", "field_mode", "field64related", "fieldacbase", "field_built", "field_base", "field_given", "fieldingbased", " field_mode", "field_enabled", "fieldingbad", "fieldacbased", "field_fixed", "fieldalljoined", "file64related", "field2related", "file64bad", "fieldlebased", "field2enabled", "field_bad", " field_found", "fieldingled", " field_fixed", "FIELD_Based", " field_joined", "fieldingrelated", "field_led", "FIELD_derived", "fieldacfound", "fieldlexBased", " field_made", "field2based", "field2base", "field_related", "FIELD_built", "field_Based", "FIELD_based", "fieldlejoined", "field67fixed", "field67based", "fieldlebase", "field64based", "fieldallbased", " field_given", "fieldalbased", "fieldallmade", "field67base", "field_found", "fieldinglength", "fieldallbase", "field67related", "field_count", "fieldlexderived", "file64based", "fieldlemade", "field_made", " field_enabled", "field64bad", " field_led", "file_based", " field_related", " field_count", "file_bad", "field67given", "fieldlexbuilt", "fieldalfixed", " field_base", "fieldingcount", "fieldlexbased", " field_length", "field_length", "fieldalled", "fieldalcount", "fieldallength", "field_joined", "fieldacmode"], "bottom_field": ["fieldestfield", "field_hidden", "bottom_fields", "fieldvalfield", "field_fields", "bottom_hidden", "fieldestfields", "fieldestdepth", "field_field", "fieldvalfields", "fieldvaldepth", "field_depth", "fieldvalhidden", "fieldesthidden", "bottom_depth"], "field_select": ["field67selected", "field67loc", " field_text", "field_loc", "field_text", "field_selected", " field_selected", " field_loc", "field67text", "field67select"], "ref_picture": ["refsauto", "current_auto", "refsimage", "current_picture", "current_img", "current_image", "refspicture", "ref_img", "ref_auto", "ref_image", "refsimg"], "pix_op": ["picker_op", "picker_oper", "pix_oper", "picker_opt", "pix_opt", "pix2oper", "pix2op", "pix_ops", "pix2ops", "pix2opt", "picker_ops"], "motion_x": ["motion__ya", " motion_wx", " motion_ya", "motion36z", "motionqey", "motion67y", "motion36x", "motion_xs", "motionECxml", "motion_ey", "move_ey", "motion67x", "motion2x", "move_x", "motion_z", "motion__x", "motion_wx", "motion33x", "motionqy", "move_ya", "motion67ey", "motion33y", "motion2y", " motion_xml", "motion36wx", "motion33ya", " motion_py", "motionqtime", "motion33xy", "motionqx", "motion2z", "motionECx", " motion_xy", " motion_xx", "move_time", " motion_z", "motion_xx", "motionECya", "move_xy", "motion_time", " motion_xs", "motion36y", "motion_xy", "motion67time", "motion_ya", "motion_py", "move_y", "motion_xml", "motion__y", "motionECy", "motion2wx", "motion__xml"], "motion_y": ["scene_ery", "motion__ya", "motion_oy", " motion_ya", "motionJx", "music_y", "scene_y", "motion___vy", "motionTimey", "motionJery", "motionJvy", "motion_z", "motion__x", " motion_zy", " motion_vy", "motionJz", "motion__vy", "motion_ye", "motionNx", " motion_on", "motionTimex", "video_y", "scene_z", "sceneJery", "motionNoy", "video_z", "motion_vy", "motionJzy", "motionTimez", "video_yan", "motion_ery", "scene_vy", "motionTimeyan", "music_vy", "motion_on", "sceneJz", "music_yy", "motion___y", " motion_z", "sceneJy", " motion_oy", "motionNon", "music_ye", "motion_yan", "motionNz", "motionNzy", "motion_ya", "sceneJvy", "motion_yy", "motionJoy", "motion___z", "motion_zy", "motion__y", "video_x", "motionJy", "motion___ery", "motionNy"], "h": ["i", "hm", "e", "hs", "g", "oh", "f", "y", "t", "u", "m", "p", "o", "q", "H", "c", "sh", "ch", "b", "w", "hi", "z", "v", "bh", "l", "ph", "k"], "is_mpeg12": ["is_video13", "is_peg6", "isMvideo11", "isMmpeg6", "is_video12", "isMvideo13", "is_peg13", "isMmpeg11", "is_cpp13", "is_mpeg6", "is_mpeg22", "is_cpp11", "isMmpeg12", "is_mpeg13", "is_mp12", "is_mp6", "is_cpp12", "isMmpeg13", "is_peg12", "isMvideo12", "is_peg22", "is_mpeg11", "is_cpp22", "is_mp11", "is_mp22", "is_video11", "is_video6", "isMvideo6", "is_peg11", "is_mp13"], "mb_y": ["mb_ry", "mb05z", "mb05vy", "ghost_ry", "ghost_vy", "mb05x", "mp_x", "mb_z", "mb33y", "mb_yy", "mb_sy", "mp_z", "mb33yy", "mp_sy", "ghost_y", "mb_vy", "mb_x", "ghost_yy", "mb33vy", "mp_y", "mb05y", "mp_vy", "mb33ry"], "ptr_y": ["ptramevy", "dest_vy", "ptr_wy", "dest_ya", "ptrameya", "ptr_ya", "ptramey", "dest_wy", "ptramewy", "ptr_vy"], "ptr_cb": ["ptr__cb", "dest_fb", "dest_rb", "ptr__b", "ptr__fb", "ptr__rb", "ptr_fb", "ptr_b", "dest_b", "ptr_rb"], "ptr_cr": ["ptr__cb", "dest_rb", "ptr__rb", "ptr__cr", "ptr_lr", "ptr__lr", "ptr_rb", "dest_lr"], "dxy": ["pdgb", "dlbit", "Dpy", "odxy", "odcoord", " ddy", "dlval", "dcoord", "dxp", "dlgb", "dhxy", "oddy", "Dcoord", "dbit", "dgb", "odxp", " dgb", " dval", "dhdy", "bdpx", " dpy", "dlxy", "dpx", "ddy", " dxp", " dpx", "Dpx", "bdpy", "bdcoord", "dhxp", "bdxy", "dhcoord", " dbit", "pdval", "pdbit", "dval", "pdxy", "dpy", " dcoord", "Dxy"], "uvdxy": ["uvndxy", "uvdhxy", "uvdloxy", "ufdxp", "uvdcquad", "ufdlxy", "uvdhxxx", "tvdphy", "ufdxy", "ufdzx", "uvndoxy", "uvdcphy", "uvndquad", "uvdsXY", "ufdcoord", "uvlcoord", "uvdsxy", "uvdxxx", "tvndxy", "uvfzx", "uvdcoord", "uvdlphy", "uvdzx", "uvlxp", "tvdquad", "uvdquad", "uzdxy", "uzdsphy", "uvdlxp", "uvdsphy", "tvndquad", "uvdXY", "ufdlcoord", "ufdlxp", "uzdsxxx", "uvfxp", "uzdsXY", "uvdoxy", "uzdXY", "uvlzx", "tvdxy", "uvdcxy", "uvdsxxx", "uzdxxx", "uvfxy", "tvndoxy", "tvndphy", "uvdlquad", "uvndphy", "uvdxp", "uvdlzx", "uvdlcoord", "uvdlxy", "ufdlzx", "uvdphy", "uvlxy", "uvfcoord", "uvdhXY", "tvdoxy", "uvdcoxy", "uzdsxy", "uvdhphy", "uzdphy"], "mx": ["md", "wm", "mus", "hop", "ml", "me", "xy", "cm", "mag", "rx", "tx", "mn", "mis", "pm", "mor", "mic", "km", "m", "mc", "axy", "mod", "yx", "np", "mm", "zx", "mi", "py", "memory", "px", "xml", "module", "mp", "wy", "mem", "ms", "dm", "ym", "mes", "loc", "mr", "Mi", "wx", "vm", "mos", "x", "nz", "MX"], "my": ["md", "ami", " mine", "ix", "mini", "mph", "med", "me", "meta", "mag", "your", "pm", "mor", "time", "mis", "by", "mic", "y", "ey", "m", "MY", "mc", "gy", "mm", "zx", "mys", "mid", "mi", "py", "ng", "am", "body", "self", "module", "mem", "make", "ms", "ym", "cy", "any", "test", "maybe", "mr", "Mi", "wx", "ma", "My", "some", "mos", "x", "where", "mn", "mmm"], "src_x": ["srcJy", "srcalx", "src_xs", "srcalxs", "srcaly", "srcJxs", "srcJx", "source_h", "g", "_", "bytes", "src_X", "img", "mpeg", "pos", "srcJX", " src_X", "src_h", " src_xs", "srcalh", "src", "source_y", "source_xs", "url", "source_x"], "src_y": ["source_dy", "source_py", "src_py", "src_dy", " src_yt", "src_yt", "src_i", "source_y", " src_i", "source_x"], "uvsrc_x": ["uvsrc_ix", "uvrc_xy", "uvrc_h", "uvsrc_h", "uvsrc_yl", "uvsrcJy", "uvrc_x", "uvsrcJx", "uvsrc_xy", "uvsrc_px", "uvsrcJix", "uvsrc_w", "uvsrc_id", "uvsrcJyl", "uvrc_px"], "uvsrc_y": ["uvsrcJdy", "uvsource_dy", "uvrc_asy", "uvrc_z", "uvrc_y", "uvsource_x", "uvsrc_vy", "uvsrc_dy", "uvsource_y", "uvrc_x", "uvsrcJx", "uvsrc_z", "uvsrcJvy", "uvsrc_asy", "uvsource_vy", "uvsrcJy"], "v_edge_pos": ["v_ge_position", "v_ge_loc", "v_ge_val", "v_edge_size", "v_line_size", "v_edge2position", "v_ge__val", "v_edge_position", "v_line_type", "v_pe_position", "v_edge_type", "v_pe_neg", "v_line_position", "v_edge__pos", "v_edge__type", "v_edge2neg", "v_edge__loc", "v_ge__pos", "v_ge__loc", "v_edge\u00b7neg", "v_line_pos", "v_edge2os", "v_edge_loc", "v_edge_val", "v_edge__val", "v_ge__position", "v_pe_os", "v_edge_os", "v_edge_neg", "v_pe_pos", "v_edge2pos", "v_edge\u00b7pos", "v_edge\u00b7os", "v_ge_pos", "v_edge\u00b7position", "v_edge__position", "v_edge__size"], "uvlinesize": ["uvipsize", "uvmailsization", "uvipsizer", "uvlinksization", "uvlinksizer", "uvnsize", "evlinesense", "uvnsizer", "uvlinesization", "uvnsense", "uvlinesizing", "uvpinsize", "uvlinksense", "uvmailsizing", "uvnsization", "uvpinsiz", "uvmailsiz", "uvlinksize", "uvlinesiz", "uvmailsize", "evlinesize", "uvlinesizer", "uvpinsizing", "evnsize", "uvipsization", "uvlinesense", "uvipsense", "evlinesizer", "uvpinsization", "evlinesization", "evnsense", "evnsization", "evnsizer"], "linesize": [" Linesiz", "passization", "passize", "linesIZE", "linsize", " linesizing", "linksization", " linesization", "vertsization", "linessize", "linesizing", "codesizer", "linesizer", "codesiz", " Linesization", "passsize", " linesIZE", "vertsizer", "linssize", "codesize", "codesization", "vertssize", "linesiz", "linesization", "passizer", "pinsizing", "linsIZE", " Linesizer", " linessize", " linesiz", " Linesize", " linesizer", "pinsization", "pinsiz", "codesizing", "linsization", "pinsize", "linksIZE", "vertsize", "linksize", "linkssize"]}}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n", "idx": 23455, "substitutes": {"cpu": ["lc", "platform", "computer", "gpu", "linux", "config", "GPU", "eni", "progress", "fork", "processor", "process", "pc", "CPU", "node", "css", "cmp", "nc", "cp", "cat", "cache", "component", "uno", "uci", "np", "mac", "cli", "sync", "cn", "roc", "gp", "ocr", "cpp", "gc", "core", "chip", "pai", "console", "android", "prem", "proc", "vm", "clock", "pu"], "config_change": [" config_add", "config_code", "configpreChange", "configpreplace", " config_Change", "configureadd", "configurechange", "configprereplace", " config_remove", "config_add", " config_update", " config_changed", "config_Change", "configpupdate", " config_replace", "config_update", "configpchange", "configureupdate", "configpreupdate", "config_changed", " config_code", "config_replace", "config_remove", "configpChange", "configprechange", "configureremove"], "token": ["platform", "icon", "port", "binary", "target", "password", "chain", "key", "Token", "processor", "temp", "function", "device", "buffer", "path", "KEN", "socket", "data", "lock", "or", "tick", "serial", "number", "prefix", "code", "context", "timeout", "tool", "settings", "module", "tag", "random", "oken", "byte", "wt", "service", "channel", "session", "secret", "console", "callback", "tty", "reset", "template", "user", "resource", "scope", "type"]}}
{"project": "FFmpeg", "commit_id": "dde0af2df1caffb9e33855c08fc691dbbbbc72b3", "target": 0, "func": "static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)\n\n{\n\n    int i;\n\n    static const uint8_t LUT[256] = {\n\n        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n    };\n\n\n\n    /* Read all the lengths in first */\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* At most we need to read 9 bits total to get indices up to 8 */\n\n        int val = show_bits(gb, 8);\n\n\n\n        // read reverse unary\n\n        if (val) {\n\n            val = LUT[val];\n\n            skip_bits(gb, val + 1);\n\n            ctx->len[i] = val;\n\n        } else {\n\n            skip_bits(gb, 8);\n\n            if (!get_bits1(gb))\n\n                return -1;\n\n            ctx->len[i] = 8;\n\n        }\n\n    }\n\n\n\n    /* For any values that have length 0 */\n\n    memset(ctx->val, 0, ctx->size);\n\n\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* Check we have enough bits left */\n\n        if (get_bits_left(gb) < ctx->len[i])\n\n            return -1;\n\n\n\n        /* get_bits can't take a length of 0 */\n\n        if (ctx->len[i])\n\n            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23465, "substitutes": {"ctx": ["conv", "lc", "grad", "txt", "cc", "ux", "conn", "sci", "obj", "jp", "pkg", "cv", "tx", "ca", "cas", "ci", "cmp", "cp", " cx", "xc", "ctrl", "kb", "context", "tc", "rc", "cb", "gc", "loc", "voc"], "gb": ["lc", "git", "bc", "grad", "txt", "cc", "gpu", "gt", "gl", "gin", "gd", "alloc", "bg", "mc", "kb", "tc", "rc", "gp", "sc", "gc", "bm", "loc", "cca", "gs", "lib", "rb", "hw", "pt", "fi"], "i": ["io", "e", "d", "I", "f", "ci", "ion", "r", "it", "j", "data", "or", "p", "id", "is", "c", "a", "b", "ii", " I", "n", "v", "h", "l", "fi", "k"], "LUT": ["XST", "XUT", "ZMT", "XTE", "ZTE", "XMT", "LST", "ZUT", "LTE", "DLMT", "DLST", "DLUT", "ZST", "LMT", "DLTE"]}}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n\n                const AVIOInterruptCB *int_cb)\n\n{\n\n    URLProtocol *up = NULL;\n\n    char proto_str[128], proto_nested[128], *ptr;\n\n    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n\n\n\n    if (filename[proto_len] != ':' || is_dos_path(filename))\n\n        strcpy(proto_str, \"file\");\n\n    else\n\n        av_strlcpy(proto_str, filename,\n\n                   FFMIN(proto_len + 1, sizeof(proto_str)));\n\n\n\n    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n\n    if ((ptr = strchr(proto_nested, '+')))\n\n        *ptr = '\\0';\n\n\n\n    while (up = ffurl_protocol_next(up)) {\n\n        if (!strcmp(proto_str, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n\n            !strcmp(proto_nested, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n    }\n\n    *puc = NULL;\n\n    return AVERROR_PROTOCOL_NOT_FOUND;\n\n}\n", "idx": 23470, "substitutes": {"puc": ["Prc", "preunc", "paucc", " punc", " pou", "Punc", "cbc", "pou", "pc", "jpc", "pauc", "Pauc", " prc", "Puc", "cauc", "mpuc", "jpucc", "punc", "preucc", "PUC", "mpUC", "apcu", "Pucc", " pc", "cuc", " pauc", "jpou", "apbc", "pbc", "pcu", "Pcu", "preuc", " pUC", " pbc", "pucc", "jpuc", "pac", " pucc", "prc", "apauc", "ccu", "apuc", "preauc", "mpbc", "mprc", "pUC", "paou", "Pbc"], "filename": ["name", "txt", "binary", "password", "download", "lp", "il", "text", "message", "unc", "utf", "file", "metadata", "phrase", "uri", "json", "l", "fp", "buffer", "path", "nl", "f", "sequence", "size", "nil", "setup", "kl", "prefix", "subject", "directory", "which", "word", "kn", "title", "source", "document", "ename", "rl", "vr", "loader", "location", "seq", "lvl", "provided", "length", "src", "slice", "fd", "sf", "dll", "unknown", "eger", "tty", "fil", "fn", "username", "files", "whatever", "wl", "Filename", "url"], "flags": ["types", "fts", "ints", "fixes", "fs", "features", "lines", "rules", "utf", "bytes", "ops", "dates", "flows", "offs", "fp", "nl", "f", "properties", "ids", "fps", "planes", "args", "s", "ils", "fee", "faces", "strings", "codes", "vals", "ls", "ports", "stats", "buf", "Flags", "settings", "groups", "lag", "frames", "reads", "bits", "flag", "FLAG", "parts", "fl", "length", "fd", "len", "fields", "utils", "options", "ps", "lf", "links", "tags", "files", "atts"], "int_cb": ["int2callback", "intallcb", " int2cb", "intflowrb", "int_gb", "int2fun", "int2cb", "int_cod", "intallcod", "int_nob", "int1cf", " int_rb", " int2cod", "int_bc", " int_bc", "int1rb", "int_fun", "intingfun", " int2callback", " int_cf", "intflowcb", "int_callback", "intflownob", " int_cod", " int_nob", "intallfun", " int_fun", " int2fun", "int_cf", "intflowgb", "int_rb", " int_gb", "int2cod", " int_callback", "intingcod", "intingcallback", "int1bc", "int1cb", "intingcb", "intallcallback"], "up": ["upp", "view", "ra", "name", "uf", "uc", "omp", "own", "ap", "lp", "amp", "ahead", "menu", "inc", "pkg", "ack", "file", "rup", "down", "home", "f", "cmp", "po", "one", "pre", "u", "ac", "op", "uph", "UP", "new", "p", "setup", "ip", "point", "cup", "Up", "upload", "out", "pr", "pl", "plus", "ch", "comp", "now", "loader", "line", "upt", "imp", "call", "upper", "flow", "ups", "ame", "ps", "update", "back", "parent", "ump", "user", "vp", "instance", "api", "pt", "upe", "image", "um", "cap"], "proto_str": ["proto__Str", "proto_obj", "proto__seq", "proto_enc", "proto\u00b7doc", "proto__arr", "propos_string", "propo_st", "probo_str", "propos_part", "proto_st", "proto_arr", "proto_pos", "proto_Str", "probo_st", "profrom_seq", "proto__enc", "proto_name", "profrom_str", "propo_res", "proto_string", "profrom_name", "proto_doc", "proto\u00b7Str", "propos_req", "proto\u00b7obj", "proto_seq", "proto\u00b7pos", "proto\u00b7arr", "propos_str", "propo_obj", "probo_Str", "profrom_arr", "probo_string", "proto__name", "proto\u00b7str", "propo_str", "proto__pos", "propo_Str", "proto\u00b7enc", "propo_doc", "proto_part", "proto_res", "proto_req", "proto__str", "propo_arr"], "proto_nested": ["proto_gnored", "proto_notest", "proto_inotted", "proto_ngested", "proto2gnured", "proto_notamed", "proto_inest", "proto2gnored", "proto__sested", "proto_adjored", "proto\u00b7nesting", "proto2nesting", "proto_nsested", "proto_nsesting", "proto\u00b7notted", "proto\u00b7inested", "proto_inested", "proto\u00b7inotted", "proto_Nesting", "proto_adjured", "proto_named", "proto_nsest", "proto2nored", "proto2gnesting", "proto2nested", "proto_ngerved", "proto_Notted", "proto\u00b7inest", "proto\u00b7inesting", "proto_Nest", "proto\u00b7nest", "proto_notted", "proto__nested", "proto_nsamed", "proto__sest", "proto_sested", "proto2gnested", "proto_ngamed", "proto_Nerved", "proto_sesting", "proto_gnesting", "proto_Nested", "proto__nesting", "proto_gnested", "proto__named", "proto_adjested", "proto_nesting", "proto_sest", "proto_Named", "proto_nest", "proto_nored", "proto__sesting", "proto_adjesting", "proto_nured", "proto__samed", "proto_ngesting", "proto__nest", "proto_ngest", "proto\u00b7nested", "proto_gnured", "proto_notested", "proto_inesting", "proto_notesting", "proto2nured", "proto_nerved", "proto_samed"], "ptr": ["str", "port", "stack", "name", "sym", "obj", "ref", "adr", "push", "ctr", "eth", "tr", "pad", "fp", "buffer", "pos", "cmp", "pre", "pointers", "rel", "code", "addr", "buf", "ext", "dr", "pr", "fr", "xp", "vr", "seq", "length", "src", "inst", "len", "loc", "br", "fd", "trace", "Ptr", "buff", "pair", "pointer", "sp", "lf", "pt", "offset", "attr"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n", "idx": 23491, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "lb", "bis", "qs", "ba", "obj", "fs", "ses", "ubs", "xs", "fb", "boxes", "bb", "ks", "bid", "ds", "bes", "bl", "bp", "bas", "state", "ob", "os", "vs", "cs", "ts", "us", "ls", "abc", "bi", "bps", "sa", "js", "b", "blocks", "ns", "BS", "iss", "ab", "ps", "rs", "gs", "ins", "banks", "ss", "gb"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495, "substitutes": {"opaque": ["OPaque", "ochole", "opaques", "OPque", "phole", "OPaques", "opatile", "ipaques", "ipaque", " opaques", "ocaques", "obaques", " opatile", "ophole", "obque", "patile", "obaque", "ipque", "opacity", "ocatile", "OPacity", "ocaque", "paques", "obacity", "opque", "paque", "ipacity", " ophole"], "addr": ["rol", "ocol", "port", "asm", "ref", "adr", "config", "prot", "part", "aud", "mode", "ord", "afi", "pad", "host", "pc", "align", "pos", "cmd", "address", "ad", "data", "p", "ace", "point", "code", "mac", "slot", "buf", "dr", "rc", "cb", "frame", " address", "ptr", "ada", "seq", "src", "len", "sid", "pointer", "tz", "offset"], "val": ["ival", "reg", "sel", "def", "serv", "fail", "ref", "sl", "valid", "ind", "vt", "part", "xxx", "tx", "bl", "buffer", "pos", "exec", "al", "pre", "data", "stat", "state", "ret", "p", "enc", "vals", "slot", "buf", "rot", "el", "index", "pid", "b", "vol", "len", "loc", "VAL", "base", "Val", "v", "eval", "block", "pt", "lit", "x", "prop", "value"], "size": ["str", " bytes", "Size", "bytes", "address", "fee", "data", "args", "unit", "mem", "value", "length", " length", "len", "SIZE", "eval", "padding", "type"], "s": ["ions", "i", "sb", "ips", "e", "sym", "qs", "es", "sl", "uns", "g", "ses", "an", "private", "d", "sets", "ops", "as", "ks", "ds", "services", "f", "sys", "t", "r", "u", "m", "its", "ssl", "os", "p", "ts", "cs", "us", "o", "ls", "sync", "is", "sg", "c", "js", "settings", "opens", "ows", "si", "a", "b", "w", "service", "se", "session", "S", "n", "ns", "ps", "rs", "gs", "south", "v", "grades", "secondary", "scope", "server", "l", "x", "ss", "states"]}}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n", "idx": 23504, "substitutes": {"cs": ["lc", "ras", "cc", "sk", "fs", "cons", "ks", "pc", "css", "ds", "cas", "CS", "sys", "cp", "s", "ys", "cf", "ls", "rc", "c", "ctx", "cn", "spec", "sc", "cks", "ics", "cr", "ns", "cus", "ps", "rs", "acks", "ce", "ec", "ck", "ss", "k", "acs"], "run": ["rol", "reg", "row", "view", "runs", "name", "un", "ru", "config", "ur", "none", "con", "process", "build", "get", "node", "product", "model", "ro", "win", "Run", "exec", "r", "kin", "use", "rain", "ram", "head", "pos", "man", "play", "job", "unit", "runner", "work", "sync", "scan", "load", "rc", "module", "cn", "add", "pass", "create", "ran", "read", "re", "cr", "call", "session", "flow", "running", "clean", "update", "boot", "resource", "block", "image", "record", "output", "fun"], "cpu": ["lc", "platform", "bench", "bc", "computer", "net", "lb", "gpu", "conn", "linux", "config", "GPU", "eni", "performance", "progress", "cm", "consumer", "CU", "processor", "piece", "pc", "CPU", "node", "product", "css", "cmp", "lan", "nc", "kin", "cp", "phy", "gru", "login", "cache", "lu", "program", "component", "mc", "setup", "runner", "que", "np", "uno", "cli", "cf", "sync", "cow", "c", "load", "cn", "roc", "gp", "cal", "uca", "loader", "PU", "python", "core", "gc", "auc", "chip", "prem", "boot", "proc", "vm", " CPU", "hw", "ck", "clock", "nu", "pu"], "switched_level": ["swipped_line", "switchedensize", "switchedingvel", "switching_level", "swipped_vel", "switchedingsize", "switching_lock", "switchedinglevel", "switchinglevel", "switched_value", "switched_lvl", "swipped_layer", "switched_info", "switch_info", "switchedlexlevel", "switched_levels", "switchingmessage", "switched_wall", "switched_lock", "swipped_level", "switching_vel", "switch_message", "switchedlexsize", "switchedinginfo", "switchingsize", "switching_value", "swipped_lvl", "switch_level", "switchedlexinfo", "switched_size", "switched_line", "switchedinglevels", "switched_vel", "switchedenmessage", "switchedenlevel", "switchedablelevel", "switching_layer", "switchedablelayer", "switched_layer", "switchedeninfo", "switching_levels", "switchedablewall", "switched_message", "switch_size", "switching_wall", "switchedlexmessage", "switchinginfo", "switchedingmessage"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_trailer(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int res = 0;\n\n    int i, j, n, nb_frames;\n\n    int64_t file_size;\n\n\n\n    if (pb->seekable) {\n\n        if (avi->riff_id == 1) {\n\n            ff_end_tag(pb, avi->movi_list);\n\n            res = avi_write_idx1(s);\n\n            ff_end_tag(pb, avi->riff_start);\n\n        } else {\n\n            avi_write_ix(s);\n\n            ff_end_tag(pb, avi->movi_list);\n\n            ff_end_tag(pb, avi->riff_start);\n\n\n\n            file_size = avio_tell(pb);\n\n            avio_seek(pb, avi->odml_list - 8, SEEK_SET);\n\n            ffio_wfourcc(pb, \"LIST\"); /* Making this AVI OpenDML one */\n\n            avio_skip(pb, 16);\n\n\n\n            for (n = nb_frames = 0; n < s->nb_streams; n++) {\n\n                AVCodecParameters *par = s->streams[n]->codecpar;\n\n                AVIStream *avist       = s->streams[n]->priv_data;\n\n\n\n                if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                    if (nb_frames < avist->packet_count)\n\n                        nb_frames = avist->packet_count;\n\n                } else {\n\n                    if (par->codec_id == AV_CODEC_ID_MP2 ||\n\n                        par->codec_id == AV_CODEC_ID_MP3)\n\n                        nb_frames += avist->packet_count;\n\n                }\n\n            }\n\n            avio_wl32(pb, nb_frames);\n\n            avio_seek(pb, file_size, SEEK_SET);\n\n\n\n            avi_write_counters(s, avi->riff_id);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVIStream *avist = s->streams[i]->priv_data;\n\n        for (j = 0; j < avist->indexes.ents_allocated / AVI_INDEX_CLUSTER_SIZE; j++)\n\n            av_free(avist->indexes.cluster[j]);\n\n        av_freep(&avist->indexes.cluster);\n\n        avist->indexes.ents_allocated = avist->indexes.entry = 0;\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 23508, "substitutes": {"s": ["bc", "sv", "ions", "bis", "es", "xs", "ds", "sys", "ssl", "os", "ts", "cs", "us", "params", "js", "small", "aus", "aws", "S", "ns", "slice", "ins", "v", "rb", "l", "ss", "sim", "request", "sb", "g", "ses", "sets", "services", "sites", "sg", "c", "cb", "spec", "wp", "sc", "a", "sf", "su", "e", "sym", "qs", "tests", "sie", "hs", "fs", "sis", "f", "t", "series", "p", "si", "b", "service", "sup", "photos", "ps", "gs", "h", "api", "sq", "types", "sci", "sl", "ops", "plugins", "ks", "m", "its", "vs", "ls", "sync", "is", "sa", "settings", "single", "session", "comments", "parser", "bs"], "avi": ["ami", "anti", "cam", "nav", "imi", "fi", "bis", "vim", "iv", "ui", "eni", "av", "mini", "aci", "afi", "umi", "abo", "picture", "oi", "adi", "ini", "omi", "data", "abi", "asu", "voice", "pic", "vi", "bi", "ani", "mi", "sa", "aj", "music", "audio", "si", "mp", "ati", "ii", "wikipedia", "fm", "media", "ai", "pai", "aa", "liv", "xi", "archive", "ave", "di", "multi", "audi", "vp", "sn", "image", "photo", "pi", "api", "opus", "video"], "pb": ["lc", "bc", "platform", "sb", "fc", "summary", "bos", "lb", "uc", "jp", "lp", "prot", "ses", "db", "pkg", "fb", "pm", "pit", "bb", "phrase", "plugins", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "posts", "PB", "um", "aph", "tp", "p", "kb", "wb", "bps", "py", "cb", "ctx", "pl", "ib", "wp", "mp", "b", "ub", "cpp", "tmp", "hub", "fm", "alist", "bm", "pai", "parser", "nb", "ab", "proc", "bf", "bh", "bs", "vp", "rb", "dp", "xb", "typ", "api", "ppa", "abb", "pa"], "i": ["ix", "start", "ik", "ie", "e", "qi", "fi", "ind", "ri", "ui", "eni", "ki", "gi", "d", "uri", "ti", "I", "f", "ci", "y", "u", "r", "m", "ini", "oi", "init", "p", "ip", "id", "o", "ani", "mi", "si", "b", "ii", "in", "iu", "ai", "xi", "di", "v", "yi", "z", "li", "im", "pi", "x", "ni", "ori"], "j": ["ja", "jit", "syn", "oj", "e", "un", "jl", "obj", "jp", "ind", "adj", "g", "ui", "key", "d", "f", "pos", "jj", "dj", "y", "r", "uj", "m", "kj", "it", "jet", "p", "ip", "job", "o", "q", "c", "js", "index", "aj", "fr", "el", "J", "b", "ii", "ji", "x", "ij", "fl", "br", "jc", "v", "z", "li", "note", "h", "jo", "l", "bj", "k", "ni"], "n": ["span", "net", "syn", "name", "un", "e", "en", "conn", "yn", "adj", "nn", "g", "an", "coll", "d", "ny", "mn", "not", "node", "f", "y", "t", "N", "r", "m", "u", "nc", "init", "p", "na", "current", "o", "ng", "c", "el", "num", "nw", "b", "a", "w", "min", "ns", "nb", "z", "ner", "v", "nt", "sn", "nor", "fn", "nu", "l", "x", "pn", "ne", "k", "ni"], "nb_frames": ["nb00flows", "nbxframes", "nbIPflows", "nbJlines", "nn_views", "nn67frames", "nbxsteps", "nbIPfeatures", "nb48faces", "nb_images", "nbxvideos", "num_faces", "nb_flows", "nbJfeatures", "nb_videos", "num_images", "split_features", "nb_faces", "nn67features", "nb_fram", "nn67views", "num_videos", "split_bits", "nn_lines", "nb_features", "split_frames", "nb33features", "num_frame", "nb48frames", "nb67features", "nb33lines", "nb00frames", "nb_bits", "nbJviews", "nn67lines", "nb67frames", "num_fps", "nbwframe", "num_frames", "nb00planes", "nb_fps", "nb00fps", "nbXsteps", "nb00bits", "split00bits", "nbIPframes", "nbxcycles", "nbxflows", "nb48features", "nn_features", "split_flows", "nb00images", "nbXcycles", "nb67planes", "split00features", "num_cycles", "nbwfram", "nbJframes", "num_planes", "nb_steps", "nn_frames", "num_features", "nb00features", "num_fram", "nbxfaces", "nbXflows", "nb67fps", "num_flows", "split00flows", "nb67lines", "nb67views", "nb33frames", "nb_views", "nbwframes", "nb_lines", "nbxfram", "num_steps", "nb33views", "nbxfeatures", "nbXframes", "nbwvideos", "split00frames", "nb48flows", "nbxframe", "nbIPbits", "nb_planes", "nb_frame", "nb67images", "nb_cycles"], "file_size": ["filexsize", "file2size", "zip_scale", " file_offset", "cache64time", "file6count", "cache_count", "file64time", "file2offset", "filexname", "cache_source", "file2name", "file64size", "cache_size", "file64source", "file_length", "cache64size", "file6size", "file_count", "zip_length", "file_scale", "zip_timeout", "cache64source", "file6source", "zip_size", "cache64count", "cache_time", "filexoffset", "file_source", "file64count", "file_timeout", "file_time", "file_offset", "file_name", " file_name", "file6time"], "par": ["pas", "like", "medi", "serv", "app", "har", "part", "pe", "mar", "parse", "ca", "cop", "prep", "pc", "as", "pie", "pal", "dep", "po", "per", "particip", "pre", "war", "pp", "p", "oper", "params", "star", "var", "py", "la", "pr", "pro", "ar", "mp", "pass", "pard", "comp", "Par", "aa", "pol", "cap", "ps", "car", "proc", "sp", "param", "arin", "ph", "pa", "capt"], "avist": ["avinst", "evist", "avIST", "avirst", "ajistent", "evism", " avistent", "avert", " avisted", "appIST", " avast", "varistent", "ajirst", "appdist", "AVort", "ajist", "alist", "alisted", "avalist", " avaint", "avalaint", "avalort", "varirst", "evists", "ajaint", "avant", "eviste", "avast", "alast", "aveort", "abIST", " avists", "varaint", "ajists", "ajast", "avism", "AViz", "alant", "abdist", "avistent", "abist", "avisted", " avirst", "ajisted", "avaint", "evIST", "aviz", "aviste", "aveiste", "avists", "varist", "avalism", "evdist", "ovism", " avism", "avaliz", "appist", " avert", "aveist", "ajism", "AVist", "ovaint", "ovist", "avort", "evinst", " avant", "avaliste", "ajinst", "avdist", "abiste", "AViste", "overt", "appiste", "aveiz", " avinst", "ajant", "avalert"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516, "substitutes": {"opaque": ["appacity", "operacity", "operaque", "transacity", " opaco", "oppaco", "opaco", "oppaque", "oppacity", "transonymous", "appque", "operque", "opacity", "operonymous", " opque", " opacity", "transaque", "opque", "apponymous", "appaque", "transque", "oppque", "operaco", "oponymous"], "addr": ["route", "port", "handle", "target", "start", "asm", "conn", "adr", "config", "part", "eth", "mode", "oa", "ord", "func", "afi", "pad", "host", "align", "node", "layer", "pos", "cmp", "cmd", "address", "data", "args", "ad", "state", "ip", "p", "ace", "point", "work", "code", "prefix", "dr", "ctx", "cb", "nr", "arch", "index", "byte", "x", "ptr", "dc", "Address", "seq", "alias", "error", "src", "len", "loc", "pointer", "image", "offset", "base", "inter", "padding", "type"], "size": ["name", "e", "en", "scale", "g", "sized", "Size", "bytes", "align", "ize", "address", "s", "data", "fee", "or", "code", "sync", "rc", "c", "small", "capacity", " address", "length", "len", "loc", "large", "sec", "SIZE", "from", "empty", "offset", "x", "type"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n", "idx": 23540, "substitutes": {"opaque": ["OPaque", "Opasi", "ipace", "ipaque", " opac", "opusonymous", "opasi", "opusaque", "Opace", "opace", "Opacity", "OPonymous", "opusac", " opasi", "opacity", "OPac", "opac", " oponymous", " opacity", "Opaque", " opace", "ipasi", "opusifice", "opifice", "OPifice", " opifice", "ipacity", "oponymous"], "addr": ["md", "class", "ref", "config", "arg", "eth", "oa", "xd", "pad", "host", "mt", "node", "device", "pos", "address", "ad", "data", "at", "ace", "prefix", "id", "od", "mac", "dr", "filename", "cb", "nr", "ptr", "vr", "Address", "seq", "src", "fd", "pointer", "offset", "x", "attr", "inter", "url"], "val": [" value", "sel", "Value", "ee", "fail", "ref", "sl", "valid", "ol", "tx", "pos", "al", "data", "rel", "arr", "vals", "slot", "var", "buf", "el", "aval", "byte", "b", "vol", "oval", "len", "VAL", "base", "Val", "v", "alt", "eval", "all", "offset", "x", "value"], "d": ["md", "dos", "i", "grad", "e", "cd", "rd", "g", "db", "pd", "dh", "ds", "ld", "f", "gd", "t", "r", "m", "da", "ad", "dd", "p", "o", "od", "c", "sd", "dt", "ads", "b", "dc", "fd", "D", "z", "dat", "l"], "s": ["i", "e", "sl", "fs", "g", "ses", "ds", "f", "t", "u", "r", "m", "ad", "os", "ssl", "p", "ts", "o", "ss", "sg", "c", "si", "a", "b", "w", "n", "S", "ns", "ps", "rs", "gs", "v", "h", "l", "sq"]}}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555, "substitutes": {"dev": ["md", "Dev", "str", "priv", "grad", "cam", "def", "conn", "eth", "de", "d", "tr", "ds", "device", "devices", "dist", "info", "data", "diff", "mod", "self", "pro", "ver", "rad", "dc", "dm", "test", "req", "tty", "di", "proc", "conf", "bus", "hw", "development", "ev", "pub"], "errp": [" errf", "rrP", "rrf", "rorp", "rorip", "errf", "erip", "errorpc", "rrp", " errfp", " errpc", "errpc", "rrpc", "errfp", "errP", " errip", "errorf", "rorpc", "erfp", "errorP", " errP", "errip", "erp", "rorfp", "erpc", "errorp"], "fs": ["fc", "outs", "qs", "fts", "linux", "fb", "ks", "ds", "fp", "f", "flags", "df", "flows", "sys", "fps", "os", "fx", "cf", "cs", "fits", "ls", "vs", "stats", "af", "js", "FS", "ows", "fr", "ms", "fd", "ns", "fw", "feed", "ps", "alls", "bf", "bs", "Fs", "ats", "files", "ips", "ss"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n", "idx": 23560, "substitutes": {"s": ["sv", "sb", "i", "e", "sed", "es", "ast", "sci", "sl", "fs", "ses", "an", "lex", "sac", "sis", "as", "ds", "f", "sys", "p", "cs", "ls", "is", "ss", "sa", "sg", "c", "self", "source", "si", "sts", "sc", "a", "w", "service", "se", "src", "ns", "sf", "rs", "gs", "sq"], "frame": ["view", "e", "iframe", "next", "scene", "part", "framework", "fb", "za", "feature", "fp", "f", "buffer", "data", "fx", "cf", "component", "point", "ace", "word", "pse", "self", "frames", "document", "source", "window", "rame", "face", "seq", "slice", "flow", "Frame", "range", "fram", "image", "fi", "video", "interface"], "flags": ["kind", "fs", "features", "mode", "func", "ffff", "ops", "f", "args", "faces", " flag", "cs", "Flag", "stats", "ants", "Flags", "settings", "lag", "fr", "bits", "flag", "FLAG", "mask", " Flags", "options", "ips", "feat", "format"], "ist": ["est", "edit", "ess", "dit", "xt", "ast", "adr", "ind", "ost", "IST", "iste", "kt", "aci", "ide", "isc", "pect", "dist", "asi", "osi", "ant", "sd", "wp", "et", "ic", "alist", "ists", "ism", "iss", "ict", "st", "isd", "ais", "asp", "pt", "feat", "ista"], "ctx": ["lc", "fc", "cc", "wcs", "conn", "sci", "ct", "config", "acl", "pkg", "cv", "tx", "ca", "Context", "pc", "ds", "cu", "cas", "fp", "ci", "cmp", "ac", "cmd", "cp", "nc", "p", "cs", "cf", "ace", "context", "c", "cn", "comp", "cal", "fw", "loc", "cca", "hw", "kw", "sq", "acs", "vc"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "void ff_h264_idct8_add_c(uint8_t *dst, DCTELEM *block, int stride){\n\n    int i;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    block[0] += 32;\n\n\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[0+i*8] + block[4+i*8];\n\n        const int a2 =  block[0+i*8] - block[4+i*8];\n\n        const int a4 = (block[2+i*8]>>1) - block[6+i*8];\n\n        const int a6 = (block[6+i*8]>>1) + block[2+i*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[3+i*8] + block[5+i*8] - block[7+i*8] - (block[7+i*8]>>1);\n\n        const int a3 =  block[1+i*8] + block[7+i*8] - block[3+i*8] - (block[3+i*8]>>1);\n\n        const int a5 = -block[1+i*8] + block[7+i*8] + block[5+i*8] + (block[5+i*8]>>1);\n\n        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        block[0+i*8] = b0 + b7;\n\n        block[7+i*8] = b0 - b7;\n\n        block[1+i*8] = b2 + b5;\n\n        block[6+i*8] = b2 - b5;\n\n        block[2+i*8] = b4 + b3;\n\n        block[5+i*8] = b4 - b3;\n\n        block[3+i*8] = b6 + b1;\n\n        block[4+i*8] = b6 - b1;\n\n    }\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[i+0*8] + block[i+4*8];\n\n        const int a2 =  block[i+0*8] - block[i+4*8];\n\n        const int a4 = (block[i+2*8]>>1) - block[i+6*8];\n\n        const int a6 = (block[i+6*8]>>1) + block[i+2*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[i+3*8] + block[i+5*8] - block[i+7*8] - (block[i+7*8]>>1);\n\n        const int a3 =  block[i+1*8] + block[i+7*8] - block[i+3*8] - (block[i+3*8]>>1);\n\n        const int a5 = -block[i+1*8] + block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1);\n\n        const int a7 =  block[i+3*8] + block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b7) >> 6) ];\n\n        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b2 + b5) >> 6) ];\n\n        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b4 + b3) >> 6) ];\n\n        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b6 + b1) >> 6) ];\n\n        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b6 - b1) >> 6) ];\n\n        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b4 - b3) >> 6) ];\n\n        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b2 - b5) >> 6) ];\n\n        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b7) >> 6) ];\n\n    }\n\n}\n", "idx": 23576, "substitutes": {"dst": ["fst", "DST", "dbl", "Dbl", "fbl", "Dst", " dbl", " dST", "fsc", "dsc", "Dsc", "fST", " dsc", "dST"], "block": ["bc", "row", "def", "off", "app", "event", "none", "map", "container", "ban", "post", "copy", "device", "buffer", "bit", "use", "bug", "ip", "list", "link", "work", "pool", "header", "line", "join", "clean", "batch", "image", "type", "request", "name", "object", "style", "node", "pre", "lock", "tick", "unit", "buf", "blocks", "channel", "keep", "panel", "space", "chain", "tx", "box", "full", "head", "patch", "p", "point", "comment", "open", "module", "check", "byte", "b", "month", "core", "error", "flow", "loc", "page", "user", "group", "bar", "view", "limit", "square", "board", "layout", "BL", "rect", "plugin", "bl", "down", "product", "cl", "build", "cache", "word", "sync", "tag", "frame", "random", "filter", "match", "pull", "rock", "session", "large", "wall", "pack", "Block", "all", "record", "condition", "contract"], "stride": [" strite", " strides", "slide", "slite", " shrider", " shride", " shrides", "strite", "slider", "strider", "strides", "slides", " strider", " shrite"], "i": ["io", "ami", "e", "ix", "ie", "fi", "qi", "ui", "eni", "mini", "ki", "gi", "uri", "chi", "ti", "I", "l", "f", "ci", "esi", "y", "phi", "info", "ini", "u", "oi", "j", "adi", "it", "s", "ir", "ip", "p", "asi", "id", "at", "vi", "bi", "o", "cli", "mi", "is", "c", "mu", "index", "si", "ii", "b", "ji", "in", "n", "iu", "slice", "ai", "xi", "ei", "hi", "di", "v", "multi", "li", "pi", "x", "zi", "k", "ni", "ori"], "cm": ["lc", "bc", "cc", "cd", "circ", "rem", "pm", "ca", "ci", "km", "cp", "mc", "cf", "mm", "cb", "CM", "ym", "fm", "gc", "cr", "bm", "mx", "im", "image", "mn", "nm"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587, "substitutes": {"val": ["reg", "name", "sel", "ee", "ref", "ind", "valid", "arg", "key", "local", "pos", "sol", "al", "entry", "size", "data", "it", "ret", "vals", "slot", "addr", "count", "var", "live", "el", "index", "num", "byte", "pid", "value", "vol", "call", "len", "test", "loc", "VAL", "base", "Val", "doc", "v", "old", "eval", "lit", "x", "prop", "type"]}}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tlb_set_page(CPUArchState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    section = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n           \" prot=%x idx=%d pd=0x%08lx\\n\",\n\n           vaddr, paddr, prot, mmu_idx, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 23622, "substitutes": {"env": ["net", "txt", "e", "chn", "org", "en", "ee", "forge", "conn", "oe", "eu", "config", "eur", "eni", "db", "cv", "eng", "engine", "export", "ea", "ef", "exec", "exc", "ah", "dev", "init", "her", "enc", "cf", "que", "context", "np", "Environment", "ext", "ctx", "el", "edge", "et", "equ", " environment", "dt", "gui", "ect", "het", "core", "viron", "enter", "console", "iss", "osc", "fen", "ner", "qt", "dat", "anne", "cot", "erv", "ne", "ev", "environment", "server", "inet", "ec", "ette"], "vaddr": ["nvhop", "lvaddr", "nvaddr", "faddr", "lvaddress", "vwork", "vhop", "uhost", "uhop", "vaddress", "frf", "laddress", "ldb", "nvadr", "nvaddress", "faddress", "pindex", "ivnode", " vindex", " vdb", "haddr", "padr", "fdata", "phop", "phost", "uaddr", "vrf", "paddress", "vindex", " vadr", "hindex", "hhost", "fhost", "fwork", "pdata", "pwork", " vrf", " vdata", "uaddress", "haddress", " vhost", " vwork", "laddr", "vdb", " vhop", "vadr", "fnode", "ivaddress", "vnode", "ivaddr", "vhost", "pnode", "prf", "pdb", "lvhop", " vaddress", "lvhost", "ivhost", "vdata"], "paddr": ["postdata", " pkg", " padr", "vpconn", "padd", " pconn", "pptr", "vaddress", " pptr", "pkg", "vadd", " pord", "postaddr", "pord", "vargs", "padr", "vkg", "appdb", "Pord", "appptr", " pady", "postadr", " pargs", "vptr", "paddress", "Padd", "pargs", "vpargs", " paddress", " padd", "pdata", "Pkg", "Pady", " pdata", "vpaddress", " pdb", "vdb", "vpaddr", "appaddr", "vpady", "vadr", "pconn", "vconn", "pady", "vpord", "pdb", "Paddress", "Paddr", "appaddress", "vdata", "postaddress"], "prot": ["io", "platform", "col", "prototype", "period", "txt", "lat", "plain", "nat", "conn", "ref", "config", "pattern", "sil", "eth", "det", "utf", "rin", "rep", "byter", "tun", "plugin", "rect", "rf", "fp", "transfer", "model", "cont", "phy", "stat", "ret", "prefix", "np", "cli", "thin", "rot", "ext", "lo", "sector", "pro", "dim", "ptr", "sect", "het", "seq", "python", "fl", "chron", "len", "Prot", "mult", "chrom", "reset", "fen", "bot", "pointer", "dat", "gap", "typ", "lit", "pt", "server", "inet", "att", "format", "prop"], "mmu_idx": ["mmu_pidp", "mmu__idx", "mmu_idc", "mmu_idz", "mmu_ideg", "mmu_indx", "mmu_idp", "mmu_startx", "mmu_idest", "mmu_pidv", "mmu_idsz", "mmu_idst", "mmu_idev", "mmu_startc", "mmu_idey", "mmu__startc", "mmu__idy", "mmu_startr", "mmu__idr", "mmu_starty", "mmu_idsv", "mmu__startr", "mmu_idg", "mmu_pidx", "mmu_idy", "mmu_ider", "mmu_pidy", "mmu_idexs", "mmu_idr", "mmu_idsx", "mmu_idxs", "mmu_idez", "mmu__idc", "mmu_indy", "mmu_idec", "mmu_pidxs", "mmu_idex", "mmu_idv", "mmu_pidz", "mmu_idsp", "mmu_indg", "mmu__startx", "mmu__starty", "mmu_idep", "mmu_indst"], "size": ["name", "class", "security", "password", "esc", "en", "shape", "send", "scale", "ui", "mode", "sized", "eng", "Size", "uri", "connection", "style", "export", "ize", "fee", "data", "storage", "sum", "unit", "code", "count", "shift", "timeout", "six", "small", "capacity", "second", "core", "desc", "length", "loc", "len", "large", "page", "south", "z", "sec", "SIZE", "empty", "position", "offset", "max", "cap", "type"], "section": ["bc", "package", "row", "area", "esc", "ct", "config", "part", "connection", "cell", "fat", "j", "sector", "small", "sect", "division", "ment", "test", "vision", "route", "security", "option", "character", "site", "ion", "component", "sections", "ext", "rc", "Section", "sc", "element", "ie", "action", "lc", "sel", "region", "pex", "function", "job", "comment", "sea", "form", "sub", "service", "core", "loc", "definition", "sec", "script", "secondary", "sq", "port", "establishment", "sl", "plugin", "entry", "storage", "setting", "version", "sa", "settings", "search", "ect", "session", " sections", "server", "environment", "block"], "index": ["route", "i", "shape", "connect", "end", "ind", "config", "loop", "val", "inc", "key", "connection", "access", "pos", "ion", "ini", "fee", "lock", "diff", "point", "number", "code", "ace", "addr", "sync", "condition", "open", "Index", "find", "num", "edge", "match", "si", "value", "sect", "date", "error", "length", "slice", "loc", "len", " indexes", "iter", "test", "element", "update", "ne", "pointer", "ticket", "position", "sort", "offset", "x", "action", "type"], "address": ["route", "port", "name", "shape", "attribute", "area", "password", "e", "object", "end", "en", "table", "event", "ress", "format", "message", "region", "mode", "uri", "align", "host", "node", "type", "order", "state", "ip", "component", "number", "point", "code", "addr", "ace", "answer", "memory", "network", "header", "capacity", "ptr", "Address", "location", "alias", "enter", "length", "element", "test", "reference", "alpha", "pair", "array", "pointer", "resource", "image", "position", "offset", "output", "ACE", "padding", "value"], "code_address": ["code_addr", "code2index", "codes_position", "code2address", "code_position", "code64addr", " code_number", " code_mode", "code_offset", "code2position", "codes_index", "codes_address", "codes_number", " code_addr", " code_offset", "code2number", "code64address", "code_number", "code2offset", "code_index", "codes2number", "code64mode", "codes2position", "code2addr", "code_mode", "codes2address", "codes2index"], "addend": [" addending", "nextpend", "Addstart", "endpend", "endstart", "adended", "Addend", " addEnd", "addedEnd", "adending", "addedend", "addbegin", " addbegin", "Addpend", "callpend", "callend", "incend", " addended", "Addended", "addender", "newender", "callending", "incender", "newEnd", "Addender", "nextending", " addstart", "addstart", "addEnd", "genend", "newbegin", "adend", "incEnd", " addpend", "endend", "addended", "AddEnd", "newend", "newended", "nextend", "addending", "genended", "incended", "addpend", "genending", "addedbegin", "endended", "addedended"], "te": ["td", "je", "ut", "ite", "txt", "e", "ee", "oe", "eu", "scale", "text", "ade", "pe", "ette", "me", "be", "private", "ze", "de", "tr", "ti", "so", "ten", "t", "ffe", "info", "ue", "fee", "tes", "tg", "ts", "le", "ye", "ss", "tile", "fe", "complete", "fr", "ste", "let", "dt", "ptr", "ta", "Te", "tre", "se", "he", "ele", "lt", "test", "ve", "see", "ae", "ce", "tm", "template", "dat", "ke", "ge", "ne", "TE"], "iotlb": ["ietbl", "iollb", "otb", "otla", "iottb", "ietlin", "ctlab", "ntb", "iollab", "itlr", "iollr", "itlb", "iotlib", "inetlb", "ntlib", "inetbl", "otl", "iotl", "ottlb", "iotb", "iottlib", "ctlp", "iotlab", "itlab", "ietlb", "ntlb", "ietlp", "iottl", "inetl", "iotlin", "itlp", "ottl", "iottla", "ntlin", "iotla", "inetlp", "ottbl", "iotbl", "iottlin", "iottlb", "iotlp", "otlb", "iollp", "ottlp", "ietlib", "ietl", "ietb", "iotlr", "ietla", "ctlr", "ctlb"]}}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 23626, "substitutes": {"opaque": ["ospac", "OPaque", "opec", "Opaya", "ospslot", " opaya", " opac", "opaya", "Ophole", "OPhole", "ophole", " opslot", "OPaya", "Opec", "OPec", "OPac", "opslot", "opac", "ospec", "Opaque", "OPslot", "ospaque", " opec", " ophole"], "addr": ["md", "port", "grad", "asm", "ast", "adr", "config", "hop", "ref", "id", "part", "pkg", "eth", "mode", "oa", "ord", "rx", "mag", "afi", "amd", "pad", "host", "align", "node", "device", "flags", "ea", "pos", "layer", "cmp", "al", "alloc", "coord", "cmd", "address", "r", "data", "ad", "ip", "osi", "ace", "mod", "slot", "mac", "od", "fx", "code", "dr", "rc", "cb", "el", "advert", "rt", "x", "ptr", "vr", "seq", "src", "len", "ag", "proc", "alt", "sid", "anne", "offset", "sta"], "val": ["ee", "fail", "config", "vt", "part", "key", "buffer", "pos", "r", "data", "vals", "live", "la", "pl", "dim", "line", "ve", "VAL", "util", "v", "eval", "l", "fi", "gal", "delay", "valid", "ind", "sil", "text", "gold", "cel", "al", "fee", "stat", "unit", "aval", "a", "vol", "va", "alt", "li", "vl", "prop", "lc", "ival", "reg", "e", "sel", "serv", "ref", "err", "tx", "ld", "f", "ret", "p", "nil", "rot", "el", "ver", "b", "loc", "Val", "lit", "x", "gb", "count", "sl", "lv", "als", "cond", "bal", "ol", "bl", "pal", "rel", "label", "slot", "elt", "change", "au", "index", "quote", "cal", "fl", "len", "pol", "update", "vert", "all", "pt", "base", "value"], "s": ["i", "es", "ds", "sys", "y", "r", "ssl", "os", "ts", "cs", "stats", "n", "S", "ns", "rs", "v", "conf", "http", "l", "an", "ss", "request", "sb", "g", "ses", "private", "d", "sets", "services", "u", "state", "stat", "o", "sg", "c", "self", "spec", "a", "sf", "e", "sym", "serv", "sie", "fs", "lines", "rates", "f", "t", "new", "p", "si", "b", "service", "side", "ps", "gs", "z", "x", "sq", "status", "port", "sk", "sl", "your", "ops", "m", "socket", "its", "ls", "sync", "is", "sa", "client", "settings", "w", "se", "session", "south", "server", "states"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n", "idx": 23627, "substitutes": {"src": ["conv", "transform", "stack", "sb", "grad", "start", "sel", "support", "irc", "sl", "config", "iv", "sil", "input", "rect", "cur", "img", "secure", "url", "sync", "gz", "rc", "cb", "reflect", "spec", "source", "filter", "sc", "sr", "sub", "inst", "slice", "loc", "req", "dest", "stream", "rb", "gb"], "stride": ["drider", " strider", " strend", "fride", "drize", "strend", " strided", "strider", "Strided", "frider", "dride", " strance", "Strance", "brend", "strance", "bride", "strize", "Strend", "drided", "brance", "frize", "brided", "frided", "strided", "Stride", " strize"], "filter_p1": ["filter_p8", "filter_qars", "filter_q8", "filter_int0", "filter_q6", "filter_r0", "filter_vars", "filter_pars", "filter_r1", "filter_int1", "filter_p11", "filter_r8", "filter_v6", "filter_v1", "filter_q0", "filter_intars", "filter_p6", "filter_q11", "filter_r11", "filter_p0", "filter_int6", "filter_v0"], "filter_q1": ["filter_f1", "filter_q16", "filter_q2", "filter_qb", "filter_k0", "filter_p2", "filter_c0", "filter_k1", "filter_qs2", "filter_cb", "filter_kb", "filter_qs0", "filter_c1", "filter_p16", "filter_f2", "filter_q0", "filter_f16", "filter_p0", "filter_f0", "filter_pb", "filter_qs16", "filter_qs1"], "alpha": ["i", "phase", "area", "amp", "scale", "asc", "acl", "inc", "average", "pha", "A", "zero", "ac", "acc", "da", "init", "appa", "diff", "star", "sa", "la", "audio", "filter", "lambda", "si", "a", "mad", "qa", "error", "positive", "aa", "LA", "ma", "\u03b1", "Alpha"], "beta": ["binary", "phase", "ba", "\u03b2", "margin", "zero", "neg", "phi", "acc", "da", "appa", "params", "eta", "c", "mu", "negative", "filter", "lambda", "gradient", "si", "a", "ii", "b", "ta", "qa", "error", "offset", "Beta", "pa", "Alpha"], "lim_p0q0": ["lim_p0q1", "lim_p0p8", "lim_p1p1", "lim_p1q8", "lim_p0w1", "lim_p0p00", "lim_p0q25", "lim_p0q5", "lim_p0p5", "lim_p0w0", "lim_p0f8", "lim_p0q00", "lim_p0dq0", "lim_p1q0", "lim_p0dq25", "lim_p0f0", "lim_p1p0", "lim_p1q5", "lim_p0w8", "lim_p0dq1", "lim_p0p0", "lim_p1q1", "lim_p0p1", "lim_p1p25", "lim_p0w5", "lim_p0p25", "lim_p0dq00", "lim_p0f5", "lim_p0q8", "lim_p1p5", "lim_p0f1", "lim_p1p8", "lim_p1q25", "lim_p1q00", "lim_p1p00"], "lim_q1": ["lim_p5", "lim_qs5", "lim_p0", "lim_dq5", "lim_p01", "lim_qs0", "lim_qi01", "lim_qi101", "lim_p101", "lim_qi1", "lim_q5", "lim_q01", "lim_qq1", "lim_q0", "lim_q101", "lim_qq01", "lim_qq0", "lim_qq101", "lim_qi0", "lim_qs1", "lim_dq0", "lim_dq1"], "lim_p1": ["lim_lone", "lim_pi1", "lim_l01", "lim_p4", "lim_pi01", "lim_q81", "lim_p0", "lim_l4", "lim_p01", "lim_pi0", "lim_l81", "lim_qone", "lim_pione", "lim_l0", "lim_pone", "lim_q01", "lim_q0", "lim_l1", "lim_q4", "lim_p81"]}}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static int decode_subframe(WmallDecodeCtx *s)\n\n{\n\n    int offset        = s->samples_per_frame;\n\n    int subframe_len  = s->samples_per_frame;\n\n    int total_samples = s->samples_per_frame * s->num_channels;\n\n    int i, j, rawpcm_tile, padding_zeroes, res;\n\n\n\n    s->subframe_offset = get_bits_count(&s->gb);\n\n\n\n    /* reset channel context and find the next block offset and size\n\n        == the next block of the channel with the smallest number of\n\n        decoded samples */\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        if (offset > s->channel[i].decoded_samples) {\n\n            offset = s->channel[i].decoded_samples;\n\n            subframe_len =\n\n                s->channel[i].subframe_len[s->channel[i].cur_subframe];\n\n        }\n\n    }\n\n\n\n    /* get a list of all channels that contain the estimated block */\n\n    s->channels_for_cur_subframe = 0;\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        const int cur_subframe = s->channel[i].cur_subframe;\n\n        /* subtract already processed samples */\n\n        total_samples -= s->channel[i].decoded_samples;\n\n\n\n        /* and count if there are multiple subframes that match our profile */\n\n        if (offset == s->channel[i].decoded_samples &&\n\n            subframe_len == s->channel[i].subframe_len[cur_subframe]) {\n\n            total_samples -= s->channel[i].subframe_len[cur_subframe];\n\n            s->channel[i].decoded_samples +=\n\n                s->channel[i].subframe_len[cur_subframe];\n\n            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;\n\n            ++s->channels_for_cur_subframe;\n\n        }\n\n    }\n\n\n\n    /* check if the frame will be complete after processing the\n\n        estimated block */\n\n    if (!total_samples)\n\n        s->parsed_all_subframes = 1;\n\n\n\n\n\n    s->seekable_tile = get_bits1(&s->gb);\n\n    if (s->seekable_tile) {\n\n        clear_codec_buffers(s);\n\n\n\n        s->do_arith_coding    = get_bits1(&s->gb);\n\n        if (s->do_arith_coding) {\n\n            avpriv_request_sample(s->avctx, \"Arithmetic coding\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        s->do_ac_filter       = get_bits1(&s->gb);\n\n        s->do_inter_ch_decorr = get_bits1(&s->gb);\n\n        s->do_mclms           = get_bits1(&s->gb);\n\n\n\n        if (s->do_ac_filter)\n\n            decode_ac_filter(s);\n\n\n\n        if (s->do_mclms)\n\n            decode_mclms(s);\n\n\n\n        if ((res = decode_cdlms(s)) < 0)\n\n            return res;\n\n        s->movave_scaling = get_bits(&s->gb, 3);\n\n        s->quant_stepsize = get_bits(&s->gb, 8) + 1;\n\n\n\n        reset_codec(s);\n\n    } else if (!s->cdlms[0][0].order) {\n\n        av_log(s->avctx, AV_LOG_DEBUG,\n\n               \"Waiting for seekable tile\\n\");\n\n        s->frame.nb_samples = 0;\n\n        return -1;\n\n    }\n\n\n\n    rawpcm_tile = get_bits1(&s->gb);\n\n\n\n    for (i = 0; i < s->num_channels; i++)\n\n        s->is_channel_coded[i] = 1;\n\n\n\n    if (!rawpcm_tile) {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            s->is_channel_coded[i] = get_bits1(&s->gb);\n\n\n\n        if (s->bV3RTM) {\n\n            // LPC\n\n            s->do_lpc = get_bits1(&s->gb);\n\n            if (s->do_lpc) {\n\n                decode_lpc(s);\n\n                avpriv_request_sample(s->avctx, \"Expect wrong output since \"\n\n                                      \"inverse LPC filter\");\n\n            }\n\n        } else\n\n            s->do_lpc = 0;\n\n    }\n\n\n\n\n\n    if (get_bits1(&s->gb))\n\n        padding_zeroes = get_bits(&s->gb, 5);\n\n    else\n\n        padding_zeroes = 0;\n\n\n\n    if (rawpcm_tile) {\n\n        int bits = s->bits_per_sample - padding_zeroes;\n\n        if (bits <= 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Invalid number of padding bits in raw PCM tile\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        av_dlog(s->avctx, \"RAWPCM %d bits per sample. \"\n\n                \"total %d bits, remain=%d\\n\", bits,\n\n                bits * s->num_channels * subframe_len, get_bits_count(&s->gb));\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_coeffs[i][j] = get_sbits(&s->gb, bits);\n\n    } else {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            if (s->is_channel_coded[i]) {\n\n                decode_channel_residues(s, i, subframe_len);\n\n                if (s->seekable_tile)\n\n                    use_high_update_speed(s, i);\n\n                else\n\n                    use_normal_update_speed(s, i);\n\n                revert_cdlms(s, i, 0, subframe_len);\n\n            } else {\n\n                memset(s->channel_residues[i], 0, sizeof(**s->channel_residues) * subframe_len);\n\n            }\n\n    }\n\n    if (s->do_mclms)\n\n        revert_mclms(s, subframe_len);\n\n    if (s->do_inter_ch_decorr)\n\n        revert_inter_ch_decorr(s, subframe_len);\n\n    if (s->do_ac_filter)\n\n        revert_acfilter(s, subframe_len);\n\n\n\n    /* Dequantize */\n\n    if (s->quant_stepsize != 1)\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_residues[i][j] *= s->quant_stepsize;\n\n\n\n    /* Write to proper output buffer depending on bit-depth */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        int subframe_len = s->channel[c].subframe_len[s->channel[c].cur_subframe];\n\n\n\n        for (j = 0; j < subframe_len; j++) {\n\n            if (s->bits_per_sample == 16) {\n\n                *s->samples_16[c]++ = (int16_t) s->channel_residues[c][j] << padding_zeroes;\n\n            } else {\n\n                *s->samples_32[c]++ = s->channel_residues[c][j] << padding_zeroes;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handled one subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ++s->channel[c].cur_subframe;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23636, "substitutes": {"s": ["es", "uns", "xs", "ds", "sys", "y", "r", "ssl", "os", "ts", "cs", "us", "params", "stats", "js", "aws", "ms", "n", "S", "ns", "rs", "http", "conf", "l", "ss", "this", "sb", "g", "ses", "d", "sets", "site", "as", "ches", "services", "u", "o", "sites", "sg", "self", "spec", "a", "set", "sf", "su", "native", "e", "sym", "qs", "hs", "fs", "f", "t", "less", "full", "p", "si", "b", "service", "parts", "ps", "gs", "sq", "features", "plugins", "ks", "m", "its", "vs", "ls", "sync", "is", "se", "session", "south", "bs", "states"], "i": ["io", "eni", "mini", "ti", "y", "info", "r", "ini", "ip", "field", "mu", "line", "n", "iu", "slice", "di", "v", "l", "fi", "type", "name", "ix", "qi", "ind", "ri", "iv", "gi", "d", "I", "ci", "u", "o", "mi", "ji", "xi", "multi", "yi", "li", "ie", "pi", "offset", "k", "ni", "lc", "e", "ui", "result", "f", "t", "phi", "it", "init", "p", "bi", "cli", "module", "si", "b", "h", "api", "x", "zi", "ori", "anti", "start", "uri", "oi", "m", "id", "index", "source", "ii", "ai", "range"], "j": ["je", "e", "obj", "jp", "adj", "g", "eni", "pos", "dj", "r", "m", "p", "job", "o", "js", "aj", "J", "ji", "ij", "n", "ai", "jc", "v", "z", "l", "k", "jump", "ni"], "rawpcm_tile": ["rawpca_style", "rawpca_tile", "rawpcm_style", "rawpca_offset", "rawpca_slice", "rawpcm_offset", "rawpcm_slice"], "padding_zeroes": ["padding_eros", "padding_zoeros", "padding_zoes", "padding_zerones", "padding_zoos", "padding_eroes", "padding_zones", "padding_erones", "padding_zeros", "padding_zos", "padding_zereros", "padding_ereros", "padding_zooes", "padding_zoones"], "res": ["col", "row", "err", "val", "rem", "pos", "nc", "r", "final", "Res", "vals", "q", "pres", "blocks", "seq", "rev", "rss", "req", "ps", "rs", "reset", "range", "resolution", "resp", "max", "eps"], "channels_for_cur_subframe": ["channels_for_cur_perframes", "channels_for_cur_subsample", "channels_for_cur_microsample", "channels_for_cur_partcomponent", "channels_for_cur_subcomponent", "channels_for_cur_broadcomponent", "channels_for_cur_partframe", "channels_for_cur_microscale", "channels_for_cur_subscale", "channels_for_cur_broadframe", "channels_for_cur_longscale", "channels_for_cur_perframe", "channels_for_cur_broadframes", "channels_for_cur_percomponent", "channels_for_cur_partframes", "channels_for_cur_longframe", "channels_for_cur_microframe", "channels_for_cur_subframes", "channels_for_cur_longsample", "channels_for_cur_longcomponent", "channels_for_cur_longframes"], "channel": ["remote", "package", "phase", "target", "sample", "config", "scale", "character", "scene", "chain", "project", "container", "chan", "connection", "player", "file", "queue", "column", "layer", "pixel", "can", "Channel", "component", "version", "unit", "change", "cycle", "que", "context", "client", "network", "module", "source", "byte", "sc", "service", "core", "error", "center", "call", "flow", "large", "game", "button", "group", "stream", "image", "server", "block", "video", "course"], "cur_subframe": ["cur_subslice", "cur_sublace", "cur_serverframe", "cur_subfram", "cur_broadframe", "cur_transframe", "cur_longsample", "cur_submotion", "cur_broadfram", "cur_longslice", "cur_difframe", "cur_secondlace", "cur_transsample", "cur_seconddraw", "cur_ubfram", "cur_diffframe", "cur_supframes", "cur_singlemotion", "cur_pubframe", "cur_diffdraw", "cur_partfram", "cur_subrame", "cur_partsample", "cur_pubFrame", "cur_perframes", "cur_subzone", "cur_supstate", "cur_subrange", "cur_ubframe", "cur_partframes", "cur_transstate", "cur_persample", "cur_serverrame", "cur_pubscene", "cur_subscene", "cur_broadsample", "cur_suprange", "cur_subframes", "cur_partframe", "cur_supface", "cur_supzone", "cur_substate", "cur_subdraw", "cur_broadslice", "cur_longframe", "cur_broadframes", "cur_subsample", "cur_singleframes", "cur_singleframe", "cur_singlerange", "cur_transface", "cur_serverdraw", "cur_supframe", "cur_transmotion", "cur_perframe", "cur_secondrame", "cur_secondframe", "cur_singlezone", "cur_difflace", "cur_perfram", "cur_subFrame", "cur_partFrame", "cur_supmotion", "cur_serverlace", "cur_subface", "cur_partscene", "cur_ubscene", "cur_ubFrame", "cur_pubfram", "cur_singleface", "cur_transslice", "cur_singlestate"]}}
{"project": "FFmpeg", "commit_id": "1bab6f852c7ca433285d19f65c701885fa69cc57", "target": 1, "func": "static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,\n\n                                 const int16_t *ubuf[2], const int16_t *bguf[2],\n\n                                 const int16_t *abuf0, uint8_t *dest,\n\n                                 int dstW, int uvalpha, int y)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];\n\n    const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1\n\n\n\n    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1b(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n", "idx": 23643, "substitutes": {"c": ["lc", "bc", "i", "e", "cam", "cc", "g", "cm", "d", "ca", "f", "ci", "r", "ac", "m", "s", "u", "cache", "oc", "enc", "p", "cs", "mc", "ctx", "cb", "a", "b", "dc", "w", "cy", "n", "C", "v", "h", "cit", "l", "x", "k"], "buf0": ["cv2", "port2", "buff1", "buff4", "buff6", "buff0", " buf5", " buf2", "uf00", "buffer0", "uf1", "buf4", "buffer1", "uf6", "cf1", "port1", "cf2", "cv00", "buf5", "port0", "buf00", "uf0", "cv1", "port5", "buffer4", "buf6", " buf6", "cf00", "uf2", "uf5", "cf0", "cv0", "buff2", "uf4", "buf2"], "ubuf": ["uflf", "bbuf", "ucuffy", "ufuf", "rubbuff", " ublf", "ucuffer", "abuffer", "ubbo", "ucbuf", "rubbuf", "ubbuf", "ubuffer", "ubuffy", "ablf", "ubbuff", "buffer", " ubbo", "abbo", " ubbuf", "buf", "rubuffer", "abbuff", "abuffy", "ufbo", "rubuf", "rubuffy", "ufbuf", "abuf", "ucuf", "abbuf", "ublf", "bbuff"], "bguf": ["lbull", "sbbuf", "gbuf", "bgull", "bgbuf", "lbuf", "lbbuf", "sbuc", "sbuf", "gbbuf", "gbuc", "gbull", "bguc", "lbuc", "sbull"], "abuf0": ["ubbuf1", "abuf2", "ubuf2", "abf2", "abuf1", "ubbuf2", "abbuf2", "abbuf0", "abf0", "abf1", "abef1", "ubbuf0", "abef2", "abef0", "abbuf1"], "dest": ["output", "txt", "target", "shape", "err", "config", "butt", "origin", "bin", "temp", "img", "dep", "dist", "cont", "path", "coord", "acc", "seed", "opt", "trans", "wb", "shift", "gen", "source", "Dest", "beta", "dim", "du", "mem", "dc", "w", "tmp", "ff", "desc", "src", "test", "comb", "di", "feat", "prop"], "dstW": ["dspW", "destY", "hstB", "hstD", "dstB", "dSTD", "dstY", "dSTW", "hestW", "hestY", "hstW", "destD", "destW", "dSTB", "hestD", "dspY", "dstD", "destB", "dSTY", "dspD", "dspB", "hestB", "hstY"], "uvalpha": ["uevallambda", " uvalph", "uselph", "uvalph", "uselphase", " uValpa", "Uvalspha", "uvalspha", "Uvalta", "uValphase", "uevalpha", "uvalspa", "uvalphase", "Uvalslambda", "uValpha", " uValph", "uvalsphase", "Uvalsphas", " uvalpa", " uValphase", " uvalphase", "uevalphas", "Uvallambda", "uvalsta", "uvalphas", "uevalta", "uvallambda", "uselpha", "uValph", "uvalsph", "uvalpa", "uselpa", "Uvalpha", "Uvalsta", "uvalslambda", "Uvalphas", " uValpha", "uvalta", "uValpa", "uvalsphas"], "y": ["ya", "i", "e", "yd", "yn", "vy", "yy", "ay", "d", "ny", "ty", "ey", "sy", "oy", "ys", "dy", "iy", "wy", " Y", "Y", "w", "ym", "cy", "z", "yi", "ry", "x"], "ubuf0": ["ubbuff0", "ubull3", "ubbuf1", "abuf00", "obuf1", "obf1", "ubull1", "obuf00", "ubf1", "ubf2", "ubbuff1", "obf00", "ubbuff00", "ubbuf00", "ubf0", "abbuf00", "obuf0", "ubuf2", "ubull00", "abuf1", "obf0", "ubbuff3", "ubf00", "ubuf00", "ubbuf2", "obf2", "ubull0", "abbuf3", "obuf2", "abbuf0", "ubbuff2", "ubbuf3", "abuf3", "ubbuf0", "ubuf3", "abbuf1"], "ubuf1": ["ubbufn", "ubbuff0", "ubbuf1", "ublfn", "ublf0", "ublf2", "ubf1", "ubf2", "ubbuff1", "abuf2", "ubf0", "ubuf2", "ubbuffn", "ubff2", "abf2", "abuf1", "ubff0", "ubbuf2", "ublf1", "ubff1", "abbuf2", "abbuf0", "ubufn", "ubbuff2", "abf0", "ubbuf0", "abbufn", "abufn", "abf1", "abbuf1"], "buf1": ["cv2", "bufn", "buff1", "buffern", "buff0", "buffer0", "uf1", "buffer1", "buffb", "bufb", "ufn", "uf0", "cv1", "cvb", "uf2", "cv0", "buffn", "buff2", "ufb", "buf2"]}}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 23656, "substitutes": {"mon": ["Mon", "monitor", "phys", "un", "mot", "mini", "mag", "my", "mor", "con", "tun", "gin", "mic", "emon", "amon", "master", "m", "mo", "mat", "man", "don", "mm", "mid", "MON", "mer", "mu", "module", "mons", "atom", "dom", "ann", "on", "arm", "wan", "channel", "min", "meter", "mun", "chron", "mand", "mut", "mos", "mn"], "qdict": ["qrect", "kmap", "eqblock", "reqdetails", "qualdict", "reqrect", "sqrect", "sqdict", "qualfile", "kdi", " qtable", "qudict", "qdb", "qdetails", "eqdict", "sqblock", "iqdb", "kdict", "reqdict", "kfile", "iqdi", "sqdetails", "eqrect", " qfile", "qualtable", "qmap", "qudi", "qualdb", "qdi", "iqmap", "eqdetails", "qfile", "qudb", "qumap", "qblock", "ktable", " qdb", "kdb", "iqdict", "qtable", "reqblock"], "size": ["name", "shape", "external", "iz", "en", "esc", "e", "start", "scale", "sized", "cm", "Size", "style", "bytes", "ize", "weight", "ci", "address", "s", "fee", "enc", "cs", "code", "count", "sync", "shift", "small", "capacity", "form", "si", "speed", "length", "len", "loc", "large", "z", "SIZE", "sn", "sec", "empty", "offset", "sum"], "chardev": ["chnev", "cdneva", "cdnev", "cdiev", "vardev", "rownec", "rowneva", "chnov", "cdnec", "chardeva", "cderv", "vardov", "vardeva", "rownev", "cdev", "cdov", "chidev", "chardiev", "chnerv", "charderv", "chiderv", "cdnov", "chidiev", "vardec", "chardov", "rownov", "chardec", "chniev", "chidov"], "data": ["str", "start", "response", "space", "next", "valid", "scale", "text", "input", "none", "message", "Data", "extra", "uri", "rec", "style", "json", "bytes", "buffer", "done", "pos", "da", "cache", "number", "code", "body", "inner", "shift", "content", "memory", "missing", "a", "DATA", "window", "raw", "media", "reader", "slice", "len", "partial", "database", "batch", "alpha", "dat", "image", "empty", "base", "output", "format", "padding", "value", "zero"], "errp": [" errf", " errlp", "ErP", "rrf", "srpe", "erpre", "errf", "erlp", "erc", "erf", "rrp", " errc", " errpre", "Erp", "srp", " errpc", "errpc", "rrpc", " errpe", "errP", "Erpe", "frpre", "frp", "rrc", "errc", "frlp", "Erc", "frpc", "errpre", "src", "errpe", "errlp", " errP", "erp", "erpc", "srP"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int do_bit_allocation(AC3DecodeContext *ctx, int flags)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i, snroffst = 0;\n\n\n\n    if (!flags) /* bit allocation is not required */\n\n        return 0;\n\n\n\n    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */\n\n        snroffst += ab->csnroffst;\n\n        if (ab->flags & AC3_AB_CPLINU)\n\n            snroffst += ab->cplfsnroffst;\n\n        for (i = 0; i < ctx->bsi.nfchans; i++)\n\n            snroffst += ab->fsnroffst[i];\n\n        if (ctx->bsi.flags & AC3_BSI_LFEON)\n\n            snroffst += ab->lfefsnroffst;\n\n        if (!snroffst) {\n\n            memset(ab->cplbap, 0, sizeof (ab->cplbap));\n\n            for (i = 0; i < ctx->bsi.nfchans; i++)\n\n                memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n\n            memset(ab->lfebap, 0, sizeof (ab->lfebap));\n\n\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    /* perform bit allocation */\n\n    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))\n\n        if (_do_bit_allocation(ctx, 5))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (flags & (1 << i))\n\n            if (_do_bit_allocation(ctx, i))\n\n                return -1;\n\n    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))\n\n        if (_do_bit_allocation(ctx, 6))\n\n            return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 23668, "substitutes": {"ctx": ["bc", "fc", "cam", "def", "ct", "config", "cm", "parse", "pc", "exc", "cp", "cs", "xc", "prefix", "kb", "context", "cpp", "qa", "src", "fw", "cus", "wx", "cms", "conf", "txt", "wcs", "conn", "pkg", "cv", "anc", "ci", "rc", "c", "cb", "sc", "gc", "cz", "vc", "conv", "lc", "stack", "grad", "cc", "uc", "com", "func", "tx", "cas", "cmp", "exec", "cmd", "cf", "tc", "cli", "ocr", "cy", "loc", "cca", "req", "hw", "obj", "sci", "ca", "Context", "nc", "ga", " cx", "cache", "ctrl", "abc", "sync", "cn", "ch", "cal", "kw", "ck"], "flags": ["ipes", "allows", "afi", "lists", "ils", "vals", "stats", "lag", "styles", "details", "fields", "ins", "does", "relations", "ips", "pages", "feat", "rets", "fts", "ages", "missions", "bugs", "ids", "fps", "fee", "fx", "ports", "Flags", "bits", "FLAG", "requires", "utils", "options", "ats", "files", "atts", "ags", "fs", "fb", "rules", "func", "lines", "ffff", "bytes", "dates", "heads", "members", "full", "ants", "lins", "values", "parts", "fd", " Flags", "pins", "alls", "acks", "mods", "fun", "status", "versions", "includes", "types", "ints", "weights", "features", "locks", "ops", "plugins", "tails", "tones", "orts", "planes", "args", "faces", "strings", "vs", "ails", "id", "settings", "frames", "reads", "flag", "fl", "comments", "mask", "links", "states"], "ab": ["abl", "pb", "hab", "sb", "bc", "lb", "emb", "ap", "app", "ast", "ba", "sam", "acl", "wa", "av", "aps", "com", "db", "mb", "fb", "bb", "ca", "bl", "anc", "al", "eb", "lab", "ac", "tab", "ah", "obb", "web", "um", "ob", "abi", "abc", "mac", "am", "af", "amb", "arch", "ib", "ub", "b", "AB", "hub", "bm", "ai", "cap", "nb", "base", "bf", "http", "bh", "ae", "bs", "rb", "bag", "Ab", "api", "pa", "attr", "abb", "fab", "pub"], "i": ["io", "eni", "key", "ti", "y", "info", "r", "ini", "bit", "j", "ip", "mu", "ib", "n", "iu", "di", "v", "image", "l", "fi", "type", "name", "ix", "qi", "ri", "g", "gi", "d", "I", "ci", "u", "s", "abi", "o", "mi", "c", "a", "ji", "xi", "yi", "multi", "li", "ie", "pi", "k", "ni", "e", "ui", "ki", "f", "t", "phi", "it", "p", "vi", "bi", "si", "b", "z", "x", "zi", "anti", "uri", "oi", "m", "id", "is", "index", "ii", "in", "w", "ai", "hi"]}}
{"project": "qemu", "commit_id": "761731b1805f6ef64eb615e5b82a0801db3cde78", "target": 0, "func": "void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 23680, "substitutes": {"device": ["remote", "package", "port", "name", "attribute", "gpu", "driver", "Device", "controller", "mount", "project", "key", "connection", "compatible", "feature", "plugin", "host", "engine", "node", "product", "devices", "model", "mobile", "address", "dev", "data", "component", "serial", "unit", "machine", "directory", "mac", "disk", "network", "module", "tag", "direction", "location", "service", "element", "database", "resource", "image", "server", "android", "value"], "target": ["remote", "route", "platform", "port", "Target", "driver", "origin", "file", "token", "site", "plugin", "host", "node", "path", "address", "data", "version", "unit", "range", "template", "dest", "resource", "base", "output", "type"], "has_format": ["has_version", " has_version", " has_source", "has_spec", " has_spec", "has_source"], "format": ["route", "package", "port", "transform", "name", "attribute", "command", "language", "event", "scale", "option", "pattern", "driver", "config", "layout", "file", "feature", "style", "plugin", "host", "function", "write", "term", "standard", "address", "cat", "data", "it", "patch", "method", "version", "at", "unit", "prefix", "field", "Format", "ant", "module", "tag", "filter", "form", "date", "stage", "template", "resource", "att", "sort", "api", "feat", "action", "theme", "type", "letter"], "sync": ["status", "io", "delay", "syn", "class", "config", "ride", "drive", "driver", "force", "copy", "style", "compatible", "plugin", "transfer", "write", "ync", "custom", "slave", "use", "bit", "cache", "sy", "lock", "setup", "rc", "settings", "spec", "lag", "match", "Sync", "stage", "sort", "offset"], "has_mode": ["has__mode", " has_type", "has_type", " has_direction", " has_lane", "has_module", " has_module", "has__source", "has_lane", " has_source", "has__direction", "has_direction", "has_source", "has__type"], "mode": ["route", "view", "name", "phase", "class", "only", "kind", "object", "off", "language", "config", "scale", "option", "ui", "driver", "none", "layout", "message", "force", "style", "site", "plugin", "node", "no", "transfer", "model", "slave", "disable", "MODE", "enabled", "m", "data", "state", "unit", "number", "id", "code", "mod", "module", "direction", "role", "error", "grade", "stage", "multi", "group", "block", "Mode", "command", "theme", "type"], "has_speed": ["has_width", "has_time", "has_sync", "has_size", "have_width", "have_driver", "have_sync", "have_speed", "have_weight", "has_driver", "have_time", "has_weight", "have_size"], "speed": ["port", "name", "peed", "Speed", "connect", "scale", "gain", "driver", "cost", "performance", "power", "ress", "drive", "spin", "time", "seconds", "style", "access", "engine", "weight", "proxy", "address", "rate", "fps", "state", "lock", "score", "count", "index", "spec", "capacity", "second", "priority", "service", "error", "sw", "length", "mark", "grade", "stream", "frequency", "strength", "sort", "zero"], "has_on_source_error": ["has_on_scene_error", "has_on_source_info", "has_on_sourcealerror", "has_on_scene_err", "has_on_sourcealror", "has_on_scene_type", "has_on_sourcealdata", "has_on_source_type", "has_on_source_data", "has_on_parent_ror", "has_on_sourcealerr", "has_on_parent_error", "has_on_scene_info", "has_on_source_err", "has_on_parent_err", "has_on_source_ror", "has_on_parent_data"], "on_source_error": ["on_target_err", "on_source67function", "on_source_ror", "on_source67error", "on_SOURCE_ror", "on_SOURCE_function", "on_source_err", "on_source67err", "on_source67ror", "on_SOURCE_err", "on_target_bug", "on_SOURCE_error", "on_source_bug", "on_target_ror", "on_source_function"], "has_on_target_error": ["has_on_source_source", "has_on_target_type", "has_on_target_ror", "has_on_source_type", "has_on_targetapperror", "has_on_target_source", "has_on_targetappsource", "has_on_target_err", "has_on_source_err", "has_on_source_ror", "has_on_targetapperr", "has_on_targetappror"], "on_target_error": ["on_target_err", "on_source_ror", "on_target_server", "on_targeterserver", "on_targetbookerr", "on_targetbookerror", "on_targetercomplete", "on_source_err", "on_source_operation", "on_target_complete", "on_source_server", "on_target_ror", "on_target_operation", "on_source_complete", "on_targetererror", "on_targetbookoperation", "on_targetererr", "on_targetbookror"], "errp": ["lerP", " errf", "ErP", "errps", "errorfp", "errpr", "err", "Erpc", "lerpr", "errf", "finderps", "errorpc", " erp", "lerf", " errfp", "Erp", " errpc", "errfp", "errpc", "errP", "Err", " errps", "finderP", " erP", "erfp", "errorP", " errP", "errorr", " errpr", " erpr", "finderr", "lerp", "erp", "erP", "errr", "finderp", " erf", " errr", "erpc", "erps", "errorp"], "bs": ["obs", "bc", "pb", "sb", "bos", "outs", "bis", "conn", "obj", "fs", "db", "fb", "null", "bb", "bytes", "ops", "ks", "css", "ds", "bid", "bl", "bes", "bing", "bu", "s", "bas", "state", "os", "vs", "cs", "ts", "us", "ls", "bi", "abi", "bps", "settings", "js", "b", "bits", "blocks", "hub", "src", "ns", "bm", "BS", "iss", "ps", "rs", "gs", "banks", "ins", "lib", "bh", "http", "bus", "base", "ss", "las", "gb"], "target_bs": ["source_ds", "source_bs", "source_vs", "target_ds", "source_src", "target_vs", "target_src"], "source": ["remote", "status", "ident", "git", "ource", "port", "view", "security", "SOURCE", "object", "config", "driver", "text", "input", "origin", "site", "secure", "dist", "proxy", "master", "slave", "storage", "cache", "ssl", "component", "id", "inner", "client", "index", "spec", "ources", "family", "comp", "service", "core", "session", "src", "slice", "parent", "select", "dest", "Source", "resource", "image", "server", "scope", "interface"], "drv": ["srv", "rdvs", "hrva", "yrf", " drp", " drva", "drvs", "srf", "drp", "rdp", "drf", "yrp", "srvs", "drb", "DRf", "yrv", "srp", " drb", " drvs", "hrp", "hrv", "drvp", "hrvs", "prva", "DRvs", " drvp", "drva", "yrvs", "hrf", "hrvp", "srb", "DRv", " drf", "rdv", "prv", "DRp", "rdf", "prf", "hrb", "prvp"], "local_err": [" local_progress", "localxprogress", "local_error", "localxerror", "localxerr", "localxer", "local_er", "local_progress", " local_er", " local_error"], "flags": ["status", "delay", "types", "fs", "features", "seconds", "lines", "rules", "locks", "ops", "heads", "ds", "offset", "fps", "s", "args", "data", "cs", "errors", "ports", "stats", "Flags", "settings", "frames", "reads", " speeds", "bits", "cycles", "flag", "parts", "fl", "mask", "len", "options", "ps", "alls", "links", "files", "ips", "states"], "size": ["name", "security", "store", "scale", "Size", "engine", "ize", "weight", "ci", "pos", "address", "args", "code", "addr", "capacity", "go", "error", "loc", "grade", "sec", "SIZE", "stream", "empty", "pack", "cap", "zero"], "ret": ["delay", " fps", " success", "result", "Ret", " quiet", " failures", " timeout", "quiet", "res", " fs", "success", "rc", " bits", " wait", "RET", " rows", " mem", " disp", "rs", "wait", "nt", "sec", "rets"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688, "substitutes": {"opaque": ["OPaque", "opaques", "opca", "opsca", "OPaques", "copaques", "opsaques", "copaque", "iopaques", "ocaques", "opacle", "obaques", "ioponymous", "ocacle", "OPca", "obonymous", "obaque", "oconymous", "obacle", "OPac", "ocaque", "opac", "copca", "iopacle", "iopaque", "opsaque", "copac", "opsac", "oponymous"], "addr": ["route", "port", "name", "handle", "ast", "ino", "ref", "config", "hop", "adr", "arg", "mode", "oa", "afi", "amd", "pad", "host", "align", "node", "ea", "pos", "cmp", "r", "address", "data", "ad", "p", "arr", "ace", "point", "work", "slot", "dr", "index", "frame", "add", "rt", " address", "ptr", "x", "value", "sta", "error", "fd", "src", "len", "loc", "v", "sid", "pointer", "offset", "base", "type"], "val": ["rol", "sv", "ee", "fail", "key", "pos", "data", "vals", "var", "live", "pl", "pid", "mem", "slice", "ve", "test", "VAL", "v", "old", "eval", "str", "ind", "valid", "item", "text", "sol", "al", "pre", "enc", "unit", "code", "buf", "aval", "vol", "alt", "vl", "prop", "ival", "reg", "sel", "serv", "ref", "err", "tx", "it", "ret", "arr", "play", "p", "nil", "el", "num", "role", "error", "loc", "Val", "lit", "x", "start", "sl", "arg", "ol", "bl", "pal", "slot", "elt", "py", "index", "cal", "len", "pol", "update", "all", "pt", "base", "value"], "size": [" error", " bytes", "scale", "Size", "bytes", " arg", "data", "vals", " data", " type", "mem", " mem", " length", "length", "len", "VAL", "v", "SIZE", "eval", "type"], "s": ["i", "bis", "es", "uns", "ds", "sys", "y", "slave", "r", "address", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "S", "ns", "rs", "ins", "v", "conf", "instance", "l", "an", "ss", "sb", "g", "ses", "private", "d", "sets", "as", "services", "u", "state", "stat", "o", "sg", "c", "self", "a", "scope", "e", "sym", "serv", "sie", "fs", "f", "t", "p", "si", "b", "service", "ps", "gs", "secondary", "x", "sq", "status", "port", "sl", "your", "plugins", "local", "m", "socket", "sync", "is", "settings", "se", "session", "south", "server", "states"], "saddr": ["wsaddr", "sysalt", "sattr", "southlive", "paddr", "parg", "fsattr", "southhost", "sbaddress", " sdr", "slive", " spos", "fsalt", " sattr", "dlive", "player", "spos", "syslayer", " saddress", "daddr", "sysaddress", " sptr", "dhost", "paddress", "sespos", "fsptr", "sbarg", "saddress", " salt", "slayer", "fsaddr", "sesdr", "sysattr", "sbaddr", "sysptr", "sblayer", "wsaddress", "southaddr", "daddress", "sysarg", "sarg", "salt", "sdr", "wsdr", "shost", "wspos", "southaddress", "sesaddr", "sysaddr", "sptr", "sesaddress"]}}
{"project": "FFmpeg", "commit_id": "94bb1ce882a12b6d7a1fa32715a68121b39ee838", "target": 0, "func": "static int revert_channel_correlation(ALSDecContext *ctx, ALSBlockData *bd,\n\n                                       ALSChannelData **cd, int *reverted,\n\n                                       unsigned int offset, int c)\n\n{\n\n    ALSChannelData *ch = cd[c];\n\n    unsigned int   dep = 0;\n\n    unsigned int channels = ctx->avctx->channels;\n\n\n\n    if (reverted[c])\n\n        return 0;\n\n\n\n    reverted[c] = 1;\n\n\n\n    while (dep < channels && !ch[dep].stop_flag) {\n\n        revert_channel_correlation(ctx, bd, cd, reverted, offset,\n\n                                   ch[dep].master_channel);\n\n\n\n        dep++;\n\n    }\n\n\n\n    if (dep == channels) {\n\n        av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel correlation!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bd->const_block = ctx->const_block + c;\n\n    bd->shift_lsbs  = ctx->shift_lsbs + c;\n\n    bd->opt_order   = ctx->opt_order + c;\n\n    bd->store_prev_samples = ctx->store_prev_samples + c;\n\n    bd->use_ltp     = ctx->use_ltp + c;\n\n    bd->ltp_lag     = ctx->ltp_lag + c;\n\n    bd->ltp_gain    = ctx->ltp_gain[c];\n\n    bd->lpc_cof     = ctx->lpc_cof[c];\n\n    bd->quant_cof   = ctx->quant_cof[c];\n\n    bd->raw_samples = ctx->raw_samples[c] + offset;\n\n\n\n    dep = 0;\n\n    while (!ch[dep].stop_flag) {\n\n        unsigned int smp;\n\n        unsigned int begin = 1;\n\n        unsigned int end   = bd->block_length - 1;\n\n        int64_t y;\n\n        int32_t *master = ctx->raw_samples[ch[dep].master_channel] + offset;\n\n\n\n        if (ch[dep].time_diff_flag) {\n\n            int t = ch[dep].time_diff_index;\n\n\n\n            if (ch[dep].time_diff_sign) {\n\n                t      = -t;\n\n                begin -= t;\n\n            } else {\n\n                end   -= t;\n\n            }\n\n\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1    ]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp        ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1    ]) +\n\n                     MUL64(ch[dep].weighting[3], master[smp - 1 + t]) +\n\n                     MUL64(ch[dep].weighting[4], master[smp     + t]) +\n\n                     MUL64(ch[dep].weighting[5], master[smp + 1 + t]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        } else {\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp    ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        }\n\n\n\n        dep++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23692, "substitutes": {"ctx": ["lc", "bc", "git", "cam", "cc", "wcs", "support", "ia", "conn", "sci", "config", "ha", "pkg", "cv", "kt", "cm", "tx", "ca", "Context", "qq", "anc", "cas", "cmp", "ci", "nc", "cmd", "cp", "component", "cs", "xc", "cf", "ctrl", "kb", "context", "tc", "cli", "prefix", "sync", "rc", "cb", "cn", "client", "cfg", "sc", "cal", "dc", "service", "cci", "gc", "qa", "core", "fw", "loc", "cdn", "cca", "cus", "ku", "utils", "cycle", "cms", "qt", "ce", "hw", "ck", "kw", "concept", "cu", "vc"], "bd": ["md", "td", "bc", "sb", "lb", "gt", "edd", "board", "ade", "db", "wd", "d", "vd", "bb", "xd", "pd", "dh", "ld", "ds", "bl", "sth", "gd", "df", "cmd", "da", "dd", "nd", "hd", "ad", "bt", "cf", "bn", "kb", "od", "kk", "cb", "dt", "b", "dc", "dm", "dk", "dl", "ff", "fd", "bm", "nb", "di", "bf", "bh", "bot", "bs", "lf", "ke", "BD", "kel", "gb"], "cd": ["md", "td", "bc", "cc", "ct", "db", "cv", "cm", "d", "xd", "ca", "pd", "ld", "cand", "ci", "cmd", "cp", "da", "dd", "nd", "hd", "ad", "cf", "xc", "cle", "cs", "rc", "cb", "ecd", "dc", "cr", "fd", "cdn", "CD", "ck", "cod"], "reverted": ["retjected", "invert", "changeverted", "changearted", "prevert", "perverted", "recverts", "renverted", "perjected", "refverted", "convered", "converted", "converting", "retverts", "invered", "renerved", "reljected", "renverts", "reerved", "recverted", "perferred", "referred", "relverted", "refverting", "preverting", "reverting", "convert", "retvert", "recjected", "rearted", "recvert", "refarted", "renferred", "changevert", "relerved", "inverting", "revert", "reverts", "retverted", "revered", "refvert", "prevered", "pererved", "renjected", "inverted", "prearted", "relferred", "rejected", "renvert", "changeverting", "preverted"], "offset": ["adjust", "delay", "bound", "col", "i", "phase", "port", "start", "attribute", "end", "off", "ref", "part", "origin", "disabled", "pad", "fp", "f", "type", "pos", "ci", "order", "padding", "enabled", "address", "fee", "size", "data", "entry", "p", "o", "depth", "initial", "shift", "timeout", "cb", "index", "lag", "et", "edge", "set", "location", "online", "seq", "error", "Offset", "length", "len", "loc", " offsets", "reset", "alpha", "frequency", "clock", "scroll", "position", "base", "format", "url", "count"], "c": ["lc", "bc", "col", "fc", "i", "e", "cc", "uc", "ct", "config", "cent", "g", "chain", "com", "coll", "toc", "cm", "d", "con", "ca", "pc", "cur", "cl", "cu", "f", "ci", "cont", "t", "nc", "u", "ac", "s", "m", "size", "cache", "cat", "r", "p", "cs", "cf", "xc", "mc", "code", "tc", "q", "rc", "cn", "sc", "b", "dc", "cy", "channel", "cr", "n", "vc", "core", "center", "C", "v", "ce", "h", "cit", "l", "x", "ec", "k", "count"], "ch": ["cha", "bc", "col", "sch", "chn", "sk", "conn", "ach", "app", "cor", "coll", "part", "chan", "ich", "cm", "uch", "chi", "ca", "Ch", "che", "cl", "cand", "cmp", "ci", "cmd", "cp", "cht", "patch", "p", "cs", "cf", "CH", "chart", "code", "cle", "change", "q", "rc", "cb", "arch", "sh", "ver", "cho", "he", "cy", "tch", "channel", "cr", "zh", "gh", "th", "conf", "cher", "ce", "ech", "unch", "h", "inch", "ph", "vc"], "dep": ["upp", "bc", "Dep", "deb", "app", "config", "depend", "ipp", "gl", "df", "dist", "neg", "cp", "context", "pl", "dim", "cpp", "hl", "src", "ev", "attr", "col", "ind", "push", "db", "ctr", "de", "d", "bb", "op", "dir", "dev", "mod", "code", "rc", "ext", "sc", "du", "deep", "dc", "dq", "channel", "desc", "oc", "dp", "ph", "grad", "uc", "ref", "com", "mode", "rec", "ld", "f", "cmp", "cmd", "nd", "tc", "depth", "day", "comp", "ptr", "imp", "loc", "req", "view", "egg", "category", "inc", "decl", "ca", "cur", "cl", "nc", "pp", "ep", "id", "change", "dr", "supp", "pull"], "smp": ["smc", "dmb", " sp", "jscap", "ssmb", "sMP", " sape", "psmp", "dsmc", "dsmb", "ssmp", "smb", "Smp", "dmp", " scap", "jsupp", " sme", "Smb", "Scap", "Sape", "dsamp", "ssMP", " sMP", "dsmp", "scap", "isupp", "psmb", " smb", "dupp", "supp", "Supp", "ssape", "sme", " supp", "isp", " smc", "jsmp", "SMP", "ismp", " samp", "ismb", "jsme", "psamp", "sp", "psmc", "dp", "samp", "Sme", "sape"], "y": ["sky", "ya", "i", " x", "yn", "vy", "yy", "ay", "ny", "yo", "yr", "ey", "t", "m", "oy", "j", "sy", "ys", "ip", "p", "gy", "year", "dy", "py", "ye", "iy", "Y", "ym", "ype", "zy", "fy", "cy", "n", "yl", "yi", "z", "ies", "x", "type"], "master": ["target", "table", "me", "wave", "mon", "node", "bl", "dist", "r", "pre", "m", "prefix", "mm", "mid", "Master", "ss", "num", "worker", "top", "mx", "test", "total", "parent", "all", "server", "tail", "masters", "type"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n", "idx": 23696, "substitutes": {"hpet": [" hpret", "phPet", "adhpit", "Hpit", "hrpet", " hped", "Hvet", "affett", "bhpel", "affpel", "helpit", "phpet", "hett", "hrPet", "Hpel", "hepel", "hmpel", "hmett", "hrped", " hPet", "hwpit", "bhpit", "adhpret", "hwpret", "phped", "hepret", "adhpet", "hppel", "hrpit", "bhped", "phpel", " hpit", "hpPet", "bhpret", "hppet", "hpit", "adhpel", "heett", "hepet", "hvet", " hpel", "hmpret", "bhPet", "hpel", "phpit", "hwpet", "hppit", "hwpel", "hmpet", "affpet", " hvet", "affpret", "hpret", "Hpet", "helpet", "helped", "phpret", "helpel", "hped", "bhpet", "hwvet", "hPet"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;\n\n    }\n\n}\n", "idx": 23704, "substitutes": {"samples": [" sample", " sumpy", "sample", "asums", " siments", "gumpy", "asamples", "asamps", "gamples", " samps", " ssample", "siments", "ssamp", "pamples", "swample", "exients", " samp", "samp", "pamp", "pources", "examps", "sints", "sients", "emodels", "sums", "eiments", "anspling", "swmodels", "sources", "piments", "ssample", "examples", "Samps", "gamps", "pumpy", "gample", "eample", " sints", "ssums", "pample", "ansamples", "Sums", "ansiments", "spints", "saves", "assample", "spamps", "ssaves", "spamples", "samps", "eamples", "smodels", "swiments", " spling", "sumpy", "spaves", " sources", "psample", "ssamples", "ansamps", "pamps", "ssints", "pients", "ssamps", "Samples", " sients", " saves", "Samp", " sums", " smodels", "ppling", "spling", "asamp", "exources", "swamples", "pums"], "i": ["io", "ami", "e", "ix", "ie", "fi", "qi", "ri", "ui", "val", "mini", "pi", "key", "ki", "gi", "d", "uri", "ti", "I", "type", "f", "ci", "t", "r", "u", "m", "ini", "info", "j", "phi", "init", "oi", "it", "p", "abi", "ip", "id", "bi", "inner", "cli", "c", "mu", "index", "source", "si", "a", "ii", "b", "in", "length", "iu", "slice", "ai", "xi", "hi", "di", "v", "multi", "z", "li", "h", "api", "l", "x", "zi", "ni", "count"]}}
{"project": "FFmpeg", "commit_id": "cd1047f3911fa0d34c86f470537f343d23c8b956", "target": 0, "func": "static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    const AVPixFmtDescriptor *desc;\n\n    mfxSession session = NULL;\n\n    int iopattern = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n    int frame_width  = avctx->coded_width;\n\n    int frame_height = avctx->coded_height;\n\n    int ret;\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!desc)\n\n        return AVERROR_BUG;\n\n\n\n    if (!q->async_fifo) {\n\n        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));\n\n        if (!q->async_fifo)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {\n\n        AVQSVContext *user_ctx = avctx->hwaccel_context;\n\n        session           = user_ctx->session;\n\n        iopattern         = user_ctx->iopattern;\n\n        q->ext_buffers    = user_ctx->ext_buffers;\n\n        q->nb_ext_buffers = user_ctx->nb_ext_buffers;\n\n    }\n\n\n\n    if (avctx->hw_frames_ctx) {\n\n        AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;\n\n\n\n        if (!iopattern) {\n\n            if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)\n\n                iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;\n\n            else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)\n\n                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;\n\n        }\n\n\n\n        frame_width  = frames_hwctx->surfaces[0].Info.Width;\n\n        frame_height = frames_hwctx->surfaces[0].Info.Height;\n\n    }\n\n\n\n    if (!iopattern)\n\n        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;\n\n    q->iopattern = iopattern;\n\n\n\n    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;\n\n    param.mfx.FrameInfo.FourCC         = q->fourcc;\n\n    param.mfx.FrameInfo.Width          = frame_width;\n\n    param.mfx.FrameInfo.Height         = frame_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0)\n\n        return ff_qsv_print_error(avctx, ret,\n\n                                  \"Error initializing the MFX video decoder\");\n\n\n\n    q->frame_info = param.mfx.FrameInfo;\n\n\n\n    return 0;\n\n}\n", "idx": 23714, "substitutes": {"avctx": ["ajcv", "devcontext", "avecu", "aveconfig", "aveloc", "AVconfig", "AVcmp", "avcv", "vercontext", "vercu", "ajcontext", "devcmp", "verconn", "avsq", "afctl", "averctl", "afcmp", "avconn", "verctx", "avconfig", "AVcontext", "afctx", "avercontext", "AVcu", "Avconfig", " avbc", "averctx", "navctx", "Avcontext", "AVclient", "avecontext", " avcmp", "aveclient", " avsq", "afcu", "avbc", "avecv", "afsq", "Avcu", "AVsq", "avcu", "avcontext", "navconn", "avctl", "AVconn", "vercmp", "averconn", "navctl", "avclient", " avloc", "AVbc", "afconfig", "devconfig", "ajctx", "avectx", "avcmp", "Avctx", "navcmp", "afcontext", "AVctx", "AVcv", "afconn", " avcontext", "ajclient", "avebc", "AVloc", "devctx", "navcontext", "avloc"], "q": ["request", "view", "query", "qs", "qi", "conn", "eq", "config", "g", "input", "Q", "post", "ack", "queue", "d", "qq", "get", "f", "t", "u", "cmd", "m", "ue", "qu", "ad", "p", "cf", "que", "context", "client", "c", "ctx", "self", "ch", "cal", "dq", "window", "question", "w", "quant", "quest", "qa", "session", "iq", "req", "batch", "v", "qt", "conf", "z", "user", "h", "sq", "k", "requ"], "desc": ["lc", "bc", "fc", "name", "def", "esc", "uc", "config", "asc", "text", "meta", "der", "de", "d", "func", "rec", "cur", "anc", "dep", "dist", "env", "info", "dir", "nc", "description", "enc", "code", "comment", "ext", "rc", "la", "cb", "sc", "sub", "des", "dc", "session", "loc", "req", "doc", "sec", "Desc", "disc", "ec", "fun"], "ret": ["reg", "def", "valid", "result", "progress", "aud", "rep", "rec", "Ret", " quiet", " resp", "res", "cat", "arr", "success", "match", "RET", "flag", "re", "error", "alt", "sec", "resp", "fun"], "user_ctx": [" user_cmp", "use_cu", "user_cmp", "useringctx", " user_loc", "use_xc", "useringcontext", " user_conn", "user_wcs", "user_kb", "user_anc", " user_chan", "useringloc", "use_ctx", "useringcu", "user_xc", "use_wcs", " user_cu", "use_context", "use_kb", "user_chan", "user_cu", "user_loc", "use_cmp", " user_anc", "user_conn", "use_loc", "user_context"], "frames_ctx": ["frames___pkg", "flows_vc", "frames_vc", "flows_ctx", "frames_loc", "frames___vc", "frames_pkg", "frames___context", "flows_loc", "frames_ci", "flows_pkg", "frames_context", "flows_ci", "flows_context", "frames___ctx"], "frames_hwctx": ["frames_nvcontext", "frames_iwcf", "frames_nvctx", "frames_vcctx", "frames_hopcmd", "frames_vccf", "frames_hwcmd", "frames_hwrx", "frames_hhcmd", "frames_hwcontext", "frames_hmconfig", "frames_fwcontext", "frames_hopcontext", "frames_memconfig", "frames_navconfig", "frames_navcb", "frames_hwcf", "frames_iwcontext", "frames_fwchan", "frames_cowctx", "frames_hoprx", "frames_fwcmd", "frames_fwctx", "frames_cowchan", "frames_fwrx", "frames_hmctx", "frames_nvcp", "frames_nvchan", "frames_hhctx", "frames_hopctx", "frames_iwcb", "frames_hwcp", "frames_hwsec", "frames_hhcontext", "frames_vcconfig", "frames_navcontext", "frames_navctx", "frames_cowcp", "frames_iwsec", "frames_iwctx", "frames_iwconfig", "frames_cowcontext", "frames_hmcontext", "frames_hhrx", "frames_hwconfig", "frames_hwcb", "frames_fwcp", "frames_hwchan", "frames_memctx", "frames_memsec", "frames_hmcb", "frames_vcsec", "frames_memcf"]}}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n", "idx": 23744, "substitutes": {"proxy": ["io", "remote", "route", "port", "native", "ruby", "Proxy", "wrapper", "linux", "driver", "pe", "connection", "queue", "uri", "cop", "plugin", "bridge", "slave", "phy", "address", "cache", "zip", "component", "client", "pool", "pse", "plug", "pro", "gp", "service", "library", "core", "slice", "proc", "http", "lib", "manager", "resource", "image", "server", "clip", "api", "base", "pa"], "region": ["remote", "route", "span", "reg", "port", "native", "area", "ort", "config", "project", "connection", "account", "feature", "plugin", "node", "local", "transfer", "ion", "section", "ale", "address", "ortex", "cache", "version", "component", "unit", "zone", "memory", "module", "dim", "role", "service", "REG", "location", "slice", "range", "Region", "report", "manager", "array", "group", "resource", "gap", "image", "scope", "environment", "folder", "record", "server", "script", "format", "country"], "cap": ["span", "bc", "ap", "fac", "app", "config", "scale", "acl", "fab", "ha", "aps", "map", "cube", "rap", "CAP", "card", "feature", "ca", "cop", "access", "cl", "cas", "can", "cmp", "lan", "acc", "ac", "cat", "data", "cache", "Cap", "size", "p", "cf", "ip", "ace", "caps", "mac", "tool", "ext", "spec", "cfg", "capacity", "mp", "core", "pac", "cast", "ab", "ape", "car", "gap", "clip", "feat", "capt"]}}
{"project": "qemu", "commit_id": "d044be3714db9c3750c430a2bb1be74beee6fd27", "target": 0, "func": "static void mixer_reset (AC97LinkState *s)\n\n{\n\n    uint8_t active[LAST_INDEX];\n\n\n\n    dolog (\"mixer_reset\\n\");\n\n    memset (s->mixer_data, 0, sizeof (s->mixer_data));\n\n    memset (active, 0, sizeof (active));\n\n    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n\n    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n\n    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n\n\n\n    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n\n    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n\n    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n\n    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n", "idx": 23747, "substitutes": {"s": ["sv", "i", "es", "config", "xs", "temp", "ds", "sys", "r", "tp", "os", "ssl", "ts", "us", "stats", "js", "S", "ns", "rs", "v", "http", "l", "this", "ss", "an", "sb", "g", "ses", "d", "sets", "site", "services", "u", "stat", "current", "o", "sites", "sg", "c", "self", "spec", "sf", "native", "e", "sym", "qs", "tests", "hs", "fs", "f", "t", "full", "new", "p", "groups", "b", "service", "parts", "gs", "h", "secondary", "sq", "status", "sl", "your", "plugins", "m", "its", "storage", "ls", "sync", "is", "settings", "w", "sing", "session", "south", "states"], "active": ["status", "confirmed", "stable", "valid", "g", "playing", "activate", "progress", "null", "IVE", "ops", "mobile", "enabled", "fresh", "Active", "data", "cache", "args", "full", "play", "act", "current", "actions", "activity", "ents", "arr", "activation", "cli", "open", "memory", "live", "waves", "index", "complete", " inactive", "pass", "connected", "volt", "activated", "seq", "activ", "available", "visible", "events", "running", "selected", "empty", "all", "output", "acs"]}}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "lb", "bis", "fs", "ses", "ubs", "mb", "fb", "bb", "bytes", "ops", "as", "bid", "bl", "ds", "bes", "css", "fps", "s", "bas", "its", "state", "os", "bt", "vs", "cs", "ls", "bi", "bps", "ctx", "b", "bits", "sub", "blocks", "ms", "ns", "BS", "iss", "ps", "rs", "gs", "boot", "bh", "rb", "base", "ss"], "offset": ["delay", "phase", "limit", "start", "attribute", "off", "ref", "option", "part", "mode", "connection", "bytes", "type", "pos", "order", "alloc", "entry", "address", "size", "data", "ip", "number", "prefix", "slot", "addr", "initial", "url", "shift", "index", "num", "set", "location", "seq", "error", "Offset", "length", "slice", "len", "loc", "reference", "range", "reset", "from", "pointer", "clock", "block", "position", "offer", "base", "sort", "padding"], "count": ["col", "found", "name", "cc", "limit", "start", "ref", "amount", "part", "mount", "cond", "force", "key", "queue", "process", "weight", "f", "type", "Count", "size", "cache", "list", "sum", "number", "id", "code", "depth", "timeout", "content", "c", "index", "first", "counter", "seq", "error", "child", "length", "call", "total", "len", "large", "parent", "group", "base", "max"], "co": ["col", "ra", "cc", "oo", "oe", "ri", "coll", "con", "ca", "pc", "can", "po", "ci", "cmp", "ro", "ac", "mo", "cache", "ob", "ico", "mc", "cf", "oper", "o", "code", "py", "coe", "c", "rc", "aco", "Co", "bo", "CC", "call", "flo", "loc", "cca", "CO", "ko", "ck", "oc", "cu", "fo"], "aio_context": ["aios_context", "aio__sc", "aios_sc", "aio_sc", "aio_environment", "aiopenvironment", "aio_package", "aio__context", "aio__connection", "aio_connection", "aioppackage", "aio__ctx", "aiopcontext", "aiopctx", "aios_connection", "aio_ctx", "aios_ctx"]}}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n", "idx": 23758, "substitutes": {"env": ["priv", "ception", "enh", "e", "org", "chn", "en", "end", "conn", "obj", "err", "config", "eu", "iv", "eni", "event", "db", "eng", "energy", "engine", "ea", "ef", "eye", "esi", "exc", "ah", "nc", "dev", "init", "eb", "her", "enc", "ep", "uv", "que", "np", "context", "Environment", "buf", "rc", "kn", "ctx", "el", "c", "et", "equ", "enable", "viron", "console", "fen", "v", "ner", "anne", "vm", "erv", "estate", "ev", "environment", "inet", "ec"], "addr": ["az", "config", "amp", "part", "ord", "amd", "pad", "device", "pos", "dist", "order", "address", "data", "prefix", "work", "cpu", "alias", "src", "proc", "pointer", "clock", "sta", "attr", "inter", "str", "db", "pkg", "ack", "oa", "rx", "align", "node", "coord", "ad", "ext", "arch", "rt", "offset", "md", "grad", "ref", "adr", "xxx", "host", "intel", "ld", "layer", "cmp", "adder", "cmd", "dd", "arr", "ace", "edge", "ptr", "usr", "ne", "hop", "rr", "socket", "aug", "id", "dr", "ctx", "index", "frame", "ady", "ar", "vr", "seq", "server", "url"], "val": ["ival", "ra", "sel", "ee", "fail", "ref", "err", "sl", "valid", "il", "wa", "part", "db", "tx", "as", "buffer", "pos", "al", "pre", "r", "entry", "data", "rel", "stat", "ret", "arr", "na", "vals", "vi", "elt", "var", "au", "la", "rot", "el", "index", "aval", "pid", "x", "b", "rt", "vol", "call", "va", "len", "loc", "VAL", "Val", "v", "up", "old", "isal", "eval", "pt", "base", "value"]}}
{"project": "FFmpeg", "commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "target": 1, "func": "int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 23762, "substitutes": {"w": ["e", "ow", "wa", "wd", "d", "ww", "weight", "f", "u", "r", "m", "s", "wh", "p", "wl", "we", "work", "aw", "q", "rw", "W", "c", "sh", "a", "b", "wt", "n", "sw", "fw", "wx", "v", "z", "hw", "l", "x", "max"], "h": ["ih", "hm", "ph", "hs", "ha", "han", "d", "oh", "host", "f", " H", "ah", "u", "m", "kh", "hd", "p", "rh", "q", "uh", "H", "c", "sh", "ch", "hr", "b", "hl", "n", "gh", "th", "hi", "v", "bh", "z", "l", "x", "max", "ht", "hh"], "sar": ["resolutionari", "fare", "ssare", " saru", "sars", " sAR", "psart", "ssear", "sari", "sumiar", "larl", "psare", "dsara", "dsari", "sir", " sear", "pare", "tear", "sumaru", "nsari", " sars", "psara", " shar", "ssari", "sslaru", "far", "ssar", "lir", "sumar", "dsare", "parl", "lsar", "ssars", "sear", "wara", "sarp", "ingsar", "lAR", "lar", "sare", "ingsiar", "dsar", "asara", "yara", "war", "resolutioniar", "psar", "shar", "tar", "siar", "sslar", "pari", "yare", "osarp", "ingsari", "sslart", "sart", "phar", "sara", "ssarl", " sart", "fart", "ssarp", "para", "lsara", "laru", "nsara", "ingsaru", "wari", " sarl", "esarl", "psir", "psAR", "yar", "lshar", "saru", "lari", "paring", "tars", "psari", "resolutionar", "parp", "sslarl", "sumari", "osari", "fara", "asarp", "lsaring", "esara", "psarp", " saring", "asarl", "sAR", " sara", "yari", "asar", "nsare", "tarl", "lart", "esarp", " sari", "nsar", "resolutionaru", "esar", "ware", "nsart", "saring", "par", "osar", "sarl", " sir", "osara", "ssara"], "scaled_dim": ["scaled__dm", "scalled_di", "scaled_orig", "scaled_shape", "scalled_dim", "scaled_grad", "scaled_lim", "scaled___num", "scaled___di", "scalled_num", "scaled__shape", "scaled___mem", "scaled__dim", "scalled_lim", "scalled_shape", "scaled___dim", "scaled_num", "scalled_dm", "scalled_mem", "scaled__lim", "scaled_dm", "scaled__num", "scalled_orig", "scaled_di", "scaled__orig", "scalled_grad", "scaled_mem"]}}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n", "idx": 23769, "substitutes": {"s": ["ions", "sv", "sb", "e", "sym", "bis", "es", "qs", "hs", "fs", "g", "ses", "com", "ubs", "rates", "d", "sets", "ops", "site", "ks", "ds", "services", "f", "sys", "t", "r", "u", "m", "res", "args", "ssl", "strings", "ts", "cs", "p", "os", "ls", "sync", "is", "ss", "sites", "c", "ctx", "js", "settings", "si", "sr", "b", "a", "service", "re", "session", "S", "ns", "comments", "sf", "side", "ps", "rs", "gs", "http", "conf", "l", "times", "sq", "gb"], "count": ["col", "found", "name", "limit", "cc", "e", "start", "err", "ind", "loop", "coll", "cond", "force", "key", "process", "type", "offset", "weight", "f", "Count", "size", "cache", "list", "current", "sum", "number", "id", "code", "depth", "find", "pool", "c", "close", "num", "low", "b", "counter", "seq", "core", "n", "child", "length", "len", "call", "cast", "base", "conf", "scroll", "all", "l", "max"], "i": ["io", "lc", "e", "ix", "qi", "ind", "ui", "eni", "gu", "pi", "init", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "y", "oi", "u", "ini", "phi", "m", "j", "info", "adi", "it", "data", "p", "ip", "abi", "id", "diff", "o", "bi", "cli", "mi", "c", "index", "si", "a", "ii", "b", "x", "ji", "n", "iu", "slice", "ai", "xi", "ei", "di", "v", "multi", "li", "api", "ie", "fi", "zi", "ni"]}}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n", "idx": 23771, "substitutes": {"mr": ["md", "ra", "err", "adr", "Mr", "rr", "yr", "lr", "r", "m", "arr", "mc", "rh", "las", "rw", "dr", "nr", "rm", "fr", "shr", "RR", "sr", "rt", "vr", "hr", "usr", "er", "bm", "mx", "br", "try", "gr", "rs", "kr", "mk", "MR", "mn", "rg"]}}
{"project": "qemu", "commit_id": "be18b2b53ebbf2eb3f00e7890d0b9ff8b58d22bf", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n        env->error_code = 0x10000000;\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x40000000;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (rwx == 1) {\n\n                env->spr[SPR_DSISR] = 0x42000000;\n\n            } else {\n\n                env->spr[SPR_DSISR] = 0x40000000;\n\n            }\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x08000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 23779, "substitutes": {"cpu": ["lc", "platform", "bench", "hp", "net", "cc", "gpu", "conn", "linux", "GPU", "nic", "kernel", "performance", "kt", "processor", "process", "pc", "CPU", "intel", "fp", "node", "cmp", "sys", "nc", "cp", "cache", "component", "uci", "np", "cli", "cow", "rc", "c", "ctx", "cn", "roc", "gp", "comp", "ocr", "loader", "cpp", "core", "gc", "auc", "chip", "boot", "proc", "vm", "hw", "clock", "pu", "ec"], "eaddr": ["eadhr", "efder", "ecder", "eedld", "elldr", "eeddat", "epDR", "oadstr", "eedder", "epder", "avtr", "oadder", "eadDr", "efDR", "ellbr", "aybr", "ecdr", "leddr", "endtr", "efdr", "oaddr", "ewayder", "eftr", "ellDR", "epdr", "efbr", "efstr", "eedr", "eadstr", "eeDr", "ellder", "aystr", "ewayhr", "ledDR", "avdr", "eyDR", "eeDR", "ewaydat", "eedDr", "avDR", "eedhr", "ledder", "epbr", "eadbr", "elldat", "eeddr", "eydr", "aydr", "eaddat", "eadld", "efDr", "eadder", "ayder", "ledld", "ellhr", "ecDR", "eadDR", "eyld", "enddr", "eedDR", "endDR", "eyder", "ecbr", "eeder", "endder", "oadbr", "ewaydr", "avder", "eadtr"], "rwx": ["rhX", "rrx", "rnx", "wnx", "wxx", "RWf", "nwf", "RWy", "wwy", "rnX", "wny", "wxxes", "wnX", "rhxes", "rrX", "rackX", "RW1", "racky", "rwv", "rwxes", "wwv", "wn1", "wrxp", "rhx", "rwxp", "rackx", "rhv", "rwy", "rny", "wwX", "nwy", "wwx", "wxxp", "wrX", "wrx", "nwx", "rhxp", "rnz", "RWX", "rhz", "RWv", "RWz", "RWx", "rh1", "RWxp", "rackax", "rwz", "rhy", "wxz", "rry", "rrxp", "nwX", "rhf", "rwX", "wxX", "wry", "rwf", "nwxes", "rw1", "wxy", "rhax", "rwax", "RWax"], "mmu_idx": ["mmu_sidxc", "mmu_idc", "mmu_sidv", "mmu_idz", "mmu_midy", "mmu_idxc", "mmu_idsz", "mmu_namec", "mmu_idsw", "mmu_idw", "mmu_midw", "mmu_idsy", "mmu_aidx", "mmu_namexc", "mmu_aidc", "mmu_idy", "mmu_namev", "mmu_idsx", "mmu_sidc", "mmu_sidx", "mmu_aidxc", "mmu_midx", "mmu_namex", "mmu_idv", "mmu_aidv", "mmu_midz"], "cs": ["lc", "bc", "ras", "cc", "wcs", "Cs", "qs", "sk", "conn", "ix", "fs", "cons", "ca", "ks", "css", "pc", "ds", "cas", "CS", "ci", "sys", "ac", "cp", "args", "cache", "cases", "vs", "cf", "ts", "ls", "sync", "ss", "rc", "c", "ctx", "self", "spec", "js", "cn", "sc", "ics", "core", "ns", "cus", "utils", "ps", "rs", "gs", "acks", "cms", "ce", "bs", "ck", "ec", "acs", "vc"], "env": ["bc", "net", "e", "en", "es", "forge", "conn", "err", "eu", "config", "eni", "kernel", "db", "cv", "esp", "energy", "style", "site", "export", "engine", "ea", "eve", "ef", "exc", "nc", "s", "args", "dev", "cache", "state", "enc", "vs", "ace", "assets", "js", "context", "np", "cli", "Environment", "ss", "rc", "En", "agent", "c", "spec", "et", "cfg", "el", "equ", " environment", "enable", "gui", "cal", "core", "viron", "session", "ass", "console", "utils", "skin", "v", "qt", "conf", "ne", "estate", "server", "environment", "scope", "ev", "ec", "here"], "slb": ["islb", "selc", "SLbs", "slbs", "SLp", "sla", "snp", "helk", "clk", " sla", " slc", "Slbd", "islB", "slbb", "hlbb", "slB", "snb", "slc", "selbs", "slfb", "clb", " slab", "Slb", "SLib", "SLbd", "clba", "SLa", "slib", "helb", "SLfb", "SLB", "slab", "islab", "helc", "SLab", "slbd", "islbd", "hlb", "Slab", " slbb", "SLc", "helba", "islib", "selb", " slfb", "slba", "snc", "clc", " slba", "islfb", "islbb", "snbs", "slp", "SLb", "isla", " slib", "selp", "hlab", " slk", "SlB", "slk"], "pte_offset": ["ptee_Offset", "pte_slice", "pte_Offset", "ptee_shift", "ptE_ref", "pte_ref", "pte_position", "ptee_offset", "ptE_slice", "pte_length", "ptee_length", "pte_len", "ptE_Offset", "ptE_position", "pte_shift", "ptE_length", "ptE_len", "ptE_offset"], "pte": ["nte", " pted", "ptae", "PTes", "pted", "ipte", " ptae", "ptE", "ptes", "nted", "ppae", "pped", "PTae", "PTe", "PTl", "ntes", "ppe", "iptes", " ptl", "PTE", "ptl", "iptE", "PTed", "ipted", "ntE", "ppl"], "pp_prot": ["cp_rot", "pp_phys", "cp_ptr", "cp_phys", "pp_ptr", "cp_prot", "pp_rot"], "amr_prot": ["aml_channel", "aml_seq", "aml_prot", "amr_seq", "aml_pointer", "amr2prot", "amr_channel", "amr2channel", "amr_pointer", "amr2pointer", "amr2seq"], "prot": ["io", "ocol", "port", "pb", "period", "txt", "ref", "config", "sil", "transfer", "phy", "stat", "ret", "prefix", "rot", "ext", "header", "pri", "seq", "channel", "fl", " protocol", "Prot", "reset", "server", "att", "prop"], "new_pte1": ["new_ptu4", "new_ctE4", "new_pte2", "new_ptes4", "new_ptu1", "new_cte4", "new_cte1", "new_pte4", "new_cte2", "new_ptes1", "new_ptu2", "new_ptE1", "new_ptes2", "new_ptE4", "new_ptE2", "new_ctE1", "new_ctE2"], "need_prot": ["nn_conn", "nn_stat", "pp_stat", "pp_conn", "nn_channel", "nn_prot", "pp_channel"], "raddr": ["paddr", "rpad", "ppad", "pptr", " rptr", "Raddr", "padr", " raddress", "pada", "rptr", "Rptr", "raddress", "rraddress", "rrptr", "paddress", "rada", "rrada", "radr", "Raddress", "rraddr", " rpad", "sraddr", " rada", "Rpad", "sradr", "sraddress", "Radr", "srpad"]}}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    uint8_t const *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin = AV_RL16(buf+ 4);\n\n    ymin = AV_RL16(buf+ 6);\n\n    xmax = AV_RL16(buf+ 8);\n\n    ymax = AV_RL16(buf+10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf+66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes<<8) + bits_per_pixel) {\n\n        case 0x0308:\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            break;\n\n        case 0x0108:\n\n        case 0x0104:\n\n        case 0x0102:\n\n        case 0x0101:\n\n        case 0x0401:\n\n        case 0x0301:\n\n        case 0x0201:\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                ptr[3*x  ] = scanline[x                    ];\n\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        for (y=0; y<h; y++, ptr+=stride) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto end;\n\n        }\n\n\n\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n", "idx": 23786, "substitutes": {"avctx": ["avcam", "AVkb", "avesync", "aveloc", "avcv", "afcc", "vercontext", " avcv", "avsync", "afnp", "AVcp", "verconn", "avcca", "verctx", "avconn", "avecc", "avcp", "avecp", "afctx", "AVcontext", "avercontext", "avercca", "vercam", "AVsync", "avercas", "avcas", "AVnp", "afloc", "avnp", "averctx", "avercam", "versync", "avecontext", "avalcas", "AVcca", "avekb", "avecv", "verkb", "avcontext", "AVconn", "avenp", " avcc", "averconn", " avconn", "avalctx", " avloc", "avalcca", "avectx", "AVcam", "afcontext", "AVctx", "afconn", "avalcontext", " avcontext", "afcv", "avkb", "afcp", "aveconn", "avcc", "AVcas", "avloc"], "data": ["package", "start", "next", "sample", "config", "result", "input", "val", "text", "Data", "connection", "queue", "d", "meta", "pad", "buffer", "results", "pos", "entry", "size", "cache", "body", "record", "open", "content", "client", "memory", "frame", "audio", "module", "window", "DATA", "channel", "read", "media", "reader", "database", "batch", "feed", "buff", "parent", "doc", "proc", "dat", "image", "block", "api", "base", "video", "value"], "data_size": ["data_name", " data_capacity", " data_len", " data_name", "data_capacity", "data_len"], "avpkt": ["avskt", "avesck", "avpnt", "abfacket", "aveppsth", "aveppnt", "avepck", "avcft", "avfck", "abfft", "avpck", "abfct", "abpacket", "avPacket", "avepnt", "avesacket", "avfkt", "avcpkt", "avPsth", "abfkt", "avPnt", "avcct", "abpkt", "avfct", "avcpft", "avpft", "avssth", "avfacket", "avpct", "avppsth", "aveskt", "avppnt", "avcpnt", "avsacket", "avsck", "avPck", "avfsth", "avppacket", "aveppkt", "avcpsth", "aveppacket", "avepsth", "avpsth", "avepacket", "avessth", "avcpct", "avckt", "avfft", "abpft", "avcpacket", "avPkt", "abpct", "avpacket", "avppkt", "avcacket", "avepkt"], "buf": ["conv", "begin", "bc", "uint", "port", "uf", "prop", "uc", "brace", "config", "text", "pkg", "cv", "fb", "queue", "func", "utf", "pad", "Buff", "img", "cur", "cas", "home", "buffer", "gb", "uber", "alloc", "coord", "cmd", "grab", "tab", "box", "cf", "uv", "context", "wb", "pool", "c", "cb", "ctx", "plug", "aux", "b", "window", "bo", "tmp", "usr", "seq", "fd", "src", "wav", "br", "bd", "loc", "ab", "feed", "batch", "aka", "buff", "proc", "chrom", "bag", "vec", "rb", "dest", "block", "fam", "feat", "cap", "pub"], "s": ["sky", "sv", "sb", "e", "space", "sl", "fs", "g", "d", "as", "ds", "ages", "f", "r", "m", "size", "j", "os", "ssl", "cs", "o", "q", "sa", "sg", "c", "sq", "pass", "si", "a", "b", "S", "sup", "sf", "ps", "rs", "v", "conf", "sec", "l", "ss", "share"], "picture": ["camera", "package", "summary", "cam", "space", "fine", "obj", "movie", "config", "mini", "meta", "uri", "piece", "feature", "Picture", "style", "img", "buffer", "pict", "info", "gallery", "pic", "detail", "ctx", "frame", "brush", "family", "gui", "profile", "conference", "library", "media", "details", "plan", "definition", "avi", "image", "photo", "guide", "base", "video"], "p": ["pb", "port", "e", "g", "pi", "d", "P", "pd", "pc", "fp", "f", "r", "m", "it", "o", "np", "py", "c", "mp", "a", "b", "ps", "proc", "v", " P", "vp", "l"], "compressed": [" uncompression", "suppressor", "ompacted", " composed", "compressor", " compacted", " compression", "ompressed", " uncompressor", "ompression", "suppacted", "suppressed", "suppression", " decompacted", " decompressed", "expressed", " decomposed", "expacted", " uncompressed", "compacted", " uncompacted", "composed", "expression", " decompression", "expressor", "omposed", "compression"], "xmin": ["Xmax", "ystart", " xstart", "ixpos", "wmin", "exMin", "xmins", "exmin", "Xmin", "wmax", " xmini", "xmini", "wmins", "ixmax", "xstart", "Xstart", "ypos", " xpos", "ixmin", " xMin", "wpos", " xinit", "xMin", "wMin", "ymini", "xinit", "exmax", "ymins", "yMin", "Xmini", "yinit", "ixinit", "xpos", "exmins"], "ymin": ["xonly", "y0", "ystart", "Ymini", " yname", "sypos", "eymax", "symini", "xmean", "syonly", "systart", "eypos", "sy0", "eymean", "eyonly", "yonly", "yname", "Y0", " y0", "Ymax", "ypos", "xname", "Ymin", " yonly", "Yname", "eymin", " ystart", "Ystart", " ymean", "ymini", " ymini", "symin", "symax", "xpos", "ymean"], "xmax": ["Xend", "Xmax", "xxend", "yMAX", "axend", "xMAX", "xxax", "exmin", "Xmin", "Xdiv", "dxmad", "xxmax", "dxmax", "xdiv", " xmad", " xlast", "xxlast", "exend", "xlast", "yend", "axdiv", "xend", " xdiv", "dxend", " xMAX", "xax", "exMAX", "xxmad", "dxax", "xxmin", " xend", "exmax", "Xlast", "axmax", "xmad", " xax", "axmin"], "ymax": ["atemail", "iamail", "ymmak", "tmack", "ymand", "ymass", "iamack", "ymaz", "tmax", "atemade", "imak", "ammax", "iemax", "yrax", "iemand", "ymak", "ammail", "imase", "mmaz", "ymmaz", "iemaz", "ymmap", "ymaze", "ymmand", "ymake", "ymase", "yrass", "iamake", "ymack", "imax", "mmap", "iamax", "yahass", "ymade", "yrak", "yraze", "iamase", "mmand", "iamak", "mmax", "iamade", "ymmax", "atemax", "ammade", "yahax", "ymap", "tmase", "tmak", "iemap", "ymail", "yahaze", "atemake", "ymmaze", "yahak", "ammake", "imack", "ymmass"], "w": ["how", "ow", "g", "week", "wa", "d", "wave", "weight", "f", "win", "r", "ex", "m", "u", "wh", "work", "we", "aw", "rw", "W", "q", "c", "iw", "wb", "wt", "b", "sw", "n", "fw", "ew", "wx", "v", "z", "hw", " W", "l", "max"], "h": ["col", "hm", "e", "en", "g", "height", "d", "dh", "f", "t", "u", "r", "m", "ht", "j", "o", "rh", "q", "H", "c", "sh", "ch", "b", "n", "gh", "hi", "v", "z", "l", "ph", "k", "hh", "padding"], "bits_per_pixel": ["bits_per_channel", "bits_PER_pixel", "bits_per_page", "bits_per_chip", "bits_Per_pixel", "bits_per_line", "bits_per_cell", "bits_Per_cell", "bits_PER_channel", "bits_per_byte", "bits_PER_chip", "bits_Per_line"], "bytes_per_line": ["bytes_per_slice", "bytes_per_page", "bytes_per_row", "bytes_per_scene", "bytes_PER_line", "bytes_per_cell", "bytes_PER_slice", "bytes_per_byte", "bytes_PER_byte", "bytes_PER_pixel", "bytes_per_pixel"], "nplanes": [" nliners", "nliners", "Npages", " nlines", " nframes", "llines", "snplanes", "numbands", "Nliners", "numlines", " npins", "lplanes", "numpins", "nrows", "mplanes", "nframes", "Nbands", "Nrows", "snlines", "mlines", "nbplanes", "numpages", "numframes", "Nlines", "numrows", "Nplanes", "npins", "numliners", "lframes", "mframes", "Nframes", "Npins", "nblines", "mrows", " nrows", "nlines", "nbrows", "nbands", "snbands", "nbpages", "snframes", "lbands", "npages", "numplanes", " nbands"], "stride": ["snided", "decides", "brides", "snide", "brided", "strider", "decide", "strides", "strided", "snider", "decided", "snides", "brider", "decider", "bride"], "y": ["start", "vy", "yy", "height", "d", "f", "t", "ey", "m", "size", "o", "dy", "c", "b", "Y", "min", "n", "lon", "z", "l", "padding", "type"], "x": ["step", "ix", "xs", "xy", "d", "height", "xx", "f", "win", "ex", "size", "c", "px", "xml", "index", "dx", "X", "min", "n", "z", "l", "max"], "bytes_per_scanline": ["bytes_per_scanment", "bytes_per_scancell", "bytes_per_pixelse", "bytes_per_pixelblock", "bytes_per_binline", "bytes_per_bincell", "bytes_per_Scanframe", "bytes_per_readline", "bytes_per_misscell", "bytes_per_pixelframe", "bytes_per_binment", "bytes_per_readblock", "bytes_per_pixelcell", "bytes_per_missse", "bytes_per_scanframe", "bytes_per_readcell", "bytes_per_pixelline", "bytes_per_Scanline", "bytes_per_pixelment", "bytes_per_Scanse", "bytes_per_missframe", "bytes_per_scanse", "bytes_per_Scanment", "bytes_per_binblock", "bytes_per_missline", "bytes_per_Scanblock", "bytes_per_Scancell", "bytes_per_scanblock"], "ptr": ["port", "config", "ctr", "queue", "pad", "fp", "buffer", "alloc", "code", "addr", "dr", "cb", "tmp", "seq", "fd", "src", "slice", "br", "trace", "buff", "proc", "pair", "pointer", "vec", "fi", "attr", "prop"], "bufstart": ["ufstart", "bufferstop", "bufStart", "ufStart", "queuestart", "bufstop", "queueStart", "ufstop", "bufferStart", "queuestop", "bufferstart"], "scanline": ["parselines", "readline", " scanlines", " scanl", "readlines", "scanlines", "readl", "parsel", "scanl", "parseline"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "substitutes": {"list": ["like", "name", "ul", "object", "config", "acl", "result", "chain", "coll", "tree", "pkg", "ack", "lists", "cl", "listed", "entry", "full", "p", "List", "code", "load", "comment", "out", "self", "xml", "complete", "add", "set", "seq", "call", "batch", "base", "parent", "array", "li", "LIST", "l", "x", "this"], "qdict": ["qstr", "qudir", "qdf", "sqdict", "qudict", " qmap", "qdocument", "qsdf", "qdir", "eqdict", "eqdocument", " qdocument", " qdir", "qudf", "qtdict", "qsmap", "eqstyle", " qstr", "qmap", " qdf", "sqdt", "sqstr", "qsdict", "qtdocument", "sqdf", "sqmap", "qdt", "qsdt", "qumap", "sqdir", "qtstyle", " qstyle", "eqdf", "qustr", "qstyle", "qudt", "qtdf"], "opts": [" optt", "opals", " optins", "hopents", "optbs", " ops", "opcs", "OPts", " optrs", "ops", " opents", "obps", " opbs", "obts", "OPps", "opgs", "opents", " opss", "opins", "obins", "optrs", "OPals", "oprs", "OPgs", "hopts", "optents", " oprs", " opcs", "OPrs", "optgs", " opgs", "hopcs", " optps", "opss", " optts", "opps", "optss", " opals", "OPs", "obrs", "optt", "apptt", " opps", "appps", "appals", "optcs", "hopss", "opbs", "OPtt", "optins", "OPbs", "appts", "optts", "optps"]}}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816, "substitutes": {"ch": ["cha", "sch", "kick", "chn", "ph", "conn", "ach", "app", "err", "cor", "g", "chan", "ich", "chi", "Ch", "che", "cur", "cl", "cand", "ci", "exec", "cmd", "cp", "qu", "cht", "p", "CH", "enc", "chart", "code", "work", "q", "change", "or", "client", "c", "arch", "ctx", "cb", "sh", "form", "sc", "cho", "ic", "cy", "channel", "gr", "chip", "zh", "chron", "th", "gh", "history", "game", "http", "cher", "ce", "ech", "conf", "hw", "ck", "chrom", "bh", "command"], "current": ["recent", "target", "comment", "prev", "next", "conn", "config", "valid", "result", "com", "queue", "accept", "temp", "control", "local", "path", "cont", "cache", "compl", "component", "serial", "code", "open", "active", "client", "c", "ctx", "self", "complete", " cur", "content", "reported", "future", "form", "comp", "present", "now", "volt", "counter", "channel", "history", "running", "selected", "parent", "report", "currently", "stream", "image", "server", "command", "Current", "count"], "br": ["BR", "bc", "str", "handle", "serv", "bro", "fore", "err", "ref", "db", "ctr", "bal", "be", "fb", "queue", "cm", "tr", "bid", "bl", "bridge", "cl", "bre", "r", "cmd", "msg", "bug", "bg", "rel", "j", "arr", "p", "code", "buf", "dr", "rc", "header", "el", "fr", "ver", "hr", "b", "vr", "cr", "comm", "gr", "bm", "mr", "bh", "Br", "rb", "broad", "base"], "sel_mask": ["selgmatch", "sl_match", "sl_scale", "selgvalue", "sel2value", "sel_scale", "sel2mask", "sl_mode", "sl_sum", "sel_sum", "sl_shadow", "sl_count", "sl_mask", "sel___mask", "selalweight", "sel___sum", "selgcount", "sel___shadow", "sl_scan", "selalscan", "sel_count", "sel_scan", "sl_value", "sel_match", "selalvalue", "sel2mode", "sel_mode", "sl_weight", "sel_weight", "sel2scale", "selgmask", "sel_shadow", "sel___value", "selalmask"], "sel_value": ["sel___address", "sl_work", "selvalvalue", "hidevaladdress", "selfaddress", "hide_id", "sl_val", "sl_scale", "selvalinfo", "hide_value", "sel___info", "hidevalinfo", "selvaladdress", "sel___id", "sel_val", "sel_scale", "selvalwork", "selsvalue", "sel_id", "sl_mask", "selsmask", "hidevalvalue", "selfid", "sel_label", "selfinfo", "selsval", "selfvalue", "selsscale", "selvalmask", "sel_info", "hide_info", "hidevalid", "sl_value", "hide_address", "sl_label", "selvallabel", "selvalid", "sel_work", "sel_address", "sel___value"], "status": ["reg", "summary", "security", "connect", "serv", "STAT", "err", "nic", "result", "progress", "val", "shell", "uses", "style", "css", "flags", "cmp", "exec", "reason", "msg", "s", "fps", "stat", "state", "ssl", "score", "unit", "id", "code", "sync", "cli", "comment", "success", "stats", "rc", "complete", "spec", "speed", "service", "seq", "gc", "error", "comm", "rss", "wait", "st", "sp", "Status", "resp"], "cond": ["lc", "bc", "col", "reg", " condition", "fc", "cc", "connect", "rupt", "fail", "err", "ct", "ind", "thread", "part", " conf", " conditional", "crit", "func", "cl", "cas", "contin", "no", "cmp", "ci", "pos", "cont", "Cond", "reason", "cmd", "bit", "pre", "exec", "box", "stat", "act", "unit", "xc", "code", "count", "success", "close", "day", "cb", "c", "lic", "comp", "fl", "cr", "len", "loc", "co", "parent", "bf", "sec", "block", " cont", "resp", "condition"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n\n                               Jpeg2000Component *comp,\n\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j;\n\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n\n        int *src = t1->data[j];\n\n        if (band->i_stepsize == 16384) {\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = src[i] / 2;\n\n        } else {\n\n            // This should be VERY uncommon\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;\n\n        }\n\n    }\n\n}\n", "idx": 23854, "substitutes": {"x": ["e", "ix", "en", "xxx", "xy", "time", "d", "xx", "f", "pos", "ci", "t", "ex", "r", "m", "u", "p", "code", "q", "c", "px", "index", "dx", "X", "on", "b", "w", "n", "xi", "ax", "z", "v", "h", "im", "l"], "y": ["col", "vy", "yy", "xy", "ay", "d", "ny", "ty", "yt", "ci", "t", "ey", "u", "m", "oy", "p", "o", "dy", "py", "c", "ch", "a", "b", "Y", "w", "cy", "ym", "n", "hi", "z", "yi", "v", "h", "k", "type"], "cblk": [" cblkie", "cplke", "dplq", "Cblk", "lcBlks", "dblkt", "lcblke", "cbrq", "cplkt", "lcplk", "lcblks", "cbalke", "cwlkid", " cblkt", "cblek", "cBLks", "cbalkie", "cmlik", "cbrkt", "cblef", "Cllkid", "lcblik", "lcblwork", "cblb", "Cllk", "cplk", "dplck", "cllkid", "lcBlke", "cBLik", "cplkie", "cmlks", "cplq", "cblks", "cmlk", "dblq", "lcplwork", "cwlf", "cbrek", " cblke", "dplkt", "cbrk", "cbrck", " cbalk", "cflks", "cbleb", "cblke", "cllf", "cBlkt", "cbalkt", "cblekid", "cblwork", "cblkt", "lcBlk", "cbrework", "cBLk", "lcblkt", "cBlck", "cllb", "Cblb", "lcplkt", "cflkt", "cBlke", "cBLke", "cblkie", "cblf", "cbreks", "cllk", "cBlks", "Cblf", "lcBlik", "cBlq", "cblik", "Cllb", "dplk", "cwlb", "Cblkid", " cbalkt", "Cllf", "cmlke", " cbalkie", "dblck", "cbalk", "dblk", "lcplks", "cflwork", "cblq", "cwlk", "cplks", "cplwork", "cbrekt", " cbalke", "cBlik", "cBlk", "cblkid", "cflke", "cflkie", "lcblk", "cblck", "cplck", "cflk"], "comp": ["conv", "cc", "uc", "omp", "app", "ref", "config", "Component", "project", "coll", "com", "cond", "crit", "con", "cop", "prep", "host", "cel", "cell", "cmp", "op", "coord", "cp", "cache", "component", "p", "xc", "unit", "mod", "chart", "ctrl", "mac", "code", "c", "ctx", "Comp", "spec", "source", "pro", "ch", "par", "core", "comm", "comb", "req", "proc", "conf", "prop"], "t1": ["p01", "Tone", "T2", "pone", "p2", "t2", "it1", " tron", "tron", "it2", " t01", "T1", "p4", "pron", "p1", "t4", "tone", "it01", " t4", "t01", "itron", " t2", " tone", "T4"], "band": ["io", "plane", "phase", "prop", "app", "config", "amp", "hard", "g", "project", "part", "db", "force", "mode", "connection", "d", "bb", "piece", "vd", "bin", "plugin", "bridge", "host", "product", "function", "cell", "lab", "cmd", "bass", "pp", "component", "disk", "cb", "tag", "ground", "rad", "b", "line", "service", "channel", "plan", "bd", "Band", "co", "boot", "range", "car", "group", "bus", "gap", "gb"], "i": ["io", "e", "ix", "ie", "fi", "qi", "end", "ind", "ui", "eni", "result", "pi", "gi", "d", "uri", "ti", "I", "temp", "f", "ci", "u", "r", "m", "oi", "it", "ini", "phi", "init", "info", "p", "ip", "abi", "id", "o", "bi", "inner", "cli", "mi", "mu", "si", "a", "ii", "b", "w", "ji", "n", "iu", "ai", "xi", "di", "v", "z", "multi", "li", "h", "api", "l", "zi", "k"], "j": ["ja", "jit", "e", "ix", "jl", "ie", "qi", "jp", "adj", "jen", "d", "f", "jj", "t", "u", "dj", "m", "uj", "kj", "p", "job", "o", "dy", "js", "el", "aj", "index", "J", "ch", "b", "ii", "ji", "w", "ij", "n", "xi", "jc", "v", "z", "li", "h", "jo", "l", "k"], "datap": [" datamp", "netapper", " datab", " Datape", "metap", " datapper", "dataap", " Datap", "Dataps", "arraps", "metaps", " datape", "netape", " Dataps", "metamp", "Datape", "datip", "netaps", "arrap", "arrab", "datape", "Datap", "datamp", " dataps", "dataaps", "datapper", " datip", "metab", "netap", "dataape", "arramp", "dataapper", " Datip", "datab", "dataps", "Datip"], "src": ["conv", "bc", "sb", "fc", "uc", "support", "config", "sl", "iv", "g", "std", "result", "text", "uri", "rect", "img", "split", "gb", "rob", "r", "s", "rest", "data", "uv", "sync", "rc", "cb", "spec", "source", "sc", "b", "sub", "sur", "sup", "slice", "loc", "inst", "rss", "rs", "range", "proc", "http", "sec", "dest", "rb", "stream", "bs", "sid", "st", "attr", "url"]}}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855, "substitutes": {"s": ["sv", "sb", "i", "e", "sym", "sie", "sl", "g", "ses", "su", "d", "sets", "site", "so", "services", "f", "sys", "t", "r", "u", "m", "socket", "storage", "state", "ssl", "os", "p", "ts", "o", "ls", "sync", "stats", "ss", "sg", "js", "c", "client", "sd", "spec", "sa", "si", "b", "w", "service", "session", "S", "ns", "n", "sf", "ps", "rs", "south", "z", "v", "h", "server", "l", "sq"], "sockaddr": ["sighaddress", "sinkstr", "dsipaddr", "siglen", "dsipord", "sighord", "dsiplen", "sockstr", "dsockref", "sinkoa", "sckref", "sockaddress", "socksord", "sipord", "sockoa", "ionsipaddress", "ionsockaddr", "sackadd", "dsocklen", "dsipaddress", "ionsockaddress", "dsockord", "socksaddr", "ionsockoa", "ionsipaddr", "dsockaddress", "sinkaddr", "sighaddr", "sinkadd", "socklen", "sockref", "sckaddr", "sackoff", "sipstr", "siplen", "sockadd", " sipaddress", "sackaddr", "dsipref", "sighoa", "sinkaddress", "sipadd", " sockadd", "scklen", "sockord", "socksaddress", " sockoff", "sipoa", "ionsockstr", "sackaddress", "sigref", "sipref", "sipaddress", " sipoff", " sipadd", "sighstr", "ionsipoa", "sckaddress", "sigaddress", "sipoff", "sinkoff", " sipaddr", "sipaddr", " sockaddress", "dsockaddr", "ionsipstr", "sockoff", "sigaddr"], "len": ["lc", "limit", "en", "ie", "sl", "val", "part", "db", "d", "ln", "ld", "f", "pos", "lan", "ell", "size", "data", "fin", "lock", "id", "lin", "count", "elt", "dy", "el", "num", "line", "seq", "rev", "dl", "n", "length", " length", "ll", "fl", "loc", "lon", "lib", "ler", "alt", "nt", "li", "lf", "fn", "l", "base", "lic", "Len", "fun"], "fd": ["fc", "config", "director", "temp", "ds", "df", "fat", "hd", "dy", " df", "pid", "dl", "ff", "fw", "bd", "v", "pointer", "l", "fi", "format", "fin", "driver", "db", "d", "handler", "pd", "fp", "pipe", "dir", "fee", "fx", "buf", "c", "cb", " f", "dc", "flo", "sf", "feed", "fen", "ctl", " fin", "md", " FD", "fa", "e", "fs", "fb", "fax", "ln", "ld", "f", "dn", "exec", "dd", "nd", "cf", "sd", "dt", "fed", "flow", "bf", "lf", " ff", "fun", "td", "cd", "wd", "vd", "xd", "draft", "FD", "socket", " d", "fe", " fid", "fm", "fl", "fn", "FH"]}}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferHEVC  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferHEVC   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH265Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH265MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        // general_profile_space == 0.\n\n        vseq->general_profile_idc = 1; // Main profile (ctx->codec_profile?)\n\n        vseq->general_tier_flag = 0;\n\n\n\n        vseq->general_level_idc = avctx->level * 3;\n\n\n\n        vseq->intra_period = 0;\n\n        vseq->intra_idr_period = 0;\n\n        vseq->ip_period = 0;\n\n\n\n        vseq->pic_width_in_luma_samples  = ctx->aligned_width;\n\n        vseq->pic_height_in_luma_samples = ctx->aligned_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1; // 4:2:0.\n\n        vseq->seq_fields.bits.separate_colour_plane_flag = 0;\n\n        vseq->seq_fields.bits.bit_depth_luma_minus8 = 0; // 8-bit luma.\n\n        vseq->seq_fields.bits.bit_depth_chroma_minus8 = 0; // 8-bit chroma.\n\n        // Other misc flags all zero.\n\n\n\n        // These have to come from the capabilities of the encoder.  We have\n\n        // no way to query it, so just hardcode ones which worked for me...\n\n        // CTB size from 8x8 to 32x32.\n\n        vseq->log2_min_luma_coding_block_size_minus3 = 0;\n\n        vseq->log2_diff_max_min_luma_coding_block_size = 2;\n\n        // Transform size from 4x4 to 32x32.\n\n        vseq->log2_min_transform_block_size_minus2 = 0;\n\n        vseq->log2_diff_max_min_transform_block_size = 3;\n\n        // Full transform hierarchy allowed (2-5).\n\n        vseq->max_transform_hierarchy_depth_inter = 3;\n\n        vseq->max_transform_hierarchy_depth_intra = 3;\n\n\n\n        vseq->vui_parameters_present_flag = 0;\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->vui_num_units_in_tick = avctx->framerate.num;\n\n            vseq->vui_time_scale        = avctx->framerate.den;\n\n        } else {\n\n            vseq->vui_num_units_in_tick = avctx->time_base.num;\n\n            vseq->vui_time_scale        = avctx->time_base.den;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->decoded_curr_pic.picture_id = VA_INVALID_ID;\n\n        vpic->decoded_curr_pic.flags      = VA_PICTURE_HEVC_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->reference_frames); i++) {\n\n            vpic->reference_frames[i].picture_id = VA_INVALID_ID;\n\n            vpic->reference_frames[i].flags      = VA_PICTURE_HEVC_INVALID;\n\n        }\n\n\n\n        vpic->collocated_ref_pic_index = 0xff;\n\n\n\n        vpic->last_picture = 0;\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n\n\n        vpic->diff_cu_qp_delta_depth = 0;\n\n        vpic->pps_cb_qp_offset = 0;\n\n        vpic->pps_cr_qp_offset = 0;\n\n\n\n        // tiles_enabled_flag == 0, so ignore num_tile_(rows|columns)_minus1.\n\n\n\n        vpic->log2_parallel_merge_level_minus2 = 0;\n\n\n\n        // No limit on size.\n\n        vpic->ctu_max_bitsize_allowed = 0;\n\n\n\n        vpic->num_ref_idx_l0_default_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_default_active_minus1 = 0;\n\n\n\n        vpic->slice_pic_parameter_set_id = 0;\n\n\n\n        vpic->pic_fields.bits.screen_content_flag = 0;\n\n        vpic->pic_fields.bits.enable_gpu_weighted_prediction = 0;\n\n\n\n        // Per-CU QP changes are required for non-constant-QP modes.\n\n        vpic->pic_fields.bits.cu_qp_delta_enabled_flag =\n\n            ctx->va_rc_mode != VA_RC_CQP;\n\n    }\n\n\n\n    {\n\n        mseq->video_parameter_set_id = 5;\n\n        mseq->seq_parameter_set_id = 5;\n\n\n\n        mseq->vps_max_layers_minus1 = 0;\n\n        mseq->vps_max_sub_layers_minus1 = 0;\n\n        mseq->vps_temporal_id_nesting_flag = 1;\n\n        mseq->sps_max_sub_layers_minus1 = 0;\n\n        mseq->sps_temporal_id_nesting_flag = 1;\n\n\n\n        for (i = 0; i < 32; i++) {\n\n            mseq->general_profile_compatibility_flag[i] =\n\n                (i == vseq->general_profile_idc);\n\n        }\n\n\n\n        mseq->general_progressive_source_flag    = 1;\n\n        mseq->general_interlaced_source_flag     = 0;\n\n        mseq->general_non_packed_constraint_flag = 0;\n\n        mseq->general_frame_only_constraint_flag = 1;\n\n        mseq->general_inbld_flag = 0;\n\n\n\n        mseq->log2_max_pic_order_cnt_lsb_minus4 = 8;\n\n        mseq->vps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->vps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->vps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->vps_max_latency_increase_plus1[0]   = 0;\n\n        mseq->sps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->sps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->sps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->sps_max_latency_increase_plus1[0]   = 0;\n\n\n\n        mseq->vps_timing_info_present_flag = 1;\n\n        mseq->vps_num_units_in_tick = avctx->time_base.num;\n\n        mseq->vps_time_scale        = avctx->time_base.den;\n\n        mseq->vps_poc_proportional_to_timing_flag = 1;\n\n        mseq->vps_num_ticks_poc_diff_minus1 = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            mseq->conformance_window_flag = 1;\n\n            mseq->conf_win_left_offset   = 0;\n\n            mseq->conf_win_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            mseq->conf_win_top_offset    = 0;\n\n            mseq->conf_win_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            mseq->conformance_window_flag = 0;\n\n        }\n\n\n\n        mseq->num_short_term_ref_pic_sets = 0;\n\n        // STRPSs should ideally be here rather than repeated in each slice.\n\n\n\n        mseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            mseq->aspect_ratio_info_present_flag = 1;\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                mseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                mseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                mseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                mseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (1) {\n\n            // Should this be conditional on some of these being set?\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format = 5; // Unspecified.\n\n            mseq->video_full_range_flag = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            mseq->colour_primaries = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coeffs = avctx->colorspace;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23870, "substitutes": {"avctx": ["svcontext", "avecu", "svca", "aveloc", "AVconfig", "svcmp", "evconfig", "AVcmp", " avcp", "AVctl", "afca", "afcf", "Avconn", "vcmp", "afctl", "evconn", "avconn", "afcmp", "avconfig", "avcp", "vloc", "AVcontext", "afctx", "AVcu", "avecmp", "evcontext", "varctl", "AVca", "avcf", "avca", "varcmp", "navctx", "Avcontext", "avecontext", "svctx", "navcp", "Avcu", "varcontext", "avcu", "avcontext", "vctx", " avcf", "varctx", "AVconn", "avctl", "vcontext", "afconfig", "evctx", "avectx", "avcmp", "Avctx", "afcontext", "AVctx", "afconn", " avcontext", "afcp", "aveconn", "AVloc", "navcf", "navcontext", "avloc"], "ctx": ["conv", "lc", "bc", "git", "cc", "cam", "wcs", "uc", "qs", "conn", "sci", "config", "pkg", "cv", "cm", "rx", "tx", "ca", "Context", "pc", "anc", "cas", "fp", "cu", "cmp", "ci", "nc", "cmd", "cp", "cases", "cs", "cf", "mc", "ctrl", "tc", "context", "xc", "cli", "kb", "sync", "client", "c", "cb", "cn", "rc", "sc", "ann", "auc", "qa", "media", "fw", "loc", "cca", "cus", "utils", "proc", "hw", "voc", "concept", "sq", "vc"], "vseq": [" vqueue", " vsequence", "ovsequence", "usequ", "fsequence", "lqa", "nsequence", "vframe", "vinzip", "esequence", "Vconfig", "versequ", "ovgen", " vcomp", "fsequ", "usequence", "voltseq", "ysem", "Vclus", "useq", "liq", "vinqueue", "lseq", " vzip", "vevec", "varisequence", "svseq", "Vstruct", "lsequence", "vzip", "varvec", "vsequence", " vvec", "svconfig", "vqa", "jiq", "veseq", "vsequ", "voltvec", "vclus", " vcf", " vbatch", "eseq", "ena", "nvseq", "revcode", "niq", "wseq", "Vreq", "nvgen", "ysequence", "voltctx", "varireq", "gstruct", "nseq", " vgen", "lzip", "uvec", " vctx", "ssequ", "ssequence", "nvsequence", "svvec", "varseq", "fcf", "lna", "evvec", "Vctx", "vinclus", "lstruct", "svsequ", "sviq", "ovseq", "vstruct", "vsem", "Vvec", "vna", " vqa", "vequeue", " vreq", " vframe", "evseq", "svqueue", "Vsequ", "verseq", " vna", "revseq", "voltsequence", "vesequence", "vgen", "gseq", "fqueue", "viq", "lclus", "jsequence", "lreq", "vctx", "vcomp", " vstruct", "vbatch", "svstruct", "Vsequence", " vconfig", "vincf", "Vseq", "lcomp", "wsequence", " vsem", "varsequence", "vcode", "vinseq", "lcode", "uzip", "yseq", "vqueue", "jseq", "sclus", "variseq", "fseq", "revqa", "varivec", "sseq", "lvec", "vvec", "svsequence", " vcode", "Vgen", "yna", "vreq", "evsequence", " vclus", "wctx", "wcomp", "fna", "revsequence", "versequence", "ureq", "svclus", "Vsem", "vcf", "giq", "nbatch", "jbatch", "evsequ", "ovvec", "wsequ", " vsequ", "lsequ", "verreq", "evreq", "Vna", "fstruct", "vconfig", " viq", "gsequence", "estruct", "nvframe", "Vframe", "gsequ", "vinsequence", "variq"], "vpic": ["svproc", "tvstruct", "vstruct", "tvproc", "tvctx", "vctx", " vctx", " vstruct", " vproc", "svstruct", "svpic", "vproc", "tvpic", "svctx"], "priv": ["pb", "cam", "uc", "conn", "prof", "obj", "config", "pkg", "private", "ki", "Priv", "tx", "ca", "access", "anc", "cmp", "info", "acc", "cp", "data", "cache", "mc", "auth", "rc", "pri", "cb", "aux", "cfg", "roc", "ocr", "cy", "cci", "soc", "req", "proc", "lib", "conf", "sec", "voc", "fi", "vc", "pub"], "mseq": ["cmsequence", "dsequ", "cmsequ", "dseq", "gmsequence", "gmseq", "dsequence", "dvec", "cmvec", "mvec", "msequence", "msequ", "cmseq", "gmsequ", "gmvec"], "i": ["e", "d", "ti", "I", "f", "ci", "phi", "it", "j", "ip", "p", "id", "o", "bi", "is", "c", "a", "ii", "n", "iu", "xi", "di", "v", "multi", "pi", "x", "zi", "count"]}}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "static void rdft_calc_c(RDFTContext *s, FFTSample *data)\n\n{\n\n    int i, i1, i2;\n\n    FFTComplex ev, od;\n\n    const int n = 1 << s->nbits;\n\n    const float k1 = 0.5;\n\n    const float k2 = 0.5 - s->inverse;\n\n    const FFTSample *tcos = s->tcos;\n\n    const FFTSample *tsin = s->tsin;\n\n\n\n    if (!s->inverse) {\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n    /* i=0 is a special case because of packing, the DC term is real, so we\n\n       are going to throw the N/2 term (also real) in with it. */\n\n    ev.re = data[0];\n\n    data[0] = ev.re+data[1];\n\n    data[1] = ev.re-data[1];\n\n    for (i = 1; i < (n>>2); i++) {\n\n        i1 = 2*i;\n\n        i2 = n-i1;\n\n        /* Separate even and odd FFTs */\n\n        ev.re =  k1*(data[i1  ]+data[i2  ]);\n\n        od.im = -k2*(data[i1  ]-data[i2  ]);\n\n        ev.im =  k1*(data[i1+1]-data[i2+1]);\n\n        od.re =  k2*(data[i1+1]+data[i2+1]);\n\n        /* Apply twiddle factors to the odd FFT and add to the even FFT */\n\n        data[i1  ] =  ev.re + od.re*tcos[i] - od.im*tsin[i];\n\n        data[i1+1] =  ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n        data[i2  ] =  ev.re - od.re*tcos[i] + od.im*tsin[i];\n\n        data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n    }\n\n    data[2*i+1]=s->sign_convention*data[2*i+1];\n\n    if (s->inverse) {\n\n        data[0] *= k1;\n\n        data[1] *= k1;\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n}\n", "idx": 23872, "substitutes": {"s": ["sv", "bis", "sample", "ds", "sys", "r", "ssl", "os", "ts", "cs", "params", "stats", "js", "aws", "n", "S", "ns", "rs", "v", "conf", "l", "ss", "this", "same", "sb", "support", "g", "ses", "d", "sets", "site", "services", "u", "current", "o", "sg", "c", "self", "spec", "a", "sf", "su", "e", "sym", "space", "qs", "fs", "f", "t", "less", "p", "si", "b", "service", "sup", "ps", "gs", "h", "sq", "sci", "your", "m", "args", "ls", "sync", "is", "in", "w", "se", "session", "south", "server", "states"], "data": ["next", "sample", "off", "config", "wa", "map", "post", "message", "extra", "key", "temp", "pad", "pos", "r", "info", "list", "na", "params", "load", "la", "window", "draw", "date", "keys", "slice", "batch", "di", "v", "image", "output", "this", "pages", "delay", "items", "only", "response", "support", "end", "valid", "g", "d", "style", "align", "as", "devices", "split", "da", "ad", "current", "actions", "o", "code", "body", "c", "complete", "add", "pass", "a", "first", "media", "aa", "views", "options", "multi", "empty", "video", "grad", "e", "space", "ui", "result", "lines", "rec", "dates", "img", "function", "f", "model", "one", "series", "size", "zip", "new", "p", "arr", "open", "memory", "module", "sd", "values", "parts", "error", "steps", "dat", "script", "h", "x", "models", "view", "start", "board", "input", "Data", "ops", "product", "results", "done", "ata", "m", "args", "cache", "version", "change", "content", "index", "missing", "DATA", "w", "days", "session", "mask", "array", "apps", "record", "value", "zero"], "i": ["io", "eni", "mini", "key", "ti", "y", "info", "ini", "j", "ip", "ic", "n", "iu", "slice", "di", "v", "l", "fi", "ix", "qi", "ind", "ri", "gi", "d", "I", "ci", "u", "abi", "code", "o", "mi", "c", "ji", "xi", "yi", "multi", "uni", "li", "ie", "pi", "k", "ni", "uli", "e", "ik", "ui", "chi", "f", "phi", "it", "p", "vi", "bi", "ani", "cli", "si", "b", "api", "x", "zi", "ori", "ia", "uri", "oi", "adi", "m", "id", "is", "index", "ii", "in", "ai", "isi"], "i1": ["p01", "pione", "p2", "i81", "iu13", "pi64", "i91", "p6", "i64", "ini1", "io100", "iu01", "qi01", " i8", " i6", "intOne", "iiOne", "si01", "pi13", " i61", "iOne", "li1", "iniL", "iione", "ii81", "io01", "e91", "ii3", "qi1", "int3", "i3", "ini71", "li01", "qi71", "sione", "si61", "i13", "i71", "si100", "i61", "ione", "int1", "li61", "si8", "iu1", "li2", "e01", "ini81", "pi01", "iu31", "iu91", "qi91", "iu71", " i01", "ii8", "iu64", "pi100", "iu61", "siOne", "ii1", " iOne", "li64", "i01", "iL", "i8", " i3", "i31", "si1", "si71", "e71", "e1", " ione", "ii71", "ii01", "ii100", "pi31", "iu100", "li6", "p1", "i100", "ioone", "int8", "pi1", "ii31", "pi61", "i6", "li13", "si81", "iiL", "ii61", " i81", "siL", "io1"], "i2": ["iu256", "liTwo", "I8", "iiSecond", "IB", "ini62", "ITwo", "ini2", " iII", "li62", "u2", "k4", "oiII", "si62", " i20", " i6", "i02", "kB", "iSecond", "I2", "oi2", "ui1", "iTwo", "i256", "uiSecond", "ini256", "xiTwo", " iB", "iu10", "si5", "sisecond", "k62", "siSecond", "i42", " isecond", "u02", "I4", "ii2", "si82", "si2", "ii62", "siII", "i5", "u20", "i62", "ini52", "ii42", "li2", "ini10", "iuTwo", " i52", "li8", "ii8", "xi42", " i4", "oi62", "i52", "ii256", "isecond", "ii1", "iB", "si42", "iu2", "i8", "i4", "ui82", "si1", "ii5", "ii82", "xi2", "li20", "xi5", "siTwo", "oisecond", "li02", "k2", "ini6", "ii52", "iniTwo", "I62", "ii6", "ui2", "i82", "ii10", " i62", " i02", "i20", "i10", "i6", "iiTwo", "iII"], "ev": ["sv", "ee", "ak", "om", "event", "av", "ott", "wave", "eff", "ell", "r", "nov", "lev", "ever", "ek", "ood", "dem", "ov", "re", "ve", "Ev", "v", " dev", "image", "eval", "oe", "ind", "iv", "complex", "cv", "ef", "ove", "dev", "enc", "c", "equ", "rev", "vol", "em", "evidence", "aa", "eva", "element", "vec", "eg", "ih", "e", "err", "rec", "img", "model", "eb", "dd", "uv", "el", "sd", "ver", "inst", "er", "gr", "ew", "ae", "exper", "ec", "tv", "cd", "sk", "lv", "tr", "gd", "oy", "ep", "gg", "ect", "ch", "vr", "vert", "im", "record"], "od": ["md", "td", "odd", "oder", "end", "off", "oe", "yd", "ind", "pred", "ur", "valid", "op", "ost", "oda", "post", "ott", "oa", "de", "d", "vd", "ed", "ord", "pad", "oh", "ld", "gd", "bad", "ud", "ody", "ell", "order", "ok", "ode", "dev", "ad", "odi", "oy", "ob", "dd", "nd", "or", "opt", "id", "mod", "OD", "o", "ani", "ant", "ood", "el", "sd", "odic", "add", "oid", "in", "ov", "er", "co", "rod", "ag", "lov", "old", "cod", "ox", "lad", "ods"], "tcos": ["Tbs", "ttpos", "retnas", "Tpos", "hros", "tscs", "Tmas", "tcus", "hpose", "hcos", "retcos", "tcin", "retpos", "Tcos", "Tns", "tspos", "tns", "ttcos", "retoks", "xbs", " tmas", "dris", "tris", " tcs", "tsnas", "Tcus", " tcin", "toks", "tsoks", "tpos", " toks", "Tcin", "Tros", "tros", "dcos", "tsris", "ttbs", "retcin", "tbs", "tmas", "xcus", "tspose", "tcs", " tbs", "Tpose", "dcs", "tnas", "tsras", " tras", " tpos", "tscos", " tns", "xcos", " tris", "tsros", "retmas", "Tsin", "ttsin", "tscin", "ttcus", "hpos", "tpose", "dras", "xpos", "ttns", "tras", " tnas"], "tsin": ["timesbin", "tesinc", "psinn", "tesins", "tsout", "tsinn", "TSini", "atsin", "atesbin", "msinn", "TSin", "TSinn", "tsini", "ssinn", "outsin", "tsoin", "atsIN", "timesins", "psbin", "outsinc", "tesini", "TSoin", "tesout", "atsins", "psin", "outsins", "msini", "atesini", "atesinn", "vertsin", "atesin", "tsins", "tsbin", "psini", "outsini", "timesini", "vertsinc", "ssins", "TSins", "tsIN", "mentsIN", "timesin", "timesoin", "TSbin", "vertsoin", "ssini", "ssin", "timesout", "msin", "mentsins", "tipscin", "msins", "mentsin", "tsinc", "tscin", "TSIN", "tesoin", "timescin", "tesin", "timesinc", "tesbin", "tipsinc", "atsoin", "mentsoin", "tescin", "tipsin", "vertsbin", "tipsout"]}}
{"project": "FFmpeg", "commit_id": "aca490777f9da2a71b537874ed4e16105bb3df02", "target": 0, "func": "static av_cold int g726_init(AVCodecContext * avctx)\n\n{\n\n    AVG726Context* c = (AVG726Context*)avctx->priv_data;\n\n    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;\n\n\n\n    if (\n\n        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&\n\n         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n    if(index>3){\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of bits %d\\n\", index+2);\n\n        return -1;\n\n    }\n\n    g726_reset(&c->c, index);\n\n    c->code_size = c->c.tbls->bits;\n\n    c->bit_buffer = 0;\n\n    c->bits_left = 0;\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23877, "substitutes": {"avctx": ["airctl", "avecf", "avalctl", "alcontext", "vercontext", "vercf", " avcu", "avcca", "averctl", "avconfig", "avcup", "alloc", "alcmd", "afloc", "avsci", "avlc", "avalcmp", "ajcup", " avconn", " avloc", "ajcmd", "afconfig", "ajctx", "avcmp", "Avctx", "AVcv", "afconn", "alctx", "devctx", "devcontext", "avecu", "aveconfig", "aveloc", "avcv", "AVctl", "avecca", "Avctl", "airctx", "avalconfig", "verctx", "afcup", "afctx", "avectl", "avesci", "avelc", "aircmp", "avcontext", "ajconn", " avctl", "alctl", "ajcmp", "avevoc", "aircf", "AVctx", "avalcontext", "afcca", "afcv", "avvoc", "aveconn", " avvoc", "avercmp", "AVcf", "AVconfig", "devcmp", "ajcontext", " avlc", "afctl", "afcmp", "afcmd", "avercontext", "avcf", "averctx", "afcu", "afvoc", "avcu", "avctl", "AVconn", " avcca", "avalcmd", "avectx", "afcontext", "avecup", "avalloc", "aflc", "ajcv", "avercf", "AVcmp", "afcf", "verconn", "Avconn", "avconn", "AVcontext", "avecmp", "devcf", "Avcontext", "avecontext", "avecmd", "averconn", "avalctx", "afsci", "avcmd", " avcontext", "aversci", "avloc"], "c": ["lc", "bc", "i", "e", "cc", "uc", "conn", "config", "g", "this", "coll", "unc", "cm", "orc", "d", "con", "ca", "l", "cur", "pc", "f", "ci", "cmp", "t", "exec", "ac", "u", "cp", "m", "s", "r", "cache", "data", "p", "mc", "cf", "cs", "ctrl", "o", "context", "tc", "ctx", "self", "roc", "ch", "sc", "a", "b", "dc", "w", "cy", "cr", "n", "C", "co", "v", "ec", "ce", "conf", "z", "h", "oc", "cu", "k"]}}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "substitutes": {"addr": ["hp", "asm", "ref", "adr", "amp", "g", "oa", "ord", "amd", "align", "host", "pad", "nc", "r", "address", "ad", "ip", "ace", "prefix", "np", "buf", "dr", "rc", "nr", "inet", "ar", "ptr", "Address", "src", "slice", "alpha", "array", "pointer", "rb", "image", "x", "padding"], "size": ["confirmed", "i", "area", "esc", "es", "message", "extra", "ize", "pos", "order", "address", "data", "false", "last", "shift", "small", "negative", "n", "global", "since", "from", "name", "response", "end", "scale", "g", "term", "fee", "unit", "when", "code", "c", "complete", "capacity", "needed", "set", "see", "SIZE", "empty", "position", "sum", "e", "ui", "result", "sized", "bytes", "function", "white", "new", "score", "or", "number", "max", "answer", "num", "second", "si", "speed", "error", "length", "loc", "side", "page", "sec", "count", "shape", "start", "en", "send", "Size", "done", "cache", "storage", "change", "sync", "timeout", "source", "len", "large", "grade", "range", "value"], "offset": ["exclusive", "adjust", "after", "i", "limit", "start", "attribute", "end", "off", "ref", "next", "option", "result", "part", "origin", "extra", "oa", "disabled", "align", "no", "pos", "order", "optional", "address", "ace", "id", "prefix", "o", "initial", "operation", "shift", "count", "timeout", "number", "answer", "index", "second", "ptr", "set", "now", "location", "alias", "online", "error", "Offset", "length", "iterator", "slice", "loc", "len", "page", "range", "alpha", "array", "pointer", "aligned", "empty", "position", "attr", "padding", "type"], "p": ["i", "e", "ap", "jp", "lp", "g", "d", "P", "bp", "pc", "l", "fp", "f", "po", "t", "op", "r", "u", "m", "cp", "pre", "s", "tp", "pp", "ip", "point", "o", "np", "q", "py", "c", "wp", "a", "b", "x", "w", "n", "proc", "v", "pair", "sp", "pointer", "vp", "h", "api", "pi", "dp"], "tmp": ["sample", "config", "vt", "part", "extra", "copy", "temp", "pad", "bp", "emp", "buffer", "front", "cp", "address", "data", "tp", "shift", "crop", "slice", "test", "wx", "proc", "v", "pointer", "rb", "output", "attr", "sb", "binary", "txt", "jp", "bb", "tt", "fp", "pre", "treatment", "opt", "code", "buf", "c", "cb", "wp", "tf", "mp", "appy", "st", "opp", "prev", "wrapper", "result", "meta", "fb", "f", "cmp", "t", "zip", "tc", "gz", "cro", "b", "ptr", "sup", "loc", "page", "buff", "clip", "api", "start", "obj", "input", "po", "m", "storage", "cache", "pp", "np", "py", "kk", "source", "now", "stuff", "paper", "array", "sp"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895, "substitutes": {"v": ["conv", "tv", "sv", "view", "i", "e", "V", "lv", "iv", "g", "vim", "vt", "gu", "val", "vd", "f", "t", "u", "m", "vic", "j", "p", "uv", "vs", "vi", "o", "var", "c", "ver", "volt", "w", "vv", "ve", "util", "vert", "z", "vm", "vp", "h", "ev", "l", "api", "k", "video", "vc"], "errp": ["errps", "eorp", "drp", "drP", "drps", "erc", "erlp", "derP", " errc", "derpi", "eorc", " errpi", "armP", " errpc", "armps", "errpc", "derpc", "eorP", "errpa", "armlp", "errP", "derp", "drlp", "armp", " errpa", "errc", "erpi", "errpi", "errlp", " errP", "erpa", "erp", "erP", "eorpa", "erpc", "erps"]}}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899, "substitutes": {"client": ["remote", "port", "request", "name", "public", "connect", "support", "irc", "conn", "config", "project", "input", "progress", "container", "private", "connection", "cm", "con", "plugin", "cl", "node", "product", "cell", "ci", "custom", "master", "cmd", "cat", "cache", "man", "patch", "method", "cart", "current", "ace", "cli", "open", "c", "close", "friend", "cn", "core", "child", "call", "co", "req", "clean", "parent", "util", "http", "ce", "manager", "from", "contact", "cod", "resource", "server", "api", "command", "Client", "contract"], "fatal": ["filler", "elfiller", "rfatal", "afal", "fale", "infal", "ofatal", "rfaster", "flatal", "infatal", "rfale", "elfale", "faster", "elfatal", "fliller", "afatal", "fal", "afault", "ofault", "elfaster", "ofaster", "infault", "afaster", "rfiller", "fault", "infaster", "flale", "ofal", "flaster"], "errp": ["errcp", "arrcp", " errf", "errps", "eorp", "errpr", "erpe", "rrpr", "errorpe", "errf", "eorps", " err", "derpe", " erp", "derpr", "rrp", " errcp", "arrpr", " errfp", "rrpe", "rrfp", "arrfp", "errfp", " errpe", "derp", "derfp", " errps", "errorf", "ercp", "eorcp", "erpr", "arrp", "errpe", " erpe", "erfp", "errorr", " errpr", "erp", "eorfp", "errr", " erf", " errr", "erps", "errorp"], "ret": ["reg", "ut", "def", "en", "obj", "ref", "conn", "sil", "result", "val", "arg", "ft", "det", "_", "rep", "Ret", "mt", "art", "fit", "f", "t", "res", "cat", "fin", " RET", "fun", "py", "rc", "cb", "match", "pass", "let", "RET", "rt", " Ret", "mem", "value", "flag", "reply", "rev", "re", "desc", "len", "req", "base", "alt", "bot", "nt", "lit", "att", "empty", "all", "fi", "resp", "rets"]}}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912, "substitutes": {"node_path": ["host_name", "node_package", "node_host", " node_name", "nodevalhost", "node_root", "host_pointer", "nodevalpath", "nodevalname", " node_prop", "host_root", "host_package", "nodevalpackage", "host_path", "node_name", "host_host", "node_prop", "node_folder", "node_pointer", " node_folder"], "prop": ["col", "priv", "pb", "name", "property", "target", "ref", "config", "option", "pred", "prot", "project", "part", "key", "host", "home", "properties", "term", "op", "cp", "data", "opt", "method", "p", "id", "field", "pro", "pid", "comp", "value", "tmp", "test", "parent", "proc", "range", "pointer", "param", "lit", "attr", "Prop", "type"], "val": ["str", "expr", "sel", "def", "ref", "sl", "valid", "arg", "func", "buffer", "split", "al", "data", "opt", "p", "vals", "slot", "buf", "el", "b", "read", "VAL", "base", "Val", "v", "vec", "eval", "lit", "pt", "l", "x", "value"], "len": ["lc", "str", "name", "limit", "en", "end", "err", "ref", "sl", "valid", "part", "ln", "pos", "lan", "fat", "pre", "ell", "size", "data", "fin", "lin", "count", "ls", "elt", "le", "la", "gen", "el", "c", "num", "lif", "mem", "line", "seq", "rev", "fl", "n", "length", " length", "min", "lt", "ll", "loc", "fd", "lon", "nt", "li", "lf", "fn", "lit", "l", "base", "resp", "ellen", "Len", "fun"], "path": ["route", "name", "limit", "ath", "end", "conn", "ref", "next", "config", "obj", "Path", "key", "file", "handler", "temp", "host", "node", "anc", "fp", "home", "dir", "cmd", "cp", "cat", "data", "cache", "method", "p", "enc", "id", "prefix", "rh", "np", "inner", "point", "open", "success", "close", "c", "ctx", "index", "near", "location", "error", "n", "length", "child", "fd", "loc", "base", "root", "parent", "pointer", "fn", "folder", "h", "dest", "l", "api", "url"], "f": ["fa", "fc", "e", "fac", "ref", "fs", "g", "fb", "file", "d", "handler", "rf", "fp", "fit", "df", "function", "fast", "t", "r", "m", "s", "raf", "j", "fx", "p", "cf", "inf", "o", "af", "c", "fe", "fr", "form", "b", "w", "fm", "ff", "fd", "F", "sf", "feed", "fen", "v", "bf", "fn", "h", "api", "l", "fi", "fo", "fun"], "ret": ["feat", "str", "reg", "ut", "name", "fi", "obj", "err", "ref", "gt", "result", "arg", "det", "Ret", "no", "fit", "fat", "bad", "al", "res", "cat", "j", "rets", "job", "id", "fun", "code", "elt", "success", "fire", "out", "el", "ext", "match", "run", "RET", "rt", "mem", "line", "rev", "re", "alt", "nt", "lit", "base", "resp", "fin"], "pathlen": ["threadlon", "tempLen", " pathen", "colLen", "athel", "Pathlength", "pathlon", "pathl", "templen", "threadlen", "threadLen", " pathlon", "Pathl", "Pathel", "templ", "PathLen", "Pathlen", "templength", "threaden", "collen", " pathl", "athlen", "pathLen", "pathen", "pathel", " pathel", "athLen", "collength", " pathLen", "athlength", "pathlength", "Pathen", "Pathlon", " pathlength"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 23916, "substitutes": {"s": ["ions", "sv", "request", "i", "sb", "e", "qs", "es", "hs", "fs", "g", "ses", "this", "input", "private", "d", "sets", "site", "ches", "ks", "ds", "services", "f", "sys", "t", "r", "u", "m", "info", "stat", "ssl", "os", "p", "cs", "us", "o", "sync", "is", "ss", "stats", "client", "c", "js", "sg", "self", "spec", "b", "w", "service", "se", "n", "session", "ns", "S", "details", "sf", "gs", "conf", "h", "scope", "sq", "states"], "data": ["str", "reg", "grad", "def", "sample", "sam", "config", "result", "input", "map", "xxx", "decl", "Data", "d", "rec", "ds", "device", "info", "address", "m", "da", "cache", "ad", "res", "args", "arr", "p", "mi", "memory", "la", "ctx", "xxxx", "DATA", "session", "desc", "reader", "slice", "src", "dll", "base", "database", "proc", "dat", "array", "resource", "record"], "addr": ["reg", "sb", "e", "area", "obj", "asm", "adr", "ref", "amp", "eni", "ha", "arg", "ack", "oa", "ord", "rx", "amd", "align", "pad", "ea", "pos", "coord", "r", "address", "m", "da", "dd", "ad", "arr", "osi", "ace", "p", "code", "mac", "work", "np", "params", "dr", "la", "rc", "nr", "rn", "ctx", "add", "ar", "index", "ptr", "Address", "arm", "alias", "src", "loc", "dll", "array", "pointer", "orig", "offset", "sta", "attr", "nm"], "oi": ["ois", "rio", "i", "sym", "ie", " iii", "agi", "iri", "amp", "ui", "eni", " ii", "oda", "cm", "oa", "uri", " ip", "ti", "oci", " si", "offset", "ci", "ini", "ok", "address", " mi", "oni", "odi", "abi", "asi", "osi", "ip", "uci", "o", "mm", "mi", " pi", "inet", "ib", "roc", "si", "oid", " ki", "ilo", "ii", "tmp", " di", " bi", "iu", "oji", "ai", "loc", "ei", "aram", "di", "yi", " os", "igi", " ie", " pci", "pi", "fi", " vi", "ahi", "ski", "im", "ni", "ori"], "is_64": ["is264", "is2128", "isx24", "is232", "isx32", " is_32", "is_44", "is_24", "Is_44", "Is_24", "is_32", "Is_64", "is224", "Is_32", " is_128", " is_24", "isx64", "is_128", "isx128"], "addrz": ["alignz", "drj", "addriz", "adrzen", " addrZ", " addrj", "addrx", "alignZ", "addrZ", "addrzen", "drx", "adrZ", "adriz", "adrz", " addry", "urlzo", "alignx", "alignzen", " addrx", "urlZ", "aligniz", "addressZ", "alignj", "drz", "attrZ", " addrzo", "attrz", "drZ", "addrzo", "attry", "addressiz", "urlz", "attrzo", "addresszen", "addry", "addrj", "addressz", "urly"], "param": ["member", "reg", "request", "sym", "asm", "err", "adr", "sam", "amp", "item", "config", "ref", "inc", "arg", "part", "cm", "ack", "pm", "amd", "temp", "Param", "model", "pos", "nom", "address", "ram", "m", "ad", "da", "p", "params", "mm", "var", "am", "pri", "rn", "rac", "index", "rm", "num", "ctx", "source", "c", "sm", "mem", "arm", "tmp", "prom", "par", "qa", "channel", "error", "loc", "grade", "aram", "proc", "vm", "rb", "resource", "im", "nick", "attr", "nm", "type"], "func": ["str", "stack", "name", "cc", "asm", "wrapper", "obj", "val", "xxx", "unc", "rx", "amd", "align", "pc", "function", "f", "exec", "sys", "alloc", "r", "cmd", "args", "aug", "method", "job", "cs", "cf", "work", "code", "mac", "var", "abc", "rc", "c", "ctx", "cb", "self", "lambda", "pass", "comp", "go", "xp", "CC", "call", "src", "Function", "slice", "dll", "callback", "partial", "loc", "doc", "proc", "sec", "fn", "orig", "kw", "attr", "fun"], "label_ptr": ["code_pointer", "align_pointer", "label_struct", "labelingpointer", "align_tr", "labelingptr", "code_ptr", "label__pointer", "code_pt", "label__ptr", "labelingpt", "label__proc", "label_pointer", "labelxptr", "align_ptr", "labelxstruct", "label_proc", "labelingstruct", "code_struct", "align_proc", "labelxpt", "label__tr", "label_tr", "label_pt", "labelxpointer"]}}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n", "idx": 23918, "substitutes": {}}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23922, "substitutes": {"s": ["ions", "sv", "i", "es", "uns", "xs", "uds", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "params", "stats", "js", "aws", "n", "S", "ns", "details", "rs", "ins", "v", "conf", "http", "l", "an", "ss", "request", "sb", "g", "ses", "d", "sets", "site", "as", "services", "devices", "u", "o", "sg", "c", "self", "spec", "a", "set", "sf", "su", "e", "sym", "qs", "tests", "fs", "f", "t", "new", "p", "si", "b", "service", "side", "ps", "gs", "sq", "your", "ops", "ks", "m", "args", "its", "ls", "sync", "is", "settings", "w", "session", "server"], "dev": ["cam", "def", "app", "pad", "dh", "ds", "prov", "device", "dist", "info", "data", "serial", "dem", "ve", "di", "v", "conf", "nt", "ev", "pub", "priv", "name", "conn", "iv", "g", "driver", "db", "private", "der", "de", "d", "node", "ad", "mod", "od", "spec", "dom", "dc", "desc", "md", "grad", "mode", "host", "f", "dn", "adv", "cmd", "dd", "p", "del", "sd", "ver", "rad", "prom", "req", "user", "dat", "hw", "h", "Dev", "cd", "sk", "gu", "wd", "home", "dep", "diff", "pro", "sh", "die", "ch", "w", "dm", "den", "debug", "server"], "udev": ["ubexp", "vdek", "ddiver", "ubec", "udiver", "ubek", "ddov", "udv", "ddef", "uidek", "hddev", "vdef", "vdev", "uidem", "odv", "uidiver", "ddv", "udek", "hdef", "ddec", "oddev", "ddexp", "ufiver", "udect", "ddect", "odov", "ubov", "hdev", "odev", "dddev", "ubem", "odef", "uidev", "ddev", "ddiv", "udov", "udec", "ufef", "uiddev", "ubect", "udexp", "ubef", "odexp", "udiv", "ubv", "vdem", "ubdev", "ubiv", "hdiver", "udef", "uidef", "ufev", "udem", "ufiv", "ubiver", "uidec", "uddev", "ufdev", "ubev", "ufect"], "rc": ["lc", "bc", "fc", "cc", "rd", "uc", "irc", "conn", "err", "ct", "fail", "config", "result", "inc", "ack", "rx", "rec", "rr", "cur", "pc", "anc", "sth", "ci", "pg", "cmp", "nc", "ac", "xc", "rh", "sync", "rn", "cb", "irm", "roc", "RC", "rt", "sc", "dc", "rl", "ann", "sr", "hl", "auc", "error", "cr", "src", " src", "loc", "co", "req", "rs", "back", "proc", " RC", "ry", "ko", "rb", "ck", "oc", "rg", "vc"]}}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924, "substitutes": {"new_size": ["NEWaccache", "new_SIZE", "new_number", "newlsize", "new_bytes", "new6size", " new_time", " new_name", "finallexsize", "newaccache", "old_content", " new_weight", " new_capacity", "old_cache", "newaclength", "finallexset", "final_set", "newlexset", "new6cache", "NEWacnumber", "newPsize", " new_loc", "new67name", "new_set", "newacsize", "NEW_length", "new67cache", "newPweight", "new_time", "new_capacity", "newlexbytes", " new_SIZE", "finallexbytes", "newlbytes", "new_name", "NEW_number", "new67capacity", "new67size", " new_year", "final_capacity", " new_storage", "final_size", "newPyear", "final_bytes", "new_storage", "newlcapacity", "finallexcapacity", "new6content", "new_weight", "new_loc", "newacnumber", "new_content", "NEWacsize", "newlexsize", "old_size", "NEWaclength", "NEW_size", "new_year", "newlset", "newlexcapacity", "new_length", "NEW_cache"], "errp": ["errcp", "errps", "errorfp", "rrpre", "armpa", "errorc", "err", "erc", "rrp", "nerp", "yrp", " errcp", "errorp", "errorpc", "nerr", " errc", "nerpc", "armcp", " errfp", " errpre", "armr", " errpc", "yrpc", "errpc", "rrpc", "yrpre", "errfp", "errpa", "armp", " errpa", "errc", "ercp", "irpc", "irps", "rrpa", "errpre", "irp", "irr", "erfp", "erpa", "erp", "errr", "nerps", " errr", "erpc", "erps", "yrpa"], "new_cache": [" new_table", " new_clear", " new_conn", "new__cache", "newAcconn", " new_buffer", "new67size", "new_clear", "new_table", "newAcsize", "new_config", "new_buffer", "newAcscore", "new_conn", "new67cache", "new67score", "new__table", "new_score", "new67conn", " new_config", " new_score", "newAccache", "new__size"], "ret": ["sat", "feat", "reg", "ut", "def", "ig", "obj", "gt", "ref", "hard", "result", "val", "part", "arg", "ft", "det", "Ret", "mt", "fit", "pre", "info", "bit", "res", "cat", "final", "data", "fin", "code", "fun", "success", "ext", "out", "num", "match", "let", "RET", "rt", " Ret", "mem", "flag", "reply", "re", "pat", "len", "req", "alt", "nt", "lit", "wrap", "format", "rets"]}}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933, "substitutes": {"sig": [" sigma", "ssigned", "pigma", "sigs", "pess", " sess", " sigs", "asigma", "pigs", "gsigma", "sigh", "dsig", "sIG", "ssigs", " sigh", "fIG", "pigh", "ssig", "figma", "pIG", "asess", " sIG", "asigs", "dsigs", "sigma", "figs", "gsig", "ssigma", "sess", "asig", "gsigs", "gsigh", "fig", "pig", "dsigned", "dsigma"], "ka": ["bc", "ja", "ra", "ya", "ia", "fi", "ba", "kernel", "ha", "wa", "oda", "kt", "KA", "ki", "oa", "ker", "ca", "jam", "ea", "ci", "ga", "da", "na", "java", "kb", "sa", "la", "ctx", "ket", "sc", "ema", "a", "ta", "ua", "auc", "qa", "va", "ai", "cca", "ku", "LA", "aka", "qua", "ae", "ko", "ma", "ke", "kee", "sta", "k", "ama"], "info": ["name", "summary", "area", "def", "Info", "fi", " fi", "start", "config", "ind", "ui", "INFO", "meta", "ti", "f", "ci", "ini", "information", "raf", "init", "data", "isu", "stat", "abi", "inf", "setup", "id", "code", "context", "mi", "ctx", "index", "spec", "source", "si", "family", "ii", "alias", "error", "loc", "hi", "util", "conf", "image", "ie", "api", "attr", "fo", "inter", "interface"], "set": ["status", "ut", "net", "e", "start", "sel", "en", "end", "send", "err", "config", "ind", "push", "sche", "post", "kit", "sign", "parse", "site", "get", "export", "SET", "ex", "use", "init", "state", "stat", "new", "setting", "act", "Set", "setup", "ace", "code", "context", "sync", "load", "open", "gen", "settings", "ctx", "spec", "et", "add", "c", "sc", "check", "match", "create", "se", "update", "see", "vert", "ner", "reset", "ise", "server", "offset", "base", "ne"], "env": ["net", "stack", "e", "en", "eq", "obj", "end", "eu", "config", "conn", "eni", "me", "db", "ea", "ef", "exec", "exc", "nc", "ini", "dir", "dev", "init", "cache", "state", "enc", "ep", "dict", "que", "context", "np", "ext", "ctx", "et", "cfg", "viron", "stage", "osc", "vert", "qt", "ne", "conf", "v", "ev", "environment", "scope", "server", "ec"], "frame_addr": ["frame_nr", "frame_address", "frame__offset", " frame_layer", "frame_layer", " frame_ord", " frame_offset", "frame_offset", "fram_addr", "frame__address", " frame_address", " frame_nr", "frame__nr", "fram_offset", "fram_address", "frame__addr", "fram_ord", "frame_ord"], "r26": ["p16", " r16", "p27", "R6", "p26", "r6", "R27", "R16", "p6", "r27", " r6", " r27", "r16", "R26"], "frame": ["target", "def", "sample", "config", "event", "part", "message", "force", "parse", "plate", "sequence", "figure", "context", "fr", "window", "line", "draw", "slice", "game", "Frame", "ko", "image", "fi", "feat", "txt", "object", "jp", "sche", "file", "za", "processor", "style", "node", "fake", "state", "lock", "component", "setup", "tick", "code", "body", "fire", "cfg", "raise", "element", "boot", "fram", "ce", "position", "scope", "interface", "e", "flower", "thread", "fb", "framework", "function", "f", "layer", "model", "section", "play", "cf", "point", "coe", "module", "role", "face", "call", "flow", "show", "stage", "ze", "fo", "plane", "iframe", "feature", "build", "invoke", "motion", "version", "cycle", "word", "fe", "frames", "shot", "die", "profile", "seq", "session", "update", "range", "block", "environment", "base", "condition"], "i": ["io", "uli", "ix", "e", "ie", "qi", "err", "ind", "ri", "ui", "eni", "part", "mini", "gi", "d", "uri", "ti", "I", "l", "ci", "y", "t", "phi", "adi", "m", "ini", "oi", "j", "u", "ip", "p", "id", "o", "code", "bi", "is", "cli", "c", "mu", "index", "si", "a", "ii", "x", "ji", "b", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "z", "v", "li", "yi", "api", "pi", "fi", "zi", "ni"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938, "substitutes": {"dev": ["Dev", "priv", "reg", "grad", "cam", "def", "serv", "conn", "app", "prof", "mode", "de", "tr", "temp", "home", "device", "devices", "ro", "dd", "data", "serial", "mod", "pro", "dem", "dom", "ver", "rad", "w", "dm", "prom", "test", "debug", "req", "di", "conf", "hw", "ev"], "s": ["sv", "i", "es", "uns", "xs", "ds", "sys", "y", "ssl", "os", "ts", "cs", "us", "params", "js", "ms", "n", "S", "ns", "rs", "ins", "ans", "conf", "l", "ss", "same", "sb", "g", "ses", "d", "sets", "site", "as", "services", "u", "o", "sg", "c", "spec", "a", "has", "ats", "su", "e", "sym", "qs", "tests", "hs", "fs", "f", "t", "new", "p", "si", "b", "service", "ps", "gs", "x", "sq", "sl", "your", "plugins", "ks", "m", "args", "its", "vs", "ls", "sync", "is", "settings", "w", "se", "session", "comments", "bs", "states"]}}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}", "idx": 23942, "substitutes": {"t": ["i", "e", "timer", "table", "g", "time", "d", "tt", "f", "y", "r", "u", "m", "it", "tp", "p", "ts", "o", "tc", "c", "dt", "b", "ta", "tmp", "T", "n", "test", "tty", "v", "tm", "h", "pt", "l", "this", "type"], "ev": ["tv", "e", "serv", "ee", "err", "app", "ind", "lv", "iv", "event", "lex", "tr", "eed", "vent", "ract", "temp", "ere", "ef", "exec", "ell", "env", "ex", "eb", "dev", "bug", "ep", "enc", "ace", "ant", "ek", "el", " event", "ect", "ch", "rt", "ov", "vr", "echo", " inst", "rev", "inst", "em", "ve", "ait", "Ev", "ew", "actor", "v", "ce", "erv", " dev", "hw", "im", "eg", "eval", "ec", "vc"], "host_timer": ["hard_time", "hostingtimer", "hostingtime", "hostingtim", "hostworktimer", "hard_walker", "hostworktime", "hostworktim", "hard_timer", " host_tim", "hostworkmonitor", "host_tim", "host_time", "host_monitor", "hostingwalker", "hard_monitor", "host_walker", "hard_tim", " host_time"], "act": [" Act", "nat", "fac", "err", "ct", "obj", "amp", "activate", "val", "lex", " ACT", "cv", "ack", "rx", "sign", "cas", "art", "eff", "acs", "op", "catch", "ac", "ex", "acts", "init", "ace", "actions", "ant", "active", "agent", "ctx", "ask", "ACT", "ect", "form", "pass", "Act", "set", "activ", "ass", "ff", "call", "mit", " acts", "ait", "ain", "actor", "parent", "ec", "att", "effect", "fi", "feat", "action", "fact"]}}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23947, "substitutes": {"cc": ["lc", "fc", "cd", "uc", "ct", "lv", "coll", "cv", "ca", "che", "cl", "cu", "cmp", "acc", "cmd", "cp", "ac", "ucc", "cf", "xc", "mc", "cs", "tc", "rc", "kk", "ctx", "content", "cn", "c", "sq", "icc", "sc", "cpp", "cci", "CC", "cy", "seq", "ff", "loc", "cca", "cus", "co", "ce", "ck", "ec", "hh", "vc", "CCC"], "pec": ["lc", "fc", "csv", "ped", "config", "lv", "pe", "pkg", "erc", "cv", "cm", "clus", "pm", "qv", "plugin", "pc", "che", "cl", "fp", "scl", "cel", "ci", "cmp", "pect", "cmd", "phy", "cf", "cs", "pic", "uci", "context", "cli", "closure", "rc", "ctx", "pes", "spec", "cfg", "icc", "mp", "ocr", "xp", "priority", "cpp", "cci", "seq", "hl", "loc", "cit", "username", "concept", "fi", "ec", "cki"], "fh": ["fch", " fhs", "fhs", "lff", "fdhm", "lfhost", "afH", "vbh", " fbh", "rfh", "rfhs", "vhm", "afhm", "fhm", "fH", "fph", "fbh", " fhost", "fdh", "fhost", " fch", "vH", "vph", "rfhost", "ff", "fdH", "afph", "afh", "vh", "lfhs", "vhost", "vf", " ff", "fdph", "rfch", "lfbh", "lfh", "lfch"], "fid": ["cfmid", "xmid", "paddr", "pids", "rfids", "caddr", "rfide", "hid", "cfaddr", "cids", "pip", "cstart", " fID", "fids", "rfid", "rfstart", "fide", "xID", "cip", "hstart", "cfid", "hide", "pid", "cid", "cfip", "xid", "cfID", "cide", "fmid", "fstart", " fids", " fmid", "cfids", "fID", "hids", "xids", "fip"], "faddr": ["fwd", " fwd", "caddr", "vaddress", "chost", "lid", "caddress", "faddress", "hid", "cfhost", "cfaddr", "lhost", "haddr", "daddr", "dhost", "did", "lwd", "hhost", "cwd", " fhost", "fhost", "vaddr", "cfid", "cid", "haddress", "laddr", "vhost", "vid", "daddress", "cfaddress"], "e": ["je", "est", "i", "ee", "en", "end", "es", "oe", "eu", "ie", "g", "E", "pe", "me", "be", "ed", "d", "f", "ea", "ef", "eve", "y", "r", "ffe", "m", "u", "p", "ace", "o", "le", "c", "eeee", "fe", "edge", "complete", "se", "error", "n", "er", "element", "ei", "ae", "v", "ne", "ec", "l", "ze", "entity"], "sei_cont": ["sei_ci", "fee\u30f3control", "tsy_cont", "sei\u30f3component", "yi_cur", "sei\u30f3ci", "eni__nav", "sei_cms", "fee\u30f3cont", "sei_Cont", "sei__nav", "sei_ctr", "sei\u30f3core", "tsy_desc", "isi_content", "sei\u30f3control", "sei__component", "isi_const", "sei_CONT", "ci_cont", "sei__ctr", "eni_ont", "sei\u30f3ont", "fee_cod", "eni_nav", "sei\u30f3cod", "sei\u30f3cont", "sei_content", "fee_ci", "eni_ctr", "sei_cod", "sei\u30f3ctr", "sei_desc", "yi_core", "cies_cont", "sei_ont", "ci_ct", "sei_component", "eni_cont", "isi_cms", "fee\u30f3cod", "cies_Cont", "tsy_CONT", "sei_ct", "sei\u30f3sequ", "sei_nav", "sei_core", "sei_lc", "sei\u30f3cur", "fee_control", "yi_cont", "sei_dest", "sei\u30f3container", "sei_container", "fee\u30f3ci", "sei_const", "sei__cont", "cies_cot", "sei\u30f3content", "eni__component", "isi_cont", "sei_sequ", "sei_cur", "sei\u30f3nav", "yi_container", "ci_const", "fee_cont", "eni__cont", "eni__ctr", "sei_cot", "eni_component", "ci_dest", "eni_content", "tsy_lc", "eni_sequ", "sei_control", "cies_sequ"], "s": ["sb", "i", "sym", "sl", "ses", "d", "sets", "site", "ds", "services", "f", "sys", "t", "r", "u", "m", "socket", "stat", "ssl", "p", "ls", "o", "sync", "is", "sg", "c", "js", "settings", "b", "service", "session", "S", "ns", "src", "n", "rs", "v", "h", "secondary", "l", "ss", "states"]}}
{"project": "qemu", "commit_id": "81907a582901671c15be36a63b5063f88f3487e2", "target": 1, "func": "void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,\n\n                CPSRWriteType write_type)\n\n{\n\n    uint32_t changed_daif;\n\n\n\n    if (mask & CPSR_NZCV) {\n\n        env->ZF = (~val) & CPSR_Z;\n\n        env->NF = val;\n\n        env->CF = (val >> 29) & 1;\n\n        env->VF = (val << 3) & 0x80000000;\n\n    }\n\n    if (mask & CPSR_Q)\n\n        env->QF = ((val & CPSR_Q) != 0);\n\n    if (mask & CPSR_T)\n\n        env->thumb = ((val & CPSR_T) != 0);\n\n    if (mask & CPSR_IT_0_1) {\n\n        env->condexec_bits &= ~3;\n\n        env->condexec_bits |= (val >> 25) & 3;\n\n    }\n\n    if (mask & CPSR_IT_2_7) {\n\n        env->condexec_bits &= 3;\n\n        env->condexec_bits |= (val >> 8) & 0xfc;\n\n    }\n\n    if (mask & CPSR_GE) {\n\n        env->GE = (val >> 16) & 0xf;\n\n    }\n\n\n\n    /* In a V7 implementation that includes the security extensions but does\n\n     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control\n\n     * whether non-secure software is allowed to change the CPSR_F and CPSR_A\n\n     * bits respectively.\n\n     *\n\n     * In a V8 implementation, it is permitted for privileged software to\n\n     * change the CPSR A/F bits regardless of the SCR.AW/FW bits.\n\n     */\n\n    if (write_type != CPSRWriteRaw && !arm_feature(env, ARM_FEATURE_V8) &&\n\n        arm_feature(env, ARM_FEATURE_EL3) &&\n\n        !arm_feature(env, ARM_FEATURE_EL2) &&\n\n        !arm_is_secure(env)) {\n\n\n\n        changed_daif = (env->daif ^ val) & mask;\n\n\n\n        if (changed_daif & CPSR_A) {\n\n            /* Check to see if we are allowed to change the masking of async\n\n             * abort exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_AW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_A flag from \"\n\n                              \"non-secure world with SCR.AW bit clear\\n\");\n\n                mask &= ~CPSR_A;\n\n            }\n\n        }\n\n\n\n        if (changed_daif & CPSR_F) {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n", "idx": 23956, "substitutes": {"env": ["app", "config", "event", "chal", "exc", "que", "context", "header", "hl", "iss", "global", "doc", "v", "conf", "ev", "inet", "emb", "txt", "org", "password", "end", "conn", "iv", "db", "cookie", "cv", "ench", "oa", "eng", "style", "site", "ah", "dev", "vel", "enc", "code", "ext", "c", "equ", "ass", "fen", "qt", "erv", "empty", "scope", "operator", "net", "e", "forge", "err", "eu", "kernel", "token", "img", "ea", "init", "her", "uv", "Environment", "el", "edge", "enable", "loader", "core", "gr", "skin", "stage", "dat", "manager", "h", "ne", "ec", "enh", "en", "obj", "shell", "energy", "export", "engine", "local", "nc", "entry", "args", "cache", "vs", "dict", "np", "ctx", "viron", "session", "console", "vm", "server", "environment"], "val": ["ee", "config", "lex", "key", "pos", "win", "bit", "data", "vals", "pl", "mem", "rule", "VAL", "doc", "util", "v", "eval", "fi", "ut", "ind", "valid", "item", "db", "al", "pre", "vel", "stat", "unit", "code", "aval", "vol", "pret", "lib", "alt", "li", "reg", "sel", "serv", "ref", "bin", "exec", "ret", "p", "vi", "addr", "rot", "el", "byte", "b", "oval", "loc", "Val", "lit", "x", "count", "sk", "sl", "il", "arg", "ol", "bl", "local", "pal", "cache", "slot", "elt", "py", "ctx", "index", "cal", "min", "len", "vert", "all", "pt", "base", "value"], "mask": ["delay", "miss", "shape", "sk", "config", "scale", "pattern", "kernel", "Mask", "map", "ban", "key", "ack", "feature", "sign", "pad", "weight", "flags", "pixel", "offset", "bit", "bug", "cache", "patch", "lock", "label", "count", "depth", "scan", "comment", "fix", "hack", "header", "strip", "tag", "ask", "pin", "filter", "match", "hide", "pass", "flag", "hash", "alias", "carry", "qa", "magic", "secret", "mark", "shift", "iq", "clean", "black", "batch", "skip", "parent", "shadow", "conf", "gap", "ck", "pack", "cover", "broad", "effect", "allow", "sum"], "write_type": ["writeingbase", " write_style", "call_name", "callingname", "write___type", "write_level", "write___name", "writeinglevel", " write_object", "write_style", "writerobject", "callinglevel", "writeingname", "callingbase", "call_type", "writertypes", "write___base", "writeingtype", "writerstyle", "call_level", "write_types", "write___level", "write_object", " write_types", "callingtype", "write_name", "call_base", "writertype", "write_base"], "changed_daif": ["changed_deenilib", "changed_taig", "changed_deenip", "changed_naife", "changed_taifer", "changed_waiv", "changed_daiff", "changed_naif", "changed_daiv", "changed_daip", "changed_shaip", "changed_naifer", "changed_dailib", "changed_maif", "changed_waip", "changed_waIF", "changed_naIF", "changed_deenIF", "changed_naiff", "changed_taip", "changed_maIF", "changed_naip", "changed_naig", "changed_daife", "changed_daifer", "changed_eaIF", "changed_mailib", "changed_maifer", "changed_eailib", "changed_naiv", "changed_daig", "changed_daIF", "changed_eaif", "changed_taif", "changed_deenif", "changed_taiff", "changed_shaiv", "changed_eaip", "changed_maip", "changed_taIF", "changed_waig", "changed_waife", "changed_shaif", "changed_waif", "changed_shaife", "changed_maiff"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 23965, "substitutes": {"vdev": ["lserv", "pde", "mconn", "svrad", "lrad", "vdiv", " vver", "nvdev", "wver", "mdevice", "ldc", "vserv", "pconf", "lmem", "hoff", "vflow", "gdev", "svdiv", "Vgu", "pmem", "hdiv", "moff", " vdevice", "lver", "coff", "Vconn", "nvdevice", "vdef", " vmem", "cdevice", "nvserv", "gde", "vgu", "cdev", "svproject", "mdev", "herror", "pdata", "ldevice", "nvdiv", " vdef", "gdef", "wdev", "vconf", "vrad", "Vflow", "vconn", "nvdc", "pver", "vdata", " vdiv", " vflow", "lerror", "grad", " vconn", "voff", "nvproject", "pdevice", "svserv", "hdev", "verror", "vdevice", "ldef", "gproject", " verror", "vproject", "gconn", "pdiv", "vmem", "Vdev", "mdef", "svdev", "gconf", "wdiv", " vgu", "gver", "gserv", "svde", " vconf", "ldata", "svdevice", "gdc", "mflow", "hdef", "mgu", "vdc", "vver", "pdev", "hdevice", "wdevice", " vdata", "ldev", "gdevice", "pconn", "lde", "vde", "gdiv", "cdef"], "nr": ["name", "nin", "next", "our", "err", "adr", "nn", "nic", "chain", "nir", "eni", "none", "rx", "rin", "rr", "rec", "wr", "tr", "yr", "rf", "lr", "no", "outer", "nl", "uj", "nc", "r", "nov", "or", "NR", "number", "np", "inner", "rw", "ng", "rn", "num", "nar", " NR", "ar", "fr", "sr", "nw", "ii", "usr", "counter", "seq", "n", "src", "gr", "br", "mr", "nb", "iter", "iq", "range", "ner", "radius", "nt", "inter", "sn", "nor", "rb", "manager", "nob", "nu", "rue", "attr", "nm", "ni", "rg"], "quirk": ["qirt", "affik", "squirk", "squirt", "requik", " quirt", " quavour", "acquavour", "iqulict", "quoise", "equlict", "equir", "requark", "aquark", "squark", "QUirt", "affirt", "requirk", "affird", "quash", "affirk", "QUirk", "acquik", "coirk", "equork", "coik", "qik", "quelict", "iquirus", "quirrel", "qulict", "acquoise", "quirus", "querark", "QUirrel", "aquoise", "acquird", "iquird", "queark", "sqash", "shirk", "aquirrel", "promark", "quork", "equirk", "sqork", "aquirt", "quir", "iquir", "aquirk", "equash", "QUark", "promik", " quash", "quack", "confirt", "querik", "shirt", "sqark", " quirrel", " quork", "quark", "querirk", "queirk", "coirt", "iquirk", " quirus", "equirt", "iquirt", "equark", "coird", "confirk", "requird", "promird", "aquavour", "promirt", "sqirk", "confirus", "promirk", "quird", "confird", "shird", "quirt", "iquark", "quavour", "requirt", "qirk", "squlict", "acquirk", "shack", " qulict", "acquner", "queir", "qird", " quoise", "acquark", "quner", " quner", "promack", "querirt", "acquirt", "quik", " quird", "qark", "qack", "equik", "QUlict", "aquner", " quark"], "mirror": ["silverceptor", "mirrage", " mirra", "matrr", "prror", "mirace", "mirra", "matception", " mirrorrect", "mirrect", "perron", "matmbol", "jerrc", "verior", "irron", "permbol", "marrage", "jerrored", "varror", "marrect", "merray", "matror", " mirrored", "murner", " mirrage", "varrr", "irrored", " mirrormbol", "ironmbol", " mirrr", "marra", "mirceptor", "earner", " mirrect", " mirrorrog", "horrr", "murmbol", "varrog", "earder", "murror", "merner", "hyperrect", "ironception", "pirra", "irrup", "marrup", "varrored", "perrr", "prder", "perrc", "mirrog", "irner", "mirray", "irace", "marray", "marmbol", "pirror", " mirrup", "verrog", "varra", "marrored", "irror", "mirbug", "verceptor", "ironror", "hyperder", "pirrage", "marror", "varceptor", "irrr", " mirron", " mirrorceptor", "perace", "merrr", "horner", "murrage", "varmbol", "perrored", " mirace", "irior", "hyperror", "horror", "mirrc", " mirner", "irrect", "earmbol", "mirrored", "irri", "varior", "ironrect", "verror", "jerror", "earror", "hypermbol", "irceptor", "perri", " mirceptor", "marrr", "marbug", "varrup", "irra", " mirrorior", "irray", "matrect", "prmbol", " mirrorception", "mirron", "mirner", "mirrr", "merior", "pirrored", "prrect", "varbug", "mirception", "matner", "mirior", " mirrorror", "irmbol", "merrect", "jermbol", "silverner", "perra", "horrect", "marner", "silverrr", "mirri", "merror", "varrage", "mirder", "irbug", "mirmbol", "mirrup", "earra", "silverror", " mirmbol", "earrect", " mirri", " mirrc", "perner", "varner", " mirior"]}}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009, "substitutes": {"ctx": ["conv", "bc", "cam", "wcs", "cc", "gpu", "conn", "obj", "config", "pkg", "cv", "func", "tx", "ca", "Context", "anc", "cas", "cl", "cmp", "exec", "cmd", "cp", " cx", "cf", "cs", "mc", "ctrl", "kb", "context", "tc", "cli", "xc", "rc", "c", "cb", "cfg", "sc", "comp", "cpp", "gc", "src", "loc", "utils", "proc", "vc"], "arg0": ["param4", "argument0", "param2", "param8", "arg8", "Arg1", "Arg0", " arg4", "argument1", "param1", "argument2", "param0", "argument8", " arg8", "arg4", "Arg4"], "arg1": ["argument0", "arg01", "Arg01", " arg01", "argument3", "arg3", "args3", "Arg1", "ark2", " arg3", "args01", "argument1", "argument01", "argument2", "args0", "args1", "args2", "ark1", "ark01", "Arg2", "ark0", "Arg3"], "arg2": ["param4", " arg02", "param2", "arg02", "param5", "ag02", "Arg1", "ag2", "args4", " arg4", " arg5", "Arg5", "ag4", "param1", "args02", "args1", "args2", "Arg2", "arg4", "Arg4", "arg5", "ag1"], "sub": ["member", "bc", "reg", "sel", "asm", "con", "rec", "leaf", "control", "split", "neg", "rob", "rel", "super", "job", "diff", "trans", "mid", "submit", "small", "second", "sc", "dim", "ub", "sing", "desc", "child", "sup", "loc", "comb", "south", "Sub", "lib", "sec", "sq", "sum", "pub"]}}
{"project": "FFmpeg", "commit_id": "cd19c677cb5dcaecc472c021bd38370817740a5e", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, \n\n                             void *data, int *data_size,\n\n                             uint8_t *buf, int buf_size)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    MpegEncContext *s = &h->s;\n\n    AVFrame *pict = data; \n\n    int buf_index;\n\n    \n\n    s->flags= avctx->flags;\n\n    s->flags2= avctx->flags2;\n\n\n\n   /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_TRUNCATED){\n\n        int next= find_frame_end(h, buf, buf_size);\n\n        \n\n        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )\n\n            return buf_size;\n\n//printf(\"next:%d buf_size:%d last_index:%d\\n\", next, buf_size, s->parse_context.last_index);\n\n    }\n\n\n\n    if(h->is_avc && !h->got_avcC) {\n\n        int i, cnt, nalsize;\n\n        unsigned char *p = avctx->extradata;\n\n        if(avctx->extradata_size < 7) {\n\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n\n            return -1;\n\n        }\n\n        if(*p != 1) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown avcC version %d\\n\", *p);\n\n            return -1;\n\n        }\n\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n\n           so put a fake nal_length_size = 2 while parsing them */\n\n        h->nal_length_size = 2;\n\n        // Decode sps from avcC\n\n        cnt = *(p+5) & 0x1f; // Number of sps\n\n        p += 6;\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding sps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Decode pps from avcC\n\n        cnt = *(p++); // Number of pps\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize)  != nalsize) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding pps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Now store right nal length size, that will be use to parse all other nals\n\n        h->nal_length_size = ((*(((char*)(avctx->extradata))+4))&0x03)+1;\n\n        // Do not reparse avcC\n\n        h->got_avcC = 1;\n\n    }\n\n\n\n    if(!h->is_avc && s->avctx->extradata_size && s->picture_number==0){\n\n        if(decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0) \n\n            return -1;\n\n    }\n\n\n\n    buf_index=decode_nal_units(h, buf, buf_size);\n\n    if(buf_index < 0) \n\n        return -1;\n\n\n\n    //FIXME do something with unavailable reference frames    \n\n \n\n//    if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_index, buf_size);\n\n    if(!s->current_picture_ptr){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"error, NO frame\\n\");\n\n        return -1;\n\n    }\n\n\n\n    {\n\n        Picture *out = s->current_picture_ptr;\n\n#if 0 //decode order\n\n        *data_size = sizeof(AVFrame);\n\n#else\n\n        /* Sort B-frames into display order */\n\n        Picture *cur = s->current_picture_ptr;\n\n        Picture *prev = h->delayed_output_pic;\n\n        int out_idx = 0;\n\n        int pics = 0;\n\n        int out_of_order;\n\n        int cross_idr = 0;\n\n        int dropped_frame = 0;\n\n        int i;\n\n\n\n        if(h->sps.bitstream_restriction_flag\n\n           && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n            s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n            s->low_delay = 0;\n\n        }\n\n\n\n        while(h->delayed_pic[pics]) pics++;\n\n        h->delayed_pic[pics++] = cur;\n\n        if(cur->reference == 0)\n\n            cur->reference = 1;\n\n\n\n        for(i=0; h->delayed_pic[i]; i++)\n\n            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)\n\n                cross_idr = 1;\n\n\n\n        out = h->delayed_pic[0];\n\n        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)\n\n            if(h->delayed_pic[i]->poc < out->poc){\n\n                out = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        out_of_order = !cross_idr && prev && out->poc < prev->poc;\n\n        if(prev && pics <= s->avctx->has_b_frames)\n\n            out = prev;\n\n        else if((out_of_order && pics-1 == s->avctx->has_b_frames)\n\n           || (s->low_delay && \n\n            ((!cross_idr && prev && out->poc > prev->poc + 2)\n\n             || cur->pict_type == B_TYPE)))\n\n        {\n\n            s->low_delay = 0;\n\n            s->avctx->has_b_frames++;\n\n            out = prev;\n\n        }\n\n        else if(out_of_order)\n\n            out = prev;\n\n\n\n        if(out_of_order || pics > s->avctx->has_b_frames){\n\n            dropped_frame = (out != h->delayed_pic[out_idx]);\n\n            for(i=out_idx; h->delayed_pic[i]; i++)\n\n                h->delayed_pic[i] = h->delayed_pic[i+1];\n\n        }\n\n\n\n        if(prev == out && !dropped_frame)\n\n            *data_size = 0;\n\n        else\n\n            *data_size = sizeof(AVFrame);\n\n        if(prev && prev != out && prev->reference == 1)\n\n            prev->reference = 0;\n\n        h->delayed_output_pic = out;\n\n#endif\n\n\n\n        *pict= *(AVFrame*)out;\n\n    }\n\n\n\n    assert(pict->data[0]);\n\n    ff_print_debug_info(s, pict);\n\n//printf(\"out %d\\n\", (int)pict->data[0]);\n\n#if 0 //?\n\n\n\n    /* Return the Picture timestamp as the frame number */\n\n    /* we substract 1 because it is added on utils.c    */\n\n    avctx->frame_number = s->picture_number - 1;\n\n#endif\n\n    return get_consumed_bytes(s, buf_index, buf_size);\n\n}\n", "idx": 24018, "substitutes": {"avctx": ["aveca", "avecf", "avescope", "awcontext", "afca", "AVc", "avconfig", "AVcu", "AVca", "navlinux", "afloc", "navctx", "avlc", "awctx", " avcf", "avxc", "AVlc", "afconfig", "aircp", "auctl", "ajctx", "AVloc", "navcam", "navcontext", "avecu", "aveconfig", "aveloc", "avec", "afsync", "avsync", "airctx", "afcci", "afcam", "awcit", " avcit", "avcp", "avecp", "afctx", "AVsync", "avscope", "avelc", "avecci", "avcontext", "aircci", " avctl", "AVctx", "afcp", "afxc", "avcam", "AVconfig", "avcit", "ajcontext", "navscope", "afctl", "aucontext", "avexc", "avcf", "afscope", "avca", "ajlinux", "aucam", "ajscope", "afcu", "avcu", "avctl", "avlinux", "navctl", "avectx", "afcit", "afcontext", "aircontext", "afc", "auctx", "awctl", "aflc", "avesync", "avcci", "afcf", " avscope", "aflinux", "AVcontext", "avecontext", "avc", " avxc", " avcontext", "avloc"], "data": ["start", "response", "next", "sample", "result", "input", "val", "Data", "d", "img", "f", "buffer", "m", "size", "da", "o", "body", "record", "memory", "rc", "frame", "fr", "a", "b", "DATA", "window", "raw", "media", "reader", "buff", "dat", "image", "block", "base", "video", "value"], "data_size": ["data_SIZE", "dataallsize", "data_sized", "dataallSIZE", "data_channel", "dataallchannel", "dataallsized", " data_channel", " data_sized", " data_SIZE"], "buf": ["conv", "bc", "pb", "uf", "uc", "next", "ref", "config", "result", "cv", "fb", "queue", "func", "img", "fp", "cas", "buffer", "cmd", "cf", "context", "wb", "rc", "header", "cb", "ctx", "frame", "b", "window", "seq", "ff", "src", "fd", "foo", "br", "flow", "batch", "buff", "border", "v", "array", "vec", "rb", "bag", "block", "fi", "feat"], "buf_size": ["bufnname", " buf_len", "buffer_name", "buf64len", "buf64size", "uf_send", "buf_len", "buf64length", "bufdsize", "buffer_index", "buf_length", "buf_unit", "bufslen", "uf2send", "buf2name", "buf2len", "buffer_size", "bufxcount", "buf2index", "bufssize", "bufnlen", "data_unit", "bufpsend", "bufdlen", "buf_send", "bufslength", "buffer_count", "buf_scale", "uf2length", "buf2send", "bufxindex", "buf_count", "bufxscale", "bufpsize", "buffer_scale", "buffer_len", "bufxsize", "uf_size", "data_scale", "bufnsize", "uf2size", "buf2length", " buf_length", "bufplength", "bufdunit", "buf2size", "bufdscale", "uf_unit", "bufnindex", "data_len", "buf_name", "buf2unit", "uf_length", "bufpunit", "uf2unit"], "h": ["ih", "hhh", "hp", "hm", "e", "ul", "hs", "g", "ha", "this", "han", "d", "oh", "host", "home", "f", "t", "r", "eh", "m", "ah", "u", "j", "hd", "rh", "context", "q", "o", "uh", "H", "c", "ctx", "self", "header", "sh", "ch", "hr", "b", "w", "he", "hl", "zh", "gh", "history", "hi", "buff", "v", "ec", "bh", "http", "hw", "z", "l", "ph", "ht", "hh"], "s": ["sv", "sb", "e", "sym", "support", "qs", "sl", "fs", "g", "ses", "ssh", "input", "hs", "sports", "d", "ops", "l", "ds", "f", "t", "m", "storage", "ssl", "shared", "cs", "setup", "ts", "ls", "o", "sync", "sa", "sg", "c", "ctx", "client", "spec", "settings", "sq", "sh", "js", "sc", "si", "b", "w", "service", "aws", "n", "S", "ns", "session", "slice", "sup", "sf", "parser", "ps", "rs", "gs", "v", "conf", "sec", "sp", "http", "secondary", "scope", "server", "su", "ss", "share"], "pict": ["fa", " r", " w", "ref", "fs", "cv", "fb", " b", "img", "rf", "f", "buffer", "r", "af", "rc", "cb", "fr", " f", "raw", "fm", "fl", "src", "F", "fw", "fd", "z", " fa", "rb", "fn", "fi"], "buf_index": ["cf_offset", "buf_offset", "buf_toc", "cf_size", "cf_toc", "cf_index"], "i": ["io", "e", "ix", "ie", "fi", "qi", "ind", "ri", "ui", "eni", "g", "part", "me", "gi", "d", "uri", "chi", "ti", "I", "l", "type", "f", "ci", "y", "phi", "info", "ini", "oi", "it", "j", "u", "ip", "at", "id", "code", "vi", "o", "bi", "mi", "ori", "c", "mu", "index", "si", "ii", "b", "ji", "n", "iu", "slice", "ai", "xi", "hi", "di", "v", "multi", "yi", "li", "api", "pi", "x", "zi", "ni", "count"], "cnt": ["cnd", "nNT", "lcne", "Cnc", "ucne", "cNT", "nnt", " cnc", "CNT", "ecnt", "ecnc", "ecant", "ecnd", "ucnt", "ucnn", "ecNT", "lcnt", "ucnc", "cnc", "C0", " cne", " c0", "ecct", "cne", "lcnn", "nant", "cnn", " cnd", " cnn", " cNT", "nnc", "ec0", "cant", "Cnd", "cct", "Cct", "Cnt", "Cant", " cant", " cct", "c0", "lcnc"], "nalsize": ["nalsIZE", "callsiz", " nasesite", "notalesiz", "nallsizes", "nasesizer", "nalesIZE", "nitesize", "nALSizer", "Nalsiz", "nassIZE", "nalesized", "lalesize", "callsizes", "lalsize", "nassization", "Nalescore", "nalsite", "notaliz", "nALSize", "nelsiz", "nalesize", "NalsIZE", "callssize", "notalsizer", "nallyiz", "callsize", "nALSiz", " nalsizer", "nasesize", "nallsite", "notalsiz", "lalesiz", "nallyizer", "nallyization", "nassiz", "nalesite", "nelsized", "notalcore", "lalesizer", "nitesization", "Nalesizer", "notalize", "lalssize", "Nalesize", "nasesite", "notalesIZE", "nalsization", "nallsize", "Nalesization", "nallsIZE", "notalizer", "nalsizer", "nalesizes", "nelssize", "nalfsize", "nalscore", "nalesization", "lalessize", "nalssize", "calsiz", "nalsized", " nasesizer", "nalsiz", "nelsizes", " nalsite", "notalsIZE", "calsize", "nelsization", "notalesizer", "nalfiz", "nallsiz", " nalsiz", " nasesize", "Nalesiz", "Nalscore", "nalfizer", "nalessize", "Nalsize", "nallsizer", "nallyIZE", "notalesize", "nallyize", "nalescore", "NalesIZE", "notalesized", "nalesiz", "calsizes", "nasesiz", "nallssize", "nasesization", "nassize", "nALScore", " nasesiz", "nalfize", "Nalsization", "notalsized", "nalesizer", "notalesization", "nitesiz", "nallsization", "nalsizes", "calssize", "nelsize", "nitesized", "lalsiz", "Nalsizer", "notalsization", "notalsize", "lalsizer"], "p": ["pb", "port", "after", "e", "press", "ap", "jp", "lp", "g", "op", "pe", "part", "post", "d", "pm", "P", "bp", "pc", "l", "fp", "f", "po", "per", "t", "y", "r", "u", "m", "pre", "cp", "j", "tp", "pp", "patch", "ip", "at", "point", "o", "np", "q", "py", "c", "pr", "pl", "wp", "a", "b", "x", "pat", "n", "ps", "v", "up", "sp", "vp", "pointer", "api", "pt", "pi", "dp", "pn", "pa"]}}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 24044, "substitutes": {"cpu": ["lc", "platform", "computer", "fc", "lb", "uc", "gpu", "conn", "linux", "config", "lp", "GPU", "nic", "kernel", "performance", "pkg", "consumer", "processor", "process", "pc", "CPU", "node", "css", "cmp", "proxy", "nc", "cp", "fps", "gru", "cache", "program", "ucc", "component", "unit", "uci", "np", "mac", "cli", "rc", "c", "ctx", "px", "module", "cn", "cfg", "roc", "gp", "ocr", "uca", "dc", "loader", "cpp", "uu", "comp", "core", "auc", "gc", "chip", "console", "utils", "boot", "proc", "vm", " CPU", "hw", "instance", "clock", "pu", "cu", "ilo"], "cc": ["lc", "bc", "fc", "cd", "uc", "LC", "cm", "BC", "con", "ca", "pc", "css", "anc", "cl", "cmp", "ac", "acc", "cp", "cache", "ucc", " CC", "mc", "cf", "cs", "ctrl", "tc", "PC", "rc", "ctx", "cn", "sc", "dc", "cci", "CC", "gc", "core", "cca", " gcc", "ck", "ec", "vc"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047, "substitutes": {"list": ["stack", "name", "config", "acl", "chain", "loop", "result", "queue", "lists", "layer", "listed", "pre", "sequence", "full", "List", "code", "sync", "cli", "live", "client", "out", "self", "complete", "la", "collection", "low", "seq", "top", "call", "batch", "parent", "li", "all", "LIST", "l", "base", "this"], "func": ["fc", "expr", "stack", "cc", "prev", "next", "wrapper", "loop", "val", "unc", "apply", "handler", "pc", "interface", "invoke", "function", "f", "layer", "exec", "op", "adder", "nc", " function", "r", "cf", "ace", "c", "cb", "later", "complete", "lambda", "b", "go", "worker", "callback", "back", "proc", "up", "fn", "fun"], "opaque": ["operacity", "opaques", "operaque", "opsacs", "opspha", "opusacity", "opsacity", "opsaques", "ipaques", "ipaque", "ipacle", "opusaque", "opusacs", "opacle", "opuspha", "oppha", " oppha", " opacs", "opacity", "operacle", " opacity", "opsacle", "opsaque", "operaques", "ipacity", "opacs"], "abort_on_failure": ["abort_on_structash", "abort_on_passure", "abort_on_failured", "abort_on_flowured", "abort_on_structure", "abort_on_failedion", "abort_on_fallur", "abort_on_failedured", "abort_on_failion", "abort_on_flowure", "abort_on_failures", "abort_on_failedURE", "abort_on_structures", "abort_on_flowion", "abort_on_failur", "abort_on_passash", "abort_on_flowURE", "abort_on_failash", "abort_on_fallures", "abort_on_structur", "abort_on_fallure", "abort_on_passURE", "abort_on_passion", "abort_on_passured", "abort_on_passures", "abort_on_passur", "abort_on_failURE", "abort_on_fallash", "abort_on_failedure"], "opts": [" optms", " opms", "opters", "operrs", "opcs", "optps", "optters", " opks", "operps", " optters", "operts", "appcs", "opms", "optrs", "hopts", "oprs", " opcs", " opte", " optcs", "opte", "optte", " optts", "opps", "opercs", "optms", "hopte", "optks", "hopters", "appps", "optcs", "hopks", "opks", "appts", "optts", "apprs", " opters"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n", "idx": 24050, "substitutes": {"opaque": ["ospac", "OPaque", "opaques", "ospacity", "OPaques", "opatile", "ipaques", "ipaque", "OPatile", "ospatile", "ppatile", "ipac", "ppaques", "ppaque", "ospaques", "opacity", "OPacity", "OPac", "opac", "ospaque", "ipacity"], "addr": ["az", "eno", "grad", "start", "area", "rd", "tta", "asm", "obj", "adr", "config", "amp", "eni", "eth", "mode", "oa", "ord", "ack", "rx", "afi", "amd", "rr", "align", "host", "access", "pad", "node", "layer", "ea", "pos", "ld", "dist", "proxy", "adder", "coord", "address", "dd", "ad", "data", "fx", "ip", "ace", "prefix", "work", "code", "mac", "id", "au", "dr", "la", "index", "nr", "edge", "ady", "ar", "x", "ptr", "xp", "Address", "seq", "alias", "src", "slice", "loc", "alt", "pointer", "orig", "offset", "base", "attr", "url"], "value": ["name", "Value", "end", "store", "valid", "val", "key", "function", "buffer", "write", "address", "fee", "size", "data", "ret", "version", "number", "prefix", "buf", "content", "index", "values", "complete", "num", "byte", "x", "set", "w", "seq", "length", "flow", "v", "array", "block", "server", "offset", "VALUE", "format", "padding"], "len": ["lc", "name", " val", "limit", "en", "valid", "val", "format", "ln", "bytes", "offset", "pos", "lan", "size", "data", "label", "count", "field", "lin", "la", "el", "lim", "num", "low", "line", "seq", "rev", "min", "n", "length", " length", "fd", "ll", "lon", "base", "lib", "alt", "z", "li", "lf", "lit", "l", "Len", "fun"], "mmio": ["pmio", "MMios", "memio", "tmorg", "magIO", "memIO", "MMi", "emIO", "cmios", "MMiol", "pmIO", "mpi", " mmi", "mpio", "cmro", "emios", " mmiol", "emorg", "mmios", "cmio", "mmino", "temino", "mmiol", "cmino", "tmio", "mmorg", " mmro", "MMio", "emio", "mmro", " mmios", "mmi", "memno", "mpios", " mmino", " mmno", " mmIO", "temios", "magio", "temio", "pmno", "pmios", "tmios", "tmIO", "memios", "temro", "magorg", "mpiol", "mmIO", "magios", "mmno"], "section": ["lc", "writer", "name", "area", "esc", " Section", "establishment", "config", "option", " entry", "part", "layout", "connection", "region", " sector", "protection", "site", " replacement", "function", "ion", "proxy", "address", "entry", " setup", " intersection", "size", "description", "version", "component", " structure", "context", "ECTION", "comment", "closure", "sections", "rc", "sector", "tag", " extension", "source", "Section", "sub", "behavior", "sect", "service", "se", "set", "core", "division", "session", " subscription", "slice", "definition", "loc", "parent", "shadow", "pair", "array", "sec", "vision", "instance", "script", "server", "environment", "ie", " SECTION", " subsection", " segment"]}}
{"project": "FFmpeg", "commit_id": "48e52e4edd12adbc36eee0eebe1b97ffe0255be3", "target": 0, "func": "static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 24072, "substitutes": {"avctx": ["awcontext", "avcv", "akcmd", "Avmac", "awconv", "airctx", "afcmd", "Avconv", "AVcontext", "afctx", "avcas", "avconv", "AVmac", "akcontext", "Avcomponent", "afcas", "Avcontext", "Avcv", "akctx", "awctx", "Avcmd", "avcontext", "aircomponent", "avcomponent", "Avcas", "airmac", "Avctx", "avcmd", "aircontext", "AVctx", "AVcomponent", "AVcv", "AVconv", "afcontext", "avmac", "awcv", "akcas"], "ctx": ["bc", "fc", "cam", "ct", "config", "acl", "cm", "connection", "pc", "cp", "data", "cs", "xc", "prefix", "kb", "context", " context", "qa", "fw", "cus", "instance", "wcs", "support", "conn", "jp", "coll", "pkg", "cv", "anc", "fp", "ci", "component", "setup", "mac", "c", "cb", "wp", "sc", "ce", "concept", "cu", "vc", "conv", "lc", "cc", "tx", "cas", "cmp", "exec", "cmd", "p", "cf", "tc", "cli", "comp", "python", "loc", "cca", "hw", "obj", "sci", "kt", "ca", "Context", "nc", "mc", "ctrl", "np", "sync", "client", "cn", "aux", "auc", "parent", "kw", "ck"], "dl_fn": ["ll_function", "dl_func", "DL_module", "ll_fn", "dl1fn", "DL_conn", "dl_module", "DL_fn", "DL_ln", "dlpfn", "dlpfd", "dl_fd", "dlWconn", "dl1function", "ll_fd", "dlWfn", "dl_ln", "dl1func", "dlpfunction", "dl_conn", "dl1fd", "dlWln", "dl_function", "dlWmodule", "dlpfunc", "ll_func"], "p_nvenc": ["p_purenc", "p_cvenf", "p_cavenc", "p_nvencs", "p_nvenf", "p_nrenf", "p_nvincs", "p_cvenec", "p_nvinec", "p_pvenci", "p_purencs", "p_cvencs", "p_navenf", "p_nrencs", "p_cavenec", "p_nvincc", "p_nvenec", "p_pvencc", "p_nurenc", "p_navenec", "p_purenci", "p_nvencc", "p_nvinf", "p_nvinci", "p_nvenci", "p_navencc", "p_nurencs", "p_navenci", "p_pvenc", "p_nvinc", "p_navencs", "p_navenc", "p_cavenf", "p_nrenc", "p_cvenc", "p_nrenec", "p_nurencc", "p_purencc", "p_pvencs", "p_cavencs", "p_nurenci"], "i": ["io", "lc", "e", "ix", "start", "ie", "fi", "qi", "ind", "ri", "iv", "ui", "g", "part", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "y", "phi", "info", "m", "u", "adi", "j", "oi", "ini", "full", "ip", "abi", "p", "id", "current", "o", "bi", "inner", "load", "mi", "code", "mu", "index", "si", "a", "ii", "b", "ji", "in", "iu", "slice", "ai", "xi", "di", "r", "multi", "v", "yi", "li", "pointer", "h", "block", "pi", "x", "zi", "isin", "count"], "nb_registered_frames": ["nb_registered_flows", "nb_registered64frames", "nb_registered64Frames", "nb_loaded_flows", "nb_loaded_images", "nb_registered64objects", "nb_registered_images", "nb_registered_frame", "nb_registeredjobjects", "nb_registered_Frames", "nb_loaded_frame", "nb_registeredjframe", "nb_registeredjframes", "nb_registeredjFrames", "nb_loaded_frames", "nb_loaded_cycles", "nb_registered_devices", "nb_registered_objects", "nb_loaded_Frames", "nb_registered64frame", "nb_loaded_objects", "nb_registered_cycles", "nb_loaded_devices"]}}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n", "idx": 24075, "substitutes": {"cpu": ["lc", "platform", "computer", "bench", "fc", "lb", "gpu", "conn", "kernel", "performance", "cm", "consumer", "processor", "css", "CPU", "node", "pc", "intel", "cmp", "nc", "phy", "cp", "gru", "cache", "tp", "uno", "runner", "uci", "mac", "cli", "cow", "coe", "cb", "ctx", "cfg", "roc", "gp", "uca", "loader", "gc", "core", "auc", "chip", "chu", "boot", "proc", "vm", "hw", "clock", "pu", "gb", "ilo"], "addr": ["target", "e", "conn", "ref", "adr", "config", "hop", "amp", "ast", "mode", "oa", "ord", "ack", "amd", "align", "host", "pad", "node", "device", "layer", "ea", "ld", "nc", "address", "data", "p", "point", "ace", "work", "mac", "code", "rc", "index", "nr", "add", "ptr", "xp", "Address", "arm", "src", "slice", "len", "pointer", "offset", "x", "attr"], "i": ["io", "e", "ix", "qi", "ri", "ui", "eni", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "u", "phi", "m", "ini", "oi", "j", "ip", "p", "abi", "id", "o", "bi", "c", "mu", "index", "si", "ii", "b", "x", "n", "iu", "ai", "xi", "di", "v", "z", "multi", "li", "yi", "pi", "fi", "zi", "k", "ni"]}}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n", "idx": 24084, "substitutes": {"bs": ["bc", "pb", "sb", "bos", "outs", "lb", "bis", "qs", "ba", "fs", "ubs", "als", "fb", "bb", "ops", "bytes", "bin", "bid", "ds", "bes", "bl", "bas", "os", "vs", "cs", "ts", "ls", "bi", "bps", "b", "bits", "blocks", "ns", "BS", "bd", "Bs", "ps", "gs", "rs", "banks", "bus", "ss"]}}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 24085, "substitutes": {"qov": ["kov", "qova", "ghOV", "qoval", " qoval", "woval", "sqovi", "qOV", "sqova", " qovi", "qovi", "ghoval", "qtoval", "qovo", "wOV", "ghov", "wov", "ghovo", "sqov", "kovo", "qtovi", "qtov", " qova", "wovo", "sqoval", "koval", "kOV", "qtova"], "value": ["package", "stack", "name", "target", "example", "Value", "object", "result", "val", "none", "key", "message", "null", "queue", "feature", "node", "function", "weight", "buffer", "u", "entry", "address", "size", "data", "version", "p", "number", "id", "depth", "comment", "content", "index", "values", "source", "w", "length", "child", "flow", "element", "expression", "reference", "parent", "v", "array", "instance", "block", "server", "image", "VALUE", "type"], "e": ["i", "ee", "en", "oe", "eu", "g", "E", "pe", "ed", "de", "d", "l", "node", "ea", "f", "esi", "u", "r", "entry", "m", "eb", "j", "p", "ep", "o", "c", "el", "fe", "edge", "x", "se", "ele", "enter", "n", "er", "element", "ei", "ae", "v", "ne", "ce", "ge", "eg", "ie", "ev", "ec", "entity"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n", "idx": 24087, "substitutes": {"x": ["ix", "ux", "xt", "lex", "xs", "xxx", "xy", "rx", "tx", "xx", "y", "ex", "php", "xf", "xc", "px", "xes", "c", "ctx", "X", "plus", "xa", "xp", "w", "xi", "z", "v", "xb"], "items": ["times", "example", "item", "rows", "features", "xs", "lines", "bytes", "ops", "properties", "pieces", "orders", "ids", "members", "classes", "izes", "groups", "xml", "values", "bits", "cycles", "blocks", "objects", "ms", "keys", "points", "events", "Items", "ins", "ips", "pages", "eps"], "size": ["member", "i", "name", "shape", "e", "iz", "ix", "config", "scale", "item", "g", "sized", "Size", "sign", "ize", "weight", "order", "address", "s", "j", "storage", "fee", "args", "unit", "izes", "grow", "count", "code", "o", "timeout", "c", "small", "index", "capacity", "si", "speed", "value", "n", "length", "len", "loc", "large", "page", "z", "sec", "SIZE", "empty", "position", "k", "sum"], "p": ["i", "e", "ap", "jp", "lp", "g", "pe", "pi", "d", "P", "pc", "fp", "f", "po", "per", "t", "pre", "y", "u", "cp", "r", "j", "data", "tp", "pp", "ip", "point", "o", "np", "q", "py", "c", "b", "n", "ps", "v", "z", "sp", "l"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090, "substitutes": {"vs": ["obs", "sv", "VS", "vers", "qs", "serv", "vt", "lv", "fs", "iv", "config", "uns", "ses", "xs", "cv", "lines", "vg", "qv", "ops", "ks", "ds", "flags", "pos", "env", "fps", "s", "ils", "state", "ys", "cs", "ls", "Vs", "vi", "vis", "stats", "rc", "settings", "ctx", "spec", "wp", "sts", "ii", "vr", "ov", "ms", "rev", "verts", "vol", "ns", "va", "ps", "rs", "gs", "vert", "eps", "v", "alls", "vm", "bs", "vp", "ss", "pps", "vc"], "x": ["col", "row", "i", "xs", "xy", "d", "f", "pos", "ex", "m", "p", "o", "px", "c", "index", "dx", "X", "on", "b", "n", "z", "v", "image", "l"], "y": ["col", "i", "hot", "vy", "yy", "xy", "d", "f", "t", "r", "m", "j", "p", "o", "q", "c", "ch", "a", "b", "Y", "n", "z", "l"], "w": ["row", "i", "ow", "level", "g", "wa", "d", "height", "f", "win", "r", "m", "size", "wh", "p", "q", "W", "c", "wt", "b", "n", "sw", "fw", "ew", "wx", "v", "z", "hw", "l", "max", "k"], "h": ["ih", "i", "end", "g", "d", "height", "f", "t", "u", "ht", "m", "r", "hd", "p", "rh", "o", "q", "H", "c", "ch", "b", "n", "gh", "th", "hi", "z", "v", "hw", "l", "ph", "k", "hh"], "palette": ["plipe", " palignment", "Palge", "palote", "reallette", "palettes", "alge", "pallette", "alettes", "alette", "plettes", "Palenge", "realette", "palge", "Palettes", "Palipe", "plignment", "mallette", "Palette", " palettes", "Palignment", "realenge", " palote", "palenge", " palenge", "plette", "malignment", " pallette", "realettes", "palipe", "realignment", "palignment", "allette", " palge", "malette", "realge", "Pallette", "malote", "realipe", "Palote"], "color_type": ["colorPtypes", " color_version", "colorPstr", "channel_types", "colorvalvalue", "color_str", "color32ty", "colorftypes", "channel_source", "colorvalversion", "channelftype", "type_role", "color_count", "colorvaltype", "color__count", "channelfsource", "colorPsource", " color_count", "color32types", "colorenrole", " color_types", "color_unit", "color__unit", "colorenType", "color_var", "color32var", "typeentype", "color_source", "colorfsource", "color32type", "channelfstr", "channel_type", "color_ty", "colorentype", " color_var", "color_types", " color_value", " color_style", "colorvalunit", "color_version", "color_style", "colorftype", "colorfstr", " color_ty", "type_Type", "channelftypes", "colorvalstyle", " color_unit", "color_role", "channel_str", "colorvalcount", "typeenrole", "type_type", "colorvaltypes", "color_value", "color__types", "colorPtype", "color_Type", "typeenType", "color__type"], "png_ptr": ["px_dr", "wp67rot", "img_ptr", "txt_Ptr", "png_rt", "np_fd", "img_ref", "png_addr", "png_Ptr", "np_pointers", "png67rt", "png67pt", "pngAMaddress", "png_ref", "img_tty", "png00dr", "wp67ptr", "ng_desc", "img_addr", "png_pointer", "wp_addr", "package67addr", "wp67addr", "png_push", "package67ptr", "ng_ptr", "txt_ptr", "png67pointer", "img_pointer", "png67tty", "png_proc", "img_desc", "png00transfer", "png_rot", "png_pointers", "px00transfer", "pnglptr", "ng_pointer", "png00tty", "png67desc", "png00push", "png__ptr", "png00ptr", "png00addr", "png_address", "np_inst", "px00dr", "package67pt", "np_ptr", "png00desc", "pngAMptr", "package_pt", "png67rot", "png_transfer", "px_transfer", "pnglref", "wp67pointer", "pnglpointers", "png_pt", "wp_rot", "px00push", "txt_pointer", "pngAMref", "img_address", "png_desc", "np_tr", "pnglinst", "ng_ref", "png67addr", "np_pointer", "np_ref", "px_ptr", "png_inst", "png__desc", "pngAMproc", "img_tr", "png67Ptr", "px_push", "png__pointer", "img_Ptr", "png_fd", "package_ptr", "img_proc", "png_dr", "wp_pointer", "png67ptr", "png_tty", "png__ref", "px00ptr", "png_tr", "wp_ptr", "txt_rt", "package_addr"], "info_ptr": ["fo_ptr", " info_type", " info_pointer", "info_type", "info___struct", "infoPaddr", "info_pert", "info_pointer", "info___pointer", "fo_addr", "fo_buf", "fo_struct", " info_addr", "info___ptr", "fo_pointer", "info_buf", "fo_pointers", " info_pert", "info_dr", "infoPtype", " info_dr", "info___buf", "info_pointers", "info_struct", "infoPptr", "infoPpointer", "info_addr"], "linebuf": ["Linebag", "slicearray", "linebag", "inlinebuf", "Linebuf", "inlinearray", "linecache", "inlinebag", "inlinecache", "slicebag", "Linecache", "Linearray", "linearray", "slicebuf", "slicecache"], "buf": ["conv", "stack", "uf", "val", "pkg", "cv", "queue", "func", "buffer", "alloc", "cmd", "box", "rc", "pool", "ctx", "cb", "ptr", "window", "tmp", "seq", "ff", "src", "fd", "len", "Buffer", "buff", "rb", "cap"], "dy": ["ding", "def", " height", "ded", "db", " row", "d", " dd", " dir", "ds", "dir", "dev", "dd", " def", "sync", " d", "dx", "dim", " rows", " disp", "D", " dim", " delta", "di", " dev", " dup"], "priv": ["pb", "public", "ra", "str", "uc", "fac", "err", " Priv", "vt", "prof", "mini", "private", " privilege", "Priv", "impl", "color", "rec", "tx", "access", "ci", "trust", "neg", "info", "cp", "dev", "white", "wh", "cer", "auth", "rw", "rc", "pri", "riv", "pro", "ch", "ocr", "gr", "req", "cert", "buff", "proc", "sec", "rib", "li", "lit", "pi", "fi", "resp", "pub"]}}
