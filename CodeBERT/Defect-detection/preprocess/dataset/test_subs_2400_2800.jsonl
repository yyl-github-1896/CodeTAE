{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n", "idx": 24100, "substitutes": {"state": ["use", "name", "manager", "State", "states", "self", "private", "seed", "start", "admin", "STATE", "part", "service", "status", "j", "list", "core", "match", "area", "slice", "user", "driver", "address", "port", "key", "old", "patch", "work", "resource", "new", "cache", "update", "rule", "settings", "node", "public", "scope", "parse", "context", "data", "component", "cfg", "message", "session", "output", "parent", "grade", "stat", "size", "count", "source", "post", "connection", "tag", "info", "master", "style", "config", "type", "instance", "id", "o", "inner", "estate", "art", "os", "local", "comment", "conn", "runner", "ace"], "io": ["ie", "i", "info", "api", "storage", "ia", "reader", "ri", "flow", "o", "iw", "resource", "input", "admin", "uri", "lib", "ini", "cli", "library", "os", "ou", "client", "IO", "co", "ro", "zip", "timeout", "rio", "f", "service", "iol", "ui", "connection", "area"], "fw_cfg": ["fw2fg", "FW_cfg", "FW_config", "FW_fg", "fw_gd", "wallappregion", "fw_config", "fwappfg", "fw2cfg", "fw2config", "wallappfg", "FW_gd", "fwappregion", "fw_region", "wallappcfg", "fw2gd", "wallappconfig", "wall_region", "wall_cfg", "fw_fg", "wall_fg", "fwappcfg", "wall_config", "fwappconfig"], "owner": ["head", "node", "ow", "fork", "driver", "name", "owned", "manager", "access", "own", "property", "reader", "loader", "instance", "mac", "ee", "Owner", "creator", "rew", "mode", "parent", "cow", " ownership", "ro", "created", "slave", "host", "row", "owners", "root", "builder", "r", "org", "unknown", "ace", "container", "writer"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 24103, "substitutes": {"bs": ["rs", "ses", "obj", "sys", "iss", "ss", "b", "bas", "bis", "ns", "lbs", "ob", "bb", "ts", "vs", "las", "base", "ms", "ds", "bh", "gb", "cb", "bos", "bc", "BS", "bl", "ins", "outs", "sync", "css", "rss", "oss", "gs", "pb", "http", "eb", "bi", "os", "ros", "bes", "sb", "obs", "ras", "fb", "ls", "fs", "details", "js", "bits", "bing", "ris", "org", "cs"], "res": ["remote", "rs", "sys", "RS", "bis", "resolution", "RES", "rez", "conf", "rus", "us", "gr", "mr", "rows", "proc", "css", "rss", "resh", "rel", "resource", "rh", "err", "rev", "spec", "resources", "re", "os", "ras", "ros", "rc", "response", "ress", "req", "ry", "rem", "Res", "serv", "reset", "details", "js", "rx", "pres", "reg", "resp", "results", "ver", "r", "ris", "result", "rr", "cs"], "fix": [" debug", " _", " reject", " sett", " fixes", "Fix", " clear", " test", " update", " reply", " conf", " repair", " priv", " error", " defaults", " reporter", " prefix", " spec", " build", " upgrade", " patch", " init", " def", " confirm"], "rebuild": ["REinstall", "REbuild", " reininstall", " reinupdate", "reinstall", " reconstruct", " reinconstruct", "REupdate", "reconstruct", "REconstruct", "reupdate", " reupdate", " reinstall", " reinbuild"], "refcount_table": ["refcount2integer", "refcount_integer", "refcount_total", "refcountStable", "refcountstotal", "refcounteddirectory", "refname_table", "refmatch_server", "refount_database", "refcountingserver", "refcount2table", "refcountSmachine", "refcountPserver", "refcountingsource", "refcount64table", "refcountabletable", "refmatchpcontainer", "refcountingTable", "refload2tree", "refmatchpsource", "refload_table", "refcountTtable", "refcountJsequence", "refcount_directory", "refname_query", "refcountedwindow", "refsumingtable", "refcountableinteger", "refcountSinterface", "refcountererror", "refcountingerror", "refCount_interface", "refcount_tab", "refCount_TABLE", "refload_db", "refcountptable", "refcount64error", "refmatchptable", "refload2integer", "refcount_source", "refcountedtab", "refcountabledb", "refcount_service", "refstart_directory", "refcountingservice", "refcount2db", "refCount_table", "refCount_Table", "refCount_count", "refcount_machine", "refstart_tab", "refcount_container", "refcountpcontainer", "refcount_tree", "refstarteddirectory", "refcountingtab", "refsum_TABLE", "refnamePrule", "refcountTrule", "refmatch_source", "refcountscount", "refnamePtable", "refCount_total", "refcounterservice", "refname_sequence", "refcountabletree", "refload2db", "refnamePsequence", "refount_queue", "refsumingerror", "refcountTquery", "refcount_server", "refmatch_table", "refCountstable", "refcountingdirectory", "refcountPcontainer", "refcountJquery", "refname_rule", "refcount64service", "refcountinginterface", "refcount_interface", "refload_error", "refcount_sequence", "refsum_error", "refcountPquery", "refcount_Table", "refcount_database", "refcountpsource", "refsumingservice", "refcount_queue", "refcountTsequence", "refload2table", "refcount_error", "refcountingcontainer", "refload_integer", "refcountertable", "refcountedtable", "refcount_window", "refsum_service", "refmatchpserver", "refcount_query", "refcountPtable", "refcount_count", "refount_table", "refcountingtable", "refnamePquery", "refcount_rule", "refcounterTABLE", "refount_TABLE", "refcountingwindow", "refstart_window", "refcountJtable", "refcountPsequence", "refstartedwindow", "refmatch_container", "refcount_db", "refload_tree", "refcountPrule", "refCountscount", "refcount2tree", "refload_interface", "refcountSerror", "refCountstotal", "refcountPsource", "refcount64TABLE", "refcountpserver", "refstartedtab", "refcountJrule", "refsum_table", "refstartedtable", "refcount_TABLE", "refcountstable", "refsumingTABLE", "refcountingTABLE", "refload_machine", "refstart_table"], "nb_clusters": ["nb_compresses", "nb_clunks", "nb_spluster", "nb_slust", "nb_CLros", "nb_bluster", "nb_topusters", "nb_llresses", "nb_blusters", "nb_slunks", "nb_CLroups", "nb_licuster", "nb_slances", "nbOfsplusters", "nb_CLocations", "nb_CLuster", "nb_llappers", "nb_clros", "nb_helusters", "nb_licots", "nb_CLicas", "nb_laborders", "nb_topresses", "nb_sluster", "nb_licusters", "nb_clappers", "nb_closures", "nb_labuster", "nb_labocks", "nb_plocations", "nb_CLocks", "nb_CLots", "nb_CLresses", "nb_llances", "nb_pluster", "nbOfsplros", "nb_helambers", "nb_plusters", "nbOfclusters", "nb_klrs", "nb_slusters", "nb_splroups", "nb_clambers", "nb_llust", "nb_clroups", "nb_slambers", "nb_scunks", "nb_clicas", "nb_zappers", "nb_plicas", "nb_scusters", "nb_CLappers", "nb_slocations", "nb_CLorders", "nb_clust", "nb_lluster", "nb_zresses", "nb_splusters", "nb_blicas", "nb_clocks", "nbOfcluster", "nb_clresses", "nb_klusters", "nb_blots", "nb_slicas", "nb_scosures", "nb_CLrs", "nb_topuster", "nb_clrs", "nbOfsplroups", "nb_kluster", "nb_clots", "nb_compances", "nb_compust", "nb_helosures", "nb_klresses", "nb_splros", "nb_toprs", "nb_scambers", "nb_licicas", "nb_zuster", "nb_helunks", "nb_slosures", "nb_clances", "nb_cluster", "nb_clocations", "nb_compusters", "nb_zusters", "nb_clorders", "nb_CLusters", "nbOfclros", "nbOfclroups", "nbOfspluster", "nb_llusters", "nb_slresses", "nb_labusters"], "s": ["comments", "sys", "ns", "ts", "ps", "secondary", "states", "sync", "self", "es", "stats", "ess", "gs", "http", "sym", "sa", "xs", "f", "service", "fs", "js", "qs", "n", "t", "r", "ops", "S", "p", "b", "m", "c", "sum", "ds", "state", "ins", "su", "css", "is", "sets", "spec", "services", "h", "details", "sl", "settings", "its", "rates", "g", "rs", "ses", "args", "ss", "bis", "d", "conf", "sg", "ks", "rss", "e", "ubs", "session", "sb", "full", "ssl", "cs", "params", "iss", "site", "o", "si", "os", "ls", "a", "results", "v", "l"], "i": ["z", "ie", " ii", " sup", "io", "u", "li", "ini", "bi", "ai", " err", " sig", " response", "n", "j", " li", "chi", "ami", " rec", " cont", "p", " bit", "c", " bi", "x", "ti", "mi", "phi", "qi", "ri", "di", " fi", " mi", "ci", "eni", "vi", " r", "h", "ki", " rep", " fid", "yi", " rest", "d", "uli", " fin", "e", " reply", " resp", "uri", "ii", "fi", "I", " si", "iu", " pi", " ti", " j", "ix", "id", " pri", "gi", "ji", "zi", "multi", "xi", "si", "ni", " error", "mini", "ip", "index", "v", "pi", " len", "ui", "l"], "sn": ["sc", "sk", "kn", "sid", "ski", "sr", "ns", "bn", "sw", "sam", "fn", "sq", "nn", "Sn", "sync", "su", "ne", "sp", "span", "scl", "cl", "nb", "ii", "SN", "si", "fl", "ni", "cn", "sb", "syn", "eni", "sa", "ls", "sm", "nr", "n", "na", "sd", "sl", "ssl", "sv", "dn", "sh"], "ret": ["ref", "ft", "cat", "rf", "att", "it", "num", "url", "arr", "valid", "mt", "det", "lit", "nt", "pet", "part", "f", "status", "t", "match", "r", "val", "gt", "complete", "ber", "obj", "flag", "msg", "red", "hard", "en", "debug", "def", "rep", "pret", "key", "bit", "repl", "RET", "group", "result", "let", "feat", "bad", "Ret", "len", "ut", "final", "fun", "pt", "usr", "data", "back", "success", "fail", "error", "db", "str", "err", "re", "reply", "sec", "req", "arg", "alt", "reg", "post", "std", "info", "job", "br", "bf", "opt", "pass", "id", "rets", "rev", "fit", "art", "run", "lt", "rc", "rt", "ext", "conn", "out", "pre", "reset", "format"], "check_errors": ["check_success", "checkNerror", "checkloglength", "checklogerror", "checkNlength", "checkNerrors", " check_error", " check_length", "checklogsuccess", "checkNsuccess", "check_length", "check_error", "checklogerrors", " check_success"]}}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n", "idx": 24123, "substitutes": {"q": ["iq", "Q", "k", "w", "p", "m", "quick", "c", "d", "x", "qa", "back", "queue", "qt", "sq", "qi", "port", "pad", "u", "e", "o", "work", "cache", "req", "quad", "h", "f", "qs", "ip", "qq", "t", "r", "query", "dq", "que", "pc", "g"], "addr": ["md", "node", "seq", "args", " address", "Address", "pkg", "asm", "x", "data", "base", "config", "pointer", "ad", "address", "ada", "port", "mac", "alias", "url", "pad", "amp", "adr", "bridge", "work", "ord", "offset", "eni", "ptr", "oa", "ar", "amd", "ack", "au", "nr", "ip", "conn", "host", "ace", "pc", "kt"], "qtd": ["qod", "qudd", " qld", " qTD", "htd", "Qtm", "zod", "qld", "pgdd", "ktd", "qulf", "reqtd", "pgtd", "sqTD", "questtm", "Qld", "reqdd", "quicktd", "ztd", " qdl", "qtw", "Qdt", "reqTD", "qpd", "kdd", "quds", "hdd", "querydt", "Qcd", "qdt", "sqpd", "Qfd", "reqdt", "ktw", "qfd", "queryTD", "hcd", "hdt", "questdt", "sqdt", "Qlf", "qudt", "qTD", "Qpd", "quickTD", "kdt", "quickdd", " qod", "Qod", "viewtd", "zdd", "kTD", "querytw", "questTD", "zdt", "questtd", "qtm", "Qtd", "qlf", "questdd", "qdl", "Qdl", "questfd", "qutd", "qds", "sqtd", "qupd", "querytd", "quickdt", "viewdt", " qfd", "pgdt", "sqdd", "QTD", "sqdl", "questdl", " qcd", "qdd", "viewtm", "sqlf", "Qds", " qdd", "viewdd", "pgld", "qcd", "Qdd", " qdt"]}}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n", "idx": 24141, "substitutes": {"d": ["md", "dds", "done", "z", "dc", "i", "p", "m", "cd", "c", "dad", "ded", "b", "data", "ld", "ds", "ad", "bd", "dd", "ed", "id", "dom", "db", "e", "du", "did", "td", "dos", "dh", "dat", "pd", "dx", "nd", "dl", "gd", "dt", "D", "dm", "t", "sd", "ind", "l", "fd", "dB"], "s": ["S", "rs", "ses", "args", "er", "w", "z", "ss", "p", "m", "i", "c", "b", "ns", "se", "data", "sq", "ds", "conf", "ps", "dd", "state", "ks", "sync", "is", "u", "db", "e", "es", "south", "cs", "gs", "o", "session", "si", "sym", "os", "sb", "services", "ls", "f", "service", "js", "fs", "a", "an", "t", "sd", "sl", "sf", "settings", "ops", "l", "sv", "ed", "g"]}}
{"project": "FFmpeg", "commit_id": "70f9661542a581dfe93b636b1c55b5558e4a4e3c", "target": 0, "func": "static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame, AVPacket *avpkt)\n\n{\n\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n\n    ThreadFrame frame = { .f = data };\n\n    AVFrame *picture = data;\n\n    int tileno, ret;\n\n\n\n    s->avctx     = avctx;\n\n    s->buf       = s->buf_start = avpkt->data;\n\n    s->buf_end   = s->buf_start + avpkt->size;\n\n    s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles\n\n\n\n    // reduction factor, i.e number of resolution levels to skip\n\n    s->reduction_factor = s->lowres;\n\n\n\n    ff_jpeg2000_init_tier1_luts();\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    // check if the image is in jp2 format\n\n    if ((AV_RB32(s->buf) == 12) &&\n\n        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&\n\n        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {\n\n        if (!jp2_find_codestream(s)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't find jpeg2k codestream atom\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {\n\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n\n        return -1;\n\n    }\n\n    if (ret = jpeg2000_read_main_headers(s))\n\n        goto end;\n\n\n\n    /* get picture buffer */\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"ff_thread_get_buffer() failed.\\n\");\n\n        goto end;\n\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n\n    picture->key_frame = 1;\n\n\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n\n            goto end;\n\n\n\n    *got_frame = 1;\n\n\n\nend:\n\n    jpeg2000_dec_cleanup(s);\n\n    return ret ? ret : s->buf - s->buf_start;\n\n}\n", "idx": 24148, "substitutes": {"avctx": ["ovctx", "AVlc", "navcontext", "ovpkg", "afkb", "avcontext", "afcontext", "ovcontext", "avectx", "avctl", "ajctx", "ajcmp", "avekb", " avpkg", "afxc", "ajwcs", "cvconfig", "avcci", "evcci", "akctx", "avecor", "akcontext", "AVwcs", "ajxc", "AVcontext", "avepkg", "navkb", "abcontext", " avloc", "ovcor", "afctx", "avconfig", "akxc", "avpkg", "avloc", "akcf", "abctx", "aveloc", "AVctx", "abctl", "avxc", "afwcs", "avcf", "avelc", "avecci", "AVcmp", "avecontext", "evcontext", "avcmp", "afcf", "afcci", "evctx", "avcor", "aflc", "akcci", "afcor", "avconn", "ajcf", "afconn", "ajcontext", "cvctl", "akconn", "afctl", "avecf", "afpkg", "cvcontext", "avkb", "AVcf", "abconfig", "evconn", "navcci", "cvctx", " avcontext", "avlc", "afloc", "navctx", "avwcs", "afcmp", "afconfig"], "data": ["load", "head", "Data", "body", "done", "gap", "i", "p", "m", "batch", "frame", "empty", "none", "name", "image", "d", "function", "buffer", "base", "media", "img", "shift", "next", "def", "reader", "id", "port", "pad", "raw", "buf", "feed", "open", "o", "input", "dat", "jpg", "start", "sample", "one", "mode", "size", "video", "response", "cache", "first", "missing", "xxx", "current", "block", "window", "f", "da", "a", "DATA", "content", "init", "header", "database", "alpha", "result", "len", "file", "area"], "got_frame": ["get_layer", "get_Frame", "get_image", "got_frames", "get_figure", "got___frames", "got_image", "get_frame", "got__figure", "got___Frame", "get_frames", "got__frames", "got_figure", "got___layer", "got__image", "got___frame", "got_layer", "got__frame", "got_Frame"], "avpkt": ["avwkg", "avwke", "avspke", "avckg", "avepeth", "avepkh", "avebct", "avcct", "avvpkh", "avPkt", "avepkg", "abpkg", "avebkt", "avwkt", "avvpct", "avejpkh", "abfke", "abpke", "avfke", "avbkt", "abpkt", "avpke", "avjpct", "avjpkh", "avebet", "avfkg", "avepet", "abfkg", "abfkt", "avwacket", "avebkg", "avpaeth", "abpacket", "avPkg", "avpakh", "avejpeth", "avvpeth", "avpkg", "avbkg", "avPet", "abfacket", "avspkt", "avvpkt", "avcet", "avbct", "avejpkt", "avpkh", "avjpkt", "avPct", "avpacket", "avepct", "avfkt", "avspacket", "avpet", "avjpeth", "avpct", "avspkg", "avbet", "avejpct", "avpact", "avfacket", "avpakt", "avepkt", "avckt", "avpeth"], "s": ["sys", "server", "ns", "ts", "or", "sq", "ps", "sync", "self", "u", "es", "gs", "http", "sym", "sa", "xs", "f", "service", "fs", "n", "js", "qs", "j", "r", "ops", "S", "er", "p", "m", "b", "c", "se", "storage", "ds", "us", "su", "is", "ions", "spec", "aws", "new", "services", "h", "details", "sl", "settings", "its", "g", "side", "rs", "ses", "ss", "features", "bis", "d", "conf", "sg", "e", "session", "hs", "sb", "your", "full", "sf", "ssl", "sv", "cs", "sc", "i", "plugins", "site", "o", "si", "os", "ctx", "as", "ls", "y", "a", "an", "v", "parts", "l"], "picture": ["gif", "summary", "obj", "slice", "Picture", "info", "photos", "i", "parse", "frame", "p", "m", "image", "fn", "buffer", "detail", "photo", "img", "style", "storage", "feature", "shadow", "general", "big", "util", "fine", "profile", "movie", "guide", "audio", "jpg", "gallery", "si", "avi", "stat", "fi", "video", "cache", "feat", "game", "sa", "bank", "xxx", "details", "pict", "png", "meta", "large", "pic", "file"], "tileno": ["lineno", "silasso", "salno", "tilno", "tilaxy", "iloa", "tifeno", "saleno", "tilendo", "talenos", "tilogo", "illono", "livendo", "tinono", "phaleno", "ilogo", "mileno", "livasso", "phaloni", "tinaxy", "taleno", "miloa", "tifoa", "linaxy", "ileno", "sileno", "iloni", "theleno", "miloni", "tinzi", "thelogo", "illzi", "tinica", "tineno", "silendo", "tiloni", "tifica", "tilono", " tiloa", " tilname", "tilica", "tilname", "salendo", "taloni", "tilasso", "tifname", "illaxy", "silenos", "phalenos", "theloni", "livno", " tilica", "salasso", "liveno", "milogo", "tinoa", "linono", "linzi", "illeno", "tilenos", "tilzi", "theloa", "tiloa", "tinname", "talendo", "phalendo", "siloni", "silno"], "ret": ["ref", "code", "fin", "sid", "ft", "res", "af", "usr", "cat", "flag", "back", "en", "success", "mi", "att", "def", "pass", "url", "rets", "mem", "arr", "get", "mt", "det", "rev", "lit", "session", "RET", "slot", "re", "sel", "nt", "rc", "let", "feat", "bot", "reply", "pet", "arg", "Ret", "rt", "alt", "reg", "match", "result", "len", "val", "ut", "fun"]}}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162, "substitutes": {"vbasedev": ["vbasedesc", "vbaseef", "vbaseev", " vakedev", "vbasedown", "verbasediv", "vfedell", "vakeddev", "svasedell", "vbackeddev", "verbasedev", "vbuiltef", "vmadee", " vbasedef", "vmadiv", "svbasedell", "vfedesc", "vldee", " vbaseef", "vasedev", "vldown", "vfedee", "vbaseiv", "vfedev", "vbuiltiv", "vbasedom", "vadedell", "vadedev", "vfedown", " vbasedom", " vbaseddev", "verbasedee", "svbasedesc", "svasedesc", "verbasedown", " vakedef", "vbackedom", "vadedesc", "vakedef", "svbasedev", " vbaseiv", "vbuiltdev", "vbuiltev", "vmadev", " vakedom", "svasedown", "vadedown", "vasedell", "vbasedef", "vasedesc", "vldev", " vbasediv", "verldev", "vasedown", "svbasedown", "verldee", "vfediv", "vbasedee", "verldiv", "vbackedef", " vakeddev", "vbasedell", "vakedev", "vbackedev", "svasedev", "vbackediv", "vakedom", "vbaseddev", "vbasediv", "vldiv", " vbaseev", "vmadown", "verldown"], "intp": ["intq", "INTp", "INTc", "intf", "interc", "structq", "pointu", "intsc", "ortps", "intu", "uintP", "ortf", "xtp", "Intl", "INTu", "indP", " intpa", "Intp", "intpc", "genpe", "xtps", "indpoint", "xtpc", "ntP", "Intc", "indpr", "Intpc", "ntf", "uintp", "interl", "indp", "indd", "intP", " intq", "interp", "indps", "interu", "inte", "intc", "ntpoint", "pointpc", "incpa", "pointc", "bitc", "genv", "intpoint", "structc", "intps", "intv", "idv", "ipp", "bitpoint", "interpc", "incv", "Intpoint", "intsl", "idpe", "structpr", "indv", "ntp", " intP", " intps", "genP", "indpe", "pointp", "incps", "ortpoint", " intd", "intd", "inpr", "uintpr", "uintv", "ntpa", "uintpc", "xte", "intpa", "intsp", "ipc", " intc", "intl", "ine", "idp", "inde", "incP", "indpc", "uintd", "incp", "intspc", "ortpc", "ortc", "Intv", "intpe", "structp", "uintq", "ippr", "ntc", "ortp", "orte", "INTpc", "bitp", "genp", "idP", "inc", "uintc", "bitP", "ipe", "IntP", "indq", "ntps", "inp", "indf", "incpc", "indc", "intpr"], "vdev": ["varrad", "vdem", "tvdef", "verror", "wdef", "Vdevelopment", "pdevice", "Vvalid", "tvrad", "qdiff", "qdef", "vdevelopment", "svdef", "nmod", "vardev", "ndev", "vardef", "Verror", "ovdef", "pdc", "svconn", " vdiv", "ldev", "qerror", "tvvalid", " vdem", "qconn", "ovvalid", "Vdc", "Vconf", "vdiff", "pmod", "qdevelopment", "Vdev", "qdiv", "Vconn", "vvdevice", "svdem", "Vmod", "vvalid", "ndc", "qdev", "wdev", " vdef", "ldevelopment", "vdef", "vvdev", "vrad", "vdevice", "vdc", "wdevice", "ldef", "wvalid", "Vdef", "Vdiv", "vdiv", "Vdem", "pdev", "qconf", "varvalid", "ldiff", "vverror", "vmod", "svdiv", "Vdevice", "tvdev", "ndevice", "Vdiff", "vconf", "Vrad", "vconn", "vvconf", "svdevice", "svdev", "ovdev", "qdevice", "ovdevice"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164, "substitutes": {"s": ["S", "temp", "txt", "rs", "ses", "sys", "w", "i", "p", "m", "b", "c", "ns", "context", "d", "ts", "ds", "conf", "support", "ps", "sg", "sync", "su", "u", "e", "es", "sets", "session", "sv", "sym", "ctx", "sb", "services", "xs", "h", "f", "fs", "js", "src", "t", "a", "v", "sf", "ops", "ssl", "cs", "g"], "rlow": [" rlo", " rmin", "rrange", "rrlo", "rmid", "rrmin", "plow", "pLow", "srlo", "rrlow", "rlo", "prange", "rclow", "rrmid", "srLow", "rcLow", "srmin", "srmid", "srrange", "rcmin", "rmin", "pmin", "rLow", "srlow", " rmid", "rcrange"], "rhigh": ["frfill", "frpeak", "rmid", "rpeak", "rtop", "prhi", "frmid", "irlimit", "rlimit", "prlimit", "rfill", " rpeak", "prhigh", "rarhigh", " rfill", "rhi", "rarmid", " rhi", "frhigh", "rarfill", "irhigh", "irtop", " rlimit", "prtop", "rarpeak", " rtop", "irhi", " rmid"], "val": ["temp", "ref", "obj", "pot", "b", "pt", "p", "VAL", "x", "test", "eval", "data", "base", "var", "prop", "py", "gb", "vt", "bl", "split", "vals", "db", "al", "grad", "valid", "pb", "loc", "lib", "fl", "slot", "sel", "ctx", "pm", "ffff", "Val", "elt", "rt", "f", "part", "value", "j", "t", "reg", "func", "v", "sl", "ind", "alt", "pre", "pos", "len"], "tmp": ["temp", "txt", "obj", "np", "kk", "b", "m", "p", "stuff", "emp", "pt", "c", "app", "test", "data", "Temp", "storage", "rb", "config", "py", "jp", "vt", "cb", "beta", "property", "bp", "proc", "vv", "cmp", "tv", "mp", "buf", "TB", "pb", "nb", "tt", "output", "copy", "ctx", "cp", "sb", "fb", "cache", "ptr", "vm", "tab", "part", "rt", "etc", "tc", "j", "src", "t", "fp", "tp", "v", "attr", "pre", "result"]}}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179, "substitutes": {"obj": ["ref", "ie", "pg", "pkg", "ns", "ob", "Object", "cb", "aj", "oid", "io", "bs", "bj", "oss", "el", "nb", "lib", "object", "nt", "js", "n", "j", "val", "code", "b", "p", "bo", "bb", "x", "jp", "eff", "ocr", "op", "boot", "office", "oa", "xxx", "Obj", "bm", "coll", "attr", "ut", "g", "node", "args", "otype", "pt", "data", "orb", "rb", "act", "bl", "tmp", "str", "pl", "sb", "po", "obo", "alt", "org", "pos", "oh", "objects", "adj", "dr", "fn", "api", "img", "bh", "type", "so", "id", "o", "obb", "art", "os", "ctx", "co", "ot", "off", "ext", "oi", "conn"], "qint": ["sqint", "eqint", "qnt", " qinner", "shinc", "qualin", "eqinc", "quinteger", "tINT", "dqicit", "qualint", "qunit", "qanit", "queryinteger", "shint", "quinc", "qqinteg", "quinit", "dqint", "qinit", "qind", "quicit", "tinteger", "dqid", " qinteg", "quobject", "quickint", "qid", "shid", "qainner", "qain", "qconfig", "quconfig", "sqinteger", "sqicit", "quinner", "queryint", "quinteg", "quint", "qinner", "qinc", "dqINT", "qqint", "quin", "sqinit", "qINT", "qualinner", "shind", "queryINT", "sqinteg", "qicit", "qinteg", " qconfig", "quinst", "sqobject", "qqinner", "sqnt", " qinit", "qualnit", "qnit", "quickinc", "qinteger", "dqinteger", "dqfloat", "qaint", "quid", "qin", "quickinteger", "qunt", "eqinst", "dqinc", "dqnt", "qinst", "tfloat", "queryfloat", "quind", "tint", " qobject", "dqind", "qobject", "qqconfig", "eqinteger", "quickinst"], "qfloat": ["hfloat", "qustring", " qinteger", "qfat", "sqflat", "Qdouble", "querystring", "qflat", "queryfat", "iqdouble", "querydouble", "hflat", "iqfloat", "quflat", "Qinteger", "gfloat", "gflat", " qdouble", "qflo", "Qfloat", "hflo", "qpart", "iqflat", "hdouble", "queryfloat", "iqflo", "querypart", "gpart", "sqfloat", "gdouble", "qufloat", "quflo", "qdouble", "qfinal", "Qfinal", " qflat", "qinteger", "ginteger", "gfat", " qfinal", "sqpart", "qudouble", "queryflat", " qstring", "qstring", "gfinal", "sqfat"]}}
{"project": "qemu", "commit_id": "95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb", "target": 0, "func": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n", "idx": 24200, "substitutes": {"ohci": ["ohcit", "ohsci", "ahcin", "ahc", "ohcu", "ovlc", "ahii", "hovc", "ovcin", "ihcit", "ophcit", "ophcin", "ehcu", "hovcci", "ohii", "ahcci", "hcu", "hdi", " ohcci", "ohc", " ohcu", "ehcci", "hovci", "ehci", "hc", "ahcu", "ihco", "ehco", "ihc", "ophc", "hovii", "oucin", "ouc", "ihcci", "oulc", "ouci", "hcin", "ophcu", "ahci", "ovcci", " ohdi", "ehcit", "ihci", "ophci", " ohc", "ehc", "ovcit", "ohcci", "ohdi", "hsci", "ovci", " ohcit", "hci", "ahdi", "ohlc", "ovc", "ehii", " ohcin", "ahco", "ehcin", "ahcit", "ophsci", "ahlc", " ohsci", "ohco", "ohcin", "ophcci"], "head": ["load", "code", "body", "subject", "gap", "heads", "foot", "cost", "name", "flag", "flags", "back", "send", "next", "mid", "state", "tail", "end", "port", "id", "front", "self", "gate", "brand", "depth", "key", "link", "open", "patch", "Head", "max", "input", "group", "start", "set", "bound", "run", "last", "clean", "sign", "headers", "parent", "forward", "anch", "client", "size", "target", "rc", "first", "length", "origin", "current", "before", "ack", "h", "count", "stream", "total", "lead", "commit", "pull", "index", "src", "host", "row", "header", "ck", "ind", "HEAD", "pos", "post", "tag"], "completion": ["ocomple", "committed", "ocommented", "calpletion", "ocompletion", " commented", " committed", "calple", " comple", "calmitted", "ocommitted", "comple", "commented", "calmented"], "ed": ["fed", "z", "ned", "eded", "ded", "rod", "written", "or", "ld", "aned", "ated", "ee", "es", "set", "ended", "edited", "ied", "et", "oved", "er", "based", "se", "ted", "red", "ing", "sed", "en", "ad", "itted", "line", "ED", "one", "pred", "ped", "named", "ited", "acked", "sent", "ex", "ined", "temp", "done", " extended", "d", "started", "ached", "ev", "e", "reed", "needed", "made", "eb", "led", "edd", "wired", "ged", "ipped", "hed", "oned", "aed", "ordered", "added", "aged", "linked", "aid", "wed", " sent", "read", "rated", "dd", "id", "aled", "eds", "mented", "Ed", "ced", "ind", "ared", "med", "iced"], "next_ed": [" next_sent", "currentJeds", "nextJeds", " next_eds", "current_ded", "nextJedited", "next_sent", "current_edited", " next_red", "currentJded", "nextjped", "currentJedited", "nextjred", "next_edited", "nextJed", "current_ed", " next_led", "next_ded", "current_eds", "next_ped", " next_ped", "nextjeds", "next_eds", "currentJed", "nextJded", "next_red", "nextjed", "next_led"], "cur": ["rest", "sr", "uc", "c", "der", "usr", "dr", "back", " cursor", "var", "next", "cr", "pub", "mid", "ch", "end", "ah", "car", "tr", "orig", "sth", "id", "iter", "sur", "open", "arch", "feed", "cher", "input", "start", "prev", "loc", "rev", "per", "cli", "enter", "cer", "ser", "sel", "client", "ctr", "rc", "ur", "ptr", "fer", "req", "current", "length", "feat", "Cur", "cor", "focus", "child", "pr", "src", " prev", "row", "inter", "ind", "ver", "r", " curs", "ait", "rog", "desc"], "active": ["exec", "connected", "enable", " running", "add", "att", "progress", " pending", "ended", "current", "r", "Active", "ait", "complete", "play", "x", "cycle", "activ", "live", "proc", "feed", "stable", "total", "running", "g", "circ", "act", "all", "open", "cli", "le", "parent", " inactive", "client", "sec", "_", "pos", "aid", "seq", "confirmed", "pass", "id", "activity", "lic", "rev", "run", "loop", " reactive", "acs", "ace", " act", "ac"], "addr": ["md", "node", "seq", "ref", "obj", "sid", "name", "pkg", "dr", "doc", "data", "config", "align", "ad", "vr", "address", "nn", "mid", "state", "mac", "id", "url", "pad", "amp", "adr", "sta", "cmd", "cap", "ord", "afi", "loc", "mt", "offset", "anne", "hop", "rc", "ptr", "ack", "rt", "amd", "xp", "nr", "rx", "ip", "src", "conn", "host", "attr", "nc", "pos", "layer"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201, "substitutes": {"pbdev": ["pcver", "sbapp", "pbver", "labdiv", "sbconf", "sbdef", "cbdata", "pbdef", "pcdata", "cbdev", "pbtest", "cbver", "pbadv", "bbadv", "fbapp", "pbdevice", "refdevice", "sbdevice", "PBdevice", "pcdevice", "bbdev", "pdevice", "PBapp", "pconf", "pbapp", "refdev", "pcdiv", "PBadv", "pcadv", "pbdiv", "cbdiv", "pcconf", "cbtest", "sbdev", "refdata", "reftest", "PBconf", "labdev", "bbdevice", "pbconf", "PBdev", "fbdev", "pdef", "PBdef", "fbdevice", "cbdevice", "labver", "pctest", "bbconf", "pcdev", "pbdata", "pdev", "labdevice"]}}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_connect(URLContext *uc, AVDictionary **options)\n\n{\n\n    int err =\n\n        uc->prot->url_open2 ? uc->prot->url_open2(uc,\n\n                                                  uc->filename,\n\n                                                  uc->flags,\n\n                                                  options) :\n\n        uc->prot->url_open(uc, uc->filename, uc->flags);\n\n    if (err)\n\n        return err;\n\n    uc->is_connected = 1;\n\n    /* We must be careful here as ffurl_seek() could be slow,\n\n     * for example for http */\n\n    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, \"file\"))\n\n        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)\n\n            uc->is_streamed = 1;\n\n    return 0;\n\n}\n", "idx": 24205, "substitutes": {"uc": ["acc", "exec", "ru", "uf", "sc", "cca", "class", "oc", "auc", "anc", "c", "UC", "context", "cv", "cci", "ec", "cur", "config", "uca", "up", "soc", "cus", "us", "pub", "bc", "mac", "ocr", "util", "url", "su", "u", "instance", "fc", "aux", "con", "input", "ul", "unc", "sub", "cli", "cc", "ctx", "ucc", "client", "ub", "asc", "rc", "mc", "roc", "co", "BC", "cas", "lc", "uu", "um", "aut", "ack", "ca", "usc", "tc", "cu", "userc", "RC", "plug", "uci", "ui", "connection", "ac", "pc"], "options": ["exec", "args", "public", "oci", "this", "option", "context", "flags", "other", "or", "data", "ec", "text", "config", "opens", "opt", "optional", "mac", "Options", "url", "self", "e", "aux", "con", "o", "path", "fee", "lib", "object", "os", "cache", "co", "six", "array", "null", "pos", "settings", "ops", "times", "params"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206, "substitutes": {"sd": ["sch", "z", "cd", "sy", "ld", "gb", "ud", "ess", "sta", "nd", "dl", "lib", "ini", "st", "dt", "dev", "sci", "sa", "sm", "tf", "sim", "des", "service", "dm", "df", "md", "sk", "sem", "se", "dis", "sed", "ds", "ad", "bd", "su", "di", "wd", "ci", "vd", "od", "sl", "fd", "sh", "ss", "sn", "d", "isi", "data", "eddy", "sg", "sth", "gd", "sb", "lc", "zh", "sf", "sv", "ed", "dk", "std", "sc", "hd", "sam", "dd", "td", "ic", "pd", "dat", "si", "SD", "ln", "dist", "yd", "ind"], "ret": ["ref", "fin", "ft", "res", "pt", "data", "success", "att", "opt", "def", "id", "url", "all", "rets", "mem", "arr", "str", "get", "bit", "mt", "det", "lit", "rev", "RET", "re", "art", "nt", "reply", "rc", "feat", "let", "pat", "pet", "arg", "Ret", "rt", "reg", "alt", "resp", "match", "result", "len", "val", "gt", "ut", "fun"], "io_len": ["ioqlen", "net_del", "io_length", "ioqlimit", "io_offset", "control_lan", "control_width", "iofoff", "ioaclen", "feed_den", "feed_len", "ioxlan", "io67len", "ioambase", "cgiamoff", "io_base", " ioflen", "io_start", "io_field", "io_fin", " io_offset", "input_len", "control_len", " io_off", "cgiamcount", "io_count", "control00width", " iofden", " io_ln", "ioccbase", "io_min", "cgiambase", "iokcount", "control00lan", "io00lif", "feed_lim", "io67Len", "io_del", "inputaclen", "inputacln", " ioffin", "ioxlif", "input_lim", "io_den", "inputacstart", "cgiamlen", " io_width", "io67offset", "net_len", "io00len", "ioacln", "io32ln", "feed_limit", "iokbase", "io_lif", "io_lan", "io_off", "iocclen", "ioamoff", "control00len", "net_min", "ioacstart", "net_limit", "io_ln", "io_bin", "io_lim", "ioxlen", "ioklen", "input_ln", "data_len", "ioamcount", "ioqden", "io32field", "data_length", "cgi_off", " io_field", "ioflen", "io32offset", "ioaclim", "control00lif", "io_width", "io_Len", " io_den", " io_Len", "io_limit", "inputaclim", " iofoff", "io00width", "data_count", "io67width", "ioqlim", "ioffin", "ioccoff", "input_start", "iokoff", "iocccount", "control_lif", "io00lan", "iofden", " io_fin", "ioxwidth", "cgi_count", "data_bin", "cgi_len", "cgi_base", "ioamlen", "io32len"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212, "substitutes": {"data": ["exec", "Data", "code", "call", "args", "this", "info", "p", "m", "parser", "d", "qa", "test", "buffer", "api", "style", "config", "ad", "ds", "type", "reader", "state", "id", "self", "ui", "o", "arr", "input", "dat", "object", "parent", "ctx", "client", "record", "cache", "window", "comment", "value", "da", "a", "DATA", "match", "database", "draw", "result", "writer"], "unused": ["unknownuse", " unchecked", "Unuse", "unknownchecked", "unchecked", "unusable", " unuse", "unuse", "unknownusable", "Unused", " unusable", "Unusable", "Unchecked", "unknownused"], "obj": ["ref", "node", "code", "args", "ie", "i", "p", "b", "pt", "bo", "adj", "ns", "ob", "x", "api", "Object", "img", "py", "jp", "cb", "act", "eff", "so", "inst", "instance", "op", "bj", "o", "tmp", "nb", "object", "art", "nt", "parent", "ctx", "os", "fi", "oa", "Obj", "elt", "po", "oi", "n", "j", "js", "alt", "value", "coll", "init", "ind", "ex", "attr", "pos", "val"]}}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213, "substitutes": {"mon": ["ban", "wan", "bin", "m", "mont", "bo", "uno", "module", "mot", "config", "am", "mr", "meter", "mat", "mut", "bean", "dom", "mos", "blue", "mic", "mag", "MON", "mer", "con", "atom", "mt", "ann", "lin", "mn", "mun", "mand", "mo", "plan", "mc", "mas", "block", "mor", "man", "mini", "tun", "tom", "un", "bm", "mm", "amon", "an", "mu", "Mon", "monitor", "nan", "mons"], "src_str": ["src_string", "source_Str", "src_Str", "src_list", " src_list", " src_br", "src2str", " src_string", "src2br", "source_string", "rc_char", "src2string", "rc_Str", "source_br", "rc_str", "source_str", "src_char", "rc_br", "src_br", "src_arr", "rc_arr", "src2Str"], "host_port": ["node_addr", "port_port", "host_addr", "server_port", "hostaltype", "node_port", "host_host", "port_host", "hostaladdress", "host_address", "hostalpoint", "server_address", "host_type", "port_length", "host_PORT", "node_PORT", "hostalport", "host_length", "host_point", "server_point", "server_type"], "buf": ["seq", "uf", "bag", "received", "uc", "b", "batch", "wb", "c", "pkg", "context", "cat", "cv", "exc", "grab", "bb", "enc", "buffer", "queue", "vec", "data", "text", "ab", "rb", "bf", "bh", "bd", "br", "cb", "cur", "bc", "prop", "port", "bu", "bus", "pad", "cmp", "bed", "raw", "fab", "brace", "feed", "home", "ff", "ba", "cmd", "str", "pb", "cap", "la", "path", "padding", "loc", "bound", "box", "ctx", "fb", "cf", "rc", "conv", "bags", "cas", "buff", "h", "f", "bytes", "agg", "src", "func", "fd"], "p": ["pp", "pa", "np", "w", "i", "b", "m", "c", "pt", "d", "x", "api", "P", "pointer", "jp", "prefix", "ps", "port", "bp", "u", "point", "sp", "e", "o", "padding", "pb", "s", "ctx", "cp", "wp", "h", "part", "f", "y", "pr", "ip", "tp", "t", "fp", "j", "q", "pipe", "v", "r", "vp", "l", "pc", "ap"], "n": ["node", "k", "none", "z", "nat", "sn", "i", "m", "b", "name", "ns", "pn", "d", "c", "fn", "en", "nn", " N", "num", "ne", "nor", "e", "o", "min", "nb", "ni", "nt", "cn", "number", "ng", "N", "y", "nr", "j", "na", "t", "nl", "v", "nu", "ind", "nc", "l", "len", "dn", "g"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222, "substitutes": {"bs": ["ses", "sys", "iss", "ss", "b", "bas", "bis", "lbs", "ns", "lb", "bb", "vs", "base", "ab", "ds", "bh", "gb", "us", "bos", "bc", "BS", "bl", "outs", "ks", "ins", "bu", "css", "db", "gs", "ubs", "pb", "http", "eb", "bi", "os", "ros", "bes", "sb", "fb", "obs", "sa", "bid", "ls", "fs", "js", "bits", "bm", "bing", "bps", "cs", "banks"], "sector_num": ["sector_length", "sector_size", "section_offset", "sector0count", "shadow_name", "region_sum", "sector0num", "shadow_num", "shadowIDtun", "sector0sum", "section_no", "sectorpname", "sector_no", "sectorpsum", " sector_un", "sector_count", "sectorpoffset", " sector_offset", "sector_div", "shadowIDname", "sectorIDnum", "sectorIDname", "region_count", " sector_length", "sector_number", "shadow_div", "section_num", "sector_tun", "sector_un", "sector_sum", "shadowIDdiv", "region_num", "region_size", " sector_sum", "sector_offset", " sector_number", "sector0size", "sectorIDtun", "sectorpnum", "sectorIDdiv", "shadow_tun", "section_number", "shadowIDnum", " sector_name", "sector_name"], "remaining_sectors": ["remaining_teces", "remaining_pecs", "remaining_vectors", "remaining_bellers", "remaining_serctions", "remaining_serctor", "remaining_sector", "remaining_vector", "remaining_psectors", "remaining_vections", "remaining_sections", "remaining_bectors", "remaining_peces", "remaining_seapters", "remaining_psector", "remaining_secs", "remaining_pellers", "remaining_secapters", "remaining_serctors", "remaining_vecs", "remaining_peapters", "remaining_pectors", "remaining_vegments", "remaining_secces", "remaining_secgments", "remaining_tegments", "remaining_becs", "remaining_sergments", "remaining_psections", "remaining_segments", "remaining_seces", "remaining_pegments", "remaining_begments", "remaining_psegments", "remaining_sellers", "remaining_tectors", "remaining_teapters", "remaining_secctors", "remaining_vellers"], "qiov": ["sqrolet", " qiris", "sqoren", " qroxy", " qoyer", "quoren", "requoyer", "requiov", "sqiris", "quroxy", "sqiov", "qoren", "quveh", "qurolet", "questiov", "quiop", "quoyer", "qrolet", " qoby", "qoby", "requveh", "questiop", " qiop", "quiris", "requrolet", "qroxy", "qoyer", "qiop", "quoby", "questoby", "qiris", "quiov", " qoren", "qveh", " qveh", " qrolet", "questroxy"], "s": ["S", "rs", "ses", "sys", "args", "ss", "b", "server", "c", "p", "ns", "d", "ts", "storage", "sq", "ds", "conf", "ps", "sg", "state", "secondary", "states", "sync", "sis", "is", "su", "self", "e", "stats", "ess", "site", "gs", "o", "sets", "sie", "session", "spec", "l", "sym", "si", "aws", "os", "stat", "sb", "utils", "services", "sa", "ls", "f", "service", "js", "fs", "t", "v", "sl", "r", "settings", "ops", "parts", "ssl", "cs", "g"], "index_in_cluster": ["index_in_Cluration", "index_in_clructure", "index_in_hellayer", "index_in_Clayer", "index_in_ecructure", "index_in_secryption", "index_in_helluration", "index_in_clayer", "index_in_clryption", "index_in_Cluster", "index_in_hellusters", "index_in_secusters", "index_in_helluster", "index_in_secructure", "index_in_ecusters", "index_in_ecryption", "index_in_Clusters", "index_in_CLuster", "index_in_clusters", "index_in_CLayer", "index_in_CLuration", "index_in_secuster", "index_in_cluration", "index_in_Clructure", "index_in_CLusters", "index_in_ecuster", "index_in_Clryption"], "n1": ["p3", "N3", "N2", "N1", "c2", "N0", "n8", "unOnce", "none", "un8", "nn1", "n9", "c0", "ln1", " n91", "ln2", "p1", "sn2", " n3", "nnone", "snOnce", " n2", "sn1", "sn8", "N9", "nn8", "snone", "p2", "n3", "c1", "un1", "n91", "nnOnce", "n2", "nOnce", "N91", "c9", "unone", "sn9", "ln91", "n0", "sn0"], "ret": ["ref", "seq", "fin", "ft", "res", "info", "cat", "flag", "data", "test", "job", "rb", "success", "fail", "ct", "att", "opt", "def", " Ret", "end", "rep", "url", "rets", "iter", "bit", "mt", "det", "rev", "lit", "RET", "fit", "re", "art", "nt", "rc", "let", "pet", "arg", "Ret", "rt", "part", "ext", "sat", "j", "alt", "reg", "match", "result", "len", "val", "gt", "ut", "fun"], "cur_nr_sectors": ["cur_nr_peators", "cur_nr_secctors", "cur_nr_tections", "cur_nr_semvers", "cur_nr_selators", "cur_nr_cerets", "cur_nr_secctions", "cur_nr_SEgments", "cur_nr_psecs", "cur_nr_semcs", "cur_nr_sector", "cur_nr_perets", "cur_nr_seivers", "cur_nr_selgments", "cur_nr_severs", "cur_nr_psegments", "cur_nr_secgments", "cur_nr_pectors", "cur_nr_securities", "cur_nr_peurities", "cur_nr_pections", "cur_nr_secbits", "cur_nr_pexes", "cur_nr_seitors", "cur_nr_curctor", "cur_nr_psectors", "cur_nr_veitors", "cur_nr_serets", "cur_nr_pebits", "cur_nr_selctors", "cur_nr_seurities", "cur_nr_curgments", "cur_nr_semgments", "cur_nr_vevers", "cur_nr_pecs", "cur_nr_secs", "cur_nr_sections", "cur_nr_pegments", "cur_nr_curctors", "cur_nr_specs", "cur_nr_SEctors", "cur_nr_lectors", "cur_nr_spegments", "cur_nr_segments", "cur_nr_leivers", "cur_nr_secctor", "cur_nr_sexes", "cur_nr_sebits", "cur_nr_pevers", "cur_nr_seators", "cur_nr_selivers", "cur_nr_psections", "cur_nr_SEctions", "cur_nr_tectors", "cur_nr_cexes", "cur_nr_cectors", "cur_nr_cegments", "cur_nr_legments", "cur_nr_teurities", "cur_nr_semctors", "cur_nr_vecs", "cur_nr_vegments", "cur_nr_curbits", "cur_nr_peivers", "cur_nr_SEcs", "cur_nr_tegments", "cur_nr_pector", "cur_nr_peitors", "cur_nr_speitors", "cur_nr_spectors", "cur_nr_vectors", "cur_nr_leators"], "hd_qiov": ["hd_qanr", "hd_qqiov", "hd_ceiop", "hd_qaiop", "hd_sqiop", "hd_Qiov", "hd_miop", "hd_qoyer", "hd_cliov", "hd_sqilo", "hd_qiris", "hd_goyer", "hd_chiov", "hd_qnr", "hd_quicho", "hd_qqiop", "hd_sqirin", "hd_qaliv", "hd_ceiev", "hd_shoyer", "hd_qurolet", "hd_Qilo", "hd_chilo", "hd_quiev", "hd_clnr", "hd_chiris", "hd_qaicho", "hd_choyer", "hd_poyer", "hd_qilo", "hd_clicho", "hd_quiov", "hd_qairin", "hd_Qoyer", "hd_clliv", "hd_sqoyer", "hd_shilo", "hd_shiris", "hd_shiov", "hd_gliv", "hd_sqiov", "hd_quilo", "hd_qarolet", "hd_mirin", "hd_quoyer", "hd_quiop", "hd_qicho", "hd_pliv", "hd_qqilo", "hd_qirin", "hd_milo", "hd_grolet", "hd_prolet", "hd_piov", "hd_qiop", "hd_ceiov", "hd_miov", "hd_ceilo", "hd_Qiris", "hd_giov", "hd_qaiov", "hd_qqiev", "hd_qiev", "hd_qunr", "hd_qrolet", "hd_quliv", "hd_qliv", "hd_qaoyer", "hd_sqrolet", "hd_qailo"], "cluster_data": ["cluster_size", "clusteringsize", "clusters_size", "clusters_entry", "clusteringdata", "cluster_offset", "clusteringoffset", "clusters_data", "clusteringentry", "cluster_entry", "clusters_offset"]}}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "sr", "ss", "p", "b", "i", "c", "bis", "ns", "ts", "sed", "sq", "ds", "us", "ps", "sg", "ks", "sync", "bs", "self", "su", "is", "e", "gs", "south", "sie", "ions", "lines", "session", "sts", "spec", "sv", "l", "si", "less", "sign", "aws", "os", "sb", "services", "sa", "sing", "xs", "ls", "f", "service", "sim", "js", "fs", "t", "an", "v", "sl", "r", "sf", "ops", "ssl", "cs", "g"], "size": ["use", "name", "time", "enc", "buffer", "num", "second", "any", "max", "SIZE", "fee", "number", "six", "n", "core", "content", "complete", "code", "body", "ize", "p", "c", "empty", "sized", "storage", "sum", "en", "address", "speed", "form", "cache", "shape", "now", "timeout", "iz", "large", "len", "g", "args", "sn", "data", "send", "capacity", "Size", "small", "offset", "sec", "length", "count", "page", "i", "shift", "type", "loc", "si", "scale", "handle", "v"], "pb": ["summary", "txt", "uf", "pa", "uc", "p", "b", "parser", "pg", "wb", "pkg", "lb", "ppa", "cv", "bb", "xb", "api", "rb", "ab", "bf", "bh", "jp", "alist", "cb", "gb", "bc", "dp", "py", "prop", "bp", "platform", "bs", "proc", "typ", "plugin", "db", "hub", "PB", "fc", "rob", "fab", "pd", "tmp", "loc", "eb", "pl", "cli", "ctx", "cp", "fb", "sb", "ub", "pm", "lab", "bot", "lc", "wp", "lp", "prot", "tp", "fp", "cpp", "bm", "bps", "vp", "pc", "ib"], "st": ["rest", "std", "sc", "fe", "ST", "ft", "ss", "pt", "rd", "sn", "se", "ts", "sam", "sw", "ld", "ste", "ct", "ast", "ust", "inst", "end", "St", "fr", "typ", "sth", "sp", "td", "sta", "str", "nd", "start", "mt", "sts", "art", "sign", "nt", "lt", "sb", "client", "est", "ist", "sa", "ost", "stage", "stop", "t", "stack", "sd", "dest", "sl", "sf", "post", "put", "ut", "kt"], "strt": ["Strtt", "srs", "drt", "charts", "charT", "frt", "strT", "STRte", "strtt", "trte", "drtt", "chartt", " strT", " strtt", "trt", "srd", "Strts", "Strt", "strs", "drT", "strts", "STRt", "strte", "STRtt", "srt", " strd", "drts", "STRT", " strte", "frts", " strts", "trtt", "strd", "StrT", "chart", " strs", "frd", "trT", "srts", "frs"], "skip": ["use", "call", "gap", "slice", "parse", "jump", "keep", "name", "scroll", "read", "success", "delay", "ignore", "fail", "access", "type", "hide", "speed", "pass", "write", "sync", "op", "allow", "link", "step", "unit", "miss", "min", "zero", "start", "nic", "spec", "offset", "run", "blank", "scale", "item", "hop", "missing", "need", "scan", "sleep", "loop", "ipp", "stop", "eat", "n", "ip", "index", "limit", "Skip", "pos", "wait"], "atom": ["acc", "node", "mom", "cm", "np", "class", "info", "p", "m", "app", "fam", "data", "tm", "base", "orb", "ab", "om", "prop", "component", "oms", "am", "type", "abc", "article", "op", "atomic", "typ", "rss", "mag", " atoms", "tmp", "term", "at", "spec", "abb", "item", "com", "channel", "xml", "tab", "array", "list", "tom", "kat", " Atom", "attr", "plane", "map"], "preamble": [" pREAMble", "pREAMbled", "parsbling", " preambled", "parenble", "pairle", " parenle", "parml", "pairbling", "parmbe", "prambe", "pramble", "prawbe", " pREAMle", "preambling", " parmBLE", " preamBLE", "pairble", " parmbe", "pramBLE", "parmbled", "parmBLE", "prawBLE", "prawle", " preambe", " preamle", "parenBLE", "parsBLE", "parmble", "parsble", "parsle", " parenble", " parenBLE", "prawble", "preambe", "praml", "pREAMle", "prambled", "preaml", "parenle", "pREAMble", "pramle", "parenbling", " pREAMbled", " parmle", " parenbling", "parmle", " parmble", "pairBLE", "preamle", " preaml", " pREAMl", "preambled", "pREAMl", " preambling", "preamBLE"]}}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231, "substitutes": {"rdma": ["rbmas", "ldmp", "rxma", "rbmp", "rrmp", "rnha", "rwmma", "rtma", "rnda", "rrma", "rnma", "rxha", "ldmma", "ldmas", "rrmas", "rtmas", "rdmas", "ldha", "rbma", "rnmma", "rxmma", "ldma", "ldfa", "rdda", "rdmma", "rtmma", "rxda", "ldda", "rrfa", "rbfa", "rwma", "rdfa", "rtda", "rdha", "rwda", "rwmas", "rdmp"], "mode": ["md", "code", "move", "MODE", "m", "dim", "name", "module", "phrase", "data", "style", "access", "type", "kind", "op", "id", "mac", "method", "key", "password", "mission", "path", "command", "role", "lane", "grade", "size", "scale", "direction", "ward", "device", "mod", "Mode", "stage", "perm", "mm", "de", "route", "ode", "range", "language"], "r": ["rs", "k", "sr", "er", "w", "this", "i", "p", "m", "b", "c", "usr", "d", "dr", "hr", "rb", "br", "cr", "gr", "mr", "reader", "fr", "u", "e", "o", "arr", "R", "rh", "err", "str", "lr", "re", "rc", "rg", "ar", "kr", "h", "rt", "f", "nr", "pr", "n", "rx", "t", "v", "root", "rr", "result", "l", "g"]}}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int decode_codestream(J2kDecoderContext *s)\n\n{\n\n    J2kCodingStyle *codsty = s->codsty;\n\n    J2kQuantStyle  *qntsty = s->qntsty;\n\n    uint8_t *properties = s->properties;\n\n\n\n    for (;;){\n\n        int marker, len, ret = 0;\n\n        const uint8_t *oldbuf;\n\n        if (s->buf_end - s->buf < 2){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n\n            break;\n\n        }\n\n\n\n        marker = bytestream_get_be16(&s->buf);\n\n        if(s->avctx->debug & FF_DEBUG_STARTCODE)\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n        oldbuf = s->buf;\n\n\n\n        if (marker == J2K_SOD){\n\n            J2kTile *tile = s->tile + s->curtileno;\n\n            if (ret = init_tile(s, s->curtileno))\n\n                return ret;\n\n            if (ret = decode_packets(s, tile))\n\n                return ret;\n\n            continue;\n\n        }\n\n        if (marker == J2K_EOC)\n\n            break;\n\n\n\n        if (s->buf_end - s->buf < 2)\n\n            return AVERROR(EINVAL);\n\n        len = bytestream_get_be16(&s->buf);\n\n        switch(marker){\n\n            case J2K_SIZ:\n\n                ret = get_siz(s); break;\n\n            case J2K_COC:\n\n                ret = get_coc(s, codsty, properties); break;\n\n            case J2K_COD:\n\n                ret = get_cod(s, codsty, properties); break;\n\n            case J2K_QCC:\n\n                ret = get_qcc(s, len, qntsty, properties); break;\n\n            case J2K_QCD:\n\n                ret = get_qcd(s, len, qntsty, properties); break;\n\n            case J2K_SOT:\n\n                if (!(ret = get_sot(s))){\n\n                    codsty = s->tile[s->curtileno].codsty;\n\n                    qntsty = s->tile[s->curtileno].qntsty;\n\n                    properties = s->tile[s->curtileno].properties;\n\n                }\n\n                break;\n\n            case J2K_COM:\n\n                // the comment is ignored\n\n                s->buf += len - 2; break;\n\n            default:\n\n                av_log(s->avctx, AV_LOG_ERROR, \"unsupported marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n                s->buf += len - 2; break;\n\n        }\n\n        if (s->buf - oldbuf != len || ret){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"error during processing marker segment %.4x\\n\", marker);\n\n            return ret ? ret : -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 24244, "substitutes": {"s": ["sys", "w", "ns", "ts", "sites", "sq", "request", "support", "ps", "states", "sync", "self", "u", "es", "stats", "gs", "http", "lines", "sym", "xs", "f", "service", "qs", "js", "fs", "tests", "t", "n", "r", "ops", "S", "p", "b", "m", "c", "se", "single", "ing", "en", "ds", "us", "ins", "su", "is", "sets", "ions", "spec", "aws", "new", "services", "h", "details", "in", "its", "side", "g", "rs", "ses", "args", "ss", "features", "d", "conf", "sg", "ks", "e", "session", "hs", "sb", "your", "full", "sf", "ssl", "cs", "sv", "i", "plugins", "site", "si", "os", "as", "ls", "y", "styles", "a", "v", "parts", "l"], "codsty": ["odsty", "calltyp", "codsy", "codtyp", "codstyle", "odestyle", "codesta", "cmdsty", "cmdty", "codeestyle", "cdsym", "labgy", "cbsy", "codsym", "codety", "codsta", "cdestyle", " codty", "codestyle", "labty", " codety", "cbty", "codeety", "codetyp", "cbsta", "codty", "cdsta", "cdgy", "cmdsy", "odsta", "odety", "callsta", " codsy", "cdsy", " codestyle", "callgy", " codsta", "odty", "cdty", "odsy", " codsym", "codesty", "cmdsym", "codegy", "labsy", "codgy", "cbsty", " codstyle", " codtyp", "codesy", " codgy", "labsty", "callsty", "cdsty", "odstyle"], "qntsty": ["qtty", "qontwy", "qntwy", "Qntsy", "qntstyle", "wntsy", "Qntty", "wrtpty", "qentsty", "qrtty", "qncwy", "qntety", "Qncwy", "qentrt", "qontsty", "qntsy", "Qntwy", "krtty", "qantty", "qrtpty", "krtpty", "qntpty", "wrtty", "qtety", "Qntsta", "qktrt", "Qntstyle", "krtety", "wntpty", "qntsta", "qrtsta", "qentstyle", "kntety", "qNTty", "qontty", "wntstyle", "qrtrt", "qncty", "qktstyle", "Qncsty", "qntrt", "qndty", "Qncty", "qndsy", "qNTsta", "qrtety", "qntty", "Qrtty", "Qrtsty", "Qntsty", "qrtsy", "wrtrt", "qNTsty", "qNTsy", "qtpty", "Qncstyle", "qktsty", "qndwy", "qrtstyle", "wrtstyle", "Qrtsy", "qncsty", "krtsty", "qtsty", "qncstyle", "wntsty", "qontstyle", "qantsty", "qndstyle", "wrtsty", "kntpty", "qentpty", "qantety", "qktpty", "qantpty", "kntty", "kntsty", "wrtsy", "qndsta", "qncsy", "qrtsty", "wntrt", "Qrtsta", "wntty", "qndsty"], "properties": ["fo", "ie", "features", "charges", "objects", "definition", "flags", "ips", "items", "les", "effects", "metadata", "ms", "prop", "phones", "gb", "ports", "ds", "sites", "types", "property", "rules", "notes", "products", "ties", "ui", "stats", "options", "phy", "fields", "tmp", "pb", "lines", "nb", "strings", "perties", "keys", "progress", "requires", "utils", "nice", "asts", "xml", "json", "classes", "pro", "bytes", "details", "bits", "styles", "reports", "status", "results", "values", "settings", "ops", "description", "resources", "fits", "params", "limits"], "marker": [" Marker", "pler", "marking", " Markiner", " Markeri", " Markier", " markr", " Markr", "linkier", "marketer", "maskener", " markier", "markers", " markiner", "pling", " markner", "marksER", "metener", "plger", "Marketer", "plner", "marksers", " MarkER", "Markeri", " markger", "meter", "Markiner", "maskoser", "meteter", " markeri", "maskER", "Markr", "markseri", "markr", "linkER", "MarkER", "masketer", "markser", "linkeri", "markger", " marking", " Marking", "markeri", "Markener", "masker", "Markers", "Markoser", "markER", " markER", "markiner", "markner", " Markger", "markener", "metER", "markoser", "marksoser", "markier", " Markner", "linker", "maskers", "Marker"], "len": ["seq", "fin", "sid", "bin", "ll", "fn", "vec", "lan", "ld", "en", "bl", "lon", "split", "num", "id", "lf", "mem", "el", "Len", "li", "str", "err", "lit", "rev", "loc", "dl", "lin", "fl", "lis", "lt", "ret", "size", "fat", "ln", "length", "il", "lc", "part", "elt", "count", "lp", "ls", "n", "sil", "net", "sl", "pos", "l", "val", "fun"], "oldbuf": ["newbuff", " oldbu", "Oldqueue", "Oldbuf", "newcb", " oldcb", "Oldcb", "oldqueue", "Oldbuff", "oldercb", "oldbuff", "olderbuf", "newqueue", "oldcb", " oldqueue", "newbuf", " oldbuff", "oldbu", "olderbu", "olderbuff", "newbu"], "tile": ["chip", "ski", "ie", "suit", "module", "tele", "surface", "cube", "project", "coord", "thin", "hop", "ptr", "tel", "Tile", "zip", "tf", "t", "fil", "kid", "late", "tty", "tle", "layer", "mask", "slice", "ele", "ti", "mat", "port", "live", "mobile", "buf", "tri", " tiles", "ugi", "task", "rule", "pod", "tun", "prot", "sl", "plane", "ico", "table", "file", "kt", "txt", "sid", "component", "tif", "profile", "xy", "tmp", "flat", "cli", "phone", "skin", "tab", "transfer", "plate", "tag", "sheet", "theme", "image", "feature", "vt", "chrome", "texture", "depth", "grid", "phy", "tu", "fit", "scale", "co", "dist", "route"]}}
{"project": "FFmpeg", "commit_id": "9745f19ffc9031ce480e43d7cf1053b58100d70f", "target": 0, "func": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n\n    avctx->subtitle_header_size = avctx->extradata_size;\n\n    return 0;\n\n}\n", "idx": 24269, "substitutes": {"avctx": ["avcms", "varctx", "navcontext", "varcontext", "afconnection", "aycontext", "avcontext", "avesync", "afcontext", "avectx", "avcn", "varcn", "avecmp", "navcu", "avecor", "afcca", "avcu", "afsync", "avepkg", "avalloc", "aucmp", "avcca", "evcms", "avalcontext", " avloc", "afcn", "afctx", "avalctx", "avpkg", "afca", "varci", "afci", "avloc", "aveca", "verctx", "avci", "avcf", "avecontext", "evcontext", "avcmp", "aucontext", "avsync", "afcms", "avecu", "avca", "auctx", "afcf", "aupkg", "evctx", " avcf", "avcor", "vercn", "afcor", "avconn", "ayctx", "avalcor", "afconn", "verci", "navconn", "avalcca", "avecf", "aycmp", " avsync", "evcmp", "afpkg", "avecca", "avalconnection", "vercontext", " avca", "afcu", " avcu", "aycms", "avconnection", "aveconn", " avconn", " avcontext", " avconnection", "afloc", "navctx", "afcmp"]}}
{"project": "qemu", "commit_id": "f2b58c43758efc61e2a49b899f5e58848489d0dc", "target": 1, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n\n{\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n    int rc = 1;\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n        s->pdus[i].s = s;\n\n        s->pdus[i].idx = i;\n\n    }\n\n\n\n    v9fs_path_init(&path);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n\n                   \"id = %s\",\n\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n\n                   s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n", "idx": 24280, "substitutes": {"s": ["sys", "w", "server", "ns", "ts", "sq", "ps", "secondary", "states", "sync", "self", "bs", "u", "es", "gs", "stats", "set", "sym", "xs", "f", "service", "qs", "js", "n", "fs", "t", "status", "tests", "r", "native", "S", "p", "m", "b", "c", "se", "storage", "sum", "ds", "us", "state", "ins", "su", "is", "sets", "ims", "spec", "aws", "new", "services", "h", "sl", "settings", "in", "its", "g", "side", "temp", "rs", "ses", "args", "scope", "this", "ss", "d", "data", "ms", "conf", "sg", "ks", "uses", "e", "session", "hs", "sb", "your", "full", "ssl", "cs", "sv", "site", "o", "si", "os", "uns", "as", "ls", "a", "out", "v", "l"], "errp": ["arrfp", "interpi", "docpe", "erP", "aerfp", "rrping", "strr", "erfp", "errpe", "erpi", "rrpre", "erpe", "finderp", "interp", "strf", "strp", " errr", "interfp", "rrp", "errpre", "aerping", "interpre", "aerp", "finderping", "aerpre", "err", " errP", "errpi", "errr", " errf", "errorfp", "erf", "docping", "erpre", "docp", "finderpe", "erping", "erp", "arrp", "arrping", "errP", "errping", "errfp", "finderfp", "rrfp", "docfp", "errorpre", "errf", "strP", "errorp", "errorpi", "arrpre"], "i": ["z", "ie", "p", "info", "m", "c", "b", "d", "ix", "x", "ti", "next", "mi", "type", "qi", "end", "ri", "io", "id", "u", "e", "li", "gi", "zi", "multi", "xi", "uri", "start", "ii", "di", "si", "bi", "ini", "ni", "ai", "ci", "fi", "eni", "iv", "I", "f", "count", "ki", "n", "ip", "index", "j", "oi", "t", "y", "limit", "iu", "ind", "init", "pi", "ui", "l", "hi"], "len": ["seq", "fin", "gen", "z", "dy", "fn", "lan", "ren", "en", "ld", "fail", "bl", "non", "lon", "lf", "mem", "li", "Len", "span", "min", "el", "err", "la", "lit", "rev", "dl", "pl", "lin", "fl", "lang", "loc", "le", "ni", "nt", "lt", "ln", "length", "lc", "il", "elt", "count", "n", "limit", "alt", "lim", "ind", "sl", "pos", "pre", "l", "val"], "stat": ["exec", "Stat", "call", "gen", "info", "m", "p", "c", "name", "cat", "x", "data", "def", "sync", "num", "proc", "all", "link", "stats", "mem", "open", "str", "cpu", "dir", "lib", "dev", "nt", "fi", "size", "sec", "cache", "task", "fs", "status", " Stat", "list", "reg", "net", "un", "block", "lock", "g"], "fse": ["vge", "fspe", "lfse", "fze", "fsge", "vse", "fste", " fsle", "fxce", "cfze", "dsu", "vpse", "fSE", "dpe", "fsle", "rse", "fsu", " fge", "fso", "fcte", "dte", "lfke", "vte", "vze", "fce", " fze", "fke", "fxte", "fge", "fske", " fSE", "Fsu", "rte", "lfsle", "lfte", "fpse", "cfpse", " fte", "rsle", " fsu", "fte", "cfse", " fce", " fke", "fcse", "fcso", "vke", "fpe", "fsso", "fsce", "cfte", "Fte", "fsse", "fsSE", "vSE", "Fpe", "fxse", "rke", "fcpe", " fso", " fpse", "dse", " fpe", "Fse", "fxso"], "path": ["temp", "node", " paths", "sc", "location", " config", "ref", "th", "code", " call", " pointer", "er", "info", "p", "w", "user", "name", " prog", "context", "image", "mount", "data", "text", "pointer", "next", " parent", " info", "prefix", " inner", "pass", "port", "id", "alias", "url", "depth", " name", "key", "str", " pass", "dir", "uri", " node", " text", "ath", " PATH", "parent", " child", " priv", " method", "target", " provider", " prefix", "device", "PATH", " location", "source", "ext", "n", "conn", "host", "root", "dest", "r", "route", "Path", "file", "tag", "pid"]}}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int wsd_read_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    int version;\n\n    uint32_t text_offset, data_offset, channel_assign;\n\n    char playback_time[AV_TIMECODE_STR_SIZE];\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avio_skip(pb, 8);\n\n    version = avio_r8(pb);\n\n    av_log(s, AV_LOG_DEBUG, \"version: %i.%i\\n\", version >> 4, version & 0xF);\n\n    avio_skip(pb, 11);\n\n\n\n    if (version < 0x10) {\n\n        text_offset = 0x80;\n\n        data_offset = 0x800;\n\n        avio_skip(pb, 8);\n\n    } else {\n\n        text_offset = avio_rb32(pb);\n\n        data_offset = avio_rb32(pb);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);\n\n    av_dict_set(&s->metadata, \"playback_time\", playback_time, 0);\n\n\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->codec_id    = s->iformat->raw_codec_id;\n\n    st->codecpar->sample_rate = avio_rb32(pb) / 8;\n\n    avio_skip(pb, 4);\n\n    st->codecpar->channels    = avio_r8(pb) & 0xF;\n\n    st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;\n\n    if (!st->codecpar->channels)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avio_skip(pb, 3);\n\n    channel_assign         = avio_rb32(pb);\n\n    if (!(channel_assign & 1)) {\n\n        int i;\n\n        for (i = 1; i < 32; i++)\n\n            if (channel_assign & (1 << i))\n\n                st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);\n\n    }\n\n\n\n    avio_skip(pb, 16);\n\n    if (avio_rb32(pb))\n\n       avpriv_request_sample(s, \"emphasis\");\n\n\n\n    if (avio_seek(pb, text_offset, SEEK_SET) >= 0) {\n\n        get_metadata(s, \"title\",       128);\n\n        get_metadata(s, \"composer\",    128);\n\n        get_metadata(s, \"song_writer\", 128);\n\n        get_metadata(s, \"artist\",      128);\n\n        get_metadata(s, \"album\",       128);\n\n        get_metadata(s, \"genre\",        32);\n\n        get_metadata(s, \"date\",         32);\n\n        get_metadata(s, \"location\",     32);\n\n        get_metadata(s, \"comment\",     512);\n\n        get_metadata(s, \"user\",        512);\n\n    }\n\n\n\n    return avio_seek(pb, data_offset, SEEK_SET);\n\n}\n", "idx": 24283, "substitutes": {"s": ["S", "sc", "ses", "rs", "sys", "args", "ss", "p", "b", "parser", "c", "ns", "m", "d", "se", "ts", "sq", "ds", "ps", "sg", "ks", "sis", "su", "e", "gs", "sp", "south", "o", "stats", "sie", "spec", "sts", "sv", "si", "sym", "aws", "os", "sb", "services", "sa", "ls", "f", "service", "qs", "fs", "js", "sim", "src", "t", "v", "sl", "r", "sf", "settings", "ops", "ssl", "cs", "g"], "pb": ["summary", "pp", "dll", "uf", "pa", "p", "pt", "parser", "pg", "pkg", "wb", "b", "lb", "ppa", "xb", "phrase", "api", "ld", "rb", "prop", "bf", "bh", "gb", "jp", "cb", "py", "bc", "dp", "bp", "platform", "bs", "plugin", "typ", "db", "mp", "PB", "fc", "hub", "rob", "pd", "nb", "dl", "pl", "eb", "mb", "ab", "ctx", "cp", "sb", "fb", "pm", "bot", "lab", "lc", "wp", "um", "lp", "tc", "prot", "tp", "fp", "cpp", "bm", "bps", "vp", "pc", "ib", "pid"], "st": ["rest", "std", "sc", "fe", "ST", "ft", "ss", "sn", "pt", "se", "sw", "sam", "ts", "ld", "ste", "stand", "www", "ct", "bl", "ast", "ust", "inst", "end", "St", "fr", "trans", "sth", "sp", "ess", "td", "sta", "str", "nd", "mt", "start", "sts", "set", "tt", "dt", "art", "nt", "lt", "sb", "est", "ist", "sa", "ost", "rt", "elt", "stage", "stop", "src", "t", "sd", "sl", "stab", "bt", "et", "irst", "put", "ut", "kt"], "version": ["VERSION", "package", "class", "section", "date", "Version", "server", "option", "name", "position", "cv", "vision", "feature", "type", "beta", "support", "bug", "vers", "serial", "plugin", " VERS", "depth", "ception", "python", "step", "patch", "VER", " Version", "model", "versions", "parent", " ver", "vert", " versions", "scale", "number", "channel", "video", "length", "current", "update", "translation", "f", "stage", "value", "v", "ver", "release", "event", "alpha", "result", "connection", "latest", "tag", "format", "final"], "text_offset": ["attribute_shift", "output_offs", "text_offs", "text_Offset", "text_size", "text_shift", "output_skip", "textxoffset", " text_size", "attribute_skip", "textxOffset", "textxskip", "attribute_slot", "text_skip", "attribute_offset", "output_offset", " text_limit", "text_slot", "text_limit", " text_usage", "textxoffs", "text_usage", "output_Offset"], "data_offset": ["data\u00b7off", "data_index", "body_notation", "data_entry", "body___notation", "data\u00b7offset", "image_offset", "audio_offset", "image_off", "data_notation", "body___limit", "image_limit", "body_offset", "body___offset", "data\u00b7size", "image_size", "data\u00b7limit", "data_limit", "body_entry", "data_size", "data___limit", "data___entry", "data_skip", "data___offset", "audio_off", "audio_index", "data_off", "body___entry", "data___notation", "body_limit", "audio_skip"], "channel_assign": ["channel_alllate", "channel_assigning", "channel_ignigning", "channel_assIGN", "channel_allIGN", "channel_Assign", "channel_ignigned", "channel_ASSignment", "channel_allignment", "channel_isalign", "channel_attigning", "channel_Assigning", "channel_alligned", "channel_affigning", "channel_AssIGN", "channel_isallate", "channel_isalignment", "channel_attlate", "channel_ignign", "channel_attignment", "channel_ignignment", "channel_Assigned", "channel_Assignment", "channel_attIGN", "channel_affign", "channel_ASSigning", "channel_attign", "channel_allign", "channel_assignment", "channel_attigned", "channel_ASSign", "channel_assigned", "channel_isaligned", "channel_asslate", "channel_affignment"], "playback_time": ["playback2times", "playback_offset", "playboard24time", "playback24time", "playboard24times", "playBack_info", "playbackJtime", "playbackJoffset", "playBack_time", "playBack_rate", "playBack_name", "playback24times", "playBack_times", "playBack_offset", "playbackJtimes", "playboard24rate", "playback24rate", "playboard_times", "playbackJinfo", "playback2name", "playboard_rate", "playback2time", "playboard24info", "playback24info", "playboard_time", "playback_info", "playback_name", "playback2rate", "playboard_info", "playback_rate", "playback_times"], "i": ["abi", "slice", "k", "z", "yi", "p", "m", "info", "c", "b", "uli", "x", "ti", "mi", "phi", "qi", "ri", "io", "num", "split", "u", "e", "li", "gi", "ji", "o", "zi", "multi", "xi", "bi", "di", "si", "ii", "ini", "ni", "ai", "ci", "fi", "eni", "block", "I", "count", "f", "chi", "n", "j", "index", "ip", "a", "value", "v", "mu", "pi", "ui", "l", "hi"]}}
{"project": "FFmpeg", "commit_id": "16c6795465fd7663792fe535256c760560714863", "target": 0, "func": "x11grab_read_header(AVFormatContext *s1)\n\n{\n\n    struct x11grab *x11grab = s1->priv_data;\n\n    Display *dpy;\n\n    AVStream *st = NULL;\n\n    enum AVPixelFormat input_pixfmt;\n\n    XImage *image;\n\n    int x_off = 0;\n\n    int y_off = 0;\n\n    int screen;\n\n    int use_shm;\n\n    char *dpyname, *offset;\n\n    int ret = 0;\n\n    Colormap color_map;\n\n    XColor color[256];\n\n    int i;\n\n\n\n    dpyname = av_strdup(s1->filename);\n\n    if (!dpyname)\n\n        goto out;\n\n\n\n    offset = strchr(dpyname, '+');\n\n    if (offset) {\n\n        sscanf(offset, \"%d,%d\", &x_off, &y_off);\n\n        if (strstr(offset, \"nomouse\")) {\n\n            av_log(s1, AV_LOG_WARNING,\n\n                   \"'nomouse' specification in argument is deprecated: \"\n\n                   \"use 'draw_mouse' option with value 0 instead\\n\");\n\n            x11grab->draw_mouse = 0;\n\n        }\n\n        *offset= 0;\n\n    }\n\n\n\n    av_log(s1, AV_LOG_INFO, \"device: %s -> display: %s x: %d y: %d width: %d height: %d\\n\",\n\n           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);\n\n\n\n    dpy = XOpenDisplay(dpyname);\n\n    av_freep(&dpyname);\n\n    if(!dpy) {\n\n        av_log(s1, AV_LOG_ERROR, \"Could not open X display.\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto out;\n\n    }\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto out;\n\n    }\n\n    avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */\n\n\n\n    screen = DefaultScreen(dpy);\n\n\n\n    if (x11grab->follow_mouse) {\n\n        int screen_w, screen_h;\n\n        Window w;\n\n\n\n        screen_w = DisplayWidth(dpy, screen);\n\n        screen_h = DisplayHeight(dpy, screen);\n\n        XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);\n\n        x_off -= x11grab->width / 2;\n\n        y_off -= x11grab->height / 2;\n\n        x_off = FFMIN(FFMAX(x_off, 0), screen_w - x11grab->width);\n\n        y_off = FFMIN(FFMAX(y_off, 0), screen_h - x11grab->height);\n\n        av_log(s1, AV_LOG_INFO, \"followmouse is enabled, resetting grabbing region to x: %d y: %d\\n\", x_off, y_off);\n\n    }\n\n\n\n    use_shm = XShmQueryExtension(dpy);\n\n    av_log(s1, AV_LOG_INFO, \"shared memory extension%s found\\n\", use_shm ? \"\" : \" not\");\n\n\n\n    if(use_shm) {\n\n        int scr = XDefaultScreen(dpy);\n\n        image = XShmCreateImage(dpy,\n\n                                DefaultVisual(dpy, scr),\n\n                                DefaultDepth(dpy, scr),\n\n                                ZPixmap,\n\n                                NULL,\n\n                                &x11grab->shminfo,\n\n                                x11grab->width, x11grab->height);\n\n        x11grab->shminfo.shmid = shmget(IPC_PRIVATE,\n\n                                        image->bytes_per_line * image->height,\n\n                                        IPC_CREAT|0777);\n\n        if (x11grab->shminfo.shmid == -1) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Can't get shared memory!\\n\");\n\n            ret = AVERROR(ENOMEM);\n\n            goto out;\n\n        }\n\n        x11grab->shminfo.shmaddr = image->data = shmat(x11grab->shminfo.shmid, 0, 0);\n\n        x11grab->shminfo.readOnly = False;\n\n\n\n        if (!XShmAttach(dpy, &x11grab->shminfo)) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Failed to attach shared memory!\\n\");\n\n            /* needs some better error subroutine :) */\n\n            ret = AVERROR(EIO);\n\n            goto out;\n\n        }\n\n    } else {\n\n        image = XGetImage(dpy, RootWindow(dpy, screen),\n\n                          x_off,y_off,\n\n                          x11grab->width, x11grab->height,\n\n                          AllPlanes, ZPixmap);\n\n    }\n\n\n\n    switch (image->bits_per_pixel) {\n\n    case 8:\n\n        av_log (s1, AV_LOG_DEBUG, \"8 bit palette\\n\");\n\n        input_pixfmt = AV_PIX_FMT_PAL8;\n\n        color_map = DefaultColormap(dpy, screen);\n\n        for (i = 0; i < 256; ++i)\n\n            color[i].pixel = i;\n\n        XQueryColors(dpy, color_map, color, 256);\n\n        for (i = 0; i < 256; ++i)\n\n            x11grab->palette[i] = (color[i].red   & 0xFF00) << 8 |\n\n                                  (color[i].green & 0xFF00)      |\n\n                                  (color[i].blue  & 0xFF00) >> 8;\n\n        x11grab->palette_changed = 1;\n\n        break;\n\n    case 16:\n\n        if (       image->red_mask   == 0xf800 &&\n\n                   image->green_mask == 0x07e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log (s1, AV_LOG_DEBUG, \"16 bit RGB565\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB565;\n\n        } else if (image->red_mask   == 0x7c00 &&\n\n                   image->green_mask == 0x03e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log(s1, AV_LOG_DEBUG, \"16 bit RGB555\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB555;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR, \"RGB ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 24:\n\n        if (        image->red_mask   == 0xff0000 &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0x0000ff ) {\n\n            input_pixfmt = AV_PIX_FMT_BGR24;\n\n        } else if ( image->red_mask   == 0x0000ff &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0xff0000 ) {\n\n            input_pixfmt = AV_PIX_FMT_RGB24;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR,\"rgb ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 32:\n\n        input_pixfmt = AV_PIX_FMT_0RGB32;\n\n        break;\n\n    default:\n\n        av_log(s1, AV_LOG_ERROR, \"image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n        ret = AVERROR_PATCHWELCOME;\n\n        goto out;\n\n    }\n\n\n\n    x11grab->frame_size = x11grab->width * x11grab->height * image->bits_per_pixel/8;\n\n    x11grab->dpy = dpy;\n\n    x11grab->time_base  = av_inv_q(x11grab->framerate);\n\n    x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);\n\n    x11grab->x_off = x_off;\n\n    x11grab->y_off = y_off;\n\n    x11grab->image = image;\n\n    x11grab->use_shm = use_shm;\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width  = x11grab->width;\n\n    st->codec->height = x11grab->height;\n\n    st->codec->pix_fmt = input_pixfmt;\n\n    st->codec->time_base = x11grab->time_base;\n\n    st->codec->bit_rate = x11grab->frame_size * 1/av_q2d(x11grab->time_base) * 8;\n\n\n\nout:\n\n    av_free(dpyname);\n\n    return ret;\n\n}\n", "idx": 24289, "substitutes": {"x11grab": ["y13rob", "x86save", "sex110stab", " x14focus", "x11Grab", "x12grab", "X14rob", "x14storage", "X11transfer", "sex110grab", "X11grab", "x511grab", "x15fab", "X12grab", "x12pop", "x1grab", "x11crop", " x11transfer", "x13tab", "x86stab", " x11rob", "sex110save", "x100crop", "y11hide", "x14transfer", "x15rob", "x18grab", "x15tab", "x11hide", "X11rob", "x18pop", "x100rob", "sex11save", "X14Grab", "x110rob", "y11tab", "x11storage", "X12pop", "x14rob", "x18rob", "x12Grab", "x100grab", "xi15fab", "x1rob", "x13hide", "x11rob", "x101crop", "x10grab", "x86rob", "x100transfer", " x14transfer", "x11stab", "x14focus", "x15crop", "x110crop", " x100hide", "X14grab", "x101grab", "x11save", "x511storage", "x15hide", "x110pop", "X12crop", "x13rob", "x18save", "x110Grab", "X12Grab", "y13tab", "X11crop", "x18crop", "X11pop", "x13grab", "x110stab", "xi11Grab", "sex11rob", "x12fab", "x18stab", "x110grab", "x1tab", "xi15rob", "xi11grab", " x100grab", "x15Grab", "x1hide", "x12crop", "x101hide", "x14Grab", "y13hide", "x511transfer", " x11focus", "y11rob", "x10focus", "xi11fab", "X14transfer", "y11grab", "x10rob", "x10storage", " x11storage", "x86grab", "x15grab", "x11pop", "x10Grab", "x11fab", "x101rob", "x14grab", "x10transfer", "sex11grab", "x100hide", "x110save", "x11focus", "y13grab", "x100Grab", " x100crop", "sex11stab", "sex110rob", " x14grab", "xi11rob", "x18Grab", "xi15Grab", " x14storage", " x11hide", " x11crop", "x10fab", " x100rob", "x12rob", "x511focus", "xi15grab", "X11Grab", "x11tab", "x11transfer"], "dpy": ["Dpi", "dmy", "cdpy", "ldp", "ldpi", "bdpy", "vdpy", "lpie", "adply", "cdPy", " dph", "dspsy", "ndpsy", "ndpi", "vdPy", "ppi", "dpi", "pdpe", "adpe", "dapy", " dcp", "ppy", "dp", " dpi", "dPy", "pdpy", "lply", "epsy", "sdmy", "ndpy", " dpe", "dply", "dhapy", "bdsync", "vdpe", "pp", " dpie", "dsync", "pdpie", "adpy", "epi", "inpe", "Dpy", "Dcp", "dpe", "dspy", "Dp", " dply", "Dmi", "epy", "sdapy", "ldply", "Dpe", "ldpie", "ppty", "bdpe", "eph", "lpy", "dpie", " dpty", "sdpsy", "cdpe", "lpe", "dhpsy", "sdpy", "Dpty", "pdply", "dsmy", "ldpy", "inply", "vdsync", " dpsy", "pcp", "inpie", "inpy", "dpsy", "dcp", "dsapy", "ndph", "ldpe", " dmi", "dph", "dhpy", "pmi", "dhmy", "dpty", "adpie", "ppe", " dp", "dmi", "cdsync", "bdPy"], "st": ["rest", "std", "sc", "sty", "obj", "sr", "ST", "ft", "sn", "rd", "sw", "ld", "ste", "cr", "ct", "bl", "ast", "ust", "inst", "St", "fr", "sth", "sp", "td", "sta", "str", "tmp", "nd", "stim", "start", "sts", "tt", "art", "nt", "sb", "est", "ist", "sa", "ost", "rt", "stream", "src", "t", "stack", "sl", "put", "ut", "sh"], "image": ["gif", "picture", "cm", "frame", "pg", "large", "x", "photo", "media", "img", "mage", "icon", "amp", "jpg", "ii", "original", "video", "crop", "view", "Image", "xml", "ng", "im", "png", "document", "file"], "screen": ["esc", "use", "remote", "sc", "code", "console", "Screen", "scope", "page", "widget", "score", "play", "close", "resolution", "scroll", "creen", "sw", "scene", "isc", "display", "en", "style", "speed", "chrome", " Screen", "port", "profile", "script", "sp", "resh", "con", "twitter", "password", " sc", "process", "clear", "size", "sec", "video", "channel", "game", "scan", "win", "six", "timeout", "window", "count", "gc", "stage", "network", "glass", " scr", "net", "core", "png", "draw", "pen"], "use_shm": ["use_thmi", "use_whw", "use_thm", "use_frm", "use_thw", "use_shw", "use_frcm", "use2thm", "use_whcm", "use_shmi", "use2thcm", "use2thmi", "use2shcm", "use_whm", "use_shcm", "use2thw", "use_frw", "use2shm", "use_frmi", "use_thcm", "use2shw", "use_whmi", "use2shmi"], "dpyname": ["dpynase", "dpypAME", "dpinnames", "dpennename", "dpylAME", "dpennase", "dcynames", "dpname", "dpnamel", "copennamel", "dpynaming", "tpennename", "dcynename", "dpypame", "pynname", "tpylAME", "tpenname", "vpynAME", "dpyaname", "vpypame", "dpypase", "dcylode", "tpennase", "dpysames", "dcynaming", "dpignaming", "dcynAME", "dpynode", "tpylames", "pyname", "pYNename", "dpydAME", "dpenname", "vpyname", "vpynames", "dpennamel", "copenname", "tpyname", "dpypames", "dpennoe", "vpypAME", "dpylename", "dpyanname", "dpyanamel", "dpinname", "dpylode", "dcylame", "dpysename", "dpynAME", "dpylaming", "dpynamed", "dpydode", "copynoe", "pynename", "dpnoe", "tpennAME", "dpnamed", "dcypame", "tpylename", "dpyanename", "dpyanase", "dpennAME", "pYName", "copynamel", "copynamed", "dpylames", "dcylaming", "pynamed", "dpignAME", "dpinnAME", "copennamed", "dcypames", "pYNamed", "dpYNename", "dpYNames", "dpynename", "pYNname", "dpigname", "dcypename", "dpinnamed", "tpynAME", "dpyanAME", "vpynename", "dpyanamed", "dpynoe", "dpinnname", "dpynamel", "dpYNAME", "dpypename", "vpypename", "dcylAME", "dpylame", "dcypAME", "dcynode", "dpynames", "dpysAME", "dpinnename", "dpignode", "dpYName", "dpydaming", "dpennamed", "dpYNamed", "dpYNname", "dpydame", "copyname", "tpylame", "copennoe", "tpynames", "dpysame", "vpypames", "dpynname", "dcyname", "tpynase", "tpynename", "dpyanoe"], "offset": ["ref", "location", "skip", "annot", "slice", "page", "p", "info", "option", "shift", "position", "function", "scroll", "connection", "data", "attribute", "no", "align", "pointer", "address", "type", "prefix", "Offset", "optional", "reference", "end", "alias", "pad", "o", "padding", "initial", "layout", "start", "axis", "loc", "slot", "output", "append", "order", "online", "size", "missing", "origin", "off", "length", "addr", "timeout", "array", "part", "reset", "f", "comment", "index", "operation", "fp", "alpha", "ace", "range", "pos", "et", "layer"], "color_map": ["color_maps", "gray_set", "gray_maps", "color_set", "gray_map", "gray_code", "color_code"], "color": ["mask", "space", "COLOR", "byte", "data", "base", "col", "type", "colour", "gray", "black", "cap", "object", "Color", "number", "array", "window", "list", "pair", "map", "block", "white", "format"], "i": ["b", "p", "info", "pixel", "data", "on", "align", "it", "id", "ui", "is", "e", "cut", "line", "s", "start", "inner", "ii", "si", "I", "f", "n", "index", "pi", "reset"], "screen_w": ["disk_width", "screen_y", "disk_y", "screen_off", " screen_off", " screen_W", "screenNoff", "screenNw", "disk_w", "disk_won", "screenNh", "screen_won", "screenNW", "screen_W", "screen_width"], "screen_h": ["screen25h", " screen_ha", "screen25w", "screen25ha", " screen_hh", "screen25v", "screen_v", "screen_ha", " screen_sh", "screen_hh", "screen_sh", " screen_v"], "w": ["ow", "z", "widget", "p", "m", "c", "wb", "d", "sw", "x", "weight", "wh", "rw", "u", "wx", "e", "max", "l", "fw", "ew", "web", "win", "wid", "h", "window", "f", "y", "aw", "wall", "n", "W", "wt", "t", "row", "v", "r", "we", "wa", " W", "g"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++)\n\n        if (simple_limit(dst+i*stride, 1, flim))\n\n            filter_common(dst+i*stride, 1, 1);\n\n}\n", "idx": 24291, "substitutes": {"dst": ["dsST", "Dost", " dsts", "iddr", "dsts", "godst", "dsst", "Dld", "pdld", "pdost", "sdST", "dST", "Ddr", " dost", "ddr", "godset", "idset", "dset", "pddr", "dssc", "sdsc", "sdsts", "dld", "sdst", "dssts", "idld", "godost", " dsc", "godsc", " dset", "dost", " dST", "dsc", "idsc", "idost", "pdst", "Dst", "idst"], "stride": [" strided", "Strider", "charode", "yride", "charide", "STRide", "stade", "stided", " strode", "stode", "stider", "strode", " strIDE", "yrided", "charIDE", "Strided", "strride", "stIDE", "stine", "stide", "STRided", "strIDE", "yrade", " strine", "strider", "strade", "Stride", "STRride", "STRine", "strided", "charided", "yrider", "Strade", " strride", "strine"], "flim": [" flog", " flimit", " fmem", " fmi", "dlimit", "rfmi", "fmem", "climit", "flimited", "flimit", " flic", "sfmi", "cmem", "dlog", "rflic", "flic", " flimited", "dlim", "sflic", "flog", "fmi", "sflim", "sflimited", "dmem", "rflimited", "rflim", "clim"], "i": ["strength", "abi", "slice", "iii", "p", "b", "info", "m", "d", "uni", "ix", "x", "api", "adi", "ti", "mi", "ei", "qi", "it", "phi", "ri", "id", "io", "u", "e", "li", "o", "ji", "gi", "zi", "multi", "xi", "uri", "ii", "di", "si", "ai", "bi", "ini", "ni", "ci", "fi", "eni", "sup", "h", "I", "f", "count", "oi", "mini", "j", "index", "ip", "v", "iu", "mu", "pi", "attr", "in", "ui", "l", "hi", "ami"]}}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292, "substitutes": {"bs": ["rs", "ses", "iss", "ss", "b", "bas", "bis", "lbs", "ns", "lb", "bb", "las", "vs", "base", "blocks", "ubis", "ds", "gb", "us", "bos", "bc", "BS", "ks", "states", "css", "bus", "db", "gs", "fps", "ubs", "pb", "os", "nas", "bes", "fb", "sb", "ras", "boxes", "bid", "ls", "fs", "bits", "js", "bps", "cs", "banks"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n", "idx": 24294, "substitutes": {"nonblocking": [" nonblock", "Nonlocking", "notlocking", "nolocking", " nonlocking", "Nonblocking", " nonblocks", "nonlocking", "nonblock", "noblock", "noblocks", "notblock", "Nonblocks", "Nonblock", "notblocks", "noblocking", "notblocking", "nonblocks"], "last_io": [" last_iol", "last_iol", "last_lo", " last_lo", "last_ios", " last_ios", " last_ori", "last_ori", " last_exec", "last_timeout", "last_exec", " last_timeout"], "ti": ["ati", "abi", "ski", "ie", "i", "tis", "tta", "ta", "isi", "tti", "tm", "trace", " vi", "mi", " i", "ita", "ri", "li", "tu", "zi", "xi", "TI", "ii", "di", "si", "bi", "ai", "ni", "ini", "cli", "hi", "ci", "fi", "iti", "vi", "eni", "tw", "timer", "rt", "ki", "ori", "obi", "iu", "tim", "pi", "ui", "wa", "iot"], "r": ["ru", "rs", "w", "er", "b", "m", "p", "c", "d", "hr", "rf", "or", "trace", "rb", "br", "cr", "race", "ra", "ri", "rw", "u", "nor", "e", "o", "resource", "R", "rl", "runs", "err", "lr", "rar", "re", "rc", "rg", "kr", "ro", "ry", "h", "rt", "f", "nr", "rx", "n", "a", "t", "runner", "q", "v", "root", "attr", "rr", "range", "l"]}}
{"project": "qemu", "commit_id": "0928a95ffe91862938cee997c9e30602fa7884ab", "target": 0, "func": "static void bootp_reply(const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    const struct in_addr *preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr)\n\n        dprintf(\" req_addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n    else\n\n        dprintf(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr) {\n\n            bc = request_addr(preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = *preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(&daddr.sin_addr);\n\n            if (!bc) {\n\n                dprintf(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else if (preq_addr) {\n\n        bc = request_addr(preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = *preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, 6);\n\n        } else {\n\n            daddr.sin_addr.s_addr = 0;\n\n        }\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        dprintf(\"%s addr=%08x\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24311, "substitutes": {"bp": ["pp", "np", "p", "b", "pg", "pkg", "lb", "bn", "bb", "rb", "bf", "gb", "jp", "bh", "cb", "py", "kb", "db", "BP", "sp", "hp", "bitcoin", "pd", "pb", "cp", "sb", "fb", "gp", "wp", "lp", "tp", "arp", "conn", "fp", "bm", "cpp", "bps", "bt", "pc", "ap"], "bc": ["exec", "ref", "sc", "abi", "cm", "acl", "comm", "cca", "dc", "uc", "oc", "b", "ml", "c", "bo", "wb", "lb", "bn", "bb", "xc", "ec", "cur", "config", "bf", "bd", "cb", "bl", "abc", "sync", "mac", "bs", "db", "fc", "cms", "lic", "bitcoin", "vc", "cl", "ic", "loc", "lib", "bi", "cc", "cn", "sb", "web", "mc", "rc", "sec", "com", "cf", "BC", "fb", "lc", "ctrl", "ca", "BBC", "gc", "MC", "tc", "loop", "bg", "func", "nc", "ac", "pc", "g"], "m": ["md", "hm", "cm", "ml", "b", "p", "c", "i", "d", "manager", "msg", "module", "mad", "me", "tm", "media", "ms", "am", "mi", "fm", "mr", "u", "mx", "e", "em", "o", "message", "rm", "mt", "M", "mn", "wm", "mc", "vm", "man", "im", "um", "h", "f", "sm", "y", "n", "dm", "bm", "t", "mm", "v", "r", "mu", "gm", "l", "g"], "rbp": ["rlp", "wbp", "vrpc", "lrtp", "lbtp", "rdpr", "rbpc", "bbp", "rdpc", "vrv", "lrP", "rdc", "rbtp", "rtpc", "wbpr", "lrp", "RBtp", "RBp", "rbc", "rbv", "rbpr", "bbpi", "lrpc", "rtp", "bbv", "rtpi", "lbpc", "rdp", "lbP", "rbpi", "rtv", "rlpr", "vrpi", "bbpc", "rbP", "RBpc", "rlpc", "wbpc", "rlc", "RBP", "lbp", "vrp", "wbc"], "saddr": ["sysaddress", "syshop", "_hop", " saddress", "_address", "shop", "saddress", "sysaddr", " shop", "_addr"], "daddr": ["Daddr", "poder", "paddr", " dalias", "dattr", "baddress", "Daddress", "raddress", "doder", " daddress", " doder", "baddr", "adalias", "darr", "pacl", "daddress", "parr", "roder", "barr", "lattr", "paddress", "Darr", "adarr", "dnode", " dnode", "Dattr", "dyaddr", "laddr", "adaddr", "battr", "laddress", "dynode", "dacl", "larr", " dattr", " dacl", "adnode", " darr", "pattr", "raddr", "racl", "dyalias", "dyarr", "dalias"], "dns_addr": ["dnet_url", "dns_name", "dnet_address", "dnsamaddress", "dns_address", "dnsamaddr", "dns_url", "dnet_name", "dnsamurl", "dnsamname", "dnet_addr"], "preq_addr": ["preq__host", "preq_dr", "prereq_address", "prequest_hl", "preq__name", "preq2address", "preq_error", "preque67url", "prequest__node", "preqkhop", "preq67arm", "preque_loc", "preq_offer", "prev_address", "preq2add", "prereq_addr", "prequest_nr", "preq_host", "preqkaddr", "preq_nr", "preq2host", "preqdnode", "preq2dr", "preq67loc", "prereq_rx", "preqMtype", "prece_host", "prequest_dr", "preqinghl", "preq__add", "preqkdata", "preqdaddr", "preqddr", "prequest_hop", "prequest_offset", "prec_offer", "preq_node", "preq67url", "preq_ord", "preq__node", "preqkaddress", "prequest_node", "preq_loc", "preqMaddress", "preq_data", "prequest__address", "preq_orig", "preqingaddr", "preq__dr", "preqdtype", "prequest__type", "prece_dr", "preq_hop", "prereq_dist", "prev_data", "preq2hop", "preq67offer", "preq__offset", "preq2addr", "preq_add", "preq__addr", "preq_name", "preqMnode", "preque_url", "preq__ord", "preq_dist", "preqMaddr", "prece_addr", "preq_address", "preq__address", "preqdaddress", "prequest_orig", "preqingorig", "preque_addr", "preq_offset", "preq67error", "prequest_address", "preq_type", "prec_addr", "prereq_name", "prev_hop", "preq2nr", "prequest_type", "preqingaddress", "preq_arm", "preq_rx", "preq_hl", "preq67addr", "prev_addr", "preqdoffset", "prec_error", "prequest__addr", "preq_url", "preq__type", "preque67arm", "preque67addr", "preque67loc", "preque_arm", "prequest_addr", "prece_add", "prereq_ord"], "dhcp_msg_type": ["dhcp_msgbtype", "dhcp_message_code", "dhcp_msg_id", "dhcp_msg_block", "dhcp_message_class", "dhcp_msgbformat", "dhcp_message_key", "dhcp_msgbname", "dhcp_message_data", "dhcp_message_no", "dhcp_msg__type", "dhcp_msg_no", "dhcp_msg_data", "dhcp_message_num", "dhcp_msg__num", "dhcp_msg_types", "dhcp_msg_code", "dhcp_message_types", "dhcp_message_name", "dhcp_msg__id", "dhcp_msgbid", "dhcp_msg_class", "dhcp_msg_name", "dhcp_message_type", "dhcp_message_block", "dhcp_msg__block", "dhcp_message_id", "dhcp_message_info", "dhcp_msg_key", "dhcp_msg_info", "dhcp_msg_num", "dhcp_message_format", "dhcp_msg_format"], "val": ["ref", "seq", "w", "msg", "x", "enc", "eval", "data", "def", "num", "ne", "all", "vals", "al", "key", "valid", "fee", "sel", "ret", "sec", "f", "value", "aud", "v", "r", "len", "g"], "q": ["seq", "iq", "Q", "k", "w", "z", "c", "d", "x", "qa", "qt", "sq", "config", "id", "o", "cl", "s", "eq", "req", "h", "f", "qq", "v", "r", "query", "dq", "g"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n", "idx": 24312, "substitutes": {"f": ["ref", "fen", "framework", "font", "w", "p", "m", "b", "c", "d", "function", "rf", "x", "fn", "fff", "filename", "form", "fr", "e", "fc", "feed", "o", "ff", "s", "inf", "fi", "fb", "fx", "fore", "buff", "h", "fs", "n", "fa", "t", "fp", "func", "v", "full", "r", "g", "sf", "fold", "l", "fd", "file", "F"], "cpu_fprintf": ["cpu_rfprintf", "cpu_forriter", "cpu_forformat", "cpu_formt", "cpu_Fwrite", "cpu_fmt", "cpu_frprintln", "cpu_forprintln", "cpu_frprintf", "cpu_fwrite", "cpu_forprint", "cpu_Fprint", "cpu_friter", "cpu_rfmt", "cpu_fformat", "cpu_frriter", "cpu_forprintf", "cpu_forwrite", "cpu_fprint", "cpu_rfprint", "cpu_Fprintf", "cpu_frwrite", "cpu_rfprintln", "cpu_fprintln", "cpu_Fprintln", "cpu_rfformat", "cpu_rfwrite"], "features": ["pieces", "ants", "ATURES", "info", "includes", "ns", "flags", "frames", "ips", "pins", "forms", "feature", "types", "plugins", "format", "span", "fields", "prints", "strings", "fts", "ributes", "versions", "faces", "requires", "tops", "properties", "files", "lists", "feat", "Features", "pages", "classes", "eatures", "details", "bits", "names", "tests", "modules", "settings", "fixes", "ints", " Features"], "prefix": ["ref", "primary", "info", "p", "master", "name", "ix", "flags", "phrase", "fix", "buffer", "base", "text", "filename", "pointer", "feature", "support", "type", "reference", "bp", "pad", "repeat", "patch", "radius", "padding", "path", "progress", "uri", "pattern", "offset", "parent", "scale", "cache", "length", "before", "mix", "prot", "fp", "pre", "reset", "fixes", "foo", "border", "format"], "i": ["abi", "k", "z", "ie", "p", "m", "b", "c", "yi", "name", "d", "ix", "x", "ti", "qi", "it", "ri", "id", "io", "u", "e", "key", "o", "gi", "li", "ji", "zi", "multi", "xi", "start", "uri", "ii", "bi", "si", "di", "ai", "ni", "ini", "ci", "fi", "isin", "lc", "h", "I", "y", "oi", "n", "j", "index", "t", "v", "iu", "ind", "pi", "mu", "in", "ui", "l"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315, "substitutes": {"gen_code_buf": ["gen_code36end", "gen_code2len", "gen_code_len", "gen_codes_end", "gen_code24ptr", "gen_code1len", "gen_code1uf", "gen_code36buf", "gen_code24buff", "gen_code_uf", "gen_call_offset", "gen_code_pad", "gen_call_buff", "gen_code_buffer", "gen_code24buf", "gen_codes2end", "gen_codes_buf", "gen_code_offset", "gen_codes2buf", "gen_call_buffer", "gen_code2uf", "gen_code36len", "gen_codes_uf", "gen_code2end", "gen_code36uf", "gen_code24end", "gen_codes2len", "gen_codes2uf", "gen_code1buf", "gen_code1end", "gen_code_buff", "gen_code2buf", "gen_call_buf", "gen_codes_len", "gen_call_end", "gen_call_pad", "gen_code_ptr", "gen_call_ptr"], "max_code_size": ["max_code_capacity", "max_codes_capacity", "max_code_SIZE", "max_codes_size", "max_cache_SIZE", "max_codes_len", "max_code2size", "max_code2max", "max_code_max", "max_code_len", "max_code2SIZE", "max_cache_size", "max_cache_max"], "gen_code_size_ptr": ["gen_code_address_tr", "gen_code_address_pointer", "gen_code_size_pt", "gen_code_address_pt", "gen_code_size_pointer", "gen_code_address_ptr", "gen_code_size_tr", "gen_code_size_inter"], "pc_start": ["pc67start", "pc_offset", "PC_end", "pc2len", "pc2ptr", "pc_end", "fc_start", "PC_start", "fc_end", "pc_scale", "pc67scale", "pc_len", "PC_len", "pc67offset", "PC_ptr", "pc2start", "fc_offset", "pc2end", "fc_scale", "pc67end"], "flags": ["mask", "comments", "ants", "seq", "args", "heads", "features", "flag", "days", "cards", "Flags", " Flags", "pins", "blocks", "opens", "planes", "types", "rules", "plugins", "windows", "vals", "lins", "lf", "stats", "codes", "rets", "options", "fields", "s", "strings", "lines", "fts", "fee", "limits", "words", "lag", "utils", "files", "mods", "feat", "xs", "pages", "ags", "f", "fs", "bytes", "bits", "groups", "alls", "tests", "checks", "details", "func", "atts", "FLAG", "ops", "packs", "len", "ints", "fun"], "dc1": ["c2", "dc0", " dc0", "c0", "DC1", "nc1", " dc2", "DC2", "DC0", "nc0", "rc1", "rc0", "c1", "dc2"], "dc": ["gui", "sc", "ctl", "DC", "cca", "uc", "cd", "director", "dim", "c", "auc", "d", "dr", "fd", "enc", "doc", "xc", "ec", " DC", "ds", "cr", "diff", "ct", "bc", "abc", "dp", "dd", "ea", "db", "fc", "td", "cmd", "input", "dat", "vc", "cdn", "dir", "loc", "disc", "jc", "di", "enter", "dt", "cc", "cf", "mc", "ga", "rc", "inc", "dra", "device", "design", "lc", "ctrl", "gc", "tc", "vd", "da", "dm", "conn", "draw", "df", "nc", "ac", "dk", "desc"], "gen_code_end": ["gen_code67start", "gen_codes_end", "gen_codeprepend", "gen_codepreend", "gen_codes_pend", "gen_code_pend", "gen_codeenlength", "gen_code_END", "gen_code_max", "gen_call_end", "gen_code67offset", "gen_code67end", "gen_code_offset", "gen_codepreoffset", "gen_codeenmax", "gen_code_length", "gen_call_END", "gen_codes_offset", "gen_call_start", "gen_code67pend", "gen_codeenstart", "gen_codeenend", "gen_code_start", "gen_codeprestart", "gen_codes_start"], "pc_ptr": ["PC_start", "dc_end", "fc_pad", "fc_end", "pc_addr", "PC_pointer", "pc67pointer", "bc_ref", "fc_tip", "fc_ptr", "PC_enter", "dc_ptr", "dc_size", "bc_pointer", "PC_ptr", "fc_offset", "bc_pad", "pc_enter", "pc_desc", "pc_code", "pc_end", "pc_size", "fc_pointer", "dc_pointer", "pc_ref", "pc_offset", "fc_desc", "pc67ref", "pc_pointer", "pc67ptr", "pc67pad", "fc_code", "bc_ptr", "dc_addr", "pc_tip", "pc_pad"], "ret": ["ref", "code", "fin", "obj", "ft", "res", " RET", "flag", "red", "job", "back", "data", "buffer", "no", "success", "bf", "ct", "att", " Ret", "rep", "num", "xt", "id", "rets", "al", "rl", "eth", "mt", "det", "rev", "lit", "bit", "repl", "RET", "last", "re", "nt", "lag", "reply", "bot", "let", "rc", "pat", "ry", "arg", "Ret", "rt", "gc", "ext", "status", "part", "comment", "reg", "alt", "desc", "match", "r", "result", "len", "val", "fun"], "disasm_info": ["disam_now", "dispackaminformation", "disast_offset", "disasm_conf", "disassembly_info", "disasmaminformation", "disassembly_state", "disam_inf", "dispackaminf", "disassembly_spec", "dispack_inf", "disast_error", "disasmamalias", "disjam_conf", "disasmaminf", "disasm_help", "disasm_Info", "disasmCinfo", "disjam_info", "disast2info", "dispack_alias", "disjam_id", "disam_info", "disasmamoffset", "disjam_Info", "disam_error", "dispack_info", "disasm_information", "disast2help", "disasmamhelp", "disasm_id", "dispackaminfo", "disasmCstate", "disasm_offset", "dispack_information", "disast_help", "disast2offset", "disasmaminfo", "disasm_state", "disasm2error", "disasm_now", "disasm_spec", "disasmCspec", "disasm_alias", "disast2error", "disasm_inf", "disasm2offset", "disasm_error", "disasmamerror", "disasm2help", "dispackamalias", "disast_info", "disasm2info"], "pc": ["sc", "sys", "uc", "anc", "toc", "c", "enc", "xc", "pointer", "PC", "bc", "mac", "proc", "fc", "con", "amp", "td", "pb", "cpu", "cc", "mc", "rc", "lc", "tc", "arc", "nc", "ac", "pid"], "count": ["ref", "seq", "code", "call", "found", "toc", "c", "base", "col", "cb", "counter", "type", "id", "num", "proc", "depth", "con", "offset", "Count", "nt", "parent", "cc", "cache", "length", "total", "child", "func", "len"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328, "substitutes": {"qiv": ["qerv", "qaih", "qistor", "questiv", "qterv", "qaiva", "quih", "questerv", "questivist", "qtiv", "quiv", "reqiver", "reqiv", "reqivable", "qivist", "qaistor", "qtivist", "qiver", "questiver", "quivable", "querv", "qih", "questih", "questiva", "qaiv", "quistor", "questistor", "qiva", "qtiver", "quiva", "reqivist", "qtivable", "quiver", "quivist", "qivable"], "name": ["call", "param", "none", "image", "ix", "time", "x", "data", "base", "var", "on", "am", "type", "prefix", "property", "pass", "ame", "id", "alias", "self", "Name", "key", "old", "create", "path", "start", "search", "object", "parent", "word", "change", "new", "size", "part", "comment", "NAME", "ext", "value", "n", "named", "names", "attr", "large"], "errp": ["errpc", "erP", "asterr", "rrpre", "errsp", "rrP", " ersp", " errsp", " errr", "rrp", "errpre", "asterp", "errcp", "rrcp", "erpc", "rrr", " errP", "rrpc", "err", "ercp", "errr", " erp", "erpre", " err", " errpr", " errpc", "astersp", "asterpr", "erp", " errcp", "errP", " errpre", " erpr", "errpr"], "qobj": ["quobj", "qbo", "quobject", "qbr", "querybo", "wpos", "queryobj", "cobj", "cobject", "kobject", "qcode", "qustr", "kbr", "pobj", "wstr", "cbo", "kbo", "wobj", "queryobject", "pobject", "kstr", "wbr", "qpos", "querystr", "qubo", "cstr", "wbo", "pcode", "qubr", "querypos", "pstr", "eqcode", "qucode", "eqobj", "wobject", "qupos", "eqstr", "kobj", "qobject", "eqobject"], "qstr": [" qname", "qustring", " qbytes", "sqint", "eqhr", "questarr", "qsl", "dqstr", "qusl", " qint", "qpass", "qint", "qtr", "eqinst", " qsl", "qustr", "quarr", "questsl", "quhr", "dqpass", "quname", "qutr", "sqstr", "qubytes", " qarr", "qinst", " qtr", "qname", "qbytes", "questname", "quinst", "qupass", "qhr", " qhr", "quint", "queststring", "sqbytes", "queststr", "qarr", "dqhr", "eqpass", "questhr", "eqstr", "dqinst", "sqtr", " qstring", "qstring"]}}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331, "substitutes": {"obj": ["node", "ock", "oc", "objects", "pt", "ob", "enc", "data", "Object", "orb", "pointer", "jp", "cb", "opt", "so", "io", "self", "bj", "buf", "o", "obb", "arr", "tmp", "object", "nt", "os", "ctx", "parent", "sb", "cn", "Obj", "po", "j", "src", "conn", "init", "ex", "org", "ops", "pos"], "ioc": ["ptoc", "giocl", "itocl", "riocl", "iooco", "itroc", " iirc", "iocl", "iOC", "xioc", "ioco", " iocl", "xiroc", "riirc", " iroc", "rioc", " iob", "ioca", "poc", "gioco", "proc", "iiroc", "iiOC", "ioocl", "iob", "dioca", "diroc", "piob", "xioco", "gioc", "itirc", "gioca", "iioc", "dioc", "pOC", "itoc", "iooc", "iirc", " iOC", "ioroc", "rioca", "xiob", "diocl", "riroc", "piocl", "pioc", "iitoc", "piroc", "xiocl", "giroc", "iroc", " itoc"]}}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351, "substitutes": {"mount_point": ["mountingpointer", "mount00pointer", "mount_center", "match_points", "mount24center", "download_point", "downloadpleline", "mountEndpointer", "mountingpoint", "mount_points", "mount_path", "mount00point", " mount_patch", " mount_pointer", "mountvepointer", "mount_patch", "mountvesize", "mount_line", "mount00points", "mountpleline", "mountingpoints", "mount00patch", "download_location", "mount24location", "mount24point", "mountplecenter", "mount_pointer", "downloadplepoint", "mount_size", "downloadplecenter", "mountvepath", " mount_size", "download_center", "match_pointer", " mount_path", "mountEndpoints", "download_line", "mountingpath", "mountplelocation", "mountEndpoint", "mountplepoint", "downloadplelocation", "match_path", " mount_points", "mount_location", "mountEndpath", "match_point", "mount24line", "mountvepoint"], "path": ["temp", "code", "user", "p", "close", "c", "name", "context", "image", "mount", "time", "enc", "test", "trace", "text", "config", "pointer", "type", "bug", "error", "port", "platform", "url", "method", "key", "point", "open", "patch", "home", "rh", "dir", "progress", "process", "pattern", "object", "ath", "clean", "wd", "parent", "cp", "thin", "size", "cache", "level", "PATH", "stream", "entry", "conn", "runner", "match", "dest", "root", "Path", "walk", "file", "lock"], "debugfs_found": ["debugf_found", "debugfsalllen", "debugfs_mounted", "debugFS_Found", "debugFS_found", "debugf_Found", "debugf_len", "debugFS_find", "debugfsallfound", "debugfs_Found", "debugf_mounted", "debugfs_find", "debugf_err", "debugfsallFound", "debugFS_err", "debugfs_err", "debugfs_len"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A1 = 0xffff<<14, A2= 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A1 = 0xffff<<14, A2 = 0xffff<<14;\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24356, "substitutes": {"ubuf0": ["ubuf6", "ubbuff0", "ubbuf0", "ubbuff6", "abuf6", "ubf8", "ubf2", "abuf2", "ubbuff8", "abufk", "ubf1", "ubufk", "ubbuffk", "abbufk", "abbuf8", "ubbufk", "abuf1", "ubuffer1", "ubbuff2", "ubuf2", "ubuffer6", "ubuf8", "abbuf2", "ubbuff1", "ubf0", "ubbuf2", "ubufferk", "ubuffer0", "ubbuf1", "ubbuf6", "abbuf6", "abuf0", "ubbuf8", "abbuf0", "abuf8", "abbuf1"], "vbuf0": ["fbufk", "Vbuff50", "fbuff0", "fbuffk", "vbuffer2", "vcv50", "fbuf2", "vbufferk", "Vbuff2", "Vbuff0", "vbufk", "vbuffk", "vbuffer0", "Vbuf50", "vbuff0", "vufk", "vuf0", "Vbuf0", "vbuff1", "vbuf2", "vbuf50", "vcv0", "vbuff2", "Vbuf2", "vbuff50", "fbuf0", "fbuf1", "vuf1", "fbuff2", "fbuff1", "vuf2", "vbuffer1", "vcv2"], "i": ["my", "slice", "ie", "b", "m", "p", "c", "info", "page", "yi", "d", "image", "ix", "x", "me", "api", "ti", "mi", "phi", "qi", "it", "ri", "io", "id", "ui", "u", "is", "e", "li", "gi", "o", "zi", "multi", "xi", "uri", "inner", "bi", "ii", "si", "ai", "ini", "ni", "di", "cli", "ci", "fi", "eni", "part", "I", "y", "chi", "mini", "n", "j", "ip", "oi", "f", "index", "v", "iu", "mu", "pi", "l", "hi"], "R": ["S", "L", "Q", "NR", "C", "K", "P", "H", "A", "UR", "X", "RA", "ER", "GR", "U", "M", "D", "Y", "N", "I", "W", "RC", "V", "RR", "E", "Re", "RP", "J", "r", "O", "DR", "F"], "G": ["S", "AG", "L", "Q", "C", "P", "Ge", "H", "A", "X", "GR", "U", "M", "Gs", "D", "Gr", "Y", "Gu", "GB", "MG", "F", "GH", "N", "I", "W", "V", "E", "J", "O", "GN", "LG", "g"], "B": ["OB", "L", "Q", "HB", "DB", "FB", "IB", "b", "C", "P", "T", "A", "BS", "EB", "PB", "U", "LB", "BL", "Bs", "M", "D", "Bi", "Y", "NB", "WB", "GB", "BO", "N", "I", "AB", "W", "MB", "V", "J", "O", "Ub", "UB"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364, "substitutes": {"v": ["ve", "gu", "k", "w", "i", "p", "m", "b", "c", "cv", "inv", "vs", "vis", "vt", "ev", "tv", "vv", "u", "self", "e", "o", "vc", "vim", "client", "view", "iv", "vm", "conv", "h", "uv", "vic", "f", "lv", "GV", "value", "j", "V", "t", "vp", "l", "sv", "val", "g"], "obj": ["ref", "node", "code", "args", "class", "b", "objects", "adj", "ob", "data", "api", "Object", "base", "fn", "py", "cb", "type", "prefix", "inst", "self", "o", "arr", "object", "ctx", "emb", "oa", "Obj", "po", "js", "value", "j", "src", "func", "attr", "val"], "name": ["code", "nm", "info", "sn", "anc", "time", "data", "base", "label", "member", "type", "prefix", "error", "id", "alias", "self", "Name", "key", "o", "path", "inner", "object", "ni", "parent", "word", "new", "size", "nice", "part", "comment", "NAME", "named", "n", "names", "nam", "attr", "len", "desc"], "errp": ["incpi", "erP", "derP", "ferP", "derlp", "ferpi", "erpi", "derc", " errr", "acerP", "erpa", "acerr", "incpa", "err", " errP", "errpi", "errlp", "errr", "acerlp", "acerp", "erp", "errpa", "errP", "erlp", " errc", "derp", "errc", "incP", "ferp", " errlp", "erc", "ferpa", "incp"]}}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_mid_8w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3;\n\n    v16u8 out0, out1;\n\n\n\n    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    hz_out0 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n    hz_out1 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n    hz_out3 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n\n\n        hz_out5 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n        hz_out6 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n        hz_out7 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n        hz_out8 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst1 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst3 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n        out0 = PCKEV_XORI128_UB(dst0, dst1);\n\n        out1 = PCKEV_XORI128_UB(dst2, dst3);\n\n        ST8x4_UB(out0, out1, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out3 = hz_out7;\n\n        hz_out1 = hz_out5;\n\n        hz_out5 = hz_out4;\n\n        hz_out4 = hz_out8;\n\n        hz_out2 = hz_out6;\n\n        hz_out0 = hz_out5;\n\n    }\n\n}\n", "idx": 24368, "substitutes": {"src": ["seq", "sc", "rs", "low", "slice", "sr", "rib", "uc", "img", "rb", "sq", "cur", "config", "gb", "filename", "cb", "inst", "sync", "url", "cont", "rob", "fc", "sur", "scl", "gn", "tmp", "loc", "sub", "lib", "st", "sel", "ctx", "sb", "ctr", "rc", "sec", "iv", "sup", "dist", "comp", "rect", "source", "stream", "sil", "RC", "bg", "dest", "sl", "ssl", "desc"], "src_stride": ["src_striride", "src_Strided", "src_arrided", "src_Strride", "src_striider", "src_arride", "src_brides", "src_strride", "src_strider", "src_Strides", "src_STRide", "src_drider", "src_brider", "src_STRides", "src_drided", "src_striide", "src_drides", "src_dride", "src_bride", "src_striided", "src_striides", "src_arrider", "src_STRided", "src_strides", "src_brride", "src_arrride", "src_brided", "src_STRride", "src_Stride", "src_strided"], "dst": ["ddest", "sdest", "Ddest", "ssts", "Dsts", "sst", "bst", "bdest", "dsts", "bsp", "Dsp", "bsts", "Dst", "dsp", "ssp"], "dst_stride": ["dst64arrided", "dst64strided", "dst64strid", "dst64stride", "dst_brid", "dst_arrided", "dst_arrride", "dst_brided", "dst_tride", "dst64arrid", "dst_strid", "dst_bride", "dst_trid", "dst_trided", "dst_strided", "dst_arrid", "dst_arride", "dst_strride", "dst64strride", "dst_trride", "dst64arrride", "dst64arride", "dst_brride"], "height": ["build", "gap", "th", "dc", "lvl", "dim", "dy", "resolution", "hd", "data", "buffer", "img", "style", "diff", "deep", "mac", "id", "high", "gpu", "depth", "padding", "rh", "input", "density", "thin", "shape", "level", "length", "gh", "timeout", "h", "window", "count", "y", "bottom", "index", "Height", "block", "top"], "loop_cnt": ["loop_fnt", "loop_count", "loop_rcnc", "loop_lcNT", "loop_rcnt", "loop_ncNT", "loop_acNT", "loop_acnd", "loop_cnd", "loop_lcount", "loop_lcnd", "loop_ncnt", "loop_lcnt", "loop_ncount", "loop_Cnt", "loop_rcnd", "loop_acnc", "loop_Cnc", "loop_lcnn", "loop_Cnd", "loop_fnd", "loop_lcnc", "loop_CNT", "loop_cnn", "loop_fnc", "loop_acount", "loop_Count", "loop_rcNT", "loop_ncnn", "loop_fount", "loop_cnc", "loop_acnt", "loop_Cnn", "loop_cNT"], "src0": ["source1", "dist1", "source4", "img6", "loc3", "dist00", "src6", "rc3", "loc2", " src00", "rc6", "dest4", " src6", "img1", "loc1", "rc5", "dist5", "loc6", "source0", "dest0", "dist2", "source2", "dist4", "loc0", "dest1", "rc1", "rc0", "img0", "rc2", " src5", "loc4", "dest2", "dist0", "rc00", "src5", "img2", "src00", "rc4"], "src1": ["source1", "source4", "sc2", "loc2", "rc3", "img1", "loc1", "sc3", " src8", "sc4", "source0", "source01", "source2", "loc01", "img8", " src01", "loc0", "rc1", "rc0", "sc0", "img01", "rc2", "src01", "loc4", "rc8", "img2", "sc1", "rc01", "src8", "loc3", "rc4"], "src2": ["rc3", "loc2", "dest4", "loc1", "rc5", "dist5", " src8", "dist2", "dist3", "loc0", "rc1", "rc0", "dest8", "rc2", " src5", "dest3", "loc4", "rc8", "dest2", "dist0", "src5", "src8", "loc3", "rc4"], "src3": ["source1", "dist1", "source4", "src03", "src6", "dist03", "rc3", "loc2", "loc03", "source5", "rc6", "loc1", " src6", "rc5", "source3", "rc03", "dist3", "source2", "dist6", "source6", "rc1", " src03", "rc2", " src5", "source03", "src5", "loc3", "rc4"], "src4": ["source1", "dist1", "source4", "seq4", "rc3", "source5", "img1", "seq14", "rc5", "dist5", "seq24", "source3", "img14", "dist2", "source2", "dist4", "rc1", "src24", "rc40", "src14", "rc2", " src5", "img4", "rc24", "img24", "img40", "seq2", "src40", " src40", "src5", "img2", "rc4", "rc14"], "mask0": ["Mask4", " maskg", " mask4", "Mask50", "mask90", "mask4", "black2", "Mask0", " mask8", "pay0", " mask50", "pay1", "maski", "ask4", "black1", "aski", "mark1", " maski", "ask0", "askg", " mask000", "black0", "mask8", "mass1", "maskg", "pay2", "ask000", "ask1", "mark0", "mass90", "pay000", "mark2", "mask50", "black000", "ask8", "massi", "ask50", "mask000", "blackg", "ask2", "ask90", "mass0", "Mask1", " mask90", "mark8"], "mask1": ["Mask4", " mask4", "mask4", "weight2", "mark4", "weight3", "weight4", "Mask0", " mask8", "ask3", "ask4", "mark1", "ask0", "weight0", "mask8", "mask3", "ask1", "weight1", "mark0", "Mask2", "mark2", "ask8", " mask3", "ask2", "Mask1", "mark8"], "mask2": [" maskless", "mark3", "miss0", " mask4", "mask4", "weight2", "mark4", "weight3", "weight4", " mask6", " mask8", "mask6", "ask3", "ask4", "ask6", "weightless", "mark1", "ask0", "maskless", "weight8", "mask8", "mask3", "weight6", "weight1", "ask1", "miss3", "mark2", "ask8", "miss6", " mask3", "miss4", "ask2", "askless", "miss8", "miss2"], "hz_out0": ["hz_in6", "hz_mask1", "hz_opt0", "hz_opt6", "hz_opt1", "hz_in2", "hz_mask2", "hz_in0", "hz_mask4", "hz_mask0", "hz_opt4", "hz_mask6", "hz_in1", "hz_in4"], "hz_out1": ["hz_out11", "hz_index11", "hz_Out2", "hz_Out3", "hz_indexOne", "hz_Out1", "hz_in11", "hz_OUT2", "hz_OUT3", "hz_index1", "hz_outOne", "hz_in2", "hz_in3", "hz_inOne", "hz_index2", "hz_OUT1", "hz_in1"], "hz_out2": ["hz_Out2", "hz_nin8", "hz_conn2", "hz_in6", "hz_nin1", "hz_int8", "hz_int2", "hz_Out1", "hz_int6", "hz_conn6", "hz_int1", "hz_in2", "hz_nin6", "hz_in8", "hz_Out6", "hz_conn1", "hz_nin2", "hz_conn4", "hz_Out4", "hz_in1", "hz_in4"], "hz_out3": ["hz_Out2", "hz_nin8", "hz_Out3", "hz_off0", "hz_nin0", "hz_off03", "hz_off1", "hz_Out03", "hz_Out1", "hz_out03", "hz_in2", "hz_in8", "hz_nin3", "hz_in0", "hz_in3", "hz_off2", "hz_off3", "hz_in03", "hz_nin2", "hz_off8", "hz_in1"], "hz_out4": ["hz_sum4", "hz_infour", "hz_sum7", "hz_match7", "hz_loss4", "hz_outfour", "hz_sum5", "hz_in2", "hz_in4", "hz_loss2", "hz_in5", "hz_again4", "hz_matchfour", "hz_loss7", "hz_again2", "hz_match4", "hz_in7", "hz_match2", "hz_again5", "hz_sum2", "hz_again7", "hz_lossfour"], "hz_out5": ["hz_outFive", "hz_passFive", "hz_pass8", "hz_pass5", "hz_in2", "hz_in8", "hz_in5", "hz_off2", "hz_offFive", "hz_off5", "hz_off8", "hz_pass2", "hz_inFive"], "hz_out6": ["hz_scan2", "hz_scanN", "hz_in6", "hz_name2", "hz_in256", "hz_inN", "hz_scan256", "hz_in2", "hz_outN", "hz_name6", "hz_out256", "hz_nameN", "hz_name256", "hz_scan6"], "hz_out7": ["hz_nin07", "hz_nin87", "hz_nin7", "hz_ex07", "hz_ex87", "hz_Out9", "hz_nin9", "hz_Out87", "hz_ex7", "hz_Out07", "hz_out07", "hz_out87", "hz_out9", "hz_Out7", "hz_ex9"], "hz_out8": ["hz_again8", "hz_index5", "hz_output8", "hz_index8", "hz_index4", "hz_output5", "hz_again6", "hz_index6", "hz_again4", "hz_output6", "hz_output4", "hz_again5"], "dst0": ["dsta1", "dsc3", "dsta2", "dsc0", "sst3", "dest0", "dsta3", "ssc2", "dsc2", "ssc0", "dest1", "dest3", "sst2", "sst0", "dest2", "dsta0", "sst1", "dsc1", "ssc1", "ssc3"], "dst1": ["dsp1", "dost2", " dst4", "dsp4", "dest4", "dsp0", "dest0", "dst4", " dest4", "dest1", " dest2", "dsp2", "dost4", "dost0", " dest1", "dest2", " dest0", "dost1"], "dst2": ["drc2", "drc1", "dest4", "adrc2", "adrc0", "dsc0", "dest0", "adst1", "dst4", "adst2", "dsc2", "dest1", "adst4", "drc0", "adst0", "adrc4", "dsc4", "dest2", "adrc1", "drc4", "dsc1"], "dst3": ["fst5", "drc1", "dsc3", "dstage1", "drc6", "dst6", "frc1", "fst6", "frc6", "frc3", "dstage3", "drc5", "fst3", "dstage5", "dst5", "dstage6", "dsc6", "drc3", "frc5", "dsc5", "fst1", "dsc1"], "out0": ["in0", "in1", "Out2", " out2", "Out0", "in2", "Out1", "out2"], "out1": ["Out4", " outOne", "OutOne", "out4", "Out2", " out2", "OUT2", "OUT1", "OUTOne", "outOne", "OUT4", "Out1", " out4", "out2"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pam_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 24371, "substitutes": {"avctx": ["averctx", "averconfig", "afsync", "aversync", " avsync", "avalcf", "afctrl", "avcontext", "avalcontext", "avalctrl", "avsync", "avercontext", "AVcf", "afcf", "afcontext", "afctx", "avconfig", "avalctx", "AVctrl", "avctrl", "AVctx", " avcontext", " avconfig", "AVcontext", "avcf", "afconfig"]}}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)\n\n{\n\n    OggVorbisContext *context = avccontext->priv_data;\n\n    double cfreq;\n\n\n\n    if (avccontext->flags & CODEC_FLAG_QSCALE) {\n\n        /* variable bitrate */\n\n        if (vorbis_encode_setup_vbr(vi, avccontext->channels,\n\n                                    avccontext->sample_rate,\n\n                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))\n\n            return -1;\n\n    } else {\n\n        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;\n\n        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;\n\n\n\n        /* constant bitrate */\n\n        if (vorbis_encode_setup_managed(vi, avccontext->channels,\n\n                                        avccontext->sample_rate, minrate,\n\n                                        avccontext->bit_rate, maxrate))\n\n            return -1;\n\n\n\n        /* variable bitrate by estimate, disable slow rate management */\n\n        if (minrate == -1 && maxrate == -1)\n\n            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))\n\n                return -1;\n\n    }\n\n\n\n    /* cutoff frequency */\n\n    if (avccontext->cutoff > 0) {\n\n        cfreq = avccontext->cutoff / 1000.0;\n\n        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))\n\n            return -1;\n\n    }\n\n\n\n    if (context->iblock) {\n\n        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);\n\n    }\n\n\n\n    return vorbis_encode_setup_init(vi);\n\n}\n", "idx": 24375, "substitutes": {"vi": ["ati", "oci", "ski", "i", "isi", "adi", "vision", "mi", "vt", "edi", "qi", "ri", "ani", "audi", "liv", "iri", "ji", "li", "vid", "zi", "vc", "xi", "ii", "ini", "si", "ai", "bi", "ni", "cli", "di", "avi", "ci", "VI", "fi", "ku", "eni", "rc", "iv", "vm", "iti", "ki", "umi", "ori", "v", "medi", "pi", "ui", "vim", "voc", "ami", "ili"], "avccontext": ["avconstruct", "avccorstruct", "avbecontext", "avconect", "avccontTEXT", "avccONect", "avbcontext", "avcconyst", "avcconstex", "avcentext", "avcconevert", "avccaroncil", "avaccondter", "avaccondconnection", "avacconter", "avrconconnection", "avccondstr", "avccynnect", "avdconobject", "avccorcil", "avccontvert", "avcconconfig", "avcconact", "avcconcontext", "avdcorobject", "avccanonnect", "avccontex", "avccONter", "avccaconct", "avaccondtext", "avcontext", "avrcopytext", "avaccondstruct", "avsconstatic", "avccopytext", "avcconversion", "avccentext", "avccONconnection", "avccyntext", "avctanonte", "avcONTEXT", "avcconstr", "avscontext", "avctonte", "avccompversion", "aveconterm", "avccONcil", "avccondstruct", "avbconatext", "avacconvert", "avccortext", "avcenstruct", "aveconconfig", "avdcorcil", "avcONtex", "avccaronobject", "avccopyst", "avccONobject", "avccopTEXT", "avccenstruct", "avcconpath", "avccONner", "avnconct", "avncaconcontext", "avconTEXT", "avcontex", "avccaompstruct", "avcchentext", "avctanontext", "avcconastruct", "avcconttext", "avcconterm", "avccONtext", "avcconect", "avrconcontract", "avccopyversion", "avbeconversion", "avrconnect", "avctontext", "avcconste", "avcconter", "avcONvert", "avccaontext", "avncacontext", "avconpath", "avcenvert", "avccompst", "avccorobject", "avdcortext", "avccacontext", "avccoconect", "avacconstruct", "avdcorstruct", "avccynstatic", "avcconTEXT", "avccompstruct", "avccONconfig", "avccynconfig", "avcONnect", "avcconerect", "avcconcil", "avcconte", "avcconente", "avccaonversion", "avaccopTEXT", "aveconect", "avccolontext", "avbeconastr", "avcconstruct", "avsconsst", "avcconsvert", "avrcontext", "avcconetext", "avccONvert", "avccaconcontext", "avncaconcontract", "avccoptext", "avbconastruct", "avccopvert", "avbconstruct", "avcconenconnection", "avcconst", "avccaronstruct", "avccaonstruct", "avccopynect", "avccolonstruct", "avdconstruct", "avbeconatext", "avbeconstr", "avccarontext", "avcconacil", "avccanonstruct", "avbconacil", "avccyncontract", "avaccopvert", "avconnect", "avccONterm", "avcconerconfig", "avcconner", "avccettext", "avcconenstruct", "avecONect", "avcconerterm", "avccolonvert", "avccorestruct", "avcconvert", "avcconsstatic", "avecontext", "avcconenter", "avccONstruct", "avcconstatic", "avcconertext", "avccondter", "avecONtext", "avcconestruct", "avdcontext", "avccONnect", "avcconastr", "avbeconct", "avcconsstruct", "avcconytext", "avccanonTEXT", "avbconcil", "avccoinstr", "avcchencontract", "avcconcontract", "avccomptext", "avcconaner", "avccynst", "avcconyvert", "avrcopycontract", "avnconcontract", "avccaconect", "avccoconvert", "avccONversion", "avrcopyconnection", "avccopyconnection", "avccoconcil", "avccetconnection", "avecONterm", "avccanonvert", "avcONect", "avcconaversion", "avccoretext", "avcchenct", "avcconsst", "avecONconfig", "avdconcil", "avccenTEXT", "avcconnect", "avccenpath", "avccaonst", "avccoinversion", "avctanonnect", "avsconst", "avccopycontract", "avcconepath", "avcconennect", "avaccontex", "avccenvert", "avccondconnection", "avnconcontext", "avsconsvert", "avccoconner", "avccanontext", "avccoinct", "avcconentext", "avsconvert", "avcconttex", "avbconner", "avctanonvert", "avccaconcontract", "avccolonpath", "avccointext", "avcconenvert", "avccondtext", "avcconystatic", "avccopystruct", "avctonnect", "avcconsct", "avbeconact", "avsconsstatic", "avccONtex", "avccynvert", "avccoptex", "avccaconstruct", "avctonvert", "avccaompversion", "avccynect", "avccoconstruct", "avccorenect", "avcconscontract", "avsconstext", "avcconconnection", "avcchencontext", "avrcopynect", "avccynterm", "avccaconvert", "avconvert", "avcONtext", "avcenpath", "avbeconaversion", "avcconct", "avncaconct", "avccetnect", "avcconsnect", "avccONst", "avcconobject", "avccynconnection", "avaccoptex", "avccoretex", "avaccoptext", "avccaompst", "avccONTEXT", "avcconstext", "avccaomptext", "avacconTEXT", "avccanonte", "avccocontext", "avccondct", "avccondversion", "avccentex", "avcconscontext", "avccetcontract", "avcconatext", "avncontext", "avaccontext", "avcONstruct", "avbconaner", "avacconconnection"], "context": ["temp", "package", "kernel", "slice", "public", "cca", "info", "definition", "document", "anc", "engine", "driver", "function", "filter", "qa", "buffer", "data", "text", "config", "component", "interface", "support", "center", "reader", "concept", "general", "environment", "private", "project", "contact", "resource", "input", "path", "command", "cel", "loc", "object", "Context", "parent", "ctx", "mc", "cache", "current", "stream", "source", "event", "result", "tx", "connection"], "cfreq": ["afneed", "ctrequ", "CFrt", " cfload", "afrequ", " cferr", "cferr", "ctrequest", "ctreq", "cfload", "cfrequ", "afrequest", " covload", "CFrequest", "CFreq", "cfneed", "cfrequest", "casrequest", "afrt", "CFload", " covreq", "ctrt", " cfrequ", "CFerr", "CFrequ", " coverr", "afreq", "casneed", " covrequ", "casrequ", "CFneed", "casreq", "cfrt"]}}
{"project": "FFmpeg", "commit_id": "439c3d5bcc4a4560eaf5fd43c6e156e3d9bc42f2", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                        const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    NellyMoserEncodeContext *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n\n\n    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));\n\n    if (frame) {\n\n        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],\n\n               frame->nb_samples * sizeof(*s->buf));\n\n        if (frame->nb_samples < NELLY_SAMPLES) {\n\n            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,\n\n                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));\n\n            if (frame->nb_samples >= NELLY_BUF_LEN)\n\n                s->last_frame = 1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))\n\n            return ret;\n\n    } else {\n\n        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));\n\n        s->last_frame = 1;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n    encode_block(s, avpkt->data, avpkt->size);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 24400, "substitutes": {"avctx": ["afctl", "apcontext", "ufconfig", "afcmd", " avcm", "AVconfig", "AVcontext", " avcn", "awctl", "avcmp", "afkb", "AVcn", "awcontext", "apctx", "awctx", "avcontext", "avkb", " avcmp", "afcn", " avctl", "afcontext", "afctx", "avconfig", "avctl", "ufcmd", "avcm", " avcmd", "avcn", " avkb", "apconfig", "ufctx", "awkb", "apcmp", "afcm", "AVctx", "ufcontext", " avcontext", "AVctl", "ufcm", "avcmd", " avconfig", "afcmp", "afconfig", "ufctl"], "avpkt": ["avfck", "avPacket", "avcft", "avppacket", "afcqt", "afpqt", "abpetsk", "avpreelt", "avpreacket", "afput", "avvpkt", "avcqt", "AVPke", "avppkt", "avput", "avcpnt", "avfkt", "avprekt", "avcpqt", "avpnt", "avnelt", "AVpqt", "afckt", "AVPacket", "avpqt", "avjpdt", "appdt", "avpredt", "appelt", "afpacket", "avpetsk", "avvpnt", "afcck", "avfdt", "avfft", "avfet", "abfacket", "abfetsk", "affut", "avfut", "avpck", "AVpkt", "avpreck", "avPkt", "avPqt", "appacket", "avjpacket", "avppqt", "affacket", "abpkt", "avcdt", "avcelt", "affnt", "afpck", "afpdt", "avPet", "avfnt", "avcpacket", "avndt", "avjpkt", "afpnt", "avfetsk", "avpft", "avPetsk", "avcacket", "avcck", "avjpft", "avfacket", "apcdt", "afpkt", "avcpke", "affft", "affdt", "avvput", "AVpacket", "afcacket", "abfet", "apcacket", "avnkt", "avfqt", "AVPqt", "avnacket", "avcput", "appkt", "avpke", "avPke", "AVPkt", "avnpetsk", "affkt", "abfkt", "abpet", "avpreqt", "abpacket", "avpelt", "AVpke", "avcpkt", "avnpkt", "apcelt", "avpacket", "afpft", "avpet", "apckt", "avnpet", "avpdt", "avnpacket", "avppke", "avckt", "avvpacket"], "frame": ["fram", "node", "seq", "code", "element", "call", "fe", "slice", "body", "none", "close", "m", "dy", "position", "image", "function", "se", "time", "frames", "buffer", "data", "callback", "module", "style", "request", "up", "feature", "cb", "za", "state", "flow", "motion", "fr", "range", "line", "e", "el", "pse", "rame", "session", "object", "sample", "sequence", "fi", "setup", "fb", "video", "cf", "series", "fake", "game", "scale", "feat", "zip", "layer", "iframe", "update", "window", "f", "part", "j", "Frame", "header", "event", "block", "document", "ce", "file", "ze"], "got_packet_ptr": ["got_packacket_addr", "got_packet_tr", "got_packacket_pointer", "got_packacket_str", "got_packet_str", "got_packet2ptr", "got_packacket_ptr", "got_packet_addr", "got_packacket_tr", "got_packet_pointer", "got_packet2pointer", "got_packet2str", "got_packet2addr"], "s": ["sys", "w", "ns", "ts", "vs", "sq", "ps", "states", "sync", "self", "u", "es", "gs", "http", "sym", "xs", "f", "service", "js", "n", "fs", "qs", "t", "j", "r", "S", "sk", "k", "p", "b", "m", "c", "se", "ds", "us", "ins", "su", "is", "spec", "aws", "services", "h", "its", "g", "side", "rs", "ses", "args", "ss", "bis", "d", "ms", "conf", "sg", "ks", "e", "session", "stat", "sb", "your", "full", "ssl", "cs", "sc", "site", "o", "si", "os", "ctx", "sup", "as", "ls", "y", "a", "an", "parts", "l"], "ret": ["ref", "code", "fin", "obj", "ft", "res", "info", "usr", " RET", "cat", "flag", "red", "back", "cur", "success", "en", "no", "att", "bc", " Ret", "def", "error", "rep", "num", "id", "db", "rets", "mem", "valid", "bit", "mt", "det", "lit", "RET", "fit", "re", "run", "last", "nt", "reply", "rc", "bot", "let", "feat", "pat", "bad", "arg", "Ret", "rt", "part", "reset", "value", "alt", "reg", "resp", "match", "r", "result", "len", "val", "gt", "ut", "fun"]}}
{"project": "FFmpeg", "commit_id": "7167bc94cb695a3027aea6aac34a1b040848c7dc", "target": 1, "func": "static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n\n{\n\n    IndividualChannelStream *ics = &sce->ics;\n\n    float *in    = sce->coeffs;\n\n    float *out   = sce->ret;\n\n    float *saved = sce->saved;\n\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    float *buf  = ac->buf_mdct;\n\n    float *temp = ac->temp;\n\n    int i;\n\n\n\n    // imdct\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)\n\n            av_log(ac->avctx, AV_LOG_WARNING,\n\n                   \"Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. \"\n\n                   \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\");\n\n        for (i = 0; i < 1024; i += 128)\n\n            ff_imdct_half(&ac->mdct_small, buf + i, in + i);\n\n    } else\n\n        ff_imdct_half(&ac->mdct, buf, in);\n\n\n\n    /* window overlapping\n\n     * NOTE: To simplify the overlapping code, all 'meaningless' short to long\n\n     * and long to short transitions are considered to be short to short\n\n     * transitions. This leaves just two cases (long to long and short to short)\n\n     * with a little special sauce for EIGHT_SHORT_SEQUENCE.\n\n     */\n\n    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&\n\n            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {\n\n        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n\n    } else {\n\n        for (i = 0; i < 448; i++)\n\n            out[i] = saved[i] + bias;\n\n\n\n        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n\n        } else {\n\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n\n            for (i = 576; i < 1024; i++)\n\n                out[i] = buf[i-512] + bias;\n\n        }\n\n    }\n\n\n\n    // buffer update\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        for (i = 0; i < 64; i++)\n\n            saved[i] = temp[64 + i] - bias;\n\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else { // LONG_STOP or ONLY_LONG\n\n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n\n    }\n\n}\n", "idx": 24424, "substitutes": {"ac": ["acc", "aic", "acl", "k", "rac", "dc", "uc", "oc", "auc", "anc", "c", "fac", "enc", "ec", "sac", "ad", "am", "cus", "ax", "bc", "act", "mac", "mic", "con", "AC", "ic", "vc", "http", "cc", "Ac", "jac", "mc", "roc", "pac", "as", "ack", "ca", "gc", "aut", "tc", "arc", "acs", "ace", "iac", "cs", "pc", "cam"], "sce": ["dscel", "ske", "Sces", "scle", "dsCE", "openske", "Sce", "Scle", "opensce", " sface", " sque", "scel", " sne", "dske", "sces", "Sne", " sse", "sface", "dsce", "openscel", "sque", "sCE", " sCE", "Sse", "psce", "Ske", "pske", " ske", " scle", "Sque", "sne", "SCE", "psCE", "pscel", "opensface", " scel", "sse", " sces"], "bias": ["Bases", " bases", "bai", " bius", " bake", "bake", "Bait", "base", " unbase", " base", "lbai", "bius", "fait", "lax", "fias", "lbias", "Bake", " bait", "bax", "bases", "Base", "bait", "fius", " bax", " unbases", "fake", " bai", "lai", "Bias", " unbias", " unbius", "lbax", "lias", "Bius"], "ics": ["exec", "ants", "sys", "ns", "ts", "ips", "inas", "acks", "sync", "self", "bs", "mic", "stats", "cms", "http", "ig", "IC", "nas", "xs", "ums", "ents", "fs", "qs", "osi", "ris", "pic", "aic", "ICS", "ec", "ins", "css", "s", "spec", "ik", "mc", "cache", "xml", "ex", "ico", "voc", "pc", "its", "rates", "rs", "args", "tis", "ats", "iris", "icks", "act", "abc", "icons", "ks", "uses", "fc", "fps", "nic", "wcs", "cats", "ras", "bits", "atts", "cs", "iss", "oc", "ix", "isc", "config", "cus", "bc", "cons", "ic", "icc", "wic", "ctx", "inc", "ls", "facts", "acs", "iac", "fits"], "in": ["login", "IN", "slice", "bin", "uc", "c", "image", "gin", "In", "x", "qa", "data", "buffer", "img", "config", "again", "ins", "pass", "rec", "orig", "into", "con", "min", "input", "str", "vin", "ul", "inner", "ini", "nin", "pin", "new", "ci", "inc", "inn", "isin", "win", "f", "source", "bits", "n", "index", "a", "init", "ints"], "out": ["exec", "call", "obj", "OUT", "bin", "batch", "image", "fn", "data", "buffer", "sum", "config", "again", "prefix", "Out", "outs", "pass", "sync", "op", "io", "wx", "o", "extra", "cmd", "str", "work", "err", "input", "at", "bit", "inner", "output", "pool", "copy", "parent", "new", "ret", "client", "inc", "cache", "arg", "buff", "window", "ext", "source", "child", "init", "ex", "result", "val"], "saved": ["paved", "psave", "unsaged", " saving", " sitched", "saving", "Sitched", "psaved", " saged", "Save", "pave", "saves", "sitched", "setsaves", "Saved", "served", "Saving", "unsave", "unsaving", "sorted", " save", "setsaved", "Saves", "setsave", "saged", "unsaves", "pserved", "save", "Served", "Sorted", "setsitched", "paving", " sorted", " saves", "setsorted", "psaves", "psaving", "setsaged", "perved", "unsaved", "setsaving"], "swindow": ["swillo", "swINDo", "swINDowed", "swillowed", "swinnowed", "swindowed", "swINDow", "Swindows", "swindows", "SwINDow", "SwINDows", "Swindowed", "swINDows", "swillows", "swinno", "SwINDo", "swindo", "swinnows", "swillow", "Swindo", "swinnow", "SwINDowed", "Swindow"], "lwindow_prev": ["lwindows_prev", "lview_prev", "lwindows_last", "lview_first", "lwindow1first", "lwindow_pre", "lwindow1orig", "lwindow_orig", "lwindow1upper", "lwindow_upper", "lwindows_cur", "lwindow1prev", "lwindow_last", "lwindow_cur", "lwindow_first", "lview_orig", "lview_upper", "lwindows_pre"], "swindow_prev": ["swindow_orig", "swindOW_pre", "swindow_last", "swindOW_last", "swindOW_prev", "swindow_pre", "swindOW_orig"], "buf": ["seq", "uf", "ru", "bag", "margin", "uc", "b", "auc", "batch", "wb", "gin", "cv", "bn", "data", "buffer", "vec", "queue", "text", "rb", "img", "br", "cur", "cb", "prefix", "bc", "port", "num", "bus", "aux", "home", "ff", "tmp", "input", "fw", "box", "output", "pool", "ctx", "result", "fb", "cf", "fi", "rc", "cache", "xff", "conv", "cas", "buff", "window", "fp", "block", "fd"], "temp": ["txt", "margin", "w", "pt", "keep", "c", "cv", "wave", "buffer", "Temp", "frac", "weight", "prefix", "opt", "wrap", "num", "tr", "iter", "tmp", "input", "flat", "output", "clean", "ctr", "local", "cache", "tem", "conv", "ptr", "stable", "current", "win", "buff", "timeout", "window", "tc", "alt", "dest", "wa", "table"], "i": ["z", "it", "io", "num", "u", "li", "start", "bi", "ini", "ai", "f", "n", "j", "chi", "ami", "slice", "k", "b", "p", "c", "x", "ti", "mi", "phi", "qi", "ri", "key", "iter", "di", "ci", "eni", "isin", "ki", "yi", "d", "uli", "adi", "e", "iw", "axis", "uri", "ii", "cli", "fi", "I", "init", "iu", "my", "info", "ix", "id", "gi", "ji", "o", "zi", "multi", "xi", "inner", "si", "ni", "y", "mini", "child", "oi", "ip", "index", "a", "v", "mu", "pi", "ui", "l", "hi"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->avg_pixels_tab[0][0] = avg_pixels16_axp;\n\n    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;\n\n    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;\n\n    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;\n\n    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->put_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_pixels_tab[1][1] = put_pixels_x2_axp;\n\n    c->put_pixels_tab[1][2] = put_pixels_y2_axp;\n\n    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;\n\n\n\n    c->avg_pixels_tab[1][0] = avg_pixels_axp;\n\n    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;\n\n    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;\n\n    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;\n\n    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;\n\n\n\n    c->clear_blocks = clear_blocks_axp;\n\n    }\n\n\n\n    /* amask clears all bits that correspond to present features.  */\n\n    if (amask(AMASK_MVI) == 0) {\n\n        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;\n\n        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;\n\n\n\n        if (!high_bit_depth)\n\n            c->get_pixels   = get_pixels_mvi;\n\n        c->diff_pixels      = diff_pixels_mvi;\n\n        c->sad[0]           = pix_abs16x16_mvi_asm;\n\n        c->sad[1]           = pix_abs8x8_mvi;\n\n        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;\n\n        c->pix_abs[1][0]    = pix_abs8x8_mvi;\n\n        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;\n\n        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;\n\n        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;\n\n    }\n\n\n\n    put_pixels_clamped_axp_p = c->put_pixels_clamped;\n\n    add_pixels_clamped_axp_p = c->add_pixels_clamped;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {\n\n        c->idct_put = ff_simple_idct_put_axp;\n\n        c->idct_add = ff_simple_idct_add_axp;\n\n        c->idct =     ff_simple_idct_axp;\n\n    }\n\n}\n", "idx": 24426, "substitutes": {"c": ["sc", "cm", "k", "dc", "uc", "oc", "p", "this", "context", "C", "cit", "d", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "ce", "cy", "ch", "u", "e", "fc", "con", "ic", "cl", "vc", "s", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "co", "lc", "ctrl", "ca", "f", "gc", "tc", "n", "cu", "conn", "t", "q", "arc", "g", "r", "nc", "l", "cs", "ac", "pc"], "avctx": ["Avctl", "AVcmp", "abca", "avecontext", "abcontext", "avcmp", "afcmp", "avcontext", "avsci", "AVsci", "avca", "afcontext", "afctx", "avectx", "avctl", "afca", "abctx", "Avcontext", "avesci", "AVca", "abcmp", "AVctx", "AVctl", "Avsci", "avectl", "AVcontext", "Avctx"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "static char *check_nan_suffix(char *s)\n\n{\n\n    char *start = s;\n\n\n\n    if (*s++ != '(')\n\n        return start;\n\n\n\n    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\n           (*s >= '0' && *s <= '9') ||  *s == '_')\n\n        s++;\n\n\n\n    return *s == ')' ? s + 1 : start;\n\n}\n", "idx": 24433, "substitutes": {"s": ["w", "sy", "ns", "ts", "ps", "states", "u", "es", "gs", "south", "sound", "sym", "seconds", "f", "js", "n", "t", "r", "ops", "S", "space", "steps", "p", "m", "b", "c", "se", "x", "blocks", "ds", "ans", "us", "ins", "is", "sp", "sets", "ims", "h", "sl", "its", "side", "g", "rs", "ses", "sid", "args", "ss", "d", "ats", "ms", "e", "span", "has", "hs", "sb", "source", "sv", "cs", "i", "parts", "ix", "o", "strings", "si", "os", "as", "ls", "y", "a", "an", "v", "times", "l"], "start": ["use", "space", "from", "skip", "Start", "starting", "k", "shift", "p", "i", "none", "c", "name", "ss", "d", "started", "x", "data", "next", "type", "error", "end", "id", "e", "step", "sp", "span", " Start", "str", "set", "st", "offset", "si", "new", "scale", "first", "part", "source", "y", "n", "index", "star", "init", "ind", "v", "r", "in", "pos", "stop"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\n\n    long i;\n\n#if !HAVE_FAST_UNALIGNED\n\n    if((long)src2 & (sizeof(long)-1)){\n\n        for(i=0; i+7<w; i+=8){\n\n            dst[i+0] = src1[i+0]-src2[i+0];\n\n            dst[i+1] = src1[i+1]-src2[i+1];\n\n            dst[i+2] = src1[i+2]-src2[i+2];\n\n            dst[i+3] = src1[i+3]-src2[i+3];\n\n            dst[i+4] = src1[i+4]-src2[i+4];\n\n            dst[i+5] = src1[i+5]-src2[i+5];\n\n            dst[i+6] = src1[i+6]-src2[i+6];\n\n            dst[i+7] = src1[i+7]-src2[i+7];\n\n        }\n\n    }else\n\n#endif\n\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n\n        long a = *(long*)(src1+i);\n\n        long b = *(long*)(src2+i);\n\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n\n    }\n\n    for(; i<w; i++)\n\n        dst[i+0] = src1[i+0]-src2[i+0];\n\n}\n", "idx": 24472, "substitutes": {"dst": [" dconst", "didsc", "dsts", "fdost", "adst", "cdest", "dconst", "ddconst", " dste", " dsp", "adsts", "past", "didstep", " dest", " dstep", " dsc", "ddset", "didst", "cdsc", "dsST", "cdost", "fdput", "ssts", "Dost", "fput", "dST", " dost", "pst", "sdost", "dset", "dssts", "nsts", "psts", "odost", " drest", " dput", "cdsts", "odsts", "dsc", "adsp", "dste", "ldest", "drest", "ddsc", "ddrest", "sst", "adost", " dsts", "fest", "dsst", "adast", "dsput", "ddst", "odput", "dsost", "fst", "ddsts", "ldost", "sdest", "sdsts", "Dstep", "fdsts", "dsp", "hdst", "dast", " dset", "dost", " dST", "ldsts", "cdst", "Dsc", "Dst", "dstep", "adste", "sST", "dsdest", "ldste", "psp", "fdst", "hdrest", "fost", " dast", "nset", "Dsts", "didost", "hdsc", "nconst", "ldst", "odst", "sdst", "fsts", "nst", "hdsts", "ddest", " ddest", "dest", "dput"], "src1": ["source1", "srcOne", "dest01", "sourceOne", " srcone", "rc3", "support1", "loc2", "locOne", "loc1", "destOne", "source01", "source3", "rcone", "source2", "srcStart", "rcStart", "inst3", " src01", "supportOne", "dest1", "support2", " src11", "rc1", "source11", "supportStart", "inst2", "srcone", "rc2", "rcOne", "dest3", "instone", "src01", "src11", "src3", "dest2", " srcStart", " src3", " srcOne", "rc11", "inst01", "rc01", "inst1"], "src2": ["sc2", "src4", "rc5", "struct42", "rc02", "dest0", "st2", "sttwo", "st1", "config1", " src5", "config2", "rctwo", "rc2015", "sc1", "dest2", " src4", "src2015", "rcsecond", " src0", "source42", "sourceTwo", "source5", "config0", "dest62", "img1", "src0", "obl62", "struct5", "struct2", "src42", "rc2", "loc4", "sup2", "src5", "rc62", "source4", "loc2", "source8", "sup0", "rcTwo", "source2", "oblsecond", "loc0", "dest1", "sup1", "rc0", "source62", "obl2", "sc5", " srcTwo", "img0", "imgtwo", "rc8", "destTwo", "src8", " src02", "source1", "srcsecond", "struct1", "srctwo", " srctwo", "src02", "obl2015", "structTwo", "rc42", "source02", "obl1", "src62", "rc1", "locTwo", "srcTwo", "stsecond", "obltwo", "sc8", "config5", "img2", "source2015", "supTwo", "rc4"], "w": ["ow", "kw", "k", "z", "p", "m", "ww", "c", "wb", "d", "sw", "wave", "x", "weight", "wh", "end", "u", "wx", "hw", "o", "max", "l", "fw", "ew", "tw", "win", "wp", "wal", "h", "window", "aw", "y", "wt", "f", "n", "W", "wei", "t", "nw", "q", "v", "r", "we", "wa", " W", "g"], "i": ["z", "ie", "name", "it", "io", "u", "li", "start", "bi", "ini", "ai", "f", "n", "j", "chi", "ami", "k", "slice", "p", "b", "m", "c", "x", "ti", "mi", "us", "phi", "qi", "ri", "is", "key", "iter", "s", "di", "ci", "isin", "ki", "in", "g", "yi", "d", "isi", "uli", "the", "e", "at", "uri", "ii", "cli", "fi", "I", "iu", "init", "anti", "idi", "my", "info", "image", "ix", "api", "id", "site", "o", "gi", "ic", "zi", "multi", "xi", "inner", "si", "ni", "iv", "y", "mini", "oi", "ip", "index", "a", "v", "mu", "pi", "ui", "l", "hi"]}}
{"project": "FFmpeg", "commit_id": "cb85779d459c6486acbbf060b3f169779424583e", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    DPXContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr[AV_NUM_DATA_POINTERS];\n\n\n\n    unsigned int offset;\n\n    int magic_num, endian;\n\n    int x, y, i, ret;\n\n    int w, h, bits_per_color, descriptor, elements, packing, total_size;\n\n\n\n    unsigned int rgbBuffer = 0;\n\n    int n_datum = 0;\n\n\n\n    if (avpkt->size <= 1634) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small for DPX header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_num = AV_RB32(buf);\n\n    buf += 4;\n\n\n\n    /* Check if the files \"magic number\" is \"SDPX\" which means it uses\n\n     * big-endian or XPDS which is for little-endian files */\n\n    if (magic_num == AV_RL32(\"SDPX\")) {\n\n        endian = 0;\n\n    } else if (magic_num == AV_RB32(\"SDPX\")) {\n\n        endian = 1;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"DPX marker not found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    offset = read32(&buf, endian);\n\n    if (avpkt->size <= offset) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid data start offset\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    // Need to end in 0x304 offset from start of file\n\n    buf = avpkt->data + 0x304;\n\n    w = read32(&buf, endian);\n\n    h = read32(&buf, endian);\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    // Need to end in 0x320 to read the descriptor\n\n    buf += 20;\n\n    descriptor = buf[0];\n\n\n\n    // Need to end in 0x323 to read the bits per color\n\n    buf += 3;\n\n    avctx->bits_per_raw_sample =\n\n    bits_per_color = buf[0];\n\n    buf++;\n\n    packing = *((uint16_t*)buf);\n\n\n\n    buf += 824;\n\n    avctx->sample_aspect_ratio.num = read32(&buf, endian);\n\n    avctx->sample_aspect_ratio.den = read32(&buf, endian);\n\n    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)\n\n        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,\n\n                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,\n\n                  0x10000);\n\n    else\n\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n\n\n    switch (descriptor) {\n\n        case 51: // RGBA\n\n            elements = 4;\n\n            break;\n\n        case 50: // RGB\n\n            elements = 3;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported descriptor %d\\n\", descriptor);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (bits_per_color) {\n\n        case 8:\n\n            if (elements == 4) {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            }\n\n            total_size = avctx->width * avctx->height * elements;\n\n            break;\n\n        case 10:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 32bit required\\n\");\n\n                return -1;\n\n            }\n\n            avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n\n            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;\n\n            break;\n\n        case 12:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 16bit required\\n\");\n\n                return -1;\n\n            }\n\n            if (endian) {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        case 16:\n\n            if (endian) {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;\n\n            } else {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported color depth : %d\\n\", bits_per_color);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n    if ((ret = ff_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    // Move pointer to offset from start of file\n\n    buf =  avpkt->data + offset;\n\n\n\n    for (i=0; i<AV_NUM_DATA_POINTERS; i++)\n\n        ptr[i] = p->data[i];\n\n\n\n    if (total_size > avpkt->size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Overread buffer. Invalid header?\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (bits_per_color) {\n\n    case 10:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[0]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[1]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                // For 10 bit, ignore alpha\n\n                if (elements == 4)\n\n                    read10in32(&buf, &rgbBuffer,\n\n                               &n_datum, endian);\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 12:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2] = *((uint16_t*)buf);\n\n                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);\n\n                dst[2]++;\n\n                buf += 2;\n\n                *dst[0] = *((uint16_t*)buf);\n\n                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);\n\n                dst[0]++;\n\n                buf += 2;\n\n                *dst[1] = *((uint16_t*)buf);\n\n                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);\n\n                dst[1]++;\n\n                buf += 2;\n\n                // For 12 bit, ignore alpha\n\n                if (elements == 4)\n\n                    buf += 2;\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 16:\n\n        elements *= 2;\n\n    case 8:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            memcpy(ptr[0], buf, elements*avctx->width);\n\n            ptr[0] += p->linesize[0];\n\n            buf += elements*avctx->width;\n\n        }\n\n        break;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 24478, "substitutes": {"avctx": ["apcontext", "avcms", "AVfw", "navcontext", "alconn", "afkb", "avalobj", "avcontext", "avesync", "afcontext", "avectx", "ajctx", "avekb", "akctx", "alcb", "avcv", "avecmp", "affw", "akcontext", "AVcontext", "afcca", "akloc", "avcu", "afsync", "avepkg", "avcoll", "afctrl", "avcca", "avalcontext", " avloc", "avsci", "afctx", "avconfig", "avpkg", "avalctx", "avectrl", "avfw", "avecms", "avloc", "avecoll", "avctrl", "navsync", "avalcms", "AVctx", "verctx", "afcv", "avcb", "afobj", "alctx", "apcu", "ajcoll", "avalcmp", "avecontext", "avefw", "AVconn", "avcmp", "verconn", "apctx", "avsync", "afcms", "avalcu", "avecv", " avsci", "ajctrl", "afcb", "avesci", "avconn", "alcontext", "afcoll", "ajpkg", "afconn", "vercb", "ajcontext", "akconn", "afpkg", "avecca", "ajkb", "avkb", "aveconfig", "vercontext", "afcu", "ajcms", "aveconn", "avobj", " avconn", "aveobj", "afsci", " avcontext", "navcv", "afloc", " avconfig", "apcms", "navctx", "afcmp", "ajcca", "afconfig"], "data": ["Data", "body", "code", "package", "download", "batch", "frame", "name", "context", "image", "d", "buffer", "queue", "base", "media", "doc", "config", "read", "next", "reader", "id", "pad", "feed", "open", "message", "padding", "input", "dat", "start", "command", "sample", "original", "mode", "parent", "client", "size", "video", "cache", "response", "channel", "device", "length", "window", "bytes", "value", "da", "a", "DATA", "content", "header", "database", "memory", "meta", "result", "pos", "connection"], "got_frame": ["numacchannel", "numgtime", "num_frame", "num_time", "numgtrace", "numgframe", "get_channel", "num_channel", "numgchannel", "numactrace", "get_frame", "num_trace", "numactime", "get_time", "numacframe", "get_trace"], "avpkt": ["avperkt", "avegkt", "avPacket", "abcct", "avcft", "AVPcf", "avbpct", "abcacket", "avparut", "avpept", "avpect", "avepkn", "AVPke", "avparkat", "avopkt", "avput", "avfkt", "avpbkt", "avgut", "AVpcf", "avperkn", "avcpct", "avopdt", "avgkt", "AVPacket", "avbpft", "avepkt", "avPcf", "avbpett", "afpct", "avgacket", "avepkat", "avpcf", "afpacket", "avpett", "avperkat", "AVPpt", "avfdt", "avPett", "avPft", "avfft", "avpbke", "affct", "avfcf", "AVPett", "avppt", "avpeke", "avpct", "avegkn", "avparkn", "abcft", "AVpkt", "avcct", "avPkt", "avPpt", "avjpacket", "AVpett", "abpkt", "affacket", "avcdt", "avgkn", "afpdt", "avpkn", "avjpcf", "AVpft", "AVPft", "avbpkt", "avjpkt", "avpft", "avpbpt", "avPct", "avcacket", "avgkat", "abpft", "avpbct", "avfacket", "afpkt", "avopacket", "avgct", "affdt", "AVpacket", "avcpft", "avegut", "aveput", "avpke", "avPke", "AVPkt", "avjpct", "avgft", "avfct", "affkt", "avpekt", "avperut", "abpacket", "avcpett", "AVpke", "avcpkt", "abckt", "avopct", "AVppt", "avparkt", "avpacket", "AVpct", "abpct", "avpkat", "avegkat", "AVPct", "avpdt", "avckt"], "buf": ["font", "socket", "bag", "exc", "batch", "wb", "pkg", "Buff", "usb", "buffer", "cb", "begin", "cmd", "fw", "pool", "cf", "conv", "uu", "buff", "window", "fp", "r", "pack", "wa", "b", "c", "cv", "msg", "queue", "text", "port", "proc", "feed", "ff", "uint", "cap", "cache", "feat", "cas", "tc", "src", "func", "block", "fd", "fun", "uf", "uc", "usr", "context", "d", "rb", "bus", "all", "raw", "brace", "tmp", "box", "fb", "fi", "utf", "alloc", "Buffer", "length", "ha", "header", "_", "seq", "shift", "vec", "img", "cur", "config", "br", "prop", "aka", "bc", "pad", "rw", "aux", "home", "loc", "ctx", "rc", "xff", "loop", "result"], "s": ["S", "space", "sc", "sys", "ss", "m", "c", "bis", "d", "sq", "ds", "sac", "conf", "ps", "sg", "sync", "e", "es", "share", "session", "sv", "si", "sym", "stat", "sb", "sec", "services", "sup", "as", "f", "fs", "service", "a", "an", "q", "v", "r", "sf", "ssl", "cs", "g"], "picture": ["gif", "summary", "space", "package", "obj", "slice", "Picture", "family", "info", "definition", "frame", "image", "camera", "buffer", "detail", "photo", "media", "img", "config", "feature", "plugin", "profile", "movie", "piece", "conference", "guide", "share", "uri", "slot", "library", "ctx", "fi", "video", "cache", "brush", "details", "pict", "png", "meta", "room", "cam", "pic"], "p": ["np", "b", "m", "c", "d", "P", "py", "jp", "ps", "proc", "u", "mp", "e", "pd", "f", "n", "a", "fp", "v", "r", "pi", "vp", "l", "pc", "g"], "ptr": ["seq", "obj", "pt", "cv", "dr", "buffer", "vec", "br", "pointer", "inst", "ch", "tr", "proc", "pad", "mem", "arr", "str", "ef", "nt", "fi", "ctr", "alloc", "Ptr", "addr", "transfer", "src"], "AV_NUM_DATA_POINTERS": ["AV_NUM_DATA_POATCHS", "AV_NUM_DATA_PRINTINGS", "AV_NUM_DATA_PROTER", "AV_NUM_DATA_POOTS", "AV_NUM_DATA_POOTERS", "AV_NUM_DATA_POINTER", "AV_NUM_DATA_PROTINGS", "AV_NUM_DATA_POOTER", "AV_NUM_DATA_POILER", "AV_NUM_DATA_POILS", "AV_NUM_DATA_POATCHINGS", "AV_NUM_DATA_PROTERS", "AV_NUM_DATA_POOTINGS", "AV_NUM_DATA_PROTS", "AV_NUM_DATA_POATCHERS", "AV_NUM_DATA_PRINTERS", "AV_NUM_DATA_POATCHER", "AV_NUM_DATA_POILERS", "AV_NUM_DATA_POINTINGS", "AV_NUM_DATA_POINTS", "AV_NUM_DATA_POILINGS", "AV_NUM_DATA_PRINTER", "AV_NUM_DATA_PRINTS"], "offset": ["ref", "skip", "from", "shift", "info", "position", "image", "base", "no", "fff", "align", "error", "Offset", "end", "num", " offsets", "o", "ff", "padding", "start", "nb", "set", "loc", "unc", "slot", "lace", "nt", "parent", " error", "size", "ffff", "now", "origin", "off", "timeout", "part", "aw", "f", "limit", "index", "fp", "et", "pos", "len"], "magic_num": ["magic67no", " magic_bin", " magic_common", "magic_nom", "magic67common", "magic_sum", " magic_sum", "magic67num", "magic_number", " magic_nu", "magic_no", "magic_nu", " magic_type", "magicialnumber", "magicialsum", "magic_common", "magicialnum", "magic_bin", "magic__nu", "magic_fun", " magic_number", " magic_nom", "magic_type", "magic__number", "magic__nom", "magic2num", "magic2fun", " magic_fun", "magic67bin", "magic__num", "magic2no", "magicialtype", " magic_no", "magic2bin"], "endian": ["endedrian", "ENDian", " endrian", "endio", "endiana", "appendio", "endedio", "ENDiet", "endnet", "angio", " endiet", "endrian", "endsians", " endians", " endig", "endedian", "endiet", "ENDio", "endserman", "angiana", "endedig", "endednet", " enderman", " endiar", "endsiar", " endiana", " endior", "endederman", "endedians", "endiar", "endien", " endio", "endedior", "endians", "angian", " endnet", "endsrian", "appendien", "appendian", "endsnet", "endediar", "angians", "endsig", "endig", "enderman", "endsian", " endien", "appendiet", "endior", "ENDien", "endediana", "endsior"], "x": ["z", "c", "d", "image", "ix", " image", " X", "X", "num", " index", "o", "dx", "win", "f", "n", "index", "v", "r", "ex", "l", "g"], "y": ["height", "z", "b", "m", "c", "dy", "d", "phi", "vy", "u", "e", "o", "Y", "f", "n", "t", "a", "q", "v", "r", "l", "hi", "g"], "i": ["b", "m", "c", "ix", "mi", "phi", "it", "io", "u", "xi", "ii", "ini", "si", "ai", "ni", "ci", "f", "I", "j", "index", "ip", "v", "pi", "l", "hi"], "ret": ["ref", "temp", "code", "ft", "res", "info", "flag", "back", "no", "success", "fail", "att", "def", "error", "id", "rets", "mem", "get", "tmp", "bit", "lit", "det", "RET", "re", "nt", "reply", "rc", "utf", "feat", "bad", "timeout", "Ret", "count", "entry", "rt", "used", "status", "part", "alt", "reg", "resp", "value", "match", "out", "r", "result", "len", "val", "fun"], "w": ["height", "ow", "kw", "k", "z", "b", "m", "ww", "c", "sh", "d", "wo", "wb", "sw", "weight", "wh", "end", "u", "wx", "hw", "max", "work", "l", "wl", "fw", "wd", "ew", "size", "win", "wid", "wal", "f", "wt", "aw", "n", "W", "t", "q", "v", "r", "we", "wi", "wa", " W", "g"], "h": ["height", "hm", "ht", "z", "m", "b", "c", "sh", "d", "hr", "hd", "ih", "bh", "H", "end", "ah", "u", "uh", "e", "hp", "o", "padding", "rh", "ul", "hs", "size", "gh", "f", "n", "ha", "q", "v", "r", "l", "hi", "ph", "oh", "g"], "bits_per_color": ["bits_per_colour", "bits_per_texture", "bits_per_pixel", "bits_perfcolor", "bits_perftexture", "bits_perfpixel", "bits_per_channel", "bits_perfsize", "bits_per_size"], "descriptor": ["desccriptors", "descructors", "descributor", "escriptcer", "decributoring", "descstructoring", "desccription", "descstructor", "descributoring", "describution", "esccriptor", "descpectoring", "descpectors", "decriptOR", "escriptor", "descruction", "decributor", "descpection", "descriptors", "desccriptcer", "descriptOR", "descriptcer", "descpector", "escription", "descpectOR", "escriptors", "decriptoring", "decributOR", "esccriptors", "decribution", "descstructOR", "desccriptor", "esccriptcer", "descructor", "descributOR", "decription", "descstruction", "esccription", "decriptor", "description", "descpectcer", "descructcer", "descriptoring"], "elements": ["peodes", "element", "Eles", "pelement", " element", " eles", "pelements", "Eodes", "Elements", "eles", "eodes", "peles", "Element", " eodes"], "packing": ["space", "mask", "kw", "secret", "adding", "slice", "setting", "reading", "stuff", "pkg", "using", "buffer", "queue", "storage", "capacity", "ping", "counter", "rows", "loading", "extra", "padding", "spec", "tracking", "sequence", "writing", "including", "xff", "ipping", "missing", "xxx", "checking", "packed", "processing", "working", "leading", "ending", "checks", "running", "icing", "pack", "aging", "packs", "power"], "total_size": ["total_sum", "total_count", "total67size", "total67sum", " total_count", "total67count", " total_sum", " total_len", "total_len", "total67len"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n\n{\n\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n\n    int rs = mmreg(ctx->opcode & 0x7);\n\n    int opc;\n\n\n\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n\n    case NOT16 + 0:\n\n    case NOT16 + 1:\n\n    case NOT16 + 2:\n\n    case NOT16 + 3:\n\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n\n        break;\n\n    case XOR16 + 0:\n\n    case XOR16 + 1:\n\n    case XOR16 + 2:\n\n    case XOR16 + 3:\n\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n\n        break;\n\n    case AND16 + 0:\n\n    case AND16 + 1:\n\n    case AND16 + 2:\n\n    case AND16 + 3:\n\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n\n        break;\n\n    case OR16 + 0:\n\n    case OR16 + 1:\n\n    case OR16 + 2:\n\n    case OR16 + 3:\n\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n\n        break;\n\n    case LWM16 + 0:\n\n    case LWM16 + 1:\n\n    case LWM16 + 2:\n\n    case LWM16 + 3:\n\n        {\n\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case SWM16 + 0:\n\n    case SWM16 + 1:\n\n    case SWM16 + 2:\n\n    case SWM16 + 3:\n\n        {\n\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case JR16 + 0:\n\n    case JR16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case JRC16 + 0:\n\n    case JRC16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    case JALR16 + 0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 24483, "substitutes": {"ctx": ["exec", "txt", "sc", "kw", "cm", "np", "cca", "scope", "parse", "anc", "c", "pkg", "context", "cv", "connection", "qa", "xc", "qt", "sq", "config", "jp", "cus", "ct", "cb", "bc", "sync", "kb", "mac", "ocr", "linux", "cmp", "wx", "hw", "cmd", "grad", "cms", "vc", "la", "cl", "loc", "wcs", "ann", "cli", "hs", "Context", "cc", "ci", "cp", "cf", "cn", "rc", "client", "sci", "conv", "ga", "cas", "utils", "lc", "ctrl", "ca", "gc", "tc", "na", "cu", "conn", "cpp", "ck", "nc", "tx", "cs", "cam", "kt"], "is_branch": ["is_refix", "is_franc", "is_refanch", "is_banch", "is_franch", "is_branc", "is_branches", "is_banc", "is_frix", "is_brix", "is_franches", "is_refanches", "is_banches", "is_bix", "is_refanc"], "opc": [" opci", " opn", "opci", "OPcode", "opn", "OPc", " copci", "opcode", " copcode", " opcode", "OPci", " copn", " copc", "OPn"], "lwm_convert": ["lwm_unverted", "lwm_Convert", "lwm_pervert", "lwm_unvert", "lwm_converts", "lwm_canvert", "lwm_Conversion", "lwm_canversion", "lwm_converted", "lwm_conversion", "lwm_canverted", "lwm_unverts", "lwm_Converted", "lwm_perversion", "lwm_perverts", "lwm_perverted", "lwm_canverts", "lwm_unversion", "lwm_Converts"], "swm_convert": ["swm_perver", "swm_unver", "swm_unverted", "swm_perverts", "swm_genvert", "swm_conver", "swm_pervert", "swm_genverts", "swm_converted", "swm_genver", "swm_helverts", "swm_inver", "swm_perverted", "swm_inverted", "swm_unverts", "swm_helvert", "swm_unvert", "swm_invert", "swm_genverted", "swm_converts", "swm_helverted", "swm_inverts", "swm_helver"]}}
{"project": "FFmpeg", "commit_id": "abb5e37f64c48bba8bd0fde2bada0f7544defa24", "target": 1, "func": "int ff_filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFrame *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFrame *out;\n\n\n\n    FF_DPRINTF_START(NULL, filter_frame);\n\n    ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    /* copy the frame if needed */\n\n    if (dst->needs_writable && !av_frame_is_writable(frame)) {\n\n        av_log(link->dst, AV_LOG_DEBUG, \"Copying data in avfilter.\\n\");\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, frame->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        av_frame_copy_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->width, frame->height);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        av_frame_free(&frame);\n\n    } else\n\n        out = frame;\n\n\n\n    return filter_frame(link, out);\n\n}\n", "idx": 24484, "substitutes": {"link": ["head", "call", "mail", "module", "or", "base", "label", "ld", "add", "bug", "sync", "url", "li", "bridge", "model", "edge", "zip", "mm", "match", "pack", "slice", "leg", "ink", "line", "feed", "key", "path", "di", "ci", "flash", "plug", "machine", "block", "file", "load", "light", "parse", "band", "loader", "plugin", "db", "cp", "lc", "arg", "source", "ck", "connection", "tag", "lock", "linked", "info", "Link", "image", "style", "config", "type", "flow", "loc", "links", "local", "ln", "channel", "co", "loop", "network", "ip", "route", "ind", "ace", "l"], "frame": ["element", "call", "fe", "definition", "name", "module", "frames", "time", "base", "version", "motion", " Frame", "rame", "object", "model", "cf", "game", "zip", "part", "f", "Frame", "match", "draw", "layer", "code", "slice", "user", "play", "scene", "ground", "boot", "line", "point", "cell", "panel", "new", "now", "plane", "in", "block", "file", "load", "zone", "data", "force", "back", "component", "up", "plugin", "player", "parent", "fb", "setup", "fi", "video", "view", "fake", "full", "post", "connection", "lock", "ze", "fram", "framework", "position", "image", "style", "interface", "figure", "feature", "flow", "movie", "layout", "run", "channel", "iframe", "mini"], "filter_frame": [" filter_node", "filterayproperty", "filteraycomponent", " filter_component", "filter_setup", "filter_sequence", "filter_position", "filterenfram", "filteracsetup", "filteracframe", " filter_sequence", "filtervalframe", "filteracsequence", "filteraldef", "filterayframe", "filter_point", "filter___frame", "filter___position", " filter_position", "filteroutpoint", "sort_frame", "filterersequence", "filter_fram", "filter_element", "filter___element", "filterenproperty", "filter_link", "sort_style", " filter_channel", "filterennode", "filterensetup", " filter_property", "filtervalfram", "filtervaldef", "filter_channel", "filteracfram", "filtervallink", " filter_element", "filteroutframe", "filteralframe", " filter_def", "sort_fram", "filtererframe", " filter_link", "filter_style", "filteracnode", "filteroutfram", "filteralfram", "filteroutstyle", " filter_fram", "filteracchannel", "filterenframe", "filter_node", "filterayfram", "filter_def", "filterallink", "sort_point", " filter_setup", "filter___fram", "filteracpoint", "filteracstyle", "filter_component", "filterencomponent", "filtererchannel", "filter_property"], "dst": ["Dft", "fnt", " dnt", " dsts", "bdsc", "tdsc", "dsts", "tdst", "ndst", "ndsts", "Dput", "bdst", "sdST", "tdput", "DST", "fbl", "dST", "fst", "Dsts", "dft", "fsc", " dbl", "ndST", "odst", "dbl", "dnt", "sdsts", "odbl", "sdst", "tdft", "odsc", "odnt", "ndbl", " dft", " dsc", "sdbl", " dST", " dput", "dsc", "Dsc", "bdST", "Dst", "bdsts", "dput"], "out": ["ref", "call", "name", "module", "or", "base", "again", "sync", "io", "url", "ne", "wx", "object", "part", "window", "f", "n", "match", "code", "OUT", "obj", "user", "m", "empty", "of", "on", "check", "diff", "op", "line", "point", "got", "old", "group", "new", "blank", "update", "in", "block", "file", "load", "bin", "data", "no", "up", "to", "error", "orig", "all", "extra", "outer", "err", "at", "and", "output", "copy", "parent", "client", "source", "full", "init", "connection", "post", "lock", " in", "page", "image", "img", "style", "Out", "outs", "end", "flow", "instance", "o", "inner", "run", "co", "channel", "off", "ext", "child", "conn", "result"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24485, "substitutes": {"transport": ["ransPORT", "transPORT", " transort", "ransp", "Transort", "transporter", "ransports", "Transport", "Transports", " transports", "transort", "TransPORT", "ransort", "ransporter", " transp", " transporter", "Transporter", "Transp", "transp", " transPORT", "transports", "ransport"], "data": ["Data", "body", "batch", "d", "buffer", "api", "base", "queue", "read", "style", "pointer", "next", "address", "dd", "write", "pad", "ui", "buf", "message", "input", "dat", "zero", "start", "client", "size", "response", "cache", "block", "addr", "window", "bytes", "da", "a", "DATA", "result", "val"], "len": ["load", "seq", "fin", "ll", "name", "vec", "fn", "base", "lan", "en", "ld", "delay", "split", "all", "line", "lf", "mem", "el", "Len", "str", "valid", "err", "start", "lit", "lib", "offset", "nt", "size", "ln", "length", "f", "limit", "n", " length", "alt", "conn", "pos", "block", "l", "val", "fun"], "vs": ["rs", "sk", "args", "iss", "ss", "ns", "Vs", "ts", "ils", "flags", "ms", "ds", "vr", "forces", "ports", "vt", "ps", "ks", "vers", "bs", "eps", "vals", "es", "stats", "gs", "rev", "sv", "os", "utils", "vm", "ls", "fs", "v", "vp", "ops", "VS", "cs"], "ret": ["ref", "code", "fin", "sr", "ft", "flag", "rf", "base", "success", "bf", "att", "type", "error", " Ret", "id", "num", "url", "rets", "err", "rl", "det", "rev", "lit", "RET", "re", "art", "nt", "reply", "rc", "req", "pet", "ry", "arg", "Ret", "rt", "f", "ext", "count", "alt", "t", "resp", "reg", "try", "result", "val", "fun"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486, "substitutes": {"obj": ["node", "p", "objects", "b", "bo", "ob", "x", "data", "api", "Object", "rb", "opt", "inst", "op", "self", "foo", "buf", "o", "tmp", "pb", "rev", "object", "parent", "ctx", "fi", "emb", "iv", "xxx", "Obj", "f", "po", "js", "j", "src", "func", "attr", "env", "val"], "v": ["w", "p", "m", "b", "c", "d", "vs", "vt", "vu", "ev", "op", "tv", "vv", "u", "e", "o", "object", "iv", "vm", "conv", "uv", "f", "lv", "j", "V", "vp", "l", "sv", "env", "val", "g"], "opaque": ["pacity", "opachy", "spachy", "iopacity", "opaqu", "opac", "obacity", " opac", " opaqu", " opachy", "spacity", " opacity", "spaque", "iopaque", "obaqu", "iopachy", "iopac", "paque", "opacity", "spac", "paqu", "obaque"], "name": ["code", "nm", "none", "anc", "data", "label", "no", "var", "member", "type", "prefix", "property", "error", "alias", "foo", "Name", "key", "cap", "clean", "word", "new", "size", "nice", "field", "missing", "comment", "NAME", "named", "n", "names", "null", "unknown", "val", "desc"], "errp": ["errpc", "reqpc", "rarp", "nerpc", "irpi", "irp", "irpc", "ircp", "rrp", " erl", "errcp", "rrlp", "nerpi", "rarl", "rrcp", " errl", "rrpc", "errpi", "rarcp", "errlp", " erp", "rrps", " erlp", " ercp", "errps", "irps", "reqps", "rrpi", "rarlp", "reqp", " errcp", "irlp", "nerlp", "reqcp", " errlp", "errl", "nerp"], "prop": ["ref", "np", "info", "p", "b", "option", "pkg", "Prop", "api", "pointer", "jp", "type", "opt", "property", "priv", "op", "proc", "plugin", "typ", "cmp", "mp", "tmp", "pb", "lit", "parent", "properties", "cp", "fi", "fb", "ptr", "pred", "field", "part", "pro", "f", "po", "pr", "prot", "j", "attr", "val"], "value": ["ref", "class", "p", "image", "data", "type", "property", "reference", "Value", "write", "example", "id", "version", "instance", "foo", "key", "protected", "message", "create", "valid", "object", "parent", "target", "VALUE", "size", "number", "field", "length", "array", "index", "null", "content", "values", "result", "val", "format"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,\n\n                            int mb_x, int mb_y, uint8_t *img_y,\n\n                            uint8_t *img_cb, uint8_t *img_cr,\n\n                            unsigned int linesize, unsigned int uvlinesize)\n\n{\n\n    assert(!FRAME_MBAFF(h));\n\n    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {\n\n        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n\n        return;\n\n    }\n\n\n\n#if CONFIG_SMALL\n\n    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);\n\n#else\n\n    if(h->pixel_shift){\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);\n\n    }else{\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);\n\n    }\n\n#endif\n\n}\n", "idx": 24488, "substitutes": {"h": ["hm", "ht", "w", "z", "p", "m", "b", "c", "context", "d", "image", "history", "x", "img", "ih", "bh", "H", "hh", "ch", "ah", "self", "u", "uh", "hl", "e", "ssh", "hp", "o", "hw", "work", "rh", "dh", "http", "s", "ul", "l", "pl", "hs", "ctx", "auth", "gh", "ahi", "eh", "f", "y", "n", "t", "host", "ha", "q", "zh", "v", "g", "r", "hr", "hi", "he", "ph", "oh", "sh"], "sl": ["sch", "sc", "SL", "sk", "hel", "p", "m", "sn", "c", "b", "ssl", "se", "sw", "shell", "enc", "ph", "cur", "ch", "su", "spot", "hl", "el", "cl", "rl", "la", "s", "lr", "loc", "spec", "pl", "lib", "fl", "si", "sel", "ctx", "sb", "sa", "lc", "il", "serv", "ls", "f", "sil", "src", "coll", "Sl", "sf", "l", "kl", "sh"], "mb_x": ["mb44yx", "url_yx", "mn_x", "mn_dy", "urlameyx", "mb44x", "mb_tx", "mb_wy", "mb44xi", "mb_dy", "mbameyx", "mb_xi", "url_xi", "mbametx", "mbamex", "bf_y", "mbamexi", "mp_y", "urlamexi", "mb_width", "mp_x", "mb_z", "mn_width", "mb_yx", "mn_y", "mb44tx", "mb_n", "mp_z", "mb_w", "url_x", "mp_n", "bf_w", "urlamex", "urlametx", "url_tx", "bf_x", "bf_wy"], "mb_y": ["mb_Y", "mp_dy", "mb_zy", "mp_cy", "mb_ey", "img_zy", "mbingcy", "mb_yo", "mb_dy", "mb_cy", "mb68oy", "mp_yo", "mb_oy", "img_x", "mb68y", "mp_vy", "mb_py", "mb68yo", "mp_y", "mbingvy", "mp_x", "mbingx", "img_Y", "mp_oy", "mb_yy", "mp_py", "mb68x", "mp_ey", "mb_vy", "mbingy", "mp_yy"], "img_y": ["mb_yk", "image_ya", "img_bar", " imgJcy", "imgKx", "img__x", "mbJya", "mbJy", "mbJies", "imgJcy", "img9ye", "img_cy", "img_ies", "utm9iy", "imagKy", "imag_x", "mb_ya", "img_x", "utm_iy", "utm9x", "imagKbar", "imgKbar", "mb_ies", "image_ies", "image_y", "image_ey", "utm_x", "img__ye", " img_yk", "img_ya", "img_yy", "img_yk", "utm_y", "img_ye", " img_cy", "img_ey", "mbJyk", "utm_ye", "img_iy", "imgJya", "utm9ye", "imgKyy", "imgJies", "utm9y", " imgJy", "imag_yy", "imag_y", "imagKyy", "img9iy", "img__iy", "imgKy", "imgJny", "img_ny", "img9x", "imag_bar", " imgJny", " imgJyk", "img__y", "imgJyk", "imagKx", " img_ny", "img9y", "imgJy"], "img_cb": ["img24bb", "imgJcmd", "imgaccr", "imgLcmd", "imgacsrc", "img24cb", "imgLcp", "img_cmd", "imag_cmd", "im_rc", "imgIPrc", "imgLcb", "img24cr", "img_b", "imp_home", "img24home", " img_cf", "imp_cb", "imgIPc", "imagLcb", "imag_cp", "imagLcp", "im_cb", "imgJcb", "imagLcmd", "img_rc", "imgJcp", "imgLy", "imagLy", "bg_cr", "img_src", "imp_bb", "imgaccb", "imgaccf", "bg_b", "img_bb", "img_c", "img_cp", "bg_bb", "imag_y", "imgIPcr", "imp_cr", "imag_cb", "bg_cb", "img_cf", "im_cr", "imgIPcb", " img_src", "img_home", "im_c", "imgJy"], "img_cr": ["bg_CR", " img_cd", "image_cr", "img_CR", "imgAcur", "image_cb", "img_car", "img_ocr", "img_ctr", "img__cb", "img_rb", "im_cur", "img_cur", "im_cm", " img_CR", "img__car", "imgAcm", "im_cb", "imgAcb", "img__cr", "bg_bre", "imag_cr", "img__ocr", "image_ctr", "image_rb", " img_cre", "bg_cr", "img_cre", "imgAcr", "img_bre", "img_cd", "imag_ocr", "imag_cb", "imag_car", "img_cm", "bg_cb", "im_cr"], "linesize": ["linizer", "linization", "vsizing", "linssize", "topsizer", "vsize", "linsize", "topsization", "liniz", "vsization", "linksiz", "linksize", "linksizing", "cellsize", "topsiz", " linesizer", "roomsizer", " linessize", "inesization", "inesize", "roomsizing", "worksizing", "linesizer", "inesiz", "roomsiz", "linsization", "linesization", "vsiz", "worksizer", " linesizing", " linesiz", "cellsiz", "linessize", "cellsizer", "linize", "linesizing", "inesizer", "linsiz", "linkssize", "worksize", "linesiz", " linesization", "roomsize", "worksiz", "topsize", "linksization", "cellsization"], "uvlinesize": ["ovlinersizer", "uvpagesizable", "upplineizable", "uvliningize", "ovlinesizer", "imglinersense", "uvlinersite", "uzlinkssize", "uvlinksiz", "uvbandsization", "imglinersizer", "uvlineiz", "uumlinesparse", "uvlinersizer", "uvpagesite", "ovlinersize", "uzlinesizer", "uvlinsize", "uvbandsiz", "imglinesizer", "uzlinesiz", "uvlinesizer", "uvbandsparse", "uvcellsiz", "uvcodesizer", "uumliningize", "uvlinesparse", "upplinesize", "uvlinesite", "uvpagesize", "imglinersize", "uzlinksiz", "uumlinesize", "uvlinesization", "uumliningparse", "uzlinessize", "uvlinesense", "ovlinersizable", "imglinesense", "uzlinksizer", "uvliningiz", "uvlinssize", "ovlinersite", "uvlinesiz", "uvlinksizer", "uumliningization", "uvlinsiz", "uvlineizer", "ovlinesizable", "uvlinersiz", "uvlinksize", "upplineiz", "uvliningization", "uvlinersize", "uvcodesiz", "upplinesiz", "uvcodesize", "uvcellsizable", "uvlineization", "imglinesiz", "upplinesization", "uvpagesizer", "uvlinersense", "uvlinersizable", "uzlinksize", "uvlineite", "uvcellsization", "uzlinesize", "upplinesizable", "uvlinkssize", "uvliningizable", "imglinersiz", "uumlinesiz", "uvliningparse", "uvlinsizer", "upplineize", "uvlinesizable", "uumlinesization", "uvlineizable", "upplineization", "uvcellsize", "imglinesize", "uvlinessize", "uvbandsize", "uumliningiz", "uvlineparse", "ovlinesite", "uvlineize", "ovlinesize", "uvcodesense"]}}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n", "idx": 24501, "substitutes": {"device": ["node", "remote", "package", "user", "driver", "p", "Device", "name", "mount", "module", "buffer", "data", "attribute", "component", "prop", "address", "feature", "port", "mac", "serial", "gpu", "link", "disk", "unit", "hw", "phy", "project", "password", "cmd", "path", "message", "object", "dev", "mode", "model", "parent", "result", "target", "channel", "block", "task", "product", "handle", "ip", "devices", "machine", "draw", "tty", "connection", "tag"], "has_force": ["Has_forced", "has_forcing", " has_Force", "Has_Force", "Has_force", "has_forced", " has_forcing", "has_Force", "has_write", "Has_write"], "force": ["load", "use", " Force", "driver", "flag", "dr", "x", "hard", "base", "weight", "forces", "ant", "dirty", "ignore", "support", "act", "push", "sync", "form", "front", "fr", "allow", "Force", "ff", "uri", "flat", "fw", "fl", "forced", "like", "orce", "weak", "cache", "ride", "dist", " forced", "f", "source", "service", "pull", "q", "cing", "require", "r", "forcing", "l", "ce", "secure"], "errp": ["errback", "errorb", "errpc", "resultps", "errb", "erfp", " errback", "rrP", " errps", " errr", "rrp", "resultP", "resultp", "erpc", "rrr", " errP", "err", " errb", " erback", "resultc", " erpc", "errr", " erp", "rrps", " errfp", " err", "errps", " errpc", "erb", "erback", "rrc", "erp", "errP", "errfp", "rrfp", " errc", "errc", "errorr", "erc", "errorp"], "local_err": ["local_er", " local_nr", "localableer", "localableerr", " local_rr", " local_out", "local_out", "localablenr", "localiferror", "localifrr", " local_rc", "local_rr", "localapperr", "local_nr", " local_er", " local_error", "localiferr", "localapperror", "localableerror", "localifout", "localapper", "local_rc", "local_error", "localapprc"], "rc": ["code", "sc", "dc", " RC", "oc", "uc", " src", "c", "cv", "ec", "cur", "rb", "cr", "cb", "ct", "bc", "error", "rec", " cc", "fc", " sc", "rh", "err", "vc", "ac", "rl", "nc", "loc", "cc", "ci", "inc", "roc", "co", "lc", "ry", "irc", "src", "RC", "arc", "ck", "rr", "result", "cs", "rog", "pc", "ok"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508, "substitutes": {"prot": ["het", "txt", "primary", "ht", "np", "termin", "p", "pt", "server", "cot", "test", "api", "prop", "config", "pointer", "rin", "att", "type", "prefix", "port", "inet", "platform", "typ", "python", "pb", "eth", "repl", "flat", "rot", "bot", "ptr", "pred", "pat", "Prot", "addr", "transfer", "rect", "pro", "ext", "ocol", "tf", "tp", "php", "t", "fp", "sil", "pre", "reset", "rog"], "rw": ["ru", "w", "rou", "ww", "wb", "usr", "rn", "wo", "sw", "rf", "rb", "wh", "rus", "wrap", "wx", "rss", "hw", "iw", "work", "rh", "rew", "wer", "wl", "fw", "worker", "wit", "rc", "tw", "ro", "rack", "wp", "wal", "nw", "rx", "wr", "RW", "r", "wa", "rog"], "access_type": [" access_style", "accesstypetype", " access_resource", "accessingtype", "accessingpolicy", "access_types", "accesstyperesource", " access_types", "accessingname", "accesstypestyle", "access_resource", "access_name", "access_policy", " access_name", "access__key", " access_key", "access_style", "accessingkey", "access__type", "access__policy", " access_policy", "access__name", "access_key", "accesstypetypes"], "ret": ["std", "ref", "code", "ft", "res", "final", "cat", "flag", "data", "back", "base", "hard", "success", "opt", "def", "error", "pass", "id", "num", "rets", "al", "mem", "grad", "str", "mt", "lit", "det", "rev", "RET", "fit", "re", "art", "nt", "reply", "let", "feat", "req", "pat", "arg", "Ret", "rt", "part", "ext", "alt", "reg", "resp", "t", "match", "result", "len", "val", "gt", "fun"]}}
{"project": "qemu", "commit_id": "4545d4f4af8b29ba3b38dfb74d6f45342e15a62d", "target": 1, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24540, "substitutes": {"extent": ["silract", "xtient", "extend", "expient", "silractor", "expent", " extente", "contient", "decension", "xtension", "expenter", "xtant", "contenter", "indract", "descension", "defant", "expension", "extract", "contend", "silend", "descant", "xtent", "decant", "indenter", "descient", "extractor", " extenter", "defenter", "contension", "exent", "extency", "extient", "contract", "indractor", " extency", "decent", "silent", "lexency", "defent", "indente", "lexente", "expant", "exension", "indent", "exant", "lexent", "extente", "descent", "defension", "extension", "extant", "contractor", "indency", "content", "exient", "lexenter", "decient", "indend", "extenter", "contant"], "cluster_offset": ["clusters_slot", "cluster_size", "clressor_size", "clusters_Offset", "clusteraloffset", "cluster_address", "clressoralbound", "cluster__Offset", "clusteraladdress", "clressor_address", "clressoraladdress", "clressoraloffset", "cluster__offset", "clressor_bound", "clusteralsize", "cluster_no", "cluster__no", "cluster_Offset", "clressor_offset", "clusters_no", "clressoralsize", "cluster_slot", "cluster__slot", "cluster_bound", "clusteralbound", "clusters_offset"], "offset_in_cluster": ["offset_in_splusters", "offset_in_glusters", "offset_in_spluster", "offset_in_gluster", "offset_in_sclancer", "offset_in_blusters", "offset_in_splarc", "offset_in_clructure", "offset_in_CLructure", "offset_in_sclructure", "offset_in_CLuster", "offset_in_splructure", "offset_in_CLusters", "offset_in_clarc", "offset_in_bluster", "offset_in_glarc", "offset_in_scluster", "offset_in_clancer", "offset_in_clusters", "offset_in_blructure", "offset_in_Clancer", "offset_in_Clructure", "offset_in_Clusters", "offset_in_Cluster", "offset_in_glructure", "offset_in_sclusters", "offset_in_blancer", "offset_in_CLarc"], "qiov": ["qqiov", "qqliv", " qoyer", "quoren", "sqiosity", "quliv", " qiro", "Qiov", " qliv", "qqimedia", "quilo", "chiov", "sqiov", "qoren", "chiop", "reqiop", "chiro", "qimedia", "qnox", "sqimedia", "qurolet", "reqiosity", "Qoyer", "quiop", "quoyer", "quiosity", "Qoren", "qrolet", "sqiop", "chilo", " qilo", " qiop", "qiro", "qoyer", "reqiov", "quiro", "qunox", "Qnox", "qiop", "qliv", "qilo", "quiov", " qoren", "quimedia", " qimedia", " qnox", "reqimedia", "qqrolet", "qiosity", " qrolet"], "qiov_offset": ["qarrison__start", "qarrison__position", "qarrison__offset", "qiop_len", "qarrison_off", "qarrison_start", "qiop_off", "qiov_off", "qiop_offset", "qiov_start", "qiop_position", "qiov__off", "qiov_pos", "qiop_pos", "qiov__offset", "qiov__position", "qiov_position", "qarrison_position", "qiov__start", "qarrison_offset", "qiov_len", "qarrison__off"], "n_bytes": ["n_bits", "n67resources", "n_rows", "ln_devices", "nb_byte", "n96files", "n_units", "nb_units", "N_bytes", "ln_bytes", " n_bits", "n_pieces", "r", " n_clips", "ln67devices", "n96bytes", "n__pieces", "n__bytes", "nNdevices", "n_lines", "n_seconds", "nNpages", " n_seconds", " n_lines", "s", "n_pages", "nNbytes", "nb_bits", "ln67bytes", "m_bytes", "n2bits", "n_files", " n_pieces", "block", "m_files", "g", "d", " n_resources", "n67files", "n_clips", "n67pages", "all", "n__lines", "n2bytes", "m_zip", "n2byte", "n67bits", "n96rows", " n_files", "_", "n96zip", "pos", "n67devices", "n_zip", "n2units", "ln_pages", "nb_bytes", "n_byte", "ln_bits", "n_devices", "N_lines", "n_resources", "id", "nNbits", "ln67pages", "ln67bits", "N_seconds", "m_rows", "N_pieces", "n__seconds", "n67bytes"], "offset": ["oton", "abyte", "seq", "location", "acl", "shift", "position", "buffer", "align", "address", "prefix", "Offset", "end", "op", "num", "id", "key", "o", "padding", "start", "axis", "afi", "set", "slot", "size", "ptr", "ipping", "off", "length", "origin", "transfer", "addr", "index", "fp", "meta", "attr", "pos", "len", "format", "phase"], "ret": ["ref", "code", "fin", "sr", "ft", "res", "info", "final", " RET", "cat", "flag", "red", "back", "no", "success", "rb", "att", " Ret", "id", "num", "rep", "db", "rets", "arr", "valid", "rl", "bit", "mt", "lit", "rev", "det", "RET", "re", "art", "nt", "reply", "rc", "let", "feat", "arg", "Ret", "rt", "ext", "status", "count", "alt", "reg", "resp", "match", "r", "result", "len", "val", "gt", "ut", "fun"], "data": ["batch", "uni", "buffer", "base", "next", "version", "input", "initial", "progress", "window", "bytes", "da", "content", "memory", "draw", "wa", "writer", "complete", "body", "code", "slice", "p", "empty", "actions", "storage", "media", "align", "reader", "buf", "di", "binary", "cache", "response", "xxx", "json", "value", "DATA", "attr", "load", "temp", "Data", "done", "byte", "d", "function", "send", "gz", "xy", "open", "str", "partial", "output", "parent", "size", "length", "ata", "header", "init", "info", "shift", "i", "aa", "image", "img", "config", "dd", "write", "o", "dat", "layout", "zero", "sample", "record", "device", "results", "mu", "database", "result"], "buf_len": ["buf1lif", "block_den", "buf_ln", "uf_length", "cb_size", "buf_den", "buf2size", "buf2length", "buff1len", "buff_size", "buffer_count", "buf_val", "buffer2base", "uf_l", "buf_l", "uf_len", "buf64len", "buf2lf", "buff_len", " buf_length", "buf1size", "buf2len", "buffer_pos", "buf00ln", "buf_size", "buf00log", "buf00den", "buffer2len", "buf64val", "buff_pos", "buf_lin", "buf_log", "buf_lf", "block_log", "buff1size", "block_len", "buf00len", "buf_base", "buf2l", "buf6count", "buff1lif", "buf2pos", "buf_count", "buf2lif", "buffer_length", "buf_pos", "buffer_base", "buf64length", "buf6len", "block_ln", "buf2lin", "buf1len", "buf_lif", "buff_lif", "buf6length", "buff1pos", "cb_len", " buf_l", "buffer_len", "buf6pos", "buffer2length", "buf1pos", "buffer_val", "uf_lin", "cb_length", "buf2val", "buf64base", " buf_lf", "buf_length", "buf2base", "buffer2val"], "local_qiov": ["local_idiov", "local_dqrolet", "local_dqominium", "local_quiop", "local_qimedia", "local_qovi", "local_giov", "local_dqiov", "local_piov", "local_pilib", "local_viov", "local_requiov", "local_requovi", "local_goyer", "local_requoyer", "local_quiov", "local_qiris", "local_dqmus", "local_qrolet", "local_quoyer", "local_quovi", "local_qilib", "local_dqimedia", "local_qominium", "local_Qiov", "local_qoyer", "local_quimedia", "local_quiris", "local_quliv", "local_dqiop", "local_Qiop", "local_vilib", "local_idominium", "local_Qimedia", "local_grolet", "local_quominium", "local_qumus", "local_qiop", "local_piris", "local_qliv", "local_dqliv", "local_idliv", "local_qmus", "local_requrolet", "local_idmus", "local_quilib", "local_qurolet", "local_piop", "local_Qrolet", "local_govi", "local_viris", "local_viop"], "iov": ["nih", "iop", "ione", "roxy", " nucleus", "iii", " virt", " hive", "gra", "yout", "uno", " misc", " gateway", "iris", " sensor", "gru", "iev", " destro", " continuity", "imedia", "kov", "oren", " multimedia", " module", "io", "nox", " reservoir", "liv", "audi", " io", "iw", " modem", "oyer", "odi", " cluster", "ibl", "mus", " lib", "ij", "wav", "eni", " ensemble", " eth", "iago", "imoto", " gif", " chic", " mech", "ilo", "iro", " bio", "club", "ahi", "drm", "rolet", "igroup", " compressor", "lov", " codec", "iol", "\u00ef", "ijah", "dyl", " cla", "ilib", "mu", " combo", "imi", "dq", " alloc", "iola", "obo", " gru"], "write_offset": ["writeCoption", "write___off", "write_option", " write_error", "write_operation", "writeCerror", "network_pos", " write_length", " write_option", "writeingsize", "writeingoffset", "writePpos", "write67off", " write_off", "write_len", "write_error", "write67length", "writeCoffset", "network_size", "network_len", "write_pos", "write___operation", "writePoffset", "writeingpos", "write___length", "writePlen", "write_size", "writePsize", " write_operation", "writeinglen", "network_offset", "write_length", "write___offset", "write67offset", "write_off", "write67operation"], "write_end_sector": ["write_start_section", "write_end_order", "write_endensection", "write_start_unit", "write_end_unit", "write_start_sector", "write_endensector", "write_end_section", "write_start_order", "write_endenunit", "write_endenorder"], "compressed_data": ["compressed___text", "compressed_value", "compressionedsize", "compressededsize", "compressionedresults", "compressededdata", "compared_memory", "compression_Data", "composed_value", "compressed_size", "compressed_results", "compression_data", "compression_results", "compulated_data", "compresseddkey", "compressed_body", "compressed___dat", "compressededresults", "compressededmemory", "compared_data", "compressed67data", "compressed_dat", "compressededkey", "compressed_key", "composed_text", "compressed_message", "composed_dat", "compresseddmemory", "compressed_next", "compulated_message", "compressionednext", "compressededvalue", "compression_next", "compulated_body", "compressed___data", "compressedednext", "compression_size", "compresseddvalue", "compressedddata", "compressed___value", "compulated_results", "compressioneddata", "compared_key", "compressed_memory", "compressed67text", "compared_value", "composed_data", "compressed67value", "compressed67dat", "compressed_Data", "compressed_text"]}}
{"project": "FFmpeg", "commit_id": "8bc80f8b24cb6f03ad209ce546ae594904c8b353", "target": 1, "func": "static int http_server(void)\n\n{\n\n    int server_fd, ret, rtsp_server_fd, delay, delay1;\n\n    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 2], *poll_entry;\n\n    HTTPContext *c, *c_next;\n\n\n\n    server_fd = socket_open_listen(&my_http_addr);\n\n    if (server_fd < 0)\n\n        return -1;\n\n\n\n    rtsp_server_fd = socket_open_listen(&my_rtsp_addr);\n\n    if (rtsp_server_fd < 0)\n\n        return -1;\n\n    \n\n    http_log(\"ffserver started.\\n\");\n\n\n\n    start_children(first_feed);\n\n\n\n    first_http_ctx = NULL;\n\n    nb_connections = 0;\n\n    first_http_ctx = NULL;\n\n\n\n    start_multicast();\n\n\n\n    for(;;) {\n\n        poll_entry = poll_table;\n\n        poll_entry->fd = server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        poll_entry->fd = rtsp_server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        /* wait for events on each HTTP handle */\n\n        c = first_http_ctx;\n\n        delay = 1000;\n\n        while (c != NULL) {\n\n            int fd;\n\n            fd = c->fd;\n\n            switch(c->state) {\n\n            case HTTPSTATE_SEND_HEADER:\n\n            case RTSPSTATE_SEND_REPLY:\n\n            case RTSPSTATE_SEND_PACKET:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLOUT;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_SEND_DATA_HEADER:\n\n            case HTTPSTATE_SEND_DATA:\n\n            case HTTPSTATE_SEND_DATA_TRAILER:\n\n                if (!c->is_packetized) {\n\n                    /* for TCP, we output as much as we can (may need to put a limit) */\n\n                    c->poll_entry = poll_entry;\n\n                    poll_entry->fd = fd;\n\n                    poll_entry->events = POLLOUT;\n\n                    poll_entry++;\n\n                } else {\n\n                    /* not strictly correct, but currently cannot add\n\n                       more than one fd in poll entry */\n\n                    delay = 0;\n\n                }\n\n                break;\n\n            case HTTPSTATE_WAIT_REQUEST:\n\n            case HTTPSTATE_RECEIVE_DATA:\n\n            case HTTPSTATE_WAIT_FEED:\n\n            case RTSPSTATE_WAIT_REQUEST:\n\n                /* need to catch errors */\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;/* Maybe this will work */\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_WAIT:\n\n                c->poll_entry = NULL;\n\n                delay1 = compute_send_delay(c);\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            case HTTPSTATE_WAIT_SHORT:\n\n                c->poll_entry = NULL;\n\n                delay1 = 10; /* one tick wait XXX: 10 ms assumed */\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            default:\n\n                c->poll_entry = NULL;\n\n                break;\n\n            }\n\n            c = c->next;\n\n        }\n\n\n\n        /* wait for an event on one connection. We poll at least every\n\n           second to handle timeouts */\n\n        do {\n\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n\n        } while (ret == -1);\n\n        \n\n        cur_time = gettime_ms();\n\n\n\n        if (need_to_start_children) {\n\n            need_to_start_children = 0;\n\n            start_children(first_feed);\n\n        }\n\n\n\n        /* now handle the events */\n\n        for(c = first_http_ctx; c != NULL; c = c_next) {\n\n            c_next = c->next;\n\n            if (handle_connection(c) < 0) {\n\n                /* close and free the connection */\n\n                log_connection(c);\n\n                close_connection(c);\n\n            }\n\n        }\n\n\n\n        poll_entry = poll_table;\n\n        /* new HTTP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(server_fd, 0);\n\n        }\n\n        poll_entry++;\n\n        /* new RTSP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(rtsp_server_fd, 1);\n\n        }\n\n    }\n\n}\n", "idx": 24542, "substitutes": {"server_fd": ["server__fp", "server_dir", "ser_fn", "server_td", "erver_dl", "server_handler", "http_td", "ser_fp", "server_fn", " server_fc", "server__fn", "server_dl", "server_fp", "server64fn", "http_FD", "server64fd", "erver_d", "server64fp", "http_dir", "ser_fc", "server_fc", "server_d", "http_fd", "server__fd", "erver_fc", "server_FD", " server_handler", "server__fc", "erver_fd", " server_dl", "server64fc", "ser_fd"], "ret": ["complete", "exec", "seq", "done", "callback", "queue", "del", "fail", "def", "sync", "rec", "err", "run", "sec", "req", " wait", "sleep", "gc", "status", "rx", "resp", "result", "wa", "len", "val", "fun"], "rtsp_server_fd": ["rtsp_server_cb", "rtsp_client_dc", "rtsp_server_dc", "rtsp_server_dl", "rtsp_ser_fin", "rtsp_server_buf", "rtsp_server_fc", "rtsp_erver_fn", "rtsp_server_fin", "rtsp_client_dl", "rtsp_client_handler", "rtsp_ser_fn", "rtsp_server_handler", "rtsp_client_fc", "rtsp_client_cb", "rtsp_server64fd", "rtsp_server64fn", "rtsp_server64buf", "rtsp_erver_buf", "rtsp_server64fc", "rtsp_erver_fd", "rtsp_erver_fc", "rtsp_ser_fc", "rtsp_client_fd", "rtsp_server_fn", "rtsp_ser_fd"], "delay": ["load", "skip", "day", "trial", "shift", "ll", "dy", "hold", "d", "ay", "pid", "shell", "data", "queue", "send", "pause", "del", "fail", "hide", "error", "dd", "duration", "def", "sync", "live", "rec", "repeat", "seed", "rel", "until", "start", "dl", "mode", "sel", "rate", "sec", "req", "length", "sleep", "timeout", "status", "da", "nl", "mu", "poll", "draw", "range", "wa", "ait", "stay", "val", "lock", "wait"], "delay1": ["sleep1", "sleepOne", "delayOne", "pauseOne", "waitOne", "pause1", "wait1"], "poll_table": ["pollgcourse", "server_table", " poll_cache", "poll_list", "server_list", "pollallcourse", "poll_cache", "server_TABLE", "poll_course", "server_entry", "pollalltable", "pollgtable", "pollallentry", "poll_TABLE", " poll_course", "pollgcache", "pollallcache", "pollgentry"], "poll_entry": ["pollallauthor", "ollallentry", "Poll_entry", "pollsauto", "pollappinc", " poll_source", "poll_enter", "ll_owner", "pollenelement", "polledsection", "live_Entry", "pollallenter", "select_table", "pollureresource", "blockselement", "pollableentry", "pull_entry", "search_section", "poll_no", "pollureowner", "pollPelement", "poll_cell", "pollingentry", "poll64enter", "poll_argument", "pollappsession", "pollPentry", "pollappelement", "exec_session", "exec_resource", " poll_package", "search_Entry", "poll\u00b7Entry", "poll_site", "poll\u00b7entry", "poll_ry", "blocksenter", "blocksentry", "pollallresource", "pollacentry", "pollerenter", "llappinc", "job_enter", "poll_ident", "search\u00b7response", "pollkentry", "pollureident", "pollensession", "pollerident", "syncerterm", "sync_element", "job_Entry", "polledentry", "poll_internal", "pollingsource", "pollacexit", "syncerentry", "poll\u00b7section", "liveureentry", "pollacterm", "polloextra", "job_entry", "block_auto", "pollappspec", "oll_author", "ollksite", "pollkelement", "pollfgroup", "pollappenter", "pollacresult", "job_source", "ollallexit", "poll64Entry", "pollallsite", "pollureentry", "pollablery", "poll_global", "search\u00b7section", "pollOsource", "poll_result", "polluresource", "poll\u00b7response", "blocksauto", "pollselement", "pollfreader", "pull_inner", "pollingenter", "selectertable", "pollkenter", "poll64entry", "pollureEntry", "liveurecomment", "pollkcell", "pollappauto", "search_no", "oll_exit", "llappspec", "pollurecomment", "search_element", "pollallexit", "ll_spec", "Poll_internal", "pollOtable", "pollfexit", "pollureextra", "llappowner", "pollingtry", "pollappentry", "liveureEntry", "poll_auto", "search_group", "pollaciterator", "pull_enter", "poll_author", "sync_entry", "pollerterm", "pollfno", "pollPreader", "Poll_table", "poll\u00b7setting", "pollenenter", "pollappowner", "ll_inc", "pollingelement", "pollscell", " poll_extra", "poll_exit", "Poll_enter", "block_entry", "pollOident", "poll_source", "searchfno", "poll_extra", "poll_iterator", "poll_see", "search_entry", "ll_entry", "searchfelement", "polledresponse", "oll_entry", "exec_enter", "poll64element", "pollallentry", "poll_resource", "poll_Entry", "searchfentry", "pollacglobal", "poll_element", "select_source", "search\u00b7Entry", "oll_reader", "poll_package", "pollalliterator", "selecterident", "pollsenter", "poll_setting", "polluretry", "pollensee", " poll_term", "poll\u00b7author", "pollfentry", "exec_see", "ollallreader", "pollfterm", "syncerreader", "syncerelement", "pollapptable", " poll_result", "selecterentry", "search_response", "pollerreader", "pollsentry", "poll_response", "llappentry", "pollureglobal", "live_comment", "poll_inner", "ollalliterator", "Poll_global", "pull_element", "pollfelement", "oll_setting", "pollacreader", "live_entry", "pollertable", "pollersource", "exec_argument", "pollacenter", "poll_term", "pollingEntry", "poll_group", "exec_ry", "poll_try", "pollurespec", "Poll_source", "pollerentry", "poll_comment", "pollappsource", "pollerinner", "select_entry", "searchfgroup", "pollableargument", "selectersource", "polloentry", "sync_term", "pollappsee", "pollacelement", "poll_inc", "pollPterm", "pollenentry", "exec_Entry", "search\u00b7entry", "pollksetting", "oll_iterator", "pollksite", "ollkauthor", "block_enter", "pollureinc", "poll_spec", "pull_cell", "exec_entry", "ollkentry", "poll\u00b7site", "pollfiterator", "poll_owner", "pollableenter", "pollkauthor", "select_ident", "polluretable", "pollopackage", "poll_archive", "live_try", "poll_session", "pollureenter", "block_element", "polleninner", "pollurepackage", "sync_reader", "pollingcomment", "poll_reader", "exec_element", "ollksetting", "poll_section", " poll_element", "polledEntry", "oll_site", "pollallarchive", "pollerelement", "pollurearchive", "exec_archive", "pollOentry", "liveuretry", "pollallsetting", "pollacsource", "pollallreader"], "c": ["exec", "sc", "cm", "k", "w", "dc", "cd", "p", "oc", "b", "m", "C", "cv", "d", "enc", "xc", "ec", "cur", "cr", "conf", "ct", "cb", "bc", "ce", "abc", "ch", "cmp", "e", "fc", "con", "ic", "cl", "vc", "s", "jc", "icc", "cc", "ctx", "ci", "cp", "cn", "mc", "cf", "rc", "co", "client", "cache", "sec", "lc", "ctrl", "h", "ca", "f", "tc", "n", "cu", "conn", "t", "coll", "v", "r", "nc", "l", "cs", "ac", "pc", "g"], "c_next": ["p_next", "c__sec", "p_new", "c__reply", "c_new", "c_sec", "c__next", "p_reply", "c__new", "c_reply", "p_sec"], "fd": ["fen", "fed", "socket", "fe", "cd", "dy", "enc", "ld", "fm", "cb", "lf", "nil", "cl", "nd", "dl", "fl", "dt", "cf", "ffff", "addr", "f", "fs", "dial", "fp", "sd", "draw", "df", "dn", "wait", "md", "none", "ds", "bd", "buf", "feed", "ff", "draft", "dir", "wd", "FD", "fx", "feat", "timeout", "fa", "func", "d", "fff", " d", "FH", "db", "fc", "wat", "err", "handler", "fb", "client", "fi", "length", "pipe", "sf", "poll", "pid", "dig", "DC", "dc", "xd", "fn", "bf", "dd", "td", "grad", "pd", "did", "loc", "dra", "ln", "win", "dist", "conn"]}}
{"project": "FFmpeg", "commit_id": "f3c0e0bf6f53df0977f3878d4f5cec99dff8de9e", "target": 0, "func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n\n                               const uint8_t *buf, int buf_size,\n\n                               int first_field)\n\n{\n\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n\n    int i, cid, ret;\n\n\n\n    if (buf_size < 0x280)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5)) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"error in header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf[5] & 2) { /* interlaced */\n\n        ctx->cur_field = buf[5] & 1;\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n\n    }\n\n\n\n    ctx->height = AV_RB16(buf + 0x18);\n\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n\n\n    av_dlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height);\n\n\n\n    ctx->is_444 = 0;\n\n    if (buf[0x4] == 0x2) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n\n        }\n\n        ctx->is_444 = 1;\n\n    } else if (buf[0x21] & 0x40) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n\n        }\n\n    } else {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n\n        ctx->avctx->bits_per_raw_sample = 8;\n\n        if (ctx->bit_depth != 8) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 8;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n\n        }\n\n    }\n\n\n\n    cid = AV_RB32(buf + 0x28);\n\n    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n\n        return ret;\n\n\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ctx->mb_width  = ctx->width >> 4;\n\n    ctx->mb_height = buf[0x16d];\n\n\n\n    av_dlog(ctx->avctx,\n\n            \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);\n\n\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n\n        ctx->height <<= 1;\n\n\n\n    if (ctx->mb_height > 68 ||\n\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR,\n\n               \"mb height too big: %d\\n\", ctx->mb_height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (i = 0; i < ctx->mb_height; i++) {\n\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n\n        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24555, "substitutes": {"ctx": ["sys", "cca", " context", "pkg", "qa", "support", "cb", "sync", "wx", "coe", "cmd", "cl", "cms", "vc", "fw", "cf", "sci", "conv", "window", "ca", "gc", "crit", "r", "nc", "kw", "cm", "anc", "c", "cv", "jp", "css", "cmp", "gpu", "ci", "utils", "cas", "tc", "cu", "coll", "que", "pc", "kt", "console", "np", "scope", "context", "d", "history", "xc", "component", "conf", "act", "mac", "cfg", "wcs", "cli", "Context", "cc", "cn", "cp", "client", "lc", "ctrl", "na", "ck", "_", "tx", "connection", "cs", "cam", "sc", "config", "cus", "bc", "kb", "id", "hub", "hw", "cpu", "loc", "co", "conn", "cpp"], "frame": ["fram", "framework", "thread", "slice", "sys", "family", "context", "image", "frames", "module", "buffer", "qa", "base", "config", "component", "jp", "cycle", "flow", "fr", "cmp", "coe", "cfg", "cpu", "process", "fw", "que", "fi", "setup", "cf", "feat", "conv", "co", "game", "buff", "iframe", "window", "ca", "Frame", "conn", "coll", "stack", "fp", "range", "tx", "val", "kt"], "buf": ["seq", "uf", "comb", "bag", "uc", "b", "exc", "batch", "pkg", "wb", "context", "auc", "cv", "fam", "grab", "bb", "Buff", "data", "queue", "buffer", "vec", "img", "rb", "br", "ab", "bh", "gb", "text", "cb", "config", "bc", "bf", "aka", "broad", "prop", "port", "bu", "proc", "pad", "cmp", "bed", "begin", "home", "BU", "cmd", "uint", "pb", "cap", "loc", "box", "fb", "cf", "ctr", "rc", "alloc", "feat", "conv", "Buffer", "cas", "buff", "src", "bg", "ha", "header", "func", "que", "fd", "msg"], "buf_size": ["buf__length", "buf_SIZE", "buf__SIZE", "buffer_SIZE", "buf_depth", "buf__size", "buf_large", "buf__depth", "buffer_size", "buffer_large", " buf_SIZE", "buf_length", " buf_length", " buf_depth"], "first_field": ["frontOfffields", "frontOfffield", "front_field", "frontOffbyte", " first_window", "firstvelfield", "front_fields", "firstamfield", "firstoffbyte", "first_byte", "firstofflevel", "firstOfffield", "firstamwindow", "firstOfflevel", "firstofffield", "front_byte", " first_channel", "firstOfffields", "first_window", "firstamchannel", "first_fields", "first_channel", "first_level", "firstvelwindow", "firstvelchannel", "firstOffbyte", "frontOfflevel", "firstvelfields", "front_level", "firstofffields", "firstamfields", " first_fields"], "header_prefix": ["extra__pad", "header_path", "header_sequence", "headeracsequence", "headeracprefix", "header__pre", "header_pre", "header__pad", "extra__pre", "header__path", " header_sequence", "extra_pre", "extra_path", "extra_prefix", "header_prot", "extra_pad", "extra__path", "headeracprot", "header_pad", "extra__prefix", " header_prot", "header__prefix"], "header_prefix444": ["header_prefix443", "header_pattern444", "header_wrapper444", "header_patternCustom", "header_pointer555", "headeracprefix602", "header_pointer444", "header_fix555", "headeracwrapperCustom", "headeracprefixCustom", "headeracprefix448", "header_pattern448", "header_sequence555", "header_pointer443", "header_pattern602", "header_sequence446", "headeracwrapper448", "header_fix446", "header_index448", "headeracwrapper602", "header_pointer446", "header_sequence444", "header_prefix448", "headeracwrapper444", "header_wrapper448", "header_wrapper602", "header_wrapperCustom", "header_sequence443", "header_prefixCustom", "header_prefix446", "headeracprefix444", "header_prefix602", "header_fix444", "header_prefix555", "header_fix443", "header_indexCustom", "header_index444", "header_index602"], "i": ["k", "b", "p", "c", "image", "uni", "d", "base", "ti", "mi", "ri", "io", "id", "li", "uri", "ii", "di", "ai", "ci", "fi", "I", "f", "j", "index", "ip", "iu", "pi", "ui"], "cid": [" cnt", " cids", "cids", "cfnt", "cfid", "cfids", "ucid", "ucids", "ucnt", "cnt"], "ret": ["std", "seq", "code", "obj", "res", "info", "cat", "flags", "back", "buffer", "cb", "bc", "def", "aux", "mem", "rev", "RET", "rc", "feat", "Ret", "resp", "result", "val", "desc"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559, "substitutes": {"pval": ["Pdata", "pVAL", "Pval", "Peval", "lpvalid", " pVAL", "fval", "Pvals", "pdata", "peval", "pvalid", "lpval", "cval", "lppol", "pVal", "Pvalue", "spval", "cdata", "tvalue", " pdata", "preval", "tVal", "speval", "prepol", "cvalue", "fpVal", "PVal", "cVal", "lpVAL", " pvalid", "prevalid", " peval", "pvalue", " pvalue", "spvalue", "fpvals", " pVal", "fvalue", " ppol", "pvals", "feval", "tval", "fpvalue", "spVal", "preVAL", "tvals", "ppol", "fpval"], "name": ["space", "ref", "code", "call", "param", "none", "image", "time", "data", "action", "base", "label", "no", "style", "config", "am", "on", "address", "type", "prefix", "version", "ame", "id", "alias", "self", "Name", "key", "cmd", "path", "group", "word", "new", "size", "part", "NAME", "named", "value", "n", "names", "nam", "init", "normal", "description", "block", "val"], "md": ["exec", "head", "nm", "cd", "ld", "add", "own", "dom", "self", "mem", "cmd", "nd", "mt", "dt", "dev", "nt", "mod", "MD", "sm", "da", "dm", "mm", "sd", "df", "code", "cm", "m", "ds", "ad", "bd", "diff", "mi", "def", "mp", "ma", "old", "di", "mb", "Cmd", "mand", "mc", "vd", "od", "managed", "meta", "fd", "node", "pt", "d", "data", "ms", "am", "mid", "db", "mode", "req", "ng", "hm", "dc", "hd", "dr", "doc", "kg", "dd", "mag", "o", "td", "amp", "pd", "grad", "dat", "rm", "mo", "pm", "amd", "conn", "ind", " MD"], "ptr": ["ref", "code", "slice", " pointer", "shift", "pt", "mount", "dr", "fd", "buffer", "rb", "br", "pointer", "address", "inst", "push", "port", "tr", "proc", "pad", "sth", "buf", "iter", "td", "adr", "val", "pb", "eth", "loc", "offset", "enter", "coord", "rc", "alloc", "req", "Ptr", "ctr", "addr", "length", "buff", "amd", "rt", "ext", "src", "pair", "inter", "ind", "attr", "ace", "tty", "pos", "pc", "desc"], "env": ["code", "obj", "sys", "np", "console", "scope", "exc", "context", "cv", "vs", "enc", "ec", "en", "config", "ct", "priv", "state", "ev", "end", "ea", "inet", "environment", "db", "e", "buf", "dir", "loc", "viron", "dev", "edge", "ctx", "eu", "size", "sec", "eni", "rc", "iv", "vm", "oa", "len", "addr", "rt", "nw", "conn", "vel", "net", "v", "pos", "nc", "que", "equ"]}}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578, "substitutes": {"env": ["exec", "txt", "code", "gui", "np", "iss", "exc", "engine", "c", "context", "cv", "enc", "vs", "ec", "qt", "en", "config", "conf", "rb", "opt", "bc", "priv", "inst", "ev", "ea", "environment", "proc", "e", "gov", "esi", "dat", "session", "ef", "nc", "enter", "viron", "ctx", "here", "eu", "energy", "eni", "cache", "req", "osc", "conn", "init", "erg", "org", "et", "que", "equ", "eng"], "frame_addr": ["frame1ptr", "thread_nr", "frame1address", "thread_addr", "frame_ptr", "frame1name", "frame__ptr", " frame_ptr", "frame__address", "frame__addr", "frame_name", "thread_address", "frame_nr", " frame_address", "thread_ptr", "frame__nr", " frame_name", "frame1addr", "frame_address"], "uc": ["exec", "sc", "uf", "this", "oc", "auc", "c", "UC", "context", "xc", "ec", "gnu", "config", "soc", "uca", "ct", "bc", "instance", "util", "self", "uh", "u", "fc", "con", "lu", "input", "ul", "unc", "cc", "ou", "ucc", "client", "ub", "rc", "mc", "com", "cf", "fat", "current", "lc", "uu", "um", "usc", "tc", "userc", "un", "uci", "org", "nc", "ac", "pc"], "host_set": ["hostnameadd", " host_name", "host_Set", "hostlexstore", "hostnamename", "hostlexset", "hostamset", "hostlexread", "hostnameset", "host_store", "address_set", "hostamSet", "auth_init", "auth_Set", "auth_clear", "host_clear", "host_name", "host_init", " host_add", "host_read", "hostlexadd", "address_store", "hostamclear", "address_read", "host_add", "address_add", "hostaminit", "auth_set"], "regspace": ["argspace", "argpace", "memspace", "argrange", "regpace", "ginrange", "ginarray", "ginpace", "argarray", "mempace", "regarray", "ginspace", "memarray", "regrange", "memrange"]}}
{"project": "qemu", "commit_id": "619d11e4631000f20318dec90b87f314272bfa4a", "target": 0, "func": "FWCfgState *pc_memory_init(MemoryRegion *system_memory,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           ram_addr_t below_4g_mem_size,\n\n                           ram_addr_t above_4g_mem_size,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"pc.ram\",\n\n                           below_4g_mem_size + above_4g_mem_size);\n\n    vmstate_register_ram_global(ram);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 24588, "substitutes": {"system_memory": ["runtime_image", "systemalmessage", "system_global", "runtime_program", "system_usage", "system_resource", "systemalvm", "system___media", "kernel_message", "systemalimage", " system_usage", "system_image", "system_message", "runtime_global", "kernel_image", "system___memory", "kernel_vm", "system_media", "runtime_memory", "system___usage", "system___resource", " system_media", "kernel_memory", "system_vm", "systemalmemory", " system_resource", "system_program"], "kernel_filename": [" kernel_memory", "kernelockplatform", "kernelfilesettings", "kerneldbfile", "kernel_settings", "kerneldbdirectory", "kernelockfilename", "kernel_platform", "kerneldbfilename", " kernel_file", " kernel_directory", "kerneldbsettings", "kernelockmemory", "kernelockfile", " kernel_settings", "kernellogmemory", "kernel_memory", "kernelfilefile", "kernel_file", " kernel_platform", "kernel_directory", "kernellogfile", "kernelfiledirectory", "kernellogfilename", "kernelfilefilename", "kernellogplatform"], "kernel_cmdline": ["kernel_hostline", "kernel_cmdfile", "kernel_bootfile", "kernel_hoststring", "kernel_bootline", "kernel_hostfile", "kernel_bootname", "kernel_cmdstring", "kernel_commandfile", "kernel_commandstring", "kernel_cmdname", "kernel_commandname", "kernel_bootstring", "kernel_commandline", "kernel_hostname"], "initrd_filename": ["initrdtprofile", "initaclmatconfig", "initrdallprofile", "initacl_profile", "initrdmatprofile", "initrdmatfilename", "initrdallconfig", "initrdallfilename", "initrdallsettings", "initrdtconfig", "initacl_settings", "initacl_filename", "initrdmatconfig", "initrdmatsettings", "initrd_settings", "initrd_config", "initrd_profile", "initacl_config", "initaclmatprofile", "initaclmatsettings", "initrdtfilename", "initrdtsettings", "initaclmatfilename"], "below_4g_mem_size": ["below_4g_memory_size", "below_4g_memory_name", "below_4g_mem_second", "below_4g_memxrate", "below_4g_mem_pos", "below_4g_mem\u00b7size", "below_4g_memory_sum", "below_4g_memssource", "below_4g_mem_sum", "below_4g_memsloc", "below_4g_memory_second", "below_4g_mem_name", "below_4g_memssize", "below_4g_mem_scale", "below_4g_memxscale", "below_4g_mem_source", "below_4g_mem_num", "below_4g_memory_pos", "below_4g_memory_num", "below_4g_memory_scale", "below_4g_memory_rate", "below_4g_memxsize", "below_4g_mem_rate", "below_4g_mem\u00b7loc", "below_4g_mem\u00b7source", "below_4g_mem_loc"], "above_4g_mem_size": ["above_4g_mem2size", "above_4g_mem_sum", "above_4g_memory_address", "above_4g_memory_offset", "above_4g_memory_sum", "above_4g_mem2offset", "above_4g_mem_num", "above_4g_mem1name", "above_4g_memory_name", "above_4g_memnaddress", "above_4g_memory_speed", "above_4g_mem_address", "above_4g_mem_scale", "above_4g_mem1size", "above_4g_memnsize", "above_4g_mem1num", "above_4g_memory_scale", "above_4g_memory_num", "above_4g_memory_size", "above_4g_mem_name", "above_4g_memnoffset", "above_4g_mem2address", "above_4g_mem_capacity", "above_4g_memory_capacity", "above_4g_mem_offset", "above_4g_mem_speed"], "rom_memory": ["rom___mobile", "rom_ram", "ram_mem", "drm_mem", "rom___memory", "ram_size", "ram_mobile", "drm_manager", "rom_size", "drm_ram", "rom___size", "rom_manager", "rom_mem", "rom___mem", "rom_mobile", "drm_memory"], "ram_memory": ["ramallmem", "gram_memory", "ram_mem", "rom_config", "gram_description", "ramallconfig", "gram_cache", "ram_cache", "ramallregion", "rom_mem", "ram_description", "ram_config", "rom_region", "ramallmemory", "gram_mem", "ram_region"], "guest_info": ["guest_hand", "guess_manager", "guess_conf", "guesterinfo", "guess_Info", "guest_Info", "guess_info", "guesterhand", "guess_hand", "guest_conf", "guest_manager", "guestermanager"], "linux_boot": [" linux_connection", "linux67boot", "linux__init", "linux_connection", "linux67config", "linux_disk", "linux_mount", "linux01connection", "linux_config", "linux__config", " linux_config", " linux_init", "linux01init", "linux01config", " linux_mount", "linux67disk", "linux__connection", "linux_init", "linux__boot", "linux67mount", " linux_disk", "linux01boot"], "i": ["p", "m", "b", "c", "info", "image", "ix", "instance", "mac", "io", "ui", "li", "ii", "ini", "cli", "ni", "ci", "im", "I", "n", "j", "ip", "init", "r", "pi", "in", "ib", "g"], "ram": ["gram", "RAM", "remote", "micro", "cm", "rom", "param", "RM", "gra", "dim", "arm", "image", "mount", "module", "sam", "pass", "buffer", "program", "img", "media", "config", "sum", "gam", "am", "address", "RGB", "broad", "lam", "iam", "region", "mac", "instance", "ra", "Ram", "range", "rw", "jam", "mx", "raw", "disk", "mem", "max", "resource", "rame", "process", "gem", "mode", "ray", "mc", "vm", "scan", "mor", "man", "AM", "win", "array", "amd", "MM", "sim", "mm", "null", "row", "nam", "machine", "memory", "container", "rum", "cam", "yan"], "option_rom_mr": ["option_ram_rm", "option_rom__mr", "option_rom_rr", "option_rom_lr", "option_mem\n", "option_rom__dr", "option_rom_rm", "option_ram_rr", "option_rom__rr", "option_rm\n", "option_ram_mr", "option_ram_dr", "option_mem_", "option_ram_nr", "option_rom_nr", "option_rm_", "option_rom_", "option_ram_lr", "option_rome_", "option_rom\n", "option_rom_dr", "option_rome\n", "option_rom__lr"], "ram_below_4g": ["ram_below_40gu", "ram_below_24gs", "ram_below_164gg", "ram_below_8gu", "ram_below_40gg", "ram_below_4gm", "ram_below_8gs", "ram_below_114gs", "ram_below_164G", "ram_below_24g", "ram_below_5gg", "ram_below_8d", "ram_below_40gen", "ram_below_4gs", "ram_below_2G", "ram_below_4G", "ram_below_8gm", "ram_below_8G", "ram_below_164gm", "ram_below_4gg", "ram_below_04d", "ram_below_fourG", "ram_below_2g", "ram_below_24G", "ram_below_4d", "ram_below_114g", "ram_below_8g", "ram_below_4gen", "ram_below_2gen", "ram_below_40d", "ram_below_164g", "ram_below_114gg", "ram_below_04g", "ram_below_114gu", "ram_below_24gu", "ram_below_04gs", "ram_below_fourgs", "ram_below_2gs", "ram_below_04G", "ram_below_5g", "ram_below_40g", "ram_below_04gu", "ram_below_40G", "ram_below_fourg", "ram_below_5gm", "ram_below_fourgen", "ram_below_8gg", "ram_below_40gs", "ram_below_5G", "ram_below_4gu"], "ram_above_4g": ["ram_above_4gas", "ram_above_5G", "ram_aboveM4s", "ram_above_4gs", "ram_above_fourl", "ram_above_4d", "ram_above_64b", "ram_above_8b", "ram_above_8G", "ram_above_29l", "ram_above_29g", "ram_above_504d", "ram_above_4eg", "ram_above_4b", "ram_above_04n", "ram_above_04gs", "ram_aboveMfours", "ram_above_9eg", "ram_above_8l", "ram_above_5gs", "ram_above_4gh", "ram_above_8n", "ram_aboveM4l", "ram_aboveMfourgu", "ram_above_4s", "ram_above_8gu", "ram_above_29gu", "ram_above_4G", "ram_above_4gu", "ram_above_04d", "ram_above_8g", "ram_above_4ga", "ram_aboveMfourl", "ram_above_4n", "ram_above_504gas", "ram_above_8s", "ram_above_5n", "ram_above_4l", "ram_above_9g", "ram_above_9ga", "ram_above_40G", "ram_above_04eg", "ram_above_04g", "ram_above_40gas", "ram_aboveM4gu", "ram_above_504g", "ram_above_256b", "ram_above_04ga", "ram_aboveM4g", "ram_above_fourg", "ram_above_fourgu", "ram_above_64g", "ram_above_64gh", "ram_above_29s", "ram_above_256gh", "ram_above_9G", "ram_above_256g", "ram_above_8gh", "ram_above_fours", "ram_above_04G", "ram_above_504gu", "ram_above_8gs", "ram_above_64gu", "ram_above_5g", "ram_above_40ga", "ram_above_40g", "ram_aboveMfourg", "ram_above_04gu", "ram_above_40gu", "ram_above_40eg", "ram_above_40d", "ram_above_04gas", "ram_above_256gu"], "fw_cfg": ["FW_cfg", "FW_config", "fw_config", "FW_states", "fwjcfg", "fw_state", "fwjstates", "fwjconfig", "FW_state", "fwjstate", "fw_states"]}}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603, "substitutes": {"vs": ["rs", "ses", "sk", "sys", "events", "ss", "ns", "va", "cv", "ts", "las", "ms", "ds", "forces", "conf", "verts", "ps", "vas", "state", "vers", "ks", "plugins", "bs", "css", "uses", "vals", "ys", "cs", "gs", "stats", "vc", "s", "http", "os", "sb", "obs", "services", "xs", "ums", "ents", "ls", "fs", "qs", "ves", "alls", "v", "acs", "vp", "VS", "sv", "env", "views"], "keysym": ["Keysys", "keyscm", "typesy", "typesem", "keysys", " keysyn", "keysem", " keysy", "Keysym", " keyscm", "typessym", "Keysy", "keyssym", " Keysyn", "typesys", "typesym", "Keysem", "keysy", " keysem", "typescm", "keysyn", "typesyn", " Keyscm", " keyssym", " keysys", " Keyssym", " Keysym"]}}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static void s390_virtio_device_sync(VirtIOS390Device *dev)\n\n{\n\n    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    ram_addr_t cur_offs;\n\n    uint8_t num_vq;\n\n    int i;\n\n\n\n    virtio_reset(dev->vdev);\n\n\n\n    /* Sync dev space */\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n", "idx": 24606, "substitutes": {"dev": ["w", "server", "der", "kick", "bug", "non", "dom", "self", "adv", "cmd", "valid", "controller", "lib", "dt", "model", "nov", "game", "mod", "de", "pack", "md", "user", "driver", "engine", "test", "ad", "diff", "debug", "def", "DEV", "di", "wd", "plug", "rad", "od", "root", "ver", "container", "block", "gu", "d", "ov", "data", "var", "conf", "pub", "av", "error", "ch", "ev", "gd", "client", "req", "reg", "cam", "ow", "dc", "info", "app", "api", "img", "config", "dd", "end", "flow", "die", "serial", "hub", "home", "device", "gh", "pro", "comment", "conn", "Dev", "v", "result"], "bus": ["use", "gen", "driver", "b", "engine", "cat", "mount", "usb", "back", "config", "conf", "us", "bug", "bc", " BUS", "pass", "ch", "sync", "io", "serial", "proc", "id", "port", "hub", "boot", "db", "feed", "buf", "self", "def", "bridge", "path", "http", "bit", "session", "Bus", "dir", "lib", "board", "cache", "device", "loop", "plug", "block", "connection", "lock", "BUS"], "cur_offs": ["cur67roots", "cur67off", "curProots", "cur_times", " cur_works", "cur_works", " cur_off", " cur_opens", "cur_tips", "curPoffs", "cur_roots", " cur_roots", "cur_sets", " cur_times", "cur_sticks", " cur_sticks", " cur_sets", "cur_opens", "curPopens", " cur_asks", "cur67offs", "cur_asks", "curPsticks", " cur_tips", "cur67sticks", "cur_off", "curPoff", "curPtips"], "num_vq": ["num_voltq", "num_vqs", "num_uq", "num_uid", "numOfvqs", "num_pq", "num_vqi", "num_voltqi", "num_vaqs", "numOfvz", "num_fQ", "num_vz", "num_xQ", "num_uvq", "num_svqs", "num_liq", "numOfvaqs", "num_lqs", "numacvq", "num_avqq", "num_evqu", "num_vaquad", "num_lqq", "numacuqu", "num_avqs", "numLvqu", "num_vsq", "num_uqu", "num_cvquad", "num_evq", "num_pqu", "num_vcq", "num_xue", "num_viq", "num_hqs", "num_vquad", "numOfvaquad", "num_usq", "numacuq", "num_hquad", "num_uvsq", "num_vqq", "numacvid", "numOfvquad", "num_uvqu", "numacvsq", "numOfvaz", "numLvq", "num_xq", "num_xqu", "num_svqq", "num_vue", "num_fqu", "num_vaz", "num_voltqu", "numacusq", "num_vcid", "num_avq", "num_vaq", "num_hq", "num_vcsq", "numOfvaq", "num_aviq", "numacvqu", "num_evqi", "numacuid", "numOfvq", "num_cvz", "num_hz", "num_vid", "num_vcqu", "num_vqu", "num_fq", "numLvqi", "num_cvqs", "num_uvid", "num_svq", "num_pQ", "num_lq", "numLvoltqi", "numLvoltqu", "numLvoltq", "num_fue", "num_cvq", "num_lqu", "num_lqi", "num_vQ", "num_pue", "num_sviq"], "i": ["gu", "k", "slice", "ski", "z", "yi", "info", "m", "p", "c", "b", "name", "d", "uli", "ix", "x", "api", "ti", "mi", "type", "phi", "qi", "it", "end", "ri", "id", "u", "e", "li", "o", "gi", "ji", "zi", "multi", "xi", "uri", "bi", "ii", "si", "di", "ai", "ni", "ini", "ci", "fi", "eni", "sup", "I", "ki", "chi", "mini", "n", "ip", "j", "index", "f", "y", "t", "iu", "v", "mu", "pi", "r", "ui", "l", "hi"], "vring": ["vmray", "bring", "vmro", " vsetting", "versionray", "jring", "vrings", "bining", "svding", "jining", "nvring", "fring", "qray", "jrings", "bray", "versionding", "versionring", " vding", "vding", "vstring", "quro", "svsetting", "mpc", "mstring", "svring", " vining", "brings", "vray", "vining", "fq", "vpc", "nvq", "vry", "quray", "versionsetting", "qury", "quring", "nvstring", "jray", "mring", "vmring", "vro", "svray", "qry", "mq", " vrings", "vmry", "vsetting", "nvpc", "qro", "qring", "fstring", "vq", "fpc", " vray"]}}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n", "idx": 24621, "substitutes": {"_src": [" _dest", "_dest", "_rc", "_img", " _source", " _usc", " _img", "_usc", "_source", " _rc"], "stride": [" strid", " strided", "Strider", " strace", "striided", "brine", "dividen", "strine", " strension", "slides", "hrance", "drine", "divide", "divIDE", "brider", "stided", "brance", "slided", "hride", "strid", "arrider", "divided", "striider", "striace", "Strided", "slIDE", "hrine", "hrride", "slension", "Strension", "strides", "StrIDE", "strride", "brace", "Striden", "stine", "stide", "brided", "Strid", "hrided", "brride", "arrided", "drid", "strIDE", "draine", "divider", "straine", " straine", "striide", " strance", "hrider", "Strides", "dride", "slide", " strine", "staine", "arriden", "strace", "strider", "Stride", "drider", "strided", "arride", "striden", "strension", "strance", "slider", " strider", "bride", " strides", "drided"], "i": ["my", "slice", "z", "ie", "p", "info", "m", "c", "d", "ix", "x", "me", "ti", "mi", "phi", "qi", "it", "ri", "io", "id", "is", "u", "e", "o", "li", "gi", "ji", "zi", "multi", "xi", "s", "uri", "bi", "ii", "si", "ai", "cli", "ni", "di", "ini", "ci", "fi", "eni", "vi", "ir", "I", "y", "f", "oi", "ip", "j", "ori", "index", "iu", "v", "mu", "pi", "init", "in", "ui", "l", "hi", "anti", "ami", "r", "g"], "dc0": ["disc0", " dc50", "c0", "nc18", "dc000", "ac00", "ac2", "rc50", "dc3", "ac000", "DC4", "mc0", "ac0", "DC00", "nc3", "cd0", "DCfe", "cd50", "mc4", "nc1", " dc3", "dc50", "DC2", "DC0", "DC8", "nc0", "rc0", "disc2", "dc1", "mc50", "dc4", "c1", "dc18", "rcfe", " dc18", "rc2", "DC000", "c18", "disc00", "dc8", "c3", " dc1", "disc000", "cd4", " dcfe", "dcfe", "cd8", "DC50", "dc00", "mc8"], "dc2": ["c2", "ctwo", "DC02", "lc1", "dc256", "c4", "c6", "cd2", "c0", "circ2", " dc256", "DC4", "DC1", " dcTwo", "rc02", "fc2", "fctwo", "cd6", "cd1", "circ4", "circTwo", "dctwo", "DC2", "DC256", "DC0", "dcTwo", "lctwo", "rc1", " dc4", "dc1", "circ256", "dc4", "c02", "fc1", "fc6", "c1", "rc2", "DCtwo", "cdtwo", "lc2", "lc0", "dc6", "dc02", "DCTwo", "rc4"], "dc0splat": ["dc00split", "dc0splitat", "dc0splatter", "dc0Plat", "dc1splAT", "dc2plat", "dc0Splatter", "dc1splatter", "dc0plAT", "dc0spat", "dc1splat", "dc00splats", "dc0Splat", "dc0ppat", "dc2plit", "dc0plugatch", "dc0plats", "dc0plit", "dc0Splatch", "dc0Split", "dc0spats", "dc2platch", "dc0spland", "dc00Plats", "dc0ppatter", "dc1Splat", "dc0PlAT", "dc00splAT", "dc0plugit", "dc0splitAT", "dc0ppater", "dc00PlAT", "dc0spit", "dc0splatch", "dc1splater", "dc2pland", "dc0splats", "dc0plugat", "dc0splater", "dc0splitatter", "dc2split", "dc0pland", "dc0Plit", "dc1Splatter", "dc00splat", "dc0plat", "dc0spAT", "dc0Splater", "dc2spland", "dc0split", "dc1Splater", "dc0SplAT", "dc0Plats", "dc0splAT", "dc0platch", "dc1SplAT", "dc00Plit", "dc00Plat", "dc0Spland", "dc2splatch", "dc0ppAT", "dc0splitater", "dc0plugand"], "dc2splat": ["dc1Spland", "dc1splAT", "dc2plat", "dc4split", "dc2islAT", "dc0plAT", "dc2splAT", "dc1splat", "dc2splare", "dc2plit", "dc0plit", "dc4plat", "dc2islit", "dc1Splat", "dc2Splat", "dc4plit", "dc2SplAT", "dc2pland", "dc2splar", "dc2Spland", "dc2slat", "dc2plar", "dc1spland", "dc2islare", "dc2slit", "dc4splare", "dc2split", "dc2Splare", "dc2Splar", "dc0plat", "dc2spland", "dc0split", "dc1Split", "dc4splat", "dc0splar", "dc2Split", "dc4plAT", "dc0plar", "dc2plare", "dc4splAT", "dc0splAT", "dc2slAT", "dc1SplAT", "dc4plare", "dc1split", "dc2slar", "dc2islat", "dc2plAT"], "src": ["rest", "remote", "sc", "rs", "obl", "sr", "rib", "dc", "transform", "c", "pixel", "camera", "image", "scene", "img", "rb", "config", "text", "gb", "component", "support", "cb", "rin", "cur", "inst", "sync", "supp", "url", "proc", "rss", "fc", "scl", "resource", "input", "rl", "http", "uri", "loc", "spec", "lib", "st", "https", "impl", "cli", "sel", "sb", "size", "ci", "rc", "scale", "sit", "iv", "feat", "channel", "sup", "rect", "source", "stream", "usc", "RC", "host", "core", "dest", "sl", "r", "chrom", "secure"]}}
{"project": "FFmpeg", "commit_id": "48aecf5a7dd8e914d44cb4210a09172dbd8d5d86", "target": 1, "func": "static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n", "idx": 24625, "substitutes": {"poutbuf": ["pallvec", "loutrb", "pallbuf", "lexbuff", "loutbuf", " poutport", "painbuff", " poutuf", "poutingbuf", "pexrb", " pallport", " poutvec", "pOutbuf", "pbootbr", "poutbag", "punuf", "poutbu", "pouport", "pdownbuff", "poffport", "pdownport", "poutbr", "pupbr", " pOutbuf", "ipoutbox", "paincb", "pupbox", "poutflo", " poutflo", "poutcb", "painbuffer", "poutervec", " poutbr", "pintrb", "puntab", "pallport", "pupuf", "pantbu", "pdownbuf", " pOutbuff", "pupcv", " pupcv", "poutport", "poffbuf", " poutrb", "pouterbuff", "pOutbr", "pupport", " poutcb", "poffbox", "poutcf", "pupcb", "pintuf", "puptab", "pupimg", "pdowncv", "pbootbuf", "loutuf", " pallbuff", " poutbag", "poutingbu", " pupbuf", "poutbox", "ipoutbuf", "poutercf", "pexbuf", "pbootcb", "pupbag", "pOutbuffer", "pouvec", "poutvec", "punbuf", "pupbuffer", "pintbuf", "ipoutvec", "poutbuffer", "poutimg", "poutbuff", "poutercv", "pupbuff", " pupvec", " pOutbag", "ipoutport", "poffvec", "ipoffvec", " poutcf", "pupbuf", "poutingflo", " pouttab", "pexbuff", "lexrb", " poutbuffer", "pouttab", "pbootbag", "puncb", " pOutbuffer", "pOutbag", " poutbuff", " poutcv", "pintbuff", "poubuf", "ipoffbuf", " pupcf", " poutbu", " poutimg", "pOutcb", "ipoffbox", "pexuf", "lexuf", "pupvec", "pantrb", "pouterimg", "lexbuf", "pouterbuf", " pallbuf", "pouterbuffer", " pOutcb", "poutuf", "poutrb", "pdownvec", "pallbuff", "ipoffport", "pdowncf", "poutcv", "painbuf", " pOutbr", "pantbuf", "pupcf", "pantflo", "loutbuff", "poubox", "poutingrb", " pallvec", "pOutbuff"], "poutbuf_size": ["poutbuf_scale", "poutbuf_capacity", "poutbuf_small", "poutbuf_loc", "poutbuf_max"], "sps_pps": ["sps__ppo", "sps__params", "sips_pps", "sps_pp", "sps___ppo", "spse___pps", "spse_pp", "sps___dds", "sps__dds", "sps_ppa", "sps___pp", "sps_ops", "spse_ppo", "sps_ppo", "spse___ppo", "spse___pp", "sips_ops", "sps_params", "sps___pps", "spse_pps", "sps__pp", "sps__pps", "sips_ppa", "spse___dds", "sps__ops", "sips_pp", "spse_dds", "sips_params", "sps_dds"], "sps_pps_size": ["sps_ppa_small", "sps_ppa_size", "sps_pps_core", "sps_ps_size", "sps_pps_num", "sps_pps_c", "sps_ppa_core", "sps_ps_ize", "sps_ps_small", "sps_pps_offset", "sps_ps_c", "sps_ps_offset", "sps_ps_num", "sps_pps_ize", "sps_pps_small"], "in": ["inside", "IN", "margin", "bin", "i", "p", "m", "image", "In", "inas", "x", "time", "ins", "end", "id", "into", "url", "e", "o", "min", "input", "at", "inf", "nin", "new", "inc", "isin", "inn", "amin", "win", "as", "current", "before", "include", "index", "a", "out", "ac"], "in_size": ["in64size", "in96length", "planvalsize", "out_size", "out_scale", "in64bytes", "plan_bytes", "invalcapacity", "in_capacity", " in_scale", "planvallength", "in_length", "invallength", "planvalcapacity", "out_length", "plan_length", "plan_size", "in96scale", "plan_capacity", "in64length", "planvalbytes", "invalsize", "invalbytes", "in_scale", " in_storage", "in64capacity", "in_bytes", "in96size", "in_storage"]}}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 24626, "substitutes": {"ctx": ["exec", "sc", "kw", "cm", "acl", "np", "console", "cca", "dc", "scope", "anc", "c", "pkg", "context", "cv", "module", "qa", "xc", "config", "component", "conf", "jp", "ct", "cb", "bc", "cy", "sync", "cmp", "fc", "cs", "chan", "hw", "cfg", "cmd", "cl", "vc", "cdn", "loc", "cli", "Context", "handler", "cc", "ci", "cp", "cf", "cn", "client", "utils", "sci", "conv", "mc", "git", "lc", "ctrl", "ca", "gc", "tc", "cu", "conn", "crit", "core", "nc", "tx", "connection", "pc"], "e": ["exec", "element", "fe", "er", "w", "ie", "none", "p", "m", "i", "c", "d", "se", "ae", "x", "ec", "eg", "eve", "pe", "ce", "ei", "end", "ev", "ea", "xe", "ne", "eps", "oe", "u", "ee", "es", "el", "o", "esi", "le", "edge", "eu", "h", "f", "y", "source", "n", "j", "de", "E", "entity", "be", "v", "event", "r", "l", "ed", "g"], "io_notify": ["io_nify", "io_verify", "io_signify", "io_disen", "io_noten", "io_verate", "io_Notifier", "io_notine", "io_notificate", "io_signpire", "io_notification", "io_nate", "io_failifier", "io_disify", "io_npire", "io_nonificate", "io_nen", "io_failen", "io_failification", "io_Notificate", "io_nonish", "io_verifier", "io_notish", "io_Notish", "io_verine", "io_signate", "io_notate", "io_signine", "io_nification", "io_navificate", "io_nonify", "io_disifier", "io_nine", "io_navish", "io_failpire", "io_signifier", "io_navifier", "io_Notify", "io_nonifier", "io_navify", "io_notpire", "io_notifier", "io_nifier", "io_signification", "io_failify", "io_disification"], "io_flush": ["io_flow", " io_flow", "io\u00b7flow", "iofflush", "io__flush", " io_lock", "io_lock", "iofsend", "iofclose", "auto_send", " io_flash", "io__lock", "iofsync", " io_sync", "io\u00b7clear", "io_flash", "auto_sync", "io\u00b7send", "auto_close", "auto_flush", "io_close", "io__flow", "io\u00b7sync", " io_send", "io\u00b7flush", " io__flush", " io__clear", "io_sync", "io\u00b7lock", "io__clear", "io_send", "io_clear", "io\u00b7flash", " io_clear", " io__lock", " io__flow"], "node": ["call", "server", "name", "callback", "module", "enc", "cb", "holder", "self", "ne", "seed", "nil", "object", "edge", "hop", "note", "n", "core", "content", "query", "document", "writer", "native", "remote", "obj", "none", "c", "empty", "storage", "wh", "live", "op", "cmp", "Node", "key", "resource", "path", "one", "ko", "leaf", "new", "target", "stage", "od", "root", "event", "block", "g", "load", "gen", "parse", "function", "no", "component", "nn", "loader", "open", "huge", "message", "cdn", "peer", "graph", "handler", "parent", "view", "N", "source", "nw", "null", "host", "connection", "post", "location", "tree", "package", "master", "fn", "instance", "id", "hub", "o", "loc", "inner", "local", "missing", "slave", "comment", "child", "index", "route", "ode"]}}
{"project": "FFmpeg", "commit_id": "40ad05bab206c932a32171d45581080c914b06ec", "target": 0, "func": "int float_near_ulp(float a, float b, unsigned max_ulp)\n\n{\n\n    union av_intfloat32 x, y;\n\n\n\n    x.f = a;\n\n    y.f = b;\n\n\n\n    if (is_negative(x) != is_negative(y)) {\n\n        // handle -0.0 == +0.0\n\n        return a == b;\n\n    }\n\n\n\n    if (abs(x.i - y.i) <= max_ulp)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n", "idx": 24629, "substitutes": {"a": ["pa", "i", "p", "c", "aa", "va", "d", "ae", "ab", "am", "ia", "A", "ea", "asa", "u", "e", "ma", "ba", "at", "ai", "ar", "sa", "as", "au", "f", "n", "na", "fa", "an", "alpha", "l", "ac", "area"], "b": ["k", "i", "p", "c", "wb", "lb", "bb", "xb", "base", "rb", "ab", "bd", "cb", "bp", "bs", "e", "o", "ba", "nb", "eb", "bi", "fb", "sb", "ub", "B", "abb", "f", "n", "j", "be", "v", "r", "l", "ib", "g"], "max_ulp": ["max_imp", " max_imp", "maxFfp", "maxFearly", "maxFulp", "maxFimp", "max_early", "max_fp", " max_fp", " max_zip", " max_pull", "max_pull", "max_zip", " max_early"], "x": ["xx", "w", "z", "i", "p", "m", "c", "d", "ix", "px", "ad", "ax", "cross", "X", "u", "wx", "e", "xy", "o", "xi", "dx", "l", "one", "ci", "fx", "xs", "xxx", "h", "f", "rx", "n", "an", "v", "ex", "tx", "g"], "y": ["w", "z", "yi", "i", "p", "dy", "oy", "c", "ay", "d", "yt", "bb", "type", "cy", "iy", "ym", "vy", "u", "yo", "ys", "ey", "e", "xy", "o", "ii", "Y", "yy", "zy", "ry", "h", "f", "ny", "j", "n", "t", "v", "ty", "ya"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}", "idx": 24631, "substitutes": {"avctx": ["AVlc", " avcv", "vercmp", "navcontext", "avcontext", "navctrl", "ajconn", "afcontext", "avectx", "avctl", "ajctx", "AVsync", "AVctrl", "camconn", "avdc", "avcv", "verlc", "AVcontext", "verctrl", "afsync", "avcoll", "avalloc", "afctrl", "avcca", "avcit", "versync", "evctl", "AVloc", "avalcontext", "avalctrl", " avloc", "camcontext", "avercontext", " avcmp", "averctrl", "afctx", "avalctx", "afca", "afgc", "avecoll", "avloc", "avctrl", " avctrl", "ajcit", "AVcas", "AVctx", "verctx", "AVctl", "aveca", "AVdc", "afcv", "AVgc", "avecontext", "evcontext", "AVconn", "avcmp", "verconn", "avsync", "avca", "evctx", "avecv", "aflc", "camctl", "avconn", "AVcit", "avalgc", "avaldc", "ajcontext", "AVcca", "averctx", "avalcca", "AVcoll", "avecca", "vercontext", " avca", " avcoll", "evconn", "avallc", "aveconn", "avedc", " avconn", "avgc", " avcontext", "camctx", "navcas", "avlc", "avcas", "vercit", "avercas", "navctx", "afcmp"], "context": ["sc", "subject", "package", "kernel", "acl", "scope", "driver", "definition", "parser", "document", "anc", "manager", "qa", "buffer", "data", "metadata", "text", "config", "component", "support", "address", "reader", "concept", "instance", "general", "aux", "resource", "input", "path", "object", "Context", "parent", "ctx", "cache", "channel", "current", "ca", "network", "index", "stack", "event", "memory", "container", "database", "result", "connection", "ce"]}}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648, "substitutes": {"cs": ["sc", "sk", "rs", "sys", "c", "ns", "cks", "ix", "CS", "ec", "ds", "gb", "cus", "ps", "cons", "ks", "sync", "ocr", "css", "cmp", "cms", "vc", "ics", "spec", "wcs", "cc", "ras", "cn", "ci", "cf", "ctx", "cas", "lc", "ls", "ca", "fs", "qs", "ced", "cing", "core", "acs", "nc", "ce", "pc", "ces"], "fdt": ["fdtm", "fdta", "fedtm", "FDn", "dln", "fdd", "dltm", "vdd", "vdit", "lft", "fedt", "lfd", "fdn", "dlte", "FDt", "vdt", "dfta", "FDte", "dft", "fedn", "dfd", "fdte", "fedte", "lfit", "fdit", "lfta", "dfit", "vdta", "dlt", "FDtm"], "offset": ["location", "slice", "shift", "position", "align", "delay", "address", "prefix", "Offset", "error", "end", "alias", "range", "o", "padding", "initial", "set", "start", "loc", "slot", "output", "size", "off", "length", "origin", "addr", "timeout", "part", "f", "limit", "index", "reset", "pos", "len", "phase"], "spapr": ["pAPn", "spagr", "pAPrs", "papn", "spagR", "spapeR", "spapsR", "scapl", "spapel", "spagrs", "paprs", "pAPR", "papR", "spagn", "scapsl", "spapl", "scapr", "spAPr", "spAPrs", "spAPn", "scapsR", "spAPl", "spapsl", "scapR", "papr", "spapn", "spAPR", "spapprs", "scapsr", "spaper", "spappR", "spapR", "spapsr", "spappn", "pAPr", "spaprs", "spappr"], "cpu": ["CPU", "processor", "node", "socket", "np", "chip", "dc", "c", "frame", "lb", "px", "clock", "component", "config", "bc", "loader", "platform", "instance", "sync", "proc", "linux", "gpu", "cmp", "boot", "fc", "unit", "coe", "hw", "prem", "GPU", "nic", "process", "nc", "cc", "ctx", "cp", "cn", "gp", "roc", "cache", "vm", "device", " CPU", "lc", "pai", "proxy", "CP", "conn", "core", "pu", "uci", "pc"], "env": ["gui", "args", "np", "scope", "exc", "cv", "shell", "enc", "ec", "en", "config", "conf", "style", "export", "opt", "state", "ev", "ea", "environment", "visor", "profile", "e", "path", "err", "dir", "ef", "estate", "viron", "exe", "energy", "skin", "eu", "eni", "esp", "ext", "core", "dest", "equ", "desc"], "pcc": ["Pcca", "jpck", " pcca", "pck", "Pck", " pck", "PCC", "jpCC", "Pcc", "pcca", " pCC", "pCC", "jpcca", "jpcc"], "segs": ["pega", "meg", "mega", "megments", "pegs", "peg", "persega", "megs", "persegments", "segments", "perseg", "sega", "pegments", "persegs", "seg"], "page_sizes_prop": ["page_size_Prop", "page_sizesingProp", "page_sizesingprop", "page_sizesingattr", "page_sizes_Prop", "page_sizes_attr", "page_size_prop", "page_size_attr"], "page_sizes_prop_size": ["page_sizes_prop64max", "page_sizes_prop_length", "page_sizes_prop_max", "page_sizes_prop64size", "page_sizes_Prop_size", "page_sizes_Prop_max", "page_sizes_prop_2", "page_sizes_prop642", "page_sizes_Prop_2", "page_sizes_Prop_length", "page_sizes_prop64length"], "pft_size_prop": ["pft_size_cp", "pft_sizeallprop", "pft_sec_comp", "pft_size_comp", "pft_sec_cp", "pft_size_opt", "pft_sec_prop", "pft_sec_opt", "pft_sizeallcp", "pft_sizeallopt", "pft_sizeallcomp"], "drc": ["dRC", "dirc", " dRC", "bdRC", "bdsc", "ldRC", "bRC", "bsrc", "brc", "Dsrc", "bdsrc", "adrec", "Drc", "bdc", "ldsrc", "bdrec", "drec", "dsrc", "bdbc", "adsrc", "adRC", " dbc", "adrc", "lddc", " dirc", "adbc", "ddc", "ldrc", "Dirc", "Ddc", "Dbc", "adirc", " dsc", "dbc", "DRC", "bdrc", "dsc", "ldbc", " dsrc", "adsc", " drec"], "drck": ["derce", "rrrick", "derck", "drct", "mircc", " drok", " drcus", "derok", " drkk", "dercc", "rrok", " drct", "mircus", "drkk", "drok", "Drce", "rrcc", "drrick", "drce", "derrick", "derct", " drk", "Drck", "Drk", "mirkk", "rrck", "errcc", " drce", "drk", "errkk", " drrick", "Drct", "errcus", "derk", "drcc", " drcc", "drcus", "mirck", "errck"], "drc_index": ["drc_id", "dsrc_index", "drcxlen", "dxc_id", "drc__i", "drc64label", "drc_len", "dxcxnum", "dRC_Index", "drcxid", "drc__position", "dsrc_i", "drc_position", "drc_label", "dxc_num", "dRC_index", "dsrc_label", "dRC_id", "dsrc_position", "dxcxid", "drcxnum", "drc_i", "dxcxindex", "drc64i", "drc__index", "dxc_len", "drcxindex", "drc64index", "drc64position", "dxc_index", "drc__label", "drc_Index", "drc_num", "dxcxlen"], "radix_AP_encodings": ["radix_max_encodings", "radix_max_encodesings", "radix_max_ENCODing", "radix_max_encODINGS", "radix_max_encodering", "radix_max_ENCodINGS", "radix_max_ENCODers", "radix_max_encODing", "radix_max_encODers", "radix_max_ENCODINGS", "radix_max_ENCODings", "radix_max_ENCoding", "radix_max_encodesers", "radix_max_encoding", "radix_max_encodesing", "radix_max_ENCoders", "radix_max_encodesINGS", "radix_max_encodINGS", "radix_max_encoderers", "radix_max_encoderings", "radix_max_encoders", "radix_max_encODings", "radix_max_encoderINGS", "radix_max_ENCodings"], "i": ["abi", "z", "p", "b", "c", "data", "ti", "interface", "qi", "it", "id", "is", "e", "multi", "bi", "ii", "si", "I", "f", "n", "ip", "j", "a", "iu", "pi", "ui", "l"]}}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void test_function(const TestStruct test_sample)\n\n{\n\n    int ret, i;\n\n    void **output_data  = NULL;\n\n    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,\n\n                                            test_sample.nb_samples_pch);\n\n    if (!afifo) {\n\n        ERROR(\"ERROR: av_audio_fifo_alloc returned NULL!\");\n\n    }\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n\n    }\n\n    printf(\"read: %d\\n\", ret);\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    /* test av_audio_fifo_peek */\n\n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n\n    }\n\n    printf(\"peek:\\n\");\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_peek_at */\n\n    printf(\"peek_at:\\n\");\n\n    for (i = 0; i < afifo->nb_samples; ++i){\n\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n\n        if (ret < 0){\n\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n\n        }\n\n        printf(\"%d:\\n\", i);\n\n        print_audio_bytes(&test_sample, output_data, ret);\n\n    }\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_drain */\n\n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n\n    }\n\n    if (afifo->nb_samples){\n\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n\n    }\n\n\n\n    /* deallocate */\n\n    for (i = 0; i < afifo->nb_buffers; ++i){\n\n        av_freep(&output_data[i]);\n\n    }\n\n    av_freep(&output_data);\n\n    av_audio_fifo_free(afifo);\n\n}\n", "idx": 24655, "substitutes": {"test_sample": ["testnsample", "writelsample", "testedsound", "test_case", "check_sample", "test_resource", "testedsample", "sampleableSample", " test_test", "savedsound", "testdcase", "testgshape", " test_scale", "testknode", "testablestring", "test_sequence", "test00ample", "testgsample", "txtkstage", "txt_stage", "testdexample", "seedvalpackage", "testndatabase", "test_group", "stageingsample", "stage_instance", "test_example", "testnample", "writelservice", " test_shape", "testedexample", "write_service", "testedcase", "check_database", "testabledata", "seed_package", "testdsound", "liveedsample", "testingsample", "test_instance", "testappsample", "liveedproject", "testvalgold", "txtknode", "sample_package", "testerspace", "test_stage", "save_sound", "test_project", "testmfolder", "sampleableslice", "txt_node", "testablecell", "stageinginstance", "testappinstance", "testvalresource", "testlsample", " test_component", "test_shape", "testureresource", "check00ample", "train_component", "test2instance", "testgtest", "test_space", "test_slice", "stage_group", "write_model", "testkstage", "test_cell", "testablegroup", "testuresample", "testappgroup", "testedproject", "testercomponent", "live_sample", "stageinggroup", " test_space", "test_test", "writelfolder", "testablestage", "write_sample", "test_model", "test_service", "check_phase", "testnphase", "testmservice", " test_group", "test_Sample", "testurepackage", "writelmodel", "test_data", "testfexample", "testedname", "testvalpackage", "testableSample", "test_node", "sample_slice", "txt_group", "liveedsequence", "testingscale", "testablegold", "testlfolder", "train_model", "test_component", "test00database", "test2example", "test_folder", "testablenode", "test_name", "sampleablesample", "testkgroup", "check00database", "sample_cell", "testfsample", "savedexample", "testvalsample", "testingexample", "testappexample", "testmsample", "test_string", "liveedname", "txtksample", "testlservice", "train_sample", "test00sample", "test_ample", "sample_string", "savedsample", "test_sound", "testersample", "test_database", "testedsequence", "test_phase", "txt_sample", "testlmodel", "testableslice", "test2group", "testuregold", "stage_sample", "train_phase", "test_scale", "seedvalsample", "save_sample", "sample_data", "testingcomponent", "save_case", "testdsample", "save_example", "test00phase", "live_sequence", "check00sample", "testerscale", "live_project", "testfcase", "test_package", "live_name", "seedvalresource", "txtkgroup", "seed_sample", "seed_resource", "testingspace", "testinggroup", "sample_Sample", "testggroup", "testmmodel", "testinginstance", "testfsound", "savedcase", "stageingexample", "test_gold", "check00phase", "testablesample", "testksample", "stage_example", "seedvalgold", "sampleablepackage", "check_ample", "seed_gold", "testableresource", "write_folder", "sample_sample", "testablepackage", "test2sample"], "ret": ["ref", "sr", "ft", "cat", "rf", "detail", "base", "att", "ct", "url", "mem", "arr", "valid", "mt", "det", "lit", "nt", "pet", "part", "reset", "f", "match", "r", "val", "gt", "code", "obj", "flag", "en", "def", "rep", "xt", "store", "pret", "key", "sur", "bit", "RET", "group", "let", "feat", "pat", "Ret", "len", "fun", "res", "usr", "data", "back", "rb", "success", "error", "all", "db", "al", "str", "get", "err", "re", "reply", "arg", "alt", "reg", "full", "post", "info", " RET", "cur", "br", "bf", "opt", " Ret", "pass", "id", "rets", "rl", "rev", "fit", "art", "html", "active", "rt", "ext", "result", "format"], "i": ["ref", "rest", "slice", "k", "ie", "p", "info", "yi", "b", "c", "ix", "x", "ami", "ti", "mi", "phi", "qi", "it", "end", "ri", "id", "rep", "io", "u", "key", "li", "rel", "gi", "o", "err", "multi", "bit", "xi", "uri", "ii", "ini", "si", "bi", "di", "ni", "ai", "ci", "eni", "I", "y", "mini", "f", "j", "index", "ip", "ori", "t", "init", "ind", "iu", "pi", "mu", "in", "ui", "l", "hi", "len", "val", "g"], "output_data": ["input_done", "output2size", "outputPlist", "outputingdata", "outputsdata", "output_results", "bytePlist", "output2format", "input_dat", "output_list", "outputeddata", "byte_list", "output_default", "outputingsize", "output_space", "byte_length", "outputPdat", "outputingdone", "response_bytes", "doublesdata", "outputPlen", "byte_len", "application_space", " output_format", "outputeddefault", "double_data", "response_space", "response_data", "input_bytes", "output_body", "application_data", "outputedvalid", "outputingdat", "input_default", "output_done", "outputingformat", "outputPbytes", "outputalldata", "outputsbytes", "outputallvalid", "output_format", "outputPdone", "application_buffer", "outputPbody", "outputPspace", "output_size", "outputPdata", "output_length", "application_alpha", "bytePdata", "output_bytes", "doublesresults", "output_buffer", "outputsresults", "outputingbody", "byte_data", " output_size", "outputedbytes", "outputallbytes", "output_len", "output_valid", "response_dat", "bytePlength", "double_results", "bytePlen", "output_dat", "input_valid", "input_body", "doublesbytes", "output_alpha", "outputalldefault", "input_data", "output2data", "double_bytes", "outputPlength"], "afifo": ["afiffoin", "afihos", "afigoo", "afiffo", "aflifano", "aftifoo", "affifn", "afefo", "failo", "afiferano", "afilos", "affn", "afifol", "affifio", "aff\n", "afiferiso", "afiano", "avifano", "affipoo", "alifo", "afifi", "affifoa", "afiloa", "afifio", "afiffiso", "affiffo", "afild", "atifi", "afiolo", "afiplo", "avifi", "afifn", "afihno", "afinfbo", "affiffos", "afefos", "afiffos", "afipoo", "afofoo", "afiffio", "afippano", "avifiso", "afinfol", "afiffoo", "afiftode", "affifo", "afefi", "affifoo", "aftifno", "alifbo", "afispol", "aviferiso", "avinfiso", "afipode", "afianio", "failoa", "afinfdo", "avinfo", "afafo", "alifoi", "afianoin", "affi", "afihoa", "faifo", "afispoi", "affiffi", "atifoa", "afiffdo", "faifoo", "af\n", "afofdo", "afefio", "afofo", "affio", "afiplos", "aliolo", "aftifi", "aphefo", "afofio", "afefone", "aviferano", "aphifos", "aflifiso", "afifoi", "afafos", "afifdo", "afifano", "aftifo", "avinfdo", "affiffoa", "aftifoa", "afafi", "aftifode", "afipo", "affiffone", "afipno", "afifto", "aifo", "alioloi", "afinfo", "afiferoff", "ab\n", "afifoo", "affifode", "afipli", "aifoa", "aviploff", "afinfoo", "afigoa", "aifone", "afifone", "aliolol", "aifi", "afioloi", "afifno", "aftifone", "aviplos", " af\n", "afifoin", "aviplo", "afiffone", "afilno", "afigd", "afianos", "avifero", "affiffio", "affifno", "afefoin", "affipode", "atifone", "avifos", "afilo", "afiloff", "afifode", "afiffd", "afiolol", "affifi", "afofn", "afifos", "afifiso", "affifone", "faifoa", "avifo", "avifdo", "avifoff", "affipo", "afippoff", "aflifo", "afiploa", "afippiso", "afiffn", "affipno", "atifo", "afifero", "afifbo", "afiffoa", "affo", "afispo", "aphefio", "faifd", "afigo", "aphefos", "aphifoin", "afifoa", "affifos", "afiffi", "alifol", "afiffno", "avifoo", "avipli", "aliolbo", "aphefoin", "afiploff", "afiftoo", "afiolbo", "afiloo", "afinfoi", "afili", "afafone", "afinfiso", "failoo", "afiftno", "faild", "aphifio", "afefoa", "afiplone", "aphifo", "affiffno", "affiffn", "avinfoo", "aviferoff", "afippo", "afispbo", "afofi", "afofiso", "afifoff", "afiho", "afifd", "aflifoff"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n", "idx": 24668, "substitutes": {"dest": ["temp", "node", "Dest", "rest", "comb", "done", "class", "dc", "dim", "wb", "destroy", "img", "opt", "global", "end", "cont", "orig", "delete", "buf", "ident", "outer", "loc", "flat", "di", " destination", "save", "target", "local", "feat", "dist", "source", "later", "src", "de", "route", "draw", "ignore", "large", "desc"], "line_size": ["line2SIZE", " line_address", " line0SIZE", " line_weight", "line0size", " line_small", " line_scale", " line_SIZE", "line__address", " line0size", " line0address", "line2scale", "line_scale", "line_address", "line0address", "line_small", "line0SIZE", "line2weight", "line__size", "line_SIZE", "line__small", "line__SIZE", " line0small", "line2size", "line_weight", "line0small"], "block": ["chain", "mask", "node", "slice", "bin", "p", "name", "pixel", "image", "filter", "function", "data", "buffer", "blocks", "label", "config", "check", "type", "bl", "circle", "end", "plugin", "line", "point", "unit", "cl", "outer", "Block", "loc", "object", "box", "output", "group", "parent", "cache", "channel", "shape", "device", "source", "ip", "out", "event", "pack", "lock"]}}
{"project": "FFmpeg", "commit_id": "5a08ba5381cf8d46034440163e71cd95748beceb", "target": 0, "func": "static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)\n\n{\n\n    Hnm4VideoContext *hnm = avctx->priv_data;\n\n    GetByteContext gb;\n\n    uint32_t writeoffset = 0, count, left, offset;\n\n    uint8_t tag, previous, backline, backward, swap;\n\n\n\n    bytestream2_init(&gb, src, size);\n\n\n\n    while (bytestream2_tell(&gb) < size) {\n\n        count = bytestream2_peek_byte(&gb) & 0x1F;\n\n        if (count == 0) {\n\n            tag = bytestream2_get_byte(&gb) & 0xE0;\n\n            tag = tag >> 5;\n\n            if (tag == 0) {\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n            } else if (tag == 1) {\n\n                writeoffset += bytestream2_get_byte(&gb) * 2;\n\n            } else if (tag == 2) {\n\n                count = bytestream2_get_le16(&gb);\n\n                count *= 2;\n\n                writeoffset += count;\n\n            } else if (tag == 3) {\n\n                count = bytestream2_get_byte(&gb) * 2;\n\n                while (count > 0) {\n\n                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);\n\n                    count--;\n\n                }\n\n                bytestream2_skip(&gb, 1);\n\n            } else {\n\n                break;\n\n            }\n\n        } else {\n\n            previous = bytestream2_peek_byte(&gb) & 0x20;\n\n            backline = bytestream2_peek_byte(&gb) & 0x40;\n\n            backward = bytestream2_peek_byte(&gb) & 0x80;\n\n            bytestream2_skip(&gb, 1);\n\n            swap   = bytestream2_peek_byte(&gb) & 0x01;\n\n            offset = bytestream2_get_le16(&gb);\n\n            offset = (offset >> 1) & 0x7FFF;\n\n            offset = writeoffset + (offset * 2) - 0x8000;\n\n\n\n            left = count;\n\n\n\n            if (!backward && offset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (backward && offset >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (writeoffset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"Attempting to write out of bounds\");\n\n                break;\n\n            }\n\n\n\n            if (previous) {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            } else {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            }\n\n\n\n            if (swap) {\n\n                left         = count;\n\n                writeoffset -= count * 2;\n\n                while (left > 0) {\n\n                    swap = hnm->current[writeoffset];\n\n                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];\n\n                    hnm->current[writeoffset + 1] = swap;\n\n                    left--;\n\n                    writeoffset += 2;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24677, "substitutes": {"avctx": ["apcontext", "ahctx", "afcas", "ahcontext", "awconnection", "afconnection", "AVloc", "awcontext", "apctx", "awctx", "avcontext", "awcas", "afcontext", "afctx", "AVcb", "ahcas", "afcb", "avconnection", "avloc", "AVctx", "apcb", "aploc", "avcas", "ahconnection", "afloc", "avcb", "AVcontext"], "src": ["sc", "rs", "slice", "sr", "image", "scene", "data", "buffer", "storage", "img", "rb", "filename", "config", "cb", "bc", "inst", "sync", "url", "buf", "rob", "input", "loc", "sub", "lib", "sel", "ctx", "sb", "rc", "channel", "source", "stream", "func", "dest", "sl", "ssl", "secure"], "size": ["esc", "code", "sc", "args", "z", "ize", "c", "empty", "sized", "data", "storage", "sum", "en", "style", "address", "global", "Size", "unit", "SIZE", "max", "loc", "small", "fee", "mode", "sec", "scale", "shape", "length", "six", "timeout", "bytes", "cs", "len"], "hnm": ["hnmos", "wnmm", "hnms", "rnm", "knm", "dnc", "nnl", "rnfm", "wnM", "cnf", "cnmm", "hnf", "wnfm", "knl", "gnM", "hnr", "wnc", "wnm", "gnmm", "dnl", "ennsm", "cnm", "wnmos", "gnm", "nnm", "hnc", "hnfm", "wnms", "nnc", "hnl", "rnms", "rnM", "ennf", "gnf", "wnsm", "dnr", "hnmm", "dnf", "gnc", "hnsm", "cnc", "dnm", "dnmos", "ennm", "ennmos", "wnf", "knr", "knc", "gnfm", "nnr", "dnsm", "hnM", "gnms"], "gb": ["pg", "usb", "gru", "gom", "gs", "cmd", " cd", "lib", "ga", "rg", " camera", "game", " db", "uu", "buff", " storage", " mem", " bi", "gin", "bb", " scene", "storage", " eg", "gpu", " chunk", "tg", "mb", "ko", "binary", "ci", "gp", "git", "gio", "yg", "bm", "g", "gram", "gu", "byte", " co", " img", " rg", "rb", "gal", "gam", "gz", "gy", "region", "db", " rc", "cfg", "gn", " cf", "eb", "gd", "gae", "sb", " channel", " alloc", "cod", "ogg", " gl", " prog", "bf", "py", "bc", "broad", "kb", "hub", " msg", " GC", " conf", " gcc", "ctx", "GB", "rc", " kb", "gl", " gui", "greg", "gh", " disp", "gg", "bg", "gm", "ui", " now", "cgi"], "count": ["use", "call", "batch", "name", "keep", "cat", "time", "base", "label", "bug", "tail", "num", "cast", "max", "start", "Count", "pool", "cond", "number", "level", "current", "part", "limit", "list", "match", "core", "content", "val", "code", "low", "p", "cost", "c", "flag", "sum", "col", "counter", "cycle", "key", "process", "cache", "coll", "large", "len", "carry", "session", "parent", "cc", "more", "length", "connection", "skip", "close", "weight", "type", "id", "catch", "depth", "allow", "loc", "comment", "child", "index", "ind"], "offset": ["ref", "skip", "location", "gap", "slice", "shift", "position", "image", "data", "api", "attribute", "pointer", "align", "next", "address", "type", "error", "Offset", "tail", "sync", "end", "alias", "point", "patch", "o", "padding", "iso", "set", "start", "at", "loc", "fee", "slot", "output", "loss", "sort", "online", "number", "off", "length", "origin", "timeout", "part", "limit", "index", "operation", "alt", "attr", "alpha", "range", "pos", "et", "len", "layer"], "tag": ["use", "ref", "call", "tags", "date", "batch", "name", "cat", "label", "bug", "tail", "character", "word", "number", "hop", "uu", "go", "year", "match", "big", "code", "gap", "user", "option", "cost", "c", "flag", "Tag", "attribute", "sum", "pe", "debug", "port", "key", "patch", "bit", "month", "category", "cache", "feat", "bad", "rule", "ver", "meta", "attr", "block", "byte", "token", "class", "error", "sign", "parent", "length", "ack", "reg", "TAG", "post", "close", "image", "cur", "style", "type", "id", "catch", "loc", "role", "rate", "channel", "co", "round", "loop", "comment", "child", "ag", "format", "eng"], "previous": ["Precision", "reviously", "Previously", " prevert", "forepre", "forevert", "prepre", "reprev", "Preprev", "previously", "Previous", "foretext", "interpre", "recision", "perviously", "perprev", "revious", "prevert", "intervert", "intervious", " pretext", "forevious", "preprev", "percision", "intertext", "pervious", " prepre", "pretext"], "backline": ["worklined", "bookline", "backplane", "backside", "frontlined", " backwrite", "frontwrite", "booklink", "bookplane", "bookside", "frontlines", " backlined", "bottomplane", "firstline", "firstlink", "worklines", "backlink", "bottomline", "bottomlink", "bottomside", "frontline", "firstside", " backlines", "backlined", "backwrite", "firstplane", "workwrite", "backlines", "workline"], "backward": ["Backwards", "frontwards", "backforward", " backforward", "backboard", "BACKwards", "Backline", "frontforward", " backwards", "frontward", " backboard", "frontline", "backwards", "BACKboard", "BACKforward", "Backforward", "Backward", "Backboard", "BACKward"], "swap": [" swapping", "rewap", "chap", "chip", "swave", "swapper", "scapper", " swave", "rewapping", "swip", "rewag", "scap", " swag", " swapper", "Swap", "Swapping", "Swaps", "Swag", " swip", " swaps", "swapping", "swag", "rewaps", "scip", "swaps", "chapper", "chave", "scave"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720, "substitutes": {"sig": ["nsigma", "Sig", " sigma", "asigma", "gigma", "setsigh", "nslic", "pigh", " slic", "setsigs", "slic", " sigh", "Slic", "gib", "psigh", "SIG", "pigs", "setsigma", "sigs", "asig", "nsigh", " sib", "psigma", "pib", "psig", "nsIG", "sigma", "asigh", "sIG", "Sigs", "psigs", "pig", "setsig", "sigh", "pIG", "nsig", "gigs", "nsigs", "sib", " sIG", " sigs", "asigs", "pigma", "gig"], "ka": ["sc", "pa", "kernel", "qua", "cca", "ana", "va", "ta", "ama", "ae", "qa", "ket", "ia", "aka", "ea", "kb", "ua", "asa", "ma", "ba", "sta", "la", "eka", "ker", "Ka", "KA", "ko", "ai", "LA", "ctx", "ga", "cha", "oa", "sci", "sa", "ca", "ki", "au", "java", "na", "da", "ha", "kee", "ke", "ku", "kl", "ya", "ja", "kt"], "set": ["ner", "gen", "setting", "iss", "section", "parse", "context", "se", "SET", "test", "base", "send", "en", "config", "ise", "lex", "export", "def", "state", "end", "sync", "op", "sche", "store", "unit", "site", "el", "sets", "get", "dat", "start", "session", "spec", "loc", "kit", "sign", "ets", "stat", "vert", "setup", "Set", "update", "net", "ha", "init", "ind", "ex", "settings", "pack", "reset", "tx", "et", "ut", "ze"], "env": ["fen", "her", "etta", "exc", "shell", "enc", "chal", "gear", "export", "dict", "inet", "ne", "el", "ef", "ini", "dt", "define", "eq", "ette", "core", "et", "vel", "er", "engine", "me", "qt", "ec", "en", "Environment", "enter", "vag", "eni", "ench", "oa", "eh", "stage", "enh", "que", "equ", "gui", "ep", "args", "np", "console", "scope", "context", "global", "ev", "ah", "ea", "db", "e", "cfg", "session", "po", "init", " environment", "anne", "ze", "esm", "iss", "config", "ise", "environment", "ey", "esi", "dat", "viron", "ctx", "eu", "ext", "net", "conn", "eng"], "frame": ["build", "element", "call", "thread", "fe", "face", "module", "frames", "next", "ne", "nil", "el", "tick", "rame", "object", "define", "sequence", "cf", "game", "f", "Frame", "draw", "document", "val", "processor", "code", "body", "slice", "ock", "none", "b", "play", "c", "scene", "def", "state", "cycle", "fr", "boot", "line", "point", "shape", "update", "stage", "event", "block", "que", "ce", "file", "load", "node", "zone", "gen", "shot", "scope", "section", "parse", "context", "function", "data", "trace", "up", "za", "sche", "orig", "e", "step", "cfg", "message", "session", "fb", "setup", "fi", "view", "fake", "init", "plate", "ke", "lock", "ze", "fram", "framework", "seq", "position", "image", "dr", "raise", "style", "config", "ise", "figure", "feature", "flow", "die", "cpu", "sample", "vert", "iframe", "runner", "ind", "ace", "range", "show"]}}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730, "substitutes": {"bs": ["rs", "ses", "obj", "ss", "b", "bas", "ns", "lb", "ts", "bb", "vs", "blocks", "ds", "gb", "bc", "BS", "ps", "bl", "ks", "ins", "css", "gs", "ba", "pb", "Bs", "aws", "os", "fb", "sb", "sa", "ls", "fs", "js", "bt", "cs"], "s": ["S", "rs", "ses", "ss", "b", "p", "c", "ns", "d", "ts", "storage", "sq", "ds", "opens", "ps", "state", "ks", "sync", "su", "e", "es", "gs", "cs", "o", "spec", "si", "sym", "aws", "os", "sb", "services", "sa", "ls", "f", "service", "js", "n", "fs", "a", "sl", "sf", "settings", "ssl", "sv"]}}
{"project": "FFmpeg", "commit_id": "93c39db5f1544d1220488cfeb93bfe812a52f374", "target": 1, "func": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;", "idx": 24732, "substitutes": {"s": ["S", "sch", "ses", "sys", "w", "ss", "p", "c", "ns", "se", "ts", "sites", "sq", "ds", "opens", "ans", "us", "ps", "sg", "ins", "self", "su", "is", "e", "es", "gs", "sets", "ions", "set", "session", "spec", "sts", "sv", "less", "si", "sym", "os", "sb", "services", "xs", "sa", "ls", "f", "service", "qs", "js", "fs", "src", "a", "t", "sl", "settings", "ops", "ssl", "cs", "g"], "pkt": [" pk", "pct", " packet", "tpnt", "ppnt", "apkt", "Pnt", "pcht", " peth", "tpet", "preth", "Packer", "pracker", "packet", "ppk", " pct", " packer", " pet", "prkt", "pret", "Pk", " ppt", " pnt", "prcht", " pcht", "Packet", "ppt", "Ppt", "apacket", "tpacket", "ppkt", "tpkt", "pk", "ppacket", "pet", "peth", "packer", "pnt", "pracket", "apct", "appt", "Pcht", "Peth", "Pkt", "Pct", "Pet"], "st": ["rest", "std", "sc", "sk", "fe", "ST", "ft", "ss", "sn", "pt", "se", "sw", "sed", "ld", "ste", "ds", "stand", "ct", "bl", "ast", "ust", "inst", "St", "fr", "sth", "sp", "ess", "td", "sta", "str", "nd", "cl", "set", "start", "sts", "mt", "dt", "nt", "sb", "client", "est", "ist", "sa", "ost", "stage", "stop", "src", "stack", "t", "sd", "sl", "sf", "et", "sv", "ut", "kt"], "aiff": ["Aiff", "saiff", "aqa", " a8", "saIFF", " aqa", "gaqa", "aef", "Aif", "Aqa", "vaqa", "saisk", "naiff", " aif", "aisk", "gaef", " aiper", "aIFF", "naisk", " aef", "gaiper", "aif", "a8", "na8", "saif", "vaiper", "naif", "gaiff", "sa8", " aisk", "saqa", "AIFF", "vaef", " aIFF", "vaiff", "aiper"], "max_size": ["total_length", "maximum_length", "max64width", "max67size", "max64length", "max67shape", " max_align", "total67length", "total_size", "max_width", " max_age", "maximum_size", "maximumlexsize", "maxlexsize", "max_storage", "max67length", "max64shape", "maxlexwidth", "total67shape", " max_width", "total_shape", "max_sec", "total67size", "maximum_width", "maximumlexlength", "maximumlexwidth", "maxlexlength", "maximumlexstorage", "max_age", "max_shape", "maxlexstorage", "max_align", "maximum_storage", " max_sec", "max64sec", "max_length", "max64size"], "res": ["ares", "rs", "breaks", "errors", "nos", "resolution", "data", "blocks", "sum", "ms", "rez", "gr", "ps", "changes", "rows", "id", "rep", "rss", "es", "resh", "max", "min", "rh", "runs", "err", "rev", "ries", "re", "os", "ras", "result", "rate", "rc", "response", "ress", "req", "Res", "rem", "bytes", "des", "js", "rx", "details", "pres", "reg", "used", "resp", "row", "results", "content", " resolution", "ver", "ex", "r", "range", "ris", "cs", "len", "pos"], "size": ["esc", "code", "sc", "slice", "z", "page", "ize", "shift", "i", "empty", "sized", "resolution", "name", "c", "sn", "sw", "time", "data", "sum", "send", "sea", "capacity", "address", "speed", "Size", "form", "end", "id", "num", "sex", "ui", "e", "grow", "unit", "cs", "max", "SIZE", "min", "resource", "loc", "small", "fee", "si", "sec", "scale", "rc", "shape", "length", "ng", "bytes", "mini", "value", "go", "content", "sent", "core", "ace", "iz", "range", "pos", "large", "len", "eng"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 24742, "substitutes": {"arg1": ["ax2", " argone", "ax01", "argone", "Argone", "argument01", "Arg1", "ax1", "Arg2", "argument3", "axone", "Arg01", "argument1", "argument2", "ax3", " arg01", "arg01"], "arg2": ["ax2", "args2", "ax1", "arg4", "args4", "arg02", " arg02", "ark3", "argument3", " arg4", "ark1", "ark4", "ax4", "argument4", "ark2", "argument1", "argument2", "args02", "ax02", "args1"], "arg3": ["arg03", "Arg3", "args1", "ag53", "argument03", "Arg1", "Arg2", "args3", "argument3", "args53", "ag1", " arg53", "Arg03", "argument1", "ag03", "arg53", "argument2", "args03", " arg03", "ag3"], "farg1": ["fargs5", "fargA", " fax1", "farm1", "farg71", "fargs1", "fargs01", "fArgn", " farg81", "ferr3", "fax3", "farg01", "fang3", "fArg0", "ofang01", "Farg13", "fax81", "fang01", "fargs6", " farg0", " farg71", "fullarg1", "fag01", "faccess13", "farc01", "fagg71", "fArg10", "Fax3", "Fark3", "fig3", "Farg10", " fax81", "fArg4", "farc3", "fang17", " fargA", "farm3", "fang1", "faxone", "Farg6", "ofarg3", "ferr1", "fargsn", "faccess3", " fax3", "fark1", "fparam1", "ofang17", " fArg0", "Fargsn", "farg10", "farg0", "fag1", "fullarg3", "farg5", "Fargs1", "farg6", "fargone", "fArg81", "ferr13", "fargs2", " fArg1", "fparam5", "fang2", "fArg71", "ofarg17", "farg17", "Farg3", "Fax5", "ofarg01", "fArg2", "farg81", "Fargs6", "fargs3", "fark10", "fag3", "ofang3", "farc2", "fargsone", "fig17", "fax2", "fangA", "faxA", "Fark10", "fullarc2", "Fark13", " fArg2", "fark3", "farmn", "fig1", "Farg01", "fArg6", "farg4", "Fark1", "Fargone", "fark13", "fax71", " fax71", "faccess100", "faccess1", "fullarg2", "fargs4", "fagg1", " fArg4", "ofarg1", "fullarc3", "fark100", "fax5", "Faxone", "fagg3", "ofang1", "farm6", "fparamone", "fparam3", "Farg100", "Fark100", "fArg1", "farg13", "Farg1", "fArg17", "fax1", "farc1", "fagg81", "fArg01", "fargn", "fark01", "Fark01", "ferr100", "fullarc1", "fullarg01", "farg100", "fig01", "fArg3", " farg4", "Fargn", "fag10", "Fargs3", "Fax1", "fullarc01", "fargs0", "Farg5"], "farg2": ["fmember62", "fargs1", "frarcb", "forarg3", "fxarg62", "farc62", " farg02", "fang62", "foragn3", "fdate2", "fargs6", "floadtwo", "farg27", " farg72", "fparam2", "fload82", "fvar6", "fcat27", "fang02", "farg62", " fang72", "facktwo", "foragnTwo", "farktwo", "farcsecond", "fag27", "forarg2", "fmember2", "fArg4", "fang6", "fdateii", "fparamtwo", "fargTwo", "fxag27", "fargtwo", "frarc62", "fracksecond", "fxarg2", "fdate62", "fag2", "fangb", "farg6", "farc82", "fagnTwo", "farcii", "fargs2", "fvar72", "fack2", "fack82", " fArg1", "fang2", "farg72", " fang2", "fload2", "fargs02", "farg82", "fArg2", "foragntwo", "fmembersecond", "facksecond", "forargTwo", "farc2", "frack82", "fdateb", "frargtwo", "frarg62", "fxargsecond", "fmember27", "fxarg27", " fArg02", "farcb", " fArg2", " fang6", "frargii", "fark3", "frargb", "farkTwo", "fargs72", "farg4", "fargs4", "fang72", " fArg4", "fag62", "frarc2", "fagn2", "fparam3", "fark2", "fArg1", "fangii", "fcat62", "fvar02", "fagntwo", " fang02", "fagsecond", "frack2", "fargsecond", "fxagsecond", "fracktwo", "frarg82", "foragn2", "farg02", "fagn3", "floadsecond", " farg6", "fvar2", "frarg2", "frarcii", "fparamTwo", " farg4", "farctwo", "fcat2", "fcatsecond", "fargii", "frargsecond", "fxag62", "fArg02", "forargtwo", "fargb", "fxag2"], "farg3": ["frarg7", "fax4", " fax4", "farg7", "farg20", "fearg3", "fvalid40", "farg93", " fax03", " fax2", "fmag3", "farmthird", "cfax23", "ifarg3", "fax3", "fang3", "targ7", "fmagThird", "fplay03", "cfarg3", "targ03", "fgen3", "fackThird", "farm23", "fig3", "cfargthird", "fargs03", "tplay12", "fevalid3", "fArg4", "farg40", "fack3", "fearg20", "cfax03", "fgen7", "farm3", " farg03", "fvalid3", "frgen7", "farg15", "frarg3", "farg03", "tplay7", "fplay7", "cfaxthird", "cfax3", " fax3", "fig40", "fevalid20", "frgthird", "fearg40", "tplay03", "frarg93", "frgen93", "targ3", "fargThird", "ifax03", "frgen15", "fargs2", "farm03", "fgroup03", "ifaxthree", "fevalid40", "fang03", "fax7", "fack03", "fArg03", "fargthree", "ifaxThird", "ifargThird", "fvalid20", "fArg2", "frg3", "fmag03", "fard3", "fargs3", "fag3", "fplay3", "fax03", "fax2", "ifax3", "fmagthree", "ifargthree", "fig20", "farg23", "farg4", "cfarg23", "fargs4", "fplay12", "faxThird", "fgroup3", "fag20", "fgroup12", "tplay3", "fax15", "fang7", "targ12", "fearg43", "fard7", "farg12", "fang12", "fard15", "fgen15", "frg23", "ifarg03", "faxthree", "fag40", "cfarg03", "fackthree", "frarg15", "fArg3", "fgroup7", "fax23", "fig43", "fvalid43", "fevalid43", "frg03", " farg4", "fag43", "fgen93", "faxthird", "fax93", "fard93", "frgen3", "fargthird", "farg43"], "ft0_128": ["ft7_32", "ft2_256", "ft0__33", "ft11__257", "ft8_256", "ft0_64", "ft8_123", "ft11_257", "ft8_328", "ft1_1024", "ft0_123", "ft11_33", "ft11__33", "ft1_64", "ft1_256", "ft0_48", "ft0_1024", "ft2_128", "ft0__128", "ft0_32", "ft0_257", "ft11__1024", "ft0_328", "ft0_512", "ft7_256", "all", "ft8_128", "ft11__128", "ft2_48", "ft7_132", "_", "ft11_1024", "ft0__1024", "ft0__257", "ft0_256", "ft7_128", "ft2_1024", "unc", "ft11_128", "ft0_33", "ft1_512", "ft0_132"], "ft1_128": ["ft0_32", "ft0_65", "ft1A256", "ft0_127", "ft0_256", "ft1A48", "ft0_512", "ft1_65", "ft1A128", "ft1_123", "ft1_256", "ft1A65", "ft1_132", "ft1_127", "ft1_48", "ft0_48", "ft1_512", "ft0_132", "ft0_123", "ft1_32"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 24744, "substitutes": {"dc": ["exec", "gui", "sc", "cm", "DC", "cca", "uc", "cd", "auc", "anc", "c", "cit", "d", "context", "fd", "doc", "data", "ec", " DC", "ds", "config", "cr", "ct", "bc", "dp", "center", "central", "ea", "db", "fc", "td", "input", "vc", "dat", "cdn", "loc", "disc", "jc", "di", "enter", "dt", "cc", "ctx", "cf", "mc", "rc", "ga", "design", "lc", "gc", "tc", "da", "dm", "conn", "de", "duc", "arc", "draw", "df", "nc", "ac", "pc", "desc"], "l1": ["l0", "l2", "dl2", " ln", "dln", "ar0", "l8", "el3", "el1", "Lone", "dl8", " l0", "ll1", "ll8", "L1", "el2", "el0", "ar1", "L8", " l3", "lone", "L3", "L0", "ln", "ll2", " l2", "Ln", "dlone", " lone", "l3", "ll0", "ar2", "dl1", "dl0", "L2"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n", "idx": 24748, "substitutes": {"opaque": ["openaque", "opacity", "OPacle", "OPacity", "openacle", "OPaque", "openacity", " opacity", " opacle", "opacle"], "addr": ["md", "node", "seq", "i", "p", "dr", "ix", "x", "data", "align", "pointer", "ad", "address", "prefix", "mac", "port", "alias", "cmp", "point", "grad", "padding", "adr", "eth", "ord", "start", "offset", "slot", "edge", "coord", "target", "rc", "ptr", "oa", "device", "arg", "amd", "ext", "xp", "ip", "index", "alt", "host", "src", "osi", "adder", "attr", "ace", "pos", "val", "layer"], "value": ["w", "p", "m", "server", "name", "image", "x", "buffer", "data", "address", "type", "version", "Value", "write", "end", "flow", "port", "message", "padding", "valid", "offset", "target", "VALUE", "number", "array", "entry", "ip", "index", "v", "memory", "values", "age", "result", "val", "format"]}}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n\n{\n\n\n\n    if (err == 0 || errno != ENOENT) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    if (vs->perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_do_mkdir(s, vs);\n\n        v9fs_create_post_mkdir(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_do_symlink(s, vs);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_LINK) {\n\n        int32_t nfid = atoi(vs->extension.data);\n\n        V9fsFidState *nfidp = lookup_fid(s, nfid);\n\n        if (nfidp == NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 24754, "substitutes": {"s": ["sys", "server", "ns", "ts", "sq", "ps", "states", "sync", "sis", "self", "bs", "es", "stats", "south", "gs", "sie", "http", "xs", "serv", "f", "fs", "service", "status", "js", "ves", "qs", "t", "tests", "r", "ops", "native", "S", "b", "p", "m", "c", "se", "ds", "us", "state", "su", "is", "sets", "spec", "services", "h", "src", "settings", "its", "g", "rs", "ses", "ss", "bis", "ms", "ks", "uses", "e", "session", "sb", "ches", "ssl", "cs", "sv", "ys", "site", "o", "si", "os", "as", "ls", "v"], "vs": ["sys", "nav", "pg", "ns", "ts", "ps", "states", "bs", "vals", "es", "stats", "gs", "vc", "http", "lines", "dev", "cf", "xs", "serv", "ums", "f", "fs", "qs", "js", "ves", "r", "vp", "ops", "env", "vol", "views", "sk", "p", "c", "cv", "ds", "css", "ims", "path", "versions", "obs", "services", "vi", "wp", "lv", "alls", "func", "vo", "ver", "settings", "g", "rs", "ses", "nets", "args", "ss", "d", "Vs", "ov", "ils", "ms", "var", "verts", "ks", "ev", "open", "sts", "sb", "_", "VS", "sv", "cs", "params", "virt", "va", "vr", "vis", "ports", "vt", "isl", "type", "plugins", "vers", "write", "end", "eps", "ys", "os", "iv", "vm", "ls", "v", "posts", "values"], "err": ["yr", "call", "der", "rn", "cb", "bug", "mr", " Err", "url", "arr", "valid", "fer", "go", "wr", "eor", "r", "aster", "ter", "code", "ner", "er", "rage", "msg", "test", "ler", "erer", "fr", "proc", "iter", "work", "rar", "finder", "ver", "Er", "rr", "attr", "len", "icer", "far", "res", "oller", "rb", "var", "cr", "gr", "error", "ah", "orig", "nor", "cfg", "Error", "str", "rh", "magic", "order", "fi", "kr", "req", "ar", "ng", "ir", "fg", "count", "later", "resp", "erg", "org", "errors", "dr", "doc", "br", "ise", "end", "rl", "lr", "rev", "last", " error", "ctr", "y", "nr", "pr", "result"], "nfidp": ["nfidsr", "nfIdl", "nfidsd", "nfidc", "nffP", "nlfstrps", "ncfidscp", "nfidsP", "nfstrp", "nffp", "nfaidm", "nfaidps", "nlfidc", "nfidsl", "nfaidp", "ncfidd", "nfidP", "nfsidep", "nlfidps", "nfidscp", "nfidsc", "nfsided", "nlfstrp", "nfstrP", "ncfidr", "nfaidc", "nfIdd", "ncfidsd", "nfidr", "nfsidel", "nfIdcp", "nfIdp", "nfsidecp", "nfstrps", "ncfidp", "ncfidsr", "ncfidm", "nlfidP", "nlfidp", "nfidps", "nfidd", "nfidl", "nffr", "ncfidcp", "nfidsp", "nfidsm", "nfidsps", "nlfstrc", "nfaidr", "ncfidP", "ncfidsp", "nfstrc", "nfaidP", "nfidcp", "ncfidl", "nfidm", "ncfidsm", "nlfstrP", "ncfidsl", "nffm", "ncfidsP"], "ctype": ["octtype", "pttype", "cfype", "CTpe", "octype", "cfyle", "ctropy", "actyp", "ctypes", "CTtype", "catyle", "octypes", "ptypes", "CType", "cattype", "octropy", "cttype", "cpe", "actpe", "CTropy", "cype", "cfitle", "octitle", "acttype", "ptype", "CTyp", "ctpe", "CTypes", "octyle", "ctyle", "cftype", "catitle", "cyp", "catype", "actype", "ctyp", "ctitle", "ptropy"], "major": ["processor", "bor", "ner", "primary", "micro", "power", "driver", "none", "master", "server", "over", "der", "usr", "nir", "or", "oper", "next", "feature", "type", "gr", "mid", "version", "ior", "mac", "serial", "num", "Major", " Major", "patch", "older", "min", "valid", "inner", "ajor", "dev", "ser", "owner", "vert", "gener", "length", "current", "mod", "total", "post", "inter", "ver", "release", "pre", "olar", "ter", "little"], "minor": ["tenor", "tenion", "MINior", "MINor", "indor", "MINory", "anchOR", "MINOR", "Minion", "minior", " minour", "MinOR", "victior", "victOR", "tenOR", "minour", "tenored", "indory", "minory", "indOR", "indore", "minore", "minion", "minored", " minored", "MINore", "victor", "minOR", "Minor", " minior", "MINour", "anchor", "anchore", " minOR", " minion", "anchory", "Minored", "victour"]}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init (CPUState *env)\n\n{\n\n}\n", "idx": 24756, "substitutes": {"env": ["np", "ov", "enc", "ec", "en", "config", "conf", "cb", "priv", "ev", "end", "environment", "db", "e", "buf", "err", "cap", "dir", "ef", "viron", "fi", "erv", "iv", "fg", "conn", "bg", "v", "et"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759, "substitutes": {"spapr": ["Spapar", "Spappar", "spajra", " spapprd", "spaprar", "Spapprar", "sparpR", "spaprd", "wpapr", "spiprar", "sprapr", "spaptr", "spapsrar", "spapprar", "wpaptra", " spappra", "spapsR", "Spapr", "spaptsr", "sprapra", "spatrar", " spaprd", "sparprar", "wpaprar", "Spappr", "spaptrar", "spapra", "spappra", "sprapR", "spapprd", " spapra", "spraprd", "spajrd", "SpappR", "spipr", "spajR", "sparpr", "Spaprar", "sparpar", "wpapra", "spajr", " spapR", "wpaptsr", "spappR", "spipsr", "spaptra", "SpapR", "spapR", "wpapsr", "wpaptr", " spappR", "spapar", " spappr", "spapsr", "spipra", "spapsar", "spatsr", "spatra", "wpaptrar", "spatr", "spappr", "spappar"], "token": ["remember", "node", "secret", "socket", "element", "byte", "sid", "trial", "argument", "date", "option", "oken", "sn", "name", "function", "template", "api", "text", "type", "prefix", "version", "duration", "character", "column", "shadow", "sync", "KEN", "key", "seed", "o", "password", "code", "tick", "start", "session", "uri", "offset", "word", "sequence", "target", "number", "variable", "eni", "channel", "len", "length", "Token", "auth", "arg", "note", "timeout", "notice", "username", "rule", "stage", "wt", "prot", "limit", "year", "header", "cookie", "event", "document", "random", "tag", "format", "ok"], "nargs": [" nvalid", "pvalid", "lgs", "natret", "lvalid", "largs", "cparams", "ngs", "pparams", " narg", "natarg", " nparams", "cret", "nvalid", "carg", "nparams", "lparams", "natargs", "narg", " ngs", "pargs", "cgs", "cargs", "larg"], "args": ["ants", "secret", "rs", "seq", "argument", "res", "info", "parse", "context", "flags", "msg", "data", "doc", "var", "config", "ans", "next", "col", "ars", "vals", "stats", "aux", "gs", "arr", "extra", "cmd", "fields", "err", "Args", "strings", "ig", "aws", "ras", "ret", "files", "arg", "details", "names", "conn", "resp", "func", "results", "pos", "cs", "len", "params", "fun"], "nret": ["nrets", "crets", "nresult", "lRET", "creturn", "lret", " nlen", "cresult", "lresult", " nRET", "calt", "enrets", " nresult", " nreturn", "cret", "nRET", "nalt", "Nreturn", "lreturn", "enreturn", "clen", "Nrets", " nrets", "Nlen", "enalt", "Nret", " nalt", "nlen", "nreturn", "cRET", "enret"], "rets": ["ants", "secret", "rs", "breaks", "errors", "res", "info", "ns", "ats", "flags", "ts", "red", "items", "ds", "verts", "vt", "att", "def", "rules", "rows", "urs", "artifacts", "vals", " secrets", "aux", "protected", "tails", "fields", "runs", "strings", "lines", "RET", "ras", "uds", "ret", "urses", "utils", "nas", "cas", "ents", "ails", "fs", "details", "des", "alt", "results", "ieves", "ops", "pillar", "uments", "ints", "fun"], "call": ["exec", "use", "build", "code", "throw", "can", "invoke", "parse", "p", "play", "c", "close", "name", "cat", "function", "make", "ec", "send", "ell", "act", "def", "pass", "push", "end", "sync", "key", "e", "cell", "work", "create", "ul", "run", "cal", "roll", "cache", "co", "kill", "ack", "f", "mix", "apply", "init", "event", "Call", "block", "ac"]}}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n", "idx": 24761, "substitutes": {"out": ["ref", "temp", "code", "call", "OUT", "obj", "bin", "p", "m", "b", "c", "app", "image", "filter", "flag", "other", "data", "doc", "again", "up", "Out", "outs", "pass", "sync", "op", "all", "line", "o", "outside", "outer", "input", "at", "process", "inner", "flat", "object", "output", "group", "append", "parent", "copy", "new", "vert", "client", "cache", "co", "conv", "update", "array", "dot", "part", "source", "n", "list", "v", "init", "pre", "result"], "in": ["exec", "ref", "inside", "IN", "din", "bin", "this", "p", "m", "b", "c", "image", "In", "data", "config", "up", "again", "ins", "pass", "id", "ani", "rec", "orig", "line", "con", "arr", "work", "min", "input", "ic", "at", "inner", "ini", "inf", "ii", "ai", "nin", "binary", "new", "inn", "isin", "win", "update", "before", "part", "source", "n", "index", "a", "init", "ind", "pre", "ac", "table"], "order": ["use", "code", "er", "page", "info", "en", "next", "Order", "error", "end", "id", "rec", "orig", "iter", "seed", "reverse", "max", "min", "err", "dir", "ord", "oder", "start", "inner", "ini", "ii", "si", "ai", "grade", "sort", "rank", "asc", "record", "level", "first", "length", "orders", "part", "count", "rule", "limit", "list", "index", "init", "ind", "ordered", "r", "pos"], "direction": ["orient", "dc", "dim", "dy", "d", "oriented", "weight", "phase", "diff", "rec", "range", "directory", "depth", "step", "reverse", "linear", "unit", "dir", "di", "ii", "forward", "mode", "wd", "vert", "sort", "period", "ward", "quad", "length", "dist", "round", "gradient", "directed", "dest", "ind", "degree", "normal", "irection", "direct", "dn", "desc"], "tns_coefs": ["tns_coefds", "tns_coecs", "tns_coafs", "tns_coffsets", "tns_Coefs", "tns_coefments", "tns_coeffsets", "tns_Coefments", "tns_coeffments", "tns_coreferences", "tns_coffors", "tns_corefsets", "tns_coeffds", "tns_coefsets", "tns_cofferences", "tns_coecments", "tns_coffds", "tns_coffnames", "tns_coecds", "tns_coefnames", "tns_coecsets", "tns_coefors", "tns_coafds", "tns_Coffments", "tns_Coffs", "tns_Coefsets", "tns_coefferences", "tns_corefnames", "tns_corefs", "tns_coffments", "tns_coafors", "tns_Coffds", "tns_coffs", "tns_coeferences", "tns_coeffnames", "tns_coafsets", "tns_Coefds", "tns_coeffs", "tns_coeffors", "tns_Coffsets"], "ltp_used": ["ltnp_enabled", "ltps_used", "ltps_active", "ltp_using", "ltp_needed", "ltp_active", "ltnp_use", "ltnp_used", "ltnp_needed", "ltp_enabled", "ltps_using", "ltp_use"], "w": ["ow", "kw", "z", "c", "d", "sw", "wave", "weight", "wh", "wx", "iw", "wl", "wd", "wind", "win", "wp", "h", "aw", "f", "wt", "nw", "W", "v", "r", "nc", "wa", "wait"], "filt": ["ofilt", "tflt", "ofitter", "oflet", "tfilt", "tfitter", "flt", "efilt", "fitter", "tflet", "eflet", "eflt", "oflt", "flet", "efitter"], "start_i": [" start_p", "start_start", "end_j", "start_j", "start_I", " start_in", "start_p", "end_I", "end_i", "end_start", "start_in", " start_j"], "len": ["L", "seq", "fin", "z", "ll", "base", "en", "non", "end", "lon", "lf", "line", "el", "li", "Len", "min", "lu", "la", "start", "loc", "dl", "lib", "lin", "ii", "size", "ln", "length", "lc", "win", "part", "lp", "count", "f", "limit", "n", "list", "net", "lim", "ind", "pos", "l", "val", "lock"], "i": ["my", "k", "z", "yi", "p", "b", "m", "c", "ie", "info", "ix", "x", "api", "mi", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "ic", "o", "zi", "ji", "start", "xi", "uri", "ii", "ini", "si", "ai", "di", "ni", "bi", "cli", "ci", "fi", "eni", "I", "f", "y", "oi", "n", "ip", "index", "a", "mini", "iu", "ind", "v", "pi", "r", "ui", "l", "hi", "init"], "j": ["obj", "jit", "k", "z", "ie", "p", "m", "b", "uj", "adj", "c", "d", "pt", "x", "job", "jing", "je", "jo", "jp", "py", "next", "aj", "qi", "jj", "it", "u", "jam", "key", "e", "bj", "ji", "o", "li", "start", "jc", "ii", "journal", "ij", "jet", "oj", "length", "note", "json", "h", "f", "y", "jl", "js", "n", "pr", "t", "jon", "index", "q", "v", "J", "ind", "ui", "l", "dj", "jen", "ja", "g"], "inc": ["acc", "pp", "k", "z", "dc", "p", "page", "keep", "c", "adj", "d", "enc", "circ", "diff", "ins", "inst", "end", "cycle", "num", "rec", "fr", "step", "sp", "iter", "INC", "min", "zi", "start", "dir", "loc", "inner", "ii", "inf", "ini", "lin", "sign", "ci", "sort", "rc", "Inc", "inn", "req", "asc", "lc", "update", "win", "zip", "ir", "f", "count", "n", "index", "incre", "inter", "init", "ind", "r", "alpha", "nc", "pack"], "tmp": ["temp", "pp", "txt", "code", "obj", "done", "np", "slice", "nm", "page", "b", "p", "emp", "stuff", "app", "rup", "data", "test", "job", "frac", "img", "rb", "py", "area", "jp", "cb", "up", "front", "proc", "pad", "cmp", "ppo", "mp", "sp", "amp", "ff", "input", "dat", "start", "nb", "prep", "flat", "st", "output", "copy", "cp", "sb", "fb", "pm", "cache", "now", "sup", "zip", "wp", "part", "perm", "src", "fp", "v", "dest", "pre", "map", "result", "attr", "post", "table", "params"]}}
{"project": "FFmpeg", "commit_id": "69c1fe7c9c9bc85eebfc02c6a19caf7e88cd74ff", "target": 0, "func": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n\n                                AVPacket *pkt)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n\n    uint8_t *start, *end, *data = pkt->data;\n\n    ebml_master blockgroup;\n\n    char buffer[2048];\n\n\n\n    while (data_size) {\n\n        int duration = ass_get_duration(data);\n\n        max_duration = FFMAX(duration, max_duration);\n\n        end          = memchr(data, '\\n', data_size);\n\n        size         = line_size = end ? end - data + 1 : data_size;\n\n        size        -= end ? (end[-1] == '\\r') + 1 : 0;\n\n        start        = data;\n\n        for (i = 0; i < 3; i++, start++)\n\n            if (!(start = memchr(start, ',', size - (start - data))))\n\n                return max_duration;\n\n        size -= start - data;\n\n        sscanf(data, \"Dialogue: %d,\", &layer);\n\n        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",\n\n                     s->streams[pkt->stream_index]->nb_frames, layer);\n\n        size = FFMIN(i + size, sizeof(buffer));\n\n        memcpy(buffer + i, start, size - i);\n\n\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"Writing block at offset %\" PRIu64 \", size %d, \"\n\n               \"pts %\" PRId64 \", duration %d\\n\",\n\n               avio_tell(pb), size, pkt->pts, duration);\n\n        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n\n                                       mkv_blockgroup_size(size));\n\n        put_ebml_id(pb, MATROSKA_ID_BLOCK);\n\n        put_ebml_num(pb, size + 4, 0);\n\n        // this assumes stream_index is less than 126\n\n        avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n\n        avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n\n        avio_w8(pb, 0);\n\n        avio_write(pb, buffer, size);\n\n        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n\n        end_ebml_master(pb, blockgroup);\n\n\n\n        data      += line_size;\n\n        data_size -= line_size;\n\n    }\n\n\n\n    return max_duration;\n\n}\n", "idx": 24768, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "ss", "p", "b", "server", "c", "ns", "sam", "storage", "sq", "ds", "ps", "sg", "self", "su", "bs", "e", "stats", "gs", "o", "http", "session", "spec", "sv", "si", "os", "ctx", "sb", "client", "services", "sci", "sa", "ls", "f", "service", "qs", "fs", "n", "t", "a", "v", "sl", "sf", "ssl", "cs", "g"], "pb": ["pg", "pkg", "lb", "gb", "cb", "bos", "typ", "PB", "dl", "lp", "fp", "bps", "r", "vp", "ib", "summary", "p", "b", "parser", "ppa", "xb", "jp", "dp", "proc", "mp", "buf", "pit", "wp", "tc", "prot", "tp", "plug", "pc", "kt", "g", "pp", "uf", "np", "uc", "d", "rb", "bp", "plugin", "all", "db", "eb", "pl", "sb", "fb", "client", "length", "_", "pos", "pa", "api", "bf", "bh", "bc", "plugins", "platform", "hub", "python", "amp", "pd", "ctx", "pro"], "pkt": ["pct", "fnt", " packet", "matt", "facket", "apkt", "plct", "mcp", "patt", "mke", "pqt", "Patt", "pcp", "Pcp", "pke", "placket", "Pnt", " pcp", "lacket", " pqt", "Pdt", "mnt", "fct", "latt", "Pft", "packet", " pdt", "apnt", " pct", "lnt", " pnt", " pft", "Packet", "mqt", "apacket", "apqt", "pft", "apke", "mdt", "Pke", "fkt", "Pqt", "mkt", "apdt", "pnt", "plkt", "macket", "lkt", "mct", "Pkt", "pdt", "Pct", "plft"], "mkv": ["kw", "cpv", "mkw", " mkf", "kvd", "mkvd", "kvt", "mkc", "cpc", "ikw", "ikc", "mkvt", "skvd", "cpf", "kc", "ikv", " mkvd", "skv", " mkvt", "skf", "ikf", "mkf", "kf", "cpw", "skvt", "kv"], "i": ["idi", "slice", "z", "ie", "p", "info", "b", "c", "m", "position", "d", "uli", "ix", "uni", "x", "ti", "mi", "phi", "qi", "it", "id", "is", "line", "e", "iter", "li", "gi", "zi", "multi", "esi", "xi", "uri", "inner", "ii", "di", "si", "ai", "bi", "ni", "ini", "cli", "offset", "ci", "fi", "eni", "length", "part", "I", "y", "mini", "f", "n", "ip", "index", "j", "ice", "inter", "init", "ind", "pi", "ui", "l", "hi", "layer"], "size": ["use", "name", "time", "num", "max", "SIZE", "fee", "number", "six", "bytes", "n", "content", "core", "area", "ice", "body", "code", "ize", "engine", "c", "empty", "sized", "x", "storage", "sum", "en", "align", "mi", "address", "speed", "line", "ci", "eni", "shape", "timeout", "stream", "large", "len", "g", "send", "capacity", "Size", "e", "span", "extra", "small", "offset", "mode", "sec", "length", "page", "shift", "position", "weight", "member", "unit", "loc", "si", "scale", "ui", "l"], "line_size": [" line2size", " line_len", " line_sized", " line2len", "data_width", " line2scale", "line_len", " line_scale", "data_count", "line2scale", "line_scale", "line2sized", "line2len", "line_count", "data_size", " line2sized", "line_sized", "line2size", "line_width"], "start": ["use", "starting", "ie", "name", "time", "add", "next", "it", "seed", "max", "min", "set", "st", "current", "part", "j", "space", "Start", "slice", "p", "se", "x", "ad", "address", "line", "key", "sp", "work", "resource", "new", "middle", "before", "root", "block", "len", "load", "rest", "parse", "d", "started", "mid", "error", "e", "step", "span", "get", "offset", "grade", "like", "length", "source", "init", "alpha", "pos", "stop", "from", "shift", "info", "style", "cur", "type", "id", "pad", "si", "art", "scale", "index", "v", "ind", "range"], "end": ["exec", "use", "body", "p", "except", "End", "x", "enc", "send", "en", "END", "ad", "next", "style", "address", "ed", "id", "all", "e", "line", "feed", "begin", "open", "max", "nd", "until", "set", "after", "inner", "ent", "offset", "last", "append", "edge", "change", "ended", "est", "length", "update", "pend", "h", "f", "limit", "ending", "index", "desc", "content", "event", "pos", "post", "len", "stop"], "data": ["date", "batch", "frame", "frames", "time", "base", "next", "li", "input", "current", "window", "bytes", "da", "content", "memory", "area", "layer", "complete", "space", "body", "code", "gap", "slice", "p", "queue", "actions", "blocks", "media", "text", "ad", "address", "reader", "buf", "feed", "work", "resource", "di", "one", "new", "result", "response", "cache", "first", "middle", "timeout", "stream", "stage", "DATA", "block", "len", "load", "Data", "d", "delay", "three", "step", "open", "message", "offset", "parent", "video", "length", "source", "alpha", "pos", "shift", "image", "api", "dd", "id", "pad", "audio", "dat", "zero", "inner", "sample", "record", "scale", "channel", "device", "dist", "a", "results", "ui"], "blockgroup": ["poolGROUP", "byteGroup", "poolmap", "blockGroup", "BlockGROUP", " blockblock", "poolgroup", "byteblock", "blockblock", " blockGroup", "Blockgroup", " blockgroups", "rowgroups", " blockmap", "blockmap", "bytegroups", "Blockmap", "rowblock", "bytegroup", " blockGROUP", "blockgroups", "blockGROUP", "rowGroup", "rowgroup"], "buffer": ["code", "gap", "byte", "slice", "bin", "b", "p", "batch", "frame", "position", "image", "wave", "queue", "text", "read", "address", "duration", "texture", "uffer", "pad", "cube", "url", "buf", "line", "iter", "message", "resource", "input", "audio", "cap", "offset", "binary", " buffers", "result", "video", "cache", "channel", "Buffer", "shape", "length", "device", "buff", "transfer", "window", "f", "source", "null", "header", "memory", "block", "document", "layer"]}}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "substitutes": {"block_name": ["blockfprefix", " block_address", "block_prefix", "blockfaddress", " block_size", "blockfsize", " block_prefix", "blockfname", "block_address", "block_size"], "host_addr": ["hostacoffset", "block_addr", "hostacaddress", "hostacaddr", "block_id", "hostacsize", "block_offset", "host_size", "host_address", "host_name", "host_id", "block_address", "hostbname", "block_size", "hostbaddress", "hostbaddr", "hostbid", "host_offset"], "offset": ["ref", "slice", "position", "data", "base", "style", "align", "pointer", "address", "prefix", "Offset", "error", "end", "start", "set", "loc", "parent", "order", "off", "origin", "addr", "entry", "limit", "index", "range", "pos", "len"], "length": ["build", "seq", "ength", "slice", "family", "section", "info", "position", "mount", "base", "style", "read", "delay", "filename", "address", "type", "duration", "port", "pad", "url", "depth", "line", "padding", "angle", "library", "sequence", "view", "shape", "level", "block", "Length", "count", "limit", "pull", "index", "match", "range", "l", "len"], "opaque": [" oprobe", "opprobe", "ospatile", " opaques", "opaques", "opatile", "opcos", "ospaque", "opusatile", " opatile", "opusmac", "opusaque", "ospcos", " opmac", "Opaque", " opcos", "Opaques", "oppaques", "ospmac", "opuscos", "oppaque", "opmac", "Opatile", "Oprobe", "oprobe", "oppatile"], "mis": ["abi", "sys", "oci", "iss", "scope", "oc", "m", "tis", "isi", "cci", "ms", "vis", "mi", "Mis", "bos", "mac", "rec", "mos", "is", "mes", "proc", "mic", "miss", "session", "mn", "os", "fi", "mc", "mas", "cas", "fs", "pas", "osi", "acs", "voc", "pc", "params"], "reg_struct": ["reg2const", "regacint", "mod_return", "mod_feat", "Reg_feat", " reg_addr", "reg_addr", "regacnat", " reg_string", "Reg_int", "reg_int", "reg2struct", "rec_config", "rec_struct", "mod_struct", " reg_nat", "Reg_nat", "reg_feat", "rec_const", "reg_config", "reg_string", " reg_feat", "rec_construct", "reg_Struct", "reg2config", "regacstruct", "regacfeat", "reg_const", "Reg_struct", "reg_return", "reg_ptr", "reg_construct", " reg_ptr", "mod_config", "reg_nat", "reg2construct", " reg_Struct"]}}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void draw_bar_yuv(AVFrame *out, const float *h, const float *rcp_h,\n\n                         const ColorFloat *c, int bar_h)\n\n{\n\n    int x, y, yh, w = out->width;\n\n    float mul, ht, rcp_bar_h = 1.0f / bar_h;\n\n    uint8_t *vy = out->data[0], *vu = out->data[1], *vv = out->data[2];\n\n    uint8_t *lpy, *lpu, *lpv;\n\n    int lsy = out->linesize[0], lsu = out->linesize[1], lsv = out->linesize[2];\n\n    int fmt = out->format;\n\n\n\n    for (y = 0; y < bar_h; y += 2) {\n\n        yh = (fmt == AV_PIX_FMT_YUV420P) ? y / 2 : y;\n\n        ht = (bar_h - y) * rcp_bar_h;\n\n        lpy = vy + y * lsy;\n\n        lpu = vu + yh * lsu;\n\n        lpv = vv + yh * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            if (h[x] <= ht) {\n\n                *lpy++ = 16;\n\n                *lpu++ = 128;\n\n                *lpv++ = 128;\n\n            } else {\n\n                mul = (h[x] - ht) * rcp_h[x];\n\n                *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (fmt == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n\n\n        ht = (bar_h - (y+1)) * rcp_bar_h;\n\n        lpy = vy + (y+1) * lsy;\n\n        lpu = vu + (y+1) * lsu;\n\n        lpv = vv + (y+1) * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            /* u and v are skipped on yuv420p */\n\n            if (fmt != AV_PIX_FMT_YUV420P) {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (out->format == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24787, "substitutes": {"out": ["call", "OUT", "obj", "user", "w", "bin", "page", "name", "image", "data", "base", "img", "up", "again", "figure", "next", "prefix", "error", "global", "Out", "outs", "band", "sync", "io", "op", "version", "it", "line", "point", "o", "cmd", "input", "outer", "err", "at", "process", "object", "output", "one", "group", "model", "parent", "word", "new", "copy", "client", "down", "cache", "conv", "off", "device", "array", "dot", "window", "part", "source", "n", "conn", "a", "png", "init", "draw", "in", "result", "connection", "by"], "h": ["hm", "code", "k", "w", "z", "p", "m", "b", "d", "hd", "history", "ih", "bh", "H", "hh", "ch", "end", "ah", "both", "uh", "u", "hl", "e", "home", "o", "rh", "err", "http", "l", "hs", "f", "n", "t", "host", "ha", "q", "header", "v", "g", "r", "hr", "hi", "ph", "oh", "sh"], "rcp_h": ["rcjp_c", "rcpxc", "rcP_c", "rcpxh", "rcjp_height", "rcp2sh", "rcjpxh", "rcp_p", "rcp_c", "rcp_sh", "rcjpxheight", "rcp_height", "rcpamhm", "rcP_sh", "rcjpxc", "rcP_h", "rcpamc", "rcjp_h", "rcp2h", "rcpxheight", "rcjp_hm", "rcp2c", "rcP_p", "rcpxhm", "rcjpxhm", "rcpamh", "rcpamheight", "rcp_hm", "rcp2p"], "c": ["sc", "code", "cm", "k", "w", "dc", "i", "p", "b", "m", "C", "d", "xc", "ec", "cr", "ct", "cycle", "ch", "u", "e", "con", "cl", "ac", "s", "cc", "ctx", "ci", "cp", "cn", "mc", "cf", "cache", "co", "conv", "f", "n", "t", "a", "q", "arc", "v", "r", "nc", "cs", "ce", "g"], "bar_h": [" bar_hh", "bar_sh", " bar_rh", " bar_H", "bar_H", "bar_height", "car_c", "bar0H", " bar_height", "bar_z", "bar_rh", "bar_hh", "car_z", "bar_w", "bar_hp", "bar0sh", "bar_hm", "bar0height", " bar_sh", "car_h", "bar0h", " bar_hm", "car_hp", "bar_c", " bar_w", " bar_c"], "x": ["w", "z", "name", "time", "px", "cross", "u", "wx", "any", "el", "min", "yx", "xs", "f", "n", "j", "t", "r", "wa", "code", "k", "p", "m", "b", "en", "on", "pe", "X", "xt", "sex", "key", "ady", "work", "s", "fx", "xml", "xxx", "event", "ex", "in", "ph", "by", "xx", "this", "d", "xc", "gy", "e", "step", "xy", "dx", "change", "xp", "rx", "host", "full", "tx", "my", "zx", "i", "image", "ix", "sw", "ux", "plus", "id", "xi", "ctx", "ext", "ip", "index", "a", "v", "l", "hi"], "y": ["yr", "height", "ish", "xx", "w", "hy", "z", "yi", "i", "sy", "b", "p", "dy", "oy", "d", "ay", "yt", "yl", "sky", "py", "ye", "iy", "cy", "ch", "ym", "u", "yo", "ys", "ey", "xy", "o", "ky", "Y", "yy", "ry", "f", "ny", "n", "yn", "t", "j", "v", "yd", "ty", "l", "hi", "ya"], "yh": ["xf", " yhr", " ygh", "yf", "eygh", "eyh", "pyH", "xH", "Yh", "yH", "vyH", " yH", "YH", "vybh", "yhr", "ybh", "cyH", "yv", "vyh", " yv", "cybh", "yw", "eyv", "eyf", "xhr", "cyh", "pyhi", "vyw", " yhi", "pyhr", "ygh", "yhi", "xh", "eyhr", "eyhi", " yf", "xbh", "Ygh", "Yv", "xw", "cyw", "eyH", "pyh"], "mul": ["nmlu", "Mulus", "emulus", "Mlu", "amuli", " mule", "luli", "omul", "Mull", " mulus", "Mule", " mall", "MUL", "smuli", "Muli", "nmul", "Mul", "emuli", "tmall", "manduls", "Mur", "mush", "amular", " muli", "smUL", "mmush", "mule", "tmull", "mular", "omular", "amuls", "emull", "tmuli", "omall", "muli", "mmuli", " mur", "mlu", "Mush", "nmulus", "mur", "mandul", "lull", "omuli", "mandular", "muls", "mmull", "mull", "amul", " mular", " mUL", "mmul", "mall", "smlu", "manduli", "tmular", "mUL", "tmur", "mmule", " mush", " mull", "mmUL", "lul", "mulus", " muls", "tmul", " mlu", "nmUL", "emul", "smul", "lulus"], "ht": ["hm", "th", "hy", "ush", "ft", "pt", "hat", "yt", "hd", "mot", "force", "hard", "ih", "bh", "vt", "att", "ct", "hh", "ch", "uh", "hl", "wx", "hp", "hw", "iw", "hart", "lat", "rh", "vc", "fw", "tt", "dt", "hs", "wd", "gp", "ich", "wp", "gh", "rt", "lv", "wt", "hhh", "qq", "zh", "host", "q", "dq", "hr", "hi", "he", "yy", "gt", "sh"], "vy": ["xx", "hy", "yi", "sy", "dy", "oy", "wy", "yt", "px", "sky", "py", "nv", "vt", "gb", "cy", "iy", "yo", "ey", "xy", "ady", "vc", "si", "ky", "hi", "yy", "fy", "vi", "ry", "ny", "zh", "v", "ty", "sv", "ya"], "vu": ["ve", "vg", "von", "va", "wy", "vr", "nv", "vt", "ju", "yu", "su", "u", "tu", "vid", "lu", "vc", "vin", "ni", "vet", "vi", "uu", "uv", "lv", "cu", "qv", "vo", "nu", "pu", "v", "mu", "vp", "uci", "ui", "iu", "env"], "vv": ["ve", "vg", "xx", "von", "va", "cv", "hd", "ov", "vs", "eve", "vr", "nv", "vt", "hh", "tv", "su", "u", "wx", "hw", "vid", "vc", "vet", "vag", "nov", "vi", "xxx", "uu", "uv", "lv", "vd", "zh", "qv", "vo", "v", "nu", "vp", "sv", "yy", "dn"], "lpy": ["lpi", " lpa", " lpi", "mpu", "mcp", "lbsy", "Lmi", "dlpa", "mpe", "dlcp", "Lpi", "llpy", "llpu", "elpi", "dlmi", "lbpa", "elsy", "elpa", "llcp", "dlpy", "lcp", "dlpi", "dlsy", "lmi", "lbpy", "Lcp", "lsy", "llpe", "elcp", "Lpa", "lpe", "elpu", " lsy", " lmi", "mpy", " lpe", "lpa", "elpy", "Lpy", "lbpu", " lcp"], "lpu": ["lpi", " lpa", "lgpu", " lpi", "lcsu", "klgpu", "slpc", "elpc", "elsu", "lcu", "klpa", "liwu", "lipc", " lgpu", "lccu", "lipu", "Lpi", "Lsu", "lcpu", "Lpu", "elpa", "klsu", " lcu", "klpu", "slpu", "slsu", "klcu", "elwu", " lwu", " lpc", "lipa", "klpy", "Lpa", "klpi", "elpu", " lsu", "lpc", "lcgpu", "lwu", "lsu", "lpa", "elpy", "Lpy", "slpy"], "lpv": ["ppp", "pelf", "lpview", "pbf", "lipv", "LPj", "ilkvin", "dpva", "fpu", "lipj", "bpview", "pbj", "ilkv", "dlu", "lpversion", "fpv", "lipu", "dpv", "ppv", "bpv", "LPu", "ppu", "dpu", "lbva", "fpp", "bpu", "lipview", "lpf", "LPf", "pelu", "pelversion", "pbv", "pbversion", "pelv", "bpvin", "lipp", "ilkver", "lpver", "lpva", "bpp", "ilku", "LPversion", "lpvin", "lbu", "dlversion", "ppva", "lbv", "lpj", "pelver", "dlf", "lipf", "bpver", "dlv", "LPv", "fpview", "dpp", "lpp", "lbp", "lipversion", "pelvin"]}}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n", "idx": 24794, "substitutes": {"opts": [" ops", "opttt", "OPtt", "obops", "obts", "optt", "opt", " opt", "OPs", "obt", " optt", "optops", "obs", "opops", "optts", "OPts", "OPt", "ops", "OPops"], "_chr": [" _Chm", "_schrs", "_Chm", " _cortr", " _corr", "_schr", "_schsr", " _chrs", " _Chsr", "_chrs", " _chsr", "_Chrs", "_achr", "_ichm", " _Chr", "_cortr", "_achsr", "_ichr", "_chtr", "_corrs", "_corr", " _chm", " _Chrs", " _chtr", "_ichsr", "_Chr", "_chsr", "_corsr", "_Chsr", "_ichrs", "_chm", " _corrs", "_achrs", "_schtr", "_achm", " _corsr"], "file_out": ["file_ex", "file__path", "fd_window", "file_OUT", "file__out", "fd_in", "file_in", "fd_ex", "file_window", "file__in", "file__OUT", "fd_OUT", "fd_path", "file_path"], "fd_out": ["fd_Out", "file_Out", "fd_again", "FD_in", "FD_again", "file_OUT", "file_outs", "fd_in", "file_in", "fd_id", "fd_outs", "file_again", "FD_Out", "file_id", "fd_OUT", "FD_out"]}}
{"project": "FFmpeg", "commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "target": 1, "func": "int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int i, len;\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        H264Picture *sorted[32];\n\n        int cur_poc, list;\n\n        int lens[2];\n\n\n\n        if (FIELD_PICTURE(h))\n\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n\n        else\n\n            cur_poc = h->cur_pic_ptr->poc;\n\n\n\n        for (list = 0; list < 2; list++) {\n\n            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);\n\n            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);\n\n            av_assert0(len <= 32);\n\n\n\n            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                                  sorted, len, 0, h->picture_structure);\n\n            len += build_def_list(h->default_ref_list[list] + len,\n\n                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                                  h->long_ref, 16, 1, h->picture_structure);\n\n            av_assert0(len <= 32);\n\n\n\n            if (len < sl->ref_count[list])\n\n                memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n\n            lens[list] = len;\n\n        }\n\n\n\n        if (lens[0] == lens[1] && lens[1] > 1) {\n\n            for (i = 0; i < lens[0] &&\n\n                        h->default_ref_list[0][i].parent->f.buf[0]->buffer ==\n\n                        h->default_ref_list[1][i].parent->f.buf[0]->buffer; i++);\n\n            if (i == lens[0]) {\n\n                FFSWAP(H264Ref, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n            }\n\n        }\n\n    } else {\n\n        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                              h->short_ref, h->short_ref_count, 0, h->picture_structure);\n\n        len += build_def_list(h->default_ref_list[0] + len,\n\n                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                              h-> long_ref, 16, 1, h->picture_structure);\n\n        av_assert0(len <= 32);\n\n\n\n        if (len < sl->ref_count[0])\n\n            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n\n    }\n\n#ifdef TRACE\n\n    for (i = 0; i < sl->ref_count[0]; i++) {\n\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n\n                (h->default_ref_list[0][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                h->default_ref_list[0][i].pic_id,\n\n                h->default_ref_list[0][i].parent->f.data[0]);\n\n    }\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        for (i = 0; i < sl->ref_count[1]; i++) {\n\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n\n                    (h->default_ref_list[1][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                    h->default_ref_list[1][i].pic_id,\n\n                    h->default_ref_list[1][i].parent->f.data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24818, "substitutes": {"h": ["her", "hm", "hel", "ht", "th", "w", "z", "p", "m", "c", "kh", "hash", "b", "image", "hd", "hr", "history", "img", "ih", "hist", "en", "bh", "H", "hh", "FH", "ch", "ah", "uh", "u", "hl", "e", "hp", "hw", "o", "rh", "dh", "http", "s", "ul", "adh", "hs", "ctx", "gh", "eh", "f", "t", "host", "ha", "header", "enh", "v", "q", "zh", "g", "r", "l", "hi", "he", "ph", "oh", "sh"], "sl": ["sch", "sc", "SL", "tl", "ml", "sn", "p", "spl", "c", "sw", "api", "ph", "ih", "cur", "util", "fr", "url", "su", "sth", "hl", "al", "el", "cl", "s", "ul", "lr", "loc", "l", "pl", "fl", "si", "sel", "sb", "sec", "gl", "sa", "il", "lc", "serv", "ls", "f", "sil", "src", "coll", "Sl", "sf", "ssl", "kl", "sh"], "i": ["code", "z", "ie", "p", "b", "yi", "c", "d", "ix", "x", "ti", "phi", "qi", "ri", "id", "num", "ani", "ui", "u", "io", "e", "li", "ji", "gi", "zi", "start", "xi", "ii", "bi", "ini", "ai", "di", "ni", "si", "ci", "fi", "eni", "field", "I", "f", "count", "ki", "n", "j", "index", "ip", "chi", "y", "iu", "ind", "v", "pi", "pos", "r", "l", "mu"], "len": ["ref", "L", "fin", "z", "ie", "name", "ld", "num", "url", "split", "lf", "el", "li", "min", "lu", "lit", "lang", "dl", "lib", "lin", "fl", "syn", "part", "lp", "n", "limit", "val", "body", "p", "en", "ler", "lon", "line", "cache", "il", "fun", "bin", "bl", "compl", "span", "Len", "str", "err", "la", "led", "le", "size", "length", "lc", "count", "sil", "pos", "seq", "ll", "fn", "vec", "id", "ul", "rev", "lt", "vert", "ln", "elt", "conn", "lim", "v", "pre", "l"], "sorted": ["islied", "sitesressed", "opensressed", "fources", "unsort", "unsorter", "sorting", " sort", "gorted", " sorter", "gorting", "Sort", "isressed", "sources", "siteslied", "sorter", "isored", "psources", " sources", "unsorted", "sitesored", "psorted", "sitesorted", "opensored", "gorter", "Sorting", "psorts", "psorting", "slied", "opensorted", "sort", "openslied", "Sorted", " sorters", "sorters", "sored", "gort", "sorts", "forts", "Sorter", " sorting", "sressed", "forting", " sorts", "forted", "isorted", "Sorters", "unsorters"], "cur_poc": ["cur_mpac", "cur_Pect", "cur_joc", "cur_POC", "cur_peroint", "cur_fOC", "cur_vpect", "cur_Poo", "cur_proc", "cur_phpoc", "cur_mpoc", "cur_npoo", "cur_soc", "cur_perow", "cur_npac", "cur_vpock", "cur_Pow", "cur_vpac", "cur_peroc", "cur_point", "cur_pac", "cur_phproc", "cur_sac", "cur_soint", "cur_mproc", "cur_poo", "cur_Perc", "cur_ferc", "cur_wpoc", "cur_perac", "cur_npoci", "cur_phpoint", "cur_Proc", "cur_vpoc", "cur_perc", "cur_Poc", "cur_Pac", "cur_piac", "cur_pOC", "cur_wpac", "cur_wpoci", "cur_Point", "cur_pioc", "cur_piect", "cur_Pock", "cur_jOC", "cur_fac", "cur_jac", "cur_mpoint", "cur_wpoo", "cur_pock", "cur_pect", "cur_piock", "cur_sow", "cur_jerc", "cur_Poci", "cur_foc", "cur_pow", "cur_npoc", "cur_phpac", "cur_poci"], "list": ["chain", "L", "acl", "batch", "keep", "name", "base", "ld", "hl", "li", "arr", "cl", "lu", "lat", "set", "dl", "st", "part", "lp", "entry", "n", "match", "val", "code", "low", "tl", "p", "c", "x", "test", "queue", "en", "diff", "ler", "key", "old", "cache", "feat", "lv", "coll", "block", "g", "load", "rest", "this", "bl", "cont", "all", "e", "str", "err", "la", "pl", "cli", "parent", "view", "length", "lc", "count", "alt", "null", "full", "pos", "seq", "page", "config", "lex", "type", "id", "List", "rel", "ul", "gl", "lists", "listed", "loop", "LIST", "index", "v", "pre", "range", "l"], "lens": ["Lens", "slen", " loss", "elen", " lizes", "olening", " lenses", " lkens", "slens", "elenth", "lents", "lening", "lenth", "celkens", "olkens", "flents", "Lents", "elents", "lkens", "celening", "Lenth", "elowers", "Len", " lents", " lenth", "celens", "elenses", "olenth", "flens", "sloss", "loss", "eloss", "flowers", "lizes", "slenth", "slenses", "elizes", "flizes", " lowers", "lenses", "lowers", "slents", " lening", "olens", "Lenses", "Loss", "elens", "celenth"]}}
{"project": "qemu", "commit_id": "a3f409cb4a35d9aa6a4d24a7a1e05423e189cb7a", "target": 1, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->iommu_ops.notify_started = vtd_iommu_notify_started;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    if (x86_iommu->intr_supported) {\n\n        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;\n\n    }\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n", "idx": 24824, "substitutes": {"s": ["sys", "server", "ns", "ts", "vs", "sq", "ps", "states", "sync", "self", "u", "private", "es", "stats", "gs", "south", "set", "http", "sym", "current", "f", "fs", "qs", "js", "status", "service", "t", "n", "r", "native", "S", "p", "m", "b", "c", "se", "sports", "storage", "sum", "ds", "us", "state", "ins", "su", "is", "sets", "spec", "services", "h", "settings", "in", "its", "g", "rs", "ses", "scope", "ss", "d", "conf", "sg", "ks", "e", "has", "session", "hs", "stat", "sb", "sec", "ssl", "cs", "i", "plugins", "site", "o", "si", "os", "as", "ls", "a", "an", "l"], "x86_iommu": ["x86_xiommmu", "x86_iormmu", "x86_xiormmu", "x86_uiommou", "x86_uiomus", "x86_iormur", "x86_iompu", "x86_iompur", "x86_xiormu", "x86_xiormur", "x86_xiommur", "x86_uiommu", "x86_iommus", "x86_iormus", "x86_iompou", "x86_uiommus", "x86_xiommui", "x86_xiommu", "x86_iormui", "x86_uiomou", "x86_iormu", "x86_iammu", "x86_iammur", "x86_uiommur", "x86_uiomur", "x86_iomou", "x86_iommur", "x86_iomu", "x86_iomur", "x86_iommui", "x86_iompus", "x86_iammui", "x86_iormou", "x86_uiomu", "x86_iomui", "x86_iammmu", "x86_iomus", "x86_iommou", "x86_iommmu", "x86_xiormui"]}}
{"project": "FFmpeg", "commit_id": "ce19aec15b4291dc48e791d89a1f940babc22cdc", "target": 0, "func": "const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)\n\n{\n\n    av_assert2(p < end);\n\n\n\n    end-=2;\n\n    p++;\n\n    for(;p<end; p+=2){\n\n        if(!*p){\n\n            if     (!p[-1] && p[1]) return p - 1;\n\n            else if(!p[ 1] && p[2]) return p;\n\n        }\n\n    }\n\n    return end+2;\n\n}\n", "idx": 24829, "substitutes": {"av_restrict": ["av_distrupt", "av2refrict", "av_restrupt", "av_restricted", "av2refricted", "av_stricted", "av_Restricted", "av_resriction", "av_Restrupt", "av_distact", "av2restact", "av_resricted", "av_distriction", "av_strict", "av_district", "av_resrict", "av_refrict", "av_restact", "av_strupt", "av_refriction", "av_resact", "av_restriction", "av2restriction", "av_Restact", "av2refriction", "av2restrict", "av2refact", "av_districted", "av_Restrict", "av2restricted", "av_refact", "av_refricted", "av_stact"], "p": ["w", "pn", "next", "ps", "u", "start", "prev", "part", "lp", "f", "n", "j", "t", "fp", "r", "k", "b", "m", "c", "x", "P", "jp", "pe", "dp", "port", "op", "point", "sp", "patch", "path", "s", "one", "pat", "h", "tp", "pc", "pp", "np", "d", "data", "up", "bp", "e", "at", "parent", "change", "cp", "po", "q", "pos", "ap", "pid", "pa", "page", "i", "api", "end", "o", "after", "pm", "y", "pr", "ip", "a", "v", "pi", "pre", "l"]}}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n", "idx": 24847, "substitutes": {"env": ["exec", "exc", "server", "pg", "manager", "enable", "enc", "vs", "export", "dict", "self", "ne", "el", "dev", "dt", "ou", "entry", "core", "nc", "vel", "code", "obj", "er", "engine", "c", "cv", "queue", "ec", "qt", "en", "Environment", "eff", "proc", "em", "cache", "erv", "oa", "forge", "dep", "stage", "event", "que", "ce", "txt", "gui", "ep", "args", "np", "console", "scope", "context", "data", "conf", "global", "loader", "ev", "ah", "ea", "db", "e", "err", "session", "output", "nw", "init", "org", "pos", "theme", "app", "config", "end", "environment", "site", "dat", "viron", "ctx", "eu", "emb", "vm", "ext", "conn", "net", "v", "eng"], "arg1": ["val3", "arg3", "args2", "rgOne", "exec3", "Argone", "Arg1", "ag100", "arginf", " arg2", "ig01", "valOne", "tag100", " arginf", "arg61", "val251", "item1", "argumentone", "argument1", "argpre", "argument2", "rg1", "ig251", "ag61", "locOne", "loc1", "argonce", "Arg2", "ace1", "argumentonce", "argsone", "num251", "arg11", "numone", "argument0", "iteminf", "argumentOne", " argonce", "ag11", "arg251", "args1", "exec2", "Arg0", " argone", "num01", "argone", "argument01", "val01", "argument251", " arg3", "loc01", "argument3", "locone", "aceonce", "ag1", "argsinf", "arg100", "val1", "execinf", "igone", "ace100", "Arg01", "val2", "num1", "arg0", " arg01", "aceone", "tag1", "rgpre", "tag11", "exec1", "argOne", "valone", " argOne", "ace11", "valpre", "item2", "ig1", " arg0", "args3", "rg2", "argumentinf", "ace61", "ace2", "tag61", " argpre", "arg2", "itemone", "arg01"], "reg": ["exec", "rest", "Reg", "thread", "eng", "res", "arm", "flag", "eg", "config", "lex", "debug", "abc", "region", "rec", "proc", "orig", "mem", "bit", "pattern", "loc", "REG", "re", "ig", "stat", "sec", "rc", "rg", "feat", "addr", "rem", "arg", "round", "fun", "rule", "bg", "match", "g", "pre", "tag"]}}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853, "substitutes": {"opaque": ["OPque", "operaque", " opaques", "OPacity", "OPaques", "operaques", "defacity", "oplaques", "opaques", "defaque", "defque", "opercca", "oplcca", "oplaque", "Opaque", "Opaques", "defaques", " opque", " opacity", "opacity", "opque", "opcca", "Opque", "oplque", "operque", "Opcca", "OPaque"], "irq": ["risqs", "rinqt", " irqs", "iref", "iraf", "irque", "irry", "virquest", "risf", "IRqu", "iraq", "virflow", "ironq", "iraQ", "risq", "ireqs", " irf", "rinQ", "irquest", "IRf", "riQ", "ireq", "ierQ", "irflow", "ariq", "iriquest", "iriq", "ierq", "irtq", "ierqual", "irtqual", "rif", "IRq", "irequ", "iraqu", "arique", "ierqt", "irqu", " irry", "riqu", "ironqu", "ironQ", "ireQ", "irqs", "irtQ", "irf", "ariflow", "rinqual", "irQ", "IRQ", "ironf", "ariquest", "virque", "virq", "risry", "riq", "rinq", "irery", "irqt", "irique", "iriflow", "irqual", "irtqt"], "level": ["code", "thread", "scope", "lvl", "cost", "name", "enc", "weight", "style", "letter", "type", "id", "url", "method", "depth", "key", "point", "str", "path", "levels", "loc", "wl", "clean", "mode", "parent", "inc", "length", "round", "loop", "stage", "wall", "limit", "index", "coll", "full", "Level", "vel", "where", "layer"], "env": ["her", "fen", "code", "args", "console", "np", "er", "scope", "exc", "engine", "server", "context", "enc", "qa", "queue", "ec", "en", "config", "conf", "chal", "style", "dict", "ev", "ah", "ea", "inet", "environment", "loader", "ne", "end", "db", "e", "el", "password", "esi", "err", "ef", "nc", "viron", "que", "edge", "ctx", "here", "energy", "eu", "eni", "cache", "erv", "esp", "oa", "ench", "vm", "erb", "req", "forge", "conn", "net", "core", "v", "enh", "et", "vel", "equ", "eng"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n", "idx": 24855, "substitutes": {"bdrv": ["btrvt", "bgrf", "hdrvt", "hdrva", "bdrvm", "brrvt", "htrvm", "brcva", "btrva", "htrvt", "bdrvt", "btrv", "bsrc", " bsrv", "brrva", "bgrvr", "btrvm", " bsrvr", "htrva", "bdrf", "hdrv", "brcv", "brcvt", "htrv", " bdrc", "hdrvm", "bdrvr", "bsrv", " bsrf", "brrvm", "bsrf", "brcvm", " bdrvr", "bgrv", "bdrc", "bsrvr", "bdrva", " bsrc", " bdrf", "brrv", "bgrc"], "cmd": ["md", "node", "seq", "comm", "code", "head", "cod", "cm", "uf", "dc", "cd", "c", "pkg", "cat", "msg", "doc", "img", "config", "gz", "cb", "prefix", "opt", "ux", "dict", "bind", "mac", "dom", "method", "cmp", "cfg", "grad", "input", "gn", "command", "Cmd", "cli", "mode", "cc", "ctx", "cp", "client", "cf", "ctr", "req", "buff", "ctrl", "window", "src", "conn", "host", "pipe", "header", "core", "route", "cookie", "ck"], "buf": ["bag", "batch", "wb", "pkg", "buffer", "cb", "num", "mem", "ef", "pool", "cf", "conv", "buff", "window", "uv", "bytes", "border", "desc", "comb", "b", "bo", "cv", "msg", "grab", "queue", "text", "port", "proc", "bed", "cmp", "feed", "ff", "path", "cas", "src", "func", "fd", "fun", "uf", "byte", "uc", "data", "ab", "rb", "band", "rows", "bus", "fab", "box", "fb", "alloc", "req", "header", "seq", "doc", "vec", "img", "br", "config", "prop", "bc", "front", "pad", "aux", "loc", "ctx", "rc", "off", "runner", "v", "result"], "sensebuf": ["anefile", " sensefile", "ensebuff", "isepkg", " sensepkg", "sebuf", "ensebuffer", "sebuffer", "kebuf", "anectx", "isectx", "isebuf", "sensepkg", "kequeue", "anebuffer", "sebuff", "ensequeue", "sequeue", " sensebuffer", "kebuff", "sensebuff", "ensebuf", "sensefile", " sensectx", "anebuf", "kebuffer", "sensebuffer", "sensectx", "anebuff", "sensequeue", "anepkg", "sefile", "isebuff", " sensebuff"], "io_header": ["ioappheader", "io__buffer", "ios_layer", "ioappbuffer", " io_tail", "iol_buffer", "server_document", "server_header", "ioapphead", " io_parser", " io_module", "io__server", "server_director", "io__writer", "ios_header", "io__header", " io_holder", "io_key", "ioappleader", "ios_buffer", "io_cookie", "io__driver", "io__head", "io_leader", "iol_server", "iol_driver", "io__director", "io_dr", "iol_layer", "io__document", "io__layer", "io_buffer", " io_config", "iol_message", " io_dr", "io_driver", "iloappheader", "ios_head", "ios_server", "ioappcookie", "io_message", " io_server", "iol_head", "iloappcookie", " io_player", " io_handler", "io_tail", "io_line", " io_director", "io__leader", "io_info", "ios_dr", "server_message", "io_secondary", "io_player", "io_parser", "io__dr", "io_layer", " io_wrapper", "ilo_header", "ilo_head", "io_head", "iloapphead", "io_config", " io_head", "iol_header", "io_director", "ios_writer", "io_wrapper", "iol_dr", "io_holder", "ioappdirector", "io_writer", "io_document", "ilo_director", "io_server", " io_document", "ilo_cookie", "ios_info", "io__message", " io_driver", "io_module", "iloappdirector", "io_handler", " io_cookie", "iol_leader", " io_secondary", " io_key", " io_line"], "ret": ["ref", "code", "fin", "sr", "res", "pt", " RET", "flag", "red", "back", "cur", "success", "att", " Ret", "num", "rets", "iter", "mem", "mer", "mt", "det", "lit", "RET", "re", "nt", "reply", "rc", "pat", "arg", "Ret", "rt", "count", "part", "j", "alt", "reg", "resp", "out", "match", "r", "result", "len", "val", "fun"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24880, "substitutes": {"bs": ["rs", "ses", "iss", "lbs", "b", "bas", "bis", "ss", "ns", "vs", "base", "blocks", "rb", "ds", "ab", "bh", "gb", "bos", "bc", "BS", "ps", "outs", "ks", "ins", "gs", "ubs", "pb", "eb", "bi", "os", "nas", "bes", "fb", "obs", "boxes", "ras", "sb", "bid", "ls", "fs", "bits", "cases", "bps", "cs", "banks"], "ign": ["exec", "pect", "oci", "iss", "ass", "anc", "issa", "igned", " assign", "aff", "ach", "ect", "align", "lex", "address", "act", "IGN", "abc", "form", "inet", "xt", "urn", "ident", " align", "cl", "ica", "anch", "igning", "sign", "ig", "clean", "gener", "ignment", "aligned", "conn", "ind", "sect", "account"], "offset": ["from", "ref", "location", "adjust", "shift", "position", "base", "attribute", "align", "pointer", "address", "prefix", "type", "Offset", "reference", "end", "inet", "eno", "set", "start", "loc", "art", "order", "absolute", "ptr", "aligned", "origin", "off", "addr", "length", "part", "entry", "limit", "index", "fp", "reset", "pos", "et", "len", "area"], "size": ["esc", "from", "ize", "shift", "empty", "sized", "name", "storage", "sum", "en", "send", "capacity", "address", "Size", "end", "sync", "unit", "SIZE", "s", "loc", "fee", "small", "si", "parent", "sec", "scale", "shape", "length", "six", "timeout", "content", "iz", "pos", "len"]}}
{"project": "FFmpeg", "commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "target": 0, "func": "int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    Picture *pic;\n\n    s->mb_skipped = 0;\n\n\n\n    if (!ff_thread_can_start_frame(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* mark & release old frames */\n\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n\n        s->last_picture_ptr != s->next_picture_ptr &&\n\n        s->last_picture_ptr->f.buf[0]) {\n\n        ff_mpeg_unref_picture(s, s->last_picture_ptr);\n\n    }\n\n\n\n    /* release forgotten pictures */\n\n    /* if (mpeg124/h263) */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (&s->picture[i] != s->last_picture_ptr &&\n\n            &s->picture[i] != s->next_picture_ptr &&\n\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n\n            if (!(avctx->active_thread_type & FF_THREAD_FRAME))\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"releasing zombie picture\\n\");\n\n            ff_mpeg_unref_picture(s, &s->picture[i]);\n\n        }\n\n    }\n\n\n\n    ff_mpeg_unref_picture(s, &s->current_picture);\n\n\n\n    release_unused_pictures(s);\n\n\n\n    if (s->current_picture_ptr &&\n\n        s->current_picture_ptr->f.buf[0] == NULL) {\n\n        // we already have a unused image\n\n        // (maybe it was set before reading the header)\n\n        pic = s->current_picture_ptr;\n\n    } else {\n\n        i   = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        pic = &s->picture[i];\n\n    }\n\n\n\n    pic->reference = 0;\n\n    if (!s->droppable) {\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            pic->reference = 3;\n\n    }\n\n\n\n    pic->f.coded_picture_number = s->coded_picture_number++;\n\n\n\n    if (ff_alloc_picture(s, pic, 0) < 0)\n\n        return -1;\n\n\n\n    s->current_picture_ptr = pic;\n\n    // FIXME use only the vars from current_pic\n\n    s->current_picture_ptr->f.top_field_first = s->top_field_first;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (s->picture_structure != PICT_FRAME)\n\n            s->current_picture_ptr->f.top_field_first =\n\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n\n    }\n\n    s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&\n\n                                                 !s->progressive_sequence;\n\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n\n\n    s->current_picture_ptr->f.pict_type = s->pict_type;\n\n    // if (s->flags && CODEC_FLAG_QSCALE)\n\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n\n    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n\n                                   s->current_picture_ptr)) < 0)\n\n        return ret;\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n\n        s->last_picture_ptr = s->next_picture_ptr;\n\n        if (!s->droppable)\n\n            s->next_picture_ptr = s->current_picture_ptr;\n\n    }\n\n    av_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n\n            s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,\n\n            s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,\n\n            s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,\n\n            s->pict_type, s->droppable);\n\n\n\n    if ((s->last_picture_ptr == NULL ||\n\n         s->last_picture_ptr->f.buf[0] == NULL) &&\n\n        (s->pict_type != AV_PICTURE_TYPE_I ||\n\n         s->picture_structure != PICT_FRAME)) {\n\n        int h_chroma_shift, v_chroma_shift;\n\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n\n                                         &h_chroma_shift, &v_chroma_shift);\n\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocating dummy last picture for B frame\\n\");\n\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"warning: first frame is no keyframe\\n\");\n\n        else if (s->picture_structure != PICT_FRAME)\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocate dummy last picture for field based first keyframe\\n\");\n\n\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->last_picture_ptr = &s->picture[i];\n\n\n\n        s->last_picture_ptr->reference   = 3;\n\n        s->last_picture_ptr->f.key_frame = 0;\n\n        s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n\n            s->last_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n\n\n        memset(s->last_picture_ptr->f.data[0], 0x80,\n\n               avctx->height * s->last_picture_ptr->f.linesize[0]);\n\n        memset(s->last_picture_ptr->f.data[1], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[1]);\n\n        memset(s->last_picture_ptr->f.data[2], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[2]);\n\n\n\n        if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n\n            for(i=0; i<avctx->height; i++)\n\n            memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);\n\n        }\n\n\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n    if ((s->next_picture_ptr == NULL ||\n\n         s->next_picture_ptr->f.buf[0] == NULL) &&\n\n        s->pict_type == AV_PICTURE_TYPE_B) {\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->next_picture_ptr = &s->picture[i];\n\n\n\n        s->next_picture_ptr->reference   = 3;\n\n        s->next_picture_ptr->f.key_frame = 0;\n\n        s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n\n            s->next_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n\n\n#if 0 // BUFREF-FIXME\n\n    memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));\n\n    memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));\n\n#endif\n\n    if (s->last_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->last_picture);\n\n        if (s->last_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->last_picture,\n\n                                       s->last_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n    if (s->next_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->next_picture);\n\n        if (s->next_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->next_picture,\n\n                                       s->next_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n\n                                                 s->last_picture_ptr->f.buf[0]));\n\n\n\n    if (s->picture_structure!= PICT_FRAME) {\n\n        int i;\n\n        for (i = 0; i < 4; i++) {\n\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n\n                s->current_picture.f.data[i] +=\n\n                    s->current_picture.f.linesize[i];\n\n            }\n\n            s->current_picture.f.linesize[i] *= 2;\n\n            s->last_picture.f.linesize[i]    *= 2;\n\n            s->next_picture.f.linesize[i]    *= 2;\n\n        }\n\n    }\n\n\n\n    s->err_recognition = avctx->err_recognition;\n\n\n\n    /* set dequantizer, we can't do it during init as\n\n     * it might change for mpeg4 and we can't do it in the header\n\n     * decode as init is not called for mpeg4 there yet */\n\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n\n    } else {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24881, "substitutes": {"s": ["comments", "sys", "ns", "ts", "vs", "sites", "sq", "ps", "states", "sync", "self", "sis", "u", "es", "gs", "stats", "http", "sym", "xs", "f", "fs", "qs", "js", "n", "service", "t", "j", "r", "ops", "S", "p", "b", "m", "c", "se", "sports", "storage", "ds", "ans", "us", "ins", "css", "is", "su", "sets", "ions", "spec", "aws", "new", "services", "h", "details", "settings", "its", "g", "times", "rs", "ses", "args", "ss", "bis", "d", "ms", "conf", "sg", "ks", "e", "session", "hs", "client", "sb", "full", "sf", "ssl", "sv", "cs", "plugins", "o", "si", "words", "os", "uns", "as", "ls", "a", "v", "parts", "l"], "avctx": ["afctl", "armcmp", "aucca", "vrloc", "avcoll", "navcontext", "vrctrl", "afctrl", "AVconfig", "avecontext", "avcca", "vrcontext", "mpctx", "AVcmp", "absync", "abcontext", "avcmp", "mpcoll", "mpcontext", "armctl", "mpcmp", "afcmp", "Avconnection", "aucontext", "avcontext", "avsync", "armcontext", "auctx", "aveconfig", "afctx", "avconfig", "afcontext", "armctx", "avectx", "avctl", "ajctx", "avectrl", "abconfig", "AVsync", "avconnection", "avloc", "avecoll", "abctx", "aveconnection", "avctrl", "afxc", "navsync", "Avcontext", "AVconnection", "navconfig", "aveloc", "AVctx", "afcoll", "avxc", "AVctl", "avecmp", "Avconfig", "afloc", "ajcontext", "auxc", "afcca", "navctx", "ajxc", "AVcontext", "Avctx", "ajcca", "vrctx"], "i": ["ski", "z", "ie", "name", "ei", "it", "io", "u", "li", "start", "bi", "ini", "ai", "f", "n", "j", "t", "r", "chi", "val", "code", "k", "slice", "p", "m", "b", "c", "x", "ti", "mi", "phi", "qi", "ri", "line", "di", "ci", "eni", "ki", "in", "g", "abi", "yi", "d", "data", "adi", "e", "err", "uri", "ii", "cli", "fi", "lc", "I", "count", "ori", "iu", "info", "ix", "api", "type", "end", "id", "gi", "ji", "o", "zi", "multi", "xi", "si", "ni", "iv", "aci", "y", "mini", "oi", "ip", "index", "a", "v", "ind", "pi", "ui", "l", "hi"], "ret": ["ru", "obj", "res", "bis", "jp", "ri", "num", "arr", "RET", "fi", "reply", "rc", "feat", "arg", "Ret", "gc", "resp", "J", "r", "result", "len", "val"], "pic": ["picture", "pa", "pins", "Picture", "photos", "p", "pot", "parse", "cat", "image", "fn", "doc", "capt", "study", "photo", "img", "config", "vec", "style", "jp", "feature", "cus", "bc", "mac", "piece", "fc", "li", "pse", "ic", "zi", "str", "xi", "spec", "lib", "bi", "si", "ig", "pin", "avi", "fi", "sec", "fat", "sci", "feat", "cache", "sa", "lc", "Pic", "mini", "pict", "fp", " picture", "ac", "pc", "file"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895, "substitutes": {"opaque": ["OPque", "octsea", "opsaques", "octaques", "opsque", "openaques", " opaques", "OPacity", "OPaques", "opsaque", "opaques", "ipsea", "openque", "ipacity", "octacity", "openacity", "opsea", "octaque", " opacity", "opsacity", "ipaque", " opsea", "ipaques", "opacity", "openaque", "opque", "OPaque"], "s": ["S", "ses", "socket", "sys", "scope", "ss", "p", "m", "server", "c", "b", "ns", "sq", "ds", "sg", "secondary", "sync", "e", "south", "o", "sie", "session", "spec", "si", "sym", "submit", "hs", "sb", "services", "sa", "f", "fs", "n", "a", "sl", "settings", "ops", "ssl", "g"]}}
{"project": "FFmpeg", "commit_id": "41abc9da50ba7a7b68bbbf6622475ce7a3c72e3f", "target": 1, "func": "static int decode_frame_ilbm(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for (plane = 0; plane < s->bpp; plane++) {\n\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for(y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n\n                    if (start >= buf_end)\n\n                        break;\n\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n\n        int x;\n\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n\n            buf += raw_width;\n\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n\n                for(x = 0; x < avctx->width; x++)\n\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { // PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 24896, "substitutes": {"avctx": ["apcontext", "vercmp", "navcontext", "avalconn", "alconn", "aprt", "versci", "avehw", "avcontext", "avesync", "afcontext", "afrt", "ajcue", "avectx", "avctl", "ajctx", " avpkg", "ajcot", "avalcci", "afxc", " avcot", "abcmp", "avcci", "abcoll", "akctx", "akcontext", "AVcontext", "afcli", "avcu", "abcf", "afsync", "avepkg", "avcoll", "afctrl", "AVconfig", "abcontext", "afc", "avalcontext", "avalctrl", "avsci", " avctl", "afctx", "avconfig", "apcoll", "avalctx", "avpkg", "avcot", "afca", "avchan", "avectrl", "abctx", "avctrl", "avhw", "apcf", "navsync", "apconn", "AVctx", "ajc", "avrt", "avxc", "verctx", "aveca", "akcb", "avcb", "alctx", "avecb", "avcf", "ajhw", "ajcoll", "avecontext", "afchan", "avcmp", "afcmp", "verconn", "apctx", "abc", "ajctl", "avsync", "akca", "afcf", "avca", "navpkg", "avecu", "afhw", "afcci", "akchan", "ajrt", "afcue", "afcb", "avalpkg", "akcci", "avc", "AVpkg", "navconfig", " avxc", "afcot", "avconn", "alcontext", "afcoll", "ajcf", "afconn", "ajconfig", "ajcontext", "ajsync", "akconn", "afctl", "avalxc", "alpkg", "avalchan", "afpkg", "vercf", "avcue", "avalsci", "avecli", "aveconfig", "vercontext", "avcli", "afcu", " avcu", " avcoll", "aveconn", "avalsync", " avconn", "afsci", " avcontext", "avecue", "navctx", "akpkg", "navcli", "afconfig"], "data": ["head", "w", "batch", "frame", "name", "module", "buffer", "base", "next", "split", "input", "lines", "sequence", "buff", "window", "bytes", "da", "content", "memory", "draw", "body", "code", "slice", "p", "empty", "action", "actions", "media", "align", "ad", "address", "one", "cache", "first", "value", "DATA", "map", "block", "table", "Data", "done", "bin", "d", "delay", "open", "message", "offset", "output", "parent", "size", "length", "ata", "source", "header", "alpha", "shift", "i", "image", "read", "style", "end", "id", "pad", "padding", "dat", "zero", "layout", "ul", "sample", "last", "series", "index", "a", "results", "result", "format"], "data_size": ["image1len", "data1shape", "image_length", "data1size", "image_len", "data_shape", "image1shape", "image_size", "image_shape", "data_len", "data1length", "data_length", "image1length", "image1size", "data1len"], "avpkt": ["avperkt", "avperdt", "avPacket", "avppacket", "avpce", "avfke", " avpKT", "avlpett", "avpcka", "avvdt", "avspce", "avfpKT", "afpect", "afpce", "avvacket", "avpect", "afpkid", "avpeect", "avppkt", "avbpkid", "afpka", "avfkt", "avspacket", "afpcht", "affce", "avppce", "avfpqt", "avfect", "affect", "ajpacket", "avpckt", "afpki", "ajlpacket", "ajpkt", "affka", "avbpett", "avfett", "avpqt", "avpercht", "avlpacket", "ajlpkt", "afpacket", "avpett", " avPkt", "avect", "avfeth", "avspeth", "avpki", "avfpacket", "avpka", " avPacket", "avfdt", "avlpce", " avPqt", "avpccht", "avpcacket", "abfacket", "avppkid", "avfcht", "avpcht", "affcht", "affki", "avlpeth", "avfpkt", "avperacket", "avpct", "avecht", "avperki", "avPKT", "aphpke", "avvki", "avspke", "avlpke", "avfce", "avcct", "aphlpacket", "avPkt", " avPKT", "avPqt", "abfcht", " avpacket", "affacket", "abpkt", "avperka", "ajpett", "afpdt", " avpqt", "avspkt", "avekt", "avbpkt", "aphpkt", "avfki", "avbpacket", "aveacket", "avpece", "avpkid", "aphpeth", "avfka", "avcacket", "abfct", "avfacket", "afpkt", "avccht", "aphlpkt", "affdt", "abpcht", "avpeth", "ajlpett", "avspect", "avfqt", "ajlpkid", "aphlpeth", "avpeacket", "aphlpke", "avlpkid", "avpke", "avlpkt", "avfct", "affkt", "abfkt", "affkid", "avfKT", "avpekt", "abpacket", "avfkid", "ajpkid", "avpacket", "abpct", "avpKT", "avvkt", "avpdt", "aphpacket", "avckt"], "s": ["S", "sc", "ses", "rs", "sys", "args", "sk", "w", "i", "p", "m", "c", "ss", "ns", "d", "se", "ts", "sq", "ds", "conf", "us", "ps", "sg", "ins", "ks", "sync", "bs", "su", "is", "e", "es", "gs", "stats", "o", "sets", "http", "session", "spec", "l", "si", "sym", "hs", "aws", "os", "sb", "services", "sec", "xs", "sup", "as", "ls", "f", "service", "js", "n", "qs", "details", "a", "t", "fs", "v", "full", "r", "ops", "parts", "ssl", "cs", "its", "g"], "buf": ["seq", "uf", "fin", "gen", "w", "uc", "b", "batch", "wb", "empty", "cv", "bn", "wave", "queue", "buffer", "vec", "base", "cur", "rb", "ab", "cb", "bc", "flow", "num", "bus", "xy", "home", "cmd", "max", "zero", "cap", "loc", "fw", "offset", "box", "fl", "cp", "cf", "alloc", "cache", "bar", "length", "buff", "h", "f", "bytes", "limit", "bg", "header", "lim", "block", "len"], "buf_end": ["buf2End", "fileaclimit", "bufacEnd", "buf2start", "buf2size", "buf_size", "buf_max", "buf2limit", "buffer_end", "file_end", "buf_End", "buffer_start", "buffer_size", "fileacEnd", "bufacend", "file_start", "buf2max", "buffer_max", "fileacend", "fileacstart", "file_End", "file_limit", "bufacstart", "bufaclimit", "buf2end", "buf_limit", "buf_start"], "y": ["height", "yr", "w", "z", "i", "p", "m", "sy", "oy", "dy", "c", "b", "ay", "d", "base", "py", "col", "ye", "type", "gy", "cy", "iy", "ch", "port", "vy", "yo", "key", "ey", "ady", "o", "Y", "yy", "hop", "h", "f", "n", "ip", "j", "ny", "t", "a", "ind", "l", "ya", "area", "g"], "plane": ["zone", "orient", "slice", "w", "z", "page", "p", "nat", "i", "cat", "se", "ge", "weight", "sea", "pe", "planes", "col", "port", "flow", "num", "key", "line", "e", "xy", "span", "axis", "per", "fl", "lane", "rot", "jet", "cp", "mo", "plan", "scale", "period", "level", "direction", "den", "drop", "f", "flo", "n", "ane", "core", "fly", "age", "pos", "pen", "len", "priority", "pose"], "res": ["ber", "rs", "breaks", "gen", "obj", "args", "errors", "score", "nos", "resolution", "RES", "msg", "ms", "success", "cr", "conf", "rus", "gr", "ps", "error", "mr", "cons", "pass", "rec", "range", "press", "bs", "vals", "rss", "e", "css", "resh", "arr", "min", "rh", "err", "rev", "rap", "clean", "re", "ros", "ras", "result", "ret", "sol", "rate", "os", "response", "cache", "req", "ress", "Res", "rem", "des", "status", "rx", "details", "pres", "reg", "js", "resp", "results", "content", "ver", "r", "root", "ris", "reset", "cs", "val", "rates", "rex"], "row": ["sc", "slice", "byte", "w", "col", "rows", "port", "id", "num", "line", "key", "feed", "cell", "max", "month", "offset", "rc", "ry", "zip", "win", "entry", "value", "ip", "index", "q", "block", "pos", "val"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n", "idx": 24897, "substitutes": {"addr": ["socket", "server", "name", "pkg", "url", "ne", "cmd", "sta", "ord", "edge", "coord", "hop", "ptr", "sa", "part", "osi", "et", "ino", "env", "layer", "md", "code", "obj", "slice", "er", "p", "bo", "oo", "bb", "ad", "align", "address", "state", "proc", "cmp", "line", "sp", "hp", "oa", "od", "attr", "rr", "block", "len", "load", "node", "np", "data", "no", "nn", "ada", "error", "sg", "mac", "ea", "alias", "player", "extra", "adr", "str", "rh", "la", "afi", "offset", "ar", "proxy", "ack", "au", "po", "alt", "host", "ha", "pos", "ati", "info", "shi", "dr", "config", "vr", "opt", "dd", "o", "amp", "eth", "loc", "si", "ctx", "inc", "rc", "co", "off", "rt", "ext", "nr", "ip", "conn", "ag", "adder", "ace"], "so": ["ski", "ie", "pg", "OO", "ob", "sq", " SO", "sync", "io", "ne", "oss", "coe", "li", "oso", "ou", "cf", "ro", "sa", "sm", "service", "go", "osi", "ho", "who", "code", "sk", "obj", "fo", "ock", "bo", "osa", "oo", "se", "ge", "wh", "So", "su", "sp", "s", "ko", "one", "tto", "now", "oa", "sing", "cu", "sl", "LO", "ce", "pc", "sh", "wo", "no", "ste", "to", "sg", "zo", "how", "la", "cli", "client", "sb", "olo", "proxy", "SO", "po", "flo", "lo", "zh", "sf", "ke", "cs", "oh", "from", "ow", "shi", "info", "style", "py", "since", "plus", "oe", "o", "si", "sel", "os", "mo", "co", "pro", "ao", "ace"]}}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899, "substitutes": {"opaque": ["obaca", "opsaques", "OPya", "ospacity", "opaca", "OPacity", "opsaque", "ospac", "oppaca", "opac", "opaques", " opac", "opatile", "ospaque", "opsatile", "OPac", "ospya", "oppaques", "opya", " opacity", " opya", "oppaque", "opsaca", "opacity", "obatile", "obaques", "OPaque", "obaque", "oppatile"], "addr": ["ref", "socket", "frame", "name", "pkg", "callback", "base", "ld", "add", "cb", "url", "arr", "cmd", "sta", "ord", "edge", "hop", "ptr", "osi", "nc", "layer", "md", "code", "arm", "rpm", "x", "hard", "ad", "align", "address", "prefix", "port", "proc", "cmp", "point", "work", "wd", "fx", "oa", "ost", "src", "attr", "rr", "len", "kt", "node", "args", "byte", "np", "data", "pointer", "nn", "mac", "alias", "adr", "la", "afi", "offset", "mode", "ar", "req", "ack", "xp", "reg", "host", "ha", "intel", "dc", "dr", "hd", "asm", "clock", "config", "vr", "dd", "id", "pad", "nick", "amp", "grad", "cpu", "advert", "eth", "loc", "slot", "art", "device", "amd", "handle", "ext", "rt", "ip", "index", "conn", "arp", "route", "adder", "ace"], "irqmp": ["irgmp", "irqump", "Irqump", "ircmp", "irQMP", "irqm", "irqqmp", "ircepy", "ircema", " irqpm", "IrquMP", "Irqpy", "Irqmm", "iriqumb", "irqpy", "irqqmb", "irqum", "Irqumm", "irqumm", "irgmm", "irqma", "irgpm", "irqpm", "ircemm", "Irqupy", "ircemp", "iriqmb", " irgpm", "irquma", " irgmm", "irchpm", "irgMP", "irqupy", "irchmp", "irqmm", "iriqmp", "irqmb", "ircem", "ircmm", "ircpy", "irqumb", " irgMP", "iriqma", "irqqma", "irchmm", "ircemb", "iriqum", "irQmp", " irqMP", "irQpm", "IrqMP", "irQmm", "irquMP", "iriqump", "irchMP", "ircMP", "Irqmp", " irgmp", "iriquma", "irqMP", " irqmm", "irqqm", "irceMP", "iriqm"], "state": ["call", "param", "name", "manager", "State", "dict", "states", "sync", "self", "seed", "set", "start", "progress", "object", "STATE", "level", "note", "part", "status", "list", "print", "val", "code", "body", "slice", "er", "se", "test", "address", "port", "store", "key", "patch", "work", "resource", "spec", "new", "cache", "notice", "rule", "value", "event", "map", "node", "scope", "parse", "force", "data", "trace", "component", "error", "push", "all", "e", "step", "open", "message", "err", "session", "mode", "parent", "grade", "stat", "order", "size", "length", "count", "source", "ke", "connection", "statement", "lock", "tag", "info", "master", "style", "config", "type", "o", "estate", "co", "conn", "ace", "range"]}}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}", "idx": 24902, "substitutes": {"qsg": ["qsa", "qugu", "qsc", "Qsg", "qusa", "psa", " qsa", "psb", "qsb", " qsq", "qsq", " qgu", "dqsb", "dqsa", "dqsc", "psg", "dqsg", "qusb", "qusc", "psc", "Qsa", "Qsq", "qusg", "qusq", "qgu", "Qgu"]}}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921, "substitutes": {"vdev": ["vpriv", "ldevice", "xconf", "vdd", "gdevice", "ldev", "svconf", "Vdevice", "ddd", "Vpriv", "xdd", "vde", " vprom", "xdevice", " vconf", "vdevice", " vdevice", "pdevice", "vprom", "xdev", "gdev", "Vdev", "vconf", "ppriv", " vde", "lprom", "dconf", "lconf", " vpriv", "gconf", "pde", "gprom", "pdev", "Vde", "svdevice", "svdev", "ddev", "svdd", "ddevice"], "s": ["sys", "w", "server", "ns", "ts", "ps", "secondary", "states", "sync", "self", "es", "gs", "stats", "set", "sym", "xs", "serv", "f", "service", "js", "n", "qs", "fs", "t", "tests", "S", "p", "m", "b", "c", "storage", "ds", "state", "su", "is", "ssh", "ims", "sets", "spec", "aws", "new", "services", "h", "sl", "settings", "its", "g", "side", "rs", "ses", "args", "ss", "d", "data", "conf", "sg", "ks", "e", "session", "hs", "sb", "your", "full", "ssl", "cs", "site", "o", "si", "os", "uns", "sup", "as", "ls", "a", "v", "parts", "l"], "i": ["k", "yi", "p", "info", "m", "c", "name", "b", "d", "ix", "x", "ti", "mi", "type", "phi", "qi", "ri", "id", "u", "e", "key", "li", "gi", "ji", "zi", "multi", "xi", "uri", "start", "ii", "di", "si", "ai", "ini", "ni", "bi", "ci", "fi", "eni", "hei", "sup", "I", "f", "ki", "oi", "n", "j", "index", "chi", "t", "a", "v", "ind", "iu", "pi", "mu", "in", "ui", "l", "hi"], "len": ["seq", "fin", "low", "dim", "dy", "lan", "ld", "en", "mi", "ler", "bl", "non", "lon", "id", "all", "lf", "mem", "li", "el", "Len", "min", "lu", "err", "la", "lit", "lang", "l", "dl", "lin", "fl", "ann", "pl", "le", "ni", "nt", "lib", "lt", "size", "ln", "length", "lc", "il", "lif", "elt", "lp", "count", "n", "limit", "lo", "lim", "ind", "sl", "pos", "val", "fun"], "stat": ["exec", "Stat", "rs", "ctl", "sys", "gen", "STAT", "info", "nat", "name", "cat", "opt", "debug", "def", "sync", "util", "proc", "css", "link", "disk", "stats", "mem", "cmd", "cpu", "nic", "dir", "spec", "mode", "sec", "cache", "task", "lif", "serv", "raf", "dot", "status", "reg", "conn", "nam", "meta", "attr", "block"], "fse": ["fsee", "Fce", "cfze", "fste", " fge", "fce", "rfpe", "Fge", "fke", "rfge", " fsu", "psee", "gde", "vke", "dse", " fpe", "fsp", "sfsp", "fxste", "dpse", " fsee", "fsu", "vze", " fze", "pse", " fses", " fste", "fxses", "cfce", " fce", "vsel", "fpe", "pde", "fbe", "Fpe", "fxse", " fpse", "Fse", " fsp", " fbe", "vste", "ffe", "dfsel", "rfse", " ffe", "rfce", "fxsu", "sfpse", "vce", "dfse", "dsp", "dfbe", "fses", "gsee", "fze", "vse", "vbe", "cfbe", "dfe", "fsel", " fde", " fsel", "sfse", "fge", "gse", "pze", "vses", "fpse", "vsu", "dfke", "cfse", " fke", "fde", "gze", "sffe"], "path": ["ref", "node", " paths", "sc", "code", " Path", "w", "er", "m", "c", "name", "d", "image", "mount", "data", "fn", "ec", "config", "next", "address", "prefix", "ch", "loader", "port", "end", "alias", "self", "url", "id", "key", "home", "cmd", "str", "err", "dir", "uri", "loc", "ath", "mode", "parent", "result", "target", "device", "PATH", "f", "source", "host", "root", "r", "Path", "file"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_request(V9fsProxy *proxy, int type,\n\n                        void *response, const char *fmt, ...)\n\n{\n\n    dev_t rdev;\n\n    va_list ap;\n\n    int size = 0;\n\n    int retval = 0;\n\n    uint64_t offset;\n\n    ProxyHeader header = { 0, 0};\n\n    struct timespec spec[2];\n\n    int flags, mode, uid, gid;\n\n    V9fsString *name, *value;\n\n    V9fsString *path, *oldpath;\n\n    struct iovec *iovec = NULL, *reply = NULL;\n\n\n\n    qemu_mutex_lock(&proxy->mutex);\n\n\n\n    if (proxy->sockfd == -1) {\n\n        retval = -EIO;\n\n        goto err_out;\n\n    }\n\n    iovec = &proxy->out_iovec;\n\n    reply = &proxy->in_iovec;\n\n    va_start(ap, fmt);\n\n    switch (type) {\n\n    case T_OPEN:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_OPEN;\n\n        }\n\n        break;\n\n    case T_CREATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n\n                                    flags, mode, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CREATE;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        rdev = va_arg(ap, long int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n\n                                    uid, gid, path, mode, rdev);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKNOD;\n\n        }\n\n        break;\n\n    case T_MKDIR:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n\n                                    uid, gid, path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKDIR;\n\n        }\n\n        break;\n\n    case T_SYMLINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n\n                                    uid, gid, oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_SYMLINK;\n\n        }\n\n        break;\n\n    case T_LINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n\n                                    oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LINK;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSTAT;\n\n        }\n\n        break;\n\n    case T_READLINK:\n\n        path = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_READLINK;\n\n        }\n\n        break;\n\n    case T_STATFS:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_STATFS;\n\n        }\n\n        break;\n\n    case T_CHMOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHMOD;\n\n        }\n\n        break;\n\n    case T_CHOWN:\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHOWN;\n\n        }\n\n        break;\n\n    case T_TRUNCATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        offset = va_arg(ap, uint64_t);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_TRUNCATE;\n\n        }\n\n        break;\n\n    case T_UTIME:\n\n        path = va_arg(ap, V9fsString *);\n\n        spec[0].tv_sec = va_arg(ap, long);\n\n        spec[0].tv_nsec = va_arg(ap, long);\n\n        spec[1].tv_sec = va_arg(ap, long);\n\n        spec[1].tv_nsec = va_arg(ap, long);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_UTIME;\n\n        }\n\n        break;\n\n    case T_RENAME:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_RENAME;\n\n        }\n\n        break;\n\n    case T_REMOVE:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_REMOVE;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n\n                                    \"dss\", size, path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LGETXATTR;\n\n        }\n\n        break;\n\n    case T_LLISTXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LLISTXATTR;\n\n        }\n\n        break;\n\n    case T_LSETXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        value = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n\n                                    path, name, value, size, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSETXATTR;\n\n        }\n\n        break;\n\n    case T_LREMOVEXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LREMOVEXATTR;\n\n        }\n\n        break;\n\n    case T_GETVERSION:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_GETVERSION;\n\n        }\n\n        break;\n\n    default:\n\n        error_report(\"Invalid type %d\", type);\n\n        retval = -EINVAL;\n\n        break;\n\n    }\n\n    va_end(ap);\n\n\n\n    if (retval < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* marshal the header details */\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n", "idx": 24933, "substitutes": {"proxy": ["ref", "call", "socket", "pa", "roxy", "fe", "clone", "server", "engine", "context", "image", "callback", "x", "buffer", "api", "queue", "base", "request", "address", "ping", "pe", "port", "fax", "io", "proc", "plugin", "linux", "python", "pse", "bridge", "resource", "project", "http", "pool", "echo", "super", "client", "cop", "Proxy", "cache", "zip", "pex", "pro", "f", "service", "prot", "host", "pipe", "null", "query", "ssl", "connection", "pc", "cgi"], "type": ["ref", "code", "day", "call", "class", "token", "info", "flag", "single", "time", "action", "style", "request", "config", "py", "pe", "ping", "types", "error", "version", "state", "port", "op", "id", "url", "method", "typ", "key", "link", "rel", "http", "set", "Type", "role", "model", "binary", "parent", "copy", "like", "size", "ype", "field", "active", "part", "TYPE", "y", "status", "t", "pre", "in", "block", "post", "len", "val", "tag", "format", "side"], "response": ["ref", "call", "res", "respons", "server", "callback", "data", "buffer", "request", "Response", "next", "respond", "method", "http", "parent", "cache", "req", "xml", "timeout", "service", "status", "resp", "report", "result"], "fmt": ["sfformat", "fnt", " fnt", "Fformat", " fMT", "sfnt", "Fprintf", " flt", "FMT", " fformat", "flt", "fMT", "fformat", "Flt", "Fmt", "Fnt", "sflt", "sfMT", "sfmt", "sfprintf"], "rdev": ["ldeal", "ldev", "rdef", "rteal", "irdeal", "rdesc", "rtev", "rdelta", "irdev", "rtef", "irdata", "ldef", "ldesc", "rbesc", "rbef", "rbev", "irdef", "tdelta", "rdata", "tdesc", "rtata", "rdeal", "tdef", "ldelta", "ldata", "rbelta", "tdev"], "ap": ["nav", "ns", "or", "base", "ps", "aj", "ak", "lat", "http", "ptr", "external", "addr", "pac", "gap", "p", "hap", "jp", "address", "tap", "op", "rep", "mp", "sp", "apache", "cap", "https", "ang", "ape", "cache", "xml", "wp", "array", "tp", "report", "AP", "map", "ep", "snap", "np", "this", "ae", "Ap", "ab", "av", "all", "al", " op", "at", "ar", "au", "na", "ha", "aps", "apps", "pos", "skip", "pa", "apt", "app", "api", "img", "archive", "amp", "dat", " AP", "html", "as", " sp", "ip", "arp", "a", "apy", "ag"], "offset": ["ref", "seq", "done", "shift", "info", "empty", "flag", "SET", "base", "Offset", "error", "set", "start", "parent", "number", "alloc", "length", "timeout", "count", "index", "pos", "len", "put", "final"], "spec": ["ature", "byte", "class", "info", "data", "Spec", "opt", "def", " sup", "str", "ul", "ef", "size", "sec", "shape", "length", " specification", "ext", "I", "ice", "match", "pack", "ace", "len", "desc"], "flags": ["mask", "ants", "args", "acl", "steps", "errors", "features", "ns", "includes", "flag", "fd", "ips", "data", "items", "Flags", "ds", "opens", "filename", "planes", "types", "rules", "version", "plugins", "locks", "vals", "rets", "stats", "lf", "options", "fields", "s", "lines", "reads", "fts", "levels", "links", "faces", "versions", "properties", "stat", "size", "files", "mods", "ls", "f", "fs", "groups", "bits", "status", "details", "bytes", "content", "posts", "ids", "values", "settings", "ops", "len", "format", "fun"], "mode": ["md", "mask", "node", "sid", "user", "driver", "MODE", "m", "dim", "module", "time", "data", "style", "filename", "prefix", "mid", "version", "kind", "id", "alias", "plugin", " modes", "key", "du", "mission", "dir", "uri", "role", "group", "lane", "model", "grade", "owner", "size", "scale", "level", "direction", "device", "mod", "Mode", "perm", "de", "coll", "route", "range", "vel", "language", "phase"], "uid": ["mask", "gu", "sid", "user", "uc", "usr", "uin", "gin", "uni", "nn", "gy", "ud", "id", "ua", "su", "u", "gpu", "eno", "udi", "wallet", "home", "du", "cmd", "uint", "lu", "vid", "password", "cpu", "uri", "session", "ug", "owner", "ou", "size", "UID", "direction", "device", "uu", "auth", "username", "uv", "umi", " u", "host", "nu", "who", "kid", "ui", "upid", "pid"], "gid": ["rgids", "Gname", " gide", "angid", "gids", "pgname", "sgID", "guip", "sgid", "rgaid", "ginidd", "sgide", "guid", " gname", "GID", "gbit", "gname", "gID", "gaid", " gbit", "rgID", "ginID", " gip", "angID", "gidd", "rgip", "pgids", "ginid", "rgide", "ginbit", "Gids", "Gid", " gidd", " gID", "rgid", "gip", "gide", "pgID", "sgaid", " gids", "angbit", "guids", "pgid", "angidd", " gaid"], "name": ["mask", "node", "info", "image", "shell", "time", "data", "base", "filename", "member", "address", "prefix", "version", "alias", "Name", "group", "parent", "username", "ext", "NAME", "child", "ip", "names", "host", "meta", "format"], "value": ["data", "text", "media", "property", "version", "Value", "write", "end", "port", "depth", "vals", "key", "message", "uri", "VALUE", "device", "entry", "ip", "alt", "content", "v", "values", "settings", "description", "range", "val", "format"], "path": ["node", "location", "code", "txt", "skip", "th", "token", "info", "p", "transform", "context", "image", "enc", "data", "fn", "text", "filename", "pointer", "prop", "col", "prefix", "pass", "end", "sync", "id", "alias", "url", "method", "key", "link", "resource", "rh", "password", "dir", "uri", "pattern", "loc", "ath", "sign", "clean", "parent", "join", "PATH", "wp", "part", "ith", "entry", "child", "host", "content", "route", "dest", "root", "full", "match", "Path", "ph", "file", "area"], "oldpath": ["oldloc", "prevpath", "origloc", "newloc", "olddesc", "newdesc", "origpath", "prevdesc", "origdesc", "origname", "prevloc", "prevname", "newpath", "oldname", "newname"], "iovec": [" iovecd", " iovecin", "iovef", "xioreuc", "iomecs", "iokeh", "iorec", "iosecs", "ioref", "iouf", " iouc", "ioperc", "iopercs", "xioveuc", " iolec", "ioodlec", "iopercd", " iolecin", "iovecs", "iokef", "ioreuc", "iobycs", "iouc", "ioodlecc", "iokec", "ioretc", "iovecin", "iokecin", "xiovef", "iosec", "iobyf", "iouci", " iovecc", " iouct", " ioretc", "ioveh", "iomec", " ioucc", " ioveci", "iomecc", "iosecat", "ioretcd", " ioveh", "ioucc", " ioucs", "ioviex", "iomect", "xiovex", "xiorex", " ioretcd", "iouct", "ioviec", "iopercat", "ioycin", "xiovec", " iokef", "iobyuc", "iosecc", "iorecs", "ioyf", " ioleh", "iosef", "xiovecc", "iovecc", "iouuc", "iobyc", "ioviecc", "iokecs", "iorecc", " ioretcs", " iovect", "iolef", "xiorecc", "ioleh", "iovect", "ioyh", "ioveuc", "xiorecs", "xiovecs", "ioretcat", "ioodlect", "iosex", "iosecd", " iolef", "ioveci", "iovecat", " iokec", "ioretcs", "iolecin", "xioref", "iolec", "iorex", "iovief", " iovef", "ioyc", " ioretcat", "ioreci", " iovecs", " iovecat", "iovecd", "ioodlecs", "ioucs", " iokeci", "iokeci", " iokecs", "iovex", "xiorec"], "reply": ["body", "call", "info", "server", "buffer", "queue", "send", "request", "Response", "next", "py", "jp", "respond", "write", "sync", "rep", "link", "reverse", "Reply", "message", "session", "cache", "req", "replace", "resp", "related", "answer", "route", "report", "query", "rr", "result", "connection"]}}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n", "idx": 24968, "substitutes": {"r": ["ru", "rs", "k", "er", "sr", "res", "p", "m", "parse", "usr", "dr", "rf", "rb", "br", "request", "cr", "vr", "gr", "mr", "ra", "fr", "tr", "self", "rss", "e", "resource", "R", "rh", "rl", "lr", "rar", "l", "re", "rc", "rg", "ar", "req", "kr", "ir", "nr", "pr", "rx", "rr", "result", "hr", "g"], "status": ["complete", "code", "Status", "STAT", "info", "score", "name", "msg", "weight", "style", "success", "prefix", "speed", "state", "write", "sync", "id", "security", "uses", "e", "stats", "fps", "str", "err", "progress", "enabled", "spec", "model", "mode", "si", "stat", "sol", "device", "update", "active", "f", "stage", "service", "source", "index", "running", "content", "settings", "description", "result"], "sense_code": ["senseidcode", "sensevalcore", "sense_number", "sensevalcodes", " sense_number", " sense_cod", " sense_codes", "sense_cod", "sensevalcod", "sense_codes", " sense_tag", "senseidnumber", "senseidtag", "senseidcodes", "sense_core", "sense_tag", " sense_core", "sensevalcode"], "s": ["S", "side", "rs", "ses", "sys", "z", "scope", "ss", "p", "m", "info", "c", "server", "ns", "d", "sq", "ds", "states", "sync", "instance", "su", "u", "e", "o", "http", "spec", "si", "sb", "services", "h", "f", "fs", "js", "n", "service", "sl", "sf", "settings", "ssl", "g"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n", "idx": 25005, "substitutes": {"s": ["sys", "server", "ns", "manager", "ts", "sq", "request", "ps", "secondary", "states", "sync", "self", "u", "es", "gs", "south", "http", "set", "sym", "grades", "f", "service", "js", "n", "status", "fs", "t", "r", "ops", "native", "S", "slice", "none", "p", "m", "b", "c", "storage", "ds", "ans", "us", "state", "ins", "port", "su", "is", "sets", "spec", "aws", "new", "services", "sl", "settings", "its", "g", "rs", "ses", "ss", "d", "conf", "sg", "ks", "e", "session", "hs", "sb", "your", "sf", "ssl", "cs", "sv", "params", "secure", "i", "changes", "plugins", "site", "o", "home", "si", "os", "uns", "ls", "an", "l"], "value": ["complete", "element", "section", "none", "m", "option", "name", "d", "data", "attribute", "style", "address", "type", "property", "version", "Value", "state", "end", "id", "store", "range", "reason", "key", "message", "resource", "valid", "set", "after", "fee", "object", "si", "VALUE", "size", "number", "response", "now", "xml", "current", "update", "json", "status", "total", "index", "source", "service", "v", "expression", "values", "settings", "description", "result", "sv", "val", "format"]}}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n", "idx": 25024, "substitutes": {"opts": [" ops", "optths", "opths", "opttd", "optter", "opttes", " opds", "precs", "opoptions", "opcs", " optes", "optoptions", "otoptions", "omts", "OPds", "pretes", "OPs", "preths", "optcs", " opte", " opcs", "prots", "proths", "otTs", "opTs", "optd", " optd", " opths", "ads", "opps", "OPths", "omps", "omTs", " opoptions", "prets", "adds", "optps", "optts", "OPts", "otps", "otts", " opter", "adths", "opds", "optes", "otter", "opte", "adts", "optte", "omte", "opter", "ops", "protd", "otte", "prote", "optTs"], "backend": ["returnends", "backen", "behindengine", "headsend", "backedserver", "suppward", "buffward", " backending", "acksend", "homeender", "bsend", " backen", "bootend", "suppend", "bootward", " backends", "worksend", "frontload", "backward", "landload", "homeend", "Backengine", "homeended", "ackend", "headended", "calending", "bender", "aggsend", "frontsend", "suppsend", "ckending", "ackended", "behindends", "backends", "Backended", "backender", "calend", " backserver", "homesend", "landend", "bootender", "frontended", "backedended", "workending", "calended", "Backender", "backengine", " backender", "behindending", "fronten", "backended", "headend", "ckend", "landended", "backload", " backengine", "bend", "ckender", "workend", "Backend", "buffsend", "frontending", "headending", "ckended", "backending", "buffend", " backward", "buffended", "worken", "aggward", "calender", "landsend", "bended", "ackload", " backsend", "bootengine", "backedend", "workended", " backended", "frontserver", "returnend", "frontend", "suppended", "backedsend", "aggend", "frontward", "aggended", "backserver", "frontender", "backsend", "returnending", "Backward", "Backserver", "returnengine", "behindend"], "errp": ["ererror", "err", "lererror", " errr", "erp", "lerr", "lerp", " errerror", "errerror", "errr", "ersp", "errsp", " errsp", "lersp"], "val": ["ref", "xx", "call", "gen", "b", "pt", "pol", "dim", "VAL", "x", "data", "eval", "doc", "base", "var", "gal", "py", "tx", "col", "fail", "it", "live", "num", "all", "vals", "aval", "al", "key", "unit", "el", "rel", "grad", "lat", "min", "valid", "ol", "vc", "loc", "l", "fl", "cal", "slot", "sel", "vert", "cond", " Val", "req", "il", "serv", "Val", "elt", "rt", "f", "count", "part", "value", "alt", "v", "ver", "ind", "pos", "_", "sl", "vel", "len", "vol"]}}
{"project": "FFmpeg", "commit_id": "39e0accb7a934bfe3d42324b016dd8790790746d", "target": 1, "func": "static unsigned int find_best(struct vf_instance *vf){\n\n  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);\n\n  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))\n\n    return IMGFMT_YV12;\n\n  else\n\n    return 0;\n\n}\n", "idx": 25066, "substitutes": {"vf": ["svrf", "avrf", " vfp", "svf", "svfs", "fsf", "vrf", " vfs", "ffp", "avf", "avsf", "Vdf", "svc", "qf", " vrf", "ff", "ffs", "vc", "vdf", " vsf", "Vf", "qc", "svdf", "qdf", "Vc", "svfp", "svsf", "qfs", "vfs", "Vfs", "frf", "vfp", "vsf", "avfs"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075, "substitutes": {"den": ["fen", "dy", "der", "uni", "norm", "dom", "ne", "ben", "min", "fl", "dev", "DEN", "nen", "n", "limit", "da", "dm", "de", "dn", "ner", "none", "m", "en", "diff", "su", "range", "dan", "sen", "di", "plan", "oa", "zen", "don", "wall", "que", "len", "side", " Den", "d", "data", "lan", "ani", "db", "e", "con", "err", "ven", "order", "mon", "Den", "po", "flo", "nu", "pos", "pen", "dim", "end", "ten", "pri", "dem", "du", "iden", "un", "ind", "nan"], "q": ["Q", "k", "w", "z", "p", "m", "b", "c", "d", "x", "qa", "qt", "sq", "cur", "qi", "ch", "id", "u", "depth", "e", "o", "eq", "order", "req", "ue", "h", "qu", "f", "count", "qs", "quant", "n", "y", "qq", "un", "v", "query", "dq", "l", "g"], "r": ["ru", "rs", "k", "er", "sr", "res", "i", "p", "m", "b", "c", "d", "x", "or", "rb", "u", "e", "o", "R", "err", "rh", "rar", "re", "result", "order", "rate", "ur", "rg", "ar", "req", "rc", "h", "f", "nr", "pr", "n", "a", "v", "rr", "range", "l", " R"], "num": ["iq", "gen", "np", "nm", "w", "bin", "i", "b", "m", "dim", "p", "name", "d", "uni", "norm", "bn", "sum", "no", "en", "om", "Num", "id", "dom", "su", "u", "unit", "nom", "con", "du", "o", "max", "multi", "zero", "nb", "cal", "mn", "mon", "number", "inc", "len", "off", "uu", "um", "f", "n", "NUM", "na", "un", "mult", "nu", "mu", "nc", "g"]}}
{"project": "FFmpeg", "commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "target": 1, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n\n{\n\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n\n    int t10, t11, t12, t13;\n\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n", "idx": 25081, "substitutes": {"blk": ["brk", "blke", " blsk", " blke", "blK", "BLq", "mlsk", "slb", "BLv", "llk", "llke", "nlb", " blq", "blv", "Blb", "Blsk", "brb", "mlkin", "brck", "blks", "BLk", "plks", "slsk", "nlk", "ylkin", "plck", "glck", "glK", "blq", "llsk", "llq", "blck", "blch", "plb", "mlK", " blb", " blku", "plke", "plv", "llks", "ylk", "nlsk", "plq", "silks", "glq", "blsk", "plsk", "plk", "blb", "mlk", "llck", "blku", " blK", "oblsk", "slku", "ylsk", "silk", " blck", "BLck", "brsk", "mlch", "oblk", " blch", "slk", "Blk", " blks", " blkin", "silch", " blv", "nlku", "oblck", "glk", "ylks", "llb", "oblb", "silK", "Blck", "blkin", "plK", "mlks"], "quant": ["requ", "sc", "Quant", "gap", "quick", "app", "cat", "dash", "frac", "text", "cur", "config", "pay", "quart", "pub", "form", "util", "compl", "serial", "rec", "pad", "press", "private", "qual", "ident", "charge", "percent", "patch", "spec", "sign", "stat", "client", "inc", "scale", "local", "integer", "quad", "complex", "comp", "buff", "product", "qu", "comment", "count", "total", "mix", "color", "mult", "qq", "print", "q", "event", "chart", "query", "draw", "post"], "t0": ["Tzero", "s00", "at0", "t000", "te0", "ta2", "tzero", "d02", "te02", "d0", "dt00", "dt0", "f8", "at1", "d00", "d000", "f2", "ta0", "at00", "f0", "f4", "T1", "ta8", "p2", "T4", "T00", "p8", "szero", "dt02", "T2", "te00", "atzero", "t00", "p4", "p0", "dt000", "f1", "T0", "ta4", "t02", "te000"], "t1": ["p3", "y3", "ta1", "f3", "y1", "p1", "d1", "ta7", "d2", "d4", "f4", "T1", "p7", "p2", "T4", "f5", "p5", "T7", "p4", "d7", "y4", "y5", "T3", "ta4", "f1", "ta3", "T2"], "t2": ["ta62", "ta2", "pB", "m5", "m4", "m2", "m0", "n4", "it4", "f2", "itB", "it62", "f0", "ta6", "n7", "f4", "n5", "p2", "T4", "f5", "p5", "T7", "p4", "p62", "ta5", "p0", "n2", "it2", "t62", "T5", "T2", "ta4", "taB"], "t3": ["pt5", "p3", "T03", "v3", "e8", "t03", "pt13", "v5", "s03", "the13", "pt2", "ta1", "p1", "v1", "ta6", "e5", "the5", "it13", "T1", "e3", "p7", "T6", "ft5", "v7", "the2", "T4", "ft3", "ft2", "ft8", "it3", "it5", "p5", "the3", "ta5", "it2", "T8", "T3", "T5", "e2", "ta03", "ta4", "pt3", "ta3", "T2"], "t4": ["tpB", "ta2", "i5", "fB", "tp2", "i2", "i4", "tp6", "f4", "ta8", "tp4", "f6", "ta5", "i8", "ta4", "f2"], "t5": ["p3", "ta45", "m45", "m5", "m4", "m6", "it6", "it4", "t45", "ta6", "p2", "p8", "it45", "it3", "it8", "it5", "p5", "ta5", "it2", "ta4"], "t6": ["e9", "ts8", "ts12", "pt8", "f8", "pt4", "f66", "f7", "f3", "ta7", "ta6", "e5", "e4", "f4", "ta8", "t06", "T6", "e12", " t06", "pt66", "T4", "ts6", "ts06", "e06", "f6", "pt6", "e6", "t66", "ta5", "T66", "T8", "ta9", "ta4", "e8", "ta3"], "t7": [" t97", " t07", "tt7", "tt07", "tt74", " t87", "t97", "ta13", "n87", "te74", "te87", "ta07", "n07", "ta7", "n7", "t87", "t07", "t74", "ta97", "te97", "n13", "te07", "ty13", "ta87", "ty87", "tt13", "ty07", "te13", " t74", "te7", "ty7"], "t8": ["it10", "taE", "f10", "te8", "f8", "it6", "TEight", "it86", "ta08", "teEight", "taEight", "ta8", "teE", "t86", "f6", "tEight", " t86", "it8", "TE", "te08", "f86", "t08", "T8", "T08"], "t9": ["pt11", "it49", "ta99", "t19", "ta09", "t49", "T9", "pt49", " t09", "d19", "it19", "ta8", "T99", "d9", "d11", "it11", "it9", "t99", "ta9", "pt19", "T09", "pt9", " t99", "d49", "T8", "t09"], "tA": ["teA", "yO", "mtA", "teI", "yC", "mtB", "tO", " tI", "mtC", "yA", "TB", "TI", "TC", "TA", "retO", "retB", "tI", "teC", "teB", "retA", "mtO", "yB", "retC"], "tB": ["taskL", "tR", " t42", "tiR", "ta42", "taskB", "taskBB", "tiB", " tb", "t42", "tiL", "tBB", "taskR", "TBB", "T42", "TL", "TB", "taBB", "tb", "Tb", " tBB", "tab", "tL", "TR", "tiBB", "taB"], "tC": ["taC", "TD", "taE", "pC", "wtE", "wtC", "yC", "vD", "atC", "ttB", "fB", "otc", "otP", " tc", "wtD", "atG", "yE", "vE", "taD", " tG", "pD", " tP", "fD", "wtB", "ttD", "TC", "TN", " tN", "TA", "tP", "atP", "ttE", "fC", "tN", "tc", "pA", "atc", "yD", "pN", "otC", "fE", "ttC", "tG", "yB", "vC", "vB", "otG", "taB"], "tD": ["tiC", "taC", "pC", "pB", "tiB", "tU", "tfD", "pD", "ptC", "tiU", "tfB", "tfC", "taF", "ptD", "tfU", "tiD", "ptB", "ptU", "taD", "pF", "taB"], "tE": ["mtV", "ttV", "tuC", "teL", "tuE", " tL", "mtC", "mtG", "timE", "teE", "tV", "ttE", "tuG", "tL", "timC", "teC", "tuV", "teB", "ttG", "mtE", "timL", "ttC", "tG", "timB"], "tF": ["tzP", "tzV", " tP", "tY", "tzY", "tV", "taV", " tY", " tV", "taP", "taY", "tP", "tzF", "taF"], "t10": ["s50", "set50", "f50", "t50", "s10", "s11", "f10", "set12", "s12", "f12", "set11", "set10", "f11"], "t11": ["t14", "T10", " t14", "f10", "T11", "T12", "f12", "f11", "T14", "f14"], "t12": ["t14", "t15", " t14", "p14", "all13", "all12", "p15", "all14", "p12", "all15", "p13", " t15"], "t13": ["s57", "t57", "tu19", "f13", "tu57", "s13", "s12", "f12", "tu13", "t19", "tu12", "f57", "s19", "f19"], "s0": ["s50", "si1", "ps8", "ps50", "s90", "ps0", " s12", "p1", "ses8", "si2", " s8", "ses1", "ses0", "s8", "p2", " s50", "t90", "s12", "ses50", "p90", "ps1", "p0", "si90", "si0", "si12"], "s1": ["p3", "ns9", "g3", "g4", "f7", "f3", "p1", "d1", "ns3", "d2", "p7", "n5", "p2", "d3", "f5", "s9", "ns4", "g9", "p5", "n2", "d7", "ss3", "ns1", "ss9", "g1", "ss1", "n1", "n7", "f1", "ss4"], "s2": ["c2", "d5", "m5", "m4", "d0", "c4", "m2", "is2", "g5", "g4", "p10", "ns10", "s10", "ns5", "f0", "d2", "e5", " s8", "d4", "e4", "s8", "f4", "c5", "p2", "is8", "ns2", "f5", "is5", "ns4", "g2", "e1", "p5", "p0", "p4", "c10", "g1", "e2", "m8", "is4", "f2"], "s3": ["p3", "d5", "S15", "s15", "m5", "m4", "m13", "s03", "g3", "S03", "S3", "s53", "sed", " s15", "g8", "f3", "S53", "p1", "p6", "sined", "s13", "d13", "sin53", " s8", "S8", "d4", "s8", "g53", "se5", "d3", "f6", "f5", "g03", "se4", "se3", "p5", "sin15", "sin3", "Sed", "m3", " s53", " s03", " sed", "se13", "f1"], "s4": ["d5", "g5", "g4", "n4", "p1", "d8", " s8", "d4", "s8", "n5", "p2", "d3", "w5", "w3", "w8", "n6", "g2", "w4", "p5", "p4", "n2", "g1", "p6"], "s5": ["c2", "d5", "e8", "su4", "i3", "c6", "i5", "su12", " s12", "p1", "d1", "p6", "d2", "e5", "ss5", "s8", "e3", "c5", "p2", "s12", "ss2", "f6", "f5", "c1", "e1", "p5", "i1", "d6", "su5", "ss12", "su2", "i8", "f1", "ss4", "f2"], "s6": ["si11", "n8", " s11", "f8", " s12", "n4", "g4", "ses11", "ses12", "si8", "f3", "g8", "g6", "s11", "ses8", " s8", "s8", "f4", "p7", "p2", "s12", "f6", "n6", "p8", "g2", "p4", "si12", "ses6", "si6", "n7", "p6"], "s7": ["ssl712", "z7", "sets712", "session712", "s07", "h13", " s667", "s17", "ssl718", "z07", "sys87", "v718", "es667", "z87", "l13", " s07", "es7", "ssl7", "s13", "z718", " s8", "sets7", "p07", "sys7", "sys07", "l5", "s8", "p7", "s57", "session7", "ssl17", "v7", "v87", "h5", " s13", "sets718", "p8", "l7", "session718", "sets17", "s87", "s712", "h7", " s57", "l57", "h57", "s667", "p667", "sys718", "es07", "session17", "v07", "es8", "s718"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 25091, "substitutes": {"p": ["pp", "pa", "np", "k", "i", "m", "b", "c", "d", "data", "api", "P", "jp", "ps", "bp", "op", "proc", "u", "e", "sp", "patch", "o", "pb", "s", "http", "per", "progress", "wp", "lp", "f", "n", "j", "tp", "t", "fp", "a", "v", "r", "pre", "l", "post", "pc", "ap", "g"]}}
{"project": "FFmpeg", "commit_id": "2c9be3882a03823413945bd9e2d9af33e6e322d5", "target": 0, "func": "static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,\n\n                              ScanTable *intra_scantable,\n\n                              uint16_t luma_intra_matrix[64],\n\n                              uint16_t chroma_intra_matrix[64],\n\n                              int hsample[3])\n\n{\n\n    int i, j, size;\n\n    uint8_t *ptr;\n\n    MpegEncContext *s = avctx->priv_data;\n\n\n\n    if (avctx->codec_id != AV_CODEC_ID_LJPEG) {\n\n        int matrix_count = 1 + !!memcmp(luma_intra_matrix,\n\n                                        chroma_intra_matrix,\n\n                                        sizeof(luma_intra_matrix[0]) * 64);\n\n    if (s->force_duplicated_matrix)\n\n        matrix_count = 2;\n\n    /* quant matrixes */\n\n    put_marker(p, DQT);\n\n    put_bits(p, 16, 2 + matrix_count * (1 + 64));\n\n    put_bits(p, 4, 0); /* 8 bit precision */\n\n    put_bits(p, 4, 0); /* table 0 */\n\n    for(i=0;i<64;i++) {\n\n        j = intra_scantable->permutated[i];\n\n        put_bits(p, 8, luma_intra_matrix[j]);\n\n    }\n\n\n\n        if (matrix_count > 1) {\n\n            put_bits(p, 4, 0); /* 8 bit precision */\n\n            put_bits(p, 4, 1); /* table 1 */\n\n            for(i=0;i<64;i++) {\n\n                j = intra_scantable->permutated[i];\n\n                put_bits(p, 8, chroma_intra_matrix[j]);\n\n            }\n\n        }\n\n    }\n\n\n\n    if(avctx->active_thread_type & FF_THREAD_SLICE){\n\n        put_marker(p, DRI);\n\n        put_bits(p, 16, 4);\n\n        put_bits(p, 16, (avctx->width-1)/(8*hsample[0]) + 1);\n\n    }\n\n\n\n    /* huffman table */\n\n    put_marker(p, DHT);\n\n    flush_put_bits(p);\n\n    ptr = put_bits_ptr(p);\n\n    put_bits(p, 16, 0); /* patched later */\n\n    size = 2;\n\n\n\n    // Only MJPEG can have a variable Huffman variable. All other\n\n    // formats use the default Huffman table.\n\n    if (s->out_format == FMT_MJPEG && s->huffman == HUFFMAN_TABLE_OPTIMAL) {\n\n        size += put_huffman_table(p, 0, 0, s->mjpeg_ctx->bits_dc_luminance,\n\n                                  s->mjpeg_ctx->val_dc_luminance);\n\n        size += put_huffman_table(p, 0, 1, s->mjpeg_ctx->bits_dc_chrominance,\n\n                                  s->mjpeg_ctx->val_dc_chrominance);\n\n\n\n        size += put_huffman_table(p, 1, 0, s->mjpeg_ctx->bits_ac_luminance,\n\n                                  s->mjpeg_ctx->val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, s->mjpeg_ctx->bits_ac_chrominance,\n\n                                  s->mjpeg_ctx->val_ac_chrominance);\n\n    } else {\n\n        size += put_huffman_table(p, 0, 0, avpriv_mjpeg_bits_dc_luminance,\n\n                                  avpriv_mjpeg_val_dc);\n\n        size += put_huffman_table(p, 0, 1, avpriv_mjpeg_bits_dc_chrominance,\n\n                                  avpriv_mjpeg_val_dc);\n\n\n\n        size += put_huffman_table(p, 1, 0, avpriv_mjpeg_bits_ac_luminance,\n\n                                  avpriv_mjpeg_val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, avpriv_mjpeg_bits_ac_chrominance,\n\n                                  avpriv_mjpeg_val_ac_chrominance);\n\n    }\n\n    AV_WB16(ptr, size);\n\n}\n", "idx": 25095, "substitutes": {"avctx": ["apcontext", "afpc", "AVconfig", "avecontext", "AVconn", "afconnection", "apctx", "Avvoc", "avcontext", "avsci", "AVcf", "afcf", "aveconfig", "avconfig", "afcontext", "afctx", "avectx", "AVpc", "afsc", "avvoc", " avsci", "airpc", "avconnection", "aveconn", "aveconnection", "avpc", "apcf", "airctx", "Avcontext", "apconfig", "AVconnection", "AVctx", "avconn", "afsci", "aircontext", "AVsc", "afvoc", " avcontext", "afconn", "avsc", "airconn", " avvoc", "Avsci", "AVcontext", "avcf", "Avctx", "afconfig", "avesc"], "p": ["complete", "exec", "pp", "pa", "package", "np", "er", "param", "m", "b", "c", "pkg", "d", "x", "or", "api", "img", "P", "up", "jp", "ps", "bp", "op", "port", "proc", "u", "private", "e", "python", "sp", "point", "patch", "hp", "o", "pb", "progress", "per", "at", "http", "pl", "ctx", "cp", "like", "cache", "current", "wp", "comp", "part", "lp", "f", "y", "pr", "tp", "t", "php", "fp", "pair", "a", "v", "r", "pi", "pre", "vp", "result", "l", "post", "pc", "ap", "g"], "intra_scantable": ["intra_scardable", "intra_scantiable", "intra_scantatable", "intra_descantable", "intra_descantation", "intra_expaintative", "intra_scartable", "intra_scartada", "intra_scceptation", "intra_descantiable", "intra_scartacle", "intra_swantatable", "intra_scartatable", "intra_scatable", "intra_scanniable", "intra_swantacle", "intra_swattatable", "intra_scaintative", "intra_descannation", "intra_scantacle", "intra_scactables", "intra_scutada", "intra_swantada", "intra_scutable", "intra_scattacle", "intra_scceptiable", "intra_scaintada", "intra_expaintable", "intra_expantada", "intra_scannation", "intra_scantative", "intra_scattada", "intra_descanniable", "intra_scantada", "intra_expaintada", "intra_scardada", "intra_swattacle", "intra_swantable", "intra_scannables", "intra_scatation", "intra_expantative", "intra_descannable", "intra_scantables", "intra_scactable", "intra_scardatable", "intra_scutative", "intra_scattatable", "intra_scannable", "intra_scactiable", "intra_scactation", "intra_scantation", "intra_expaintation", "intra_scatada", "intra_scaintation", "intra_descannables", "intra_scatative", "intra_scardacle", "intra_descantables", "intra_scattable", "intra_swattable", "intra_scaintable", "intra_scutation", "intra_expantation", "intra_scceptable", "intra_scceptables", "intra_expantable", "intra_swattada"], "luma_intra_matrix": ["luma_intra_projectrix", "luma_intra_matrics", "luma_intra_protric", "luma_intra_atensor", "luma_intra_atramid", "luma_intra_bitric", "luma_intra_attensor", "luma_intra_latribution", "luma_intra_contrix", "luma_intra_monric", "luma_intra_monrices", "luma_intra_protramid", "luma_intra_protri", "luma_intra_projectramid", "luma_intra_matrices", "luma_intra_projectric", "luma_intra_latrix", "luma_intra_metrix", "luma_intra_attribution", "luma_intra_bitrices", "luma_intra_atrics", "luma_intra_attrix", "luma_intra_projectri", "luma_intra_contric", "luma_intra_contractor", "luma_intra_latensor", "luma_intra_attric", "luma_intra_atribution", "luma_intra_atric", "luma_intra_bitrix", "luma_intra_metric", "luma_intra_metrices", "luma_intra_bitrics", "luma_intra_atri", "luma_intra_protrix", "luma_intra_monrics", "luma_intra_matric", "luma_intra_matractor", "luma_intra_latric", "luma_intra_atrix", "luma_intra_atrices", "luma_intra_metractor", "luma_intra_matri", "luma_intra_contrices", "luma_intra_matensor", "luma_intra_matramid", "luma_intra_matribution", "luma_intra_atractor", "luma_intra_monrix"], "chroma_intra_matrix": ["chroma_intra_metrices", "chroma_intra_atment", "chroma_intra_attogram", "chroma_intra_attrices", "chroma_intra_matment", "chroma_intra_matrics", "chroma_intra_atrics", "chroma_intra_attment", "chroma_intra_metric", "chroma_intra_mitrices", "chroma_intra_matric", "chroma_intra_metrics", "chroma_intra_monrix", "chroma_intra_matogram", "chroma_intra_atrix", "chroma_intra_monric", "chroma_intra_mitogram", "chroma_intra_metrix", "chroma_intra_atrices", "chroma_intra_atogram", "chroma_intra_atric", "chroma_intra_monogram", "chroma_intra_attrix", "chroma_intra_monment", "chroma_intra_matrices", "chroma_intra_mitrics", "chroma_intra_attric", "chroma_intra_mitrix", "chroma_intra_mitric"], "hsample": ["hopsample", "hhamples", "psamp", "hhpec", "hhamp", "hsamples", "hopspec", "HSample", "hopsamples", "psample", "pssample", "ricssample", "HSamples", "ricsamples", "ricsamp", "hopsamp", "HSamp", "hopssample", "hssample", "psamples", "hsamp", "hspec", "hhample", "ricsample", "HSpec"], "i": ["my", "z", "ie", "b", "yi", "c", "d", "ix", "x", "ti", "mi", "phi", "qi", "it", "ri", "id", "io", "ani", "ui", "u", "e", "key", "li", "ji", "o", "gi", "xi", "uri", "ii", "ini", "si", "ai", "bi", "ni", "di", "hi", "ci", "fi", "ik", "eni", "vi", "I", "f", "y", "oi", "n", "ip", "index", "ori", "v", "iu", "r", "pi", "ind", "in", "l", "mu", "init", "ami", "g"], "j": ["jit", "k", "z", "ie", "b", "m", "uj", "adj", "d", "kj", "x", "job", "je", "jo", "jp", "aj", "qi", "jj", "ani", "u", "key", "e", "o", "ji", "li", "xi", "jc", "ii", "offset", "si", "ni", "ij", "jet", "f", "y", "jl", "js", "n", "index", "q", "v", "J", "r", "pos", "ui", "l", "dj", "ja", "g"], "size": ["code", "sc", "z", "ize", "sn", "shift", "c", "empty", "sized", "ix", "x", "sum", "weight", "address", "capacity", "speed", "Size", "e", "sp", "unit", "SIZE", "loc", "small", "offset", "si", "ci", "sec", "scale", "count", "n", "index", "g", "l", "cs", "len", "sh"], "ptr": ["code", "scope", "ft", "pt", "dim", "dr", "buffer", "trace", "oper", "br", "pointer", "address", "inst", "push", "port", "tr", "rw", "depth", "str", "err", "tmp", "loc", "ii", "offset", "fl", "rc", "alloc", "iv", "Ptr", "addr", "length", "index", "src", "inter", "attr", "pos", "len", "val", "sh"], "s": ["S", "space", "sc", "ses", "sys", "b", "m", "parser", "c", "ns", "data", "buffer", "storage", "sq", "support", "sg", "id", "all", "e", "stats", "gs", "sp", "o", "session", "spec", "sv", "si", "client", "sb", "services", "sa", "f", "service", "bytes", "js", "n", "a", "t", "r", "settings", "ops", "_", "ssl", "cs", "params", "g"]}}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103, "substitutes": {"machine": ["space", "node", "kernel", "class", "scope", "info", "b", "m", "server", "image", "manager", "template", "module", "data", "base", "hard", "config", "interface", "address", "state", "loader", "mac", "instance", "mobile", "linux", "jam", "boot", "e", "cell", "home", "message", "process", "session", "M", "object", "model", "mode", "cache", "vm", "device", "note", "part", "slave", "comment", "computer", "host", "Machine", "database", "managed", "connection", "table"], "spapr": ["spapers", "skarpb", "scapeyr", "spapre", "spuprb", "spapprb", " spappb", " spapsrs", " spapsar", "SPaprator", "sparprc", "SPapper", "spashr", " spappru", " spaptrb", "sparpsr", "spaprator", "spapl", "SPapprs", "scapeb", "spampsr", "spapert", "spamper", "scaprt", "spAPR", "spupra", " spapR", "scapert", "spaptra", " spapl", "spappsr", "spapsar", " spapsr", "spaitrs", "spupl", "skarpar", " spaprb", "spapb", "scapers", "scapyr", "sprapr", " spappre", "spapprt", "spapepr", "spaptrb", "skapsr", "spappru", "spapsru", "spaprt", " spaprt", "spraprs", "scapb", "scapr", "sparprator", "spAPr", "spapeb", "scapeer", " spapb", "sparpr", "spaityr", "spaprb", "spapprs", "spapprc", "spapsrator", "spraprb", "spapsr", "spappre", "SPapprator", "spapper", "spamprt", "spapsrs", " spaptl", "SPaprc", "spapyr", "spadr", "spappar", "spampb", "scappr", "spapsrc", "spampre", "SPapr", "sprapl", "SPapprc", " spapru", "sparpb", " spapprt", "spupr", "spapsR", "spapeer", "spaperar", " spapper", " spaprs", "spapra", "spadpr", "spapsrb", " spapra", "SPapprb", " spapsru", "skapar", "spappb", "spashrt", " spappsr", "spadyr", "SPaper", "spaprc", "spapR", " spappr", "spapar", "spAPru", "spapprator", "skapb", " spaptra", "scapepr", " spapre", "spaperr", "SPappr", "spampru", " spapar", "scaprs", "spaitr", "spaptr", "SPaprs", "spapeyr", "sparprs", "spapru", "spasher", "spaptar", "spapser", "sprapra", "spaitpr", "spampR", " spaptr", "skapr", "SPaprb", "spaptl", "spashre", "spAPrs", "scaper", "spamprs", "spaperb", "spapsl", "sparpar", " spaper", "sparpru", "spapersr", "skarpr", "spaper", "skarpsr", "spampr", "spadrs", " spapsR", "sprapar", "spaptrs", "spaprs", "spappr", " spapsl"], "smc": ["smp", "mmc", "SMc", "smf", "svf", "svp", "svc", "svcc", "smcc", "SMf", "SMcc", "SMp", "mmf", "mmp", "mmcc"], "kernel_filename": ["linux_source", "kernelingfilename", "kernelpubfile", "linux_filename", "kernelingdescription", " kernel_file", "kernel_description", "kernel___description", "kernelpubfilename", "kernel___username", "kernelpubusername", "linux_description", "kernel_file", "kernel_password", " kernel_username", "kernel___filename", "kernel___source", "linux_username", "kernelpubpassword", "kernelingsource", "kernel_source", "kernelingusername", "kernel_username", " kernel_password"], "kernel_cmdline": ["kernel_macLine", "kernel_hostline", "kernel_cleanname", "kernel_hostLine", "kernel_commandli", "kernel_commandLine", "kernel_cmdli", "kernel_hostli", "kernel_cmdname", "kernel_cmdLine", "kernel_macline", "kernel_commandname", "kernel_cleanline", "kernel_cleanLine", "kernel_commandline", "kernel_hostname", "kernel_macli"], "initrd_filename": ["initrt_mode", "initrs_name", "initrs_location", "initrt_name", "initrs_filename", "initrt_filename", "initrd_name", "initrs_file", "initrd_location", "initrd_file", "initrd_mode", "initrt_file"], "cpu": ["CPU", "processor", "node", "gnu", "proc", "linux", "gpu", "mx", "boot", "disk", "mem", "hw", "lu", "nic", "process", "pool", "cow", "cp", "gp", "cache", "vm", " CPU", "conn", "computer", "net", "pu", "pc"], "phb": ["ppbs", "ppp", "PHbs", "ppB", "PHp", "phB", "php", "PHb", " phB", "PHB", "phbs", " phbs", "ppb", " php"], "i": ["z", "p", "m", "b", "c", "d", " I", "it", "ri", "io", "is", "e", "o", "s", "si", "ai", "ni", "ress", "h", "I", "f", "n", "j", "ip", "a", "r", "pi", "l"], "sysmem": ["systemram", "procmem", "sysmemory", "procmemory", " syslang", " sysram", "sysram", "procram", "systemlang", " sysmemory", "systemmem", "systemmemory", "proclang", "syslang"], "ram": ["gram", "RAM", "sc", "rom", "image", "sam", "tm", "img", "access", "iam", "mac", "instance", "range", "rams", "disk", "mem", "cms", "resource", "process", "mode", "cow", "cache", "AM", "ream", "sim", "mm", "Ram", "cam"], "rma_region": ["rna_location", "rma_location", "rna_region", "rna_resource", "rma_resource", "rma_area", "rna_area"], "rma": ["Rmas", "nrmas", "Rta", "srta", "rga", "Rfa", "rfa", "Rga", "srfa", "rta", "nrga", " rga", "nrma", "srma", "Rma", "srmas", " rta", " rfa", "nrfa", " rmas", "rmas"], "rma_alloc_size": ["rma_alloc__count", "rma_alloc_small", "rma_alloc32small", "rma_alloc32number", "rma_alloc_scale", "rma_alloc__num", "rma_alloc_address", "rma_alloc32size", "rma_allocetnum", "rma_alloc32scale", "rma_allocallscale", "rma_alloc_length", "rma_alloc_id", "rma_allocetize", "rma_allocetcount", "rma_alloc_ize", "rma_allocallunit", "rma_alloc_num", "rma_loc_size", "rma_loc_count", "rma_allocallid", "rma_alloc__ize", "rma_allocallsize", "rma_alloc_name", "rma_alloc_unit", "rma_alloc_number", "rma_allocetsize", "rma_alloc__size", "rma_loc_num", "rma_alloc_count", "rma_alloc_capacity", "rma_loc_ize"], "load_limit": ["loader_limit", "loader_limits", "load___policy", "load___lim", "loadingpolicy", "loader_length", "loadinglength", "load_limits", "loader_limited", "load_policy", "loadinglim", "load___limit", "load___length", "load_limited", "loader_lim", "load_lim", "load_length", "loadinglimit", "loader_policy"], "fw_size": ["hw_capacity", "hw_size", "hw_length", "fw_address", "fw_capacity", "hw_address", "fw_length"], "filename": ["processor", "dll", "name", "phrase", "fn", "prefix", "loader", "alias", "Filename", "url", "password", "cmd", "jpg", "path", "uri", "original", "wav", "files", "username", "src", "fil", "description", "title", "fd", "file"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n", "idx": 25113, "substitutes": {"s": ["comments", "sys", "server", "ns", "ts", "sites", "ps", "states", "sync", "self", "u", "es", "south", "gs", "sym", "xs", "f", "service", "js", "n", "fs", "qs", "t", "tests", "ops", "S", "p", "b", "c", "ds", "us", "ins", "su", "is", "sets", "spec", "new", "services", "src", "settings", "in", "its", "g", "rs", "ses", "args", "ss", "features", "bis", "d", "conf", "sg", "ks", "e", "session", "less", "sb", "your", "full", "sf", "ssl", "cs", "sc", "i", "strings", "si", "os", "uns", "as", "ls", "l"], "otp_region": ["otp8reg", "otcp_division", "otip_string", "otp_version", "otcp_union", "otp_division", "otp_location", "otp_string", "otp_union", "otip_country", "otp_country", "otip_location", "otp_reg", "otpa_region", "otpa_location", "otp8region", "otcp_region", "otpa_version", "otp8location", "otip_region", "otcp_location", "otp8version", "otpa_reg", "otcp_reg"], "dinfo": ["DInfo", "sdInfo", "Dinfo", " dafi", "idinfo", "Ddata", "dblock", "dbni", " darea", "dbafi", " dinf", "carea", "cinfo", " dblock", "darea", "ddinfo", "dbisu", "ddni", "winfo", " disu", "dinf", " dni", "dInfo", "ddata", "finfo", "wblock", "dafi", "sdinfo", "disu", "ddisu", "dni", " ddata", "cInfo", "idInfo", "ddafi", "iddata", " dInfo", "sddata", "cblock", "wInfo", "fInfo", "sdinf", "finf", "warea", "fdata", "dbinfo"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 25119, "substitutes": {"env": ["fen", "her", "exc", "server", "manager", "enc", "vs", "qa", "chal", "operator", "export", "dict", "inet", "ne", "u", "el", "ef", "ini", "dt", "ig", "edge", "ou", "n", "core", "et", "obj", "p", "m", "engine", "c", "cv", "ec", "en", "Environment", "inst", "fr", "proc", "enter", "energy", "fx", "eni", "cache", "oa", "h", "forge", "event", "settings", "assets", "que", "equ", "gui", "txt", "args", "np", "console", "context", "inv", "eve", "conf", "global", "loader", "ev", "ea", "db", "e", "cfg", "extra", "output", "sb", "init", " environment", "org", "config", "py", "end", "environment", "site", "rev", "viron", "eu", "vm", "ext", "conn", "net", "un", "v", "eng"], "f": ["exec", "fen", "fe", "af", "fo", "b", "p", "m", "c", "fac", "d", "function", "rf", "x", "fn", "filename", "bf", "fm", "form", "fr", "u", "e", "fc", "feed", "o", "ff", "fw", "fb", "fi", "cf", "fx", "fore", "buff", "h", "fun", "fs", "tf", "n", "fa", "j", "t", "fp", "func", "v", "r", "sf", "l", "fd", "file", "F"], "cpu_fprintf": ["cpu_fbformat", "cpu__rfprintf", "cpulogfformat", "cpu__fwrite", "cpu_frep", "cpu_rfprintf", "cpu__rfrint", "cpulexfprint", "cpu2rfxp", "cpu_fbrep", "cpu__fecho", "cpu_lenny", "cpu_grint", "cpu_bwrite", "cpulexfformat", "cpu_dwrite", "cpu2fformat", "cpu_cprintf", "cpu_wxp", "cpulexlprint", "cpu_inflt", "cpu_rfrep", "cpu__frint", "cpu_rfxp", "cpu_fprintln", "cpu_dformat", "cpu_fenny", "cpu_confecho", "cpu_rfformat", "cpu__fprintf", "cpu_rfprintln", "cpu_confformat", "cpu_fblt", "cpuloginfprintf", "cpu_Faffle", "cpupyefprint", "cpuloginfformat", "cpu_wprintf", "cpu_cformat", "cpu_frint", "cpulexfenny", "cpupyfprintf", "cpu_lprint", "cpu_confrep", "cpu_dprintf", "cpu_fmt", "cpu_confprintf", "cpu_fwrite", "cpu2fprintln", "cpuloginfrep", "cpulogflt", "cpulogfprintf", "cpu2rfformat", "cpu_confrint", "cpu_Fmt", "cpu_rfmt", "cpu_fformat", "cpu_clt", "cpupyfprintln", "cpu2fprintf", "cpu_efprintln", "cpu_cenny", "cpupyfetch", "cpupyefprintf", "cpu_infrep", "cpu__dwrite", "cpu_infformat", "cpu_baffle", "cpulexfprintf", "cpu_wformat", "cpupyefetch", "cpu_grep", "cpulogfrep", "cpu_fbprintf", "cpu_cprintln", "cpu_wprintln", "cpupyfprint", "cpu_decho", "cpu2fxp", "cpu_cwrite", "cpuloginflt", "cpu_cecho", "cpu_fecho", "cpu_rfenny", "cpulexlformat", "cpu_efprintf", "cpu_Fprint", "cpu_Fxp", "cpu2rfprintf", "cpu_Fprintf", "cpu_confwrite", "cpu_flt", "cpu__fformat", "cpu_faffle", "cpu__rfrep", "cpu_efprint", "cpu2rfprintln", "cpu_cprint", "cpu__frep", "cpu_Fwrite", "cpulexlprintf", "cpu_Fformat", "cpu_rfrint", "cpupyefprintln", "cpu_bprintln", "cpu_cetch", "cpu__dprintf", "cpu_lformat", "cpu_gprintf", "cpu_efetch", "cpu_fetch", "cpu_fprint", "cpu_rfprint", "cpu_caffle", "cpu_lprintf", "cpulexlenny", "cpu_crep", "cpu__dformat", "cpu_bprintf", "cpu_fxp", "cpu_Fprintln", "cpu_infprintf", "cpu__decho"], "flags": ["ants", "args", "lbs", "features", "flag", "frames", "ips", "ils", "vs", "Flags", " Flags", "forces", "ports", "types", "vals", "lf", "stats", "options", "ff", "fps", "fields", "eth", "fl", "does", "faces", "lag", "utils", "fx", "files", "fires", "len", "alf", "fg", "ags", "fish", "fs", "bits", "status", "alls", "settings", "ops", "fd", "ints", "fun"], "c0_status": ["c0_stats", "c0Pstat", "c15lexstatus", "c0lexStatus", "c1_status", "c0_state", "c15lexStatus", "c0_err", "c0lexstatus", "c15lexsuccess", "c15_status", "c0_level", "c1_stats", "c0_width", "c1_err", "c1_stat", "c0_Status", "c0lexlevel", "c1_Status", "c0lexsuccess", "c0Pspeed", "c15lexlevel", "c15_success", "c0Pstatus", "c1_state", "c0_speed", "c15_level", "c1_width", "c0Pstate", "c0_success", "c1_speed", "c15_Status", "c0_stat"], "i": ["abi", "code", "k", "yi", "p", "b", "m", "c", "info", "d", "uli", "uni", "x", "api", "base", "adi", "ti", "mi", "diff", "col", "type", "phi", "qi", "it", "ri", "io", "id", "u", "e", "gi", "o", "li", "zi", "multi", "xi", "uri", "start", "ii", "di", "si", "ai", "bi", "ni", "ini", "cli", "ci", "fi", "eni", "conv", "h", "loop", "I", "oi", "n", "ip", "j", "index", "t", "v", "iu", "mu", "pi", "r", "in", "ui", "l", "hi"]}}
{"project": "FFmpeg", "commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "target": 1, "func": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n", "idx": 25130, "substitutes": {"state": ["code", "body", "obj", "args", "param", "callback", "data", "test", "oper", "State", "config", "media", "address", "inst", "states", "store", "proc", "private", "boot", "seed", "resource", "str", "start", "session", "inner", "st", "STATE", "ctx", "cache", "length", "addr", "buff", "part", "handle", "j", "conn", "r", "settings", "attr", "params"], "hdr_info": ["hhr_inter", "hdrsInfo", "hhr_private", "hdr_id", "hdr_error", "hdr0inter", "hhr_error", "hdrsid", "hdr_Info", "hhr_index", "hdr_private", "hDR_id", "hDR_diff", "hdr_diff", "hdr_di", "hDR_info", "hhr_Info", "hdr0info", "hdrsinf", "hdr_index", "hDR_inf", "hDR_di", "hdr0inf", "hhr_fo", "hDR_Info", "hhr_inf", "hhr_info", "hdr0private", "hdr_inf", "hdr_fo", "hdrsinfo", "hdr_inter"], "need_next_header": ["need_next_layer", "need_new_frame", "need_next_message", "need_new_message", "need_new_channel", "need_new_header", "need_next_channel", "need_new_layer", "need_next_frame"], "new_frame_start": ["new_frame2end", "new_frame_offset", "new_frame_pos", "new_fram_pos", "new_frame2start", "new_frame_id", "new_frame_set", "new_frame2id", "new_fram_set", "new_fram_end", "new_fram_id", "new_fram_start", "new_frame2set", "new_fram_offset", "new_frame_end"], "bits": ["temp", "pieces", "txt", "rs", "nets", " tcp", "features", "bis", "nos", "batch", "flags", "hops", "ips", "data", "pins", "config", "py", "cb", "opt", "bc", "mins", "bug", "outs", "ps", "proc", "self", "cmp", "locks", "bs", "mp", "lins", "boot", "stats", "options", "fps", "bit", "sections", "boxes", " buffers", "ctx", "sb", "utils", "cache", " props", "bugs", "buff", "bytes", "details", "rooms", "t", " bytes", "init", "bps", "pos", "settings", "ops", "parts", "tx", "params", "ints"], "hdr": ["wder", "hdvar", "ohdr", "hhdr", " hder", "phrs", "adhder", "ohder", "chdr", "bhver", "handhr", "herler", "hman", "adhrs", " hDR", "wdr", "hver", "rhdr", "adhDR", "chsr", " dhdr", "rhver", "hDR", " hver", "phDR", "handvar", "htr", "hvar", " hler", "hhr", " htr", "hler", "chrid", "hrid", "ohrid", "rhrs", "hhtr", "bhrs", "hldr", " hrid", "bhdr", "hller", "hlman", "phdr", "rhder", "whr", "phder", "bhder", "herman", "ohsr", "hder", " hman", "hsr", "handdr", "herdr", "hrs", "hddr", "hhder", "wvar", "handder", " hsr", "hdder", " dhder", "adhdr", "hdhr", " dhtr", "chder", " hrs"], "size": ["from", "code", "args", "ize", "i", "c", "empty", "sized", "x", "send", "sum", "en", "address", "capacity", "Size", "cmp", "unit", "extra", "SIZE", "start", "loc", "small", "offset", "new", "sec", "scale", "cache", "shape", "number", "rc", "length", "part", "handle", "count", "bytes", "n", "full", "pack", "iz", "ui", "pos", "len", "big"], "u8": ["f16", "uint6", "uint8", "U8", "c6", "f8", "ui16", "x16", "x8", "U16", "x6", "x32", "uint32", "ui6", "ui32", "u6", "c8", "u32", "U6", "c16", "c32", "f6", "u16", "f32", "ui8", "uint16", "U32"], "tmp": ["temp", "txt", "obj", "np", "app", "stuff", "bb", "data", "storage", "img", "rb", "config", "py", "jp", "vt", "cb", "prop", "fm", "inst", "proc", "cmp", "mp", "buf", "boot", "amp", "dat", "input", "nb", "ctx", "cp", "sb", "fb", "cache", "buff", "array", "uv", "part", "tf", "tp", "src", "fp", "attr", "bt", "params"]}}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,\n\n                       int sign)\n\n{\n\n    uint64_t ret = 0;\n\n#if defined(DEBUG_ASI)\n\n    target_ulong last_addr = addr;\n\n#endif\n\n\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    switch (asi) {\n\n    case 0x82: /* Primary no-fault */\n\n    case 0x8a: /* Primary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 25134, "substitutes": {"env": ["obj", "console", "np", "iss", "exc", "context", "cv", "shell", "enable", "enc", "ec", "qt", "en", "config", "chal", "eve", "conf", "cb", "py", "vt", "ev", "ea", "environment", "proc", "db", "e", "dh", "dat", "err", "ef", "viron", "dt", "eu", "fi", "cf", "emb", "eni", "erv", "iv", "req", "vm", "forge", "ext", "conn", "core", "init", "que", "equ", "eng"], "addr": ["socket", "acl", "server", "name", "enc", "gru", "add", "aug", "url", "arr", "bridge", "sta", "cmd", "start", "ord", "edge", "coord", "hop", "ptr", "osi", "da", "r", "nc", "area", "layer", "complete", "remote", "slice", "er", "arm", "x", "en", "align", "ad", "address", "prefix", "state", "work", "enter", "eni", "oa", "src", "attr", "kt", "node", "np", "usr", "data", "error", "mac", "ea", "alias", "rss", "player", "adr", "err", "la", "afi", "uri", "offset", "mode", "grade", "ar", "au", "xp", "rx", "alt", "host", "erg", "anne", "dc", "dr", "asm", "config", "ast", "pad", "amp", "grad", "advert", "loc", "art", "ret", "rc", "amd", "rt", "ext", "nr", "ip", "conn", "route", "adder", "ace", "ac"], "asi": ["asis", "ati", "acl", "ski", "ara", "i", "isa", "asu", "osa", "ta", "aa", "asm", "qa", "api", "adi", "ti", "sha", "address", "asio", "aka", "ei", "ani", "asa", "ity", "asia", "radius", "adr", "sta", "zi", "esi", "iso", "axis", "afi", "anza", "aaa", "uri", "ini", "si", "ai", "ni", "agi", "eni", "oa", "sa", "aci", " sa", "osi", "assi", " si", "ois", "pi", "anti", "ui", "ami", "arity", "params", "ais"], "size": ["esc", "complete", "code", "cm", "slice", "z", "page", "ize", "sn", "i", "c", "name", "sized", "empty", "large", "engine", "sh", "time", "enc", "storage", "sum", "en", "style", "align", "member", "address", "capacity", "hh", "speed", "Size", "form", "sync", "security", "unit", "south", "extra", "SIZE", "password", "gn", "loc", "small", "fee", "offset", "si", "mode", "sec", "scale", "number", "shape", "eni", "sort", "length", "six", "timeout", "source", "n", "ny", "year", "ui", "cs", "len", "format", "ice"], "sign": ["load", "secret", "account", "ize", "shift", "ss", "se", "sw", "enc", "send", "en", "sum", "align", "lex", "act", "wrap", "pass", "form", "plus", "sync", "sp", "gn", "spec", "small", "Sign", "magic", "ig", "connect", "inc", "scale", "rc", "shape", "ign", "mod", "round", " sig", "mini", "reg", "SIGN", "big", "format"]}}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift, ret;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance < FF_COMPLIANCE_STRICT) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Format does not strictly comply with VC2 specs\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, decrease strictness to use it.\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    ret = av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n    if (ret)\n\n        return ret;\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 25135, "substitutes": {"avctx": ["ovctx", "avcms", "navcontext", "ausys", "evcu", "ajx", "avcontext", "av\n", "afcontext", "ovcontext", "avectx", "avctl", "ajctx", "ajcmp", "avekb", "abcmp", "avecmp", "navcu", "svctx", "navcca", "au\n", "ovconn", "afsys", "AVcontext", "avcu", "aucf", "aj\n", "avepkg", "avcca", "abcontext", "AVconv", "afctx", "evchan", "avpkg", "avchan", "nav\n", "abconv", "avecms", "avloc", "abctx", "aveloc", "AVctx", "avnum", "auloc", "ovchan", "avcf", "navnum", "AVcmp", "avecontext", "evcontext", "AVconn", "afchan", "avcmp", "AVcu", "aunum", "aucontext", "ajctl", "ivcms", "avecu", "auctx", "ivctx", "navpkg", "evctx", "navx", " avcf", "abconn", "navcmp", "AVpkg", "avconn", "ajpkg", "afconn", "ajcontext", "AVcca", "navconn", "afctl", "ivcontext", "evcmp", "afpkg", "ajconv", "avecca", "avkb", "AVcf", "auconn", "aux", "afcu", "ivkb", "AVkb", "svpkg", "svcontext", "evconn", "avsys", "aveconn", "avconv", " avconn", " avcontext", "ajnum", "svctl", "afloc", "AVcms", "navctx", "avesys", "afcmp", "avx"], "p": ["pp", "pa", "np", "m", "c", "P", "jp", "pe", "bp", "op", "u", "e", "hp", "pb", "cp", "gp", "wp", "lp", "n", "tp", "t", "q", "pu", "pi", "pre", "pc", "ap"], "b": ["bin", "c", "lb", "bb", "buffer", "base", "rb", "br", "ab", "bd", "gb", "cb", "bp", "bs", "boot", "buf", "nb", "binary", "sb", "B", "bar", "a", "v", "l", "ib"], "i": ["gu", "abi", "k", "z", "ie", "m", "c", "yi", "info", "name", "d", "uni", "ix", "uli", "x", "ti", "mi", "phi", "qi", "it", "ri", "id", "io", "ui", "is", "depth", "e", "gi", "li", "ji", "zi", "multi", "start", "xi", "uri", "inner", "ii", "bi", "ini", "ai", "di", "ni", "si", "ci", "fi", "eni", "source", "part", "I", "f", "ki", "oi", "n", "index", "ip", "chi", "mini", "y", "t", "iu", "ind", "v", "pi", "in", "l"], "j": ["k", "pop", "z", "m", "uj", "jp", "it", "op", "key", "li", "rel", "ji", "ii", "ij", "note", "im", "f", "jl", "js", "n", "q", "v", "J", "pos", "l", "len"], "level": ["height", "temp", "sc", "file", "code", "low", "scope", "lvl", "server", "name", "position", "time", "weight", "style", "delay", "pe", "col", "type", "speed", "version", "profile", "depth", "key", "line", "unit", "rel", "cl", "str", "path", "levels", "loc", "fl", "role", "mode", "le", "parent", "grade", "size", "inc", "scale", "length", "zip", "count", "stage", "source", "value", "limit", "index", "quality", "volume", "q", "where", "full", "vel", "hi", "len", "val", "priority", "lock", "layer"], "o": ["m", "option", "position", "ob", "no", "opt", "type", "io", "op", "oe", "num", "e", "ol", "offset", "mode", "os", "mo", "oa", "f", "po", "oi", "n", "out", "O", "range"], "shift": ["skip", "pop", "dim", "cv", "dr", "br", "jp", "cb", "type", "push", "ch", "op", "depth", "max", "offset", "mode", "cp", "sort", "size", "rc", "scale", "off", "sup", "length", "src", "pos", "len"], "ret": ["std", "dim", "quiet", "flag", "back", "en", "no", "mi", "att", "nz", "deep", "rows", "num", "rec", "depth", "bit", "fl", "mode", "pin", "rc", "Ret", "count", "alt", "len", "val", "layer"], "fmt": ["tfmt", " fmp", "filt", "cMT", "frmt", "fnm", " flt", " frt", "frformat", "Filt", " filt", "fformat", "defmt", "Frt", "tflt", "fmp", "plt", "ctm", "infformat", "infmn", "inftt", "forprintf", "formMT", "tfMT", "milt", "Fmp", "flt", "rfMT", "cnt", "ftt", "deftt", "formt", "Fnt", "ptm", "rfmt", "forformat", "pmt", "mmt", "tftm", "tfilt", "formrt", "fnt", "rfilt", "frt", "formlt", " fnt", "formmt", " fMT", "mmp", " ftm", "FMT", " fformat", " fnm", "tfformat", "ftm", "infmt", "Fnm", "Flt", "forilt", "mMT", "defmn", "mtm", "defformat", "fortm", "infprintf", "mprintf", "infilt", "frtt", "tfrt", "prt", "fmn", "fMT", "cmt", "Ftm", "Fmt", "rfnm", "frmn", "mformat"], "s": ["comments", "sys", "ns", "ts", "sites", "sq", "ps", "secondary", "sync", "self", "u", "es", "gs", "stats", "sym", "xs", "f", "fs", "qs", "js", "n", "service", "t", "r", "ops", "S", "m", "c", "storage", "ds", "ins", "su", "is", "sets", "spec", "new", "services", "details", "settings", "its", "g", "rs", "ses", "ss", "d", "data", "conf", "sg", "ks", "e", "session", "hs", "sb", "full", "ssl", "sv", "cs", "params", "info", "site", "si", "os", "ctx", "sup", "ls", "groups", "a", "v", "parts", "l"]}}
{"project": "FFmpeg", "commit_id": "b86651a208ee67666a7305b002bc9f14b21dae7f", "target": 1, "func": "static av_cold int rv40_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n\n\n    r->rv30 = 0;\n\n    ff_rv34_decode_init(avctx);\n\n    if(!aic_top_vlc.bits)\n\n        rv40_init_tables();\n\n    r->parse_slice_header = rv40_parse_slice_header;\n\n    r->decode_intra_types = rv40_decode_intra_types;\n\n    r->decode_mb_info     = rv40_decode_mb_info;\n\n    r->loop_filter        = rv40_loop_filter;\n\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n\n    return 0;\n\n}\n", "idx": 25149, "substitutes": {"avctx": ["afcas", "ivcontext", "navkb", "avcc", "navcontext", "AVcmp", "AVcontext", "avecontext", "ivcrit", "avcmp", "afkb", "awcontext", "afcrit", "ajcc", "awctx", "avecrit", "avcontext", "awcas", "avkb", "ivca", "avca", "ivctx", "afcontext", "afctx", "avectx", "AVcc", "afca", "ajctx", "ajcmp", "avcrit", "awkb", "AVctx", "aveca", "navcas", "avcas", "afcc", "ajcontext", "navctx", "afcmp"], "r": ["ru", "rs", "ner", "er", "sr", "i", "p", "m", "b", "c", "d", "dr", "or", "data", "rb", "br", "cr", "mr", "reader", "fr", "self", "tr", "u", "e", "o", "arr", "adr", "R", "rh", "err", "rar", "l", "re", "rc", "rg", "ar", "ur", "kr", "array", "ir", "rt", "f", "nr", "pr", "n", "t", "v", "attr", "rr", "result", "hr", "g"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25163, "substitutes": {"opaque": ["ospacity", "ospque", "ipicit", "compacity", "openque", "ospaque", "ipacity", "openacity", "ospicit", "Opaque", "compaque", "Opicit", "ipque", " opque", " opacity", "ipaque", "compque", "openaque", "opacity", "opque", "Opque", "Opacity", "opicit"], "sprn": ["Sprnum", "Sprns", "prb", "prN", "prn", "wrnum", " sprb", "Sprb", "wrn", "wrb", "sprnum", "prns", "sprns", " sprN", "sprN", "sprb", "Sprn", "wrN", "prnum", " sprns", "SprN"], "ctx": ["exec", "ref", "cm", "acl", "obj", "cca", "scope", " context", "anc", "c", "pkg", "context", "cv", "qa", "jp", "cb", "prefix", "bc", "sync", "bp", "proc", "cmp", "grad", "unc", "loc", "cc", "cp", "cf", "rc", "alloc", "cas", "lc", "ctrl", "ca", "src", "conn", "fp", "tx", "pc", " cx"]}}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167, "substitutes": {"format": ["space", "call", "package", "args", "argument", " formatting", "transform", "name", "function", "template", "time", "data", "attribute", "style", "ant", "pointer", "text", "filename", "base", "letter", "type", "prefix", "property", "version", "Format", "form", "character", "method", "unit", "str", "term", "command", "at", "pattern", "spec", "magic", "size", "scale", "feat", "field", "length", "arg", "array", "before", "f", "source", "value", "pretty", "alpha", "language", "len", "file"]}}
{"project": "FFmpeg", "commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "target": 1, "func": "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n\n                                   uint8_t **data, int *size)\n\n{\n\n    static const int extradata_nal_types_hevc[] = {\n\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n\n    };\n\n    static const int extradata_nal_types_h264[] = {\n\n        H264_NAL_SPS, H264_NAL_PPS,\n\n    };\n\n\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n\n\n    H2645Packet h2645_pkt = { 0 };\n\n    int extradata_size = 0;\n\n    const int *extradata_nal_types;\n\n    int nb_extradata_nal_types;\n\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n        extradata_nal_types    = extradata_nal_types_hevc;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n\n    } else {\n\n        extradata_nal_types    = extradata_nal_types_h264;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n\n    }\n\n\n\n    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,\n\n                                ctx, 0, 0, ctx->par_in->codec_id, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &h2645_pkt.nals[i];\n\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n\n            extradata_size += nal->raw_size + 3;\n\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n\n            } else {\n\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (extradata_size &&\n\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n", "idx": 25179, "substitutes": {"ctx": ["exec", "txt", "tk", "sc", "cm", "kw", "np", "cca", "p", " context", "anc", "c", "pkg", "context", "cv", "qa", "qt", "sq", "config", "conf", "jp", "cb", "ct", "bc", "concept", "sync", "kb", "cmp", "fc", "cmd", "cms", "grad", "vc", "wcs", "Context", "cc", "cp", "ci", "cf", "client", "rc", "sci", "conv", "req", "cas", "git", "lc", "ctrl", "ca", "qs", "tc", "cu", "conn", "fp", "q", "ck", "tx", "cs", "cam", "pc", "kt"], "pkt": ["het", "pct", "Pelt", " packet", "pkg", "cpacket", "pke", "psth", "helt", "Psth", " pelt", "hkg", "packet", " pet", " pct", "hacket", "Pkg", "Packet", "pelt", "hke", "Pke", "pet", " pke", "cpkt", "cpct", " pkg", " psth", "Pkt", "hkt", "Pct", "Pet", "cpsth"], "data": ["load", "Data", "body", "args", "slice", "bin", "p", "batch", "name", "d", "buffer", "media", "read", "config", "next", "address", "type", "reader", "id", "message", "input", "dat", "start", "sample", "accept", "binary", "parent", "response", "cache", "missing", "device", "zip", "ata", "window", "bytes", "value", "DATA", "content", "memory", "draw", "result", "connection"], "size": ["code", "body", "args", "slice", "ize", "c", "empty", "sized", "name", "storage", "send", "sum", "capacity", "address", "type", "version", "Size", "depth", "SIZE", "cap", "small", "offset", "mode", "sec", "scale", "shape", "channel", "length", "bytes", "n", "len"], "extradata_nal_types_hevc": ["extradata_nal_types_kell", "extradata_nal_types_sheVC", "extradata_nal_types_shevc", "extradata_nal_types_peVC", "extradata_nal_types_shexc", "extradata_nal_types_shec", "extradata_nal_types_pell", "extradata_nal_types_kec", "extradata_nal_types_keVC", "extradata_nal_types_pexc", "extradata_nal_types_hec", "extradata_nal_types_hxc", "extradata_nal_types_pec", "extradata_nal_types_hell", "extradata_nal_types_hVC", "extradata_nal_types_hexc", "extradata_nal_types_hll", "extradata_nal_types_hc", "extradata_nal_types_pevc", "extradata_nal_types_hvc", "extradata_nal_types_heVC", "extradata_nal_types_kevc"], "extradata_nal_types_h264": ["extradata_nal_types_v24", "extradata_nal_types_H24", "extradata_nal_types_phavi", "extradata_nal_types_havi", "extradata_nal_types_ph24", "extradata_nal_types_he128", "extradata_nal_types_H64", "extradata_nal_types_ph64", "extradata_nal_types_H264", "extradata_nal_types_H265", "extradata_nal_types_ph128", "extradata_nal_types_he264", "extradata_nal_types_he24", "extradata_nal_types_h64", "extradata_nal_types_v264", "extradata_nal_types_ph264", "extradata_nal_types_he64", "extradata_nal_types_v64", "extradata_nal_types_h24", "extradata_nal_types_v128", "extradata_nal_types_p24", "extradata_nal_types_ph265", "extradata_nal_types_h128", "extradata_nal_types_v265", "extradata_nal_types_Havi", "extradata_nal_types_p264", "extradata_nal_types_pavi", "extradata_nal_types_p64", "extradata_nal_types_h265"], "s": ["sc", "ses", "w", "ss", "p", "parser", "c", "ns", "d", "sq", "sac", "sg", "e", "gs", "session", "spec", "sec", "sa", "h", "f", "qs", "n", "a", "t", "csv", "ssl", "cs", "g"], "extradata_nal_types": ["extradata_nals_type", "extradata_nal_properties", "extradata_nals_types", "extradata_nal_styles", "extradata_nal_resources", "extradata_nal_times", "extradata_nals_properties", "extradata_nals_ypes", "extradata_nal_ypes", "extradata_nal_pes", "extradata_nal_type", "extradata_nals_names", "extradata_naled_type", "extradata_naled_times", "extradata_nals_styles", "extradata_naled_types", "extradata_naled_pes", "extradata_nal_names", "extradata_nals_resources"], "nb_extradata_nal_types": ["nb_extradata_naler_ids", "nb_extradata_naled_types", "nb_extradata_nal_type", "nb_extradata_nals_types", "nb_extradata_naler_resources", "nb_extradata_naler_type", "nb_extradata_naled_plugins", "nb_extradata_nal_resources", "nb_extradata_nals_type", "nb_extradata_naled_ids", "nb_extradata_naler_types", "nb_extradata_naled_type", "nb_extradata_nals_names", "nb_extradata_nal_names", "nb_extradata_nal_ids", "nb_extradata_nals_ids", "nb_extradata_nal_plugins"], "i": ["gu", "jit", "k", "ie", "p", "b", "m", "yi", "c", "d", "ix", "x", "adi", "ti", "mi", "type", "phi", "qi", "it", "ri", "id", "num", "ani", "io", "ki", "u", "e", "key", "li", "gi", "zi", "multi", "start", "xi", "uri", "ii", "di", "ini", "ai", "si", "bi", "result", "ret", "ik", "fi", "eni", "im", "I", "f", "count", "mini", "n", "j", "ip", "index", "a", "chi", "y", "oi", "iu", "v", "ind", "pi", "in", "ui", "hi", "len"], "nal": ["namal", "neal", "ynale", "nanals", "nanal", "ynals", "nonals", " nals", "nalis", "naal", "rnmal", "nonal", " neal", "ynal", "nonale", "rnalis", "nanale", " nale", "naale", "neale", "naneal", "ynAL", "pnal", "nale", " nAL", "nealis", "rnale", "nmal", "pnals", "naalis", "nemal", "rnal", "nAL", "pnale", "pnAL", "noneal", "nals"]}}
{"project": "FFmpeg", "commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "target": 1, "func": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,\n\n                                       int16_t *src2,\n\n                                       int height, int denom, int wx0, int wx1,\n\n                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)\n\n{\n\n    int x, y;\n\n    pixel *src = (pixel *)_src;\n\n    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);\n\n    pixel *dst          = (pixel *)_dst;\n\n    ptrdiff_t dststride = _dststride / sizeof(pixel);\n\n    const int8_t *filter = ff_hevc_epel_filters[mx - 1];\n\n    int shift = 14 + 1 - BIT_DEPTH;\n\n    int log2Wd = denom + shift - 1;\n\n\n\n    ox0     = ox0 * (1 << (BIT_DEPTH - 8));\n\n    ox1     = ox1 * (1 << (BIT_DEPTH - 8));\n\n    for (y = 0; y < height; y++) {\n\n        for (x = 0; x < width; x++)\n\n            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +\n\n                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));\n\n        src  += srcstride;\n\n        dst  += dststride;\n\n        src2 += MAX_PB_SIZE;\n\n    }\n\n}\n", "idx": 25181, "substitutes": {"_dst": ["_rst", " _dest", " _rst", " _dstr", "_bstr", " _lbl", "_dest", "_Dst", "_rsts", "_idsts", "_rset", "_bsp", "_ssts", "_sset", "_dsp", "_lstr", "_dsts", "_lbl", "_lst", " _dset", "_idest", " _rset", "_rest", "_sst", "_idset", " _lsp", "_bbl", " _dsts", "_sest", "_dbl", "_dset", "_lsp", "_Dstr", " _rsts", " _dbl", " _lst", "_Dsp", "_dstr", " _dsp", " _rest", "_bst", "_Dbl", " _lstr", "_idst"], "_dststride": ["_dstSTRided", "_dstdrride", "_dndstrides", "_dndstrise", "_dstdrise", "_dndbride", "_doststriding", "_dstdrided", "_doststrride", "_dostStriding", "_dstStrides", "_dstSTRide", "_dststrise", "_dstStride", "_dstSTRiding", "_dstdriding", "_dstStrise", "_dststriding", "_dndbrides", "_dstStriding", "_dstbrided", "_dststrided", "_doststrided", "_dndstride", "_dstbride", "_dstbrides", "_dostStrided", "_dststrride", "_dndstrided", "_dststrides", "_dstSTRride", "_dstStrride", "_dstdrides", "_dstbrise", "_dstStrided", "_dostStride", "_dstdride", "_dostStrride", "_doststride", "_dndbrided", "_dndbrise"], "_src": ["_rc", " _source", "_sl", "_source", " _loc", " _sl", "_loc", "_sb"], "_srcstride": ["_srcstides", "_locstrided", "_srcbrided", "_locStrride", "_srcstider", "_srcbrides", "_srcSTRides", "_srcstide", "_srcStride", "_locStrides", "_srcbrride", "_srcStrides", "_locstrride", "_srcbride", "_srcstrride", "_srcSTRided", "_srcbrider", "_locstride", "_srcSTRide", "_srcStrride", "_locStrided", "_srcstrided", "_srcstrides", "_srcSTRider", "_locStride", "_locstrides", "_srcSTRride", "_srcstrider", "_srcStrided"], "src2": ["source1", "src32", " src0", "RC2", "rc3", "loc2", "src4", " src32", "loc1", " src1", "RC32", "src0", "source3", "source0", "RC1", "source2", "rc1", "rc0", "rc2", "loc4", "rc32", "src3", " src4", " src3", "src1", "rc4"], "height": ["th", "w", "z", "dim", "dy", "d", "tight", "img", "style", "hh", "def", "center", "deep", "rows", "depth", "max", "size", "thin", "crop", "shape", "length", "gh", "h", "window", "wall", "pull", "ip", "bottom", "row", "Height", "han", "sh"], "denom": ["Denom", " denoom", " denomin", " denam", "denow", "denoom", "DENow", "Denomin", "DENom", "sinym", "Denym", "denym", "denam", "denomin", " denow", "Denam", "DENoom", " denym", "sinomin", "Denoom", "sinom", "DENomin", "Denow", "sinam"], "wx0": ["ww8", "hw0", "wx8", "wx2", "xy8", "x8", "xy1", "x0", "x1", "hw2", "ww2", "hw1", "hw8", "xy0", "ww1", "xy2", "ww0", "x2"], "wx1": ["fw1", "rw1", "wx2", "wp1", "xy1", "xy01", "rw2", "x0", "x1", "fw0", "wp2", "ww2", "wp01", "fw2", "rw01", "ww1", "xy2", "rw3", "ww0", "x2", "xy3", "wx3", "wx01", "wp3"], "ox0": ["mix00", "box00", "wxk", "wx2", "mix0", "ex0", "wx00", " oxk", "oxi", "ixi", "ox8", "ex00", "mix10", "x0", " ox8", "x1", " ox00", "ck0", " ox2", "wxi", "mix8", "oxk", "xi", "x00", "ex10", " ox10", "ox10", "boxk", "ck2", "ex8", "ix1", "ck1", "ix00", "ix2", "ck00", "x2", "ox00", "ix0", "box0", "ox2", "box2"], "ox1": ["ex1", "exone", "boxone", "wx2", "ixone", "ex11", "wxone", "x0", "x1", "oxone", "xOne", "ix11", " ox2", "x11", "ixOne", "xone", "ox11", "box1", "ix1", "ix2", "ex2", "oxOne", "x2", " oxOne", "ix0", "box0", "ox2", "box2"], "mx": ["mask", "xx", "cm", "byte", "nm", "ml", "m", "image", "ix", "module", "px", "xc", "weight", "ms", "py", "nn", "ux", "nz", "mac", "wx", "mic", "mag", "cpu", "mb", "mode", "mn", "ij", "wm", "mc", "cf", "hop", "vm", "xml", "ng", "xp", "nr", "rx", "dm", "mm", "MX", "tx", "large", "ap"], "my": ["md", "dll", "micro", "sys", "bin", "ml", "wave", "imag", "ms", "py", "mi", "gy", "cy", "mic", "gray", "ys", "ma", "mb", "mn", "mon", "mal", "amin", "win", "wp", "world", "tiny", "ny", "mm"], "x": ["code", "xx", "w", "z", "i", "p", "b", "c", "pixel", "d", "image", "ix", "sw", "px", "time", "xc", "en", "on", "no", "ax", "cross", "X", "id", "u", "e", "key", "ey", "xy", "ady", "el", "o", "work", "xi", "dx", "yx", "fx", "xs", "xxx", "h", "f", "n", "ip", "index", "t", "wa", "rx", "j", "v", "q", "ex", "tx", "ph"], "y": ["yr", "w", "z", "yi", "i", "p", "b", "m", "dy", "c", "sy", "oy", "d", "ay", "yt", "wy", "yl", "py", "col", "ye", "type", "gy", "cy", "iy", "ch", "ym", "id", "vy", "ys", "ey", "xy", "o", "yx", "ky", "Y", "yy", "hop", "ry", "h", "f", "n", "ny", "j", "t", "yn", "v", "ty", "ya"], "src": ["sc", "slice", "sr", "uc", "c", "camera", "cv", "upp", "image", "img", "rb", "filename", "config", "sq", "gb", "gz", "cb", "vr", "bl", "cur", "inst", "sync", "url", "proc", "rss", "sur", "rel", "rl", "start", "loc", "sub", "lib", "sel", "ctx", "sb", "rc", "channel", "req", "sup", "upload", "rect", "source", "stream", "rx", "RC", "bg", "core", "dest", "sl", "r", "chrom"], "dst": ["sest", "Dest", "bbl", "ssts", "sst", "Dbl", "bst", " dsts", "dstr", "dsts", "bsp", "sdsp", "bstr", "adst", "adsc", "sbl", "dsl", "Dsts", "ddr", " dsp", "sdstr", "rsl", " ddr", "adsl", " dbl", " dest", "dbl", "sdst", "rdr", " dsl", "dsp", "addr", " dsc", "sdbl", "rst", "dsc", "dest", " dstr", "rsc", "Dst"], "filter": ["mask", "bin", "effect", "transform", "wave", "fn", "force", "config", "feature", "type", "opt", "url", "path", "fl", "parent", "sel", "sort", "cache", "channel", "source", "stream", "include", "Filter", "header", "map", "block", "layer"]}}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182, "substitutes": {"dcl": ["bml", "pdacl", "ffl", "pbl", " dpl", "bcl", "dpl", "dml", "bacl", "pacl", "Dml", "fcl", "dfl", "Dcl", "bfl", "pdcl", "sdfl", "Dfl", "fpl", " dbc", "pcl", " dbl", "pdbl", "dbl", "sdcl", "sdbc", "psc", " dsc", "dacl", "dbc", " dfl", "Dacl", " dacl", "dsc", "fbc", "pdsc", "sdpl", " dml"], "backing_id": ["backing_side", "backings_side", "backings_type", "backing_start", "backings_id", "backing_name", "backing_ids", "backings_start", "backings_ids", "backings_name", "backing_type"], "backing_y_0_top": ["backing_y_in_bottom", "backing_y_0_high", "backing_y_from_bottom", "backing_y_from_high", "backing_y_in_top", "backing_y_in_high", "backing_y_in_tops", "backing_y_0_tops", "backing_y_0_bottom", "backing_y_from_tops", "backing_y_from_top"], "x": ["xx", "z", "i", "p", "b", "m", "c", "name", "d", "ix", "px", "data", "tx", "address", "ax", "id", "X", "u", "wx", "e", "xy", "xi", "dx", "s", "xs", "win", "f", "n", "index", "t", "a", "v", "ex", "pos", "l", "g"], "y": ["hy", "z", "yi", "i", "p", "b", "ya", "dy", "oy", "sy", "c", "ay", "wy", "yt", "py", "ye", "type", "cy", "id", "vy", "u", "yo", "ey", "o", "yx", "ii", "ky", "Y", "ry", "n", "yn", "ny", "year", "q", "v", "ty", "l", "yy"], "w": ["height", "ow", "k", "z", "i", "p", "b", "c", "ww", "m", "wb", "d", "sw", "wave", "weight", "wh", "id", "rw", "u", "wx", "e", "o", "work", "s", "l", "wl", "fw", "wd", "ew", "size", "win", "wp", "wal", "f", "aw", "n", "W", "t", "v", "r", "we", "wa", "g"], "h": ["height", "hm", "ht", "k", "z", "i", "p", "m", "b", "c", "sh", "dy", "d", "top", "ih", "bh", "H", "end", "ah", "id", "u", "e", "o", "rh", "s", "hs", "eh", "f", "n", "j", "t", "host", "ha", "q", "wa", "v", "l", "hi", "ph", "oh", "g"], "scon": ["sinacon", "Sca", "lscon", " sgin", "sympen", "esconst", "fwin", "ansgin", "sfac", "psban", "sinocon", "sun", " sfc", "psuc", "openscon", "sinCON", "lsban", "dca", "symocon", "itscn", "osrc", "lscn", "sinCon", "lsCon", "portocon", "scn", "sportssel", "sconnect", "sportscon", "suc", "dsocon", "skycon", " sCon", " sfac", " sctrl", "wspen", " sacon", "sCon", "sincon", "dsun", "sco", "psconst", "dsca", "swin", "dscn", "lsCON", "sinca", "anscon", "dsfc", "Sacon", "physron", " src", " sconnect", " socon", " sCON", " sconn", "itsconn", "tsconst", "itsfc", "physcn", "sinban", "itsban", "opensco", "sban", "portcon", "tsrc", "sportsconst", " ssel", "skyran", " sca", "wscon", "lsocon", "pscon", "dsrc", "fcon", "portpen", "symconst", "osconnect", "gsconst", "physfc", "tscon", "wsocon", " sconnection", "tsdon", " scn", "lsconst", "itsconst", "symcon", "dsconnect", "gsocon", "opensfac", "src", "osfc", "dfc", "esdon", "psocon", "gscon", "dsco", "itsron", " sron", "gsconnection", "dconn", "lsran", "docon", "openspen", "tsfc", " suc", "tspen", "ssun", " sun", "fconnect", "osgin", "ssrc", "ansconnect", "sCON", "spen", "sinco", "sconst", "gsctrl", "osocon", "sconn", "lsconnection", " sconst", "sacon", "gsco", "sportspen", "Scon", "sgin", "gspen", "itscon", "fco", "psco", "sctrl", "sfc", "skyocon", "oscon", "physcon", "lsdon", "ssel", "dscon", "SCON", " sban", "tsocon", "dsran", "sscon", "dwin", "ansrc", "wsconst", "dswin", "lsctrl", "sca", "gsfac", "socon", "skycn", "sinuc", " spen", "portconst", "sdon", "ssconn", "sconnection", "escon", "psconn", " sco", "sran", "drc", " swin", "dcon", "dsconn", "sron", "esocon"]}}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185, "substitutes": {"t": ["w", "i", "p", "m", "b", "c", "d", "ts", "time", "T", "ct", "it", "port", "e", "o", "tick", "s", "tt", "dt", "f", "n", "tp", "v", "r", "tty", "l", "ut", "g"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 25189, "substitutes": {"s": ["S", "ses", "sys", "scope", "i", "p", "m", "b", "c", "ss", "ns", "info", "d", "se", "sq", "ds", "request", "conf", "us", "sg", "secondary", "states", "sync", "sis", "self", "u", "is", "e", "cs", "gs", "site", "o", "es", "sets", "stats", "ions", "session", "spec", "l", "sample", "sym", "si", "os", "new", "stat", "sb", "services", "sec", "sup", "h", "f", "service", "source", "js", "n", "qs", "tests", "t", "fs", "r", "sf", "settings", "in", "ssl", "sv", "g"], "data": ["Data", "args", "slice", "bin", "res", "info", "p", "m", "d", "buffer", "api", "base", "config", "ds", "ad", "align", "address", "def", "reader", "proc", "rec", "ui", "buf", "arr", "grad", "resource", "input", "dat", "la", "str", "session", "object", "sample", "ctx", "new", "size", "record", "cache", "xxx", "array", "f", "source", "decl", "ip", "da", "reg", "src", "DATA", "memory", "map", "result", "pos", "len"], "addr": ["seq", "code", "dll", "obj", "rs", "np", "slice", "Address", "dr", "asm", "pointer", "align", "ad", "address", "ea", "alias", "proc", "pad", "orig", "e", "buf", "arr", "amp", "adr", "sta", "cmd", "dat", "la", "ord", "loc", "offset", "sample", "coord", "ctx", "sb", "rc", "ptr", "proxy", "array", "amd", "ack", "source", "nr", "rx", "da", "reg", "src", "r", "attr", "ace", "nc", "pos"], "oi": ["abi", "oda", "cm", " ie", "oci", "ski", "yi", "i", "ie", " Xi", " bi", " ki", " di", "omi", "api", "ih", " vi", "ti", "mi", " i", " ii", "ei", "phi", "oid", " iii", "asi", "e", "o", "tmp", " pci", "isu", "odi", "oni", "oji", "di", "ii", "si", "ai", "ini", "offset", "sym", "ctx", "ci", " mi", "oko", "agi", "eni", "roc", "fi", "oa", "aram", "im", "ilo", "rio", "ki", "ori", "osi", "ip", "mm", "igi", " si", "ois", "iu", "uci", "ogi", "pi", "ui", " pi", "ib", "ok"], "addrz": ["addrzip", "adrzi", " addrw", "adriz", "addressZ", "acez", "addressw", "layerzi", " addrzip", "adrZ", "lenzi", "lenz", "aceZ", " addrZ", "leniz", "addressz", "adrza", "addrZ", "adrz", " addriz", "acezip", "lenza", "adrw", "layerz", "addrw", " addrza", "acezi", "layerzip", "layerZ", "addrzi", " addrzi", "addriz", "addrza"], "param": ["ref", "temp", "cm", "Param", "nm", "see", "rom", "i", "p", "m", "arm", "c", "name", "dim", "rn", "asm", "qa", "sam", "var", "ad", "am", "member", "address", "request", "type", "col", "error", "mi", "num", "proc", "prom", "jam", "key", "begin", "pri", "mem", "ram", "amp", "adr", "resource", "atom", "err", "rm", "tmp", "category", "loc", "model", "sym", "grade", "pm", "inc", "item", "channel", "vm", "aram", "im", "amd", "prim", "comment", "sm", "source", "da", "index", "mm", "par", "attr", "pos", "pc", "params"], "func": ["exec", "dll", "code", "call", "obj", "args", "slice", "lambda", "wrapper", "sys", "kw", "b", "c", "function", "callback", "asm", "fn", "job", "rb", "var", "cb", "abc", "dd", "pc", "mac", "proc", "orig", "method", "self", "buf", "fc", "aux", "grad", "work", "cmd", "unc", "loc", "lib", "cc", "ctx", "fi", "cf", "sec", "xxx", "amd", "f", "xp", "go", "rx", "src", "r", "attr", "nc", "val", "fun"], "label_ptr": [" label_code", "labelingptr", "label6ptr", "labelingpos", "labelingPtr", "label_pos", "label_pointer", "field_pt", "labelingaddr", " label_length", "label67pt", "label6size", "label_Ptr", "field_Ptr", "field_pos", "labelingpointer", "label67code", "label67addr", "label_code", "label67size", " label_pointer", "label6code", "label6pointer", "label_pt", "label_length", " label_size", "label67ptr", "labelingpt", " label_pt", " label_pos", " label_addr", "label67length", "label_size", "field_ptr", "label67pointer", "label_addr"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n", "idx": 25223, "substitutes": {"fd": ["temp", "md", "fed", " f", " fid", "xf", "socket", "fe", "dc", "d", "fn", "data", "ld", "fff", "ds", "bf", "bd", " FD", "cb", "flow", "id", "db", "lf", "fc", "buf", "feed", "td", "ff", "pd", "nd", "dir", "dl", "fee", "fl", "wd", "handler", "FD", "fb", "cond", "fx", "client", "size", "length", "buff", "f", "fs", "fa", "fp", "pipe", "sd", "sf", "df", "connection", "file", "dn", "format"], "s": ["S", "side", "rs", "ses", "socket", "args", "w", "i", "p", "b", "m", "c", "sh", "ns", "ss", "d", "se", "server", "ssl", "ts", "ips", "sq", "ds", "ps", "sg", "ins", "ks", "rows", "sync", " fs", "self", "su", "u", "is", "e", "es", "gs", "o", "http", "spec", "si", "sym", "aws", "os", "als", "sb", "services", "as", "ls", "f", "fs", "js", "n", "source", "service", "t", "an", "src", "qs", "v", "sl", "r", "sf", "settings", "l", "cs", "g"]}}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->sei.unregistered.x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->sei.unregistered.x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 25245, "substitutes": {"h": ["hm", "ht", "w", "p", "c", "hr", "history", "ih", "bh", "H", "hh", "ch", "ah", "self", "u", "hl", "e", "hp", "hw", "cl", "rh", "s", "http", "hs", "handler", "gh", "eh", "f", "t", "host", "ha", "q", "v", "g", "l", "hi", "he", "ph", "oh", "sh"], "sl": ["sch", "kel", "sc", "SL", "sk", "acl", "hel", "slice", "tl", "ml", "sn", "spl", "ll", "c", "pg", "se", "sw", "oper", "bh", "ell", "isl", "bl", "util", "split", "su", "hl", "el", "li", "cl", "rl", "la", "s", "ul", "lit", "cel", "dl", "l", "loc", "fl", "pl", "si", "wl", "lr", "sel", "sb", "gl", "ln", "sa", "il", "lc", "serv", "ls", "f", "sm", "flo", "sil", "t", "zh", "nl", "Sl", "sf", "ssl", "kl", "sh"], "mb_type": ["MB_length", "mbqtype", "mn_type", "mn_TYPE", "db_id", "db_type", "mbqtypes", "mn_size", "MB_types", "MB_id", "db_family", "mb_family", "mb_id", "mbqlength", "MB_type", "mb_TYPE", "mb_length", "mb_types", "mbqid", "mb_size", "db_TYPE"], "mb_type_col": ["mb_type_column", "mb_types_col", "mb_type_type", "mb_types_column", "mb_types_row", "mb_types_type", "mb_type_row"], "l1mv0": ["l1cmw6", "l1mh6", "l1mx2", "l1mw6", "l1mw2", "l1mh0", "l1cmw1", "l1cmv2", "l1cmw0", "l1mx6", "l1mx0", "l1mw0", "l1cmv1", "l1cmv6", "l1mv6", "l1cmv0", "l1mh2", "l1mx1", "l1cmw2", "l1mw1", "l1mv2", "l1mh1"], "l1mv1": ["l1mb0", "l1mh0", "l1mw3", "l1dh3", "l1mb3", "l1dh0", "l1dh1", "l1dv3", "l1dv0", "l1dv1", "l1mw0", "l1mb1", "l1mv3", "l1mh3", "l1mw1", "l1mh1"], "l1ref0": ["l_reference1", "l1reference1", "l_ref2", "l1p2", "l_ref4", "l_reference0", "l1Ref2", "l1Ref4", "l1reference4", "l1reference2", "l1Ref1", "l1p0", "l1Ref0", "l1ref4", "l1p4", "l1reference0", "l_ref0", "l1p1", "l1ref2", "l_ref1", "l_reference2", "l_reference4"], "l1ref1": ["l2ref1", "l1reference1", "l1f1", "l2f1", "l1arc8", "l1f8", "l1arc1", "l1ref8", "l1reference8", "l2f8", "l2ref8"], "i8": ["m6", "p10", "m10", "u8", "u10", "p8", "u16", "i16", "p16", "i10", "m8", "u6", "i6", "p6", "m16"], "i4": ["int8", "int6", "int4", "l8", " i6", "int64", "l6", "l4", " i64", "i6", "l64", "i64"], "ref": ["call", "info", "p", "aff", "buffer", "base", "config", "pointer", "conf", "diff", "col", "Ref", "def", "reference", "id", "num", "rec", "all", " reference", "rel", "input", "ef", "cal", "rc", "cache", "block", "arg", "comp", "f", "count", "comment", "index", "null", "row", "inter", "arc", "pre", "range", "pos", "val", "REF"], "mv": [" mvp", "pmq", "mj", "pmj", "bmq", "mvp", "bmj", " mq", "mq", "bmv", "pmv", "pmvp", " mj", "bmvp"], "list": ["chain", "L", "call", "CL", "batch", "server", "name", "cat", "module", "base", "sync", "self", "arr", "li", "cl", "set", "pool", "entry", "pair", "complete", "code", "low", "p", "test", "queue", "diff", "key", "old", "group", "cache", "feat", "com", "comp", "coll", "map", "block", "que", "large", "len", "table", "g", "load", "rest", "see", "hold", "conf", "act", "bl", "ch", "cont", "all", "e", "str", "la", "pl", "cli", "parent", "like", "view", "lc", "count", "source", "pull", "stack", "null", "full", "seq", "i", "config", "member", "type", "id", "List", "ul", "LI", "record", "lists", "gl", "listed", "loop", "comment", "LIST", "child", "index", "out", "pre", "l"], "C": ["S", "L", "CL", "DC", "c", "LC", "K", "P", "T", "H", "U", "CM", "EC", "R", "M", "JC", "FC", "D", "CR", "G", "N", "I", "CA", "W", "V", "E", "O", "VC", "F"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n", "idx": 25247, "substitutes": {"opaque": ["OPque", " opqua", "operacity", "OPaque", "operaque", " opaques", "OPaques", "operaques", "opaco", "opaques", "OPaco", "copaques", "opqua", "operaco", " opacity", " opque", "copacity", "operqua", "copqua", " opaco", "opacity", "opque", "operque", "copaque"], "event": ["esc", "node", "events", "date", "name", "image", "d", "callback", "x", "data", "test", "ec", "text", "style", "address", "type", "error", "end", "id", "vent", "press", "e", "ee", "key", "message", "input", "layout", "start", "command", "ent", "size", "view", "shape", "channel", "xml", "current", "which", "ack", "child", "t", "Event", "age", "ce", "g"], "s": ["S", "side", "rs", "ses", "sys", "ss", "p", "m", "c", "ns", "sports", "sq", "ds", "sg", "secondary", "state", "states", "sync", "self", "su", "u", "e", "south", "gs", "o", "sets", "session", "sym", "hs", "aws", "new", "stat", "sb", "services", "h", "f", "service", "fs", "n", "your", "a", "an", "t", "sl", "r", "sf", "ops", "ssl", "g"]}}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252, "substitutes": {"ci": ["cm", "cod", "oci", "dc", "cd", "c", "cit", "cci", "xc", "cy", "ei", "coe", "cia", "li", "ic", "uri", "jc", "ii", "ini", "di", "si", "cli", "ni", "icc", "cium", "fi", "CI", "sci", "co", "lc", "reci", "ki", "cu", "uci", "ce", "ili", "cgi", "ice"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq(OpenPICState *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25260, "substitutes": {"opp": ["opl", "pp", "obj", "kk", "oc", "ogg", "app", "pkg", "upp", "ob", "ov", "kick", "OP", "oper", "rb", "ripp", "jp", "fail", "eff", "own", "hack", "inst", "oph", "op", "supp", "proc", "oe", "cmp", "cho", "front", "ppo", "imp", "ff", "omp", "tmp", "pps", "ord", "odd", "ko", "owner", "cop", "roc", "rc", "iv", "off", "sup", "ost", "comp", "buff", "ack", "gg", "dep", "ipp", "agg", "cpp", "plug", "lov", "coll", "od", "org", "ops", "rog", "iop"], "n_IRQ": ["n_ARP", "n_TRq", "n_IRLY", "n_FRQ", "n_PRQL", "n_ARX", "n_IREEC", "n_IREV", "n_MirQ", "n_TRQual", "n_ARRQ", "n_RRq", "n_ARQUIRE", "n_IRELY", "n_ARQual", "n_IRU", "n_ARRV", "n_ARU", "n_PRP", "n_ARRP", "n_IREC", "n_IRANCE", "n_IRV", "n_IREP", "n_IRP", "n_TRP", "n_ARQL", "n_REU", "n_MirP", "n_IRq", "n_ARLY", "n_RRX", "n_RRANCE", "n_RRQ", "n_IRQL", "n_RREC", "n_IRQual", "n_AREC", "n_IREQL", "n_RRP", "n_ARRANCE", "n_IRB", "n_IREQ", "n_TRQ", "n_PRV", "n_IRQUIRE", "n_ARB", "n_IREANCE", "n_RRV", "n_IRX", "n_IREB", "n_ARq", "n_Mirq", "n_RRQL", "n_REQ", "n_ARQ", "n_ARANCE", "n_RRQUIRE", "n_RRLY", "n_FRQUIRE", "n_MirQual", "n_REX", "n_PRQ", "n_FRq", "n_RRU", "n_ARV", "n_RRB"], "src": ["socket", "sys", "sr", "sq", "gb", "support", "cb", "sync", "supp", "url", "typ", "hl", "wx", "input", "lit", "sub", "lib", "st", "ptr", "desc", "obl", "obj", "inst", "proc", "cmp", "liv", "buf", "sur", "ruby", "resource", "uint", "spec", "target", "feat", "ost", "comp", "dep", "stream", "func", "sl", "attr", "chrom", "load", "node", "kk", "uc", "sn", "usr", "send", "rb", "ripp", "rin", "btn", "sth", "rss", "rob", "fc", "tmp", "small", "inf", "sb", "sec", "lc", "ack", "source", "RC", "stack", "host", "null", "ssl", "iop", "secure", "std", "sc", "download", "img", "config", "cur", "bc", "grad", "rl", "loc", "impl", "sel", "gl", "rc", "sup", "dist", "rt", "bg", "scenes", "dest"], "i": ["my", "k", "slice", "ski", "z", "ie", "p", "b", "info", "c", "m", "yi", "d", "ix", "x", "me", "api", "adi", "ti", "mi", "phi", "qi", "it", "ri", "io", "id", "u", "e", "li", "ji", "gi", "o", "zi", "xi", "uri", "inner", "ii", "bi", "si", "ini", "ai", "ni", "di", "f", "cli", "ci", "fi", "eni", "I", "y", "mini", "oi", "n", "ip", "j", "t", "a", "index", "iu", "v", "mu", "pi", "init", "anti", "ui", "l", "hi", "ami"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n", "idx": 25263, "substitutes": {"s": ["S", "rs", "ses", "socket", "sys", "w", "ss", "p", "b", "m", "c", "ns", "ts", "sq", "opens", "state", "secondary", "sync", "self", "su", "is", "u", "e", "gs", "o", "sets", "http", "session", "spec", "sym", "si", "aws", "os", "uns", "sb", "services", "f", "service", "js", "a", "t", "v", "r", "ops", "ssl", "sv", "native", "side"], "fifo": ["fifoa", "ippoo", "livode", "ippo", "flexoin", "ritoco", "prombo", " fifoko", "promoo", " fifop", "Fifodo", " fifoff", "ditoko", "feto", " fifow", "logao", "logo", "fetoo", " fifoid", "livos", "fifodo", "ligo", "lipos", "ditao", "fundoko", "fifode", "ritodo", "Fifpo", "fifoid", "FifO", "fifow", "rawno", "flexo", "filo", "rito", "fifoco", "ditoa", "fifos", "logodo", "infoo", "promoid", "Fifoo", "lifao", "lipo", "Fifo", "ritao", " fifos", "lifo", "ritoo", "fifbo", "fifoo", "ligodo", "infoff", "fetoid", "infao", "lipow", "fundo", "phyo", "rawnoid", " fifodo", "phyode", "phyodo", "rawnoo", " fifoco", "fundbo", "ippoff", "flexpo", "phyoo", "pullo", " fifoa", "livodo", "filoid", "promo", " fifoo", "logbo", "infodo", " fifoin", "filao", "fifology", "fundodo", "pullology", "ligoa", "ligos", " fifpo", "pulloid", "fetop", "pulloo", "filoo", "fifpo", "fundos", "infoa", "ritoa", "filbo", "livo", "lifoin", "fifO", "livoo", "ritpo", "lifpo", " fifology", "info", "Fifoco", "Fifode", "Fifos", "flexao", "Fifow", "fundao", "fundoa", "rawnop", " fifao", "fifop", "ditodo", "lipO", "fifoko", " fifO", "fifao", "pullos", "pullbo", "dito", "livology", "fifoff", "fifoin", "filodo"], "send": ["exec", "use", "from", "call", "fin", "see", "invoke", "execute", "shift", "parse", "empty", "function", "read", "text", "export", "write", "push", "Send", "end", "sync", "e", "feed", "open", "message", "set", "command", "start", "define", "size", "reply", "sec", "missing", "transfer", "update", "find", "kill", "service", "source", "apply", "later", "init", "sent", "query", "draw", "pack", "final"], "complete": ["exec", "seq", "code", "call", "done", "close", "master", "empty", "callback", "enable", "queue", "Complete", "success", "delay", "request", "fail", "secure", "escape", "sync", "open", "cl", "partial", "progress", "fee", "closure", "correct", "result", "response", "transfer", "complex", "fun", "total", "status", "finished", "func", "content", "full", "completely", "block", "closed", "lock", "final"], "data": ["name", "buffer", "base", "next", "url", "el", "li", "start", "fee", "lib", "current", "f", "bytes", "da", "content", "cookie", "wa", "val", "body", "code", "low", "none", "p", "empty", "queue", "en", "def", "buf", "one", "new", "cache", "response", "first", "update", "DATA", "block", "Data", "done", "byte", "res", "d", "function", "no", "delay", "fail", "ada", "error", "ui", "raw", "open", "str", "la", "partial", "offset", "parent", "size", "req", "length", "ata", "full", "alpha", "pos", "connection", "seq", "info", "i", "image", "api", "del", "id", "dat", "zero", "ul", "rev", "missing", "off", "a", "pre", "result"], "len": ["fin", "z", "ie", "dy", "name", "base", "label", "num", "split", "url", "hl", "lf", "el", "li", "lu", "min", "start", "lang", "lit", "dl", "lib", "lin", " lib", "f", "n", "limit", "val", "layer", "code", "body", "low", "en", "ler", "lon", "line", "in", "block", "fun", "d", "lan", " el", "all", "e", "Len", "err", "la", "le", "loss", "fi", "size", "length", "den", "lc", "lif", "count", "lo", "full", "pos", "lock", "seq", " lang", "i", "fn", "vec", "lex", "end", "id", "lic", "ln", " length", "net", "lim", "pre", "l"]}}
{"project": "FFmpeg", "commit_id": "c2c1726847fe3a043762062db40774bf0cc434c3", "target": 0, "func": "static void compute_status(HTTPContext *c)\n\n{\n\n    HTTPContext *c1;\n\n    FFStream *stream;\n\n    char *p;\n\n    time_t ti;\n\n    int i, len;\n\n    AVIOContext *pb;\n\n\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n\n        /* XXX: return an error ? */\n\n        c->buffer_ptr = c->buffer;\n\n        c->buffer_end = c->buffer;\n\n        return;\n\n    }\n\n\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n\n    avio_printf(pb, \"Content-type: %s\\r\\n\", \"text/html\");\n\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n\n    avio_printf(pb, \"\\r\\n\");\n\n\n\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n\n    if (c->stream->feed_filename[0])\n\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feed_filename);\n\n    avio_printf(pb, \"</head>\\n<body>\");\n\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n\n    /* format status */\n\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n\n    avio_printf(pb, \"<table cellspacing=0 cellpadding=4>\\n\");\n\n    avio_printf(pb, \"<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\\n\");\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        char sfilename[1024];\n\n        char *eosf;\n\n\n\n        if (stream->feed != stream) {\n\n            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n\n            eosf = sfilename + strlen(sfilename);\n\n            if (eosf - sfilename >= 4) {\n\n                if (strcmp(eosf - 4, \".asf\") == 0)\n\n                    strcpy(eosf - 4, \".asx\");\n\n                else if (strcmp(eosf - 3, \".rm\") == 0)\n\n                    strcpy(eosf - 3, \".ram\");\n\n                else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n\n                    /* generate a sample RTSP director if\n\n                       unicast. Generate an SDP redirector if\n\n                       multicast */\n\n                    eosf = strrchr(sfilename, '.');\n\n                    if (!eosf)\n\n                        eosf = sfilename + strlen(sfilename);\n\n                    if (stream->is_multicast)\n\n                        strcpy(eosf, \".sdp\");\n\n                    else\n\n                        strcpy(eosf, \".rtsp\");\n\n                }\n\n            }\n\n\n\n            avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n\n                         sfilename, stream->filename);\n\n            avio_printf(pb, \"<td align=right> %d <td align=right> \",\n\n                        stream->conns_served);\n\n            fmt_bytecount(pb, stream->bytes_served);\n\n            switch(stream->stream_type) {\n\n            case STREAM_TYPE_LIVE: {\n\n                    int audio_bit_rate = 0;\n\n                    int video_bit_rate = 0;\n\n                    const char *audio_codec_name = \"\";\n\n                    const char *video_codec_name = \"\";\n\n                    const char *audio_codec_name_extra = \"\";\n\n                    const char *video_codec_name_extra = \"\";\n\n\n\n                    for(i=0;i<stream->nb_streams;i++) {\n\n                        AVStream *st = stream->streams[i];\n\n                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                        switch(st->codec->codec_type) {\n\n                        case AVMEDIA_TYPE_AUDIO:\n\n                            audio_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*audio_codec_name)\n\n                                    audio_codec_name_extra = \"...\";\n\n                                audio_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_VIDEO:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*video_codec_name)\n\n                                    video_codec_name_extra = \"...\";\n\n                                video_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_DATA:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                    }\n\n                    avio_printf(pb, \"<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s\",\n\n                                 stream->fmt->name,\n\n                                 stream->bandwidth,\n\n                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,\n\n                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);\n\n                    if (stream->feed)\n\n                        avio_printf(pb, \"<td>%s\", stream->feed->filename);\n\n                    else\n\n                        avio_printf(pb, \"<td>%s\", stream->feed_filename);\n\n                    avio_printf(pb, \"\\n\");\n\n                }\n\n                break;\n\n            default:\n\n                avio_printf(pb, \"<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\\n\");\n\n                break;\n\n            }\n\n        }\n\n        stream = stream->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        if (stream->feed == stream) {\n\n            avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n\n            if (stream->pid) {\n\n                avio_printf(pb, \"Running as pid %d.\\n\", stream->pid);\n\n\n\n#if defined(linux) && !defined(CONFIG_NOCUTILS)\n\n                {\n\n                    FILE *pid_stat;\n\n                    char ps_cmd[64];\n\n\n\n                    /* This is somewhat linux specific I guess */\n\n                    snprintf(ps_cmd, sizeof(ps_cmd),\n\n                             \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\",\n\n                             stream->pid);\n\n\n\n                    pid_stat = popen(ps_cmd, \"r\");\n\n                    if (pid_stat) {\n\n                        char cpuperc[10];\n\n                        char cpuused[64];\n\n\n\n                        if (fscanf(pid_stat, \"%9s %63s\", cpuperc,\n\n                                   cpuused) == 2) {\n\n                            avio_printf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\",\n\n                                         cpuperc, cpuused);\n\n                        }\n\n                        fclose(pid_stat);\n\n                    }\n\n                }\n\n#endif\n\n\n\n                avio_printf(pb, \"<p>\");\n\n            }\n\n            avio_printf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\");\n\n\n\n            for (i = 0; i < stream->nb_streams; i++) {\n\n                AVStream *st = stream->streams[i];\n\n                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                const char *type = \"unknown\";\n\n                char parameters[64];\n\n\n\n                parameters[0] = 0;\n\n\n\n                switch(st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_AUDIO:\n\n                    type = \"audio\";\n\n                    snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->sample_rate);\n\n                    break;\n\n                case AVMEDIA_TYPE_VIDEO:\n\n                    type = \"video\";\n\n                    snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height,\n\n                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                avio_printf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\",\n\n                        i, type, st->codec->bit_rate/1000, codec ? codec->name : \"\", parameters);\n\n            }\n\n            avio_printf(pb, \"</table>\\n\");\n\n\n\n        }\n\n        stream = stream->next;\n\n    }\n\n\n\n    /* connection status */\n\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n\n                 nb_connections, nb_max_connections);\n\n\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n\n                 current_bandwidth, max_bandwidth);\n\n\n\n    avio_printf(pb, \"<table>\\n\");\n\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\");\n\n    c1 = first_http_ctx;\n\n    i = 0;\n\n    while (c1 != NULL) {\n\n        int bitrate;\n\n        int j;\n\n\n\n        bitrate = 0;\n\n        if (c1->stream) {\n\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n\n                if (!c1->stream->feed)\n\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n\n                else if (c1->feed_streams[j] >= 0)\n\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n\n            }\n\n        }\n\n\n\n        i++;\n\n        p = inet_ntoa(c1->from_addr.sin_addr);\n\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\",\n\n                    i,\n\n                    c1->stream ? c1->stream->filename : \"\",\n\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n\n                    p,\n\n                    c1->protocol,\n\n                    http_state[c1->state]);\n\n        fmt_bytecount(pb, bitrate);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, c1->data_count);\n\n        avio_printf(pb, \"\\n\");\n\n        c1 = c1->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    /* date */\n\n    ti = time(NULL);\n\n    p = ctime(&ti);\n\n    avio_printf(pb, \"<hr size=1 noshade>Generated at %s\", p);\n\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n\n    c->buffer_ptr = c->pb_buffer;\n\n    c->buffer_end = c->pb_buffer + len;\n\n}\n", "idx": 25265, "substitutes": {"c": ["sc", "cm", "k", "dc", "uc", "cd", "b", "anc", "m", "context", "C", "cv", "d", "enc", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "ce", "cy", "ch", "u", "e", "con", "ic", "cl", "vc", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "lc", "h", "ca", "f", "tc", "n", "cu", "t", "coll", "v", "g", "r", "nc", "l", "cs", "ac", "pc"], "c1": ["lc2", "c2", "c3", "C1", "lc3", " c4", "lc1", " c3", "C4", "C3", "c4", " c2", "C2", "lc4"], "stream": ["thread", "server", "transform", "enc", "buffer", "Stream", "request", "stem", "sync", "url", "self", "input", "valid", "progress", "sub", "object", "model", "pool", "current", "zip", "f", "go", "row", "content", "draw", "sem", "user", "each", "engine", "filter", "pe", "speed", "reader", "form", "port", "live", "feed", "trans", "draft", "resource", "path", "new", "ream", "stage", "src", "coll", "event", "sl", "forward", "fd", "put", "load", "public", "uc", "context", "hold", "prom", "cook", "rss", "track", "open", "message", "follow", "client", "view", "length", "ack", "source", "stack", "host", "pipe", "full", "ssl", "control", "post", "sc", "sw", "cur", "method", "steam", "zero", "clean", "record", "roll", "channel", "hook", "round", "loop", "child"], "p": ["np", "pn", "m", "b", "P", "pointer", "jp", "ps", "bp", "port", "e", "o", "cp", "wp", "lp", "f", "n", "tp", "t", "fp", "r", "pi", "vp", "pre", "pc", "pid"], "ti": ["fe", "tl", "ta", "mi", "to", "ita", "ri", "io", " pri", "li", "ic", "rie", "bi", "ii", "si", "ci", " mi", " fa", "off", "au", "ao", "t", " li", "ty", "icker", "pc", "gt"], "i": ["info", "d", " vi", " ii", "id", "ui", "is", "e", "li", "si", "ai", "ni", "ci", "h", "I", "f", "n", "ip", "t", "v", "pi", "l"], "len": ["seq", "fin", "fd", "en", "bl", "lon", "lf", "line", "li", "el", "Len", "la", "lang", "rev", "lin", "fl", "offset", "le", "lt", "ln", "length", "count", "limit", "resp", "lim", "pos", "l", "val"], "pb": ["summary", "uf", "pa", "cod", "np", "b", "parser", "wb", "pkg", "pg", "lb", "ppa", "cv", "bb", "xb", "phrase", "buffer", "api", "ab", "rb", "bf", "bh", "jp", "py", "cb", "gb", "bc", "dp", "abc", "bp", "platform", "kb", "proc", "plugin", "bs", "typ", "db", "PB", "buf", "fc", "python", "fab", "rob", "pd", "eb", "pl", "dl", "ctx", "cp", "fb", "sb", "pm", "lab", "bot", "lc", "wp", "lp", "prot", "tp", "fp", "bm", "cpp", "bps", "vp", "pc"], "sfilename": ["wsroot", " sFilename", "vesfilename", "southfn", "ssfile", "ffile", "ssname", " sbinary", " sname", "esusername", "fbinary", "esfn", "southinline", "sfile", "wsinline", "skyfilename", "ssFilename", "lsutf", "dfilename", "Stitle", "wsfilename", "sroot", "setsstring", "vesfile", "skySourceFile", "spackage", " SFilename", " Sfilename", "skytitle", "Sname", "esfilename", " stitle", "sFilename", "sesname", " susername", "esfile", "SSourceFile", "southroot", "ssutf", "skyinline", "southusername", "sesusername", "dname", "setsusername", "lsfilename", "lsname", "SFilename", "sesstring", "vespackage", " Sname", "Susername", "stitle", "ssbinary", "dfile", "wsusername", "espackage", "skyFilename", "sesfile", " Sutf", "sbinary", "sinline", "southfilename", "lsFilename", "ssfilename", "sstring", "skyroot", "sSourceFile", "sname", "esstring", "sfn", "setsfilename", "sesfilename", " spackage", "dFilename", "ansfilename", "sesFilename", " sSourceFile", "ansusername", " sfile", "esFilename", "sesfn", " sfn", "setsfn", "susername", "ansstring", "ffn", "ffilename", "skyusername", " sstring", "southstring", "ansfn", "Sfilename", "esname", "vesname", "sutf", "ssfn"], "eosf": ["eosesfen", "eosesfm", "eoconf", "neiosf", "eosfm", "eossl", "eossv", "eeosv", "eoesv", "eoconfc", "neosif", " eiosl", "eeoesfat", " eiosfp", "eiosfe", "eiosfor", " eiosf", "eoesif", "eiosf", "neiosif", "eeosl", "eoosfac", "eosfor", " eaosfs", "feosfs", "eoesm", "eossfac", "eiosfp", "eoesfat", "eeoosf", "eosfull", " eiosfac", "eeoosl", "eosfr", "eosif", "eosesf", "eaosform", "eoesfs", "eoshd", " eaosf", " eisfs", "eosesfp", "neosfull", "eeoesv", "eaosfp", "eoosf", " eosfp", " eosfm", " eosfo", "eoesfo", " eisfo", "eoidl", "eoesfp", "eosfat", "eosfs", "erosfs", "eisf", "neiosfamily", "eeosf", "neiosfull", " eoconfor", "eosfac", "eosfo", "eiosff", "eosh", "erosfp", "eoesf", "eeosfac", "eoosfat", "eaosfor", " eosd", "eosd", "eOSfull", "eosfamily", "eeosd", "eosfp", "eosfe", "eoesfen", "eiosfc", "eeoosh", "eOSf", "eeosfat", "eeoosv", "erosd", "eoconfw", "feoesf", "eoesfr", " eiosff", "eiosfw", "eOsfe", "eiosfamily", "eoidf", "neosf", " eoconfc", "eoesfac", "eaosfr", "eosv", "eaosn", "eoosp", "eosesh", "eoshfat", "eosesv", "eiosl", "eeoesm", " eosfac", " eoosv", "eosp", "erosff", "eozfc", "eozp", "eaosfc", "eoesl", " eoosfc", "eiosfull", "eosform", "eoosfc", "eOSif", "eeoesf", "eoshf", "eisd", "eossm", "eOsfac", "eaosfm", "eozv", " eosfs", "eoidff", "eosesl", "eozf", "neosfamily", "feosif", "eeoesl", "erosif", " eosv", "eoosl", "eeosh", "erosf", "eoshv", "eossf", "eoesfm", " eosfr", " eoconf", "eoesn", "feosf", " eoosf", "eoesfc", "feoesfs", "eoosfe", "eosesfs", "eosfc", "eaosfw", "eisfo", " eisd", "eaosf", "eeoesfac", "eiosm", "eoesd", "eoesform", "feoesif", "eosl", " eosn", " eosfor", "eisfs", " eiosfor", "eosff", " eosfw", "eoidfp", " eosl", "erosl", " eiosfe", "eoconfor", " eoconfw", " eaosfp", "eOsf", " eaosfm", "eiosif", " eosform", "eOsfor", " eosp", " eoosp", "eeosm", " eosfc", "eosesif", "eosm", "eosn", "eoesp", "eoosh", " eisf", "eossh", "eoosfor", "erosfen", "eosfen", "eoosd", " eosfe", "feosfen", "eoosv", "erosfo", "eOSfamily", "feoesfen", "eosfw", "eaosfs", " eosff", "eeoesd", "eiosfac"]}}
{"project": "qemu", "commit_id": "b3be28969b797b27d7f7f806827e9898e4ee08f0", "target": 0, "func": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,\n\n                                    bool last_stage,\n\n                                    uint64_t *bytes_transferred)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit;\n\n    uint8_t *p;\n\n    int ret;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->offset;\n\n\n\n    p = block->host + offset;\n\n\n\n    bytes_xmit = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 25284, "substitutes": {"f": ["ref", "fen", "framework", "fe", "k", "fo", "af", "info", "m", "elf", "c", "b", "this", "i", "d", "rf", "fn", "bf", "def", "form", "fr", "self", "e", "lf", "feed", "fc", "ff", "fw", "inf", "fb", "fi", "cf", "fx", "cache", "buff", "fs", "tf", "n", "j", "fa", "fp", "v", "g", "r", "sf", "df", "l", "fd", "file", "F"], "pss": ["pts", " pds", "apSS", "cpts", "ccs", "qsc", "qSS", "cds", "Pss", "qss", "qrss", "css", "cpcs", "PSS", "apss", " pSS", "cpds", "cts", "cSS", " piss", " pcs", "pcs", "piss", "ciss", "psc", "cpss", "prss", " psc", "apsc", "Piss", " prss", " pts", "pSS", "aprss", "Pds", "pds"], "last_stage": ["last_sent", "last_channel", "next_sent", "next_finished", "last__channel", "lastststage", "last__stage", "laststchannel", "next_channel", "laststfinished", "last_finished", "last__finished", "last__sent", "laststsent", "next_stage"], "bytes_transferred": ["bytes_perferred", "bytes_transaved", "bytes_formfixed", "bytes_xlated", "bytes_rexidered", "bytes_transported", "bytes_suppferred", "bytes_premitted", "bytes_rexferred", "bytes_rexcluded", "bytes_peraved", "bytes_compidered", "bytes_xidered", "bytes_compcluded", "bytes_interverted", "bytes_rexmitted", "bytes_formmitted", "bytes_reformed", "bytes_transfixed", "bytes_suppported", "bytes_wamit", "bytes_suppped", "bytes_transverted", "bytes_xmitted", "bytes_complated", "bytes_xferred", "bytes_suppmitted", "bytes_xped", "bytes_formped", "bytes_reported", "bytes_xaved", "bytes_waverted", "bytes_transmit", "bytes_referred", "bytes_formferred", "bytes_perlated", "bytes_compferred", "bytes_transformed", "bytes_interferred", "bytes_preformed", "bytes_wamitted", "bytes_translated", "bytes_waferred", "bytes_xformed", "bytes_preferred", "bytes_suppaved", "bytes_transmitted", "bytes_suppfixed", "bytes_transidered", "bytes_remit", "bytes_permitted", "bytes_reaved", "bytes_xcluded", "bytes_premit", "bytes_compaved", "bytes_compmitted", "bytes_remitted", "bytes_transped", "bytes_permit", "bytes_intermit", "bytes_xfixed", "bytes_intermitted", "bytes_transcluded", "bytes_xported", "bytes_perverted"], "bytes_xmit": ["bytes_nexpire", "bytes_Xmission", "bytes_wmission", "bytes_axmits", "bytes_axit", "bytes_exmit", "bytes_fxmit", "bytesOxfvis", "bytes_transmont", "bytes_Xmit", "bytes_xcat", "bytes_exmits", "bytes_ixmitter", "bytes_xpire", "bytes_wmit", "bytes_wvis", "bytes_permission", "bytes_xvert", "bytes_xxmt", "bytes_intermont", "bytes_xfer", "bytes_Xmitted", "bytesOxfmit", "bytes_xdlate", "bytes_wmt", "bytes_xmits", "bytes_Xlate", "bytes_ixmiss", "bytes_xdmitted", "bytes_whmt", "bytes_rxMIT", "bytes_whmission", "bytes_whvis", "bytes_xxmit", "bytes_andit", "bytes_exmt", "bytes_xmt", "bytes_xmont", "bytesOxfmission", "bytes_xmitted", "bytes_xit", "bytes_rxmit", "bytes_xfcat", "bytes_axmitt", "bytes_xfmission", "bytes_xfvis", "bytes_exmiss", "bytes___nexmit", "bytes_overmont", "bytes_axmit", "bytes_Xpire", "bytes_transmission", "bytesOxmit", "bytes_pervert", "bytes_interfer", "bytesOxmt", "bytes___xcat", "bytes_widemitted", "bytes_xmitt", "bytes_xmitter", "bytes_xxmits", "bytes___xmission", "bytes_xfpire", "bytes_xdmit", "bytes_transmon", "bytes_intermon", "bytes_overmiss", "bytes___nexmission", "bytes_ixmit", "bytes_fxit", "bytes_overfer", "bytes___xpire", "bytes_transmit", "bytes_xdpire", "bytes_andmits", "bytes_exmitt", "bytes_andmit", "bytes_xxmission", "bytes_widemit", "bytes_exmission", "bytes_exit", "bytes_rxmiss", "bytes_xlate", "bytes_xmission", "bytes_nexmit", "bytes_overmon", "bytes___nexcat", "bytes_ixit", "bytes_whmit", "bytes_transvert", "bytes_overmitter", "bytes_transmitted", "bytes_xvis", "bytes_permitted", "bytes_overit", "bytes_exMIT", "bytes_nexcat", "bytes_overmit", "bytes_exmitter", "bytes___nexpire", "bytes_Xvert", "bytes_nexmission", "bytes_wmits", "bytes_xfmt", "bytes_fxmiss", "bytes_xMIT", "bytes_xfmit", "bytes___xmit", "bytes_xmiss", "bytes_widelate", "bytesOxfmt", "bytes_permit", "bytesOxmission", "bytes_intermit", "bytes_rxit", "bytes_andmitt", "bytes_widepire", "bytes_xmon", "bytes_fxMIT", "bytesOxvis", "bytes_transfer"], "p": ["pp", "np", "page", "i", "b", "m", "c", "d", "data", "api", "base", "P", "pointer", "up", "jp", "ps", "bp", "port", "op", "u", "e", "point", "sp", "patch", "o", "padding", "pb", "path", "at", "per", "offset", "parent", "cp", "cache", "wp", "h", "lp", "n", "tp", "ip", "t", "fp", "j", "q", "v", "pi", "pre", "pos", "l", "post", "pc", "ap", "params"], "ret": ["ref", "res", "page", " RET", "cat", "flag", "job", "en", "success", "att", " Ret", "def", "rep", "url", "rets", "iter", "mem", "arr", "rl", "progress", "det", "rev", "lit", "RET", "re", "art", "nt", "reply", "rc", "cache", "feat", "req", "Ret", "rt", " result", "ext", "alt", "reg", "resp", "conn", "full", "result", "post", "len", "val", "fun"], "block": ["chain", "ref", "exec", "batch", "frame", "name", "buffer", "base", "label", "sync", "io", "cl", "initial", "object", "pool", "number", "part", "row", "r", "F", "k", "queue", "address", "check", "prefix", "def", "link", "line", "work", "panel", "group", "cache", "wall", "blocking", "node", "byte", "bin", "section", "bl", "error", "plugin", "open", "Block", "session", "offset", "box", "parent", "fb", "view", "ack", "header", "full", "pos", "tx", "lock", "page", "info", "image", "job", "clock", "type", "bc", "flow", "unit", "layout", "run", "record", "channel", "field", "device", "off", "network", "ip", "un", "pre", "range"], "acct_info": ["acctallstate", "acst_INFO", "acc_error", "acctallmanager", "acc_manager", "acctalldef", "acst_error", "acctallinfo", "acct_cache", "acct_def", "acct_error", "accent_info", "acct_init", "acct_manager", "acc_info", "acct_state", "acctallerror", "acctallinit", "accent_state", "acc_init", "acst_info", "acst_cache", "accent_error", "acct_INFO", "accent_def"], "norm_pages": ["normedimages", "normedpage", "norm_page", "norm_maps", "normal_cats", "normal_page", "normal_projects", "normedpages", "normal_maps", "norm_projects", "normal_images", "norm_cats", "normal_pages", "norm_images", "normedmaps"], "dup_pages": ["dup_cells", "dup_sites", "duping_cells", "duping_page", "duping_pages", "dup_page", "duping_sites"]}}
{"project": "qemu", "commit_id": "554b614765090f47d97a20ca6981e17e96515ec1", "target": 0, "func": "void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_error, BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25310, "substitutes": {"has_job_id": ["has_block_id", "has_block_info", "has_jobbookcheck", "has_jobingid", "has_jobs_file", "has_job_error", "has_job00file", "has_job00id", "has_jobbookinfo", "has_job_ids", "has_job_file", "has_job00error", "has_job_check", "has_jobs_error", "has_block_ids", "has_job00ids", "has_block_check", "has_jobs_id", "has_jobs_ids", "has_jobbookid", "has_jobbookids", "has_jobingfile", "has_job_info", "has_jobingerror", "has_jobingids"], "job_id": [" job_index", " job_name", "job_name", " job_ids", " job_number", "job_sid", "job_number", "job_index", " job_sid", "job_ids"], "device": ["node", "remote", "user", "driver", "Device", "server", "image", "mount", "module", "android", "buffer", "component", "address", "feature", "port", "mobile", "serial", "plugin", "directory", "disk", "unit", "controller", "di", "dev", "model", "mode", "vm", "task", "service", "network", "ip", "host", "devices", "machine", "root", "block", "connection", "layer"], "has_base": ["had_b", "had_base", "hasEbase", "have_support", "has_fixed", "have_base", "has_b", "hasetsource", "had_source", "has_source", "has_support", "has_file", "has__support", "have_fixed", "hasetb", "hasEfixed", "hasEsupport", "had_db", "hasetbase", "has__base", "has__file", "has_db", "hasetdb", "have_file", "hasEfile", "has__fixed"], "base": ["body", "family", "i", "b", "p", "server", "bas", "name", "based", "position", "image", "bare", "back", "data", "buffer", "address", "support", "type", "prefix", "version", "id", "url", "profile", "db", "key", "unit", "site", "home", "resource", "http", "ase", "kit", "common", "bi", "model", "parent", "change", "Base", "client", "bot", "cache", "fake", "stable", "part", "source", "core", "root", "block", "file", "area", "layer"], "has_backing_file": ["has_backacking_file", "has_backacking_filename", "has_backingablefiles", "has_backing2files", "has_backingablefile", "has_backning_image", "has_backing_path", "has_backacking_files", "has_backing2filename", "has_backing_filename", "has_backging_name", "has_backingablepath", "has_backning_file", "has_backging_file", "has_backing_image", "has_backacking_name", "has_backging_files", "has_backingablename", "has_backing2file", "has_backning_filename", "has_backing_name", "has_backging_path", "has_backing2name", "has_backning_files", "has_backing_files"], "backing_file": ["backing_image", "backging_file", "backing_url", "backding___path", "backging_files", "backing___path", "backding_file", "backing_uri", "backingfilefiles", "backing___files", "backing___url", "backging_uri", "backingfileurl", "backding_files", "backding_url", "backding_path", "backing_path", "backingfilefile", "backding___files", "backding___file", "backging_image", "backing_files", "backding___url", "backing___file", "backingfilepath"], "has_speed": ["has_weight", " has_rate", "has_rate", "hasOgrade", "has_grade", "has__grade", "has__weight", "hasOrate", "has__speed", " has_grade", " has_weight", "has__rate", "hasOspeed"], "speed": ["strength", "frequency", "reshold", "param", "score", "engine", "name", "ips", "weight", "read", "peed", "config", "delay", "error", "race", "duration", "Speed", "sync", "screen", "wash", "ensor", "fps", "percent", "start", "progress", "gain", "ributes", "grade", "size", "rate", "ride", "number", "rank", "scale", "sort", "length", "shock", "count", "stream", "sm", "status", "index", "performance", "mark", "power", "lock", "stop"], "has_on_error": ["has_off_comment", "has_on_comment", "has_off_complete", "has_off_error", "has_ononerr", "has_ononcomment", "has_on_progress", "has_on_err", "has_ononprogress", "has_off_err", "has_on_complete", "has_ononerror", "has_off_progress"], "on_error": [" on_mode", "onfror", " on_err", "onfsuccess", "onalerrors", "on_err", "on_warning", " on_status", "onfmode", "on67error", "on_mode", "onferr", "on_ror", "on_status", " on_success", "onfstatus", "on_success", "onalerror", "onferror", "onfwarning", "on67status", " on_warning", "on67ror", " on_ror", "on_errors", "onalwarning", "on67success", " on_errors", "onalerr"], "errp": ["aerpr", "errpc", "erP", "erpr", "ferP", "sersp", "aerpc", "erfp", "rrpre", "errorpc", "erpi", "rrP", "acep", "yrpr", "errsp", "acer", " errpi", " errsp", "ferr", " errr", "acepi", "rrp", "errpre", "aerp", "erpc", "rrr", "err", " errP", "errpi", "acefp", "errr", "ferpr", " errfp", "serpc", "erpre", "yrsp", " errpr", " errpc", "yrp", "serp", "erp", "errP", "errfp", "serpr", "aerr", " errpre", "ferp", "errorr", "yrpc", "errorp", "errpr"], "bs": ["rs", "ses", "obj", "iss", "ss", "b", "bas", "bis", "ns", "lb", "ob", "bb", "las", "vs", "blocks", "ds", "br", "bh", "gb", "cb", "bos", "bl", "BS", "bc", "ps", "ins", "state", "sync", "css", "db", "hub", "cs", "gs", "ba", "ubs", "pb", "s", "eb", "bi", "os", "ctx", "bes", "sb", "fb", "obs", "bot", "lc", "bid", "ls", "fs", "bytes", "js", "bits", "src", "core", "bing", "bps", "ops", "block", "banks"], "base_bs": ["basexbas", "bare_css", "base_css", "bare_bs", "basexref", "base6bas", "bas_bas", "base_ns", "baseCsync", " base_sync", "base_bytes", "base67iss", "baseCname", "base6bal", " base_js", "base67js", "base64name", "base_bas", "baseCfs", "bare_gb", "base_ref", "base64bs", "base_fs", "base64sync", " base_iss", " base_bas", "bare_fs", "base6bs", "base6ref", "base_iss", "base67bs", " base_bc", "basexbal", "base_gb", "baseCbs", "base64fs", "basexbs", " base_bal", "bas_ns", " base_bytes", "base_js", "base_sync", " base_fs", "bas_fs", " base_ref", "base67bytes", "bas_bs", "base_bal", "base_bc"], "aio_context": ["aiogcontrol", "aioamcontext", "aio_loc", "aiogcontext", "aiogctx", "aio_scope", "aio_support", "aios_support", "aiogsupport", "aioamconfig", "aios_scope", "aios_ctx", "aio_config", "aios_context", "aios_control", "aioamloc", "aio_cache", "aio_ctx", "aIO_context", "aIO_config", "aio_control", "aios_cache", "aIO_ctx", "aios_loc", "aios_config", "aioamctx"], "local_err": ["local_er", "global_err", "localamerror", "localayexc", "local_req", "internal_call", "global_error", " local_error", "localamcall", "local__error", "internal_err", "local_error", "global_er", " local_dev", " local_rr", "local__dev", "local__err", "internal_req", "global_req", "local_rr", "localmmerr", "localamreq", "local_exc", "localamerr", "localmmrr", "local__rr", "internal_error", "global_exc", "local_dev", "localmmerror", "localayerror", "localayer", "localayerr", "localmmdev", "local_call"], "base_name": ["base_line", "base__size", "based8named", "base5names", "based_Name", "based_names", "basexname", "base5line", "baseCsize", "base2named", "based8name", "job_names", "baseCname", "base8line", "based8line", " base_file", " base_size", "basexnames", "base8named", "baseCnames", "base__file", "base_base", "basexprefix", "base8names", "based8names", "base_named", "base5name", "base8name", "base2Name", " base_names", "based_named", "base5named", " base_base", "job_prefix", "base2size", "based_name", "based_line", " base_id", "base_Name", "baseCbase", "base_size", "base_file", "base__id", "job_name", "base__name", "basexsize", "based_size", "base_prefix", "job_size", "base_id", "base2name", "base_names"]}}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n\n                           AVDXVAContext *ctx,\n\n                           DECODER_BUFFER_DESC *dsc,\n\n                           unsigned type, const void *data, unsigned size,\n\n                           unsigned mb_count)\n\n{\n\n    void     *dxva_data;\n\n    unsigned dxva_size;\n\n    int      result;\n\n    HRESULT hr;\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,\n\n                                                 D3D11VA_CONTEXT(ctx)->decoder,\n\n                                                 type,\n\n                                                 &dxva_size, &dxva_data);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,\n\n                                            &dxva_data, &dxva_size);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",\n\n               type, hr);\n\n        return -1;\n\n    }\n\n    if (size <= dxva_size) {\n\n        memcpy(dxva_data, data, size);\n\n\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n\n            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n\n            memset(dsc11, 0, sizeof(*dsc11));\n\n            dsc11->BufferType           = type;\n\n            dsc11->DataSize             = size;\n\n            dsc11->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n\n            DXVA2_DecodeBufferDesc *dsc2 = dsc;\n\n            memset(dsc2, 0, sizeof(*dsc2));\n\n            dsc2->CompressedBufferType = type;\n\n            dsc2->DataSize             = size;\n\n            dsc2->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n\n\n        result = 0;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);\n\n        result = -1;\n\n    }\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to release buffer type %u: 0x%x\\n\",\n\n               type, hr);\n\n        result = -1;\n\n    }\n\n    return result;\n\n}\n", "idx": 25344, "substitutes": {"avctx": ["afcmd", "navcontext", "AVcmd", "AVcmp", "AVconfig", "abcontext", "abcv", "avecontext", "evcontext", "AVconn", "avcmp", "navpc", "afcmp", "verconn", "devconfig", "avcontext", "devctl", "vercontext", "devcontext", "avconfig", "afctx", "afcontext", "verpc", "AVpc", "evctx", "aveconfig", "avctl", "avectx", "avecv", "devctx", "svconfig", "svcontext", "abconfig", "abconn", "evconfig", "navcmp", "evconn", "abctx", "avpc", "navcmd", "AVctx", "avconn", "AVctl", "verctx", "svctx", "avcv", "svctl", "avcmd", "verconfig", "navctx", "AVcv", "AVcontext", "navconn"], "ctx": ["exec", "txt", "sc", "kw", "cca", "anc", "c", "pkg", "context", "cv", "qa", "storage", "sq", "config", "component", "cus", "bc", "concept", "mac", "kb", "ocr", "cmp", "hub", "hw", "grad", "cl", "cmd", "vc", "loc", "lib", "voc", "cli", "Context", "nt", "cp", "cn", "cf", "client", "rc", "ga", "sci", "conv", "req", "cas", "lc", "ctrl", "ca", "tc", "src", "conn", "fp", "cu", "qq", "crit", "tx", "cam", "kt"], "dsc": ["jsp", "gsp", "gsc", "fsp", " drc", "lrc", "bsp", "lesc", "Dsp", " desc", "prc", "pSC", "besc", "lsc", " dsp", "fesc", "fsc", "disc", " dbc", "bsc", "gbc", "pesc", "gisc", "Dbc", "dsp", "psc", " dSC", "bbc", "dbc", "Disc", "jisc", "drc", "lSC", "jbc", "Dsc", "fbc", "dSC", "jsc", "desc"], "type": ["slice", "class", "info", "none", "p", "name", "time", "test", "buffer", "attribute", "style", "pe", "ping", "types", "error", "version", "address", "kind", "op", "port", "url", "method", "typ", "id", "ity", "key", "unit", "http", "Type", "model", "role", "handler", "parent", "like", "client", "sort", "shape", "ype", "field", "length", "part", "rule", "TYPE", "y", "value", "ip", "t", "root", "event", "attr", "ty", "block", "pre", "table", "format"], "data": ["Data", "body", "byte", "none", "batch", "d", "image", "buffer", "media", "next", "reader", "ui", "raw", "buf", "message", "input", "dat", "zero", "start", "inner", "sample", "one", "binary", "response", "cache", "block", "missing", "window", "bytes", "source", "value", "da", "a", "DATA", "content", "memory", "draw", "alpha"], "size": ["esc", "use", "code", "slice", "ize", "sn", "c", "empty", "sized", "name", "time", "storage", "weight", "style", "filename", "sum", "capacity", "address", "hh", "speed", "Size", "unit", "password", "SIZE", "max", "loc", "small", "fee", "offset", "si", "mode", "sec", "scale", "cache", "shape", "number", "length", "timeout", "source", " sizes", "status", "ny", "content", "large", "len", "g"], "mb_count": ["byte_count", "mb2th", "mbcountsize", "mb8count", "mb8size", "mbcountth", "MB_count", "byte_len", "MB_size", "byte_th", "mb2len", "mb2count", "mb_len", "mbcountlen", "mb2size", "MB_len", "mb8len", "byte_size", "mb_th", "mbcountcount", "mb_size"], "dxva_data": ["dxva_last", "dxvas_uri", "dxva67ui", "dxva6uri", "dxva2last", "dxvas67media", "dxaa_data", "dxva_Data", "dxva_ui", "dxva2Data", "dxva6dat", "dxva67data", "dxva1data", "dxva2buf", "dxena6data", "dxva_buf", "dxvas_media", "dxva6data", "dxva67uri", "dxsa_buffer", "dxva67media", "dxena_uri", "dxena_data", "dxena_dat", "dxena6dat", "dxva_dat", "dxvas_ui", "dxsa_memory", "dxva1uri", "dxsa_data", "dxva1dat", "dxva_uri", "dxva_memory", "dxvas67ui", "dxsa_size", "dxva_buffer", "dxva1content", "dxva_content", "dxva_media", "dxena_content", "dxva2data", "dxaa_last", "dxvas67data", "dxaa_buf", "dxva6content", "dxvas_data", "dxena6uri", "dxena6content", "dxaa_Data", "dxvas67uri"], "dxva_size": ["dxha_sized", "dxvo_name", "dxva_sized", "dxvo_size", "dxva_sum", "dxva_loc", "dxva_desc", "dxva_stream", "dxva_width", "dxvo_desc", "dxva_name", "dxvo_loc", "dxha_name", "dxvo_length", "dxvo_stream", "dxva_length", "dxvo_width", "dxvo_sum", "dxha_size", "dxvo_count", "dxha_data", "dxva_count"], "result": [" cr", "rs", " sr", "sr", "res", "Result", "dr", "mr", " rc", " ret", "rh", "err", "rl", " thr", " results", "ret", "response", " success", " r", "rx", "src", "resp", "results", " res", "HR", " rs"], "hr": ["yr", "hour", "rs", "er", "sr", "p", "RS", "rd", "c", "dr", "callback", "ec", "img", "ih", "br", "bh", "cr", "gr", "hh", " HR", "mr", "id", "fr", "rw", "uh", "hl", "rid", "e", "resh", "arr", "work", "rh", "err", "str", "lr", "MR", "worker", "ctr", "rc", "rg", "kr", "req", "h", "ir", "hn", "nr", "pr", "rx", "src", "pull", "ha", "header", "wr", "r", "HR", "rr", "WR", "shr", "DR"], "dsc11": ["dsc100", "dsc10", "dc11", "desc10", "dSC10", "dc31", "dbc11", "dbc13", "Drc11", "dbc14", " desc13", " desc12", "Drc31", "dbc10", " dsc31", " desc1", "drc31", " desc101", "drc14", "Dsc11", "dSC101", " dsc100", "dsc101", " desc31", "desc31", " dsc10", "desc11", "dsc12", "dosc13", "drc101", " dsc101", "dSC14", "dsc14", "Dsc31", "Dsc14", "Drc13", " dsc12", "desc13", " desc14", "dSC12", "desc1", "desc100", "desc14", "desc12", "desc101", "dosc100", "Drc101", "dc1", "dosc11", "Dsc13", " desc100", " dsc1", " dsc13", "drc13", "dSC100", " desc10", "dsc1", "drc1", " desc11", "Dsc101", " dsc14", "Drc14", "drc11", "dbc101", "dSC11", "dosc12", "drc10", "dc14", "dsc31", "dSC13", "dsc13"], "dsc2": ["drc2", "dasc2", "Drc4", "drc1", " dbcTwo", "dsc3", "dbc3", "desc1", "dbc22", "dbcTwo", "dbc1", "dcr02", " dsc02", "dbc4", " dscTwo", "Dsc1", "duc2", "descTwo", "dsc22", "dbc2", "dSC2", "Dsc02", " dbc2", " drc02", "duc1", "Drc02", "dcr1", "duc02", " dsc3", "Drc1", "dsc02", "dasc4", " dbc1", "dasc3", "Drc2", "drc02", "dcr2", " dbc4", " drc2", "dSC4", " dsc1", "desc4", "dSC1", "desc3", "desc22", "dascTwo", " drc1", " dsc4", "dbc02", "Dsc4", "desc02", " dbc22", "dsc4", " dbc3", "duc4", "dcrTwo", "Dsc2", "dscTwo", "dsc1", "dSC22", "drc4", " dsc22", "drcTwo", "desc2", " drcTwo"]}}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353, "substitutes": {"saddr": ["sprot", "dsptr", "salign", "southenv", "servicehop", "sesaddr", "symaddress", "pvr", " slayer", "servicelayer", "saddress", "serviceaddr", "slayer", "southaddress", "wsvr", " sadr", " sprot", "svaddress", "svr", "padr", "nsaddr", "senv", "taddress", " sconfig", "shipalign", "shipaddress", " sptr", "shipprot", " svr", "ssladdress", "fadr", "seslayer", " salign", "faddr", "nslayer", "taddr", "tlayer", "paddress", "dsaddr", "shop", "svvr", "shost", "tconfig", "nconfig", "dsvr", "sord", "sadr", "nshost", "nsaddress", "sslhost", "symenv", "sattr", "sconfig", "dsaddress", "servicesalign", "ssladdr", "wsaddress", " sadd", "svadr", "southaddr", "wsptr", "seshop", "sesaddress", "ford", "svadd", "symaddr", "svord", " saddress", "servicesprot", " sord", "sadd", "paddr", "svhost", "naddr", "naddress", "servicesaddress", "nlayer", "fenv", "shipaddr", "southattr", "svaddr", " shop", "phost", "faddress", "dslayer", "serviceaddress", "dshost", "ssladr", "servicesaddr", "fattr", "nsadr", " shost", "wsaddr", "symattr", "sptr"], "port_offset": ["ort_offset", "ort_len", "ort_off", "port_default", "port_len", "port_bound", "port67off", "port_alt", "port_padding", "port_auto", "connection_optional", "port___offset", "port67ext", "port_limit", "port67offset", "ort_ext", "portlendefault", "Port_default", "port_optional", "connection_limit", "ort_alt", "port___off", "Port_range", "portlenoffset", "port___alt", "port_ext", "connection_padding", "port_range", "port_off", "port___ext", "Port_off", "portlenoff", "ort_auto", "connection_offset", "portlenrange", "ort_bound", "Port_offset", "port67alt"], "update_addr": ["updateIfaddr", "updateFmac", " change_ptr", "updateIfptr", " changeFmac", "updateIfmac", "update_ptr", "update64mac", " changeFptr", "updateIforig", "update64addr", " change_orig", " change_addr", "updateForig", "updateFaddr", "update_mac", "update_orig", "update64ptr", " changeForig", " change_mac", "update64orig", " changeFaddr", "updateFptr"], "errp": ["arrk", "errpc", "erP", "errb", " errk", "erfp", "errpe", "erpi", "errorpc", "arrf", " errpi", " errr", "rrf", " erpi", "rrp", "errpre", "errk", "errorf", "grp", "grf", "erpc", "rrr", " errP", "errpi", " errb", "grc", " errpe", " erf", "errr", " erp", " errf", "errorfp", "erf", " errfp", "erpre", "erk", "arrr", " errpc", "grfp", "erb", "rrpe", "errorP", "rrb", "errorc", "erp", "arrp", "rrc", "errP", "errfp", " erb", " erc", "rrfp", " errpre", "errorpre", " errc", "errc", " erpe", "errf", "errorp"], "ai": ["acc", "ana", "qa", "ee", "sub", "ini", "bi", "ann", "ig", "issue", "agi", "ga", "sa", "aii", "ca", "ait", "ami", "ru", "oci", "af", " bi", "ay", "ti", "ia", "mi", "address", "qi", "ra", "aaa", "ci", " mi", "eni", "man", "auth", "aud", "fa", "attr", "pc", "ais", "gui", "abi", "ae", "iam", "mac", "ani", "asi", "iri", "afi", "uri", "fi", "pai", "au", "umi", "na", "ha", " AI", "pa", "air", "i", "info", "aa", "aim", "api", "config", "access", "iana", "AI", "si", "ni", "hai", "aci", "net", "an", "AU", "a", "conn", "pi", "ui", "ac", "iat"], "res": ["ru", "rs", "gr", "mr", "rec", "rss", "arr", "rh", "rev", "rar", "re", "os", "ras", "ros", "ret", "response", "ress", "req", "ry", "rem", "Res", "ack", "rx", "pres", "reg", "conn", "resp", "results", "r", "ex", "ris", "result", "rr"], "e": ["esc", "rs", "ep", "fe", "er", "exc", "c", "ae", "enc", "ec", "en", "debug", "ei", "ev", "end", "ea", "ee", "es", "ef", "re", "eu", "ir", "E", "resp", "event", "r", "ace"], "port": ["socket", "date", "server", "name", "mail", "phrase", "request", "export", "bug", "version", "url", "project", "term", "contract", "object", "hop", "number", "ptr", "zip", "serv", "username", "part", "service", "entry", "match", "core", "code", "body", "slice", "option", "m", "PORT", "mount", "test", "queue", "text", "address", "ORT", "duration", "form", "point", "feed", "patch", "password", "resource", "path", "target", "json", "timeout", "rule", "stream", "value", "report", "table", "file", "rest", "token", "nat", "pt", "data", "component", "pointer", "select", "mac", "message", "uri", "offset", "phone", "parent", "cp", "length", "proxy", "ort", "host", "null", "header", "pos", "post", "connection", "pid", "page", "Port", "position", "api", "config", "interface", "ports", "type", "opt", "end", "method", "pad", "allow", "fat", "channel", "direction", "comment", "pr", "ip", "route", "pre", "format"], "uaddr": ["_host", " uptr", "uaddress", "uuhost", "uuaddress", "uptr", " uhost", "_address", "uuaddr", "uuptr", "uhost", "_addr", "_ptr", " uaddress"], "uport": ["urports", "urhost", "usconfig", "uhost", "ushost", "usport", "usports", "urconfig", "Uhost", "urport", "Uconfig", "Uports", "uports", "Uport", "uconfig"], "slisten": ["nslisten", "snamon", "snamen", "sdefener", "nslistener", "slistener", "sliston", "sdefon", "snamener", "nsliston", "nsnamen", "nsnamon", "snamenc", "slistenc", "nsnamenc", "nsnamener", "sdefen", "sdefenc", "nslistenc"], "rc": ["sr", "rn", "add", "cb", "num", "vc", "rg", "r", "nc", "auc", "anc", "c", "ec", "rec", "src", "rr", "pc", "g", "rs", " RC", "uc", "parse", "d", "back", "xc", "rb", "success", "error", "abc", "fc", "rh", "cc", "ror", "ras", "reply", "ack", "rx", "RC", "ck", "_", "ok", "sc", "dc", "oc", "cur", "bc", "end", "id", "rl", "loc", "roc", "co", "rt", "irc", "result", "ac"], "port_min": ["port64min", "port64range", "port64limit", "port_range", " port_limit", "port_limit", "port64max", " port_range"], "port_max": ["portfmin", "portflimit", "portfmax", " port_diff", "portfdiff", " port_limit", "port_diff", "port_limit"], "p": ["pp", "param", "i", "c", "P", "jp", "ping", "ps", "dp", "op", "proc", "patch", "pb", "cp", "pat", "po", "ip", "tp", "a", "fp", "q", "r", "pi", "pos", "pc", "pid"], "err": ["rs", "sys", "er", "errors", "rage", "exc", "der", "dr", "acer", "doc", "ec", "ise", "cr", "gz", "cb", "gr", "ler", "error", "mr", "rag", "bug", "ev", "fr", "oe", "rss", "ee", "iter", "arr", "Error", "rh", "rm", " er", "aaa", "lr", "rev", "rar", "fee", "cer", "ait", "here", "fi", "order", "fy", " error", "ar", "req", "kr", "ir", "pr", "rx", "resp", "runner", "erg", "ind", "r", "aster", "Er", "rr", "result", "tx", "ace", "eor"], "baseport": ["basect", "bideto", "ancect", "sitestate", " baseto", "basety", " basect", "baseland", "bideport", "baseename", "baseto", " basep", "siteto", "basestate", "Baseport", "Basename", "Basep", "anceport", " basety", "siteport", "baseety", "Baseland", " basetime", "ancename", "anceland", " basename", "Basect", "baseetime", " basemin", "Basemin", "basetime", " baseland", "Basetime", "basemin", "Basety", "baseemin", "sitename", "basename", "basep", "bidestate", "baseep", " basestate", "bidename", "baseeport"]}}
{"project": "FFmpeg", "commit_id": "a7f27453f64d9020b92b01687baeb5909c6cdad0", "target": 0, "func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;\n\n    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n\n        codec->codec_id == AV_CODEC_ID_H264 &&\n\n        atom.size > 11) {\n\n        avio_skip(pb, 10);\n\n        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n\n        if (avio_rb16(pb) == 0xd4d)\n\n            codec->width = 1440;\n\n        return 0;\n\n    }\n\n\n\n    return mov_read_avid(c, pb, atom);\n\n}\n", "idx": 25357, "substitutes": {"c": ["sc", "cm", "dc", "uc", "cd", "p", "m", "b", "oc", "C", "cv", "xc", "ec", "cur", "config", "cr", "cus", "ct", "cb", "bc", "abc", "cy", "ch", "cmp", "e", "fc", "con", "cl", "vc", "ac", "jc", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "cn", "co", "lc", "ctrl", "ca", "f", "tc", "conn", "coll", "core", "nc", "l", "cs", "ce", "pc"], "pb": ["pa", "uc", "p", "b", "wb", "pg", "lb", "ppa", "bb", "xb", "api", "rb", "ab", "bh", "gb", "jp", "cb", "bc", "dp", "bp", "platform", "typ", "cmp", "db", "mp", "PB", "fc", "rob", "fab", "tmp", "eb", "pl", "ctx", "cp", "fb", "sb", "pm", "abb", "bot", "lp", "tc", "cpp", "fp", "bm", "bps", "pc", "ib"], "atom": ["temp", "node", "mom", "abi", "obj", "cm", "chem", "param", "m", "app", "image", "bb", "asm", "data", "tm", "orb", "ab", "config", "om", "prop", "component", "operator", "type", "instance", "op", "num", "orbit", "atomic", "typ", "canon", "article", "mag", "fab", "cell", "amp", "tmp", "term", "at", "ator", "spec", "object", "parent", "emb", "item", "com", "hop", "xml", "tc", "tom", "material", "container", " Atom", "attr", "ac", "chrom", "tag"], "codec": ["odac", "odroc", "odEC", " codoc", "Codroc", "codeesc", "odef", "compec", "Codec", "odec", "pedenc", " codEC", "compEC", "codenc", "codEC", "equec", "codeEC", "pedef", "codeoc", "CodEC", "Codoc", "odoc", "odbc", "Codef", "coduc", "odesc", "pedac", "codac", "codeec", "codesc", "codroc", "pedesc", "compex", "copec", "Codbc", "comproc", "codoc", "copenc", "copuc", "equoc", "codex", "Codenc", "copesc", "oduc", " codesc", "codbc", "peduc", "equenc", "Codac", "odex", "pedbc", "equEC", "pedec", "Codex", "odenc", "codef"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370, "substitutes": {"vmsd": ["vmesds", "hmsdh", "vssdl", "vmasd", "varesd", "vimsds", " vksdy", " vksdc", "vmsdc", "vmsdy", "vmsD", "vmmhd", "vmmd", "vmasdm", "varesdy", "varesdc", "vmasdh", "vemsdh", " vmshd", "vmsdh", " vmsD", "hmesd", "vmesdm", "hmsds", "vksd", " vmsdc", " vmsds", "hmesds", "vemsd", "vmesdh", " vmmds", "vsshd", "vmmds", " vmsdy", "hmsd", " vksd", "hmesdh", "vimsdl", " vmsdl", "vssds", "vmesd", "vmsds", "vimshd", " vksD", "varesD", " vmmd", "vmshd", "vmesdy", "vmmdl", " vmmdl", "vmasds", "vimsd", "vmsdm", " vmmhd", "vssd", "vmesD", "vemsdm", "vksdy", "vksdc", "hmsdm", "vksD", "hmesdm", "vmsdl", "vemsds", "vmesdc"], "opaque": ["octaques", " opifice", "opifice", "operacity", "oifice", "octga", "operaque", " opaques", "oity", "operity", "operaques", "oaque", "opga", "opaques", "opusacity", "oacity", "opity", "octacity", " opity", "copaques", "copity", "opusaque", "operga", "octaque", "Opaque", "Opaques", "opusaques", "operifice", " opacity", "copacity", "opacity", "opusity", "Opacity", "copaque", "Opga"], "se": ["ve", "sle", "sem", "ses", "sk", "see", "ie", "parse", "sh", "ae", "ge", "sed", "sea", "isse", "cle", "pe", "lex", "te", "so", "sche", "su", "SE", "ne", "e", "es", "sp", "ee", "pse", "s", "session", "ase", "ade", "si", "ser", "le", "sel", "sec", "sa", "serv", "service", "entry", "de", "be", "inse", "sl", "asse", "ke", "ce", "Se", "ze"], "new_se": ["new_parse", "current_se", "new_SE", " new_sem", " new_parse", "new_sem", "new_sche", "current_sche", " new_SE", "current_parse", "new_sea", "current_sea"]}}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382, "substitutes": {"n": ["node", "np", "nm", "z", "pn", "sn", "m", "p", "c", "b", "ns", "rn", "none", "d", "bn", "adj", "fn", "en", "on", "nv", "nn", "non", "num", "ne", "u", "nor", "gn", "nd", "min", "cdn", "nic", "nb", "ni", "mn", "nt", "new", "cn", "i", "nov", "syn", "ln", "inn", "not", "N", "h", "f", "network", "na", "tun", "net", "conn", "t", "un", "an", "nu", "zn", "j", "in", "l", "dn", "g"], "cmd": ["md", "node", "seq", "comm", "code", "ctl", "dll", "gen", "cod", "acl", "dc", "cd", "c", "name", "pkg", "msg", "text", "config", "col", "cb", "opt", "ct", "act", "bind", "mac", "id", "method", "cmp", "cfg", "cl", "gn", "grad", "path", "command", "Cmd", "cli", "mode", "nt", "cc", "ctx", "cp", "client", "cf", "ctr", "req", "ctrl", "src", "conn", "qq", "init"], "iov": ["nih", "nikov", "kok", "yout", "uno", "rn", "mia", "iris", "vec", "gru", "music", "gnu", "nova", "vre", "voice", "oren", "imedia", "veh", "iasm", "io", "nox", "mos", "liv", "mx", "hub", "audi", "icon", "oyer", "emn", "cdn", "nic", "oji", "ibl", "yon", "mus", "mn", "wav", "gener", "eni", "iv", "icho", "gio", "pai", "club", "ilo", "hn", "nr", "drm", "rolet", "userc", "lov", "iol", "\u00ef", "clinton", "gmail", "iu", "dyl", "mu", "ilib", "colo", "obo", "iola", "voc", "chrom", "iop"], "iov_cnt": ["iov_acnt", "iov_cfnt", "iov_mcateg", "iov_conount", "iov_uncant", "iov_countrypted", "iov_dcnt", "iov_pcrowd", "iov_fcrt", "iov_arcnt", "iov_connn", "iov_lnt", "iov_acnn", "iov_crypt", "iov_lrt", "iov_arcrowd", "iov_icnt", "iov_Cnt", "iov_uncateg", "iov_uncred", "iov_cursor", "iov_cred", "iov_lcound", "iov_conannot", "iov_lcnn", "iov_crrowd", "iov_acNT", "iov_uncnt", "iov_Count", "iov_dcrowd", "iov_cst", "iov_pcateg", "iov_cound", "iov_mcrowd", "iov_icant", "iov_cfound", "iov_crt", "iov_lcrypted", "iov_conrypt", "iov_cannot", "iov_uncrt", "iov_crnt", "iov_arcoding", "iov_categ", "iov_icount", "iov_lcnt", "iov_dcoding", "iov_crypted", "iov_crowd", "iov_coding", "iov_cfst", "iov_pcursor", "iov_pcnt", "iov_connt", "iov_Cnn", "iov_arcannot", "iov_CNT", "iov_lcrypt", "iov_ecant", "iov_ecnt", "iov_mcursor", "iov_cNT", "iov_cfrypted", "iov_icrowd", "iov_conoding", "iov_conrowd", "iov_lant", "iov_crount", "iov_lcount", "iov_fcant", "iov_countst", "iov_crant", "iov_uncursor", "iov_cnn", "iov_uncrowd", "iov_fcnt", "iov_fcred", "iov_cant", "iov_lcNT", "iov_dcannot", "iov_lcst", "iov_Crypt", "iov_acount", "iov_ecount", "iov_count", "iov_ecrowd", "iov_countnt", "iov_lred", "iov_countound", "iov_mcnt"], "mac_data": ["macPdatabase", "macpcache", "mac_action", "macfbatch", "macMfail", "macpdatabase", " mac_database", "mac_rec", "macMdata", "featurefbatch", "macPdata", " mac_", " mac_dat", "macsdat", "mc_", "macgnew", "mac_dat", "cas_type", "micro_database", "macenddata", "cas_data", "macPkeys", "MAC_data", "cas_fail", "mac_new", "mc_database", "micro_DATA", "mac2DATA", "mac_type", "macMtype", "mac7database", "mac_done", "mac_database", "macPdat", "Mac_data", "macgdata", "mackaction", "macsdatabase", "mic_keys", "mc\n", "mac7keys", "mc_data", "mc_type", "mac_cache", "macfdata", "feature_data", "featurefdata", "mic_done", "MAC\n", "micro_data", "mac2start", "mac_info", "macendstart", "mackdata", "mac_DATA", "MAC_DATA", "macendDATA", "macendinfo", "macfdatabase", "mac_la", "mc_cache", "micro_Data", " mac_keys", "mac\n", "mac_Data", "mac2info", "mac_start", "macptype", "macMnew", "macpdata", "mac_fail", "mac7data", "mic_dat", "mic_action", "mac2data", "Mac_cache", "featurefdatabase", "mac_", "MAC_info", "mic_data", "MAC_", "mac_batch", "macgfail", "macsdata", "macgtype", "macsbatch", "mackkeys", "MAC_start", "feature_dat", "Mac_rec", "Mac_DATA", "feature_database", "feature_batch", " mac\n", "mac_keys", "mac7dat", "mackdone", "mic_la", "macfdat", "cas_new", "featurefdat"], "s": ["sys", "server", "ns", "sites", "sq", "secondary", "sync", "stats", "gs", "south", "input", "lines", "sym", "f", "fs", "status", "js", "t", "r", "ops", "S", "b", "m", "p", "c", "ds", "su", "is", "sets", "spec", "services", "say", "h", "details", "src", "sl", "side", "g", "rs", "ses", "args", "ss", "sn", "d", "send", "conf", "sg", "e", "session", "small", "sb", "size", "sec", "sf", "ssl", "sv", "cs", "params", "i", "sw", "site", "o", "sample", "si", "os", "ls", "network", "v", "result", "l"], "nc": ["nm", "dc", "sn", "anc", "c", "ns", "rn", "cv", "nv", "nn", "bc", "nec", "ne", "NC", "cdn", "nic", "nb", "nt", "cc", "mn", "cn", "ci", "ctx", "mc", "rc", "lc", "ng", "nw", "network", "nr", "irc", "conn", "nl", "cs", "voc", "pc", "dn"], "macs": ["vats", " macks", "macks", "imacks", "Macs", "vacs", "premacs", " mAC", "mac", " mats", "imaces", "premaces", " maces", "mats", "premAC", "mAC", "Mac", "vacts", "Mats", " mac", "imacs", "imAC", " macts", "premacks", "vac", "Macts", "maces", "macts"]}}
{"project": "FFmpeg", "commit_id": "14a90c9ef09a4b046500dceab5ca1875e330a376", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401, "substitutes": {"avctx": ["avcms", "varctx", " avcms", "navcontext", "varcontext", " avc", " avcas", "AVc", "avcontext", "ajconn", "avec", "afcontext", "avectx", "avctl", "varcmd", "ajctx", "airctx", "awcfg", "aircontext", "akctx", "avsc", "avecmp", "akcontext", "AVcontext", "afctrl", "avconsole", "awcontext", "avalcontext", " avcc", " avcmp", "afctx", "avpkg", "avalctx", "afca", "avchan", "varcc", "avctrl", "avalcms", "AVca", "AVcas", "AVctx", "AVchan", "avcfg", "aveca", "awpkg", "avcf", "AVcfg", "avcc", "airctl", "AVcmd", "AVcmp", "avalcmp", "avecontext", "AVconn", "avcmp", "awctx", "afcms", "afcf", "avca", "navcmp", "varcms", "avc", "AVpkg", "avconn", "AVsc", "ajcf", "afconn", "AVcli", "ajcontext", "afcc", "aveconsole", " avcli", "avesc", "afctl", "airctrl", "avecf", "ajcas", "avalchan", "avalcmd", "avechan", "AVcf", "avcli", "akctrl", "akcfg", " avsc", "aveconn", " avconn", "ajconsole", "akctl", "AVconsole", " avcontext", "avcas", "avcmd", "AVcms", "navctx", "akpkg", "navcli"], "ctx": ["cm", "console", "cca", " context", "anc", "c", "pkg", "context", "cv", "connection", "qa", "cci", "xc", "text", "config", "component", "cb", "bc", "general", "cmp", "hw", "cmd", "cms", "vc", "wcs", "voc", "cli", "parent", "cc", "ci", "cp", "cf", "client", "rc", "cn", "conv", "cas", "git", "lc", "ctrl", "ca", "service", "cu", "conn", "coll", "event", "tx", "cs", "cam"], "status": ["exec", "temp", "std", "code", "sc", "Status", "STAT", "class", "res", "usr", "cat", "flag", "msg", "job", "success", "cb", "bc", "error", "state", "sync", "proc", " resp", " ret", "str", "err", "val", "s", "progress", "session", "output", "stat", "ret", "sb", "sec", "rc", "response", "gc", "null", "resp", "crit", "bg", "result", "wait"], "format_in": [" format\n", "format_ac", "Format_out", "formatocat", "Formatformat", "template_in", "formatableIn", "filter\n", "feedableout", "feedableIn", "type_In", "live_inc", "form_IN", "filter_out", " format_at", "formatableout", "filter_ini", "format_0", "format_again", "format_at", "Format_in", "filter_inn", "format_In", "format\n", "filter_in", "feed_In", "Format_inc", "formatoc0", "format_ini", "feedablenew", "formatocin", "formatingdiff", " format_init", "formatformat", " format_new", "format___IN", "format_init", "formatMixat", "formatablein", "filterformat", "Format_In", "Format_again", "formatocinit", "formatingnew", " format_out", "feedablein", "formatocini", "feed_new", "type_in", "form_in", " formatformat", "live_ins", "format_inn", " format_diff", " format_id", " format_inc", "format_ins", "formatMixin", "format_out", "format___in", "formatMixinit", "formatacnew", "formatablenew", "Format\n", "template_ini", "formatacdiff", "feed_in", "format___out", "format_for", "form_ac", "form_out", "formatingin", "format_diff", "type_inc", "format_id", "type_for", "format_inc", "formatacin", "live_in", "Format_ins", "format___ac", " format_IN", "feed_out", "format_IN", " format_In", "format_new", "template_0"], "decoder": ["Decode", "decode", "decoded", "encrator", " decrator", "recoder", "decloding", "recader", "decrator", "encoder", "decade", "encode", "Decater", "deoder", "Decoding", "ecode", "recade", "decader", "Decoder", "recode", "decloder", "declader", "deode", "decater", "declade", "deoded", "encater", "declater", "declode", " decader", " decoded", " decoding", " decade", "ecoding", "encoding", "encoded", "decoding", " decode", "deoding", "ecater", "declrator", "ecoder"], "tmp": ["temp", "obj", " obj", " co", " img", " proc", "bb", "img", "cb", " params", "MP", "proc", "pad", "cmp", "mp", " ecc", " rc", " resp", " reply", " msg", " dup", " app", "sb", " param", " dst", " pad", "src", " pts"]}}
{"project": "FFmpeg", "commit_id": "9e1c55cfdec1e1e46fa39b92ea5c425ba9499c68", "target": 1, "func": "static int ogg_get_length(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int i;\n\n    int64_t size, end;\n\n    int streams_left=0;\n\n\n\n    if(!s->pb->seekable)\n\n        return 0;\n\n\n\n// already set\n\n    if (s->duration != AV_NOPTS_VALUE)\n\n        return 0;\n\n\n\n    size = avio_size(s->pb);\n\n    if(size < 0)\n\n        return 0;\n\n    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, end, SEEK_SET);\n\n\n\n    while (!ogg_read_page (s, &i)){\n\n        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&\n\n            ogg->streams[i].codec) {\n\n            s->streams[i]->duration =\n\n                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);\n\n            if (s->streams[i]->start_time != AV_NOPTS_VALUE){\n\n                s->streams[i]->duration -= s->streams[i]->start_time;\n\n                streams_left-= (ogg->streams[i].got_start==-1);\n\n                ogg->streams[i].got_start= 1;\n\n            }else if(!ogg->streams[i].got_start){\n\n                ogg->streams[i].got_start= -1;\n\n                streams_left++;\n\n            }\n\n        }\n\n    }\n\n\n\n    ogg_restore (s, 0);\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, s->data_offset, SEEK_SET);\n\n    ogg_reset(s);\n\n\n    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {\n\n\n        int64_t pts = ogg_calc_pts(s, i, NULL);\n\n        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            s->streams[i]->duration -= pts;\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }\n\n        }\n\n            if(streams_left<=0)\n\n                break;\n\n    }\n\n    ogg_restore (s, 0);\n\n\n\n    return 0;\n\n}", "idx": 25404, "substitutes": {"s": ["comments", "comm", "sys", "server", "ns", "ts", "sq", "ps", "states", "sync", "self", "bs", "u", "es", "gs", "stats", "input", "http", "sym", "uploads", "game", "xs", "f", "service", "qs", "js", "fs", "n", "t", "tests", "r", "ops", "S", "p", "m", "b", "c", "se", "ds", "us", "ins", "is", "sets", "ogs", "ions", "spec", "aws", "obs", "services", "com", "ows", "settings", "in", "its", "g", "rs", "ses", "ss", "bis", "d", "ms", "conf", "sg", "ks", "rows", "ch", "e", "session", "sb", "sec", "sf", "ssl", "cs", "sv", "params", "sc", "events", "sw", "plugins", "o", "os", "as", "ls", "a", "an", "times", "l"], "ogg": ["acc", "comm", "pg", "ob", "bug", "ott", "wx", "mpeg", "gs", "oss", "cmd", "input", "wav", "ga", "game", "window", "omm", "mm", "kw", "bb", "media", "ocr", "feed", "ogo", "ogs", "tg", "oga", "podcast", "obs", "gow", "wp", "ows", "stream", "aud", "od", "rog", "gram", "uc", "ogl", "ov", "gz", "ch", "ev", "google", "ogle", "rss", "ood", "gov", "cfg", "tmp", "gae", "eb", "gd", "cli", "sb", "ohm", "gross", "php", "og", "org", "ow", "oc", "app", "doc", "oper", "config", "dd", "owl", "hw", "obb", "audio", "tt", "roc", "co", "gg", "agg", "ogi"], "i": ["abi", "iii", "z", "yi", "p", "info", "b", "c", "ie", "m", "d", "ix", "module", "x", "api", "ti", "type", "ei", "qi", "it", "ri", "io", "id", "phi", "is", "u", "e", "li", "gi", "ic", "o", "multi", "start", "xi", "uri", "l", "ii", "di", "si", "ini", "ai", "ni", "cli", "bi", "inner", "ci", "fi", "eni", "iv", "lc", "h", "I", "f", "y", "oi", "n", "j", "index", "ori", "ip", "t", "q", "iu", "v", "init", "pi", "ui", "pos", "g"], "size": ["complete", "use", "code", "day", "cm", "args", "fe", "page", "ize", "engine", "c", "name", "sized", "large", "se", "empty", "time", "data", "storage", "sum", "en", "send", "sea", "address", "capacity", "speed", "Size", "form", "sync", "e", "unit", "max", "cl", "SIZE", "start", "loc", "small", "fee", "offset", "si", "last", "ci", "sec", "scale", "video", "cache", "be", "length", "h", "bytes", "mini", "sd", "content", "core", "full", "iz", "ui", "l", "cs", "len", "big", "g"], "end": ["z", "close", "End", "time", "enc", "send", "en", "END", "ad", "address", "export", "type", "port", "id", "e", "line", "open", "ff", "max", "nd", "start", "set", "after", "loc", "inner", "offset", "last", "client", "ended", "scale", "est", "length", "stage", "entry", "limit", "index", "ending", "range", "pos", "post", "stop"], "streams_left": ["streaming_left", "streams_leave", "streames_leave", "streamabs_allowed", "streams__leave", "streams__right", "streaming_in", "streams_cle", "streams_Left", "streams2allowed", "streaming__right", "streames_l", "streaming__found", "streams__cle", "streamabs_left", "streams_right", "streamabs_found", "streams_l", "streamabs_Left", "streams_in", "streaming_right", "streames_left", "streames_cle", "streams__left", "streams__in", "streams__l", "streams_found", "streams2Left", "streams2left", "streams__found", "streaming__in", "streams2found", "streaming__left", "streaming_found", "streams_allowed"]}}
{"project": "FFmpeg", "commit_id": "80387f0e2568746dce4a68e2217297029a053dae", "target": 1, "func": "static int mimic_decode_frame(AVCodecContext *avctx, void *data,\n\n                              int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MimicContext *ctx = avctx->priv_data;\n\n    GetByteContext gb;\n\n    int is_pframe;\n\n    int width, height;\n\n    int quality, num_coeffs;\n\n    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;\n\n\n\n    if (buf_size <= MIMIC_HEADER_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"insufficient data\\n\");\n\n        return -1;\n\n    }\n\n\n\n    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);\n\n    bytestream2_skip(&gb, 2); /* some constant (always 256) */\n\n    quality    = bytestream2_get_le16u(&gb);\n\n    width      = bytestream2_get_le16u(&gb);\n\n    height     = bytestream2_get_le16u(&gb);\n\n    bytestream2_skip(&gb, 4); /* some constant */\n\n    is_pframe  = bytestream2_get_le32u(&gb);\n\n    num_coeffs = bytestream2_get_byteu(&gb);\n\n    bytestream2_skip(&gb, 3); /* some constant */\n\n\n\n    if(!ctx->avctx) {\n\n        int i;\n\n\n\n        if(!(width == 160 && height == 120) &&\n\n           !(width == 320 && height == 240)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid width/height!\\n\");\n\n            return -1;\n\n        }\n\n\n\n        ctx->avctx     = avctx;\n\n        avctx->width   = width;\n\n        avctx->height  = height;\n\n        avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        for(i = 0; i < 3; i++) {\n\n            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));\n\n            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;\n\n        }\n\n    } else if(width != ctx->avctx->width || height != ctx->avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"resolution changing is not supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decoding must start with keyframe\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->buf_ptrs[ctx->cur_index].reference = 1;\n\n    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;\n\n    if(ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->next_prev_index = ctx->cur_index;\n\n    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;\n\n\n\n    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],\n\n                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    ff_thread_finish_setup(avctx);\n\n\n\n    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,\n\n                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if(!ctx->swap_buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ctx->dsp.bswap_buf(ctx->swap_buf,\n\n                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),\n\n                        swap_buf_size>>2);\n\n    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);\n\n\n\n    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {\n\n        if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);\n\n        else {\n\n            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ctx->prev_index = ctx->next_prev_index;\n\n    ctx->cur_index  = ctx->next_cur_index;\n\n\n\n    /* Only release frames that aren't used for backreferences anymore */\n\n    if(ctx->buf_ptrs[ctx->cur_index].data[0])\n\n        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    return buf_size;\n\n}\n", "idx": 25413, "substitutes": {"avctx": ["varctx", "varcomponent", " avcv", " avkw", "navcontext", "varcontext", "evcu", "avcontext", "varvoc", "afcontext", "avectx", "avctl", "varcmd", "avcal", "appcontext", "abcu", "appcmp", "abcmp", "AVxc", "avalkw", "akctx", "avcv", "avecmp", "akcontext", "AVcontext", "avcu", "AVkw", "abcf", "AVconfig", "afcfg", "abcontext", "avalcv", "navcomponent", "avalcontext", "AVvoc", "appctx", " avctl", "avconfig", "afctx", "avalctx", "abctx", "appctl", "AVctx", "avcfg", "avxc", "AVctl", "avcf", "AVcfg", "AVcmd", "AVcmp", "avecontext", "evcontext", "avcmp", "AVcu", "avecu", "afcf", "evctx", "avgpu", "navcal", "navvoc", "avvoc", "varcal", "akconfig", "avkw", "avalconfig", " avxc", "navcmd", "avconn", "afconn", "AVcli", "avalcfg", " avcli", "afctl", "avalxc", "avalgpu", "AVcf", "aveconfig", " avcfg", "avcli", " avgpu", "afcu", "AVgpu", "akcfg", "abconfig", "evconn", "aveconn", "avcomponent", "akctl", " avcontext", "akcli", "avecfg", "avcmd", " avconfig", "navctx", "AVcv", "afcmp", "afconfig"], "data": ["load", "Data", "uf", "body", "obj", "code", "batch", "frame", "image", "buffer", "queue", "base", "media", "read", "config", "next", "address", "bc", "reader", "message", "input", "dat", "parent", "client", "size", "video", "cache", "channel", "block", "addr", "buff", "window", "source", "src", "DATA", "content", "memory", "result", "connection", "val"], "data_size": [" data_data", "data_capacity", " data_capacity", " data_SIZE", "data_SIZE", "data_data"], "avpkt": ["AVpacket", "avperkt", "avmkt", "avmct", "AVpsth", "avPkt", "AVpck", "AVvpKT", "avPacket", "avcpKT", "AVcpacket", "avvpct", "avPsth", "AVpka", "avpsth", "AVPkt", "avfct", "AVvpkt", "avperct", "avmacket", "avpka", "avperka", "AVvpck", "avvpkt", "AVpKT", "avcpka", "avPck", "avcpkt", "avcpacket", "AVcpct", "avvpck", "avPct", "avpacket", "AVpct", "avfkt", "AVvpct", "avfka", "AVcpka", "AVcpkt", "avpct", "avpKT", "avperacket", "avvpKT", "AVPct", "avfsth", "avPKT", "avmsth", "AVPsth", "avfacket", "avcpct", "avcpck", "AVPacket", "avpck", "AVpkt"], "buf": ["seq", "uf", "code", "bag", "uc", "cv", "bb", "buffer", "queue", "vec", "rb", "config", "br", "cb", "bc", "bus", "ff", "cmd", "cap", " buffer", "box", "pool", "cf", "rc", "alloc", "cache", "Buffer", "cas", "buff", "window", "src", "fp", "map", "block", "fd", "val"], "ctx": ["kw", "cm", "acl", "console", "cca", "anc", "c", "pkg", "context", "cv", "qa", "cci", "xc", "config", "component", "cus", "cb", "act", "bc", "prefix", "kb", "css", "cmp", "wx", "fc", "cfg", "hw", "cmd", "vc", "loc", "wcs", "fw", "cli", "cal", "Context", "cc", "cp", "ci", "cf", "cn", "utils", "client", "sci", "conv", "cas", "git", "lc", "ctrl", "window", "ca", "tc", "na", "cu", "conn", "qq", "coll", "ck", "tx", "cs", "cam", "pc"], "gb": ["pg", "gru", "gom", "gs", "bridge", " cd", "nb", " lib", "ga", "rg", " db", "gc", " ig", " storage", "vg", "kw", "b", " bi", "gin", "bb", "storage", " eg", "gpu", " rgb", "tg", "mb", "ko", "gp", "gio", " bus", "yg", "bm", "pc", "g", "gram", "gu", "uf", " co", " rg", "rb", "gal", "gam", "gy", " gp", " cc", "db", " rc", "cfg", " cf", "eb", "gd", "gae", "sb", "abb", " alloc", " gl", " prog", "bf", "bc", "hub", " pci", " GC", " conf", " gcc", "GB", "gl", " kb", " gui", "gh", "greg", "gg", "bg", "gm", "ui", "cgi"], "is_pframe": ["is__pframes", "is__pfram", "is__fstate", "is_pstate", "is_pfram", "is__pframe", "is_brame", "is_fpstate", "is__ffram", "is_preframe", "is_hrame", "is_fpframe", "is_pframes", "is_ipframes", "is_fstate", "is_bfram", "is_ipframe", "is__pstate", "is_prerame", "is_hfram", "is_fpframes", "is_ipstate", "is_prame", "is_prefram", "is_bframe", "is_fpfram", "is_fframes", "is__fframe", "is__fframes", "is_hframe", "is_ffram", "is_fframe", "is_ipfram"], "height": ["build", "ht", "w", "definition", "dy", "inches", "lat", "input", "fw", "thin", "rank", "level", "window", "above", "Height", "gravity", "stroke", "gap", "slice", "th", "hang", "x", "def", "duration", "gpu", "distance", "density", "crop", "shape", "thumbnails", "generation", "ths", "ows", "h", "wall", "details", "han", "resolution", "d", "history", "tight", "capacity", "deep", "rows", "grow", "huge", "rh", "gallery", "wide", "arrow", "size", "view", "length", "pull", "alpha", "ty", "dim", "image", "img", "upper", "high", "depth", "padding", "layout", "east", "direction", "missing", "gh", "y", "bottom", "volume", "v", "times", " heights"], "quality": ["frequency", "gap", "z", "dim", "frame", "name", "resolution", "quiet", "time", "qa", "buffer", "weight", "style", "diff", "capacity", "speed", "version", "deep", "confidence", "depth", "qual", "padding", "distance", "density", "Quality", "grade", "rate", "scale", "level", "length", "window", "value", "q", "memory", "query", "alpha", "len", "format"], "num_coeffs": ["num_COeffi", "num_COffs", "num_COeffs", "num_COffi", "num_coefi", "num_coEFFes", "num_coffs", "num_coefes", "num_COeffps", "num_coefps", "num_coffes", "num_coefficientses", "num_coefficientsi", "num_coEFFps", "num_coefficientss", "num_coEFFi", "num_coffi", "num_coeffps", "num_coffps", "num_coefficientsps", "num_coefs", "num_coEFFs", "num_COffps", "num_COeffes", "num_coeffi", "num_COffes", "num_coeffes"], "i": ["oi", "idi", "abi", "yi", "p", "m", "b", "c", "ie", "info", "ori", "uli", "ix", "x", "adi", "ti", "mi", "diff", "phi", "qi", "it", "ri", "id", "io", "num", "u", "e", "li", "gi", "ji", "zi", "multi", "xi", "uri", "inner", "ii", "bi", "di", "ini", "si", "ni", "ai", "ci", "fi", "eni", "block", "lc", "h", "I", "count", "y", "child", "n", "ip", "j", "index", "a", "mini", "chi", "t", "v", "iu", "mu", "pi", "anti", "ui", "l", "hi", "area"]}}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x8(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[2];\n\n    unsigned int flags = 0;\n\n\n\n    /* 2-color encoding for each 4x4 quadrant, or 2-color encoding on\n\n     * either top and bottom or left and right halves */\n\n    CHECK_STREAM_PTR(2);\n\n\n\n    P[0] = *s->stream_ptr++;\n\n    P[1] = *s->stream_ptr++;\n\n\n\n    if (P[0] <= P[1]) {\n\n\n\n        CHECK_STREAM_PTR(14);\n\n        s->stream_ptr -= 2;\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // new values for each 4x4 block\n\n            if (!(y & 3)) {\n\n                P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                flags = bytestream_get_le16(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 1)\n\n                *s->pixel_ptr++ = P[flags & 1];\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n\n\n        /* need 10 more bytes */\n\n        CHECK_STREAM_PTR(10);\n\n\n\n        if (s->stream_ptr[4] <= s->stream_ptr[5]) {\n\n\n\n            flags = bytestream_get_le32(&s->stream_ptr);\n\n\n\n            /* vertical split; left & right halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 16; y++) {\n\n                for (x = 0; x < 4; x++, flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) {\n\n                    s->pixel_ptr -= 8 * s->stride - 4;\n\n                    P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                    flags = bytestream_get_le32(&s->stream_ptr);\n\n                }\n\n            }\n\n\n\n        } else {\n\n\n\n            /* horizontal split; top & bottom halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 8; y++) {\n\n                if (y == 4) {\n\n                    P[0] = *s->stream_ptr++;\n\n                    P[1] = *s->stream_ptr++;\n\n                }\n\n                flags = *s->stream_ptr++ | 0x100;\n\n\n\n                for (; flags != 1; flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->line_inc;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 25448, "substitutes": {"s": ["comments", "sys", "w", "ns", "ts", "ips", "sq", "ps", "states", "sync", "u", "es", "gs", "http", "lines", "sym", "f", "service", "fs", "js", "qs", "tests", "t", "n", "r", "ops", "native", "S", "p", "m", "b", "c", "sports", "ds", "ans", "us", "ins", "is", "sets", "ims", "phys", "ads", "aws", "new", "services", "h", "settings", "its", "g", "side", "times", "rs", "ses", "args", "ss", "features", "bis", "d", "ats", "data", "ms", "conf", "sg", "ks", "e", "session", "less", "hs", "sb", "your", "sf", "ssl", "cs", "params", "i", "opens", "site", "o", "si", "words", "os", "as", "ls", "a", "an", "parts", "l"], "x": ["my", "code", "xx", "w", "z", "i", "p", "b", "c", "name", "ww", "d", "ay", "ix", "image", "time", "data", "px", "wy", "xc", "en", "on", "no", "tx", "pe", "ax", "cross", "col", "gy", "X", "num", "sex", "id", "u", "e", "key", "ey", "xy", "any", "el", "xi", "dx", "yx", "l", "fx", "xs", "win", "h", "f", "n", "ip", "index", "t", "wa", "a", "rx", "v", "j", "ex", "ty", "in", "pos", "ph"], "y": ["yr", "height", "w", "hy", "z", "yi", "i", "p", "sy", "m", "dy", "c", "oy", "b", "ay", "d", "yt", "yl", "sky", "py", "ye", "type", "gy", "cy", "iy", "ch", "yer", "ym", "id", "lon", "vy", "yo", "key", "ey", "ys", "xy", "o", "ady", "ky", "Y", "yy", "size", "zy", "length", "ry", "h", "f", "count", "uy", "ny", "j", "year", "yn", "t", "n", "isy", "yd", "v", "ty", "l", "hi", "ya", "by", "g"], "P": ["S", "ARP", "L", "Data", "Push", "PP", "VP", "Q", "PU", "Position", "FF", "p", "GP", "NP", "WP", "PIN", "C", "Port", "LP", "Part", "K", "API", "T", "SP", "H", "A", "PE", "Py", "X", "XP", "BP", "Pool", "TP", " p", "R", "HP", "M", "JP", "D", "PUT", "PS", "Y", "PD", "B", "Point", "G", "N", "CP", "I", "Page", "FP", "Ps", "V", "IP", "E", "PF", "PO", "RP", "J", "AP", "O", "DP", "Path", "PA", "YP", "PR", "F"]}}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "substitutes": {"env": ["exec", " en", "txt", "NV", "her", "obj", "code", "console", "np", "er", "this", "scope", "exc", "app", "server", "engine", "ass", "context", "manager", "enable", "enc", "me", "data", "ec", "en", "config", "conf", "Environment", "export", "style", "global", "priv", "dict", "ev", "loader", "ea", "end", "environment", "proc", "self", "ne", "db", "buf", "e", "site", "el", "extra", "err", "cdn", "viron", "dev", "ctx", "eu", "eni", "cache", "erv", "external", "esp", "ext", "nw", "conn", "net", "core", "event", " environment", "nc", "que", "et", " environments", "eng"], "mem_buf": ["memalprim", "mem0buffer", "sm_raf", "mem_coord", "Mem_coord", "Mem_done", "sm_buf", "mem_bu", "memingbuf", "memalhor", "mem0hor", " mem_fd", "mem_prim", "mem_begin", "Mem_buf", "memingbuffer", "mem_fd", "sm_begin", "Mem_buffer", " mem_prim", "memmemvec", "mem_bag", "memmembuff", "mem_brace", "memalbuf", "mem_done", "mem_buffer", "mem_vec", "memmemdone", "Mem_brace", " mem_buff", "memmembuf", " mem_hor", "Mem_bu", "mem0prim", "sm_bu", "memalbuffer", "Mem_vec", "mem_raf", "Mem_buff", "mem_buff", "Mem_bag", "mem_hor", " mem_buffer", "memingfd", "mem0buf", "memingbuff"], "n": ["node", "np", "k", "w", "z", "i", "sn", "m", "b", "c", "name", "ns", "p", "d", "pn", "x", "or", "fn", "en", "no", "on", "nn", "config", " N", "num", "self", "ne", "u", "all", "nor", "e", "o", "s", "nb", "ni", "nt", "cn", "number", "N", "f", "y", "nr", "network", "j", "nw", "t", "un", "conn", "an", "net", "v", "nu", "r", "in", "nc", "l", "len", "nat"]}}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 25472, "substitutes": {"s": ["comments", "sys", "server", "ns", "ts", "sites", "sq", "ps", "secondary", "states", "sync", "sis", "self", "u", "es", "south", "gs", "sie", "http", "sym", "xs", "f", "service", "qs", "js", "fs", "n", "t", "status", "r", "ops", "S", "p", "m", "b", "c", "se", "sports", "ds", "state", "ins", "su", "is", "sets", "spec", "new", "services", "details", "sl", "settings", "in", "g", "rs", "ses", "this", "ss", "conf", "sg", "ks", "e", "session", "less", "sb", "your", "sf", "ssl", "cs", "sv", "i", "site", "o", "si", "os", "as", "ls", "y", "styles", "a", "l"], "full_update": ["full_save", "full_UPDATE", "full_append", "fulllexflush", "fullpreupdate", "fulllexupdate", "complete_status", "fullpreflush", "full___edit", " full_save", " full_flush", "fullprestatus", " full_UPDATE", "full_updated", " full_append", "complete_flush", "full___append", "fulllexstatus", " full_edit", "full_flush", "complete_updated", "full_edit", "fullpreupdated", " full_database", "complete_update", "fulllexupdated", "full_database", "full_status", " full_updated", "full___update"], "surface": ["side", "sc", "console", "slice", "wrapper", "face", "image", "scene", "texture", "screen", "sur", "site", "layout", "panel", "sym", "faces", "skin", "source", "stream", "sm", "sim", "sl", "aster", "draw", "ssl", "document", "sheet"], "cx": ["Cx", "rcwx", " cwx", "Cw", "cwx", "rcx", "ctx", "Cwx", "rctx", "rcw", " ctx", "Ctx"], "cy": ["sty", "cm", "cd", "dy", "ay", "wy", "yl", "cr", "py", "ct", "cb", "gy", "cycle", "vy", "wx", "ee", "gray", "xy", "iw", "yx", "ky", "cc", "ci", "cf", "ry", "ca", "ty"], "cheight": ["cheffield", "cheq", "Cheight", "chyadh", "cheights", "Cheadh", "chyights", "peigh", "peust", "feadh", "ceigh", "cheigh", "ceust", "chyight", "ueight", "cheust", "ueigh", "peq", "ceq", "peight", "feffield", "ueq", "feight", "chyffield", "Cheights", "ceight", "Cheffield", "feights", "ueust", "cheadh"], "cw": ["kw", "kx", "kh", " cws", "cv", "pcwd", "pcw", "Cx", "crx", "crv", "Cv", "dh", "dx", "pcx", "crw", "dw", "cws", "pcv", "Cw", "kws", "dws", "Cwd", "crwd", "cwd"], "ch": ["code", "cm", "ht", "th", "z", "cd", "c", "ach", "img", "align", "wh", "conf", "col", "bh", "chan", "el", "vc", "ctx", "ci", "cp", "cf", "count", "zh", "power", "sh"], "cattr": ["bwm", " cptr", "bwd", "bptr", " cwm", "cptr", "nattr", "cwm", " cwd", "nptr", "battr", "nwm", "nwd", "cwd"], "height": ["gap", "th", "w", "gravity", "dim", "dy", "resolution", "image", "hd", "x", "img", "style", "duration", "rows", "flow", "id", "deep", "high", "depth", "max", "padding", "input", "layout", "density", "angle", "fw", "arrow", "size", "thin", "crop", "shape", "html", "direction", "length", "window", "y", "bottom", "volume", "above", "zh", "png", "Height", "alpha", "stroke"], "ch_attr": ["char_attr", "ch_attribute", "char_offset", "chblockoffset", "char_unit", "chblockattribute", "ch_unit", "chblockattr", "ch_offset", "char_attribute", "chblockunit"], "cx_min": ["cw_version", "cx_mid", "cw_mid", "cw_min", "cw_max", "cx_version"], "cx_max": ["cw_ax", "cx_ax", "cx_mid", "cw_mid", "cw_min", "cw_max"], "linesize": ["lssize", "planessize", " linespeed", "planespeed", "linespeed", "planesize", "linesiz", "planesiz", "lspeed", " linessize", "lsiz", "lsize", " linesiz", "linessize"], "x_incr": ["x_incp", "x_decur", "x_increp", "x_intr", "x_intp", "x_increur", "x_decrs", "x_decp", "x_intrs", "x_incrs", "x_incur", "x_increr", "x_decr", "x_incrers", "x_intur"], "line": ["code", "w", "page", "frame", "name", "position", "style", "col", "write", "e", "cell", "unit", "lines", "lined", "lin", "mode", "le", "size", "level", "block", "length", "lc", "source", "pos", "range", "l", "len"], "line1": ["Line0", " line0", "Line1", "lin1", "line0", "lin0"], "offset": ["base", "sync", "num", "url", "start", "set", "angle", "ptr", "addr", "part", "entry", "limit", "row", "area", "usage", "layer", "gap", "slice", "option", "flag", "attribute", "align", "col", "address", "Offset", "port", "update", "phase", "abi", "adjust", "data", "notation", "no", "pointer", "error", "optional", "alias", "ui", "outer", "enabled", "append", "online", "size", "length", "count", "adjusted", "alt", "alpha", "pos", "location", "skip", "margin", "page", "shift", "info", "position", "image", "scroll", "exclusive", "api", "style", "type", "end", "id", "o", "padding", "layout", "slot", "off", "origin", "index", "reset", "format"], "fgcol": ["fgCol", "fxCol", "bgblock", "cfgblock", "fxcolor", "bgcolor", "fxcol", "cfgcol", "cfgcolor", "fxblock", "fgcolor", "bgCol", "fgblock", "cfgCol"], "bgcol": ["bluecol", "fgCol", "wxcol", "wxfl", "bgcolumn", "bluecolumn", "bluefl", "fgfl", "wxCol", "wxcolumn", "fgcolumn", "blueCol", "bgCol", "bgfl"], "v": ["ve", "gu", "k", "w", "z", "i", "p", "m", "b", "c", "va", "position", "ov", "x", "vs", "nv", "vt", "av", "version", "ev", "tv", "vv", "u", "e", "vert", "view", "vi", "video", "conv", "iv", "uv", "f", "lv", "value", "n", "j", "t", "V", "volume", "q", "ver", "r", "vp", "l", "sv", "volt", "val", "vol", "g"], "cursor_offset": ["cairo_ptr", "cursor_off", "cursor_pos", "cairo_pos", "cairo_off", "cairo_offset"], "d1": ["D2", "ds2", "d2", "f1", "ds1", "D1", "f2"], "d": ["w", "dc", "p", "m", "c", "dy", "x", "ds", "dp", "u", "e", "dir", "start", "di", "D", "direction", "dist", "f", "source", "out", "desc", "draw", "l", "g"], "src": ["slice", "b", "image", "data", "img", "rb", "config", "filename", "text", "bl", "url", "reverse", "input", "start", "loc", "sub", "st", "rc", "crop", "origin", "sup", "dist", "source", "bg", "sl", "attr"], "dest": ["Dest", "txt", "comb", "done", "dc", "dim", "img", "text", "cb", "url", "path", "dir", "di", "dev", "coord", "vert", "direction", "origin", "dist", "dep", "source", "route", "desc"], "cursor_ptr": ["cairo_ptr", "cursor_pointer", "cursor2offset", "cairo_pointer", "cursor2ptr", "cairo_pad", "cursor_pad", "cursor2pointer", "cursor2pad", "cairo_offset"], "font_ptr": ["font_pointer", "text_ptr", "text_offset", "font_offset", "text_address", "font_address", "text_pointer"], "font_base": ["fontamspace", " font_cache", "fontlexsize", "font_area", " font_bare", "font_cache", "font_type", "font_size", "fontambase", "font_ase", " font_size", "font_support", "font_bare", " font_format", "font_space", " font_area", "fontlexbare", "fileamspace", "fileamsupport", "file_ase", " font_type", "font_format", "file_space", "fontamsupport", "fontlextype", "fileambase", "fontlexformat", "fontlexarea", "file_base", "fontlexbase", "fileamase", "fontamase", "fontlexcache", "file_support"], "dup9": ["udv9", "duv96", "dub7", "udv96", "dups96", "duv9", "dub96", "dub11", "udp11", "dup7", "duv7", "duv11", "udp96", "dups7", "udv11", "dup96", "dub9", "udp7", "udv7", "dup11", "udp9", "dups9", "dups11"], "line_offset": ["line\u00b7offset", " line_index", "inline_base", " line_off", "lin_address", "line_location", " line_location", "line_index", "line_position", "line\u00b7notation", "inline_notation", "line_off", "line_address", "line\u00b7off", "line_notation", "line_base", "lin_off", "lin_offset", "line\u00b7base", "inline_offset", "lin_position", "inline_off"], "palette": ["Palettes", "Palignment", "capignment", "Palette", "plant", "capettes", "palettes", "plette", "plettes", "Palant", "capant", "capette", "palignment", "palant", "plignment"], "ch_attr_ptr": ["ch_att_pointer", "ch_attr_addr", "ch_attr_pointer", "ch_att_ptr", "ch_att_tr", "ch_att_addr", "ch_attr_tr"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492, "substitutes": {"f": ["ref", "fen", "fe", "fo", "af", "i", "p", "m", "c", "d", "rf", "data", "bf", "fr", "proc", "lf", "e", "feed", "fc", "fw", "inf", "fi", "fb", "fx", "cf", "buff", "raf", "h", "fs", "tf", "t", "fp", "func", "df", "l", "fd", "file", "F"]}}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    return av_read_frame(qc->fmtctx, pkt);\n\n}\n", "idx": 25501, "substitutes": {"s": ["S", "rs", "ses", "sc", "k", "ss", "p", "m", "i", "c", "ns", "b", "d", "data", "sq", "ds", "sg", "self", "u", "e", "gs", "spec", "sv", "ctx", "client", "sb", "f", "n", "src", "a", "an", "t", "v", "r", "sf", "parts", "ssl", "cs", "g"], "pkt": [" pk", " packet", "nk", "nkg", "pkg", "met", "Pnt", "mnt", "packet", " pet", "Pk", "Pkg", " pnt", "Packet", "pk", "pet", "mkt", "nacket", "nkt", " pkg", "pnt", "macket", "Pkt", "Pet"], "qc": ["cfc", "klc", "qlc", "kcu", "qcu", "qtpc", "kpc", " qdc", "Qlc", "dqc", "Qc", "dqdc", "qtcu", "dqlc", "dqci", "qdc", "cfpc", "kc", "cfcu", " qlc", "Qci", "cflc", "qtlc", " qci", "qpc", "qci", "qtc", "Qdc"]}}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n\n                                           const char *devaddr,\n\n                                           const char *opts)\n\n{\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    int type = -1;\n\n    char buf[128];\n\n    PCIBus *bus;\n\n    int devfn;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", opts)) {\n\n        if (!strcmp(buf, \"scsi\"))\n\n            type = IF_SCSI;\n\n        else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 25505, "substitutes": {"mon": ["my", "day", "user", "bin", "date", "m", "master", "bo", "mail", "gin", "mount", "module", "msg", "mi", "col", "bug", "mr", "non", "meter", "mat", "mid", "bean", "dom", "boot", "mag", "MON", "mer", "con", "home", "prem", "cmd", "min", "atom", "mt", "session", "month", "ann", "lin", "ko", "mn", "mun", "pin", "mo", "thin", "mc", "plan", "pal", "man", "part", "mini", "lo", "tom", "conn", "mm", "an", "amon", "un", "reg", "mu", "Mon", "normal", "monitor", "block", "pos", "connection", "mit", "vol", "lock", "fun"], "devaddr": ["appfn", " devname", "devicefn", "evlen", "evaddr", "deviceAddress", "appaddress", "devicename", "evref", "deviceaddress", "deviceref", "difffn", " devref", "diffaddress", "appaddr", "diffAddress", "evfn", " devaddress", "evname", "devAddress", "deviceaddr", "devaddress", " devlen", "devicelen", "evAddress", "evaddress", "devref", "devlen", "diffaddr", "devname"], "opts": [" ops", " optgs", "opters", "opttr", "opouts", "optTS", "opgs", " optth", "optouts", "opth", "opTS", "optgs", "OPcs", " optts", " opters", "opcs", "optt", "opt", "OPters", " opt", "optth", " opth", "optcs", "optters", " opouts", " optr", " opted", "OPouts", "OPted", " opgs", "OPtr", "iopTS", "opted", "optts", "optted", "OPts", "optr", "iopt", "OPt", "iopcs", "OPTS", "iopts", "ops"], "dev": ["ve", "temp", "gu", "priv", "user", "driver", "dc", "info", "fo", "app", "compl", "d", "test", "data", "kick", "var", "prop", "conf", "diff", "good", "pub", "debug", "error", "bug", "DEV", "def", "prof", "ev", "ch", "serial", "prom", "die", "adv", "dd", "kind", "id", "dom", "dem", "valid", "err", "lib", "di", "result", "client", "nov", "cache", "ani", "req", "device", "off", "dist", "mod", "development", "comment", "conn", "Dev", "rad", "root", "ver", "pos", "block", "fail", "vol"], "dinfo": ["DInfo", "dcInfo", "dhhelp", "dderror", "ndinf", "derror", " derror", "dlINFO", " dInfo", "dhinf", " dfo", "Dinf", "fInfo", "dhelp", "ldsafe", "dnow", "dninfo", "lerror", "ndinit", "ldinf", "Dinfo", "addiff", "disinfo", "nfo", "dcinfo", "dinf", " ddiff", " dsafe", "dhINFO", "dhinfo", "dayinit", "disINFO", "dnhelp", "linf", "ddInfo", "finf", "lInfo", "disnow", "dINFO", "ddiff", "dfi", "dlnow", "dsinf", "dcerror", "pdinfo", "dfo", "nfi", "dconf", "ndINFO", " dconf", "lfo", "dddiff", "ddinf", "ffo", " dfi", " dhelp", "pdinf", "dserror", "dsafe", "adinfo", "ndinfo", "dayINFO", "ldinfo", "ddconf", "dsfo", "aderror", " dinf", "dlinfo", "dinit", "dayinf", "pdsafe", "ddinfo", "ninfo", "lderror", "dcconf", "linfo", "ffi", "dInfo", "dsinfo", "pderror", "finfo", " dINFO", " dnow", "disinf", "dnINFO", "adinf", "ninf", "dlinf", " dinit", "dayinfo", "dninf"], "buf": ["seq", "uf", "bag", "uc", "b", "batch", "wb", "bo", " buff", "cv", "fam", " bu", "Buff", "data", "buffer", "vec", "blocks", "text", "ab", "br", "rb", " b", "bh", "config", "cb", "queue", "bc", "bl", "base", "mac", "bu", "pad", "bed", "url", "feed", "brace", "aux", "home", "bang", "ff", "cmd", "path", "cap", "pb", " buffer", "la", "loc", "bound", "box", "ctx", "result", "fb", "rc", "alloc", " bc", "feat", "conv", " aux", "tab", "cas", "buff", "raf", "bid", "src", "runner", "func", "lim", "bt", "fd"], "bus": ["gen", "driver", "bin", "class", "b", "bo", "cat", "mount", "las", "usb", "mot", "base", "config", "us", "bc", "bug", "pass", "port", "io", "die", "bs", "proc", "serial", "hub", "boot", "feed", "home", "li", "front", "bridge", "http", "session", "Bus", "pl", "lib", "box", "board", "lab", "local", "cache", "device", "proxy", "serv", "bid", "loop", "used", "pull", "conn", "host", "plug", "coll", "root", "pu", "block", "pos", "lock", "BUS"], "devfn": ["deffn", " devname", "divname", "devicefn", "evlen", " devFN", "devln", " devf", "deviceln", "pubfp", "devicename", "evln", "Devfp", "divfn", "defln", " devn", "pubfn", "pubf", "devicefd", " devfp", "deffp", "devFN", "deflen", "devfp", "DevFN", "evfn", "Devf", "Devfn", "evname", "devicen", "devfd", "pubFN", "devicelen", " devln", " devfd", "divn", "defname", "devlen", "divfd", "divfp", "devn", "devname", "divln", "devf"], "scsibus": ["scpsisu", " scssis", " scssbis", "scsis", " scsis", "Scsidi", "scsgasi", "scrsasi", "scssbis", "Scsasi", "scssidi", "scsisu", "Scsisu", "scosis", "scssisu", "scssasi", " scssisu", "Scssibus", "scsgidi", " scsbis", "scpsbis", "scpsis", "scsidi", "scosibus", "Scssasi", " scssibus", "scosisu", "scsgibus", "scssis", "scpsibus", "scsasi", "scrsibus", "scrsisu", "Scssidi", "Scssisu", "scsgisu", "scrsidi", "scosbis", "scssibus", "Scsibus", "scsbis", " scsisu"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510, "substitutes": {"eeprom": ["pseeprome", "eegrome", "peefron", "eeprome", "eepron", "eapron", " eppram", "eepchrom", "eepsron", "emprim", "peeprm", "eefram", " eeprim", "eEprom", "eefrm", "eeprod", "eppron", "peeprom", "eaprom", "eaprod", "empram", " eaprom", " eapron", "pseepram", " eaprod", "eegrom", "pseeprm", "epprom", "eEpchrom", "pseegrom", "pseeprom", "eegrm", "peepram", "peefram", "eeprim", "eepram", "eegram", "eefrom", "pseegrm", "emprm", " epprom", "eapchrom", "epprome", "eEprod", "eEpron", " eepchrom", "eeprm", "epprim", "eefron", " eeprod", " eapchrom", "peefrm", " eepram", "peefrom", "pseegram", " epprim", "eefrim", "eepschrom", "empron", "pseegrome", "eefrome", "emprom", " eppron", " eepron", "eppram", "eepsrom", "eepsrod", "epprm", "peepron"]}}
{"project": "qemu", "commit_id": "f3172a0e2e7bd983cada19f11d9bb59400e0dd3d", "target": 0, "func": "static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 25515, "substitutes": {"opaque": ["opsaques", "operac", "operaque", " opaques", "operc", "operaques", "opsaque", "opac", "opaques", " opac", "OPca", "opc", "opca", "opsc", "OPac", " opca", " opc", "operca", "OPc", "OPaque"], "addr": ["ref", "socket", "name", "pkg", "ld", "add", "cb", "aug", "url", "hl", "cmd", "bridge", "ord", "coord", "hop", "rg", "ptr", "wr", "env", "layer", "md", "code", "driver", "p", "x", "align", "ad", "address", "prefix", "port", "buf", "work", "cap", "oa", "forge", "src", "func", "attr", "rr", "fd", "len", "kt", "node", "usr", "data", "pointer", "mac", "alias", "expr", "adr", "href", "offset", "mode", "ar", "proxy", "arg", "ack", "xp", "alt", "host", "ha", "org", "anne", "pos", "seq", "Address", "hash", "dr", "asm", "config", "vr", "id", "pad", "site", "grad", "eth", "loc", "slot", "worker", "channel", "handle", "rt", "ext", "ip", "route", "adder", "ace"], "value": ["w", "server", "name", "buffer", "version", "non", "multiple", "valid", "two", "start", "set", "fee", "model", "number", "current", "entry", "limit", "content", "match", "memory", "wa", "val", "native", "complete", "none", "m", "cost", "test", "address", "Value", "example", "port", "key", "password", "resource", "work", "one", "now", "xml", "money", "json", "array", "update", "rule", "total", "root", "description", "large", "node", "function", "data", "no", "component", "capacity", "reference", "message", "get", "command", "offset", "output", "parent", "join", "VALUE", "size", "view", "length", "count", "source", "php", "alt", "ha", "age", "connection", "paid", "position", "image", "weight", "member", "type", "write", "end", "flow", "id", "unit", "home", "gi", "create", "multi", "sample", "scale", "device", "off", "child", "index", "v", "values", "result", "format"], "s": ["comments", "sys", "server", "ns", "ts", "sites", "sq", "secondary", "states", "sync", "u", "es", "stats", "gs", "set", "sym", "xs", "f", "service", "fs", "js", "n", "qs", "t", "r", "native", "S", "p", "m", "b", "c", "se", "ds", "us", "ins", "su", "is", "sets", "spec", "aws", "services", "sl", "settings", "in", "its", "g", "rs", "ses", "args", "scope", "ss", "d", "conf", "sg", "ks", "e", "session", "hs", "stat", "sb", "full", "sf", "ssl", "cs", "iss", "site", "o", "si", "uns", "as", "ls", "y", "l"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_mallocz(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avcodec_get_frame_defaults(frame);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    return frame;\n\n}\n", "idx": 25526, "substitutes": {"frame": ["fram", "framework", "code", "element", "body", "call", "slice", "none", "dy", "c", "position", "image", "function", "frames", "scene", "data", "buffer", "base", "component", "pointer", "next", "feature", "hide", "property", "cycle", "flow", "instance", "hole", "fr", "boot", "e", "point", "line", " Frame", "object", "board", "fb", "cf", "setup", "scale", "video", "length", "iframe", "part", "f", "flo", "value", "Frame", "fp", "row", "ace", "result", "ce", "val", "ze"]}}
{"project": "FFmpeg", "commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "target": 1, "func": "static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n", "idx": 25530, "substitutes": {"dst": ["rdsts", "jsp", " dconst", "dsdest", "idST", "sdcast", " dsts", "dsts", "jst", "sdsp", "dsst", "rdst", "adst", "dconst", "rdST", "dST", " dost", "dsrc", "ldsc", "jconst", " dsp", "jcast", "adsts", "dssrc", "ldsp", "cdsrc", "ldst", "rdost", "cddest", "sdst", "dssts", " dcast", "dsp", " dsc", "ddest", "dost", " dST", "cdsts", "cdst", "ldsts", "dsc", " ddest", "idost", " dsrc", "adsp", "sdconst", "idsts", "adsc", "dcast", "idst"], "src": ["rest", "sc", "sr", "kk", "uc", "b", "sn", "cv", "img", "sq", "config", "rb", "support", "ins", "inst", "url", "fc", "reverse", "scl", "tmp", "expl", "loc", "sub", "spec", "inf", "st", "cc", "ctx", "sb", "sort", "record", "rc", "asc", "sec", "conv", "rank", "scan", "sup", "source", "usc", "stack", "dest", "attr", "in", "ssl", "desc"], "mask": ["skip", "sc", "sk", " img", "info", "shift", "m", "card", "fac", "filter", "flags", "flag", "asm", "qa", "fix", "img", "weight", "label", "delay", "conf", "sum", "check", "hack", "pass", "shadow", "mac", "ask", "rec", "cover", "allow", "key", "black", "patch", "arr", "work", "bit", "Mask", "group", "sign", "cc", "clear", "inc", "scale", "shape", "scan", "ack", "count", "comment", "reg", "match", "map", "pack", "block", "mark", "lock"], "w": ["ow", "kw", "k", "z", "p", "m", "ww", "wb", "c", "d", "sw", "x", "weight", "wh", "end", "wn", "u", "wx", "iw", "work", "max", "l", "wcs", "fw", "wd", "ew", "tw", "win", "h", "window", "aw", "y", "wt", "wall", "n", "W", "f", "t", "q", "v", "r", "wa"], "acc": ["sc", "comb", "abi", "acl", "rac", "dc", "uc", "effect", "ass", "anc", "c", "card", "aa", "fac", "app", "batch", "asm", "enc", "qa", "test", "weight", "config", "circ", "conf", "access", "eff", "abc", "pass", "aug", "mac", "ask", "rec", "u", "ak", "allow", "fc", "amp", "AC", "gain", "contract", "CC", "ann", "inf", "sign", "cc", "result", "order", "inc", "rc", "cache", "shape", "asc", "sup", "complex", "ack", "f", "comment", "a", "g", "alpha", "ace", "attr", "pack", "account", "ac", "Acc", "ACC"], "i": ["abi", "k", "iii", "ie", "p", "m", "b", "c", "yi", "info", "d", "uli", "ix", "x", "ti", "mi", "phi", "qi", "it", "ri", "id", "io", "ui", "u", "e", "key", "li", "o", "gi", "ji", "zi", "xi", "uri", "s", "start", "inner", "ii", "bi", "si", "ai", "di", "ni", "ini", "cli", "ci", "fi", "isin", "lc", "I", "y", "f", "oi", "n", "j", "index", "a", "t", "v", "iu", "mu", "pi", "init", "in", "l", "hi"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549, "substitutes": {"base": ["seq", "obe", "byte", "info", "b", "p", "server", "c", "ix", "vs", "buffer", "en", "bf", "gb", "up", "py", "address", "ada", "real", "bc", "end", "inet", "aos", "buf", "es", "e", "ba", "work", "path", "bi", "ctx", "Base", "weak", "cache", "as", "au", "f", "po", "fs", "used", "ip", "net", "fp", "out", "be", "full", "root", "core", "r", "ace", "v", "reset", "len", "area"], "env": ["ses", "ep", "np", "er", "w", "scope", "z", "iss", "exc", "p", "c", "context", "inv", "enc", "vs", "enable", "ec", "en", "config", "conf", "state", "ch", "ev", "end", "ea", "inet", "environment", "e", "es", "ey", "path", "viron", "si", "ctx", "energy", "eu", "sb", "eni", "cache", "oa", "h", "f", "y", "network", "conn", "net", "core", "v", "init", "ex", "settings", "nc", "que"], "s": ["socket", "sys", "w", "z", "server", "ns", "ts", "vs", "sites", "sq", "ps", "states", "sync", "sis", "u", "es", "gs", "south", "sym", "f", "fs", "js", "n", "qs", "t", "r", "S", "sk", "p", "m", "b", "c", "en", "ds", "us", "state", "su", "is", "spec", "services", "sl", "settings", "its", "g", "rs", "ses", "ss", "d", "conf", "sg", "e", "session", "sb", "client", "q", "sf", "ssl", "cs", "secure", "sc", "secret", "i", "o", "si", "os", "ctx", "ls", "y", "v", "l"], "iomemtype": ["vocemtypes", "iomademTYPE", "iopademstyle", "iopademtype", "iomhemstyle", "iomerType", "iomhemval", "iomhemTYPE", "iomemTYPE", "iomemType", "iomEMtypes", "iopemTYPE", "lovemType", "iomEMstyle", "lovearType", "iomeltype", "iomertypes", "iopemtypes", "iomhemtype", "iopademtypes", "iomemtypes", "lovemid", "iomelrole", "iomimertypes", "iomhemtypes", "voceltypes", "iomearval", "iomhemid", "iopemtype", "iomimerrole", "iopademTYPE", "iomertype", "voceltype", "iomhemType", "iomEMtype", "loveartype", "iomerrole", "iopemstyle", "iomearid", "iomelval", "iomelid", "vocemtype", "lovearid", "iomearType", "iomeartype", "iomemval", "iomademtype", "iomademtypes", "vocelrole", "iomelType", "vocemType", "iomemstyle", "lovemtype", "vocelType", "iomademstyle", "iomimertype", "iomemid", "iomimerType", "iomemrole", "iomEMTYPE", "vocemrole", "lovearval", "iomeltypes", "lovemval"], "qi": ["fen", "gui", "iq", "qua", "yi", "i", "p", "shi", "c", " ki", "qa", "qt", "sq", "config", "jp", " ii", "ei", " iii", " q", " ni", "li", "zi", "esi", "xi", "aq", "bi", "ii", "si", "ai", "cli", "ni", "ctx", "ci", "fi", "iaz", "agi", "eni", "cf", "sci", "req", "pai", "ahi", "qs", "qq", "q", "qv", "mu", "dq", "ace", "query", "chi", "ce"]}}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25550, "substitutes": {"opts": ["popments", "obls", "opls", "opttd", "optls", "oprs", "OPter", "opments", "popts", "edls", "edTs", "optter", "obTs", "edtics", "obts", "OPns", "optt", "opt", "popte", "popps", " opt", "OPs", "obt", "optrs", "cattd", "obrs", "opTs", "optd", " opments", " opsts", "opps", "otrs", "edts", "catte", "poprs", "poptd", "opttics", "obs", "optps", " opns", "catps", "optts", "OPts", "optics", "otts", "opns", " opter", "OPrs", "popsts", "obtics", "OPt", "opte", "optns", "optte", "catts", "otsts", "otments", "ops", "opter", "opsts", "optTs", " oprs"], "new_opts": ["new_operps", "new_optts", "new_OPs", "new_OPps", "new_OPts", "new_opt", "new_optt", "new_operts", "new_opers", "new_ops", "new_OPt", "new_optps", "new_opps", "new_opert"], "name": ["space", "temp", "call", "w", "nm", "m", "time", "base", "no", "address", "type", "prefix", "ame", "id", "alias", "Name", "key", "options", "o", "path", "cap", "parent", "word", "new", "client", "size", "active", "part", "NAME", "named", "network", "n", "ip", "names", "host", "nam", "connection"], "vlan": ["vnic", "jlan", " vnet", "jni", "nvnet", "vLAN", "vnet", "msl", " vnic", "jLAN", "vpn", "nvnic", "nvpn", "qlan", "vni", "mni", "qnet", "qnic", "mLAN", "mlan", "jsl", "vsl", "qpn", " vLAN", " vsl", " vni", " vpn", "nvlan"], "sock": ["pock", " socks", "Sink", "Sck", " sink", "sick", "socker", "spvc", "Socker", "socks", " socker", "spick", "sck", "svc", "spock", "sink", "pvc", "spocks", " sck", "Socks", " svc", " sick", "Sock", "pick", "pocks"], "group": ["mask", "gu", "gap", "package", "user", "family", "scope", "cost", "context", "module", "force", "label", "style", "config", "type", "gr", "band", "version", "global", "company", "id", "key", "password", "parent", "order", "size", "sort", "number", "field", "note", "gh", "mod", "part", "gg", "count", "groups", "ip", "host", "coll", "Group", "GROUP", "range", "guard", "roup", "where", "g"], "port": ["import", "p", "Port", "PORT", "position", "time", "prop", "config", "interface", "ports", "address", "type", "version", "op", "id", "method", "key", "point", "options", "project", "offset", "pool", "phone", "target", "hop", "number", "direction", "length", "mod", "timeout", "ort", "count", "service", "value", "limit", "ip", "index", "host", "route", "range", "pos", "priority", "pid"], "mode": ["md", "mask", "move", "slice", "driver", "MODE", "m", "dim", "position", "module", "time", "lan", "style", "delay", "type", "version", "id", "depth", "line", "key", "step", "cmd", "max", "dir", "command", "month", "role", "model", "lane", "grade", "order", "size", "rate", "scale", "level", "direction", "ward", "device", "mod", "Mode", "slave", "mm", "route", "ace", "range", "language", "priority"]}}
{"project": "FFmpeg", "commit_id": "f57b00e89749b559da7cd99a4b630c90617e17d4", "target": 1, "func": "static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n\n{\n\n    int i = 0;\n\n    while (ff_id3v2_extra_meta_funcs[i].tag3) {\n\n        if (!memcmp(tag,\n\n                    (isv34 ?\n\n                        ff_id3v2_extra_meta_funcs[i].tag4 :\n\n                        ff_id3v2_extra_meta_funcs[i].tag3),\n\n                    (isv34 ? 4 : 3)))\n\n            return &ff_id3v2_extra_meta_funcs[i];\n\n        i++;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25557, "substitutes": {"tag": ["ref", "code", "call", "param", "class", "token", "date", "name", "cat", "Tag", "test", "attribute", "text", "prop", "feature", "type", "prefix", "bug", "tail", "id", "num", "key", "patch", "atom", "loc", "category", "word", "feat", "length", "comment", "year", "reg", "pair", "match", "TAG", "attr", "block", "val"], "isv34": ["Isv35", "risvv349", "isv349", "isu35", "ISV36", "isvs349", "isv36", "isv31", "isvs34", "Isvp34", "isV33", "Isvp35", "isf35", "isuv339", "isv33", "isv339", "risv34", "risv339", "isvp349", "Isv349", "isf33", "isu33", "isV349", "risv31", "ISv33", "isvs33", "Isvp33", "risv349", "risvv31", "Isvp349", "isV34", "isvv339", "isvv34", "Isv34", "risvv339", "isvs35", "isvs339", "ISv35", "ISv36", "isvp33", "isu34", "isV35", "isvv31", "isv35", "isf34", "ISV34", "isV36", "ISv34", "isvv349", "isuv34", "isuv349", "isuv31", "ISV33", "isu36", "ISV35", "isvs31", "isvp35", "Isv33", "risvv34", "isvp34", "isf36"], "i": ["abi", "slice", "iii", "ski", "ie", "info", "m", "p", "b", "yi", "c", "d", "uli", "ix", "x", "api", "adi", "ti", "phi", "qi", "ri", "io", "ui", "u", "e", "key", "li", "gi", "o", "multi", "xi", "uri", "start", "bi", "di", "si", "ai", "ini", "ni", "ii", "ci", "I", "y", "f", "oi", "j", "ip", "index", "t", "a", "v", "init", "iu", "pi", "mu", "l", "g"]}}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}", "idx": 25566, "substitutes": {"buffer_filter": ["bufferwfilter", "callbackvfinder", "bufferlexfilter", "thread_slice", "buffer_find", "callback_fil", "buffer_set", "buffer_context", "buffervfil", "bufferlexset", "callback_filter", "buffer_handler", "bufferwfil", "buffer_finder", "buffer_fil", "queue_proxy", "bufferwfinder", "bufferwcontrol", "queue_filter", "buffer0fil", "buffervfinder", "code_ref", "buffer_proxy", "buffer0control", "queue_set", "bufferlexcontext", "buffer_force", "buffer_control", "code_force", "bufferlexproxy", "buffer_slice", "buffer0filter", "queue_context", "callbackvfilter", "thread_filter", "buffervfilter", "callback_finder", "callback_control", "thread_fil", "code_filter", "callbackvfil", "buffer_ref", "buffer0finder", "buffervcontrol", "callbackvcontrol", "code_find", "thread_handler"], "picref": [" picdef", " picurl", " picalf", "pitcol", "pinconfig", "busdef", " picfilter", " piccol", "nicurl", "busref", "icdef", "macref", "picalt", "picurl", "busRef", "pinref", "icalf", "pcval", "bcRef", "Picconfig", "icreference", " picconfig", "pcref", "macfilter", "picval", "macurl", "picconfig", "picdef", "bcref", "macreference", "pitref", "nicfilter", "pinreference", "nicval", "pinurl", "nicREF", "pitalt", "nicdef", "picRef", "Picreference", "picalf", "pitreference", "pcdef", " picreference", "Picref", "pincol", "pinalt", "nicreference", "piccol", "icref", "picfilter", "picreference", "nicref", "bcreference", "icREF", " picREF", "busval", " picRef", "icRef", "bcalf", "nicRef", " picalt", "pcRef", "picREF", "Picurl"], "flags": ["mask", "ants", "args", "features", "flag", "ats", "ils", "Flags", "planes", "types", "rules", "books", " fs", "plugins", "locks", "vals", "lf", "stats", "rets", "options", "fields", "caps", "s", "lines", " bits", "fee", "fl", "lag", "utils", "fx", "files", "bugs", "ags", "fs", "bits", "styles", "alls", "status", "checks", "nl", "FLAG", "settings", "ops", "parts", "sf", "fd", "fun"], "c": ["exec", "sc", "call", "cm", "k", "w", "dc", "uc", "oc", "p", "b", "m", "cat", "C", "context", "d", "cv", "enc", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "cy", "ch", "self", "u", "e", "con", "o", "cl", "vc", "ac", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "co", "lc", "ctrl", "ca", "f", "tc", "cu", "conn", "t", "coll", "v", "g", "l", "cs", "ce", "pc"], "buf": ["ref", "bag", "wb", "pkg", "lb", "Buff", "buffer", "gb", "cb", "cmd", "pool", "cf", "buff", "f", "fp", "val", "obj", "b", "cv", "queue", "bd", "port", "proc", "feed", "ff", "pb", "cap", "cache", "feat", "cas", "raf", "src", "plug", "func", "len", "fd", "fun", "uf", "bin", "uc", "data", "rb", "ab", "brace", "str", "tmp", "la", "box", "cp", "fb", "fi", "alloc", "seq", "job", "vec", "img", "cur", "config", "bf", "br", "bh", "bc", "aux", "home", "loc", "ctx", "rc", "fat", "off", "bg", "runner", "result"], "ret": ["ref", "fin", "sr", "ft", "cat", "rf", "base", "att", "num", "mem", "det", "lit", "lib", "nt", "pet", "part", "match", "r", "val", "code", "obj", "af", "flag", "red", "en", "debug", "def", "bit", "repl", "RET", "result", "let", "bad", "pat", "Ret", "value", "len", "fun", "res", "over", "data", "back", "rb", "success", "no", "fail", "error", "al", "err", "re", "reply", "utf", "bot", "arg", "alt", "reg", " RET", "job", "cur", "bf", "pass", "id", "rets", "rev", "run", "art", "rc", "active", "rt", "ext", "out", "reset", "format"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n", "idx": 25571, "substitutes": {"obj": ["ref", "txt", "args", "this", "pty", "p", "pt", "objects", "ob", "x", "fn", "data", "Object", "img", "bh", "act", "so", "inst", "id", "self", "bj", "arr", "o", "obb", "str", "tmp", "object", "art", "os", "ctx", "bot", "xs", "xxx", "Obj", "active", "po", "oi", "n", "j", "src", "js", "q", "init", "pos"], "qs": ["rs", "iq", "args", "events", "pg", "ns", "eries", "ts", "ips", "qa", "vs", "maps", "qt", "sq", "forces", "ds", "igs", "ps", "qi", "ks", "rows", "ins", "plugins", "bs", "eps", "gs", "fields", "str", "s", "ql", "strings", "fts", "ads", "wcs", "points", "hs", "als", "ctx", "mods", "req", "xs", "quad", "pages", "ls", "fs", "js", "tests", "qq", "checks", "q", "qv", "results", "dq", "query", "parts", "cs", "ints", "books"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n", "idx": 25574, "substitutes": {"ctx": ["kw", "cm", "cca", "scope", "dc", "cd", "anc", "c", "pkg", "context", "cv", "connection", "qa", "xc", "config", "component", "conf", "cus", "ct", "cb", "bc", "ocr", "fc", "cfg", "hw", "cmd", "cms", "cdn", "loc", "cli", "Context", "cc", "cn", "ci", "cf", "client", "cache", "conv", "cas", "lc", "ctrl", "ca", "tc", "cu", "conn", "crit", "nc", "tx", "cs"], "node": ["exec", "ref", "call", "server", "name", "callback", "module", "enc", "sync", "num", "self", "cmd", "object", "edge", "n", "content", "core", "query", "document", "native", "remote", "none", "c", "msg", "live", "op", "Node", "key", "path", "leaf", "stage", "func", "consumer", "root", "event", "load", "gen", "this", "parse", "context", "function", "no", "component", "nn", "global", "loader", "cdn", "command", "session", "graph", "odes", "handler", "parent", "client", "view", "source", "nw", "null", "host", "connection", "post", "tree", "package", "fn", "config", "instance", "id", "hub", "loc", "inner", "comment", "child", "conn", "route"]}}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578, "substitutes": {"vq": [" vqs", "svqs", "vQ", "vux", "ivck", "sviq", "svQ", "svq", "gQ", "vque", "svux", "Vck", "svck", "ivq", "Vq", " vque", "gque", "iviq", "gqs", "vck", "gq", "viq", " vQ", "svque", "vqs", "Viq", "Vux", "ivux"], "in": ["login", "IN", "din", "margin", "byte", "bin", "i", "b", "m", "c", "name", "d", "gin", "In", "inas", "qa", "data", "kin", "read", "again", "rin", "diff", "ax", "ins", "pass", "Out", "pc", "id", "rec", "raw", "max", "input", "min", "str", "ini", "nin", "pin", "new", "inc", "inn", "isin", "len", "win", "arg", "f", "n", "index", "ex", "ac", "val"], "out": ["IN", "OUT", "call", "token", "bin", "gin", "In", "qa", "doc", "no", "again", "diff", "ax", "Out", "outs", "ins", " Out", "id", "wx", "o", "arr", "cmd", "outer", "str", "nin", "nt", "new", "inc", "isin", "off", "ext", "index", "net", "init", "ex", "gt"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "substitutes": {"argc": [" argf", "argsf", "Argf", "argsc", " argn", "Argn", "argf", "Argv", "argn", "argsn", "Argc", "argsv"], "argv": ["argsb", " argp", "argb", "argsc", "Argp", "Argv", "argp", "argsp", "Argc", "argsv", "Argb", " argb"]}}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583, "substitutes": {"ram_size": ["ram_c", "ram_shape", "ramingshape", "memory_size", "ramingc", " ram_addr", "ram6size", "ram_addr", "ram_address", "gram_source", "ram_Size", " ram_shape", " ram_c", "gram_address", "ram6Size", "ram_source", "ramingsize", "memory_address", "ram6addr", "ramingaddr", "gram_size", "gram_scale", "ram_scale", "ram6address", "memory_Size", "memory_addr"], "boot_device": ["bootbookmode", "bootportdevice", "kernel_device", "bootportmemory", "bootportroot", "boot_root", "bootbookdevice", "boot_memory", "kernel_root", "kernel_memory", "kernel_mode", "boot_mode", "bootbookmemory", "bootbookroot", "bootportmode"], "kernel_filename": ["base_platform", "base_url", "base_filename", "kernel_platform", " kernel_file", "kernel_document", "kernel_file", " kernel_username", " kernel_platform", "base_document", "kernel_username", "kernel_url"], "kernel_cmdline": ["kernel_hostline", "kernel_Cmdlined", "kernel_configlin", "kernel_hostlin", "kernel_commandlines", "kernel_configLine", "kernel_cmdlined", "kernel_commandLINE", "kernel_cmdlines", "kernel_hostLine", "kernel_configLINE", "kernel_hostLINE", "kernel_commandlined", "kernel_configline", "kernel_commandlin", "kernel_Cmdline", "kernel_Cmdlines", "kernel_hostlined", "kernel_commandLine", "kernel_hostlines", "kernel_cmdLINE", "kernel_cmdlin", "kernel_cmdLine", "kernel_commandline"], "initrd_filename": ["initrd_url", "initnd_fp", "initrd_Filename", "initrt_mode", "initnd_filename", "initrdOFilename", "initrt_filename", "initrdOfilename", "initrdOmode", "initnd_url", "initrdOfiles", "initrd_file", "initrd_files", "initrt_Filename", "initrd_fp", "initrt_files", "initrd_mode", "initnd_file"], "cpu_model": ["cpu_spec", "pu_spec", "pu_model", "core_models", "core_location", "cpuachandler", "pu_mode", "cpu_mode", "cpuaclocation", "pu_models", "cpuacmodels", "core_model", "cpu_handler", "cpu_models", "core_handler", "cpuacmodel", "cpu_location"], "pci_enabled": ["pci__disabled", "pcc_enable", "pki_interrupted", "pci_disabled", "pci67enable", "pcc67Enabled", "pci67disabled", "pki_loaded", "pcc_enabled", "pci67enabled", "pcc_Enabled", "pci__enabled", "pcc67disabled", "pcc67enable", "pci_loaded", "pci__enable", "pci_Enabled", "pki_enabled", "pci_interrupted", "pki_disabled", "pci67Enabled", "pcc67enabled", "pki_enable", "pcc_disabled", "pci_enable"], "kvmclock_enabled": ["kvmsync_enabled", "kvmlock_provided", "kvmsync_disabled", "kvmclock_Enabled", "kvmsync_Enabled", "kvmclock_disabled", "kvmsync_enable", "kvmlock_disabled", "kvmlock_led", "kvmclock_enable", "kvmclock_led", "kvmlock_enabled", "kvmclock_provided"], "i": ["k", "p", "m", "b", "c", "d", "x", " I", "counter", "type", "io", "id", "proc", "is", "e", "s", "h", "I", "f", "n", "j", "ip", "a", "v", "r", "pi", "l"], "below_4g_mem_size": ["below_4g_memory_capacity", "below_4g_memory_size", "below_4g_memory_address", "below_4g_memory_Size", "below_4g_mem_sum", "below_4g_mem_capacity", "below_4g_mem_Size", "below_4g_memory_sum", "below_4g_mem_address"], "above_4g_mem_size": ["above_4g_mem2size", "above_4g_memory_time", "above_4g_mem_sum", "above_4g_mem2sum", "above_4g_mem64Size", "above_4g_mem64size", "above_4g_mem64time", "above_4g_mem2speed", "above_4g_memory_size", "above_4g_mem_Size", "above_4g_memory_Size", "above_4g_mem_time", "above_4g_mem_speed"], "pci_bus": ["pci_bridge", "pci_device", "pciambus", "pki_bus", "pki_device", "pci__boot", "pci_lib", "pci_boot", "pci__cache", "pki_session", "pcijcache", "pciamlib", "pci__bus", "pci_cache", "pciamboot", "pcijboot", "pci_session", "pcijbus", "pci__bridge", "pki_lib", "pciamsession", "pki_bridge", "pcijbridge", "pki_cache", "pki_boot"], "i440fx_state": ["i440fx_data", "i440fs_states", "i440plex_config", "i440fx_states", "i440fx_work", "i440fx67data", "i440fx_manager", "i440fx_config", "i440plex67manager", "i440plex_manager", "i440fs_work", "i440plex_data", "i440plex_state", "i440fx67config", "i440plex67state", "i440fx67manager", "i440plex67data", "i440fs_config", "i440fx67state", "i440fs_state", "i440plex67config"], "cpu_irq": ["cpu_rinch", "cpu_rinq", "cpu_rfqs", "cpu_IRp", "cpu_pircle", "cpu_iracle", "cpu_IRqa", "cpu_ireQ", "cpu_irch", "cpu_irsq", "cpu_irQ", "cpu_pirqs", "cpu_rinqs", "cpu_pirp", "cpu_irtch", "cpu_irp", "cpu_ireq", "cpu_rinsq", "cpu_pirqa", "cpu_iraq", "cpu_ireqa", "cpu_IRq", "cpu_irtq", "cpu_irep", "cpu_irqa", "cpu_rfsq", "cpu_pirQ", "cpu_pirq", "cpu_ierquest", "cpu_ierq", "cpu_irtsq", "cpu_rfq", "cpu_iercle", "cpu_ircle", "cpu_IRQ", "cpu_pirquest", "cpu_rfch", "cpu_irqs", "cpu_irtqs", "cpu_iraqs", "cpu_iraquest", "cpu_ierqs", "cpu_irquest"], "isa_irq": ["isa__irqs", "isa__irq", "isa_ircle", "isa_Irq", "isa_mirqq", "isa_yrqt", "isa_IrQ", "isa_irtq", "isa_mirq", "isa_irtquest", "isa_irtqa", "isa__irtQ", "isa_Irqa", "isa_ierqs", "isa_irqs", "isa_irquest", "isa_IRQ", "isa_irch", "isa_irtch", "isa_irtqq", "isa_irtqs", "isa_ierqq", "isa_irtqt", "isa_irqt", "isa__irtqa", "isa__irtqs", "isa_mirqs", "isa_yrcle", "isa__irqa", "isa_irQ", "isa_Irqs", "isa_irqq", "isa_irtQ", "isa_yrq", "isa_ierquest", "isa__irtq", "isa_ierq", "isa_irtcle", "isa_ierqt", "isa_IRqa", "isa_IRqs", "isa_iercle", "isa_yrquest", "isa_mirch", "isa_irqa", "isa_IRq", "isa_ierch", "isa__irQ"], "i8259": ["xi6259", "pi8239", "xi8129", "pi4252", "i4239", "si8199", "pi4259", "pi8129", "i7259", "i8139", "i9259", "pi4129", "i15169", "xi8579", "xi8259", "si8139", "i6252", "pi8259", "i7139", "i825", "i059", "i4259", "i6129", "i15259", "i025", "si15199", " i8252", "i9252", "si15259", "i8169", "i0259", "i859", "i864249", "i12259", "i8199", "i8579", "si8259", " i059", "pi8252", "i18129", " i025", "i6259", "i0129", "i18249", "i4129", "i12139", " i825", "i4252", "i8129", " i0259", "i108259", "i7199", "xi6249", "i864129", "i12169", " i859", "si8169", "xi6129", "xi8249", " i0252", "i10825", "i0239", "i12199", "i8252", "i925", "i15199", "i6579", "i0252", "i864579", "i6239", "i108252", "si15169", "i8239", "i18579", "i6249", "i15139", "i864259", "xi6579", "i7169", "pi4239", "si15139", "i10859", "i18259", "i8249", "i959"], "cmos_s3": ["cmos_gics", "cmos_sgd", "cmos_snd", "cmos_g3", "cmos_ps3", "cmos_sics", "cmos_csgd", "cmos_psics", "cmos_cs3", "cmos_psnd", "cmos_csics", "cmos_gnd", "cmos_ggd", "cmos_psgd", "cmos_csnd"], "smi_irq": ["smi_irqs", "smi_irg", "smi_iraq", "smi_iraquest", "smi_iraqs", "smi_pirquest", "smi_errqs", "smi_errquest", "smi_pirq", "smi_pirg", "smi_errq", "smi_irquest", "smi_pirqs", "smi_errg", "smi_irag"], "isa_irq_state": ["isa_irquire_state", "isa_irq_rule", "isa_irq__state", "isa_irp_mode", "isa_irqa_state", "isa_irq_mode", "isa_irq_data", "isa_irQ_states", "isa_irqrstates", "isa_irQ_rule", "isa_irq_states", "isa_irqrstate", "isa_irq_config", "isa_irqrrule", "isa_irq_store", "isa_irquest_store", "isa_irq_back", "isa_irq__data", "isa_irp_state", "isa_irr_state", "isa_irp_rule", "isa_irq_parent", "isa_irquire_states", "isa_irqa_manager", "isa_irr_data", "isa_irq_manager", "isa_irq__states", "isa_irq__config", "isa_irr_config", "isa_irquire_parent", "isa_irquest_state", "isa_irqa_rule", "isa_irQ_back", "isa_irQ_state", "isa_irqrback", "isa_irquest_states", "isa_irr_states"], "hd": ["md", "hm", "ht", "xd", "cd", "dr", "HD", "ld", "dri", "bd", "dd", "udi", "hub", "hid", "hp", "du", "hw", "pd", "rh", "gd", "di", "dt", "wd", "cow", "dist", "vd", "df", "fd"], "MAX_IDE_BUS": ["MAX_IDE_US", "MAX_IDE_LINE", "MAX_IDEAMUS", "MAX_ISE_US", "MAX_IDEAMBUS", "MAX_ISE_DI", "MAX_ISE_LINE", "MAX_ISE_BUS", "MAX_ISE_USE", "MAX_IDEAMDI", "MAX_IDE_DI", "MAX_IDE_USE"], "MAX_IDE_DEVS": ["MAX_IDE_DIVICE", "MAX_IDE_DEVICE", "MAX_IDE_DRV", "MAX_IDE_DIV", "MAX_IDE_DVS", "MAX_IDE_DEFS", "MAX_IDE_DIFS", "MAX_IDE_DFS", "MAX_IDE_DEV", "MAX_IDE_DVICE", "MAX_IDE_DRVS", "MAX_IDE_DRFS", "MAX_IDE_DRVICE", "MAX_IDE_DIVS", "MAX_IDE_DV"], "floppy_controller": ["flp_driver", "flp_design", "floppy2driver", "floppy2controller", "floppy2design", "floppy2control", "flp_controller", "floppy_driver", "floppy_control", "flp_control", "floppy_design"], "idebus": ["IDEbus", "iebus", "ieBUS", "IDEBUS", "inecache", "inebus", "ineBus", "ideBUS", "ieBus", "IDEBus", "IDEcache", "ideBus", "ineBUS", "iecache", "idecache"], "rtc_state": ["rtc_states", "rtc_config", "rtac_config", "rtac_state", "rtac_model", "rtc_model", "rtac_states"]}}
{"project": "FFmpeg", "commit_id": "8be23d424feea50d4ee892cdbdd6abd9a807709f", "target": 0, "func": "static av_cold int roq_decode_init(AVCodecContext *avctx)\n\n{\n\n    RoqContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n\n\n    if (avctx->width % 16 || avctx->height % 16) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Dimensions must be a multiple of 16\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    s->last_frame    = av_frame_alloc();\n\n    s->current_frame = av_frame_alloc();\n\n    if (!s->current_frame || !s->last_frame) {\n\n        av_frame_free(&s->current_frame);\n\n        av_frame_free(&s->last_frame);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n\n\n\n    return 0;\n\n}\n", "idx": 25593, "substitutes": {"avctx": ["varctx", "varcontext", "avalconn", "avcontext", "avesync", "avecup", "ajconn", "afcontext", "avectx", "ajctx", "ajcmp", "abcu", "ajwcs", "akctx", "avecmp", "ajkw", "vertx", "akcontext", " avtx", "AVcontext", "afcca", "avcu", "abtx", "avepkg", "afsync", "varcu", "afcfg", "abcontext", "avcca", "avecmd", "avalcontext", "aftx", " avcmp", "afctx", "avpkg", "avalctx", "abctx", " avcca", "AVctx", "varcup", "avcfg", "verctx", "afwcs", "avcb", "avecb", "avcf", "ajtx", "verwcs", "AVcmp", "akcu", "avecontext", " avcb", "avcmp", "avtx", "avalcb", "avsync", "afcf", "avecu", " avcf", "afcb", "avkw", "avconn", "avcup", "ajpkg", "afconn", "ajcontext", "afcmd", "afpkg", "avecca", "avalcmd", "AVcf", "vercontext", "afcu", " avcu", "akcfg", "avekw", "aveconn", "avalsync", "afcup", " avcontext", "avecfg", "avcmd", "afkw", "avwcs", "afcmp"], "s": ["S", "sc", "ses", "rs", "args", "sys", "sk", "w", "this", "i", "p", "m", "b", "c", "ss", "ns", "d", "ts", "vs", "data", "sq", "ds", "ms", "ans", "us", "ps", "sg", "ins", "ks", "sync", "bs", "u", "is", "e", "es", "gs", "o", "sets", "session", "l", "si", "aws", "os", "ctx", "nas", "sb", "uns", "services", "sec", "sa", "xs", "as", "ls", "f", "fs", "js", "n", "qs", "a", "t", "v", "acs", "sf", "ops", "parts", "ssl", "cs", "its", "g"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602, "substitutes": {"dev": ["ve", "md", "w", "info", "d", "data", "ds", "ad", "conf", "def", "dd", "priv", "ch", "ev", "die", "dom", "proc", "self", "serial", "private", "pad", "dem", "hw", "gd", "di", "device", "mod", "pro", "dm", "conn", "plug", "Dev", "rad", "od", "de", "sd", "an", "g", "v", "cam", "sh"], "p": ["exec", "pp", "pa", "ep", "np", "k", "er", "param", "i", "m", "b", "c", "pg", "parse", "parser", "d", "data", "api", "P", "py", "jp", "pe", "up", "ps", "dp", "ch", "bp", "op", "port", "proc", "press", "u", "mp", "e", "sp", "patch", "o", "pd", "pb", "process", "per", "cp", "pm", "gp", "cache", "ar", "current", "wp", "h", "part", "lp", "f", "po", "n", "tp", "ip", "t", "fp", "j", "php", "a", "v", "r", "pi", "vp", "pre", "l", "post", "pc", "ap", "g"], "s": ["sys", "w", "sr", "ns", "ts", "sq", "ps", "sync", "sis", "self", "u", "private", "es", "gs", "http", "sym", "sa", "xs", "f", "service", "fs", "n", "js", "tests", "qs", "t", "sd", "r", "ops", "native", "S", "m", "b", "c", "x", "ds", "us", "ins", "su", "is", "css", "sp", "ions", "spec", "aws", "services", "sl", "its", "g", "sh", "rs", "ses", "args", "ss", "d", "ms", "sg", "e", "has", "session", "less", "sb", "php", "full", "sf", "ssl", "cs", "sv", "i", "sw", "plugins", "o", "si", "os", "uns", "sup", "as", "ls", "y", "v", "l"]}}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 25619, "substitutes": {"cpu": ["CPU", "processor", "clock", "gnu", "prof", "loader", "port", "proc", "linux", "gpu", "boot", "mem", "GPU", "fps", "apache", "nic", "process", "pool", "cp", "gp", "cache", "vm", " CPU", "proxy", "conn", "pu", "pc", "pid"], "spapr": ["spapers", "scappr", "spampm", "spappm", "SpapeR", "Spaper", "scaprs", "spapeR", "Spapr", "scapar", "scappm", "scapm", "scapr", "spAPr", "spAPrs", "Spaprs", "spamprs", "scappar", "spAPm", "Spapers", "spAPR", "spapprs", "spampar", "spaper", "SpapR", "spapR", "spapar", "spampr", "spapm", "spAPar", "spaprs", "scapprs", "spappr", "spappar"], "token": ["seq", "secret", "call", "socket", "nat", "function", "callback", "config", "util", "stats", "protected", "session", "slot", "target", "reply", "response", "win", "timeout", "bits", "prot", "resp", "match", "reset", "random", "oken", "native", "ok"], "nargs": ["snflags", "numargs", "numrows", "sparams", "cparams", "numarg", "bparams", " narg", "sargs", " nparams", "carg", "nparams", " nrows", "snparams", "numparams", "narg", "bargs", "barg", "snargs", "sflags", "sarg", "cflags", "cargs", "snarg", "nflags", "brows", "nrows"], "args": ["rs", "call", "argument", "res", "features", "parse", "frame", "ns", "flags", "msg", "enc", "data", "config", "var", "py", "cb", "states", "is", "all", "vals", "boot", "gs", "stats", "arr", "options", "cmd", "fields", "Args", "lines", "loc", "os", "ras", "size", "reply", "sec", "cache", "addr", "arg", "active", "serv", "bytes", "bits", "alls", "conn", "func", "init", "parts", "cs", "len", "params"], "nret": ["nopt", "lRET", "nreply", "creturn", "lret", "snalt", " ndef", " nRET", "copt", "Nreply", " narg", "Ndef", "nealt", " nreturn", "snret", "cret", "nRET", "ddef", "neret", "dreply", " nmatch", "nalt", "snRET", "NRET", "Nreturn", " nopt", "lreturn", "Nmatch", "npart", "dret", "neRET", "narg", "Narg", "snpart", "lopt", "ndef", " nreply", "nmatch", "Nret", "nreturn", "Nargs", "cRET", "Nalt", "nepart", "dargs", "lmatch", "Npart", "larg"], "rets": ["seq", "secret", "rs", "nets", "dies", "expected", "errors", "res", "features", "bis", "flags", "ts", "uts", "ils", "ips", "ds", "opens", "verts", "types", "def", "outs", "vers", "rows", "urs", "states", "nuts", "proc", "vals", " secrets", "aux", "mem", "ls", "fields", "runs", "strings", "fts", "ries", "RET", "nt", "als", "nas", "uds", "utils", "reply", "sec", "stores", "qs", "grades", "groups", "its", "Ret", "ails", "bytes", "bits", "details", "des", "tests", "alt", "reg", "fs", "checks", "results", "jas", "values", "fits", "ints"], "sphb": ["sPhpart", "sphpabe", "fphf", "scpB", "sphlb", "psphr", "nsphb", "sphpart", "fmphab", "saphr", "smphf", "sPHb", "shtabe", "saphb", "sphpr", "smphB", "ssaphr", "sPhl", "saphl", "sPhlb", "saphlb", "sPhr", "sPha", "sphppart", "sphf", "nsPHb", "saphp", "sphbb", "psphB", "fmphf", "scpbb", "psmphb", "saphbase", "sephbase", "nsphlb", "ssaphb", "sphB", "smphbase", "sphl", "sPhabe", "nsPHl", " sPhabe", "psmphp", "fphb", "scpr", "saphB", "psphp", "sPhb", "ssphb", "sphabe", "psphb", "sPHl", " sphr", "sphbase", " sphpart", "smphr", "smphab", "sPHa", "fphab", "saphab", "ssaphbb", "sephf", "ssphr", "nsPHa", "nsPHlb", "shtr", "ssphB", "saphbb", "nspha", "sapha", "fphbase", "smphb", "fmphb", "nsphl", "scpb", "sPHlb", " sPhpart", " sphabe", "sphp", "sephab", "sphr", "sphab", "sphpb", "psmphr", " sPhr", "ssaphB", "fmphbase", "shtpart", "shtb", " sPhb", "spha", "psmphB", "sephb", "ssphbb", "saphf", "smphp"], "spc": ["ppac", "prd", "app", "SPc", "Spcs", " spp", "ppf", " spd", "prc", " spf", "SPcs", "ppcs", "Spac", "prp", "prf", "Splc", "spci", "SPC", "spC", "Spf", "apf", "SPlc", "spf", " splc", "SPci", "SPf", "Spc", "apc", "Spci", "SpC", " spci", " spac", "ppc", " spC", "spac", "spp", "splc", "spcs", " spcs", "spd", "apd"], "buid": ["luID", "buids", " buip", "Buid", "basip", " buId", " buID", "buip", "basids", "basid", "auids", "buID", "buId", "luid", "basId", "Buids", " buis", " buin", "buis", "BuID", "basin", "auin", "bufid", "basID", "auid", "buin", "Buis", " buids", "luids", "bufID", "bufids", "bufId", "luis", "auip"], "state": ["rest", "code", "secret", "name", "test", "back", "State", "config", "style", "address", "type", "error", "version", "states", "port", "id", "store", "private", "key", "al", "resource", "err", "str", "start", "session", "loc", "art", "nt", "grade", "STATE", "stat", "size", "addr", "ry", "arg", "part", "f", "rule", "reset", "value", "status", "alt", "conn", "out", "reg", "ace", "result", "len", "val", "tag"], "ret": ["ref", "rest", "secret", "obj", "trial", "res", "cat", "flag", "job", "back", "data", "success", "att", "rep", "id", "store", "ne", "pret", "al", "mem", "str", "mt", "lit", "RET", "fire", "re", "art", "nt", "fi", "reply", "feat", "pet", "ry", "arg", "Ret", "rt", "ext", "part", "status", "value", "alt", "reg", "resp", "match", "result", "len", "val", "fun"]}}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n", "idx": 25636, "substitutes": {"value": ["server", "name", "image", "function", "data", "buffer", "media", "feature", "type", "property", "reference", "Value", "end", "flow", "id", "num", "key", "unit", "message", "min", "valid", "max", "start", "fee", "one", "grade", "size", "VALUE", "scale", "number", "rate", "now", "length", "current", "timeout", "count", "total", "index", "volume", "v", "expression", "memory", "values", "age", "range", "large", "val", "format"], "errp": ["erP", "armP", "rrP", "irp", "ircp", "rrp", "erop", "errcp", "armc", "errop", "rrlp", " errop", "ercp", " errP", "errlp", "irop", "armlp", "irP", "rrc", "erp", " errcp", "errP", " errc", "errc", " errlp", "armp"], "s": ["S", "rs", "ses", "sys", "args", "ss", "p", "m", "b", "c", "ns", "ts", "ds", "ps", "states", "sync", "is", "u", "e", "es", "cs", "gs", "si", "sym", "os", "sb", "services", "sa", "ls", "f", "service", "status", "n", "fs", "sl", "sf", "settings", "ssl", "sv"]}}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n", "idx": 25669, "substitutes": {"path": ["temp", "code", "package", "np", "w", "page", "anc", "transform", "name", "c", "template", "x", "enc", "data", "api", "text", "config", "pointer", "next", "prop", "prefix", "type", "sync", "method", "e", "point", "sp", "python", "patch", "str", "s", "relative", "pattern", "ath", "parent", "cp", "pat", "length", "current", "PATH", "h", "part", "f", "po", "value", "n", "pr", "php", "pair", "root", "route", "Path", "l", "ph"], "p": ["pp", "pa", "ep", "np", "w", "page", "i", "b", "m", "c", "x", "data", "api", "P", "pointer", "jp", "pe", "ps", "it", "bp", "op", "u", "e", "point", "sp", "pard", "patch", "o", "pb", "s", "cp", "pat", "h", "part", "lp", "f", "po", "y", "pr", "n", "tp", "j", "t", "fp", "a", "v", "r", "pi", "pos", "pre", "Path", "l", "vp", "pc", "ap", "g"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n", "idx": 25670, "substitutes": {"ov": ["ow", "ull", "oc", "akov", "oy", "oo", "ovan", "cv", "ob", "vs", "orb", "oper", "vr", "om", "ant", "opp", "kov", "ovo", "opt", "av", "vers", "ev", "oid", "op", "oven", "ocr", "tv", "oe", "ott", "ood", "raft", "o", "obb", "oyer", "ol", "ove", "ou", "rov", "nov", "ova", "ork", "OV", "iv", "oa", "ever", "off", "oker", "uv", "lov", "vo", "v", "od", "ver", "sv", "voc", "oh"], "iter": ["chain", "exec", "ite", "Iter", "gen", "er", "oc", "keep", " inter", "or", "oper", "ise", "it", "tr", "store", "ee", "el", " ir", "str", "ul", "ator", "loc", "tri", "inner", "enter", " iterator", "order", "gener", "inc", "iv", "scan", "il", "design", "ir", "loop", "walker", "f", "ip", "coll", "inter", "init", "v", "itter", "iterator", "l", "former"], "any": ["chain", "sc", "iq", "call", "can", "args", "whatever", "none", "each", "empty", "ay", "single", "x", "qa", "other", "or", "ise", "anything", "optional", "global", "ast", "sync", "ask", "all", "allow", "arr", "ANY", "some", "common", "one", "worker", "parent", "cc", "inc", "co", "ar", "which", "array", "ack", "coll", "q", "g", "either", "unknown", "query", "ait", "ac", "pc", "Any"], "depth": ["Depth", "cost", "dim", "name", "data", "weight", "delay", "debug", "version", "push", "deep", "id", "seed", "reverse", "input", "path", "parent", "order", "rank", "cache", "level", "round", "dep", "index", "stack", "root", "query", "priority", "layer"], "first": ["use", "head", "sc", "primary", "th", "none", "p", "c", "empty", "name", "must", "only", "other", "next", "error", "instance", "latest", "fr", "catch", "all", "second", "then", "First", "initial", "valid", "start", "prev", "st", "one", "last", "parent", "cc", "missing", "current", "f", "null", "func", "header", "root", "r", "alpha", "pc"]}}
{"project": "FFmpeg", "commit_id": "204cb29b3c84a74cbcd059d353c70c8bdc567d98", "target": 1, "func": "static av_cold int shorten_decode_close(AVCodecContext *avctx)\n\n{\n\n    ShortenContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < s->channels; i++) {\n\n        s->decoded[i] -= s->nwrap;\n\n        av_freep(&s->decoded[i]);\n\n        av_freep(&s->offset[i]);\n\n    }\n\n    av_freep(&s->bitstream);\n\n    av_freep(&s->coeffs);\n\n\n\n    return 0;\n\n}\n", "idx": 25672, "substitutes": {"avctx": ["AVcmp", " avcas", "AVconn", "avcit", "avcmp", "afcmp", "avcontext", "afcit", "afcontext", "afctx", "Avcas", "ajctx", "ajcmp", "Avcontext", " avconn", "ajcit", "AVcas", "AVctx", "Avconn", "avconn", "AVcit", " avcontext", "avcas", "ajcontext", "AVcontext", "Avctx"], "s": ["S", "sc", "ses", "rs", "args", "comm", "sys", "p", "b", "ss", "c", "ns", "d", "ts", "vs", "data", "sq", "ds", "ms", "ans", "conf", "ps", "sg", "ks", "sync", "bs", "self", "u", "is", "e", "cs", "gs", "es", "o", "session", "spec", "l", "ads", "si", "sym", "aws", "os", "ctx", "als", "sb", "services", "sec", "sa", "xs", "as", "ls", "f", "fs", "js", "qs", "a", "an", "t", "v", "sf", "ops", "parts", "ssl", "sv", "g"], "i": ["k", "z", "p", "m", "b", "c", "info", "d", "ix", "x", "ti", "mi", "phi", "qi", "io", "u", "e", "li", "gi", "ji", "o", "zi", "multi", "xi", "uri", "start", "ii", "bi", "si", "ai", "di", "ini", "ni", "ci", "fi", "eni", "I", "f", "y", "oi", "n", "j", "ip", "index", "t", "a", "q", "v", "iu", "mu", "pi", "ui", "l", "hi"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,\n\n                                         src - (stride * 2),\n\n                                         stride, dst, stride);\n\n}\n", "idx": 25693, "substitutes": {"dst": ["sdrc", " drc", "Dsrc", "sdsrc", "Drc", "ldsrc", "dsrc", "ldsc", "ldst", "sdsc", "sdst", "ldrc", " dsc", "drc", "dsc", "Dsc", " dsrc", "Dst"], "src": ["sc", "slice", "sr", "rib", "b", "c", "dr", "img", "rb", "config", "cur", "gb", "sq", "gz", "cb", "inst", "sync", "supp", "url", "cmp", "rob", "sur", "grad", "sub", "lib", "st", "sel", "sb", "sec", "rc", "ctr", "iv", "sup", "dist", "source", "bg", "dest", "sl", "attr"], "stride": [" strided", "arrie", "Strider", "brine", "collider", "etrip", "arrine", " strade", "colliden", "stided", "divide", "strie", " strode", "etride", "drided", "stider", " strie", "strode", "collided", "etrider", "Strine", "divided", "vertider", "Strided", "trider", "collide", "vertade", "stide", "brided", "arrided", "Strip", "divine", "strip", "brie", "vertode", " strine", "dride", "etrided", "strider", "strade", " strip", "Stride", "vertide", "driden", "trade", "tride", "drider", "strided", "arride", "striden", "stiden", "divade", "Strade", " strider", "bride", "trode", "strine"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    uint32_t val;\n\n    int index;\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return 0;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    index = (addr >> 4) & 0xff;\n\n    switch(index) {\n\n    case 0x02: /* id */\n\n        val = s->id << 24;\n\n        break;\n\n    case 0x03: /* version */\n\n        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */\n\n        break;\n\n    case 0x08:\n\n        apic_sync_vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n", "idx": 25704, "substitutes": {"opaque": ["OPque", "opac", "oaque", "OPac", "ocode", "opque", "oac", "OPcode", "obac", "obque", "obcode", "opcode", "oque", "OPaque", "obaque"], "addr": ["ref", "node", "seq", "sid", "byte", "dc", "Address", "arm", "ix", "asm", "x", "data", "config", "ad", "pointer", "add", "address", "dd", "mac", "id", "alias", "pad", "point", "amp", "arr", "adr", "ord", "offset", "slot", "ptr", "amd", "part", "ip", "src", "conn", "host", "route", "ace", "pos"], "d": ["md", "Ds", "dc", "z", "cd", "p", "m", "rd", "c", "dy", "b", "ded", "i", "dr", "ld", "ds", "ad", "bd", "dd", "state", "dict", "id", "dom", "u", "db", "e", "o", "did", "dos", "dh", "dat", "pd", "dx", "dl", "di", "does", "dt", "D", "f", "n", "t", "dm", "sd", "l", "fd", "dB", "dn", "g"], "s": ["comments", "sys", "w", "server", "ns", "ts", "sq", "request", "ps", "secondary", "states", "sync", "self", "es", "gs", "south", "stats", "sie", "sym", "xs", "serv", "f", "service", "js", "n", "fs", "tests", "t", "sd", "r", "ops", "native", "S", "slice", "p", "m", "b", "c", "se", "storage", "sum", "ds", "us", "state", "ins", "su", "is", "sets", "spec", "services", "sl", "settings", "its", "g", "ses", "args", "scope", "ss", "bis", "sg", "ks", "the", "e", "session", "sts", "hs", "stat", "sb", "sec", "your", "sf", "ssl", "sv", "cs", "hm", "i", "site", "o", "si", "os", "as", "ls", "y", "a", "an", "v", "parts", "l"], "val": ["exec", "ref", "call", "pt", "pol", "VAL", "msg", "doc", "eval", "data", "base", "rol", "sum", "var", "col", "fail", "bl", "def", "bc", "util", "split", "num", "all", "vals", "aval", "al", "db", "ee", "unit", "mean", "el", "rel", "grad", "valid", "err", "ol", "rl", "lit", "loc", "pl", "ann", "fl", "slot", "cal", "sel", "stat", "ret", "cond", "arg", "serv", "Val", "part", "ail", "value", "alt", "reg", "crit", "v", "sl", "mit", "ind", "pre", "attr", "pos", "len", "vol", "pid"], "index": ["element", "date", "name", "module", "label", "column", "num", "input", "valid", "object", "number", "level", "f", "mix", "de", "match", "slice", "option", "x", "diff", "address", "key", "point", "path", "bit", "group", "shape", "xxx", "xxxx", "update", "value", "block", "len", "node", "found", "fff", "success", "pointer", "error", "open", "search", "offset", "mode", "connect", "size", "length", "lead", "alpha", "pos", "connection", "he", "page", "i", "dim", "position", "image", "weight", "style", "config", "type", "ticket", "end", "id", "site", "loc", "Index", "inc", "active", "find", "loop", "comment", "route", "ind"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 25711, "substitutes": {"host_port": ["hostblockserver", " host_host", "hostblocktype", "address_server", "hostblockaddress", "address_port", " host_address", "address_address", "host_host", "host_address", "host_type", "host_server", "address_type", "hostblockport"], "errp": ["eep", "erip", "erP", "rorpp", "errpe", "eefp", "erpe", "rorpe", "rorp", "eelp", " errpp", "eepp", "rorip", "errpp", "rorlp", " errP", " errpe", "errlp", " errfp", "rorP", "errip", "erp", " errip", "errP", "errfp", "rorfp", " errlp"], "iaddr": ["sAddress", "sioder", "riext", "iass", "iext", " iaddress", "iiaddress", "xiplayer", "sext", " iAddress", "Iass", "xiaddr", "iptr", "sptr", "soder", "Iinfo", "riaddr", "rioder", "siaddress", "sass", "saddress", "xiaddress", "soffset", "splayer", "siaddr", "ioffset", "iiptr", "siext", "iinfo", "ioder", " iplayer", "Iaddr", "iAddress", "xiAddress", " iinfo", "iioffset", " iass", "iiaddr", "sioffset", "siptr", "iplayer", "riaddress", "sinfo", "Iaddress", "iaddress"], "saddr": ["sadd", "fadd", " sdd", "seaddr", "idd", "sinadd", "tsnode", "uaddress", "ssladdr", " sbuilder", " sptr", "unode", "sinaddr", " sadd", "salign", "Sfd", "inode", "lsmd", "lsad", "lsptr", "ualign", "Sptr", "sindd", "snode", "faddr", "sbuilder", "tsaddr", "saddress", "iaddress", "iadd", "lsaddr", "sslfd", "smd", "sdd", "sfd", "faddress", "ford", "iord", " sad", " smd", "sdr", "Sdr", "sead", "sslptr", "Saddr", "septr", "ialign", "sinbuilder", "sord", "tsaddress", " saddress", "uaddr", "ssldr", " sord", "semd", "tsalign", "ibuilder", "sad", "sptr"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n", "idx": 25729, "substitutes": {"x0": ["ex1", "xx", " x12", "ya0", " x2", "ya2", "y86", "y00", "ex0", "x8", "X1", "p1", "ex00", "X2", "y8", "x86", "x12", "yx", "x00", "ya1", "X86", " xx", "ya86", "p8", "y2", "X12", "Xx", "ex8", "X0", "p0", "p00", "x2", "y12"], "y0": ["ey0", "xx", "Y2", "y3", "dy1", "Y1", "x8", "x6", "Y0", "dyee", "y90", "y6", "y8", "dy0", " y6", "ry1", "yx", "xee", " y3", "Y90", " yx", "y2", " y2", "x90", "ry90", "ey3", "dy6", "eyee", "yee", " y8", "ey1", "x3", "ry0", "Yx", "x2", "ey6", "Y8"], "x1": [" x2", "X1", "ix01", "xOne", "X2", "x01", "yOne", "ixOne", "y01", "xn", "y2", " x01", "X0", "ix1", " xn", " xOne", "yn", "x2", "ix0", "Xn"], "y1": ["ey2", "zone", "ey0", "Y2", "Y1", " yone", "Y0", "xOne", "z0", " yOne", "z1", "zOne", "yOne", "xone", "yone", "y2", "ey1", "x2"], "buf": ["seq", "uf", "bag", "uc", "b", "context", "cv", "Buff", "fam", "data", "queue", "buffer", "vec", "text", "rb", "br", "ab", "img", "config", "cur", "cb", "bc", "port", "cube", "db", "fab", "feed", "aux", "cmd", "cap", "box", "output", "pool", "ctx", "fb", "fi", "cf", "Buffer", "alloc", "ptr", "conv", "cas", "cache", "feat", "buff", "src", "runner", "fd"], "x": ["code", "xx", "w", "z", "i", "b", "p", "dy", "ww", "c", "d", "ix", "px", "xc", "base", "tx", "ax", "X", "e", "ady", "xy", "xi", "dx", "yx", "Y", "ctx", "xs", "xxx", "ry", "h", "f", "y", "xp", "n", "rx", "index", "v", "ex", "l", "ya"]}}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734, "substitutes": {"qiv": ["sqoc", "waiva", "qenc", "phpiv", " qih", "quou", "qirc", " qirc", "qiver", "waiver", " qoc", "erhr", "qhr", " qiva", "dqiv", " qou", "qerv", "qou", "phpexp", "quIV", "waivist", " qroc", "phpIV", "qqenc", "sqiv", "questev", "quhr", "Qoy", "qroc", " qov", "qoc", "quenc", "sqroc", "quivo", "qqoc", "phpou", "quiver", "quivist", "quroc", " qoy", "sqivo", "dqoc", "qsiva", "eriva", "questiv", "erirc", "quih", "qov", "dqivo", "quiv", "sqivist", "qivist", "qsivist", " qIV", "sqirc", "questoc", "qsiv", "querv", "qqev", "questenc", "sqih", "questov", "quiva", "quev", "quirc", "qqiv", "qtirc", "Qenc", "eriv", "qterv", "qoy", "qtiv", " qexp", "qev", " qenc", "waiv", "qtiva", "qIV", "qih", "sqiva", " qhr", "qsiver", "qiva", "qexp", "questoy", "quexp", "sqerv", "qivo", "Qiv", "Qov", "quoc", "dqivist"], "name": ["space", "code", "class", "none", "time", "x", "data", "base", "label", "no", "style", "type", "prefix", "ame", "id", "alias", "self", "Name", "key", "resource", "path", "search", "common", "object", "parent", "word", "new", "size", "part", "comment", "NAME", "named", "value", "n", "entry", "names", "null", "core", "nam", "known"], "qobj": ["kaj", "capi", "qtmp", "qlib", "questcdn", "eqopt", "sqbj", "dqobject", "kobi", "Qorb", "qcdn", "qbh", "qapi", "qopt", "sqopt", "sqobb", "questlib", "kapi", "qqobb", " qtmp", "quobject", "questaj", "questobi", "playocl", "kcdn", "Qobj", "klib", "questobj", "dqobj", "playobject", "wob", "qobi", "sqlib", "cbh", "dqorb", "cocl", "worb", "eqobj", "quobj", "qbj", "eqobb", "kobject", "eqlib", "sqaj", "qqopt", "Qob", "qualobject", "kbj", "qutmp", "qqobj", "questobject", "wobj", "qualob", "sqobi", "qqlib", "sqobject", "qualobj", "eqbh", "Qobject", "wobject", "kobj", "qobb", "eqobject", "qorb", "qaj", "cobj", "cobject", "eqcdn", "qob", " qorb", "quorb", "sqobj", "playbh", "eqocl", "cbj", "dqtmp", "qualorb", "qocl", "playobj", " qobject", "sqapi", "qobject"]}}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static BufferPoolEntry *get_pool(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *cur = NULL, *last = NULL;\n\n\n\n    do {\n\n        FFSWAP(BufferPoolEntry*, cur, last);\n\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n\n        if (!cur)\n\n            return NULL;\n\n    } while (cur != last);\n\n\n\n    return cur;\n\n}\n", "idx": 25737, "substitutes": {"pool": ["ref", "pa", "call", "thread", "wrapper", "p", "batch", "server", "pg", "image", "buffer", "queue", "pointer", "col", "ping", "capacity", "bc", "type", "flow", "port", "hole", "allow", "buf", "Pool", "con", "work", "cl", "slot", "parent", "board", "client", "hop", "cache", "alloc", "current", "loop", "ca", "comment", "pair", "host", "coll", "row", "null", "full", "memory", "container", "poll", "guard", "block", "wa", "connection", "ac", "pc", "lock"], "cur": ["build", "rest", "dc", "uc", "oc", "keep", "c", "cat", "dr", "or", "var", "cr", "next", "ct", "pub", "always", "ch", "ah", "car", "cont", "tr", "sth", "iter", "sur", "feed", "ul", "per", "loc", "prev", "aur", "unc", "cer", "ser", "sel", "client", "cf", "ctr", "rc", "ur", " Cur", "first", "ar", "ptr", "length", "current", "lc", "cache", "Cur", "cor", "focus", " result", "pr", " prev", "pull", "src", "coll", "sl", "r", "try", "result", "ce", "ok"], "last": ["build", "code", "sc", "th", "p", "c", "empty", "cat", "se", "or", "base", "worst", "next", "cle", "col", "always", "cycle", "end", "sync", "id", "tr", "self", "fr", "old", "max", "cl", "nd", "ul", "prev", "st", "parent", "est", "first", "current", "lc", "cor", "slave", "child", "later", " Last", "row", "Last", "full", "l", "latest", "final"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n\n                          int *end_pos2)\n\n{\n\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n\n        s->gb           = s->in_gb;\n\n        s->in_gb.buffer = NULL;\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        skip_bits_long(&s->gb, *pos - *end_pos);\n\n        *end_pos2 =\n\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n\n        *pos      = get_bits_count(&s->gb);\n\n    }\n\n}\n", "idx": 25738, "substitutes": {"s": ["S", "side", "rs", "ses", "sys", "w", "ss", "p", "i", "c", "b", "ns", "se", "ts", "ms", "ds", "sq", "conf", "us", "ps", "sg", "ins", "ks", "sync", "self", "css", "is", "su", "e", "es", "gs", "sets", "strings", "session", "lines", "si", "hs", "aws", "os", "uns", "sb", "services", "xs", "as", "h", "ls", "f", "fs", "qs", "js", "service", "n", "t", "a", "sf", "settings", "ops", "cs", "g"], "pos": ["ref", "seq", "body", "neg", "gen", "slice", "none", "p", "pt", "ass", "nos", "ss", "position", "x", "doc", "no", "prop", "pointer", "en", "diff", "type", "ps", "def", "pass", "push", "pc", "port", "all", "POS", "sp", "unit", "trans", "min", "start", "lines", "loc", "Pos", "offset", "os", "size", "cond", "cache", "comp", "pro", "count", "po", "des", "n", "index", "pres", "pre", "block", "post", "len", "val", "pose", "pid"], "end_pos": ["END_Pos", "end__Pos", "start_loc", "end_pose", "end_part", "end_position", "start_len", "end2loc", "end_line", "edge00line", "edge00pos", "start_pos", "end__os", "edge00part", "END__Pos", "edge_line", "end__len", "end_Pos", "END_os", "end__loc", "end2pos", "END_pose", "end00line", "edge_pos", "end_loc", "end__pos", "end_os", "end00pos", "end2position", "end_len", "END__os", "END__pose", "start_position", "END__pos", "END_pos", "end00part", "end__pose", "end2len", "edge_part", "end__position"], "end_pos2": ["end_position1", "end_loc2", "end_len4", "end_len1", "end_pos4", "end__position2", "end_position2", "end_po2", "end__pos4", "end_po4", "end_len2", "end_pose4", "end_pose2", "end_pos1", "end__position4", "end_position4", "end_loc4", "end_po1", "end__pos2"]}}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25741, "substitutes": {"bs": ["abi", "ses", "iss", "ss", "b", "bas", "bis", "lbs", "ns", "lb", "bb", "las", "vs", "blocks", "base", "rb", "ds", "ubis", "bh", "gb", "ab", "cb", "bos", "bc", "BS", "bl", "ins", "ks", "outs", "sync", "us", "css", "gs", "stats", "ubs", "pb", "http", "bi", "aws", "os", "ros", "bes", "sb", "fb", "obs", "sa", "bid", "ls", "fs", "qs", "js", "bits", "bytes", "bing", "bps", "org", "cs", "banks"], "sector_num": [" sector_id", "section_off", "sector_gen", "sector_header", " sector_header", "sector_no", "sectorIdnr", "sector_n", "sector_nam", "sector_nom", "section_name", "sector_number", " sector_gen", "section_nr", "section_sum", "section_num", "sector_nr", " sector_no", "sector_sum", "sector_um", "sectoridheader", "sectorIdnum", "sectorIdnumber", " sector_nam", " sector_n", " sector_number", "sectoridnum", "sectoridnumber", "sectorIdsum", "sectoridno", " sector_um", " sector_nom", "section_number", "sector_id", " sector_name", "sector_name", "sector_off"], "buf": ["seq", "uf", "bag", "uc", "b", "batch", "wb", "lb", "msg", "data", "vec", "buffer", "queue", "rb", "ab", "gb", "bd", "cb", "bc", "port", "num", "raw", "aux", "home", "mem", "ff", "cmd", "pb", "path", "pool", "board", "ctx", "fb", "fi", "cf", "rc", "alloc", "Buffer", "len", "feat", "cas", "off", "buff", "array", "src", "fp", "func", "block", "fd"], "nb_sectors": ["nb_pseapters", "nb_sgments", "nb_serctions", "nb_sleces", "nb_pevers", "nb_seces", "nb_seapters", "nb_gections", "nb_pections", "nb_pegments", "nb_sctors", "nb_psectors", "nb_slegments", "nb_teors", "nb_serics", "nb_gevers", "nb_desctions", "nb_sctions", "nb_SEctors", "nb_serctors", "nb_vecs", "nb_svers", "nb_secctors", "nb_sector", "nb_sercs", "nb_desivers", "nb_SEapters", "nb_sleivers", "nb_secctions", "nb_gectors", "nb_secs", "nb_perics", "nb_psector", "nb_seccs", "nb_tevers", "nb_veces", "nb_serors", "nb_gegments", "nb_vevers", "nb_verics", "nb_pector", "nb_SEctor", "nb_veivers", "nb_desces", "nb_desgments", "nb_tegments", "nb_secgments", "nb_slectors", "nb_severs", "nb_servers", "nb_psections", "nb_vectors", "nb_vections", "nb_SEctions", "nb_sections", "nb_seors", "nb_desrics", "nb_sergments", "nb_veors", "nb_tectors", "nb_desctors", "nb_pectors", "nb_peapters", "nb_segments", "nb_vegments", "nb_seivers"], "s": ["S", "space", "ses", "sys", "i", "p", "b", "ss", "c", "bis", "ns", "ts", "storage", "sq", "ds", "ps", "state", "sync", "is", "e", "stats", "gs", "o", "http", "session", "spec", "si", "sym", "os", "sb", "services", "sa", "ls", "f", "service", "qs", "n", "t", "a", "v", "sl", "r", "sf", "ssl", "cs", "g"], "offset": ["location", "seq", "offer", "skip", "adjust", "af", "i", "shift", "option", "position", "image", "api", "base", "align", "pointer", "disabled", "address", "type", "prefix", "Offset", "error", "end", "num", "url", "alias", "line", "office", "o", "padding", "esi", "set", "nb", "start", "loc", "fee", "partial", "afi", "slot", "bound", "rot", "art", "order", "size", "online", "number", "alloc", "ptr", "off", "length", "addr", "origin", "timeout", "not", "reset", "part", "slave", "stop", "limit", "index", "operation", "fp", "activation", "route", "alpha", "block", "pos", "et", "len", "area", "layer"], "sectors": ["insellers", "spellers", "sergments", "selements", "psegments", "spesections", "secrets", "vegments", "gelements", "gellers", " selements", "alrets", "sexgments", "vellers", "insections", "insegments", "spections", "suctions", "spectors", "spevers", " sections", "surets", "vectors", "vesections", "secvers", "sexefficients", "insectors", "serctions", "secefficients", "gegments", "kections", "SEctors", "alctions", "gections", "sesections", "gectors", "veefficients", "serctors", "segments", "secllers", "secctions", "apegments", " segments", "psections", " seivers", "verets", "sections", "serets", "psellers", "secsections", "sellers", "sexctors", "severs", "sexctions", "serlements", "apectors", "spegments", "secgments", "veivers", "psectors", "suctors", "sperets", "kectors", "gevers", "apeivers", "kellers", "suvers", "seefficients", "vections", "SEctions", "SEvers", "alllers", "secctors", "apections", "kegments", "seivers", "SEllers", "alctors", "pserets"], "sectors_per_block": ["sectors_per_line", "sectors_Per_Block", "sectors_for_blocks", "sectors_per32lock", "sectors_Per_line", "sectors_per32block", "sectors_per32length", "sectors_by_block", "sectors_per_length", "sectors_per_blocks", "sectors_for_block", "sectors_per_lock", "sectors_for_byte", "sectors_Per_block", "sectors_per_unit", "sectors_for_lock", "sectors_per_byte", "sectors_by_length", "sectors_per_Block", "sectors_by_lock"], "ret": ["ref", "seq", "secret", "expected", "res", " RET", "flag", "data", "read", "en", "success", "att", "opt", "error", " Ret", "def", "id", "rets", "iter", "sur", "str", "bit", "det", "rev", "lit", "RET", "rot", "re", "nt", "sel", "reply", "rc", "sec", "arg", "Ret", "rt", "count", "total", "part", "ext", "conn", "alt", "resp", "reg", "match", "result", "et", "len", "val", "fun"], "footer": ["schener", "footing", "ownizer", "Footner", "sawner", "footers", "Footier", "Footker", "owning", "Footers", "Footer", " footizer", "footier", "footker", "scheier", "scheker", "sawier", "scheer", "owner", "footizer", "sawer", "Footizer", "sawker", " footers", "Footing", "footner", "owners", " footing"]}}
{"project": "FFmpeg", "commit_id": "4ffe5e2aa5241f8da9afd2c8fbc854dcc916c5f9", "target": 1, "func": "static int read_old_huffman_tables(HYuvContext *s){\n\n#if 1\n\n    GetBitContext gb;\n\n    int i;\n\n\n\n    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);\n\n    if(read_len_table(s->len[0], &gb)<0)\n\n        return -1;\n\n    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);\n\n    if(read_len_table(s->len[1], &gb)<0)\n\n        return -1;\n\n\n\n    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n\n    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n\n\n\n    if(s->bitstream_bpp >= 24){\n\n        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n\n        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n\n    }\n\n    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n\n    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));\n\n\n\n    for(i=0; i<3; i++){\n\n        ff_free_vlc(&s->vlc[i]);\n\n        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);\n\n    }\n\n\n\n    generate_joint_tables(s);\n\n\n\n    return 0;\n\n#else\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"v1 huffyuv is not supported \\n\");\n\n    return -1;\n\n#endif\n\n}\n", "idx": 25748, "substitutes": {"s": ["sys", "server", "ns", "ts", "sites", "sq", "request", "ps", "states", "sync", "self", "u", "es", "gs", "stats", "south", "http", "lines", "sym", "xs", "f", "service", "qs", "js", "fs", "n", "tests", "t", "r", "ops", "S", "p", "b", "m", "c", "ds", "us", "ins", "is", "sets", "ions", "spec", "new", "services", "settings", "in", "its", "g", "rs", "ses", "ss", "d", "data", "ms", "conf", "sg", "ks", "e", "session", "sf", "ssl", "cs", "sc", "site", "o", "os", "uns", "ls", "y", "a", "parts", "l"], "gb": ["gu", "cm", "b", "Gb", " rg", "gin", "bn", "bb", "ge", " g", " eg", "kg", "gal", "bf", "gam", "gz", "cb", "bc", "gy", "sg", " cs", "kb", "hub", "db", " rc", " rgb", "gs", "cfg", "gi", "gn", "tg", "nb", "gd", "mb", "ci", "sb", "abb", "GB", "ga", "rg", " bc", "rc", "gp", "G", "gl", " db", "gio", "gh", "gg", "gc", "yg", "bg", "bm", "mc", "gm", "pc", "gt", "cgi", "g"], "i": ["abi", "slice", "yi", "b", "p", "ie", "c", "info", "name", "d", "ix", "x", "me", "api", "ti", "mi", "phi", "qi", "it", "ri", "id", "io", "ui", "u", "is", "e", "key", "gi", "li", "o", "zi", "multi", "xi", "uri", "inner", "ii", "bi", "si", "ai", "ini", "ni", "di", "ci", "fi", "eni", "vi", "part", "I", "f", "y", "mini", "n", "ip", "index", "t", "a", "oi", "j", "chi", "v", "iu", "mu", "pi", "in", "l", "hi", "g"]}}
{"project": "qemu", "commit_id": "7264961934130df50d151def5eb415efa2e28ec5", "target": 0, "func": "exynos4_boards_init_common(MachineState *machine,\n\n                           Exynos4BoardType board_type)\n\n{\n\n    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n", "idx": 25753, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "ings", "ss", "p", "m", "b", "c", "d", "ts", "ms", "sq", "ds", "us", "ps", "sg", "state", "states", "sync", "rows", "su", "is", "e", "es", "gs", "south", "o", "session", "spec", "os", "sb", "services", "sa", " ads", "ows", "f", "service", "sim", "fs", "n", "t", "machine", "sl", "r", "sf", "l", "cs", "its", "g"], "mc": ["md", "sc", "cm", "dc", "m", "c", "module", "mot", "mi", "bc", "mr", "Mc", "mac", "mx", "mp", "mic", "fc", "ma", "ram", "cfg", "mn", "cc", "mo", "co", "vm", "lc", "man", "ca", "MC", "mm", "bm", "coll", "machine", "container", "ac", "pc"]}}
{"project": "FFmpeg", "commit_id": "29d46d7bce1c67852e4c6e22605144eb32b21072", "target": 1, "func": "static void json_print_section_header(WriterContext *wctx)\n\n{\n\n    JSONContext *json = wctx->priv;\n\n    AVBPrint buf;\n\n    const struct section *section = wctx->section[wctx->level];\n\n    const struct section *parent_section = wctx->level ?\n\n        wctx->section[wctx->level-1] : NULL;\n\n\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n\n        printf(\",\\n\");\n\n\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n\n        printf(\"{\\n\");\n\n        json->indent_level++;\n\n    } else {\n\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n        json_escape_str(&buf, section->name, wctx);\n\n        JSON_INDENT();\n\n\n\n        json->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n\n        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n\n        } else {\n\n            printf(\"{%s\", json->item_start_end);\n\n\n\n            /* this is required so the parser can distinguish between packets and frames */\n\n            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n\n                if (!json->compact)\n\n                    JSON_INDENT();\n\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n\n            }\n\n        }\n\n        av_bprint_finalize(&buf, NULL);\n\n    }\n\n}\n", "idx": 25787, "substitutes": {"wctx": ["wci", "Wcb", " wkb", "wakb", "wttx", "fwcontext", "wcontext", "webcontext", "waci", "wwcontext", "wkb", "wtx", "hctx", "wecontext", "Wlc", "fwconn", " wcmp", " wjc", "wacf", "wwcmp", "wscontext", "wscmp", "wtctx", "owctx", " wlc", "wecmp", "ewcmp", "rcv", "wlc", "ewcontext", "rctx", "wscb", " wcb", "owconn", "wtjc", "wactx", " wcontext", "wacmp", "ewc", "wwci", "wscf", "fwctx", "ewcv", "ewconn", "webctx", "welc", "wcmp", "wc", "hjc", " wc", "ewcu", "wconn", "ewctx", "wacontext", "wjc", "fwcmp", "wwctx", "rcf", "owcmp", "rkb", " wcf", "wsctx", "Wcontext", "wcv", "wsci", "owcu", " wtx", "wectx", "wslc", "webjc", "wcu", "rcontext", "Wcf", "webcmp", "Wcmp", "wcb", "Wctx", "htx", "rcu", "hcontext", "Wjc", " wcv", " wconn", "Wc", "wsconn", "wcf", "wtcontext", " wcu"], "json": ["temp", "txt", "kw", "tree", "obj", "info", "server", "parser", "context", "data", "api", "job", "text", "config", "filename", "wire", "global", "john", "serial", "rec", "general", "format", "rss", "key", "feed", "nil", "ruby", "python", "javascript", "JSON", "jc", "journal", "parent", "ctx", "size", "view", "now", "html", "xml", "length", "zip", "jack", "note", "wp", "son", "service", "source", "java", "js", "j", "value", "null", "coll", "root", "full", "memory", "database", "pack", "ssl", "sv", "writer", "ja"], "buf": ["seq", "uf", "obj", "bag", "uc", "dump", "wb", "pkg", "usr", "context", "cv", "msg", "callback", "bb", "Buff", "buffer", "queue", "job", "fn", "vec", "rb", "ab", "br", "bh", "bd", "config", "cb", "base", "bc", "port", "bu", "rw", "book", "db", "aux", "home", "cast", "cmd", "pb", "la", " buffer", "loc", "fw", "output", "box", "pool", "ctx", "fb", "sb", "fi", "cf", "Buffer", "feat", "cache", "cas", "buff", "fp", "runner", "func", "bg", "builder", "result", "fd", "border"], "section": ["element", "setting", "ie", "definition", "server", "name", "module", "version", "column", "uration", "project", "set", "object", "ion", "closure", "course", "ruction", "part", "service", "entry", "j", "sect", "except", "area", "writer", "layer", "code", "option", "parser", "cript", "se", "test", "action", "vision", "chapter", "ure", "key", "patch", "draft", "group", "journal", "item", "array", "stage", "container", "description", "block", "table", "file", "Section", "itution", "function", "component", "article", "plugin", "small", "sections", "parent", "sec", "lc", "header", "division", "account", "connection", "tag", "cription", "package", "tree", "page", "position", "job", "config", "instance", "environment", "script", "python", "sector", "jack", "child", "format"], "parent_section": ["current_sector", "child_division", "parentencomponent", "rule_child", "current_component", "parent_component", "parentallsection", "parentedsection", "parentallchild", "ruleallchild", "child_section", "parent_child", "ruleallsection", "parentensection", "parent_setting", "parentensetting", "rule_setting", "parentablecomponent", "parentallcomponent", "parent_division", "parentallsetting", "parent_option", "parentablestruct", "parentablesection", "parent_sector", "child_sector", "ruleallsetting", "parentedsetting", "child_option", "current_struct", "rule_component", "parentenchild", "parentedcomponent", "current_section", "parentablesector", "ruleallcomponent", "parentedchild", "parent_struct", "rule_section"], "indent_level": ["indentingplimit", "indent_limit", "indent_path", "indentalpath", "indenting_level", "indentpline", "indent_error", "indenting_error", "indentalcol", "indentplevel", "indentingperror", "indentperror", "indent_col", "indenting_limit", "indentingalcol", "indentingalpath", "indentplimit", "indentingpline", "indenting_path", "indentallimit", "indentingallevel", "indenting_col", "indentingallimit", "indent_line", "indenting_line", "indentallevel", "indentingplevel"]}}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810, "substitutes": {"memmap": ["memorycache", "memstore", "poolmap", "poolstore", "memorydata", " memblock", "gramstore", "rammap", "poolshare", "dimmap", " memMap", "limbar", "memcap", "ramcap", "memcache", "Memlist", "memblock", "memorydown", "memlist", "imagecache", "memorybar", "memoryMap", "memorylist", "membar", "limcache", "dimhash", "gramhash", "memdata", "ramdata", "memorycap", "ramblock", "memMap", "limdown", "Memmap", "memshare", "memdown", " memdata", "gramshare", " memlist", "imagedown", "grammap", "imagemap", "memoryblock", "memorymap", "MemMap", "imagebar", "dimshare", "limmap", " memcap", "dimstore", "poolhash", "memhash"], "irqmap": ["irparray", "srqspace", "srquspace", "irwmap", "pirqmap", "irklist", "irkmap", "srqumap", "irqarray", "pirparray", "irquspace", "pirqblock", "srqlist", "srquconf", "irwspace", "irqlist", "pirqlist", "pirqarray", "srqmap", "irkarray", "srqconf", "irquconf", "irQblock", "irpmap", "irQlist", "irwconf", "irplist", "irQmap", "irqumap", "pirpblock", "irqulist", "irqconf", "irqblock", "irpblock", "pirplist", "irqspace", "pirpmap", "irkblock", "irQarray", "irkconf", "srqulist", "irkspace", "irwlist"], "madt": ["jadty", "mandtt", "midtor", "mingtt", "aidT", "madty", "madts", "madtu", "medten", "mandt", "midt", "madtor", "midtu", "mrtt", "madT", "adt", " madts", " madta", "medty", "mrt", "mrten", "aidt", "medtt", "midtt", "mandtu", "aidta", "jadtt", "mingtor", "mandtor", "madtt", "adta", "jadt", "madta", "adT", "mingt", "jadten", "medt", "adts", "mrty", " madT", "aidts", "mingtu", "madten"], "gicd": ["gaicdi", "picdi", "gacn", "gessdi", " gicf", "gicandn", "gaccd", "gicn", "gicst", "gixdh", "giccdl", "gicitd", "gircdd", "gicdn", "giacdl", "giscd", "gicsl", "gaicd", " gict", "egicitdt", "gicdi", " grict", " gisct", " gicl", "gixsd", "giccdn", "gricc", "giccdd", " gikdn", "ogicdh", "giccds", "giacds", "gicdb", "gisct", "gicitdh", " gikd", "Gacds", "gircd", "gicdl", "gicitdd", "giscdd", "gessdd", " gikcd", "gicandt", "gizc", "gicu", "giccd", "Gicd", "egicitsd", "ogicitdh", "gicansd", "giscf", "gizl", "giccu", " giscds", "gizd", "gicancd", "gicandb", "gicand", "gicdh", "Gicn", "gicandd", "gacf", "giaccd", "gikd", "gicdd", "Gacn", "gicitdt", "gixdt", "gikdn", "gircdb", " giscd", " gicdn", "giacd", " gicds", "picu", " gricd", "gicccd", "gicds", "Gacd", "gicsc", "egicd", "gicitdb", " gaicd", "ogicdb", " gicdl", "ogicitdb", "giscu", "piscd", "grict", "gact", "egicdh", "egicdt", "gessd", "gircdh", "egicitd", "ogicdd", "giacdi", "giccdi", "piscdd", "gessu", "gicct", " giscf", " giccd", "Gaccd", "picdd", "gizt", "giccf", "ogicitdd", "gicdt", "gisccd", " gicdi", "Giccd", " gaicdl", "egicsd", "gicsd", "piscdi", "picd", "giscdi", "gricd", "gacd", "gicandh", " gricc", " gicdt", " gaicdi", "gricl", "Gicds", " gricl", "gicf", "gicl", "gaicdl", " gikdt", "gict", "ogicitd", "gikdt", "gixd", "giscds", "gicitsd", "gacds", "giscn", "giacn", "egicitdh", "gikcd", "giccdt", "ogicd", "piscu"], "gic_msi": ["gic__ansii", "gic__ansi", "gic_csd", "gic_ansb", "gic__msii", "gic__msb", "gic_msd", "gic_ksd", "gic_ansi", "gic_msii", "gic_csi", "gic_ansii", "gic_ksi", "gic__msi", "gic__ansb", "gic_ksii", "gic_msb", "gic__ansd", "gic__msd", "gic_ansd", "gic_csii", "gic_csb", "gic_ksb"], "i": ["idi", "gui", "abi", "slice", "k", "ski", "z", "yi", "p", "m", "b", "c", "name", "d", "uli", "x", "ti", "mi", "type", "phi", "qi", "it", "ri", "io", "id", "u", "udi", "e", "li", "gi", "ji", "zi", "multi", "xi", "s", "uri", "ii", "cli", "si", "bi", "di", "ni", "ini", "ci", "fi", "eni", "h", "I", "f", "chi", "mini", "n", "j", "ip", "index", "ki", "oi", "lo", "t", "iu", "v", "mu", "pi", "anti", "ui", "l", "hi"], "gicc": ["wci", "musc", "gusc", "rgirc", "geicc", "geirc", "genusc", "geci", "rgicc", "gib", "geniac", "kigg", " gisi", "genirc", "agica", "gausc", "agocl", "agirc", "kusc", "Girc", "gocl", "Gigg", "gaocl", " gosc", "genaic", "picc", "genisc", "rgitech", "agosc", "gairc", " gisc", "gaigg", "gosc", "igocl", "piac", "pci", "Giac", "Gocl", "gaicc", "igiac", "pusc", "gci", "agigg", " gigg", "agib", "maic", " gci", "agci", "genocl", "micc", "kirc", "igisi", "gica", "agicc", "Gib", "kicc", " giac", "rgigg", "igicc", "gaiac", "agusc", "gigg", "miac", "gifi", " gifi", "igifi", "agiac", "genigg", "genib", "wusc", "kiac", "wiac", "igib", "igusc", "gisc", "genisi", "genicc", "agisc", " gica", "gitech", " gib", "gisi", "Gitech", " gocl", "girc", "kitech", "Gicc", "genifi", "gaic", "giac", "gaosc", "wicc", " gusc", "igaic", "genica", "genci", "geib"], "armcpu": ["amcpu", "arggpu", "mpu", "mprocessor", "amchu", "ampc", "mgpu", "amprocessor", "ramgpu", "adjcpu", "ampu", "ramcpu", "armgpu", "mcgpu", "adjchu", "rampc", "mccpu", "ramCPU", "adjpc", "mcprocessor", "mCPU", "argpu", "mcpu", "armpu", "argcpu", "armpc", "argCPU", "armchu", "adjgpu", "armCPU", "amgpu", "rampu", "ramchu", "armprocessor"], "gic_its": ["glic_ins", "gic__ins", "glic_times", "gic_times", "gic__times", "gic__its", "glic_its", "gic_ins", "gic_ms", "gic__ms", "glic_ms"]}}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n", "idx": 25813, "substitutes": {}}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n", "idx": 25814, "substitutes": {"klass": ["tklass", " kclass", "cklass", " klf", "ckclass", "tkcl", "scclass", "klf", "sclf", "jcl", "jlass", "sclass", "tkclass", "kazz", "kpl", "jclass", " kpl", "jazz", "cklf", "Klass", "kcl", "Kcl", "Kazz", "scpl", "Kclass", "kclass", "ckpl", "tkazz"], "data": ["load", "Data", "package", "class", "d", "module", "base", "config", "type", "bus", "buf", "input", "dat", "object", "parent", "board", "ctx", "cache", "device", "ata", "child", "da", "DATA", "func", "ui", "connection"], "uc": ["acc", "ru", "sc", "uf", "oc", "auc", "anc", "UC", "cv", "uma", "usb", "ec", "uca", "config", "cus", "us", "pub", "bc", "mac", "instance", "su", "uh", "u", "hub", "fc", "con", "home", "lu", "ubs", "input", "ul", "unc", "sub", "cc", "ucc", "client", "ub", "utf", "mc", "rc", "asc", "cas", "lc", "uu", "um", "ca", "usc", "tc", "userc", "cu", "plug", "uci", "ui", "ac", "pc"]}}
{"project": "FFmpeg", "commit_id": "77d98898211eeb0241e8411428b0b364a6231744", "target": 1, "func": "static int pixlet_decode_frame(AVCodecContext *avctx, void *data,\n                               int *got_frame, AVPacket *avpkt)\n{\n    PixletContext *ctx = avctx->priv_data;\n    int i, w, h, width, height, ret, version;\n    AVFrame *p = data;\n    ThreadFrame frame = { .f = data };\n    uint32_t pktsize;\n    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);\n    pktsize = bytestream2_get_be32(&ctx->gb);\n    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid packet size %\"PRIu32\"\\n\", pktsize);\n    }\n    version = bytestream2_get_le32(&ctx->gb);\n    if (version != 1)\n        avpriv_request_sample(avctx, \"Version %d\", version);\n    bytestream2_skip(&ctx->gb, 4);\n    if (bytestream2_get_be32(&ctx->gb) != 1)\n    bytestream2_skip(&ctx->gb, 4);\n    width  = bytestream2_get_be32(&ctx->gb);\n    height = bytestream2_get_be32(&ctx->gb);\n    w = FFALIGN(width,  1 << (NB_LEVELS + 1));\n    h = FFALIGN(height, 1 << (NB_LEVELS + 1));\n    ctx->levels = bytestream2_get_be32(&ctx->gb);\n    if (ctx->levels != NB_LEVELS)\n    ctx->depth = bytestream2_get_be32(&ctx->gb);\n    if (ctx->depth < 8 || ctx->depth > 15) {\n        avpriv_request_sample(avctx, \"Depth %d\", ctx->depth);\n    }\n    ret = ff_set_dimensions(avctx, w, h);\n    if (ret < 0)\n        return ret;\n    avctx->width  = width;\n    avctx->height = height;\n    if (ctx->w != w || ctx->h != h) {\n        free_buffers(avctx);\n        ctx->w = w;\n        ctx->h = h;\n        ret = init_decoder(avctx);\n        if (ret < 0) {\n            free_buffers(avctx);\n            ctx->w = 0;\n            ctx->h = 0;\n            return ret;\n        }\n    }\n    bytestream2_skip(&ctx->gb, 8);\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n    p->color_range = AVCOL_RANGE_JPEG;\n    ret = ff_thread_get_buffer(avctx, &frame, 0);\n    if (ret < 0)\n        return ret;\n    for (i = 0; i < 3; i++) {\n        ret = decode_plane(avctx, i, avpkt, frame.f);\n        if (ret < 0)\n            return ret;\n        if (avctx->flags & AV_CODEC_FLAG_GRAY)\n            break;\n    }\n    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);\n    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);\n    *got_frame = 1;\n    return pktsize;\n}", "idx": 25828, "substitutes": {"avctx": ["AVlc", "varctx", "navcontext", "aklc", "varcontext", "versci", "avcontext", "navctrl", "afcontext", "avectx", "varcmd", "Avtx", "vercu", "avcn", "abcu", "afxc", "airctx", "abcmp", "aircontext", "akctx", "akcontext", "AVcontext", "avcu", "avepkg", "avcoll", "aircn", "afcfg", "abcontext", "afctrl", "AVcn", "airpkg", "aftx", "avsci", "afcn", "afctx", "avpkg", "varctrl", "avecoll", "abctx", "avctrl", "AVctx", "avcfg", "avxc", "verctx", "AVcmp", "avecontext", "avcmp", "AVcu", "airlc", "avtx", "avetx", "Avcu", "avecu", "aflc", "avesci", " avxc", "navcmd", "afcoll", "Avctx", "afcmd", "afpkg", "AVsci", "vercontext", "afcu", " avcu", "akcfg", "Avxc", "Avcontext", "afsci", "aircoll", " avcontext", "avlc", "avcmd", "Avsci", "navctx"], "data": ["load", "Data", "body", "code", "primary", "slice", "bin", "batch", "frame", "empty", "image", "d", "buffer", "api", "base", "media", "read", "next", "def", "reader", "id", "proc", "pad", "buf", "open", "o", "input", "dat", "valid", "start", "sample", "one", "mode", "parent", "size", "video", "response", "cache", "channel", "length", "array", "window", "f", "source", "bytes", "value", "da", "DATA", "results", "init", "database", "memory", "draw", "result", "len", "val"], "got_frame": ["aved_frames", "got_frames", "gotfimage", "got_image", "aved_image", "gotfframes", "aved_size", "gotfsize", "got2frame", "gotfframe", "got_size", "got2frames", "got2image", "aved_frame", "got2size"], "avpkt": [" avpft", "avpqt", "avfkl", "avPkt", " avbct", "avPacket", "avppacket", "avvpct", "avppqt", " avlpkt", "avfke", "avtpacket", "avbkt", " avpacket", "avtpft", " avppkl", "avpke", "avPke", "avlpkt", " avbke", "avfct", "avpkl", " avpkl", " avppkt", "avtpkl", " avlpqt", "avfft", "avvpqt", " avbkt", "avbke", "avppcht", " avpqt", "avvpkt", "avbct", "avppkt", "avpft", "avlpct", "avpcht", "avbacket", "avpacket", " avlpcht", "avlpqt", "avPct", "avfkt", " avbacket", "avlpcht", "avpct", " avpct", " avlpct", "avvpcht", "avfacket", "avppct", " avpke", "avppkl", "avppft", " avppacket", "avtpkt", " avppft", " avpcht"], "ctx": ["exec", "acl", "sys", "cca", "pkg", "qa", "sq", "support", "cb", "general", "num", "wx", "cmd", "cms", "vc", "fw", "ann", "cal", "cf", "sci", "conv", "window", "ca", "crit", "r", "nc", "kw", "cm", "obj", "c", "cv", "prefix", "util", "cmp", "buf", "s", "ci", "utils", "mc", "cache", "cas", "git", "tc", "cu", "coll", "pc", "g", "scope", "this", "context", "d", "xc", "cci", "component", "conf", "act", "concept", "all", "cfg", "wcs", "cli", "hs", "Context", "cc", "cn", "client", "cp", "length", "lc", "ctrl", "_", "tx", "connection", "cs", "cam", "dc", "config", "cus", "bc", "instance", "kb", "chan", "hw", "loc", "rc", "co", "rt", "conn", "qq"], "i": ["code", "b", "c", "d", "ix", "x", "mi", "io", "is", "e", "ii", "di", "si", "ni", "ci", "I", "f", "n", "index", "v", "init", "iu", "pi", "in", "ui", "l", "len"], "w": ["ow", "kw", "z", "widget", "b", "wb", "sh", "name", "ww", "d", "wy", "sw", "x", "weight", "wh", "wn", "rw", "u", "wx", "hw", "iw", "home", "work", "max", "l", "wl", "fw", "wd", "ew", "win", "wp", "wal", "wid", "window", "f", "y", "wt", "wall", "n", "W", "nw", "t", "aw", "q", "v", "r", "we", "wi", "wa", "g"], "h": ["hm", "ht", "th", "z", "b", "m", "c", "sh", "d", "hd", "hr", "x", "en", "ih", "bh", "H", "hh", "u", "depth", "hl", "e", "hp", "o", "max", "rh", "length", "gh", "f", "y", "n", "j", "t", "wa", "ha", "q", "v", "r", "l", "hi", "ph", "g"], "height": ["build", "head", "ht", "th", "k", "hang", "z", "gap", "dy", "resolution", "d", "image", "hd", "history", "x", "img", "style", "hh", "gy", "upper", "inches", "shadow", "han", "high", "uh", "depth", "hw", "huge", "padding", "rh", "layout", "distance", "density", "hz", "fw", "adh", "size", "thin", "east", "shape", "direction", "length", "gh", "window", "y", "wall", "bottom", "volume", "quality", "row", "Height", "enh", "wa", "hi", "ph", "sh"], "ret": ["ref", "seq", "code", "sr", "ft", "res", " RET", "cat", "flag", "back", "success", "feature", "att", "fail", "debug", "def", "error", "url", "rets", "arr", "valid", "err", "bit", "mt", "progress", "rev", "det", "lit", "RET", "last", "re", "art", "nt", "reply", "let", "rc", "feat", "Ret", "rt", "ext", "status", "sat", "value", "alt", "reg", "match", "ver", "result", "len", "val", "gt", "fun"], "version": ["VERSION", "package", "download", "driver", "section", "option", "server", "Version", "name", "cv", "qa", "weight", "vision", "feature", "type", "debug", "support", "beta", "vers", "bug", "platform", "latest", "num", "url", "brand", "depth", "python", "step", "seed", "draft", "progress", "rev", "model", "mode", "versions", "parent", "vert", "number", "scale", "channel", "level", "length", "current", "uu", "update", "round", "stage", "status", "value", "v", "ver", "release", "result", "len", "val", "format"], "p": ["pa", "np", "m", "b", "c", "d", "P", "pointer", "bp", "e", "o", "pb", "cp", "wp", "lp", "f", "n", "tp", "j", "t", "fp", "a", "q", "v", "pi", "pc", "ap"], "pktsize": ["pktdizable", "pktesizable", "pkoutsize", "puktesize", "pkstsiz", "pktsizer", "puktsizing", "pkssizes", "pkatsize", "psktizes", "psktize", "puktizer", "puktesizable", "pktsizes", "psktsz", "pksssize", "pkTSizer", "puktsizable", "pktesiz", "pktsizing", "pktdize", "pkstssize", "pkoutsiz", "psktsizable", "pkatsz", "pktizes", "pktz", "psktz", "pktessize", "pktiz", "pktdsize", "pkTSize", "psktssize", "pktizable", "pkstsizable", "pkatsiz", "puktesiz", "puktsize", "pktsizable", "puktesizing", "pkoutssize", "puktize", "pktizer", "pkssz", "puktssize", "puktsiz", "psktiz", "psktizable", "pktsz", "pktesizer", "puktessize", "puktsizer", "pktesize", "pkssize", "pktize", "pkatsizes", "psktsize", "pkoutsizing", "pkstsize", "pkTSiz", "pkatsizing", "psktsizes", "psktsiz", "pktdiz", "pktssize", "pkatssize", "pkTSsize", "puktiz", "pktsiz", "pktesizing"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831, "substitutes": {"mc": ["md", "cm", "dc", "uc", "class", "m", "anc", "c", "ml", "dr", "module", "cci", "doc", "ec", "config", "mi", "cus", "bc", "mr", "Mc", "mac", "mic", "fc", "ic", "vc", "spec", " MC", "model", "wic", "cc", "ci", "cn", "rc", "lc", "ca", "MC", "tc", "mm", "coll", "arc", "nc", "ac", "pc"], "s390mc": ["s350mac", "s170mac", "s30mm", "s40mc", "s390module", " s390mac", " s90cci", "s390mm", " s90module", "s350mc", "s350mi", "s390cc", "s390dc", "S170mc", "s170dc", "s390mac", "s170MC", "s090mc", "s30MC", " s30mm", "s390cci", "S390mac", " s30mi", "s170mc", "s90cc", "s30mc", "s30mi", "s350mm", "s090cc", " s390mm", " s390cci", "S170MC", " s390cc", "s40module", " s90mc", " s30mac", " s90cc", "s90cci", "s370MC", "s390mi", " s30mc", "s370dc", "S390mc", "s90mc", "s310mc", " s390mi", "S390MC", "s370mac", "s310mi", "s370mc", "S170mac", "s30mac", "s390MC", "s40cci", "s090cci", "S390dc", " s390module", "S170dc", "s090module", "s90module", "s310mm", "s310mac", "s40cc", "s30dc"]}}
{"project": "FFmpeg", "commit_id": "d9fe6b926cd619c311e45e0ae352cf09713c482c", "target": 1, "func": "static int matroska_read_header(AVFormatContext *s)\n\n{\n\n    MatroskaDemuxContext *matroska = s->priv_data;\n\n    EbmlList *attachements_list = &matroska->attachments;\n\n    MatroskaAttachement *attachements;\n\n    EbmlList *chapters_list = &matroska->chapters;\n\n    MatroskaChapter *chapters;\n\n    MatroskaTrack *tracks;\n\n    uint64_t max_start = 0;\n\n    int64_t pos;\n\n    Ebml ebml = { 0 };\n\n    AVStream *st;\n\n    int i, j, k, res;\n\n\n\n    matroska->ctx = s;\n\n\n\n    /* First read the EBML header. */\n\n    if (ebml_parse(matroska, ebml_syntax, &ebml)\n\n        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)\n\n        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n        ebml_free(ebml_syntax, &ebml);\n\n        return AVERROR_PATCHWELCOME;\n\n    } else if (ebml.doctype_version == 3) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n    }\n\n    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)\n\n        if (!strcmp(ebml.doctype, matroska_doctypes[i]))\n\n            break;\n\n    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);\n\n    }\n\n    ebml_free(ebml_syntax, &ebml);\n\n\n\n    /* The next thing is a segment. */\n\n    pos = avio_tell(matroska->ctx->pb);\n\n    res = ebml_parse(matroska, matroska_segments, matroska);\n\n    // try resyncing until we find a EBML_STOP type element.\n\n    while (res != 1) {\n\n        res = matroska_resync(matroska, pos);\n\n        if (res < 0)\n\n            return res;\n\n        pos = avio_tell(matroska->ctx->pb);\n\n        res = ebml_parse(matroska, matroska_segment, matroska);\n\n    }\n\n    matroska_execute_seekhead(matroska);\n\n\n\n    if (!matroska->time_scale)\n\n        matroska->time_scale = 1000000;\n\n    if (matroska->duration)\n\n        matroska->ctx->duration = matroska->duration * matroska->time_scale\n\n                                  * 1000 / AV_TIME_BASE;\n\n    av_dict_set(&s->metadata, \"title\", matroska->title, 0);\n\n\n\n    if (matroska->date_utc.size == 8)\n\n        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));\n\n\n\n    tracks = matroska->tracks.elem;\n\n    for (i=0; i < matroska->tracks.nb_elem; i++) {\n\n        MatroskaTrack *track = &tracks[i];\n\n        enum CodecID codec_id = CODEC_ID_NONE;\n\n        EbmlList *encodings_list = &track->encodings;\n\n        MatroskaTrackEncoding *encodings = encodings_list->elem;\n\n        uint8_t *extradata = NULL;\n\n        int extradata_size = 0;\n\n        int extradata_offset = 0;\n\n        uint32_t fourcc = 0;\n\n        AVIOContext b;\n\n\n\n        /* Apply some sanity checks. */\n\n        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&\n\n            track->type != MATROSKA_TRACK_TYPE_AUDIO &&\n\n            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n\n                   track->type);\n\n            continue;\n\n        }\n\n        if (track->codec_id == NULL)\n\n            continue;\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            if (!track->default_duration)\n\n                track->default_duration = 1000000000/track->video.frame_rate;\n\n            if (!track->video.display_width)\n\n                track->video.display_width = track->video.pixel_width;\n\n            if (!track->video.display_height)\n\n                track->video.display_height = track->video.pixel_height;\n\n            if (track->video.color_space.size == 4)\n\n                fourcc = AV_RL32(track->video.color_space.data);\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            if (!track->audio.out_samplerate)\n\n                track->audio.out_samplerate = track->audio.samplerate;\n\n        }\n\n        if (encodings_list->nb_elem > 1) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR,\n\n                   \"Multiple combined encodings not supported\");\n\n        } else if (encodings_list->nb_elem == 1) {\n\n            if (encodings[0].type ||\n\n                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&\n\n#if CONFIG_ZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&\n\n#endif\n\n#if CONFIG_BZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&\n\n#endif\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {\n\n                encodings[0].scope = 0;\n\n                av_log(matroska->ctx, AV_LOG_ERROR,\n\n                       \"Unsupported encoding type\");\n\n            } else if (track->codec_priv.size && encodings[0].scope&2) {\n\n                uint8_t *codec_priv = track->codec_priv.data;\n\n                int offset = matroska_decode_buffer(&track->codec_priv.data,\n\n                                                    &track->codec_priv.size,\n\n                                                    track);\n\n                if (offset < 0) {\n\n                    track->codec_priv.data = NULL;\n\n                    track->codec_priv.size = 0;\n\n                    av_log(matroska->ctx, AV_LOG_ERROR,\n\n                           \"Failed to decode codec private data\\n\");\n\n                } else if (offset > 0) {\n\n                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n\n                    memcpy(track->codec_priv.data,\n\n                           encodings[0].compression.settings.data, offset);\n\n                    memcpy(track->codec_priv.data+offset, codec_priv,\n\n                           track->codec_priv.size);\n\n                    track->codec_priv.size += offset;\n\n                }\n\n                if (codec_priv != track->codec_priv.data)\n\n                    av_free(codec_priv);\n\n            }\n\n        }\n\n\n\n        for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n\n            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n\n                        strlen(ff_mkv_codec_tags[j].str))){\n\n                codec_id= ff_mkv_codec_tags[j].id;\n\n                break;\n\n            }\n\n        }\n\n\n\n        st = track->stream = avformat_new_stream(s, NULL);\n\n        if (st == NULL)\n\n            return AVERROR(ENOMEM);\n\n\n\n        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")\n\n            && track->codec_priv.size >= 40\n\n            && track->codec_priv.data != NULL) {\n\n            track->ms_compat = 1;\n\n            fourcc = AV_RL32(track->codec_priv.data + 16);\n\n            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);\n\n            extradata_offset = 40;\n\n        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")\n\n                   && track->codec_priv.size >= 14\n\n                   && track->codec_priv.data != NULL) {\n\n            int ret;\n\n            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,\n\n                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);\n\n            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);\n\n            if (ret < 0)\n\n                return ret;\n\n            codec_id = st->codec->codec_id;\n\n            extradata_offset = FFMIN(track->codec_priv.size, 18);\n\n        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")\n\n                   && (track->codec_priv.size >= 86)\n\n                   && (track->codec_priv.data != NULL)) {\n\n            fourcc = AV_RL32(track->codec_priv.data);\n\n            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);\n\n        } else if (codec_id == CODEC_ID_PCM_S16BE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;\n\n            }\n\n        } else if (codec_id == CODEC_ID_PCM_S16LE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;\n\n            }\n\n        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n\n            codec_id = CODEC_ID_PCM_F64LE;\n\n        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {\n\n            int profile = matroska_aac_profile(track->codec_id);\n\n            int sri = matroska_aac_sri(track->audio.samplerate);\n\n            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n\n            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);\n\n            if (strstr(track->codec_id, \"SBR\")) {\n\n                sri = matroska_aac_sri(track->audio.out_samplerate);\n\n                extradata[2] = 0x56;\n\n                extradata[3] = 0xE5;\n\n                extradata[4] = 0x80 | (sri<<3);\n\n                extradata_size = 5;\n\n            } else\n\n                extradata_size = 2;\n\n        } else if (codec_id == CODEC_ID_TTA) {\n\n            extradata_size = 30;\n\n            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            ffio_init_context(&b, extradata, extradata_size, 1,\n\n                          NULL, NULL, NULL, NULL);\n\n            avio_write(&b, \"TTA1\", 4);\n\n            avio_wl16(&b, 1);\n\n            avio_wl16(&b, track->audio.channels);\n\n            avio_wl16(&b, track->audio.bitdepth);\n\n            avio_wl32(&b, track->audio.out_samplerate);\n\n            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);\n\n        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n\n                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n\n            extradata_offset = 26;\n\n        } else if (codec_id == CODEC_ID_RA_144) {\n\n            track->audio.out_samplerate = 8000;\n\n            track->audio.channels = 1;\n\n        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||\n\n                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {\n\n            int flavor;\n\n            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,\n\n                          0, NULL, NULL, NULL, NULL);\n\n            avio_skip(&b, 22);\n\n            flavor                       = avio_rb16(&b);\n\n            track->audio.coded_framesize = avio_rb32(&b);\n\n            avio_skip(&b, 12);\n\n            track->audio.sub_packet_h    = avio_rb16(&b);\n\n            track->audio.frame_size      = avio_rb16(&b);\n\n            track->audio.sub_packet_size = avio_rb16(&b);\n\n            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);\n\n            if (codec_id == CODEC_ID_RA_288) {\n\n                st->codec->block_align = track->audio.coded_framesize;\n\n                track->codec_priv.size = 0;\n\n            } else {\n\n                if (codec_id == CODEC_ID_SIPR && flavor < 4) {\n\n                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };\n\n                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];\n\n                    st->codec->bit_rate = sipr_bit_rate[flavor];\n\n                }\n\n                st->codec->block_align = track->audio.sub_packet_size;\n\n                extradata_offset = 78;\n\n            }\n\n        }\n\n        track->codec_priv.size -= extradata_offset;\n\n\n\n        if (codec_id == CODEC_ID_NONE)\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id);\n\n\n\n        if (track->time_scale < 0.01)\n\n            track->time_scale = 1.0;\n\n        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n\n\n        st->codec->codec_id = codec_id;\n\n        st->start_time = 0;\n\n        if (strcmp(track->language, \"und\"))\n\n            av_dict_set(&st->metadata, \"language\", track->language, 0);\n\n        av_dict_set(&st->metadata, \"title\", track->name, 0);\n\n\n\n        if (track->flag_default)\n\n            st->disposition |= AV_DISPOSITION_DEFAULT;\n\n        if (track->flag_forced)\n\n            st->disposition |= AV_DISPOSITION_FORCED;\n\n\n\n        if (!st->codec->extradata) {\n\n            if(extradata){\n\n                st->codec->extradata = extradata;\n\n                st->codec->extradata_size = extradata_size;\n\n            } else if(track->codec_priv.data && track->codec_priv.size > 0){\n\n                st->codec->extradata = av_mallocz(track->codec_priv.size +\n\n                                                  FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if(st->codec->extradata == NULL)\n\n                    return AVERROR(ENOMEM);\n\n                st->codec->extradata_size = track->codec_priv.size;\n\n                memcpy(st->codec->extradata,\n\n                       track->codec_priv.data + extradata_offset,\n\n                       track->codec_priv.size);\n\n            }\n\n        }\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_tag  = fourcc;\n\n            st->codec->width  = track->video.pixel_width;\n\n            st->codec->height = track->video.pixel_height;\n\n            av_reduce(&st->sample_aspect_ratio.num,\n\n                      &st->sample_aspect_ratio.den,\n\n                      st->codec->height * track->video.display_width,\n\n                      st->codec-> width * track->video.display_height,\n\n                      255);\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n            if (track->default_duration)\n\n                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);\n\n\n\n            /* export stereo mode flag as metadata tag */\n\n            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)\n\n                av_dict_set(&st->metadata, \"stereo_mode\", matroska_video_stereo_mode[track->video.stereo_mode], 0);\n\n\n\n            /* if we have virtual track, mark the real tracks */\n\n            for (j=0; j < track->operation.combine_planes.nb_elem; j++) {\n\n                char buf[32];\n\n                if (planes[j].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)\n\n                    continue;\n\n                snprintf(buf, sizeof(buf), \"%s_%d\",\n\n                         matroska_video_stereo_plane[planes[j].type], i);\n\n                for (k=0; k < matroska->tracks.nb_elem; k++)\n\n                    if (planes[j].uid == tracks[k].uid) {\n\n                        av_dict_set(&s->streams[k]->metadata,\n\n                                    \"stereo_mode\", buf, 0);\n\n                        break;\n\n                    }\n\n            }\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->sample_rate = track->audio.out_samplerate;\n\n            st->codec->channels = track->audio.channels;\n\n            if (st->codec->codec_id != CODEC_ID_AAC)\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n        }\n\n    }\n\n\n\n    attachements = attachements_list->elem;\n\n    for (j=0; j<attachements_list->nb_elem; j++) {\n\n        if (!(attachements[j].filename && attachements[j].mime &&\n\n              attachements[j].bin.data && attachements[j].bin.size > 0)) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");\n\n        } else {\n\n            AVStream *st = avformat_new_stream(s, NULL);\n\n            if (st == NULL)\n\n                break;\n\n            av_dict_set(&st->metadata, \"filename\",attachements[j].filename, 0);\n\n            av_dict_set(&st->metadata, \"mimetype\", attachements[j].mime, 0);\n\n            st->codec->codec_id = CODEC_ID_NONE;\n\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n\n            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if(st->codec->extradata == NULL)\n\n                break;\n\n            st->codec->extradata_size = attachements[j].bin.size;\n\n            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n\n\n\n            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n\n                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n\n                             strlen(ff_mkv_mime_tags[i].str))) {\n\n                    st->codec->codec_id = ff_mkv_mime_tags[i].id;\n\n                    break;\n\n                }\n\n            }\n\n            attachements[j].stream = st;\n\n        }\n\n    }\n\n\n\n    chapters = chapters_list->elem;\n\n    for (i=0; i<chapters_list->nb_elem; i++)\n\n        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid\n\n            && (max_start==0 || chapters[i].start > max_start)) {\n\n            chapters[i].chapter =\n\n            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n\n                           chapters[i].start, chapters[i].end,\n\n                           chapters[i].title);\n\n            av_dict_set(&chapters[i].chapter->metadata,\n\n                             \"title\", chapters[i].title, 0);\n\n            max_start = chapters[i].start;\n\n        }\n\n\n\n    matroska_add_index_entries(matroska);\n\n\n\n    matroska_convert_tags(s);\n\n\n\n    return 0;\n\n}\n", "idx": 25854, "substitutes": {"s": ["S", "space", "comments", "sc", "ses", "rs", "sys", "ss", "p", "server", "c", "ns", "se", "ts", "storage", "sq", "ds", "soc", "conf", "request", "support", "sg", "su", "e", "cs", "gs", "es", "sets", "session", "spec", "si", "sym", "os", "ctx", "sb", "client", "services", "sci", "sa", "serv", "h", "f", "fs", "service", "js", "qs", "a", "t", "v", "r", "sf", "ops", "ssl", "sv", "g"], "matroska": ["macroska", "matrisaka", "matrokaya", "macrosla", "matronesku", "matraskee", "matrusla", "Matrocky", "macroki", "matronskee", "matrsski", " matrosaka", "matrssena", "Matrsaka", "matreska", "matosla", "matroaka", "matrski", "matroseka", "matrisku", "macrola", "matroneskee", "matrockee", "matroneska", "matronesla", "matruskee", "matroena", "macroskaya", "matrssla", "matrsaka", "matrotla", "matoska", "matoskee", "macroskee", "matrokee", "matrska", "matrosky", "matronskaya", "matroskaya", "Matroku", "matronsla", "matrotkaya", "Matroka", "matrocky", "macroski", "matruski", "Matrski", "matronsaka", "matrosena", "matreskee", "matrotkee", "Matrskee", "macrokee", "matroneski", "matrocena", "matrasla", "matrocka", "Matrockee", "Matroskee", "macroka", "matriska", "Matrska", "Matrosla", "matroskee", " matrosya", "matrosela", "matrosya", "matrosaka", "Matroska", " matreska", "matresya", "matroya", " matresya", "matrusaka", " matroskee", "macroena", "matosky", "macrokaya", "matrotka", "Matrola", "matrocki", "matruska", "matrola", "Matrosku", "matroseya", "matresaka", "matronesaka", "matraska", "matroku", "matroka", "Matrocla", "Matrosaka", "matronsya", "matroski", "matrusky", "Matrocka", " matreskee", "Matroaka", "matrosla", "matroki", "matrasya", " matresaka", "Matrosky", "matrskee", "matrsya", "Matroski", "macrosena", "matrosku", "matronska", "matrosekee", "macrosya", "macroya", "matrocla", "matrisla", "matrsska", "matoski"], "attachements_list": ["attachements_type", "attachements_diff", "attacheles_list", "attachements__diff", "attacheles_diff", "attachements__list", "attachements__type", "attacheles_type"], "attachements": ["attachments", "attachls", "attaitment", "assachements", "attailment", "attaitls", "assachments", "attailments", "attachels", "assachment", "attaitments", "attachures", "attaitures", "assachures", "assachement", "attachment", "attaills", "assachels", "assachls", "assacheures", "attacheures", "attailures", "attachement"], "chapters_list": ["channels_name", "channels_set", "chapters_name", "channels_LIST", "chapters_set", "channels_list", "chapters_LIST"], "chapters": ["achassis", "charts", "adassis", "corts", " chunks", "chassis", "chants", "chorts", "adapters", "acharts", "phannels", "achannels", "adorts", "adants", "achants", " channels", "cants", "chunks", " charts", "capters", "phunks", "channels", "achunks", "achorts", "achapters", "pharts", "cassis", "phapters"], "tracks": ["comments", "tags", "steps", "events", "relations", "frames", "ips", "items", "acks", "media", "phones", "shows", "notes", "rows", "clips", "flows", "reads", "sections", "tracking", "series", "mods", "grades", "groups", "ids", "parts", "videos", "views"], "pos": ["ref", "seq", "body", "fin", "obj", "args", "pt", "nos", "position", "no", "next", "diff", "type", "def", "pc", "port", "su", "all", "POS", "sp", "rel", "start", "loc", "spec", "Pos", "offset", "os", "sec", "cache", "cas", "part", "loop", "pro", "po", "limit", "put", "index", "resp", "block", "len", "val", "params", "pid"], "st": ["rest", "std", "sc", "ST", "ss", "sn", "sw", "ste", "cr", "bl", "ast", "inst", "St", "sth", "rss", "sp", "sta", "stim", "sts", "est", "ist", "sa", "ost", "stage", "stack", "sl", " ss"], "i": ["abi", "slice", "ski", "z", "ie", "p", "info", "m", "yi", "c", "d", "ix", "x", "adi", "ti", "mi", "phi", "qi", "ri", "id", "io", "ui", "count", "e", "key", "li", "gi", "ji", "zi", "multi", "start", "xi", "uri", "ii", "bi", "si", "ai", "ini", "ni", "di", "ci", "fi", "eni", "h", "part", "I", "f", "ki", "oi", "n", "index", "ip", "t", "chi", "iu", "ind", "r", "pi", "in", "l", "hi", "mu", "v"], "j": ["z", "ie", "m", "p", "uj", "kj", "je", "py", "jp", "jj", "sp", "o", "ji", "ii", "si", "ij", "y", "jl", "n", "q", "J", "r", "l", "ja", "g"], "k": ["sk", "kw", "w", "kk", "z", "p", "ka", "kj", "K", "km", "ks", "ak", "key", "o", "ko", "ky", "ik", "kr", "ek", "ki", "mk", "q", "ck", "kid", "ke", "ku", "ok"], "res": ["ru", "rs", "sw", "vs", "cr", "us", "ps", "ks", "rows", "rec", "rw", "rss", "sp", "R", "err", "rev", "os", "rc", "req", "ro", "Res", "ack", "js", "rx", "pres", "resp", "r"]}}
{"project": "FFmpeg", "commit_id": "feb13aed794a7f1a1f8395159e9b077351348a34", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    SignatureContext *sic = ctx->priv;\n\n    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);\n\n    FineSignature* fs;\n\n\n\n    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };\n\n    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296\n\n    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...\n\n    */\n\n    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};\n\n    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};\n\n\n\n    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */\n\n    uint64_t intpic[32][32];\n\n    uint64_t rowcount;\n\n    uint8_t *p = picref->data[0];\n\n    int inti, intj;\n\n    int *intjlut;\n\n\n\n    uint64_t conflist[DIFFELEM_SIZE];\n\n    int f = 0, g = 0, w = 0;\n\n    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;\n\n    int64_t denom;\n\n    int i, j, k, ternary;\n\n    uint64_t blocksum;\n\n    int blocksize;\n\n    int64_t th; /* threshold */\n\n    int64_t sum;\n\n\n\n    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;\n\n\n\n    /* initialize fs */\n\n    if (sc->curfinesig) {\n\n        fs = av_mallocz(sizeof(FineSignature));\n\n        if (!fs)\n\n            return AVERROR(ENOMEM);\n\n        sc->curfinesig->next = fs;\n\n        fs->prev = sc->curfinesig;\n\n        sc->curfinesig = fs;\n\n    } else {\n\n        fs = sc->curfinesig = sc->finesiglist;\n\n        sc->curcoarsesig1->first = fs;\n\n    }\n\n\n\n    fs->pts = picref->pts;\n\n    fs->index = sc->lastindex++;\n\n\n\n    memset(intpic, 0, sizeof(uint64_t)*32*32);\n\n    intjlut = av_malloc_array(inlink->w, sizeof(int));\n\n    if (!intjlut)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < inlink->w; i++) {\n\n        intjlut[i] = (i*32)/inlink->w;\n\n    }\n\n\n\n    for (i = 0; i < inlink->h; i++) {\n\n        inti = (i*32)/inlink->h;\n\n        for (j = 0; j < inlink->w; j++) {\n\n            intj = intjlut[j];\n\n            intpic[inti][intj] += p[j];\n\n        }\n\n        p += picref->linesize[0];\n\n    }\n\n    av_freep(&intjlut);\n\n\n\n    /* The following calculates a summed area table (intpic) and brings the numbers\n\n     * in intpic to the same denominator.\n\n     * So you only have to handle the numinator in the following sections.\n\n     */\n\n    dh1 = inlink->h / 32;\n\n    if (inlink->h % 32)\n\n        dh2 = dh1 + 1;\n\n    dw1 = inlink->w / 32;\n\n    if (inlink->w % 32)\n\n        dw2 = dw1 + 1;\n\n    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        rowcount = 0;\n\n        a = 1;\n\n        if (dh2 > 1) {\n\n            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32;\n\n            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32;\n\n            a = (a == dh1)? dh2 : dh1;\n\n        }\n\n        for (j = 0; j < 32; j++) {\n\n            b = 1;\n\n            if (dw2 > 1) {\n\n                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32;\n\n                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32;\n\n                b = (b == dw1)? dw2 : dw1;\n\n            }\n\n            rowcount += intpic[i][j] * a * b * precfactor / denom;\n\n            if (i > 0) {\n\n                intpic[i][j] = intpic[i-1][j] + rowcount;\n\n            } else {\n\n                intpic[i][j] = rowcount;\n\n            }\n\n        }\n\n    }\n\n\n\n    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;\n\n\n\n    for (i = 0; i < ELEMENT_COUNT; i++) {\n\n        const ElemCat* elemcat = elements[i];\n\n        int64_t* elemsignature;\n\n        uint64_t* sortsignature;\n\n\n\n        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!elemsignature)\n\n            return AVERROR(ENOMEM);\n\n        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!sortsignature)\n\n            return AVERROR(ENOMEM);\n\n\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            blocksum = 0;\n\n            blocksize = 0;\n\n            for (k = 0; k < elemcat->left_count; k++) {\n\n                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n            }\n\n            sum = blocksum / blocksize;\n\n            if (elemcat->av_elem) {\n\n                sum -= 128 * precfactor * denom;\n\n            } else {\n\n                blocksum = 0;\n\n                blocksize = 0;\n\n                for (; k < elemcat->block_count; k++) {\n\n                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n                }\n\n                sum -= blocksum / blocksize;\n\n                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));\n\n            }\n\n\n\n            elemsignature[j] = sum;\n\n            sortsignature[j] = FFABS(sum);\n\n        }\n\n\n\n        /* get threshold */\n\n        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);\n\n        th = sortsignature[(int) (elemcat->elem_count*0.333)];\n\n\n\n        /* ternarize */\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            if (elemsignature[j] < -th) {\n\n                ternary = 0;\n\n            } else if (elemsignature[j] <= th) {\n\n                ternary = 1;\n\n            } else {\n\n                ternary = 2;\n\n            }\n\n            fs->framesig[f/5] += ternary * pot3[f%5];\n\n\n\n            if (f == wordvec[w]) {\n\n                fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];\n\n                if (w < 24)\n\n                    w++;\n\n            }\n\n            f++;\n\n        }\n\n        av_freep(&elemsignature);\n\n        av_freep(&sortsignature);\n\n    }\n\n\n\n    /* confidence */\n\n    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);\n\n    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);\n\n\n\n    /* coarsesignature */\n\n    if (sc->coarsecount == 0) {\n\n        if (sc->curcoarsesig2) {\n\n            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));\n\n            if (!sc->curcoarsesig1)\n\n                return AVERROR(ENOMEM);\n\n            sc->curcoarsesig1->first = fs;\n\n            sc->curcoarsesig2->next = sc->curcoarsesig1;\n\n            sc->coarseend = sc->curcoarsesig1;\n\n        }\n\n    }\n\n    if (sc->coarsecount == 45) {\n\n        sc->midcoarse = 1;\n\n        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));\n\n        if (!sc->curcoarsesig2)\n\n            return AVERROR(ENOMEM);\n\n        sc->curcoarsesig2->first = fs;\n\n        sc->curcoarsesig1->next = sc->curcoarsesig2;\n\n        sc->coarseend = sc->curcoarsesig2;\n\n    }\n\n    for (i = 0; i < 5; i++) {\n\n        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);\n\n    }\n\n    /* assuming the actual frame is the last */\n\n    sc->curcoarsesig1->last = fs;\n\n    if (sc->midcoarse) {\n\n        for (i = 0; i < 5; i++) {\n\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n\n        }\n\n        sc->curcoarsesig2->last = fs;\n\n    }\n\n\n\n    sc->coarsecount = (sc->coarsecount+1)%90;\n\n\n\n    /* debug printing finesignature */\n\n    if (av_log_get_level() == AV_LOG_DEBUG) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n\n        for (i = 0; i < 5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] );\n\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n\n        for (i = 0; i < SIGELEM_SIZE/5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] );\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n\n\n    if (FF_INLINK_IDX(inlink) == 0)\n\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n\n    return 1;\n\n}\n", "idx": 25859, "substitutes": {"inlink": [" inpath", "innLink", "inframe", "inlock", "innurl", "outli", "inurl", "incload", "inlog", "inslog", "inpath", "innlink", "inLink", "innpath", "innload", "incframe", "inslock", "innlock", " inbase", " inlock", "inli", "incLink", "incli", "inslink", "outLink", "inload", "innli", "insframe", "insbase", "incurl", "innframe", "inclink", "inclog", "inbase", "innbase", "innlog", "inspath", "outlink", "insload", "outurl"], "picref": [" picdef", "pinsref", "pinsrel", "Picrel", "Picnum", "Picdef", "pinref", "picnum", " picnum", "icreference", " picrel", "picdef", "pinreference", "pinsdef", "PicREF", "PicRef", "Picreference", "picRef", "Picref", "pinREF", "pinRef", "icref", "picreference", "pinsnum", "icREF", "picrel", "icRef", "picREF"], "ctx": ["cm", "cca", "uc", "anc", "c", "context", "cv", "cci", "soc", "conf", "cb", "bc", "fc", "cms", "unc", "Context", "cc", "ci", "cp", "cf", "ctr", "rc", "sci", "lc", "ctrl", "ca", "tc", "cu", "conn", "src", "ck", "nc", "tx", "cs", "cam", "pc"], "sic": ["sch", "ses", "shi", "anc", "cot", "cci", "isc", "ec", "sac", "soc", "cus", "bc", "priv", "sis", "cies", "ic", "bitcoin", "ac", "ics", "isu", "icc", "si", "ik", "sb", "sec", "sci", "osc", "SC", "lc", "usc", "tc", "irc", "userc", "uci", "acs", "org", "ku", "voc", "pic", "SEC"], "sc": ["exec", "esc", "sem", "cca", "scope", "uc", "dc", "anc", "c", "context", "cv", "isc", "ec", "cur", "config", "soc", "cr", "cus", "gb", "conf", "bc", "sync", "ocr", "sche", "fc", "cms", "cl", "scl", "spec", "loc", "cer", "cc", "mc", "rc", "sec", "sci", "asc", "co", "osc", "git", "SC", "ctrl", "ca", "usc", "tc", "src", "RC", "ck", "Sc", "nc", "cs", "cam", "pc", "desc"], "fs": ["rs", "xf", "fe", "sys", "FS", "ns", "flags", "frames", "ips", "vs", "fn", "ts", "irs", "ms", "ds", "bf", "fm", "ps", "ks", "outs", "rows", "ups", "bs", "vals", "rets", "fc", "gs", "lf", "flows", "feed", "fps", "Fs", "fields", "s", "fts", "fee", "wcs", "fw", "hs", "gets", "os", "fb", "cf", "fx", "files", "fi", "obs", "xs", "fu", "ows", "raf", "ums", "ls", "qs", "ves", "fp", "acs", "sf", "df", "cs", "fd", "fits"], "pot3": ["chan5", "ft5", "chan3", "lat5", "potd", "ft3", "chan6", "lat3", "pot5", "chand", "ft6", "pot6", "latd", "ftd", "lat6"], "wordvec": ["wavepad", "Wvec", "wordseq", "Wbuffer", "allpad", "wordbuffer", "wordpad", "waveseq", "allvec", "Wpad", "allseq", "Wseq", "allbuffer", "wavebuffer", "wavevec"], "s2usw": ["sblusiw", "s2auswer", "sbluswer", "sblbusiw", "s2buswe", "s2uswe", "s2ausw", "sblusw", "sblbuswer", "sblbuswe", "s2buswer", "s2uw", "sblbusw", "s2uwer", "sbluswe", "s2uiw", "s2usiw", "s2busw", "s2auswe", "s2ausiw", "s2uswer", "s2uwe", "s2busiw"], "wordt2b": ["wordt0w", "wordt6w", "wordt6a", "wordinttoa", "wordt6c", "wordttow", "wordttoa", "wordt2c", "wordinttob", "wordt2a", "wordint2w", "wordinttow", "wordint2b", "wordttob", "wordt0b", "wordttoc", "wordint2c", "wordint2a", "wordt2w", "wordinttoc", "wordt0a", "wordt0c", "wordt6b"], "intpic": ["numseq", "intseq", "maxtoc", "numpic", "chartoc", "inttoc", "numstruct", "maxseq", "maxpic", "charpic", "charstruct", "maxstruct", "charseq", "intstruct", "numtoc"], "rowcount": ["bytenum", "bitlen", "rowCount", "rowsnum", "rowscount", "rowsCount", "rowslen", "bytelen", "rowlen", "bitCount", "rownum", "byteCount", "bitnum", "bytecount", "bitcount"], "p": ["pp", "np", "m", "c", "d", "pid", "data", "P", "op", "e", "sp", "o", "s", "h", "lp", "n", "pic", "t", "tp", "q", "r", "pi", "pc", "g"], "inti": ["Inti", "indI", "IntI", "indi", "Intj", "indj", "intI", " intI"], "intj": ["intf", " intf", "indj", "indf", "intk", "netj", "netk", " intk", "netf", "indk"], "intjlut": ["intiglus", "floatjlu", "intgnut", "floatiglut", "intgnus", "intiglu", "intgnull", "intjlull", "floatiglull", "intklus", "floatjlut", "intgnu", "intklut", "intklull", "floatjlus", "intjlus", "intiglut", "intjlu", "floatjlull", "floatiglus", "intiglull", "floatiglu", "intklu"], "conflist": ["conclst", "cocline", "constrst", "conclize", "coflst", "confize", "confine", "conclist", "confst", "cofline", "constrist", "coflize", "concline", "conflize", "constrine", "coclize", "coclist", "confist", "constrize", "confline", "coclst", "conflst", "coflist"], "a": ["m", "c", "aa", "d", "ae", "x", "ad", "am", "A", "u", "ak", "e", "o", "s", "ai", "ar", "sa", "y", "n", "an", "r", "ac"], "b": ["c", "wb", "d", "x", "ab", "rb", "bs", "u", "e", "o", "s", "eb", "B", "h", "y", "n", "v", "r", "l", "g"], "denom": ["nano", "leno", "dono", "denow", "donum", "lenow", "deno", "nanum", "denum", "donom", "lenom", "nanom", "lenum", "donow", "nanow"], "i": ["z", "m", "c", "d", "x", "u", "is", "e", "o", "li", "ii", "ci", "h", "I", "y", "n", "v", "r", "in", "l", "g"], "j": ["z", "m", "uj", "d", "x", "je", "jp", "e", "sp", "ji", "li", "o", "ii", "ij", "h", "y", "n", "v", "J", "r", "l", "g"], "k": ["sk", "kw", "z", "kk", "m", "c", "ka", "x", "K", "ks", "ch", "u", "ak", "key", "e", "o", "s", "ik", "h", "ki", "y", "n", "q", "v", "ke", "kl", "ok"], "ternary": ["ternality", "primality", "primary", "ternical", "signical", "literary", "signality", "signaries", "literaries", "literical", "ternaries", "primical", "primaries", "literality", "signary"], "blocksum": ["outsum", "bitsume", "bitsumm", "bitsum", "ocksum", "blocksumm", "ocksums", "ocksume", "ocksumm", "outsumm", "bitsums", "blocksums", "blocksume", "outsume", "outsums"], "blocksize": ["framesize", "framesiz", " blocksizer", "bitsizer", " blocksizes", "blocksiz", "framesizer", " blocksiz", "bitsiz", "blocksizer", "blocksizes", "framesizes", "bitsize", "bitsizes"], "th": ["mask", "skip", "std", "comb", "ht", "thread", "each", "batch", "kh", "oth", "bh", "col", "ch", "tr", "num", "rw", "prime", "eth", "last", "sel", "thin", "rate", "ctr", "sec", "first", "gh", "src", "row", "sh"], "sum": ["gram", "mask", "skip", "mass", "hash", "cost", "Sum", "weight", "add", "gam", "num", "seed", "mean", "mem", "miss", "min", "sub", "sym", "dev", "sign", "scale", "sa", "ums", "um", "count", "sim", "total", "mix", "sh"], "w": ["kw", "wan", "z", "m", "sw", "x", "weight", "wh", "rw", "u", "wx", "fw", "win", "h", "window", "y", "n", "W", "q", "v", "r", "wi", "wa", "g"], "f": ["fen", "z", "info", "m", "c", "x", "fn", "fm", "num", "e", "fc", "o", "fb", "field", "F", "h", "n", "fa", "index", "t", "v", "l", "g"]}}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862, "substitutes": {"ahci": ["ahcin", "actcci", "phlc", "ohcu", "phcia", "aphci", "aphcin", "ohii", "avii", "ghcin", "ghci", "ehsi", "ahcu", "akci", "ehki", "hcin", "aphcci", "ehcit", "ohcci", "ohci", "akcia", "hci", "angcci", "avcci", "lahcin", "yahcci", "lahci", "ahcit", "ahlc", "actcu", "AHci", "ohcit", "avcu", "ahscia", "phci", "amsi", "AHcium", "ehcu", "hcu", "hdi", "avki", "ohki", "lahcit", "actcit", "yahcit", "ahki", "akcin", "ohcia", "ohlc", "hrlc", "ohcium", "ercin", "amcia", "ahscit", "avci", "ahcia", "akcit", "ehlc", "hcci", "lahcci", "akcu", "amdi", "AHcin", "ehcci", "hrci", "angcin", "amcu", "occia", "archcin", "aphcit", "archcci", "ercci", "amci", "akcci", "ehcia", "actcia", "archcu", "ohsi", "ahcium", "ahdi", "avcia", "ehii", "hrii", "occci", "angci", "ghki", "ehcin", "occin", "erci", "ghcium", "yahci", "hrcci", "ahii", "actci", "ahcci", "hrcu", "actcin", "phcin", "ehci", "archci", "amcci", "ahsci", "AHki", "hrcin", "avcin", "hrcia", "ehdi", "yahcin", "ahsi", "ercu", "occi", "amcin", "angcia", "ohcin", "ahslc"], "cmd": ["md", "std", "comm", "code", "ctl", "cod", "gen", "acl", "call", "cm", "dc", "cd", "c", "pkg", "wo", "msg", "module", "callback", "x", "config", "cr", "gz", "cb", "prefix", "col", "ct", "act", "css", "method", "cmp", "buf", "cfg", "hw", "phy", "grad", "gn", "vc", "cms", "command", "scl", "cl", "Cmd", "cli", "clean", "custom", "cc", "ctx", "cp", "client", "setup", "cf", "cn", "ctr", "req", "help", "addr", "ctrl", "conn", "qq", "pipe", "func", "cpp", "ck", "cookie", "core", "nc", "cgi"], "px": ["yp", "pp", "zx", "xx", "cm", "pa", "ss", "pty", "pt", "p", "pixel", "ix", "x", "xc", "config", "pointer", "py", "lex", "ct", "prefix", "vt", "cus", "ux", "css", "plugin", "mx", "wx", "fc", "xy", "amp", "ff", "val", "padding", "cpu", "ico", "cel", "kit", "pl", "cc", "ctx", "ci", "pm", "cp", "fx", "ffff", "cas", "xxx", "pex", "wp", "xp", "fp", "cpp", "pos", "pi", "cs", "pc"], "tx": ["temp", "txt", "zx", "xx", "cd", "pt", "context", "x", "data", "test", "text", "ds", "cr", "lex", "ax", "cross", "ps", "ux", "push", "pc", "tr", "rw", "wx", "buf", "trans", "loc", "tri", "nt", "ctx", "cf", "fx", "rc", "ctr", "shape", "req", "cas", "xs", "addr", "pex", "xxx", "rt", "tc", "TX", "src", "t", "fp", "index", "q", "Tx", "hea", "pull", "r", "ex", "xa"], "rx": ["xxxxxxxx", "ru", "zx", "rs", "xf", "sr", "rd", "sw", "x", "rf", "xc", "rb", "vr", "cr", "rin", "lex", "prefix", "reader", "ux", "pc", "sync", "rw", "mx", "rss", "wx", "buf", "rh", "rl", "rm", "lr", "loc", "ctx", "fx", "rc", "req", "addr", "ry", "rt", "xp", "TX", "src", "row", "r", "ex", "rr", "rex"], "ptr": ["ref", "pp", "temp", "code", "sr", "p", "pt", "pg", "context", "dr", "mount", "x", "vr", "pointer", "cr", "address", "push", "inst", "port", "xt", "tr", "proc", "pad", "rw", "sth", "buf", "patch", "padding", "tmp", "fx", "eth", "loc", "fif", "offset", "ctx", "cp", "cf", "ffff", "alloc", "ctr", "Ptr", "req", "addr", "length", "rc", "buff", "cache", "rect", "pend", "rt", "po", "xp", "pr", "ext", "src", "fp", "index", "plug", "wr", "prot", "tty", "pos", "fd", "pc"]}}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n", "idx": 25865, "substitutes": {"opaque": ["openmA", "copbuffer", "opusmA", "ospaques", " opaques", " opmA", "ospbuffer", "opaco", "opaques", "opusacity", "ospaque", "openacity", "copaques", "opusaque", "openaya", "opaya", "opbuffer", " opacity", " opaco", "opusaya", "openaque", "opacity", "ospaco", "opmA", " opbuffer", "copaco", " opaya", "copaque"], "addr": ["ref", "code", "p", "fd", "asm", "data", "x", "base", "pointer", "ad", "align", "address", "prefix", "mac", "port", "url", "pad", "buf", "point", "amp", "adr", "bridge", "cmd", "val", "start", "eth", "ord", "offset", "slot", "mode", "ctx", "size", "rc", "hop", "ptr", "amd", "rt", "ext", "part", "rx", "aud", "prot", "alt", "host", "src", "index", "ace", "attr", "nc", "pos", "len", "pc", "layer"], "g": ["gu", "vg", "gen", "w", "gas", "i", "p", "m", "c", "pg", "gin", "d", "msg", "ge", "eg", "gb", "sg", "gate", "u", "e", "gs", "cfg", "gi", "gn", "tg", "s", "group", "ig", "mg", "gp", "ga", "rg", "game", "G", "greg", "gg", "f", "gc", "go", "agg", "bg", "erg", "v", "gm"]}}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    int64_t size;\n\n    AVIOContext *pb  = s->pb;\n\n    WAVContext    *wav = s->priv_data;\n\n    AVStream *st;\n\n    uint8_t guid[16];\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_riff, 16))\n\n        return -1;\n\n\n\n    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */\n\n        return -1;\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_wave, 16)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find wave guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    size = find_guid(pb, guid_fmt);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find fmt guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* subtract chunk header size - normal wav file doesn't count it */\n\n    ff_get_wav_header(pb, st->codec, size - 24);\n\n    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);\n\n\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n\n\n    av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n    size = find_guid(pb, guid_data);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find data guid\\n\");\n\n        return -1;\n\n    }\n\n    wav->data_end = avio_tell(pb) + size - 24;\n\n    wav->w64      = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 25868, "substitutes": {"s": ["S", "comments", "sc", "ses", "rs", "sys", "ss", "p", "b", "sn", "c", "bis", "ns", "server", "se", "i", "ts", "or", "sq", "ds", "ans", "ps", "sg", "ks", "sync", "self", "su", "is", "bs", "e", "es", "gs", "south", "stats", "sp", "session", "spec", "less", "sv", "sts", "si", "sym", "os", "stat", "sb", "services", "sa", "sing", "xs", "as", "ls", "f", "service", "qs", "js", "n", "t", "an", "v", "sl", "r", "sf", "in", "ops", "ssl", "cs", "g"], "ap": ["pp", "pa", "np", "api", "prop", "ad", "am", "att", "dp", "ams", "mp", "al", "sp", "hp", "cap", "ai", "cp", "pac", "wp", "array", "au", "arp", "tp", "AP", "pi", "aps", "attr", "ac", "pc"], "size": ["use", "z", "date", "name", "time", "or", "sync", "num", "any", "li", "SIZE", "fee", "external", "six", "zip", "go", "content", "who", "ice", "desc", "code", "body", "cm", "gap", "day", "ize", "p", "c", "empty", "sized", "x", "sum", "en", "sea", "address", "speed", "form", "ci", "cache", "shape", "now", "value", "large", "len", "ce", "g", "esc", "args", "sn", "function", "send", "capacity", "Size", "e", "small", "offset", "grade", "sec", "length", "ng", "count", "source", "page", "i", "weight", "member", "unit", "loc", "si", "scale", "rc", "handle", "ny", "ui"], "pb": ["summary", "pp", "uf", "pa", "np", "p", "b", "parser", "pg", "wb", "pkg", "ppa", "lb", "cv", "xb", "api", "rb", "ab", "prop", "bh", "jp", "gb", "cb", "bf", "bc", "dp", "prof", "bp", "platform", "proc", "plugin", "typ", "db", "mp", "PB", "hub", "rob", "fc", "hp", "aph", "pd", "eb", "pl", "verb", "orp", "ctx", "cp", "sb", "fb", "ub", "pm", "pac", "wp", "lp", "pro", "tc", "prot", "tp", "fp", "cpp", "bm", "bps", "vp", "pc"], "wav": ["acc", "waves", "aver", "kw", "wan", "w", "writers", "af", "uc", "wb", "wo", "cv", "sw", "wave", "music", "www", "av", "voice", "craft", "WA", "rw", "mp", "buf", "mpeg", "aux", "hw", "WS", "audio", "sound", "wcs", "wl", "aws", "avi", "web", "wm", "xml", "wp", "wal", "aw", "aaaa", "wt", "ave", "wi", "wa", "voc", "writer"], "st": ["rest", "std", "sc", "obj", "fe", "th", "ST", "ft", "ss", "sn", "p", "pt", "c", "se", "sw", "sam", "ld", "ste", "cr", "ct", "so", "ast", "inst", "St", "fr", "sth", "stress", "sp", "ess", "td", "sta", "nd", "str", "start", "stim", "sts", "cl", "art", "nt", "sb", "est", "ist", "sa", "ost", "stream", "stage", "src", "t", "sd", "be", "sl", "stab", "r", "sf", "irst", "sh"], "guid": ["bugkid", "guiden", "guision", "aguider", "uniqueid", " guider", "acide", "gamide", "gamid", "grID", "squID", "acID", "gukid", "ruid", "squid", "acision", "iuide", " guidate", "bugiden", "bugide", "guider", "iuid", "guidate", "acid", "uuid", "grid", "guaid", "guide", "Guide", " guaid", "uuidate", "bugid", "aguid", " guide", "squision", "GuID", "Gukid", "squide", "uuID", "uniqueider", "ruide", "guID", "iuidate", " guID", "gamiden", "uniqueaid", "aguID", "aguaid", "Guiden", "iuID", "Guids", "gride", "ruID", "uniqueID", "gamkid", "Guision", "Guid", "guids", "grids", "uuide", "ruids"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 25869, "substitutes": {"src": ["rest", "sc", "slice", "img", "rb", "config", "sq", "gb", "cur", "cb", "inst", "sync", "supp", "url", "sth", "rob", "buf", "sur", "scl", "input", "rl", "http", "start", "loc", "sub", "st", "sel", "ctx", "sb", "gl", "rc", "req", "sup", "dist", "comp", "rect", "source", "stack", "dest", "sl", "ssl"], "dst": ["sST", "ssts", "idST", "sst", "wbl", " dsts", "wsts", "dsts", "lsts", "lST", "DST", "sbl", "dST", "Dsts", "Ddest", "lst", "dbl", "iddest", "wST", "ddest", " dST", "lbl", " ddest", "wst", "idsts", "Dst", "idst"], "src_size": ["src_Size", " src_Size", " src_scale", " src_address", "src_address", "src_scale"], "i": ["abi", "k", "p", "m", "c", "info", "d", "clip", "api", "adi", "ti", "mi", "phi", "qi", "it", "ri", "io", "id", "ui", "u", "is", "e", "li", "o", "gi", "ji", "zi", "multi", "xi", "uri", "ii", "bi", "si", "cli", "ini", "ni", "ai", "di", "ci", "eni", "I", "f", "y", "oi", "n", "j", "index", "a", "ori", "v", "iu", "pi", "mu", "init", "l", "hi", "ami"], "b": ["k", "w", "p", "m", "c", "wb", "d", "ob", "bb", "x", "rb", "ab", "br", "gb", "u", "db", "e", "o", "s", "bi", "sb", "fb", "abb", "B", "f", "y", "n", "a", "bg", "reb", "v", "l", "big"], "g": ["gu", "k", "w", "m", "p", "c", "pg", "d", "ge", "x", "gb", "gam", "gr", "sg", "u", "e", "gs", "gi", "o", "gn", "s", "group", "gp", "ga", "rg", "G", "gh", "h", "gg", "f", "y", "n", "a", "bg", "q", "v", "gre", "gm", "l", "big"], "r": ["rs", "k", "sr", "w", "er", "p", "m", "c", "d", "x", "rb", "br", "gr", "u", "e", "o", "R", "rl", "s", "re", "rc", "rg", "ur", "ro", "h", "f", "nr", "pr", "n", "j", "t", "a", "q", "v", "rr", "range", "l"], "rgb": ["rsgb", "argb", " rgg", "wbg", "argg", "rgg", " rg", "rba", "srgo", "rcgp", "cgg", "rga", "brgg", "hbb", "brpi", "nrgd", "lgb", "cgb", "arbb", " rbg", "hbg", "wbb", "rgd", "rcgb", "argp", "rbba", "nrgb", "rcg", "rbgb", "srgd", "rgo", "lgd", "rsgg", "rbgo", "brbb", "lga", "hgg", "rpi", "rbg", "rgp", "rg", " rga", "wgg", "arg", "rcgg", "brgb", "wgb", "lgg", " rgp", "cgd", "arpi", "rspi", "rsbb", " rbb", "rbb", "hgb", "nrba", " rgd", "rbgd", "nrgo", "srgb", "cga", "srba"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872, "substitutes": {"job": ["node", "seq", "section", "page", "b", "server", "batch", "image", "manager", "ob", "module", "queue", "base", "cb", "plugin", "db", "line", "feed", "project", "work", "command", "session", "run", "group", "worker", "order", "item", "game", "child", "j", "row", "route", "event", "Job", "block", "connection", "lock", "layer"], "x": ["height", "code", "xx", "z", "i", "p", "b", "dy", "c", "name", "m", "d", "image", "px", "data", "address", "X", "id", "wx", "point", "xy", "work", "lat", "path", "xi", "dx", "loc", "ick", "shape", "win", "f", "rx", "n", "index", "t", "a", "v", "r", "pos", "ex", "l"], "y": ["z", "yi", "i", "p", "b", "sy", "oy", "dy", "ya", "ay", "d", "yt", "ies", "c", "wy", "py", "ye", "type", "cy", "ym", "vy", "yo", "ys", "ey", "xy", "Y", "zy", "ry", "ny", "j", "year", "t", "a", "ty", "yy"], "w": ["height", "ow", "k", "z", "i", "p", "b", "m", "c", "d", "sw", "weight", "wh", "rw", "u", "wx", "hw", "o", "work", "max", "fw", "wd", "ew", "length", "win", "wid", "f", "wt", "n", "W", "a", "wa", "t", "q", "v", "r", "ex", "l", "sh"], "h": ["height", "hm", "ht", "k", "z", "i", "p", "b", "m", "c", "d", "H", "u", "depth", "e", "home", "o", "hw", "dh", "rh", "hs", "size", "gh", "f", "n", "t", "host", "q", "v", "r", "l", "hi", "ph", "oh", "sh"], "entry": ["import", "element", " Entry", "ie", "section", "info", "server", "cat", "image", "module", "ge", "insert", "data", "queue", "connection", "or", "base", "pointer", "next", "add", "export", "member", "reader", "it", "end", "id", "line", "key", "link", "Entry", "e", "feed", "step", "path", "set", "start", "inner", "ent", "enter", "object", "offset", "si", "parent", "inc", "item", "rc", "ry", "update", "array", "lc", "service", "child", "index", "row", "inter", "event", "route", "post", "desc"]}}
{"project": "qemu", "commit_id": "54f254f973a1b2ed0f3571390f4de060adfe23e8", "target": 0, "func": "static void uhci_async_complete_packet(USBPacket * packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCI_QH qh;\n\n    UHCI_TD td;\n\n    uint32_t link;\n\n    uint32_t old_td_ctrl;\n\n    uint32_t val;\n\n    uint32_t frame_addr;\n\n    int ret;\n\n\n\n    /* Handle async isochronous packet completion */\n\n    frame_addr = s->async_frame_addr;\n\n    if (frame_addr) {\n\n        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n        le32_to_cpus(&link);\n\n\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret == 2) {\n\n            s->async_frame_addr = frame_addr;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            val = cpu_to_le32(td.link);\n\n            cpu_physical_memory_write(frame_addr,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25925, "substitutes": {"packet": ["compets", "octets", "octet", "viewets", "packacket", "compacket", "packets", "viewer", "compet", "comper", "viewacket", "viewet", "octacket", "octer", "packer"], "opaque": ["opec", "opusque", "ocaque", "ocque", " opec", "ocayne", "opayne", "opc", "OPec", "opusaque", "OPacs", " opacs", " opayne", "opusec", " opque", "ipec", "ipaque", "ipc", "ipacs", "opque", "OPc", " opc", "ocec", "OPaque", "opacs", "opusayne"], "s": ["S", "summary", "rs", "ses", "socket", "sys", "scope", "ss", "p", "b", "server", "c", "ns", "se", "single", "ts", "storage", "sq", "ps", "sg", "state", "secondary", "states", "instance", "sync", "self", "su", "is", "e", "cs", "gs", "stats", "ssh", "o", "site", "sets", "sie", "share", "http", "session", "spec", "si", "os", "sb", "client", "services", "utils", "sa", "ls", "f", "service", "slave", "n", "t", "sl", "g", "sf", "ops", "settings", "ssl", "sv", "params", "side"], "qh": ["questionhr", "sqd", "dqh", " qe", "qqsh", "qha", "quH", "qhd", "qhr", "idh", "qbh", "iqh", "kd", "Qe", "quh", " qhd", "qqbh", "qH", "qqh", " qc", "questd", "quhy", "qr", "qud", " qH", "qhm", "qrh", "sqh", "que", "questionh", "iqhr", "quc", "khm", "questrh", "quha", "questhy", "qsh", "dqH", "qur", "qd", "quhm", "qc", "dqbh", "iqc", "questhi", "questr", "qhy", "qe", "dqsh", "quhi", "idd", "QH", "Qbh", "kh", "sqr", "qqH", "khs", "quhs", "Qh", "Qc", "questha", "questionc", " qhy", " qrh", "qurh", " qha", " qhr", "sqhi", "iqhd", "questionhd", "Qsh", "qhi", "qhs", "questh", "idhm", "idhs"], "td": ["md", "dll", "std", "txt", "ctl", "cod", "TD", "BT", "butt", "th", "dc", "primary", "cd", "pt", "rd", "cz", "d", "hd", "tm", "ld", "ds", "ad", "config", "bd", "gt", "tif", "gb", "bl", "dd", "ud", "tr", "typ", "db", "lf", "fc", "nil", "TB", "LD", "pd", "dh", "nd", "dat", "pb", "ff", "dl", "pl", "di", "dt", "wd", "sel", "PD", "nt", "lt", "sb", "SD", "tab", "elt", "tn", "dial", "tf", "tc", "sd", "od", "sl", " dd", "ssl", "fd", "table", "dn", " TD", "layer"], "link": ["chain", "ref", "call", "frame", "base", "ld", "label", "cross", "bug", "sync", "url", "self", "lf", "li", "set", "lib", "dev", "model", "lag", "level", "list", "match", "pack", "slice", "user", "ink", "address", "check", "cmp", "line", "feed", "cell", "path", "di", "group", "ci", "target", "cache", "focus", "block", "len", "load", "light", "data", "delay", "error", "open", "hip", "follow", "connect", "stat", "cp", "reply", "length", "source", "lo", "reg", "ck", "ssl", "control", "connection", "tag", "lock", "linked", "info", "Link", "image", "weight", "read", "style", "lex", "type", "dd", "write", "id", "rel", "layout", "loc", "links", "local", "ln", "channel", "co", "field", "handle", "loop", "comment", "slave", "network", "child", "index", "conn", "route", "ind", "ace", "l"], "old_td_ctrl": ["old_dd_ctrl", "old_td_trl", "old_dd_trl", "old_sd_control", "old_td_lc", "old_td__control", "old_sd_ctr", "old_dd_control", "old_dd_lc", "old_sd_Ctrl", "old_td__trl", "old_td_control", "old_sd_ctrl", "old_td__Ctrl", "old_sd_trl", "old_td_ctr", "old_td_Ctrl", "old_td__ctrl", "old_sd_controller", "old_td_controller"], "val": ["ref", "call", "base", "vals", "ee", "el", "li", "valid", "lit", "fl", "rot", "cal", "cond", "serv", "Val", "part", "vol", "b", "play", "bo", "x", "col", "def", "live", "store", "key", "il", "update", "value", "sl", "len", "put", "bin", "pt", "eval", "data", "var", "delay", "fail", "bl", "all", "al", "err", "la", "change", "stat", "arg", "count", "alt", "seq", "VAL", "doc", "py", "pass", "bal", "unit", "rel", "lay", "ol", "ul", "loc", "slot", "sel", "sol", "local", "fat", "win", "elt", "index", "v", "result"], "frame_addr": ["frame_grad", "frame67len", "frame__order", "frame64info", " frame_len", "frame_callback", "frame64addr", " frame_grad", " frame_data", "frame_order", "frame_align", " frame_info", "frameamdata", " frame_callback", "frame_ptr", "frame__align", "frameacaddr", "frame__address", "framekaddr", "framekalign", " frame_align", " frame_index", "frame67url", "frameingcallback", "frame_url", "frame_host", "frameamaddress", "frame_address", "framekaddress", "frame_index", " frame_order", "frame67addr", "frame64ptr", "frame64address", "frame64callback", "frameacaddress", "framekorder", "frameamaddr", "frameachost", "frameingaddress", "frame_len", "frame_info", "frameacgrad", " frame_host", "frame_data", "frameamurl", " frame_ptr", "frame67address", "frame__addr", "frame64index", "frameingaddr", "frameinginfo", " frame_address", " frame_url"], "ret": ["ref", "ft", "res", "final", " RET", "cat", "flag", "back", "cur", "success", "col", "att", "opt", " Ret", "def", "rep", "rets", "al", "mem", "rl", "valid", "bit", "mt", "det", "rev", "lit", "RET", "re", "nt", "sel", "lt", "reply", "let", "sec", "rc", "arg", "Ret", "rt", "part", "alt", "reg", "resp", "match", "result", "len", "gt", "fun"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n", "idx": 25932, "substitutes": {"req": ["exec", "load", "requ", "ref", "seq", "call", "iq", "obj", "sem", "low", "pkg", "dr", "msg", "rf", "queue", "qt", "ready", "cur", "request", "rb", "next", "jp", "sq", "cb", "gr", "def", "push", "loader", "fr", "proc", "rec", "cmp", "grad", "str", "err", "progress", "peer", "ctx", "ctr", "arg", "comp", "mod", "ext", "dep", "f", "rx", "pull", "list", "crit", "q", "require", "r", "dq", "org", "rr", "hr", "desc"], "bs": ["ses", "ss", "bis", "bas", "ns", "ts", "bb", "ds", "us", "ps", "BS", "bc", "outs", "bu", "gs", "bal", "bi", "os", "sb", "as", "bid", "ls", "fs", "bytes", "bps", "bt", "cs"], "serialising_in_flight": ["serialising_out_flight", "serialising_in_progress", "serialising_out_queue", "serialising_in_process", "serialising_in_queue", "serialising_out_progress", "serialising_out_process"]}}
{"project": "FFmpeg", "commit_id": "ac94b8bcc6cdba000ada0c84b4c287f7f37f2384", "target": 0, "func": "static int adpcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    ADPCMDecodeContext *c = avctx->priv_data;\n\n    ADPCMChannelStatus *cs;\n\n    int n, m, channel, i;\n\n    int block_predictor[2];\n\n    short *samples;\n\n    short *samples_end;\n\n    const uint8_t *src;\n\n    int st; /* stereo */\n\n\n\n    /* DK3 ADPCM accounting variables */\n\n    unsigned char last_byte = 0;\n\n    unsigned char nibble;\n\n    int decode_top_nibble_next = 0;\n\n    int diff_channel;\n\n\n\n    /* EA ADPCM state variables */\n\n    uint32_t samples_in_chunk;\n\n    int32_t previous_left_sample, previous_right_sample;\n\n    int32_t current_left_sample, current_right_sample;\n\n    int32_t next_left_sample, next_right_sample;\n\n    int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n\n    uint8_t shift_left, shift_right;\n\n    int count1, count2;\n\n    int coeff[2][2], shift[2];//used in EA MAXIS ADPCM\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    //should protect all 4bit ADPCM variants\n\n    //8 is needed for CODEC_ID_ADPCM_IMA_WAV with 2 channels\n\n    //\n\n    if(*data_size/4 < buf_size + 8)\n\n        return -1;\n\n\n\n    samples = data;\n\n    samples_end= samples + *data_size/2;\n\n    *data_size= 0;\n\n    src = buf;\n\n\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_IMA_QT:\n\n        n = buf_size - 2*avctx->channels;\n\n        for (channel = 0; channel < avctx->channels; channel++) {\n\n            int16_t predictor;\n\n            int step_index;\n\n            cs = &(c->status[channel]);\n\n            /* (pppppp) (piiiiiii) */\n\n\n\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n\n            predictor = AV_RB16(src);\n\n            step_index = predictor & 0x7F;\n\n            predictor &= 0xFF80;\n\n\n\n            src += 2;\n\n\n\n            if (cs->step_index == step_index) {\n\n                int diff = (int)predictor - cs->predictor;\n\n                if (diff < 0)\n\n                    diff = - diff;\n\n                if (diff > 0x7f)\n\n                    goto update;\n\n            } else {\n\n            update:\n\n                cs->step_index = step_index;\n\n                cs->predictor = predictor;\n\n            }\n\n\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n\n\n            samples = (short*)data + channel;\n\n\n\n            for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n\n                samples += avctx->channels;\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n\n                samples += avctx->channels;\n\n                src ++;\n\n            }\n\n        }\n\n        if (st)\n\n            samples--;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WAV:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n//        samples_per_block= (block_align-4*chanels)*8 / (bits_per_sample * chanels) + 1;\n\n\n\n        for(i=0; i<avctx->channels; i++){\n\n            cs = &(c->status[i]);\n\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n\n\n\n            cs->step_index = *src++;\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n\n        }\n\n\n\n        while(src < buf + buf_size){\n\n            for(m=0; m<4; m++){\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] & 0x0F, 3);\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] >> 4  , 3);\n\n                src++;\n\n            }\n\n            src += 4*st;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_4XM:\n\n        cs = &(c->status[0]);\n\n        c->status[0].predictor= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].predictor= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].step_index= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].step_index= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        if (cs->step_index < 0) cs->step_index = 0;\n\n        if (cs->step_index > 88) cs->step_index = 88;\n\n\n\n        m= (buf_size - (src - buf))>>st;\n\n        for(i=0; i<m; i++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] & 0x0F, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] & 0x0F, 4);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] >> 4, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] >> 4, 4);\n\n        }\n\n\n\n        src += m<<st;\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_MS:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n        n = buf_size - 7 * avctx->channels;\n\n        if (n < 0)\n\n            return -1;\n\n        block_predictor[0] = av_clip(*src++, 0, 6);\n\n        block_predictor[1] = 0;\n\n        if (st)\n\n            block_predictor[1] = av_clip(*src++, 0, 6);\n\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n\n        if (st){\n\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[0]];\n\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[0]];\n\n        c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[1]];\n\n        c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[1]];\n\n\n\n        c->status[0].sample1 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n\n        c->status[0].sample2 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n\n\n\n        *samples++ = c->status[0].sample2;\n\n        if (st) *samples++ = c->status[1].sample2;\n\n        *samples++ = c->status[0].sample1;\n\n        if (st) *samples++ = c->status[1].sample1;\n\n        for(;n>0;n--) {\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n\n            src ++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK4:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        c->status[0].predictor  = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = *src++;\n\n        src++;\n\n        *samples++ = c->status[0].predictor;\n\n        if (st) {\n\n            c->status[1].predictor  = (int16_t)bytestream_get_le16(&src);\n\n            c->status[1].step_index = *src++;\n\n            src++;\n\n            *samples++ = c->status[1].predictor;\n\n        }\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK3:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        if(buf_size + 16 > (samples_end - samples)*3/8)\n\n            return -1;\n\n\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n\n        c->status[0].step_index = src[14];\n\n        c->status[1].step_index = src[15];\n\n        /* sign extend the predictors */\n\n        src += 16;\n\n        diff_channel = c->status[1].predictor;\n\n\n\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n\n         * the buffer is consumed */\n\n        while (1) {\n\n\n\n            /* for this algorithm, c->status[0] is the sum channel and\n\n             * c->status[1] is the diff channel */\n\n\n\n            /* process the first predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the diff channel predictor */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n\n\n            /* process the first pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n\n\n            /* process the second predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the second pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_ISS:\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 0);\n\n        c->status[0].step_index = src[2];\n\n        src += 4;\n\n        if(st) {\n\n            c->status[1].predictor  = (int16_t)AV_RL16(src + 0);\n\n            c->status[1].step_index = src[2];\n\n            src += 4;\n\n        }\n\n\n\n        while (src < buf + buf_size) {\n\n            uint8_t v1, v2;\n\n            uint8_t v = *src++;\n\n            /* nibbles are swapped for mono */\n\n            if (st) {\n\n                v1 = v >> 4;\n\n                v2 = v & 0x0F;\n\n            } else {\n\n                v2 = v >> 4;\n\n                v1 = v & 0x0F;\n\n            }\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_XA:\n\n        while (buf_size >= 128) {\n\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n\n                avctx->channels);\n\n            src += 128;\n\n            samples += 28 * 8;\n\n            buf_size -= 128;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n        samples_in_chunk = bytestream_get_le32(&src) >> (1-st);\n\n\n\n        if (samples_in_chunk > buf_size-4-(8<<st)) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].step_index = bytestream_get_le32(&src);\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].predictor  = bytestream_get_le32(&src);\n\n\n\n        for (; samples_in_chunk; samples_in_chunk--, src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n        for (; src < buf+buf_size; src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA:\n\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n\n           each coding 28 stereo samples. */\n\n        if (buf_size < 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        samples_in_chunk = AV_RL32(src);\n\n        if (samples_in_chunk / 28 > (buf_size - 12) / 30) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid frame\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        src += 4;\n\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n\n\n\n        for (count1 = 0; count1 < samples_in_chunk/28;count1++) {\n\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n\n            src++;\n\n\n\n            shift_left  = (*src >> 4  ) + 8;\n\n            shift_right = (*src & 0x0F) + 8;\n\n            src++;\n\n\n\n            for (count2 = 0; count2 < 28; count2++) {\n\n                next_left_sample  = (int32_t)((*src & 0xF0) << 24) >> shift_left;\n\n                next_right_sample = (int32_t)((*src & 0x0F) << 28) >> shift_right;\n\n                src++;\n\n\n\n                next_left_sample = (next_left_sample +\n\n                    (current_left_sample * coeff1l) +\n\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n\n                next_right_sample = (next_right_sample +\n\n                    (current_right_sample * coeff1r) +\n\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n\n\n                previous_left_sample = current_left_sample;\n\n                current_left_sample = av_clip_int16(next_left_sample);\n\n                previous_right_sample = current_right_sample;\n\n                current_right_sample = av_clip_int16(next_right_sample);\n\n                *samples++ = (unsigned short)current_left_sample;\n\n                *samples++ = (unsigned short)current_right_sample;\n\n            }\n\n        }\n\n\n\n        if (src - buf == buf_size - 2)\n\n            src += 2; // Skip terminating 0x0000\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n\n        for(channel = 0; channel < avctx->channels; channel++) {\n\n            for (i=0; i<2; i++)\n\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n\n            shift[channel] = (*src & 0x0F) + 8;\n\n            src++;\n\n        }\n\n        for (count1 = 0; count1 < (buf_size - avctx->channels) / avctx->channels; count1++) {\n\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n\n                for(channel = 0; channel < avctx->channels; channel++) {\n\n                    int32_t sample = (int32_t)(((*(src+channel) >> i) & 0x0F) << 0x1C) >> shift[channel];\n\n                    sample = (sample +\n\n                             c->status[channel].sample1 * coeff[channel][0] +\n\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n\n                    c->status[channel].sample2 = c->status[channel].sample1;\n\n                    c->status[channel].sample1 = av_clip_int16(sample);\n\n                    *samples++ = c->status[channel].sample1;\n\n                }\n\n            }\n\n            src+=avctx->channels;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_R1:\n\n    case CODEC_ID_ADPCM_EA_R2:\n\n    case CODEC_ID_ADPCM_EA_R3: {\n\n        /* channel numbering\n\n           2chan: 0=fl, 1=fr\n\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n\n        int32_t previous_sample, current_sample, next_sample;\n\n        int32_t coeff1, coeff2;\n\n        uint8_t shift;\n\n        unsigned int channel;\n\n        uint16_t *samplesC;\n\n        const uint8_t *srcC;\n\n        const uint8_t *src_end = buf + buf_size;\n\n\n\n        samples_in_chunk = (big_endian ? bytestream_get_be32(&src)\n\n                                       : bytestream_get_le32(&src)) / 28;\n\n        if (samples_in_chunk > UINT32_MAX/(28*avctx->channels) ||\n\n            28*samples_in_chunk*avctx->channels > samples_end-samples) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n\n                                         : bytestream_get_le32(&src))\n\n                           + (avctx->channels-channel-1) * 4;\n\n\n\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n\n            srcC  = src + offset;\n\n            samplesC = samples + channel;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n\n            } else {\n\n                current_sample  = c->status[channel].predictor;\n\n                previous_sample = c->status[channel].prev_sample;\n\n            }\n\n\n\n            for (count1=0; count1<samples_in_chunk; count1++) {\n\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n\n                    srcC++;\n\n                    if (srcC > src_end - 30*2) break;\n\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n\n\n\n                    for (count2=0; count2<28; count2++) {\n\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                } else {\n\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n\n                    shift = (*srcC++ & 0x0F) + 8;\n\n\n\n                    if (srcC > src_end - 14) break;\n\n                    for (count2=0; count2<28; count2++) {\n\n                        if (count2 & 1)\n\n                            next_sample = (int32_t)((*srcC++ & 0x0F) << 28) >> shift;\n\n                        else\n\n                            next_sample = (int32_t)((*srcC   & 0xF0) << 24) >> shift;\n\n\n\n                        next_sample += (current_sample  * coeff1) +\n\n                                       (previous_sample * coeff2);\n\n                        next_sample = av_clip_int16(next_sample >> 8);\n\n\n\n                        previous_sample = current_sample;\n\n                        current_sample  = next_sample;\n\n                        *samplesC = current_sample;\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n\n                c->status[channel].predictor   = current_sample;\n\n                c->status[channel].prev_sample = previous_sample;\n\n            }\n\n        }\n\n\n\n        src = src + buf_size - (4 + 4*avctx->channels);\n\n        samples += 28 * samples_in_chunk * avctx->channels;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_EA_XAS:\n\n        if (samples_end-samples < 32*4*avctx->channels\n\n            || buf_size < (4+15)*4*avctx->channels) {\n\n            src += buf_size;\n\n            break;\n\n        }\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int coeff[2][4], shift[4];\n\n            short *s2, *s = &samples[channel];\n\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n\n                for (i=0; i<2; i++)\n\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n\n                shift[n] = (src[2]&0x0F) + 8;\n\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n\n            }\n\n\n\n            for (m=2; m<32; m+=2) {\n\n                s = &samples[m*avctx->channels + channel];\n\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n\n                        int level = (int32_t)((*src & (0xF0>>i)) << (24+i)) >> shift[n];\n\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        samples += 32*4*avctx->channels;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_AMV:\n\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = bytestream_get_le16(&src);\n\n\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n            src+=4;\n\n\n\n        while (src < buf + buf_size) {\n\n            char hi, lo;\n\n            lo = *src & 0x0F;\n\n            hi = *src >> 4;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n                FFSWAP(char, hi, lo);\n\n\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                lo, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                hi, 3);\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_CT:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SBPRO_4:\n\n    case CODEC_ID_ADPCM_SBPRO_3:\n\n    case CODEC_ID_ADPCM_SBPRO_2:\n\n        if (!c->status[0].step_index) {\n\n            /* the first byte is a raw sample */\n\n            *samples++ = 128 * (*src++ - 0x80);\n\n            if (st)\n\n              *samples++ = 128 * (*src++ - 0x80);\n\n            c->status[0].step_index = 1;\n\n        }\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n\n            while (src < buf + buf_size) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] >> 4, 4, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x0F, 4, 0);\n\n                src++;\n\n            }\n\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n\n            while (src < buf + buf_size && samples + 2 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 5        , 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x07, 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] & 0x03, 2, 0);\n\n                src++;\n\n            }\n\n        } else {\n\n            while (src < buf + buf_size && samples + 3 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 6        , 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    (src[0] >> 4) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x03, 2, 2);\n\n                src++;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SWF:\n\n    {\n\n        GetBitContext gb;\n\n        const int *table;\n\n        int k0, signmask, nb_bits, count;\n\n        int size = buf_size*8;\n\n\n\n        init_get_bits(&gb, buf, size);\n\n\n\n        //read bits & initial values\n\n        nb_bits = get_bits(&gb, 2)+2;\n\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n\n        table = swf_index_tables[nb_bits-2];\n\n        k0 = 1 << (nb_bits-2);\n\n        signmask = 1 << (nb_bits-1);\n\n\n\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n\n                c->status[i].step_index = get_bits(&gb, 6);\n\n            }\n\n\n\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n\n                int i;\n\n\n\n                for (i = 0; i < avctx->channels; i++) {\n\n                    // similar to IMA adpcm\n\n                    int delta = get_bits(&gb, nb_bits);\n\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n\n                    int k = k0;\n\n\n\n                    do {\n\n                        if (delta & k)\n\n                            vpdiff += step;\n\n                        step >>= 1;\n\n                        k >>= 1;\n\n                    } while(k);\n\n                    vpdiff += step;\n\n\n\n                    if (delta & signmask)\n\n                        c->status[i].predictor -= vpdiff;\n\n                    else\n\n                        c->status[i].predictor += vpdiff;\n\n\n\n                    c->status[i].step_index += table[delta & (~signmask)];\n\n\n\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n\n\n\n                    *samples++ = c->status[i].predictor;\n\n                    if (samples >= samples_end) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        src += buf_size;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_YAMAHA:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_THP:\n\n    {\n\n        int table[2][16];\n\n        unsigned int samplecnt;\n\n        int prev[2][2];\n\n        int ch;\n\n\n\n        if (buf_size < 80) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        src+=4;\n\n        samplecnt = bytestream_get_be32(&src);\n\n\n\n        for (i = 0; i < 32; i++)\n\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        /* Initialize the previous sample.  */\n\n        for (i = 0; i < 4; i++)\n\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        if (samplecnt >= (samples_end - samples) /  (st + 1)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (ch = 0; ch <= st; ch++) {\n\n            samples = (unsigned short *) data + ch;\n\n\n\n            /* Read in every sample for this channel.  */\n\n            for (i = 0; i < samplecnt / 14; i++) {\n\n                int index = (*src >> 4) & 7;\n\n                unsigned int exp = 28 - (*src++ & 15);\n\n                int factor1 = table[ch][index * 2];\n\n                int factor2 = table[ch][index * 2 + 1];\n\n\n\n                /* Decode 14 samples.  */\n\n                for (n = 0; n < 14; n++) {\n\n                    int32_t sampledat;\n\n                    if(n&1) sampledat=  *src++    <<28;\n\n                    else    sampledat= (*src&0xF0)<<24;\n\n\n\n                    sampledat = ((prev[ch][0]*factor1\n\n                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);\n\n                    *samples = av_clip_int16(sampledat);\n\n                    prev[ch][1] = prev[ch][0];\n\n                    prev[ch][0] = *samples++;\n\n\n\n                    /* In case of stereo, skip one sample, this sample\n\n                       is for the other channel.  */\n\n                    samples += st;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* In the previous loop, in case stereo is used, samples is\n\n           increased exactly one time too often.  */\n\n        samples -= st;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 25936, "substitutes": {"avctx": ["ovctx", "avalconv", "avclient", "navcontext", "afpkg", "ovpkg", "afclient", "AVcontext", "Avcmp", "AVcmp", "avalcmp", "AVconfig", "Avcf", "afconv", "evcf", "avcmp", "evcontext", "avqa", "AVloc", "awcontext", "awctx", "avcontext", "avalcontext", " avcmp", "AVcf", "afcf", "AVconv", "afcontext", "afctx", "avconfig", "evctx", "ovcontext", "avalctx", "avpkg", " avcf", "avloc", "ovcf", "avconv", "afxc", "Avcontext", "awclient", "navconfig", " avxc", "navloc", "AVctx", "AVxc", " avqa", "afqa", " avcontext", "avxc", "awqa", " avclient", "afloc", "navctx", "afcmp", "avcf", "Avctx", "evpkg", "afconfig"], "data": ["load", "Data", "body", "package", "slice", "bin", "batch", "frame", "empty", "image", "d", "module", "buffer", "queue", "base", "media", "blocks", "config", "next", "reader", "pad", "raw", "open", "input", "dat", "start", "multi", "zero", "sample", "one", "new", "client", "size", "video", "cache", "first", "block", "buff", "array", "window", "source", "bytes", "da", "a", "DATA", "results", "content", "database", "memory", "result", "pos", "connection", "len"], "data_size": [" data_fee", "dataqscale", "data_range", "data_end", "batch_width", "data\u00b7size", "dataqend", "data_center", " data_scale", "dataqwidth", " data_center", "message_width", "data\u00b7scale", "block_scale", "block_range", "batch_scale", "data_width", "data\u00b7range", "message_size", "data_fee", "data_length", "data\u00b7number", "message_count", "data_scale", "batch_end", "dataqsize", "batch_size", "data_count", "message_length", "block_number", "data_number", "block_size"], "avpkt": ["aimtkt", "avcpcht", "avckg", "avpqt", "avcct", "avfck", "avPkt", "avPqt", "abpkg", "affcp", "affck", "avwpck", "avwpacket", "avtkt", "avtcp", "afpacket", "affacket", "abcpcht", "abpkt", "avpck", "avcpkg", "aimpct", "abcpkt", "affkt", "aimpqt", "afpck", "avPcp", "avwpcp", "abpcht", "abcpct", "avppcht", "avpkg", "aimpkt", "avtct", "aimpcp", "avcpacket", "avcpkt", "aimtct", "abcpkg", "avppkt", "avpcht", "avPct", "avpacket", "abpct", "avfkt", "avcpcp", "avwpkt", "avpct", "afpcp", "avcpqt", "avpcp", "avppkg", "avfcp", "avfacket", "afpkt", "avppct", "avccht", "avcpct", "avcpck", "avtqt", "avckt", "aimtqt", "aimtcp"], "buf": ["seq", "uf", "bag", "uc", "b", "batch", "wb", "cv", "msg", "queue", "buffer", "vec", "text", "rb", "br", "config", "cb", "bc", "port", "proc", "raw", "cmd", "tmp", "box", "pool", "fb", "cf", "rc", "alloc", "cache", "cas", "buff", "array", "bytes", "fp", "func", "result"], "c": ["sc", "cm", "dc", "cd", "p", "C", "ec", "ct", "cb", "bc", "cmp", "e", "con", "vc", "cc", "ctx", "ci", "cp", "cf", "cn", "mc", "co", "lc", "ca", "cu", "conn", "g", "nc", "ac", "pc", "cam"], "cs": ["rs", "sk", "cm", "args", "sc", "ss", "Cs", "ns", "cv", "ts", "CS", "vs", "ec", "ds", "cus", "ps", "bc", "cons", "ks", "sync", "bs", "css", "eps", "gs", "stats", "cms", "vc", "ics", "spec", "wcs", "hs", "cc", "ctx", "cn", "cp", "cf", "os", "rc", "cache", "ras", "cas", "lc", "cells", "ls", "fs", "qs", "acs", "nc", "ac", "pc"], "n": ["k", "np", "nm", "w", "z", "p", "b", "sn", "d", "x", "fn", "en", "nn", "num", "ne", "u", "nor", "e", "o", "nb", "nt", "cn", "N", "f", "network", "j", "t", "net", "v", "r", "nc", "l", "len", "g"], "m": ["cm", "nm", "w", "p", "dim", "d", "en", "mi", "mid", "num", "u", "e", "o", "M", "mode", "mn", "mc", "mon", "middle", "man", "h", "f", "y", "dm", "mm", "v", "r", "g"], "channel": ["sc", "cm", "can", "wan", "gap", "page", "uc", "server", "name", "cv", "qa", "queue", "component", "config", "member", "col", "type", "error", "version", "cycle", "character", "sync", "cup", "chn", "nick", "second", "chat", "unit", "chan", "open", "con", "message", "resource", "chron", "controller", "session", "category", "ann", "ko", "group", "mode", "board", "change", "target", "client", "rc", "scale", "shape", "direction", "video", "number", "block", "course", "source", "stream", "index", "core", "event", "consumer", "container", "nc", "que", "connection", "layer"], "i": ["p", "b", "d", "x", "ti", "mi", "id", "ui", "u", "li", "ii", "ini", "si", "di", "ai", "ni", "ci", "h", "I", "f", "j", "ip", "index", "iu", "v", "pi"], "block_predictor": ["block_pemptation", "block_npredictor", "block_ppectation", "block_pemptor", "block_npredictable", "block_pveyor", "block_npredicter", "block_pemptable", "block_pempter", "block_ppector", "block_pveyer", "block_pveyation", "block_npemptable", "block_ppecter", "block_npredictation", "block_predictable", "block_ppectable", "block_npempter", "block_npemptor", "block_predictation", "block_pveyable", "block_predicter", "block_npemptation"], "samples": ["testsamples", "sesamps", "setsums", "ssamples", "ssamps", "samps", "sesamples", "pamples", "pources", "sources", "offsources", "sesources", "sesessions", "testsessions", "sessions", "offsamples", "offsums", "pamps", "Samps", "setsamps", "testsamps", "sample", "sesample", "pample", "Sources", "sums", "Samples", "ssessions", "Sample", "ssources", "testsources", "Sums", "setsamples", "setsources", "offsamps"], "samples_end": ["samples_start", "samples__max", "sips__max", "sources_end", "samples_size", "samples_edge", "sources_start", "sips_begin", "samples___end", "samples__begin", "samples__end", "sips_max", "sips__end", "samples_begin", "sources_edge", "sips__begin", "samples_max", "sources_size", "sips_end", "samples___start", "samples___edge", "samples___size"], "src": ["seq", "sc", "sid", "slice", "sr", "dc", "uc", "sn", "img", "rb", "config", "component", "cb", "bc", "inst", "sync", "supp", "url", "proc", "cmp", "seed", "sur", "chan", "uint", "tmp", "input", "uri", "loc", "spec", "fl", "sel", "ctx", "sb", "gl", "rc", "video", "ptr", "sec", "ctr", "sup", "dist", "rect", "source", "stream", "RC", "dest", "sl", "attr", "nc", "chrom"], "st": ["rest", "std", "sc", "fe", "ST", "ss", "sn", "sh", "se", "sw", "ste", "ct", "since", "state", "inst", "sync", "St", "store", "sth", "step", " stride", "nd", "str", "sta", "start", "cl", "set", "sts", "si", "nt", "ci", "sb", "est", "stage", "stream", "stack", "t", "nc", "stop"], "nibble": ["rnibble", "rnseq", "pnseq", "pnibble", "pnistor", "nig", "nistor", "rnistor", "nseq", " nistor", "pnig", " nseq", "rnig", " nig"], "diff_channel": [" difference_channel", " difference_error", "diff_error", " difference_size", "diff_size", " difference_group", "diff_group"], "samples_in_chunk": ["samples_in_chacket", "samples_in_pace", "samples_in_funks", "samples_in_packet", "samples_in_Chunk", "samples_in_punk", "samples_in_punks", "samples_in_facket", "samples_in_Chacket", "samples_in_Chunks", "samples_in_face", "samples_in_chunks", "samples_in_chace", "samples_in_Chace", "samples_in_funk"], "previous_left_sample": ["previous_left_pipe", "previous_right_pipe", "previous_right_part", "previous_left_Sample", "previous_leftxsample", "previous_leftxpart", "previous_right_Sample", "previous_leftxpipe", "previous_left_part", "previous_leftxSample"], "previous_right_sample": ["previous_left_Sample", "previous_left_sequence", "previous_right_Sample", "previous_right_sequence"], "current_left_sample": ["current_right_charge", "current_leftmmSample", "current_leftmmcharge", "current_leftmmpart", "current_right_Sample", "current_leftmmsample", "current_right_part", "current_left_charge", "current_left_part", "current_left_Sample"], "current_right_sample": ["current_right_size", "current_right_Sample", "current_left_Sample", "current_left_size"], "next_left_sample": ["next_right_step", "next_left_Sample", "next_left_step", "next_right_Sample", "next_right_bin", "next_left_bin"], "next_right_sample": ["next_left_Sample", "next_right_Sample", "next_right_scale", "next_right_group", "next_left_group", "next_left_scale"], "coeff1l": ["coef1b", "coeff1b", "coeff_r", "coef1r", "coeff_b", "coef1d", "coeff_l", "coeff2d", "coeff1d", "coef1l", "coeff_d", "coeff2b"], "coeff2l": ["coeff5l", "coeff5b", "coeff1b", "coeff5r", "coff2d", "coff1b", "coeff4d", "coeff2d", "coff1r", "coeff4r", "coeff4b", "coeff5d", "coff1d", "coeff1d", "coeff4l", "coff2l", "coff1l", "coff2r", "coff2b", "coeff2b"], "coeff1r": ["coeff1n", "coeff4p", "coeff_r", "coeff4n", "coeff2p", "coeff_n", "coeff_l", "coeff2n", "coff2p", "coff1n", "coff1r", "coff2n", "coeff4r", "coeff_p", "coeff1p", "coeff4l", "coff2l", "coff1l", "coff2r", "coff1p"], "coeff2r": ["coef2p", "coeff4p", "coeff5l", "coeff5R", "coef1R", "coeff4R", "coeff5r", "coef1r", "coeff2p", "coef2R", "coef2l", "coeff4r", "coeff2R", "coeff1p", "coef1p", "coef2r", "coef1l", "coeff4l", "coeff1R", "coeff5p"], "shift_left": [" shift2left", "shift_l", " shift_l", "shift2right", " shift2right", " shift2l", "shift2left", "shift2l"], "shift_right": ["shift1r", "shift1right", "shift2r", " shift2left", "shift1left", "shift2right", " shift_r", "shift_r", " shift2right", " shift2r", "shift2left"], "count1": [" countone", "seq2", "seqone", "Count2", "Countone", "Count01", "seq1", "seq01", " count01", "Count1", "countone", "count01"], "count2": ["shift5", " count4", "shift4", "count5", " count5", "weight1", "count4", "weight5", "shift2", "weight2", "shift1", "weight4"], "coeff": ["coefficient", "coef", "Coff", "Coef", "collff", " coff", "coff", "collef", "colleff", "collefficient", "Coeff", " coefficient", " coef", "Coefficient"], "shift": ["mask", "gap", "slice", "pop", "carry", "transform", "sum", "align", "Shift", "center", "push", "pad", "repeat", "seed", "reverse", "set", "sample", "offset", "hift", "change", "scale", "shape", "dist", "mix", "pull", "power"], "predictor": ["pveyori", "nriptor", "preredictrator", "nredictori", "ppectors", " pveyors", "pcorrector", "pveyor", "ppredor", "preruptior", "pacheror", "nriptorer", " pveyori", "nredictor", "pcelerior", "pruptors", " pvictors", "pvicter", "pveyer", "pributure", "predicter", "preredictior", "pveyors", "pruptior", "pvictrator", "preruptor", "ppredation", " predictors", "preruptors", "predictation", "pcorrecture", "preredictor", "paiter", "pvictors", "pceleror", " pvictor", "pruptrator", "predictutor", " pacherion", "predicture", "paitor", "ppredors", "ppection", "pributors", "predictior", "paitoria", "preruptrator", "pacheristor", "pacherors", "nripture", "pributori", "pripture", " pvictoria", "pribututor", "ppredutor", "pcelerrator", " pacheror", "preredictors", " pveyor", "pcorrectorer", "pcelerors", " predictoria", " predictori", "pvictoria", "pruptor", "pributorer", " predictutor", "pvictor", "pcorrecter", "predictorer", " pvictutor", " pacherors", "pributor", "nriptori", "pributation", "pvictior", " pvicter", "pvictation", " predicter", "priptorer", "pvictistor", "pvictutor", " pvictation", "pcorrectori", "nredictorer", "ppector", "pacherion", "predictrator", "priptori", " pacheristor", "predictoria", " predictation", "pcorrectors", " predictistor", "predictors", "priptor", "nredicture", "predictori", "paitors", "predictistor", " prediction", "prediction", "pviction", "ppectistor", " pveyer"], "step_index": ["step2index", "action_type", "stepPoffset", "code___index", "step_position", "step___header", "step2type", "step64count", "code_end", "step_offset", "stepflowoffset", "step_num", "action_num", "step_header", "actionxindex", "step2info", "action_info", "code___offset", "step64position", "step64length", "step_count", "step_size", "stepflowend", "stepxnum", "step_length", "actionxinfo", "code_header", "step___end", "stepflowindex", "step_type", "stepflowheader", "step_info", "code_offset", "code_index", "step2num", "step64index", "step_end", "step___index", " step_offset", "stepPsize", " step_position", "actionxtype", "code___end", "stepxtype", "stepxinfo", "step___offset", "code___header", "actionxnum", "stepPindex", " step_size", " step_length", "stepxindex", " step_count", "action_index"]}}
{"project": "FFmpeg", "commit_id": "50cbe09d8ced75422571d29bbec1f35a33a0d3ed", "target": 0, "func": "static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)\n\n{\n\n    int res;\n\n    HuffContext huff;\n\n    HuffContext tmp1, tmp2;\n\n    VLC vlc[2] = { { 0 } };\n\n    int escapes[3];\n\n    DBCtx ctx;\n\n    int err = 0;\n\n\n\n    if(size >= UINT_MAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    tmp1.length = 256;\n\n    tmp1.maxlength = 0;\n\n    tmp1.current = 0;\n\n    tmp1.bits = av_mallocz(256 * 4);\n\n    tmp1.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp1.values = av_mallocz(256 * sizeof(int));\n\n\n\n    tmp2.length = 256;\n\n    tmp2.maxlength = 0;\n\n    tmp2.current = 0;\n\n    tmp2.bits = av_mallocz(256 * 4);\n\n    tmp2.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp2.values = av_mallocz(256 * sizeof(int));\n\n\n\n    if(get_bits1(gb)) {\n\n        smacker_decode_tree(gb, &tmp1, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp1.current > 1) {\n\n            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,\n\n                        tmp1.lengths, sizeof(int), sizeof(int),\n\n                        tmp1.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[0].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping low bytes tree\\n\");\n\n    }\n\n    if(get_bits1(gb)){\n\n        smacker_decode_tree(gb, &tmp2, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp2.current > 1) {\n\n            res = init_vlc(&vlc[1], SMKTREE_BITS, tmp2.length,\n\n                        tmp2.lengths, sizeof(int), sizeof(int),\n\n                        tmp2.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[1].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping high bytes tree\\n\");\n\n    }\n\n\n\n    escapes[0]  = get_bits(gb, 16);\n\n    escapes[1]  = get_bits(gb, 16);\n\n    escapes[2]  = get_bits(gb, 16);\n\n\n\n    last[0] = last[1] = last[2] = -1;\n\n\n\n    ctx.escapes[0] = escapes[0];\n\n    ctx.escapes[1] = escapes[1];\n\n    ctx.escapes[2] = escapes[2];\n\n    ctx.v1 = &vlc[0];\n\n    ctx.v2 = &vlc[1];\n\n    ctx.recode1 = tmp1.values;\n\n    ctx.recode2 = tmp2.values;\n\n    ctx.last = last;\n\n\n\n    huff.length = ((size + 3) >> 2) + 3;\n\n    huff.maxlength = 0;\n\n    huff.current = 0;\n\n    huff.values = av_mallocz(huff.length * sizeof(int));\n\n\n\n    if (smacker_decode_bigtree(gb, &huff, &ctx) < 0)\n\n        err = -1;\n\n    skip_bits1(gb);\n\n    if(ctx.last[0] == -1) ctx.last[0] = huff.current++;\n\n    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;\n\n    if(ctx.last[2] == -1) ctx.last[2] = huff.current++;\n\n    if(huff.current > huff.length){\n\n        ctx.last[0] = ctx.last[1] = ctx.last[2] = 1;\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"bigtree damaged\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    *recodes = huff.values;\n\n\n\n    if(vlc[0].table)\n\n        ff_free_vlc(&vlc[0]);\n\n    if(vlc[1].table)\n\n        ff_free_vlc(&vlc[1]);\n\n    av_free(tmp1.bits);\n\n    av_free(tmp1.lengths);\n\n    av_free(tmp1.values);\n\n    av_free(tmp2.bits);\n\n    av_free(tmp2.lengths);\n\n    av_free(tmp2.values);\n\n\n\n    return err;\n\n}\n", "idx": 25937, "substitutes": {"smk": ["slkt", " smks", "snK", "Smke", "smc", " smc", "mmK", "SMijk", "ismke", "spkt", "smke", "smK", "limK", "Smk", "slc", "SMkt", "mmk", "mmak", "spK", "smkt", " smck", "limk", "slijk", "SMk", "spk", "smak", "slK", "spks", "ismks", " smke", "ismk", "smck", "SMK", "spck", "snkt", "Smck", "slks", "snak", "smks", "slck", "mmkt", "limijk", "ismck", "slk", "limkt", "snk", "spc", "spak", "Smks", "smijk"], "gb": ["hm", "cod", "gin", "bn", "bb", "hd", "usb", "tm", "api", "storage", "gnu", "rb", "bf", "gam", "gz", "bd", "cb", "bc", "gy", "py", "bp", "kb", "ym", "plugin", "hub", "db", "gs", "cfg", "phy", "cmd", "gn", "ubs", "tg", "nb", "eb", "gd", "mb", "binary", "abb", "sb", "GB", "gp", "rg", "ga", "gow", "vm", "git", "gh", "gg", "agg", "bm", "bg", "bps", "gm", "bt", "pc", "gt", "cgi", "g"], "recodes": ["reode", "reords", "reodes", " recode", "reoding", "records", "Records", "Recode", "Recoding", "recoding", " recoding", " records", "Recodes", "recode"], "last": ["recent", "code", "events", "cycles", "batch", "cur", "br", "next", "cycle", "end", "region", "depth", "extra", "max", "after", "prev", "loc", "parent", "cache", "first", "count", "total", "child", "used", "tests", "full", "latest", "final"], "size": ["code", "cm", "ize", "i", "c", "name", "sized", "data", "capacity", "address", "Size", "extra", "max", "SIZE", "s", "loc", "small", "fee", "si", "scale", "cache", "shape", "length", "six", "timeout", "count", "bytes", "n", "out", "len", "g"], "res": ["powers", "rest", "rs", "code", "nos", "resolution", "RES", "ms", "br", "rez", "gr", "ps", "error", "acts", "cons", "rows", "rep", "id", "css", "eps", "vals", "rss", "resh", "arr", "rh", "err", "rev", "re", "os", "ras", "ons", "ret", "sol", "rc", "cache", "ress", "Res", "count", "details", "js", "pres", "reg", "resp", "out", "results", "ver", "ids", "ex", "r", "result", "pos", "val", "params"], "huff": [" dhuffy", " Hazz", " Huff", " Huffy", " huf", " huffy", " hazz", " dhuff", "huf", " dhazz", " Huf", "huffy", " dhuf", "hazz"], "tmp1": ["tmp17", "attrone", "txt0", " tmp6", "ppa1", "ppa5", "jp1", "txt6", "config1", " tmp81", "temp0", "config2", "jp01", "attr81", "txt4", "mp5", "jp8", " tmp8", "elt2", "temp5", "elt0", "tmp8", "temp17", "txt81", "mp3", " tmp3", "jpn", "proc2", "eltall", "config01", "ppa17", "tempone", "temp4", "tmp6", "temp8", " tmp5", "tmpall", "mpone", "temp2", "tmp0", "txt1", "mp1", "proc1", "tmpone", "mpall", " tmpall", " tmp17", " tmp4", "mp01", "temp1", "config3", "ppaone", "txtone", " tmpn", "mpn", "proc0", "tmp4", "tmp81", "txtn", "tmp5", "tmp01", "txt2", " tmp01", "tmpn", "attr1", "elt1", "tempn", "tmp3", "mp0", "temp01", "mp2", " tmpone", " tmp0", "temp6"], "tmp2": ["txt42", "vttwo", "tmp22", "txt0", " tmp6", "rttwo", "attr2", "vt2", "attr0", "txt6", "temp0", "app2", "temp02", "tmp42", "attr8", "bytes", "attr42", "metadatasecond", "r", "tmp02", "txt4", "txtsecond", "temptwo", " tmp8", " tmpsecond", "temp22", "attr4", "tpTwo", "tmp8", "txt22", "rt0", "metadata14", "s", " tmptwo", "tempsecond", "metadata2", "temp42", "temp4", "appsecond", "tmp14", "tmp6", "rt2", "temp8", " tmp14", "temp2", "tmp0", "txt1", "tmptwo", "all", "attr14", "mp1", "rt02", "app22", "metadata8", " tmp4", "vtTwo", "tmpsecond", "app4", "tmp4", "tp2", "id", "txt02", "txt2", "txt8", "tptwo", " tmp02", "mp02", "attrsecond", "mp4", " tmpTwo", "mp2", " tmp0", "tmpTwo", "temp6"], "vlc": ["llt", "lvp", "llc", "svf", "tlcs", "tldc", "nlf", "vlp", "svt", "rlci", "tlt", "lvt", "vlf", "llcs", "lvc", "ervl", "tlc", "svc", "lvcs", "nlp", "vlci", "vlt", "elll", "rll", "rlcs", "ervci", "lldc", "vlcs", "ellci", "nlt", "nlc", "vll", "lvdc", "ervc", "vldc", "ervcs", "svp", "lvf", "ellcs", "rlc", "ellc"], "escapes": ["secaps", "regapes", "escopes", "escaped", "secaped", "regaped", "shopes", "regopes", "secapes", "regaps", "shaps", "escaps", "shaped", "shapes", "secopes"], "ctx": ["sc", "cm", "scope", " context", "context", "qa", "config", "cr", "cb", "ct", "bc", "kb", "cmp", "buf", "loc", "lib", "Context", "parent", "cc", "ci", "cf", "cache", "lc", "ctrl", "ca", "cu", "tx", "cs", "ce"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int standard_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);\n\n    skip_bits(gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);\n\n    v->s.pict_type = get_bits(gb, 1);\n\n    if (v->s.avctx->max_b_frames)\n\n    {\n\n        if (!v->s.pict_type)\n\n        {\n\n            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;\n\n            else v->s.pict_type = B_TYPE;\n\n        }\n\n        else v->s.pict_type = P_TYPE;\n\n    }\n\n    else v->s.pict_type++;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_primary_header(v); break;\n\n    case BI_TYPE:\n\n    case B_TYPE: status = decode_b_picture_primary_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v->s.avctx, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25947, "substitutes": {"v": ["ve", "gu", "vg", "k", "w", "z", "i", "p", "m", "b", "c", "server", "va", "d", "cv", "ov", "x", "vs", "inv", "api", "ant", "nv", "vt", "av", "version", "vers", "ev", "tv", "vv", "u", "self", "e", "es", "hw", "o", "vc", "vin", "at", "rev", "vim", "dev", "video", "vi", "iv", "vm", "conv", "serv", "h", "uv", "vic", "f", "lv", "value", "n", "vd", "j", "V", "t", "q", "qv", "ver", "r", "vp", "ui", "l", "sv", "volt", "val", "vol", "g"], "gb": ["gu", "gui", "anim", "b", "Gb", "pg", "dim", "lb", "bb", "ge", "usb", "tm", "gru", "storage", "rb", "gal", "bf", "gam", "gz", "mi", "cb", "bc", "gy", "gom", "bug", "sg", "kb", "gpu", "db", "hub", "gs", "xy", "cfg", "hw", "phy", "gi", "gold", "nb", "gd", "lib", "mb", "ctx", "ci", "sb", "abb", "GB", "gp", "rg", "ga", "pm", "game", "gow", "ged", "gio", "gh", "gg", "gc", "yg", "dm", "bm", "bg", "gm", "pc", "gt", "cgi", "g"], "s": ["S", "rs", "ses", "sc", "sys", "i", "m", "p", "c", "ss", "ns", "se", "ts", "sports", "ms", "ds", "conf", "us", "ps", "secondary", "ins", "states", "sync", "ks", "is", "screen", "e", "es", "gs", "site", "o", "sets", "share", "start", "ads", "spec", "l", "sym", "hs", "submit", "aws", "os", "services", "sup", "ls", "service", "js", "fs", "network", "qs", "t", "settings", "in", "ops", "ssl", "cs", "its", "params", "native"], "pict_type": ["pictaltype", "pict\u00b7id", "advert_single", "config_type", "pict_class", "pict_status", "picture_name", "config_key", "pict_name", "picture_size", "pict_parent", "pict\u00b7types", "pictptypes", "configitytype", "advert_key", "picture_parent", "configityclass", " pict_ype", " pict_action", "picticksingle", "pict_size", "adverticalstatus", "pictpype", "adverticaltype", "picticalsingle", "pict_types", "adverticalsingle", "pictickkey", "picticalstatus", "picticktype", "pict_single", " pict_types", "advert_status", "pict_key", "pictalkey", "pict_id", "pict\u00b7name", "pictptype", "advert_type", "picticaltype", "pictpaction", "pictitykey", "picticalkey", "picture_id", "configitykey", "config_class", "config_status", "pict\u00b7type", "pictalclass", "pict_ype", "pictitytype", "pict\u00b7TYPE", "adverticalkey", "pictitystatus", "picture_order", "configitystatus", "pictityclass", "pictalstatus", "pict_TYPE", "pictickstatus", "pict\u00b7parent", "pict_action", "pict_order", "picture_type", "picture_TYPE", "picture_types"]}}
{"project": "FFmpeg", "commit_id": "a18456a2032e49385447a1d0d2f146f65fe9a5e1", "target": 0, "func": "static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)\n\n{\n\n    FILE* f;\n\n    char line[1024];\n\n    char  cmd[1024];\n\n    FFServerIPAddressACL *acl = NULL;\n\n    int line_num = 0;\n\n    const char *p;\n\n\n\n    f = fopen(stream->dynamic_acl, \"r\");\n\n    if (!f) {\n\n        perror(stream->dynamic_acl);\n\n        return NULL;\n\n    }\n\n\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n\n\n\n    /* Build ACL */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL)\n\n            break;\n\n        line_num++;\n\n        p = line;\n\n        while (av_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0' || *p == '#')\n\n            continue;\n\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n\n    }\n\n    fclose(f);\n\n    return acl;\n\n}\n", "idx": 25948, "substitutes": {"stream": ["sc", "thread", "w", "user", "uc", "wrapper", "server", "engine", "transform", "context", "mount", "sw", "enc", "Stream", "cur", "reader", "form", "sync", "port", "url", "feed", "fc", "cl", "draft", "path", "input", "resource", "clean", "model", "cc", "client", "view", "channel", "control", "iv", "ack", "loop", "child", "src", "stack", "host", "coll", "pipe", "row", "sl", "forward", "ssl", "document"], "c": ["cm", "dc", "i", "m", "C", "xc", "ct", "bc", "cy", "ch", "cont", "con", "vc", "icc", "cc", "ctx", "ci", "mc", "lc", "gc", "tc", "cu", "t", "coll", "v", "r", "pc"], "f": ["fen", "fe", "fo", "i", "m", "b", "arf", "d", "aff", "rf", "x", "fn", "fff", "bf", "fm", "form", "flow", "fr", "u", "e", "fc", "feed", "lf", "o", "ff", "s", "fw", "fl", "inf", "fi", "fb", "fx", "cf", "raf", "h", "fs", "fa", "t", "fp", "func", "v", "g", "r", "sf", "df", "l", "fd", "file", "F"], "line": ["Line", "code", "w", "page", "b", "m", "frame", "name", "d", "x", "enc", "buffer", "phrase", "base", "cr", "pe", "col", "pc", "url", "lf", "link", "cell", "o", "e", "cl", "point", "lines", "loc", "lin", "cli", "le", "word", "ln", "block", "lc", "ine", "lp", "rule", "comment", "n", "ip", "nl", "row", "pipe", "v", "sl", "r", "pos", "range", "l", "len", "val", "file"], "cmd": ["md", "seq", "code", "call", "comm", "dc", "anc", "name", "card", "frame", "d", "cat", "msg", "dr", "enc", "data", "config", "prop", "cr", "col", "prefix", "opt", "def", "dict", "domain", "mac", "id", "ch", "op", "range", "cmp", "dom", "buf", "cfg", "cl", "path", "command", "Cmd", "cli", "group", "mode", "cc", "word", "cp", "ctx", "cf", "cn", "lc", "arg", "ack", "comment", "conn", "host", "pipe", "header", "content", "cookie", "ck", "block", "desc"], "acl": ["acc", "L", "af", "z", "oc", "anc", "ll", "ssl", "ocl", "lb", "x", "enc", "qa", "api", "ec", "base", "config", "anon", "am", "bc", "abc", "mac", "op", "al", "fc", "lf", "el", "ic", "cl", "AC", "ac", "pb", "val", "fl", "pool", "aml", "cache", "lc", "auth", "lp", "ip", "list", "an", "nl", "fp", "v", "sl", "ace", "alpha", "l", "kl", "pc", "policy"], "p": ["pp", "code", "pa", "ep", "np", "w", "param", "z", "page", "i", "pn", "b", "m", "pg", "d", "x", "api", "P", "pointer", "jp", "pe", "ping", "col", "bp", "op", "port", "u", "e", "point", "sp", "patch", "o", "padding", "pb", "cl", "s", "at", "pl", "cp", "pat", "lc", "wp", "part", "lp", "po", "y", "pr", "n", "ip", "j", "t", "a", "tp", "fp", "v", "r", "pi", "pos", "pre", "l", "pc", "ap", "g"], "line_num": [" line_NUM", "line_size", "line_n", "line_orig", "line_nr", "block_num", "page_size", " line_n", "line___n", "block_nr", "page_num", "block_Num", "block_no", "page_orig", "line_no", "line_Num", "line___num", " line_no", "page_n", "line_NUM", "line___orig", "line___size"]}}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n", "idx": 25958, "substitutes": {"blk": ["plck", "blck", "Blks", "Blb", "plb", "Blk", "blks", " blks", " blb", "plks", "Blck", "plk", " blck", "blb"], "argc": ["arf", "Argv", "axci", "Argc", " argl", "aglc", " argf", "agc", "intc", "axv", "axl", "argci", "arlc", "argp", "axc", " argp", "arglc", "intci", " argci", "argl", "agv", "intv", "Argf", "arv", "agp", " arglc", "intl", "arp", "argf", "arc", "Argp"], "argv": ["axp", "argV", "axV", "axf", "Argv", "angve", "Argsv", "argsl", "Argc", "argsv", " argvs", " argl", "agV", "opp", " argf", "argx", "agc", "axv", "arvs", " argx", "axl", "angf", "argp", "opc", "armc", "argvs", "angc", "angV", "opv", " argsv", "axc", " argp", "axve", " argve", "argl", "agv", "axsv", "arml", "armvs", " argV", "arv", "Argf", "agx", "armv", "axx", "ArgV", "arp", "argsc", "argve", "angv", "arc", "argf", "argsp", "argsvs", "opvs"], "t1": ["ttone", "Tone", " t0", " tOne", " tone", "TOne", "ret2", "tt0", "tOne", "retOne", "p1", "tone", " t4", "T1", "tt2", "p2", "T4", "tt1", "p0", "p4", "ret1", "t4", "ret4", "T0", "t0", "T2"], "t2": [" t0", "table2", "ta2", "tmp6", " t32", "ta1", "table5", "TTwo", "p1", "ta0", "tablealt", "taalt", "ta6", " t4", "tmp2", "tTwo", "T1", "t5", "p7", "T6", "p2", "t32", "T4", "t6", "ta32", " t6", " t7", "t7", "talt", "table1", "p0", " tTwo", "T7", "ta5", "T32", "Talt", "tmpTwo", "t4", "T5", "T0", "tmp1", "ta4", "t0", "T2"], "c": ["code", "k", " call", "w", "z", "i", "p", "cd", "b", "m", "cat", "C", "d", "x", "enc", " o", " C", "ec", "xc", "cr", "col", "ct", "cy", "ch", "end", "u", "e", " rc", "con", "o", "err", "s", "cc", "ci", "cf", "rc", "channel", "lc", "f", "n", "a", "t", "q", "v", "r", "g", "nc", "l", "cs", "ac"], "ret": ["complete", "ref", "seq", "code", "call", "sr", "ft", "res", "usr", "cat", "flag", "back", "cur", "success", "no", "py", "en", "att", "def", "end", "rep", "num", "rec", "rets", "mem", "get", "err", "rl", "det", "rev", "lit", "RET", "re", "nt", "reply", "rc", "cache", "pet", "Ret", "rt", "gc", "part", "ext", "alt", "reg", "resp", "conn", "match", "result", "len", "val", "fun"], "offset": ["ref", "seq", "location", "skip", "obj", "af", "info", "p", "i", "cost", "shift", "name", "position", "flag", "data", "api", "base", "sum", "align", "pointer", "usage", "address", "delay", "type", "prefix", "Offset", "error", "optional", "end", "num", "url", "seed", "o", "padding", "zero", "iso", "start", "nb", "loc", "fee", "output", "slot", "parent", "order", "size", "online", "number", "ptr", "length", "off", "addr", "uple", "timeout", "not", "part", "reset", "origin", "entry", "limit", "index", "operation", "block", "pos", "et", "len", "area"], "count": ["ref", "call", "w", "keep", "name", "base", "add", "num", "max", "multiple", "start", "Count", "cond", "number", "part", "f", "n", "limit", "list", "core", "content", "match", "wait", "code", "low", "p", "b", "flag", "sum", "check", "col", "counter", "cycle", "key", "patch", "old", "process", "group", "ount", "cache", "total", "coll", "len", "many", "found", "carry", "force", "data", "error", "ch", "all", "err", "parent", "order", "size", "more", "length", "resp", "q", "seq", "skip", "info", "weight", "type", "end", "id", "depth", "allow", "inc", "handle", "child", "ind"], "optind": ["Optind", "octInd", "optimInd", " optcel", " optnd", "offinit", "optie", "OptInd", "opinn", "optinn", "optinit", "optiminc", "optend", "octinn", "opInd", "optInd", "optionInd", "optcel", " optinn", "Optnd", " optin", "optioncel", "optionnd", "optnt", "optnd", "optiminn", "opinc", "optimend", "optin", "optinc", " optie", "opend", "octind", " optinit", "octnd", "opnd", " optInd", "optimnt", "optionie", " optnt", "opcel", "optioninc", "optioninn", "offin", "opind", "octinc", "optimind", "optiminit", "offind", "offnt", "optionend", "optionind", "optimin", "Optie"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n", "idx": 25997, "substitutes": {"mr": ["yr", "ru", "rs", "sr", "er", "m", "rd", "dr", "rf", "tm", "rb", "vr", "br", "cr", "fm", "gr", "reader", "fr", "tr", "arr", "adr", "rh", "rl", "rm", "mt", "lr", "MR", "rar", "mn", "pm", "eu", "mc", "rc", "rg", "kr", "ar", "Mr", "ir", "rt", "nr", "pr", "bm", "mm", "r", "rr", "hr", "shr"], "addr": ["ref", "node", "seq", "slice", "Address", "i", "dr", "x", "base", "pointer", "align", "address", "pad", "amp", "ord", "loc", "offset", "mode", "wd", "hop", "rc", "ptr", "oa", "part", "rt", "ext", "nr", "xp", "rx", "src", "host", "index", "inter", "conn", "r", "ace", "attr", "len", "layer"], "size": ["ish", "z", "ize", "empty", "name", "sized", "storage", "en", "style", "address", "gz", "Size", "unit", "SIZE", "small", "fee", "offset", "si", "mode", "sec", "scale", "count", "bytes", "iz", "range", "l", "large"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n", "idx": 26003, "substitutes": {"vd": ["md", "dc", "xd", "cd", "rd", "va", "d", "cv", "hd", "dr", "ld", "ds", "vr", "nv", "bd", "vt", "ad", "gb", "dd", "ud", "vv", "db", "vid", "pd", "dh", "nd", "vc", "dl", "gd", "dt", "edd", "VD", "rt", "lv", "sd", "od", "v", "df", "fd", "dn"], "addr": ["acl", "pkg", "rn", "ld", "add", "cb", "holder", "url", "arr", "cmd", "ord", "mt", "actor", "hop", "ptr", "part", "r", "md", "sk", "obj", "driver", "bb", "x", "ad", "address", "inst", "cmp", "ady", "wd", "fx", "oa", "src", "func", "od", "attr", "rr", "fd", "kt", "node", "rs", "usr", "data", "nn", "act", "error", "mac", "alias", "db", "adr", "rh", "peer", "ar", "ack", "host", "org", "anne", "ap", "dc", "info", "dr", "hd", "vr", "config", "ast", "dd", "amp", "advert", "art", "owner", "rc", "amd", "rt", "conn", "ag", "route", "adder", "ace", "ac"], "err": ["rs", "sys", "er", "rage", "der", "rn", "dr", "acer", "oller", "var", "cr", "cb", "ler", "gr", "error", "mr", "orr", "fr", "e", "arr", "Error", "rh", "rm", " er", "lr", "order", "fy", "fi", "ln", "kr", "ar", "req", "ir", "cor", "y", "nr", "r", "Er", "rr"]}}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n", "idx": 26008, "substitutes": {"fs_ctx": ["ns_context", "ns_obj", "fs_context", "fs_obj", "ns_path", "ns_ctx"], "fs_path": ["fsFnode", "fsppath", " fs_node", "fs_area", "fsparea", "fsFroot", "fspctx", "fs_root", " fs_ath", "fspath", "fs_node", "fsFpath", " fs_root", " fs_area", "fs_ath", "fs_image", " fs_image", "fsFimage"], "stbuf": ["strb", "STgb", "STbuf", "ssbuf", " stgb", "stbuffer", "sthrb", "stgb", "ctbuff", "ctbuffer", "sthbuffer", "ctbuf", "ctgb", " stbuff", "sthbuf", " strb", "ssrb", "stbuff", "STbuffer", " stbuffer", "STbuff", "ssbuff", "sthbuff", "ssbuffer"], "node": ["ref", "tree", "package", "obj", "none", "master", "image", "d", "data", "fn", "config", "member", "instance", "op", "num", "self", "Node", "resource", "path", "cdn", "object", "anch", "parent", "edge", "device", "array", "part", "slave", "source", "child", "n", "value", "index", "row", "content", "root", "ode", "route", "block", "native"]}}
{"project": "FFmpeg", "commit_id": "f2e9a0ecbef5027f9532c49ffcdfc11d199f6150", "target": 1, "func": "static av_cold int qsv_decode_close(AVCodecContext *avctx)\n{\n    QSVOtherContext *s = avctx->priv_data;\n    ff_qsv_decode_close(&s->qsv);\n    qsv_clear_buffers(s);\n    av_fifo_free(s->packet_fifo);\n    return 0;\n}", "idx": 26030, "substitutes": {"avctx": ["afctrl", " avcor", " avlc", "avcontext", "afcontext", "afctx", "akcor", "avconfig", "ajctx", "avcor", "ajctrl", "aflc", "akconfig", "afcor", "avctrl", " avctrl", "ajlc", "akctx", " avcontext", "avlc", " avconfig", "akcontext", "ajcontext", "afconfig"], "s": ["S", "rs", "ses", "args", "ss", "p", "m", "i", "c", "b", "ns", "d", "server", "ts", "data", "sq", "ds", "opens", "ans", "ps", "sg", "ks", "sync", "self", "u", "e", "es", "gs", "stats", "o", "spec", "si", "sym", "aws", "os", "ctx", "sb", "services", "sa", "xs", "ls", "f", "fs", "qs", "n", "js", "your", "a", "src", "v", "settings", "ssl", "cs"]}}
{"project": "FFmpeg", "commit_id": "c83002a4f8042ccfa0688a9a18e8fa0369c1fda8", "target": 1, "func": "int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n\n                                const char *buf)\n\n{\n\n    const char *text = NULL;\n\n    char new_line[2];\n\n    int text_len = 0;\n\n\n\n    while (*buf) {\n\n        if (text && callbacks->text &&\n\n            (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1 ||\n\n             !strncmp(buf, \"{\\\\\", 2))) {\n\n            callbacks->text(priv, text, text_len);\n\n            text = NULL;\n\n        }\n\n        if (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1) {\n\n            if (callbacks->new_line)\n\n                callbacks->new_line(priv, new_line[0] == 'N');\n\n            buf += 2;\n\n        } else if (!strncmp(buf, \"{\\\\\", 2)) {\n\n            buf++;\n\n            while (*buf == '\\\\') {\n\n                char style[2], c[2], sep[2], c_num[2] = \"0\", tmp[128] = {0};\n\n                unsigned int color = 0xFFFFFFFF;\n\n                int len, size = -1, an = -1, alpha = -1;\n\n                int x1, y1, x2, y2, t1 = -1, t2 = -1;\n\n                if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) {\n\n                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n\n                    len += close != -1;\n\n                    if (callbacks->style)\n\n                        callbacks->style(priv, style[0], close);\n\n                } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", c_num, &color, sep, &len) > 2) {\n\n                    if (callbacks->color)\n\n                        callbacks->color(priv, color, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", c_num, &alpha, sep, &len) > 2) {\n\n                    if (callbacks->alpha)\n\n                        callbacks->alpha(priv, alpha, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->font_name)\n\n                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n\n                } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) {\n\n                    if (callbacks->font_size)\n\n                        callbacks->font_size(priv, size);\n\n                } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) {\n\n                    if (an != -1 && buf[2] != 'n')\n\n                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n\n                    if (callbacks->alignment)\n\n                        callbacks->alignment(priv, an);\n\n                } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n", "idx": 26031, "substitutes": {"callbacks": [" callups", "callasts", "Callback", "Callacks", "allbacks", "Callevents", "callback", "callingbacks", "broadbacks", " callback", " callevents", "broadback", "Callasts", "calleners", "Callups", "playbacks", "defback", "callheads", "defasts", "callups", "callbooks", " callheads", "defbooks", " callacks", "allback", " callasts", " calleners", "callevents", "Callbooks", "callingbooks", "Calleners", "cacks", "callacks", "Callbacks", "broadeners", " callbooks", "cbacks", "allacks", "playacks", "playups", "defbacks", "cback", "callingevents", "Callheads", "cheads"], "priv": ["txt", "Priv", "rib", "uc", "info", "wb", "usr", "data", "doc", "rb", "config", "prop", "gb", "cur", "vt", "access", "pub", "bc", "prof", "reader", "ch", "cb", "debug", "ocr", "proc", "rw", "private", "pri", "options", "li", "password", "pb", "dev", "cer", "ctx", "cp", "fi", "ctr", "rc", "ptr", "req", "pred", "pdf", "buff", "pro", "cert", "conn", "func", "attr", "tty"], "buf": ["bag", "exc", "wb", "pkg", "lb", "Buff", "callback", "buffer", "cb", "bu", "url", "cmd", "lit", "coord", "cf", "ptr", "conv", "uu", "buff", "window", "fp", "ru", "comb", "b", "auc", "cv", "fam", "grab", "bb", "queue", "filename", "port", "proc", "feed", "pb", "cap", "ucc", "cache", "feat", "cas", "raf", "tc", "src", "plug", "func", "fd", "txt", "uf", "console", "uc", "usr", "context", "data", "rb", "ab", "bp", "profile", "brace", "paren", "box", "cp", "fi", "fb", "utf", "Buffer", "tab", "length", "rail", "uber", "seq", "job", "vec", "img", "cur", "br", "config", "bh", "vr", "aka", "bc", "prof", "aux", "home", "loc", "ctx", "ctr", "rc", "loop", "runner", "dest", "bt"], "text": ["txt", "code", "font", "class", "info", "editor", "name", "image", "data", "buffer", "config", "label", "br", "tx", "check", "letter", "prefix", "select", "type", "pass", "write", "form", "id", "num", "url", "method", "math", "feed", "password", "str", "path", "input", "start", "term", "contract", "lit", "object", "binary", "append", "word", "length", "ut", "buff", "translation", "username", "ext", "source", "comment", "value", "Text", "event", "content", "title", "connection", "TEXT", "format"], "new_line": ["new_page", "newoutline", "new_name", "new_list", "newNewlines", "newvline", " new_lines", "newouttext", " new_word", "old_lines", "new_word", "newvlen", "newptline", "new_column", "newNewline", "old_code", "old_line", " new_liner", "next_line", "old_column", "newnewword", "newvlines", "new_liner", "newNewlen", "newxline", "new_code", "newNewcode", "newnewliner", "New_time", "New_page", "newnewline", "newxlines", "newnewlines", "newjline", "newptlines", "next_name", "newjlist", "newoutlines", "newoutname", "new_lines", "new_time", "New_lines", "newptcolumn", "newjpage", "newjlines", "new_len", "next_text", "newptcode", "newxtext", "New_line", "old_page", "next_lines", "newvcode", "newxname", "old_len", "new_text", "old_list"], "text_len": ["ext_pos", "txt_len", "ext_lin", "text_length", "text_lin", "txt_pos", "txt_Len", "ext_Len", "ext_len", "txt_length", "text_pos", "text_Len"], "style": ["use", "font", "body", "k", "margin", "class", "z", "info", "sy", "ss", "p", "theme", "image", "data", "force", "Style", "py", "pe", "type", "error", "speed", "character", "ch", "shadow", "sync", "id", "css", "pad", "profile", "border", "script", "line", "link", "open", "span", "o", "li", "cl", "background", "start", "price", "session", "pattern", "lib", "offset", "si", "like", "ci", "size", "cp", "co", "length", "dot", "comment", "rule", "source", "color", "styles", "sl", "attr", "white", "tag", "sh"], "c": ["code", "k", "w", "z", "dc", "i", "p", "b", "toc", "cz", "cat", "C", "d", "cv", "ec", "config", "col", "ch", "e", "o", "cl", "ac", "s", "cc", "ctx", "ci", "cp", "size", "rc", "cache", "lc", "h", "f", "count", "y", "color", "n", "cu", "t", "csv", "v", "chart", "l", "cs", "ce", "g"], "sep": ["SEk", "aseg", "sem", " sept", "seph", "semmp", " sef", "preg", "semm", "cef", "SEpa", "spek", "sepp", "lem", "pref", " seg", "seg", "kemp", "ceg", "SEpt", "cep", "kep", "sepa", "cepa", "sek", "kem", "spept", "sef", "usepa", "useg", "kepa", "lepp", "sept", "prepa", "asepa", "speg", " sek", "prep", "asep", " seph", " sepa", "lep", "useph", "sempp", "usep", "kepp", "asept", "SEp", "spep", "kept", "SEg", "semp", "keg", "lemp", "SEph"], "c_num": ["cipid", "C_num", "lc_number", "cseqloc", "c_name", "c_number", "c__number", " c1num", "c_gen", "l_dom", "lc_loc", "cseqid", "c_loc", " c1number", "c1gen", "c__name", "c_id", "ciploc", "cipnumber", "C_nm", " c1gen", " c1n", "lc_num", "c1name", "c1dim", "C_number", "l_number", "C_name", "c1number", "l_num", "cseqnumber", "c1nm", "c_nm", "c__num", " c_number", "c_dim", "c1num", "c__nm", "l_dim", " c_n", " c_gen", "c_n", "lc_id", "c1dom", "c_dom", "cseqnum", "cipnum", "c1n"], "tmp": ["temp", "font", "margin", "z", "option", "toc", "pixel", "img", "rb", "config", "cb", "opt", "proc", "script", "span", "input", "output", "cp", "rc", "source", "tc", "cpp", "bg", "attr", "white", "border"], "len": ["seq", "fen", "fin", "bin", "z", "dy", "norm", "enc", "base", "en", "align", "type", "ler", "lon", "num", "pad", "depth", "line", "sp", "span", "Len", "li", "el", "err", "cap", "la", "lit", "loc", "l", "lib", "lin", "offset", "fl", "ann", "rev", "lang", "vert", "size", "scale", "ln", "fat", "length", "den", "lif", "count", "n", "limit", "alt", "lim", "sl", "pre", "pos", "val", "fun"], "x1": ["f3", "x3", "y3", " x3", "f1", "f2"], "y1": ["y0", "p4", "p0", "p2", "p1", "cy2", "x0", "y4", "x4", "cy0", "cy1", "cy4"], "x2": [" x0", "y0", "p0", " x6", "p2", "p1", "x6", "x0", "y6", "p6"], "y2": ["y0", "p4", "p0", "p2", "Y2", "p1", "x0", "x4", "Y0", "y4", "Y1", "Y4"]}}
{"project": "FFmpeg", "commit_id": "2453f40602dd6f5fa670954ee733a4155675f645", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3],\n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n\n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now\n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 62; /* value 63 is not allowed */\n\n            }\n\n\n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\",\n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n\n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            assert(0); //cannot happen\n\n            code = 0;           /* kill warning */\n\n        }\n\n\n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j,\n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 26038, "substitutes": {"scale_code": ["scale2code", "scale2const", " scale_codes", "scale2codes", "scale_function", "scale2function", "scale_codes", " scale_function", " scale_const", "scale_const"], "scale_factors": ["scale_factories", "scale_formions", "scale_factorories", "scale_actors", "scale_factorores", "scale_actories", "scale_formores", "scale_actos", "scale_factos", "scale_factorors", "scale_fores", "scale_formors", "scale_factores", "scale_actions", "scale_factor", "scale_factoros", "scale_formos", "scale_fories", "scale_factoror", "scale_fors", "scale_for", "scale_actor", "scale_actores", "scale_factorions", "scale_factions"], "sb_samples": ["sb_scales", "sb_slales", "sb_subes", "sbsscales", "sb_exores", "sb_slipes", "sb_nipes", "sbssubes", "sb_tamps", "sb_exipes", "sb_sipes", "sbsscipes", "sb_slubes", "sb_scipes", "sb_samps", "sb_tipes", "sb_tamples", "sb_examps", "sb_nales", "sb_scubes", "sb_nores", "sb_scamples", "sb_nubes", "sb_examples", "sb_sales", "sb_namps", "sb_tores", "sb_sores", "sbsscubes", "sbssales", "sbsscamples", "sb_namples", "sbssamples", "sb_slamples", "sbssipes"], "sblimit": ["sblimsiter", "splIMit", "splimIT", "sclimit", "splIMite", "sbllimite", "sblimsit", "sblimIT", "sblimsite", "sblrimiter", "sclIMite", "sblIMiter", "sclimiter", "splimit", "sblIMited", "splimite", "sbllimIT", "sblrimite", "splIMIT", "sclIMIT", "sbllimit", "sclIMit", "sclimite", "sbllimited", "sblIMIT", "sblimiter", "sblimsIT", "splimited", "splIMited", "sclimIT", "sblimited", "sblrimIT", "sblimite", "sblIMite", "sblrimit", "sclIMiter", "sblimsited", "sblIMit"], "p": ["pp", "pa", "np", "w", "z", "b", "pt", "c", "m", "pn", "d", "x", "api", "P", "py", "jp", "pe", "ps", "bp", "port", "u", "e", "point", "sp", "patch", "s", "per", "cp", "h", "lp", "f", "po", "y", "pr", "ip", "t", "tp", "a", "q", "r", "pi", "l", "pc", "ap", "g"], "vmax": ["jdiv", "nvparent", "vvc", "vMax", "lvparent", " vMax", "vvMax", "vvco", "vc", "lvmax", "svax", "Vc", "fmin", "nvmin", "vparent", "vcax", "vvax", "vmad", "vmin", " vfinal", "valmin", " vdiv", "jax", " vc", "tvc", " vmin", "fMax", "nvrange", "svlast", "Vdev", "jc", " vmad", "vvmax", "VMax", "vfinal", "lmin", "lvMax", "vax", "jtotal", "svfinal", "Vax", "vvdev", "vvmin", "tvco", " vco", "fmax", "Vmin", "tvmax", "vctotal", "vvfinal", "Vlast", " vlast", "lmax", "Vmax", "valparent", "vrange", "Vdiv", "vco", "vdiv", "nvmax", "vvlast", "valmax", "vtotal", "vdev", "lMax", "jmax", "lvrange", "vcmad", "tvdev", "svmax", "jmad", " vax", "jMax", "valrange", "vlast", " vdev", " vtotal", "lvmin", "vcmax", "svMax"], "v": ["ve", "w", "z", "b", "m", "c", "va", "d", "cv", "ov", "x", "vs", "api", "nv", "av", "ev", "tv", "vv", "u", "max", "vi", "conv", "iv", "h", "uv", "f", "y", "lv", "value", "V", "t", "q", "ver", "vp", "l", "sv", "val", "vol", "g"], "n": ["np", "w", "z", "b", "m", "c", "pn", "ns", "d", "sn", "x", "en", "nn", "num", "u", "e", "o", "max", "min", "nb", "ni", "mn", "cn", "size", "N", "f", "y", "network", "ny", "t", "a", "na", "net", "ind", "r", "nc", "l", "len", "dn", "g"], "i": ["z", "ie", "b", "m", "yi", "c", "d", "ix", "x", "api", "mi", "jp", "phi", "qi", "it", "io", "id", "u", "key", "e", "o", "li", "ji", "xi", "s", "ii", "ini", "si", "ai", "bi", "ni", "di", "ci", "ik", "eni", "f", "y", "I", "ori", "ip", "t", "iu", "ind", "pi", "in", "ui", "l"], "j": ["w", "z", "b", "m", "c", "d", "x", "jo", "jp", "jj", "it", "u", "e", "key", "ji", "o", "li", "start", "jc", "ii", "si", "ij", "jet", "h", "f", "y", "jl", "js", "t", "q", "J", "r", "ind", "pos", "l", "ja", "g"], "k": ["sk", "kw", "kn", "w", "z", "kk", "m", "b", "c", "x", "K", "ks", "ch", "id", "u", "ak", "key", "o", "uk", "s", "l", "ko", "ik", "ek", "h", "ki", "y", "an", "mk", "q", "r", "g", "ke", "ph", "dk", "ok"], "code": ["use", "call", "xx", "fe", "slice", "cod", "comb", "info", "close", "c", "name", "Code", "function", "data", "test", "text", "condition", "address", "type", "error", "cycle", "state", "end", "example", "id", "catch", "ne", "key", "line", "unit", "codes", "charge", "message", "start", "loc", "nc", "offset", "cc", "change", "ci", "sequence", "size", "length", "xxx", "count", "comment", "entry", "pair", "func", "content", "ind", "match", "result", "desc"], "index": ["element", "fe", "thread", "date", "name", "condition", "version", "sync", "num", "ne", "second", "input", "start", "fee", "ini", "original", "ion", "number", "current", "part", "f", "list", "match", "val", "body", "slice", "none", "c", "x", "action", "diff", "address", "key", "iter", "path", "shape", "xxx", "update", "value", "in", "node", "see", "d", "insert", "no", "pointer", "nn", "error", "search", "offset", "output", "size", "online", "length", "ng", "count", "expression", "alpha", "connection", "page", "info", "position", "ix", "weight", "member", "type", "end", "id", "zero", "xi", "loc", "si", "Index", "inc", "find", "loop", "comment", "network", "ind", "degree"], "d1": ["pn", "d0", "f8", "dOne", "fn", "D1", "f3", "D2", "t3", "p1", "d8", "tOne", "cd1", "f0", " d8", "t1", " d0", "p2", "d3", "p8", "D3", "fOne", "D0", "cd3", " d3", " dn", "f1", "dn", "cdOne", "f2"], "d2": [" d62", "d5", " d4", "d02", "ld6", "do32", "ld2", "dtwo", "du62", " dtwo", "day6", "ldtwo", "dutwo", "dc62", "p32", "dctwo", " d6", "daytwo", "do4", "d4", "du02", "ld82", "p2", " d5", "d82", "day2", "d62", "day82", "dc2", "do5", "p5", "p4", " d02", " d82", "du2", "dc02", "d6", " d32", "do2", "d32"], "sf": ["gif", "fen", "uf", "models", "xf", "fe", "ft", "ffe", "tta", "ppa", "cv", "of", "sw", "rf", "fn", "sq", "bf", "gb", "fm", "tif", "diff", "hh", "support", "fr", "split", "su", "SF", "lf", "fc", "sp", "hw", "iw", "ff", "pb", "isf", "fts", "fee", "result", "fw", "si", "cp", "sb", "cf", "fx", "gp", "fi", "wm", "fb", "eph", "xs", "dist", "ls", "lp", "f", "fs", "tf", "flo", "lv", "tp", "sm", "fp", "ffield", "sd", "sl", "stab", "vp", "df", "ssl", "sv", "fd", "settings", "ze"]}}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 26059, "substitutes": {"opaque": ["OPque", "oppahi", "octaques", "operacity", "OPaque", "openaques", "operaque", "OPaques", "operaques", "opaques", "pque", "opahi", "oppque", "octacity", "openacity", "pahi", "octaque", "oppaques", "paques", "oppaque", "paque", "openaque", "opacity", "opque", "OPahi"], "irq": ["risce", "irche", "Irquant", "Irq", "IRqa", "ierc", "Irche", "irque", "irisqi", "igrquant", "ironq", "irqa", "risq", "rinQ", "ironque", "irquest", "rilqu", "ireq", "igrq", "irquant", "ariq", "iriquest", "mirqu", "rinqa", "ierq", "irqi", "igrche", "irice", "rilquant", "IRq", "igrqu", "mirce", "ireqa", "arique", "iriqi", "irqu", "ierqu", "risqu", "irisqu", "irisque", "mirc", "ironqu", "IRquest", "ireQ", "irce", "mirq", "irequest", "irQ", "IRQ", "ariqu", "ironc", "rilq", "mirque", "irc", "rilche", "Irqu", "iriqu", "ierque", "ariqi", "rinq", "irisq", "rinquest", "risquest", "irique", "iriq", "mirquest"], "s": ["S", "sc", "ses", "rs", "sid", "ss", "p", "m", "b", "c", "i", "ns", "server", "sq", "ds", "op", "sis", "self", "is", "su", "spot", "e", "gs", "es", "o", "sie", "session", "spec", "sv", "si", "sym", "os", "ctx", "bes", "sb", "services", "ls", "f", "fs", "js", "n", "sim", "source", "t", "a", "v", "sl", "ops", "ssl", "cs", "g"], "vec": ["ve", "ger", "fen", "seq", "obj", "virt", "i", "server", "c", "ec", "var", "soc", "vr", "feature", "ler", "bc", "def", "vre", "ev", "nec", "vv", "expr", "liv", "buf", "e", "str", "vc", "spec", "ef", "rev", "cer", "verb", "vert", "fi", "nov", "cf", "fx", "feat", "iv", "req", "cas", "lc", "comp", "serv", "f", "finder", "ves", "crit", "coll", "contin", "v", "ver", "vp", "vir", "cs", "voc", "val", "vector", "desc"]}}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 26061, "substitutes": {"i": ["abi", "slice", "z", "ie", "p", "b", "m", "c", "info", "yi", "d", "ix", "x", "mi", "diff", "phi", "qi", "it", "ri", "id", "io", "ui", "u", "is", "e", "li", "gi", "o", "min", "zi", "multi", "xi", "uri", "inner", "ii", "bi", "si", "di", "ai", "ni", "ini", "ci", "fi", "eni", "iv", "lc", "h", "part", "I", "f", "y", "oi", "n", "j", "index", "t", "ip", "ori", "iu", "ind", "r", "pi", "pos", "in", "l", "hi", "init"], "decoded": ["decode", "dedcoded", "Deccoded", "descoded", "declided", "enccoded", "decided", " deccoded", "enoded", "encode", "encided", "decored", " Decrypted", "declrypted", "dedoded", "desoding", "desoded", "dedrypted", "encored", "desided", "Decored", "enoding", "desanded", " Decored", "decrypted", "decloded", " decored", " decrypted", "desrypted", "Decrypted", "encrypted", "decanded", "dedored", " Decoded", "encoding", "encanded", "declanded", "decoding", " decode", " Decode", "encoded", "Decoded", "enrypted", "deccoded"], "test_cases": ["Test_case", " test_times", "testingstimes", "testplesections", " test_sections", "test_case", "testing_tests", "case_cases", " testscases", "testingstests", "testing_case", "test2tests", "testssections", "testdtests", "testscase", "testdcase", "case_times", "test2cases", "testdcases", "testscases", "test_times", "Test_forces", " teststests", "test2forces", " test_tests", "testing_times", "teststests", "testpletimes", "testingscases", "testdforces", "teststimes", "Test_cases", "test_sections", "test2case", " testssections", "testplecases", "testing_cases", "Test_tests", "test_forces", "case_tests", "test_tests", "testpletests", "testingscase", " teststimes"], "obj": ["ref", "txt", "code", "ie", "pt", "bo", "adj", "ns", "ob", "module", "x", "enc", "data", "api", "Object", "rb", "br", "py", "jp", "cb", "type", "eff", "act", "so", "inst", "oid", "op", "e", "bj", "o", "arr", "tmp", "st", "object", "art", "nt", "os", "ctx", "fi", "oa", "Obj", "active", "elt", "po", "js", "n", "j", "oi", "pr", "coll", "sl", "ex", "result", "pos", "val"], "str": ["txt", "rs", "code", "sr", "ss", "pt", "name", "ns", "dr", "enc", "doc", "data", "text", "style", "br", "cur", "cr", "ct", "type", "gr", "act", "dict", "id", "fr", "tr", "sp", "arr", "o", "err", "s", "spec", "rev", "Str", "st", "object", "STR", "sec", "kr", "stri", "Obj", "elt", "pr", "js", "j", "coll", "sl", "r", "cs", "val"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n", "idx": 26069, "substitutes": {"qdev": ["qqdata", "qqmd", "Qdev", "sqmd", "qqdev", "qdata", "Qpriv", "pdiv", " qdef", "qev", "qmd", "qdef", "ppriv", "qdiv", " qmd", "sqpriv", "Qdiv", "qqdef", "sqdev", "sqdata", "qpriv", "pdev", "sqev", " qdata", "pev", "sqdiv", "sqdef", "Qev"], "dev": ["md", "gu", "sk", "dc", "info", "app", "d", "data", "error", "var", "ad", "conf", "bd", "diff", "pub", "bug", "def", "dd", "DEV", "priv", "ev", "kind", "die", "dom", "prom", "end", "self", "adv", "dem", "hw", "patch", "home", "grad", "valid", "vc", "lib", "fw", "di", "wd", "nov", "device", "gh", "mod", "comment", "vd", "de", "plug", "rad", "Dev", "od", "ver", "v", "cam"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int gen_sub_bitmap(TeletextContext *ctx, AVSubtitleRect *sub_rect, vbi_page *page, int chop_top)\n\n{\n\n    int resx = page->columns * BITMAP_CHAR_WIDTH;\n\n    int resy = (page->rows - chop_top) * BITMAP_CHAR_HEIGHT;\n\n    uint8_t ci, cmax = 0;\n\n    int ret;\n\n    vbi_char *vc = page->text + (chop_top * page->columns);\n\n    vbi_char *vcend = page->text + (page->rows * page->columns);\n\n\n\n    for (; vc < vcend; vc++) {\n\n        if (vc->opacity != VBI_TRANSPARENT_SPACE) {\n\n            cmax = VBI_NB_COLORS;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (cmax == 0) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"dropping empty page %3x\\n\", page->pgno);\n\n        sub_rect->type = SUBTITLE_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if ((ret = avpicture_alloc(&sub_rect->pict, AV_PIX_FMT_PAL8, resx, resy)) < 0)\n\n        return ret;\n\n    // Yes, we want to allocate the palette on our own because AVSubtitle works this way\n\n    sub_rect->pict.data[1] = NULL;\n\n\n\n    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,\n\n                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],\n\n                            0, chop_top, page->columns, page->rows - chop_top,\n\n                            /*reveal*/ 1, /*flash*/ 1);\n\n\n\n    fix_transparency(ctx, sub_rect, page, chop_top, cmax, resx, resy);\n\n    sub_rect->x = ctx->x_offset;\n\n    sub_rect->y = ctx->y_offset + chop_top * BITMAP_CHAR_HEIGHT;\n\n    sub_rect->w = resx;\n\n    sub_rect->h = resy;\n\n    sub_rect->nb_colors = (int)cmax + 1;\n\n    sub_rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n    if (!sub_rect->pict.data[1]) {\n\n        av_freep(&sub_rect->pict.data[0]);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    for (ci = 0; ci < cmax; ci++) {\n\n        int r, g, b, a;\n\n\n\n        r = VBI_R(page->color_map[ci]);\n\n        g = VBI_G(page->color_map[ci]);\n\n        b = VBI_B(page->color_map[ci]);\n\n        a = VBI_A(page->color_map[ci]);\n\n        ((uint32_t *)sub_rect->pict.data[1])[ci] = RGBA(r, g, b, a);\n\n        av_dlog(ctx, \"palette %0x\\n\", ((uint32_t *)sub_rect->pict.data[1])[ci]);\n\n    }\n\n    ((uint32_t *)sub_rect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0);\n\n    sub_rect->type = SUBTITLE_BITMAP;\n\n    return 0;\n\n}\n", "idx": 26075, "substitutes": {"ctx": ["node", "tk", "kw", "cm", "sc", "np", "cca", "dc", " cx", " context", "anc", "c", "pkg", "context", "cv", "qa", "xc", "qt", "img", "config", "cb", "bc", "concept", "mac", "kb", "proc", "cmp", "wx", "hw", "cms", "la", "progress", "loc", "wcs", "fw", "cli", "lib", "Context", "cc", "cn", "cp", "cf", "client", "rc", "sci", "conv", "cas", "lc", "wp", "ctrl", "ca", "gc", "tc", "cu", "conn", "cpp", "ck", "chart", "event", "tx", "cam", "cgi", "kt"], "sub_rect": ["sub_project", " sub_ptr", "sub_ror", "subOsrc", "subOtag", "split_slice", "ub_spec", "ub_struct", "sub_ptr", "sing_struct", "sub_struct", "Sub_rect", "sub_path", "sub_butt", "sub_rt", "Sub_rt", "sub_port", "ub_butt", " sub_surface", " sub_json", "subfcontainer", "user_src", "user_shape", "subOrect", "sub_cover", "Sub_dra", "sub_shape", "sub_container", "sub_dra", "sub_surface", "subssrc", "splitfrect", " sub_spec", "subpslice", "subpcontainer", "ub_surface", "subOtransfer", "Sub_spec", "sub_transfer", "subOshape", "sing_transfer", "sub_dr", "ub_path", "subJdr", "subJsurface", "subureRect", "subureptr", "subsrect", "singOstruct", "usersrect", "subfslice", "subpmount", "sing_rect", "sub_spec", "sub_Rect", "ub_ptr", "user_surface", "sub_mount", "suburerect", "ub_dr", "subfmount", "splitfcontainer", "suburerog", "subfrect", " sub_butt", "Sub_butt", "split_mount", "splitfslice", "sub_rog", " sub_quant", " sub_cover", "ub_Rect", " sub_Rect", " sub_reg", "sub_src", "subOstruct", "sub_slice", "ub_rect", "subOslice", "singOtag", "Sub_project", "sing_tag", "main_ror", "splitfmount", "usersshape", "sub_json", "sub_pair", " sub_port", "subOsurface", "userssurface", "singOrect", "subOmount", " sub_struct", "suberbutt", "suberdra", "userssrc", "subOcontainer", "main_pair", "ub_rog", " sub_record", "subJrect", "split_container", "sub_reg", "subsshape", "main_rt", "subJbutt", "singOtransfer", "sub_tag", "sub_quant", "user_rect", "sub_record", "subssurface", "main_rect", "suberrect", "split_rect", "suberrt", "subprect"], "page": ["server", "pg", "manager", "module", "px", "phrase", "request", "next", "screen", " PAGE", "model", "word", "menu", "pdf", "current", "window", "lp", "list", "row", "document", "area", "user", "p", "c", "ge", "me", "queue", "display", "jp", "pe", "www", "port", "chapter", "mp", "sp", "cell", "resource", "pb", "month", "group", "item", "cache", "xml", "wp", "Page", "stage", "root", "block", "pc", "node", "gui", "pp", "section", "context", "ae", "wiki", "photo", "plugin", "profile", "session", "pl", "parent", "client", "order", "view", "po", "header", "age", "post", "theme", "image", "api", "config", "instance", "site", "layout", "per", "sel", "pm", "inc", "record", "html", "pages", "net", "chart", "result"], "chop_top": ["chip_left", "chrip_front", "chip_bottom", "chop_master", "chrip_next", "chops_TOP", "chrip_tops", "chip_top", "chop_tops", "chop_stop", "chops_top", "chopJsearch", "chop_start", "chop_next", "chhop_tops", "chops_Top", "chhop_left", "chop_front", "chop_Top", "chrip_search", "chrip_stop", "chopJbottom", "chhop_master", "chhop_top", "chrip_start", "chrip_bottom", "chmop_TOP", "chrip_left", "chop_bottom", "chrip_top", "chop_left", "chops_bottom", "chopJtop", "chopJstart", "chmop_tops", "chmop_top", "chop_search", "chop_TOP"], "ci": ["code", "cm", "fe", "iii", "DC", "dc", "cd", "c", "cat", "xc", " vi", "cr", "gb", "ct", "codes", "lic", "loc", "rie", "di", "ii", "ai", "cp", "cf", "ctr", "co", "ca", "cu", "ce", "ice"], "ret": ["ref", "std", "ft", "cat", "flag", "red", "data", "back", "success", "att", "def", "rep", "tr", "rets", "mem", "arr", "rl", "bit", "lit", "det", "RET", "re", "nt", "reply", "rc", "feat", "pat", "arg", "Ret", "rt", "gc", "ext", "rx", "value", "alt", "reg", "resp", "desc", "match", "result", "len", "val", "gt", "ut", "fun"], "vc": ["vg", "iii", "dc", "sn", "c", "cv", "vs", "cci", "xc", "vec", "ant", "vr", "nv", "vt", "bc", "vl", "vv", "wx", "cs", "fc", "vid", "ic", "ac", "wd", "cc", "cf", "rc", "vi", "lc", "uv", "GV", "rt", "lv", "vd", "cu", "v", "dq", "VC", "vp", "nc", "sv", "voc", "pc"], "vcend": ["vcent", "svconst", "avcend", " vconst", "svcend", " vcent", "avmid", "tcend", "tcd", "vdc", "tcent", "vcd", "svmid", " vcd", "svdc", "svcd", " vdc", "tdc", "vmid", "vconst", "avdc", " vmid", "avconst", "svcent"]}}
{"project": "FFmpeg", "commit_id": "41a052a6badc9ed672a810a40b8e54af5d093b5d", "target": 1, "func": "int opt_default(const char *opt, const char *arg)\n\n{\n\n    const AVOption *oc, *of, *os, *oswr;\n\n    char opt_stripped[128];\n\n    const char *p;\n\n    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;\n\n\n\n    if (!(p = strchr(opt, ':')))\n\n        p = opt + strlen(opt);\n\n    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n\n\n\n    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,\n\n                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n\n#if CONFIG_SWSCALE\n\n    sc = sws_get_class();\n\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        // XXX we only support sws_flags, not arbitrary sws options\n\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    swr_class = swr_get_class();\n\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (oc || of || os || oswr)\n\n        return 0;\n\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n\n    return AVERROR_OPTION_NOT_FOUND;\n\n}\n", "idx": 26087, "substitutes": {"opt": ["name", "cat", "or", "enc", " option", "it", "num", "ott", "oss", "options", "term", "ord", "lit", "prev", "object", "hop", "f", "go", "obj", "slice", "pot", "option", "x", "OP", "text", "eff", "prefix", "op", "cho", "proc", "xt", "optim", "key", "iter", "patch", "path", "feat", "wp", "h", "value", "tp", "attr", "temp", "txt", "neg", "token", "pt", "usr", "select", "orig", "expr", "all", "al", "open", "str", "inf", "cp", "ort", "po", "xp", "lo", "alt", "init", "pos", "post", "tag", "fn", "Opt", "oper", "opp", "prop", "config", "method", "o", "loc", "lt", "vert", "ret", "iv", "off", "ext", "pr", "dest"], "arg": ["call", "neg", "args", "param", "argument", "option", "name", "flag", "other", "enc", "doc", "var", "ax", "optional", "end", "op", "num", "rec", "ne", "all", "iter", "arr", "str", "valid", "Arg", "loc", "slot", "ig", "ret", "target", "item", "ar", "help", "ext", "value", "n", "alt", "null", "par", "ag", "pos", "val", "tag", "g"], "oc": ["acc", "ow", "oca", "oci", "dc", "uc", "option", "anc", "c", "toc", "oo", "oy", "ob", "ov", "enc", "ec", "oper", "om", "config", "soc", "bc", "oid", "op", "oe", "ocr", "OC", "o", "ac", "ol", "unc", "loc", "ou", "cf", "roc", "rc", "co", "iv", "ot", "hop", "off", "ir", "ocol", "od", "og", "org", "nc", "voc", "pc", "ok"], "of": ["Of", "from", "fe", "oci", "ob", "ov", "por", "or", "fd", "fn", "ec", "other", "no", "on", "bf", "eff", "oft", "oid", "fr", "o", "ol", "at", "with", "ef", "fee", "ocated", "ou", "fi", "cf", "inc", "alf", "ot", "off", "not", "f", "de", "org", "df", "et", "OF", "voc", "orf", "ok"], "os": ["sys", "ols", "oci", "sn", "option", "ss", "ob", "ips", "or", "oper", "om", "so", "ps", "bos", "pass", "oid", "op", "io", "ocr", "is", "ott", "es", "oss", "o", "options", "ol", "s", "loc", "object", "si", "OS", "ros", "obs", "oa", "ot", "osc", "ost", "ort", "f", "des", "oos", "oto", "ose", "org", "ops", "pos", "voc", "ok"], "oswr": ["osWR", "oskr", "okr", " osrw", "sswr", "ocwr", "osskr", " osWR", "oscr", "ssrw", "ocws", "ockr", "ocr", "osscr", "occr", "osrw", "swr", "osws", "owr", "ows", "ssWR", "ossws", "srw", "sWR", "osswr"], "opt_stripped": ["opt_stickipped", "optttrapping", "opt_ripped", "opt_stickraped", "opt_stitched", "opttstrived", "opt_strippping", "opt_wrapped", "optttraipped", "optttraved", "opt_stripipped", "opt_stripitched", "opt_straped", "opt_strived", "opttstriipped", "opt_strippper", "opt_stickpped", "opt_riipped", "opt_stripraped", "opt_traved", "opt_trapping", "opttstripped", "opt_wrapping", "opt_stickpping", "opt_ripper", "opt_stripper", "opt_stpping", "opt_striipped", "opt_stripping", "opt_stpped", "opt_rived", "optttrapped", "opt_strippped", "opt_striraped", "opt_traipped", "opt_wrapper", "opt_trapped", "opt_riraped", "opt_ripping", "opttstripping", "opt_riitched", "opt_stripved", "opt_wraraped", "opt_striitched"], "p": ["pp", "pa", "np", "i", "pt", "pn", "c", "b", "m", "pg", "d", "x", "P", "jp", "pe", "ps", "type", "dp", "bp", "op", "u", "e", "sp", "o", "l", "cp", "wp", "h", "lp", "f", "po", "pr", "n", "j", "tp", "t", "fp", "q", "v", "r", "pre", "pos", "pc", "ap"], "cc": ["acc", "cca", "dc", "uc", "kk", "cd", "anc", "c", "cv", "cci", "xc", "ec", "bc", "ce", "con", "cl", "ac", "unc", "jc", "CC", "icc", "ci", "cn", "cf", "mc", "rc", "roc", "co", "ucc", "ca", "tc", "cu", "ck", "nc", "cs", "voc", "pc"], "fc": ["fe", "dc", "uc", "fn", "isc", "ec", "bf", "bc", "pc", "fr", "nec", "lf", "con", "ic", "ac", "ul", "unc", "FC", "icc", "fl", "fi", "cf", "inc", "fb", "mc", "fat", "lc", "il", "f", "fs", "flo", "fa", "fp", "sf", "fd", "pic"], "sc": ["acc", "esc", "rs", "scope", "uc", "sn", "ss", "anc", "c", "dc", "cv", "sw", "ec", "isc", "sq", "cr", " SC", "bc", "sp", " rc", "cl", " Sc", "loc", "si", "ci", "cf", "inc", "rc", "asc", "sci", "osc", "SC", "lc", "ca", "go", " scr", "RC", " scope", "org", "Sc", "nc", "cs", "ac", "pc", "desc"], "swr_class": ["swr__classes", "swr_scope", "sws_class", "swr__lass", "swr__class", "sws_scope", "swr_cap", "swr_classes", "swr__cap", "sws_type", "sws_classes", "swr_type", "swr_lass", "swr__scope", "sws_lass", "swr__type", "sws_cap"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090, "substitutes": {"base": ["build", "chain", "server", "name", "buffer", "sync", "valid", "kit", "bi", "model", "part", "f", "year", "core", "big", "area", "gap", "b", "p", "se", "address", "real", "prefix", "store", "boot", "key", "pse", "resource", "common", "binary", "cache", "stable", "root", "normal", "file", "temp", "family", "bare", "ached", "ada", "db", "ase", "cli", "Base", "client", "bot", "absolute", "fake", "proxy", "source", "null", "full", "post", "bas", "api", "bf", "type", "plus", "id", "unit", "reverse", "home", "site", "basic", "zero", "os", "local", "scale", "as", "active", "slave", "ip", "out", "ace"], "aux1_base": ["aux2_last", "auxn_full", "aux1__stable", "aux1_based", "aux2_stable", "aux2_bas", "aux1_b", "aux1__base", "aux2_b", "aux1_full", "aux1__bas", "aux1__site", "aux1__b", "auxn_base", "aux1_bas", "auxn_bas", "aux1_last", "aux2_site", "aux2_based", "aux1__based", "aux1_stable", "auxn_site", "aux1__last", "aux1_site"], "aux2_base": ["aux2_last", "aux1_core", "aux2_bas", "aux2_core", "aux1_cache", "aux2_cycle", "aux1_cycle", "aux1_bas", "aux2_cache", "aux1_last", "aux62_build", "aux62_full", "aux62_last", "aux2_full", "aux62_base", "aux2_build"], "irq": ["iwk", "irque", "irach", " irk", "iraq", "iwqu", "idch", "iraQ", "iwq", "arqs", "iraqs", "irk", "idqs", "irch", "arQ", "irqu", "iwque", "idQ", "irqs", "idq", "arq", "irQ", "irik", " irque", "iriqu", " irqu", "irique", "iriq", "arch"], "fdc_tc": ["fdc2mc", "fdc2tg", "fdc_tg", "fdac_TC", "fdc2tm", "fdac_tc", "fdc2tc", "fdc_tm", "fdc_TC", "fdac_tm", "fdac_tg", "fdc_mc", "fdc2TC", "fdac_mc"], "dev": ["ve", "temp", "md", "gu", "user", "w", "driver", "dc", "info", "p", "engine", "der", "d", "data", "conf", "diff", "bug", "error", "def", "DEV", "state", "ev", "ch", "priv", "serial", "bus", "prom", "self", "dd", "db", "dem", "hw", "grad", " device", "err", "spec", "di", "mode", "req", "block", "device", "mod", "development", "pro", "conn", "de", "Dev", "rad", "v", "ver", "result", "cam", "dn", "g"], "s": ["sys", "w", "server", "ns", "ts", "sites", "sq", "states", "sync", "self", "u", "es", "gs", "south", "http", "sym", "sa", "f", "fs", "js", "n", "status", "service", "t", "tests", "r", "ops", "native", "S", "sk", "k", "p", "b", "m", "c", "se", "x", "ds", "us", "su", "is", "spec", "new", "services", "h", "sl", "settings", "its", "sh", "g", "ses", "d", "sg", "rows", "uses", "e", "session", "sb", "full", "ssl", "i", "site", "o", "si", "os", "device", "sup", "as", "a", "an", "v", "ui", "l"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n\n{\n\n    if (!mb_x) {\n\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n\n    } else {\n\n        return mb_y ? mode : HOR_VP8_PRED;\n\n    }\n\n}\n", "idx": 26100, "substitutes": {"mode": ["md", "node", "sid", "MODE", "m", "transform", "name", "position", "module", "ODE", "access", "type", "def", "version", "state", "mac", "kind", "disable", "id", "method", "path", "command", "enabled", "role", "grade", "scale", "ward", "device", "direction", "mod", "Mode", "rule", "stage", "status", "MOD", "route", "ode", "range", "language", "phase"], "mb_x": ["MB_z", "MB_x", "MB_y", "mb_p", "mb_w", "mb_v", "MB_p", "MB_v", "MB_w", "mb_z"], "mb_y": ["MB_z", "mb08y", "MB_x", "MB_y", "mbxy", "mbLogy", "mbFvy", "mm_ye", "mbLogye", "mbLogyt", "mb_yd", "mm_z", "MB_yd", "mm_y", "mbLogz", "mbxx", "mb_ry", "mbFz", "mbxry", "mb_yt", "mb_vy", "mm_yt", "mbFyd", "MB_cy", "mb08yd", "mb_cy", "mbxcy", "mb_ye", "mb08vy", "MB_vy", "mb08z", "MB_ry", "mbFy", "mb_z"]}}
{"project": "FFmpeg", "commit_id": "da34e4e13238b755bb0e6ebf549015797d9b4467", "target": 1, "func": "static struct ResampleContext *create(struct ResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear,\n\n        double cutoff, enum AVSampleFormat format, enum SwrFilterType filter_type, double kaiser_beta, double precision, int cheby, int exact_rational){\n\n    soxr_error_t error;\n\n\n\n    soxr_datatype_t type =\n\n        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :\n\n        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :\n\n        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :\n\n        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :\n\n        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :\n\n        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :\n\n        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :\n\n        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;\n\n\n\n    soxr_io_spec_t io_spec = soxr_io_spec(type, type);\n\n\n\n    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);\n\n    q_spec.precision = linear? 0 : precision;\n\n#if !defined SOXR_VERSION /* Deprecated @ March 2013: */\n\n    q_spec.bw_pc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : q_spec.bw_pc;\n\n#else\n\n    q_spec.passband_end = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : q_spec.passband_end;\n\n#endif\n\n\n\n    soxr_delete((soxr_t)c);\n\n    c = (struct ResampleContext *)\n\n        soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);\n\n    if (!c)\n\n        av_log(NULL, AV_LOG_ERROR, \"soxr_create: %s\\n\", error);\n\n    return c;\n\n}\n", "idx": 26110, "substitutes": {"c": ["cm", "k", "w", "dc", "i", "p", "b", "m", "cit", "C", "d", "context", "config", "ct", "cb", "ch", "cont", "cmp", "u", "e", "o", "s", "icc", "cc", "ctx", "cp", "ci", "cf", "mc", "cache", "lc", "h", "ca", "f", "tc", "n", "t", "a", "q", "v", "r", "g", "l", "cs", "ac"], "out_rate": ["in_rates", "out_rates", "out_frequency", "out_period", "in_frequency", "in_period"], "in_rate": ["inacradius", "inacsize", "in_rates", "inacrate", "in_size", "inacrates", "out_size", "out_rates", "out_radius", "in_radius"], "filter_size": ["filterflowsize", "filterflowscale", "filter_scale", "filterfullseed", "filterfullcenter", "filterfullscale", "filterflowseed", " filter_scale", "filter_seed", "filterflowcenter", "filter_center", "filterfullsize", " filter_center", " filter_seed"], "phase_shift": ["phase\u00b7index", "line\u00b7offset", "line\u00b7shift", "line_size", "phase\u00b7offset", "line_index", "phase\u00b7shift", "phase_index", "line\u00b7index", "phase_size", "line_shift", "line\u00b7size", "phase_offset", "line_offset", "phase\u00b7size"], "linear": ["space", "stall", "positive", "auc", "physical", "cost", "increasing", "operator", "global", "regular", "standard", "util", "serial", "repeat", "reverse", "initial", "valid", "partial", "la", "lr", "l", "lin", "sym", "binary", "local", "scale", "direction", "aligned", "active", "round", "loop", "quant", "gradient", "material", "neutral", "alpha", "forward", "ssl", "random", "params", "final"], "cutoff": [" cutoffset", "rubOFF", " cutdown", "cutdown", " cutout", "CutOFF", "cuton", "ruboffset", "rubout", "cutOFF", "clipoffs", "putoffs", "cutout", "clipdown", "rubdown", "feedoffset", " cutoffs", "feeddown", "clipoff", "cutoffset", "cutoffs", "clipaway", " cutaway", "Cutout", "Cutoffs", "Cutoff", " cuton", "Cutdown", "feedoff", "rubaway", "critOFF", "ruboffs", "putoff", "critoff", "puton", "Cuton", "ruboff", "critdown", "feedoffs", "cutaway"], "format": ["frequency", "package", "class", "definition", "transform", "name", "position", "function", "template", "data", "api", "force", "attribute", "style", "config", "AT", "ant", "filename", "support", "feature", "type", "types", "export", "version", "archive", "Format", "form", "column", "it", "MAT", "method", "unit", "dimension", "options", "path", "layout", "valid", "FORM", "pattern", "category", "magic", "object", "model", "mode", "output", "group", "fit", "offset", "parent", "size", "number", "scale", "feat", "shape", "field", "length", "array", "f", "source", "stage", "value", "list", "quality", "pretty", "map", "range", "title", "language", "file"], "filter_type": ["Filter_types", "filter2style", "Filter_name", "filter_style", "filter_types", "Filter_style", "Filter_type", "filter_name", "filter2type", "filter2types", "filter2name"], "kaiser_beta": ["kaise_alpha", "kaise_radius", "kaiser_alpha", "kaiser_radius", "kaiser_Beta", "kaise_Beta", "kaise_beta"], "cheby": ["hopbi", "chebi", "chethis", "heby", "hebar", "schebi", "geby", "hopby", "hopbar", "coreby", "heBY", "scheby", "scheBY", "hopBY", "corebi", "gebi", "cheBY", "schebar", "gegar", "chebar", "chegar", "corethis", "cherbi", "chergar", "gethis", "hebi", "cherthis", "coregar", "cherby"], "exact_rational": ["exception_trial", "exception_rational", "exception_alpha", "exact_trial", "exception_norm", "exact_norm", "exact_alpha"], "error": ["sc", "fe", " E", "C", "ae", "no", "Exception", "self", "ception", " Error", "Error", "err", "AE", " err", "change", "null", "ERROR", " exception", "ok"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113, "substitutes": {"opaque": ["opedaco", "opedonymous", "opedcus", "operacity", "operonymous", "operaque", "opaco", "ioponymous", " opcus", "iopaco", "oponymous", "oplaque", "operya", "oppya", "oplonymous", "opya", "opedaque", "oppaque", "iopaque", " oponymous", "oplya", "oplacity", " opaco", "opacity", "oppacity", "iopcus", "opponymous", "opcus"], "buf": ["seq", "uf", "b", "cv", "bb", "data", "buffer", "queue", "vec", "base", "rb", "config", "bf", "cb", "bc", "port", "bp", "raw", "cmd", "pb", "cap", "loc", "pool", "fb", "sb", "alloc", "Buffer", "len", "length", "buff", "f", "src", "fp", "func", "v", "fd"], "pos": ["ref", "seq", "neg", "slice", "Position", "i", "pt", "position", "data", "base", "pointer", "conf", "address", "type", "push", "end", "port", "pad", "POS", "padding", "val", "start", "axis", "lit", "loc", "pose", "offset", " position", "slot", "os", "cache", "addr", "off", "count", "limit", "index", "len", "pc", "Pos", "pid"], "size": ["code", "args", "z", "ize", "c", "empty", "sized", "name", "enc", "data", "send", "en", "sum", "address", "Size", "end", "e", "unit", "SIZE", "loc", "fee", "small", "offset", "mode", "sec", "scale", "length", "count", "bytes", "n", "iz", "len", "g"], "s": ["S", "rs", "ses", "socket", "sys", "w", "scope", "ss", "p", "b", "m", "c", "server", "ns", "sq", "ds", "opens", "ps", "sync", "self", "is", "e", "es", "gs", "o", "http", "peer", "session", "spec", "sym", "hs", "os", "services", "syn", "sa", "ls", "f", "service", "js", "your", "a", "core", "v", "sl", "settings", "ops", "ssl", "g"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n", "idx": 26117, "substitutes": {"type": ["build", "ref", "date", "name", "module", "time", "base", "ping", "types", "version", "kind", "sync", "url", "typ", "http", "object", "model", "number", "ype", "level", "part", "f", "status", "year", "t", "code", "day", "p", "option", "test", "attribute", "pe", "address", "state", "port", "op", "key", "Type", "TYPE", "value", "block", "pc", "file", "phase", "family", "class", "data", "pointer", "error", "plugin", "message", "parent", "like", "size", "length", "count", "source", "null", "full", "ty", "info", "position", "style", "config", "py", "instance", "id", "platform", "python", "unit", "o", "role", "y", "index", "format"], "clock": ["chain", "call", "socket", "week", "ctl", "shift", "currency", "server", "time", "tower", "kick", "config", "delay", "fact", "address", "cb", "bc", "watch", "push", "sync", "css", "Clock", "boot", "script", "chron", "tick", "cpu", "http", "lib", "offset", "journal", "library", "echo", "bot", "cache", "number", "timer", "length", "proxy", "sleep", "timeout", "course", "loop", "life", "glass", "tc", "year", "keeper", "square", "poll", "block", "connection", "ac", "pc", "lock"]}}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n", "idx": 26136, "substitutes": {"opts": ["opls", "optls", "opters", "props", "OPls", " optts", " opters", "optt", "opt", "OPs", " optt", "prots", "prols", "optters", " opls", "opps", " opps", "optps", "proters", "optts", "OPts", " optls", "OPt", "ops"], "chr": ["ger", "clr", "anchr", "catr", "childrr", "gyrer", "kyru", "gydr", "Chrb", "coln", "chsr", "cherb", "chn", "chru", "handru", "cher", "cherru", "colre", "colru", "handrr", "chesr", "gyru", "anchrc", "appr", "Chru", " chcr", "corrb", "motrr", "anchrb", "corcr", "colr", "chrb", "schr", "chersr", "chrr", "uchr", "archrg", "Chsr", "kyr", " chdr", "cldr", "cherro", "chro", " chre", "chrg", "gerer", "schrr", "geru", "clrer", "corsr", "appro", "cherc", "motru", "gecr", "handn", "chcr", "chdr", "kycr", "uchrr", "uchri", "archrr", "childrg", "schrc", "motdr", "motro", "gyrr", "chrer", "motr", "cherrb", "motre", "schrb", " chro", "cherrar", "uchrg", " chru", "colro", "catrg", "handr", "cherrg", "catro", "kyrer", "archr", "coldr", "chrar", "catrar", "childr", "colrr", " chrer", "checr", "clrr", " chsr", "chrc", " chn", "apprar", "childri", "cherr", "Chr", "corr", " chrr", "apprg", "gyr", "archri", "chri", " chrb", "chre", "anchrr"], "s": ["S", "rs", "ses", "socket", "sys", "w", "er", "ss", "p", "b", "server", "c", "m", "ns", "i", "ts", "ips", "sw", "sports", "storage", "ds", "sg", "sync", "su", "u", "e", "es", "gs", "sp", "ssh", "o", "sie", "http", "session", "l", "si", "sym", "ser", "os", "sb", "client", "services", "ows", "serv", "h", "ls", "f", "service", "fs", "js", "slave", "n", "t", "a", "v", "sl", "r", "settings", "ops", "sf", "ssl", "g"], "tty": ["technology", "txt", "socket", "sys", "console", "ctl", "thread", "token", "pty", "server", "tta", "ta", "shell", "test", "tti", "trace", "pointer", "interface", "vt", "te", "tif", "reader", "tr", "proc", "kt", "private", "sth", "ctor", "python", "phy", "padding", "tmp", "readable", "eth", "tt", "sudo", "echo", "touch", "ptr", "task", "timeout", "username", "slave", "tf", "tc", "tp", "t", "ty", "tx", "sh"], "master_fd": ["masterbookdf", "slave_cond", "master_fin", "masterJtube", "primary_fs", "middleapptube", "masterachandler", "masteracsector", "primary_fd", "masterJdra", " master_ds", "masterapphandler", "masteracdf", "middleappfd", "masterbookhandler", "master_handle", "master_socket", "masterpcond", "middleapphandler", "masterappfd", "masterbooktty", "master_fx", "masteracfin", "masterapptube", "master_df", "masterpchannel", "masterbookfd", "middle_dra", "master_tty", "slave_fin", "masterJhandler", "master_dra", "masteracfs", "master_file", " master_file", "master_tube", "masterJsector", "master_fs", " master_handle", "slave_d", "masteracsocket", " master_handler", "master_cond", "slave_handler", "masteracfd", "master_channel", "middle_handler", "middleappdra", "primary_socket", "masterJfin", "master_handler", "masterJfd", "slave_tty", "middle_fd", "primary_df", "master_sector", " master_channel", "master_ds", "masterpds", "slave_fx", "middle_tube", "masterappdra", "masterpfd", "slave_sector", " master_cond", "master_d", "slave_df"], "slave_fd": ["slave_cond", "slaveerhandler", "master_fn", "slave_conn", "server_channel", "server_handler", "slave_channel", "slave_fn", "server_cond", "master_df", "slaveerdir", "master_conn", "server_d", "slave_d", "master_cond", "slave_handler", "slaveerfd", "server_fd", "slave_dl", "master_handler", "master_dir", "master_dl", "slave_dir", "slaveerconn", "slave_df"], "len": ["seq", "fin", "z", "lvl", "ll", "dy", "base", "ld", "en", "filename", "delay", "end", "lon", "num", "hl", "line", "lf", "sp", "li", "Len", "el", "span", "min", "lit", "loc", "l", "dl", "lin", "offset", "fl", "rev", "le", "lt", "size", "ln", "fat", "length", "lc", "part", "lp", "count", "f", "ls", "limit", "n", "ny", "lim", "sl", "pos", "fd", "val", "lock"], "pty_name": ["pty_len", "py_address", "pt_name", "pt_path", "pty_names", "pty_id", "slave_name", "pt_type", "pty_type", "ptysname", "pty_address", "pt_names", "pty2len", "pty2names", "slave_names", "ptysid", "pty2name", "ptystype", "pty_path", "py_names", "slave_len", "pt_id", "ptysnames", "py_name"]}}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "substitutes": {"env": ["fen", "gui", "file", "code", "obj", "args", "np", "ep", "er", "info", "exc", "server", "context", "manager", "enc", "ec", "en", "config", "conf", "style", "export", "opt", "priv", "state", "dict", "ev", "inst", "ea", "loader", "environment", "proc", "db", "e", "site", "esi", "err", "dev", "viron", "worker", "exe", "cp", "eu", "eni", "cache", "erv", "esp", "vm", "req", "ext", "conn", "v", "que", "equ", "eng"], "order_code": ["orderprecodes", "orderalcount", "order2Code", "orderpreclass", "orderprecode", "order2class", " order_class", "order_class", "sort_codes", " order_key", "sort_Code", "sort_call", "orderalcode", " order_call", "orderycall", "orderylevel", "order_codes", "order2call", "orderprecount", "orderalkey", " order_codes", "order2count", "order_key", "orderycodes", "orderalcodes", " order_count", "orderycode", "order_count", "order_Code", "order_level", "sort_code", " order_level", "order_call", "order2code", "order2codes"], "r1": ["order0", " r9", "r9", "order9", "R3", "R2", "r0", " r2", "r2", " r4", "e3", "R0", "R4", "sr1", "sr4", "order2", "e1", "order1", "sr0", "r3", " r0", "sr2", "R9", "e2", " r3", "r4", "R1"], "cpu_addr": ["cpu_offset", "gpu_ord", "cpu2addr", "cpu_ord", "gpu_addr", "gpu_offset", "cpu2address", "cpu_address", "cpu2ord", "cpu2offset", "cpu_port", "gpu_address", "gpu_port"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb_1_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                     const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                     const uint16_t *abuf0, uint8_t *dest, int dstW,\n\n                     int uvalpha, enum PixelFormat dstFormat,\n\n                     int flags, int y, enum PixelFormat target,\n\n                     int hasAlpha)\n\n{\n\n    int i;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 = buf0[i * 2]     >> 7;\n\n            int Y2 = buf0[i * 2 + 1] >> 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    }\n\n}\n", "idx": 26154, "substitutes": {"i": ["my", "abi", "slice", "z", "ie", "p", "m", "c", "info", "name", "yi", "d", "ix", "x", "me", "api", "ti", "mi", "phi", "qi", "it", "ei", "ri", "io", "id", "ki", "u", "is", "e", "key", "line", "li", "gi", "o", "zi", "multi", "xi", "uri", "inner", "ii", "bi", "si", "di", "ini", "ni", "ai", "cli", "ci", "fi", "eni", "n", "I", "f", "y", "mini", "oi", "j", "index", "ip", "source", "t", "q", "ori", "iu", "init", "v", "pi", "in", "ui", "l", "mu"], "A1": ["Aone", "Ac1", "An1", "Ac100", "AOne", "AA3", "LA2", " A30", "LA01", "CA7", "LA5", "Ac8", "An8", "A7", "CA2", "a1", "a3", "A100", "An100", "AA1", "LAOne", "AA30", "AAOne", " A3", " A8", "LA7", "a30", "CA01", "Uone", "A3", " A5", "U1", "UOne", "LA1", "Ac121", "LAone", " A01", " AOne", "U5", "aOne", " A100", "A121", "CA1", " A7", "A5", "A01", "A30", " A121", "A8", "An121", " Aone"], "A2": ["MATwo", "Y2", "EAtwo", " Asecond", "VTwo", "BTwo", "Y02", " A02", "Asecond", "LA2", "V1", "I5", "I2", " ATwo", "ATwo", "MA1", "LATwo", "EA2", "Ysecond", "Itwo", "EATwo", " A5", "V2", "Vtwo", "LA1", "EA02", "Isecond", "Y5", "LAtwo", "Ytwo", "MA2", "B2", " Atwo", "B1", "A5", "A02", "Atwo", "YTwo"], "r": ["ru", "k", "w", "sr", "er", "p", "m", "d", "dr", "x", "or", "rb", "gr", "mr", "fr", "u", "e", "o", "R", "rh", "rl", "s", "err", "re", "ur", "rg", "ar", "h", "ir", "f", "y", "pr", "n", "a", "q", "v", "attr", "rr", "l"], "g": ["gu", "gen", "k", "w", "m", "p", "c", "d", "x", "eg", "gy", "sg", "u", "e", "gi", "gn", "s", "group", "ig", "gl", "ga", "rg", "G", "gh", "h", "gg", "fg", "f", "y", "n", "j", "yg", "a", "bg", "reg", "q", "og", "v", "gm", "l"], "b": ["k", "w", "z", "p", "m", "app", "wb", "lb", "d", "ob", "bb", "x", "ab", "rb", "bd", "bh", "bl", "bs", "url", "u", "e", "o", "ba", "s", "eb", "lib", "bi", "mb", "abb", "sb", "fb", "bot", "B", "ub", "h", "f", "y", "n", "j", "a", "t", "q", "be", "v", "l", "ib"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26158, "substitutes": {"s": ["S", "comments", "rs", "ses", "sys", "iss", "this", "ss", "p", "b", "server", "c", "ns", "ts", "sq", "ds", "conf", "us", "ps", "sg", "secondary", "ins", "states", "sync", "self", "su", "is", "private", "u", "bs", "e", "es", "gs", "stats", "south", "sets", "session", "spec", "l", "si", "hs", "sym", "os", "uns", "sb", "services", "xs", "ls", "f", "service", "qs", "js", "fs", "n", "t", "v", "sl", "r", "settings", "ops", "ssl", "cs", "its", "native", "g"], "sec": ["acc", "esc", "ref", "seq", "sc", "secret", "sid", "section", "sy", "c", "se", "enc", "ec", "sq", "config", "cur", "conf", "ct", "isec", "sic", "sync", "rec", "security", "proc", "second", "con", "cl", "lit", "loc", "sub", "fee", "inf", "spec", "nt", "size", "ctr", "inc", "seconds", "req", "zip", "lc", "decl", "year", "reg", "Sec", "desc", "sl", "sect", "secure", "ssl", "SEC"], "secn": ["securityn", "secondn", "Secp", "secN", "isecr", " secns", "SecN", "isecns", "ctp", "condN", "secp", "ecn", "secnan", "isecN", "seqp", "ecns", " secd", "secd", "seqN", " secN", "securitynan", "securen", "ctN", " secl", "ecN", "securenan", "Secn", "Secno", "condc", "Secr", "ecp", "isecp", "seqn", "secc", "securityns", "ctn", "secureN", " secr", " secc", "securityN", "secno", "Secns", "secondN", "ctno", "secondd", "secl", "securens", "Secnan", " secno", "secns", "secondc", "condn", "seql", " secp", "condd", "secr", "ecl", "isecn"], "src": ["ref", "sc", "rs", "sr", "rib", "img", "rb", "cur", "SOURCE", "Source", "cb", "inst", "supp", "url", "proc", "sth", "buf", "rob", "sur", "tmp", "loc", "sub", "spec", "inf", "super", "sb", "rc", "ctr", "ptr", "roc", "source", "stream", "RC", "fp", "dest", "sl", "attr", "ssl"], "sp": ["space", "pp", " cp", "sk", "ep", "np", "sr", "p", "pg", "bsp", "ds", "SP", "py", "jp", "ps", "bp", "op", "mp", " esp", "span", "spe", " p", "prep", "si", "cp", "sb", "gp", "wp", "ipp", "pr", "tp", "ip", "par", "sl", "Sp", "pre", "pc", "ap", "sh"], "dp": ["pp", "ep", "dc", "p", "dim", "pg", "pkg", "d", "dr", "bb", "data", "api", "send", "ds", "prop", "jp", "address", "ps", "dd", "port", "rep", "isp", "deb", "eps", "db", "imp", "adr", "grad", "pd", "pb", "dat", "dh", "prep", "loc", "dl", "di", "dt", "cp", "pm", "fb", "gp", "proxy", "wp", "drop", "dep", "decl", "tp", "ip", "dm", "fp", "resp", "reb", "dq", "DP", "df", "dn", "ssl", "vp", "params", "pid"], "i": ["abi", "iii", "z", "ie", "p", "b", "info", "c", "d", "uli", "dr", "ix", "var", "ti", "jp", "mi", " ii", "ei", "qi", "phi", "ri", "io", "id", "it", "ui", "u", "e", "gi", "li", "ji", "o", "zi", "xi", "uri", "ii", "di", "si", "ai", "bi", "ni", "ini", "ci", "fi", "eni", "vi", "I", "f", "oi", "ip", "j", "v", "ind", " init", "pi", "mu", "in", "l", "hi", " pi"]}}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)\n\n{\n\n    uint64_t magic;\n\n    uint32_t opt;\n\n    uint32_t type;\n\n    uint32_t len;\n\n    uint32_t namelen;\n\n    int error;\n\n\n\n    *name = NULL;\n\n    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        error_setg(errp, \"failed to read list option magic\");\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    if (magic != NBD_REP_MAGIC) {\n\n        error_setg(errp, \"Unexpected option list magic\");\n\n        return -1;\n\n    }\n\n    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n\n        error_setg(errp, \"failed to read list option\");\n\n        return -1;\n\n    }\n\n    opt = be32_to_cpu(opt);\n\n    if (opt != NBD_OPT_LIST) {\n\n        error_setg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\",\n\n                   opt, NBD_OPT_LIST);\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {\n\n        error_setg(errp, \"failed to read list option type\");\n\n        return -1;\n\n    }\n\n    type = be32_to_cpu(type);\n\n    error = nbd_handle_reply_err(ioc, opt, type, errp);\n\n    if (error <= 0) {\n\n        return error;\n\n    }\n\n\n\n    if (read_sync(ioc, &len, sizeof(len)) != sizeof(len)) {\n\n        error_setg(errp, \"failed to read option length\");\n\n        return -1;\n\n    }\n\n    len = be32_to_cpu(len);\n\n\n\n    if (type == NBD_REP_ACK) {\n\n        if (len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n", "idx": 26160, "substitutes": {"ioc": ["antiocol", "antiroc", "riocl", "iog", "rioc", "iaoc", "ioog", "ioca", "gioca", " iocol", "tioca", "iooc", "ioroc", "pioc", "antioci", "gioci", "uiroc", "givoc", " iosc", "qiosc", "tiocol", "iosc", "uiirc", "qioc", "uiocol", "iaog", " iog", "iocol", "iairc", "iirc", "qioca", "xiosc", " iir", "iroc", "yioc", " iocal", " ioci", "iaosc", "piog", "xioc", "qioci", "xioca", "uiocal", "iaoci", "iocon", "ioocl", "antioc", "qivoc", "yivoc", "pioci", "tioc", "uiog", " ioca", "riocal", "ivoc", "tiocl", "yioca", "iaocal", "yioci", "riocon", "ioci", "iooci", "ioocol", "iocl", "ioocal", " iocl", "iir", "iocal", "uiocl", "ioirc", "uioci", "gioc", "uioc", " iocon", "qiir", "piosc", "uioca", "ioocon", "xiir"], "name": ["seq", "code", "call", "info", "option", "wave", "data", "no", "config", "prefix", "ame", "id", "alias", "op", "method", "nick", "Name", "key", "options", "cmd", "message", "str", "path", "parent", "new", "cache", "comment", "NAME", "named", "n", "ip", "names", "init", "block"], "errp": ["erP", "armfp", "erfp", "armP", "errpe", "refp", "aerp", "srP", "ierlp", "strt", " errP", "orderfp", "errps", "iterfp", "errper", "errP", "erlp", "frb", " erpe", "errorb", "aerfp", "refP", "oderb", "errg", "irp", "strp", "orderper", "frapi", "ErP", "erps", "erf", "erpre", "ierf", "oderper", "erping", "erp", "ierg", "irpoint", " errc", "ierp", "iterpre", "Erc", "Erp", "erpoint", "aitping", "strg", "errorping", "iert", "Erpre", "frp", "arrper", " erfp", "arrps", "srp", "reft", "errpre", "iterpoint", "errorf", "ierP", "errt", "errorp", "errlp", "errorfp", " erlp", "errorP", "irfp", "arrp", "armg", "errping", "frP", "aerps", "erg", "errf", "strP", "errapi", "ierpe", "irpre", "errb", "orderps", "srb", " errps", "erpe", "refg", "orderp", "oderps", "errorlp", "oderp", "aitp", " errper", "errorapi", " errb", "iterp", " erp", "errpoint", "aitfp", "ierfp", "erper", "errorc", "srapi", "errfp", " errpre", "errorpre", "errc", "aerper", "arrb", "armp"], "magic": ["space", "seq", "secret", "acl", "unique", "virt", "token", "dc", "info", "parser", "cat", "ix", "module", "wave", "data", "base", "config", "prefix", "bug", "domain", "id", "serial", "dom", "plugin", "security", "mag", "nil", "icon", "cmd", "err", "phys", "spec", "binary", "custom", "agent", "stat", "size", "bot", "cache", "special", "xml", "xxx", "git", "Magic", "tech", "mini", "status", "header", "generic", "cookie", "init", "meta", "file", "lock", "format"], "opt": ["cat", " option", "url", "oss", "options", "cmd", "min", "term", "lit", "object", "rot", "hop", "zip", "go", "obj", "pot", "option", "text", "prefix", "op", "cho", "optim", "key", "iter", "spec", "feat", "auth", "update", "timeout", "h", "prot", "attr", "block", "temp", "txt", "token", "pt", "tr", "expr", "xy", "open", "str", "err", "search", "offset", "mode", "parent", "bot", "ort", "lo", "alt", "init", "pos", "lock", "seq", "info", "Opt", "oper", "style", "config", "prop", "id", "o", "loc", "slot", "vert", "ret", "off", "ext", "ip", "operation"], "type": ["call", "cat", "time", "or", "base", "ping", "types", "version", "num", "url", "typ", "cl", "set", "model", "sort", "ype", "zip", "part", "list", "t", "val", "area", "code", "none", "p", "option", "single", "test", "action", "on", "pe", "state", "port", "op", "key", "Type", "target", "rule", "TYPE", "value", "tp", "ver", "attr", "block", "token", "class", "other", "var", "plugin", "all", "err", "offset", "parent", "copy", "like", "size", "length", "count", "alt", "ty", "post", "lock", "info", "style", "config", "py", "id", "method", "o", "rel", "loc", "role", "off", "comment", "y", "pre", "format"], "len": ["fin", "base", "version", "split", "url", "num", "hl", "lf", "el", "li", "min", "lang", "lit", "dl", "lib", "ann", "fl", "lin", "nt", "part", "f", "limit", "list", "n", "val", "layer", "body", "en", "ler", "op", "lon", "line", "iter", "coll", "sl", "block", "fun", "gen", "data", "lan", "delay", "bl", "Len", "err", "la", "offset", "size", "length", "lc", "count", "alt", "pos", "lock", "seq", "ll", "fn", "depth", "rel", "lic", "loc", "lt", "ln", "fat", "ls", "elt", "un", "pre", "l"], "namelen": ["namelaren", "namularen", "imag\n", "imagelen", "namuloen", "nameltaren", "ram\t", "nam\n", "namelloren", "lab\t", "namelinaren", "namelinoren", "samellon", "namELaren", "ram\n", "namelinen", "nam\t", "namelton", "samellen", "namELoren", "lab\n", "namelon", "imagellen", "namulen", "namulon", "imagelaren", "sameloen", "namellon", "imagellon", "nameloren", "namELen", "imagellaren", "namelloen", "namelten", "imagelon", "namellen", "imageloren", "samelon", "namELon", "nameltoen", "samelaren", "namellaren", "samellaren", "namelinon", "samelen", "imag\t", "samelloen", "imagelloren", "nameloen"], "error": ["code", "call", "element", "user", "errors", "rage", "er", "info", "none", "date", "i", "or", "no", "success", "var", "next", "bug", "id", "op", "all", "rss", "e", " Error", "patch", "Error", "err", "valid", "progress", "one", "last", "ror", " err", "grade", "order", "size", "rc", "bad", "block", "html", "length", "ack", "comment", "status", "value", "index", "null", "row", "danger", "core", "ERROR", "event", "r", "unknown", "rr", "result", "warning"]}}
{"project": "FFmpeg", "commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "target": 1, "func": "static int hwupload_query_formats(AVFilterContext *avctx)\n\n{\n\n    HWUploadContext *ctx = avctx->priv;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n\n    AVFilterFormats *input_formats = NULL;\n\n    int err, i;\n\n\n\n    if (!avctx->hw_device_ctx) {\n\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n\n               \"to upload frames to.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n\n    if (!ctx->hwdevice_ref)\n\n        return AVERROR(ENOMEM);\n\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n\n    if (!constraints) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n\n    output_pix_fmts = constraints->valid_hw_formats;\n\n\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n\n    if (!input_formats) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (input_pix_fmts) {\n\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n\n            if (err < 0) {\n\n                ff_formats_unref(&input_formats);\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n\n                   &avctx->outputs[0]->in_formats);\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&ctx->hwdevice_ref);\n\n    av_hwframe_constraints_free(&constraints);\n\n    return err;\n\n}\n", "idx": 26173, "substitutes": {"avctx": ["navctl", "afctl", "AVcam", "akcv", "navcontext", "AVcmp", "AVconfig", "avecontext", "Avcmp", "avconsole", "evcontext", "avcmp", "afkb", "afcmp", "avcontext", "avkb", "avcam", "ajconn", "afcontext", "afctx", "aveconfig", "avconfig", "Avcam", "AVcb", "avectx", "avecv", "evctx", "avctl", "ajctx", "AVkb", "afcb", "avekb", "akcam", "evconn", "navcmp", "Avcontext", "Avcb", "ajconsole", "evconsole", "AVctx", "avconn", "akctx", "AVctl", "afconn", "avcv", "avecmp", "afconsole", "afcv", "akcontext", "avcb", "AVcv", "navctx", "Avcv", "AVcontext", "ajcontext", "Avctx", "afconfig"], "ctx": ["sc", "kw", "cm", "acl", "cca", "uc", "anc", "c", "pkg", "context", "cat", "cv", "qa", "xc", "sq", "config", "conf", "jp", "cus", "cb", "bc", "ce", "instance", "kb", "cmp", "aux", "hw", "cmd", "cms", "vc", "loc", "wcs", "fw", "cc", "ci", "cp", "cf", "mc", "cn", "client", "conv", "cas", "lc", "ctrl", "ca", "tc", "cu", "conn", "ck", "nc", "tx", "cs", "cam", "pc", "kt"], "constraints": ["constaints", "concomplaint", "conribants", "constrorts", "conretaints", "constr\n", "constants", "Conctruments", "Constaints", "oconformures", "conformappings", "constructributes", "Constraints", "contrants", "conntaint", "conctraints", "constrributes", "constritives", "concomplributes", "conforts", "confortappings", "converorts", "conformures", "unstrributes", "construments", "conretappings", "constriffs", "uncomplaints", "converaints", "conctraint", "conribiffs", "confortitives", "oconstrappings", "Constrants", "conformaints", "conformitives", "constaint", "oconformaints", "oconstritives", "conretures", "uncomplorts", "contraint", "constiffs", "converributes", "conntaints", "constructuments", "consts\n", "contruments", "Constructaints", "Constrributes", "contraints", "Conctraint", "Constiffs", "recsts\n", "concomplorts", "conntants", "Constructaint", "constructaints", "unstrorts", "uncomplributes", "conribaints", "conntiffs", "Constrorts", "Constructributes", "Construments", "constrappings", "oconformappings", "constructaint", "Constants", "conctrants", "confortaints", "confaint", "conribaint", "Constriffs", "oconformitives", "constrants", "Conctraints", "conStr\n", "oconstrures", "unstraints", "Conctrants", "conretitives", "conctruments", "confaints", "converuments", "confributes", "construres", "Constaint", "Constructorts", "Constraint", "concomplants", "uncompluments", "confortures", "recstr\n", "concomplaints", "unstruments", "concompluments", "oconstraints", "constructorts", "construct\n", "constraint"], "input_pix_fmts": ["input_pix_wmters", "input_pix_rmters", "input_pix_mts", "input_pix_wmaters", "input_pix_fmps", "input_pix_gmters", "input_pix_fcaters", "input_pix_dimts", "input_pix_fmTS", "input_pix_fcats", "input_pix_fmms", "input_pix_formts", "input_pix_formats", "input_pix_gmts", "input_pix_cmTS", "input_pix_fms", "input_pix_cmters", "input_pix_fts", "input_pix_rmts", "input_pix_fmt", "input_pix_mmats", "input_pix_fmaters", "input_pix_cmaters", "input_pix_dimps", "input_pix_fmters", "input_pix_mters", "input_pix_cmats", "input_pix_mats", "input_pix_gmt", "input_pix_gmats", "input_pix_fct", "input_pix_fats", "input_pix_cmt", "input_pix_dimats", "input_pix_fTS", "input_pix_mt", "input_pix_formps", "input_pix_formters", "input_pix_mmms", "input_pix_dimters", "input_pix_wmt", "input_pix_fcts", "input_pix_cmts", "input_pix_cmps", "input_pix_cmms", "input_pix_rmt", "input_pix_fmats", "input_pix_wmts", "input_pix_rmats", "input_pix_wmats", "input_pix_mmts", "input_pix_mmTS"], "output_pix_fmts": ["output_pix_umats", "output_pix_cmt", "output_pix_formTS", "output_pix_formters", "output_pix_mts", "output_pix_rmks", "output_pix2fmts", "output_pix2cmt", "output_pix_wmt", "output_pix2wmTS", "output_pix2wmats", "output_pix2cmats", "output_pix_umks", "output_pix_fmps", "output_pix_rmts", "output_pix_mps", "output_pix_cmtes", "output_pix_rmats", "output_pix_fmats", "output_pix_cmters", "output_pix2cmks", "output_pix_cmts", "output_pix2fmTS", "output_pix2fmt", "output_pix2wmts", "output_pix_wmters", "output_pix_wmTS", "output_pix_mters", "output_pix_wmats", "output_pix_umt", "output_pix_cmps", "output_pix2fmats", "output_pix_mtes", "output_pix_formts", "output_pix2fmks", "output_pix_formats", "output_pix_fps", "output_pix2wmters", "output_pix_mats", "output_pix_cmats", "output_pix_ftes", "output_pix_fmks", "output_pix_umts", "output_pix_fmters", "output_pix_fts", "output_pix_fats", "output_pix_fmt", "output_pix_rmt", "output_pix_fmtes", "output_pix_wmts", "output_pix_cmTS", "output_pix2cmts", "output_pix_cmks", "output_pix_fmTS", "output_pix_mt", "output_pix2fmters"], "input_formats": ["input_formsls", "input_transformolds", "input_feands", "input_formataps", "input_formutters", "input_facars", "input_formatatives", "input_formsutters", "input_factats", "input_factls", "input_formatars", "input_operATS", "input_factaters", "input_transformets", "input_feATS", "input_commaters", "input_formatations", "input_featter", "input_formsations", "input_formets", "input_formATS", "input_FORMations", "input_facats", "input_formolds", "input_formarts", "input_formars", "input_formaters", "input_FORMats", "input_formations", "input_factaps", "input_formsaters", "input_formaps", "input_formsatter", "input_formatands", "input_facets", "input_formatives", "input_formsaps", "input_commats", "input_formatter", "input_formsars", "input_formataters", "input_formsarts", "input_formsets", "input_operats", "input_FORMarts", "input_formatls", "input_formatats", "input_fears", "input_transformats", "input_formatATS", "input_operarts", "input_formatatter", "input_feats", "input_feutters", "input_facolds", "input_formatutters", "input_FORMATS", "input_commatives", "input_formsolds", "input_feations", "input_formands", "input_formsATS", "input_formls", "input_formsatives", "input_commaps", "input_transformars", "input_operations", "input_formsats", "input_formsands"], "err": ["yr", "code", "ner", "fe", "er", "sr", "rage", "res", "der", "usr", "msg", "dr", "doc", "rb", "var", "ise", "br", "cb", "type", "ler", "error", "gr", "mr", " Err", "bug", "fr", "num", "orig", "iter", "Error", "arr", "min", "str", "rh", "loc", "rar", "inner", "fi", " error", "ctr", "order", "cache", "kr", "req", "size", "ar", "ir", "count", "y", "nr", "pr", "n", "later", "resp", "init", "ver", "r", "attr", "rr", "result", "Er", "ind", "aster", "val", "g"], "i": ["abi", "z", "yi", "p", "m", "info", "c", "b", "ie", "ix", "x", "ti", "mi", "type", "phi", "qi", "ri", "id", "io", "ui", "u", "e", "li", "gi", "ji", "zi", "multi", "xi", "uri", "inner", "ini", "ii", "si", "bi", "di", "ni", "ai", "cli", "ci", "fi", "eni", "I", "f", "y", "oi", "chi", "j", "ip", "index", "t", "n", "iu", "ind", "r", "pi", "v", "mu"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n", "idx": 26175, "substitutes": {"errp": ["rarpc", "errpc", "rarp", "erpr", "errb", "rerr", "rerpre", " errr", "rrf", "rrp", "errpre", "rerlp", " errpp", "ryc", "errpp", "rerp", "erpc", "rrr", "err", "rrpc", " errb", "rarr", "rrpp", "errlp", "errr", " erf", " errf", " erp", "rarpr", "erpre", "rypp", " errpr", " errpc", "erb", " erpp", "rrb", "erp", "rrc", "erlp", " errpre", " errc", "ryp", "errc", " errlp", "errf", "errpr"], "win32_err": ["win32_er", "win16_er", "win16_nr", "win32__Error", "win64_Error", "win32__error", "win64_err", "win16_rr", "win32_Error", "win16_error", "win32_error", "win64_rr", "win32__rr", "win32_rr", "win32__err", "win32_nr", "win64_error", "win16_err"], "fmt": ["tfmt", "tfilt", "tfMT", "filt", "Fformat", " fMT", "formatirm", "formatMT", "FMT", " fformat", "formatmt", "Filt", "fMT", "tfformat", " filt", "fformat", "Fmt", "formatformat", "firm", " firm", "Firm"], "ap": ["pa", "ep", "apt", "snap", "gap", "nav", "af", "p", "app", "ae", "api", "capt", "ab", "hap", "up", "jp", "address", "ax", "aper", "av", "tap", "ast", "op", "rep", "ak", "mp", "al", "sp", "amp", "arr", "cap", "rap", " AP", "ang", "cp", "ape", "ar", "pat", "pac", "as", " sp", "array", "au", "ip", "arp", "a", "tp", "ha", "ag", "AP", "aps", "wa", "ac"], "msg1": ["cmdone", "msgone", "argone", "msg3", " msg7", "Msgp", " msg8", "cmd3", "doc1", "err3", "Msg7", "arg1", "msg8", "doc3", "err1", "argp", "cmd1", " msgone", "doc8", " msg3", "msg7", "cmd7", "err8", "Msg2", "Msg3", "err2", "doc2", "arg2", "cmdp", "errone", " msgp", "Msgone", "cmd2", "Msg1", "msgp"], "msg2": ["docsecond", "comm0", "MsgTwo", " msg4", " msg0", "og4", "message2", "doc1", "msgTwo", "Msg5", "doc0", "comm2", "msgsecond", "msg0", "og1", "msg5", "Msg2", "msg4", "Msg4", "ogTwo", "commsecond", " msgsecond", "message1", "og2", " msgTwo", "message5", "og5", "message4", "doc2", "comm1", "Msg1", " msg5"]}}
{"project": "FFmpeg", "commit_id": "0114c571d4c8cc1036850ced924683709390681a", "target": 1, "func": "void ff_MPV_frame_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n   } else if((s->error_count || s->encoding || !(s->avctx->codec->capabilities&CODEC_CAP_DRAW_HORIZ_BAND)) &&\n\n              !s->avctx->hwaccel &&\n\n              !(s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) &&\n\n              s->unrestricted_mv &&\n\n              s->current_picture.f.reference &&\n\n              !s->intra_only &&\n\n              !(s->flags & CODEC_FLAG_EMU_EDGE)) {\n\n        int hshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_w;\n\n        int vshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_h;\n\n        s->dsp.draw_edges(s->current_picture.f.data[0], s->current_picture.f.linesize[0],\n\n                          s->h_edge_pos, s->v_edge_pos,\n\n                          EDGE_WIDTH, EDGE_WIDTH,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[1], s->current_picture.f.linesize[1],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[2], s->current_picture.f.linesize[2],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n    }\n\n\n\n    emms_c();\n\n\n\n    s->last_pict_type                 = s->pict_type;\n\n    s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f.quality;\n\n    if (s->pict_type!= AV_PICTURE_TYPE_B) {\n\n        s->last_non_b_pict_type = s->pict_type;\n\n    }\n\n#if 0\n\n    /* copy back current_picture variables */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (s->picture[i].f.data[0] == s->current_picture.f.data[0]) {\n\n            s->picture[i] = s->current_picture;\n\n            break;\n\n        }\n\n    }\n\n    assert(i < MAX_PICTURE_COUNT);\n\n#endif\n\n\n\n    if (s->encoding) {\n\n        /* release non-reference frames */\n\n        for (i = 0; i < s->picture_count; i++) {\n\n            if (s->picture[i].f.data[0] && !s->picture[i].f.reference\n\n                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {\n\n                free_frame_buffer(s, &s->picture[i]);\n\n            }\n\n        }\n\n    }\n\n    // clear copies, to avoid confusion\n\n#if 0\n\n    memset(&s->last_picture,    0, sizeof(Picture));\n\n    memset(&s->next_picture,    0, sizeof(Picture));\n\n    memset(&s->current_picture, 0, sizeof(Picture));\n\n#endif\n\n    s->avctx->coded_frame = &s->current_picture_ptr->f;\n\n\n\n    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);\n\n    }\n\n}\n", "idx": 26183, "substitutes": {"s": ["comments", "sys", "w", "ns", "ts", "sq", "ps", "secondary", "states", "sync", "self", "sis", "u", "es", "gs", "http", "set", "sym", "xs", "f", "service", "qs", "js", "fs", "n", "t", "sim", "r", "ops", "S", "p", "m", "b", "c", "sports", "en", "ds", "us", "ins", "css", "su", "is", "sets", "ions", "spec", "aws", "services", "details", "settings", "its", "g", "rs", "ses", "args", "ss", "d", "conf", "sg", "ks", "e", "session", "sb", "sec", "full", "sf", "ssl", "cs", "site", "o", "si", "os", "uns", "as", "ls", "y", "a", "v", "l"], "i": ["p", "b", "c", "d", "counter", "it", "ri", "io", "id", "is", "u", "e", "li", "o", "xi", "ii", "I", "f", "ip", "j", "a", "index", "iu", "v", "r", "pi", "in", "l"]}}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191, "substitutes": {"f": ["ref", "fen", "uf", "fe", "family", "found", "w", "fo", "af", "i", "p", "m", "elf", "c", "b", "this", "fac", "d", "info", "of", "rf", "x", "bf", "conf", "fm", "form", "flow", "fr", "u", "lf", "e", "fc", "feed", "o", "ff", "flat", "inf", "fw", "fl", "new", "fi", "fb", "fx", "cf", "buff", "fs", "tf", "n", "j", "fa", "t", "fp", "z", "v", "r", "sf", "df", "fd", "file", "F"], "buf": ["ref", "head", "seq", "uf", "bag", "uc", "b", "p", "c", "wb", "context", "lb", "cv", "Buff", "data", "vec", "buffer", "queue", "base", "rb", "br", "cur", "bd", "cb", "bc", "port", "id", "num", "orig", "cmp", "lf", "mem", "ff", "cmd", "pb", "path", "ul", "loc", "fl", "box", "offset", "ctx", "cp", "fb", "cf", "rc", "alloc", "Buffer", "cache", "block", "ptr", "len", "length", "buff", "count", "src", "fp", "header", "v", "lim", "result", "fd"], "size1": ["ize0", "shapeone", "value1", "addressOne", "sizeone", "valueOne", " size0", "shapeOne", "Size0", " sizeOne", "Size1", "sizeOne", " sizeone", "shape1", "capacityOne", "size0", "address1", "ize1", "capacityone", "capacity1"], "size": ["L", "z", "name", "time", "ell", "url", "u", "hl", "li", "el", "SIZE", "min", "cl", "dl", "fl", "n", "code", "low", "ize", "m", "p", "c", "empty", "sized", "x", "storage", "address", "speed", "line", "s", "cache", "shape", "sl", "iz", "large", "len", "sn", "d", "no", "capacity", "Size", "e", "la", "small", "le", "like", "length", "lc", "count", "null", "page", "i", "ll", "position", "weight", "unit", "o", "loc", "cel", "si", "last", "gl", "scale", "y", "v", "kl"], "l": ["L", "acl", "z", "i", "b", "ll", "dL", "c", "lb", "shell", "ld", "en", "ell", "bl", "url", "u", "lf", "e", "al", "el", "li", "o", "lu", "cl", "rl", "ol", "la", "ul", "lr", "loc", "dl", "pl", "s", "fl", "cel", "le", "ln", "len", "length", "lc", "il", "ls", "lp", "lv", "jl", "n", "lo", "nl", "v", "sl", "r", "kl"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "substitutes": {"addr": ["ref", "node", "md", "code", "seq", "obj", " address", "Address", "arm", "name", "dr", "x", "asm", "data", "base", "pointer", "ad", "align", "address", "type", "dd", "port", "id", "alias", "url", "pad", "amp", "arr", "adr", "grad", "rm", "start", "ord", "loc", "offset", "coord", "order", "target", "hop", "ptr", "ar", "off", "arg", "dist", "amd", "rt", "ext", "nr", "rx", "src", "alt", "host", "index", "inter", "r", "pos", "ace", "rr", "attr", "tx", "len"], "rom": ["hom", "ru", "comm", " chrom", "rome", "comb", "cm", "ril", "RM", "m", "arm", "rod", "cry", "rn", "roll", "norm", "om", "cr", "am", "chrome", "ROM", "dom", "prom", "rob", "Rom", "dem", "ram", "cmd", "rc", "rm", "stim", "sym", "ray", "ros", "ctr", "tro", "com", "rock", "irm", "ro", "co", "roc", "roman", "rim", "im", "mod", "rem", "ore", "roy", "aram", "sim", "drm", "cum", "rx", "mm", "coll", "r", "rum", "chrom"]}}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226, "substitutes": {"opaque": ["pacity", "copca", " opaques", "oac", "pca", "opac", "oaque", "opaques", " opac", "oaques", "copace", "copaques", " opace", "oace", "opca", "opace", " opca", "copac", "paques", " opacity", "copacity", "paque", "opacity", "copaque"], "param": ["ref", "temp", "sem", "cm", "Param", "see", "info", "p", "m", "arm", "option", "name", "keep", "image", "asm", "sam", "config", "var", "am", "member", "conf", "type", "error", "meter", "iam", "sync", "prom", "reason", "key", "pri", "ram", "amp", "project", "adr", "resource", "grad", "pb", "atom", "prem", "advert", "rm", "model", "sym", "pool", "grade", "ctx", "problem", "pm", "change", "item", "channel", " Param", "vm", "aram", "Parameter", "arg", "rem", "update", "im", "part", "comment", "service", "source", "index", "mm", "par", "monitor", "block", "connection", "mark", "params"], "pagesize": [" pagesization", "Pagesized", "filesized", "filessize", " pagesz", "blocksiz", " pagesized", "codesiz", "pagesz", "codessize", "codesz", "filesize", "pagessize", "Pagesiz", "blockssize", "Pagessize", "Pagesz", " pagessize", "PagesIZE", "pagesization", "userssize", "Pagesize", "pagesIZE", "codesize", "usersization", "blocksization", "pagesiz", "blocksize", "usersize", " pagesiz", "pagesized", "usersiz", " pagesIZE", "filesIZE"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234, "substitutes": {"regs": ["regm", "signps", "pools", "REGses", "rols", "RegS", "regses", "regS", "signs", "regals", "roundfs", "lics", "rounds", "Regs", "gregals", " regps", "gregs", "Regds", "licm", "rolS", "Regses", "poolfs", "rolses", "regds", "rolds", "REGs", "poolals", "regps", " regm", "REGds", "roundals", "gregfs", "licps", "regfs", "REGS", "signm"], "frame": ["fram", "processor", "framework", "code", "element", "node", "thread", "slice", "fe", "zone", "parse", "position", "image", "function", "frames", "module", "buffer", "scene", "base", "raise", "component", "config", "feature", "hide", "version", "instance", "motion", "fr", "profile", "boot", "e", " Frame", "line", "point", "cfg", "message", "tick", "cpu", "object", "role", "sequence", "target", "setup", "cf", "fb", "fi", "channel", "fake", "game", "iframe", "update", "window", "f", "Frame", "host", "header", "event", "ace", "que", "connection", "file", "ze"], "frame_addr": ["frame_offset", "frame_ptr", "fram_ptr", " frame_adr", "fram_addr", " frame_address", "frame_oa", "fram_address", "frame_ord", "fram_ord", "frame_adr", " frame_ord", " frame_oa", "frame_address", " frame_offset"], "blocked": ["BLock", " bllocked", "Bllocked", "BLOCK", "bllocked", "clock", "clocking", "plocking", "pllocked", "plOCK", "BLlocked", "clocked", "cllocked", "Blocked", "plock", "Block", "BLocking", "blOCK", "BLocked", "Blocking", " block", " blocking", "BlOCK", "block", "plocked", "blocking"], "target_set": [" target_sync", "targetvalrun", "host_set", "target_clear", "message64clear", "target_sche", "message_sche", "targetvalsets", "targetssc", "component_sets", "message_clear", "target_switch", "message64sche", "target_site", "host_switch", "componentssets", "target_Set", "component_run", "targetvalset", "message_site", " target_Set", "target_run", "target64site", " target_sc", "message64set", "host_SET", "targetsset", "targetvalexport", "target_sc", "targetsSet", "component_export", "target_SET", "target64set", "componentsset", "component_set", "message_set", "target64clear", "host_setup", "target_sync", "message64site", "componentsexport", "target_setup", "targetssets", "targetsexport", "target_export", "target64sche", "target_sets", "targetsrun", "componentsrun", "targetssync"], "r0": ["Rloop", " r180", "result180", "r1", " r1", "rr0", "x0", "x1", "R2", "result0", " r2", "r180", "result1", "r2", "rr1", "rr180", "R0", "sr1", "xloop", "srloop", "sr0", "return2", "rloop", "return0", "return1", "R1"], "i": ["code", "z", "yi", "p", "b", "m", "c", "ie", "page", "d", "x", "ti", "qi", "it", "ri", "io", "id", "ui", "u", "e", "key", "li", "gi", "o", "zi", "err", "multi", "xi", "uri", "start", "ii", "cli", "si", "ai", "bi", "ni", "ini", "di", "ci", "fi", "length", "part", "I", "f", "y", "oi", "n", "j", "ip", "index", "a", "v", "iu", "r", "pi", "ind", "mu", "l", "hi", "in"]}}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 26242, "substitutes": {"dev": ["ve", "md", "sk", "w", "p", "app", "d", "data", "test", "ds", "conf", "diff", "debug", "def", "priv", "dd", "ev", "dom", "prom", "self", "tr", "dem", "hw", "grad", "di", "req", "device", "mod", "development", "pro", "des", "conn", "dm", "devices", "Dev", "de", "sd", "ver", "rad", "cam", "g"], "s": ["S", "rs", "ses", "sys", "w", "ss", "p", "i", "b", "c", "m", "ns", "d", "data", "sq", "ds", "us", "ps", "sg", "state", "sync", "self", "su", "is", "u", "e", "es", "south", "o", "spec", "less", "si", "sym", "os", "sb", "services", "device", "f", "service", "fs", "js", "details", "tests", "a", "an", "rad", "sd", "v", "sl", "r", "t", "sf", "g", "settings", "ssl", "cs", "sh"], "info": ["abi", "fo", "i", "app", "name", "data", "api", "conf", "type", "error", "kind", "id", "op", "is", "link", "gi", "o", "iso", "afi", "Info", "INFO", "fw", "inf", "si", "bi", "ii", "mis", "os", "ci", "fi", "thin", "block", "tech", "f", "fs", "service", "init", "ui", "hi", "by"], "bsp": ["skip", "sc", "sk", "butt", "gap", "p", "spl", "wb", "lb", "hops", "bb", "frac", "ab", "br", "bf", "bh", "bd", " fab", "gb", "bl", "bc", "www", "bp", "sync", "split", "bs", "blast", "kb", "fab", "sp", " esp", "amp", "pb", "nb", "nc", "eb", "fee", "bi", "sb", "fi", "fb", "abb", "esp", "wp", " sp", "buff", "occ", " disp", "lp", "loop", "bg", "abl", "bm", "blog", "sl", "Sp", "bt", "pc", "ib", "isp"]}}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n", "idx": 26243, "substitutes": {"base": ["build", "temp", "body", "bin", "i", "b", "p", "bas", "frame", "name", "c", "server", "bat", "x", "bare", "buffer", "back", "weight", "bf", "gb", "address", "ases", "prefix", "type", "ada", "state", "support", "bp", "kb", "store", "id", "orig", "db", "boot", "site", "extra", "home", "work", "padding", "max", "old", "start", "bit", "ase", "kit", "bi", "last", "Base", "scale", "cache", "addr", "proxy", "reset", "count", "f", "total", "source", "prot", "index", "null", "bg", "core", "full", "init", "root", "ace", "bt", "file", "area"], "s": ["S", "rs", "ses", "sys", "w", "scope", "i", "p", "b", "ss", "c", "ns", "server", "d", "features", "ts", "storage", "sq", "ds", "conf", "us", "state", "states", "sync", "self", "su", "is", "u", "e", "es", "south", "stats", "gs", "o", "site", "sets", "session", "spec", "l", "sym", "si", "os", "sb", "services", "ls", "f", "service", "fs", "n", "js", "src", "a", "t", "sl", "settings", "sf", "ssl", "cs", "g"], "clk": ["Clks", "Clb", " clok", "plp", "selp", "clok", "selb", "plq", "clks", "blks", "clb", "plks", "selq", "plk", "blp", "blb", " plks", "Clok", "clq", " plok", "Clk", "selk", "blk", "clf", " clb", " clp", " clks", "clp", "Clf", "plb", " clq", " plk", "Clp", " plf", " clf"], "iomemtype": ["iomemsid", "iomellike", "iotagtype", "iopimype", "iomimpe", "iopemlock", "iomemType", "iopemid", "iotempy", "iomempy", "iomeelock", "iomemslike", "iopemType", "iomemty", "iopimlock", "iomemstype", "iomealype", "iopellike", "iotemty", "iomompy", "iomeltype", "iopemlike", "iomemsType", "iotagpy", "iomagtype", "iomemlike", "iomeetype", "iomagpy", "iomimtype", "iomapertype", "iomemlock", "iopelid", "iomelid", "iomomtype", "iopemtype", "iomomtag", "iomomty", "iopempe", "iotagtag", "iomempe", "iomealtype", "iomealpe", "iomaxpy", "iotagty", "iomaxty", "iomagtag", "iomemtag", "iomeallock", "iotemtag", "iopimpe", "iomimlock", "iomeepe", "iomaxtype", "iopimtype", "iomeeype", "iopelType", "iomemype", "iopeltype", "iomelType", "iomaperid", "iomagty", "iomimype", "iomemid", "iomaperlike", "iotemtype", "iomaperType", "iopemype", "iomaxtag"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n", "idx": 26245, "substitutes": {"vs": ["rs", "sk", "ss", "ns", "va", "flags", "ov", "ils", "Vs", "ts", "ms", "ds", "verts", "vt", "ps", "vas", "vers", "ks", "bs", "vv", "vals", "ys", "es", "gs", "stats", "s", "lines", "sts", "sv", "points", "os", "sb", "utils", "services", "series", "plays", "xs", "serv", "ls", "fs", "qs", "js", "alls", "v", "settings", "ops", "VS", "vp", "cs", "env"], "x": ["xx", "k", "z", "yi", "p", "b", "m", "c", "d", "wy", "ix", "px", "on", "ax", "X", "u", "wx", "e", "xy", "o", "ic", "xi", "yx", "ctx", "ci", "xs", "xxx", "ry", "win", "f", "rx", "index", "t", "n", "wa", "q", "v", "g", "ex", "l", "hi", "ya", "sh"], "y": ["k", "z", "yi", "b", "p", "m", "c", "oy", "dy", "sy", "d", "ya", "yt", "ay", "py", "ye", "gy", "cy", "ch", "vy", "u", "yo", "e", "ey", "o", "s", "ky", "Y", "ry", "f", "ny", "n", "a", "t", "q", "v", "ty", "l", "yy", "g"], "w": ["k", "z", "b", "p", "c", "m", "sh", "wb", "d", "sw", "wh", "u", "wx", "e", "hw", "s", "fw", "wd", "ew", "win", "f", "wt", "n", "W", "a", "wa", "q", "v", "we", "l", "g"], "h": ["hm", "ht", "k", "th", "z", "b", "p", "m", "c", "sh", "d", "H", "hh", "ch", "u", "e", "o", "s", "hs", "gh", "f", "n", "t", "q", "v", "r", "l", "hi", "ph", "oh", "g"], "i": ["k", "z", "yi", "p", "b", "m", "c", "ie", "d", "ix", "mi", "qi", "it", "io", "id", "u", "e", "o", "li", "ji", "xi", "ii", "di", "si", "ai", "ini", "ni", "ij", "ci", "vi", "f", "I", "n", "ip", "a", "index", "v", "iu", "ind", "pi", "ui", "l", "hi"], "j": ["k", "z", "ie", "p", "b", "m", "c", "dy", "uj", "d", "je", "jo", "jp", "aj", "qi", "ch", "jj", "u", "e", "o", "ji", "li", "jc", "ii", "si", "ij", "oj", "f", "jl", "js", "n", "t", "v", "J", "r", "l", "ja", "g"], "has_fg": ["last_fb", " has_fx", "hasNfw", "has_fb", "last_feat", "has_fw", " has_feat", "hasNfg", " has_fw", "hasNbg", "has_fx", "has_fig", "hasNfig", " has_fig", "has_feat", " has_cf", "has_cf"], "has_bg": ["last_focus", "has_border", "has___border", "last_background", "last_mag", "has___mag", "has_mag", "has_background", "has67bc", "has67bg", "has___bg", "has___fg", "has_focus", "has67fg", "has_blue", "has67focus", "last_bc", "has_bc", "last_blue", "last_border"], "last_fg": ["best___config", " last_pg", "first_tier", "best_auth", "last___auth", "lastlyfg", "last_id", "last_cfg", "last__bg", "best___auth", "last___fg", "last_tier", "last___ff", "last_pg", "last__ff", "best___fg", "best___cfg", "last___cfg", "last___config", "best_cfg", "first_config", "lastlyid", " last_id", "last_feat", "last_auth", "best_config", "lastlybg", "first_fg", "last__fg", "first_ff", "last___bg", "last_config", "lastlypg", "last_ff", "best_fg", "first_bg", "last__config", "first_feat"], "last_bg": ["last_fb", "last67fg", "last67fb", "first_bin", "last67bg", "last67BG", "last_blue", "lastObg", "last_bin", "first_blue", "lastOconfig", "lastallb", "first_fb", "lastalblue", "last_config", "lastalfg", "last_BG", "first_bg", "last_lb", "first_BG", "lastalbg", "first_lb", "first_fg", "lastObin", "lastOfg", "first_config"], "vd": ["md", "vg", "dc", "xd", "cd", "va", "d", "hd", "ov", "eddy", "ld", "ds", "vr", "nv", "bd", "vt", "gb", "dd", "ud", "vv", "db", "disk", "hw", "td", "vid", "pd", "dh", "vc", "nd", "dl", "gd", "di", "dt", "wd", "fb", "vm", "VD", "rt", "lv", "dm", "sd", "v", "od", "dq", "df", "sv", "fd", "dn"]}}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 26251, "substitutes": {"bs": ["rs", "ses", "obj", "iss", "b", "bis", "bas", "lbs", "ss", "ns", "lb", "bb", "vs", "base", "ds", "bf", "bh", "gb", "cb", "bos", "bc", "BS", "bl", "ps", "us", "ins", "bu", "bus", "is", "db", "gs", "ba", "cms", "ubs", "pb", "s", "eb", "bi", "os", "bes", "fb", "obs", "sb", "lc", "bid", "ls", "fs", "src", "bt", "cs", "banks", "ib"], "sector_num": [" sector_number", "sectorIDnumber", "sector_number", "sector_set", " sector_set", "sector_block", "sectorIDset", " sector_block", " sector_name", "sectorIDnum", "sectorIDname", "sector_name"], "buf": ["ref", "seq", "uf", "abi", "bag", "b", "batch", "wb", "uno", "cv", "Buff", "buffer", "queue", "vec", "data", "rb", "br", "bf", "gb", "cb", "bc", "num", "fab", "pb", "binary", "pool", "ctx", "fb", "sb", "rc", "alloc", "conv", "cas", "buff", "array", "src", "fp", "block", "fd"], "nb_sectors": ["nb_pseapters", "nbofseapters", "nb_serets", "nb_SEctors", "nb_Selements", "nb_Segments", "nb_veapters", "nb_psections", "nb_serctors", "nb_pecs", "nb_vector", "nb_vecs", "nbofSEctions", "nb_vectors", "nb_secctors", "nbofSEapters", "nb_seclements", "nb_SEgments", "nb_vections", "nb_seapters", "nb_SEctions", "nb_sector", "nbofsections", "nb_pegments", "nb_pector", "nb_sections", "nb_sercs", "nbofSEctors", "nb_selements", "nb_SElements", "nb_pserets", "nb_sergments", "nbofserets", "nb_SEapters", "nb_psectors", "nb_SErets", "nb_secrets", "nb_pectors", "nb_verets", "nb_Serets", "nb_secs", "nbofsectors", "nb_serctor", "nb_segments", "nb_Sectors", "nb_secgments", "nb_vegments", "nbofSErets"], "async_ret": ["async2Ret", "async_return", "asynchronous_RET", "asynchronous_rets", "asyncPback", "async_alt", "assync_result", "asynchronous_back", "async2alt", "async_rets", "asyncPrets", "asyncPbreak", "async2def", "asynchronous_Ret", "asynchronous_result", "async_break", "async_back", "assync_rets", "async2ret", "async_Ret", "assync_ret", "async2rets", "async2result", "assync_return", "asynchronous_ret", "assync_RET", "async_def", "assync_def", "async_result", "async_RET", "asyncPret", "assync_alt", "async2return", "asynchronous_break", "assync_Ret", "async2RET", "asynchronous_return"], "acb": ["acbr", "acl", "axbe", "Acf", "acbs", " acp", " acl", "Acb", "ACb", " acbe", "Acbr", "acbe", "axsb", "ecbr", "ecp", " acbr", " acbs", " acsb", "axb", "ecbe", "acp", "ACp", "acsb", "ACf", "ecbs", "Acl", "axbs", " acf", "Acp", "acf", "ecsb", "Acbe", "ACl", "ecb"], "iov": ["ibr", "nih", " virt", "uno", "iris", "gru", "iev", "soc", "imedia", "anni", "vre", "oren", "voice", " multimedia", "veh", "nox", "audi", "liv", "udi", " io", "wikipedia", " nem", "rob", " guardian", "oyer", "odi", "ibl", "mus", "wav", "fi", "rov", "ovi", " ensemble", "eni", "icho", "iv", "gio", " mech", "ilo", "club", "iro", " bio", " voc", "rolet", "userc", "iol", "\u00ef", "drm", "obo", "lov", "ilib", "imi", "irin", "voc", "iop"], "qiov": ["wicho", "qqiov", "qqliv", "quliv", "qqiop", "quuno", "pilo", "picho", "quilo", "wiev", "quicho", "fiov", "fliv", "wilo", "fiop", "quiop", " qiol", "quno", "xicho", " qilo", "ficho", " quno", "xiov", "wiov", "qiev", "quiol", "qicho", "qqicho", "qiol", "xilo", "xiev", "qiop", "qqilo", "piov", "qliv", "piev", "qilo", "quiov", "qquno", "qqiol"]}}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26257, "substitutes": {"cpu": ["CPU", "processor", "node", "pp", "np", "chip", "cca", "uc", "p", "c", "lb", "px", "ec", "config", "jp", "platform", "ocr", "proc", "linux", "gpu", "cmp", "environment", "fc", "hp", "hw", "prem", "uri", "nc", "cli", "pool", "ctx", "cp", "cow", "cn", "gp", "eni", "cache", "rc", "eu", "vm", "ro", "lc", "uu", "computer", "conn", "cpp", "net", "core", "pu", "uci", "colo", "que", "pc", "pid"], "env": ["exec", "her", "exc", "server", "pg", "enable", "enc", "vs", "export", "inet", "ne", "visor", "el", "dev", "cf", "current", "uv", "f", "n", "core", "nc", "et", "code", "engine", "c", "ec", "en", "Environment", "state", "ocr", "proc", "energy", "target", "eni", "cache", "oa", "h", "forge", "stage", "que", "equ", "gui", "txt", "args", "np", "console", "scope", "ass", "context", "conf", "global", "loader", "ev", "ea", "db", "e", "cfg", "extra", "err", "cli", "output", "exe", "cp", "req", "fg", "host", "header", "init", " environment", "org", "age", "style", "config", "end", "environment", "site", "hw", "esi", "dat", "viron", "ctx", "eu", "iv", "vm", "ext", "conn", "net", "v", "eng"], "sregs": ["sstatps", "southreturns", "ucondns", " ssecments", "sregions", "ssecments", "srigjs", "servicesreqions", "servicesreglines", "srefions", "sregp", "srefgs", "ssconnstates", "southregs", "slimmaps", " ssecses", "servicesregions", "srigions", "ssREGi", "slims", "ssecses", "sfuns", "ssregi", "sfunps", "sconnns", "sreturnps", " sregf", "sregstates", "southreturnlines", "dsregs", "sreturns", "sconfigp", "sREGp", "ssconnns", "sgraphments", "srogns", " sconfigjs", "servicesreqmaps", "sysreljs", "sregns", "sregjs", "sreqions", "sregps", "sprogramf", "srefjs", "ssregstates", " sconfiggs", "uregns", "sreggs", "scondf", "dsregists", "sribses", "slegps", "slimions", "srelings", "sregmaps", "servicesregmaps", "sREGs", "sysrels", "ssregs", "scondps", "uconds", "sreturnd", "uregs", "sribments", "srigmaps", "srefp", "sriglines", "sgraphses", "slegists", " sregjs", "sprograms", "servicesreqs", " sregments", "ureglines", "sREGn", "sreglines", "uregions", "sconfigi", "sreqlines", "ssREGs", "sreqs", "slimlines", "ssregp", "sysregs", " sconfigp", "southreglines", " sregp", "sregi", "southregps", "ssregn", "srogs", " sregns", "sRegstates", "sRegns", "sfunists", "sregses", "southregd", "ssREGp", "srecn", "sribs", "sregf", "servicesregs", "sgraphs", "sreflines", "sregd", "srogf", "sconds", "sconfign", "scountlines", "ssregns", "srefs", "sconfigs", "ssecs", "dslegists", "sprogramns", " sconds", "servicesreqlines", "scomps", "sysregjs", "scounts", " sregses", "srecs", "srecgs", "slimps", "srecp", "srefns", "ssecstates", "srecjs", "sRegs", "sstats", "southreturnps", " sconfigs", " sreggs", "ucondlines", "sregn", "sregists", "ssREGn", "srigs", "dslegps", "sconfigjs", "scompings", " ssecs", "scondions", "sconns", "scompjs", "sreljs", "slegs", "ucondions", "scondlines", " scondns", "ssecns", "sreqmaps", "ssconns", "srels", "sconfiggs", "sysregings", "sstatists", " scondf", "sysrelings", "dslegs", "srigings", "dsregps", "southreturnd", "sregings", "slimd", "scondns", "scountions", "scondd", "scountns", "sreci", "sregments", "sreturnlines", "sconnstates", "sREGi"], "ret": ["ref", "code", "fin", "ft", "res", "af", "pt", " RET", "cat", "flag", "back", "cur", "success", "att", "def", " Ret", "xt", "num", "id", "rets", "al", "get", "bit", "mt", "det", "lit", "RET", "last", "re", "art", "nt", "fi", "sec", "rc", "bot", "let", "len", "pat", "feat", "arg", "Ret", "rt", "part", "t", "alt", "reg", "out", "inter", "r", "_", "result", " arg", "val", "gt", "ut", "fun"], "i": ["ski", "ie", "name", "\u0438", "ei", "it", "io", "u", "li", "start", "set", "ini", "bi", "ai", "f", "n", "j", "r", "chi", "val", "p", "b", "m", "c", "x", "en", "ti", "mi", "phi", "qi", "ri", "rep", "is", "key", "s", "di", "result", "ci", "eni", "vi", "isin", "ki", "len", "g", "yi", "d", "isi", "data", "e", "err", "uri", "ii", "cli", "fi", "I", "ori", "reg", "init", "iu", "info", "ix", "api", "id", "gi", "o", "ji", "zi", "multi", "esi", "xi", "si", "ni", "iv", "y", "oi", "ip", "index", "a", "v", "ind", "mu", "pi", "ui", "l", "hi"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    uint32_t ram_offset;\n\n    qemu_irq *pic;\n\n    qemu_irq *cpu_pic;\n\n    int sd;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    integratorcm_init(ram_size >> 20);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],\n\n                       cpu_pic[ARM_PIC_CPU_FIQ]);\n\n    icp_pic_init(0xca000000, pic[26], NULL);\n\n    icp_pit_init(0x13000000, pic, 5);\n\n    pl031_init(0x15000000, pic[8]);\n\n    pl011_init(0x16000000, pic[1], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 26259, "substitutes": {"ram_size": ["ramxslice", "ram_shape", "ram_bytes", "rum_size", "gram_size", "ram64length", "ram67shape", "gram_offset", "ram_length", "ram_6", "ram_slice", "rum_limit", "mem_size", " ramxsize", "ramxsize", "ramingsize", " ram_scale", "rumxlimit", "ram67offset", "mem_ize", "rumxsize", "ram_scale", " ramxlength", " ramxscale", "ram_SIZE", "mem64length", "ramlexbytes", "ram64size", "ram64offset", " ram_length", " ram_slice", "gram_6", "ramxscale", "mem_offset", "rum_SIZE", "ramxlimit", "mem64offset", "rumxSIZE", "ram_ize", "ramlexlength", "mem64bytes", " ramxslice", "mem_shape", "rum_offset", "ramxSIZE", "mem_length", "ram67size", "mem64size", "ram64bytes", "ramlexoffset", "rumxoffset", "ramingoffset", "ramlexsize", "ramxoffset", "ram_limit", "ram67ize", "raming6", "mem_bytes", "ramxlength"], "vga_ram_size": ["vga_mem_size", "vga_mem_len", "vga_ram_len", "vga_mem_length", "vga_ram_length"], "boot_device": ["usb_device", "bootbookmode", "bootingdevice", "bootingmode", "usbingmode", "usb_channel", "boot_channel", "bootingobject", "usb_object", "boot_object", "bootbookdevice", "usbingobject", "bootbookobject", "bootingchannel", "usbingchannel", "boot_mode", "usbingdevice", "bootbookchannel", "usb_mode"], "ds": ["dds", "DS", "rs", "ss", "ded", "ns", "der", "ils", "vs", "ld", "ps", "dd", "cons", "ks", "bs", "db", "ys", "pd", "dh", "cdn", "dt", "nas", "ls", "fs", "des", "da", "df", "tx", "cs"], "kernel_filename": ["kernel__file", "boot_location", "boot_file", "kernel__location", "kernel_files", "boot_files", "boot_filename", "kernel_file", "kernel__files", "kernel_location", "kernel__filename"], "kernel_cmdline": ["kernel_hostline", "kernel_cmdfile", "kernel_bootfile", "kernel_bootline", "kernel_cmdend", "kernel_hostfile", "kernel_bootname", "kernel_hostend", "kernel_commandfile", "kernel_bootend", "kernel_cmdname", "kernel_commandname", "kernel_commandend", "kernel_commandline", "kernel_hostname"], "initrd_filename": ["initrdamesmessage", "initrdamesfilename", "initrm_filename", "initrd_directory", "initrm_file", "initrm_message", "initrdamesfile", "initrd_file", "initrdamesdirectory", "initrd_message", "initrm_directory"], "cpu_model": ["cpujmodels", " cpu_source", "kernel_image", "gpu_models", " cpu_system", "cpu_image", "kernel_channel", "gpu_control", "cpu_models", "cpu_device", "cpu__model", "cpuermodel", "core_mode", "gpu_mode", "kernel_model", "cpu_mode", "cpu_channel", "kernel_device", "cpuermode", " cpu_models", "core_device", "cpuerdevice", "cpujmodel", "cpujsystem", "cpu__device", "cpu_control", "cpu__channel", "core_Model", "cpu_Model", "gpu_model", "cpu__image", "cpuerModel", "cpujsource", "cpu_system", "cpu_source", "core_model"], "env": ["exec", "her", "obj", "sys", "console", "args", "virt", "iss", "scope", "exc", "empty", "context", "ov", "enable", "vs", "enc", "me", "ec", "qt", "img", "en", "Environment", "config", "vt", "export", "conf", "bc", "style", "priv", "global", "dict", "ev", "loader", "ea", "inet", "environment", "ne", "proc", "db", "e", "hw", "el", "session", "spec", "viron", "ctx", "ras", "eu", "cf", "eni", "cache", "iv", "oa", "ext", "conn", "net", "v", " environment", "nc", "et", "equ", "lock"], "ram_offset": ["ramssize", "ramlsize", "ramslocation", "ramfoffset", "ram___addr", "ram_index", "ram_location", "ram_addr", "ram67size", "mem_length", "ram___offset", "ram_address", "gram_index", "mem_size", "ramloffset", "ramsoffset", "mem_offset", "mem_loc", "ramslength", "ram67length", "ram_loc", "ream_size", "ramfaddress", "ram___size", "ram_limit", "mem_location", "ramlloc", "gram_size", "ram67offset", "gram_limit", "ream_addr", "ramllocation", "ramfaddr", "gram_offset", "ream_offset", "ram___address", "ram67location", "ram_length", "ramfsize", "ream_address"], "pic": ["picture", "seq", "gui", "txt", "sys", "bin", "pot", "parse", "nat", "dim", "train", "image", "mot", "enc", "doc", "kin", "pins", "capt", "study", "style", "config", "circ", "jp", "cus", "feature", "bc", "cycle", "pass", "mac", "sync", "proc", "typ", "mic", "piece", "fc", "disk", "script", "pse", "ic", "lic", "tick", "cpu", "nic", "xi", "loc", "spec", "jc", "lib", "cli", "ig", "drive", "fig", "pin", "fi", "mc", "cache", "sci", "fat", "feat", "quad", "Pic", "lc", "quin", "pick", "mini", "pull", "pres", "pict", "vir", "pen", "pc"], "cpu_pic": ["cpu__model", "cpu_config", "cpu_cycle", "cpu__pid", "core_pc", "gpu_pic", "cpuxmodel", "cpu__pins", "core_cycle", "processor_pic", "processor_pid", "cpu_gui", "core_pin", "core_config", "gpu_pins", "cpu__gui", "gpu_pin", "cpu__pic", "core_pic", "processor_model", "cpuxpid", "processor_pin", "cpu_pid", "cpu_pins", "cpu_nic", "gpu_gui", "cpuxpic", "cpu__pin", "cpu_pin", "cpuxpin", "cpu_pc", "core_nic"], "sd": ["md", "std", "xd", "cd", "ss", "dim", "sn", "ded", "d", "ay", "hd", "ism", "dis", "ld", "ad", "gb", "bd", "ada", " td", "dd", "ud", "ed", "su", "db", "ity", "sp", "td", "pd", "nd", "dl", "gd", "di", "si", "sb", "SD", "dist", " sp", "sil", "vd", " SD", "od", "ind", "sl", " dd", "sf", "fd", "dk"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n", "idx": 26291, "substitutes": {"mon": ["bin", "m", "master", "bo", "met", "Monitor", "module", "mi", "mid", "meter", "mat", "mut", "dom", "mos", "mag", "MON", "mem", "con", "prem", "min", "mt", "ann", "mn", "mun", "pin", "mand", "mo", "pm", "mc", "com", "mor", "man", "mod", "mini", "flo", "dm", "mm", "un", "mu", "Mon", "monitor", "mons"], "qdict": ["Qdat", "qqict", "qdata", "qqdata", "Qict", "qict", "qqdict", "qdat", " qdata", " qict", " qdat", "Qdict", "qqdat", "Qdata"], "bdev_list": ["bblock_parent", "bdev_last", "bdevscl", "bblock_last", "bdev_List", "bdev_l", "bdev_cl", "bdevicestype", "bdevice_type", "bblock_list", "bdevstype", "bdevsList", "bdevice_set", "bdevsset", "bdev_block", "bdeviceslist", "bdevicesset", "bdevice_block", "bdevicesblock", "bdevslist", "bdevsblock", "bdev_default", "bdevice_List", "bdevice_list", "bdevice_l", "bblock_default", "bdev_parent", "bdev_set", "bdev_type"], "bdev": ["bdiv", "lbdev", "Bdevice", " bdef", " bdiff", "bDev", " bver", "vdef", "lbver", "fev", "rbdevice", "vDev", "bev", "fdiff", "sbcase", "bde", "fdev", "rbdiff", "ambdev", "fdiv", "bbdef", "lbdevice", "Bev", " bdiv", "bdem", "lbDev", "ambdem", "Bcase", "sbdevice", "fdem", "bbdev", "bdevice", "lbev", "ambev", "Bdiv", "bdiff", "bbdiff", "lbde", "lbdef", "bver", " bDev", " bev", "bcase", "bbcase", "sbev", " bde", "bbdevice", "sbdev", "fde", "ambdevice", "bbdem", "bbev", "Bdev", "bdef", "rbdev", "rbdef", " bdevice", "vver", "lbdiff", "vdev", "fdevice"], "err": ["her", "ner", "sys", "er", "rage", "der", "dr", "acer", "oller", "cr", "ler", "gr", "error", "mr", "bug", "erer", "ev", "ra", "fr", "proc", "orig", "e", "cfg", "arr", "Error", "rh", " er", "lr", "inner", "result", "order", "rc", "ar", "ir", "fg", "cor", "f", "pr", "rx", "resp", "runner", "erg", "ind", "r", "eor", "Er", "rr", "org", "tx"]}}
{"project": "FFmpeg", "commit_id": "49cf36f4e3e9183611859af1a07dc6a82ab47288", "target": 1, "func": "static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 26294, "substitutes": {"ctx": ["txt", "sc", "cm", "acl", "obj", "cca", "anc", "c", "pkg", "context", "cv", "qa", "xc", "config", "component", "ct", "bc", "concept", "css", "cmp", "fc", "hw", "cms", "grad", "vc", "loc", "fw", "cli", "cal", "Context", "nt", "cc", "cn", "ci", "cf", "ctr", "rc", "cp", "sci", "conv", "utils", "cas", "client", "lc", "ctrl", "ca", "tc", "cu", "conn", "src", "cpp", "fp", "nc", "tx", "cs", "cam", "pc", "kt"], "frm": [" frmc", "ferf", "frmi", "trm", "trM", "trmi", " frf", " frp", "frp", " frd", "fm", "brM", "brmi", "ferms", " frcm", "drcm", "drd", "fcm", "ferm", "prmc", "brmc", "frmc", " frmi", "brm", "prms", "trms", "frms", "frcm", " frM", "drms", "frM", "brf", "brp", "prm", "drm", "fms", "prmi", "frf", "frd", " frms", "ferp", "fd", "brms"], "npixels": ["pels", "apips", "npicks", "nports", "NPowers", "apels", " nports", "fpicks", "NPixels", "upixel", "npowers", "ispels", "pixel", "bpixel", "uports", "pips", " npips", " npamples", "npamples", "fpips", "npels", "upixels", "apixels", "bpixels", "npips", "pixels", "spamples", "apixel", "spowers", "NPamples", "spips", "ispixels", "fpixels", "NPips", "picks", "NPixel", " npixel", "spixels", "bpips", "NPorts", "ispips", "fpixel", "npixel", " npowers", "ispixel", "bpicks", "upips"], "dst": ["Dfe", "rdsts", "rdbl", "bst", " dsts", "dsts", "rdst", "dfe", " dfe", "DST", "dST", "bsts", "Dsts", "ddr", "bST", "sddr", " ddr", "rddr", " dbl", "dbl", "sdsts", "sdst", "bfe", "sdbl", " dST", "Dst"]}}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306, "substitutes": {"obj": ["node", "args", "z", "i", "p", "ass", "objects", "c", "bo", "ns", "m", "b", "module", "x", "data", "Object", "orb", "rb", "jp", "act", "so", "inst", "instance", "self", "bus", "boot", "e", "office", "o", "obb", "object", "os", "ctx", "sb", "oa", "iv", "Obj", "active", "f", "po", "js", "n", "j", "src", "t", "init", "v", "ops"], "s": ["S", "rs", "sys", "scope", "ss", "p", "m", "b", "c", "ns", "ts", "sq", "ds", "so", "secondary", "states", "sync", "e", "south", "o", "session", "l", "sym", "os", "sb", "services", "f", "fs", "js", "service", "n", "an", "sl", "sf", "ops", "settings", "ssl", "g"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315, "substitutes": {"opaque": ["pacity", "openaques", " opaques", "copaque", "oplaques", "oaque", "opaques", "oacity", "oaques", "pque", "openacity", "copaques", "openaya", "oplaya", "oplaque", "opaya", "paques", " opque", "copacity", " opacity", "paque", "openaque", "opacity", "opque", "oaya", "oplacity", "copque"], "data": ["load", "Data", "code", "call", "info", "batch", "aa", "d", "ae", "module", "ready", "style", "config", "ad", "no", "ada", "type", "error", "reader", "state", "dd", "sync", "op", "rec", "ee", "li", "o", "input", "dat", "la", "object", "one", "di", "change", "client", "cache", "missing", "ata", "as", "comment", "po", "entry", "child", "da", "a", "coll", "DATA", "results", "cookie", "init", "meta", "alpha", "result", "writer"], "co": ["call", "cm", "can", "cca", "CO", "cost", "c", "bo", "oo", "ob", "bb", "soc", "col", "cb", "bc", "so", "cycle", "ra", "company", "oe", "self", "coe", "con", "o", "cl", "loc", "ko", "cro", "cc", "coord", "ci", "mo", "cf", "mc", "rc", "Co", "ca", "aco", "po", "flo", "coll", "ck", "ac", "pc"]}}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n", "idx": 26320, "substitutes": {"mon": [" monitor", "wan", "param", "bin", "m", "master", "bo", "mail", "met", "Monitor", "manager", "mount", "module", "mot", "config", "mi", "col", "type", "meter", "mat", "mut", "dom", "mos", "plugin", "boot", "MON", "mag", "wat", "min", "phys", "ann", "mn", "mun", "mand", "mo", "pm", "mc", "mor", "man", "mini", "flo", "tun", "conn", "mm", "dm", "un", "an", "amon", "mu", "Mon", "monitor", "connection", "mons", "lock", "pid"], "qdict": [" qdf", "quobj", "qdetails", "qudd", "qict", "qudf", "wictionary", "querydict", "workobj", "workictionary", "qdb", "workdb", "querydd", "bugict", "rydom", " qdom", "qtcoll", "bugdict", "querydf", "qudetails", "quict", " qdb", "kictionary", "qucoll", "qictionary", "dqdict", "qdd", "quictionary", "qudb", "Qdf", " qdd", "bugdd", "qulist", " qdetails", "Qdom", "qobj", "workdict", "rydict", "ryict", "qdf", "kdict", "dqict", " qlist", " qict", "bugictionary", "qtdetails", "rydf", "Qdb", " qcoll", "qtdict", "qcoll", "qlist", "wdd", "kdb", "qtlist", "querycoll", "wdict", "qdom", "Qict", "dqdb", "qudict", "kobj", "wict", "Qdict", "dqdf"], "ret_data": ["ret0data", "ret0map", "ret_obj", "retblockclass", "retblockdata", "ret_class", "reply_obj", "reply_data", "ret_map", "ret0class", "retblockobj", "retblockmap", "reply_map", "ret0obj", "reply_class"], "protocol": ["goldocol", "protology", "cryptocol", "refendor", "prot00", "promendor", "Protology", "crypturation", "propocol", "propology", "goldotype", "refotype", "promotype", "Proturation", "gold00", "format00", "propoint", "prootype", "Prot00", "formatocol", "protpoint", "formatotype", "proocol", "proturation", "refpoint", "prompoint", "Protocol", "propotype", "cryptology", "prototype", "refocol", "proendor", "promocol", "Prototype", "cryptotype", "propuration", "protendor"], "fdname": ["FDno", "sdame", "fxname", "bandstr", "fcname", "deckkey", "fdNAME", "fnstr", "ndame", "handlerkey", "sdno", "cdnnam", "fdame", "fddata", "fdfor", "cdnfor", "handlerstr", "fnname", "dfname", "deckdata", "fcfor", "fdsize", "dfsize", "dfkey", "fcnames", "handlername", "fdstr", "bandkey", "fxsize", "bandnames", "fnnam", "handlernames", "deckname", "fdnam", "ndname", "sdname", "ndNAME", "FDname", "sdNAME", "fdnames", "cdnnames", "fnfor", "decksize", "FDame", "fnnames", "fxkey", "cdnname", "ndno", "bandname", "fdkey", "fdno", "fcnam", "FDNAME", "dfdata", "fxdata", "fnkey"], "s": ["S", "ses", "i", "p", "m", "server", "c", "b", "ns", "bis", "d", "ds", "sg", "state", "states", "u", "e", "stats", "o", "session", "si", "sb", "f", "status", "n", "j", "js", "t", "an", "sd", "v", "sl", "r", "ind", "settings", "sf", "ssl", "sv", "g"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "substitutes": {"ioc": [" ioco", " iucc", "iucc", "atioco", "tiucc", "tioco", "tiroc", "atioc", "ioco", "iroc", "atiucc", " iroc", "atiroc"], "condition": ["chain", " cond", "processor", " thread", " proc", " interrupt", "ec", "bc", "proc", "reason", "self", " event", " prec", "parent", "cond", " error", "comp", "ruction", " block", " exc", "tc", "null", "func", "container", "block", "tx", " exception"], "user_data": ["userfulldata", "user_reader", " user_package", "userfulldevice", "custom_device", " user_done", "useruserreader", "userpooldone", "user_done", "userpooldata", "custom_reader", "userpoolclass", "user_class", "user_device", " user_class", "useringdone", "useruserinfo", "userfullreader", "useringdata", "useringpackage", "user_package", "userfullinfo", "custom_data", "user_info", "userpoolpackage", "custom_info", "useruserdata", "useruserdevice", "useringclass"], "task": ["exec", "socket", "thread", "app", "master", "server", "image", "job", "data", "test", "config", "address", "type", "instance", "trip", "ask", "sync", "key", "piece", "message", "resource", "work", "process", "session", "contract", "Task", "object", "worker", "role", "result", "target", "client", "channel", "device", "transfer", "course", "slave", "source", "child", "t", "conn", "content", "event", "route", "tty", "tx", "connection", "table", "tag"], "tioc": [" tiuc", "shiroc", "TIuc", "shiuc", "nioc", "tiec", "idioci", "kiocation", "tiOC", "sioc", "kioci", "idiocl", "shioc", "siOC", "TIoc", "tiocation", "siuc", "siec", "tiocon", "tiuc", "TIec", "niroc", "siroc", " tiOC", "shiocon", "tioci", "niocon", "siocon", "idioc", "kioc", "siocl", "tiocl", "sioci", " tiec", "kiocl", "niuc", "TIOC", "idiocation", "siocation", "tiroc"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26333, "substitutes": {"s": ["S", "rs", "ses", "sys", "args", "ss", "p", "m", "i", "c", "ns", "ts", "ds", "conf", "ps", "sg", "states", "sync", "self", "su", "is", "u", "es", "cs", "gs", "e", "o", "site", "sets", "session", "spec", "sym", "si", "os", "uns", "sb", "services", "ar", "sa", "ls", "f", "service", "qs", "js", "fs", "t", "a", "r", "settings", "ssl", "sv", "params", "g"], "sci_level": ["sciworklog", " sci_line", " sci_layer", " sci_log", "sci__level", "sci_lock", "sci__layer", "sci_index", "ci_level", " sci_loc", "sci__loc", "sci_vel", "sciworkvel", " sci_vel", "sciworkline", "sci_loc", "sci__lvl", "ci_lock", "ci_index", "ci_log", "sci_line", "sci_layer", "sci_log", "sciworklevel", " sci_lvl", "sci_lvl"], "pmsts": ["pmsta", "pxists", "gmst", " pmares", "gmsta", "premts", "premrs", "pmst", " pmrs", "hmst", "pmstores", "PMns", "wmares", "pmists", "pmds", "hmns", "pmrs", "PMds", "PMts", "gmstores", "gmsts", "bmds", "PMsta", "hmds", "pxares", "wmsts", " pmts", "PMstores", "premns", "wmst", " pmst", "pmns", "premsts", "PMst", "bmst", "wmists", "hmsts", "pmts", "bmsts", "PMsts", "pmares", " pmns", "pxsts", "pxst", " pmsta", " pmists", " pmstores", "PMrs", "bmns"]}}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_key_prefix(WriterContext *wctx)\n\n{\n\n    FlatContext *flat = wctx->priv;\n\n    const struct section *parent_section = wctx->section[wctx->level-1];\n\n\n\n    printf(\"%s\", flat->section_header[wctx->level].str);\n\n\n\n    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n\n        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n\n            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n\n        printf(\"%d%s\", n, flat->sep_str);\n\n    }\n\n}\n", "idx": 26360, "substitutes": {"wctx": ["wakb", "wencss", "kwcu", "wencv", "wcontext", "Wcss", "webcontext", "ewca", "wscss", "wwcontext", "wecontext", "wkb", "rwctx", "wesci", "kwcf", " wjc", " wcmp", "wwcmp", "wscontext", "wscmp", "wskb", "wtctx", "wacss", "owctx", "websci", "ewcmp", "wscu", "ewcp", "owcss", "ewcontext", "webcp", "wca", "owcm", "wcss", "wtjc", "wwkb", "wactx", "wcm", " wcontext", " wca", "wacmp", "rwcss", "kwctx", "wscf", "wtcmp", "webctx", "rwcmp", "wcmp", "wacv", "ewcu", "rwcm", "wecp", "wencmp", "ewctx", "ewcf", "wacontext", "wjc", "wwctx", "owcmp", "wsctx", "wscv", " wcf", "Wcontext", "Wcm", "wcv", "ewsci", "wsci", "wenctx", "wectx", "wcu", "Wcf", "Wcmp", "kwcmp", "Wctx", "Wca", "Wjc", "wcf", "wcp", "wtcontext"], "flat": ["complete", "txt", "public", "parse", "empty", "cat", "single", "module", "template", "force", "qt", "base", "py", "global", "form", "standard", "live", "front", "plugin", "python", "feed", "fc", "lat", "layout", "multi", "pure", "fast", "small", "fl", "clean", "plain", "parent", "future", "utf", "fat", "folder", "zip", "layer", "dot", "atten", "f", "full", "normal", "fold", "table", "format", "final"], "parent_section": ["Parent_sector", "parent_group", "parentingsector", "parentinggroup", "Parent_section", " parent_sect", "parent_data", " parent_group", "parent_sect", "parentingsect", "Parent_sect", "parentingsection", "parent_sector", "parent_sections", " parent_sector", "parent_table", "Parent_data", "Parent_sections", "Parent_table"]}}
{"project": "FFmpeg", "commit_id": "b97d21e4d6813498f458777ff42c7eab1eed3adf", "target": 1, "func": "static int sdp_parse_fmtp_config_h264(AVStream *stream,\n\n                                      PayloadContext *h264_data,\n\n                                      char *attr, char *value)\n\n{\n\n    AVCodecContext *codec = stream->codec;\n\n    assert(codec->codec_id == CODEC_ID_H264);\n\n    assert(h264_data != NULL);\n\n\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n\n        h264_data->packetization_mode = atoi(value);\n\n        /*\n\n         * Packetization Mode:\n\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n\n         *                      and 29 (FU-B) are allowed.\n\n         */\n\n        if (h264_data->packetization_mode > 1)\n\n            av_log(codec, AV_LOG_ERROR,\n\n                   \"Interleaved RTP mode is not supported yet.\");\n\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n\n        if (strlen(value) == 6) {\n\n            char buffer[3];\n\n            // 6 characters=3 bytes, in hex.\n\n            uint8_t profile_idc;\n\n            uint8_t profile_iop;\n\n            uint8_t level_idc;\n\n\n\n            buffer[0]   = value[0];\n\n            buffer[1]   = value[1];\n\n            buffer[2]   = '\\0';\n\n            profile_idc = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[2];\n\n            buffer[1]   = value[3];\n\n            profile_iop = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[4];\n\n            buffer[1]   = value[5];\n\n            level_idc   = strtol(buffer, NULL, 16);\n\n\n\n            av_log(codec, AV_LOG_DEBUG,\n\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n\n                   profile_idc, profile_iop, level_idc);\n\n            h264_data->profile_idc = profile_idc;\n\n            h264_data->profile_iop = profile_iop;\n\n            h264_data->level_idc   = level_idc;\n\n        }\n\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n\n        codec->extradata_size = 0;\n\n        codec->extradata      = NULL;\n\n\n\n        while (*value) {\n\n            char base64packet[1024];\n\n            uint8_t decoded_packet[1024];\n\n            int packet_size;\n\n            char *dst = base64packet;\n\n\n\n            while (*value && *value != ','\n\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n\n                *dst++ = *value++;\n\n            }\n\n            *dst++ = '\\0';\n\n\n\n            if (*value == ',')\n\n                value++;\n\n\n\n            packet_size = av_base64_decode(decoded_packet, base64packet,\n\n                                           sizeof(decoded_packet));\n\n            if (packet_size > 0) {\n\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n\n                                          codec->extradata_size +\n\n                                          FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!dest) {\n\n                    av_log(codec, AV_LOG_ERROR,\n\n                           \"Unable to allocate memory for extradata!\");\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                if (codec->extradata_size) {\n\n                    memcpy(dest, codec->extradata, codec->extradata_size);\n\n                    av_free(codec->extradata);\n\n                }\n\n\n\n                memcpy(dest + codec->extradata_size, start_sequence,\n\n                       sizeof(start_sequence));\n\n                memcpy(dest + codec->extradata_size + sizeof(start_sequence),\n\n                       decoded_packet, packet_size);\n\n                memset(dest + codec->extradata_size + sizeof(start_sequence) +\n\n                       packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n                codec->extradata       = dest;\n\n                codec->extradata_size += sizeof(start_sequence) + packet_size;\n\n            }\n\n        }\n\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\",\n\n               codec->extradata, codec->extradata_size);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26367, "substitutes": {"stream": ["acc", "public", "uc", "server", "transform", "engine", "context", "Stream", "reader", "form", "port", "raw", "feed", "con", "cl", "input", "valid", "path", "object", "model", "client", "video", "view", "channel", "length", "ream", "loop", "stage", "src", "stack", "host", "coll", "row", "ssl", "document", "writer"], "h264_data": ["h164_data", "h264_message", "hfp_info", "hmpeg_message", "h264Omessage", "h264_class", "h26400rec", "h264_ui", "hfp_default", "hwm_data", "h26400body", "h264Odata", "habl_data", "h264_rec", "h264_body", "h264_id", "h264_di", "hcv_di", "h264_div", "h264Jdata", "hwm_dat", "hmpeg_data", "habl_DATA", "h264Odefinition", "h264Jdi", "h264Jclass", "h264_info", "hcv_div", "habl_di", "hfp_reader", "h264Oid", "h264JDATA", "hcv_data", "hmpeg_id", "h164_dat", "hfp_config", "h26400dat", "hmpeg_definition", "habl_class", "hwm_rec", "h264_DATA", "h164_config", "h264_reader", "h264_default", "hfp_data", "hwm_body", "h264_definition", "h264_dat", "h264_config", "hfp_ui", "h26400data", "hcv_rec"], "attr": ["element", "args", "apt", "option", "name", "data", "api", "attribute", "config", "prop", "vr", "writer", "address", "att", "type", "feature", "property", "opt", "url", "typ", "expr", "key", "spr", "params", "arr", "adr", "resource", "atom", "rel", "term", "ann", "append", " attribute", "channel", "iv", "feat", "kr", "device", "addr", "array", "timeout", "ack", "rt", "pr", "pair", "header", "atts", "r", "rr", "range", "tag", "format", "layer"], "value": ["element", "w", "server", "name", "phrase", "request", "anything", "version", "input", "valid", "initial", "set", "object", "model", "number", "current", "service", "entry", "go", "pair", "row", "content", "match", "memory", "vector", "val", "layer", "complete", "option", "wave", "test", "attribute", "text", "media", "address", "Value", "port", "key", "feed", "password", "resource", "response", "now", "xml", "json", "update", "rule", "description", "function", "data", "component", "reference", "message", "command", "output", "parent", "change", "VALUE", "size", "view", "variable", "video", "length", "source", "null", "expression", "language", "package", "info", "image", "style", "config", "member", "feature", "type", "property", "end", "flow", "python", "unit", "padding", "sample", "selected", "comment", "child", "index", "v", "values", "result", "format"], "codec": [" codep", "Codroc", "odect", "cdpc", " codEC", "Codesc", "predenc", "Codef", "coduc", "odesc", "callc", "predrec", "codpc", "podec", "copenc", "copuc", "callec", "pedc", " codesc", "predep", "odenc", "Codrec", "odef", "pedEC", "pedenc", "Codoc", "podeca", "Codc", "codesc", " codrec", "Coduc", "predpc", "copc", "codcript", "cheec", "Codect", "pedec", "labcript", "cheEC", "codeca", "odEC", " codoc", "codeesc", "Codec", "codenc", "codEC", "codeEC", " codpc", " codenc", "codeec", "codroc", "pedesc", "copec", "predoc", "labeca", "predec", "labenc", "callesc", "cheesc", "codeuc", "codef", "labec", " codef", " codcript", "podcript", "odec", "codc", "cdec", "cheect", " codroc", "predesc", "CodEC", "codep", "cdesc", "codrec", "cdep", "Codenc", " codeca", "podenc", " codc", "callroc", "peduc", "codect", "codoc"], "buffer": ["byte", "bin", "info", "batch", "server", "position", "image", "shell", "wave", "phrase", "data", "queue", "program", "text", "read", "base", "address", "reader", "loader", "surface", "port", "texture", "url", "uffer", "cube", "profile", "raw", "buf", "iter", "feed", "message", "resource", "input", "object", "output", "binary", "board", "result", "variable", "cache", "channel", "Buffer", "shape", "bar", "length", "flash", "view", "buff", "array", "transfer", "window", "timeout", "bytes", "source", "list", "stack", "null", "row", "header", "memory", "map", "block", "document", "table", "file", "writer", "vector", "layer"], "profile_idc": ["profile_ipx", "profile_inx", "profile_adcd", "profile_idecd", "profile_adc", "profile_idl", "profile_ipc", "profile_inn", "profile_adn", "profile_idm", "profile_add", "profile_bidlc", "profile_idsci", "profile_iplc", "profile_Idl", "profile_ind", "profile_idec", "profile_Idlc", "profile_inl", "profile_idsl", "profile_idx", "profile_inc", "profile_idcd", "profile_partlc", "profile_bidi", "profile_bidx", "profile_idsn", "profile_inlc", "profile_partc", "profile_bidc", "profile_ided", "profile_idi", "profile_aidl", "profile_Idn", "profile_Idci", "profile_inm", "profile_aidci", "profile_Idm", "profile_idd", "profile_iden", "profile_ipn", "profile_parti", "profile_Idc", "profile_idn", "profile_idci", "profile_idlc", "profile_aidc", "profile_incd", "profile_aidn", "profile_partx", "profile_idsc", "profile_Idx"], "profile_iop": ["profile___ori", "mobile_loop", "profilePori", " profile_summary", "profilePloop", "profile_ori", "profile67summary", " profile_ori", "mobile_ori", "profile_iterator", "mobilePloop", " profile_exp", "profile_ionic", "prof_io", "profileMiop", "profile_ip", "profileMloop", "profile67op", "mobilePiop", "prof_orp", "profile_orp", "mobilePiterator", " profile_ionic", "mobilePori", "profile___iop", "profileMiterator", "profile_io", "profile_iot", "mobile_iterator", "profile___exp", " profile_op", "prof_ip", "profile67io", "profilePiterator", "profile_summary", "profile___io", "profile_op", " profile_io", " profile_iot", "prof_iop", "mobile_iop", "profile_loop", "profilePiop", "profile_exp", "profile67iop", "profileMori"], "level_idc": ["level_ipi", "level_idg", "level_aidn", "level_ince", "level_Idx", "level_bidc", "level_bidl", "level_indexce", "level_basec", "level_aidlc", "level_basex", "level_idsn", "level_basei", "level_Idl", "level_idsp", "level_dx", "level_idslc", "level_ipf", "level_idsc", "level_ipl", "level_dc", "level_bidx", "level_idn", "level_idsx", "level_basef", "level_idce", "level_idlc", "level_dl", "level_idscode", "level_indexc", "level_idl", "level_incode", "level_idx", "level_inp", "level_indexcode", "level_inc", "level_idsce", "level_ipg", "level_ipc", "level_idf", "level_idcode", "level_Idn", "level_idp", "level_idi", "level_aidx", "level_aidc", "level_bidlc", "level_Idc", "level_indexp", "level_ipx", "level_dg", "level_Idlc"], "base64packet": ["base64compacket", "base256packeting", "base64compET", "base64decet", "base64packET", "base64packacket", "base64peant", "base8packant", "base64peet", "base8compacket", "base64peeting", "base256packant", "base256Packet", "base64packeting", "base8packacket", "base64decacket", "base64encacket", "base64Packacket", "base8compant", "base256Packacket", "base64Packeting", "base64encET", "base64encant", "base64packant", "base64encet", "base8compET", "base64decET", "base8packET", "base64Packet", "base64Packant", "base256Packeting", "base64peacket", "base256packet", "base256Packant", "base64enceting", "base8packet", "base64compant", "base64compet", "base256packacket", "base64decant", "base8compet"], "decoded_packet": ["decoded_encets", "decoded_octacket", "decoded_encet", "decoded_compets", "decoded_octet", "decoded_compet", "decoded_encacket", "decoded_packets", "decoded_encec", "decoded_compacket", "decoded_packacket", "decoded_packec", "decoded_octets", "decoded_octec", "decoded_compec"], "packet_size": ["packet_len", "packets_len", "packets_size", "packet_count", "packets_count"], "dst": ["bbl", "bst", "dstr", " dsts", "dsts", "bstr", "type", "inst", "inbl", "bsts", "s", " dbl", "dbl", "channel", "length", "instr", " dstr", "insts", "r", "_"]}}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388, "substitutes": {"filename": ["summary", "processor", "txt", "dll", "location", "kn", "selection", "download", "wb", "name", "phrase", "fn", "queue", "metadata", "config", "prefix", "Filename", "url", "directory", "nil", "path", "rl", "jpg", "kl", "journal", "sequence", "files", "il", "which", "username", "f", "source", "jl", "fp", "content", "database", "fil", "memory", "title", "fd", "fits", "file"], "total_size": [" total_capacity", " total_content", "total67size", "total_scale", "total67content", "total_capacity", " total_scale", "total_content", "total67capacity", "total67scale"], "backing_file": ["backing64image", "backing_image", "backping2table", "backing2file", "backping_files", "backing2table", "backping2files", "backping2file", "backping2image", "backping_table", "backing2image", "backping_file", "backping_image", "backing64file", "backing64table", "backing_table", "backing2files", "backing_files", "backing64files"], "backing_format": ["backiving_unit", "backiving_writer", "backing_writer", "backiving_format", "backing_unit", "backiving_file"], "flags": ["mask", "ants", "args", "heads", "errors", "features", "flag", "ips", "Flags", "types", "plugins", "locks", "format", "depth", "vals", "stats", "fps", "fields", "links", "fl", "versions", "tops", "lag", "utils", "files", "mods", "missions", "groups", "fs", "bits", "status", "alls", "FLAG", "settings", "ops", "parts", "len", "ints"], "cluster_size": ["clinal_size", "clust_count", "cluster_capacity", "cluster2number", "cluster2bits", "clusters_count", "clinalalsize", "clusters_capacity", "clusteraltable", "clinal_count", "cluster6width", "clinalaltable", "cluster_mode", "cluster2capacity", "clinal_time", "clusters_size", "cluster6count", "cluster64mode", "cluster_table", "clust_size", "clinalaltime", "cluster_count", "clusteraltime", "cluster2size", "cluster6number", "clust_number", "clinal_table", "cluster64capacity", "clusteralcount", "cluster2mode", "cluster_width", "clusteralsize", "clusters_mode", "cluster_number", "cluster2count", "clinalalcount", "cluster64count", "cluster6size", "clust_width", "cluster_time", "cluster64size"], "prealloc": ["prexp", "postalloc", "postxp", " rexp", "postgr", " prexp", "pregr", " pregr", " regr"], "options": ["obj", "args", "errors", "info", "none", "option", "members", "ssl", "ts", "other", "config", "opens", "types", "opt", "global", "outs", "io", "Options", "linux", "vals", "ions", "caps", "session", "rates", "object", "properties", "als", "utils", "files", "cache", "details", "results", "values", "settings", "ops", "resources", "params", "limits"], "version": ["build", "VERSION", "gen", "package", "class", "driver", "section", "features", "Version", "option", "currency", "name", "server", "position", "image", "style", "config", "vision", "feature", "type", "prefix", "support", "platform", "serial", "brand", "plugin", "depth", "ception", "seed", "arch", "versions", "mode", " ver", " versions", "size", "target", "scale", "number", "level", "generation", "current", "length", "update", "product", "stage", "value", "ip", "index", "v", "ver", "release", "tag", "format", "fun"], "errp": ["errpc", "erP", "irpre", "erfp", "errorpc", "irp", "irpc", "errpre", "erpc", " errfp", "errorfp", "erpre", " errpc", "errorP", "irP", "erp", "errP", "errfp", " errpre", "errorpre", "errorp"], "cluster_bits": ["closer_bytes", "clust_bit", "cluster8features", "closer_bits", "cluster2bits", "cluster32width", "clust_pieces", "closer_cycles", "clancer_bytes", "cluster_pieces", "clust_bytes", "cluster_flags", "cluster__bytes", "cluster2bytes", "cluster32pieces", "cluster_features", "cluster6cycles", "clancer_bits", "cluster__size", "cluster_bytes", "cluster8pieces", "closer_flags", "cluster6flags", "clust_bits", "clust_parts", "cluster_parts", "closer6cycles", "cluster32bytes", "cluster6bytes", "clust_features", "cluster6bits", "cluster_width", "cluster2bit", "cluster_cycles", "clancer_parts", "cluster__bits", "cluster8bits", "cluster__parts", "closer6bytes", "clancer_size", "cluster8parts", "closer6bits", "cluster_pins", "cluster_bit", "clust_width", "closer6flags", "cluster32bits"], "bs": ["rs", "ses", "b", "ss", "bas", "ns", "lb", "bn", "bb", "vs", "base", "ds", "br", "bh", "gb", "bos", "bc", "BS", "bl", "ps", "SB", "gs", "ba", "pb", "bi", "mb", "os", "sb", "fb", "utils", "bid", "ls", "fs", "bytes", "ssl", "cs"], "header": ["head", "definition", "server", "frame", "name", "manager", "module", "buffer", "request", "holder", "secondary", "character", "column", "tail", "url", "bridge", "number", "external", "f", "service", "entry", "status", "fp", "content", "cookie", "Header", "pillar", "document", "writer", "layer", "summary", "body", "code", "driver", "parser", "queue", "reader", "port", "fr", "line", "journal", "headers", "cache", "response", "h", "report", "event", "meta", "rr", "block", "forward", "table", "final", "public", "section", "data", "back", "error", "plugin", "player", "extra", "message", "offset", "output", "client", "later", "full", "ssl", "connection", "kernel", "info", "hash", "master", "dr", "metadata", "config", "br", "type", "cover", "protected", "layout", "ext", "comment", "index", "builder", "result", "hr"], "refcount_table": ["refcount_count", "refcount_master", "refCount_cache", "refCount_master", "refCount_table", "refcount2table", "refCount_count", "refcount_cache", "refcount2count", "refcount2cache", "refcount2master"], "local_err": ["httperstr", "local_str", "localamerr", "httperresult", "localerresult", "local7str", "localamerror", "localamresult", "local_info", "httpererr", "http_err", "localamexit", "local7Error", "remote_exit", "localerstr", "localamstr", "localererror", "localanderr", "localererr", "http_str", "localanderror", "loc_result", "local7err", "localamError", "remote_err", "local7result", "local_result", "local_Error", "httpererror", "localaminfo", "loc_Error", "http_error", "http_result", "remote_info", "remote_error", "localandexit", "loc_err", "loc_str", "local_exit", "localandinfo", "local_error"], "ret": ["ref", "fin", "obj", "ft", "res", "info", "hash", " RET", "cat", "flag", "msg", "rf", "red", "back", "success", "br", "bf", "fail", "att", "pub", "debug", "def", "error", "end", "rep", "num", "proc", "ure", "db", "rets", "arr", "rl", "mt", "det", "lit", "nb", "RET", "run", "re", "art", "nt", "reply", "rc", "let", "sec", "bad", "arg", "Ret", "rt", " result", "part", "status", "alt", "reg", "resp", "conn", "match", "ver", "result", "len", "val", "lock", "fun"]}}
{"project": "FFmpeg", "commit_id": "3dea28cc2ef22861347918b6740c4c05c46a6614", "target": 0, "func": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= -1;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb= 1<<16;\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n", "idx": 26390, "substitutes": {"h": ["hm", "ht", "w", "p", "m", "b", "c", "context", "d", "hd", "history", "x", "hr", "ih", "bh", "H", "hh", "ch", "ah", "self", "u", "hl", "e", "hw", "o", "hp", "work", "home", "rh", "s", "http", "hs", "ctx", "cache", "html", "gh", "eh", "f", "n", "t", "host", "q", "v", "r", "g", "l", "hi", "he", "ph", "oh", "sh"], "i": ["k", "slice", "z", "yi", "p", "m", "b", "c", "info", "d", "ix", "x", "ti", "mi", "phi", "qi", "ri", "id", "io", "ui", "u", "e", "key", "li", "o", "gi", "ji", "zi", "multi", "xi", "start", "uri", "ii", "bi", "si", "ini", "ai", "ni", "di", "ci", "eni", "I", "f", "oi", "n", "j", "index", "t", "a", "v", "iu", "mu", "pi", "in", "l", "hi"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n", "idx": 26396, "substitutes": {"opaque": ["openace", "OPacity", "opec", "ipac", "opac", " opac", " opec", "ipacity", "openacity", " opace", "OPec", "opace", "OPace", "OPac", " opacity", "ipec", "ipaque", "openaque", "opacity", "OPaque"], "addr": ["ref", "intel", "arm", "dr", "x", "enc", "data", "config", "pointer", "align", "ad", "address", "prefix", "state", "mac", "pad", "point", "adr", "ord", "loc", "offset", "slot", "mode", "ptr", "arg", "device", "amd", "rt", "nr", "src", "alt", "host", "inter", "index", "ind", "attr", "ace", "pos", "fd", "pc"], "val": ["ref", "b", "pt", "VAL", "x", "data", "eval", "base", "bl", "bc", "end", "vals", "al", "unit", "mem", "arr", "el", "grad", "valid", "lit", "loc", "offset", "slot", "sel", "ret", "arg", "Val", "value", "v", "len", "vol"], "d": ["md", "k", "z", "dc", "cd", "p", "m", "b", "c", "ded", "i", "data", "ld", "ds", "ad", "bd", "state", "id", "dom", "db", "e", "o", "dh", "dat", "gd", "di", "dt", "D", "f", "da", "t", "od", "sd", "ind", "r", "l", "fd", "g"], "reg": ["exec", "acc", "Reg", "res", "enc", "eg", "ld", "config", "ad", "gr", "debug", "bl", "rec", "mem", "arr", "err", "dat", "loc", "REG", "re", "ig", "stat", "ret", "sec", "rc", "rg", "win", "arg", "mod", "conn", "ind", "r", "g", "ac", "pc", "tag"]}}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void abort_codec_experimental(AVCodec *c, int encoder)\n\n{\n\n    const char *codec_string = encoder ? \"encoder\" : \"decoder\";\n\n    AVCodec *codec;\n\n    av_log(NULL, AV_LOG_FATAL, \"%s '%s' is experimental and might produce bad \"\n\n            \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",\n\n            codec_string, c->name);\n\n    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);\n\n    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n\n        av_log(NULL, AV_LOG_FATAL, \"Or use the non experimental %s '%s'.\\n\",\n\n               codec_string, codec->name);\n\n    exit(1);\n\n}\n", "idx": 26428, "substitutes": {"c": ["code", "sc", "cm", "cod", "k", "call", "dc", "uc", "p", "b", "anc", "cat", "C", "cv", "x", "enc", "ec", "config", "cr", "ct", "bc", "ch", "self", "u", "e", "fc", "con", "o", "ic", "cl", "vc", "ac", "s", "cc", "cp", "cf", "mc", "com", "lc", "ca", "f", "n", "t", "coll", "v", "l", "cs", "ce"], "encoder": ["encader", "decoded", "decode", "Encode", "encener", " decener", " encener", " encode", " encader", "encode", " encater", "Encader", "ecoded", " decoder", "decener", "decader", "decoder", "ecater", "decater", "encater", "Encoding", "Encoder", " encoding", " decoded", " decoding", "ecoding", "encoding", "decoding", " encoded", "encoded", "ecoder"], "codec_string": ["codec4prefix", "codoc_path", "codec2path", "codec_path", "codec_strings", "codoc2prefix", "codec_prefix", "codec2number", "codoc2number", "codec_null", "codec4number", "codec2string", "codenc_version", "codec_version", "codec_name", "codoc_prefix", "codoc_string", "codoc2string", "codec4string", "codoc_name", "codoc_number", "codenc_strings", "codenc_string", "codec2prefix", "codec_number", "codoc_null", "codec4path", "codoc2path"], "codec": ["odac", "genec", " codef", "postdec", "Codec", "odec", "codeef", "postuc", "cdec", "cdac", "labef", "codenc", "cododer", " cododer", "predesc", " codect", "coduc", " codenc", "cdenc", "odenc", "codedec", "predoder", "predeca", "codeec", "codac", "codesc", "postec", "Coduc", "labenc", "predec", "postoder", "codeoder", "Codenc", "oduc", "codeenc", "genesc", " codeca", "predect", " codesc", "Codac", "codeuc", "coddec", "genect", "preddec", "codeca", "codect", "preduc", "geneca", "laboder", "cduc", "codef", "labec"]}}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}", "idx": 26435, "substitutes": {"c": ["w", "dc", "p", "m", "b", "cit", "C", "d", "context", "abc", "u", "e", "vc", "s", "icc", "cc", "cache", "lc", "h", "f", "n", "t", "a", "r", "l", "cs", "ac", "pc"], "dst": [" dconst", "idconst", " dsts", "dstack", "dsts", "idstack", "dconst", "Dstack", "fst", "Dsts", "Dconst", "fsc", "sdsc", "sdsts", "sdst", "fsts", " dsc", "fconst", " dstack", "dsc", "sdconst", "idsts", "Dst", "idst"], "dstWidth": ["dconstHeight", "dconstWidth", "dscW", "DSTwidth", "dstW", "DSTHeight", "dstwidth", "dscwidth", "dSTHeight", "DstW", " dSTWidth", "dSTwidth", "dconstW", "DSTWidth", " dSTW", " dstwidth", "Dstwidth", "dstackwidth", "dscWidth", "dstackHeight", "dSTW", "dSTWidth", "dstackW", "dconstwidth", "dstackWidth", "DstHeight", " dSTwidth", " dstW", "DSTW", "dstHeight", "DstWidth"], "src": ["rest", "sc", "bin", "uc", "b", "includes", "cv", "insert", "enc", "data", "text", "rb", "sq", "config", "cur", "img", "support", "cb", "inst", "sync", "front", "split", "url", "proc", "cmp", "rob", "sur", "grad", "input", "start", "loc", "sub", "lib", "st", "inf", "sel", "sb", "size", "rc", "rank", "conv", "sup", "dist", "comp", "source", "stage", "stream", "stack", "RC", "index", "func", "desc", "dest", "sl", "attr", "pack", "ssl", "secure"], "srcW": [" dstw", "rcW", "srcN", "destH", "destw", "srcH", "rcH", " dstH", "destN", " dstN", " dstW", "rcN", "srcw", "rcw", "destW"], "xInc": [" xSign", "crossIncre", " xInit", "xInit", " xEnc", "exInc", "xSign", "rxSign", "xIncre", "rxIncre", "XInc", "XEnc", "exInit", " xIncre", "exinc", "rxInit", "crossSign", "XInit", "exEnc", "rxInc", "xEnc", "Xinc", " xinc", "crossInit", "xinc", "crossInc"], "i": ["k", "z", "p", "b", "d", "ix", "x", "ti", "ei", "qi", "it", "ri", "id", "io", "ui", "u", "e", "o", "li", "gi", "ji", "zi", "multi", "xi", "uri", "l", "ii", "ini", "si", "bi", "di", "ai", "ni", "ci", "I", "f", "oi", "n", "j", "index", "ip", "t", "v", "ind", "iu", "pi", "pos"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_i_mbs(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    MpegEncContext *s = &v->s;\n\n    int current_mb = 0; /* MB/Block Position info */\n\n    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,\n\n        *p_cbpcy /* Pointer to skip some math */;\n\n\n\n    /* Reset CBPCY predictors */\n\n    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n\n\n\n    /* Select ttmb table depending on pq */\n\n    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];\n\n    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];\n\n    else v->ttmb_vlc = &vc9_ttmb_vlc[2];\n\n\n\n    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)\n\n    {\n\n        /* Init CBPCY for line */\n\n        *((uint32_t*)previous_cbpcy) = 0x00000000;\n\n        p_cbpcy = v->previous_line_cbpcy+4;\n\n\n\n        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)\n\n        {\n\n            /* Get CBPCY */\n\n            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);\n\n\n\n            s->ac_pred = get_bits(gb, 1);\n\n\n\n            /* TODO: Decode blocks from that mb wrt cbpcy */\n\n\n\n            /* Update for next block */\n\n#if TRACE > 2\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,\"\n\n                   \" cbpcy=%i%i%i%i\\n\", current_mb,\n\n                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],\n\n                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],\n\n                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);\n\n#endif\n\n            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);\n\n            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);\n\n            current_mb++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26437, "substitutes": {"v": ["ve", "k", "nav", "i", "p", "m", "b", "c", "va", "ov", "vs", "nv", "vt", "av", "version", "ev", "vu", "tv", "vv", "u", "e", "vc", "vin", "vim", "vert", "vi", "iv", "vm", "conv", "h", "uv", "f", "lv", "n", "vd", "j", "V", "t", "q", "ver", "vp", "we", "l", "sv", "volt", "vol", "g"], "gb": ["vg", "cm", "cod", "cd", "b", "m", "pg", "cv", "bb", "tm", "storage", "rb", "bf", "mi", "py", "cb", "gam", "bc", "gy", "ym", "kb", "db", "hub", "mag", "gs", "nom", "cfg", "bridge", "nb", "gd", "lib", "mb", "mode", "ctx", "ci", "sb", "abb", "GB", "rc", "gp", "rg", "pm", "vm", "buff", "gg", "uv", "gc", "bm", "gm", "ui", "pc", "g"], "s": ["acc", "sys", "w", "server", "ns", "ts", "vs", "sq", "ps", "secondary", "sync", "self", "u", "es", "gs", "share", "http", "sym", "xs", "serv", "f", "service", "fs", "n", "js", "qs", "t", "j", "r", "S", "b", "m", "p", "c", "storage", "ds", "align", "us", "ins", "su", "is", "ims", "spec", "services", "h", "sl", "its", "g", "rs", "ses", "args", "scope", "ss", "d", "ab", "conf", "sg", "ks", "e", "get", "session", "sb", "sf", "ssl", "sv", "cs", "sc", "i", "app", "site", "o", "si", "os", "sup", "ls", "y", "network", "a", "parts", "l"], "cbpcy": ["cbfky", "cbncy", "cblpci", "bbpky", "cbfry", "cbcpy", "cbppy", "bcnpsy", "cbgcy", "dbpky", "ebpcr", "cbtpcy", "cbopci", "cbopcle", "cbpci", "ebpcy", "cbccle", "cmdopcy", "cbcpcy", "dbpcy", "cbpry", "cblppy", "cbpsty", "cbcci", "bblpky", "ebpky", "bcnpci", "cbnpci", "bcnpsty", "dbpci", "dbnpcy", "cbpcsty", "cbnpsty", "bbppy", "cbpcsy", "dbnpcle", "bcpcy", "cblpky", "cbncle", "bbpci", "cbtpci", "cbpcle", "eblpky", "cblpcle", "cblpry", "cbfcy", "bcpsty", "cbnci", "bbpcy", "cbtpcle", "cmdpci", "cbnpcy", "cbpcr", "cbopry", "cbpcci", "cbcppy", "bblpcy", "cbnpsy", "ebpry", "cbfcr", "bcpci", "cbpisy", "cblpcy", "dbnpci", "cmdopcle", "cbnry", "cbccy", "cbgry", "cbpici", "cbpccy", "dbpcle", "cbpky", "dbnpky", "cbnpcle", "cbgky", "cmdopci", "cmdopry", "bblpci", "cbpisty", "cmdpcle", "cbcpky", "bcpsy", "bcnpcy", "cbnpky", "eblpcy", "cbcky", "cmdpry", "cbpicy", "bblppy", "cblpcr", "cbtpky", "cbgcr", "cbcpci", "cmdpcy", "cbopcy", "eblpcr", "cbpsy", "eblpry", "cbcry"], "previous_cbpcy": ["previous_cbnke", "previous_cbwpty", "previous_cbpry", "previous_bbpwy", "previous_bbpoy", "previous_cblpky", "previous_cbnpcy", "previous_cbvpry", "previous_bbpcy", "previous_cbPzy", "previous_cbpsch", "previous_bbPch", "previous_cbPcy", "previous_bcpcy", "previous_bbnke", "previous_cbfpzy", "previous_cbtry", "previous_cbtcat", "previous_bbPoy", "previous_bbpky", "previous_cbnwy", "previous_cbgcy", "previous_bbpsty", "previous_cbwpwy", "previous_cbpty", "previous_cbnpym", "previous_cbpscy", "previous_cbnpry", "previous_cbfpky", "previous_cbPcat", "previous_cbgry", "previous_bbpke", "previous_cbpsty", "previous_bbnty", "previous_cbpcty", "previous_cbpoy", "previous_cbprke", "previous_bbPcy", "previous_bclpky", "previous_cbPoy", "previous_cbpch", "previous_cbpke", "previous_cbvpch", "previous_cblpry", "previous_cbtsty", "previous_cbppke", "previous_cbprry", "previous_cbgym", "previous_bcpky", "previous_bcpzy", "previous_bclpry", "previous_cbppcy", "previous_cbwpcy", "previous_cbgky", "previous_cbfpcy", "previous_cbpysty", "previous_cbpzy", "previous_cbpsry", "previous_cbpym", "previous_cbpycy", "previous_bbPsty", "previous_cbfpry", "previous_cbvpcy", "previous_cbPry", "previous_cbPsty", "previous_bbncy", "previous_cbpycat", "previous_cbPky", "previous_cbtcy", "previous_bbpcat", "previous_cbnky", "previous_bclpzy", "previous_bbnym", "previous_cbncy", "previous_bbnky", "previous_cbprwy", "previous_cbvpoy", "previous_cbpcry", "previous_cblpzy", "previous_cbwpry", "previous_bbPry", "previous_bbPcat", "previous_cbpccy", "previous_bbpym", "previous_bbpry", "previous_bclpcy", "previous_cbnty", "previous_bbnry", "previous_cbnym", "previous_cbnry", "previous_cbpyry", "previous_cbpsoy", "previous_bbpch", "previous_cbpcat", "previous_bbpty", "previous_cbnpky", "previous_bcpry", "previous_cbppwy", "previous_cbprcy", "previous_cbpky", "previous_bbnwy", "previous_cbpcwy", "previous_cblpcy", "previous_cbpwy", "previous_cbPch", "previous_cbppry"], "predicted_cbpcy": ["predicted_cbpCy", "predicted_cbjpcy", "predicted_debppCy", "predicted_cbppiny", "predicted_cbppcy", "predicted_cbjpiny", "predicted_debpCy", "predicted_debppcy", "predicted_debpiny", "predicted_cbppCy", "predicted_debpcy", "predicted_cbjpCy", "predicted_cbpiny", "predicted_debppiny"], "p_cbpcy": ["p_cbfpcr", "p_bbfky", "p_pbpocy", "p_bbfkee", "p_cbpkee", "p_cblpwy", "p_cvpry", "p_cbprocfy", "p_cbfpcor", "p_ebpacor", "p_cbpaye", "p_cbbcy", "p_cbfcy", "p_cbbpcy", "p_bbfry", "p_cbppry", "p_cblpocy", "p_cbppfy", "p_bcpcy", "p_cbfct", "p_cbccy", "p_cvpcy", "p_cbpacr", "p_cbfcr", "p_ebpacy", "p_cbpsty", "p_abbpcy", "p_cbprcy", "p_cbcwy", "p_cbnpcy", "p_fbpact", "p_abbpcr", "p_cbpccy", "p_ebpcy", "p_abbfcr", "p_bcnpcy", "p_cvfya", "p_cbcct", "p_cbpaky", "p_cbpfy", "p_pbbpsty", "p_cblpcy", "p_cbpky", "p_cbpwy", "p_cblpky", "p_cbpact", "p_cbproccy", "p_bbpkee", "p_cblpct", "p_cbprct", "p_cblpci", "p_cbpocy", "p_cbprry", "p_abbfky", "p_cbpcor", "p_bcnpku", "p_cbpku", "p_bcnpky", "p_abbfcy", "p_bcnpfy", "p_cbpcr", "p_bbpcy", "p_cblpsty", "p_bbfcy", "p_cbnpfy", "p_fbpct", "p_cbnpcr", "p_bbpky", "p_cbpry", "p_cbcye", "p_ebpcor", "p_cbfpcy", "p_cblppy", "p_abbpky", "p_pbpsty", "p_cbpya", "p_cbpcky", "p_fbpwy", "p_ebpky", "p_cbnpky", "p_abbpci", "p_cbfpky", "p_cbpcsty", "p_ebpcr", "p_cbpcry", "p_cbppy", "p_cbbry", "p_cbpacor", "p_pbpcy", "p_cbpckee", "p_cbfya", "p_cbfry", "p_pbbpcy", "p_cbfpy", "p_cbbya", "p_pbbpocy", "p_fbpye", "p_cbfkee", "p_cbpci", "p_bcpku", "p_cbpawy", "p_cbpppy", "p_cbpacy", "p_cbbpky", "p_cblpye", "p_cbppku", "p_ebpaky", "p_cvpct", "p_cbnpci", "p_bbppy", "p_pbbpky", "p_fbpcy", "p_cvfry", "p_cbpye", "p_cvfcy", "p_fbpacy", "p_cblpkee", "p_ebpacr", "p_cbprocku", "p_cblpcr", "p_cbfci", "p_bbpry", "p_fbpaye", "p_cbfcor", "p_cvfct", "p_cbprocky", "p_cbfky", "p_cvpya", "p_pbpky", "p_cbppky", "p_bbfpy", "p_cbpcocy", "p_cbbpocy", "p_cbpct", "p_cbprya", "p_cblpry", "p_cbppcy", "p_bcpfy", "p_cbbpsty", "p_fbpawy", "p_cbbct", "p_cbnpku", "p_abbfci", "p_bcpky"], "mb_y": ["mbFsize", "mbFx", "MB_y", "mbFvy", "mp_w", "mb_yd", "mb_type", "MB_size", "MB_ye", "mbFye", "mb_w", "mp_y", "mb_vy", "mp_type", "mbFyd", "mbFtype", "mb_ye", "mp_yd", "MB_vy", "mp_x", "mbFy", "mb_size"], "mb_x": ["mb_wx", "MB_z", "MB_x", "mb11n", "mb_n", "MB_wx", "mb_rx", "mb__gy", "mp_rx", "mp_gy", "mb11x", "mp_z", "MB_ex", "mb__x", "mb__n", "mp_y", "mb__y", "mb11gy", "mb_gy", "mb11y", "mp_n", "mp_x", "mb_ex", "mp_ex", "mb_z"], "current_mb": ["current_bb", "current_mm", " current_mm", "current_emb", " current_MB", " current_emb", " current_bb", "current_MB"]}}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443, "substitutes": {"dev": ["ve", "md", "gu", " Dev", "w", "driver", "fo", "p", "Device", "app", "d", "data", "ad", "debug", "def", "priv", "DEV", "dd", "ev", "ch", "die", "serial", "dom", "self", "prom", "tr", "dem", "hw", "phy", "home", "grad", " device", "gd", "di", "device", "mod", "development", "conn", "dm", "de", "Dev", "rad", "od", "ver", "sd", "devices", "cam"], "s": ["S", "rs", "ses", "sys", "args", "w", "ss", "p", "m", "i", "c", "server", "b", "ns", "d", "se", "ts", "storage", "sq", "ds", "us", "ps", "sg", "sync", "self", "su", "is", "u", "e", "es", "south", "gs", "o", "session", "spec", "l", "sv", "si", "os", "uns", "sb", "services", "ls", "f", "service", "js", "n", "t", "sd", "v", "sl", "r", "settings", "ops", "ssl", "cs", "g"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 26451, "substitutes": {"ctrl": ["exec", "ref", "chain", "ctl", "acl", "cm", "obj", "dc", "oc", "ll", "wb", "server", "ocl", "manager", "Control", "rf", "xc", "rb", "config", "cr", "cb", "prefix", "trl", "bc", "io", "cmp", "fc", "Ctrl", "aux", "con", "adr", "cl", "bitcoin", "rl", "controller", "controlled", "lr", "icc", "ctx", "ci", "client", "cf", "ctr", "rc", "alloc", "utils", "conv", "lc", "rx", "irc", "alt", "fp", "conn", "attr", "nc", "ssl", "control", "ac"], "c": ["code", "cm", "k", "z", "dc", "i", "p", "b", "m", "uc", "C", "d", "x", "xc", "ec", "config", "pointer", "cr", "address", "ct", "ch", "cont", "self", "u", "e", " rc", "fc", "con", "o", "cmd", "cl", "vc", "s", "ctx", "ci", "size", "cf", "rc", "com", "channel", "co", "cache", "cp", "addr", "lc", "h", "f", "count", "n", "cu", "conn", "t", "coll", "v", "r", "g", "l", "cs", "ac", "pc"]}}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n", "idx": 26458, "substitutes": {"s": ["S", "comments", "sc", "ses", "rs", "sys", "p", "m", "server", "c", "ss", "ns", "b", "d", "features", "bis", "ts", "ds", "conf", "us", "ps", "ks", "sync", "self", "su", "is", "u", "e", "es", "gs", "south", "o", "sets", "strings", "session", "spec", "l", "si", "sym", "aws", "os", "uns", "client", "services", "com", "xs", "ls", "f", "service", "js", "qs", "sim", "fs", "a", "t", "v", "r", "settings", "ops", "ssl", "cs", "its", "native", "g"], "desc": ["acc", "esc", "ref", "seq", "sc", "code", "summary", "cod", "uc", "info", "cd", "c", "name", "stage", " descriptor", "enc", "doc", "vec", "data", "text", "ec", "config", "prop", "en", "diff", "bc", "def", "end", "rec", "cmp", "buf", "e", "dir", "loc", "sub", "disc", "Desc", "asc", "sec", "rc", "record", "req", "sup", "pro", "dep", "stream", "decl", "des", "entry", "ext", "src", "reg", "de", "comment", "resp", "usc", "dest", "description", "result"], "descptr": ["decpointer", "desptr", "escvr", " descriptPtr", "descriptionPtr", "despointer", "decPtr", " descpos", " descriptptr", "escval", "desctr", "declPtr", "descriptionaddr", "decptr", "desvr", "esctr", "secptr", "declval", "descriptionptr", "desPtr", " descpath", "declptr", "destr", " descriptpath", "desaddr", " descPtr", "DescPtr", "secctr", "descvr", "secpointer", "escctr", " descriptorptr", "descaddr", "Descaddr", "escptr", "descPtr", "descriptiontr", "declpointer", "escPtr", "Descptr", "Descpointer", "escpointer", "escaddr", " descpointer", " descaddr", "descctr", " descriptorpos", "descriptionpointer", " descriptorpath", " descriptorPtr", "descval", "decval", "secPtr", "descpos", "descpointer", "descriptionvr", " descctr", " descriptpos", "descpath"], "i": ["abi", "iii", "ie", "p", "m", "yi", "c", "info", "b", "d", "uli", "ix", "module", "x", "api", "adi", "ti", "interface", "mi", "qi", "it", "inst", "ri", "io", "id", "u", "is", "e", "li", "gi", "o", "zi", "multi", "xi", "uri", "start", "ii", "bi", "si", "ai", "di", "ni", "ini", "cli", "ci", "fi", "ik", "eni", "iv", "I", "f", "chi", "oi", "n", "j", "index", "ori", "y", "ip", "iu", "ind", "r", "pi", "v", "mu", "ui", "l", "hi", "in", "ami"]}}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468, "substitutes": {"bus": ["abi", "gen", "driver", "class", "b", "cat", "mount", "mot", "usb", "data", "back", "config", "us", "bug", "bc", "band", "ux", "pass", "cycle", "sync", "io", "serial", "plugin", "id", "self", "hub", "boot", "buf", "feed", "book", "home", "bridge", "vc", "http", "controller", "session", "Bus", "lib", "group", "drive", "parent", "board", "cache", "device", "git", "loop", "f", "child", "conn", "plug", "die", "machine", "l", "connection", "lock", "BUS"], "fdt": ["fdtm", "rafT", "FDts", "fdts", "dsts", "dst", "wdT", "FDT", "wdt", "fdT", "FDt", "dfT", "raft", "dft", "rafts", "dftm", "dfdt", "dsdt", "wdtm", "fddt", "dfts", "rafdt", "dsT", "wdts", "FDtm"], "qdev": ["reqvar", " qev", "qudiv", "Qdev", "qudc", "sqdd", " qpro", "sqvar", "questdev", "qupro", "qpro", "reqdev", "Qdiff", "questdevice", "qev", "sqdevice", "qdd", "qudev", "sqdiff", "qdiff", "qdc", "qdiv", "reqdc", "questdd", "Qpro", "Qdiv", "reqapp", "quapp", "qdevice", "Qdd", "quev", "sqdev", "qapp", "quvar", "sqdc", "Qdevice", "qvar", "questdiff", "sqapp", " qdiv", "Qev"], "qdevs": ["qvars", " qdevi", "qsdops", "qdepi", "qdeps", "pdevos", "qevos", "qdevd", "Qdeve", "qDevses", "qdevices", "wevs", "pevs", "qevses", "wdevos", "qdefe", "kevos", "dqdefstates", "qdefos", "qdevicee", "dqdevs", "qsdos", "pevses", "qdepstates", "kdevos", "pevds", "qdefsets", "wevops", "qdive", "qdeviced", "qdepd", "qvaros", "qdevses", "qevstates", "qDevds", "qdevds", "qgoodds", "qpathe", "Qdevs", "qvarops", "dqdevstates", "dqdefs", "kevlines", "qdevops", "dqdeve", "qgoodos", "qpathstates", "Qdeps", "qdevsets", "Qdevds", "qDeve", "qevlines", "qradds", "kdevs", "qDevos", "dqdevsets", "kevds", "wdevs", "qDevd", " qdevstates", "qdefstates", "qevops", "wdevops", " qddstates", "qsds", "pdevs", "qdeflines", "qdepds", "qevi", "qdefs", "kdevds", "Qdepds", "qdevlines", "qdeviceds", "qradses", "qgoodlines", "qevs", "qdepe", "kdevlines", "Qdepd", "qrados", "qpaths", "qgoods", "dqdefsets", "dqdefe", " qddi", "pdevses", "qddstates", "qddi", "qrads", "Qdevd", "pevos", "qevds", "qdivs", "qdivsets", "qdevi", "qdds", "qdevos", "pdevds", "wevos", "qdevstates", "qdivstates", "qDevs", "qpathsets", "qdefds", "kevs", "Qdepe", "qdeve", " qdds"], "kid": ["node", "kel", "tk", "sk", "gen", "sid", "k", "kn", "ski", "dc", "king", "chid", "dad", "anc", "pid", "nir", "isi", "kick", "kin", "kg", "ad", "bug", "idy", "hack", "ks", "kind", "id", "kb", " kids", "sync", "kids", "tick", "eth", "ker", "ko", "cer", "feat", "kr", "iden", "quad", "wk", "ki", "child", "da", "conn", "od", "ck", "ids", "ke", "ku", "dk", "cand", "Kid", "kt"], "i": ["k", "z", "ie", "b", "p", "yi", "c", "ix", "x", "en", "ti", "mi", "jp", "type", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "o", "ji", "zi", "multi", "start", "xi", "l", "ii", "di", "si", "ini", "bi", "ni", "ai", "ci", "ret", "eni", "part", "I", "f", "ki", "oi", "n", "j", "index", "ip", "chi", "iu", "ind", "mu", "pi", "v", "ui", "pos", "hi"], "num": ["temp", "node", "mom", "iq", "comb", "np", "nm", "b", "dim", "name", "uni", "norm", "fn", "sum", "img", "om", "nn", "col", "Num", "end", "mut", "id", "dom", "su", "u", "count", "unit", "nom", "con", "du", "span", "max", "min", "lu", "valid", "multi", "ul", "nb", "loc", "lit", "lib", "common", "ni", "mn", "parent", "coord", "ret", "sort", "inc", "number", "mon", "uu", "um", "f", "umi", "nr", "n", "index", "un", "mult", "out", "na", "NUM", "nu", "init", "lim", "mu", "net", "len"], "dev": ["md", "w", "dc", "info", "app", "data", "var", "ad", "conf", "bd", "pub", "bug", "def", "dd", "priv", "ch", "ev", "kind", "av", "dom", "prom", "pad", "adv", "dem", "lib", "di", "device", "dist", "mod", "conn", "reg", "plug", "rad", "Dev", "od", "ver", "pu", "de", "v", "block", "cand"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472, "substitutes": {"env": ["exec", "fen", "her", "code", "esm", "txt", "args", "console", "kn", "er", "exc", "engine", "server", "c", "context", "him", "manager", "enable", "enc", "vs", "queue", "ec", "en", "config", "Environment", "export", "gear", "priv", "state", "loader", "ev", "dict", "ea", "ah", "environment", "chn", "profile", "forest", "e", "password", "esi", "dat", "err", "viron", "dev", "model", "ctx", "energy", "eu", "skin", "eni", "cache", "erv", "ench", "vm", "req", "h", "icer", "forge", "ext", "stage", "prov", "status", "nw", "conn", "enh", "v", "init", " environment", "event", "settings", "que", "eng"]}}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n", "idx": 26480, "substitutes": {"env": ["exec", "esc", "her", "code", "args", "np", "console", "er", "scope", "exc", "engine", "c", "context", "shell", "enable", "enc", "qt", "ec", "en", "config", "conf", "Environment", "style", "export", "global", "ev", "end", "ea", "environment", "ne", "e", "el", "err", "enter", "dev", "cal", "ctx", "here", "energy", "eu", "emb", "erv", "iv", "esp", "conn", "vel", "event", "et", "que", "equ", "eng"], "f1": ["c2", "v3", "cf01", "c01", "h01", " fp", "f01", "F2", "f3", "h2", "cf2", "v1", "cfone", "cf1", "h3", "F1", " fone", "fone", "c1", "cone", "Fp", "F3", "v01", " f01", "fp", "h1", "F01", "vp", "v2"], "f2": ["p3", " ftwo", "ptwo", "l0", "f256", "l2", "bf256", "f3", "f0", "l4", "bf2", "f4", "e3", "ltwo", "p2", "e0", "bf3", "l256", " f3", "p4", "l3", "bf0", "ftwo", " f4", "e2", "e256"]}}
{"project": "FFmpeg", "commit_id": "2f9ca64556cba9a7edcca9a1c55923a60022937d", "target": 0, "func": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    AVDictionary *tmp = NULL;\n\n    const char *proto_name = NULL;\n\n    int ret;\n\n\n\n    av_dict_copy(&tmp, opts, 0);\n\n    av_dict_copy(&tmp, opts2, 0);\n\n\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n\n        if (url[6] == '+' || url[6] == ':')\n\n            proto_name = avio_find_protocol_name(url + 7);\n\n    }\n\n\n\n    if (!proto_name)\n\n        proto_name = avio_find_protocol_name(url);\n\n\n\n    if (!proto_name)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // only http(s) & file are allowed\n\n    if (av_strstart(proto_name, \"file\", NULL)) {\n\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n\n                url);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n\n        ;\n\n    } else\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n\n        ;\n\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n\n        ;\n\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (c->http_persistent && *pb && av_strstart(proto_name, \"http\", NULL)) {\n\n        ret = open_url_keepalive(c->ctx, pb, url);\n\n        if (ret == AVERROR_EXIT) {\n\n            return ret;\n\n        } else if (ret < 0) {\n\n            if (ret != AVERROR_EOF)\n\n                av_log(s, AV_LOG_WARNING,\n\n                    \"keepalive request failed for '%s', retrying with new connection: %s\\n\",\n\n                    url, av_err2str(ret));\n\n            ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n        }\n\n    } else {\n\n        ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n    }\n\n    if (ret >= 0) {\n\n        // update cookies on http response with setcookies.\n\n        char *new_cookies = NULL;\n\n\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n\n\n        if (new_cookies) {\n\n            av_free(c->cookies);\n\n            c->cookies = new_cookies;\n\n        }\n\n\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n\n    }\n\n\n\n    av_dict_free(&tmp);\n\n\n\n    if (is_http)\n\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n\n\n    return ret;\n\n}\n", "idx": 26481, "substitutes": {"s": ["S", "sc", "ses", "rs", "sr", "ss", "p", "b", "sn", "server", "ns", "m", "se", "ts", "sq", "us", "sg", "ks", "self", "su", "bs", "e", "cs", "es", "o", "spec", "si", "sym", "os", "ctx", "sb", "services", "sa", "ls", "f", "service", "n", "t", "v", "sl", "r", "sf", "ssl", "sv", "g"], "pb": ["uf", "pa", "obj", "p", "b", "pg", "pkg", "parse", "lb", "ppa", "x", "rb", "prop", "bh", "type", "bc", "bp", "proc", "plugin", "typ", "db", "mp", "PB", "fc", "python", "pd", "path", "http", "pl", "cli", "ctx", "cp", "sb", "fb", "pm", "lp", "tc", "prot", "tp", "fp", "cpp", "apy", "bps", "r", "vp", "_", "ssl", "pc", "ib"], "url": ["use", "ref", "date", "server", "name", "buffer", "base", "request", "bug", "hl", "el", "http", "fl", "zip", "username", "f", "r", "user", "bb", "text", "www", "address", "fr", "key", "feed", "resource", "path", "https", "web", "update", "rule", "src", "sl", "file", "email", "URL", "uc", "error", "all", "raw", "href", "Url", "str", "uri", "pl", "view", "length", "source", "pull", "host", "q", "full", "ssl", "secure", "location", "download", "page", "ll", "image", "api", "config", "type", "always", "id", "rel", "rl", "ul", "loc", "sel", "gl", "ur", "html", "ls", "route", "v", "result", "l"], "opts": ["opters", "operters", "oprs", "otcs", "opttes", " optrs", "OPcs", " optts", "opcs", "opertes", " optcs", "OPters", " optz", "optrs", "optz", "optcs", "OPtes", "optters", "otrs", "opercs", "optts", "OPts", "otts", "otz", "optes", "opz", "operts"], "opts2": ["opt4", "optSecond", "opt1", "opats2", "OPtSecond", "optes4", "opts1", "optesSecond", "opoptions2", "opts4", " opttSecond", "opttSecond", " opts52", "opats52", " optsSecond", "OPtsSecond", "optes1", "OPts2", "OPt2", "opcs2", "optsSecond", " optt52", "opoptionsSecond", "opcsSecond", " optt2", "optt52", "opcs1", "optt2", "optes2", "OPt4", "opcs4", "opts52", "opatsSecond", "opt2", "OPts1", "OPts4", "OPt1", "opoptions52"], "is_http": [" is_url", "is_url", "is_uri", "is_https", " is_https", " is_uri"], "c": ["sc", "cm", "k", "dc", "uc", "cd", "p", "b", "m", "this", "C", "d", "cv", "ec", "cur", "config", "cr", "conf", "ct", "bc", "cy", "ch", "self", "u", "e", "con", "vc", "cc", "ctx", "cn", "ci", "cf", "cp", "mc", "co", "lc", "ctrl", "ca", "f", "tc", "n", "cu", "t", "conn", "coll", "g", "l", "cs", "ce", "pc"], "tmp": ["temp", "txt", "obj", "np", "emp", "app", "stuff", "wb", "pkg", "cv", "ob", "data", "api", "storage", "metadata", "rb", "config", "vt", "cb", "opt", "proc", "cmp", "mp", "buf", "extra", "nb", "tt", "append", "copy", "properties", "ctx", "cp", "sb", "nt", "fb", "cache", "tab", "buff", "array", "etc", "source", "tc", "tp", "src", "meta", "attr", "bt", "params"], "proto_name": ["proocol_alias", "proto_alias", "protoShortname", "proo_name", "protoPName", "protoJname", "proresource_text", "propro_label", "proboPname", "proto_names", "proserver_info", "protoDtext", "protoJend", "progo_span", "prophy_name", "proprotJname", "proto\u00b7name", "proto_span", "protop64size", "propcMnames", "proto_version", "proto__n", "protop_name", "protoFname", "proto_none", "proto2info", "protoPdate", "proto_parent", "profrom_main", "protoJkey", "proco_end", "proto_end", "proco_url", "proo__type", "protoJlength", "proresourceDtext", "proprotJnone", "proto_size", "proserver_key", "protoSkey", "protop64name", "protoSlength", "protoNname", "propc_image", "proresource_name", "progo_name", "protop64named", "protoJerror", "proboPn", "proto_num", "proocol_name", "protoJlayer", "protop_size", "prophy_pass", "protoMnames", "protoMimage", "proco_size", "proto_Name", "proto_label", "protoFsearch", "propcMimage", "propc_name", "proserver_string", "proboPpart", "proto64named", "proto_n", "proo__Name", "protoNlabel", "proto__name", "proto_named", "probo_part", "proto__date", "protoNpart", "protop_named", "proresourceDsearch", "protoJName", "protoPalias", "proprotJlayer", "proto_layer", "proocol_nm", "protoJpart", "proo_type", "protoPspan", "proto_error", "protoSend", "proto2name", "protoUlayer", "proto__Name", "proto2string", "protoUnone", "profrom2main", "protoFparent", "protoShortnum", "propcMnamed", "proprot_Name", "proto64error", "proto_date", "proto_pass", "protoJn", "progo_version", "proto_info", "proto2type", "proto_nm", "protoPpart", "proto_part", "protoUname", "prophy_cache", "proto_string", "propc_names", "proco_name", "protoDsearch", "proto__part", "proproNname", "proo__name", "proocol_len", "protoMname", "proto_url", "protoDparent", "progo_Name", "proto64size", "protoJnamed", "probo_n", "proco_length", "protop64error", "profrom2type", "proboPdate", "proto_len", "proresourceDparent", "proprotJName", "profrom_type", "probo_date", "proto\u00b7span", "protofulltype", "proto_length", "proserver_name", "propro_part", "proto__type", "protoPversion", "protoMnamed", "profrom_name", "proto\u00b7version", "proprot_layer", "protofullname", "protoFtext", "protoSname", "propcMname", "proto_cache", "profrom2name", "propc_named", "probo_name", "proresourceDname", "proresource_search", "protoJsize", "proto2main", "proto2key", "protoPlen", "protop_error", "proproNpart", "protoUName", "proco_key", "proproNlabel", "proto_type", "proto_search", "proresource_parent", "protoShortnm", "proto\u00b7Name", "proto64name", "protoPn", "protoJdate", "proprot_none", "proto_image", "proocol_num", "protoJnone", "protofullmain", "proto_text", "protoDname", "propro_name", "proto_key", "proto_main", "proprot_name", "protoPname", "proo_Name"], "ret": ["ref", "code", "obj", "res", " RET", "data", "back", "att", " Ret", "def", "id", "num", "rets", "mem", "get", "bit", "det", "lit", "rev", "RET", "re", "nt", "reply", "rc", "arg", "Ret", "rt", "j", "alt", "resp", "match", "result", "len", "val", "fun"]}}
{"project": "qemu", "commit_id": "1dbd2fd9cbf29c74131e439ce80fb2efde56ee32", "target": 0, "func": "static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n\n{\n\n    int ret = -EINVAL, idx;\n\n    struct rdma_cm_id *listen_id;\n\n    char ip[40] = \"unknown\";\n\n    struct rdma_addrinfo *res;\n\n    char port_str[16];\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        rdma->wr_data[idx].control_len = 0;\n\n        rdma->wr_data[idx].control_curr = NULL;\n\n    }\n\n\n\n    if (rdma->host == NULL) {\n\n        ERROR(errp, \"RDMA host is not set!\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n    /* create CM channel */\n\n    rdma->channel = rdma_create_event_channel();\n\n    if (!rdma->channel) {\n\n        ERROR(errp, \"could not create rdma event channel\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    /* create CM id */\n\n    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);\n\n    if (ret) {\n\n        ERROR(errp, \"could not create cm_id!\");\n\n        goto err_dest_init_create_listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n", "idx": 26485, "substitutes": {"rdma": ["rdmu", "ldema", "rnka", "rnta", "ldta", "drmar", "rodmu", "ratmar", "rodma", "ddema", "rnda", "rmda", "ldmc", "rnpa", "ddma", "ratda", "lrda", "ldmma", "drmas", "rdmc", "ddha", "rostga", "rnmma", "frma", "rdga", "rdda", "rdmma", "rtmma", "rostda", "ldsa", "rlea", "nderema", "rxda", "ldda", "rtmad", "rlmeta", "rnmeta", "rnga", "rdha", "rmema", "frmas", "rxma", "rdta", "rlpa", "rnma", "dnmma", "rodda", "drma", "rdmeta", "rdea", "rtmas", "ddta", "ldma", "rdka", "ldsi", "rtmu", "lrmad", "rdwa", "ldmeta", "rlka", "ddsa", "ldea", "rostma", "rtta", "ldga", "rlmad", "rdsa", "rostmma", "drha", "rtma", "rdmar", "rmsi", "rdpa", "rxeme", "rdeme", "ratma", "rnema", "lrwa", "dnda", "ldha", "ddda", "rnmad", "rtwa", "ddea", "drda", "rdema", "ddmma", "lrma", "frmma", "nderda", "rlda", "drta", "dnmu", "rlma", "rlsa", "drmma", "rnmas", "rtda", "rxmas", "nderma", "ldwa", "rdmad", "ldka", "ldmas", "ldeme", "rmmc", "rdsi", "rdmas", "ldmad", "ratmas", "ldpa", "rtmar", "dnma", "rnsi", "rodmma", "drmc", "rneme", "rmmma", "rmma", "ndermma", "frda"], "errp": [" erps", "lerpt", "Erp", "ergps", "asterpe", "verpy", "erpr", "asterP", "erfp", "lerP", "erpp", "errpe", "verpt", "lerpy", "ergpe", "orderpr", " errr", "orderp", "errpre", "Erpe", " errpp", "asterp", "reqpe", "errpp", "verP", "angerpt", "ErP", "err", "angerp", "angerpy", "iterp", "lerp", "errr", " erp", " errfp", "errorpe", "ergpp", "orderfp", "erpre", " errpr", "errps", "iterfp", "reqpp", "reqps", " erpp", "Erc", "errpy", "errpr", "errorP", "reqp", "errpt", "erp", "errorc", "verp", "errfp", "errP", "orderr", " errpre", " erpe", "angerP", "errc", "iterpp", "iterpre", "ergp", "errorp", "asterc"], "idx": ["midx", " idxc", " idf", "pidxs", "Idxs", "idew", " idv", "midz", " idy", "idz", "indxes", "pidxc", "Idy", "ridX", "idw", "pidx", "aidx", "IDy", " idz", "idy", " idxes", "aidz", " idw", "ridw", "aidy", " idX", "Idxes", "IDxs", "indx", "aidv", "idX", "IDx", "indX", "idxc", "IdX", "ridy", "indy", " idxs", "idv", "midy", "idxes", "idf", "Idxc", "idex", "idef", "IDX", "Idw", "midv", "ridf", "idxs", "ridx", "pidX", "Idx", "idey"], "listen_id": ["listennbase", "liston_type", "listener_ids", "liston_base", "listenxids", "listener_name", "listener_sid", "listennid", "listen2type", "listen__id", "listen2start", "listen_base", "listen_name", "listennstart", "listener_type", "listen_type", "liston_start", "listen_start", "listenxid", "listen_ids", "listen__name", "listen_sid", "listenntype", "listenxname", "listenxsid", "liston_id", "listen2id", "listen__index", "listener_id", "listener_index", "listen_index", "listen__type", "listen2base"], "ip": ["seq", "skip", "email", "ep", "byte", "af", "dc", "p", "i", "ide", "name", "of", "ips", "data", "api", "img", "up", "interface", "address", "type", "pass", "mac", "op", "id", "port", "is", "num", "link", "ic", "input", "uri", "parent", "cp", "hop", "ress", "iv", "field", "addr", " IP", "im", "comp", "zip", "proxy", "loop", "source", "IP", "net", "host", "php", "route", "block", "ap", "ib", "isp"], "res": ["ref", "rest", "remote", "rs", "seq", "sr", "RS", "resolution", "RES", "gr", "error", "def", "rep", "rec", "RE", "rets", "es", "arr", "rel", "rh", "err", "rev", "re", "ras", "ret", "reply", "rc", "response", "ress", "req", "addr", "rem", "Res", "ry", "rx", "reg", "resp", "results", "r", "ex", "pre", "result", "rr", "val", "params", "ES"], "port_str": ["port_string", " port_int", "port2name", "port_dict", "port2int", " port_name", "host_Str", "port2arr", " port_Str", "port_div", "port2Str", "portallstr", "host_str", "port2str", "host_div", " port_string", "host_string", "port2dict", "portalldict", "port_Str", " port_dict", "port_int", "port_arr", "portallstring", "port2string", "port_name", "port2div", " port_arr", "portallStr", "port_br", "port2br", " port_br"], "e": ["element", "fe", "er", "ie", "i", "p", "m", "ele", "c", "d", "se", "ae", "ge", "me", "ec", "en", "eve", "je", "ell", "pe", "ze", "ei", "ev", "end", "ea", "oe", "ne", "u", "ed", "ee", "es", "o", "el", "pse", "esi", "ef", "eb", "enter", "re", "edge", "eu", "ue", "h", "f", "y", "n", "entity", "E", "de", "be", "v", "r", "l", "ce", "g"]}}
{"project": "qemu", "commit_id": "2d26512b45b5236fa521c4492608fe9fb5bedf46", "target": 0, "func": "int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t/*\n\n\t * Force to even boundary.\n\n\t */\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t */\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n", "idx": 26489, "substitutes": {"m": ["i", "p", "b", "d", "manager", "module", "x", "tm", "media", "ms", "mi", "mr", "mac", "u", "e", "o", "mt", "M", "model", "mc", "man", "h", "um", "f", "y", "sm", "n", "t", "mm", "dm", "a", "bm", "v", "machine", "r", "meta", "mu", "gm", "l", "g"], "len": ["L", "seq", "gen", "bin", "z", "ie", "ll", "x", "fn", "lan", "en", "ell", "bl", "lon", "num", "split", "enn", "hl", "lf", "line", "mem", "el", "Len", "li", "lu", "la", "ul", "dl", "lin", "fl", "le", "nt", "lt", "size", "ln", "fat", "length", "lc", "zen", "lp", "au", "f", "n", "limit", "net", "alt", "lim", "sl", "v", "pos", "_", "l", "val", "layer"], "w": ["z", "wu", "widget", "wb", "u", "wx", "oss", "fw", "word", "ou", "window", "f", "way", "n", "wei", "t", "mm", "r", "wa", "kw", "k", "p", "b", "x", "wave", "sum", "wh", "www", "work", "wd", "tw", "now", "wp", "h", "aw", "value", "W", "sh", "g", "temp", "wan", "ww", "d", "wo", "am", "ch", "how", "raw", "e", "iw", "weights", "wt", "nw", "q", "mit", "we", "ow", "i", "sw", "weight", "opt", "plus", "rw", "hw", "o", "wl", "words", "ew", "wm", "win", "wal", "y", "v", "l", " W"], "c": ["sc", "code", "k", "z", "dc", "i", "p", "b", "oc", "d", "C", "x", "enc", "xc", "ec", "config", "u", "e", "con", "o", "ic", "cl", "cc", "ci", "cp", "mc", "cache", "co", "lc", "h", "f", "n", "a", "t", "q", "v", "r", "g", "l", "cs", "ac", "pc"], "s_util": ["s2utils", "s_ui", "ws_util", "s2global", "s2util", "slogut", "slogutil", "s_global", "s_utils", "slogui", "l_utils", "s_local", "s_security", "ws_local", "ws_utils", "slogquant", "g_mut", "s2ut", "l_global", "g_ut", "g_util", "s_quant", "l_ut", "s_mut", " s_quant", " s_ui", " s_ut", "g_security", "s_ut"], "s": ["S", "sc", "k", "z", "ss", "p", "b", "ns", "d", "ts", "x", "ms", "ds", "ans", "ps", "is", "e", "si", "os", "xs", "h", "ls", "f", "n", "a", "q", "v", "sl", "r", "in", "l", "cs", "g"], "l_util": ["l_utils", " l_utils", " l_san", "ljutil", "l_san", "ljutils", "ljsan"], "mlen": [" mlenn", "slen", "MLEN", "mLent", "MLen", "MLenc", "mallen", " mleng", "mlin", "mLenn", "mLeng", "elain", "MLlen", "llien", "eln", "sln", "plun", "plain", "mlzen", "maleni", " mlent", "plenn", "mleng", "malener", "mLen", "mllen", "blen", "mLien", "plen", "milenn", "linen", "mlened", "llEN", "blener", "ulen", "slens", "mlain", "milzen", "selon", "slenn", "elening", "arlhen", "elenn", "slener", "sleng", "mlener", "malenn", "ulhen", "plan", "malon", "milin", " mladen", "mlEN", "llenn", "ulenn", " mlenc", "dlen", " mlEN", "mlhen", " mlon", "llhen", "llen", "mlent", "milener", "linenn", " mlan", "slain", "pleng", "mLun", " mleni", " mllen", "llener", "malun", "slening", "MLeng", "malened", " mlening", "linhen", "malin", "malen", "miladen", "elened", "arlzen", "dlzen", "milen", "selan", "mlan", " mlened", "mileng", "bleng", "llain", "elon", "slon", "maleng", "llan", "mleni", "mlening", " mln", "plin", "plhen", "dleng", "malain", "elens", "arlen", "mlon", "elen", "llon", " mlain", "milhen", "MLon", "eleni", " mlens", "selhen", "mlun", "arleng", "selen", "lineng", "lleng", "milent", "mlenn", "mlenc", "llun", "mladen", "milun", "mlens", "MLain", "dlhen", "mLaden", "plien", "ulener", "llenc", "plon", "blenn", "mln", "mlien"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 26496, "substitutes": {"as": ["use", "sys", "can", "er", "using", "inas", "asm", "las", "or", "base", "ab", "var", "am", "us", "ast", "mac", "alias", "is", "AS", "al", "was", "at", "aws", "os", "ras", "nas", "ar", "cas", "array", "pas", "a", "aster", "are", "acs", "As", "ap"], "buffer": ["ref", "uf", "code", "byte", "b", "master", "server", "batch", "position", "image", "callback", "queue", "data", "base", "program", "read", "pause", "delay", "interface", "address", "capacity", "prefix", "reference", "reader", "loader", "port", "texture", "surface", "uffer", "url", "buf", "iter", "ram", "message", "resource", "input", "bridge", "seek", "binary", "pool", "number", "Buffer", "cache", "shape", "ptr", "length", "addr", "buff", "array", "available", "transfer", "f", "source", "comment", "limit", "null", "material", "header", "memory", "r", "map", "result", "layer"], "len": ["seq", "name", "base", "lan", "en", "type", "bl", "all", "db", "open", "Len", "min", "cap", "start", "offset", "size", "cache", "addr", "length", "ls", "count", "limit", "index", "pos", "val", "lock"], "is_write": ["IS_writer", "as_write", "is_sync", "IS_write", "as_writing", "IS_sync", " is_read", "is_read", "is_writing", "as_sync", "is_send", "is_writer", "as_read", "IS_network", "is_network", " is_send", " is_network"], "access_len": ["ac_len", " access_line", "access2l", "ac2val", "access_label", "pass_label", "access2len", "pass_len", "passinglen", "access_ln", "access_data", " access_Len", "access2data", "access_Len", "pass_ln", " access_count", "accesslval", "accessingln", "passinglabel", "accessinglimit", "accessenl", "accessingline", "accessfval", "access_length", "ac_data", "accessllf", "passingln", "ac_l", "access_size", "accessflen", " access_val", "ac2l", "accessenlabel", "passingl", " access_length", "access_count", "access2ln", "accesslln", "access_lf", " access_ln", "access_limit", "access_line", "accessinglen", "accessfcount", "accessenlen", "ac2len", "accessflength", "access_l", "ac2data", "accesslsize", "access2val", "accesslLen", "ac_val", "access2size", "accessinglabel", "access_val", "accessingl", "pass_l", " access_limit", "accessenln", " access_size", "accessllen", " access_lf"], "l": ["L", "k", "i", "p", "m", "b", "c", "ll", "d", "lb", "ld", "ell", "u", "e", "line", "lf", "al", "el", "o", "li", "cl", "lu", "kl", "ol", "s", "la", "rl", "lit", "dl", "pl", "lin", "fl", "ul", "loc", "le", "lr", "ln", "length", "il", "lc", "ls", "lp", "f", "jl", "n", "j", "lo", "t", "nl", "v", "sl", "r", "g"]}}
{"project": "FFmpeg", "commit_id": "44d854a518f97cb65090420b0b9f55611a0ea932", "target": 1, "func": "static av_cold int atrac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    int version, delay, samples_per_frame, frame_factor;\n\n    const uint8_t *edata_ptr = avctx->extradata;\n\n    ATRAC3Context *q = avctx->priv_data;\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Channel configuration error!\\n\");\n\n\n    }\n\n\n\n    /* Take care of the codec-specific extradata. */\n\n    if (avctx->extradata_size == 14) {\n\n        /* Parse the extradata, WAV format */\n\n        av_log(avctx, AV_LOG_DEBUG, \"[0-1] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown value always 1\n\n        edata_ptr += 4;                             // samples per channel\n\n        q->coding_mode = bytestream_get_le16(&edata_ptr);\n\n        av_log(avctx, AV_LOG_DEBUG,\"[8-9] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  //Dupe of coding mode\n\n        frame_factor = bytestream_get_le16(&edata_ptr);  // Unknown always 1\n\n        av_log(avctx, AV_LOG_DEBUG,\"[12-13] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown always 0\n\n\n\n        /* setup */\n\n        samples_per_frame    = SAMPLES_PER_FRAME * avctx->channels;\n\n        version              = 4;\n\n        delay                = 0x88E;\n\n        q->coding_mode       = q->coding_mode ? JOINT_STEREO : STEREO;\n\n        q->scrambled_stream  = 0;\n\n\n\n        if (avctx->block_align !=  96 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 152 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 192 * avctx->channels * frame_factor) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown frame/channel/frame_factor \"\n\n                   \"configuration %d/%d/%d\\n\", avctx->block_align,\n\n                   avctx->channels, frame_factor);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (avctx->extradata_size == 10) {\n\n        /* Parse the extradata, RM format. */\n\n        version                = bytestream_get_be32(&edata_ptr);\n\n        samples_per_frame      = bytestream_get_be16(&edata_ptr);\n\n        delay                  = bytestream_get_be16(&edata_ptr);\n\n        q->coding_mode         = bytestream_get_be16(&edata_ptr);\n\n        q->scrambled_stream    = 1;\n\n\n\n    } else {\n\n        av_log(NULL, AV_LOG_ERROR, \"Unknown extradata size %d.\\n\",\n\n               avctx->extradata_size);\n\n\n    }\n\n\n\n    /* Check the extradata */\n\n\n\n    if (version != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version %d != 4.\\n\", version);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (samples_per_frame != SAMPLES_PER_FRAME &&\n\n        samples_per_frame != SAMPLES_PER_FRAME * 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of samples per frame %d.\\n\",\n\n               samples_per_frame);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (delay != 0x88E) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of delay %x != 0x88E.\\n\",\n\n               delay);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (q->coding_mode == STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Normal stereo detected.\\n\");\n\n    else if (q->coding_mode == JOINT_STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Joint stereo detected.\\n\");\n\n    else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown channel coding mode %x!\\n\",\n\n               q->coding_mode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (avctx->block_align >= UINT_MAX / 2)\n\n\n\n\n    q->decoded_bytes_buffer = av_mallocz(FFALIGN(avctx->block_align, 4) +\n\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (q->decoded_bytes_buffer == NULL)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    /* initialize the MDCT transform */\n\n    if ((ret = ff_mdct_init(&q->mdct_ctx, 9, 1, 1.0 / 32768)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        av_freep(&q->decoded_bytes_buffer);\n\n        return ret;\n\n    }\n\n\n\n    /* init the joint-stereo decoding data */\n\n    q->weighting_delay[0] = 0;\n\n    q->weighting_delay[1] = 7;\n\n    q->weighting_delay[2] = 0;\n\n    q->weighting_delay[3] = 7;\n\n    q->weighting_delay[4] = 0;\n\n    q->weighting_delay[5] = 7;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        q->matrix_coeff_index_prev[i] = 3;\n\n        q->matrix_coeff_index_now[i]  = 3;\n\n        q->matrix_coeff_index_next[i] = 3;\n\n    }\n\n\n\n    avpriv_float_dsp_init(&q->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    ff_fmt_convert_init(&q->fmt_conv, avctx);\n\n\n\n    q->units = av_mallocz(sizeof(*q->units) * avctx->channels);\n\n    if (!q->units) {\n\n        atrac3_decode_close(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avcodec_get_frame_defaults(&q->frame);\n\n    avctx->coded_frame = &q->frame;\n\n\n\n    return 0;\n\n}", "idx": 26512, "substitutes": {"avctx": ["AVlc", "varctx", "vercmp", "varcontext", "avalconn", "ivpkg", "avehw", "avcontext", "avesync", "afcontext", "avectx", "avctl", "ajctx", "AVsync", "avcn", " avpkg", "airctx", "afxc", "ajcli", "avcdn", "aircontext", "akctx", "avecmp", "verlc", "akcontext", "avecot", "AVcontext", "afcli", "akcomponent", "avepkg", "afsync", "afcdn", "avcoll", "alctrl", "aircn", "afctrl", "versync", "airpkg", "avalcontext", "avsci", " avcmp", "afcn", "afctx", "avconfig", "akxc", "avalctx", "avpkg", "avcot", "avectrl", "avloc", "akcf", "avctrl", "avhw", "avalctl", "aveloc", "AVctx", "AVctl", "verctx", "avxc", "avcb", "avectl", "alctx", "avcf", "akcdn", "avelc", "avalcf", "AVcmp", "avalcmp", "avecontext", "evcontext", "AVconn", "avcmp", "avalhw", "verconn", "avsync", "ivcot", "afcf", "ivctx", "afhw", "evctx", " avcf", "ajcdn", "afcb", "aflc", "avalpkg", "avesci", "afcot", "verloc", "avconn", "alcontext", "afcoll", "ajpkg", "afconn", "vercb", "ajcontext", "akcn", "afctl", "avecf", "avalxc", "ivcontext", "afpkg", "avalcoll", "varcb", "ajcn", "vercf", "AVcoll", "avalsci", "varcmp", "aveconfig", "vercontext", "avcli", "avecn", "alcf", "evconn", "alctl", "avallc", "aveconn", "avcomponent", "avalcomponent", "afcomponent", " avconn", "afsci", " avcontext", "avlc", "afloc", "avalconfig", "akpkg", "afcmp", "avalcli", "evpkg", "afconfig"], "i": ["p", "b", "info", "c", "d", "ix", "ti", "qi", "io", "id", "is", "e", "li", "ii", "di", "ai", "ci", "I", "f", "n", "j", "index", "ip", "v", "ind", "pi", "ui"], "ret": ["seq", "code", "res", "server", "success", "error", "err", "run", "re", "dev", "rc", "req", "timeout", "count", "status", "resp", "row", "event", "ver", "r", "result", "len", "val", "wait"], "version": ["VERSION", "code", "package", "trial", "info", "date", "Version", "server", "position", "qa", "condition", "vision", "feature", "type", "error", "id", "serial", "depth", "ersion", "step", "seed", "unit", "patch", "min", "progress", "model", "versions", "mode", "install", "parent", "grade", "sequence", "order", "scale", "channel", "length", "update", "stage", "event", "ver", "release", "block", "format"], "delay": ["load", "frequency", "skip", "trial", "date", "server", "queue", "pause", "del", "diff", "fail", "type", "hide", "error", "duration", "sync", "live", "repeat", "seed", "progress", "offset", "mode", "grade", "sequence", "rate", "scale", "length", "sleep", "timeout", "stage", "dq", "range", "ait", "random", "priority", "lock", "wait"], "samples_per_frame": ["samples_per_cycle", "samples_per_image", "samples_per_Frame", "samples_per_line", "samples_per_time"], "frame_factor": ["scene\u00b7fact", "frame___factor", "framealfactor", "frame___span", "zone_fact", "frame_duration", "frame\u00b7factor", "zone_dimension", "frame_size", "scene_tier", "frame\u00b7fact", "frame64factor", "framelexfactor", "frame___currency", "zone___dimension", "zone___span", "frame___scale", "frame_frequency", "scene\u00b7factor", "framelexfact", "frame64tier", "frame___fact", "frame_currency", "framealfrequency", "sample_tier", "framelexspan", "frame_tier", "frame_Factor", " frame_tier", "framealtier", "zone___fact", "wave_currency", "frame64size", "frame_span", "scene_fact", " frame_duration", "zone___factor", "scene\u00b7tier", "wave_factor", "scene_factor", " frame_Factor", "zone_span", "framelexdimension", "frame_dimension", "frame___dimension", "sample_factor", "sample_frequency", "frame\u00b7tier", " frame_size", "zone_factor", "frame_fact", "wave_scale", "frame_scale"], "edata_ptr": ["edada_tip", "edata_port", "edina_ptr", "edata67pert", "edataKrt", "edova_addr", "edova_pos", "edata_tty", "edata_pt", "eddata_pur", "edata_cur", "edova_ptr", "edata_addr", "edina_pt", "edaton67pert", "edina_ref", "edaton67ptr", "edta_cur", "edataFref", "edova_loc", "edata_dr", "edataKaddr", "edata_rt", "edata_dist", "edta_ref", "edada_port", "edata_dest", "edata_pur", "edada_ptr", "edaton_rt", "eddata_ptr", "edat_pos", "edat_tty", "edata_pert", "edada_dist", "edada_ref", "edta_addr", "edada_dr", "edata_pointers", "eddata_dr", "edat_tr", "edaton_ptr", "edat_ptr", "edaton_addr", "edataFtip", "edada_dest", "edata67rt", "edaton_pert", "edataKpert", "edada_cur", "edataFptr", "edaton67addr", "eddata_pointers", "edata67addr", "edata67ptr", "edaton67rt", "edta_ptr", "edataFcur", "edata_tip", "edata_tr", "edina_pointers", "edataKptr", "edata_loc", "edata_pos", "edata_ref"], "q": ["requ", "iq", "Q", "k", "w", "z", "info", "p", "m", "question", "c", "pg", "context", "d", "qa", "queue", "qt", "sq", "config", "conf", "ch", "self", "u", "aq", "cal", "ctx", "client", "rc", "req", "quad", "h", "qu", "f", "comment", "qs", "quant", "j", "qq", "t", "v", "query", "dq", "que", "g"]}}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 26530, "substitutes": {"opaque": ["openec", "openaque", "opacity", "Opec", "OPenv", "Opaque", "Openv", "OPaque", "Opacity", "OPacity", "opec", "openenv", "openacity", "OPec", "openv"], "addr": ["md", "node", "ref", "code", "args", "Address", "p", "arm", "context", "dr", "x", "asm", "data", "buffer", "base", "config", "pointer", "ad", "address", "error", "mac", "port", "alias", "ea", "pad", "point", "grad", "adr", "start", "offset", "slot", "coord", "target", "ptr", "arg", "amd", "src", "conn", "host", "alt", "inter", "ace", "attr", "pos", "layer"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531, "substitutes": {"a": ["pa", "w", "z", "i", "p", "m", "c", "aa", "app", "d", "ae", "x", "data", "api", "ab", "img", "am", "access", "A", "aj", "abc", "mac", "instance", "asa", "e", "aux", "ba", "audio", "s", "aaa", "ai", "parent", "sa", "as", "array", "ca", "f", "aw", "n", "index", "an", "root", "r", "alpha", "l", "ac", "area", "g"], "b": ["body", "obj", "w", "i", "p", "m", "wb", "c", "bis", "app", "d", "bb", "x", "base", "rb", "ab", "bc", "abc", "A", "bs", "e", "zb", "ba", "pb", "s", "bi", "binary", "sb", "fb", "abb", "B", "emb", "bar", "ca", "f", "n", "j", "bg", "v", "r", "l", "g"]}}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535, "substitutes": {"vs": ["rs", "sk", "args", "ss", "pg", "ns", "va", "Vs", "ov", "ts", "blocks", "ms", "ds", "forces", "var", "verts", "ports", "vr", "ps", "vas", "plugins", "vers", "ks", "bs", "css", "vals", "es", "gs", "stats", "ims", "s", "http", "spec", "sv", "points", "dev", "versions", "os", "obs", "services", "iv", "vm", "xs", "ums", "ls", "fs", "qs", "js", "alls", "ves", "v", "ver", "vp", "ops", "VS", "pos", "cs", "env", "vol", "views"], "i": ["abi", "k", "z", "ie", "p", "b", "m", "c", "d", "x", "ti", "mi", "type", "phi", "qi", "ri", "id", "u", "e", "o", "li", "gi", "ji", "zi", "multi", "xi", "uri", "ii", "bi", "si", "ai", "di", "ni", "ini", "ci", "fi", "I", "f", "oi", "n", "ip", "j", "index", "t", "v", "iu", "mu", "pi", "in", "ui", "l", "hi"]}}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538, "substitutes": {"spapr": ["spapers", "spampb", "spAPb", "SPapr", "SPapar", "spapb", "scaprs", "smatrc", "scapenr", "scapers", "spapenr", "spatrc", "smatrr", "SPaprs", "SPapb", "smapr", "spAPnr", "spapsb", "spepr", "spapnr", "SPapsr", "spatpr", "spepm", "scapm", "scapr", "spepnr", "spapem", "SPapsrs", "SPapsb", "spAPr", "scaper", "spAPrs", "spamprs", "spatrr", "spAPm", "speprs", "smaprc", "spamprr", "spAPrr", "spAPrc", "spaprc", "scapnr", "spampar", "spaper", "scapem", "smatr", "spampr", "spapsr", "spapar", "spamprc", "smappr", "spapm", "spapsar", "smatpr", "smaprr", "spaprs", "spaprr", "spatr", "spAPpr", "spapsrs", "spAPar", "SPapsar", "spappr", "spamppr"], "entry": ["ger", "her", "import", "element", "er", "expected", "ie", "section", "parse", "info", "server", "card", "se", "ge", "or", "data", "next", "letter", "escape", "reader", "error", "end", "archive", "e", "feed", "line", "Entry", "key", "cell", "extra", "session", "cel", "inner", "ent", "enter", "handler", "nt", "parent", "new", "inc", "sec", "ry", "zip", "child", "index", "row", "inter", "event", "route", "keeper", "try", "result", "connection"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n", "idx": 26540, "substitutes": {"sccb": ["scfbb", "cscentsb", "csccbb", "srcbb", "setsscl", "sucbd", "sccf", "Sccasb", "setsccl", "sclf", "srcob", "sccabin", "sckf", "setsscp", "scentbin", "sucbb", "sccaa", " scca", "csccsb", "Sccaf", "Sccsb", "sucf", "Sccb", "sckbc", "Sucb", "Sucv", " scfbd", "Scca", "sucsb", "sckp", "setsccb", "Sccafb", "sscb", "scca", "srcf", "sccbc", "sCCbb", " sccbb", "sscp", "scff", "sccaf", "sucv", "sscd", " sccbd", "sccabd", "sscl", "sccab", "scfa", "Sccfb", "scfbd", "Sccbc", "sccabb", " sCCf", "sccfb", "scld", "sclbc", "cscentbin", "sscf", "sclb", "Sccab", "scentbb", "cscentb", "srcp", "sccl", "sCCf", "Sucbb", "sucfb", " sccf", "Suca", "sccbd", "srcv", "sckd", " scfb", "srcfb", "sckob", "setsscb", "sccasb", "sccbb", "Sckbc", "sccap", " sCCb", "csccb", "Sckb", "scfbin", "sccd", "sckb", "sckl", "sccafb", "sCCbd", "setsccp", "sucp", "sccsb", "scfsb", " sCCa", "Sccbb", "scentsb", "sccob", "sscbc", "cscentbb", "Sckd", "sccbin", " scfbb", "Sccap", " sCCbd", "Sckf", "Sccf", "srcb", "srcsb", "csccbin", "srcl", "sCCa", "sscob", "sccp", "Sccp", "sucb", "sCCb", "setsscob", "sccv", "setsccob", "srca", "scentb", "scfb", "Sccv", "Sccd", "sCCv", " scfa", "suca"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n", "idx": 26543, "substitutes": {"json": ["build", "temp", "node", "txt", "tree", "obj", "token", "parse", "hash", "server", "module", "data", "api", "test", "jp", "jj", "plus", "key", "nil", "ruby", "ji", "javascript", "JSON", "jc", "object", "journal", "closure", "response", "xml", "git", "jack", "update", "son", "js", "java", "j", "value", "list", "pack", "result", "dj", "ja", "ok"], "name": ["package", "nm", "none", "option", "c", "ns", "time", "x", "data", "var", "type", "prefix", "property", "id", "alias", "self", "Name", "key", "str", "path", "inner", "parent", "word", "new", "size", "nice", "part", "comment", "NAME", "named", "value", "n", "j", "index", "names"], "val": ["ref", "p", "b", "pt", "d", "VAL", "x", "data", "eval", "doc", "var", "Value", "num", "all", "vals", "key", "unit", "arr", "el", " value", "str", "valid", "lit", "slot", "sel", "arg", "Val", "part", "f", "count", "value", "index", "alt", "func", "v", "sl", "pos", "len", "vol"]}}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26552, "substitutes": {"s": ["S", "rs", "ses", "sys", "args", "this", "ss", "p", "m", "i", "c", "ns", "b", "ts", "sites", "ds", "request", "conf", "us", "ps", "sg", "state", "states", "sync", "sis", "su", "is", "u", "self", "e", "gs", "stats", "site", "o", "sets", "input", "session", "spec", "sv", "si", "sym", "os", "uns", "new", "sb", "services", "ar", "ls", "f", "service", "qs", "js", "fs", "n", "t", "a", "j", "your", "status", "g", "r", "sf", "settings", "ssl", "cs", "params", "side"], "sci_level": ["sciianlog", "sciianpass", " sci_layer", "science_pass", "ci_mode", "sci_lock", "ci_level", "sci_vel", "ci_scale", "science_level", " sci_vel", "science_log", "sci_pass", "sci_scale", "sciianlevel", "ci_lock", "sci_layer", "sci_log", "sci_mode", "sciianlayer", "science_layer", " sci_lvl", "sci_lvl"], "pmsts": ["cmops", " pmlines", "pmst", "pmops", "fmsts", " pmrs", "hmst", "cmst", "cmlines", "pmlines", "PMns", "cmstrings", "cmrs", "fmrs", "pmds", "PMds", "pmrs", "cmsts", " pmstrings", "hmstrings", " pmds", "rpmlines", "rpmops", "hmds", "fmstrings", "PMstrings", " pmst", "pmns", "PMst", "PMops", " pmops", "hmsts", "pmstrings", "rpmsts", "PMsts", " pmns", "cmns", "rpmst", "fmst"]}}
{"project": "FFmpeg", "commit_id": "beefafda639dd53fc59c21d8a7cf8334da9a1062", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n", "idx": 26559, "substitutes": {"s": ["rs", "ses", "args", "sys", "w", "ss", "p", "i", "server", "c", "m", "ns", "b", "d", "ts", "ing", "sq", "ds", "request", "conf", "support", "ps", "sg", "ins", "ks", "sync", "self", "is", "u", "e", "stats", "gs", "site", "o", "es", "sets", "session", "spec", "l", "less", "sym", "si", "aws", "os", "new", "als", "sb", "services", "xs", "ls", "f", "service", "qs", "js", "fs", "source", "t", "a", "v", "full", "settings", "ops", "sf", "ssl", "cs", "in", "its", "g"], "crc": ["Crc", "cfc", "Cbc", " crs", " cRC", "acRC", "crs", "cRC", " cinc", "csrc", "acsrc", "acrc", " cfc", "rdc", "Crs", "CRC", "ncsrc", "acdc", "acbc", " cdc", "rinc", " csrc", "acfc", "ncfc", "cinc", "ncrc", "rRC", "acinc", "ncRC", "cbc", "rrc", "acrs", "cdc", " cbc"], "S": ["L", "DS", "Q", "Si", "ss", "RS", "C", "CS", "SR", "K", "SI", "P", "T", "SP", "H", "Source", "A", "SB", "X", "SE", "AS", "U", "WS", "TS", "R", "SS", "M", "SN", "SH", "D", "PS", "Y", "SA", "B", "G", "Set", "SC", "N", "Sa", "I", "W", "V", "String", "NS", "O", "Socket", "F"], "bit": ["mask", "gap", "byte", "digit", "bin", "BIT", "b", "i", "option", "pixel", "flag", "ix", "x", "back", "fix", "base", "no", "component", "ct", "type", "bc", "bug", "version", "pass", "it", "character", "op", "num", "id", "second", "key", "unit", "set", "Bit", "offset", "slot", "binary", "sign", "word", "sec", "quad", "off", "bar", "comp", "f", "bits", "value", "null", "block", "ac", "tag"]}}
{"project": "FFmpeg", "commit_id": "42f9132218ca11a8e9a3c82a175b46bca092113e", "target": 0, "func": "static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n    MXFContext* mxf = s->priv_data;\n\n    int64_t seekpos;\n\n    int ret;\n\n    MXFIndexTable *t;\n\n\n\n    if (mxf->nb_index_tables <= 0) {\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n\n\n    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)\n\n        return ret;\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    mxf->current_edit_unit = sample_time;\n\n    } else {\n\n        t = &mxf->index_tables[0];\n\n\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n\n         * this also means we allow seeking before the start */\n\n        sample_time = FFMAX(sample_time, 0);\n\n\n\n        if (t->fake_index) {\n\n            /* behave as if we have a proper index */\n\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n\n                return sample_time;\n\n        } else {\n\n            /* no IndexEntryArray (one or more CBR segments)\n\n             * make sure we don't seek past the end */\n\n            sample_time = FFMIN(sample_time, st->duration - 1);\n\n        }\n\n\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)\n\n            return ret;\n\n\n\n        ff_update_cur_dts(s, st, sample_time);\n\n        mxf->current_edit_unit = sample_time;\n\n        avio_seek(s->pb, seekpos, SEEK_SET);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26568, "substitutes": {"s": ["sys", "w", "server", "ns", "ts", "sq", "support", "states", "sync", "self", "u", "es", "gs", "http", "set", "sym", "xs", "sa", "f", "service", "qs", "n", "js", "fs", "r", "ops", "S", "space", "p", "m", "b", "c", "se", "storage", "ds", "us", "ins", "su", "is", "sets", "spec", "aws", "services", "com", "sl", "g", "rs", "ses", "ss", "sn", "d", "conf", "sg", "ks", "e", "session", "stat", "sb", "sf", "ssl", "cs", "sv", "sc", "i", "site", "ic", "si", "os", "ls", "y", "v", "l"], "stream_index": ["transform_prefix", "streamlexint", "streamingthread", " stream_base", "stream_ticket", "streamingticket", "transform_index", "stream_thread", "transform_ticket", "streamingprefix", "streamingindex", "stream_base", "streamlexbase", "stream_int", "stream_prefix", "transform_thread", "streamlexindex", " stream_int"], "sample_time": ["sample_host", "sample\u00b7delay", "sample_memory", "samplephost", "ample_year", "sample2times", "samplextimes", "sample\u00b7times", "site_name", "ample_money", "Sample_money", "sampleLdistance", "sample___price", "site_time", "sample\u00b7time", " sample_host", "sample_tz", "samplexlength", "samplealmode", "sampleptime", "service_rate", "server_ime", "ample_time", "ample_cost", "server_time", "sample_money", " sample_volume", "sea_times", "ample_times", " sample_val", "sample_TIME", "sample___time", "sample67rule", "sample_Time", " sample_times", "sample_ime", "sample_value", "samplexTime", "sample_val", "sample_length", "sample_volume", "samplepTime", "sampleacTIME", "servicealtime", "samplealrate", "sample_tim", "sample___times", "site_rate", "sample_rate", " sample_value", "sampleLtime", "samplealtime", "sample_delay", " sample_speed", "sampleLtimes", "sample2ime", "samplexval", "samplextime", "ample_name", "servicealmode", "sample_term", "ample_info", "sample2time", " sample_Time", " sample_ime", "servicealrate", "sample_name", "sampleLtz", "sampleacyear", "server_name", "samplepspeed", "sample_rule", "server_times", "samplexvolume", " sample_timer", "service_tim", "ample_timer", "sample_times", "ample_tim", "sample_info", "sea_tz", " sample_term", "sample_distance", "site_rule", "samplexspeed", "samplexhost", "site_volume", "server_date", "sample_timer", "ample_TIME", "sample67time", "servicealtim", "sampleactime", "samplextimer", "sea_distance", "sample_speed", "Sample_time", "site_times", "sample_mode", " sample_cost", "sample_cost", "server_money", " sample_money", "samplealvalue", "Sample_price", "sample___money", "sample_price", "service_mode", "ample_delay", "sea_time", "sample67volume", "service_time", "sample_date", "sample67times", "samplealtim", "samplealterm", "site_memory", "sample2name", " sample_length", "sampleacinfo", "Sample_times", "sample_year"], "flags": ["mask", "ants", "args", "fo", "features", "flag", "frames", "ips", "items", "Flags", " Flags", "types", "vals", "format", "lf", "stats", "options", "ff", "fps", "fields", "reads", "fts", "faces", "properties", "lag", "utils", "files", "mods", "xml", "ags", "orts", "fun", "fs", "bytes", "bits", "reports", "details", "FLAG", "settings", "ops", "sf", "ints", "windows"], "st": ["rest", "std", "sc", "sk", "w", "ST", "ss", "sn", "p", "pt", "c", "m", "d", "se", "ts", "sw", "data", "en", "ste", "ds", "ct", "inst", "end", "sync", "St", "sth", "db", "e", "step", "sp", "td", "sta", "str", "tmp", "start", "mt", "sts", "set", "tt", "dt", "nt", "stat", "sb", "sa", "stable", "lc", "ost", "stage", "n", "src", "sd", "v", "sl", "r", "sf", "l", "sv", "ut", "stop"], "seconds": ["seq", "times", "sid", "steps", "cuts", "charges", "objects", "frames", " positions", "ips", "months", "sites", "ms", "forms", "outs", "ones", "states", "eps", "second", "codes", "flows", "sets", "fps", "abytes", "hours", "letters", "fee", "strings", "lines", "sections", " second", "sb", "utils", "files", "sec", "resses", "obs", "services", "sleep", "timeout", "elt", "bytes", "years", " bytes", "sent", "values", "settings", "sf", "scripts", "ops"], "mxf": ["pmxf", "Mxf", "mfe", "tmxf", "pmcf", " mcf", "tmcf", "mxd", "Mxc", "nxc", " mfc", "mcf", "pmfc", "mmcf", "mmxc", "mxc", "pxf", "mxb", "pmxb", "tmfe", "Mxb", "Mxd", "pxd", " mxd", "Mfc", " mxe", "ncf", "gxc", "nxf", " mfx", "tmxd", "pxe", "pfc", "gcf", "mmxd", "nfx", " mxb", "mmxf", "mfc", "Mxe", "Mcf", "mxe", "Mfx", " mfe", "gxd", " mxc", "pcf", "gxf", "mfx", "pfe"], "seekpos": ["boardPos", "feedpre", "ekpos", "ekpo", "boardPOS", "boardlen", "ekPOS", "seekposition", "givepos", "givepo", "offsetlen", "feedPos", "offsetposition", " seekPos", "givepre", "seekpre", "ekposition", "seeklen", "ekPos", "feedpo", " seeklen", "seekpo", "offsetpos", "seekPos", " seekposition", "ekpre", "feedpos", "offsetPos", "seekPOS", "givePos", "boardpos", "eklen", " seekPOS"], "ret": ["ref", "code", "obj", "fe", "af", "res", "info", "flag", "red", "back", "base", "en", "success", "bf", "fail", "att", "opt", "error", "def", "pass", "it", "rep", "id", "url", "db", "rets", "al", "mem", "arr", "runs", "err", "det", "lit", "rev", "RET", "fit", "re", "run", "art", "nt", "sec", "reply", "let", "rc", "bad", "pet", "arg", "Ret", "reset", " result", "f", "rt", "value", "alt", "reg", "resp", "replace", "match", "out", "result", "len", "val", "ut", "fun"], "t": ["tree", "z", "i", "p", "m", "b", "c", "unt", "pt", "ta", "d", "template", "ts", "x", "tm", "qt", "ant", "tz", "T", "te", "att", "type", "ct", "it", "port", "the", "e", "o", "at", "mt", "tt", "dt", "nt", "tool", "tw", "ot", "h", "tn", "f", "rt", "wt", "tc", "tf", "tp", "n", "y", "j", "v", "r", "bt", "l", "et", "table", "ut", "g"]}}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587, "substitutes": {"ifm": ["ifmt", "IFp", " ifmc", "tifp", "afp", "actcm", "Ifcm", "ilm", "fnm", "itmc", "iffrm", "fm", "ifbm", " ifr", "actmt", "confm", "fcm", " iffm", "ifdm", "formc", "ilrm", "evmn", "incm", "afmt", "ifw", "actw", "iffnm", "tifmt", "iffd", "iffc", "ofy", "ifh", "notp", "elp", "evm", "actmm", "fp", "IfM", "itercm", "ittm", "notm", "ifmc", "iffcm", "itmi", "ifmn", "evp", "itn", " ifmt", "elrm", "confym", "itfm", "iterw", "itgm", " ifbm", "endifmt", "form", "ifM", "itrm", "incmt", "eldm", "endifn", " iftm", "ff", "IFm", "Ifmt", "afd", "iffn", "ifgm", "incmm", "tifm", "idc", "opmt", "evM", "ily", "itm", "Ifm", "ofcm", "iffm", "itp", " ifM", "ifym", "notmt", "oftm", "ifn", "elm", "iffmi", "afcm", "iftm", "Ifp", "itw", "iffbm", "incr", "iffdm", "iffp", "itcm", "frm", " ifcm", "ify", " ifmn", "iterl", "Ifmn", "ifc", "ifd", "fc", "itf", "actl", "fh", "ifrm", "afdm", "actm", "ifr", "eld", "defmn", "idf", "elcm", "tifcm", "forn", "fortm", "fgm", "defcm", "afm", "defym", "ifmi", "ifmm", "opcm", "ild", "Ifbm", "iterm", "iff", "ifcm", "ifnm", "confcm", "ilcm", "itc", "ifl", "idm", " ifp", "confmn", "fdm", " ifdm", "opp", " ifmm", "idgm", "actr", "iffh", " ifd", "IFmt", "ity", "endifcm", " ifnm", "ifp", "ifffm", " ifl", "endifm", " ifym", " ifh", "opm", "itl", "notcm", " ifmi", "Ifn", "iltm", "ofm", "IFl", " ifn", "defm", " ifrm", "IFcm", "iffl"], "ifqt": ["fqt", " iftk", "fikt", "afiq", "tifwx", "afiqq", "tifkt", "inkt", "fqq", "inq", "lifwx", " ifqq", " ifq", "afiqt", "aficit", "inqt", "lifkt", "fitk", "ifvt", " ifvt", "incqt", "inctk", "ifcit", "tifvt", "lifqt", "fivt", " ifcit", "Ifq", "ifwx", "Ifkt", "fq", "fcit", "lifvt", "fiwx", "ifqq", "incqq", "incvt", "fkt", "ifq", "fiqq", "fiqt", "Ifqq", "ifkt", "Ifqt", "iftk", "tifqt", "inqq"], "slirp": ["slripc", "slirl", "sloircp", "slirtpc", "slireP", "slyrpa", "slirtr", "slierl", "slwerp", "sliroP", "blirpc", "collirop", "spliropad", "slpirv", "quairr", "slirpad", "slirb", "spliarl", "slirep", "sliripc", "blirr", "slurpre", "sliarpe", "slrispi", "slirg", "skirpatch", "slirepa", "ellirtpc", " sliror", "elirp", "selirpc", "Sloirpe", "slripa", "sliarp", "skirib", "sliropad", "slirper", "Slirpe", "sliperp", "sladrp", " slirop", "lairlp", "slairr", "slrisp", "slirr", "collirp", "spliarpc", "slirP", "slirepc", "splirpe", "slyrpc", "blirpre", "slierping", "splirpc", "splirl", "selyrpc", "slirepe", "shierp", "spliarpa", "shierg", "slwerl", "slairp", "sliroper", "ellirtcp", "collirb", "slirv", "blierr", "slricp", "collirope", "shirr", "elierp", "sliarpc", "selyrpa", "slirib", "slaripi", "sliverpc", "ellircp", "slirlpatch", "slierpi", "skirp", "slirer", "sliripad", "slrispo", "selirpa", "quirpa", "blirp", "slirip", "colliroper", "slpirpc", "sliverpa", "spliarp", "slirop", "slrip", "slirtf", "splirp", "sladrcp", "sliropa", "sladrr", "sloirpe", "slirel", "slirlb", "selirpi", "slirpc", "slarig", "slierpc", "slrisr", "slirpi", "lairf", "elirping", "ellirp", "elierr", "slyrpe", "slierg", "ellirpc", "Slirr", "slierp", "slirpo", "shirpi", "sliarl", "lairp", "selirp", "elirpc", "slirlf", "slirecp", "slirope", " sliroP", "slirtl", "slircp", "slirpa", "lairlpc", "quairpc", "slpirp", "slurpc", "sliperpc", "slirf", " slircp", "slirocp", "slurr", "sloirr", "sliropi", "slriscp", "skirb", "slwerpc", "quirr", "elirr", "slrispad", "slyrper", "shierr", "splirpad", "ellirpa", "slurp", "Sloirr", "slyrb", "slyrp", "elierpc", "slyrpi", "skiripc", "selyrp", "slirtcp", "shierpc", "slirob", "collirob", "shirl", "slairpa", "Slircp", "spliarpad", "slirtpa", "slirpre", "slpirf", "sliperpad", "lairpc", "shierpi", "collirpe", "ellirtp", "quairpa", "slierb", "slirlpi", "slirpe", "sliropc", "Sloircp", "slrispc", "slyrpad", "slwerpa", "sloirp", "spliarpe", "slrispa", " slirr", "slirtP", "slirlg", "sliarpa", "slirtv", "slierr", "Slirp", "quirp", "spliropc", "slirpatch", "blierpre", "slierpatch", "slirlpc", "splirop", "slireg", "sliripatch", "slairpc", "quirpc", "slierpre", "lairlf", "Sloirp", "shirp", "slirtp", "skirpc", "elierping", "slirtg", "sliperpe", "sladrpe", "splirpa", "slirping", "sliarpad", "sliverr", "blierp", "sliripe", "shirpc", "slirepre", "quairp", "collirper", "slyrpo", " slirocp", "shierl", "sliropo", "splirpo", "slirlp", "slrisping", "ellirtpa", "skirip", "sliror", "skiripatch", "lairlv", "sloirper", " slirP", "shirg", "slarip", "lairv", "selyrpi", "slirlv", "slireping", "slaripc", "sloirb", "blierpc", "sliverp", "spliropo"], "if_queued": ["if_quesumed", "if_cluing", "ifallquemented", "if_continued", "if_queues", "if_queuing", "if_queue", "if_qauing", "if_Queuing", "if_continue", "if_quesuing", "if_queueless", "if_qaue", "ifallqueue", "if_quesue", "if_ques", "if_qued", "if_clueless", "if_queueueless", "ifallcontinued", "if_QueUE", "if_quemented", "if_quesued", "ifallqueued", "ifallcontinmented", "if_queumed", "if_queueued", "if_queueumed", "if_clued", "if_qaued", "if_queueues", "if_Queued", "ifallcontinue", "ifallqueUE", "if_continUE", "if_queUE", "if_continmented", "if_que", "if_Quemented", "ifallcontinUE", "if_qaueless", "if_Queue", "if_Queumed", "if_queueue", "if_clue", "if_queueUE", "if_queueuing", "if_queuemented", "if_quing"], "ifq_so": ["ifq_since", "ifp_while", "ifq_gone", "ifp_since", "ifp_next", "ifc_since", "ifq_while", "ifc_co", "ifq_lo", "ifp_gone", "ifq_next", "ifq__since", "ifp_so", "ifq_co", "ifp_lo", "ifp_co", "ifq__co", "ifq__so", "ifc_so"], "so_queued": ["so_queurized", "so_queueued", "so_quued", "so_queueues", "so_scheue", "so_queueue", "so_queues", "so_scheued", "so_scheues", "so_quue", "so_quurized", "so_scheurized", "so_queue", "so_quues", "so_queueurized"], "requeued": ["refqueumed", "refpeumed", "reequeused", "repeuated", "requeuing", "requured", "reQueuing", "requeumed", "reQueued", "repeured", "requeuated", "repemented", "reequeued", "repeused", "remqueuer", "reequed", "refpeued", "reequeuing", "repluated", "refquemented", "requeused", "requuing", "refqueuated", "requer", "reQueused", "reQueues", "reeqused", "requred", "replmented", "refpemented", "repeued", "remquured", "remqueued", "repeumed", "requated", "remquuer", "requeues", "refpeuated", "refqueued", "requed", "remqueured", "requuer", "requeuer", "replued", "remquuing", "reequing", "repeues", "reqused", "remquued", "replumed", "requemented", "requmed", "requing", "requeured", "reeques", "repeuing", "reques", "requued", "remqueuing", "repeuer", "reequeues", "reqmented"]}}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595, "substitutes": {"check": ["exec", "build", "call", "name", "flight", "add", "cross", "sync", "num", "project", "valid", "set", "start", "http", "lib", "cal", "match", "query", "Check", "draw", "pack", "walk", "wait", "complete", "code", "checked", "test", "key", "feed", "work", "process", "cache", "com", "task", "update", "comp", "rule", "checks", "report", "block", "file", "load", "parse", "fix", "send", "fail", "error", "get", "search", "view", "scan", "ack", "pull", "ck", "full", "post", "control", "lock", "ok", "info", "read", "config", "type", "pass", "end", "flow", "id", "create", "clean", "worker", "clear", "off", "checking", "comment", "y", "index"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n", "idx": 26599, "substitutes": {"STATUS_PARAM": ["STATUS_VAME", "STATUS_PAM", "STATUS_VAR", "STATUS_KB", "STATUS_PAR", "STATUS_VB", "STATUS_VAM", "STATUS_PARAR", "STATUS_PARAME", "STATUS_PB", "STATUS_KAME", "STATUS_KAM", "STATUS_PARB", "STATUS_KAR", "STATUS_PAME"], "zSign": ["yMod", "tRound", " zStep", "yRound", "zMod", "ZValue", "zsign", " zRound", "gzValue", "tsign", "ziStep", "ySign", " zExp", "tSign", " zSize", "ZSign", "zRound", "ZMod", "tSize", " zMod", "zExp", "zisign", "gzsign", "Zsign", "ZRound", "ZSize", "ZStep", "zValue", "gzExp", " zValue", "zStep", "zSize", " zsign", "ZExp", "ziSign", "gzSign"]}}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620, "substitutes": {"intp": ["inccp", "bitpa", "intcp", "indp", "irp", "intP", "indpi", "ircp", "incpo", "intc", "intpi", "bitpi", "indcp", "indpo", "bitp", "ippi", "indP", "bitc", "indpa", "intpa", "intpo", "ipc", "indc", "irP", "ipp", "incP", "ippa", "irpo", "incp"], "ret": ["ref", "std", "fin", "obj", "ft", "res", "cat", "flag", "red", "data", "back", "base", "bf", "py", "db", "line", "str", "valid", "mt", "det", "lit", "RET", "last", "re", "fit", "art", "nt", "fire", "reply", "rc", "pat", "pet", "arg", "active", "Ret", "rt", "part", "ext", "j", "alt", "reg", "match", "result", "et", "len", "val", "gt", "ut", "fun"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642, "substitutes": {"s": ["S", "comments", "rs", "ses", "sys", "args", "w", "ss", "m", "b", "c", "ns", "i", "d", "se", "ts", "data", "sq", "ds", "ps", "sg", "ins", "ks", "sync", "bs", "is", "e", "cs", "gs", "es", "o", "sets", "ions", "l", "si", "sym", "gets", "aws", "os", "new", "uns", "services", "as", "h", "ls", "f", "service", "js", "qs", "fs", "tests", "t", "a", "n", "v", "r", "sf", "ops", "in", "ssl", "sv", "g"], "p": ["temp", "pp", "pa", "k", "np", "i", "b", "m", "c", "d", "data", "P", "pointer", "jp", "pe", "ps", "bp", "op", "u", "e", "point", "sp", "o", "pb", "at", "cp", "part", "lp", "f", "po", "pr", "n", "tp", "j", "t", "fp", "ip", "a", "v", "pi", "vp", "l", "post", "pc", "ap", "g"]}}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n", "idx": 26653, "substitutes": {"errp": ["Erp", "erP", "Erpre", "errorproc", " errps", " errproc", "errpre", "ErP", " errP", "erps", "errproc", "errps", "errorps", "Erc", "errorP", "errorc", "erp", "errP", "erproc", " errc", "errorpre", "errc", " errpre", "errorp"], "cs": ["sc", "sk", "rs", "c", "Cs", "ns", "cks", "CS", "vs", "ec", "ds", "cus", "ps", "bc", "cons", "ks", "sync", "css", "gs", "codes", "cms", "ac", "ics", "spec", "cc", "ctx", "cn", "ci", "cf", "mc", "rc", "cache", "os", "cas", "lc", "cells", "ls", "ca", "fs", "qs", "tc", "core", "ck", "acs", "nc", "ce", "pc"], "cpu": ["CPU", "processor", "cm", "np", "console", "auc", "c", "uno", "px", "clock", "uca", "cus", "bc", "sync", "proc", "css", "gpu", "boot", "fc", "coe", "hw", "phy", "GPU", "fps", "nic", "bench", "cli", "cow", "cp", "ci", "ctx", "cn", "gp", "cache", "roc", "vm", "lc", "proxy", " CPU", "ca", "gc", "cu", "conn", "computer", "core", "pu", "uci", "colo", "nc", "pc"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n", "idx": 26663, "substitutes": {"l2hdr": ["l3hst", "l2hstr", "l1phdr", "l2phst", "l2hhstr", "l2fdr", "l2hdgt", "l2frc", "l3hrc", "l1hst", "l1hstr", "l2fst", "l1hrc", "l3frc", "l2phrc", "l1phst", "l2fstr", "l2hhst", "l1phrc", "l3hgt", "l1phstr", "l2phdr", "l2hdrc", "l2hdst", "l2hst", "l2phstr", "l3hdr", "l2hddr", "l2hhdr", "l3fdr", "l2phgt", "l3fgt", "l2hrc", "l2hgt", "l3fst", "l1hdr", "l2hhrc", "l2fgt"], "orig_flags": [" orig_planes", "orig_bits", "orig_offs", "orig___offs", "orig_ops", "orig___flags", "orig___bits", "orig_planes", " orig_ops", " orig_bits", "orig___planes", " orig_offs"], "iphdr": ["hiprr", "ipdi", "ophdr", "iphrid", "lipdr", "efdi", "liphr", "iphdc", "iphrt", "liprh", "elfhr", "iprid", "elfrh", "ephhr", "iphder", "elfrr", "apterdr", "aphdc", "iprt", "elfdr", "efrid", "ophrt", "apterrr", "lipder", "ephder", "apterder", "ephrr", "ipdr", "efrt", "iphhr", "aphrr", "elfder", "ophdi", "ephdr", "iphrh", "hipdc", "efdr", "ophrid", "ephrh", "hipdr", "iphrr", "iphdi", "aphdr", "ephdc", "apterhr"], "new_ip_off": ["new_ipacoff", "new_ip__on", "new_ip_low", "new_ipacoffs", "new_ip_offset", "new_address_on", "new_address_off", "new_address_offs", "new_ipaclow", "new_ipfon", "new_ipfoff", "new_ip__offs", "new_ip_on", "new_ipacon", "new_ip67offs", "new_ipfoffset", "new_ip_no", "new_ip67off", "new_address_low", "new_ip67low", "new_ipflen", "new_ip_len", "new_ip_offs", "new_ip__off", "new_ip__no", "new_ip67on"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 26671, "substitutes": {"a": ["pa", "i", "p", "app", "c", "va", "aa", "ama", "d", "ae", "x", "data", "api", "ab", "ad", "ia", "A", "aux", "ba", "la", "s", "aaa", "ga", "sa", "mA", "as", "ata", "active", "window", "ca", "f", "n", "da", "an", "alpha", "ac", "area"], "b": ["i", "p", "bis", "c", "wb", "aa", "lb", "d", "bb", "x", "base", "ab", "rb", "bf", "gb", "bd", "beta", "bp", "bs", "db", "e", "ba", "pb", "nb", "eb", "bi", "mb", "fb", "sb", "B", "emb", "bar", "f", "y", "be", "v", "r"], "env": ["exec", "txt", "ep", "args", "console", "np", "scope", "exc", "p", "c", "context", "enc", "eval", "data", "ec", "en", "style", "config", "conf", "chal", "state", "dict", "ev", "loader", "ea", "environment", "db", "e", "ee", "el", "err", "ef", "energy", "eu", "erv", "iv", "conn", "v", "eng"]}}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n", "idx": 26673, "substitutes": {"bsum": ["dsums", "besam", "bsul", "bscan", "basumm", "besum", "lssum", "bsam", "psumm", "BSum", "astsumm", "BSums", "besumm", "issumm", "alsuc", "astsum", "pssum", "issum", "astsub", "dsum", "issuc", "dssum", "issul", "bascan", "bassum", "ssums", "BSuc", "bsumm", "bssum", "BSsum", "pscan", "bsuc", "astsam", "lsum", "lsub", "sssum", "lsam", "alsul", "besub", "dsuc", "lscan", "basum", "lsumm", "ssuc", "besuc", "ssum", "besul", "alsumm", "bsums", "alsum", "bsub", "psum"], "i": ["k", "p", "b", "m", "c", "d", "ix", "x", "ti", "mi", "diff", "phi", "qi", "id", "u", "e", "li", "zi", "start", "xi", "ii", "ini", "si", "ai", "bi", "ni", "di", "ci", "eni", "h", "I", "f", "y", "n", "j", "index", "ip", "t", "iu", "ind", "mu", "pi", "v", "l", "ami", "g"], "sum": ["gram", "summary", "mask", "hash", "bin", "b", "ss", "cost", "name", "sh", "aa", "Sum", "se", "ass", "weight", "cur", "ad", "am", "gam", "add", "sha", "pass", "ame", "num", "su", "u", "all", "cmp", "sp", "mean", "mem", "miss", "max", "min", "fee", "average", "si", "sign", "parse", "size", "scale", "cache", "fat", "sa", "length", "um", "not", "info", "count", "comment", "total", "value", "n", "dot", "h", "a", "index", "out", "na", "match", "cash", "alpha", "result", "ash", "ac", "vol", "g"]}}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n", "idx": 26680, "substitutes": {"dev": ["md", "dc", "der", "d", "data", "test", "var", "ad", "conf", "ds", "diff", "pub", "debug", "def", "priv", "dd", "ev", "id", "dom", "tr", "serial", "adv", "raw", "private", "dem", "grad", " device", "err", "gd", "di", "req", "stable", "device", "dist", "mod", "development", "pro", "sim", " devs", "conn", "de", "devices", "rad", "Dev", "init", "ver", "od", "dm", "reg"], "errp": ["errpc", "erP", "ryps", " errps", "ryr", "nerP", "rypc", "rrp", "erpc", "rrr", " errP", "err", "rrpc", "errr", "rrps", "erps", "nerc", "nerps", "errps", "erp", "errP", " errc", "errc", "ryp", "erc", "nerp"], "ics": ["comm", "ices", "args", "sys", "events", "cycles", "dc", "ns", "ats", "ix", "ips", "icks", "px", "items", "ICS", "ec", "ms", "ds", "igs", "cus", "ars", "ins", "icons", "states", "ks", "plugins", "cons", "bs", "css", "self", "uses", "rys", "is", "cs", "stats", "codes", "cfg", "ic", "ims", "nic", "inf", "icc", "IC", "rics", "ik", "ci", "xs", "cells", "its", "ents", "ls", "fs", "qs", "js", "bits", "irc", "cases", "devices", "init", "acs", "ex", "ops", "ico", "pic", "g"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n", "idx": 26701, "substitutes": {"vs": ["rs", "ss", "ns", "va", "cv", "flags", "icks", "ds", "forces", "vt", "ps", "vas", "state", "ks", "sync", "bs", "eps", "vals", "cs", "gs", "es", "stats", "otes", "vc", "sts", "hs", "os", "obs", "services", "asts", "xs", "ums", "ls", "fs", "qs", "ves", "alls", "v", "vp", "ops", "VS", "sv", "env"]}}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n", "idx": 26711, "substitutes": {"sch": ["her", "sc", "sk", "sem", "cht", "sr", "ss", "sn", "chid", "c", "kh", "se", "sky", "soc", "conf", "gb", "cr", "cy", "chn", "ch", "ocr", "sche", "css", "sp", "inch", "spec", "icc", "si", "cer", "shop", "cp", "sb", "ctr", "kr", "ich", "osc", "Sch", "gh", "sm", "usc", "service", "conn", "chy", "zh", "sd", "osh", "sl", "psych", "sf", "ssl", "cs", "sh"], "orb": ["oret", "umb", "ogg", "urb", "ob", "xb", "or", "usb", "rb", "om", "ab", "gb", "arb", "ocr", "orbit", "gob", "rob", "zb", "obb", "atom", "http", "eb", "rub", "abb", "obs", "ub", "ur", "erb", "ore", "orc", "osc", "amber", "obo", "iol", "ori", "orn", "org", "orf", "ib"], "s": ["S", "space", "sc", "rs", "ses", "sys", "w", "i", "p", "b", "c", "sh", "ns", "se", "sq", "ds", "conf", "sg", "state", "sync", "self", "sis", "is", "su", "u", "gs", "sp", "south", "o", "sie", "session", "spec", "l", "si", "sym", "sb", "services", "sa", "sup", "ls", "f", "service", "t", "sl", "sf", "ssl", "sv", "g"]}}
{"project": "qemu", "commit_id": "e25cad6921ef78c8e2b7a4f59b03545bd675a9ad", "target": 1, "func": "static int sd_snapshot_delete(BlockDriverState *bs,\n\n                              const char *snapshot_id,\n\n                              const char *name,\n\n                              Error **errp)\n\n{\n\n    unsigned long snap_id = 0;\n\n    char snap_tag[SD_MAX_VDI_TAG_LEN];\n\n    Error *local_err = NULL;\n\n    int fd, ret;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;\n\n    uint32_t vid;\n\n    SheepdogVdiReq hdr = {\n\n        .opcode = SD_OP_DEL_VDI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26725, "substitutes": {"bs": ["rs", "ses", "iss", "b", "ss", "bis", "ns", "lb", "bb", "ts", "vs", "las", "base", "rb", "ds", "ms", "gb", "bh", "bos", "bc", "BS", "bl", "ins", "ps", "pb", "Bs", "bi", "os", "sb", "obs", "ls", "fs", "bm", "bps", "ops", "bt", "cs"], "snapshot_id": ["snapshot_type", "snapshot_tag", "snapshotPlength", "snapshot_name", "snapshot_length", "snapshotPname", "snapshotPID", "snapshot_ad", "snapshotPid", "snapshot_ids", "snapshot_Id", "snapshot_ID"], "name": ["space", "secret", "package", "info", "image", "time", "data", "base", "text", "label", "filename", "config", "type", "prefix", "version", "ame", "domain", "id", "alias", "url", "Name", "key", "home", "resource", "path", "search", "object", "group", "parent", "client", "size", "comment", "NAME", "names", "host", "nam", "memory", "meta", "description", "block", "connection", "table", "file", "tag", "desc"], "errp": ["rarp", "erP", "erpat", "erfp", "errorjp", " errr", " errjp", " errpat", "rarpat", "erjp", "err", " errP", "rarr", "errjp", "errr", " errfp", "errpat", "errorP", "erp", "errP", "errfp", "rarfp", "errorr", "errorp"], "snap_tag": ["snap2id", "snapnlog", "snap_at", "snapJfield", "Snap_desc", "capt_doc", "snaplogid", "block_id", "snap64field", "block_field", "snap_name", "Snap_at", "snap67product", "capt_name", "jump_product", "jump67id", "snaplogsum", "jump_id", "capt64id", "snap_Tag", "snaplextag", "block_length", "Snap_length", "jump67product", "Snap_Tag", "snaplexdesc", "snap_sum", "snap_field", "snapntag", "snap_desc", "capt64tag", "snap2Tag", "Snap_id", "snap64doc", "snaplexid", "snapJid", "Snap_sum", "snap_date", "snap___name", "snapJlength", "snap64tag", "capt64doc", "snapnid", "snap67bug", "snap64name", "capt_id", "jump67tag", "snap64length", "snap_id", "snap_length", "Snap_date", "snap2tag", "snap_doc", "jump67bug", "snap64id", "capt_tag", "snap___tag", "snap67tag", "block_tag", "snap___doc", "capt64name", "snaploglog", "Snap_log", "snap_bug", "snapJtag", "Snap_tag", "snapnsum", "snaplexat", "jump_tag", "snap_product", "snaplogtag", "snap67id", "snap___id", "snap_log", "jump_bug"], "local_err": ["local_er", "local_iter", "localifcode", "localamerr", "local_errors", "local_ver", "localxerrors", "localamerror", "localiferrors", "locxcode", "localingstatus", "localingerr", "remote_er", "local2ver", "local2errors", "remote_status", "local_status", "foreignamerr", "local_cb", "foreign_err", "foreign_cb", "foreignamer", "local2code", "foreign_error", "locxerr", "foreignamerror", "localamcb", "foreignamcb", "loc_errors", "localxcode", "localxver", "local_error", "localamer", "localiferr", "remote_err", "local_code", "localxerr", "localingiter", "locxver", "local2err", "locxerrors", "remote_iter", "loc_ver", "loc_code", "loc_err", "localinger", "localifver", "foreign_er"], "fd": ["md", "ref", "fin", " fid", "fe", "dc", "d", "fn", "ds", "bf", "bd", "cb", "def", "dd", "db", "fc", " resp", "ff", "wat", " ff", "nd", "dir", "dl", "fl", "dt", "FD", "fi", "fb", "rc", "fat", "len", "req", "f", "fs", "fa", "da", "conn", "fp", "resp", "vd", "df", "result", "vir", "val"], "ret": ["ref", "fin", "ft", "res", "cat", "flag", "back", "en", "success", "bf", "no", "vt", "att", "pub", "def", "pass", "id", "num", "db", "rets", "mem", "ben", "err", "bit", "mt", "det", "rev", "lit", "RET", "re", "nt", "rc", "let", "feat", "reply", "ur", "pat", "pet", "fat", "arg", "Ret", "rt", "count", "part", "ext", "sil", "f", "alt", "reg", "resp", "conn", "match", "out", "result", "et", "len", "val", "fun"], "buf": ["seq", "uf", "bag", "uc", "nat", "b", "batch", "wb", "pkg", "cv", "grab", "data", "buffer", "queue", "vec", "img", "rb", "config", "br", "cur", "bd", "prop", "cb", "ab", "bc", "port", "proc", "pad", "bed", "begin", "ff", "ba", "BU", "tmp", "pb", "cap", "loc", "fl", "box", "pool", "ctx", "fi", "fb", "rc", "Buffer", "alloc", "ptr", "feat", "cas", "conv", "buff", "array", "window", "src", "fp", "bm", "desc", "null", "dest", "map", "block", "fun"], "s": ["S", "ses", "sys", "ss", "b", "p", "server", "c", "bis", "ns", "sn", "d", "ts", "vs", "storage", "sq", "ds", "us", "ps", "sg", "state", "ks", "states", "sync", "sis", "is", "su", "self", "spot", "e", "stats", "gs", "site", "sets", "sie", "session", "spec", "sv", "si", "os", "sb", "services", "sa", "ls", "f", "service", "qs", "fs", "js", "n", "src", "t", "sl", "settings", "ssl", "cs", "g"], "vid": ["ref", "seq", "sid", "uid", "virt", "dc", "cat", "dr", "vec", "var", "vr", "vis", "vt", "mid", "version", "id", "live", "db", "nd", "vc", "tmp", "lit", "rev", "gd", "dev", "nt", "vert", "rc", "virtual", "vd", "aud", "ip", "host", "v", "ver", "nc", "len", "val", "format", "pid"], "rsp": ["irtr", "Rsc", "grsp", "grpar", "rpar", "rtr", "Rpar", "irpar", "grsc", "Rtr", "rsc", "irsp", "grtr", "irsc", "Rsp"]}}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726, "substitutes": {"f": ["ref", "fen", "uf", "fe", "k", "xf", "fo", "af", "info", "p", "m", "b", "c", "elf", "this", "fac", "d", "i", "rf", "x", "fn", "bf", "fm", "form", "fr", "e", "lf", "fc", "o", "ff", "fw", "inf", "fi", "fb", "fx", "cf", "fore", "fs", "tf", "fa", "t", "fp", "v", "g", "sf", "df", "l", "fd", "file", "F"], "opaque": ["opcodes", " opalloc", "opacity", "OPalloc", "opalloc", "operacity", "OPcodes", "operaque", " opcodes", "operalloc", "OPacity", " opacity", "OPaque", "opercodes"], "ret": ["ref", "fin", "sr", "ft", "cat", "att", "num", "url", "mem", "valid", "mt", "det", "lit", "rot", "nt", "status", "match", "val", "gt", "complete", "code", "obj", "flag", "red", "hard", "debug", "def", "rep", "bit", "RET", "result", "let", "feat", "bad", "pat", "Ret", "len", "fun", "rest", "done", "res", "usr", "data", "back", "rb", "success", "fail", "pub", "bl", "error", "db", "fab", "str", "err", "re", "reply", "req", "arg", "alt", "reg", "resp", "info", "hash", "job", "bf", "rets", "rev", "fit", "art", "run", "rc", "html", "active", "rt", "ext", "out", "reset"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)\n\n{\n\n    int i, n, n2;\n\n    float alpha;\n\n\n\n    n  = 1 << ln;\n\n    n2 = n >> 1;\n\n\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);\n\n\n\n    for (i = 0; i < n2; i++) {\n\n        alpha     = 2.0 * M_PI * i / n;\n\n        mdct->costab[i] = FIX15(cos(alpha));\n\n        mdct->sintab[i] = FIX15(sin(alpha));\n\n    }\n\n\n\n    return 0;\n\nfft_alloc_fail:\n\n    mdct_end(mdct);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 26730, "substitutes": {"avctx": ["avcu", "ovctx", "AVcmp", "AVcontext", "AVconfig", "AVconn", "avcmp", "AVcu", "avcontext", "afcontext", "afctx", "devcontext", "avconfig", "ovcontext", "devctx", "afcu", "devcu", "ovconfig", "AVctx", "avconn", "akcmp", "akctx", "afconn", "devcmp", "akcontext", "afcmp", "ovcmp", "afconfig", "akconn"], "mdct": ["cmdpt", "MDft", "mdft", "cmdCT", "mandect", "mandcat", "amdcf", "cmdnt", "mdxc", "mandct", "hdlc", " mdc", "mandxc", "mandpt", "cmdcf", "cmdlc", "hdct", "hdpt", " mdcat", "mdant", "hdCT", "mdcat", " mdxc", "MDc", " mdft", "MDpt", " mdlc", "mdect", " mdcc", " mdpt", " mdect", "mdpt", "mdcc", "cmdcat", "cmdant", "cmdct", "cmdect", "mdrt", "mdnt", "MDnt", "mandc", "mdcf", "cmdrt", "mandcf", " mdCT", " mdant", "gradant", "hdxc", "mdlc", "mdCT", "MDcc", "amdcat", "amdc", "MDrt", "cmdcc", "amdct", " mdrt", "MDCT", "gradc", "gradect", " mdnt", "MDct", "gradct", "cmdft", "hdect", " mdcf", "cmdc", "mdc"], "ln": ["L", "kn", "lvl", "oln", "sn", "ll", "pn", "rn", "fn", "lan", "en", "nn", "NL", "ern", "lon", "wn", "line", "Len", "nb", "lines", "loc", "dl", "lin", " fn", "ii", "ni", "mn", "cn", "inn", "lc", "N", "hn", "nl", " l", " len", "in", "l", "len", "dn"], "i": ["abi", "k", "slice", "z", "ie", "p", "m", "b", "c", "info", "pixel", "name", "d", "ix", "x", "api", "adi", "ti", "mi", "phi", "qi", "ri", "ani", "io", "id", "u", "e", "key", "li", "gi", "ji", "o", "zi", "multi", "esi", "xi", "start", "uri", "ii", "di", "si", "ai", "bi", "ni", "ini", "ci", "fi", "eni", "isin", "lc", "I", "f", "y", "oi", "j", "ip", "chi", "a", "index", "v", "iu", "ind", "pi", "in", "ui", "l", "init"], "n": ["nan", "k", "np", "w", "z", "p", "m", "b", "c", "ns", "sn", "d", "nat", "name", "norm", "x", "fn", "en", "nn", "pn", "num", "ne", "u", "e", "o", "s", "nb", "ii", "sign", "ni", "cn", "size", "number", "inn", "N", "f", "y", "network", "j", "ny", "t", "a", "net", "nu", "r", "in", "nc", "l", "len", "dn"], "n2": ["N2", "n82", "l2", "lTwo", " nTwo", " n02", "n4", "nTwo", "NTwo", "na82", "i62", "i2", "N32", "i4", "ne02", " n1", "naTwo", "N82", "iTwo", "ne1", " n32", "n02", "na2", " n4", "ne2", "n62", "i1", "i02", "na4", "neTwo", "i32", "N02", "l02", " n82", "n32", "n1", "ne62", "N4", " n62"], "alpha": ["acc", "acl", "k", "lambda", "margin", "af", "p", "ana", "aa", "ta", "qa", "api", "base", "ia", "lla", "beta", "abc", "phi", "ra", "alias", "pha", " Alpha", "aca", "igma", "acid", "ma", "amp", "Alpha", "padding", "audio", "la", "afi", "angle", "average", "si", "asc", "scale", "inc", "rc", "lc", "ca", "na", "da", "a", "alph", " beta", "star", "\u03b1", "ace", "ac", "ph", "xa", "area"]}}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26734, "substitutes": {"env": ["her", "txt", "code", "fen", "obj", "args", "np", "console", "scope", "exc", "engine", "context", "manager", "cv", "inv", "enc", "qa", "ec", "qt", "en", "config", "chal", "jp", "conf", "nv", "bc", "inst", "ev", "kb", "ea", "environment", "proc", "ne", "db", "buf", "gov", "cfg", "esi", "eb", "viron", "dt", "eu", "eni", "emb", "erb", "req", "esp", "fg", "ext", "conn", "bg", "nl", "qv", "net", "v", "event", "keeper", "header", "fp", "org", "que", "eng"], "tb": ["untv", "untbs", "tsbl", " tbs", "ptb", "Tbr", "Tbs", "tbs", "untbr", "Tv", "etrb", "tsbs", " trb", "trb", "ttf", "tsbh", "tv", "ttb", "ptp", " tbl", "stf", "Tbh", "ptv", "Tb", "ttbl", "tbh", " tbh", "etbl", " tv", "tbl", "stp", "stb", "tsb", "tf", "etv", "tp", "stbl", "tbr", "etf", "etb", " tp", "ttp", " tbr", "untb", "Tbl", "ptrb", "etp"], "search_pc": ["searchablefunc", "searchablemc", "search_mc", "findablepc", "search_PC", " search_mc", "find_tc", "find_PC", "find_fc", "search2tc", "searchablepc", "find_pc", " search_PC", "search2func", " searchablefunc", "search_func", "search2PC", " searchablePC", "search_tc", "search2fc", "findablefc", "searchabletc", "search_fc", "searchablefc", "search2mc", "findabletc", "search2pc", " searchablemc", " searchablepc", "searchablePC", " search_func", "findablePC"], "insn_count": ["insn64sum", "insn_sum", "insn64count", "insns_count", "insn_cache", "insns_cache", "insns_length", "insns_sum", "insn_length", "insn64length", "insn64cache"], "ctx": ["exec", "txt", "sc", "kw", "obj", "cm", "np", "acl", "console", "cca", "zx", " context", "c", "pkg", "context", "cv", "qa", "xc", "sq", "config", "gb", "cb", "bc", "kb", "sync", "proc", "cmp", "btn", "wx", "fc", "cfg", "hw", "cmd", "pb", "vc", "loc", "wcs", "fw", "cli", "Context", "cc", "ci", "cn", "cf", "cp", "client", "utils", "rc", "conv", "req", "cas", "git", "lc", "xs", "ctrl", "wp", "sci", "ca", "tc", "na", "cu", "conn", "cpp", "fp", "ck", "nc", "tx", "cs", "pc", " cx"], "ctxp": ["centmb", "cedmb", "centype", "CTxp", "CTmb", "centtxt", "cattxt", "cedxp", "catmb", "centxp", "catype", "CType", "CTtxt", "cedype", "catxp", "cedtxt"], "pc_start": ["pc1end", "dc__min", "dc__stop", "pc1pos", "pc__start", "pc_offset", "PC_offset", "PC_pos", "PC_end", "pc_min", "dc_start", "pc_end", "dc_stop", "dc_min", "pc1start", "PC_start", "PC_id", "dc_end", "pc_pos", "pc__stop", "pc1offset", "dc__end", "pc_stop", "pc__end", "pc_id", "pc__min", "dc__start"], "insn": ["lsk", "lsn", "innr", "insk", "lsnr", "inns", "insnr", "nsnr", "nsn", "nsk", "inn", "insns", "lsns", "ink", "nsns"], "gen_opc_end": ["gen_opc_ad", "gen_opci_start", "gen_opc_ends", "gen_opc_END", "gen_opci_end", "gen_opci_ends", "gen_opc__ends", "gen_opci_id", "gen_opc__end", "gen_opc_start", "gen_opc__id", "gen_opc_pos", "gen_opci_ad", "gen_opc__ad", "gen_opc__END", "gen_opci_END", "gen_opc_id", "gen_opci_pos", "gen_opc__start", "gen_opc__pos"], "bp": ["pp", "np", "p", "pg", "lb", "bb", "px", "qa", "base", "bf", "gb", "jp", "py", "bh", "cb", "bc", "dp", "kb", "proc", "cmp", "BP", "sp", "hp", "pd", "pb", "nb", "eb", "cp", "sb", "gp", "esp", "vm", "wp", "lp", "tp", "arp", "conn", "cpp", "bg", "fp", "bm", "bps", "vp", "bt", "pc", "policy"], "j": ["k", "z", "section", "i", "p", "m", "jump", "b", "uj", "adj", "kj", "job", "br", "next", "jp", " ii", "aj", "jj", "ch", "num", "fr", "key", "ji", "li", "str", "err", " dj", "jc", "offset", "last", "ni", "ij", "jet", " conn", " n", "note", "vol", "f", "jl", "js", "n", "index", "conn", "reg", " job", "v", "J", "r", "pos", " i", "l", "dj", "jen", "ja", "g"], "ret": ["ref", "trial", "ft", "nat", "pt", "cat", "flag", "back", "success", "vt", "att", "pub", "def", "rets", "miss", "rl", "mt", "lit", "rev", "det", "RET", "fit", "re", "nt", "sec", "rc", "let", "feat", "req", "arg", "Ret", "rt", "ext", "alt", "reg", "match", "result", "len", "val", "fun"], "num_insns": ["num_insxs", "num_excs", "num_insts", "num_intss", "num_inns", "num_intsons", "num_invs", "num_opensns", "num_opensn", "num_exns", "num_exxs", "num_inpins", "num_linns", "num_itscs", "num_incns", "num_expires", "num_linvs", "num_exn", "num_incsts", "num_insons", "num_insn", "num_vincs", "num_inssts", "num_itsns", "num_itsvs", "num_insvs", "num_inspires", "num_expins", "num_inn", "num_vinons", "num_incs", "num_vins", "num_vinns", "num_exsts", "num_inscs", "num_intscs", "num_lincs", "num_linn", "num_itsn", "num_openspires", "num_inpires", "num_inccs", "num_inss", "num_inxs", "num_inons", "num_incpins", "num_opensxs", "num_intsns", "num_ins", "num_inspins"], "max_insns": ["max_innes", "max_outsnas", "max_itsns", "max_outsls", "max_insn", "max_incks", "max_outsnes", "max_insnes", "max_insls", "max_incns", "max_itsn", "max_linsls", "max_innas", "max_linn", "max_insks", "max_itscs", "max_insnas", "max_outscs", "max_links", "max_linscs", "max_outsn", "max_inns", "max_incnas", "max_inccs", "max_inls", "max_inks", "max_outsns", "max_linnas", "max_lincs", "max_inscs", "max_linsn", "max_itsnes", "max_inn", "max_incn", "max_linns", "max_linsns", "max_incs"], "lj": ["lljs", "eljs", "rjp", "Laj", "linbj", "Ljc", "ilji", "ld", "lnj", "ilv", "elfr", "lg", "lbr", "elbr", "lljp", "lx", " lji", "lja", "ulv", "eljo", "rj", "llz", "ulg", "Lk", "link", "iljc", " lk", "lz", "lnjo", "lbj", "uljc", "linj", "ulx", "ulj", "lnz", "lv", "ilz", "llj", "ilj", "plv", "elja", "Lz", "ulz", "elji", "ilja", "lnja", " lz", "laj", "lji", "liz", "lifr", "ljs", "ljo", " lx", "linaj", "rz", "elz", "Lbj", "plji", "eljp", "eld", "ild", "elv", "Lj", "lk", "ilbr", " lg", " lbj", "plbr", "plz", "rjs", "iljo", "Lx", "ljc", "ljp", "lfr", " laj", " lv", "plj", "ilfr", "Lv", "lij", "elj", "lid", "Lg"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738, "substitutes": {"vs": ["rs", "ses", "iss", "ss", "va", "ns", "cv", "Vs", "flags", "ils", "guards", "court", "forces", "ds", "vr", "ports", "verts", "vt", "ps", "state", "bs", "eps", "vals", "cover", "cs", "stats", "es", "fps", "obs", "services", "xs", "ls", "fg", "fs", "qs", "v", "values", "vp", "ops", "VS", "vir", "sv", "env", "params"], "job": ["build", "OB", "node", "page", "b", "server", "name", "function", "manager", "image", "ob", "connection", "queue", "base", "ab", "config", "py", "jp", "next", "cb", "bc", "bug", "sync", "live", "plugin", "db", "feed", "work", "jobs", "object", "worker", "output", "pool", "result", "order", "obs", "item", "bar", "fun", "child", "value", "j", "row", "runner", "route", "event", "baby", "org", "block", "Job", "layer"]}}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745, "substitutes": {"client": ["head", "remote", "call", "cod", "Client", "public", "close", "server", "c", "name", "manager", "api", "config", "request", "address", "prefix", "port", "id", "self", "plugin", "cell", "con", "cmd", "resource", "command", "session", "cli", "worker", "handler", "parent", "agent", "cache", "proxy", "service", "child", "conn", "host", "core", "container", "connection", "pc"], "nb_fds": ["nb_fdcs", "nb_Fns", "nb_fDS", "nb_Fds", "nb2Fdds", "nb_fks", "nb_cdds", "nb_fdds", "nb_rfDS", "nb_cDS", "nb_fdns", "nb_cns", "nb_Fcs", "nb2Fns", "nb_fcs", "nb_rfcs", "nb_fddds", "nb_ccs", "nb_cks", "nb_rfks", "nb2fds", "nb2fcs", "nb2fdds", "nb_cds", "nb2fns", "nb2Fcs", "nb_Fdds", "nb_fns", "nb2Fds", "nb_rfds"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749, "substitutes": {"n": ["node", "np", "k", "w", "nm", "none", "p", "m", "b", "sn", "ns", "i", "d", "or", "fn", "en", "config", "on", "num", "self", "ne", "u", "e", "con", "o", "ic", "s", "nb", "mn", "nt", "cn", "not", "N", "f", "y", "nw", "network", "j", "conn", "t", "un", "q", "an", "net", "v", "r", "nu", "nl", "nc", "l", "dn", "g"], "cmd": ["md", "node", "comm", "call", "ctl", "cm", "dc", "uc", "cd", "b", "m", "d", "config", "cb", "cmp", "cfg", "command", "Cmd", "cc", "ctx", "cp", "new", "cf", "mc", "rc", "ctr", "client", "req", "ctrl", "conn", "qq", "q", "dq", "nc", "g"], "sq": ["squ", "seq", "sc", "iq", "ctl", "sk", "np", "qua", "ship", "carry", "sy", "p", "pg", "cv", "qa", "cur", "zz", "qi", "sync", "supp", " q", "scl", " seq", "s", "ql", "aq", "sub", "pool", "ctx", "eq", "client", "cf", "sci", " square", "shape", "quad", "sup", "zen", "req", "qu", " SQ", "qs", "qq", "row", "q", "g", "dq", "square", "query", "que", "cs", "sql", "sh"], "c": ["sc", "call", "cm", "k", "dc", "uc", "i", "p", "m", "b", "oc", "C", "d", "enc", "ec", "cur", "conf", "col", "ct", "ch", "self", "u", "e", "con", "ic", "cl", "vc", "cc", "ctx", "ci", "cn", "cf", "mc", "cp", "cache", "lc", "ctrl", "h", "ca", "f", "cu", "conn", "coll", "q", "v", "r", "l", "cs", "ac", "pc"]}}
{"project": "FFmpeg", "commit_id": "72a6244b5d554d7fdfdeb04c174750c7a2c52f83", "target": 0, "func": "void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,\n\n                                int start, int end, int fast_gain, int is_lfe,\n\n                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,\n\n                                uint8_t *dba_lengths, uint8_t *dba_values,\n\n                                int16_t *mask)\n\n{\n\n    int16_t excite[50]; /* excitation */\n\n    int bin, k;\n\n    int bndstrt, bndend, begin, end1, tmp;\n\n    int lowcomp, fastleak, slowleak;\n\n\n\n    /* excitation function */\n\n    bndstrt = bin_to_band_tab[start];\n\n    bndend = bin_to_band_tab[end-1] + 1;\n\n\n\n    if (bndstrt == 0) {\n\n        lowcomp = 0;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);\n\n        excite[0] = band_psd[0] - fast_gain - lowcomp;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);\n\n        excite[1] = band_psd[1] - fast_gain - lowcomp;\n\n        begin = 7;\n\n        for (bin = 2; bin < 7; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp1(lowcomp, band_psd[bin], band_psd[bin+1], 384);\n\n            fastleak = band_psd[bin] - fast_gain;\n\n            slowleak = band_psd[bin] - s->slow_gain;\n\n            excite[bin] = fastleak - lowcomp;\n\n            if (!(is_lfe && bin == 6)) {\n\n                if (band_psd[bin] <= band_psd[bin+1]) {\n\n                    begin = bin + 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        end1=bndend;\n\n        if (end1 > 22) end1=22;\n\n\n\n        for (bin = begin; bin < end1; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp(lowcomp, band_psd[bin], band_psd[bin+1], bin);\n\n\n\n            fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n            slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);\n\n        }\n\n        begin = 22;\n\n    } else {\n\n        /* coupling channel */\n\n        begin = bndstrt;\n\n\n\n        fastleak = (s->cpl_fast_leak << 8) + 768;\n\n        slowleak = (s->cpl_slow_leak << 8) + 768;\n\n    }\n\n\n\n    for (bin = begin; bin < bndend; bin++) {\n\n        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n        excite[bin] = FFMAX(fastleak, slowleak);\n\n    }\n\n\n\n    /* compute masking curve */\n\n\n\n    for (bin = bndstrt; bin < bndend; bin++) {\n\n        tmp = s->db_per_bit - band_psd[bin];\n\n        if (tmp > 0) {\n\n            excite[bin] += tmp >> 2;\n\n        }\n\n        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);\n\n    }\n\n\n\n    /* delta bit allocation */\n\n\n\n    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {\n\n        int band, seg, delta;\n\n        band = 0;\n\n        for (seg = 0; seg < FFMIN(8, dba_nsegs); seg++) {\n\n            band = FFMIN(49, band + dba_offsets[seg]);\n\n            if (dba_values[seg] >= 4) {\n\n                delta = (dba_values[seg] - 3) << 7;\n\n            } else {\n\n                delta = (dba_values[seg] - 4) << 7;\n\n            }\n\n            for (k = 0; k < dba_lengths[seg]; k++) {\n\n                mask[band] += delta;\n\n                band++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26774, "substitutes": {"s": ["S", "ses", "sys", "w", "ss", "p", "b", "m", "c", "i", "bis", "ts", "sq", "secondary", "port", "u", "e", "stats", "o", "session", "spec", "small", "sym", "si", "sb", "size", "services", "sec", "scale", "sa", "h", "f", "n", "a", "v", "r", "settings", "sf", "in", "g"], "band_psd": ["band_psn", "band_psp", "band_pesb", "band_asds", "band_vsdt", "band_apds", "band_apsl", "band_epsm", "band_ppsd", "band_ppsst", "band_epdk", "band_psm", "band2csl", "band_bsu", "band_copdal", "band_apsx", "band_pesad", "band_psdk", "band2psds", "band_lsx", "band_pointsD", "band_portsdk", "band_psl", "band_pst", "band_psst", "band2csd", "band_osd", "band_csds", "band_lsd", "band_psdx", "band___psd", "band_spdt", "band_epn", "band_apsn", "band_lsu", "band_osdat", "band_ppsf", "band_ysd", "band_tsb", "band_pesdal", "band_dsd", "band_PSf", "band_asesp", "band_spdr", "band_asdr", "band_csb", "bandCppsds", "band2csds", "band_rasds", "band_ppsx", "band_spds", "band_PSds", "band_portsd", "band_psds", "band_ysn", "band_etsD", "band_ysdk", "band_vsd", "band_bst", "band_asesd", "band_apd", "band_apsst", "band_psdh", "band_osds", "band_ppf", "band_ppsn", "band_asdt", "band_PSdal", "band_pss", "band___psb", "band_etsdm", "band_tsdh", "band_psad", "band_epd", "band_statsd", "band_psb", "band_psdt", "band2psl", "band_csd", "band_psx", "band1epsD", "band_PSl", "band_sss", "bandCppsd", "band_csdal", "band_pesdat", "band_etsm", "band_dsdk", "band_ppsD", "band_dsp", "bandCpsx", "band1psm", "band_copf", "band_psdat", "band_pesd", "band_psu", "band_ssds", "band_copd", "band1psD", "band_psdal", "band_vsdr", "band_csf", "band_portsn", "band_bsd", "band_copl", "band_ppst", "band_pssd", "band_tsx", "band_pointsd", "band_dsdx", "bandCppsn", "bandCppsx", "band_statsdal", "band_ppl", "band_opsdx", "band_PSs", "band_asesdx", "band___statsb", "band_ppds", "band_ssd", "band_statsdh", "band_epsD", "band_ppD", "band_tsds", "band_rasad", "band_apsD", "band_PSdh", "band1psd", "band2csb", "band_psD", "band___statsdh", "band_lst", "band_spd", "band_PSD", "band_osad", "band_apst", "bandCpsd", "band_tsdal", "band_tsn", "band_opsp", "band_rasdat", "band___psdh", "band_ppd", "band1psdm", "band1epsd", "band_ppt", "band_pointsdm", "bandCpsds", "band_apsds", "band_ppsu", "band_bsx", "band___statsd", "band1epsm", "band_psdr", "band_apsb", "band_ppb", "band_apsd", "band_ppsds", "band_ssdh", "band_etsd", "band_yssd", "band_pointsm", "band_epsd", "band_csl", "band_statsb", "band_pesdh", "band_psf", "band_rasd", "band_PSd", "band_portssd", "band_epsdm", "band_opsdk", "band_tsd", "band2psd", "band_ppsdh", "band_apD", "band_opsd", "band1epsdm", "band_asesdk", "band_pesds", "band___psdal", "band_PSt", "band___statsdal", "band2psb", "band_psdm", "band_vsds", "band_ppss", "bandCpsn", "band_asd"], "start": ["use", "from", "Start", "ie", "shift", "p", "i", "c", "d", "se", "x", "send", "add", "ad", "mid", "it", "id", "pad", "min", "get", "st", "offset", "art", "size", "scale", "first", "scan", "src", "init", "ind", "pre", "in", "range", "pos", "len", "stop"], "end": ["head", "use", "z", "b", "c", "End", "x", "send", "en", "END", "add", "mid", "id", "e", "max", "set", "ension", "offset", "bound", "append", "edge", "order", "ended", "inc", "size", "off", "length", "pend", "entry", "limit", "ending", "index", "dest", "range", "len", "stop"], "fast_gain": ["fastlyrate", "medium_winner", "fastianthin", "high_gain", "solid___group", "fast_channel", "mediumiangain", "fast_dim", "solid_dim", "fast_fan", "small_rate", "fast___winner", "fast_group", "solid_group", "small_grain", "fastlygain", "fast___thin", "high_rank", "solid___channel", "solid___gain", "mediumianthin", "solid___dim", "fast___gain", "fast_rate", "solid_gain", "fast___channel", "medium_thin", "small_gain", "fastiangain", "fast___group", "fast_grain", "fast_rank", "solid_channel", "high_rate", "medium_wall", "mediumianwall", "fastlyrank", "fastianwinner", "medium_gain", "fastianwall", "fast_winner", "fast_thin", "small_fan", "fast_wall", "fast___wall", "fast___dim", "mediumianwinner"], "is_lfe": ["is_lowc", "is_bfg", "is_bfe", "is_lowe", "is_ffE", "is_lowi", "is_ffe", "is_lve", "is_afe", "is_lfed", "is_lingee", "is_afc", "is_ffae", "is_lfc", "is_ffee", "is_ffi", "is_afg", "is_afE", "is_alfE", "is_afed", "is_alfe", "is_elfc", "is_elfg", "is_bfee", "is_lfE", "is_dfc", "is_lowl", "is_ffed", "is_lingae", "is_elfee", "is_afee", "is_lvi", "is_dfe", "is_afes", "is_bfc", "is_lingc", "is_ffc", "is_lfes", "is_lvl", "is_ffl", "is_linge", "is_lfae", "is_lfl", "is_alfed", "is_lfee", "is_alfes", "is_ffes", "is_elfe", "is_lvc", "is_lfg", "is_lfi", "is_dfee", "is_dfae"], "dba_mode": ["dbaOdepth", "dna_depth", "dba_size", "dba_depth", "dna_mode", "dba_sort", "dbaOsort", "dna_sort", "dbaOsize", "dna_size", "dbaOmode"], "dba_nsegs": ["dba_Nseg", "dba_Npersegs", "dba_npersels", "dba_nprog", "dba_nperseqs", "dba_nperseg", "dba_nspegs", "dba_nseg", "dba_nsels", "dba_nspels", "dba_nseqs", "dba_nprogs", "dba_Nseqs", "dba_Npersels", "dba_Nsels", "dba_nproqs", "dba_nspeqs", "dba_npersegs", "dba_nprols", "dba_nspeg", "dba_Nperseg", "dba_Nsegs", "dba_Nperseqs"], "dba_offsets": ["dba_posets", "dba_poses", "dba_offets", "dba_offsetets", "dba_offes", "dba_offsetet", "dba_posizes", "dba_offet", "dba_offsizes", "dba_offsetizes", "dba_poset", "dba_offses", "dba_offsetes", "dba_offset", "dba_offizes"], "dba_lengths": ["dba_countizes", "dba_lenits", "dba_lens", "dba_widths", "dba_countits", "dba_widthizes", "dba_lengthits", "dba_lenes", "dba_lengthizes", "dba_countes", "dba_widthits", "dba_lengthes", "dba_counts", "dba_lenizes", "dba_widthes"], "dba_values": ["dba_bits", "dba_vals", "dfa_bits", "dfa_vals", "dfa_flags", "dfa_values", "dba_flags"], "mask": ["batch", "image", "filter", "flags", "sum", "weight", "delay", "prefix", "ask", "alias", "pad", "depth", "patch", "padding", "gain", "bit", "spec", "Mask", "sign", "scale", "cache", "shape", "array", "bits", "map", "pack", "result", "lock"], "excite": [" Excrite", "ucite", " excrite", "excited", "occiton", "ecit", "ecite", " excile", "excit", " Excite", "occile", "Excite", " excites", "ucide", " Excit", " excide", "occited", "occites", " exciton", "exciton", "ExcITE", " excITE", "ucit", "Excit", "excites", "occide", "Excrite", "Excites", "ecited", "ecrite", "excile", "excrite", "Exciton", " excited", "Excited", "occite", "occit", " ExcITE", "ucile", "excide", " excit", "excITE"], "bin": ["chin", "fen", "ban", "fin", "socket", "batch", "bon", "cat", "uni", "base", "ping", "bug", "domain", "num", "split", "seed", "ben", "min", "gain", "nb", "obin", "lib", "bi", "kit", "pin", "sort", "part", "n", "year", "cookie", "val", "border", "gap", "user", "b", "bat", "gin", "flag", "bn", "bb", "align", "rec", "boot", "key", "ruby", "bit", "binary", "isin", "bad", "root", "in", "block", "len", "fun", "sid", "byte", "wan", "addin", "token", "bis", "pixel", "fix", "kin", "nn", "browser", "ask", "plugin", "db", "byn", "session", "spin", "order", "skin", "pal", "bot", "scan", "count", "init", "pos", "skip", "brain", "margin", "i", "bas", "feature", "type", "bc", "unit", "site", "gi", "vid", "inner", "slot", "local", "channel", "inn", "off", "win", "bid", "loop", "comment", "index", "bg"], "k": ["sk", "kw", "w", "i", "p", "b", "batch", "c", "unk", "kick", "kin", "K", "port", "num", "key", "loss", "channel", "scan", "win", "f", "n", "net", "r", "kid", "pos", "border", "g"], "bndstrt": ["bndcrp", "bNDstrnt", "bndstt", "bndStrt", "bndStrp", "bNDbrnt", "bndStrs", "bndctrT", "bNDstrT", "bNDStrs", "bNDbrT", "bndStrnt", "bndsts", "bndstp", "bndstrs", "bndbrt", "bNDStrt", "bndcrt", "bndbrnt", "bndstrT", "bNDStrp", "bNDbrs", "bntcrs", "bndbrT", "bntcrt", "bntstrs", "bntstrT", "bntstrt", "bNDStrT", "bNDstrp", "bndStrT", "bntcrp", "bndstrnt", "bndctrt", "bndctrs", "bntcrT", "bntstrp", "bNDstrs", "bndstrp", "bndcrs", "bNDbrt", "bNDstrt", "bndcrT", "bndstT", "bndctrnt", "bndbrp", "bndbrs"], "bndend": ["bbindend", "brnstart", "bngmax", "bndends", "abntstart", "bnnend", " bnden", "bndmax", "bNDend", " bNDen", "bnten", " bNDEnd", "abndenc", "bndstart", "abntends", " bndstart", "bindmax", "bngEnd", "brnends", "brnend", " bNDstart", "bntenc", "bbindmax", "bngest", "bbindEnd", "bbndend", "bbindest", "bntend", "bindest", "bndest", "bntstart", "bnden", "bckenc", "bckstart", "bNDEnd", "bbndest", "bnnmax", "bnnest", "bbndmax", "bckends", "brnenc", "bnnstart", " bndEnd", "abntend", "bndenc", "abntenc", "abndends", "bnnEnd", "bNDstart", "bngend", " bNDend", "bbndEnd", "bntends", "bckend", "bndEnd", "bntEnd", "bindEnd", "bindend", "bnnen", "bNDen", "abndend", "abndstart"], "begin": ["use", "uid", "batch", "num", "url", "mem", "min", "initial", "until", "gain", "sub", "Begin", "pin", "coord", "sort", "number", "um", "n", "pair", "r", "bor", "gin", "sum", "en", "filename", "hide", "wake", "month", "web", "shape", "amin", "don", "src", "forward", "chrom", "snap", "see", "uc", "rb", "nn", "mid", "span", "session", "sb", "order", "utf", "ward", "scan", "skip", "master", "position", "member", "method", "run", "record", "inn", "bid", "un", "sav", "range"], "end1": ["endOnce", "endedJ", "setone", "lenone", "endedOnce", "EndOnce", "End1", "ended5", "end5", "set5", " end2", "len2", "startOnce", "setOne", "ended1", " endJ", " endone", "ended2", " end100", " endOne", "EndOne", "endOne", "startJ", "endedOne", "len1", "end2", "startone", "endJ", " endn", "endone", "set100", "setn", "ended8", "start2", "len100", " end8", "endn", " end5", "start1", "set2", "startOne", "set8", "endedn", "end100", "set1", "end8"], "tmp": ["temp", "skip", "bis", "batch", "bb", "buffer", "rb", "nn", "cb", "beta", "duration", "port", "num", "pad", "buf", "seed", "unit", "ff", "nb", "binary", "sb", "shape", "loop", "ip", "qq", "result", "pos", "wait"], "lowcomp": ["lowcon", "flowcomp", "lowercomp", "flowomp", "fastcomponent", "smallproc", " lowcomb", "fastcomp", "lowcp", "lowcomb", "groundcmp", "slowprop", "Lowcom", " lowComp", "highcmp", " lowomp", "lowComp", "slowproc", "lowcmp", "oldcond", "lowercon", "slowcom", "lowproc", "fastproc", "Lowomp", "slowomp", "lowomp", "slowcomb", "smallpos", "slowcomponent", "flowcmp", " lowexp", "quickomp", "quickcmp", "lowfrac", " lowprop", "quickproc", "owncp", "groundomp", "lowcond", "slowcp", "highcomp", "oldcomp", " lowpar", "flowfrac", "oldproc", "Lowcomponent", "flowpar", " lowproc", "lowercp", "LowComp", "lowpos", "groundcond", "Lowproc", " lowcmp", " lowfrac", "oldcomponent", "lowexp", "quickprop", "slowexp", "smallcomp", "slowcon", "highcomponent", "slowcond", "lowerexp", "flowcomponent", "groundcomp", "highComp", "Lowcomp", "lowpar", "slowpar", "quickcomponent", "lowcom", "owncon", "lowcomponent", "oldomp", "Lowcmp", "quickcomp", "oldcmp", "slowcomp", "slowcmp", "oldfrac", "oldcom", "owncomp", "fastpos", " lowcomponent", "flowcomb", "lowprop", " lowcom", "smallcomponent", "lowerproc", "slowpos", "ownproc", "lowercom"], "fastleak": [" fastsleake", "fastneak", "highcleak", "fastpeaw", "highleak", " fastleek", "fastleaks", "fastLeark", "fastsleake", "fastoleaks", "fastpeak", "fastleaker", " fastleark", "fastbleake", " fastsleek", "fastcleak", "fastoleak", "fastLeaking", " fastsleark", "fastLeek", "fastsleak", " fastleake", "fastsleark", "fastcleaw", " fastleaker", "highleaw", "highleake", "fastneaker", "fastLeaker", " fastleaking", "fastsleaking", "fastsleek", "fastcleake", " fastsleaking", "fastLeak", "fastleark", "highcleake", "fastcleaks", "highcleaw", "fastsleaker", "fastleek", "fastleaw", "fastbleak", "fastleaking", "highleaks", "fastoleake", "fastpeaks", " fastsleak", "fastneark", " fastsleaker", "fastneake", "fastoleaw", "highcleaks", "fastpeake", "fastbleaking", "fastbleek", "fastLeake", "fastleake"], "slowleak": ["lowleake", "slowLeace", "speedpeac", "speedleac", "slowleake", "slowpeace", "lowleaker", "speedpeace", "slowsleaker", "slowleace", "slowLeac", "slowoleake", "speedleake", "slowleac", "speedpeake", "slowoleac", "speedleace", "speedpeak", "lowoleake", "slowoleace", "slowLeaks", "slowLeak", "slowoleaks", "slowsleake", "slowsleaks", "slowpeake", "slowLeaker", "lowleaks", "slowoleak", "slowleaks", "slowpeak", "lowoleaks", "slowoleaker", "speedleak", "lowoleak", "lowoleaker", "slowsleak", "slowLeake", "lowleak", "slowleaker", "slowpeac"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776, "substitutes": {"s": ["S", "rs", "ses", "sys", "ss", "p", "m", "b", "c", "i", "ns", "d", "sq", "ds", "conf", "sg", "state", "states", "sync", "self", "u", "private", "e", "south", "o", "sets", "input", "session", "spec", "si", "sym", "submit", "new", "sb", "services", "series", "f", "sim", "service", "n", "fs", "src", "t", "a", "v", "init", "r", "sf", "in", "settings", "ssl", "sv", "side"], "x": ["height", "move", "z", "i", "p", "m", "c", "b", "name", "position", "d", "image", "ix", "px", "data", "base", "on", "pointer", "X", "id", "u", "e", "o", "path", "xi", "size", "shape", "win", "f", "rx", "index", "t", "a", "v", "ex", "pos", "l"], "y": ["height", "z", "yi", "i", "p", "b", "sy", "c", "dy", "oy", "ya", "ay", "d", "yt", "ery", "ye", "cy", "lon", "vy", "u", "yo", "ys", "ey", "ady", "o", "Y", "zy", "bar", "ry", "f", "n", "j", "ny", "a", "t", "ip", "ty", "l", "hi", "yy"], "w": ["height", "ow", "k", "z", "p", "b", "c", "m", "wb", "d", "sw", "weight", "wh", "rw", "u", "wx", "o", "work", "max", "fw", "wd", "ew", "size", "length", "win", "wid", "aw", "wt", "n", "W", "wa", "a", "t", "q", "v", "we", "l", "sh"], "h": ["height", "hm", "ht", "k", "th", "z", "i", "p", "b", "m", "c", "dy", "d", "en", "H", "hh", "ch", "u", "depth", "e", "o", "dh", "size", "length", "gh", "f", "n", "j", "t", "wa", "q", "v", "l", "hi", "ph", "oh", "sh"], "rect": ["complete", "txt", "font", "butt", "slice", "driver", "pt", "director", "transform", "scroll", "dash", "dr", "text", "config", "ct", "att", "select", "cross", "surface", "port", "tr", "cont", "tv", "cover", "point", "patch", "project", "RECT", "lat", "input", "path", "grad", "tri", "spec", "object", "arrow", "ror", "client", "dra", "rc", "crop", "shape", "touch", "feat", "device", "json", "round", "dot", "quant", "upload", "pair", "row", "coll", "draw", "Rect"], "redraw_fifo_last": ["redraw_fifos_str", "redraw_fifo__last", "redraw_fifo_full", "redraw_fifos_first", "redraw_fifo_first", "redraw_fifos_max", "redraw_fifos_last", "redraw_fifos_full", "redraw_fifo_str", "redraw_fifo__max", "redraw_fifo_max", "redraw_fifo__first"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n", "idx": 26777, "substitutes": {"dc": ["exec", "sc", "DC", "cca", "uc", "cd", "oc", "director", "anc", "context", "doc", "ec", " DC", "config", "cr", "ct", "bc", "rec", "fc", "td", "input", "dat", "cdn", "loc", "jc", "CC", "enter", "cc", "cf", "mc", "rc", "CD", "ga", "xml", "tc", "da", "dm", "de", "draw", "nc", "pc", "desc"], "d": ["md", "k", "w", "z", "cd", "p", "b", "m", "i", "data", "ds", "ad", "bd", "dd", "u", "db", "e", "o", "dh", "dat", "s", "dx", "dl", "gd", "di", "dt", "D", "f", "y", "n", "da", "dm", "de", "t", "sd", "v", "q", "a", "r", "df", "l", "dn", "g"], "c": ["sc", "k", "w", "z", "i", "p", "m", "b", "cd", "uc", "C", "xc", "ec", "col", "ct", "bc", "ce", "cy", "ch", "u", "e", "fc", "con", "o", "ic", "cl", "vc", "s", "cc", "ci", "cn", "cf", "mc", "co", "lc", "h", "ca", "f", "y", "tc", "n", "cu", "t", "v", "r", "g", "nc", "l", "cs", "ac", "pc"], "x": ["xx", "k", "w", "z", "i", "p", "exc", "b", "m", "C", "ix", "xc", "config", "pe", "ax", "ct", "cross", "cy", "ch", "xe", "X", "xt", "u", "wx", "e", "xy", "con", "o", "ic", "cl", "vc", "xi", "dx", "yx", "s", "l", "xes", "cc", "ci", "fx", "xs", "xxx", "lc", "xml", "h", "f", "y", "xp", "rx", "n", "index", "php", "t", "q", "v", "r", "ex", "g", "iz", "nc", "tx", "cs", "pc"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 26780, "substitutes": {"spapr": ["ppapsp", "spApar", "spaprar", "spAprar", "spaxar", "ppapsrar", "spapsrar", "ppapsr", "spaxr", "spapp", "ppapsar", "spApp", "spaxrar", "ppaprar", "ppapp", "ppapr", "spaxp", "spapar", "spapsp", "spapsr", "spApr", "ppapar", "spapsar"], "token": ["seq", "secret", "gen", "sid", "nat", "flag", "ts", "next", "serial", "rec", "rev", "ok", "os", "reply", "len", "win", "rule", "reg", "match", "root", "init", "ops", "result", "random", "oken", "stop"], "nargs": ["lalt", "rnret", "Nparams", "NArgs", "rnparams", "lret", "rnalt", "largs", "cparams", "calt", " narg", " nparams", "cret", "nparams", "nalt", "lparams", "ncarg", "narg", "Narg", "ncArgs", "ncargs", "nArgs", "Nargs", "ncparams", "cargs", "rnargs", " nArgs"], "args": ["ants", "argument", "parse", "features", "frame", "ns", "flag", "flags", "vs", "data", "ms", "config", "opens", "ans", "py", "yrs", "ds", "ars", "ins", "ks", "mac", "vals", "gs", "arr", "options", "cmd", "fields", "Args", "axis", "lines", "strings", "spec", "limits", "ig", "words", "aws", "ras", "stat", "ret", "reply", "sec", "plays", "grades", "addr", "arg", "orders", "bytes", "details", "bits", "alls", "arms", "years", "atts", "results", "ids", "arn", "parts", "len", "params", "ints"], "nret": ["nbret", "nresult", "nbRet", "bresult", " nRET", "nbresult", "bret", " nresult", "presult", " nRet", "nRET", "nalt", "NRet", "pret", "Nresult", "bRET", "nbres", "Nret", " nalt", " nres", "pRET", "Nres", "palt", "nRet", "balt", "nres"], "rets": ["ants", "secret", "seq", "rs", "nets", "errors", "res", "features", "ns", "ats", "flags", "ts", "uts", "ils", "items", "acks", "ds", "opens", "ans", "verts", "def", "rules", "ins", "outs", "rows", "urs", "archives", "cedes", "uses", "vals", " secrets", "aux", "fields", "runs", "strings", "RET", "ras", "uds", "ret", "utils", "nas", "stores", "tracks", "ents", "ails", "ls", "fs", "details", "qs", "alls", "tests", "alt", "results", "ids", "arn", "ops", "fits", "uments", "gt", "ints", "tails"], "id": ["ref", "head", "from", "aid", "code", "sid", "uid", "info", "i", "c", "name", "d", "pid", "ix", "time", "data", "base", "no", "Id", "ad", "address", "type", "ins", "it", "end", "oid", "ks", "url", "is", "key", "did", "max", "create", "path", "bit", "uri", "rc", "addr", "h", "ca", "f", "ip", "year", "q", "core", "init", "root", "ids", "kid", "ce", "ID"], "start": ["from", "skip", "Start", "sk", "starting", "ie", "shift", "p", "info", "name", "d", "started", "enable", "x", "time", "cur", "add", "ad", "next", "type", "mid", "state", "it", "end", "is", "step", "seed", "sp", "span", "min", "get", "tick", "set", "st", "offset", "run", "art", "size", "source", "y", "ip", "index", "host", "init", "ind", "ace", "in", "pos", "len", "stop"], "r3": [" rThird", "sr03", "sriii", "ruThird", "rThree", " r53", "hriii", "ruiii", "R03", "rr03", "ru3", "r1", "srThird", " r1", "rThird", "riii", "R3", "R53", "R2", "hr3", "r53", " r2", "hr2", "r2", "Riii", "rrThree", "hr1", " r03", "rr3", "RThree", "rr53", " riii", " rThree", "R1", "ru03", "sr3", "r03"], "cs": ["sc", "sk", "rs", "sys", "c", "Cs", "ns", "cks", "ix", "ts", "CS", "vs", "icks", "ec", "ds", "cus", "ct", "ars", "ps", "bc", "cons", "ks", "sync", "bs", "css", "gs", "cms", "vc", "ac", "s", "ics", "spec", "wcs", "cer", "cc", "ras", "ci", "cp", "cf", "cn", "rc", "ctx", "cache", "os", "utils", "cas", "lc", "cells", "ls", "fs", "qs", "js", "conn", "ced", "core", "cing", "ck", "acs", "nc", "ce", "pc", "ces"], "cpu": ["CPU", "processor", "node", "cm", "sys", "np", "c", "px", "CS", "ec", "clock", "bc", "sync", "proc", "css", "gpu", "fc", "GPU", "nc", "cli", "ctx", "cp", "cn", "cf", "ci", "roc", "cache", "eni", "vm", "lc", " CPU", "gc", "conn", "core", "pu", "pc"], "env": ["zone", "np", "console", "scope", "iss", "exc", "ass", "engine", "c", "assets", "context", "cv", "shell", "enc", "vs", "ec", "en", "config", "Environment", "conf", "style", "export", "eve", "ce", "state", "ev", "ea", "inet", "environment", "ne", "db", "e", "el", "err", "session", "estate", "viron", "cal", "edge", "agent", "ctx", "energy", "eu", "skin", "eni", "cache", "cf", "oa", "vm", "ext", "conn", "core", "settings", "et", "que", "equ"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792, "substitutes": {"bus": ["driver", "this", "info", "engine", "mount", "usb", "data", "test", "config", "interface", "us", "bc", "port", "io", "serial", "plugin", "proc", "self", "boot", "feed", "bridge", "http", "controller", "Bus", "dev", "drive", "board", "cache", "device", "proxy", "loop", "service", "f", "plug", "block", "connection", "lock", "BUS"], "address": ["node", "location", "code", "account", "Address", "i", "master", "server", "name", "attribute", "request", "pointer", "interface", "capacity", "type", "reference", "state", "end", "port", "alias", "message", "resource", "uri", "object", "enter", "offset", "mode", "target", "order", "size", "number", "shape", "channel", "device", "addr", "length", "transfer", "source", "network", "ip", "index", "pair", "host", "content", "event", "route", "connection", "localhost", "layer"], "recv": ["ref", "reV", "RECf", "renv", "RECV", " reccv", "recb", "respv", " recb", " recf", "recV", "respcv", " recV", "reccv", "rev", "respceive", "renb", "rencv", "RECq", "req", "renceive", " recceive", " recq", "recceive", "recf", "RECv", "recq", "respb"], "qdev": ["quickdes", "sqdes", "qtsd", "Qde", "QDev", "Qdev", "qtdes", "qudes", "sqcase", "sqde", "qucase", "Qdef", "Qsd", "qusd", "quickdev", "sqdevice", "pdevice", "qudev", "qude", "qdef", "qde", "quickde", "quickcase", "quDev", "qcase", "pde", "sqdev", "pdef", "Qdes", "Qdevice", "qDev", "qtDev", "pdev", "qdes", "qtdev", "qsd", "sqdef", "qdevice"], "slave": ["fork", "server", "bean", "sync", "seed", "bridge", "controller", "object", "dev", "serv", "wife", "entry", "slice", "driver", "shared", "engine", "attribute", "port", "hole", "link", "ssh", "seat", "lane", "stable", "root", "sl", "machine", "table", "sh", "ve", "node", "ship", "boat", "plugin", "player", "command", "session", "uri", "mode", "ser", "parent", "copy", "future", "sb", "length", "proxy", "sett", "source", "host", "connection", "seller", "lease", "shift", "master", "interface", "type", "instance", "id", "unit", "vid", "role", "si", "worker", "owner", "channel", "missing", "device", "loop", "child", "route", "adder", "ace", "result", " slaves"]}}
{"project": "FFmpeg", "commit_id": "8a57ca5c6a1c0ad28afa7ea6f824981e6761cce1", "target": 0, "func": "static int aasc_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    AascContext *s = avctx->priv_data;\n\n    int compr, i, stride;\n\n\n\n    s->frame.reference = 3;\n\n    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &s->frame)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    compr = AV_RL32(buf);\n\n    buf += 4;\n\n    buf_size -= 4;\n\n    switch (avctx->codec_tag) {\n\n    case MKTAG('A', 'A', 'S', '4'):\n\n        bytestream2_init(&s->gb, buf - 4, buf_size + 4);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    case MKTAG('A', 'A', 'S', 'C'):\n\n    switch(compr){\n\n    case 0:\n\n        stride = (avctx->width * 3 + 3) & ~3;\n\n        for(i = avctx->height - 1; i >= 0; i--){\n\n            if(avctx->width*3 > buf_size){\n\n                av_log(avctx, AV_LOG_ERROR, \"Next line is beyond buffer bounds\\n\");\n\n                break;\n\n            }\n\n            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n\n            buf += stride;\n\n            buf_size -= stride;\n\n        }\n\n        break;\n\n    case 1:\n\n        bytestream2_init(&s->gb, buf, buf_size);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n\n        return -1;\n\n    }\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FourCC: %X\\n\", avctx->codec_tag);\n\n        return -1;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 26819, "substitutes": {"avctx": ["afcas", "AVlc", "avalconsole", "navcontext", "afkb", "avcontext", "afcontext", "avectx", "ajctx", "ajcmd", "ajcmp", "avekb", "avct", "akcca", "AVsync", "afxc", "abcmp", "akctx", "akcontext", "navlc", "ajcomponent", "ajxc", "afcca", "AVcontext", "afconsole", "avcu", "abcf", "afsync", "avcoll", "avalct", "avcca", "abca", "abcontext", "avconsole", "AVconfig", "avalcontext", "aftx", "avaltx", "afctx", "avconfig", "avalctx", "afca", "avecoll", "abctx", "navsync", "AVctx", "avxc", "aveca", "akcb", "ajcb", "avcb", "avecb", "avcf", "avelc", "ajtx", "avalcf", "afproc", "akcmd", " avcb", "avalcmp", "avecontext", "abproc", "avcmp", "AVcu", "aucoll", "avtx", "aucontext", "akkb", "avsync", "afcf", "avca", "auctx", "avecu", "afcb", "aflc", "abconn", " avxc", "avconn", "afcoll", "afconn", "ajcontext", "avalcca", "avecf", "ajcas", "abct", "afcmd", "afct", "ajproc", "avecca", "akcas", "avkb", "auconn", "aveconfig", "afcu", "abconfig", "aveconn", "avcomponent", "avalcomponent", "afcomponent", "AVconsole", " avcontext", "avproc", "avlc", "avcas", "avcmd", "navctx", "avalconfig", "afcmp", "ajcca", "afconfig"], "data": ["load", "Data", "uf", "body", "code", "slice", "margin", "bin", "p", "m", "batch", "frame", "empty", "image", "d", "buffer", "queue", "base", "media", "read", "config", "next", "reader", "pad", "feed", "open", "message", "padding", "input", "dat", "start", "offset", "output", "parent", "size", "cache", "response", "block", "length", "buff", "window", "f", "bytes", "index", "DATA", "content", "memory", "alpha", "result", "connection", "val"], "data_size": ["data___number", "data___len", "data___count", "data_count", " data_count", "data_number", " data_number", "data_len", " data_len", "data___size"], "avpkt": ["avppKT", "afpct", "avpcf", "avPkt", "AVvpKT", "avPacket", "avpbk", "avppk", "abcpacket", "avtkt", "afpacket", "affacket", "abpka", "abpkt", "avfct", "affk", "affkt", "avPk", "abcpkt", "AVvpkt", "avcpk", "avpka", "abpacket", "avpbcf", "abcpct", "avvpk", "AVpk", "avpk", "affct", "avvpkt", "avpbKT", "AVpKT", "avcpacket", "avcpkt", "avtct", "avcpka", "avppkt", "avPct", "abcpka", "avpacket", "abpct", "avfkt", "afpk", "avpbkt", "AVvpk", "avfka", "avpKT", "avpct", "AVvpcf", "avvpKT", "avfk", "AVpcf", "avvpcf", "avppcf", "avfacket", "afpkt", "avtacket", "avcpct", "avtka", "AVpkt"], "buf": ["ref", "seq", "uf", "font", "ru", "bag", "done", "uc", "p", "b", "batch", "wb", "c", "cv", "Buff", "bb", "vec", "buffer", "queue", "text", "rb", "config", "br", "img", "prop", "cb", "ab", "bc", "bd", "port", "proc", "pad", "orig", "feed", "aux", "home", "ff", "cmd", "tmp", "cap", "la", "loc", "box", "ctx", "cur", "fb", "cf", "cp", "utf", "alloc", "Buffer", "feat", "rc", "cas", "length", "buff", "array", "f", "src", "fp", "func", "v", "pack", "block", "wa", "fd"], "s": ["S", "side", "sc", "ses", "rs", "sys", "args", "ss", "p", "c", "ns", "context", "d", "ts", "sq", "ds", "ms", "conf", "us", "ps", "sg", "ins", "ks", "sync", "self", "su", "is", "e", "cs", "gs", "es", "o", "session", "spec", "l", "si", "sym", "hs", "aws", "os", "services", "sa", "sup", "as", "ls", "f", "service", "js", "qs", "fs", "j", "y", "a", "t", "r", "ops", "parts", "ssl", "sv", "in", "its", "g"], "compr": ["corpol", "corpr", "c", "compre", "ocompro", "x", "cumpr", "buffer", "imbr", "compro", "impre", "comppol", "compPr", "imPr", "ocompr", "all", "comppre", "comppro", "cumpol", "impr", " compre", "compol", "combr", "comPR", "corbr", "cumPR", "corPR", "comppr", "ocompre", "compPR", " combr", "cumbr", " compro", "compbr", "r", "_", "comPr", " comPr", "g"], "i": ["abi", "slice", "k", "z", "ie", "p", "b", "dim", "c", "m", "d", "x", "ti", "mi", "phi", "qi", "io", "u", "e", "gi", "li", "ji", "o", "zi", "multi", "xi", "start", "uri", "ii", "bi", "si", "ai", "ini", "ni", "di", "ci", "fi", "vi", "lc", "h", "f", "I", "ki", "y", "n", "j", "index", "ip", "t", "a", "v", "iu", "r", "pi", "mu", "ind", "ui", "l", "hi", "g"], "stride": [" strided", "strue", "Strider", "Strie", "STRider", "strise", "yride", "divite", "STRide", "divide", "strie", "STRise", "divise", "trince", "yrince", "Strite", " strIDE", " strie", "yrided", "drite", "Strided", "strite", "trip", " strince", "STRIDE", " strue", "trided", "STRided", "strIDE", "STRite", " strise", "strip", "dride", "strider", " strip", "Stride", " strite", "tride", "drider", "drie", "strince", "strided", "STRue", "yrip", " strider", "divIDE", "Strue"]}}
{"project": "FFmpeg", "commit_id": "de6df46120367b7d49d9d7c0971cbe36368b840a", "target": 1, "func": "int ff_h264_field_end(H264Context *h, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n#if CONFIG_ERROR_RESILIENCE\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        ff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);\n        ff_er_frame_end(&h->er);\n    }\n#endif /* CONFIG_ERROR_RESILIENCE */\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n    h->current_slice = 0;\n    return err;\n}", "idx": 26836, "substitutes": {"h": ["head", "hm", "ht", "th", "hand", "w", "z", "i", "p", "m", "b", "c", "kh", "hash", "d", "beh", "hd", "history", "ih", "hist", "bh", "H", "hh", "ch", "end", "ah", "han", "how", "self", "uh", "u", "hl", "e", "ssh", "hp", "hw", "work", "rh", "http", "s", "prev", "l", "adh", "hs", "handler", "help", "auth", "gh", "eh", "f", "t", "host", "ha", "header", "enh", "q", "v", "g", "hr", "hi", "he", "ph", "oh", "sh"], "in_setup": ["in1progress", " in_ctx", "in_progress", "in_prep", "inLogsetup", "inpctx", "in_done", " in_done", "inpsetup", "in_summary", "in1setup", "in_ctx", " in_prep", "inLogsummary", "inLogclose", "inpprep", " in_close", "in1done", "in_close", " in_progress", " in_summary"], "avctx": ["abloc", "avcontext", "afcontext", "broadcfg", "avectx", "avcal", "Avctrl", "abcfg", "evconfig", "AVctrl", "wavctx", "awcfg", "abcmp", "avbc", "broadloc", "akctx", "avecmp", "akcontext", "broadcontext", "AVcontext", " avci", "abcf", "afctrl", "afcfg", "Avcmp", "abca", "abcontext", "AVloc", "awcontext", "afctx", "avconfig", "afci", "avectrl", "avloc", "akcf", "abctx", "avctrl", "aveloc", "AVca", "AVctx", "avcfg", "aveca", "avebc", "avci", "evctrl", "avcf", "evcf", "AVcfg", "AVcmp", "avecontext", "evcontext", "AVconn", "avcmp", "awctx", "avca", "Avloc", "wavcontext", "evctx", "akconfig", "wavconn", "avconn", "broadctx", "afconn", "Avctx", "broadcal", "evcmp", "afbc", "afcal", " avcfg", "abconfig", "awci", "evconn", "broadcmp", "aveconn", "wavbc", " avcontext", "evcal", "afcmp"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26841, "substitutes": {"s": ["S", "rs", "ses", "sys", "args", "ss", "p", "m", "c", "ns", "server", "d", "ts", "storage", "sq", "ds", "ms", "conf", "us", "ps", "changes", "state", "ks", "states", "sync", "sg", "self", "is", "private", "e", "es", "gs", "cs", "stats", "o", "south", "sets", "sie", "session", "l", "sym", "si", "os", "new", "sb", "services", "xs", "ls", "f", "service", "js", "status", "fs", "qs", "t", "a", "settings", "ops", "parts", "ssl", "sv", "its", "rates", "g"], "value": ["byte", "w", "shift", "info", "name", "image", "d", "buffer", "data", "address", "type", "version", "Value", "state", "end", "flow", "io", "id", "store", "range", "u", "key", "message", "max", "set", "start", "fee", "offset", "si", "result", "VALUE", "number", "scale", "balance", "length", "current", "money", "timeout", "total", "status", "index", "v", "memory", "values", "block", "val"], "size": ["from", "ish", "code", "z", "ize", "shift", "c", "name", "sized", "time", "data", "style", "address", "capacity", "type", "Size", "is", "unit", "SIZE", "loc", "small", "fee", "offset", "si", "ci", "sec", "scale", "now", "length", "six", "timeout", "ui", "len", "g"], "i": ["k", "ie", "p", "b", "m", "info", "c", "d", "ix", "x", "data", "ti", "ia", "mi", "it", "id", "io", "ui", "is", "u", "e", "li", "ji", "o", "zi", "multi", "ini", "ii", "si", "ai", "bi", "ni", "di", "ci", "fi", "eni", "iv", "length", "h", "I", "f", "child", "oi", "ip", "index", "j", "a", "n", "t", "v", "iu", "r", "pi", "l"], "data_count": [" data_data", " data_type", " data_size", "data_start", "data_value", " data_start", "data_type", "dataCcount", " data_length", "data_pool", " data_cache", " data_value", "dataCsize", "data\u00b7data", "data\u00b7size", "dataCstart", "data_size", "data_list", " data_list", "data_data", "data\u00b7value", " data_pool", "data_len", "data\u00b7count", " data_len", "data_length", "dataClen", "data_cache"]}}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848, "substitutes": {"opts": ["opters", "operters", "oprs", "cattes", "catrs", "opttes", "opertp", "opcs", "copts", " opters", " optp", "coptp", "opertes", "copcs", "copters", "optrs", "optcs", " opcs", "catcs", "opercs", "optts", "optes", "optp", "operts", "operrs", "catts"], "filename": ["dll", "kn", "acl", "driver", "sn", "wb", "name", "fd", "enc", "fn", "prefix", "loader", "Filename", "url", "directory", "nil", "path", "rl", "unc", "wl", "wcs", "binary", "files", "il", "which", "username", "src", "fp", "func", "fil", "sf", "tty", "ssl", "kl", "file", "params"], "chr": ["colcr", "ppr", "anchr", "partrr", "shrt", "chsr", "cherb", "chru", "chrl", "partrt", "cher", " chrt", "colsr", "phdr", "colre", "cprl", "CHrt", "shre", " chcr", "chtr", "chert", "ochar", "ichrt", " chra", "colr", "ppru", "chrb", "ochri", "chra", "ichru", "gyar", "ichrb", "CHri", "chrr", "cheru", "cprar", "Chsr", "cherf", "anchra", " chdr", " chri", " chrar", "phrt", "partre", "cpr", "chera", "shr", "gyrt", "chrt", "chcr", "cpsr", "chdr", "ichrf", "chrf", "Chcr", "ichrar", "ichsr", "ochr", "ichar", "gytr", "CHr", "ichrl", "pprf", "colri", "coldr", "chrar", "shrr", "ichr", "colrr", "ichtr", "anchrt", "partr", "colrt", " chtr", " chsr", " chrl", "cherr", "ochrt", "Chr", "pprb", " chrr", "phri", "gyr", "Chrr", "phr", "chri", "CHar", "chre", "anchrr"], "s": ["S", "space", "rs", "ses", "socket", "sys", "sid", "w", "scope", "ss", "p", "i", "m", "c", "b", "ns", "storage", "sq", "ds", "ps", "sg", "state", "u", "e", "es", "south", "gs", "o", "share", "session", "spec", "si", "sym", "aws", "sb", "services", "h", "f", "fs", "status", "n", "js", "src", "t", "v", "sl", "r", "sf", "settings", "ops", "ssl", "params", "g"]}}
{"project": "FFmpeg", "commit_id": "a91d82b5cc7d828ea9779aae1595f60e7e257d29", "target": 1, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n\n    // However the Coding Technologies decoder check uses 6 patches\n\n    if (sbr->num_patches > 6) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26862, "substitutes": {"ac": ["acc", "exec", "aic", "acl", "dc", "oc", "auc", "anc", "c", "fac", "acer", "doc", "sac", "soc", "am", "ad", "ct", "bc", "mac", "mic", "fc", "AC", "ic", "cms", "vc", "cc", "Ac", "jac", "rc", "cache", "mc", "aut", "ca", "ack", "tc", "arc", "acs", "iac", "pc", "cam"], "sbr": ["sbe", "ansbl", "opensler", "wsBR", "sesbre", "chesber", " sdr", "lsBR", "jsbar", "opensarr", "tsbr", " shr", "sobi", "opensbr", "lsbro", " soulder", "nsdb", "confbert", "lsstr", "alsdr", " sbar", "soder", "esarr", "ssbridge", "gsbre", "chesbr", "wsbro", "lsbert", "ishr", "esbre", "confbar", "sinbr", "sinbl", "sbert", "opensbridge", "gsbr", "fsbro", "dsBR", "lsbr", "nsstr", "esstr", "esibr", "psber", "wsbl", "wsarr", "sesbridge", "nsbe", "setsbar", "esgr", "dsbar", " sibr", "esbar", "isher", "confbridge", " sfr", "gsfer", "chesbro", "sBR", "asdb", "setsorb", "sysibr", "confbr", "confbre", "ssber", "fsbl", "tsbro", "asibr", "sfer", " soper", "osbridge", "tsbre", "ssbl", "psfer", "ansbre", "gsber", "gsbro", "psbl", "sinbre", "sorb", "dsbl", "ansbr", "lsber", "lsfr", "ssfr", "isdiv", "sesibr", " sbre", "lsarr", " sbridge", "sesbert", "jsbr", "asbr", "psbro", "opensbert", "asbre", "gsdr", "outsbr", "sarr", "esorb", "nsbre", "ssbre", "jsbre", "psstr", "fsbr", "ansgr", "outsbridge", "ansbro", "ssobi", "shr", " sBR", "tsfr", "jsbro", "esbr", "osbert", "sdb", "psbre", "wsbr", "gsoder", "ansarr", " sfer", "sdiv", "dshr", "insbro", " sarr", "sbl", "setsbl", "sher", "setsher", "sgr", " sher", "dsbert", "fsbridge", "sstr", "ssBR", "sibr", "singr", "sshr", "opensibr", "gsbl", "psbr", "lshr", "sysdr", "lsbar", "psher", "alsbert", "outsibr", "confibr", "sfr", "gshr", "sler", "jsbridge", "ssher", "asarr", "ssler", "chesbridge", " sbro", "alsbr", "nsber", " sgr", "isbl", "jsstr", "lsbre", "soulder", "ssbr", " sorb", "tsbl", "sbar", "setsbert", "tsoulder", "outsbert", "ssarr", "anshr", "wsfr", "esbl", "eshr", "sbre", "ssibr", "sbro", "fsbar", "isbre", "sbridge", " soder", " sdiv", "dsbridge", "alsibr", "sesbr", "setsbre", "setsgr", "osibr", "ansBR", " sstr", "esber", "tsBR", "dsbre", "dsbr", "insbl", " sbert", "lsbl", "gsbridge", "ansfr", "isbar", "sysbert", "tsibr", "sdr", "nsbr", "opensobi", "asbl", "wsber", "lsher", "asbe", "setsbr", "sber", " sber", "sysbr", "fshr", "ssoper", "sysoulder", "psdr", "confbl", "ansber", "soper", "osbr", "nsbar", " sbl", "wsbre", " sobi", "jshr", "lsbridge", " sler", "insbr", "sysbl", "isbr", "setsdiv", "inshr"], "i": ["ski", "yi", "b", "m", "p", "c", "ie", "d", "ix", "x", "ti", "mi", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "o", "s", "xi", "ii", "ini", "si", "ai", "bi", "ni", "di", "ci", "ik", "h", "I", "f", "ki", "y", "n", "j", "index", "a", "oi", "chi", "v", "iu", "pi", "ui", "l"], "k": ["mask", "tk", "sk", "kn", "kw", "w", "kk", "z", "b", "m", "p", "c", "kh", "d", "ka", "unk", "x", "kick", "kin", "K", "km", "ad", "isk", "ks", "ch", "jj", "id", "kb", "kt", "u", "ak", "e", "key", "ijk", "o", "uk", "work", "s", "ok", "l", "spec", "ko", "ky", "ik", "mc", "ikk", "kr", "ek", "h", "ack", "f", "y", "ki", "n", "j", "t", "mm", "mk", "q", "kat", "v", "ck", "kid", "ke", "ku", "kl", "dk", "g"], "num_patches": ["num_catches", "num_petrices", "num_batouts", "num_patchchers", "num_pitctions", "num_datches", "num_partches", "num_batches", "num_butched", "num_atencies", "num_natges", "num_butouts", "num_patternters", "num_catched", "num_pathes", "num_petencies", "num_patries", "num_Patched", "num_patctions", "num_pats", "num_batatches", "num_patouts", "num_patchatches", "num_natched", "num_patchencies", "num_patchching", "num_patters", "num_petions", "num_patchche", "num_patns", "num_ations", "num_petched", "num_patche", "num_patatches", "num_aptching", "num_patures", "num_catchers", "num_datters", "num_apthes", "num_natches", "num_pitries", "num_patchions", "num_fetchers", "num_partched", "num_patchhes", "num_parching", "num_petges", "num_patges", "num_catrices", "num_patchters", "num_natrices", "num_fetched", "num_pitches", "num_pits", "num_patencies", "num_atches", "num_fetches", "num_butches", "num_atchers", "num_patternche", "num_patternched", "num_atns", "num_parhes", "num_datched", "num_patrices", "num_Pations", "num_patchures", "num_Patches", "num_aptched", "num_aptchers", "num_pitions", "num_Pats", "num_patched", "num_atures", "num_pations", "num_patchctions", "num_batched", "num_parries", "num_pitchers", "num_datche", "num_patternches", "num_petchers", "num_fetctions", "num_butries", "num_patchches", "num_aptches", "num_parches", "num_aptries", "num_catges", "num_patchouts", "num_partries", "num_patchers", "num_atched", "num_patchries", "num_pitched", "num_petches", "num_patchched", "num_patchns", "num_patching", "num_patchs", "num_partatches", "num_batries", "num_catures", "num_petns"]}}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 26873, "substitutes": {"p": ["np", "w", "param", "i", "m", "c", "b", "d", "data", "P", "pointer", "jp", "ps", "port", "op", "proc", "e", "o", "pb", "process", "pool", "parent", "cp", "wp", "f", "y", "tp", "php", "t", "fp", "a", "r", "pi", "pre", "pc", "params", "g"], "info": ["slice", "w", "fo", "i", "b", "parse", "function", "image", "data", "api", "base", "ph", "config", "conf", "py", "diff", "type", "bug", "error", "check", "def", "end", "io", "id", "alias", "op", "is", "proc", "linux", "gi", "extra", "work", "http", "afi", "start", "Info", "INFO", "inf", "inner", "si", "offset", "fw", "handler", "worker", "dev", "di", "ctx", "fi", "thin", "update", "raf", "f", "j", "index", "t", "inter", "init", "r", "pi", "ignore", "hi", "ami"]}}
{"project": "FFmpeg", "commit_id": "0de1319ee0109facefe9804ffe0f0d0df36b27ad", "target": 0, "func": "static int http_start_receive_data(HTTPContext *c)\n\n{\n\n    int fd;\n\n\n\n    if (c->stream->feed_opened)\n\n        return -1;\n\n\n\n    /* Don't permit writing to this one */\n\n    if (c->stream->readonly)\n\n        return -1;\n\n\n\n    /* open feed */\n\n    fd = open(c->stream->feed_filename, O_RDWR);\n\n    if (fd < 0) {\n\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    c->feed_fd = fd;\n\n\n\n    if (c->stream->truncate) {\n\n        /* truncate feed file */\n\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n\n        ftruncate(c->feed_fd, FFM_PACKET_SIZE);\n\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n\n    } else {\n\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n\n    lseek(fd, 0, SEEK_SET);\n\n\n\n    /* init buffer input */\n\n    c->buffer_ptr = c->buffer;\n\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n\n    c->stream->feed_opened = 1;\n\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n\n    return 0;\n\n}\n", "idx": 26880, "substitutes": {"c": ["exec", "sc", "call", "cm", "k", "w", "dc", "uc", "oc", "p", "b", "anc", "i", "z", "C", "d", "enc", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "cy", "ch", "self", "rec", "u", "e", "fc", "con", "ic", "cl", "vc", "ac", "s", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "co", "sec", "lc", "ctrl", "ca", "f", "tc", "n", "cu", "t", "a", "coll", "conn", "arc", "v", "g", "r", "nc", "l", "cs", "ce", "pc"], "fd": ["md", "fen", "fed", " fid", "fe", "done", "dc", "af", "cd", "xd", "driver", "rd", "dy", "ecd", "d", "hd", "fn", "ld", "fff", "ds", "ad", "bf", "bd", "dd", "reader", "die", "db", "buf", "feed", "fc", "lf", "du", "ff", "did", "pd", "nd", "draft", "td", "dl", "fl", "wd", "handler", "FD", "wind", "fb", "fi", "fx", "cond", "ln", "cf", "fun", "f", "fs", "stream", "fa", "vd", "conn", "fp", "de", "sd", "sf", "df", "draw", "file", "dn", "pid"]}}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884, "substitutes": {"opaque": ["pacity", "opifice", "compacity", "obacity", "compifice", "opatile", "copifice", "copica", "Opifice", "Opaque", "compaque", "patile", "opica", "paque", "compica", "opacity", "Opica", "obatile", "compatile", "copaque", "obaque"], "func": ["exec", "code", "package", "lambda", "wrapper", "oc", "b", "parser", "function", "callback", "asm", "fn", "job", "Function", "cb", "bc", "wrap", "util", "proc", "self", "fc", "aux", "con", "work", "rl", "unc", "loc", "worker", "cc", "ctx", "ln", "conv", "xxx", "lc", "layer", "loop", "apply", "conn", "attr", "nc", "pc", "fun"], "f": ["fen", "fe", "w", "fo", "i", "p", "b", "m", "c", "d", "of", "rf", "x", "bf", "fm", "fr", "u", "e", "fc", "lf", "feed", "o", "ff", "fw", "handler", "fb", "fi", "cf", "fu", "h", "fun", "fs", "fa", "t", "fp", "v", "r", "g", "sf", "df", "l", "fd", "file", "F"], "line": ["Line", "server", "frame", "name", "time", "buffer", "base", "sync", "url", "ne", "lf", "el", "cl", "tick", "lines", "lin", "word", "pin", "strip", "zip", "LINE", "entry", "status", "limit", "list", "de", "row", "val", "code", "slice", "user", "liner", "c", "engine", "text", "link", "cell", "key", "path", "lane", "sl", "block", " lines", "len", "file", "byte", "d", "data", "band", "error", "db", "e", "message", "str", "err", "la", "lined", "mode", "board", "lc", "ine", "source", "lo", "stack", "header", "pos", "connection", "lock", "ze", "look", "seq", "page", "style", "pass", "write", "end", "id", "unit", "cpu", "loc", "run", "ln", "device", "comment", "nl", "route", "l"], "buf": ["bag", "exc", "batch", "frame", "wb", "pkg", "buffer", "gru", "gb", "cb", "bang", "cmd", "bridge", "lines", "fw", "ptr", "buff", "r", "desc", "ru", "code", "b", "c", "cv", "msg", "grab", "queue", "text", "filename", "port", "proc", "feed", "ff", "path", "cap", "vag", "cache", "feat", "h", "src", "block", "que", "fd", "file", "uf", "uc", "context", "data", "rb", "band", "bus", "brace", "str", "la", "box", "fi", "fb", "rx", "stack", "ha", "uber", "seq", "uno", "vec", "config", "br", "aka", "prof", "home", "loc", "ctx", "off", "loop", "conn", "runner", "v"], "bus_num": ["class_count", "bus_id", "device_id", "device_name", "bus_name", "class_num", "bus_number", "bus_loc", " bus_number", "device_loc", "class_number", " bus_id", "device_info", " bus_name", "bus_info", "bus_count", "device_num"], "addr": ["md", "ref", "wrapper", "over", "name", "pkg", "dr", "enable", "data", "en", "vr", "ad", "align", "address", "access", "dd", "error", "id", "alias", "url", "pad", "cmp", "proc", "amp", "el", "adr", "cmd", "start", "advert", "ord", "loc", "ann", "offset", "rc", "hop", "ptr", "oa", "device", "dist", "amd", "rt", "ack", "nr", "ip", "src", "conn", "host", "desc", "route", "attr", "ace", "nc", "pos", "len", "layer"], "speed": ["strength", "skip", "slice", "class", "driver", "effect", "sn", "score", "engine", "cost", "name", "quick", "time", "force", "kick", "weight", "style", "peed", "delay", "send", "type", "pass", "race", "Speed", "sync", "id", "sex", "state", "reason", "seed", "unit", "start", "gain", "spec", "offset", "spin", "mode", "sign", "grade", "order", "size", "rate", "rank", "scale", "sort", "level", "direction", "length", "dist", "source", "service", "status", "powered", "index", "slow", "performance", "power"], "device_count": ["product_count", "device_id", "device_name", "product_code", " device_id", " device_num", "driver_count", "driver_code", "device_Count", "driver_Count", "device_list", "device_code", " device_list", "driver_id", "device_num"], "class_id": ["class__name", "product_like", "class_count", "product_num", "product_count", "product_code", "class_name", "class__code", "class_num", "class__id", "classalname", "class_like", "class_pid", "class_code", "product_pid", "classallike", "class_ids", "class__ids", "product_ids", "classalid", "classalcount"], "product_id": ["product_number", "product_type", "product_no", " product_number", "productappids", " product_type", "class_name", "productapppid", " product_kid", "class_pid", "productapptype", "productappname", "product_pid", " product_no", "product_kid", "productappno", "class_ids", "product_ids", "productappid"], "vendor_id": ["vendoreeid", "vendor_type", "vendorPoolid", "vendor_ids", "vender_source", "vendor__ids", "vendor_side", "vendorPoolname", "vender_id", "vendor__id", "vender_type", "vendor__ad", "vendoreelength", "vendor_source", "vendor_name", "vendor__name", "vender_name", "vender_ids", "vendor_ad", "vendorPoolids", "vendoreename", "vendorPoolside", "vender_side", "vendoreetype", "vendor_length", "vender_length"], "product_name": ["product_number", "product_list", "product_type", " product_number", " product_type", "productactype", "productaclist", " product_list", "productacid", "productacname"]}}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "substitutes": {"oc": ["acc", "oca", "oci", "cca", "uc", "ogg", "anc", "c", "toc", "ob", "isc", "ec", "oper", "oco", "soc", "om", "bc", "mac", "ocr", "oid", "OC", "fc", "o", "unc", "loc", "voc", "ucc", "mc", "rc", "roc", "alloc", "co", "comp", "aco", "ocol", "usc", "coll", "org", "nc", "ac", "pc", "ok"], "data": ["load", "acc", "Data", "cm", "d", "config", "ds", "dd", "rec", "raw", "input", "dat", "dev", "board", "ci", "rc", "cache", "co", "device", "tc", "da", "src", "DATA", "func", "ac"], "pcc": ["facc", " pca", "ppcf", "Pcci", "ppcc", "cpuc", "fcca", "cpca", "ccf", "cpcci", "lpCC", "Pcc", "ppacc", "pca", " puc", "lpec", "prc", " prc", " pcca", "Pca", "PCC", "lprc", "puc", "pxc", "pacc", "lpcci", "cpcca", " pec", "pec", " pacc", "pcca", "lpcc", "cacc", "lpxc", "fcc", "Pcca", "ccc", "cpCC", " pxc", "pprc", "Pcf", "Pxc", "crc", " pCC", "Prc", " pcf", "fCC", "Pacc", "pcci", "lpcf", "Puc", "pcf", "Pec", "pCC", "cpcc", "lpcca"], "cc": ["acc", "sc", "code", "cm", "bec", "ctl", "cca", "uc", "cd", "kk", "anc", "c", "pg", "bb", "cci", "xc", "ec", "client", "cur", "config", "ect", "cus", "ct", "bc", "PC", "ce", "mac", "self", "cmp", "ee", "fc", "cell", "con", "cast", "cmd", "cl", "vc", " gcc", "cel", "CC", "ctx", "ci", "ucc", "cf", "mc", "rc", "cache", "co", "cn", "inc", "ga", "BC", "lc", "control", "ctrl", "comp", "gg", "ca", "tc", "go", "cu", "RC", "conn", "ck", "nc", "cs", "ac", "pc"], "dc": ["acc", "sc", "DC", "cca", "uc", "cd", "director", "auc", "c", "d", "cci", "doc", "ec", "ds", "cr", "bc", "mac", "db", "fc", "vc", "cdn", "disc", "di", "dt", "cf", "mc", "ga", "rc", "co", "inc", "cache", "design", "lc", "ca", "tc", "da", "conn", "cu", "duc", "ck", "df", "nc", "ac", "pc"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "substitutes": {"vc": ["dc", "ll", "c", "cv", "vs", "cci", "xc", "ec", "api", "vec", "vr", "ant", "nv", "vt", "ct", "bc", "cy", "util", "vv", "nec", "wx", "fc", "cs", "iw", "ic", "vid", "rl", "loc", "wl", "voc", "cli", "wd", "cc", "ku", "ci", "client", "cf", "cn", "rc", "ou", "ctx", "ga", "vm", "cp", "lc", "serv", "ls", "rt", "lv", "service", "vd", "cu", "conn", "fp", "VC", "nc", "sv", "ce", "pc", "dn"]}}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935, "substitutes": {"env": ["exec", "code", "args", "console", "np", "er", "w", "scope", "exc", "ass", "engine", "server", "context", "manager", "enable", "vs", "enc", "queue", "ec", "me", "en", "config", "conf", "export", "gr", "ce", "state", "inst", "ev", "port", "end", "ea", "environment", "proc", "db", "e", "el", "err", "enter", "cal", "ctx", "cp", "cf", "cache", "window", "conn", "core", "v", "event", "eng"]}}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "substitutes": {"env": ["exec", "her", "exc", "server", "pg", "shell", "enc", "vs", "chal", "eur", "gear", "export", "inet", "ne", "dev", "uv", "core", "nc", "et", "obj", "engine", "cv", "ec", "qt", "en", "Environment", "jp", "address", "proc", "ception", "password", "dh", "enter", "energy", "eni", "erv", "forge", "dep", "stage", "enh", "que", "args", "np", "console", "context", "inv", "eve", "conf", "global", "loader", "ev", "ea", "profile", "db", "e", "cdn", "output", "exe", "here", "req", "nw", "init", "org", "anne", "cot", "img", "config", "vt", "end", "environment", "site", "esi", "dat", "viron", "ctx", "eu", "vm", "osc", "ext", "conn", "net", "v", "reset", "eng"], "intno": ["indnumber", " intdo", "intNO", "intnum", "pointnum", "initnum", "structnumber", "integernumber", "intnr", "integerno", " inteno", "pointno", "integerdo", "structna", "INTnumber", "indNO", " intnum", "argname", "structno", "idNO", "extno", "argnum", "extdo", "intNo", "uintNO", "Intnos", "pointname", "extnumber", "initno", "intnos", "INTnr", " intna", " intnot", "integernum", "Intno", "indnos", "intnot", "integereno", "INTno", " intnr", "argnot", "idnumber", " intNO", "structNo", "intna", "initNO", " intnos", "indnum", "intdo", "idnos", "extnum", "intname", " intnumber", "idno", "structnos", "IntNo", "intnumber", "argno", "indno", "uinteno", " intNo", "pointNO", "uintno", "pointnot", "INTNo", "inteno", "integerNO", "structnr", " intname", "Intna", "uintnum"], "is_int": ["is_ip", " is_integer", "is_INT", "as_nt", "is6nt", "as_inter", " is_nt", "as_INT", "is6inner", "as_int", "is6ci", "is_ci", "is_inner", "is_integer", " is_ip", "as_ci", "is_nt", "as_inner", "is_inter", "is6int"], "error_code": ["error_size", " error_mode", "errorwavemode", " error_size", "error_codes", " error_codes", "errorwavecode", "error_mode", "errorwavesize", "errorwavecodes"], "next_eip": ["next_peIP", "next_feof", "next_eep", "next_seep", "next_feIP", "next_peof", "next_eeips", "next_peip", "next_seIP", "next_eIP", "next_eeIP", "next_eeep", "next_eips", "next_feep", "next_feip", "next_seip", "next_peep", "next_peips", "next_seof", "next_eof", "next_eeip", "next_seips"], "is_hw": ["isAhw", " is_ht", "isAiw", "isAfw", "is_ht", "is_iw", " is_fw", "is_ether", "isAether", "is_rw", " is_iw", " is_rw", " is_ether", "is_fw"], "dt": ["txt", "tk", "cm", "np", "dc", "ta", "dr", "tm", "qt", "ds", "tz", "jp", "vt", "ct", "tif", "ea", "db", "e", "td", "tu", "adr", "dh", "dat", "tmp", "cmd", "mt", "tick", "tt", "ctx", "target", "elt", "rt", "tn", "uv", "wt", "tc", "tp", "dm", "t", "DT", "fp", "dq", "bt", "utm", "ut", "kt"], "ptr": ["ref", "seq", "code", "slice", "fe", "obj", " pointer", "p", "pt", "dr", "cur", "br", "pointer", "jp", "pointers", "address", "inst", "port", "tr", "proc", "pad", "cmp", "eger", "sp", "td", "str", "start", "loc", "rot", "ctr", "alloc", "req", "Ptr", "cache", "addr", "rc", "length", "rt", "count", "ext", "prot", "index", "reg", "fp", "src", "memory", "attr", "reset", "pos", "len"], "ssp": ["csm", "sslp", "csl", "ssm", "cssm", "cssl", "assm", "cssp", "asslp", "csp", "csslp", "cslp", "ssl", "assp", "assl"], "type": ["ref", "code", "call", "slice", "class", "info", "p", "i", "name", "x", "test", "action", "base", "weight", "style", "var", "label", "py", "pe", "address", "types", "error", "version", "state", "col", "port", "id", "kind", "op", "method", "typ", "key", "unit", "o", "rel", "bit", "loc", "Type", "parent", "like", "size", "sort", "scale", "shape", "ype", "length", "part", "count", "TYPE", "y", "value", "ip", "t", "null", "map", "ty", "block", "pos", "mark", "val", "format", "layer"], "dpl": ["fPL", "dcPL", " dfl", "dcfl", " dPL", "fpl", "dcpl", "ffl", "fsl", "dsl", " dsl", "dPL", "dcsl", "dfl"], "selector": ["constructors", "constructor", "processor", "constructur", "selectory", "processur", "electur", "processory", "selectur", "electors", "constructory", "elector", "processors", "selectors", "electory"], "ss_dpl": ["ss_rdll", "ss_rdpe", "ss_dbl", "ss_rdpl", "ss_dll", "ss_fpe", "ss_rdbl", "ss_ppl", "ss_dpe", "ss_fll", "ss_pll", "ss_fbl", "ss_pbl", "ss_fpl", "ss_ppe"], "cpl": ["ctpl", "cPL", "xcpy", " cps", "ctpy", "xcps", "cpy", " cPL", " cpy", "xcpl", "ctPL", "ctps", "cps", "xcPL"], "has_error_code": ["has_error_call", "has_active_count", "has_err_codes", "has_active_size", "has_error_codes", "has_errorfulcode", "has_ror_done", "has_errorfulsize", "has_active_code", "has_error64call", "has_error_size", "has_errorfulclass", "has_error_done", "has_error64code", "has_errorifcode", "has_error_class", "has_ror_count", "has_activeureclass", "has_ror_codes", "has_errorureclass", "has_error64size", "has_errorifcodes", "has_err_desc", "has_error64codes", "has_error_count", "has_err_error", "has_error_error", "has_errorifdesc", "has_erroruredone", "has_activeuresize", "has_ror_size", "has_errorurecall", "has_errorfulcount", "has_active_class", "has_errorurecode", "has_erroruresize", "has_activeurecount", "has_erroriferror", "has_activeurecode", "has_error_desc", "has_err_code", "has_ror_code", "has_ror_call", "has_errorurecount"], "new_stack": ["new__buffer", "raw__stack", "new_trace", "raw__buffer", "new_buffer", "raw__window", "new__trace", "new_window", "newlwindow", "new__stack", "newvalstack", "newlbuffer", "raw_stack", "newvaltrace", "newvalwindow", "raw_trace", "newlstack", "raw__trace", "raw_window", "newltrace", "new__window", "newvalbuffer", "raw_buffer"], "shift": ["skip", "seq", "slice", "pop", "cost", "sum", "align", "weight", "address", "Shift", "error", "push", "cmp", "seed", "extra", "ff", "small", "hift", "ctr", "scale", "shape", "sup", "dist", "slave", "count", "pull", "ip", "index", "init", "ind", "block", "pos", "sh"], "e1": ["p3", "e9", "eone", "ec2", "E3", "ec1", "ae3", "oe1", "oe32", " e3", "E1", "p1", "E6", "ae1", "Eone", "oe2", "E2", "e3", "ae2", "p2", "econe", "ec9", "oe3", " e32", "e6", " e6", " eone", "ae32", " e9", "E9", "p6", "e32"], "e2": ["ea4", " eTwo", " e4", "ee1", "eeTwo", "ea2", " e8", "ea1", "ee4", "E4", "E3", "ea8", "ee2", "E8", "E1", "E32", "p1", " e3", "E6", "ea6", "e4", "E2", "e3", "p2", "p8", " e32", "ee3", "e6", " e6", "eTwo", "ETwo", "ee32", "ee8", "e8", "e32"], "offset": ["seq", "skip", "slice", "adjust", "position", "align", "address", "error", "op", "alias", "sp", "padding", "loc", "slot", "order", "size", "ip", "index", "pos", "len"], "esp": ["yp", "esc", "temp", "pp", "asp", "sk", "ep", "np", "slice", "ss", "sn", "parser", "sw", "ism", "py", "eff", "sg", "css", "eps", "expr", "rss", "sp", "esi", "ef", "eb", "cp", "sb", "gp", "addr", "sup", "ext", "lv", "xp", "arp", "resp", "ace", "isp"], "old_eip": ["old_eeIP", "old_aeis", "old_edIP", "old_peis", "old_seep", "old_eeep", "old_eeips", "old_eIP", "old_eeid", "old_edis", "old_aeip", "old_seid", "old_peid", "old_edip", "old_seIP", "old_peIP", "old_eis", "old_eid", "old_eips", "old_peip", "old_edid", "old_aeIP", "old_seip", "old_aeid", "old_eep", "old_peep", "old_seips", "old_eeip", "old_peips"], "sp_mask": ["ss_mask", "ss_delay", "ss_map", "ss_ask", "sp_ask", "sp_map", "sp_delay"], "mask": ["args", "class", "info", "flag", "flags", "filter", "dr", "data", "fix", "weight", "sum", "bug", "op", "ask", "alias", "depth", "allow", "key", "patch", "arr", "max", "zero", "bit", "Mask", "group", "sign", "scale", "shape", "field", "scan", "asks", "count", "bits", "pull", "index", "header", "match", "map", "pack", "block", "ace", "mark", "ph", "lock"]}}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945, "substitutes": {"env": ["exec", "gui", "code", "ep", "args", "np", "console", "er", "scope", "exc", "app", "server", "engine", "empty", "context", "cv", "enable", "enc", "qa", "queue", "ec", "api", "en", "config", "conf", "export", "loader", "ev", "end", "ea", "environment", "ne", "db", "e", "iter", "site", "el", "err", "enter", "viron", "ctx", "here", "eu", "size", "client", "eni", "cache", "req", "vm", "window", "f", "stage", "ext", "conn", "core", "init", "event", " environment", "v", "nc", "que", "eng"]}}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 26946, "substitutes": {"cpu": ["CPU", "processor", "socket", "kernel", "console", "chip", "auc", "c", "module", "gru", "clock", "component", "config", "prof", "loader", "platform", "proc", "linux", "gpu", "cmp", "boot", "hp", "hw", "prem", "GPU", "process", "bench", "cli", "pool", "cow", "cp", "cn", "fi", "gp", "roc", "cache", "eni", "ctx", "vm", " CPU", "lc", "pai", "CP", "appa", "computer", "cpp", "conn", "runner", "core", "consumer", "pu", "uci", "que", "pc", "cgi"], "hash": ["use", "node", "secret", "kernel", "user", "chip", "empty", "image", "module", "history", "enc", "queue", "base", "sum", "address", "counter", "version", "global", "url", "profile", "depth", "password", "path", "session", "hz", "pool", "copy", "number", "cache", "block", "addr", "auth", "array", "h", "handle", "reset", "count", "index", "host", "header", "root", "memory", "Hash", "ash", "file"], "secondary": ["complete", "esc", "remote", "secret", "primary", "international", "server", "protection", "exclusive", "attribute", "ical", "foreign", "export", "confirmed", "global", "optional", "general", "security", "second", "south", "protected", "extra", "message", "initial", "set", "small", "sub", "offset", "binary", " second", "size", "seconds", "sec", "external", "special", "negative", "transfer", "lower", "Second", "ssl", "final"], "ptem": ["montem", "aptem", "uptem", "monte", "pteman", "apteman", "pe", "pem", "pointe", "pointemi", "monteme", "montemi", "apte", "upte", "upteme", "peman", "apteme", "pointeme", "pemi", "peme", "ptemi", "upteman", "pointem", "pteme"], "pte": ["patche", "empte", "PTe", "portem", "ctem", "ptede", "octem", "PTec", "ptee", "petec", "octee", "ctec", "octe", "emptel", "patchee", "ctee", "patchel", "octede", "patchem", "cte", "portel", "pete", "ptel", "petee", "petem", "ptec", "ctede", "PTee", "portee", "porte", "PTede", "emptem", "PTem", "emptee"], "env": ["args", "np", "scope", "exc", "engine", "context", "enc", "ec", "en", "config", "Environment", "conf", "style", "chal", "opt", "eur", "state", "dict", "ev", "ea", "ani", "environment", "ne", "visor", "profile", "db", "e", "cfg", "err", "dat", "ef", "estate", "viron", "agent", "eu", "energy", "eni", "cache", "oa", "vm", "esp", "forge", "ext", "stage", "conn", "net", "desc", "header", "v", " environment", "settings", "equ", "eng"], "i": ["abi", "k", "ski", "yi", "p", "b", "z", "c", "m", "d", "ix", "x", "adi", "ti", "mi", "ei", "qi", "phi", "it", "ri", "io", "id", "ui", "u", "e", "key", "li", "gi", "o", "min", "zi", "multi", "ji", "start", "xi", "uri", "esi", "ii", "di", "si", "bi", "ini", "ai", "ci", "fi", "eni", "vi", "lc", "h", "I", "f", "mini", "oi", "n", "ip", "index", "t", "j", "y", "v", "iu", "mu", "pi", "ind", "l"], "token": ["chain", "fen", "element", "socket", "ski", "date", "callback", "module", "buffer", "request", "character", "sync", "url", "seed", "icon", "tick", "number", "note", "uu", "username", "service", "cookie", "document", "random", "processor", "user", "ti", "prefix", "key", "password", "resource", "path", "binary", "target", "eni", "response", "cache", "auth", "timeout", "notice", "rule", "attr", "len", "temp", "node", "byte", "scope", "function", "data", " Token", "reference", "KEN", "track", "uri", "session", "future", "fi", "setup", "tool", "Token", "source", "wt", "header", "connection", "tag", "lock", "ok", "stop", "secret", "info", "theme", "aa", "fn", "api", "config", "ticket", "o", "ctx", "channel", "device", "index", "result", "oken"], "pte0": ["ptee7", "ctee0", "pte7", "pti10", "peti0", "cte00", "ptele50", "ptee00", "cte25", "pte080", "ptoe10", "pte80", "pte10", "pete80", "pti0", "cti0", "pto10", "pte2", "ptee192", "ptoe25", "ptee1", "ptE1", "cte2", "cte192", "cte0", "pto6", "pte192", "pto20", "pti50", "ctee1", "ptea6", "pte18", "ctee7", "pte6", "ptee20", "ctee25", "ptele0", "pto80", "pto18", "cte50", "ptee2", "pte50", "pete18", "ptE0", "ctee6", "ptoe192", "ptoe00", "ptE00", "ptele1", "ptoe080", "ctee00", "ptee25", "peti18", "pter1", "ctee080", "pteur192", "pti7", "ptea2", "ptoe2", "ptoe18", "pte20", "pte25", "ptoe0", "pto1", "ctee20", "cte6", "ptee50", "cte080", "ctee50", "ctee192", "ptee6", "ptee080", "pti80", "ptE6", "ptE25", "pter0", "ptoe80", "ptoe1", "cte20", "cte7", "pete0", "pteur0", "ptE20", "ptoe6", "cte1", "ctee2", "ptea0", "pti1", "pti18", "ptee0", "peti80", "peti10", "pteur080", "pto0", "pete10", "pteur1", "ptea1", "pte00", "ptele7", "cti1"], "pte1": ["pteeOne", "pteye1001", "ctee0", "ptec1", "pteone", "ptoe1001", "pteaone", "ptoe31", "pointoe0", "pteye0", "pointe100", "cte1", "ptec31", "ctee1", "ptea6", "ctee1001", "ptee31", "pte6", "ptea0", "pteOne", "ptec6", "pte1001", "ptoeOne", "ptc0", "ptoe0", "pte31", "ptee0", "pteyeOne", "ptcone", "cteeOne", "pointoe100", "cteeone", "cte1001", "cte6", "pteeone", "ptea1", "pointe1", "pointe0", "ptc1", "pointe31", "ptee6", "pointoe31", "ptec100", "ptee100", "pte100", "ptoe100", "cteone", "ptee1", "ctee6", "pteye1", "ptec0", "ptoe1", "ptee1001", "cte0", "cteOne", "pointoe1"], "pte_index": ["pti__index", "pte2index", "ptee_ini", "ptae__index", "pte2inc", "pte__i", "pte2i", "ptee_index", "pte__offset", "pte_align", "pte__id", "pte_value", "pti_id", "pte__index", "pte0i", "ptee_width", "pte_width", "pte__inc", "pte_inc", "pti_i", "pte_i", "pte0inc", "pte_ini", "ptee_align", "ptae_offset", "pte_id", "ptae__value", "pte2id", "pti__inc", "ptae__offset", "pti_index", "ptee_offset", "pte_offset", "ptae_index", "pti__i", "pte0index", "pti__id", "ptae_value", "pte0id", "pte__ini", "pte__value", "pti_inc"]}}
{"project": "FFmpeg", "commit_id": "39f7620d76c7a133535ed7a535f7a74fefa6e435", "target": 0, "func": "static av_cold int dcadec_init(AVCodecContext *avctx)\n\n{\n\n    DCAContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->core.avctx = avctx;\n\n    s->exss.avctx = avctx;\n\n    s->xll.avctx = avctx;\n\n    s->lbr.avctx = avctx;\n\n\n\n    ff_dca_init_vlcs();\n\n\n\n    if (ff_dca_core_init(&s->core) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (ff_dca_lbr_init(&s->lbr) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ff_dcadsp_init(&s->dcadsp);\n\n    s->core.dcadsp = &s->dcadsp;\n\n    s->xll.dcadsp = &s->dcadsp;\n\n    s->lbr.dcadsp = &s->dcadsp;\n\n\n\n    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);\n\n\n\n    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {\n\n    case 0:\n\n        s->request_channel_layout = 0;\n\n        break;\n\n    case AV_CH_LAYOUT_STEREO:\n\n    case AV_CH_LAYOUT_STEREO_DOWNMIX:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT0:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT1:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_WARNING, \"Invalid request_channel_layout\\n\");\n\n        break;\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n\n    avctx->bits_per_raw_sample = 24;\n\n\n\n    return 0;\n\n}\n", "idx": 26947, "substitutes": {"avctx": ["wavcu", "navcontext", "wavcmp", "avcontext", "afcit", "afcontext", "AVcb", "avectx", "ajctx", "ajcmp", "ajcmd", "avcn", "wavctx", "airctx", "afxc", "avcci", "aircontext", "avecmp", "aucu", "avecp", "AVcontext", "avcu", "avalloc", "AVconfig", " avcn", "avcit", "AVloc", "avecmd", "avalcontext", "afcn", "afctx", "avconfig", "avalctx", "afci", "avloc", "ajcit", "aveloc", "AVcas", "AVctx", " avcci", "navcit", "avxc", "avci", "ajcb", "avcb", "auxc", "avecb", "avcf", "avcp", "avalcf", "AVcmd", "AVcmp", "avalcmp", "avecontext", " avcit", "avecci", "AVci", "avcmp", "AVcu", "aucontext", "avalcb", "avecu", "wavcontext", "auctx", "afcci", "aircu", "navcmp", " avxc", "avconn", "AVcit", "AVcp", "afconn", "ajcontext", "avecf", "ajcas", "airci", "AVcf", "auconn", "ajcp", "aveconfig", "avecn", "afcu", " avcu", "aveconn", " avconn", "navloc", " avcontext", "navcas", "avcas", "avcmd", "navctx", "afcmp", "afconfig"], "s": ["sys", "w", "ns", "ts", "vs", "sq", "ps", "secondary", "states", "sync", "self", "bs", "u", "es", "gs", "sym", "f", "service", "js", "n", "qs", "fs", "t", "r", "ops", "S", "p", "m", "b", "c", "sum", "ds", "ans", "us", "ins", "su", "is", "sets", "spec", "aws", "services", "h", "sl", "its", "side", "g", "rs", "ses", "args", "this", "ss", "features", "d", "data", "conf", "sg", "ks", "e", "session", "hs", "sb", "sec", "ssl", "cs", "sv", "i", "o", "si", "os", "as", "ls", "y", "a", "v"]}}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) {\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t i, j;\n\n\n\n    vc->mapping_count=get_bits(gb, 6)+1;\n\n    vc->mappings=(vorbis_mapping *)av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));\n\n\n\n    AV_DEBUG(\" There are %d mappings. \\n\", vc->mapping_count);\n\n\n\n    for(i=0;i<vc->mapping_count;++i) {\n\n        vorbis_mapping *mapping_setup=&vc->mappings[i];\n\n\n\n        if (get_bits(gb, 16)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\");\n\n            return 1;\n\n        }\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->submaps=get_bits(gb, 4)+1;\n\n        } else {\n\n            mapping_setup->submaps=1;\n\n        }\n\n\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->coupling_steps=get_bits(gb, 8)+1;\n\n            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            for(j=0;j<mapping_setup->coupling_steps;++j) {\n\n                mapping_setup->magnitude[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                // FIXME: sanity checks\n\n            }\n\n        } else {\n\n            mapping_setup->coupling_steps=0;\n\n        }\n\n\n\n        AV_DEBUG(\"   %d mapping coupling steps: %d \\n\", i, mapping_setup->coupling_steps);\n\n\n\n        if(get_bits(gb, 2)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%d. mapping setup data invalid. \\n\", i);\n\n            return 1; // following spec.\n\n        }\n\n\n\n        if (mapping_setup->submaps>1) {\n\n            mapping_setup->mux=(uint_fast8_t *)av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));\n\n            for(j=0;j<vc->audio_channels;++j) {\n\n                mapping_setup->mux[j]=get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        for(j=0;j<mapping_setup->submaps;++j) {\n\n            skip_bits(gb, 8); // FIXME check?\n\n            mapping_setup->submap_floor[j]=get_bits(gb, 8);\n\n            mapping_setup->submap_residue[j]=get_bits(gb, 8);\n\n\n\n            AV_DEBUG(\"   %d mapping %d submap : floor %d, residue %d \\n\", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26971, "substitutes": {"vc": ["gui", "sys", "dc", "ft", "ll", "c", "cit", "cat", "cv", "bb", "api", "xc", "qt", "cur", "ant", "vr", "nv", "config", "vt", "bc", "util", "sync", "vv", "plugin", "wx", "cs", "fc", "hw", "iw", "ic", "input", "ac", "http", "wcs", "fw", "cli", "wl", "wd", "cc", "ctx", "ci", "client", "cf", "ou", "rc", "ga", "ku", "cache", "vm", "iv", "lc", "wp", "ctrl", "serv", "auth", "gg", "rt", "uv", "lv", "service", "qs", "vd", "cu", "v", "VC", "vp", "sv", "voc", "dk", "dn"], "gb": ["wb", "pg", "lb", "usb", "gru", "gom", "cb", "gs", "bridge", "nb", "lib", "ga", "rg", "game", "uv", "gc", "gt", "vg", "b", "bo", "gin", "cv", "bn", "bb", "storage", "gpu", "mb", "lane", "binary", "ko", "ci", "gp", "git", "gio", "yg", "bm", "pc", "g", "gram", "gnu", "rb", "gam", "gz", "gy", "sg", "db", "cfg", "gae", "eb", "gd", "mode", "cc", "sb", "lc", "ogg", "hd", "api", "metadata", "kg", "bf", "bc", "kb", "hub", "hw", "phy", "multi", "ctx", "GB", "rc", "gh", "gg", "agg", "bg", "gm", "ui", "cgi"], "i": ["abi", "k", "z", "yi", "p", "m", "b", "c", "ie", "info", "d", "ix", "x", "ti", "mi", "phi", "qi", "it", "ri", "io", "id", "is", "u", "key", "gi", "li", "ji", "zi", "multi", "xi", "uri", "bi", "ii", "si", "ai", "di", "ini", "ni", "ik", "ci", "fi", "eni", "f", "ki", "I", "oi", "n", "index", "ip", "y", "count", "v", "iu", "ind", "pi", "ui", "l"], "j": ["obj", "jit", "k", "z", "ie", "p", "m", "b", "uj", "adj", "d", "kj", "x", "job", "ld", "jo", "jp", "aj", "ch", "jj", "fr", "jam", "key", "bj", "sp", "e", "ji", "o", "li", "el", "xi", "jc", "si", "ij", "jet", "oj", "note", "f", "y", "jl", "js", "n", "index", "t", "v", "J", "pos", "l", "dj", "ja", "g"], "mapping_setup": ["mappingerhandle", "mapping_config", "mippingallsite", "macing_setup", "moding_setup", "mappingtroot", "mapper_setup", "mappingersetup", "mappingjlayout", "mappingacsetup", "mapping_database", "matchingfinstall", "mashing_set", "mapping_site", "mapping_connect", "mappingerset", "moding_set", "mipping_scope", "mapping___setup", "mapping_spec", "mappingjreset", "mappings_boot", "mappingtsetup", "mappings_install", "maming_scale", "mappingpsetup", "mapping_init", "matching_install", "mappingfsetup", "maming_database", "mapping_error", "mappingersett", "mappingerconnect", "matingfsite", "mappingtboot", "mapping_sett", "mating_site", "mapping_set", "mappingallscope", "mipping_site", "mappingallboot", "mappingersync", "matching_spec", "mappingallsetup", "mappingsallsetup", "mappingpspec", "mappingfsite", "mippingallsetup", "mapped_error", "mappingpset", "matchingfsetup", "mating_init", "maming_Setup", "mappingMSetup", "mappingMsetup", "mapping___set", "mappingfspec", "mashing_setup", "mating_install", "mapping_root", "mappingfsync", "mashing_sync", "mappingtconfig", "macing_handle", "macing_reset", "mapped_setup", "mappingMscale", "mapping___spec", "mapper_boot", "mappingpinstall", "mappings_setup", "mappingallsite", "moding_reset", "mappingallinstall", "matingfinstall", "mapping_boot", "mapper_config", "matching_setup", "mippingallscope", "mapping_layout", "mappingjset", "mapper_connect", "mapping_scope", "mippingallset", "mappingflayout", "mashing_layout", "mappingallset", "mapping_scale", "mapper_set", "mipping_set", "minding_Setup", "mappingplayout", "mappingerspec", "matchingfspec", "mappingsallinstall", "mappingjsetup", "macing_sett", "mappingpsync", "minding_set", "mappingerscope", "mappingacscale", "mappingerreset", "mapping_reset", "mapping_sync", "mappingfinstall", "mapping_handle", "mappingfinit", "mapped_scale", "mapper_root", "mipping_setup", "minding_create", "matingfinit", "mappingfset", "mappingMdatabase", "mappingsallboot", "minding_setup", "mapping_create", "mapping___connect", "mapper_reset", "moding_sync", "mapper_layout", "mappingersite", "mapping_install", "maming_setup", "mating_setup", "mapping_Setup", "matingfsetup", "mapper_spec", "mappingacerror"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987, "substitutes": {"dev": ["temp", "w", "info", "app", "d", "data", "var", "ad", "conf", "pub", "def", "priv", "dd", "ch", "ev", "die", "serial", "bus", "proc", "prom", "private", "link", "mem", "hw", "grad", "gd", "device", "mod", "pro", "conn", "de", "devices", "Dev", "rad", "od", "sd", "ver", "reg", "attr", "cam"], "taddr": ["Taddress", " twork", " tmac", "vaddress", "tgrad", "Tpointer", "lwork", "tpointer", " tpointer", "tmac", "twork", " taddress", "lpointer", "vaddr", " tgrad", "laddr", "Tmac", "laddress", "vmac", "Taddr", "Twork", "taddress", "vgrad", "Tgrad"], "val": ["ref", "byte", "db", "bin", "p", "b", "pt", "VAL", "x", "enc", "data", "eval", "test", "base", "py", "fail", "bl", "def", "write", "all", "vals", "aval", "al", "ee", "key", "unit", "bal", "el", "arr", "grad", "gold", "valid", "fee", "fl", "cal", "slot", "sel", "cond", "sec", "arg", "Val", "count", "value", "index", "alt", "v", "sl", "pre", "tx", "len", "vol"]}}
{"project": "FFmpeg", "commit_id": "066fff755a5d8edc660c010ddb08474d208eeade", "target": 0, "func": "static void vp6_parse_coeff_models(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    VP56Model *model = s->modelp;\n\n    int def_prob[11];\n\n    int node, cg, ctx, pos;\n\n    int ct;    /* code type */\n\n    int pt;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    memset(def_prob, 0x80, sizeof(def_prob));\n\n\n\n    for (pt=0; pt<2; pt++)\n\n        for (node=0; node<11; node++)\n\n            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {\n\n                def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            }\n\n\n\n    if (vp56_rac_get(c)) {\n\n        for (pos=1; pos<64; pos++)\n\n            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))\n\n                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);\n\n        vp6_coeff_order_table_init(s);\n\n    }\n\n\n\n    for (cg=0; cg<2; cg++)\n\n        for (node=0; node<14; node++)\n\n            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))\n\n                model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);\n\n\n\n    for (ct=0; ct<3; ct++)\n\n        for (pt=0; pt<2; pt++)\n\n            for (cg=0; cg<6; cg++)\n\n                for (node=0; node<11; node++)\n\n                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {\n\n                        def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    }\n\n\n\n    if (s->use_huffman) {\n\n        for (pt=0; pt<2; pt++) {\n\n            vp6_build_huff_tree(s, model->coeff_dccv[pt],\n\n                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);\n\n            vp6_build_huff_tree(s, model->coeff_runv[pt],\n\n                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);\n\n            for (ct=0; ct<3; ct++)\n\n                for (cg = 0; cg < 6; cg++)\n\n                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n\n                                        vp6_huff_coeff_map, 12,\n\n                                        &s->ract_vlc[pt][ct][cg]);\n\n        }\n\n        memset(s->nb_null, 0, sizeof(s->nb_null));\n\n    } else {\n\n    /* coeff_dcct is a linear combination of coeff_dccv */\n\n    for (pt=0; pt<2; pt++)\n\n        for (ctx=0; ctx<3; ctx++)\n\n            for (node=0; node<5; node++)\n\n                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);\n\n    }\n\n}\n", "idx": 26988, "substitutes": {"s": ["S", "space", "sc", "ses", "models", "sys", "args", "ss", "p", "m", "b", "i", "ns", "d", "se", "ts", "sq", "config", "conf", "ps", "sg", "ks", "states", "self", "su", "u", "e", "es", "set", "session", "spec", "sv", "si", "os", "sb", "services", "sec", "series", "serv", "f", "fs", "service", "js", "n", "qs", "src", "t", "a", "v", "sl", "r", "sf", "settings", "ssl", "cs", "params", "g"], "c": ["chain", "sc", "code", "cm", "k", "dc", "uc", "z", "p", "m", "b", "cat", "C", "d", "x", "ec", "config", "cus", "center", "cy", "cycle", "ch", "u", "e", "cell", "con", "cl", "ic", "vc", "ac", "controller", "cc", "ci", "cn", "cf", "mc", "roc", "cache", "channel", "com", "rc", "lc", "comp", "h", "ca", "f", "n", "cu", "t", "coll", "q", "arc", "v", "r", "nc", "l", "cs", "ce", "pc", "g"], "model": ["gu", "gui", "models", "code", "package", "body", "scope", "ml", "p", "m", "server", "Model", "engine", "image", "manager", "template", "module", "me", "data", "base", "storage", "style", "config", "conf", "member", "type", "global", "form", "instance", "util", "store", "method", "db", "cell", "message", "command", "session", "lib", "mode", "cal", "parent", "copy", "client", "record", "view", "ga", "xml", "ca", "f", "comment", "sim", "service", "mm", "bm", "coll", "core", "v", "builder", "query", "block", "document"], "def_prob": ["def_probs", "def_prof", "def_funbs", "defedprobs", "def_priber", "def_Probe", "def_Probi", "defedprobe", "def_prem", "def_cober", "defedprober", "def_Probs", "def_funb", "def_defb", "def_Prob", "def_perm", "def_prober", "def_cobs", "def_propb", "def_propbs", "def_pribe", "def_defbe", "def_proc", "def_prib", "def_cobi", "def_perf", "def_probi", "def_propp", "def_perbs", "defedcobs", "def_perb", "def_defbs", "def_cob", "defedcobe", "def_preb", "def_propf", "def_prebs", "def_prep", "def_funp", "def_Prop", "def_perbe", "def_probe", "def_propm", "def_defp", "defedcob", "defedprob", "def_prop", "defedcober", "def_funbe", "def_prebe", "def_prom", "def_prec", "def_pref", "def_Proc", "def_cobe", "def_perc", "def_pribs"], "node": ["ref", "call", "nm", "pn", "name", "card", "callback", "enc", "num", "ne", "seed", "cmd", "nd", "set", "object", "nt", "edge", "word", "coord", "hop", "note", "part", "n", "row", "core", "nc", "dn", "layer", "remote", "day", "anc", "msg", "en", "col", "live", "op", "Node", "line", "point", "cell", "path", "ko", "wd", "custom", "shape", "stage", "src", "od", "event", "block", "len", "pc", "load", "gen", "d", "no", "component", "nn", "global", "cdn", "peer", "session", "anch", "parent", "cp", "ng", "source", "nw", "na", "host", "full", "post", "location", "tree", "cod", "package", "dc", "page", "position", "image", "fn", "cur", "config", "type", "end", "id", "depth", "site", "loc", "ni", "local", "device", "slave", "child", "index", "conn", "route", "ode", "dest"], "cg": [" cgs", "ecgin", "pg", "Cgh", "acga", "ncgs", "Cgu", " cgh", "ecgen", "Cg", "lcgs", "cgn", "ngu", "ecgy", "lcgn", "acg", " cmg", "ngm", "pgm", "pgen", "ngn", "lcga", "cachegu", "cachegs", "ucgu", "lcg", " cgi", "ecgn", "Cgn", "Cgi", "ncgy", "lcgu", "Cga", "acgn", "cgin", "ucg", "cgh", " cgy", "acmg", "pga", "lcgi", "ecg", "cgs", " cgc", "pgn", "pgu", "ncgin", "ucgi", "ncg", "cgp", "rcgs", "pgp", "rcgi", "cgm", " cgm", "rcg", "cgy", "ecgs", "ucgh", "pmg", "ng", "ngc", "cmg", "nmg", " cgen", " cgn", "cga", " cga", "cgc", "acgi", "acgu", "cachega", " cgu", "acgs", "Cgs", "ecgp", "cgu", "cacheg", " cgin", "cgi", "cgen", "rcgu", "pgi", "pgc", " cgp"], "ctx": ["cm", "obj", "cca", "dc", "anc", "qa", "xc", "sq", "config", "act", "bc", "cmd", "loc", "wd", "cc", "ci", "cp", "cf", "cn", "rc", "gc", "rx", "na", "conn", "init", "nc", "tx", "ac", "gt"], "pos": ["ref", "pp", "seq", "neg", "obj", "slice", "pot", "p", "ass", "i", "position", "x", "doc", "no", "prop", "col", "type", "ps", "def", "act", "pass", "port", "op", "num", "sp", "unit", "o", "pse", "vid", "val", "axis", "loc", "l", "Pos", "pl", "offset", "slot", "ko", "parent", "nt", "os", "size", "comp", "part", "f", "po", "pr", "n", "j", "index", "coll", "ind", "block", "post", "len", "pc", "pose", "pid"], "ct": ["xx", "apt", "ht", "th", "cod", "cca", "ft", "dc", "nat", "cd", "cat", "cent", "enc", "xc", "qt", "capt", "ld", "ect", "ant", "config", "cr", "col", "act", "bc", "opt", "cont", "sth", "unit", "cmd", "cl", "lat", "vc", "val", "mt", "lit", "loc", "st", "dt", "wd", "nt", "cc", "ci", "lt", "cn", "ot", "pet", "CT", "rt", "count", "wt", "n", "post", "conn", "t", "sl", "ind", "Ct", "nc", "et", "pc", "gt", "kt"], "pt": ["ht", "thread", "ft", "pn", "pg", "px", "ld", "ept", "ps", "station", "cmd", "cl", "mt", "st", "dt", "nt", "cond", "ptr", "pet", "rect", "part", "j", "t", "et", "val", "gt", "day", "obj", "pot", "p", "qt", "text", "col", "port", "xt", "line", "point", "pit", "patch", "tp", " pts", "sl", "pc", "kt", "pp", "act", "sth", "peer", "pl", "anch", "parent", "count", "po", "host", "post", "tx", "pid", "pa", "apt", "pty", "yt", "br", "type", "platform", "td", "loc", "lt", "pm", "vert", "ot", "round", "rt", "pr", "ind", "PT"]}}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n", "idx": 26993, "substitutes": {"opts": ["hopters", "opls", "opters", "optls", "ropts", "hopts", "ropt", "ppps", "opents", "hops", "ropents", "ots", "copt", " opters", "copts", "copls", "optt", "opt", "ppters", "copters", " opt", "otters", "ott", "optters", "optents", "opss", "optss", "opps", "ppls", "ropps", " opps", "ppts", "optps", "otents", "optts", "otps", "otts", "copps", "ops", "hopss", "otss"], "v": ["ve", "k", "z", "i", "p", "m", "b", "c", "va", "d", "cv", "ov", "x", "vs", "vt", "av", "ev", "tv", "vv", "u", "e", "o", "verb", "vert", "vi", "iv", "conv", "h", "uv", "f", "lv", "n", "j", "V", "t", "q", "vp", "l", "sv", "volt", "val", "vol", "g"], "userdef": [" userpass", "groupDEF", "userblock", "Userdf", "Userdefinition", "plugindef", "persondefined", "ioblock", "persondef", "userdefined", "iodf", "Userblock", " userdefinition", "personDEF", "Userdev", "iodefinition", "persondefinition", "userdf", "userpass", "perdef", " userdev", "groupdef", "userDEF", "groupdefined", "userdev", "iodef", "Userdef", "pluginblock", "userdefinition", "groupdefinition", "plugindf", " userdefined", " userDEF", "perpass", "plugindefinition", "Userpass", "perdev"]}}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n", "idx": 27000, "substitutes": {"bs": ["ses", "iss", "ss", "b", "bis", "ns", "ob", "bb", "las", "vs", "base", "blocks", "ab", "ds", "bh", "gb", "cb", "bos", "bc", "BS", "ps", "state", "ins", "bl", "gs", "ubs", "pb", "os", "sb", "obs", "fb", "ls", "fs", "bits", "js", "acs", "cs"], "sector_num": ["sectorpname", " sector_number", "sector_number", "sectorpnumber", "sectorIdname", "sector_ref", "section_num", "sectorpref", " sector_header", "section_ref", "sectorpnum", "sectorIdheader", "sectorIdnum", "sectorIdnumber", "section_number", "section_name", " sector_name", "sector_name", "sector_header"], "nb_sectors": ["nb_sictors", "nb_veures", "nb_vector", "nb_seonents", "nb_vectors", "nb_psegments", "nb_pseonents", "nb_gegments", "nb_vevers", "nb_sengments", "nb_sector", "nb_sigments", "nb_sivers", "nb_senvers", "nb_veonents", "nb_gector", "nb_psectors", "nb_seures", "nb_gectors", "nb_siures", "nb_senctors", "nb_geonents", "nb_segments", "nb_senures", "nb_psector", "nb_vegments", "nb_severs"], "pnum": ["ynUM", "PNumm", "pnom", "ynum", "lnumm", "natumm", "PNUM", "natom", "dnum", "natums", "lnom", "dnumm", "pnUM", "lnums", "dnums", "pnums", "pnumm", "PNum", "ynumm", "ynums", "lnum", "PNom", "PNums", "natum", "dnUM"], "s": ["S", "rs", "ses", "sk", "sys", "w", "scope", "ss", "p", "b", "m", "c", "bis", "ns", "server", "d", "ts", "sq", "ds", "conf", "state", "secondary", "states", "sync", "su", "is", "sis", "u", "e", "stats", "south", "gs", "o", "sets", "sie", "http", "session", "l", "si", "sym", "hs", "os", "stat", "sb", "services", "sa", "serv", "f", "service", "js", "fs", "t", "sl", "g", "settings", "ops", "ssl", "cs", "side"], "offset": ["location", "offer", "slice", "i", "p", "option", "shift", "position", "image", "data", "notation", "base", "clock", "style", "align", "pointer", "attribute", "address", "Offset", "optional", "error", "sync", "alias", "url", "o", "padding", "set", "start", "loc", "fee", "slot", "append", "parent", "size", "number", "missing", "off", "length", "lock", "origin", "timeout", "addr", "part", "adjusted", "value", "limit", "index", "operation", "fp", "ace", "alpha", "et", "pos", "len", "usage"]}}
{"project": "qemu", "commit_id": "c5b9729ae918b890905e00870ffc08c9b56e6d17", "target": 0, "func": "void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_ulong page, end;\n\n\n\n    LOG_SWTLB(\"%s entry %d val \" TARGET_FMT_lx \"\\n\", __func__, (int)entry,\n\n              val);\n\n    entry &= 0x3F;\n\n    tlb = &env->tlb[entry].tlbe;\n\n    /* Invalidate previous TLB (if it's valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate old TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);\n\n    /* We cannot handle TLB size < TARGET_PAGE_SIZE.\n\n     * If this ever occurs, one should use the ppcemb target instead\n\n     * of the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n", "idx": 27007, "substitutes": {"entry": ["ref", "import", "element", "byte", "ie", "server", "image", "se", "insert", "enc", "ge", "cur", "pointer", "ell", "mid", "reader", "write", "ticket", "id", "line", "key", "cell", "Entry", "ident", "feed", "e", "start", "cel", "ent", "enter", "offset", "si", "slot", "nt", "sel", "parent", "inc", "rc", "sec", "field", "ry", "win", "count", "value", "index", "row", "inter", "match", "ind", "sl", "try", "event", "post"], "val": ["ref", "seq", "i", "p", "pt", "pol", "VAL", "x", "data", "eval", "doc", "base", "test", "prop", "py", "col", "bl", "def", "port", "id", "num", "all", "vals", "aval", "al", "e", "key", "mem", "el", "min", "gold", "valid", "ol", "start", "la", "loc", "cel", "slot", "offset", "cal", "fl", "sel", "ret", "sol", "vert", "item", "cache", "vi", "win", "arg", "serv", "Val", "isal", "elt", "value", "pr", "sil", "index", "reg", "v", "ver", "sl", "ind", "pos", "len", "vol", "pid"], "tlb": ["atctrl", "ctlb", "atb", "attlb", "totalb", "tll", "ctbl", "ttlab", "lb", "twlp", "lls", "totalLB", " tb", "gtbl", "ntb", "Tsb", "ttb", "tylb", "totallab", "ntlb", "twl", "Tl", "attb", "tb", " tlbs", "tlab", "tacl", "utlab", "ttlb", "utacl", "tslr", "notlb", " tlab", "tLB", "tteb", "Tll", "tsb", "ktlb", "lbl", " tll", "tyacl", "ttlc", "ttlbs", "Tbl", "gtlp", "gtlab", "atdl", "ttll", "utb", "Tlab", "tl", "retlam", "ptb", "pbl", " tlam", "gtlb", "ptbl", "ttLB", "trb", "tls", "twb", "utwb", " tacl", "teb", " tsb", "theb", "ttlam", "atlc", "plb", "notlc", "thelb", "ptlbs", "ctlab", "attbl", "retlc", "tslp", " tlc", "attlab", "ntl", "tyb", "testlr", "testacl", "ktlab", "Tlp", "testlb", "plab", " tl", "tylab", "tslb", "Tlf", "Twb", "Trb", "ttacl", "untlb", " tlf", "retlb", "tlbs", "attll", "ttdl", "retb", "tsacl", "retlab", "ttlr", " tbl", "utdl", "ttls", "Tlc", "tseb", "ttbl", " tctrl", "tlam", " tlp", "ktwl", "thelab", "thelp", "utlb", "tdl", "utlc", "untdl", "ttrb", "notlf", "tsbl", "utwl", "Tls", " twb", "lacl", "ttsb", " tls", "atlab", "testeb", "ctll", "tlp", "tslab", "twlab", " tLB", "attsb", "tlc", "atwl", "untlab", "ptlb", "totallb", "twlb", "retsb", "llb", "Tb", "llab", "Tlb", "ktdl", "atlb", "ntbl", "untlc", "utLB", "notls", " tdl", "tbl", "ttctrl", "pll", "lrb", "lll", "tctrl", "tlr", "tlf"], "page": ["ref", "pp", "seq", "skip", "gap", "byte", "w", "section", "p", "server", "c", "pg", "image", "pid", "next", "col", "port", "num", "url", "line", "step", "feed", "site", "start", "search", "per", "month", "session", "pl", "offset", "ew", "edge", "order", "size", "inc", "number", "cache", "record", "item", "field", "block", "hop", "pages", "win", "window", "count", "Page", "value", "limit", "ip", "total", "net", "row", "v", "ver", "age", "result", "pc", "area", "stop"], "end": ["ep", "w", "z", "p", "c", "End", "x", "send", "END", "en", "ad", "tail", "port", "id", "url", "begin", "e", "line", "max", "start", "set", "enter", "offset", "append", "edge", "client", "ended", "inc", "size", "length", "win", "update", "h", "f", "value", "limit", "n", "ending", "index", "event", "dest", "r", "pos", "post", "len", "stop"]}}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n", "idx": 27021, "substitutes": {"private": ["exec", "secret", "package", "public", "or", "test", "send", "export", "pub", "def", "priv", "pass", "gate", "util", "proc", "protected", "Private", "set", "inner", "new", "client", "core", "init", "event"], "global": ["args", "public", "scope", "master", "shared", "empty", "final", "module", "config", "export", "debug", "gate", "util", "zero", "parent", "ctx", "stat", "gl", "local", "let", "arg", "Global", "reg", "env", "g"], "index": ["seq", "unique", "info", "fix", "data", "weight", "address", "access", "prefix", "diff", "version", "key", "set", "bit", "pattern", "Index", "scale", "view", "length", "addr", "window", "value", "match", "block", "pos", "len", "val"], "mask": ["secret", "shift", "info", "master", "card", "flags", "fix", "weight", "diff", "gate", "ask", "allow", "patch", "bit", "pattern", "group", "scale", "scan", "mod", "window", "comment", "bits", "match", "map", "pack", "random", "lock"], "entry": ["import", "element", "package", "low", "section", "info", "parse", "ie", "server", "card", "name", "cat", "se", "image", "module", "ge", "data", "component", "member", "export", "def", "archive", "error", "id", "plugin", "e", "feed", "key", "Entry", "cell", "path", "command", "session", "inner", "ent", "enter", "mode", "nt", "inc", "ry", "lc", "array", "comment", "service", "source", "list", "de", "row", "match", "event", "route", "pack", "connection"], "msg": ["gram", "md", "node", "ref", "comm", "gen", "obj", "console", "nm", "cm", "info", "m", "Msg", "pkg", "ge", "data", "doc", "text", "ms", "debug", "error", "sg", "def", "util", "op", "db", "e", "mag", "gs", "ma", "cfg", "message", "cmd", "str", "err", "get", "mg", "req", "help", "arg", "update", "fg", "comment", "sim", "out", "mess", "init", "og", "route", "result", "g"], "cnt": ["cno", "acct", "Cnt", "lcnt", "lcount", "crNT", "Ctx", "ncount", " cct", "ecnt", "ncNT", "ecount", "acount", " ctx", "crnt", "eccount", "Count", "acnt", "crct", "ctx", "nctx", "cct", "ccount", "Ccount", "lccount", "lcno", " count", "CNT", "ncnt", "count", "Cno", "ecno", "acNT", " cNT", "cNT", "crount"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 27045, "substitutes": {"opaque": ["OPque", "pacity", "operacity", "operaque", "OPacity", "copaque", "OPaques", "operaques", "opaques", "pque", "copaques", "Opaque", "Opaques", "paques", "copacity", "paque", "opacity", "opque", "operque", "Opque", "Opacity", "OPaque", "copque"], "sprn": ["Sprns", "prN", "sprna", "rrna", "Sprna", "prn", " sprna", "sprnc", "Sprnc", "prnc", "prns", "rrnc", "sprns", " sprN", "prna", "rrn", "sprN", "rrN", "Sprn", " sprns", "SprN"], "ctx": ["exec", "ref", "cm", "acl", "obj", "scope", " context", "c", "pkg", "context", "cv", "qa", "config", "jp", "cb", "prefix", "abc", "sync", "bp", "proc", "cmp", "grad", "tmp", "unc", "loc", "wcs", "Context", "cp", "cf", "rc", "alloc", "lc", "ctrl", "ca", "rx", "src", "conn", "fp", "func", "tx", "pc", " cx"]}}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046, "substitutes": {"s": ["sys", "server", "ns", "ts", "sites", "request", "ps", "states", "sync", "sis", "self", "u", "es", "gs", "south", "sie", "sym", "xs", "f", "service", "status", "js", "qs", "fs", "t", "tests", "ops", "S", "p", "m", "c", "se", "ds", "us", "state", "su", "is", "sets", "ims", "ions", "spec", "new", "services", "details", "sl", "settings", "in", "its", "side", "g", "rs", "ses", "args", "ss", "d", "conf", "sg", "ks", "e", "session", "hs", "sb", "your", "ches", "ssl", "cs", "i", "site", "o", "si", "os", "uns", "as", "ls", "a", "parts", "l"], "sector_num": [" sector_number", "sector_n", "sector_number", "sector_su", "section_num", "sector_sum", "sector_unit", "section_n", " sector_sum", "section_name", " sector_name", "section_unit", " sector_n", " sector_su", "sector_name"], "ret": ["fin", "ner", "nat", "sn", "ll", " RET", "fn", "en", "br", "nn", "ern", " Ret", "id", "ne", "al", "iter", "bit", "det", "RET", "re", "nt", "sec", " r", "Ret", " result", " fun", "f", "j", "t", "conn", "ind", "g", "result", "len", "val", "fun"], "n": ["nan", "np", "k", "nm", "none", "z", "w", "i", "b", "m", "p", "pn", "c", "ns", "rn", "d", "sn", "name", "adj", "x", "fn", "en", "no", "nn", "num", "ne", "nor", "o", "nb", "ni", "nt", "mn", "cn", "eni", "N", "f", "y", "nr", "na", "j", "t", "un", "nl", "conn", "net", "init", "nu", "r", "v", "an", "in", "nc", "l", "g", "dn", "nat"], "n1": ["nvar", "N2", "N1", "N0", "done", "d91", "ynOne", "enif", "numif", "yn1", "none", "nname", "n81", "m2", "ynif", "dOne", "m1", "m0", "unOne", "envar", "un91", " nname", "n01", " n0", "d1", "rnname", " n01", "sn2", "nif", "ynvar", "sn01", "num81", " n2", "sn1", "yn0", " nOne", "ynname", "na91", "un1", "rnOne", "n91", "en81", "naOne", "nOne", "rn1", "naone", "n2", "num1", "N01", "rn0", "unone", "yn81", "numvar", "na1", "n0", "en1"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n", "idx": 27048, "substitutes": {}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUState **lastp;\n\n          CPUState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          /* TODO: Free CPU state.  */\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n                target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* libc does special remapping of the return value of\n\n         * sys_getpriority() so it's just easiest to call\n\n         * sys_getpriority() directly rather than through libc. */\n\n        ret = get_errno(sys_getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            if (put_user_s64(ret, arg4))\n\n                goto efault;\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            if (put_user_s64(res, arg4))\n\n                goto efault;\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(abi_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(abi_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n                    pstrcpy(tde->d_name, tnamelen, de->d_name);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2\n\n                        && put_user_ual(deathsig, arg2))\n\n                        goto efault;\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2))\n\n                    goto efault;\n\n                orig_fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr (cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                if (arg1 == TARGET_SSI_IEEE_RAISE_EXCEPTION) {\n\n                    /* Old exceptions are not signaled.  */\n\n                    fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                    /* If any exceptions set by this call, and are unmasked,\n\n                       send a signal.  */\n\n                    /* ??? FIXME */\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how = arg1;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(arg1, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n\tif (cmd == -TARGET_EINVAL)\n\n\t\treturn cmd;\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n        {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n#endif\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 27056, "substitutes": {"cpu_env": ["cpu_dep", "proc_env", "cpu_environment", " CPU_list", "gpu_context", "proc_desc", "cpujloader", "core_np", "cpu_scope", "cpu__env", "cpu_desc", "proc_environment", "cpuwenvironment", "cpu2environment", "cpuwproc", "gpu_environment", "gpu_loader", "cpu__np", "cpu2proc", " CPU_scope", "cpujenvironment", "cpu2env", "cpu__environment", "core_env", "core_dep", "cpu_np", "cpujcontext", "core_environment", "cpujenv", " CPU_env", "cpu_loader", "cpu_proc", "cpu_context", "proc_proc", "cpu_list", "cpu_ext", "gpu_env", "cpu2desc", "cpuwdesc", "cpu__dep", "cpuwenv", " CPU_ext"], "num": ["node", "code", "gen", "thread", "np", "nm", "param", "bin", "termin", "nat", "sn", "dim", "name", "uni", "fn", "test", "program", "gnu", "type", "Num", "prefix", "id", "proc", "su", "dom", "orig", "method", "unit", "con", "ident", "valid", "multi", "nb", "loc", "offset", "run", "binary", "mn", "coord", "number", "len", "off", "um", "count", "umi", "NUM", "n", "index", "alt", "nu", "nam", "init", "nc", "final"], "arg1": ["ax2", "args2", " argone", "Arg3", "ax01", "Arg4", "argone", "ar0", "Arg1", "ar3", "ax1", "args4", "Arg2", " arg0", "args3", "args01", "argsone", "axone", "ar4", "ar1", "Arg01", "ar2", " arg01", "arg0", "args0", "args1", "arg01"], "arg2": ["ax2", "args2", "param02", "Arg3", "argument02", "Arg4", "Arg1", "ar3", "args4", "Arg2", "arg62", "arg02", " arg02", "param2", "argument3", "param4", "param62", "ar4", "args62", "ax4", "ax62", "argument4", "ar1", "argument2", "args02", "ax02", "ar2", "param3"], "arg3": ["arg03", "Arg3", "ar03", "args1", "item3", "argument03", "Arg1", "ar3", "ArgThree", "args4", "Arg2", "item2", "inc03", "ag2", "args203", "args3", "inc5", "argument3", "agg4", " argThree", "agg03", "ag1", "ag5", "inc3", "ar1", "item1", "Arg5", "argument1", "itemThree", "argument2", "agg3", "args5", "argThree", "ar2", " arg203", "args03", "arg203", "agg203", "inc1", " arg03", "ag3"], "arg4": ["arg8", "ar5", "ar3", "arg44", " arg44", "argument3", "ax8", "ar4", "ax4", "argument4", "argument5", " arg8", "argument2", "ax5", "argument8", "ar2", "ax44", "argument44"], "arg5": ["arg8", "Arg3", "Arg4", "enc6", "args4", "args3", "enc4", "enc5", "enc8", "Arg5", " arg8", "args5", "args8", "Arg6", "args6"], "arg6": ["args2", "arg8", "agg6", "ar5", "agg56", "arg64", "agg8", "argument6", "args4", "ar6", " arg56", "arg56", "ar4", "agg64", "argument64", " arg8", "argument56", "args5", "argument8", "ar2", " arg64", "args6"], "ret": ["ref", "code", "sr", "ft", "hash", "cat", "function", "x", "data", "eval", "back", "sum", "no", "success", "opt", "debug", "def", "xt", "proc", "id", "rets", "al", "mem", "arr", "max", "str", "rl", "get", "det", "lit", "Return", "RET", "output", "last", "re", "rot", "nt", "fi", "reply", "let", "arg", "Ret", "rt", "sat", "ext", "gc", "part", "alt", "net", "out", "desc", "reg", "result", "len", "val", "gt", "format", "fun"], "st": ["rest", "std", "sc", "ST", "ft", "ss", "c", "sw", "istic", "ct", "bl", "ust", "inst", "St", "store", "str", "sts", "nt", "est", "ist", "ost", "stack", "net", "stab", "r"], "stfs": ["ctfs", "strfs", "ctfunc", "stfunc", "stabfs", "ctf", "stabf", "stabfi", "ctfi", "stfi", "stabfunc", "strfi", "stf", "strfunc", "strf"], "p": ["pp", "pa", "np", "w", "m", "b", "c", "pt", "pg", "d", "api", "P", "jp", "pe", "ps", "bp", "op", "port", "proc", "press", "u", "mp", "e", "sp", "hp", "o", "pb", "s", "process", "per", "pl", "pin", "cp", "pm", "cache", "wp", "h", "part", "lp", "f", "po", "y", "pr", "n", "tp", "ip", "t", "fp", "j", "pu", "g", "pi", "pre", "vp", "r", "l", "pc", "ap", "pid"], "ts": ["rs", "tes", "args", "ters", "ss", "pt", "ns", "ta", "ats", "ms", "ds", "tz", "T", "ports", "types", "ps", "state", "ks", "outs", "tr", "lets", "eps", "bs", "gs", "sp", "stats", "TS", "ims", "trans", "s", "ics", "sts", "tt", "points", "Ts", "hs", "als", "xs", "its", "ls", "pers", "qs", "tc", "tp", "tests", "t", "acs", "aps", "times", "tx", "cs", "tips", "pc"], "lastp": ["Lastjp", "finalep", "lastjp", " lastc", "lastf", "lastpart", "lastpc", "prevp", "firstpart", "firstep", " lastep", "firstpc", "prevP", "lastc", "firstf", " lastpart", " lastjp", "Lastc", " lastm", "prevpc", "firstp", "lastm", "finalp", "prevm", " lastcp", "firstm", " lastpc", "finalf", "firstcp", "LastP", "firstP", "firstc", "lastcp", "lastP", "Lastp", "finalpart", "firstjp", "finalP", "lastep", "finalcp", " lastP", " lastf"]}}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058, "substitutes": {"sys_type_name": ["sys_type2name", "sys_type_type", "sys_name2code", "sys_name2id", "sys_type_code", "sys_name2name", "sys_name_code", "sys_name_name", "sys_name_id", "sys_name_type", "sys_type_id", "sys_type2id", "sys_name2type", "sys_type2type", "sys_type2code"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)\n\n{\n\n    int i;\n\n    INIT_CLIP\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride /= sizeof(pixel);\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n}\n", "idx": 27081, "substitutes": {"_dst": ["_fbl", "_dsput", " _lbl", "_Dst", "_fst", "_Dput", " _lput", "_dsts", "_lbl", "_dsconst", "_lst", "_dput", "_dsst", " _dput", "_dsbl", "_rdsts", "_Dsts", "_rdbl", " _lsts", " _dsts", "_fconst", "_lsts", "_dbl", "_lput", "_rdst", "_fput", " _dbl", " _lst", "_rdput", "_dconst", "_Dbl", "_Dconst"], "_block": [" _filter", " _Block", "_filter", " _keep", "_keep", " _lock", "_image", "_Block", " _frame", "_lock", " _image", "_frame"], "stride": [" strided", "Strider", "striided", "ctride", "Strise", "strise", "hrance", "yride", "ctrise", "shrided", "striiding", "hride", "drride", "drip", "ctrider", "stridi", "Strided", "hrride", " stridi", "trip", "trider", "hrip", "strride", "stide", "trride", "Striding", " strend", "shrider", "Stridi", "shride", " strise", "Strip", "yrride", "striide", "shridi", "strip", "hrider", "stip", "stance", " strance", "dride", "yrend", "ctrride", " striding", "strider", " strip", "Stride", "tride", "Strride", "drider", "strided", "yrip", "Strend", "Strance", "yrider", "strance", "striding", " strider", "strend", "striride", " strride"], "i": ["ie", "it", "io", "split", "u", "li", "bi", "ini", "ai", "f", "n", "j", "list", "chi", "slice", "k", "iii", "p", "m", "c", "x", "me", "ti", "mi", "phi", "qi", "ri", "is", "key", "line", "di", "ci", "eni", "vi", "in", "g", "temp", "abi", "d", "adi", "e", "err", "uri", "ii", "cli", "fi", "I", "source", "q", "iu", "lock", "my", "info", "image", "ix", "api", "config", "type", "id", "gi", "zi", "multi", "xi", "inner", "si", "ni", "y", "mini", "oi", "ip", "index", "v", "mu", "pi", "ui", "l", "hi"], "dst": ["idbl", "odrest", "dsts", "xdbl", "adst", "nput", "ldsl", "ddput", "dbl", "wset", " dsc", "ddset", "ldrest", "Dset", "bdput", "nstore", "dstream", "odset", "dST", "dsbl", "dset", "fsc", "ldput", " dsl", " drest", " dput", "xdst", "xdST", "dsc", "wst", "drest", "idst", "idsc", "bdbl", "rdbl", " dsts", "dsst", "rdst", "Dput", "bdst", "ddst", "odput", "adrest", "dsl", "fst", "ldsc", "adput", "bdrest", " dstream", "rdput", " dset", " dST", "dstore", "Dsc", "Dst", "ddstore", "Dbl", "ldbl", "wstore", "xdsts", "adset", "rdsc", "fbl", "nset", " dbl", "ldst", "dssc", "odst", "nst", "dsset", "Dsl", "idstream", "wput", "dput"], "block": ["chain", "ban", "batch", "frame", "name", "keep", "buffer", "label", "condition", "sync", "cl", "tick", "object", "word", "number", "um", "list", "row", "square", "pack", "mask", "none", "p", "option", "filter", "wave", "blocks", "check", "link", "point", "line", "patch", "work", "bit", "month", "panel", "group", "cache", "rock", "array", "wall", "rule", "event", "map", "large", "byte", "section", "pixel", "bl", "error", "plugin", "BL", "Block", "session", "box", "board", "join", "view", "ack", "pull", "full", "post", "lock", "page", "image", "style", "type", "flow", "unit", "layout", "loc", "clean", "down", "record", "channel", "off", "device", "comment", "ip"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 27083, "substitutes": {"s": ["S", "rs", "ses", "sys", "i", "p", "m", "b", "c", "server", "ns", "context", "d", "ges", "sq", "ds", "request", "us", "sg", "ks", "states", "is", "u", "e", "es", "south", "gs", "o", "sets", "ions", "session", "si", "os", "ctx", "sb", "services", "h", "f", "service", "qs", "js", "groups", "tests", "a", "t", "ches", "sf", "ops", "settings", "ssl", "cs", "native", "g"], "insn": ["issnt", "issb", "idsnt", "intsne", "incN", "inl", "isssn", "insN", " insnt", "insnl", "insl", "inns", "incns", "innt", "ksnt", "outsn", "esnl", "exn", "insne", "intsn", "inssn", "idsn", "esn", "intssn", " insne", "consb", "ksn", "intsnt", "innl", "insp", "issl", "issn", "incl", "outsnt", "issp", "esb", "outssn", "exsn", "outsnl", "insnt", "incn", "insnc", "outsp", "inb", " inssn", "esl", "incnt", "insns", "esnt", "inn", "idsne", "exb", "incnc", "incsn", "inp", "issnc", " insns", "consn", "consN", "ksns", "outsns", "consnc", "exl", "issN", "incb", "ksl", "issnl", "insb", "idssn"], "mos": ["pa", "cm", "rom", "oc", "m", "Mos", "osa", "las", "mot", "qa", "ms", "omo", "om", "tz", "no", "asio", "oid", "mx", "mp", "oise", "o", "la", "mol", "loc", "mode", "mis", "os", "ros", "cp", "mo", "pm", "mc", "mon", "hop", "co", "cas", "proxy", "po", "oi", " mo", "na", "mm", "coll", "pos", "oshi", "phase"], "type": ["code", "class", "info", "p", "name", "position", "time", "test", "weight", "style", "py", "col", "pe", "types", "cross", "state", "form", "port", "id", "method", "key", "unit", "o", "rel", "min", "cl", "loc", "Type", "box", "mode", "art", "order", "size", "sort", "mon", "hop", "shape", "ype", "field", "ro", "comp", "part", "y", "po", "acy", "year", "t", "r", "pos", "pre", "ty", "block", "ony", "area"], "rm": ["ref", "md", "rom", "res", "RM", "arm", "dy", "name", "dim", "rf", "fn", "rb", "prop", "cr", "col", "cb", "mr", "cmp", "rel", "cmd", "min", "err", "lr", "loc", "role", "mode", "re", "cp", "order", "pm", "rc", "ore", "ro", "rem", "rt", "nr", "rx", "reg", "route", "r", "pre", "rr", "range"], "cond": ["ref", "seq", "code", "day", "cod", "success", "cd", "close", "red", "xc", "label", "condition", "circ", "config", "cr", "no", "col", "ct", "fail", "cb", "def", "dd", "non", "fact", "act", "id", "reason", "cmp", "cont", "bool", "lf", "unit", "cmd", "cl", "Cond", "prep", "loc", "ann", "fl", "clean", "mode", "cc", "cp", "inc", "sec", "co", "ress", "cas", "zip", "lc", "comp", "bid", "count", "na", "reg", "resp", "crit", "init", "ind", "pre", "df", "pos", "control", "len"], "rn": ["rom", "unn", "ril", "anc", "rd", "keep", "norm", "dr", "rf", "fn", "rb", "br", "nn", "rin", "col", "cross", "nz", "orig", "cmp", "rw", "ne", "nor", "adr", "rh", "err", "cdn", "lr", "rar", "ann", "mn", "cn", "ron", "roc", "rc", "rg", "ro", "raf", "rt", "hn", "nr", "rx", "na", "n", "coll", "r", "rr", "nc", "arn", "len"], "op": ["pp", "pop", "oc", "p", "option", "upp", "ob", "rol", "OP", "oper", "rb", "opp", "prop", "opus", "operator", "jp", "opt", "eff", "cmp", "mp", "ope", "rop", "o", "loc", "rot", "cp", "vert", "cop", "order", "hop", "co", "opa", "Op", "off", "block", "comp", "ort", "ip", "fp", "r", "ops", "anne", "lock", "ok"], "nzcv": ["NZvv", "nznv", "sqcv", "ezcv", "zzcv", "expCV", "expvm", "zznv", "sqnv", "zzCV", "NZuc", "ezvv", "ncqu", "expnv", "tzcv", "nzCV", "nzvm", "czvv", "nzqu", "czcv", "squc", "ezuc", "nzvv", "NZnv", "tzCV", "ncvv", "expcv", "tznv", "sqvv", "ncnv", "tzvm", "eznv", "ezqu", "NZcv", "cznv", "zzvm", "nzuc", "nccv", "czqu"], "tcg_flags": ["tcg__flag", "tcg__roots", "tcgi_mods", "tcp__flags", "tcp_flags", "tcg__bits", "tcg_lins", "tcg__Flags", "tcG_mods", "tcp__flag", "tcgi_lins", "tcg67flags", "tcg_roots", "tcG_roots", "tcG_flags", "tcg67types", "tcg__types", "tcg__mods", "tcg_bits", "tcg67bits", "tcG_bits", "tcg_flag", "tcgi_flags", "tcg__flags", "tcG_args", "tcg_Flags", "tcg__lins", "tcg_types", "tcG_types", "tcp_Flags", "tcg_args", "tcp_flag", "tcg_mods", "tcp__Flags", "tcg__args", "tcg67args"]}}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n", "idx": 27088, "substitutes": {"bit": ["load", "mask", "byte", "bin", "BIT", "flag", "filter", "base", "feature", "type", "bug", "error", "it", "sync", "id", "op", "key", "patch", "lit", "pattern", "Bit", "and", "offset", "slot", "word", "pin", "number", "feat", "lock", "length", "off", "part", "count", "bits", "child", "value", "index", "limit", "block", "ac", "val", "big", "tag"], "map": ["mask", "use", "complete", "code", "comb", "app", "master", "image", "maps", "module", "buffer", "test", "dict", "op", "MAP", "pad", "mp", "arr", "cast", "max", "cap", "set", "scale", "cache", "shape", "co", "array", "rule", "list", "func", "pack", "block", "ap", "table", "Map", "lock"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100, "substitutes": {"ctx": ["sc", "kw", "cm", "cca", "anc", "c", "pkg", "context", "cv", "connection", "qa", "xc", "config", "component", "jp", "support", "ct", "cb", "bc", "cus", "ce", "instance", "util", "sync", "kb", "css", "cmp", "fc", "cmd", "cl", "cms", "vc", "loc", "fw", "cli", "Context", "cc", "ci", "cn", "cf", "cp", "client", "ga", "rc", "co", "cas", "lc", "ctrl", "comp", "ca", "tc", "cu", "conn", "coll", "event", "ck", "nc", "tx", "cs", "cam", "pc", "cgi", "kt"], "blocking": ["complete", "exec", "starting", "rising", "testing", "interrupted", "quiet", "exclusive", "using", "locking", "buffer", "blocks", "calling", "no", "ocking", "prefix", "bc", "bl", "regular", "wait", "loading", "protected", "padding", "cl", "background", "partial", "http", "enabled", "successful", "restricted", "client", "including", "sleep", "rolling", "working", "locked", "running", "full", "block", "ssl", "limited"]}}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107, "substitutes": {"id": ["temp", "aid", "ref", "code", "iq", "i", "info", "p", "name", "d", "image", "data", "request", "Id", "ad", "address", "type", "error", "it", "end", "key", "input", "path", "parent", "bid", "h", "f", "ip", "index", "q", "event", "ids", "ID", "fd", "pid"], "response": ["complete", "my", "body", "secret", "tree", "collection", "page", "server", "image", "data", "api", "request", "Response", "success", "respond", "error", "reference", "def", "dict", "ception", "feed", "site", "message", "resource", "valid", "object", "output", "model", "parent", "os", "female", "reply", "view", "cache", "xml", "json", "array", "entry", "status", "resp", "answer", "results", "v", "r", "description", "result", "connection", "format"], "ret": ["ref", "temp", "seq", "code", "obj", "res", "flag", "x", "data", "success", "bf", "py", "xt", "rets", "mem", "get", "bit", "det", "rev", "lit", "RET", "re", "nt", "fi", "reply", "let", "pet", "arg", "Ret", "rt", "f", "part", "status", "ext", "t", "alt", "resp", "reg", "match", "v", "result", "et", "len", "val", "ut", "fun"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129, "substitutes": {"env": ["obj", "np", "exc", "context", "cv", "enc", "ec", "qt", "en", "config", "cb", "priv", "inst", "ev", "ea", "environment", "proc", "db", "buf", "cfg", "viron", "impl", "ptr", "src", "conn", "bg", "tx"], "ctx": ["exec", "txt", "sc", "kw", "cm", "obj", "np", "cca", "scope", " context", "c", "pkg", "context", "cv", "connection", "qa", "xc", "qt", "gru", "sq", "config", "component", "jp", "cb", "bc", "ch", "sync", "kb", "linux", "cmp", "gpu", "wx", "buf", "chan", "hw", "cfg", "cmd", "grad", "vc", "cpu", "loc", "wcs", "cli", "Context", "cc", "cp", "ci", "cf", "mc", "rc", "utils", "sci", "conv", "client", "cas", "xs", "lc", "ctrl", "tc", "src", "conn", "qq", "fp", "ck", "nc", "tx", "cs"], "op2": ["opt4", "hop2", "opt1", "op52", "hop4", "op4", "OP52", "op1", "OP02", " op4", " op52", " opTwo", "oper3", "op02", " op1", "op3", "ip4", "opt3", "ip2", "OP2", "hop1", "hopTwo", "oper1", " op02", "oper4", "ip3", "oper2", "hop02", "opTwo", "OP1", "opt2", "hop52", "OPTwo", "OP4"], "r1": ["ur2", "ur61", "l2", "v0", "l61", "v1", "ur3", "v4", "r61", "r0", " r2", "r2", " r4", "R0", "R4", "ur1", "l3", " r61", "r3", " r0", " r3", "r4", "R1"], "l1": ["l9", "rl9", "l2", "l8", "l11", "rl1", "el1", "Lone", "r7", "r9", "p1", "r2", "L1", " l8", "p2", "el2", "rl7", "L8", "nl1", "lone", "l7", "rl2", " l2", " lone", "r11", "rone", "p11", "nl11", "el7", "r8", "L2", "el9", "nl2"], "tmp": ["temp", "txt", "obj", "cm", "np", "bag", "slice", "kk", "emp", "app", "cv", "bb", "job", "xc", "Temp", "storage", "img", "rb", "config", "data", "jp", "vt", "cb", "bp", "front", "test", "proc", "su", "cmp", "wx", "mp", "buf", "TB", "obb", "api", "pb", "input", "nb", "session", "output", "handler", "result", "sb", "fb", "lab", "cp", "cache", "now", "vm", "timer", "tab", "sup", "tf", "tc", "tp", "src", "appy", "cpp", "bg", "mk", "fp", "v", "bt"]}}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148, "substitutes": {"dev": ["ve", "md", "gu", "sk", "w", "dc", "driver", "cd", "app", "der", "d", "data", "var", "ad", "conf", "ds", "debug", "def", "bug", "DEV", "ch", "ev", "priv", "dd", "die", "prom", "self", "adv", "dem", "hw", "grad", "err", "gd", "di", "cache", "req", "device", "dist", "gh", "mod", "development", "comment", "conn", "de", "Dev", "rad", "v", "ver", "od", "sd", "cam", "g"], "qs": ["exec", "comm", "iq", "Q", "args", "sys", "events", "quick", "c", "ns", "ts", "qa", "vs", "ksh", "qt", "views", "sq", "ds", "eks", "ps", "qi", "ks", "states", "ch", "rows", "sync", "self", " q", "gs", "cmd", "vc", "s", "gd", "os", "ctx", "rc", "req", "quad", "ls", "qu", "f", "fs", "tests", "qq", "conn", "checks", "q", "ck", "query", "dq", "cs", "params", "g"], "arch": ["build", "p", "app", "arm", "c", "der", "qa", "enc", "cur", "var", "gr", "ch", "form", "mac", "car", "id", "orig", "ARCH", "patch", "arr", "str", "prev", "art", "parent", "os", "ror", "cf", "archs", "ga", "ar", "rc", "Arch", "auth", "h", "pr", "a", "host", "q", "arc", "ver", "r", "ace", "rr", "ac", "ph"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static unsigned long iv_decode_frame(Indeo3DecodeContext *s, \n                                     unsigned char *buf, int buf_size) \n{\n  unsigned int hdr_width, hdr_height,\n    chroma_width, chroma_height;\n  unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;\n  unsigned char *hdr_pos, *buf_pos;\n  buf_pos = buf;\n  buf_pos += 18;\n  fflags1 = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  fflags3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  fflags2 = *buf_pos++;\n  buf_pos += 3;\n  hdr_height = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  hdr_width = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;\n  chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;\n  offs1 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs2 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 8;\n  hdr_pos = buf_pos;\n  if(fflags3 == 0x80) return 4;\n  if(fflags1 & 0x200) {\n    s->cur_frame = s->iv_frame + 1;\n    s->ref_frame = s->iv_frame;\n  } else {\n    s->cur_frame = s->iv_frame;\n    s->ref_frame = s->iv_frame + 1;\n  }\n  buf_pos = buf + 16 + offs1;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width, \n    hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(hdr_width, 160));\n  if (!(s->avctx->flags & CODEC_FLAG_GRAY))\n  {\n  buf_pos = buf + 16 + offs2;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  buf_pos = buf + 16 + offs3;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  }\n  return 8;\n}", "idx": 27151, "substitutes": {"s": ["S", "rs", "ses", "sys", "this", "ss", "p", "b", "c", "bis", "ns", "m", "se", "ts", "ges", "sq", "ds", "conf", "us", "ps", "sg", "ins", "ks", "states", "bs", "su", "is", "self", "e", "es", "cs", "gs", "sets", "ions", "set", "session", "spec", "sym", "new", "sb", "services", "xs", "as", "ls", "f", "fs", "qs", "js", "service", "t", "a", "full", "ops", "parts", "sv", "its", "rates", "g"], "buf": ["seq", "uf", "uc", "cv", "msg", "Buff", "data", "vec", "buffer", "queue", "img", "text", "cur", "rb", "cb", "ab", "bc", "av", "port", "bu", "orig", "num", "feed", "aux", "ff", "cmd", "uint", "max", "pb", "wav", "ctx", "fb", "ffff", "alloc", "Buffer", "len", "block", "rc", "length", "off", "ctr", "buff", "src", "fp", "result", "fd", "cf"], "buf_size": [" buf_position", "buf_position"], "hdr_width": ["hdr___size", "hdr6class", "hdr___capacity", "hdr6width", "hdr_name", "hdr_lon", "hdr6name", "hdr___width", "hdr___ws", "hdr_size", "hdr_capacity", "hdr_ws", "hdr___lon", "hdr6height", "hdr_class", "hdr___height"], "hdr_height": ["hdr_volume", "hbr_volume", "hdr_length", "hder_width", "hder_length", "hdr__max", "hdr_max", "hdr_quality", "hbr_height", "hdr_cap", "hdr__length", "hdr__height", "hder_cap", "hdr__width", "hder_height", "hbr_width", "hbr_quality"], "chroma_width": ["chromla_wide", "chroma_name", "chromla_pool", "chromla_size", "chroma_size", "chroma_wide", "chromla_height", "chromla_name", "chroma_pool", "chromla_width"], "chroma_height": ["chroman_length", "chromla_cap", "chroma_direction", "chromla_dim", "chroma_cap", "chroman_height", "chroma_dim", "chroma_length", "chromla_height", "chroman_width", "chromla_width", "chroman_direction"], "fflags1": ["ffdlags2", "ffllags2", "ffLugs3", "ffllags1", "fflag2", "ffllags9", "ffdlags3", "fflagged0", "ffllag3", "fflags0", "fflaggedOne", "ffLugsOne", "fflugsOne", "fflats2", "ffdlagg3", "ffLags3", "ffllag2", "ffdlagg2", "fflagg1", "ffllag1", "fflats9", "fflacks1", "fflages1", "fflacks0", "ffLugs0", "fflages9", "fflags9", "fflagsOne", "fflugs0", "fflacksOne", "fflag9", "fflages2", "fflagg2", "fflags5", "fflugs1", "fflagg5", "fflagged3", "fflagged1", "ffLagsOne", "fflats3", "fflag5", "ffdlags5", "fflats1", "ffdlagg5", "ffdlagg1", "fflugs3", "ffLugs1", "ffLags1", "ffLags0", "ffllag9", "fflages3", "ffdlags1", "fflats5", "fflacks3", "fflagg3", "fflag3", "fflag1", "ffllags3"], "fflags2": ["ffdlags2", "ffllags2", "fflugs2", "ffdlages1", "ffdlages2", "ffdlages3", "ffllags1", "fflag2", "ffdlags3", "fflugsTwo", "ffllars2", "fflats2", "fflars22", "fflats22", "fflars1", "fflages1", "fflarsTwo", "fflars2", "ffllagsTwo", "fflages2", "fflatsTwo", "fflugs1", "fflagsTwo", "ffllars1", "fflats3", "ffllags22", "fflats1", "ffllars22", "fflags22", "fflugs22", "ffdlags1", "fflages3", "ffllarsTwo", "fflag3", "fflag1"], "fflags3": ["fflagged23", "fflugs2", "ffflugs2", "ffllats1", "ffflugs3", "ffklags3", "ffllags1", "fflag2", "ffklages6", "fflats6", "fflats0", "fflager23", "ffflags23", "ffklags6", "fflags0", "ffllats3", "ffklags1", "fflag3", "ffllats93", "fflats2", "fflag23", "ffllags23", "fflages0", "ffklags0", "fflags6", "ffklages1", "fflags23", "fflagged93", "fflages1", "fflag0", "fflugs23", "fflag6", "fflags93", "fflager93", "fflager1", "ffflugs1", "fflages6", "fflugs1", "fflagged3", "ffklages3", "fflagged1", "ffflags1", "ffflugs23", "fflats3", "fflats1", "ffflags2", "fflag1", "fflager3", "fflugs3", "fflages3", "ffllats23", "fflats93", "fflats23", "ffklages0", "ffllags93", "ffflags3", "ffllags3"], "offs1": ["sets3", "hands1", "sets2", "sets1", "hands01", "outs01", "off1", "outs3", "hands3", "off0", "sets01", "ops1", "ops0", "offs01", "ops2", "offur", "opens01", "outs0", "offsur", "handsone", "setsone", "ops3", "outs1", "outsur", "off3", "opens1", "offs0", "off2", "setsur", "opensone", "outs2", "opens3", "offsone", "off01"], "offs2": ["times2", "offTwo", "off4", "times62", "ups4", "outsTwo", "offs62", "offs4", "ups62", "ups2", "outs4", "times02", "off02", "times4", "offs02", "downs4", "downs02", "off62", "ups02", "off2", "outs02", "downs2", "outs2", "offsTwo", "downsTwo"], "offs3": ["sets3", " offsetsthird", "offthird", " offsets3", "off03", "events15", "offsthird", "setsthree", "downs23", "sets15", "offs23", "ands15", " offsets15", "off15", "offs03", "events23", "downs3", "events3", "eventsthree", "andsthird", "off3", "offsthree", " offsets03", "downsthree", "ands3", "sets23", "offs15", "ands03", "downs15"], "offs": ["loads", "hands", "pieces", "powers", "args", "heads", "ands", "cuts", "nos", "empty", "uni", "flags", "frames", "blocks", "opp", "opens", " off", "ones", "outs", "overs", "ups", "sticks", "options", "ff", "sets", "SIZE", "unks", "lines", "offset", "gets", "utils", "xs", "Off", "off", "ows", "OFF", "ents", "bytes", "bits", "styles", "pres", "values", "ops", "times", "tips"], "hdr_pos": ["hrc_pointer", "hder_pos", "hdrDocposition", "hdr2pos", "hdr64position", "hder64pos", "hdr64po", "hder64Pos", "hrc_position", "hder_po", "hdr2Pos", "hdr_position", "hdr2loc", "hder_position", "hdr2po", "hdr_pointer", "hder64po", "hder64position", "hrc_pos", "hdr2position", "hdr_Pos", "hdr64pos", "hdrDocloc", "hdr2pointer", "hdr64Pos", "hdr_loc", "hrc_loc", "hdr_po", "hdrDocpointer", "hdrDocpos", "hder_Pos"], "buf_pos": ["cb_position", "grab_base", "buff_Pos", "fbJpos", "buf6loc", "fb_pres", "buf6Pos", "bufCos", " buf_position", "usr2loc", "cmd_pass", "bu_position", "bufCpos", "ctx6loc", "cmd_pos", "ctx_Pos", "fb_ss", "buf2len", "buffer__port", "cmdPpass", "cb_pos", "fbPpres", "grab_loc", "cmd_doc", "buflexlen", "buf00pos", "buf48pos", "cb2position", " buf_loc", "buf2doc", "fbPpos", "bufdpos", "buf67pos", "buf2pose", "buff_os", "cb2min", "buf__os", "bufacpo", "buf2min", "cb_min", "grab2loc", "ctx6pos", "buf64pos", "bu_pos", "buf_Pos", "buff_po", "buf_ss", "buffer__os", "fbJnos", "buf2Pos", "grab_pos", "buflexposition", "buf_position", "bufPneg", "buf__Pos", "fb00position", "fbPspec", "ctx_position", "bu_po", "ctx_pos", "buf6pos", "buffer_port", "buf64loc", "buf2os", "bufacpush", "bufsport", "bufPpres", "bufacunit", "buf2pres", "buf_loc", "bufPdoc", "buf__point", "buflexpid", "buf00ss", "bufJpos", "buflexnum", " buf2position", "bufJpose", "buflexloc", "buf__nos", "bufJloc", "bufCport", "buf_po", "fb00ss", "fbJsupp", "buff_push", "bufPpass", "grab2pos", "fb_neg", "buf_pid", "buffer_pos", "bufdloc", "buf00position", "buf6position", " buf_pose", "grab2pose", "box_pass", "buf67pid", "cb2num", " buf_os", "buf2supp", "bufPpose", "buf_base", "buf00loc", "buffer__pos", "buf2pos", "buff_nos", "box_pose", "fb_loc", "fb00pos", "buf00nos", "fb_nos", "bufsos", " buf2loc", "buf67nos", "buf67position", "buf_pass", "buf_pres", "buf2position", "buflexpass", "bufJnos", "buf64pose", "cmdPpose", "usr2pos", "buf2base", "grab2base", "fb_spec", "bufPpos", "bufJsupp", "bufacpos", "bufJpres", "buf2nos", "bufspos", "usr2pose", " buf_nos", "bufspoint", " buf2pos", "buf00push", "buf64pres", " buf2nos", "fbPneg", "queue_position", "buflexss", "buflexindex", "buff_pos", "buff_loc", "buf0loc", "box_pos", "buf_os", "ctx6Pos", "buf2num", "buflexsupp", "buf_port", "buf__position", "bufdpose", "bu_loc", "buf00po", "buf_spec", "cmdPdoc", "buff_pid", "buff_pose", "buf0po", "fb_supp", "cb_num", "buf__port", "queue_pos", "buf48num", "buff_position", "buf48position", "buflexpos", "fb_pos", "buffer_point", "cmdPpos", "buffer__point", "buf2loc", "usr_pose", "usr2pres", "buf_point", "buf64os", "buf64nos", "ctx_loc", "bufCpoint", "fb_position", "bufPspec", "buflexnos", "box_pres", "queue_pose", "bu_os", "buf_min", "fb00loc", "bu_Pos", "bu_nos", " buf_pres", "buf_nos", "buf_len", "buf_neg", "usr_pos", "cmd_pose", "buf_index", " buf_len", "bufJpass", "buf__loc", "buffer_os", "buf_unit", "usr_pres", "buf2pass", "buf__pos", "fbJloc", "bufdbase", "buff_unit", "buflexpose", "bufacos", "buf_push", "buf_supp", "bufacnos", "queue_index", "bu_pose", "usr_loc", "buf0pos", "buf0nos", "buf48min", "buf_pose", "ctx6position", "buf_num", "grab_pose", "buf_doc", "buflexpres", "buflexmin", "cb2pos"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 27169, "substitutes": {"env": ["exec", "her", "txt", "esm", "obj", "args", "np", "console", "scope", "net", "exc", "engine", "context", "manager", "cv", "enc", "qa", "qt", "ec", "en", "config", "Environment", "conf", "vt", "ce", "loader", "ev", "end", "ea", "sche", "environment", "ne", "db", "e", "gov", "cfg", "hw", "cmd", "esi", "cdn", "ef", "cli", "viron", "dt", "cal", "dev", "eu", "utils", "inc", "emb", "eni", "erb", "req", "fg", "ext", "conn", "bg", "runner", "ette", "header", "v", "cookie", "keeper", "event", "settings", "org", "qv", "que", "eng"], "tb": ["intab", "ttrb", "pp", " tbody", "np", "ptb", "ptgb", "ptbh", "ttgb", "tbb", "tbody", "ltrb", "ltb", "ptab", "itb", "intc", "untrb", "ptc", "tgb", "trb", "untgb", "ttb", "tba", "tsp", "ptp", "ptbe", "tsba", "ptba", "ltc", "pb", "intrb", "nb", "tbh", "itbody", "pbe", "pba", "nbb", "intb", "tbe", "tab", "untbh", "ltab", "tsb", "tc", "tp", "itp", "itbb", " tbb", "untb", " tp", "tsbe", "ttbh", "ptrb", "nbody"], "search_pc": ["searchingpb", "searchurePC", "search_mc", "search_PC", "search_arc", "searchablearc", " search_mc", "search2pb", " search2pb", "Search_fc", " search2PC", "searchingPC", "searchablepc", " search_PC", "Search_pc", "searchingpc", "search2PC", "searchurepb", " search2mc", "search2fc", " search2pc", "Search_pb", "search_fc", "searchablepb", "searchablefc", "search2mc", " search_pb", "search2pc", "searchuremc", "Search_arc", "search2arc", "search_pb", "searchingmc", "searchurepc"], "ctx": ["exec", "acl", "sys", "cca", " context", "pkg", "qa", "sq", "support", "cb", "sync", "wx", "cmd", "cl", "vc", "lib", "fw", "cf", "sci", "conv", "xs", "ca", "service", "fp", "crit", "nc", " c", "kw", "obj", "cm", "c", "cv", "jp", "prefix", "util", "css", "cmp", "ci", "utils", "cas", "wp", "tc", "cu", "coll", "que", "pc", " cx", "txt", "console", "scope", "context", "xc", "abc", "fc", "cfg", "wcs", "cli", "Context", "cc", "cp", "client", "setup", "cn", "req", "lc", "ctrl", "rx", "na", "ck", "tx", "cs", "sc", "dc", "fn", "config", "cus", "bc", "kb", "hw", "loc", "rc", "co", "conn", "cpp"], "ctxp": ["etfile", "ntxp", "ntbg", "mdbg", "cfxp", "nttxt", "ntfile", "etbg", "mdxp", "cffile", "cfbg", "etxp", "mdtxt", "cftxt", "mdfile", "ettxt"], "table": ["node", "sys", "console", "app", "batch", "server", "engine", "buffer", "test", "queue", "fn", "conf", "col", "TABLE", "global", "port", "db", "Table", "tmp", "session", "lib", "client", "cache", "source", "event", "database", "query", "file"], "handler": ["processor", "node", "code", "parser", "server", "function", "manager", "callback", "buffer", "fn", "queue", "reader", "path", "command", "Handler", "controller", "client", "response", "channel", "handle", "source", "host", "route", "event", "connection", "file", "writer"], "pc_start": ["pc7start", "pc67start", "pc__start", "fc_comp", "pc_offset", "PC_offset", "PC_end", "pc_comp", "pc7end", "pc_end", "pc_limit", "fc_get", "fc_start", "PC_start", "fc_end", "pc7id", "fc_id", "pc67limit", "pc__comp", "pc2offset", "pc67offset", "PC_limit", "pc2start", "pc_size", "fc_size", "pc_get", "pc__end", "pc_id", "pc7size", "pc2end", "pc67end", "pc2limit", "pc__get"], "gen_opc_end": ["gen_opcamend", "gen_opc___max", "gen_opcamstart", "gen_opc_max", "gen_opc_ends", "gen_opci_start", "gen_opc_END", "gen_opc___end", "gen_opci_end", "gen_opc__ends", "gen_opc__end", "gen_opcu__ends", "gen_opc_size", "gen_opci_buf", "gen_opcu_end", "gen_opci_def", "gen_opc_start", "gen_opc_buf", "gen_opc2buf", "gen_opcu__size", "gen_opcu__END", "gen_opc__size", "gen_opcamdef", "gen_opc2max", "gen_opc__END", "gen_opc2end", "gen_opcu_ends", "gen_opcu__end", "gen_opc___buf", "gen_opcu_size", "gen_opci_max", "gen_opcu_END", "gen_opc_def"], "j": ["obj", "jit", "k", "z", "ie", "i", "b", "p", "jump", "dy", "uj", "name", "adj", "shift", "m", "d", "c", "kj", "x", "job", "br", "vision", "jo", "jp", "aj", "jj", "it", "end", "num", "fr", " index", "key", "e", "bj", "step", "ji", "li", "o", "el", " dj", "jc", "ii", "fl", "ni", "ij", "jet", "oj", "length", "note", "im", "f", "y", "jl", "js", "n", "pr", "index", "J", "v", "r", " i", "l", "dj", "jen", "area", "ja", "g"], "lj": ["ylj", " lja", "flje", "lnj", "lbji", "flja", "lg", "li", "ulk", "lija", "lbz", " lji", "lbl", " li", "ylje", "lja", "Li", "yln", "ulbl", "llz", "liaj", "ulg", "Lk", " lk", "lje", " lbl", "lz", "slbl", "sljs", "lbj", "ulj", " ljs", "llj", "ulje", " ljp", "elja", "flz", "Lz", "ulz", "milji", "lnje", "uln", "sljo", " lz", "laj", "fljp", "lji", "ljs", "ljo", "milaj", "uljs", "elz", "llja", "elje", "lnji", "lnn", "slji", "ulaj", "lbi", "flj", "milj", "Lj", "lk", " lg", "llje", "ljp", "miljo", "slaj", "Lji", "lijp", " laj", "flaj", "ylji", " ljo", "ulji", "lij", "elj", "ln", "slj", "Lg"]}}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171, "substitutes": {"argv": ["argsb", " argvt", "argb", "agk", "Argh", "passV", "argV", "agvt", "Argv", "agvs", "angb", "argsl", "Argc", "argsv", " argvs", "agV", " argl", "angvs", "argk", " argf", "arkl", "agc", "tagc", "tagvt", " argk", "argp", "passv", "passvs", "angc", "argvs", " argb", " argh", "argvt", "arkvs", "passc", "argsf", " argp", "argh", "argumentc", "argl", "Argp", "argumentf", "agv", "argumentv", " argV", "Argf", "arkc", "argsc", "arkv", "angv", "argf", "argumenth", "tagk", "argsp", "argsvs", "tagv"], "argc": ["env", "axp", "enlc", "Argv", "argsl", "Argc", "enc", "argsv", " argl", " argf", "arnv", "axv", "argp", "argi", "axc", "arglc", " argp", "argsf", "argl", "arnp", "axi", "arni", "arkf", "Argf", "arkc", " arglc", "arklc", "argsc", "arkv", " argi", "enf", "argf", "Argl", "arnc", "Arglc"], "ide_idx": ["ide_idect", "idexidx", "ide_indx", "ide_ideX", "ide__endz", "ide_ider", "ide__idz", "ide__idc", "ide_aidc", "ide_aidx", "ide_idey", "ide_idX", "ide_endxe", "ide_ipxs", "ide__ider", "ide__endxe", "ide_endz", "ide__idy", "ide_IDct", "ide__ipct", "ide_endxs", "idexidxs", "ide_idxe", "idexendX", "ide_IDxs", "ide__idxs", "ide__idx", "ide_pidx", "ide_indr", "ide_ipx", "ide_endX", "ide_pidy", "ide_ipct", "ide_idy", "ide__idxe", "ide_indxs", "ide__idexs", "ide_inX", "ide_iny", "ide__idex", "ide__endx", "ide_indct", "ide__idct", "ide_pidct", "ide__endc", "idexidy", "idexendxs", "ide_aidxe", "ide__idr", "ide_idex", "ide__idect", "idexidX", "ide_aidz", "ide_inx", "ide_idct", "ide_idr", "ide_idc", "ide_IDx", "ide__ipx", "ide_endx", "ide__ipxs", "ide_IDr", "ide_idz", "ide_ipy", "ide__ipy", "ide_pidxs", "ide_idexs", "idexendx", "ide_inxs", "ide_endc", "ide_endy", "idexendy", "ide_idxs"], "i": ["gu", "abi", "k", "z", "ie", "p", "b", "m", "c", "yi", "name", "d", "ix", "x", "adi", "ti", "mi", "type", "ei", "qi", "ri", "id", "io", "ui", "u", "e", "li", "gi", "zi", "multi", "xi", "uri", "start", "ii", "di", "si", "ai", "ini", "ni", "bi", "ci", "fi", "eni", "lc", "h", "f", "I", "y", "n", "j", "index", "a", "t", "ip", "iu", "v", "r", "pi", "mu", "l"]}}
{"project": "FFmpeg", "commit_id": "e13f860ac8a5a7d803059d1553773cf2a446d3f2", "target": 0, "func": "static int decode_vol_header(MpegEncContext *s, GetBitContext *gb){\n\n    int width, height, vo_ver_id;\n\n\n\n    /* vol header */\n\n    skip_bits(gb, 1); /* random access */\n\n    s->vo_type= get_bits(gb, 8);\n\n    if (get_bits1(gb) != 0) { /* is_ol_id */\n\n        vo_ver_id = get_bits(gb, 4); /* vo_ver_id */\n\n        skip_bits(gb, 3); /* vo_priority */\n\n    } else {\n\n        vo_ver_id = 1;\n\n    }\n\n//printf(\"vo type:%d\\n\",s->vo_type);\n\n    s->aspect_ratio_info= get_bits(gb, 4);\n\n    if(s->aspect_ratio_info == FF_ASPECT_EXTENDED){\t    \n\n        s->aspected_width = get_bits(gb, 8); // par_width\n\n        s->aspected_height = get_bits(gb, 8); // par_height\n\n    }else{\n\n        s->aspected_width = pixel_aspect[s->aspect_ratio_info][0];\n\n        s->aspected_height= pixel_aspect[s->aspect_ratio_info][1];\n\n    }\n\n\n\n    if ((s->vol_control_parameters=get_bits1(gb))) { /* vol control parameter */\n\n        int chroma_format= get_bits(gb, 2);\n\n        if(chroma_format!=1){\n\n            printf(\"illegal chroma format\\n\");\n\n        }\n\n        s->low_delay= get_bits1(gb);\n\n        if(get_bits1(gb)){ /* vbv parameters */\n\n            get_bits(gb, 15);\t/* first_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* first_half_vbv_buffer_size */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 3);\t/* latter_half_vbv_buffer_size */\n\n            get_bits(gb, 11);\t/* first_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */               \n\n        }\n\n    }else{\n\n        // set low delay flag only once so the smart? low delay detection wont be overriden\n\n        if(s->picture_number==0)\n\n            s->low_delay=0;\n\n    }\n\n\n\n    s->shape = get_bits(gb, 2); /* vol shape */\n\n    if(s->shape != RECT_SHAPE) printf(\"only rectangular vol supported\\n\");\n\n    if(s->shape == GRAY_SHAPE && vo_ver_id != 1){\n\n        printf(\"Gray shape not supported\\n\");\n\n        skip_bits(gb, 4);  //video_object_layer_shape_extension\n\n    }\n\n\n\n    skip_bits1(gb);   /* marker */\n\n    \n\n    s->time_increment_resolution = get_bits(gb, 16);\n\n    \n\n    s->time_increment_bits = av_log2(s->time_increment_resolution - 1) + 1;\n\n    if (s->time_increment_bits < 1)\n\n        s->time_increment_bits = 1;\n\n    skip_bits1(gb);   /* marker */\n\n\n\n    if (get_bits1(gb) != 0) {   /* fixed_vop_rate  */\n\n        skip_bits(gb, s->time_increment_bits);\n\n    }\n\n\n\n    if (s->shape != BIN_ONLY_SHAPE) {\n\n        if (s->shape == RECT_SHAPE) {\n\n            skip_bits1(gb);   /* marker */\n\n            width = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            height = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            if(width && height){ /* they should be non zero but who knows ... */\n\n                s->width = width;\n\n                s->height = height;\n\n//                printf(\"width/height: %d %d\\n\", width, height);\n\n            }\n\n        }\n\n        \n\n        s->progressive_sequence= get_bits1(gb)^1;\n\n        if(!get_bits1(gb)) printf(\"OBMC not supported (very likely buggy encoder)\\n\");   /* OBMC Disable */\n\n        if (vo_ver_id == 1) {\n\n            s->vol_sprite_usage = get_bits1(gb); /* vol_sprite_usage */\n\n        } else {\n\n            s->vol_sprite_usage = get_bits(gb, 2); /* vol_sprite_usage */\n\n        }\n\n        if(s->vol_sprite_usage==STATIC_SPRITE) printf(\"Static Sprites not supported\\n\");\n\n        if(s->vol_sprite_usage==STATIC_SPRITE || s->vol_sprite_usage==GMC_SPRITE){\n\n            if(s->vol_sprite_usage==STATIC_SPRITE){\n\n                s->sprite_width = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_height= get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_left  = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_top   = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n            }\n\n            s->num_sprite_warping_points= get_bits(gb, 6);\n\n            s->sprite_warping_accuracy = get_bits(gb, 2);\n\n            s->sprite_brightness_change= get_bits1(gb);\n\n            if(s->vol_sprite_usage==STATIC_SPRITE)\n\n                s->low_latency_sprite= get_bits1(gb);            \n\n        }\n\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        \n\n        if (get_bits1(gb) == 1) {   /* not_8_bit */\n\n            s->quant_precision = get_bits(gb, 4); /* quant_precision */\n\n            if(get_bits(gb, 4)!=8) printf(\"N-bit not supported\\n\"); /* bits_per_pixel */\n\n            if(s->quant_precision!=5) printf(\"quant precission %d\\n\", s->quant_precision);\n\n        } else {\n\n            s->quant_precision = 5;\n\n        }\n\n        \n\n        // FIXME a bunch of grayscale shape things\n\n\n\n        if((s->mpeg_quant=get_bits1(gb))){ /* vol_quant_type */\n\n            int i, v;\n\n            \n\n            /* load default matrixes */\n\n            for(i=0; i<64; i++){\n\n                int j= s->dsp.idct_permutation[i];\n\n                v= ff_mpeg4_default_intra_matrix[i];\n\n                s->intra_matrix[j]= v;\n\n                s->chroma_intra_matrix[j]= v;\n\n                \n\n                v= ff_mpeg4_default_non_intra_matrix[i];\n\n                s->inter_matrix[j]= v;\n\n                s->chroma_inter_matrix[j]= v;\n\n            }\n\n\n\n            /* load custom intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n                    \n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n            }\n\n\n\n            /* load custom non intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n\n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= v;\n\n                    s->chroma_inter_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= last;\n\n                    s->chroma_inter_matrix[j]= last;\n\n                }\n\n            }\n\n\n\n            // FIXME a bunch of grayscale shape things\n\n        }\n\n\n\n        if(vo_ver_id != 1)\n\n             s->quarter_sample= get_bits1(gb);\n\n        else s->quarter_sample=0;\n\n\n\n        if(!get_bits1(gb)) printf(\"Complexity estimation not supported\\n\");\n\n\n\n        s->resync_marker= !get_bits1(gb); /* resync_marker_disabled */\n\n\n\n        s->data_partitioning= get_bits1(gb);\n\n        if(s->data_partitioning){\n\n            s->rvlc= get_bits1(gb);\n\n            if(s->rvlc){\n\n                printf(\"reversible vlc not supported\\n\");\n\n            }\n\n        }\n\n        \n\n        if(vo_ver_id != 1) {\n\n            s->new_pred= get_bits1(gb);\n\n            if(s->new_pred){\n\n                printf(\"new pred not supported\\n\");\n\n                skip_bits(gb, 2); /* requested upstream message type */\n\n                skip_bits1(gb); /* newpred segment type */\n\n            }\n\n            s->reduced_res_vop= get_bits1(gb);\n\n            if(s->reduced_res_vop) printf(\"reduced resolution VOP not supported\\n\");\n\n        }\n\n        else{\n\n            s->new_pred=0;\n\n            s->reduced_res_vop= 0;\n\n        }\n\n\n\n        s->scalability= get_bits1(gb);\n\n\n\n        if (s->scalability) {\n\n            GetBitContext bak= *gb;\n\n            int ref_layer_id;\n\n            int ref_layer_sampling_dir;\n\n            int h_sampling_factor_n;\n\n            int h_sampling_factor_m;\n\n            int v_sampling_factor_n;\n\n            int v_sampling_factor_m;\n\n            \n\n            s->hierachy_type= get_bits1(gb);\n\n            ref_layer_id= get_bits(gb, 4);\n\n            ref_layer_sampling_dir= get_bits1(gb);\n\n            h_sampling_factor_n= get_bits(gb, 5);\n\n            h_sampling_factor_m= get_bits(gb, 5);\n\n            v_sampling_factor_n= get_bits(gb, 5);\n\n            v_sampling_factor_m= get_bits(gb, 5);\n\n            s->enhancement_type= get_bits1(gb);\n\n            \n\n            if(   h_sampling_factor_n==0 || h_sampling_factor_m==0 \n\n               || v_sampling_factor_n==0 || v_sampling_factor_m==0){\n\n               \n\n//                fprintf(stderr, \"illegal scalability header (VERY broken encoder), trying to workaround\\n\");\n\n                s->scalability=0;\n\n               \n\n                *gb= bak;\n\n            }else\n\n                printf(\"scalability not supported\\n\");\n\n            \n\n            // bin shape stuff FIXME\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 27201, "substitutes": {"s": ["sys", "w", "ns", "ts", "vs", "sites", "sq", "ps", "sync", "self", "bs", "u", "es", "gs", "sym", "xs", "f", "service", "qs", "js", "fs", "n", "t", "r", "ops", "S", "p", "m", "b", "c", "ges", "storage", "ds", "us", "ins", "su", "is", "sets", "spec", "services", "h", "sl", "settings", "its", "rates", "g", "rs", "ses", "this", "ss", "features", "bis", "d", "ms", "conf", "sg", "ks", "e", "session", "less", "hs", "full", "sf", "ssl", "cs", "o", "si", "os", "ls", "parts", "l"], "gb": ["gu", "cod", "b", "Gb", "wb", "bo", "gin", "lb", "bn", "bb", "ge", "usb", "gru", "storage", "gnu", "rb", "gal", "bf", "gam", "gom", "cb", "py", "bc", "gy", "bug", "sync", "kb", "google", "bp", "ym", "range", "bs", "db", "hub", "boot", "gs", "cell", "cfg", "gi", "phy", "jpg", "gae", "eb", "gd", "lib", "mb", "ko", "che", "sb", "GB", "gp", "rg", "ga", "gow", "game", "ged", "git", "gio", "buff", "igh", "gh", "gg", "gc", "go", "bm", "bg", "sl", "gm", "ui", "big", "cgi", "g"], "height": ["gap", "slice", "resolution", "diff", "def", "inches", "id", "depth", "padding", "input", "density", "crop", "shape", "length", "dist", "window", "pull", "bottom", "volume", "quality", "Height", "png", "alpha", "ty", " heights", "stroke"], "vo_ver_id": ["vo_ver_name", "vo_version_name", "vo_ver_length", "vo_verxtype", "vo_version_type", "vo_ver_head", "vo_veraclength", "vo_veracinfo", "vo_ver_info", "vo_ver_ref", "vo_verxid", "vo_veracid", "vo_ver_ident", "vo_verxident", "vo_veracname", "vo_version_bit", "vo_verxref", "vo_version_ident", "vo_version_length", "vo_ver_bit", "vo_version_info", "vo_version_id", "vo_version_head", "vo_version_ref", "vo_ver_type"]}}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "void ff_init_me(MpegEncContext *s){\n\n    MotionEstContext * const c= &s->me;\n\n    c->avctx= s->avctx;\n\n\n\n    ff_set_cmp(&s->dsp, s->dsp.me_pre_cmp, c->avctx->me_pre_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_cmp, c->avctx->me_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_sub_cmp, c->avctx->me_sub_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.mb_cmp, c->avctx->mb_cmp);\n\n    \n\n    c->flags    = get_flags(c, 0, c->avctx->me_cmp    &FF_CMP_CHROMA);\n\n    c->sub_flags= get_flags(c, 0, c->avctx->me_sub_cmp&FF_CMP_CHROMA);\n\n    c->mb_flags = get_flags(c, 0, c->avctx->mb_cmp    &FF_CMP_CHROMA);\n\n\n\n/*FIXME s->no_rounding b_type*/\n\n    if(s->flags&CODEC_FLAG_QPEL){\n\n        c->sub_motion_search= qpel_motion_search;\n\n        c->qpel_avg= s->dsp.avg_qpel_pixels_tab;\n\n        if(s->no_rounding) c->qpel_put= s->dsp.put_no_rnd_qpel_pixels_tab;\n\n        else               c->qpel_put= s->dsp.put_qpel_pixels_tab;\n\n    }else{\n\n        if(c->avctx->me_sub_cmp&FF_CMP_CHROMA)\n\n            c->sub_motion_search= hpel_motion_search;\n\n        else if(   c->avctx->me_sub_cmp == FF_CMP_SAD \n\n                && c->avctx->    me_cmp == FF_CMP_SAD \n\n                && c->avctx->    mb_cmp == FF_CMP_SAD)\n\n            c->sub_motion_search= sad_hpel_motion_search; // 2050 vs. 2450 cycles\n\n        else\n\n            c->sub_motion_search= hpel_motion_search;\n\n    }\n\n    c->hpel_avg= s->dsp.avg_pixels_tab;\n\n    if(s->no_rounding) c->hpel_put= s->dsp.put_no_rnd_pixels_tab;\n\n    else               c->hpel_put= s->dsp.put_pixels_tab;\n\n\n\n    if(s->linesize){\n\n        c->stride  = s->linesize; \n\n        c->uvstride= s->uvlinesize;\n\n    }else{\n\n        c->stride  = 16*s->mb_width + 32;\n\n        c->uvstride=  8*s->mb_width + 16;\n\n    }\n\n\n\n    // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it\n\n    if((c->avctx->me_cmp&FF_CMP_CHROMA) && !s->dsp.me_cmp[2]){\n\n        s->dsp.me_cmp[2]= zero_cmp;\n\n    }\n\n    if((c->avctx->me_sub_cmp&FF_CMP_CHROMA) && !s->dsp.me_sub_cmp[2]){\n\n        s->dsp.me_sub_cmp[2]= zero_cmp;\n\n    }\n\n    c->hpel_put[2][0]= c->hpel_put[2][1]=\n\n    c->hpel_put[2][2]= c->hpel_put[2][3]= zero_hpel;\n\n\n\n    c->temp= c->scratchpad;\n\n}\n", "idx": 27203, "substitutes": {"s": ["S", "comments", "sc", "ses", "rs", "sys", "k", "w", "this", "ss", "p", "m", "b", "i", "ns", "se", "d", "ts", "x", "sq", "ds", "conf", "us", "ps", "sg", "ks", "sync", "su", "is", "u", "e", "es", "gs", "site", "o", "sets", "ic", "session", "spec", "l", "si", "sym", "aws", "os", "ctx", "sb", "services", "sec", "xs", "as", "h", "ls", "f", "fs", "service", "n", "y", "js", "t", "qs", "r", "sf", "settings", "in", "ssl", "cs", "g"], "c": ["sc", "cm", "k", "w", "dc", "uc", "cd", "p", "b", "m", "i", "C", "d", "x", "enc", "xc", "ec", "cur", "config", "cr", "conf", "cus", "ct", "us", "bc", "cy", "ch", "self", "cont", "u", "e", "fc", "es", "con", "o", "ic", "cl", "ac", "vc", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "com", "co", "lc", "ctrl", "h", "ca", "f", "y", "n", "cu", "t", "coll", "q", "core", "v", "g", "r", "nc", "l", "cs", "ce", "pc"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void filter(MpegAudioContext *s, int ch, short *samples, int incr)\n\n{\n\n    short *p, *q;\n\n    int sum, offset, i, j, norm, n;\n\n    short tmp[64];\n\n    int tmp1[32];\n\n    int *out;\n\n\n\n    //    print_pow1(samples, 1152);\n\n\n\n    offset = s->samples_offset[ch];\n\n    out = &s->sb_samples[ch][0][0][0];\n\n    for(j=0;j<36;j++) {\n\n        /* 32 samples at once */\n\n        for(i=0;i<32;i++) {\n\n            s->samples_buf[ch][offset + (31 - i)] = samples[0];\n\n            samples += incr;\n\n        }\n\n\n\n        /* filter */\n\n        p = s->samples_buf[ch] + offset;\n\n        q = filter_bank;\n\n        /* maxsum = 23169 */\n\n        for(i=0;i<64;i++) {\n\n            sum = p[0*64] * q[0*64];\n\n            sum += p[1*64] * q[1*64];\n\n            sum += p[2*64] * q[2*64];\n\n            sum += p[3*64] * q[3*64];\n\n            sum += p[4*64] * q[4*64];\n\n            sum += p[5*64] * q[5*64];\n\n            sum += p[6*64] * q[6*64];\n\n            sum += p[7*64] * q[7*64];\n\n            tmp[i] = sum >> 14;\n\n            p++;\n\n            q++;\n\n        }\n\n        tmp1[0] = tmp[16];\n\n        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];\n\n        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];\n\n\n\n        /* integer IDCT 32 with normalization. XXX: There may be some\n\n           overflow left */\n\n        norm = 0;\n\n        for(i=0;i<32;i++) {\n\n            norm |= abs(tmp1[i]);\n\n        }\n\n        n = av_log2(norm) - 12;\n\n        if (n > 0) {\n\n            for(i=0;i<32;i++) \n\n                tmp1[i] >>= n;\n\n        } else {\n\n            n = 0;\n\n        }\n\n\n\n        idct32(out, tmp1, s->sblimit, n);\n\n\n\n        /* advance of 32 samples */\n\n        offset -= 32;\n\n        out += 32;\n\n        /* handle the wrap around */\n\n        if (offset < 0) {\n\n            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), \n\n                    s->samples_buf[ch], (512 - 32) * 2);\n\n            offset = SAMPLES_BUF_SIZE - 512;\n\n        }\n\n    }\n\n    s->samples_offset[ch] = offset;\n\n\n\n    //    print_pow(s->sb_samples, 1152);\n\n}\n", "idx": 27237, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "b", "m", "c", "server", "ns", "ss", "ts", "ds", "conf", "ps", "sg", "ks", "sync", "self", "su", "u", "is", "es", "gs", "sp", "e", "o", "sets", "http", "session", "spec", "l", "sv", "si", "aws", "os", "sb", "services", "xs", "sa", "sup", "ls", "f", "fs", "service", "js", "t", "a", "v", "sl", "r", "sf", "ssl", "cs", "g"], "ch": ["sch", "code", "sk", "cm", "ht", "th", "chip", "k", "CH", "b", "c", "ach", "chrom", "bh", "conf", "col", "Ch", "cy", "chn", "fr", " chunk", "chan", "cher", "cl", "che", "ctx", "cp", "change", "com", "channel", "ich", "h", "f", "count", "chi", "cor", "ches", "zh", "conn", "range", "cs", "ph", "sh"], "samples": ["insamples", "says", "ssizes", "Says", " smodels", "psmodels", "ssamples", "ssamps", " sans", "samps", "sources", "sans", "ssmodels", "ssans", " sources", "Samps", "psamps", "insamps", "spamples", "Sources", "spources", "insources", "Samples", "smodels", " says", "insans", "spays", "spamps", "psamples", "sizes", "ssources", " sizes", "psizes", " samps"], "incr": ["discr", "discl", "infr", "incrs", " incp", " incerr", "infl", "discp", "inferr", "infp", "upur", "incur", "incl", "discerr", "uprs", "circl", "circrs", "infrs", "circr", "circur", "incerr", "upl", "upr", "infur", "incp", " incl"], "p": ["pp", "pa", "k", "np", "er", "m", "b", "c", "app", "pg", "x", "api", "P", "py", "jp", "pe", "ps", "it", "op", "pad", "u", "private", "mp", "e", "point", "sp", "hp", "o", "at", "per", "http", "cp", "pm", "cop", "wp", "h", "lp", "f", "po", "y", "pr", "tp", "t", "fp", "ip", "a", "v", "pu", "r", "pi", "vp", "pre", "l", "pc", "ap", "g"], "q": ["iq", "Q", "k", "w", "z", "b", "m", "c", "question", "app", "d", "sh", "x", "qa", "queue", "qt", "sq", "config", "qi", "form", "sync", "id", "u", "comment", "charge", "get", "like", "eq", "view", "co", "req", "quad", "h", "qu", "f", "count", "qs", "quant", "y", "qq", "quality", "t", "v", "r", "dq", "query", "secure", "l", "ac", "ph", "g"], "sum": ["use", "summary", "gram", "skip", "sc", "mass", "m", "cost", "ass", "sh", "name", "Sum", "se", "sam", "weight", "cur", "add", "gam", "up", "conf", "am", "error", "pass", "num", "su", "u", "key", "unit", "sp", "mean", "mem", "miss", "ma", "min", "err", "ul", "sub", "ann", "average", "si", "cal", "sign", "loss", "stat", "size", "scale", "cache", "fat", "um", "part", "sim", "count", "f", "total", "comment", "mix", "index", "un", "cu", "cum", "ho", "mu", "alpha", "mit", "pos", "ac", "vol", "g"], "offset": ["annot", "adjust", "info", "shift", "position", "image", "api", "base", "align", "pointer", "address", "prefix", "Offset", "error", "end", "range", "o", "amp", "padding", "start", "set", "ii", "si", "ai", "output", "anch", "order", "size", "origin", "off", "addr", "length", "timeout", "reset", "part", "f", "entry", "index", "fp", "attr", "ace", "ui", "pos", "area", "phase"], "i": ["z", "ie", "ei", "it", "io", "u", "li", "start", "ini", "bi", "ai", "f", "ami", "k", "m", "b", "c", "x", "ti", "mi", "phi", "qi", "ri", "is", "di", "ik", "ci", "eni", "in", "g", "yi", "d", "e", "at", "uri", "ii", "fi", "I", "ori", "iu", "init", "anti", "my", "info", "ix", "api", "id", "gi", "ji", "o", "zi", "multi", "xi", "inner", "si", "ni", "y", "mini", "oi", "ip", "index", "v", "mu", "pi", "ui", "l"], "j": ["k", "z", "ie", "b", "m", "c", "d", "x", "br", "jp", "aj", "qi", "jj", "it", "num", "u", "o", "ji", "li", "jc", "ii", "si", "ij", "jet", "h", "f", "y", "jl", "js", "t", "v", "J", "r", "pos", "ind", "ui", "l", "ja", "g"], "norm": ["mask", "mom", "neg", "dc", "carry", "Norm", "transform", "d", "ov", "orm", "weight", "nn", "diff", "bd", "beta", "global", "form", "sync", "num", "orig", "raw", "mean", "mem", "unit", "radius", "nom", "max", "err", "term", "ord", "loc", "small", "flat", "ann", "common", "dev", "sign", "mn", "loss", "scale", "den", "ng", "dist", "im", "f", "color", "index", "coll", "desc", "init", "ind", "root", "normal", "draw", "core", "pos", "len", "chrom", "fun"], "n": ["k", "none", "z", "m", "b", "c", "pn", "ns", "sn", "d", "nat", "bn", "adj", "x", "fn", "en", "no", "nn", "non", "num", "ne", "u", "count", "nor", "e", "o", "nb", "nc", "ni", "nt", "cn", "number", "not", "N", "f", "y", "nw", "ny", "net", "un", "na", "conn", "t", "nu", "v", "r", "nan", "l", "len", "dn", "g"], "tmp": ["temp", "pp", "txt", "code", "np", "slice", "page", "app", "m", "b", "c", "batch", "cv", "bb", "x", "data", "test", "storage", "media", "img", "config", "sq", "area", "py", "cb", "up", "jp", "bp", "front", "proc", "pad", "cmp", "mp", "buf", "seed", "sp", "extra", "amp", "audio", "nb", "flat", "sample", "output", "nt", "cp", "cache", "crop", "now", "current", "sup", "zip", "buff", "wp", "uv", "source", "po", "tp", "t", "fp", "mm", "cpp", "v", "src", "meta", "pre", "map", "bt", "params"], "tmp1": ["p3", "cmp2", "temp3", "cmp1", "mpone", "p1", "temp2", "cmpone", "tmp0", "zip1", "mp3", " tmp3", "zip0", "tmp2", "mp1", " tmp2", "pone", "tmpone", "tmp3", "mp0", "cmp0", "temp0", "zip2", "zipone", "mp2", "tempone", " tmpone", "temp1", " tmp0"], "out": ["temp", "code", "OUT", "obj", "w", "bin", "b", "m", "image", "x", "qa", "data", "doc", "no", "img", "again", "opt", "outs", "Out", "sync", "op", "num", "io", "orig", "o", "amp", "cmd", "input", "err", "bit", "at", "inner", "flat", "output", "parent", "new", "cache", "channel", "conv", "part", "source", "a", "v", "in", "result", "pos", "ac"]}}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254, "substitutes": {"cs": ["sc", "ses", "rs", "sk", "ss", "c", "CS", "ec", "acks", "ds", "cr", "cus", "ars", "ps", "cons", "ks", "sync", "css", "ys", "vc", "ics", "spec", "wcs", "cc", "ctx", "nas", "ras", "cf", "rc", "cas", "lc", "ls", "fs", "qs", "js", "ced", "cing", "ck", "acs", "ace", "ce"], "run": ["exec", "use", "build", "ru", "call", "thread", "Run", "execute", "play", "name", "job", "pass", "sync", "boot", "unit", "con", "cmd", "work", "runs", "min", "rm", "resource", "process", "re", "clean", "output", "rc", "ur", "view", "block", "ro", "mor", "man", "go", "un", "reg", "runner", "row", "r", "result", "ran", "fun"], "cpu": ["CPU", "node", "processor", "chip", "anc", "c", "uno", "lb", "android", "gru", "lan", "clock", "config", "component", "bc", "sync", "mac", "proc", "css", "gpu", "linux", "cmp", "boot", "unit", "hw", "phy", "process", "bench", "cli", "board", "cow", "cp", "cn", "ctx", "roc", "cache", "vm", "lc", "gc", "cu", "conn", "computer", "runner", "core", "pu", "uci", "nc", "pc"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n", "idx": 27256, "substitutes": {"dev": ["md", "obj", "user", "driver", "dc", "info", "app", "der", "d", "data", "test", "var", "conf", "diff", "bug", "def", "dd", "DEV", "ev", "die", "dom", "serial", "self", "dem", "cmd", "grad", " device", "wd", "nov", "req", "device", "develop", "mod", "development", "comment", "de", "plug", "Dev", "rad", "v", "ver", "pack", "block", " def"], "bus": ["user", "bc", "driver", "bin", "b", "name", "cat", "mount", "usb", "force", "back", "base", "config", "us", "prefix", "bug", "band", "def", "pass", "tag", "port", "die", "serial", "bs", "plugin", "self", "hub", "boot", "sync", "feed", "disk", "home", "bridge", "http", "controller", "bit", "Bus", "dir", "lib", "drive", "board", "os", "cache", "device", "length", "loop", "host", "plug", "dest", "pu", "pack", "block", "lock", "BUS"], "iommu_bus": ["iommus_boot", "iommu__bus", "iommu_bin", "iommu_BUS", "iommui_boot", "iommo_pass", "iommui_bus", "iommru_bus", "iommu_block", "iommu2bus", "iommo_plug", "iommru_BUS", "iommu2cat", "iommo_bus", "iommu_cat", "iommu_lib", "iommus_BUS", "iommru_band", "iommuit_lib", "iommu_usb", "iommu_us", "iommnu_BUS", "iommus_pass", "iommus_bus", "iommo_block", "iommo_usb", "iommu2lib", "iommo_dev", "iommui_lib", "iommuit_cat", "iommu_dev", "iommui_BUS", "iommu_controller", "iommo_BUS", "iommu_pass", "iommu_band", "iommnu_bin", "iommuit_plug", "iommo_us", "iommu__BUS", "iommu__dev", "iommnu_bus", "iommo_controller", "iommu2plug", "iommu__block", "iommnu_bug", "iommu_bug", "iommu_plug", "iommru_bin", "iommu__usb", "iommuit_bus", "iommu_boot"]}}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257, "substitutes": {"dst": ["idbl", "nrc", "edst", "pST", "isdst", "idST", " drc", " dsts", "dsts", "edsc", "frc", "fdst", "sdsp", "fdost", "nput", "Dsrc", "prc", "idstop", "edstop", "DST", "sdST", "isdsc", "fdbl", "dST", " dost", "fst", "fdste", "dsrc", "pst", " dste", " dsp", "pdrc", "edST", "pdsrc", " dbl", "cdsrc", "sdstop", "dstop", "sdsc", "fsrc", "dbl", "sdst", "pddest", "sdsts", "nst", "fdest", "cdST", "isdsp", "idste", "dsp", " dsc", "ddest", "dost", "nST", " dST", "pput", " dput", "cdst", "drc", "dsc", "isdsts", " ddest", "Dsc", "idst", "idost", " dsrc", "dste", "pdst", "Dst", "cdsc", "dput", "idsc"], "src": ["sc", "obl", "sys", "sr", "rib", "uc", "b", "sn", "img", "rb", "config", "vr", "cur", "rin", "cb", "bc", "inst", "sync", "url", "rec", "cmp", "rss", "fc", "sur", "sta", "rl", "vc", "loc", "sub", "lib", "st", "sel", "ctx", "stat", "sb", "rc", "conv", "sup", "dist", "source", "dest", "stab", "sl", "attr", "ssl"], "fcc_offset": ["fct_offset", "fct_adjusted", "fCCsoffset", "fccsoffset", "fcc2ref", "fccsOffset", "fcc_adjusted", "fck_offset", "fck_Offset", "fcc_position", "fcc_off", "fcc2offset", "fcc_ref", "fCC_offset", "fck_off", "fcc2off", "fCC_ref", "fct_ref", "fCC_off", "fCCsoff", "fCCsref", "fcc_Offset", "fccsref", "fct_position", "fccsoff"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_decode(AVCodecContext *avctx,\n\n                         void *data, int *data_size,\n\n                         AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    AVSubtitle *sub = data;\n\n    const uint8_t *p, *p_end;\n\n    int segment_type;\n\n    int page_id;\n\n    int segment_length;\n\n    int i;\n\n\n\n    av_dlog(avctx, \"DVB sub packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    if (buf_size <= 6 || *buf != 0x0f) {\n\n        av_dlog(avctx, \"incomplete or broken packet\");\n\n        return -1;\n\n    }\n\n\n\n    p = buf;\n\n    p_end = buf + buf_size;\n\n\n\n    while (p_end - p >= 6 && *p == 0x0f) {\n\n        p += 1;\n\n        segment_type = *p++;\n\n        page_id = AV_RB16(p);\n\n        p += 2;\n\n        segment_length = AV_RB16(p);\n\n        p += 2;\n\n\n\n        if (p_end - p < segment_length) {\n\n            av_dlog(avctx, \"incomplete or broken packet\");\n\n            return -1;\n\n        }\n\n\n\n        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||\n\n            ctx->composition_id == -1 || ctx->ancillary_id == -1) {\n\n            switch (segment_type) {\n\n            case DVBSUB_PAGE_SEGMENT:\n\n                dvbsub_parse_page_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_REGION_SEGMENT:\n\n                dvbsub_parse_region_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_CLUT_SEGMENT:\n\n                dvbsub_parse_clut_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_OBJECT_SEGMENT:\n\n                dvbsub_parse_object_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAYDEFINITION_SEGMENT:\n\n                dvbsub_parse_display_definition_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAY_SEGMENT:\n\n                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);\n\n                break;\n\n            default:\n\n                av_dlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\",\n\n                        segment_type, page_id, segment_length);\n\n                break;\n\n            }\n\n        }\n\n\n\n        p += segment_length;\n\n    }\n\n\n\n    return p - buf;\n\n}\n", "idx": 27261, "substitutes": {"avctx": ["navcontext", "avalconn", "avcontext", "avesync", "avalcn", "afcontext", "abcc", "avectx", "aviactx", "ajctx", "avekb", "avcn", "ajcot", "abcu", "airctx", "aviacas", "ajwcs", "aircontext", "navcca", "affw", "AVwcs", "AVcontext", "afcca", "avecc", " avci", "avcu", "abcf", "avepkg", "afsync", "avalfw", "avalloc", "aircot", "avcca", "abcontext", "AVconfig", "AVcn", "airpkg", "AVloc", "avalcontext", "AVvoc", "avalvoc", "afctx", "avconfig", "avpkg", "avalctx", "aviacontext", "avcot", "afci", "avfw", "avloc", "abctx", "aveloc", "AVcas", "Avci", "AVctx", "afvoc", "avci", "avcf", "avalwcs", "avalcf", "avevoc", "avcc", "avecontext", "avefw", "Avcu", "avsync", "avecu", "avvoc", "avalkb", "afcot", "avconn", "ajpkg", "afconn", "ajcontext", "navconn", "Avctx", "avalcca", "avecf", "afpkg", "abpkg", "aviaconfig", "ajcn", "avkb", "AVcf", "afcu", " avcu", "avalcas", "AVkb", "avalsync", "Avcontext", "avalcc", " avcontext", "avcas", "navctx", "avalconfig", "avwcs"], "data": ["load", "Data", "body", "package", "primary", "batch", "frame", "context", "image", "d", "cat", "buffer", "api", "base", "media", "text", "config", "next", "reader", "ra", "rec", "aux", "message", "padding", "input", "dat", "sample", "parent", "board", "client", "size", "rc", "cache", "response", "channel", "block", "length", "buff", "window", "au", "bytes", "umi", "value", "da", "DATA", "content", "results", "root", "meta", "map", "result", "val"], "data_size": ["data_start", "buffer_width", "datablocksize", "datablockwidth", "buffer_length", "data_width", "datablocklength", "buffer_start", "buffer_size", "datablockstart", "data_length"], "avpkt": ["AVPuto", "AVfct", "AVpacket", "avlpke", "avPkt", "avhkt", "avfkn", "avPacket", "avhacket", "AVcpacket", "avlpacket", "avlputo", "avfke", "avpbuto", "AVfacket", "avpke", "avPke", "AVPkt", "avlpkt", "AVputo", "avcpkn", "avfct", "AVfke", "AVpkn", "avhct", "avpkn", "avpbke", "avspkt", "avhke", "AVpke", "avcpacket", "avcpkt", "AVcpct", "AVPke", "avputo", "avspkn", "avspct", "avPct", "avpacket", "avPuto", "AVpct", "avpbacket", "avfkt", "avspacket", "avpbkt", "AVcpkt", "avpct", "AVcpkn", "avfacket", "avcpct", "AVPacket", "AVfkt", "AVpkt"], "buf": ["seq", "uf", "bag", "uc", "b", "batch", "wb", "c", "cv", "grab", "vec", "buffer", "queue", "img", "rb", "config", "br", "ab", "cur", "prop", "cb", "back", "bc", "port", "front", "num", "bp", "pad", "mem", "home", "ff", "cmd", "padding", "pb", "cap", "loc", "box", "pool", "cp", "fb", "cf", "rc", "alloc", "cache", "feat", "conv", "cas", "length", "buff", "array", "h", "f", "src", "fp", "v", "pack", "block", "large"], "ctx": ["exec", "txt", "remote", "pa", "cm", "np", "cca", "communication", "anc", "c", "pkg", "context", "cv", "qa", "xc", "media", "sq", "config", "component", "jp", "support", "cb", "aka", "bc", "concept", "sync", "cmp", "wx", "fc", "chan", "hw", "cmd", "vc", "loc", "lib", "fw", "cli", "parent", "cc", "cp", "ci", "cf", "cn", "client", "rc", "co", "cas", "git", "lc", "wp", "ctrl", "ca", "cu", "conn", "fp", "ha", "ck", "nc", "tx", "connection", "cam"], "sub": ["summary", "seq", "sc", "section", "uc", "app", "name", "sam", "job", "text", "config", "pub", "ch", "form", "rec", "sp", "path", "pl", "sec", "ub", "sup", "part", "child", "reg", "Sub", "meta", "desc"], "p": ["pp", "pa", "np", "page", "b", "pt", "c", "m", "parser", "d", "x", "api", "P", "py", "jp", "pe", "up", "ps", "dp", "bp", "port", "op", "proc", "u", "mp", "e", "point", "sp", "patch", "o", "pb", "s", "at", "per", "pl", "parent", "cp", "client", "wp", "h", "part", "lp", "f", "po", "y", "pr", "n", "tp", "j", "t", "a", "fp", "q", "ip", "v", "r", "pi", "pre", "pos", "vp", "l", "post", "pc", "ap", "g"], "p_end": ["p_get", "p___en", "p___end", "data_ident", "data_end", "p_post", "dataIPoffset", "P__ends", "dataIPend", "p_range", "lp___end", "P__start", "lp_range", "p___post", "p_ident", "p_offset", "lp___en", "lp_id", "lp___id", "p_center", "p_en", "ap_ending", "p___range", "pixcenter", "P__get", "p_ends", "p__end", "pixend", "p__ends", "P_ends", "dataIPpost", "P_get", "p___id", "p__get", "p_ending", "P_end", "pIPoffset", "P__end", "ap_begin", "pIPpost", "ap_end", "pIPend", "p_begin", "pIPident", "data_post", "lp_end", "p_start", "pixbegin", "data_offset", "P_start", "dataIPident", "lp_en", "p___ident", "ap_center", "p___offset", "p__start", "p_id", "lp___range", "pixending"], "segment_type": ["segment_name", "segment_id", "sement_style", "segment_style", "sement_id", "sement_name", "sement_type", "sement_length"], "page_id": ["page___type", "section_id", "page___id", " page_uri", " page_sid", "page_pad", "page_iden", " page_iden", "page___no", " page_no", " page_num", "page_uri", "section_iden", "page_case", "pageOiden", "page_num", "page_sid", "section_ids", "section_case", "pageOid", " page_type", "page___num", "page_ids", "page_type", " page_pad", "pageOpad", "page_no", "pageOtype"], "segment_length": ["asedata", "segments_end", "ase\n", "segmentityend", "pedata", "aseend", "segment_len", "segmentalltype", "segment_number", "segment_base", "peend", "sement_id", "segment_size", "pe\n", "segment_count", " sedata", "segmentalltext", "segmentlenlen", "sement_len", "sement_base", "sement_text", "segmentitynumber", "sement_end", "sement_length", "sedata", "segments_size", "segmentaltype", "segment_id", "segmentalend", "se\n", "segments_type", "segmentaltext", "segmentlenid", " se\n", "segments_number", "sement_type", " seend", "segmentlenlength", "segments_count", "segmentitytype", "segmentallength", "segmentitylength", "segmentalllength", "segments_length", "seend", "segment_end", "segment_text", "segmentlenbase", "segmentallend"], "i": ["yi", "b", "m", "c", "info", "d", "x", "api", "adi", "ti", "mi", "phi", "qi", "end", "ri", "id", "io", "ui", "u", "e", "li", "gi", "o", "zi", "multi", "s", "start", "xi", "uri", "ii", "bi", "si", "ai", "di", "ini", "ci", "fi", "eni", "vi", "lc", "f", "I", "mini", "oi", "n", "ip", "j", "t", "a", "index", "v", "iu", "r", "pi", "mu", "l", "hi"]}}
{"project": "qemu", "commit_id": "04088adbe0c5adca66adb6022723362ad90ed0fc", "target": 0, "func": "static void *mpc8544_load_device_tree(target_phys_addr_t addr,\n\n                                     uint32_t ramsize,\n\n                                     target_phys_addr_t initrd_base,\n\n                                     target_phys_addr_t initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    void *fdt = NULL;\n\n#ifdef CONFIG_FDT\n\n    uint32_t mem_reg_property[] = {0, ramsize};\n\n    char *filename;\n\n    int fdt_size;\n\n    int ret;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    qemu_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n", "idx": 27266, "substitutes": {"addr": ["seq", "args", "ock", "arm", "name", "base", "config", "ad", "address", "type", "db", "arr", "cap", "ord", "offset", "ptr", "oa", "endor", "part", "ext", "amd", "ip", "arp", "conn", "host", "ace", "pos", "len"], "ramsize": ["RAMSIZE", "memname", "mmaddress", "ramaddress", "memaddress", "gramname", "mmSize", "ramSize", "mmname", "ramname", " ramSIZE", "gramsize", "memSize", "mmsize", "memSIZE", "gramaddress", "RAMclass", "gramSize", "RAMsize", "memclass", "memsize", "RAMSize", " ramclass", "ramclass", " ramSize", "ramSIZE"], "initrd_base": ["initrt_scale", "initrd01base", "initrd01source", "initrd2unit", "initrdMbase", "initrn01base", "initrd_start", "initrid_size", "initrdMscale", "initrt_length", "initrd_unit", "initrd01start", "initrd_length", "initrn01unit", "initrd2source", "initrd_area", "initrdvsource", "initrt_base", "initrn01source", "initrdMlength", "initrn01start", "initrd_scale", "initrd_name", "initrn_unit", "initrn_base", "initrd_source", "initrt_size", "initrdvunit", "initrn_source", "initrdMsize", "initrid_base", "initrid_name", "initrid_area", "initrdvstart", "initrn_start", "initrdvbase", "initrd01unit", "initrd2start", "initrd2base"], "initrd_size": ["initrt_scale", "initrt_SIZE", "initrd_SIZE", "initrt_base", "initrd_scale", "initrt_adjust", "initrd_align", "initrt_size", "initrt_align", "initrd_adjust"], "kernel_cmdline": ["kernel_commandlink", "kernel_commandlines", "kernel_cmdlic", "kernel_cmdlines", "kernel_Cmdlic", "kernel_CmdLine", "kernel_Cmdline", "kernel_hardline", "kernel_commandLine", "kernel_commandlic", "kernel_mainlink", "kernel_mainlines", "kernel_cmdLine", "kernel_hardlink", "kernel_mainline", "kernel_cmdlink", "kernel_hardlines", "kernel_commandline"], "fdt": ["fxtt", "cdt", "windte", "dlnt", "fdta", "sdc", "dbT", "dltr", "dlc", "cdte", "sdtt", "dfte", "dbtf", "cdtr", "fedt", "fdtf", "ldtf", "FDT", "fdtr", "ldte", "windtr", "fct", "dlte", "fdT", "FDt", "vdt", "ddtt", "fxnt", "fctt", "dfT", "vdc", "fdc", "fctf", "dfta", "dbt", "dltf", "ddtr", "dfnt", "dft", "dftf", "fdp", "FDtf", "fedtr", "FDp", "ldtr", "ldt", "dftt", "FDtt", "fdte", "dltt", "sdt", "vdT", "ddc", "windt", "fxt", "fedte", "ddt", "ddte", "sdp", "cdtt", "dftr", "windnt", "fedtf", "FDc", "ddp", "dbtt", "fdtt", "dfc", "fxtf", "dlta", "dlT", "dlt", "vdta", "fcnt", "fdnt"], "mem_reg_property": ["mem_reg_properties", "mem_rg_property", "mem_reg__property", "mem_rec_prop", "mem_reg__info", "mem_rec_info", "mem_rec_property", "mem_reg_info", "mem_rec_properties", "mem_reg_attribute", "mem_rg_properties", "mem_rec_string", "mem_rg_data", "mem_reg__prop", "mem_rg_attribute", "mem_reg_data", "mem_reg_string", "mem_reg_prop"], "filename": ["location", "dll", "txt", "kn", "actual", "download", "subject", "successfully", "b", "wb", "name", "phrase", "fn", "bf", "prefix", "Filename", "url", "directory", "bj", "nil", "mil", "there", "path", "rl", "kl", "jpg", "uri", "loc", "wl", "offset", "binary", "journal", "lace", "jet", "files", "utf", "feat", "length", "il", "which", "json", "username", "SourceFile", "f", "source", "jl", "fp", "nl", "dyl", "database", "fil", "sf", "lua", "sheet", "document", "fd", "file", "til"], "fdt_size": ["fdt_base", "fdtlensize", "fdtf_cap", "fdtlenlength", "fdt_length", "fdt_len", "fdt_name", "fdtf_length", "fdtf_size", "fdtf_base", "fdT_length", "fdT_name", "fdtlenbase", "fdtlencap", "fdT_len", "fdt_cap", "fdT_size"], "ret": ["ref", "obj", "ft", "res", "hash", " RET", "cat", "flag", "rf", "back", "success", "bf", "py", "att", "opt", " Ret", "error", "pass", "def", "id", "num", "url", "rets", "key", "ben", "str", "rl", "valid", "bit", "mt", "det", "lit", "rev", "search", "true", "RET", "re", "art", "nt", "lt", "reply", "let", "feat", "ut", "arg", "Ret", "rt", "part", "alt", "reg", "resp", "match", "result", "post", "len", "val", "gt", "format", "fun"], "dirp": ["urlp", " dirpi", "dirpi", "dirc", "urlpc", "dirs", "c", " directoryp", "function", "d", "DIRpart", "dbp", " dirpart", "config", " directorys", "type", "airc", " directoryc", "dircp", "descpc", "write", "dirpart", "id", "proc", "linux", "urlcp", "num", "urlc", "path", "Dirs", " dirc", "dev", "descp", " dirs", "DIRd", "Dirp", "Dirpi", "new", "aircp", "Dirc", "dbd", " dird", "device", "dbpart", "dbc", "DIRp", "DIRc", " directorypi", "desccp", "func", "dird", "descc", "g", "_", "dirpc", "airpc", "airp"], "dp": ["pp", "ep", "np", "dc", "p", "director", "dim", "pg", "pkg", "d", "rpm", "dr", "jp", "port", "deb", "db", "hp", "adr", "pd", "dos", "pb", "dh", "dir", "tmp", "dl", "di", "cp", "pm", "dra", "gp", "iper", "wp", "lp", "dep", "tp", "dm", "fp", "dq", "DP", "vp", "df", "dB", "dn", "pid"], "buf": ["seq", "uf", "bag", "batch", "wb", "lb", "cv", "bn", "bb", "data", "buffer", "queue", "vec", "img", "rb", "config", "br", "bf", "bd", "text", "cb", "ab", "bc", "bh", "bs", "ff", "cmd", "cap", " buffer", "loc", "fw", "box", "output", " buffers", "ctx", "fb", "sb", "cf", "utf", "alloc", "ptr", "Buffer", "cas", "conv", "rc", "buff", "array", "uv", "src", "fp", "bt", "block", "fd", "desc"]}}
{"project": "FFmpeg", "commit_id": "3a25c707fae3c6e99fdda40474c3d74be24cc4c3", "target": 0, "func": "static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = av_new_stream(c->fc, c->fc->nb_streams);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = CODEC_TYPE_DATA;\n\n    st->start_time = 0; /* XXX: check */\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if(sc->chunk_count && (!sc->stts_count || !sc->sample_to_chunk_sz ||\n\n                           (!sc->sample_size && !sc->sample_count))){\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        sc->sample_count = 0; //ignore track\n\n        return 0;\n\n    }\n\n    if(!sc->time_rate)\n\n        sc->time_rate=1;\n\n    if(!sc->time_scale)\n\n        sc->time_scale= c->time_scale;\n\n    av_set_pts_info(st, 64, sc->time_rate, sc->time_scale);\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_AUDIO &&\n\n        !st->codec->frame_size && sc->stts_count == 1)\n\n        st->codec->frame_size = av_rescale(sc->time_rate, st->codec->sample_rate, sc->time_scale);\n\n\n\n    if(st->duration != AV_NOPTS_VALUE){\n\n        assert(st->duration % sc->time_rate == 0);\n\n        st->duration /= sc->time_rate;\n\n    }\n\n    sc->ffindex = st->index;\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR, \"stream %d, error opening file %s: %s\\n\",\n\n                   st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));\n\n    } else\n\n        sc->pb = c->fc->pb;\n\n\n\n    switch (st->codec->codec_id) {\n\n#ifdef CONFIG_H261_DECODER\n\n    case CODEC_ID_H261:\n\n#endif\n\n#ifdef CONFIG_H263_DECODER\n\n    case CODEC_ID_H263:\n\n#endif\n\n#ifdef CONFIG_MPEG4_DECODER\n\n    case CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width= 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n#ifdef CONFIG_VORBIS_DECODER\n\n    case CODEC_ID_VORBIS:\n\n#endif\n\n        st->codec->sample_rate= 0; /* let decoder init parameters properly */\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->sample_to_chunk);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n\n\n    return 0;\n\n}\n", "idx": 27272, "substitutes": {"c": ["cod", "k", "dc", "uc", "cd", "p", "m", "anc", "b", "this", "cit", "C", "cat", "xc", "ec", "cur", "config", "conf", "cr", "cus", "ct", "bc", "cy", "ch", "e", "fc", "con", "ic", "vc", "ac", "s", "icc", "cc", "ctx", "ci", "cp", "cf", "cn", "mc", "cache", "rc", "co", "lc", "ctrl", "ca", "f", "tc", "cu", "coll", "g", "r", "nc", "l", "cs", "ce", "pc"], "pb": ["summary", "pa", "cm", "param", "uc", "p", "auc", "b", "wb", "lb", "bb", "xb", "api", "rb", "ab", "bh", "gb", "cb", "bc", "abc", "arb", "bp", "platform", "proc", "plugin", "typ", "db", "mp", "rob", "PB", "fc", "eb", "pl", "icc", " eb", "pool", "orp", "cp", "fb", "sb", "abb", "ub", "pm", "client", "wp", "prototype", "lp", "tc", "prot", "tp", "bm", "fp", "cpp", "bps", "pc", "pid"], "atom": ["node", "mom", "chem", "param", "app", "orm", "fam", "asm", "tm", " com", "orb", "ab", "config", "om", "am", "prop", "abc", "mat", "ym", "article", "dom", "atomic", "typ", " atoms", "at", "mol", "object", "sym", "item", "com", "tab", "tc", "tom", "alog", " Atom", "attr", "org", "plane", "monitor", "account", "arch"], "st": ["fe", "sr", "ft", "pg", "ts", "ld", "ct", "ust", "sync", "sta", "cl", "nd", "set", "start", "nt", "est", "sci", "sa", "t", "sd", "sk", "se", "storage", "inst", "fr", "sp", "ci", "ost", "stage", "src", "sl", "pc", "ut", "sh", "esc", "rest", "ST", "uc", "ss", "sn", "pt", "scope", "capt", "ste", "cr", "St", "sth", "fc", "step", "str", "sts", "pl", "cc", "sb", "client", "sec", "lc", "stack", "post", "cs", "stop", "std", "sw", "cur", "config", "bc", "ast", "td", "tt", "rc", "ist", "co", "osc", "SC", "dest", "ace", "Sc"], "sc": ["acc", "esc", "sk", "sem", "sec", "scope", "uc", "dc", "ss", "anc", "cv", "sw", "enc", "test", "ec", "capt", "isc", "sq", "cur", "config", "cr", "ct", "access", "bc", "cy", "ch", "sync", "sche", "cont", "fc", "sp", "scl", "cl", " Sc", "contract", "spec", "loc", "sub", "pl", "cc", "ctx", "cp", "sb", "cf", "asc", "rc", "inc", "sci", "ga", "com", "osc", "scan", "lc", "SC", "sup", "ca", "usc", "tc", "src", "crit", "desc", "sd", "core", "ced", "Sc", "nc", "cs", "ce", "pc", "sh"], "ret": ["ref", "ner", "ft", "res", " RET", "red", "data", "back", "en", "success", "no", "fail", "att", "def", "pass", "rep", "url", "rets", "al", "arr", "str", "mt", "det", "lit", "RET", "re", "nt", "reply", "rc", "feat", "pet", "Ret", "rt", "ext", "gc", "status", "value", "aud", "reg", "alt", "resp", "desc", "result", "len", "val", "ut", "fun"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libschroedinger_encode_init(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroVideoFormatEnum preset;\n\n\n\n    /* Initialize the libraries that libschroedinger depends on. */\n\n    schro_init();\n\n\n\n    /* Create an encoder object. */\n\n    p_schro_params->encoder = schro_encoder_new();\n\n\n\n    if (!p_schro_params->encoder) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unrecoverable Error: schro_encoder_new failed. \");\n\n        return -1;\n\n    }\n\n\n\n    /* Initialize the format. */\n\n    preset = ff_get_schro_video_format_preset(avctx);\n\n    p_schro_params->format =\n\n                    schro_encoder_get_video_format(p_schro_params->encoder);\n\n    schro_video_format_set_std_video_format(p_schro_params->format, preset);\n\n    p_schro_params->format->width  = avctx->width;\n\n    p_schro_params->format->height = avctx->height;\n\n\n\n    if (set_chroma_format(avctx) == -1)\n\n        return -1;\n\n\n\n    if (avctx->color_primaries == AVCOL_PRI_BT709) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_HDTV;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_625;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_525;\n\n    }\n\n\n\n    if (avctx->colorspace == AVCOL_SPC_BT709) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_HDTV;\n\n    } else if (avctx->colorspace == AVCOL_SPC_BT470BG) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_SDTV;\n\n    }\n\n\n\n    if (avctx->color_trc == AVCOL_TRC_BT709) {\n\n        p_schro_params->format->transfer_function = SCHRO_TRANSFER_CHAR_TV_GAMMA;\n\n    }\n\n\n\n    if (ff_get_schro_frame_format(p_schro_params->format->chroma_format,\n\n                                  &p_schro_params->frame_format) == -1) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This codec currently supports only planar YUV 4:2:0, 4:2:2\"\n\n               \" and 4:4:4 formats.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p_schro_params->format->frame_rate_numerator   = avctx->time_base.den;\n\n    p_schro_params->format->frame_rate_denominator = avctx->time_base.num;\n\n\n\n    p_schro_params->frame_size = avpicture_get_size(avctx->pix_fmt,\n\n                                                    avctx->width,\n\n                                                    avctx->height);\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (!avctx->gop_size) {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"gop_structure\",\n\n                                         SCHRO_ENCODER_GOP_INTRA_ONLY);\n\n\n\n        if (avctx->coder_type == FF_CODER_TYPE_VLC)\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"enable_noarith\", 1);\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"au_distance\", avctx->gop_size);\n\n        avctx->has_b_frames = 1;\n\n        p_schro_params->dts = -1;\n\n    }\n\n\n\n    /* FIXME - Need to handle SCHRO_ENCODER_RATE_CONTROL_LOW_DELAY. */\n\n    if (avctx->flags & CODEC_FLAG_QSCALE) {\n\n        if (!avctx->global_quality) {\n\n            /* lossless coding */\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_LOSSLESS);\n\n        } else {\n\n            int quality;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_CONSTANT_QUALITY);\n\n\n\n            quality = avctx->global_quality / FF_QP2LAMBDA;\n\n            if (quality > 10)\n\n                quality = 10;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"quality\", quality);\n\n        }\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"rate_control\",\n\n                                         SCHRO_ENCODER_RATE_CONTROL_CONSTANT_BITRATE);\n\n\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"bitrate\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_INTERLACED_ME)\n\n        /* All material can be coded as interlaced or progressive\n\n           irrespective of the type of source material. */\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"interlaced_coding\", 1);\n\n\n\n    schro_encoder_setting_set_double(p_schro_params->encoder, \"open_gop\",\n\n                                     !(avctx->flags & CODEC_FLAG_CLOSED_GOP));\n\n\n\n    /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger\n\n     * and libdirac support other bit-depth data. */\n\n    schro_video_format_set_std_signal_range(p_schro_params->format,\n\n                                            SCHRO_SIGNAL_RANGE_8BIT_VIDEO);\n\n\n\n    /* Set the encoder format. */\n\n    schro_encoder_set_video_format(p_schro_params->encoder,\n\n                                   p_schro_params->format);\n\n\n\n    /* Set the debug level. */\n\n    schro_debug_set_level(avctx->debug);\n\n\n\n    schro_encoder_start(p_schro_params->encoder);\n\n\n\n    /* Initialize the encoded frame queue. */\n\n    ff_schro_queue_init(&p_schro_params->enc_frame_queue);\n\n    return 0;\n\n}\n", "idx": 27296, "substitutes": {"avctx": ["ovctx", "AVcam", "avcms", "aucca", "navcontext", "avcontext", "avcam", "afmc", "afcontext", "ovcontext", "avectx", "ajctx", "avmc", "ovcms", "ajcmp", "ajcmd", "Avtx", "avcn", "auconfig", "ajqa", "avemc", "abcmp", "afqa", "navcca", " avtx", "afcca", "AVcontext", "avalloc", "aucmp", "AVconfig", "avcca", "abcontext", "avqa", "AVloc", "ajscope", "avalcontext", "AVvoc", "avaltx", "afcn", "avconfig", "afctx", "avalctx", "avpkg", "avecms", "avloc", "abctx", "aveloc", "AVctx", "Avconfig", "avevoc", "AVcmp", "avecontext", "AVconn", "AVtx", "avcmp", "avtx", "avetx", "aucontext", "ajcam", "afcms", "navpkg", "auctx", "avvoc", "avalpkg", "AVpkg", "avconn", "ajpkg", "avscope", "avescope", "ajcontext", "aveqa", "ajloc", "AVcca", "Avctx", "navconn", "afcmd", "ovmc", "ajcn", "avecca", "avalcmd", "avalscope", "aveconfig", "avecn", "ajvoc", "afcam", "ajcms", "abconfig", "aveconn", "Avcontext", "navloc", " avcontext", "avcmd", " avconfig", "afscope", "navctx", "avalconfig", "afcmp", "afconfig"], "p_schro_params": ["p_schrojparams", "p_schrob_parser", "p_schrobams", "p_schro_manager", "p_schro__ams", "p_schrob_spec", "p_schroPams", "p_schrob_params", "p_schros_params", "p_schro_param", "p_schrotheparams", "p_schrob_reader", "p_schro__nas", "p_schrotheresources", "p_schla_params", "p_schro__master", "p_schro_reader", "p_schro_spec", "p_schrob_settings", "p_schro2param", "p_schrom_master", "p_schro2settings", "p_schro2manager", "p_schros_param", "p_schros_video", "p_schrojmanager", "p_schroPparams", "p_schro_members", "p_schrobparams", "p_schrobparam", "p_schroJreader", "p_schrob_private", "p_schrob_loss", "p_schro_ams", "p_schrojams", "p_schroPparam", "p_schro_model", "p_schro_settings", "p_schro_args", "p_schro_nas", "p_schroJparams", "p_schros_nas", "p_schla_ams", "p_schrojmodel", "p_schros_data", "p_schrob_ams", "p_schro_prefix", "p_schros_ams", "p_schroPvideo", "p_schrob_members", "p_schro__parser", "p_schro_video", "p_schrob_args", "p_schro_private", "p_schro_master", "p_schrom_params", "p_schrob_manager", "p_schroJresources", "p_schla_manager", "p_schrob_prefix", "p_schrotheprefix", "p_schro2params", "p_schroJprivate", "p_schrom_param", "p_schrothesettings", "p_schla_model", "p_schro__param", "p_schro__params", "p_schrobmanager", "p_schrob_resources", "p_schro_data", "p_schrom_nas", "p_schro_loss", "p_schro_resources", "p_schro_service", "p_schrob_param", "p_schrob_service", "p_schro_parser"], "preset": ["PRESET", "preteting", "frametting", " preseting", "framet", "presET", "pretette", " Presett", "PresET", "pretet", "PRESet", "Presett", "preseting", "Preset", " presetting", "presett", " Presets", "framET", " presett", "pretett", " presette", " Preset", "PRESat", "PRESeting", "framat", "PRESette", " presET", " PresET", "PRESetting", "presetting", "presat", "Presets", "presets", " presets", "PRESett", "presette", " presat"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311, "substitutes": {"system_memory": [" system_network", "module_memory", " system_storage", "system_connection", "system_storage", "module_connection", "module_image", "system_image", "system_media", " system_media", "module_network", "system_network"], "base": ["byte", "info", "b", "p", "bas", "server", "name", "c", "i", "unk", "ix", "buffer", "data", "bf", "gb", "address", "us", "ada", "prefix", "bro", "end", "u", "mx", "is", "e", "du", "ba", "work", "padding", "la", "bi", "Base", "ape", "scale", "weak", "au", "f", "fs", "ip", "net", "null", "be", "full", "root", "r", "core", "ace", "pc", "area"], "txirq": ["txiraqu", "rxpirk", "txpirq", "txidp", "txigrqu", "rxirqu", "tyirap", "rxirp", "txigrque", "tyirq", "tyirp", "txirk", "txigrk", "txirap", "rxpirqs", "txiraq", "txirtque", "txdrk", "txidqs", "txpirk", "txirqu", "txirtq", "txidque", "txdrque", "txpirqu", "txirce", "rxpirp", "txpirque", "rxpirq", "tyirqu", "tyiraqu", "txpirce", "txirp", "tyiraq", "txpirqs", "txdrq", "txidq", "txigrq", "txdrqu", "rxpirque", "tyirace", "rxpirqu", "rxirqs", "txirque", "txirtqs", "txirtp", "txirqs", "rxirque", "txirace", "txpirp", "tyirce", "rxirk"], "rxirq": ["rxrinqs", "rxirquest", "rxierq", "rxierw", "rhirquest", "rxdrqu", "rxirisquest", "rxirqu", "rxidque", "rpmirq", "rxirw", "rxirtc", "rxirtk", "rdirtq", "rxdrque", "rdirq", "rhdrqs", "rxirisqs", "rxirtq", "rdirw", "rdirque", "rdirtw", "rpmirk", "rxdrquest", "rpmirtk", "rxidqu", "rhirq", "rdirtque", "rxrinquest", "rxidq", "rdirtc", "rhirqa", "rhirqs", "rxdrqs", "rxirtqu", "rxdrq", "rdirc", "rhdrq", "rpmirtq", "rxidk", "rhdrquest", "rxierc", "rxrinq", "rxrinqa", "rxdrw", "rxierque", "rpmirtque", "rxirc", "rxdrk", "rhdrqa", "rxirqs", "rxdrc", "rxirisq", "rxirtw", "rxirqa", "rxirtque", "rxirque", "rxdrqa", "rxirisqa", "rpmirque", "rpmirqu", "rpmirtqu", "rxirk"], "dma": ["dme", "fmas", "xdmas", "ndmas", " dwa", "pma", " dmma", "ndpa", "ndma", "dtma", "dtmas", "dmas", "dwa", "xdme", " dga", "pme", "dhwa", "dhpa", "fmma", "xdga", "dmma", " dpa", "pga", "xdma", " dme", " dmas", "pmas", "dtga", "fma", "dtmma", "ndwa", "dhma", "dpa", "dga", "dhmas", "fga"], "clk": ["plks", "mlk", "plk", "plK", " clks", "mlks", "mlw", "mlK", "clks", "clw", " clw", " clK", "clK", "plw"], "s": ["sys", "w", "z", " args", "ns", "ts", "or", "sq", " parts", "ps", "secondary", "states", "sync", "self", " shares", "u", "es", "gs", "south", "stats", "sym", "f", "service", "fs", "js", "qs", "n", "t", "status", "ves", "r", " values", "S", "p", "m", "b", "c", "x", "ing", "ds", "su", "is", "sets", "ions", "spec", "new", " is", "services", "ows", "sl", "settings", "in", "its", "side", "g", "rs", "ses", "args", "ss", "d", " returns", "conf", "sg", "izes", "e", "session", "sb", "ches", "null", "ssl", "cs", "i", "ures", "site", "o", "si", "os", "ls", "y", "a", "v", "l"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[subblock_no];\n\n    int c_off = part_sizes_w[block_type];\n\n\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n\n    if(subblock_no == 3)\n\n        c_off = -1;\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n", "idx": 27317, "substitutes": {"r": ["ru", "rs", "k", "sr", "er", "w", "this", "b", "m", "p", "c", "d", "dr", "rf", "x", "rb", "br", "mr", "ra", "tr", "fr", "self", "rss", "nor", "e", "R", "rh", "err", "l", "re", "rc", "rg", "kr", "ar", "ur", "as", "h", "ir", "rt", "f", "pr", "n", "t", "v", "rr", "result", "hr", "g"], "block_type": [" block_pos", "blockworkkey", "block_name", "blockingtype", "block_pos", "blockworktype", "blockingname", "blockinglock", "blockingkey", " block_key", " block_name", " block_lock", "block_key", "blockworklock", " block_no", "block_no", "block_number", " block_number", "block_lock", "blockworkname"], "subblock_no": ["subblockIDno", "subblock2number", "subblock_po", "subBlock_nr", "subblock1pos", "subBlock_num", "subblock_No", "subblock1num", "subblock2po", "subblock2pos", "subblock2no", "subblock2No", "subblock_pos", "subBlock_number", "subblock_nu", "subblockIDpos", "subblock2num", "subblock_nos", "subblock_num", "subblock_code", "subBlock_code", "subBlock_No", "subblockIDbo", "subblock1nos", "subblock2nr", "subblock_bo", "subBlock_po", "subBlock_pos", "subblock1number", "subBlock_bo", "subBlock_nos", "subblock_nr", "subblockIDnu", "subblock1No", "subblock1nr", "subblock2nos", "subblock1no", "subBlock_no", "subblock_number", "subBlock_nu"], "dmv_no": ["dmf2from", "dmv2number", "dmvblockno", "dmf_nos", "dmvdno", "dmv_number", "dmvdfrom", "dmvdnos", "dmv2nos", "dmvblocknos", "dmv2from", "dmf2number", "dmv_from", "dmf_no", "dmf_from", "dmvblockfrom", "dmf2no", "dmvdnumber", "dmf_number", "dmv_nos", "dmf2nos", "dmv2no", "dmvblocknumber"], "s": ["sys", "w", "sy", "server", "ns", "ts", "sq", "sync", "self", "u", "es", "gs", "stats", "south", "share", "http", "lines", "sym", "current", "f", "service", "js", "n", "sim", "fs", "t", "native", "S", "er", "p", "m", "b", "c", "se", "x", "sports", "storage", "ds", "us", "su", "is", "spec", "one", "services", "h", "sl", "settings", "in", "g", "side", "rs", "ses", "ss", "d", "conf", "sg", "e", "session", "sb", "setup", "client", "sf", "ssl", "sc", "opt", "site", "o", "multi", "si", "os", "ls", "y", "a", "an", "v", "l"], "A": ["S", "None", "L", "An", "AF", "Va", "Ar", "AA", "Am", "P", "API", "T", "File", "H", "AT", "AW", "X", "AS", "AV", "U", "AC", "Alpha", "GA", "M", "LA", "D", "IA", "This", "AD", "Y", "SA", "Array", "G", "All", "mA", "AM", "NA", "N", "Ca", "I", "At", "CA", "W", "MA", "a", "V", "E", "AU", "And", "AB", "Ab", "AP", "AR", "As", "F"], "B": ["OB", "S", "L", "BA", "Q", "DB", "IB", "b", "K", "VB", "P", "T", "BR", "H", "Z", "BS", "SB", "X", "EB", "PB", "LB", "U", "TB", "R", "Block", "M", "Bs", "D", "BF", "Y", "WB", "NB", "Bar", "Base", "GB", "Both", "G", "N", "I", "BE", "AB", "W", "MB", "V", "QB", "E", "J", "AP", "BB", "O", "BG", "UB", "F"], "C": ["S", "L", "CE", "Q", "CL", "GC", "DC", "c", "Code", "CU", "CS", "P", "T", "KC", "Ch", "Cl", "X", "YC", "Cache", "U", "EC", "AC", "R", "M", "CC", "D", "Cu", "CW", "Y", "Config", "CNN", "CI", "CV", "G", "CT", "N", "CP", "CN", "MC", "CA", "W", "V", "E", "Cons", "VC", "Sc", "Con", "Ca", "O", "F"], "i": ["k", "z", "p", "m", "b", "c", "d", "x", "mi", "phi", "it", "e", "li", "ii", "si", "ai", "ci", "h", "I", "f", "y", "n", "ip", "index", "iu", "pi"], "j": ["k", "w", "z", "p", "b", "m", "kj", "x", "je", "jp", "aj", "em", "ji", "o", "l", "ii", "ij", "h", "y", "n", "mm", "q", "v", "J", "pos", "g"], "mx": ["cm", "nm", "ml", " mc", "m", "px", "me", "ms", "jp", "mi", "hh", "nz", "wx", "ma", "max", "cl", " m", "mn", "ij", " mm", "ga", "ng", "xp", "rx", "mm", "avier", "mu", "ap"], "my": ["md", "micro", "th", "nm", "My", "me", "Mi", "mmm", "ms", "am", "hh", "mid", "nz", "MY", "mos", "yo", "mic", "hz", "sym", "mis", "mn", "pm", "mo", "mon", "ng", "MM", "mm"]}}
